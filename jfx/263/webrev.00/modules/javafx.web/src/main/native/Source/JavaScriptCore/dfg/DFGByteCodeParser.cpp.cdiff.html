<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGBlockInsertionSet.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCFAPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2011-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,11 ***</span>
  
  #include &quot;ArithProfile.h&quot;
  #include &quot;ArrayConstructor.h&quot;
  #include &quot;BasicBlockLocation.h&quot;
  #include &quot;BuiltinNames.h&quot;
<span class="line-modified">! #include &quot;BytecodeStructs.h&quot;</span>
  #include &quot;CallLinkStatus.h&quot;
  #include &quot;CodeBlock.h&quot;
  #include &quot;CodeBlockWithJITType.h&quot;
  #include &quot;CommonSlowPaths.h&quot;
  #include &quot;DFGAbstractHeap.h&quot;
<span class="line-new-header">--- 30,13 ---</span>
  
  #include &quot;ArithProfile.h&quot;
  #include &quot;ArrayConstructor.h&quot;
  #include &quot;BasicBlockLocation.h&quot;
  #include &quot;BuiltinNames.h&quot;
<span class="line-modified">! #include &quot;BytecodeGenerator.h&quot;</span>
<span class="line-added">+ #include &quot;BytecodeUseDef.h&quot;</span>
<span class="line-added">+ #include &quot;CacheableIdentifierInlines.h&quot;</span>
  #include &quot;CallLinkStatus.h&quot;
  #include &quot;CodeBlock.h&quot;
  #include &quot;CodeBlockWithJITType.h&quot;
  #include &quot;CommonSlowPaths.h&quot;
  #include &quot;DFGAbstractHeap.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,19 ***</span>
  #include &quot;DFGClobberize.h&quot;
  #include &quot;DFGClobbersExitState.h&quot;
  #include &quot;DFGGraph.h&quot;
  #include &quot;DFGJITCode.h&quot;
  #include &quot;FunctionCodeBlock.h&quot;
<span class="line-modified">! #include &quot;GetByIdStatus.h&quot;</span>
  #include &quot;Heap.h&quot;
  #include &quot;InByIdStatus.h&quot;
  #include &quot;InstanceOfStatus.h&quot;
  #include &quot;JSCInlines.h&quot;
<span class="line-removed">- #include &quot;JSFixedArray.h&quot;</span>
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSModuleEnvironment.h&quot;
  #include &quot;JSModuleNamespaceObject.h&quot;
  #include &quot;NumberConstructor.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  #include &quot;OpcodeInlines.h&quot;
  #include &quot;PreciseJumpTargets.h&quot;
  #include &quot;PutByIdFlags.h&quot;
<span class="line-new-header">--- 46,23 ---</span>
  #include &quot;DFGClobberize.h&quot;
  #include &quot;DFGClobbersExitState.h&quot;
  #include &quot;DFGGraph.h&quot;
  #include &quot;DFGJITCode.h&quot;
  #include &quot;FunctionCodeBlock.h&quot;
<span class="line-modified">! #include &quot;GetByStatus.h&quot;</span>
<span class="line-added">+ #include &quot;GetterSetter.h&quot;</span>
  #include &quot;Heap.h&quot;
  #include &quot;InByIdStatus.h&quot;
  #include &quot;InstanceOfStatus.h&quot;
<span class="line-added">+ #include &quot;JSArrayIterator.h&quot;</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
<span class="line-added">+ #include &quot;JSInternalPromise.h&quot;</span>
<span class="line-added">+ #include &quot;JSInternalPromiseConstructor.h&quot;</span>
  #include &quot;JSModuleEnvironment.h&quot;
  #include &quot;JSModuleNamespaceObject.h&quot;
<span class="line-added">+ #include &quot;JSPromiseConstructor.h&quot;</span>
  #include &quot;NumberConstructor.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  #include &quot;OpcodeInlines.h&quot;
  #include &quot;PreciseJumpTargets.h&quot;
  #include &quot;PutByIdFlags.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,20 ***</span>
  #include &quot;SymbolConstructor.h&quot;
  #include &quot;Watchdog.h&quot;
  #include &lt;wtf/CommaPrinter.h&gt;
  #include &lt;wtf/HashMap.h&gt;
  #include &lt;wtf/MathExtras.h&gt;
  #include &lt;wtf/SetForScope.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  
  namespace JSC { namespace DFG {
  
  namespace DFGByteCodeParserInternal {
  #ifdef NDEBUG
<span class="line-modified">! static const bool verbose = false;</span>
  #else
<span class="line-modified">! static const bool verbose = true;</span>
  #endif
  } // namespace DFGByteCodeParserInternal
  
  #define VERBOSE_LOG(...) do { \
  if (DFGByteCodeParserInternal::verbose &amp;&amp; Options::verboseDFGBytecodeParsing()) \
<span class="line-new-header">--- 74,21 ---</span>
  #include &quot;SymbolConstructor.h&quot;
  #include &quot;Watchdog.h&quot;
  #include &lt;wtf/CommaPrinter.h&gt;
  #include &lt;wtf/HashMap.h&gt;
  #include &lt;wtf/MathExtras.h&gt;
<span class="line-added">+ #include &lt;wtf/Scope.h&gt;</span>
  #include &lt;wtf/SetForScope.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  
  namespace JSC { namespace DFG {
  
  namespace DFGByteCodeParserInternal {
  #ifdef NDEBUG
<span class="line-modified">! static constexpr bool verbose = false;</span>
  #else
<span class="line-modified">! static constexpr bool verbose = true;</span>
  #endif
  } // namespace DFGByteCodeParserInternal
  
  #define VERBOSE_LOG(...) do { \
  if (DFGByteCodeParserInternal::verbose &amp;&amp; Options::verboseDFGBytecodeParsing()) \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,10 ***</span>
<span class="line-new-header">--- 111,11 ---</span>
          , m_constantNull(graph.freeze(jsNull()))
          , m_constantNaN(graph.freeze(jsNumber(PNaN)))
          , m_constantOne(graph.freeze(jsNumber(1)))
          , m_numArguments(m_codeBlock-&gt;numParameters())
          , m_numLocals(m_codeBlock-&gt;numCalleeLocals())
<span class="line-added">+         , m_numTmps(m_codeBlock-&gt;numTmps())</span>
          , m_parameterSlots(0)
          , m_numPassedVarArgs(0)
          , m_inlineStackTop(0)
          , m_currentInstruction(0)
          , m_hasDebuggerEnabled(graph.hasDebuggerEnabled())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,24 ***</span>
          m_numLocals = newNumLocals;
          for (size_t i = 0; i &lt; m_graph.numBlocks(); ++i)
              m_graph.block(i)-&gt;ensureLocals(newNumLocals);
      }
  
      // Helper for min and max.
      template&lt;typename ChecksFunctor&gt;
      bool handleMinMax(VirtualRegister result, NodeType op, int registerOffset, int argumentCountIncludingThis, const ChecksFunctor&amp; insertChecks);
  
      void refineStatically(CallLinkStatus&amp;, Node* callTarget);
      // Blocks can either be targetable (i.e. in the m_blockLinkingTargets of one InlineStackEntry) with a well-defined bytecodeBegin,
      // or they can be untargetable, with bytecodeBegin==UINT_MAX, to be managed manually and not by the linkBlock machinery.
      // This is used most notably when doing polyvariant inlining (it requires a fair bit of control-flow with no bytecode analog).
      // It is also used when doing an early return from an inlined callee: it is easier to fix the bytecode index later on if needed
      // than to move the right index all the way to the treatment of op_ret.
<span class="line-modified">!     BasicBlock* allocateTargetableBlock(unsigned bytecodeIndex);</span>
      BasicBlock* allocateUntargetableBlock();
      // An untargetable block can be given a bytecodeIndex to be later managed by linkBlock, but only once, and it can never go in the other direction
<span class="line-modified">!     void makeBlockTargetable(BasicBlock*, unsigned bytecodeIndex);</span>
      void addJumpTo(BasicBlock*);
      void addJumpTo(unsigned bytecodeIndex);
      // Handle calls. This resolves issues surrounding inlining and intrinsics.
      enum Terminality { Terminal, NonTerminal };
      Terminality handleCall(
<span class="line-new-header">--- 140,35 ---</span>
          m_numLocals = newNumLocals;
          for (size_t i = 0; i &lt; m_graph.numBlocks(); ++i)
              m_graph.block(i)-&gt;ensureLocals(newNumLocals);
      }
  
<span class="line-added">+     void ensureTmps(unsigned newNumTmps)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         VERBOSE_LOG(&quot;   ensureTmps: trying to raise m_numTmps from &quot;, m_numTmps, &quot; to &quot;, newNumTmps, &quot;\n&quot;);</span>
<span class="line-added">+         if (newNumTmps &lt;= m_numTmps)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         m_numTmps = newNumTmps;</span>
<span class="line-added">+         for (size_t i = 0; i &lt; m_graph.numBlocks(); ++i)</span>
<span class="line-added">+             m_graph.block(i)-&gt;ensureTmps(newNumTmps);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
      // Helper for min and max.
      template&lt;typename ChecksFunctor&gt;
      bool handleMinMax(VirtualRegister result, NodeType op, int registerOffset, int argumentCountIncludingThis, const ChecksFunctor&amp; insertChecks);
  
      void refineStatically(CallLinkStatus&amp;, Node* callTarget);
      // Blocks can either be targetable (i.e. in the m_blockLinkingTargets of one InlineStackEntry) with a well-defined bytecodeBegin,
      // or they can be untargetable, with bytecodeBegin==UINT_MAX, to be managed manually and not by the linkBlock machinery.
      // This is used most notably when doing polyvariant inlining (it requires a fair bit of control-flow with no bytecode analog).
      // It is also used when doing an early return from an inlined callee: it is easier to fix the bytecode index later on if needed
      // than to move the right index all the way to the treatment of op_ret.
<span class="line-modified">!     BasicBlock* allocateTargetableBlock(BytecodeIndex);</span>
      BasicBlock* allocateUntargetableBlock();
      // An untargetable block can be given a bytecodeIndex to be later managed by linkBlock, but only once, and it can never go in the other direction
<span class="line-modified">!     void makeBlockTargetable(BasicBlock*, BytecodeIndex);</span>
      void addJumpTo(BasicBlock*);
      void addJumpTo(unsigned bytecodeIndex);
      // Handle calls. This resolves issues surrounding inlining and intrinsics.
      enum Terminality { Terminal, NonTerminal };
      Terminality handleCall(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,12 ***</span>
      unsigned inliningCost(CallVariant, int argumentCountIncludingThis, InlineCallFrame::Kind); // Return UINT_MAX if it&#39;s not an inlining candidate. By convention, intrinsics have a cost of 1.
      // Handle inlining. Return true if it succeeded, false if we need to plant a call.
      bool handleVarargsInlining(Node* callTargetNode, VirtualRegister result, const CallLinkStatus&amp;, int registerOffset, VirtualRegister thisArgument, VirtualRegister argumentsArgument, unsigned argumentsOffset, NodeType callOp, InlineCallFrame::Kind);
      unsigned getInliningBalance(const CallLinkStatus&amp;, CodeSpecializationKind);
      enum class CallOptimizationResult { OptimizedToJump, Inlined, DidNothing };
<span class="line-modified">!     CallOptimizationResult handleCallVariant(Node* callTargetNode, VirtualRegister result, CallVariant, int registerOffset, VirtualRegister thisArgument, int argumentCountIncludingThis, unsigned nextOffset, InlineCallFrame::Kind, SpeculatedType prediction, unsigned&amp; inliningBalance, BasicBlock* continuationBlock, bool needsToCheckCallee);</span>
<span class="line-modified">!     CallOptimizationResult handleInlining(Node* callTargetNode, VirtualRegister result, const CallLinkStatus&amp;, int registerOffset, VirtualRegister thisArgument, int argumentCountIncludingThis, unsigned nextOffset, NodeType callOp, InlineCallFrame::Kind, SpeculatedType prediction);</span>
      template&lt;typename ChecksFunctor&gt;
      void inlineCall(Node* callTargetNode, VirtualRegister result, CallVariant, int registerOffset, int argumentCountIncludingThis, InlineCallFrame::Kind, BasicBlock* continuationBlock, const ChecksFunctor&amp; insertChecks);
      // Handle intrinsic functions. Return true if it succeeded, false if we need to plant a call.
      template&lt;typename ChecksFunctor&gt;
      bool handleIntrinsicCall(Node* callee, VirtualRegister result, Intrinsic, int registerOffset, int argumentCountIncludingThis, SpeculatedType prediction, const ChecksFunctor&amp; insertChecks);
<span class="line-new-header">--- 187,12 ---</span>
      unsigned inliningCost(CallVariant, int argumentCountIncludingThis, InlineCallFrame::Kind); // Return UINT_MAX if it&#39;s not an inlining candidate. By convention, intrinsics have a cost of 1.
      // Handle inlining. Return true if it succeeded, false if we need to plant a call.
      bool handleVarargsInlining(Node* callTargetNode, VirtualRegister result, const CallLinkStatus&amp;, int registerOffset, VirtualRegister thisArgument, VirtualRegister argumentsArgument, unsigned argumentsOffset, NodeType callOp, InlineCallFrame::Kind);
      unsigned getInliningBalance(const CallLinkStatus&amp;, CodeSpecializationKind);
      enum class CallOptimizationResult { OptimizedToJump, Inlined, DidNothing };
<span class="line-modified">!     CallOptimizationResult handleCallVariant(Node* callTargetNode, VirtualRegister result, CallVariant, int registerOffset, VirtualRegister thisArgument, int argumentCountIncludingThis, BytecodeIndex nextIndex, InlineCallFrame::Kind, SpeculatedType prediction, unsigned&amp; inliningBalance, BasicBlock* continuationBlock, bool needsToCheckCallee);</span>
<span class="line-modified">!     CallOptimizationResult handleInlining(Node* callTargetNode, VirtualRegister result, const CallLinkStatus&amp;, int registerOffset, VirtualRegister thisArgument, int argumentCountIncludingThis, BytecodeIndex nextIndex, NodeType callOp, InlineCallFrame::Kind, SpeculatedType prediction);</span>
      template&lt;typename ChecksFunctor&gt;
      void inlineCall(Node* callTargetNode, VirtualRegister result, CallVariant, int registerOffset, int argumentCountIncludingThis, InlineCallFrame::Kind, BasicBlock* continuationBlock, const ChecksFunctor&amp; insertChecks);
      // Handle intrinsic functions. Return true if it succeeded, false if we need to plant a call.
      template&lt;typename ChecksFunctor&gt;
      bool handleIntrinsicCall(Node* callee, VirtualRegister result, Intrinsic, int registerOffset, int argumentCountIncludingThis, SpeculatedType prediction, const ChecksFunctor&amp; insertChecks);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 186,11 ***</span>
      template&lt;typename ChecksFunctor&gt;
      bool handleConstantInternalFunction(Node* callTargetNode, VirtualRegister result, InternalFunction*, int registerOffset, int argumentCountIncludingThis, CodeSpecializationKind, SpeculatedType, const ChecksFunctor&amp; insertChecks);
      Node* handlePutByOffset(Node* base, unsigned identifier, PropertyOffset, Node* value);
      Node* handleGetByOffset(SpeculatedType, Node* base, unsigned identifierNumber, PropertyOffset, NodeType = GetByOffset);
      bool handleDOMJITGetter(VirtualRegister result, const GetByIdVariant&amp;, Node* thisNode, unsigned identifierNumber, SpeculatedType prediction);
<span class="line-modified">!     bool handleModuleNamespaceLoad(VirtualRegister result, SpeculatedType, Node* base, GetByIdStatus);</span>
  
      template&lt;typename Bytecode&gt;
      void handlePutByVal(Bytecode, unsigned instructionSize);
      template &lt;typename Bytecode&gt;
      void handlePutAccessorById(NodeType, Bytecode);
<span class="line-new-header">--- 205,11 ---</span>
      template&lt;typename ChecksFunctor&gt;
      bool handleConstantInternalFunction(Node* callTargetNode, VirtualRegister result, InternalFunction*, int registerOffset, int argumentCountIncludingThis, CodeSpecializationKind, SpeculatedType, const ChecksFunctor&amp; insertChecks);
      Node* handlePutByOffset(Node* base, unsigned identifier, PropertyOffset, Node* value);
      Node* handleGetByOffset(SpeculatedType, Node* base, unsigned identifierNumber, PropertyOffset, NodeType = GetByOffset);
      bool handleDOMJITGetter(VirtualRegister result, const GetByIdVariant&amp;, Node* thisNode, unsigned identifierNumber, SpeculatedType prediction);
<span class="line-modified">!     bool handleModuleNamespaceLoad(VirtualRegister result, SpeculatedType, Node* base, GetByStatus);</span>
  
      template&lt;typename Bytecode&gt;
      void handlePutByVal(Bytecode, unsigned instructionSize);
      template &lt;typename Bytecode&gt;
      void handlePutAccessorById(NodeType, Bytecode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,10 ***</span>
<span class="line-new-header">--- 217,12 ---</span>
      void handlePutAccessorByVal(NodeType, Bytecode);
      template &lt;typename Bytecode&gt;
      void handleNewFunc(NodeType, Bytecode);
      template &lt;typename Bytecode&gt;
      void handleNewFuncExp(NodeType, Bytecode);
<span class="line-added">+     template &lt;typename Bytecode&gt;</span>
<span class="line-added">+     void handleCreateInternalFieldObject(const ClassInfo*, NodeType createOp, NodeType newOp, Bytecode);</span>
  
      // Create a presence ObjectPropertyCondition based on some known offset and structure set. Does not
      // check the validity of the condition, but it may return a null one if it encounters a contradiction.
      ObjectPropertyCondition presenceLike(
          JSObject* knownBase, UniquedStringImpl*, PropertyOffset, const StructureSet&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 219,11 ***</span>
      Node* store(Node* base, unsigned identifier, const PutByIdVariant&amp;, Node* value);
  
      template&lt;typename Op&gt;
      void parseGetById(const Instruction*);
      void handleGetById(
<span class="line-modified">!         VirtualRegister destination, SpeculatedType, Node* base, unsigned identifierNumber, GetByIdStatus, AccessType, unsigned instructionSize);</span>
      void emitPutById(
          Node* base, unsigned identifierNumber, Node* value,  const PutByIdStatus&amp;, bool isDirect);
      void handlePutById(
          Node* base, unsigned identifierNumber, Node* value, const PutByIdStatus&amp;,
          bool isDirect, unsigned intructionSize);
<span class="line-new-header">--- 240,11 ---</span>
      Node* store(Node* base, unsigned identifier, const PutByIdVariant&amp;, Node* value);
  
      template&lt;typename Op&gt;
      void parseGetById(const Instruction*);
      void handleGetById(
<span class="line-modified">!         VirtualRegister destination, SpeculatedType, Node* base, unsigned identifierNumber, GetByStatus, AccessType, unsigned instructionSize);</span>
      void emitPutById(
          Node* base, unsigned identifierNumber, Node* value,  const PutByIdStatus&amp;, bool isDirect);
      void handlePutById(
          Node* base, unsigned identifierNumber, Node* value, const PutByIdStatus&amp;,
          bool isDirect, unsigned intructionSize);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,40 ***</span>
      void parseBlock(unsigned limit);
      // Link block successors.
      void linkBlock(BasicBlock*, Vector&lt;BasicBlock*&gt;&amp; possibleTargets);
      void linkBlocks(Vector&lt;BasicBlock*&gt;&amp; unlinkedBlocks, Vector&lt;BasicBlock*&gt;&amp; possibleTargets);
  
<span class="line-modified">!     VariableAccessData* newVariableAccessData(VirtualRegister operand)</span>
      {
          ASSERT(!operand.isConstant());
  
          m_graph.m_variableAccessData.append(operand);
          return &amp;m_graph.m_variableAccessData.last();
      }
  
      // Get/Set the operands/result of a bytecode instruction.
<span class="line-modified">!     Node* getDirect(VirtualRegister operand)</span>
      {
          ASSERT(!operand.isConstant());
  
<span class="line-removed">-         // Is this an argument?</span>
          if (operand.isArgument())
<span class="line-modified">!             return getArgument(operand);</span>
  
<span class="line-modified">!         // Must be a local.</span>
<span class="line-removed">-         return getLocal(operand);</span>
      }
  
      Node* get(VirtualRegister operand)
      {
          if (operand.isConstant()) {
              unsigned constantIndex = operand.toConstantIndex();
              unsigned oldSize = m_constants.size();
              if (constantIndex &gt;= oldSize || !m_constants[constantIndex]) {
                  const CodeBlock&amp; codeBlock = *m_inlineStackTop-&gt;m_codeBlock;
<span class="line-modified">!                 JSValue value = codeBlock.getConstant(operand.offset());</span>
<span class="line-modified">!                 SourceCodeRepresentation sourceCodeRepresentation = codeBlock.constantSourceCodeRepresentation(operand.offset());</span>
                  if (constantIndex &gt;= oldSize) {
                      m_constants.grow(constantIndex + 1);
                      for (unsigned i = oldSize; i &lt; m_constants.size(); ++i)
                          m_constants[i] = nullptr;
                  }
<span class="line-new-header">--- 282,48 ---</span>
      void parseBlock(unsigned limit);
      // Link block successors.
      void linkBlock(BasicBlock*, Vector&lt;BasicBlock*&gt;&amp; possibleTargets);
      void linkBlocks(Vector&lt;BasicBlock*&gt;&amp; unlinkedBlocks, Vector&lt;BasicBlock*&gt;&amp; possibleTargets);
  
<span class="line-modified">!     void progressToNextCheckpoint()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         m_currentIndex = BytecodeIndex(m_currentIndex.offset(), m_currentIndex.checkpoint() + 1);</span>
<span class="line-added">+         // At this point, it&#39;s again OK to OSR exit.</span>
<span class="line-added">+         m_exitOK = true;</span>
<span class="line-added">+         addToGraph(ExitOK);</span>
<span class="line-added">+ </span>
<span class="line-added">+         processSetLocalQueue();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     VariableAccessData* newVariableAccessData(Operand operand)</span>
      {
          ASSERT(!operand.isConstant());
  
          m_graph.m_variableAccessData.append(operand);
          return &amp;m_graph.m_variableAccessData.last();
      }
  
      // Get/Set the operands/result of a bytecode instruction.
<span class="line-modified">!     Node* getDirect(Operand operand)</span>
      {
          ASSERT(!operand.isConstant());
  
          if (operand.isArgument())
<span class="line-modified">!             return getArgument(operand.virtualRegister());</span>
  
<span class="line-modified">!         return getLocalOrTmp(operand);</span>
      }
  
      Node* get(VirtualRegister operand)
      {
          if (operand.isConstant()) {
              unsigned constantIndex = operand.toConstantIndex();
              unsigned oldSize = m_constants.size();
              if (constantIndex &gt;= oldSize || !m_constants[constantIndex]) {
                  const CodeBlock&amp; codeBlock = *m_inlineStackTop-&gt;m_codeBlock;
<span class="line-modified">!                 JSValue value = codeBlock.getConstant(operand);</span>
<span class="line-modified">!                 SourceCodeRepresentation sourceCodeRepresentation = codeBlock.constantSourceCodeRepresentation(operand);</span>
                  if (constantIndex &gt;= oldSize) {
                      m_constants.grow(constantIndex + 1);
                      for (unsigned i = oldSize; i &lt; m_constants.size(); ++i)
                          m_constants[i] = nullptr;
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,13 ***</span>
          // A set where the SetLocal happens immediately and we do not Flush it even if
          // this is a local that is marked as needing it. This is relevant when
          // initializing locals at the top of a function.
          ImmediateNakedSet
      };
<span class="line-modified">!     Node* setDirect(VirtualRegister operand, Node* value, SetMode setMode = NormalSet)</span>
      {
<span class="line-modified">!         addToGraph(MovHint, OpInfo(operand.offset()), value);</span>
  
          // We can&#39;t exit anymore because our OSR exit state has changed.
          m_exitOK = false;
  
          DelayedSetLocal delayed(currentCodeOrigin(), operand, value, setMode);
<span class="line-new-header">--- 378,14 ---</span>
          // A set where the SetLocal happens immediately and we do not Flush it even if
          // this is a local that is marked as needing it. This is relevant when
          // initializing locals at the top of a function.
          ImmediateNakedSet
      };
<span class="line-modified">! </span>
<span class="line-added">+     Node* setDirect(Operand operand, Node* value, SetMode setMode = NormalSet)</span>
      {
<span class="line-modified">!         addToGraph(MovHint, OpInfo(operand), value);</span>
  
          // We can&#39;t exit anymore because our OSR exit state has changed.
          m_exitOK = false;
  
          DelayedSetLocal delayed(currentCodeOrigin(), operand, value, setMode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 383,22 ***</span>
      Node* injectLazyOperandSpeculation(Node* node)
      {
          ASSERT(node-&gt;op() == GetLocal);
          ASSERT(node-&gt;origin.semantic.bytecodeIndex() == m_currentIndex);
          ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);
<span class="line-modified">!         LazyOperandValueProfileKey key(m_currentIndex, node-&gt;local());</span>
          SpeculatedType prediction = m_inlineStackTop-&gt;m_lazyOperands.prediction(locker, key);
          node-&gt;variableAccessData()-&gt;predict(prediction);
          return node;
      }
  
      // Used in implementing get/set, above, where the operand is a local variable.
<span class="line-modified">!     Node* getLocal(VirtualRegister operand)</span>
      {
<span class="line-modified">!         unsigned local = operand.toLocal();</span>
<span class="line-modified">! </span>
<span class="line-removed">-         Node* node = m_currentBlock-&gt;variablesAtTail.local(local);</span>
  
          // This has two goals: 1) link together variable access datas, and 2)
          // try to avoid creating redundant GetLocals. (1) is required for
          // correctness - no other phase will ensure that block-local variable
          // access data unification is done correctly. (2) is purely opportunistic
<span class="line-new-header">--- 413,21 ---</span>
      Node* injectLazyOperandSpeculation(Node* node)
      {
          ASSERT(node-&gt;op() == GetLocal);
          ASSERT(node-&gt;origin.semantic.bytecodeIndex() == m_currentIndex);
          ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);
<span class="line-modified">!         LazyOperandValueProfileKey key(m_currentIndex, node-&gt;operand());</span>
          SpeculatedType prediction = m_inlineStackTop-&gt;m_lazyOperands.prediction(locker, key);
          node-&gt;variableAccessData()-&gt;predict(prediction);
          return node;
      }
  
      // Used in implementing get/set, above, where the operand is a local variable.
<span class="line-modified">!     Node* getLocalOrTmp(Operand operand)</span>
      {
<span class="line-modified">!         ASSERT(operand.isTmp() || operand.isLocal());</span>
<span class="line-modified">!         Node*&amp; node = m_currentBlock-&gt;variablesAtTail.operand(operand);</span>
  
          // This has two goals: 1) link together variable access datas, and 2)
          // try to avoid creating redundant GetLocals. (1) is required for
          // correctness - no other phase will ensure that block-local variable
          // access data unification is done correctly. (2) is purely opportunistic
</pre>
<hr />
<pre>
<span class="line-old-header">*** 419,34 ***</span>
              }
          } else
              variable = newVariableAccessData(operand);
  
          node = injectLazyOperandSpeculation(addToGraph(GetLocal, OpInfo(variable)));
<span class="line-removed">-         m_currentBlock-&gt;variablesAtTail.local(local) = node;</span>
          return node;
      }
<span class="line-modified">!     Node* setLocal(const CodeOrigin&amp; semanticOrigin, VirtualRegister operand, Node* value, SetMode setMode = NormalSet)</span>
      {
          SetForScope&lt;CodeOrigin&gt; originChange(m_currentSemanticOrigin, semanticOrigin);
  
<span class="line-modified">!         unsigned local = operand.toLocal();</span>
  
<span class="line-modified">!         if (setMode != ImmediateNakedSet) {</span>
<span class="line-modified">!             ArgumentPosition* argumentPosition = findArgumentPositionForLocal(operand);</span>
              if (argumentPosition)
                  flushDirect(operand, argumentPosition);
<span class="line-modified">!             else if (m_graph.needsScopeRegister() &amp;&amp; operand == m_codeBlock-&gt;scopeRegister())</span>
                  flush(operand);
          }
  
          VariableAccessData* variableAccessData = newVariableAccessData(operand);
          variableAccessData-&gt;mergeStructureCheckHoistingFailed(
              m_inlineStackTop-&gt;m_exitProfile.hasExitSite(semanticOrigin.bytecodeIndex(), BadCache));
          variableAccessData-&gt;mergeCheckArrayHoistingFailed(
              m_inlineStackTop-&gt;m_exitProfile.hasExitSite(semanticOrigin.bytecodeIndex(), BadIndexingType));
          Node* node = addToGraph(SetLocal, OpInfo(variableAccessData), value);
<span class="line-modified">!         m_currentBlock-&gt;variablesAtTail.local(local) = node;</span>
          return node;
      }
  
      // Used in implementing get/set, above, where the operand is an argument.
      Node* getArgument(VirtualRegister operand)
<span class="line-new-header">--- 448,40 ---</span>
              }
          } else
              variable = newVariableAccessData(operand);
  
          node = injectLazyOperandSpeculation(addToGraph(GetLocal, OpInfo(variable)));
          return node;
      }
<span class="line-modified">!     Node* setLocalOrTmp(const CodeOrigin&amp; semanticOrigin, Operand operand, Node* value, SetMode setMode = NormalSet)</span>
      {
<span class="line-added">+         ASSERT(operand.isTmp() || operand.isLocal());</span>
          SetForScope&lt;CodeOrigin&gt; originChange(m_currentSemanticOrigin, semanticOrigin);
  
<span class="line-modified">!         if (operand.isTmp() &amp;&amp; static_cast&lt;unsigned&gt;(operand.value()) &gt;= m_numTmps) {</span>
<span class="line-added">+             if (inlineCallFrame())</span>
<span class="line-added">+                 dataLogLn(*inlineCallFrame());</span>
<span class="line-added">+             dataLogLn(&quot;Bad operand: &quot;, operand, &quot; but current number of tmps is: &quot;, m_numTmps, &quot; code block has: &quot;, m_profiledBlock-&gt;numTmps(), &quot; tmps.&quot;);</span>
<span class="line-added">+             CRASH();</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         if (setMode != ImmediateNakedSet &amp;&amp; !operand.isTmp()) {</span>
<span class="line-modified">!             VirtualRegister reg = operand.virtualRegister();</span>
<span class="line-added">+             ArgumentPosition* argumentPosition = findArgumentPositionForLocal(reg);</span>
              if (argumentPosition)
                  flushDirect(operand, argumentPosition);
<span class="line-modified">!             else if (m_graph.needsScopeRegister() &amp;&amp; reg == m_codeBlock-&gt;scopeRegister())</span>
                  flush(operand);
          }
  
          VariableAccessData* variableAccessData = newVariableAccessData(operand);
          variableAccessData-&gt;mergeStructureCheckHoistingFailed(
              m_inlineStackTop-&gt;m_exitProfile.hasExitSite(semanticOrigin.bytecodeIndex(), BadCache));
          variableAccessData-&gt;mergeCheckArrayHoistingFailed(
              m_inlineStackTop-&gt;m_exitProfile.hasExitSite(semanticOrigin.bytecodeIndex(), BadIndexingType));
          Node* node = addToGraph(SetLocal, OpInfo(variableAccessData), value);
<span class="line-modified">!         m_currentBlock-&gt;variablesAtTail.operand(operand) = node;</span>
          return node;
      }
  
      // Used in implementing get/set, above, where the operand is an argument.
      Node* getArgument(VirtualRegister operand)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,24 ***</span>
  
          node = injectLazyOperandSpeculation(addToGraph(GetLocal, OpInfo(variable)));
          m_currentBlock-&gt;variablesAtTail.argument(argument) = node;
          return node;
      }
<span class="line-modified">!     Node* setArgument(const CodeOrigin&amp; semanticOrigin, VirtualRegister operand, Node* value, SetMode setMode = NormalSet)</span>
      {
          SetForScope&lt;CodeOrigin&gt; originChange(m_currentSemanticOrigin, semanticOrigin);
  
<span class="line-modified">!         unsigned argument = operand.toArgument();</span>
          ASSERT(argument &lt; m_numArguments);
  
<span class="line-modified">!         VariableAccessData* variableAccessData = newVariableAccessData(operand);</span>
  
          // Always flush arguments, except for &#39;this&#39;. If &#39;this&#39; is created by us,
          // then make sure that it&#39;s never unboxed.
          if (argument || m_graph.needsFlushedThis()) {
              if (setMode != ImmediateNakedSet)
<span class="line-modified">!                 flushDirect(operand);</span>
          }
  
          if (!argument &amp;&amp; m_codeBlock-&gt;specializationKind() == CodeForConstruct)
              variableAccessData-&gt;mergeShouldNeverUnbox(true);
  
<span class="line-new-header">--- 509,25 ---</span>
  
          node = injectLazyOperandSpeculation(addToGraph(GetLocal, OpInfo(variable)));
          m_currentBlock-&gt;variablesAtTail.argument(argument) = node;
          return node;
      }
<span class="line-modified">!     Node* setArgument(const CodeOrigin&amp; semanticOrigin, Operand operand, Node* value, SetMode setMode = NormalSet)</span>
      {
          SetForScope&lt;CodeOrigin&gt; originChange(m_currentSemanticOrigin, semanticOrigin);
  
<span class="line-modified">!         VirtualRegister reg = operand.virtualRegister();</span>
<span class="line-added">+         unsigned argument = reg.toArgument();</span>
          ASSERT(argument &lt; m_numArguments);
  
<span class="line-modified">!         VariableAccessData* variableAccessData = newVariableAccessData(reg);</span>
  
          // Always flush arguments, except for &#39;this&#39;. If &#39;this&#39; is created by us,
          // then make sure that it&#39;s never unboxed.
          if (argument || m_graph.needsFlushedThis()) {
              if (setMode != ImmediateNakedSet)
<span class="line-modified">!                 flushDirect(reg);</span>
          }
  
          if (!argument &amp;&amp; m_codeBlock-&gt;specializationKind() == CodeForConstruct)
              variableAccessData-&gt;mergeShouldNeverUnbox(true);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 523,126 ***</span>
              if (operand.offset() &gt;= static_cast&lt;int&gt;(inlineCallFrame-&gt;stackOffset + CallFrame::thisArgumentOffset() + inlineCallFrame-&gt;argumentsWithFixup.size()))
                  continue;
              int argument = VirtualRegister(operand.offset() - inlineCallFrame-&gt;stackOffset).toArgument();
              return stack-&gt;m_argumentPositions[argument];
          }
<span class="line-modified">!         return 0;</span>
      }
  
<span class="line-modified">!     ArgumentPosition* findArgumentPosition(VirtualRegister operand)</span>
      {
          if (operand.isArgument())
              return findArgumentPositionForArgument(operand.toArgument());
<span class="line-modified">!         return findArgumentPositionForLocal(operand);</span>
      }
  
      template&lt;typename AddFlushDirectFunc&gt;
      void flushImpl(InlineCallFrame* inlineCallFrame, const AddFlushDirectFunc&amp; addFlushDirect)
      {
          int numArguments;
          if (inlineCallFrame) {
              ASSERT(!m_graph.hasDebuggerEnabled());
              numArguments = inlineCallFrame-&gt;argumentsWithFixup.size();
              if (inlineCallFrame-&gt;isClosureCall)
<span class="line-modified">!                 addFlushDirect(inlineCallFrame, remapOperand(inlineCallFrame, VirtualRegister(CallFrameSlot::callee)));</span>
              if (inlineCallFrame-&gt;isVarargs())
<span class="line-modified">!                 addFlushDirect(inlineCallFrame, remapOperand(inlineCallFrame, VirtualRegister(CallFrameSlot::argumentCount)));</span>
          } else
              numArguments = m_graph.baselineCodeBlockFor(inlineCallFrame)-&gt;numParameters();
  
          for (unsigned argument = numArguments; argument--;)
<span class="line-modified">!             addFlushDirect(inlineCallFrame, remapOperand(inlineCallFrame, virtualRegisterForArgument(argument)));</span>
  
          if (m_graph.needsScopeRegister())
              addFlushDirect(nullptr, m_graph.m_codeBlock-&gt;scopeRegister());
      }
  
      template&lt;typename AddFlushDirectFunc, typename AddPhantomLocalDirectFunc&gt;
      void flushForTerminalImpl(CodeOrigin origin, const AddFlushDirectFunc&amp; addFlushDirect, const AddPhantomLocalDirectFunc&amp; addPhantomLocalDirect)
      {
          origin.walkUpInlineStack(
              [&amp;] (CodeOrigin origin) {
<span class="line-modified">!                 unsigned bytecodeIndex = origin.bytecodeIndex();</span>
                  InlineCallFrame* inlineCallFrame = origin.inlineCallFrame();
                  flushImpl(inlineCallFrame, addFlushDirect);
  
                  CodeBlock* codeBlock = m_graph.baselineCodeBlockFor(inlineCallFrame);
                  FullBytecodeLiveness&amp; fullLiveness = m_graph.livenessFor(codeBlock);
<span class="line-modified">!                 const FastBitVector&amp; livenessAtBytecode = fullLiveness.getLiveness(bytecodeIndex);</span>
<span class="line-modified">! </span>
                  for (unsigned local = codeBlock-&gt;numCalleeLocals(); local--;) {
                      if (livenessAtBytecode[local])
                          addPhantomLocalDirect(inlineCallFrame, remapOperand(inlineCallFrame, virtualRegisterForLocal(local)));
                  }
              });
      }
  
<span class="line-modified">!     void flush(VirtualRegister operand)</span>
      {
          flushDirect(m_inlineStackTop-&gt;remapOperand(operand));
      }
  
<span class="line-modified">!     void flushDirect(VirtualRegister operand)</span>
      {
          flushDirect(operand, findArgumentPosition(operand));
      }
  
<span class="line-modified">!     void flushDirect(VirtualRegister operand, ArgumentPosition* argumentPosition)</span>
      {
          addFlushOrPhantomLocal&lt;Flush&gt;(operand, argumentPosition);
      }
  
      template&lt;NodeType nodeType&gt;
<span class="line-modified">!     void addFlushOrPhantomLocal(VirtualRegister operand, ArgumentPosition* argumentPosition)</span>
      {
          ASSERT(!operand.isConstant());
  
<span class="line-modified">!         Node* node = m_currentBlock-&gt;variablesAtTail.operand(operand);</span>
  
          VariableAccessData* variable;
  
          if (node)
              variable = node-&gt;variableAccessData();
          else
              variable = newVariableAccessData(operand);
  
          node = addToGraph(nodeType, OpInfo(variable));
<span class="line-removed">-         m_currentBlock-&gt;variablesAtTail.operand(operand) = node;</span>
          if (argumentPosition)
              argumentPosition-&gt;addVariable(variable);
      }
  
<span class="line-modified">!     void phantomLocalDirect(VirtualRegister operand)</span>
      {
          addFlushOrPhantomLocal&lt;PhantomLocal&gt;(operand, findArgumentPosition(operand));
      }
  
      void flush(InlineStackEntry* inlineStackEntry)
      {
<span class="line-modified">!         auto addFlushDirect = [&amp;] (InlineCallFrame*, VirtualRegister reg) { flushDirect(reg); };</span>
          flushImpl(inlineStackEntry-&gt;m_inlineCallFrame, addFlushDirect);
      }
  
      void flushForTerminal()
      {
<span class="line-modified">!         auto addFlushDirect = [&amp;] (InlineCallFrame*, VirtualRegister reg) { flushDirect(reg); };</span>
<span class="line-modified">!         auto addPhantomLocalDirect = [&amp;] (InlineCallFrame*, VirtualRegister reg) { phantomLocalDirect(reg); };</span>
          flushForTerminalImpl(currentCodeOrigin(), addFlushDirect, addPhantomLocalDirect);
      }
  
      void flushForReturn()
      {
          flush(m_inlineStackTop);
      }
  
      void flushIfTerminal(SwitchData&amp; data)
      {
<span class="line-modified">!         if (data.fallThrough.bytecodeIndex() &gt; m_currentIndex)</span>
              return;
  
          for (unsigned i = data.cases.size(); i--;) {
<span class="line-modified">!             if (data.cases[i].target.bytecodeIndex() &gt; m_currentIndex)</span>
                  return;
          }
  
          flushForTerminal();
      }
<span class="line-new-header">--- 559,129 ---</span>
              if (operand.offset() &gt;= static_cast&lt;int&gt;(inlineCallFrame-&gt;stackOffset + CallFrame::thisArgumentOffset() + inlineCallFrame-&gt;argumentsWithFixup.size()))
                  continue;
              int argument = VirtualRegister(operand.offset() - inlineCallFrame-&gt;stackOffset).toArgument();
              return stack-&gt;m_argumentPositions[argument];
          }
<span class="line-modified">!         return nullptr;</span>
      }
  
<span class="line-modified">!     ArgumentPosition* findArgumentPosition(Operand operand)</span>
      {
<span class="line-added">+         if (operand.isTmp())</span>
<span class="line-added">+             return nullptr;</span>
          if (operand.isArgument())
              return findArgumentPositionForArgument(operand.toArgument());
<span class="line-modified">!         return findArgumentPositionForLocal(operand.virtualRegister());</span>
      }
  
      template&lt;typename AddFlushDirectFunc&gt;
      void flushImpl(InlineCallFrame* inlineCallFrame, const AddFlushDirectFunc&amp; addFlushDirect)
      {
          int numArguments;
          if (inlineCallFrame) {
              ASSERT(!m_graph.hasDebuggerEnabled());
              numArguments = inlineCallFrame-&gt;argumentsWithFixup.size();
              if (inlineCallFrame-&gt;isClosureCall)
<span class="line-modified">!                 addFlushDirect(inlineCallFrame, remapOperand(inlineCallFrame, CallFrameSlot::callee));</span>
              if (inlineCallFrame-&gt;isVarargs())
<span class="line-modified">!                 addFlushDirect(inlineCallFrame, remapOperand(inlineCallFrame, CallFrameSlot::argumentCountIncludingThis));</span>
          } else
              numArguments = m_graph.baselineCodeBlockFor(inlineCallFrame)-&gt;numParameters();
  
          for (unsigned argument = numArguments; argument--;)
<span class="line-modified">!             addFlushDirect(inlineCallFrame, remapOperand(inlineCallFrame, virtualRegisterForArgumentIncludingThis(argument)));</span>
  
          if (m_graph.needsScopeRegister())
              addFlushDirect(nullptr, m_graph.m_codeBlock-&gt;scopeRegister());
      }
  
      template&lt;typename AddFlushDirectFunc, typename AddPhantomLocalDirectFunc&gt;
      void flushForTerminalImpl(CodeOrigin origin, const AddFlushDirectFunc&amp; addFlushDirect, const AddPhantomLocalDirectFunc&amp; addPhantomLocalDirect)
      {
<span class="line-added">+         bool isCallerOrigin = false;</span>
          origin.walkUpInlineStack(
              [&amp;] (CodeOrigin origin) {
<span class="line-modified">!                 BytecodeIndex bytecodeIndex = origin.bytecodeIndex();</span>
                  InlineCallFrame* inlineCallFrame = origin.inlineCallFrame();
                  flushImpl(inlineCallFrame, addFlushDirect);
  
                  CodeBlock* codeBlock = m_graph.baselineCodeBlockFor(inlineCallFrame);
                  FullBytecodeLiveness&amp; fullLiveness = m_graph.livenessFor(codeBlock);
<span class="line-modified">!                 // Note: We don&#39;t need to handle tmps here because tmps are not required to be flushed to the stack.</span>
<span class="line-modified">!                 const auto&amp; livenessAtBytecode = fullLiveness.getLiveness(bytecodeIndex, m_graph.appropriateLivenessCalculationPoint(origin, isCallerOrigin));</span>
                  for (unsigned local = codeBlock-&gt;numCalleeLocals(); local--;) {
                      if (livenessAtBytecode[local])
                          addPhantomLocalDirect(inlineCallFrame, remapOperand(inlineCallFrame, virtualRegisterForLocal(local)));
                  }
<span class="line-added">+                 isCallerOrigin = true;</span>
              });
      }
  
<span class="line-modified">!     void flush(Operand operand)</span>
      {
          flushDirect(m_inlineStackTop-&gt;remapOperand(operand));
      }
  
<span class="line-modified">!     void flushDirect(Operand operand)</span>
      {
          flushDirect(operand, findArgumentPosition(operand));
      }
  
<span class="line-modified">!     void flushDirect(Operand operand, ArgumentPosition* argumentPosition)</span>
      {
          addFlushOrPhantomLocal&lt;Flush&gt;(operand, argumentPosition);
      }
  
      template&lt;NodeType nodeType&gt;
<span class="line-modified">!     void addFlushOrPhantomLocal(Operand operand, ArgumentPosition* argumentPosition)</span>
      {
          ASSERT(!operand.isConstant());
  
<span class="line-modified">!         Node*&amp; node = m_currentBlock-&gt;variablesAtTail.operand(operand);</span>
  
          VariableAccessData* variable;
  
          if (node)
              variable = node-&gt;variableAccessData();
          else
              variable = newVariableAccessData(operand);
  
          node = addToGraph(nodeType, OpInfo(variable));
          if (argumentPosition)
              argumentPosition-&gt;addVariable(variable);
      }
  
<span class="line-modified">!     void phantomLocalDirect(Operand operand)</span>
      {
          addFlushOrPhantomLocal&lt;PhantomLocal&gt;(operand, findArgumentPosition(operand));
      }
  
      void flush(InlineStackEntry* inlineStackEntry)
      {
<span class="line-modified">!         auto addFlushDirect = [&amp;] (InlineCallFrame*, Operand operand) { flushDirect(operand); };</span>
          flushImpl(inlineStackEntry-&gt;m_inlineCallFrame, addFlushDirect);
      }
  
      void flushForTerminal()
      {
<span class="line-modified">!         auto addFlushDirect = [&amp;] (InlineCallFrame*, Operand operand) { flushDirect(operand); };</span>
<span class="line-modified">!         auto addPhantomLocalDirect = [&amp;] (InlineCallFrame*, Operand operand) { phantomLocalDirect(operand); };</span>
          flushForTerminalImpl(currentCodeOrigin(), addFlushDirect, addPhantomLocalDirect);
      }
  
      void flushForReturn()
      {
          flush(m_inlineStackTop);
      }
  
      void flushIfTerminal(SwitchData&amp; data)
      {
<span class="line-modified">!         if (data.fallThrough.bytecodeIndex() &gt; m_currentIndex.offset())</span>
              return;
  
          for (unsigned i = data.cases.size(); i--;) {
<span class="line-modified">!             if (data.cases[i].target.bytecodeIndex() &gt; m_currentIndex.offset())</span>
                  return;
          }
  
          flushForTerminal();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 701,11 ***</span>
  
      BranchData* branchData(unsigned taken, unsigned notTaken)
      {
          // We assume that branches originating from bytecode always have a fall-through. We
          // use this assumption to avoid checking for the creation of terminal blocks.
<span class="line-modified">!         ASSERT((taken &gt; m_currentIndex) || (notTaken &gt; m_currentIndex));</span>
          BranchData* data = m_graph.m_branchData.add();
          *data = BranchData::withBytecodeIndices(taken, notTaken);
          return data;
      }
  
<span class="line-new-header">--- 740,11 ---</span>
  
      BranchData* branchData(unsigned taken, unsigned notTaken)
      {
          // We assume that branches originating from bytecode always have a fall-through. We
          // use this assumption to avoid checking for the creation of terminal blocks.
<span class="line-modified">!         ASSERT((taken &gt; m_currentIndex.offset()) || (notTaken &gt; m_currentIndex.offset()));</span>
          BranchData* data = m_graph.m_branchData.add();
          *data = BranchData::withBytecodeIndices(taken, notTaken);
          return data;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 751,10 ***</span>
<span class="line-new-header">--- 790,15 ---</span>
          Node* result = m_graph.addNode(
              op, currentNodeOrigin(), info1, info2,
              Edge(child1), Edge(child2), Edge(child3));
          return addToGraph(result);
      }
<span class="line-added">+     Node* addToGraph(NodeType op, Operand operand, Node* child1)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(op == MovHint);</span>
<span class="line-added">+         return addToGraph(op, OpInfo(operand.kind()), OpInfo(operand.value()), child1);</span>
<span class="line-added">+     }</span>
      Node* addToGraph(NodeType op, OpInfo info1, OpInfo info2, Edge child1, Edge child2 = Edge(), Edge child3 = Edge())
      {
          Node* result = m_graph.addNode(
              op, currentNodeOrigin(), info1, info2, child1, child2, child3);
          return addToGraph(result);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 793,11 ***</span>
  
          if (parameterSlots &gt; m_parameterSlots)
              m_parameterSlots = parameterSlots;
  
          for (int i = 0; i &lt; argCount; ++i)
<span class="line-modified">!             addVarArgChild(get(virtualRegisterForArgument(i, registerOffset)));</span>
  
          return addToGraph(Node::VarArg, op, opInfo, prediction);
      }
  
      Node* addCall(
<span class="line-new-header">--- 837,11 ---</span>
  
          if (parameterSlots &gt; m_parameterSlots)
              m_parameterSlots = parameterSlots;
  
          for (int i = 0; i &lt; argCount; ++i)
<span class="line-modified">!             addVarArgChild(get(virtualRegisterForArgumentIncludingThis(i, registerOffset)));</span>
  
          return addToGraph(Node::VarArg, op, opInfo, prediction);
      }
  
      Node* addCall(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 826,18 ***</span>
          Node* objectNode = weakJSConstant(object);
          addToGraph(CheckStructure, OpInfo(m_graph.addStructureSet(structure)), objectNode);
          return objectNode;
      }
  
<span class="line-modified">!     SpeculatedType getPredictionWithoutOSRExit(unsigned bytecodeIndex)</span>
      {
          auto getValueProfilePredictionFromForCodeBlockAndBytecodeOffset = [&amp;] (CodeBlock* codeBlock, const CodeOrigin&amp; codeOrigin)
          {
              SpeculatedType prediction;
              {
                  ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
<span class="line-modified">!                 prediction = codeBlock-&gt;valueProfilePredictionForBytecodeOffset(locker, codeOrigin.bytecodeIndex());</span>
              }
              auto* fuzzerAgent = m_vm-&gt;fuzzerAgent();
              if (UNLIKELY(fuzzerAgent))
                  return fuzzerAgent-&gt;getPrediction(codeBlock, codeOrigin, prediction) &amp; SpecBytecodeTop;
              return prediction;
<span class="line-new-header">--- 870,18 ---</span>
          Node* objectNode = weakJSConstant(object);
          addToGraph(CheckStructure, OpInfo(m_graph.addStructureSet(structure)), objectNode);
          return objectNode;
      }
  
<span class="line-modified">!     SpeculatedType getPredictionWithoutOSRExit(BytecodeIndex bytecodeIndex)</span>
      {
          auto getValueProfilePredictionFromForCodeBlockAndBytecodeOffset = [&amp;] (CodeBlock* codeBlock, const CodeOrigin&amp; codeOrigin)
          {
              SpeculatedType prediction;
              {
                  ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
<span class="line-modified">!                 prediction = codeBlock-&gt;valueProfilePredictionForBytecodeIndex(locker, codeOrigin.bytecodeIndex());</span>
              }
              auto* fuzzerAgent = m_vm-&gt;fuzzerAgent();
              if (UNLIKELY(fuzzerAgent))
                  return fuzzerAgent-&gt;getPrediction(codeBlock, codeOrigin, prediction) &amp; SpecBytecodeTop;
              return prediction;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 852,11 ***</span>
          // a tail call opcode. In that case, we walk up the
          // inline frames to find a call higher in the call
          // chain and use its prediction. If we only have
          // inlined tail call frames, we use SpecFullTop
          // to avoid a spurious OSR exit.
<span class="line-modified">!         auto instruction = m_inlineStackTop-&gt;m_profiledBlock-&gt;instructions().at(bytecodeIndex);</span>
          OpcodeID opcodeID = instruction-&gt;opcodeID();
  
          switch (opcodeID) {
          case op_tail_call:
          case op_tail_call_varargs:
<span class="line-new-header">--- 896,11 ---</span>
          // a tail call opcode. In that case, we walk up the
          // inline frames to find a call higher in the call
          // chain and use its prediction. If we only have
          // inlined tail call frames, we use SpecFullTop
          // to avoid a spurious OSR exit.
<span class="line-modified">!         auto instruction = m_inlineStackTop-&gt;m_profiledBlock-&gt;instructions().at(bytecodeIndex.offset());</span>
          OpcodeID opcodeID = instruction-&gt;opcodeID();
  
          switch (opcodeID) {
          case op_tail_call:
          case op_tail_call_varargs:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 886,11 ***</span>
  
          RELEASE_ASSERT_NOT_REACHED();
          return SpecNone;
      }
  
<span class="line-modified">!     SpeculatedType getPrediction(unsigned bytecodeIndex)</span>
      {
          SpeculatedType prediction = getPredictionWithoutOSRExit(bytecodeIndex);
  
          if (prediction == SpecNone) {
              // We have no information about what values this node generates. Give up
<span class="line-new-header">--- 930,11 ---</span>
  
          RELEASE_ASSERT_NOT_REACHED();
          return SpecNone;
      }
  
<span class="line-modified">!     SpeculatedType getPrediction(BytecodeIndex bytecodeIndex)</span>
      {
          SpeculatedType prediction = getPredictionWithoutOSRExit(bytecodeIndex);
  
          if (prediction == SpecNone) {
              // We have no information about what values this node generates. Give up
</pre>
<hr />
<pre>
<span class="line-old-header">*** 912,11 ***</span>
      }
  
      ArrayMode getArrayMode(Array::Action action)
      {
          CodeBlock* codeBlock = m_inlineStackTop-&gt;m_profiledBlock;
<span class="line-modified">!         ArrayProfile* profile = codeBlock-&gt;getArrayProfile(codeBlock-&gt;bytecodeOffset(m_currentInstruction));</span>
          return getArrayMode(*profile, action);
      }
  
      ArrayMode getArrayMode(ArrayProfile&amp; profile, Array::Action action)
      {
<span class="line-new-header">--- 956,11 ---</span>
      }
  
      ArrayMode getArrayMode(Array::Action action)
      {
          CodeBlock* codeBlock = m_inlineStackTop-&gt;m_profiledBlock;
<span class="line-modified">!         ArrayProfile* profile = codeBlock-&gt;getArrayProfile(codeBlock-&gt;bytecodeIndex(m_currentInstruction));</span>
          return getArrayMode(*profile, action);
      }
  
      ArrayMode getArrayMode(ArrayProfile&amp; profile, Array::Action action)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 934,60 ***</span>
              node-&gt;mergeFlags(NodeMayNegZeroInDFG);
  
          if (!isX86() &amp;&amp; (node-&gt;op() == ArithMod || node-&gt;op() == ValueMod))
              return node;
  
<span class="line-modified">!         {</span>
<span class="line-modified">!             ArithProfile* arithProfile = m_inlineStackTop-&gt;m_profiledBlock-&gt;arithProfileForBytecodeOffset(m_currentIndex);</span>
<span class="line-modified">!             if (arithProfile) {</span>
<span class="line-modified">!                 switch (node-&gt;op()) {</span>
<span class="line-modified">!                 case ArithAdd:</span>
<span class="line-modified">!                 case ArithSub:</span>
<span class="line-modified">!                 case ValueAdd:</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveDouble())</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayHaveDoubleResult);</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveNonNumeric())</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayHaveNonNumericResult);</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveBigInt())</span>
<span class="line-removed">-                         node-&gt;mergeFlags(NodeMayHaveBigIntResult);</span>
<span class="line-removed">-                     break;</span>
  
<span class="line-modified">!                 case ValueMul:</span>
<span class="line-modified">!                 case ArithMul: {</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveInt52Overflow())</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayOverflowInt52);</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveInt32Overflow() || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, Overflow))</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayOverflowInt32InBaseline);</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveNegZeroDouble() || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, NegativeZero))</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayNegZeroInBaseline);</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveDouble())</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayHaveDoubleResult);</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveNonNumeric())</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayHaveNonNumericResult);</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveBigInt())</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayHaveBigIntResult);</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case ValueNegate:</span>
<span class="line-modified">!                 case ArithNegate: {</span>
<span class="line-modified">!                     if (arithProfile-&gt;lhsObservedType().sawNumber() || arithProfile-&gt;didObserveDouble())</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayHaveDoubleResult);</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveNegZeroDouble() || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, NegativeZero))</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayNegZeroInBaseline);</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveInt32Overflow() || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, Overflow))</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayOverflowInt32InBaseline);</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveNonNumeric())</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayHaveNonNumericResult);</span>
<span class="line-modified">!                     if (arithProfile-&gt;didObserveBigInt())</span>
<span class="line-modified">!                         node-&gt;mergeFlags(NodeMayHaveBigIntResult);</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 default:</span>
<span class="line-modified">!                     break;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
          }
  
          if (m_inlineStackTop-&gt;m_profiledBlock-&gt;likelyToTakeSlowCase(m_currentIndex)) {
              switch (node-&gt;op()) {
              case UInt32ToNumber:
<span class="line-new-header">--- 978,72 ---</span>
              node-&gt;mergeFlags(NodeMayNegZeroInDFG);
  
          if (!isX86() &amp;&amp; (node-&gt;op() == ArithMod || node-&gt;op() == ValueMod))
              return node;
  
<span class="line-modified">!         switch (node-&gt;op()) {</span>
<span class="line-modified">!         case ArithAdd:</span>
<span class="line-modified">!         case ArithSub:</span>
<span class="line-modified">!         case ValueAdd: {</span>
<span class="line-modified">!             ObservedResults observed;</span>
<span class="line-modified">!             if (BinaryArithProfile* arithProfile = m_inlineStackTop-&gt;m_profiledBlock-&gt;binaryArithProfileForBytecodeIndex(m_currentIndex))</span>
<span class="line-modified">!                 observed = arithProfile-&gt;observedResults();</span>
<span class="line-modified">!             else if (UnaryArithProfile* arithProfile = m_inlineStackTop-&gt;m_profiledBlock-&gt;unaryArithProfileForBytecodeIndex(m_currentIndex)) {</span>
<span class="line-modified">!                 // Happens for OpInc/OpDec</span>
<span class="line-modified">!                 observed = arithProfile-&gt;observedResults();</span>
<span class="line-modified">!             } else</span>
<span class="line-modified">!                 break;</span>
  
<span class="line-modified">!             if (observed.didObserveDouble())</span>
<span class="line-modified">!                 node-&gt;mergeFlags(NodeMayHaveDoubleResult);</span>
<span class="line-modified">!             if (observed.didObserveNonNumeric())</span>
<span class="line-modified">!                 node-&gt;mergeFlags(NodeMayHaveNonNumericResult);</span>
<span class="line-modified">!             if (observed.didObserveBigInt())</span>
<span class="line-modified">!                 node-&gt;mergeFlags(NodeMayHaveBigIntResult);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case ValueMul:</span>
<span class="line-modified">!         case ArithMul: {</span>
<span class="line-modified">!             BinaryArithProfile* arithProfile = m_inlineStackTop-&gt;m_profiledBlock-&gt;binaryArithProfileForBytecodeIndex(m_currentIndex);</span>
<span class="line-modified">!             if (!arithProfile)</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             if (arithProfile-&gt;didObserveInt52Overflow())</span>
<span class="line-modified">!                 node-&gt;mergeFlags(NodeMayOverflowInt52);</span>
<span class="line-modified">!             if (arithProfile-&gt;didObserveInt32Overflow() || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, Overflow))</span>
<span class="line-modified">!                 node-&gt;mergeFlags(NodeMayOverflowInt32InBaseline);</span>
<span class="line-modified">!             if (arithProfile-&gt;didObserveNegZeroDouble() || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, NegativeZero))</span>
<span class="line-modified">!                 node-&gt;mergeFlags(NodeMayNegZeroInBaseline);</span>
<span class="line-modified">!             if (arithProfile-&gt;didObserveDouble())</span>
<span class="line-modified">!                 node-&gt;mergeFlags(NodeMayHaveDoubleResult);</span>
<span class="line-modified">!             if (arithProfile-&gt;didObserveNonNumeric())</span>
<span class="line-modified">!                 node-&gt;mergeFlags(NodeMayHaveNonNumericResult);</span>
<span class="line-modified">!             if (arithProfile-&gt;didObserveBigInt())</span>
<span class="line-modified">!                 node-&gt;mergeFlags(NodeMayHaveBigIntResult);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case ValueNegate:</span>
<span class="line-modified">!         case ArithNegate:</span>
<span class="line-modified">!         case Inc:</span>
<span class="line-added">+         case Dec: {</span>
<span class="line-added">+             UnaryArithProfile* arithProfile = m_inlineStackTop-&gt;m_profiledBlock-&gt;unaryArithProfileForBytecodeIndex(m_currentIndex);</span>
<span class="line-added">+             if (!arithProfile)</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             if (arithProfile-&gt;argObservedType().sawNumber() || arithProfile-&gt;didObserveDouble())</span>
<span class="line-added">+                 node-&gt;mergeFlags(NodeMayHaveDoubleResult);</span>
<span class="line-added">+             if (arithProfile-&gt;didObserveNegZeroDouble() || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, NegativeZero))</span>
<span class="line-added">+                 node-&gt;mergeFlags(NodeMayNegZeroInBaseline);</span>
<span class="line-added">+             if (arithProfile-&gt;didObserveInt32Overflow() || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, Overflow))</span>
<span class="line-added">+                 node-&gt;mergeFlags(NodeMayOverflowInt32InBaseline);</span>
<span class="line-added">+             if (arithProfile-&gt;didObserveNonNumeric())</span>
<span class="line-added">+                 node-&gt;mergeFlags(NodeMayHaveNonNumericResult);</span>
<span class="line-added">+             if (arithProfile-&gt;didObserveBigInt())</span>
<span class="line-added">+                 node-&gt;mergeFlags(NodeMayHaveBigIntResult);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         default:</span>
<span class="line-modified">!             break;</span>
          }
  
          if (m_inlineStackTop-&gt;m_profiledBlock-&gt;likelyToTakeSlowCase(m_currentIndex)) {
              switch (node-&gt;op()) {
              case UInt32ToNumber:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1020,17 ***</span>
          // the operands are not numbers. We don&#39;t care about that since we already
          // have speculations in place that take care of that separately. We only
          // care about when the outcome of the division is not an integer, which
          // is what the special fast case counter tells us.
  
<span class="line-modified">!         if (!m_inlineStackTop-&gt;m_profiledBlock-&gt;couldTakeSpecialFastCase(m_currentIndex))</span>
              return node;
  
          // FIXME: It might be possible to make this more granular.
          node-&gt;mergeFlags(NodeMayOverflowInt32InBaseline | NodeMayNegZeroInBaseline);
  
<span class="line-modified">!         ArithProfile* arithProfile = m_inlineStackTop-&gt;m_profiledBlock-&gt;arithProfileForBytecodeOffset(m_currentIndex);</span>
          if (arithProfile-&gt;didObserveBigInt())
              node-&gt;mergeFlags(NodeMayHaveBigIntResult);
  
          return node;
      }
<span class="line-new-header">--- 1076,17 ---</span>
          // the operands are not numbers. We don&#39;t care about that since we already
          // have speculations in place that take care of that separately. We only
          // care about when the outcome of the division is not an integer, which
          // is what the special fast case counter tells us.
  
<span class="line-modified">!         if (!m_inlineStackTop-&gt;m_profiledBlock-&gt;couldTakeSpecialArithFastCase(m_currentIndex))</span>
              return node;
  
          // FIXME: It might be possible to make this more granular.
          node-&gt;mergeFlags(NodeMayOverflowInt32InBaseline | NodeMayNegZeroInBaseline);
  
<span class="line-modified">!         BinaryArithProfile* arithProfile = m_inlineStackTop-&gt;m_profiledBlock-&gt;binaryArithProfileForBytecodeIndex(m_currentIndex);</span>
          if (arithProfile-&gt;didObserveBigInt())
              node-&gt;mergeFlags(NodeMayHaveBigIntResult);
  
          return node;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1053,11 ***</span>
      Graph&amp; m_graph;
  
      // The current block being generated.
      BasicBlock* m_currentBlock;
      // The bytecode index of the current instruction being generated.
<span class="line-modified">!     unsigned m_currentIndex;</span>
      // The semantic origin of the current node if different from the current Index.
      CodeOrigin m_currentSemanticOrigin;
      // True if it&#39;s OK to OSR exit right now.
      bool m_exitOK { false };
  
<span class="line-new-header">--- 1109,11 ---</span>
      Graph&amp; m_graph;
  
      // The current block being generated.
      BasicBlock* m_currentBlock;
      // The bytecode index of the current instruction being generated.
<span class="line-modified">!     BytecodeIndex m_currentIndex;</span>
      // The semantic origin of the current node if different from the current Index.
      CodeOrigin m_currentSemanticOrigin;
      // True if it&#39;s OK to OSR exit right now.
      bool m_exitOK { false };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1069,12 ***</span>
  
      HashMap&lt;InlineCallFrame*, Vector&lt;ArgumentPosition*&gt;, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; m_inlineCallFrameToArgumentPositions;
  
      // The number of arguments passed to the function.
      unsigned m_numArguments;
<span class="line-modified">!     // The number of locals (vars + temporaries) used in the function.</span>
      unsigned m_numLocals;
      // The number of slots (in units of sizeof(Register)) that we need to
      // preallocate for arguments to outgoing calls from this frame. This
      // number includes the CallFrame slots that we initialize for the callee
      // (but not the callee-initialized CallerFrame and ReturnPC slots).
      // This number is 0 if and only if this function is a leaf.
<span class="line-new-header">--- 1125,14 ---</span>
  
      HashMap&lt;InlineCallFrame*, Vector&lt;ArgumentPosition*&gt;, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; m_inlineCallFrameToArgumentPositions;
  
      // The number of arguments passed to the function.
      unsigned m_numArguments;
<span class="line-modified">!     // The number of locals (vars + temporaries) used by the bytecode for the function.</span>
      unsigned m_numLocals;
<span class="line-added">+     // The max number of temps used for forwarding data to an OSR exit checkpoint.</span>
<span class="line-added">+     unsigned m_numTmps;</span>
      // The number of slots (in units of sizeof(Register)) that we need to
      // preallocate for arguments to outgoing calls from this frame. This
      // number includes the CallFrame slots that we initialize for the callee
      // (but not the callee-initialized CallerFrame and ReturnPC slots).
      // This number is 0 if and only if this function is a leaf.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1137,33 ***</span>
              InlineCallFrame::Kind,
              BasicBlock* continuationBlock);
  
          ~InlineStackEntry();
  
<span class="line-modified">!         VirtualRegister remapOperand(VirtualRegister operand) const</span>
          {
              if (!m_inlineCallFrame)
                  return operand;
  
<span class="line-modified">!             ASSERT(!operand.isConstant());</span>
  
<span class="line-modified">!             return VirtualRegister(operand.offset() + m_inlineCallFrame-&gt;stackOffset);</span>
          }
      };
  
      InlineStackEntry* m_inlineStackTop;
  
      ICStatusContextStack m_icContextStack;
  
      struct DelayedSetLocal {
<span class="line-removed">-         CodeOrigin m_origin;</span>
<span class="line-removed">-         VirtualRegister m_operand;</span>
<span class="line-removed">-         Node* m_value;</span>
<span class="line-removed">-         SetMode m_setMode;</span>
<span class="line-removed">- </span>
          DelayedSetLocal() { }
<span class="line-modified">!         DelayedSetLocal(const CodeOrigin&amp; origin, VirtualRegister operand, Node* value, SetMode setMode)</span>
              : m_origin(origin)
              , m_operand(operand)
              , m_value(value)
              , m_setMode(setMode)
          {
<span class="line-new-header">--- 1195,31 ---</span>
              InlineCallFrame::Kind,
              BasicBlock* continuationBlock);
  
          ~InlineStackEntry();
  
<span class="line-modified">!         Operand remapOperand(Operand operand) const</span>
          {
              if (!m_inlineCallFrame)
                  return operand;
  
<span class="line-modified">!             if (operand.isTmp())</span>
<span class="line-added">+                 return Operand::tmp(operand.value() + m_inlineCallFrame-&gt;tmpOffset);</span>
  
<span class="line-modified">!             ASSERT(!operand.virtualRegister().isConstant());</span>
<span class="line-added">+ </span>
<span class="line-added">+             return operand.virtualRegister() + m_inlineCallFrame-&gt;stackOffset;</span>
          }
      };
  
      InlineStackEntry* m_inlineStackTop;
  
      ICStatusContextStack m_icContextStack;
  
      struct DelayedSetLocal {
          DelayedSetLocal() { }
<span class="line-modified">!         DelayedSetLocal(const CodeOrigin&amp; origin, Operand operand, Node* value, SetMode setMode)</span>
              : m_origin(origin)
              , m_operand(operand)
              , m_value(value)
              , m_setMode(setMode)
          {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1172,49 ***</span>
  
          Node* execute(ByteCodeParser* parser)
          {
              if (m_operand.isArgument())
                  return parser-&gt;setArgument(m_origin, m_operand, m_value, m_setMode);
<span class="line-modified">!             return parser-&gt;setLocal(m_origin, m_operand, m_value, m_setMode);</span>
          }
      };
  
      Vector&lt;DelayedSetLocal, 2&gt; m_setLocalQueue;
  
      const Instruction* m_currentInstruction;
      bool m_hasDebuggerEnabled;
      bool m_hasAnyForceOSRExits { false };
  };
  
<span class="line-modified">! BasicBlock* ByteCodeParser::allocateTargetableBlock(unsigned bytecodeIndex)</span>
  {
<span class="line-modified">!     ASSERT(bytecodeIndex != UINT_MAX);</span>
<span class="line-modified">!     Ref&lt;BasicBlock&gt; block = adoptRef(*new BasicBlock(bytecodeIndex, m_numArguments, m_numLocals, 1));</span>
      BasicBlock* blockPtr = block.ptr();
      // m_blockLinkingTargets must always be sorted in increasing order of bytecodeBegin
      if (m_inlineStackTop-&gt;m_blockLinkingTargets.size())
<span class="line-modified">!         ASSERT(m_inlineStackTop-&gt;m_blockLinkingTargets.last()-&gt;bytecodeBegin &lt; bytecodeIndex);</span>
      m_inlineStackTop-&gt;m_blockLinkingTargets.append(blockPtr);
      m_graph.appendBlock(WTFMove(block));
      return blockPtr;
  }
  
  BasicBlock* ByteCodeParser::allocateUntargetableBlock()
  {
<span class="line-modified">!     Ref&lt;BasicBlock&gt; block = adoptRef(*new BasicBlock(UINT_MAX, m_numArguments, m_numLocals, 1));</span>
      BasicBlock* blockPtr = block.ptr();
      m_graph.appendBlock(WTFMove(block));
      return blockPtr;
  }
  
<span class="line-modified">! void ByteCodeParser::makeBlockTargetable(BasicBlock* block, unsigned bytecodeIndex)</span>
  {
<span class="line-modified">!     RELEASE_ASSERT(block-&gt;bytecodeBegin == UINT_MAX);</span>
      block-&gt;bytecodeBegin = bytecodeIndex;
      // m_blockLinkingTargets must always be sorted in increasing order of bytecodeBegin
      if (m_inlineStackTop-&gt;m_blockLinkingTargets.size())
<span class="line-modified">!         ASSERT(m_inlineStackTop-&gt;m_blockLinkingTargets.last()-&gt;bytecodeBegin &lt; bytecodeIndex);</span>
      m_inlineStackTop-&gt;m_blockLinkingTargets.append(block);
  }
  
  void ByteCodeParser::addJumpTo(BasicBlock* block)
  {
<span class="line-new-header">--- 1228,54 ---</span>
  
          Node* execute(ByteCodeParser* parser)
          {
              if (m_operand.isArgument())
                  return parser-&gt;setArgument(m_origin, m_operand, m_value, m_setMode);
<span class="line-modified">!             return parser-&gt;setLocalOrTmp(m_origin, m_operand, m_value, m_setMode);</span>
          }
<span class="line-added">+ </span>
<span class="line-added">+         CodeOrigin m_origin;</span>
<span class="line-added">+         Operand m_operand;</span>
<span class="line-added">+         Node* m_value { nullptr };</span>
<span class="line-added">+         SetMode m_setMode;</span>
      };
  
      Vector&lt;DelayedSetLocal, 2&gt; m_setLocalQueue;
  
      const Instruction* m_currentInstruction;
      bool m_hasDebuggerEnabled;
      bool m_hasAnyForceOSRExits { false };
  };
  
<span class="line-modified">! BasicBlock* ByteCodeParser::allocateTargetableBlock(BytecodeIndex bytecodeIndex)</span>
  {
<span class="line-modified">!     ASSERT(bytecodeIndex);</span>
<span class="line-modified">!     Ref&lt;BasicBlock&gt; block = adoptRef(*new BasicBlock(bytecodeIndex, m_numArguments, m_numLocals, m_numTmps, 1));</span>
      BasicBlock* blockPtr = block.ptr();
      // m_blockLinkingTargets must always be sorted in increasing order of bytecodeBegin
      if (m_inlineStackTop-&gt;m_blockLinkingTargets.size())
<span class="line-modified">!         ASSERT(m_inlineStackTop-&gt;m_blockLinkingTargets.last()-&gt;bytecodeBegin.offset() &lt; bytecodeIndex.offset());</span>
      m_inlineStackTop-&gt;m_blockLinkingTargets.append(blockPtr);
      m_graph.appendBlock(WTFMove(block));
      return blockPtr;
  }
  
  BasicBlock* ByteCodeParser::allocateUntargetableBlock()
  {
<span class="line-modified">!     Ref&lt;BasicBlock&gt; block = adoptRef(*new BasicBlock(BytecodeIndex(), m_numArguments, m_numLocals, m_numTmps, 1));</span>
      BasicBlock* blockPtr = block.ptr();
      m_graph.appendBlock(WTFMove(block));
      return blockPtr;
  }
  
<span class="line-modified">! void ByteCodeParser::makeBlockTargetable(BasicBlock* block, BytecodeIndex bytecodeIndex)</span>
  {
<span class="line-modified">!     RELEASE_ASSERT(!block-&gt;bytecodeBegin);</span>
      block-&gt;bytecodeBegin = bytecodeIndex;
      // m_blockLinkingTargets must always be sorted in increasing order of bytecodeBegin
      if (m_inlineStackTop-&gt;m_blockLinkingTargets.size())
<span class="line-modified">!         ASSERT(m_inlineStackTop-&gt;m_blockLinkingTargets.last()-&gt;bytecodeBegin.offset() &lt; bytecodeIndex.offset());</span>
      m_inlineStackTop-&gt;m_blockLinkingTargets.append(block);
  }
  
  void ByteCodeParser::addJumpTo(BasicBlock* block)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1268,13 ***</span>
      // If we have profiling information about this call, and it did not behave too polymorphically,
      // we may be able to inline it, or in the case of recursive tail calls turn it into a jump.
      if (callLinkStatus.canOptimize()) {
          addToGraph(FilterCallLinkStatus, OpInfo(m_graph.m_plan.recordedStatuses().addCallLinkStatus(currentCodeOrigin(), callLinkStatus)), callTarget);
  
<span class="line-modified">!         VirtualRegister thisArgument = virtualRegisterForArgument(0, registerOffset);</span>
          auto optimizationResult = handleInlining(callTarget, result, callLinkStatus, registerOffset, thisArgument,
<span class="line-modified">!             argumentCountIncludingThis, m_currentIndex + instructionSize, op, kind, prediction);</span>
          if (optimizationResult == CallOptimizationResult::OptimizedToJump)
              return Terminal;
          if (optimizationResult == CallOptimizationResult::Inlined) {
              if (UNLIKELY(m_graph.compilation()))
                  m_graph.compilation()-&gt;noticeInlinedCall();
<span class="line-new-header">--- 1329,13 ---</span>
      // If we have profiling information about this call, and it did not behave too polymorphically,
      // we may be able to inline it, or in the case of recursive tail calls turn it into a jump.
      if (callLinkStatus.canOptimize()) {
          addToGraph(FilterCallLinkStatus, OpInfo(m_graph.m_plan.recordedStatuses().addCallLinkStatus(currentCodeOrigin(), callLinkStatus)), callTarget);
  
<span class="line-modified">!         VirtualRegister thisArgument = virtualRegisterForArgumentIncludingThis(0, registerOffset);</span>
          auto optimizationResult = handleInlining(callTarget, result, callLinkStatus, registerOffset, thisArgument,
<span class="line-modified">!             argumentCountIncludingThis, BytecodeIndex(m_currentIndex.offset() + instructionSize), op, kind, prediction);</span>
          if (optimizationResult == CallOptimizationResult::OptimizedToJump)
              return Terminal;
          if (optimizationResult == CallOptimizationResult::Inlined) {
              if (UNLIKELY(m_graph.compilation()))
                  m_graph.compilation()-&gt;noticeInlinedCall();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1375,11 ***</span>
  }
  
  void ByteCodeParser::emitArgumentPhantoms(int registerOffset, int argumentCountIncludingThis)
  {
      for (int i = 0; i &lt; argumentCountIncludingThis; ++i)
<span class="line-modified">!         addToGraph(Phantom, get(virtualRegisterForArgument(i, registerOffset)));</span>
  }
  
  template&lt;typename ChecksFunctor&gt;
  bool ByteCodeParser::handleRecursiveTailCall(Node* callTargetNode, CallVariant callVariant, int registerOffset, int argumentCountIncludingThis, const ChecksFunctor&amp; emitFunctionCheckIfNeeded)
  {
<span class="line-new-header">--- 1436,11 ---</span>
  }
  
  void ByteCodeParser::emitArgumentPhantoms(int registerOffset, int argumentCountIncludingThis)
  {
      for (int i = 0; i &lt; argumentCountIncludingThis; ++i)
<span class="line-modified">!         addToGraph(Phantom, get(virtualRegisterForArgumentIncludingThis(i, registerOffset)));</span>
  }
  
  template&lt;typename ChecksFunctor&gt;
  bool ByteCodeParser::handleRecursiveTailCall(Node* callTargetNode, CallVariant callVariant, int registerOffset, int argumentCountIncludingThis, const ChecksFunctor&amp; emitFunctionCheckIfNeeded)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1392,14 ***</span>
<span class="line-new-header">--- 1453,23 ---</span>
          if (targetExecutable != stackEntry-&gt;executable())
              continue;
          VERBOSE_LOG(&quot;   We found a recursive tail call, trying to optimize it into a jump.\n&quot;);
  
          if (auto* callFrame = stackEntry-&gt;m_inlineCallFrame) {
<span class="line-added">+             // FIXME: We only accept jump to CallFrame which has exact same argumentCountIncludingThis. But we can remove this by fixing up arguments.</span>
<span class="line-added">+             // And we can also allow jumping into CallFrame with Varargs if the passing number of arguments is greater than or equal to mandatoryMinimum of CallFrame.</span>
<span class="line-added">+             // https://bugs.webkit.org/show_bug.cgi?id=202317</span>
<span class="line-added">+ </span>
              // Some code may statically use the argument count from the InlineCallFrame, so it would be invalid to loop back if it does not match.
              // We &quot;continue&quot; instead of returning false in case another stack entry further on the stack has the right number of arguments.
              if (argumentCountIncludingThis != static_cast&lt;int&gt;(callFrame-&gt;argumentCountIncludingThis))
                  continue;
<span class="line-added">+             // If the target InlineCallFrame is Varargs, we do not know how many arguments are actually filled by LoadVarargs. Varargs InlineCallFrame&#39;s</span>
<span class="line-added">+             // argumentCountIncludingThis is maximum number of potentially filled arguments by xkLoadVarargs. We &quot;continue&quot; to the upper frame which may be</span>
<span class="line-added">+             // a good target to jump into.</span>
<span class="line-added">+             if (callFrame-&gt;isVarargs())</span>
<span class="line-added">+                 continue;</span>
          } else {
              // We are in the machine code entry (i.e. the original caller).
              // If we have more arguments than the number of parameters to the function, it is not clear where we could put them on the stack.
              if (argumentCountIncludingThis &gt; m_codeBlock-&gt;numParameters())
                  return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1418,49 ***</span>
          flushForTerminal();
  
          // We must set the callee to the right value
          if (stackEntry-&gt;m_inlineCallFrame) {
              if (stackEntry-&gt;m_inlineCallFrame-&gt;isClosureCall)
<span class="line-modified">!                 setDirect(stackEntry-&gt;remapOperand(VirtualRegister(CallFrameSlot::callee)), callTargetNode, NormalSet);</span>
          } else
              addToGraph(SetCallee, callTargetNode);
  
          // We must set the arguments to the right values
          if (!stackEntry-&gt;m_inlineCallFrame)
              addToGraph(SetArgumentCountIncludingThis, OpInfo(argumentCountIncludingThis));
          int argIndex = 0;
          for (; argIndex &lt; argumentCountIncludingThis; ++argIndex) {
<span class="line-modified">!             Node* value = get(virtualRegisterForArgument(argIndex, registerOffset));</span>
<span class="line-modified">!             setDirect(stackEntry-&gt;remapOperand(virtualRegisterForArgument(argIndex)), value, NormalSet);</span>
          }
          Node* undefined = addToGraph(JSConstant, OpInfo(m_constantUndefined));
          for (; argIndex &lt; stackEntry-&gt;m_codeBlock-&gt;numParameters(); ++argIndex)
<span class="line-modified">!             setDirect(stackEntry-&gt;remapOperand(virtualRegisterForArgument(argIndex)), undefined, NormalSet);</span>
  
          // We must repeat the work of op_enter here as we will jump right after it.
          // We jump right after it and not before it, because of some invariant saying that a CFG root cannot have predecessors in the IR.
          for (int i = 0; i &lt; stackEntry-&gt;m_codeBlock-&gt;numVars(); ++i)
              setDirect(stackEntry-&gt;remapOperand(virtualRegisterForLocal(i)), undefined, NormalSet);
  
<span class="line-modified">!         unsigned oldIndex = m_currentIndex;</span>
          auto oldStackTop = m_inlineStackTop;
<span class="line-removed">- </span>
<span class="line-removed">-         // First, we emit check-traps operation pointing to bc#0 as exit.</span>
          m_inlineStackTop = stackEntry;
<span class="line-modified">!         m_currentIndex = 0;</span>
<span class="line-removed">-         m_exitOK = true;</span>
<span class="line-removed">-         addToGraph(Options::usePollingTraps() ? CheckTraps : InvalidationPoint);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Then, we want to emit the SetLocals with an exit origin that points to the place we are jumping to.</span>
<span class="line-removed">-         m_currentIndex = opcodeLengths[op_enter];</span>
          m_exitOK = true;
          processSetLocalQueue();
          m_currentIndex = oldIndex;
          m_inlineStackTop = oldStackTop;
          m_exitOK = false;
  
<span class="line-modified">!         BasicBlock** entryBlockPtr = tryBinarySearch&lt;BasicBlock*, unsigned&gt;(stackEntry-&gt;m_blockLinkingTargets, stackEntry-&gt;m_blockLinkingTargets.size(), opcodeLengths[op_enter], getBytecodeBeginForBlock);</span>
          RELEASE_ASSERT(entryBlockPtr);
          addJumpTo(*entryBlockPtr);
          return true;
          // It would be unsound to jump over a non-tail call: the &quot;tail&quot; call is not really a tail call in that case.
      } while (stackEntry-&gt;m_inlineCallFrame &amp;&amp; stackEntry-&gt;m_inlineCallFrame-&gt;kind == InlineCallFrame::TailCall &amp;&amp; (stackEntry = stackEntry-&gt;m_caller));
<span class="line-new-header">--- 1488,43 ---</span>
          flushForTerminal();
  
          // We must set the callee to the right value
          if (stackEntry-&gt;m_inlineCallFrame) {
              if (stackEntry-&gt;m_inlineCallFrame-&gt;isClosureCall)
<span class="line-modified">!                 setDirect(remapOperand(stackEntry-&gt;m_inlineCallFrame, CallFrameSlot::callee), callTargetNode, NormalSet);</span>
          } else
              addToGraph(SetCallee, callTargetNode);
  
          // We must set the arguments to the right values
          if (!stackEntry-&gt;m_inlineCallFrame)
              addToGraph(SetArgumentCountIncludingThis, OpInfo(argumentCountIncludingThis));
          int argIndex = 0;
          for (; argIndex &lt; argumentCountIncludingThis; ++argIndex) {
<span class="line-modified">!             Node* value = get(virtualRegisterForArgumentIncludingThis(argIndex, registerOffset));</span>
<span class="line-modified">!             setDirect(stackEntry-&gt;remapOperand(virtualRegisterForArgumentIncludingThis(argIndex)), value, NormalSet);</span>
          }
          Node* undefined = addToGraph(JSConstant, OpInfo(m_constantUndefined));
          for (; argIndex &lt; stackEntry-&gt;m_codeBlock-&gt;numParameters(); ++argIndex)
<span class="line-modified">!             setDirect(stackEntry-&gt;remapOperand(virtualRegisterForArgumentIncludingThis(argIndex)), undefined, NormalSet);</span>
  
          // We must repeat the work of op_enter here as we will jump right after it.
          // We jump right after it and not before it, because of some invariant saying that a CFG root cannot have predecessors in the IR.
          for (int i = 0; i &lt; stackEntry-&gt;m_codeBlock-&gt;numVars(); ++i)
              setDirect(stackEntry-&gt;remapOperand(virtualRegisterForLocal(i)), undefined, NormalSet);
  
<span class="line-modified">!         // We want to emit the SetLocals with an exit origin that points to the place we are jumping to.</span>
<span class="line-added">+         BytecodeIndex oldIndex = m_currentIndex;</span>
          auto oldStackTop = m_inlineStackTop;
          m_inlineStackTop = stackEntry;
<span class="line-modified">!         m_currentIndex = BytecodeIndex(opcodeLengths[op_enter]);</span>
          m_exitOK = true;
          processSetLocalQueue();
          m_currentIndex = oldIndex;
          m_inlineStackTop = oldStackTop;
          m_exitOK = false;
  
<span class="line-modified">!         BasicBlock** entryBlockPtr = tryBinarySearch&lt;BasicBlock*, BytecodeIndex&gt;(stackEntry-&gt;m_blockLinkingTargets, stackEntry-&gt;m_blockLinkingTargets.size(), BytecodeIndex(opcodeLengths[op_enter]), getBytecodeBeginForBlock);</span>
          RELEASE_ASSERT(entryBlockPtr);
          addJumpTo(*entryBlockPtr);
          return true;
          // It would be unsound to jump over a non-tail call: the &quot;tail&quot; call is not really a tail call in that case.
      } while (stackEntry-&gt;m_inlineCallFrame &amp;&amp; stackEntry-&gt;m_inlineCallFrame-&gt;kind == InlineCallFrame::TailCall &amp;&amp; (stackEntry = stackEntry-&gt;m_caller));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1589,20 ***</span>
      int arityFixupCount = std::max&lt;int&gt;(codeBlock-&gt;numParameters() - argumentCountIncludingThis, 0);
      int numberOfStackPaddingSlots = CommonSlowPaths::numberOfStackPaddingSlots(codeBlock, argumentCountIncludingThis);
      ASSERT(!(numberOfStackPaddingSlots % stackAlignmentRegisters()));
      int registerOffsetAfterFixup = registerOffset - numberOfStackPaddingSlots;
  
<span class="line-modified">!     int inlineCallFrameStart = m_inlineStackTop-&gt;remapOperand(VirtualRegister(registerOffsetAfterFixup)).offset() + CallFrame::headerSizeInRegisters;</span>
  
      ensureLocals(
<span class="line-modified">!         VirtualRegister(inlineCallFrameStart).toLocal() + 1 +</span>
          CallFrame::headerSizeInRegisters + codeBlock-&gt;numCalleeLocals());
  
      size_t argumentPositionStart = m_graph.m_argumentPositions.size();
  
      if (result.isValid())
<span class="line-modified">!         result = m_inlineStackTop-&gt;remapOperand(result);</span>
  
      VariableAccessData* calleeVariable = nullptr;
      if (callee.isClosureCall()) {
          Node* calleeSet = set(
              VirtualRegister(registerOffsetAfterFixup + CallFrameSlot::callee), callTargetNode, ImmediateNakedSet);
<span class="line-new-header">--- 1653,22 ---</span>
      int arityFixupCount = std::max&lt;int&gt;(codeBlock-&gt;numParameters() - argumentCountIncludingThis, 0);
      int numberOfStackPaddingSlots = CommonSlowPaths::numberOfStackPaddingSlots(codeBlock, argumentCountIncludingThis);
      ASSERT(!(numberOfStackPaddingSlots % stackAlignmentRegisters()));
      int registerOffsetAfterFixup = registerOffset - numberOfStackPaddingSlots;
  
<span class="line-modified">!     Operand inlineCallFrameStart = VirtualRegister(m_inlineStackTop-&gt;remapOperand(VirtualRegister(registerOffsetAfterFixup)).value() + CallFrame::headerSizeInRegisters);</span>
  
      ensureLocals(
<span class="line-modified">!         inlineCallFrameStart.toLocal() + 1 +</span>
          CallFrame::headerSizeInRegisters + codeBlock-&gt;numCalleeLocals());
  
<span class="line-added">+     ensureTmps((m_inlineStackTop-&gt;m_inlineCallFrame ? m_inlineStackTop-&gt;m_inlineCallFrame-&gt;tmpOffset : 0) + m_inlineStackTop-&gt;m_codeBlock-&gt;numTmps() + codeBlock-&gt;numTmps());</span>
<span class="line-added">+ </span>
      size_t argumentPositionStart = m_graph.m_argumentPositions.size();
  
      if (result.isValid())
<span class="line-modified">!         result = m_inlineStackTop-&gt;remapOperand(result).virtualRegister();</span>
  
      VariableAccessData* calleeVariable = nullptr;
      if (callee.isClosureCall()) {
          Node* calleeSet = set(
              VirtualRegister(registerOffsetAfterFixup + CallFrameSlot::callee), callTargetNode, ImmediateNakedSet);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1611,15 ***</span>
          calleeVariable-&gt;mergeShouldNeverUnbox(true);
      }
  
      InlineStackEntry* callerStackTop = m_inlineStackTop;
      InlineStackEntry inlineStackEntry(this, codeBlock, codeBlock, callee.function(), result,
<span class="line-modified">!         (VirtualRegister)inlineCallFrameStart, argumentCountIncludingThis, kind, continuationBlock);</span>
  
      // This is where the actual inlining really happens.
<span class="line-modified">!     unsigned oldIndex = m_currentIndex;</span>
<span class="line-modified">!     m_currentIndex = 0;</span>
  
      switch (kind) {
      case InlineCallFrame::GetterCall:
      case InlineCallFrame::SetterCall: {
          // When inlining getter and setter calls, we setup a stack frame which does not appear in the bytecode.
<span class="line-new-header">--- 1677,15 ---</span>
          calleeVariable-&gt;mergeShouldNeverUnbox(true);
      }
  
      InlineStackEntry* callerStackTop = m_inlineStackTop;
      InlineStackEntry inlineStackEntry(this, codeBlock, codeBlock, callee.function(), result,
<span class="line-modified">!         inlineCallFrameStart.virtualRegister(), argumentCountIncludingThis, kind, continuationBlock);</span>
  
      // This is where the actual inlining really happens.
<span class="line-modified">!     BytecodeIndex oldIndex = m_currentIndex;</span>
<span class="line-modified">!     m_currentIndex = BytecodeIndex(0);</span>
  
      switch (kind) {
      case InlineCallFrame::GetterCall:
      case InlineCallFrame::SetterCall: {
          // When inlining getter and setter calls, we setup a stack frame which does not appear in the bytecode.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1646,13 ***</span>
          //
          // When we prune OSR availability at the beginning of BB#2 (bc#7 in the caller), we prune loc9 and loc10&#39;s liveness because the caller does not actually have loc9 and loc10.
          // However, when we begin executing the callee, we need OSR exit to be aware of where it can recover the arguments to the setter, loc9 and loc10. The MovHints in the inlined
          // callee make it so that if we exit at &lt;HERE&gt;, we can recover loc9 and loc10.
          for (int index = 0; index &lt; argumentCountIncludingThis; ++index) {
<span class="line-modified">!             VirtualRegister argumentToGet = callerStackTop-&gt;remapOperand(virtualRegisterForArgument(index, registerOffset));</span>
              Node* value = getDirect(argumentToGet);
<span class="line-modified">!             addToGraph(MovHint, OpInfo(argumentToGet.offset()), value);</span>
              m_setLocalQueue.append(DelayedSetLocal { currentCodeOrigin(), argumentToGet, value, ImmediateNakedSet });
          }
          break;
      }
      default:
<span class="line-new-header">--- 1712,13 ---</span>
          //
          // When we prune OSR availability at the beginning of BB#2 (bc#7 in the caller), we prune loc9 and loc10&#39;s liveness because the caller does not actually have loc9 and loc10.
          // However, when we begin executing the callee, we need OSR exit to be aware of where it can recover the arguments to the setter, loc9 and loc10. The MovHints in the inlined
          // callee make it so that if we exit at &lt;HERE&gt;, we can recover loc9 and loc10.
          for (int index = 0; index &lt; argumentCountIncludingThis; ++index) {
<span class="line-modified">!             Operand argumentToGet = callerStackTop-&gt;remapOperand(virtualRegisterForArgumentIncludingThis(index, registerOffset));</span>
              Node* value = getDirect(argumentToGet);
<span class="line-modified">!             addToGraph(MovHint, OpInfo(argumentToGet), value);</span>
              m_setLocalQueue.append(DelayedSetLocal { currentCodeOrigin(), argumentToGet, value, ImmediateNakedSet });
          }
          break;
      }
      default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1692,20 ***</span>
          // after:  [ ... ][arg2][arg1][arg0][header]
          //
          // In such cases, we do not need to move frames.
          if (registerOffsetAfterFixup != registerOffset) {
              for (int index = 0; index &lt; argumentCountIncludingThis; ++index) {
<span class="line-modified">!                 VirtualRegister argumentToGet = callerStackTop-&gt;remapOperand(virtualRegisterForArgument(index, registerOffset));</span>
                  Node* value = getDirect(argumentToGet);
<span class="line-modified">!                 VirtualRegister argumentToSet = m_inlineStackTop-&gt;remapOperand(virtualRegisterForArgument(index));</span>
<span class="line-modified">!                 addToGraph(MovHint, OpInfo(argumentToSet.offset()), value);</span>
                  m_setLocalQueue.append(DelayedSetLocal { currentCodeOrigin(), argumentToSet, value, ImmediateNakedSet });
              }
          }
          for (int index = 0; index &lt; arityFixupCount; ++index) {
<span class="line-modified">!             VirtualRegister argumentToSet = m_inlineStackTop-&gt;remapOperand(virtualRegisterForArgument(argumentCountIncludingThis + index));</span>
<span class="line-modified">!             addToGraph(MovHint, OpInfo(argumentToSet.offset()), undefined);</span>
              m_setLocalQueue.append(DelayedSetLocal { currentCodeOrigin(), argumentToSet, undefined, ImmediateNakedSet });
          }
  
          // At this point, it&#39;s OK to OSR exit because we finished setting up
          // our callee&#39;s frame. We emit an ExitOK below.
<span class="line-new-header">--- 1758,20 ---</span>
          // after:  [ ... ][arg2][arg1][arg0][header]
          //
          // In such cases, we do not need to move frames.
          if (registerOffsetAfterFixup != registerOffset) {
              for (int index = 0; index &lt; argumentCountIncludingThis; ++index) {
<span class="line-modified">!                 Operand argumentToGet = callerStackTop-&gt;remapOperand(virtualRegisterForArgumentIncludingThis(index, registerOffset));</span>
                  Node* value = getDirect(argumentToGet);
<span class="line-modified">!                 Operand argumentToSet = m_inlineStackTop-&gt;remapOperand(virtualRegisterForArgumentIncludingThis(index));</span>
<span class="line-modified">!                 addToGraph(MovHint, OpInfo(argumentToSet), value);</span>
                  m_setLocalQueue.append(DelayedSetLocal { currentCodeOrigin(), argumentToSet, value, ImmediateNakedSet });
              }
          }
          for (int index = 0; index &lt; arityFixupCount; ++index) {
<span class="line-modified">!             Operand argumentToSet = m_inlineStackTop-&gt;remapOperand(virtualRegisterForArgumentIncludingThis(argumentCountIncludingThis + index));</span>
<span class="line-modified">!             addToGraph(MovHint, OpInfo(argumentToSet), undefined);</span>
              m_setLocalQueue.append(DelayedSetLocal { currentCodeOrigin(), argumentToSet, undefined, ImmediateNakedSet });
          }
  
          // At this point, it&#39;s OK to OSR exit because we finished setting up
          // our callee&#39;s frame. We emit an ExitOK below.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1750,11 ***</span>
  
      prepareToParseBlock();
      m_currentInstruction = savedCurrentInstruction;
  }
  
<span class="line-modified">! ByteCodeParser::CallOptimizationResult ByteCodeParser::handleCallVariant(Node* callTargetNode, VirtualRegister result, CallVariant callee, int registerOffset, VirtualRegister thisArgument, int argumentCountIncludingThis, unsigned nextOffset, InlineCallFrame::Kind kind, SpeculatedType prediction, unsigned&amp; inliningBalance, BasicBlock* continuationBlock, bool needsToCheckCallee)</span>
  {
      VERBOSE_LOG(&quot;    Considering callee &quot;, callee, &quot;\n&quot;);
  
      bool didInsertChecks = false;
      auto insertChecksWithAccounting = [&amp;] () {
<span class="line-new-header">--- 1816,11 ---</span>
  
      prepareToParseBlock();
      m_currentInstruction = savedCurrentInstruction;
  }
  
<span class="line-modified">! ByteCodeParser::CallOptimizationResult ByteCodeParser::handleCallVariant(Node* callTargetNode, VirtualRegister result, CallVariant callee, int registerOffset, VirtualRegister thisArgument, int argumentCountIncludingThis, BytecodeIndex nextIndex, InlineCallFrame::Kind kind, SpeculatedType prediction, unsigned&amp; inliningBalance, BasicBlock* continuationBlock, bool needsToCheckCallee)</span>
  {
      VERBOSE_LOG(&quot;    Considering callee &quot;, callee, &quot;\n&quot;);
  
      bool didInsertChecks = false;
      auto insertChecksWithAccounting = [&amp;] () {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1778,11 ***</span>
          RELEASE_ASSERT(didInsertChecks);
          addToGraph(Phantom, callTargetNode);
          emitArgumentPhantoms(registerOffset, argumentCountIncludingThis);
          inliningBalance--;
          if (continuationBlock) {
<span class="line-modified">!             m_currentIndex = nextOffset;</span>
              m_exitOK = true;
              processSetLocalQueue();
              addJumpTo(continuationBlock);
          }
      };
<span class="line-new-header">--- 1844,11 ---</span>
          RELEASE_ASSERT(didInsertChecks);
          addToGraph(Phantom, callTargetNode);
          emitArgumentPhantoms(registerOffset, argumentCountIncludingThis);
          inliningBalance--;
          if (continuationBlock) {
<span class="line-modified">!             m_currentIndex = nextIndex;</span>
              m_exitOK = true;
              processSetLocalQueue();
              addJumpTo(continuationBlock);
          }
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1833,11 ***</span>
      const CallLinkStatus&amp; callLinkStatus, int firstFreeReg, VirtualRegister thisArgument,
      VirtualRegister argumentsArgument, unsigned argumentsOffset,
      NodeType callOp, InlineCallFrame::Kind kind)
  {
      VERBOSE_LOG(&quot;Handling inlining (Varargs)...\nStack: &quot;, currentCodeOrigin(), &quot;\n&quot;);
<span class="line-modified">!     if (callLinkStatus.maxNumArguments() &gt; Options::maximumVarargsForInlining()) {</span>
          VERBOSE_LOG(&quot;Bailing inlining: too many arguments for varargs inlining.\n&quot;);
          return false;
      }
      if (callLinkStatus.couldTakeSlowPath() || callLinkStatus.size() != 1) {
          VERBOSE_LOG(&quot;Bailing inlining: polymorphic inlining is not yet supported for varargs.\n&quot;);
<span class="line-new-header">--- 1899,11 ---</span>
      const CallLinkStatus&amp; callLinkStatus, int firstFreeReg, VirtualRegister thisArgument,
      VirtualRegister argumentsArgument, unsigned argumentsOffset,
      NodeType callOp, InlineCallFrame::Kind kind)
  {
      VERBOSE_LOG(&quot;Handling inlining (Varargs)...\nStack: &quot;, currentCodeOrigin(), &quot;\n&quot;);
<span class="line-modified">!     if (callLinkStatus.maxArgumentCountIncludingThis() &gt; Options::maximumVarargsForInlining()) {</span>
          VERBOSE_LOG(&quot;Bailing inlining: too many arguments for varargs inlining.\n&quot;);
          return false;
      }
      if (callLinkStatus.couldTakeSlowPath() || callLinkStatus.size() != 1) {
          VERBOSE_LOG(&quot;Bailing inlining: polymorphic inlining is not yet supported for varargs.\n&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1851,45 ***</span>
          mandatoryMinimum = functionExecutable-&gt;parameterCount();
      else
          mandatoryMinimum = 0;
  
      // includes &quot;this&quot;
<span class="line-modified">!     unsigned maxNumArguments = std::max(callLinkStatus.maxNumArguments(), mandatoryMinimum + 1);</span>
  
      CodeSpecializationKind specializationKind = InlineCallFrame::specializationKindFor(kind);
<span class="line-modified">!     if (inliningCost(callVariant, maxNumArguments, kind) &gt; getInliningBalance(callLinkStatus, specializationKind)) {</span>
          VERBOSE_LOG(&quot;Bailing inlining: inlining cost too high.\n&quot;);
          return false;
      }
  
<span class="line-modified">!     int registerOffset = firstFreeReg + 1;</span>
<span class="line-modified">!     registerOffset -= maxNumArguments; // includes &quot;this&quot;</span>
      registerOffset -= CallFrame::headerSizeInRegisters;
      registerOffset = -WTF::roundUpToMultipleOf(stackAlignmentRegisters(), -registerOffset);
  
      auto insertChecks = [&amp;] (CodeBlock* codeBlock) {
          emitFunctionChecks(callVariant, callTargetNode, thisArgument);
  
          int remappedRegisterOffset =
<span class="line-modified">!         m_inlineStackTop-&gt;remapOperand(VirtualRegister(registerOffset)).offset();</span>
  
          ensureLocals(VirtualRegister(remappedRegisterOffset).toLocal());
  
          int argumentStart = registerOffset + CallFrame::headerSizeInRegisters;
<span class="line-modified">!         int remappedArgumentStart = m_inlineStackTop-&gt;remapOperand(VirtualRegister(argumentStart)).offset();</span>
  
          LoadVarargsData* data = m_graph.m_loadVarargsData.add();
          data-&gt;start = VirtualRegister(remappedArgumentStart + 1);
<span class="line-modified">!         data-&gt;count = VirtualRegister(remappedRegisterOffset + CallFrameSlot::argumentCount);</span>
          data-&gt;offset = argumentsOffset;
<span class="line-modified">!         data-&gt;limit = maxNumArguments;</span>
          data-&gt;mandatoryMinimum = mandatoryMinimum;
  
<span class="line-modified">!         if (callOp == TailCallForwardVarargs)</span>
<span class="line-modified">!             addToGraph(ForwardVarargs, OpInfo(data));</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!             addToGraph(LoadVarargs, OpInfo(data), get(argumentsArgument));</span>
  
          // LoadVarargs may OSR exit. Hence, we need to keep alive callTargetNode, thisArgument
          // and argumentsArgument for the baseline JIT. However, we only need a Phantom for
          // callTargetNode because the other 2 are still in use and alive at this point.
          addToGraph(Phantom, callTargetNode);
<span class="line-new-header">--- 1917,58 ---</span>
          mandatoryMinimum = functionExecutable-&gt;parameterCount();
      else
          mandatoryMinimum = 0;
  
      // includes &quot;this&quot;
<span class="line-modified">!     unsigned maxArgumentCountIncludingThis = std::max(callLinkStatus.maxArgumentCountIncludingThis(), mandatoryMinimum + 1);</span>
  
      CodeSpecializationKind specializationKind = InlineCallFrame::specializationKindFor(kind);
<span class="line-modified">!     if (inliningCost(callVariant, maxArgumentCountIncludingThis, kind) &gt; getInliningBalance(callLinkStatus, specializationKind)) {</span>
          VERBOSE_LOG(&quot;Bailing inlining: inlining cost too high.\n&quot;);
          return false;
      }
  
<span class="line-modified">!     int registerOffset = firstFreeReg;</span>
<span class="line-modified">!     registerOffset -= maxArgumentCountIncludingThis;</span>
      registerOffset -= CallFrame::headerSizeInRegisters;
      registerOffset = -WTF::roundUpToMultipleOf(stackAlignmentRegisters(), -registerOffset);
  
      auto insertChecks = [&amp;] (CodeBlock* codeBlock) {
          emitFunctionChecks(callVariant, callTargetNode, thisArgument);
  
          int remappedRegisterOffset =
<span class="line-modified">!         m_inlineStackTop-&gt;remapOperand(VirtualRegister(registerOffset)).virtualRegister().offset();</span>
  
          ensureLocals(VirtualRegister(remappedRegisterOffset).toLocal());
  
          int argumentStart = registerOffset + CallFrame::headerSizeInRegisters;
<span class="line-modified">!         int remappedArgumentStart = m_inlineStackTop-&gt;remapOperand(VirtualRegister(argumentStart)).virtualRegister().offset();</span>
  
          LoadVarargsData* data = m_graph.m_loadVarargsData.add();
          data-&gt;start = VirtualRegister(remappedArgumentStart + 1);
<span class="line-modified">!         data-&gt;count = VirtualRegister(remappedRegisterOffset + CallFrameSlot::argumentCountIncludingThis);</span>
          data-&gt;offset = argumentsOffset;
<span class="line-modified">!         data-&gt;limit = maxArgumentCountIncludingThis;</span>
          data-&gt;mandatoryMinimum = mandatoryMinimum;
  
<span class="line-modified">!         if (callOp == TailCallForwardVarargs) {</span>
<span class="line-modified">!             Node* argumentCount;</span>
<span class="line-modified">!             if (!inlineCallFrame())</span>
<span class="line-modified">!                 argumentCount = addToGraph(GetArgumentCountIncludingThis);</span>
<span class="line-added">+             else if (inlineCallFrame()-&gt;isVarargs())</span>
<span class="line-added">+                 argumentCount = getDirect(remapOperand(inlineCallFrame(), CallFrameSlot::argumentCountIncludingThis));</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 argumentCount = addToGraph(JSConstant, OpInfo(m_graph.freeze(jsNumber(inlineCallFrame()-&gt;argumentCountIncludingThis))));</span>
<span class="line-added">+             addToGraph(ForwardVarargs, OpInfo(data), argumentCount);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             Node* arguments = get(argumentsArgument);</span>
<span class="line-added">+             auto argCountTmp = m_inlineStackTop-&gt;remapOperand(Operand::tmp(OpCallVarargs::argCountIncludingThis));</span>
<span class="line-added">+             setDirect(argCountTmp, addToGraph(VarargsLength, OpInfo(data), arguments));</span>
<span class="line-added">+             progressToNextCheckpoint();</span>
<span class="line-added">+ </span>
<span class="line-added">+             addToGraph(LoadVarargs, OpInfo(data), getLocalOrTmp(argCountTmp), arguments);</span>
<span class="line-added">+         }</span>
  
          // LoadVarargs may OSR exit. Hence, we need to keep alive callTargetNode, thisArgument
          // and argumentsArgument for the baseline JIT. However, we only need a Phantom for
          // callTargetNode because the other 2 are still in use and alive at this point.
          addToGraph(Phantom, callTargetNode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1897,22 ***</span>
          // In DFG IR before SSA, we cannot insert control flow between after the
          // LoadVarargs and the last SetArgumentDefinitely. This isn&#39;t a problem once we get to DFG
          // SSA. Fortunately, we also have other reasons for not inserting control flow
          // before SSA.
  
<span class="line-modified">!         VariableAccessData* countVariable = newVariableAccessData(VirtualRegister(remappedRegisterOffset + CallFrameSlot::argumentCount));</span>
          // This is pretty lame, but it will force the count to be flushed as an int. This doesn&#39;t
          // matter very much, since our use of a SetArgumentDefinitely and Flushes for this local slot is
          // mostly just a formality.
          countVariable-&gt;predict(SpecInt32Only);
          countVariable-&gt;mergeIsProfitableToUnbox(true);
          Node* setArgumentCount = addToGraph(SetArgumentDefinitely, OpInfo(countVariable));
<span class="line-modified">!         m_currentBlock-&gt;variablesAtTail.setOperand(countVariable-&gt;local(), setArgumentCount);</span>
  
          set(VirtualRegister(argumentStart), get(thisArgument), ImmediateNakedSet);
          unsigned numSetArguments = 0;
<span class="line-modified">!         for (unsigned argument = 1; argument &lt; maxNumArguments; ++argument) {</span>
              VariableAccessData* variable = newVariableAccessData(VirtualRegister(remappedArgumentStart + argument));
              variable-&gt;mergeShouldNeverUnbox(true); // We currently have nowhere to put the type check on the LoadVarargs. LoadVarargs is effectful, so after it finishes, we cannot exit.
  
              // For a while it had been my intention to do things like this inside the
              // prediction injection phase. But in this case it&#39;s really best to do it here,
<span class="line-new-header">--- 1976,22 ---</span>
          // In DFG IR before SSA, we cannot insert control flow between after the
          // LoadVarargs and the last SetArgumentDefinitely. This isn&#39;t a problem once we get to DFG
          // SSA. Fortunately, we also have other reasons for not inserting control flow
          // before SSA.
  
<span class="line-modified">!         VariableAccessData* countVariable = newVariableAccessData(data-&gt;count);</span>
          // This is pretty lame, but it will force the count to be flushed as an int. This doesn&#39;t
          // matter very much, since our use of a SetArgumentDefinitely and Flushes for this local slot is
          // mostly just a formality.
          countVariable-&gt;predict(SpecInt32Only);
          countVariable-&gt;mergeIsProfitableToUnbox(true);
          Node* setArgumentCount = addToGraph(SetArgumentDefinitely, OpInfo(countVariable));
<span class="line-modified">!         m_currentBlock-&gt;variablesAtTail.setOperand(countVariable-&gt;operand(), setArgumentCount);</span>
  
          set(VirtualRegister(argumentStart), get(thisArgument), ImmediateNakedSet);
          unsigned numSetArguments = 0;
<span class="line-modified">!         for (unsigned argument = 1; argument &lt; maxArgumentCountIncludingThis; ++argument) {</span>
              VariableAccessData* variable = newVariableAccessData(VirtualRegister(remappedArgumentStart + argument));
              variable-&gt;mergeShouldNeverUnbox(true); // We currently have nowhere to put the type check on the LoadVarargs. LoadVarargs is effectful, so after it finishes, we cannot exit.
  
              // For a while it had been my intention to do things like this inside the
              // prediction injection phase. But in this case it&#39;s really best to do it here,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1928,11 ***</span>
                  ValueProfile&amp; profile = codeBlock-&gt;valueProfileForArgument(argument);
                  variable-&gt;predict(profile.computeUpdatedPrediction(locker));
              }
  
              Node* setArgument = addToGraph(numSetArguments &gt;= mandatoryMinimum ? SetArgumentMaybe : SetArgumentDefinitely, OpInfo(variable));
<span class="line-modified">!             m_currentBlock-&gt;variablesAtTail.setOperand(variable-&gt;local(), setArgument);</span>
              ++numSetArguments;
          }
      };
  
      // Intrinsics and internal functions can only be inlined if we&#39;re not doing varargs. This is because
<span class="line-new-header">--- 2007,11 ---</span>
                  ValueProfile&amp; profile = codeBlock-&gt;valueProfileForArgument(argument);
                  variable-&gt;predict(profile.computeUpdatedPrediction(locker));
              }
  
              Node* setArgument = addToGraph(numSetArguments &gt;= mandatoryMinimum ? SetArgumentMaybe : SetArgumentDefinitely, OpInfo(variable));
<span class="line-modified">!             m_currentBlock-&gt;variablesAtTail.setOperand(variable-&gt;operand(), setArgument);</span>
              ++numSetArguments;
          }
      };
  
      // Intrinsics and internal functions can only be inlined if we&#39;re not doing varargs. This is because
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1940,11 ***</span>
      // calls. The prediction propagator won&#39;t be of any help because LoadVarargs obscures the data flow,
      // and there are no callsite value profiles and native function won&#39;t have callee value profiles for
      // those arguments. Even worse, if the intrinsic decides to exit, it won&#39;t really have anywhere to
      // exit to: LoadVarargs is effectful and it&#39;s part of the op_call_varargs, so we can&#39;t exit without
      // calling LoadVarargs twice.
<span class="line-modified">!     inlineCall(callTargetNode, result, callVariant, registerOffset, maxNumArguments, kind, nullptr, insertChecks);</span>
  
  
      VERBOSE_LOG(&quot;Successful inlining (varargs, monomorphic).\nStack: &quot;, currentCodeOrigin(), &quot;\n&quot;);
      return true;
  }
<span class="line-new-header">--- 2019,11 ---</span>
      // calls. The prediction propagator won&#39;t be of any help because LoadVarargs obscures the data flow,
      // and there are no callsite value profiles and native function won&#39;t have callee value profiles for
      // those arguments. Even worse, if the intrinsic decides to exit, it won&#39;t really have anywhere to
      // exit to: LoadVarargs is effectful and it&#39;s part of the op_call_varargs, so we can&#39;t exit without
      // calling LoadVarargs twice.
<span class="line-modified">!     inlineCall(callTargetNode, result, callVariant, registerOffset, maxArgumentCountIncludingThis, kind, nullptr, insertChecks);</span>
  
  
      VERBOSE_LOG(&quot;Successful inlining (varargs, monomorphic).\nStack: &quot;, currentCodeOrigin(), &quot;\n&quot;);
      return true;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1961,11 ***</span>
  
  ByteCodeParser::CallOptimizationResult ByteCodeParser::handleInlining(
      Node* callTargetNode, VirtualRegister result, const CallLinkStatus&amp; callLinkStatus,
      int registerOffset, VirtualRegister thisArgument,
      int argumentCountIncludingThis,
<span class="line-modified">!     unsigned nextOffset, NodeType callOp, InlineCallFrame::Kind kind, SpeculatedType prediction)</span>
  {
      VERBOSE_LOG(&quot;Handling inlining...\nStack: &quot;, currentCodeOrigin(), &quot;\n&quot;);
  
      CodeSpecializationKind specializationKind = InlineCallFrame::specializationKindFor(kind);
      unsigned inliningBalance = getInliningBalance(callLinkStatus, specializationKind);
<span class="line-new-header">--- 2040,11 ---</span>
  
  ByteCodeParser::CallOptimizationResult ByteCodeParser::handleInlining(
      Node* callTargetNode, VirtualRegister result, const CallLinkStatus&amp; callLinkStatus,
      int registerOffset, VirtualRegister thisArgument,
      int argumentCountIncludingThis,
<span class="line-modified">!     BytecodeIndex nextIndex, NodeType callOp, InlineCallFrame::Kind kind, SpeculatedType prediction)</span>
  {
      VERBOSE_LOG(&quot;Handling inlining...\nStack: &quot;, currentCodeOrigin(), &quot;\n&quot;);
  
      CodeSpecializationKind specializationKind = InlineCallFrame::specializationKindFor(kind);
      unsigned inliningBalance = getInliningBalance(callLinkStatus, specializationKind);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1974,11 ***</span>
      // simplification on the fly and this helps reduce compile times, but we can only leverage
      // this in cases where we don&#39;t need control flow diamonds to check the callee.
      if (!callLinkStatus.couldTakeSlowPath() &amp;&amp; callLinkStatus.size() == 1) {
          return handleCallVariant(
              callTargetNode, result, callLinkStatus[0], registerOffset, thisArgument,
<span class="line-modified">!             argumentCountIncludingThis, nextOffset, kind, prediction, inliningBalance, nullptr, true);</span>
      }
  
      // We need to create some kind of switch over callee. For now we only do this if we believe that
      // we&#39;re in the top tier. We have two reasons for this: first, it provides us an opportunity to
      // do more detailed polyvariant/polymorphic profiling; and second, it reduces compile times in
<span class="line-new-header">--- 2053,11 ---</span>
      // simplification on the fly and this helps reduce compile times, but we can only leverage
      // this in cases where we don&#39;t need control flow diamonds to check the callee.
      if (!callLinkStatus.couldTakeSlowPath() &amp;&amp; callLinkStatus.size() == 1) {
          return handleCallVariant(
              callTargetNode, result, callLinkStatus[0], registerOffset, thisArgument,
<span class="line-modified">!             argumentCountIncludingThis, nextIndex, kind, prediction, inliningBalance, nullptr, true);</span>
      }
  
      // We need to create some kind of switch over callee. For now we only do this if we believe that
      // we&#39;re in the top tier. We have two reasons for this: first, it provides us an opportunity to
      // do more detailed polyvariant/polymorphic profiling; and second, it reduces compile times in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2028,11 ***</span>
      // store the callee so that it will be accessible to all of the blocks we&#39;re about to create. We
      // get away with doing an immediate-set here because we wouldn&#39;t have performed any side effects
      // yet.
      VERBOSE_LOG(&quot;Register offset: &quot;, registerOffset);
      VirtualRegister calleeReg(registerOffset + CallFrameSlot::callee);
<span class="line-modified">!     calleeReg = m_inlineStackTop-&gt;remapOperand(calleeReg);</span>
      VERBOSE_LOG(&quot;Callee is going to be &quot;, calleeReg, &quot;\n&quot;);
      setDirect(calleeReg, callTargetNode, ImmediateSetWithFlush);
  
      // It&#39;s OK to exit right now, even though we set some locals. That&#39;s because those locals are not
      // user-visible.
<span class="line-new-header">--- 2107,11 ---</span>
      // store the callee so that it will be accessible to all of the blocks we&#39;re about to create. We
      // get away with doing an immediate-set here because we wouldn&#39;t have performed any side effects
      // yet.
      VERBOSE_LOG(&quot;Register offset: &quot;, registerOffset);
      VirtualRegister calleeReg(registerOffset + CallFrameSlot::callee);
<span class="line-modified">!     calleeReg = m_inlineStackTop-&gt;remapOperand(calleeReg).virtualRegister();</span>
      VERBOSE_LOG(&quot;Callee is going to be &quot;, calleeReg, &quot;\n&quot;);
      setDirect(calleeReg, callTargetNode, ImmediateSetWithFlush);
  
      // It&#39;s OK to exit right now, even though we set some locals. That&#39;s because those locals are not
      // user-visible.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2050,13 ***</span>
      // We may force this true if we give up on inlining any of the edges.
      bool couldTakeSlowPath = callLinkStatus.couldTakeSlowPath();
  
      VERBOSE_LOG(&quot;About to loop over functions at &quot;, currentCodeOrigin(), &quot;.\n&quot;);
  
<span class="line-modified">!     unsigned oldOffset = m_currentIndex;</span>
      for (unsigned i = 0; i &lt; callLinkStatus.size(); ++i) {
<span class="line-modified">!         m_currentIndex = oldOffset;</span>
          BasicBlock* calleeEntryBlock = allocateUntargetableBlock();
          m_currentBlock = calleeEntryBlock;
          prepareToParseBlock();
  
          // At the top of each switch case, we can exit.
<span class="line-new-header">--- 2129,13 ---</span>
      // We may force this true if we give up on inlining any of the edges.
      bool couldTakeSlowPath = callLinkStatus.couldTakeSlowPath();
  
      VERBOSE_LOG(&quot;About to loop over functions at &quot;, currentCodeOrigin(), &quot;.\n&quot;);
  
<span class="line-modified">!     BytecodeIndex oldIndex = m_currentIndex;</span>
      for (unsigned i = 0; i &lt; callLinkStatus.size(); ++i) {
<span class="line-modified">!         m_currentIndex = oldIndex;</span>
          BasicBlock* calleeEntryBlock = allocateUntargetableBlock();
          m_currentBlock = calleeEntryBlock;
          prepareToParseBlock();
  
          // At the top of each switch case, we can exit.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2064,11 ***</span>
  
          Node* myCallTargetNode = getDirect(calleeReg);
  
          auto inliningResult = handleCallVariant(
              myCallTargetNode, result, callLinkStatus[i], registerOffset,
<span class="line-modified">!             thisArgument, argumentCountIncludingThis, nextOffset, kind, prediction,</span>
              inliningBalance, continuationBlock, false);
  
          if (inliningResult == CallOptimizationResult::DidNothing) {
              // That failed so we let the block die. Nothing interesting should have been added to
              // the block. We also give up on inlining any of the (less frequent) callees.
<span class="line-new-header">--- 2143,11 ---</span>
  
          Node* myCallTargetNode = getDirect(calleeReg);
  
          auto inliningResult = handleCallVariant(
              myCallTargetNode, result, callLinkStatus[i], registerOffset,
<span class="line-modified">!             thisArgument, argumentCountIncludingThis, nextIndex, kind, prediction,</span>
              inliningBalance, continuationBlock, false);
  
          if (inliningResult == CallOptimizationResult::DidNothing) {
              // That failed so we let the block die. Nothing interesting should have been added to
              // the block. We also give up on inlining any of the (less frequent) callees.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2093,11 ***</span>
          VERBOSE_LOG(&quot;Finished optimizing &quot;, callLinkStatus[i], &quot; at &quot;, currentCodeOrigin(), &quot;.\n&quot;);
      }
  
      // Slow path block
      m_currentBlock = allocateUntargetableBlock();
<span class="line-modified">!     m_currentIndex = oldOffset;</span>
      m_exitOK = true;
      data.fallThrough = BranchTarget(m_currentBlock);
      prepareToParseBlock();
      Node* myCallTargetNode = getDirect(calleeReg);
      if (couldTakeSlowPath) {
<span class="line-new-header">--- 2172,11 ---</span>
          VERBOSE_LOG(&quot;Finished optimizing &quot;, callLinkStatus[i], &quot; at &quot;, currentCodeOrigin(), &quot;.\n&quot;);
      }
  
      // Slow path block
      m_currentBlock = allocateUntargetableBlock();
<span class="line-modified">!     m_currentIndex = oldIndex;</span>
      m_exitOK = true;
      data.fallThrough = BranchTarget(m_currentBlock);
      prepareToParseBlock();
      Node* myCallTargetNode = getDirect(calleeReg);
      if (couldTakeSlowPath) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2113,11 ***</span>
          if (result.isValid())
              set(result, addToGraph(BottomValue));
          VERBOSE_LOG(&quot;couldTakeSlowPath was false\n&quot;);
      }
  
<span class="line-modified">!     m_currentIndex = nextOffset;</span>
      m_exitOK = true; // Origin changed, so it&#39;s fine to exit again.
      processSetLocalQueue();
  
      if (Node* terminal = m_currentBlock-&gt;terminal())
          ASSERT_UNUSED(terminal, terminal-&gt;op() == TailCall || terminal-&gt;op() == TailCallVarargs || terminal-&gt;op() == TailCallForwardVarargs);
<span class="line-new-header">--- 2192,11 ---</span>
          if (result.isValid())
              set(result, addToGraph(BottomValue));
          VERBOSE_LOG(&quot;couldTakeSlowPath was false\n&quot;);
      }
  
<span class="line-modified">!     m_currentIndex = nextIndex;</span>
      m_exitOK = true; // Origin changed, so it&#39;s fine to exit again.
      processSetLocalQueue();
  
      if (Node* terminal = m_currentBlock-&gt;terminal())
          ASSERT_UNUSED(terminal, terminal-&gt;op() == TailCall || terminal-&gt;op() == TailCallVarargs || terminal-&gt;op() == TailCallForwardVarargs);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2125,11 ***</span>
          addJumpTo(continuationBlock);
      }
  
      prepareToParseBlock();
  
<span class="line-modified">!     m_currentIndex = oldOffset;</span>
      m_currentBlock = continuationBlock;
      m_exitOK = true;
  
      VERBOSE_LOG(&quot;Done inlining (hard).\nStack: &quot;, currentCodeOrigin(), &quot;\n&quot;);
      return CallOptimizationResult::Inlined;
<span class="line-new-header">--- 2204,11 ---</span>
          addJumpTo(continuationBlock);
      }
  
      prepareToParseBlock();
  
<span class="line-modified">!     m_currentIndex = oldIndex;</span>
      m_currentBlock = continuationBlock;
      m_exitOK = true;
  
      VERBOSE_LOG(&quot;Done inlining (hard).\nStack: &quot;, currentCodeOrigin(), &quot;\n&quot;);
      return CallOptimizationResult::Inlined;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2147,19 ***</span>
          return true;
      }
  
      if (argumentCountIncludingThis == 2) {
          insertChecks();
<span class="line-modified">!         Node* resultNode = get(VirtualRegister(virtualRegisterForArgument(1, registerOffset)));</span>
          addToGraph(Phantom, Edge(resultNode, NumberUse));
          set(result, resultNode);
          return true;
      }
  
      if (argumentCountIncludingThis == 3) {
          insertChecks();
<span class="line-modified">!         set(result, addToGraph(op, get(virtualRegisterForArgument(1, registerOffset)), get(virtualRegisterForArgument(2, registerOffset))));</span>
          return true;
      }
  
      // Don&#39;t handle &gt;=3 arguments for now.
      return false;
<span class="line-new-header">--- 2226,19 ---</span>
          return true;
      }
  
      if (argumentCountIncludingThis == 2) {
          insertChecks();
<span class="line-modified">!         Node* resultNode = get(VirtualRegister(virtualRegisterForArgumentIncludingThis(1, registerOffset)));</span>
          addToGraph(Phantom, Edge(resultNode, NumberUse));
          set(result, resultNode);
          return true;
      }
  
      if (argumentCountIncludingThis == 3) {
          insertChecks();
<span class="line-modified">!         set(result, addToGraph(op, get(virtualRegisterForArgumentIncludingThis(1, registerOffset)), get(virtualRegisterForArgumentIncludingThis(2, registerOffset))));</span>
          return true;
      }
  
      // Don&#39;t handle &gt;=3 arguments for now.
      return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2203,11 ***</span>
  
              if (!MacroAssembler::supportsFloatingPointAbs())
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* node = addToGraph(ArithAbs, get(virtualRegisterForArgument(1, registerOffset)));</span>
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, Overflow))
                  node-&gt;mergeFlags(NodeMayOverflowInt32InDFG);
              setResult(node);
              return true;
          }
<span class="line-new-header">--- 2282,11 ---</span>
  
              if (!MacroAssembler::supportsFloatingPointAbs())
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* node = addToGraph(ArithAbs, get(virtualRegisterForArgumentIncludingThis(1, registerOffset)));</span>
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, Overflow))
                  node-&gt;mergeFlags(NodeMayOverflowInt32InDFG);
              setResult(node);
              return true;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2240,11 ***</span>
  #undef DFG_ARITH_UNARY
              default:
                  RELEASE_ASSERT_NOT_REACHED();
              }
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(ArithUnary, OpInfo(static_cast&lt;std::underlying_type&lt;Arith::UnaryType&gt;::type&gt;(type)), get(virtualRegisterForArgument(1, registerOffset))));</span>
              return true;
          }
  
          case FRoundIntrinsic:
          case SqrtIntrinsic: {
<span class="line-new-header">--- 2319,11 ---</span>
  #undef DFG_ARITH_UNARY
              default:
                  RELEASE_ASSERT_NOT_REACHED();
              }
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(ArithUnary, OpInfo(static_cast&lt;std::underlying_type&lt;Arith::UnaryType&gt;::type&gt;(type)), get(virtualRegisterForArgumentIncludingThis(1, registerOffset))));</span>
              return true;
          }
  
          case FRoundIntrinsic:
          case SqrtIntrinsic: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2264,11 ***</span>
                  break;
              default:
                  RELEASE_ASSERT_NOT_REACHED();
              }
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(nodeType, get(virtualRegisterForArgument(1, registerOffset))));</span>
              return true;
          }
  
          case PowIntrinsic: {
              if (argumentCountIncludingThis &lt; 3) {
<span class="line-new-header">--- 2343,11 ---</span>
                  break;
              default:
                  RELEASE_ASSERT_NOT_REACHED();
              }
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(nodeType, get(virtualRegisterForArgumentIncludingThis(1, registerOffset))));</span>
              return true;
          }
  
          case PowIntrinsic: {
              if (argumentCountIncludingThis &lt; 3) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2276,24 ***</span>
                  insertChecks();
                  setResult(addToGraph(JSConstant, OpInfo(m_constantNaN)));
                  return true;
              }
              insertChecks();
<span class="line-modified">!             VirtualRegister xOperand = virtualRegisterForArgument(1, registerOffset);</span>
<span class="line-modified">!             VirtualRegister yOperand = virtualRegisterForArgument(2, registerOffset);</span>
              setResult(addToGraph(ArithPow, get(xOperand), get(yOperand)));
              return true;
          }
  
<span class="line-modified">!         case ArrayPushIntrinsic: {</span>
<span class="line-modified">! #if USE(JSVALUE32_64)</span>
<span class="line-modified">!             if (isX86()) {</span>
<span class="line-modified">!                 if (argumentCountIncludingThis &gt; 2)</span>
<span class="line-modified">!                     return false;</span>
              }
<span class="line-removed">- #endif</span>
  
              if (static_cast&lt;unsigned&gt;(argumentCountIncludingThis) &gt;= MIN_SPARSE_ARRAY_INDEX)
                  return false;
  
              ArrayMode arrayMode = getArrayMode(Array::Write);
              if (!arrayMode.isJSArray())
<span class="line-new-header">--- 2355,74 ---</span>
                  insertChecks();
                  setResult(addToGraph(JSConstant, OpInfo(m_constantNaN)));
                  return true;
              }
              insertChecks();
<span class="line-modified">!             VirtualRegister xOperand = virtualRegisterForArgumentIncludingThis(1, registerOffset);</span>
<span class="line-modified">!             VirtualRegister yOperand = virtualRegisterForArgumentIncludingThis(2, registerOffset);</span>
              setResult(addToGraph(ArithPow, get(xOperand), get(yOperand)));
              return true;
          }
  
<span class="line-modified">!         case TypedArrayEntriesIntrinsic:</span>
<span class="line-modified">!         case TypedArrayKeysIntrinsic:</span>
<span class="line-modified">!         case TypedArrayValuesIntrinsic: {</span>
<span class="line-modified">!             if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadIndexingType)</span>
<span class="line-modified">!                 || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             ArrayMode mode = getArrayMode(Array::Read);</span>
<span class="line-added">+             if (!mode.isSomeTypedArrayView())</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             addToGraph(CheckArray, OpInfo(mode.asWord()), get(virtualRegisterForArgumentIncludingThis(0, registerOffset)));</span>
<span class="line-added">+             addToGraph(CheckNeutered, get(virtualRegisterForArgumentIncludingThis(0, registerOffset)));</span>
<span class="line-added">+             FALLTHROUGH;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case ArrayEntriesIntrinsic:</span>
<span class="line-added">+         case ArrayKeysIntrinsic:</span>
<span class="line-added">+         case ArrayValuesIntrinsic: {</span>
<span class="line-added">+             insertChecks();</span>
<span class="line-added">+ </span>
<span class="line-added">+             IterationKind kind;</span>
<span class="line-added">+             switch (intrinsic) {</span>
<span class="line-added">+             case ArrayValuesIntrinsic:</span>
<span class="line-added">+             case TypedArrayValuesIntrinsic:</span>
<span class="line-added">+                 kind = IterationKind::Values;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case ArrayKeysIntrinsic:</span>
<span class="line-added">+             case TypedArrayKeysIntrinsic:</span>
<span class="line-added">+                 kind = IterationKind::Keys;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case ArrayEntriesIntrinsic:</span>
<span class="line-added">+             case TypedArrayEntriesIntrinsic:</span>
<span class="line-added">+                 kind = IterationKind::Entries;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+                 break;</span>
              }
  
<span class="line-added">+             // Add the constant before exit becomes invalid because we may want to insert (redundant) checks on it in Fixup.</span>
<span class="line-added">+             Node* kindNode = jsConstant(jsNumber(static_cast&lt;uint32_t&gt;(kind)));</span>
<span class="line-added">+ </span>
<span class="line-added">+             // We don&#39;t have an existing error string.</span>
<span class="line-added">+             unsigned errorStringIndex = UINT32_MAX;</span>
<span class="line-added">+             Node* object = addToGraph(ToObject, OpInfo(errorStringIndex), OpInfo(SpecNone), get(virtualRegisterForArgumentIncludingThis(0, registerOffset)));</span>
<span class="line-added">+ </span>
<span class="line-added">+             JSGlobalObject* globalObject = m_graph.globalObjectFor(currentNodeOrigin().semantic);</span>
<span class="line-added">+             Node* iterator = addToGraph(NewArrayIterator, OpInfo(m_graph.registerStructure(globalObject-&gt;arrayIteratorStructure())));</span>
<span class="line-added">+ </span>
<span class="line-added">+             addToGraph(PutInternalField, OpInfo(static_cast&lt;uint32_t&gt;(JSArrayIterator::Field::IteratedObject)), iterator, object);</span>
<span class="line-added">+             addToGraph(PutInternalField, OpInfo(static_cast&lt;uint32_t&gt;(JSArrayIterator::Field::Kind)), iterator, kindNode);</span>
<span class="line-added">+ </span>
<span class="line-added">+             setResult(iterator);</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case ArrayPushIntrinsic: {</span>
              if (static_cast&lt;unsigned&gt;(argumentCountIncludingThis) &gt;= MIN_SPARSE_ARRAY_INDEX)
                  return false;
  
              ArrayMode arrayMode = getArrayMode(Array::Write);
              if (!arrayMode.isJSArray())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2305,11 ***</span>
              case Array::ArrayStorage: {
                  insertChecks();
  
                  addVarArgChild(nullptr); // For storage.
                  for (int i = 0; i &lt; argumentCountIncludingThis; ++i)
<span class="line-modified">!                     addVarArgChild(get(virtualRegisterForArgument(i, registerOffset)));</span>
                  Node* arrayPush = addToGraph(Node::VarArg, ArrayPush, OpInfo(arrayMode.asWord()), OpInfo(prediction));
                  setResult(arrayPush);
                  return true;
              }
  
<span class="line-new-header">--- 2434,11 ---</span>
              case Array::ArrayStorage: {
                  insertChecks();
  
                  addVarArgChild(nullptr); // For storage.
                  for (int i = 0; i &lt; argumentCountIncludingThis; ++i)
<span class="line-modified">!                     addVarArgChild(get(virtualRegisterForArgumentIncludingThis(i, registerOffset)));</span>
                  Node* arrayPush = addToGraph(Node::VarArg, ArrayPush, OpInfo(arrayMode.asWord()), OpInfo(prediction));
                  setResult(arrayPush);
                  return true;
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2317,16 ***</span>
                  return false;
              }
          }
  
          case ArraySliceIntrinsic: {
<span class="line-removed">- #if USE(JSVALUE32_64)</span>
<span class="line-removed">-             if (isX86()) {</span>
<span class="line-removed">-                 // There aren&#39;t enough registers for this to be done easily.</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- #endif</span>
              if (argumentCountIncludingThis &lt; 1)
                  return false;
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadConstantCache)
                  || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCache))
<span class="line-new-header">--- 2446,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2361,11 ***</span>
                      m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
                      m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
  
                      insertChecks();
  
<span class="line-modified">!                     Node* array = get(virtualRegisterForArgument(0, registerOffset));</span>
                      // We do a few things here to prove that we aren&#39;t skipping doing side-effects in an observable way:
                      // 1. We ensure that the &quot;constructor&quot; property hasn&#39;t been changed (because the observable
                      // effects of slice require that we perform a Get(array, &quot;constructor&quot;) and we can skip
                      // that if we&#39;re an original array structure. (We can relax this in the future by using
                      // TryGetById and CheckCell).
<span class="line-new-header">--- 2484,11 ---</span>
                      m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
                      m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
  
                      insertChecks();
  
<span class="line-modified">!                     Node* array = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
                      // We do a few things here to prove that we aren&#39;t skipping doing side-effects in an observable way:
                      // 1. We ensure that the &quot;constructor&quot; property hasn&#39;t been changed (because the observable
                      // effects of slice require that we perform a Get(array, &quot;constructor&quot;) and we can skip
                      // that if we&#39;re an original array structure. (We can relax this in the future by using
                      // TryGetById and CheckCell).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2389,13 ***</span>
                      structureSet.add(globalObject-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithDouble));
                      addToGraph(CheckStructure, OpInfo(m_graph.addStructureSet(structureSet)), array);
  
                      addVarArgChild(array);
                      if (argumentCountIncludingThis &gt;= 2)
<span class="line-modified">!                         addVarArgChild(get(virtualRegisterForArgument(1, registerOffset))); // Start index.</span>
                      if (argumentCountIncludingThis &gt;= 3)
<span class="line-modified">!                         addVarArgChild(get(virtualRegisterForArgument(2, registerOffset))); // End index.</span>
                      addVarArgChild(addToGraph(GetButterfly, array));
  
                      Node* arraySlice = addToGraph(Node::VarArg, ArraySlice, OpInfo(), OpInfo());
                      setResult(arraySlice);
                      return true;
<span class="line-new-header">--- 2512,13 ---</span>
                      structureSet.add(globalObject-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithDouble));
                      addToGraph(CheckStructure, OpInfo(m_graph.addStructureSet(structureSet)), array);
  
                      addVarArgChild(array);
                      if (argumentCountIncludingThis &gt;= 2)
<span class="line-modified">!                         addVarArgChild(get(virtualRegisterForArgumentIncludingThis(1, registerOffset))); // Start index.</span>
                      if (argumentCountIncludingThis &gt;= 3)
<span class="line-modified">!                         addVarArgChild(get(virtualRegisterForArgumentIncludingThis(2, registerOffset))); // End index.</span>
                      addVarArgChild(addToGraph(GetButterfly, array));
  
                      Node* arraySlice = addToGraph(Node::VarArg, ArraySlice, OpInfo(), OpInfo());
                      setResult(arraySlice);
                      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2450,15 ***</span>
                      m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
                      m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
  
                      insertChecks();
  
<span class="line-modified">!                     Node* array = get(virtualRegisterForArgument(0, registerOffset));</span>
                      addVarArgChild(array);
<span class="line-modified">!                     addVarArgChild(get(virtualRegisterForArgument(1, registerOffset))); // Search element.</span>
                      if (argumentCountIncludingThis &gt;= 3)
<span class="line-modified">!                         addVarArgChild(get(virtualRegisterForArgument(2, registerOffset))); // Start index.</span>
                      addVarArgChild(nullptr);
  
                      Node* node = addToGraph(Node::VarArg, ArrayIndexOf, OpInfo(arrayMode.asWord()), OpInfo());
                      setResult(node);
                      return true;
<span class="line-new-header">--- 2573,15 ---</span>
                      m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
                      m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
  
                      insertChecks();
  
<span class="line-modified">!                     Node* array = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
                      addVarArgChild(array);
<span class="line-modified">!                     addVarArgChild(get(virtualRegisterForArgumentIncludingThis(1, registerOffset))); // Search element.</span>
                      if (argumentCountIncludingThis &gt;= 3)
<span class="line-modified">!                         addVarArgChild(get(virtualRegisterForArgumentIncludingThis(2, registerOffset))); // Start index.</span>
                      addVarArgChild(nullptr);
  
                      Node* node = addToGraph(Node::VarArg, ArrayIndexOf, OpInfo(arrayMode.asWord()), OpInfo());
                      setResult(node);
                      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2474,23 ***</span>
              return false;
  
          }
  
          case ArrayPopIntrinsic: {
<span class="line-removed">-             if (argumentCountIncludingThis != 1)</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">- </span>
              ArrayMode arrayMode = getArrayMode(Array::Write);
              if (!arrayMode.isJSArray())
                  return false;
              switch (arrayMode.type()) {
              case Array::Int32:
              case Array::Double:
              case Array::Contiguous:
              case Array::ArrayStorage: {
                  insertChecks();
<span class="line-modified">!                 Node* arrayPop = addToGraph(ArrayPop, OpInfo(arrayMode.asWord()), OpInfo(prediction), get(virtualRegisterForArgument(0, registerOffset)));</span>
                  setResult(arrayPop);
                  return true;
              }
  
              default:
<span class="line-new-header">--- 2597,20 ---</span>
              return false;
  
          }
  
          case ArrayPopIntrinsic: {
              ArrayMode arrayMode = getArrayMode(Array::Write);
              if (!arrayMode.isJSArray())
                  return false;
              switch (arrayMode.type()) {
              case Array::Int32:
              case Array::Double:
              case Array::Contiguous:
              case Array::ArrayStorage: {
                  insertChecks();
<span class="line-modified">!                 Node* arrayPop = addToGraph(ArrayPop, OpInfo(arrayMode.asWord()), OpInfo(prediction), get(virtualRegisterForArgumentIncludingThis(0, registerOffset)));</span>
                  setResult(arrayPop);
                  return true;
              }
  
              default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2568,11 ***</span>
  
              insertChecks();
  
              Vector&lt;Node*, 3&gt; args;
              for (unsigned i = 0; i &lt; numArgs; ++i)
<span class="line-modified">!                 args.append(get(virtualRegisterForArgument(1 + i, registerOffset)));</span>
  
              Node* resultNode;
              if (numArgs + 1 &lt;= 3) {
                  while (args.size() &lt; 3)
                      args.append(nullptr);
<span class="line-new-header">--- 2688,11 ---</span>
  
              insertChecks();
  
              Vector&lt;Node*, 3&gt; args;
              for (unsigned i = 0; i &lt; numArgs; ++i)
<span class="line-modified">!                 args.append(get(virtualRegisterForArgumentIncludingThis(1 + i, registerOffset)));</span>
  
              Node* resultNode;
              if (numArgs + 1 &lt;= 3) {
                  while (args.size() &lt; 3)
                      args.append(nullptr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2594,85 ***</span>
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCell) || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             VirtualRegister valueOperand = virtualRegisterForArgument(1, registerOffset);</span>
              Node* parseInt;
              if (argumentCountIncludingThis == 2)
                  parseInt = addToGraph(ParseInt, OpInfo(), OpInfo(prediction), get(valueOperand));
              else {
                  ASSERT(argumentCountIncludingThis &gt; 2);
<span class="line-modified">!                 VirtualRegister radixOperand = virtualRegisterForArgument(2, registerOffset);</span>
                  parseInt = addToGraph(ParseInt, OpInfo(), OpInfo(prediction), get(valueOperand), get(radixOperand));
              }
              setResult(parseInt);
              return true;
          }
  
          case CharCodeAtIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             VirtualRegister thisOperand = virtualRegisterForArgument(0, registerOffset);</span>
<span class="line-modified">!             VirtualRegister indexOperand = virtualRegisterForArgument(1, registerOffset);</span>
              Node* charCode = addToGraph(StringCharCodeAt, OpInfo(ArrayMode(Array::String, Array::Read).asWord()), get(thisOperand), get(indexOperand));
  
              setResult(charCode);
              return true;
          }
  
          case CharAtIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             VirtualRegister thisOperand = virtualRegisterForArgument(0, registerOffset);</span>
<span class="line-modified">!             VirtualRegister indexOperand = virtualRegisterForArgument(1, registerOffset);</span>
              Node* charCode = addToGraph(StringCharAt, OpInfo(ArrayMode(Array::String, Array::Read).asWord()), get(thisOperand), get(indexOperand));
  
              setResult(charCode);
              return true;
          }
          case Clz32Intrinsic: {
              insertChecks();
              if (argumentCountIncludingThis == 1)
                  setResult(addToGraph(JSConstant, OpInfo(m_graph.freeze(jsNumber(32)))));
              else {
<span class="line-modified">!                 Node* operand = get(virtualRegisterForArgument(1, registerOffset));</span>
                  setResult(addToGraph(ArithClz32, operand));
              }
              return true;
          }
          case FromCharCodeIntrinsic: {
              if (argumentCountIncludingThis != 2)
                  return false;
  
              insertChecks();
<span class="line-modified">!             VirtualRegister indexOperand = virtualRegisterForArgument(1, registerOffset);</span>
              Node* charCode = addToGraph(StringFromCharCode, get(indexOperand));
  
              setResult(charCode);
  
              return true;
          }
  
          case RegExpExecIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* regExpExec = addToGraph(RegExpExec, OpInfo(0), OpInfo(prediction), addToGraph(GetGlobalObject, callee), get(virtualRegisterForArgument(0, registerOffset)), get(virtualRegisterForArgument(1, registerOffset)));</span>
              setResult(regExpExec);
  
              return true;
          }
  
          case RegExpTestIntrinsic:
          case RegExpTestFastIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              if (intrinsic == RegExpTestIntrinsic) {
                  // Don&#39;t inline intrinsic if we exited due to one of the primordial RegExp checks failing.
                  if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCell))
<span class="line-new-header">--- 2714,114 ---</span>
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCell) || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             VirtualRegister valueOperand = virtualRegisterForArgumentIncludingThis(1, registerOffset);</span>
              Node* parseInt;
              if (argumentCountIncludingThis == 2)
                  parseInt = addToGraph(ParseInt, OpInfo(), OpInfo(prediction), get(valueOperand));
              else {
                  ASSERT(argumentCountIncludingThis &gt; 2);
<span class="line-modified">!                 VirtualRegister radixOperand = virtualRegisterForArgumentIncludingThis(2, registerOffset);</span>
                  parseInt = addToGraph(ParseInt, OpInfo(), OpInfo(prediction), get(valueOperand), get(radixOperand));
              }
              setResult(parseInt);
              return true;
          }
  
          case CharCodeAtIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, Uncountable) || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             VirtualRegister thisOperand = virtualRegisterForArgumentIncludingThis(0, registerOffset);</span>
<span class="line-modified">!             VirtualRegister indexOperand = virtualRegisterForArgumentIncludingThis(1, registerOffset);</span>
              Node* charCode = addToGraph(StringCharCodeAt, OpInfo(ArrayMode(Array::String, Array::Read).asWord()), get(thisOperand), get(indexOperand));
  
              setResult(charCode);
              return true;
          }
  
<span class="line-added">+         case StringPrototypeCodePointAtIntrinsic: {</span>
<span class="line-added">+             if (!is64Bit())</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (argumentCountIncludingThis &lt; 2)</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, Uncountable) || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             insertChecks();</span>
<span class="line-added">+             VirtualRegister thisOperand = virtualRegisterForArgumentIncludingThis(0, registerOffset);</span>
<span class="line-added">+             VirtualRegister indexOperand = virtualRegisterForArgumentIncludingThis(1, registerOffset);</span>
<span class="line-added">+             Node* result = addToGraph(StringCodePointAt, OpInfo(ArrayMode(Array::String, Array::Read).asWord()), get(thisOperand), get(indexOperand));</span>
<span class="line-added">+ </span>
<span class="line-added">+             setResult(result);</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case CharAtIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
<span class="line-added">+             if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // FIXME: String#charAt returns empty string when index is out-of-bounds, and this does not break the AI&#39;s claim.</span>
<span class="line-added">+             // Only FTL supports out-of-bounds version now. We should support out-of-bounds version even in DFG.</span>
<span class="line-added">+             // https://bugs.webkit.org/show_bug.cgi?id=201678</span>
<span class="line-added">+ </span>
              insertChecks();
<span class="line-modified">!             VirtualRegister thisOperand = virtualRegisterForArgumentIncludingThis(0, registerOffset);</span>
<span class="line-modified">!             VirtualRegister indexOperand = virtualRegisterForArgumentIncludingThis(1, registerOffset);</span>
              Node* charCode = addToGraph(StringCharAt, OpInfo(ArrayMode(Array::String, Array::Read).asWord()), get(thisOperand), get(indexOperand));
  
              setResult(charCode);
              return true;
          }
          case Clz32Intrinsic: {
              insertChecks();
              if (argumentCountIncludingThis == 1)
                  setResult(addToGraph(JSConstant, OpInfo(m_graph.freeze(jsNumber(32)))));
              else {
<span class="line-modified">!                 Node* operand = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
                  setResult(addToGraph(ArithClz32, operand));
              }
              return true;
          }
          case FromCharCodeIntrinsic: {
              if (argumentCountIncludingThis != 2)
                  return false;
  
              insertChecks();
<span class="line-modified">!             VirtualRegister indexOperand = virtualRegisterForArgumentIncludingThis(1, registerOffset);</span>
              Node* charCode = addToGraph(StringFromCharCode, get(indexOperand));
  
              setResult(charCode);
  
              return true;
          }
  
          case RegExpExecIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* regExpExec = addToGraph(RegExpExec, OpInfo(0), OpInfo(prediction), addToGraph(GetGlobalObject, callee), get(virtualRegisterForArgumentIncludingThis(0, registerOffset)), get(virtualRegisterForArgumentIncludingThis(1, registerOffset)));</span>
              setResult(regExpExec);
  
              return true;
          }
  
          case RegExpTestIntrinsic:
          case RegExpTestFastIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
              if (intrinsic == RegExpTestIntrinsic) {
                  // Don&#39;t inline intrinsic if we exited due to one of the primordial RegExp checks failing.
                  if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCell))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2698,11 ***</span>
                  // Check that RegExp.exec is still the primordial RegExp.prototype.exec
                  if (!isRegExpPropertySame(globalObject-&gt;regExpProtoExecFunction(), m_vm-&gt;propertyNames-&gt;exec.impl()))
                      return false;
  
                  // Check that regExpObject is actually a RegExp object.
<span class="line-modified">!                 Node* regExpObject = get(virtualRegisterForArgument(0, registerOffset));</span>
                  addToGraph(Check, Edge(regExpObject, RegExpObjectUse));
  
                  // Check that regExpObject&#39;s exec is actually the primodial RegExp.prototype.exec.
                  UniquedStringImpl* execPropertyID = m_vm-&gt;propertyNames-&gt;exec.impl();
                  unsigned execIndex = m_graph.identifiers().ensure(execPropertyID);
<span class="line-new-header">--- 2847,11 ---</span>
                  // Check that RegExp.exec is still the primordial RegExp.prototype.exec
                  if (!isRegExpPropertySame(globalObject-&gt;regExpProtoExecFunction(), m_vm-&gt;propertyNames-&gt;exec.impl()))
                      return false;
  
                  // Check that regExpObject is actually a RegExp object.
<span class="line-modified">!                 Node* regExpObject = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
                  addToGraph(Check, Edge(regExpObject, RegExpObjectUse));
  
                  // Check that regExpObject&#39;s exec is actually the primodial RegExp.prototype.exec.
                  UniquedStringImpl* execPropertyID = m_vm-&gt;propertyNames-&gt;exec.impl();
                  unsigned execIndex = m_graph.identifiers().ensure(execPropertyID);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2710,88 ***</span>
                  FrozenValue* regExpPrototypeExec = m_graph.freeze(globalObject-&gt;regExpProtoExecFunction());
                  addToGraph(CheckCell, OpInfo(regExpPrototypeExec), Edge(actualProperty, CellUse));
              }
  
              insertChecks();
<span class="line-modified">!             Node* regExpObject = get(virtualRegisterForArgument(0, registerOffset));</span>
<span class="line-modified">!             Node* regExpExec = addToGraph(RegExpTest, OpInfo(0), OpInfo(prediction), addToGraph(GetGlobalObject, callee), regExpObject, get(virtualRegisterForArgument(1, registerOffset)));</span>
              setResult(regExpExec);
  
              return true;
          }
  
          case RegExpMatchFastIntrinsic: {
              RELEASE_ASSERT(argumentCountIncludingThis == 2);
  
              insertChecks();
<span class="line-modified">!             Node* regExpMatch = addToGraph(RegExpMatchFast, OpInfo(0), OpInfo(prediction), addToGraph(GetGlobalObject, callee), get(virtualRegisterForArgument(0, registerOffset)), get(virtualRegisterForArgument(1, registerOffset)));</span>
              setResult(regExpMatch);
              return true;
          }
  
          case ObjectCreateIntrinsic: {
              if (argumentCountIncludingThis != 2)
                  return false;
  
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(ObjectCreate, get(virtualRegisterForArgument(1, registerOffset))));</span>
              return true;
          }
  
          case ObjectGetPrototypeOfIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(GetPrototypeOf, OpInfo(0), OpInfo(prediction), get(virtualRegisterForArgument(1, registerOffset))));</span>
              return true;
          }
  
          case ObjectIsIntrinsic: {
              if (argumentCountIncludingThis &lt; 3)
                  return false;
  
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(SameValue, get(virtualRegisterForArgument(1, registerOffset)), get(virtualRegisterForArgument(2, registerOffset))));</span>
              return true;
          }
  
          case ObjectKeysIntrinsic: {
              if (argumentCountIncludingThis &lt; 2)
                  return false;
  
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(ObjectKeys, get(virtualRegisterForArgument(1, registerOffset))));</span>
              return true;
          }
  
          case ReflectGetPrototypeOfIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(GetPrototypeOf, OpInfo(0), OpInfo(prediction), Edge(get(virtualRegisterForArgument(1, registerOffset)), ObjectUse)));</span>
              return true;
          }
  
          case IsTypedArrayViewIntrinsic: {
              ASSERT(argumentCountIncludingThis == 2);
  
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(IsTypedArrayView, OpInfo(prediction), get(virtualRegisterForArgument(1, registerOffset))));</span>
              return true;
          }
  
          case StringPrototypeValueOfIntrinsic: {
              insertChecks();
<span class="line-modified">!             Node* value = get(virtualRegisterForArgument(0, registerOffset));</span>
              setResult(addToGraph(StringValueOf, value));
              return true;
          }
  
          case StringPrototypeReplaceIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 3)</span>
                  return false;
  
              // Don&#39;t inline intrinsic if we exited due to &quot;search&quot; not being a RegExp or String object.
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
<span class="line-new-header">--- 2859,88 ---</span>
                  FrozenValue* regExpPrototypeExec = m_graph.freeze(globalObject-&gt;regExpProtoExecFunction());
                  addToGraph(CheckCell, OpInfo(regExpPrototypeExec), Edge(actualProperty, CellUse));
              }
  
              insertChecks();
<span class="line-modified">!             Node* regExpObject = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-modified">!             Node* regExpExec = addToGraph(RegExpTest, OpInfo(0), OpInfo(prediction), addToGraph(GetGlobalObject, callee), regExpObject, get(virtualRegisterForArgumentIncludingThis(1, registerOffset)));</span>
              setResult(regExpExec);
  
              return true;
          }
  
          case RegExpMatchFastIntrinsic: {
              RELEASE_ASSERT(argumentCountIncludingThis == 2);
  
              insertChecks();
<span class="line-modified">!             Node* regExpMatch = addToGraph(RegExpMatchFast, OpInfo(0), OpInfo(prediction), addToGraph(GetGlobalObject, callee), get(virtualRegisterForArgumentIncludingThis(0, registerOffset)), get(virtualRegisterForArgumentIncludingThis(1, registerOffset)));</span>
              setResult(regExpMatch);
              return true;
          }
  
          case ObjectCreateIntrinsic: {
              if (argumentCountIncludingThis != 2)
                  return false;
  
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(ObjectCreate, get(virtualRegisterForArgumentIncludingThis(1, registerOffset))));</span>
              return true;
          }
  
          case ObjectGetPrototypeOfIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(GetPrototypeOf, OpInfo(0), OpInfo(prediction), get(virtualRegisterForArgumentIncludingThis(1, registerOffset))));</span>
              return true;
          }
  
          case ObjectIsIntrinsic: {
              if (argumentCountIncludingThis &lt; 3)
                  return false;
  
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(SameValue, get(virtualRegisterForArgumentIncludingThis(1, registerOffset)), get(virtualRegisterForArgumentIncludingThis(2, registerOffset))));</span>
              return true;
          }
  
          case ObjectKeysIntrinsic: {
              if (argumentCountIncludingThis &lt; 2)
                  return false;
  
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(ObjectKeys, get(virtualRegisterForArgumentIncludingThis(1, registerOffset))));</span>
              return true;
          }
  
          case ReflectGetPrototypeOfIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(GetPrototypeOf, OpInfo(0), OpInfo(prediction), Edge(get(virtualRegisterForArgumentIncludingThis(1, registerOffset)), ObjectUse)));</span>
              return true;
          }
  
          case IsTypedArrayViewIntrinsic: {
              ASSERT(argumentCountIncludingThis == 2);
  
              insertChecks();
<span class="line-modified">!             setResult(addToGraph(IsTypedArrayView, OpInfo(prediction), get(virtualRegisterForArgumentIncludingThis(1, registerOffset))));</span>
              return true;
          }
  
          case StringPrototypeValueOfIntrinsic: {
              insertChecks();
<span class="line-modified">!             Node* value = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
              setResult(addToGraph(StringValueOf, value));
              return true;
          }
  
          case StringPrototypeReplaceIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 3)</span>
                  return false;
  
              // Don&#39;t inline intrinsic if we exited due to &quot;search&quot; not being a RegExp or String object.
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2833,21 ***</span>
              if (!isRegExpPropertySame(globalObject-&gt;regExpProtoSymbolReplaceFunction(), m_vm-&gt;propertyNames-&gt;replaceSymbol.impl()))
                  return false;
  
              insertChecks();
  
<span class="line-modified">!             Node* resultNode = addToGraph(StringReplace, OpInfo(0), OpInfo(prediction), get(virtualRegisterForArgument(0, registerOffset)), get(virtualRegisterForArgument(1, registerOffset)), get(virtualRegisterForArgument(2, registerOffset)));</span>
              setResult(resultNode);
              return true;
          }
  
          case StringPrototypeReplaceRegExpIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 3)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* resultNode = addToGraph(StringReplaceRegExp, OpInfo(0), OpInfo(prediction), get(virtualRegisterForArgument(0, registerOffset)), get(virtualRegisterForArgument(1, registerOffset)), get(virtualRegisterForArgument(2, registerOffset)));</span>
              setResult(resultNode);
              return true;
          }
  
          case RoundIntrinsic:
<span class="line-new-header">--- 2982,21 ---</span>
              if (!isRegExpPropertySame(globalObject-&gt;regExpProtoSymbolReplaceFunction(), m_vm-&gt;propertyNames-&gt;replaceSymbol.impl()))
                  return false;
  
              insertChecks();
  
<span class="line-modified">!             Node* resultNode = addToGraph(StringReplace, OpInfo(0), OpInfo(prediction), get(virtualRegisterForArgumentIncludingThis(0, registerOffset)), get(virtualRegisterForArgumentIncludingThis(1, registerOffset)), get(virtualRegisterForArgumentIncludingThis(2, registerOffset)));</span>
              setResult(resultNode);
              return true;
          }
  
          case StringPrototypeReplaceRegExpIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 3)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* resultNode = addToGraph(StringReplaceRegExp, OpInfo(0), OpInfo(prediction), get(virtualRegisterForArgumentIncludingThis(0, registerOffset)), get(virtualRegisterForArgumentIncludingThis(1, registerOffset)), get(virtualRegisterForArgumentIncludingThis(2, registerOffset)));</span>
              setResult(resultNode);
              return true;
          }
  
          case RoundIntrinsic:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2858,11 ***</span>
                  insertChecks();
                  setResult(addToGraph(JSConstant, OpInfo(m_constantNaN)));
                  return true;
              }
              insertChecks();
<span class="line-modified">!             Node* operand = get(virtualRegisterForArgument(1, registerOffset));</span>
              NodeType op;
              if (intrinsic == RoundIntrinsic)
                  op = ArithRound;
              else if (intrinsic == FloorIntrinsic)
                  op = ArithFloor;
<span class="line-new-header">--- 3007,11 ---</span>
                  insertChecks();
                  setResult(addToGraph(JSConstant, OpInfo(m_constantNaN)));
                  return true;
              }
              insertChecks();
<span class="line-modified">!             Node* operand = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              NodeType op;
              if (intrinsic == RoundIntrinsic)
                  op = ArithRound;
              else if (intrinsic == FloorIntrinsic)
                  op = ArithFloor;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2875,24 ***</span>
              Node* roundNode = addToGraph(op, OpInfo(0), OpInfo(prediction), operand);
              setResult(roundNode);
              return true;
          }
          case IMulIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 3)</span>
                  return false;
              insertChecks();
<span class="line-modified">!             VirtualRegister leftOperand = virtualRegisterForArgument(1, registerOffset);</span>
<span class="line-modified">!             VirtualRegister rightOperand = virtualRegisterForArgument(2, registerOffset);</span>
              Node* left = get(leftOperand);
              Node* right = get(rightOperand);
              setResult(addToGraph(ArithIMul, left, right));
              return true;
          }
  
          case RandomIntrinsic: {
<span class="line-removed">-             if (argumentCountIncludingThis != 1)</span>
<span class="line-removed">-                 return false;</span>
              insertChecks();
              setResult(addToGraph(ArithRandom));
              return true;
          }
  
<span class="line-new-header">--- 3024,22 ---</span>
              Node* roundNode = addToGraph(op, OpInfo(0), OpInfo(prediction), operand);
              setResult(roundNode);
              return true;
          }
          case IMulIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 3)</span>
                  return false;
              insertChecks();
<span class="line-modified">!             VirtualRegister leftOperand = virtualRegisterForArgumentIncludingThis(1, registerOffset);</span>
<span class="line-modified">!             VirtualRegister rightOperand = virtualRegisterForArgumentIncludingThis(2, registerOffset);</span>
              Node* left = get(leftOperand);
              Node* right = get(rightOperand);
              setResult(addToGraph(ArithIMul, left, right));
              return true;
          }
  
          case RandomIntrinsic: {
              insertChecks();
              setResult(addToGraph(ArithRandom));
              return true;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2922,63 ***</span>
          }
  
          case SetInt32HeapPredictionIntrinsic: {
              insertChecks();
              for (int i = 1; i &lt; argumentCountIncludingThis; ++i) {
<span class="line-modified">!                 Node* node = get(virtualRegisterForArgument(i, registerOffset));</span>
                  if (node-&gt;hasHeapPrediction())
                      node-&gt;setHeapPrediction(SpecInt32Only);
              }
              setResult(addToGraph(JSConstant, OpInfo(m_constantUndefined)));
              return true;
          }
  
          case CheckInt32Intrinsic: {
              insertChecks();
              for (int i = 1; i &lt; argumentCountIncludingThis; ++i) {
<span class="line-modified">!                 Node* node = get(virtualRegisterForArgument(i, registerOffset));</span>
                  addToGraph(Phantom, Edge(node, Int32Use));
              }
              setResult(jsConstant(jsBoolean(true)));
              return true;
          }
  
          case FiatInt52Intrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
              insertChecks();
<span class="line-modified">!             VirtualRegister operand = virtualRegisterForArgument(1, registerOffset);</span>
              if (enableInt52())
                  setResult(addToGraph(FiatInt52, get(operand)));
              else
                  setResult(get(operand));
              return true;
          }
  
          case JSMapGetIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* map = get(virtualRegisterForArgument(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgument(1, registerOffset));</span>
              Node* normalizedKey = addToGraph(NormalizeMapKey, key);
              Node* hash = addToGraph(MapHash, normalizedKey);
              Node* bucket = addToGraph(GetMapBucket, Edge(map, MapObjectUse), Edge(normalizedKey), Edge(hash));
              Node* resultNode = addToGraph(LoadValueFromMapBucket, OpInfo(BucketOwnerType::Map), OpInfo(prediction), bucket);
              setResult(resultNode);
              return true;
          }
  
          case JSSetHasIntrinsic:
          case JSMapHasIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* mapOrSet = get(virtualRegisterForArgument(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgument(1, registerOffset));</span>
              Node* normalizedKey = addToGraph(NormalizeMapKey, key);
              Node* hash = addToGraph(MapHash, normalizedKey);
              UseKind useKind = intrinsic == JSSetHasIntrinsic ? SetObjectUse : MapObjectUse;
              Node* bucket = addToGraph(GetMapBucket, OpInfo(0), Edge(mapOrSet, useKind), Edge(normalizedKey), Edge(hash));
              JSCell* sentinel = nullptr;
<span class="line-new-header">--- 3069,63 ---</span>
          }
  
          case SetInt32HeapPredictionIntrinsic: {
              insertChecks();
              for (int i = 1; i &lt; argumentCountIncludingThis; ++i) {
<span class="line-modified">!                 Node* node = get(virtualRegisterForArgumentIncludingThis(i, registerOffset));</span>
                  if (node-&gt;hasHeapPrediction())
                      node-&gt;setHeapPrediction(SpecInt32Only);
              }
              setResult(addToGraph(JSConstant, OpInfo(m_constantUndefined)));
              return true;
          }
  
          case CheckInt32Intrinsic: {
              insertChecks();
              for (int i = 1; i &lt; argumentCountIncludingThis; ++i) {
<span class="line-modified">!                 Node* node = get(virtualRegisterForArgumentIncludingThis(i, registerOffset));</span>
                  addToGraph(Phantom, Edge(node, Int32Use));
              }
              setResult(jsConstant(jsBoolean(true)));
              return true;
          }
  
          case FiatInt52Intrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
              insertChecks();
<span class="line-modified">!             VirtualRegister operand = virtualRegisterForArgumentIncludingThis(1, registerOffset);</span>
              if (enableInt52())
                  setResult(addToGraph(FiatInt52, get(operand)));
              else
                  setResult(get(operand));
              return true;
          }
  
          case JSMapGetIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* map = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              Node* normalizedKey = addToGraph(NormalizeMapKey, key);
              Node* hash = addToGraph(MapHash, normalizedKey);
              Node* bucket = addToGraph(GetMapBucket, Edge(map, MapObjectUse), Edge(normalizedKey), Edge(hash));
              Node* resultNode = addToGraph(LoadValueFromMapBucket, OpInfo(BucketOwnerType::Map), OpInfo(prediction), bucket);
              setResult(resultNode);
              return true;
          }
  
          case JSSetHasIntrinsic:
          case JSMapHasIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* mapOrSet = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              Node* normalizedKey = addToGraph(NormalizeMapKey, key);
              Node* hash = addToGraph(MapHash, normalizedKey);
              UseKind useKind = intrinsic == JSSetHasIntrinsic ? SetObjectUse : MapObjectUse;
              Node* bucket = addToGraph(GetMapBucket, OpInfo(0), Edge(mapOrSet, useKind), Edge(normalizedKey), Edge(hash));
              JSCell* sentinel = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2993,31 ***</span>
              setResult(resultNode);
              return true;
          }
  
          case JSSetAddIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* base = get(virtualRegisterForArgument(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgument(1, registerOffset));</span>
              Node* normalizedKey = addToGraph(NormalizeMapKey, key);
              Node* hash = addToGraph(MapHash, normalizedKey);
              addToGraph(SetAdd, base, normalizedKey, hash);
              setResult(base);
              return true;
          }
  
          case JSMapSetIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 3)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* base = get(virtualRegisterForArgument(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgument(1, registerOffset));</span>
<span class="line-modified">!             Node* value = get(virtualRegisterForArgument(2, registerOffset));</span>
  
              Node* normalizedKey = addToGraph(NormalizeMapKey, key);
              Node* hash = addToGraph(MapHash, normalizedKey);
  
              addVarArgChild(base);
<span class="line-new-header">--- 3140,31 ---</span>
              setResult(resultNode);
              return true;
          }
  
          case JSSetAddIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* base = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              Node* normalizedKey = addToGraph(NormalizeMapKey, key);
              Node* hash = addToGraph(MapHash, normalizedKey);
              addToGraph(SetAdd, base, normalizedKey, hash);
              setResult(base);
              return true;
          }
  
          case JSMapSetIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 3)</span>
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* base = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
<span class="line-modified">!             Node* value = get(virtualRegisterForArgumentIncludingThis(2, registerOffset));</span>
  
              Node* normalizedKey = addToGraph(NormalizeMapKey, key);
              Node* hash = addToGraph(MapHash, normalizedKey);
  
              addVarArgChild(base);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3032,11 ***</span>
          case JSSetBucketHeadIntrinsic:
          case JSMapBucketHeadIntrinsic: {
              ASSERT(argumentCountIncludingThis == 2);
  
              insertChecks();
<span class="line-modified">!             Node* map = get(virtualRegisterForArgument(1, registerOffset));</span>
              UseKind useKind = intrinsic == JSSetBucketHeadIntrinsic ? SetObjectUse : MapObjectUse;
              Node* resultNode = addToGraph(GetMapBucketHead, Edge(map, useKind));
              setResult(resultNode);
              return true;
          }
<span class="line-new-header">--- 3179,11 ---</span>
          case JSSetBucketHeadIntrinsic:
          case JSMapBucketHeadIntrinsic: {
              ASSERT(argumentCountIncludingThis == 2);
  
              insertChecks();
<span class="line-modified">!             Node* map = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              UseKind useKind = intrinsic == JSSetBucketHeadIntrinsic ? SetObjectUse : MapObjectUse;
              Node* resultNode = addToGraph(GetMapBucketHead, Edge(map, useKind));
              setResult(resultNode);
              return true;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3044,11 ***</span>
          case JSSetBucketNextIntrinsic:
          case JSMapBucketNextIntrinsic: {
              ASSERT(argumentCountIncludingThis == 2);
  
              insertChecks();
<span class="line-modified">!             Node* bucket = get(virtualRegisterForArgument(1, registerOffset));</span>
              BucketOwnerType type = intrinsic == JSSetBucketNextIntrinsic ? BucketOwnerType::Set : BucketOwnerType::Map;
              Node* resultNode = addToGraph(GetMapBucketNext, OpInfo(type), bucket);
              setResult(resultNode);
              return true;
          }
<span class="line-new-header">--- 3191,11 ---</span>
          case JSSetBucketNextIntrinsic:
          case JSMapBucketNextIntrinsic: {
              ASSERT(argumentCountIncludingThis == 2);
  
              insertChecks();
<span class="line-modified">!             Node* bucket = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              BucketOwnerType type = intrinsic == JSSetBucketNextIntrinsic ? BucketOwnerType::Set : BucketOwnerType::Map;
              Node* resultNode = addToGraph(GetMapBucketNext, OpInfo(type), bucket);
              setResult(resultNode);
              return true;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3056,56 ***</span>
          case JSSetBucketKeyIntrinsic:
          case JSMapBucketKeyIntrinsic: {
              ASSERT(argumentCountIncludingThis == 2);
  
              insertChecks();
<span class="line-modified">!             Node* bucket = get(virtualRegisterForArgument(1, registerOffset));</span>
              BucketOwnerType type = intrinsic == JSSetBucketKeyIntrinsic ? BucketOwnerType::Set : BucketOwnerType::Map;
              Node* resultNode = addToGraph(LoadKeyFromMapBucket, OpInfo(type), OpInfo(prediction), bucket);
              setResult(resultNode);
              return true;
          }
  
          case JSMapBucketValueIntrinsic: {
              ASSERT(argumentCountIncludingThis == 2);
  
              insertChecks();
<span class="line-modified">!             Node* bucket = get(virtualRegisterForArgument(1, registerOffset));</span>
              Node* resultNode = addToGraph(LoadValueFromMapBucket, OpInfo(BucketOwnerType::Map), OpInfo(prediction), bucket);
              setResult(resultNode);
              return true;
          }
  
          case JSWeakMapGetIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* map = get(virtualRegisterForArgument(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgument(1, registerOffset));</span>
              addToGraph(Check, Edge(key, ObjectUse));
              Node* hash = addToGraph(MapHash, key);
              Node* holder = addToGraph(WeakMapGet, Edge(map, WeakMapObjectUse), Edge(key, ObjectUse), Edge(hash, Int32Use));
              Node* resultNode = addToGraph(ExtractValueFromWeakMapGet, OpInfo(), OpInfo(prediction), holder);
  
              setResult(resultNode);
              return true;
          }
  
          case JSWeakMapHasIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* map = get(virtualRegisterForArgument(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgument(1, registerOffset));</span>
              addToGraph(Check, Edge(key, ObjectUse));
              Node* hash = addToGraph(MapHash, key);
              Node* holder = addToGraph(WeakMapGet, Edge(map, WeakMapObjectUse), Edge(key, ObjectUse), Edge(hash, Int32Use));
              Node* invertedResult = addToGraph(IsEmpty, holder);
              Node* resultNode = addToGraph(LogicalNot, invertedResult);
<span class="line-new-header">--- 3203,56 ---</span>
          case JSSetBucketKeyIntrinsic:
          case JSMapBucketKeyIntrinsic: {
              ASSERT(argumentCountIncludingThis == 2);
  
              insertChecks();
<span class="line-modified">!             Node* bucket = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              BucketOwnerType type = intrinsic == JSSetBucketKeyIntrinsic ? BucketOwnerType::Set : BucketOwnerType::Map;
              Node* resultNode = addToGraph(LoadKeyFromMapBucket, OpInfo(type), OpInfo(prediction), bucket);
              setResult(resultNode);
              return true;
          }
  
          case JSMapBucketValueIntrinsic: {
              ASSERT(argumentCountIncludingThis == 2);
  
              insertChecks();
<span class="line-modified">!             Node* bucket = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              Node* resultNode = addToGraph(LoadValueFromMapBucket, OpInfo(BucketOwnerType::Map), OpInfo(prediction), bucket);
              setResult(resultNode);
              return true;
          }
  
          case JSWeakMapGetIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* map = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              addToGraph(Check, Edge(key, ObjectUse));
              Node* hash = addToGraph(MapHash, key);
              Node* holder = addToGraph(WeakMapGet, Edge(map, WeakMapObjectUse), Edge(key, ObjectUse), Edge(hash, Int32Use));
              Node* resultNode = addToGraph(ExtractValueFromWeakMapGet, OpInfo(), OpInfo(prediction), holder);
  
              setResult(resultNode);
              return true;
          }
  
          case JSWeakMapHasIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* map = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              addToGraph(Check, Edge(key, ObjectUse));
              Node* hash = addToGraph(MapHash, key);
              Node* holder = addToGraph(WeakMapGet, Edge(map, WeakMapObjectUse), Edge(key, ObjectUse), Edge(hash, Int32Use));
              Node* invertedResult = addToGraph(IsEmpty, holder);
              Node* resultNode = addToGraph(LogicalNot, invertedResult);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3113,19 ***</span>
              setResult(resultNode);
              return true;
          }
  
          case JSWeakSetHasIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* map = get(virtualRegisterForArgument(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgument(1, registerOffset));</span>
              addToGraph(Check, Edge(key, ObjectUse));
              Node* hash = addToGraph(MapHash, key);
              Node* holder = addToGraph(WeakMapGet, Edge(map, WeakSetObjectUse), Edge(key, ObjectUse), Edge(hash, Int32Use));
              Node* invertedResult = addToGraph(IsEmpty, holder);
              Node* resultNode = addToGraph(LogicalNot, invertedResult);
<span class="line-new-header">--- 3260,19 ---</span>
              setResult(resultNode);
              return true;
          }
  
          case JSWeakSetHasIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* map = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              addToGraph(Check, Edge(key, ObjectUse));
              Node* hash = addToGraph(MapHash, key);
              Node* holder = addToGraph(WeakMapGet, Edge(map, WeakSetObjectUse), Edge(key, ObjectUse), Edge(hash, Int32Use));
              Node* invertedResult = addToGraph(IsEmpty, holder);
              Node* resultNode = addToGraph(LogicalNot, invertedResult);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3133,37 ***</span>
              setResult(resultNode);
              return true;
          }
  
          case JSWeakSetAddIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* base = get(virtualRegisterForArgument(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgument(1, registerOffset));</span>
              addToGraph(Check, Edge(key, ObjectUse));
              Node* hash = addToGraph(MapHash, key);
              addToGraph(WeakSetAdd, Edge(base, WeakSetObjectUse), Edge(key, ObjectUse), Edge(hash, Int32Use));
              setResult(base);
              return true;
          }
  
          case JSWeakMapSetIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 3)</span>
                  return false;
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* base = get(virtualRegisterForArgument(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgument(1, registerOffset));</span>
<span class="line-modified">!             Node* value = get(virtualRegisterForArgument(2, registerOffset));</span>
  
              addToGraph(Check, Edge(key, ObjectUse));
              Node* hash = addToGraph(MapHash, key);
  
              addVarArgChild(Edge(base, WeakMapObjectUse));
<span class="line-new-header">--- 3280,37 ---</span>
              setResult(resultNode);
              return true;
          }
  
          case JSWeakSetAddIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* base = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              addToGraph(Check, Edge(key, ObjectUse));
              Node* hash = addToGraph(MapHash, key);
              addToGraph(WeakSetAdd, Edge(base, WeakSetObjectUse), Edge(key, ObjectUse), Edge(hash, Int32Use));
              setResult(base);
              return true;
          }
  
          case JSWeakMapSetIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 3)</span>
                  return false;
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* base = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
<span class="line-modified">!             Node* value = get(virtualRegisterForArgumentIncludingThis(2, registerOffset));</span>
  
              addToGraph(Check, Edge(key, ObjectUse));
              Node* hash = addToGraph(MapHash, key);
  
              addVarArgChild(Edge(base, WeakMapObjectUse));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3173,10 ***</span>
<span class="line-new-header">--- 3320,45 ---</span>
              addToGraph(Node::VarArg, WeakMapSet, OpInfo(0), OpInfo(0));
              setResult(base);
              return true;
          }
  
<span class="line-added">+         case DatePrototypeGetTimeIntrinsic: {</span>
<span class="line-added">+             if (!is64Bit())</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             insertChecks();</span>
<span class="line-added">+             Node* base = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-added">+             setResult(addToGraph(DateGetTime, OpInfo(intrinsic), OpInfo(), base));</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case DatePrototypeGetFullYearIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetUTCFullYearIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetMonthIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetUTCMonthIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetDateIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetUTCDateIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetDayIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetUTCDayIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetHoursIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetUTCHoursIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetMinutesIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetUTCMinutesIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetSecondsIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetUTCSecondsIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetMillisecondsIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetUTCMillisecondsIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetTimezoneOffsetIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetYearIntrinsic: {</span>
<span class="line-added">+             if (!is64Bit())</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             insertChecks();</span>
<span class="line-added">+             Node* base = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-added">+             setResult(addToGraph(DateGetInt32OrNaN, OpInfo(intrinsic), OpInfo(prediction), base));</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case DataViewGetInt8:
          case DataViewGetUint8:
          case DataViewGetInt16:
          case DataViewGetUint16:
          case DataViewGetInt32:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3238,11 ***</span>
              Node* littleEndianChild = nullptr;
              if (byteSize &gt; 1) {
                  if (argumentCountIncludingThis &lt; 3)
                      isLittleEndian = FalseTriState;
                  else {
<span class="line-modified">!                     littleEndianChild = get(virtualRegisterForArgument(2, registerOffset));</span>
                      if (littleEndianChild-&gt;hasConstant()) {
                          JSValue constant = littleEndianChild-&gt;constant()-&gt;value();
                          if (constant) {
                              isLittleEndian = constant.pureToBoolean();
                              if (isLittleEndian != MixedTriState)
<span class="line-new-header">--- 3420,11 ---</span>
              Node* littleEndianChild = nullptr;
              if (byteSize &gt; 1) {
                  if (argumentCountIncludingThis &lt; 3)
                      isLittleEndian = FalseTriState;
                  else {
<span class="line-modified">!                     littleEndianChild = get(virtualRegisterForArgumentIncludingThis(2, registerOffset));</span>
                      if (littleEndianChild-&gt;hasConstant()) {
                          JSValue constant = littleEndianChild-&gt;constant()-&gt;value();
                          if (constant) {
                              isLittleEndian = constant.pureToBoolean();
                              if (isLittleEndian != MixedTriState)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3257,11 ***</span>
              data.isLittleEndian = isLittleEndian;
              data.isSigned = isSigned;
              data.byteSize = byteSize;
  
              setResult(
<span class="line-modified">!                 addToGraph(op, OpInfo(data.asQuadWord), OpInfo(prediction), get(virtualRegisterForArgument(0, registerOffset)), get(virtualRegisterForArgument(1, registerOffset)), littleEndianChild));</span>
              return true;
          }
  
          case DataViewSetInt8:
          case DataViewSetUint8:
<span class="line-new-header">--- 3439,11 ---</span>
              data.isLittleEndian = isLittleEndian;
              data.isSigned = isSigned;
              data.byteSize = byteSize;
  
              setResult(
<span class="line-modified">!                 addToGraph(op, OpInfo(data.asQuadWord), OpInfo(prediction), get(virtualRegisterForArgumentIncludingThis(0, registerOffset)), get(virtualRegisterForArgumentIncludingThis(1, registerOffset)), littleEndianChild));</span>
              return true;
          }
  
          case DataViewSetInt8:
          case DataViewSetUint8:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3323,11 ***</span>
              Node* littleEndianChild = nullptr;
              if (byteSize &gt; 1) {
                  if (argumentCountIncludingThis &lt; 4)
                      isLittleEndian = FalseTriState;
                  else {
<span class="line-modified">!                     littleEndianChild = get(virtualRegisterForArgument(3, registerOffset));</span>
                      if (littleEndianChild-&gt;hasConstant()) {
                          JSValue constant = littleEndianChild-&gt;constant()-&gt;value();
                          if (constant) {
                              isLittleEndian = constant.pureToBoolean();
                              if (isLittleEndian != MixedTriState)
<span class="line-new-header">--- 3505,11 ---</span>
              Node* littleEndianChild = nullptr;
              if (byteSize &gt; 1) {
                  if (argumentCountIncludingThis &lt; 4)
                      isLittleEndian = FalseTriState;
                  else {
<span class="line-modified">!                     littleEndianChild = get(virtualRegisterForArgumentIncludingThis(3, registerOffset));</span>
                      if (littleEndianChild-&gt;hasConstant()) {
                          JSValue constant = littleEndianChild-&gt;constant()-&gt;value();
                          if (constant) {
                              isLittleEndian = constant.pureToBoolean();
                              if (isLittleEndian != MixedTriState)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3342,22 ***</span>
              data.isLittleEndian = isLittleEndian;
              data.isSigned = isSigned;
              data.byteSize = byteSize;
              data.isFloatingPoint = isFloatingPoint;
  
<span class="line-modified">!             addVarArgChild(get(virtualRegisterForArgument(0, registerOffset)));</span>
<span class="line-modified">!             addVarArgChild(get(virtualRegisterForArgument(1, registerOffset)));</span>
<span class="line-modified">!             addVarArgChild(get(virtualRegisterForArgument(2, registerOffset)));</span>
              addVarArgChild(littleEndianChild);
  
              addToGraph(Node::VarArg, DataViewSet, OpInfo(data.asQuadWord), OpInfo());
              setResult(addToGraph(JSConstant, OpInfo(m_constantUndefined)));
              return true;
          }
  
          case HasOwnPropertyIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis != 2)</span>
                  return false;
  
              // This can be racy, that&#39;s fine. We know that once we observe that this is created,
              // that it will never be destroyed until the VM is destroyed. It&#39;s unlikely that
              // we&#39;d ever get to the point where we inline this as an intrinsic without the
<span class="line-new-header">--- 3524,22 ---</span>
              data.isLittleEndian = isLittleEndian;
              data.isSigned = isSigned;
              data.byteSize = byteSize;
              data.isFloatingPoint = isFloatingPoint;
  
<span class="line-modified">!             addVarArgChild(get(virtualRegisterForArgumentIncludingThis(0, registerOffset)));</span>
<span class="line-modified">!             addVarArgChild(get(virtualRegisterForArgumentIncludingThis(1, registerOffset)));</span>
<span class="line-modified">!             addVarArgChild(get(virtualRegisterForArgumentIncludingThis(2, registerOffset)));</span>
              addVarArgChild(littleEndianChild);
  
              addToGraph(Node::VarArg, DataViewSet, OpInfo(data.asQuadWord), OpInfo());
              setResult(addToGraph(JSConstant, OpInfo(m_constantUndefined)));
              return true;
          }
  
          case HasOwnPropertyIntrinsic: {
<span class="line-modified">!             if (argumentCountIncludingThis &lt; 2)</span>
                  return false;
  
              // This can be racy, that&#39;s fine. We know that once we observe that this is created,
              // that it will never be destroyed until the VM is destroyed. It&#39;s unlikely that
              // we&#39;d ever get to the point where we inline this as an intrinsic without the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3365,12 ***</span>
              // hasOwnProperty.
              if (!m_vm-&gt;hasOwnPropertyCache())
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* object = get(virtualRegisterForArgument(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgument(1, registerOffset));</span>
              Node* resultNode = addToGraph(HasOwnProperty, object, key);
              setResult(resultNode);
              return true;
          }
  
<span class="line-new-header">--- 3547,12 ---</span>
              // hasOwnProperty.
              if (!m_vm-&gt;hasOwnPropertyCache())
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* object = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-modified">!             Node* key = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              Node* resultNode = addToGraph(HasOwnProperty, object, key);
              setResult(resultNode);
              return true;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3380,48 ***</span>
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* thisString = get(virtualRegisterForArgument(0, registerOffset));</span>
<span class="line-modified">!             Node* start = get(virtualRegisterForArgument(1, registerOffset));</span>
              Node* end = nullptr;
              if (argumentCountIncludingThis &gt; 2)
<span class="line-modified">!                 end = get(virtualRegisterForArgument(2, registerOffset));</span>
              Node* resultNode = addToGraph(StringSlice, thisString, start, end);
              setResult(resultNode);
              return true;
          }
  
          case StringPrototypeToLowerCaseIntrinsic: {
<span class="line-removed">-             if (argumentCountIncludingThis != 1)</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">- </span>
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* thisString = get(virtualRegisterForArgument(0, registerOffset));</span>
              Node* resultNode = addToGraph(ToLowerCase, thisString);
              setResult(resultNode);
              return true;
          }
  
          case NumberPrototypeToStringIntrinsic: {
<span class="line-removed">-             if (argumentCountIncludingThis != 1 &amp;&amp; argumentCountIncludingThis != 2)</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">- </span>
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* thisNumber = get(virtualRegisterForArgument(0, registerOffset));</span>
              if (argumentCountIncludingThis == 1) {
                  Node* resultNode = addToGraph(ToString, thisNumber);
                  setResult(resultNode);
              } else {
<span class="line-modified">!                 Node* radix = get(virtualRegisterForArgument(1, registerOffset));</span>
                  Node* resultNode = addToGraph(NumberToStringWithRadix, thisNumber, radix);
                  setResult(resultNode);
              }
              return true;
          }
<span class="line-new-header">--- 3562,42 ---</span>
  
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* thisString = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
<span class="line-modified">!             Node* start = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              Node* end = nullptr;
              if (argumentCountIncludingThis &gt; 2)
<span class="line-modified">!                 end = get(virtualRegisterForArgumentIncludingThis(2, registerOffset));</span>
              Node* resultNode = addToGraph(StringSlice, thisString, start, end);
              setResult(resultNode);
              return true;
          }
  
          case StringPrototypeToLowerCaseIntrinsic: {
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* thisString = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
              Node* resultNode = addToGraph(ToLowerCase, thisString);
              setResult(resultNode);
              return true;
          }
  
          case NumberPrototypeToStringIntrinsic: {
              if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType))
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* thisNumber = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
              if (argumentCountIncludingThis == 1) {
                  Node* resultNode = addToGraph(ToString, thisNumber);
                  setResult(resultNode);
              } else {
<span class="line-modified">!                 Node* radix = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
                  Node* resultNode = addToGraph(NumberToStringWithRadix, thisNumber, radix);
                  setResult(resultNode);
              }
              return true;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3429,11 ***</span>
          case NumberIsIntegerIntrinsic: {
              if (argumentCountIncludingThis &lt; 2)
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* input = get(virtualRegisterForArgument(1, registerOffset));</span>
              Node* resultNode = addToGraph(NumberIsInteger, input);
              setResult(resultNode);
              return true;
          }
  
<span class="line-new-header">--- 3605,11 ---</span>
          case NumberIsIntegerIntrinsic: {
              if (argumentCountIncludingThis &lt; 2)
                  return false;
  
              insertChecks();
<span class="line-modified">!             Node* input = get(virtualRegisterForArgumentIncludingThis(1, registerOffset));</span>
              Node* resultNode = addToGraph(NumberIsInteger, input);
              setResult(resultNode);
              return true;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3602,29 ***</span>
  bool ByteCodeParser::handleDOMJITGetter(VirtualRegister result, const GetByIdVariant&amp; variant, Node* thisNode, unsigned identifierNumber, SpeculatedType prediction)
  {
      if (!variant.domAttribute())
          return false;
  
<span class="line-modified">!     auto domAttribute = variant.domAttribute().value();</span>
  
      // We do not need to actually look up CustomGetterSetter here. Checking Structures or registering watchpoints are enough,
      // since replacement of CustomGetterSetter always incurs Structure transition.
      if (!check(variant.conditionSet()))
          return false;
      addToGraph(CheckStructure, OpInfo(m_graph.addStructureSet(variant.structureSet())), thisNode);
  
      // We do not need to emit CheckCell thingy here. When the custom accessor is replaced to different one, Structure transition occurs.
<span class="line-modified">!     addToGraph(CheckSubClass, OpInfo(domAttribute.classInfo), thisNode);</span>
  
      bool wasSeenInJIT = true;
<span class="line-modified">!     addToGraph(FilterGetByIdStatus, OpInfo(m_graph.m_plan.recordedStatuses().addGetByIdStatus(currentCodeOrigin(), GetByIdStatus(GetByIdStatus::Custom, wasSeenInJIT, variant))), thisNode);</span>
  
      CallDOMGetterData* callDOMGetterData = m_graph.m_callDOMGetterData.add();
      callDOMGetterData-&gt;customAccessorGetter = variant.customAccessorGetter();
      ASSERT(callDOMGetterData-&gt;customAccessorGetter);
  
<span class="line-modified">!     if (const auto* domJIT = domAttribute.domJIT) {</span>
          callDOMGetterData-&gt;domJIT = domJIT;
          Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = domJIT-&gt;compiler()();
          callDOMGetterData-&gt;snippet = snippet.ptr();
          m_graph.m_domJITSnippets.append(WTFMove(snippet));
      }
<span class="line-new-header">--- 3778,32 ---</span>
  bool ByteCodeParser::handleDOMJITGetter(VirtualRegister result, const GetByIdVariant&amp; variant, Node* thisNode, unsigned identifierNumber, SpeculatedType prediction)
  {
      if (!variant.domAttribute())
          return false;
  
<span class="line-modified">!     auto* domAttribute = variant.domAttribute();</span>
  
      // We do not need to actually look up CustomGetterSetter here. Checking Structures or registering watchpoints are enough,
      // since replacement of CustomGetterSetter always incurs Structure transition.
      if (!check(variant.conditionSet()))
          return false;
      addToGraph(CheckStructure, OpInfo(m_graph.addStructureSet(variant.structureSet())), thisNode);
  
      // We do not need to emit CheckCell thingy here. When the custom accessor is replaced to different one, Structure transition occurs.
<span class="line-modified">!     addToGraph(CheckSubClass, OpInfo(domAttribute-&gt;classInfo), thisNode);</span>
  
      bool wasSeenInJIT = true;
<span class="line-modified">!     GetByStatus* status = m_graph.m_plan.recordedStatuses().addGetByStatus(currentCodeOrigin(), GetByStatus(GetByStatus::Custom, wasSeenInJIT));</span>
<span class="line-added">+     bool success = status-&gt;appendVariant(variant);</span>
<span class="line-added">+     RELEASE_ASSERT(success);</span>
<span class="line-added">+     addToGraph(FilterGetByStatus, OpInfo(status), thisNode);</span>
  
      CallDOMGetterData* callDOMGetterData = m_graph.m_callDOMGetterData.add();
      callDOMGetterData-&gt;customAccessorGetter = variant.customAccessorGetter();
      ASSERT(callDOMGetterData-&gt;customAccessorGetter);
  
<span class="line-modified">!     if (const auto* domJIT = domAttribute-&gt;domJIT) {</span>
          callDOMGetterData-&gt;domJIT = domJIT;
          Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = domJIT-&gt;compiler()();
          callDOMGetterData-&gt;snippet = snippet.ptr();
          m_graph.m_domJITSnippets.append(WTFMove(snippet));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3641,17 ***</span>
      blessCallDOMGetter(callDOMGetterNode);
      set(result, callDOMGetterNode);
      return true;
  }
  
<span class="line-modified">! bool ByteCodeParser::handleModuleNamespaceLoad(VirtualRegister result, SpeculatedType prediction, Node* base, GetByIdStatus getById)</span>
  {
      if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCell))
          return false;
      addToGraph(CheckCell, OpInfo(m_graph.freeze(getById.moduleNamespaceObject())), Edge(base, CellUse));
  
<span class="line-modified">!     addToGraph(FilterGetByIdStatus, OpInfo(m_graph.m_plan.recordedStatuses().addGetByIdStatus(currentCodeOrigin(), getById)), base);</span>
  
      // Ideally we wouldn&#39;t have to do this Phantom. But:
      //
      // For the constant case: we must do it because otherwise we would have no way of knowing
      // that the scope is live at OSR here.
<span class="line-new-header">--- 3820,17 ---</span>
      blessCallDOMGetter(callDOMGetterNode);
      set(result, callDOMGetterNode);
      return true;
  }
  
<span class="line-modified">! bool ByteCodeParser::handleModuleNamespaceLoad(VirtualRegister result, SpeculatedType prediction, Node* base, GetByStatus getById)</span>
  {
      if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCell))
          return false;
      addToGraph(CheckCell, OpInfo(m_graph.freeze(getById.moduleNamespaceObject())), Edge(base, CellUse));
  
<span class="line-modified">!     addToGraph(FilterGetByStatus, OpInfo(m_graph.m_plan.recordedStatuses().addGetByStatus(currentCodeOrigin(), getById)), base);</span>
  
      // Ideally we wouldn&#39;t have to do this Phantom. But:
      //
      // For the constant case: we must do it because otherwise we would have no way of knowing
      // that the scope is live at OSR here.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3679,14 ***</span>
      int argumentCountIncludingThis, TypedArrayType type, const ChecksFunctor&amp; insertChecks)
  {
      if (!isTypedView(type))
          return false;
  
<span class="line-modified">!     if (function-&gt;classInfo() != constructorClassInfoForType(type))</span>
          return false;
  
<span class="line-modified">!     if (function-&gt;globalObject(*m_vm) != m_inlineStackTop-&gt;m_codeBlock-&gt;globalObject())</span>
          return false;
  
      // We only have an intrinsic for the case where you say:
      //
      // new FooArray(blah);
<span class="line-new-header">--- 3858,14 ---</span>
      int argumentCountIncludingThis, TypedArrayType type, const ChecksFunctor&amp; insertChecks)
  {
      if (!isTypedView(type))
          return false;
  
<span class="line-modified">!     if (function-&gt;classInfo(*m_vm) != constructorClassInfoForType(type))</span>
          return false;
  
<span class="line-modified">!     if (function-&gt;globalObject() != m_inlineStackTop-&gt;m_codeBlock-&gt;globalObject())</span>
          return false;
  
      // We only have an intrinsic for the case where you say:
      //
      // new FooArray(blah);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3719,16 ***</span>
      // or else making Construct not super slow.
  
      if (argumentCountIncludingThis != 2)
          return false;
  
<span class="line-modified">!     if (!function-&gt;globalObject(*m_vm)-&gt;typedArrayStructureConcurrently(type))</span>
          return false;
  
      insertChecks();
      set(result,
<span class="line-modified">!         addToGraph(NewTypedArray, OpInfo(type), get(virtualRegisterForArgument(1, registerOffset))));</span>
      return true;
  }
  
  template&lt;typename ChecksFunctor&gt;
  bool ByteCodeParser::handleConstantInternalFunction(
<span class="line-new-header">--- 3898,16 ---</span>
      // or else making Construct not super slow.
  
      if (argumentCountIncludingThis != 2)
          return false;
  
<span class="line-modified">!     if (!function-&gt;globalObject()-&gt;typedArrayStructureConcurrently(type))</span>
          return false;
  
      insertChecks();
      set(result,
<span class="line-modified">!         addToGraph(NewTypedArray, OpInfo(type), get(virtualRegisterForArgumentIncludingThis(1, registerOffset))));</span>
      return true;
  }
  
  template&lt;typename ChecksFunctor&gt;
  bool ByteCodeParser::handleConstantInternalFunction(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3741,89 ***</span>
      // unlikely that the result operand would be invalid - you&#39;d have to call this via a setter call.
      if (!result.isValid())
          return false;
  
      if (kind == CodeForConstruct) {
<span class="line-modified">!         Node* newTargetNode = get(virtualRegisterForArgument(0, registerOffset));</span>
          // We cannot handle the case where new.target != callee (i.e. a construct from a super call) because we
          // don&#39;t know what the prototype of the constructed object will be.
          // FIXME: If we have inlined super calls up to the call site, however, we should be able to figure out the structure. https://bugs.webkit.org/show_bug.cgi?id=152700
          if (newTargetNode != callTargetNode)
              return false;
      }
  
<span class="line-modified">!     if (function-&gt;classInfo() == ArrayConstructor::info()) {</span>
<span class="line-modified">!         if (function-&gt;globalObject(*m_vm) != m_inlineStackTop-&gt;m_codeBlock-&gt;globalObject())</span>
              return false;
  
          insertChecks();
          if (argumentCountIncludingThis == 2) {
              set(result,
<span class="line-modified">!                 addToGraph(NewArrayWithSize, OpInfo(ArrayWithUndecided), get(virtualRegisterForArgument(1, registerOffset))));</span>
              return true;
          }
  
          for (int i = 1; i &lt; argumentCountIncludingThis; ++i)
<span class="line-modified">!             addVarArgChild(get(virtualRegisterForArgument(i, registerOffset)));</span>
          set(result,
              addToGraph(Node::VarArg, NewArray, OpInfo(ArrayWithUndecided), OpInfo(argumentCountIncludingThis - 1)));
          return true;
      }
  
<span class="line-modified">!     if (function-&gt;classInfo() == NumberConstructor::info()) {</span>
          if (kind == CodeForConstruct)
              return false;
  
          insertChecks();
          if (argumentCountIncludingThis &lt;= 1)
              set(result, jsConstant(jsNumber(0)));
          else
<span class="line-modified">!             set(result, addToGraph(ToNumber, OpInfo(0), OpInfo(prediction), get(virtualRegisterForArgument(1, registerOffset))));</span>
  
          return true;
      }
  
<span class="line-modified">!     if (function-&gt;classInfo() == StringConstructor::info()) {</span>
          insertChecks();
  
          Node* resultNode;
  
          if (argumentCountIncludingThis &lt;= 1)
              resultNode = jsConstant(m_vm-&gt;smallStrings.emptyString());
          else
<span class="line-modified">!             resultNode = addToGraph(CallStringConstructor, get(virtualRegisterForArgument(1, registerOffset)));</span>
  
          if (kind == CodeForConstruct)
<span class="line-modified">!             resultNode = addToGraph(NewStringObject, OpInfo(m_graph.registerStructure(function-&gt;globalObject(*m_vm)-&gt;stringObjectStructure())), resultNode);</span>
  
          set(result, resultNode);
          return true;
      }
  
<span class="line-modified">!     if (function-&gt;classInfo() == SymbolConstructor::info() &amp;&amp; kind == CodeForCall) {</span>
          insertChecks();
  
          Node* resultNode;
  
          if (argumentCountIncludingThis &lt;= 1)
              resultNode = addToGraph(NewSymbol);
          else
<span class="line-modified">!             resultNode = addToGraph(NewSymbol, addToGraph(ToString, get(virtualRegisterForArgument(1, registerOffset))));</span>
  
          set(result, resultNode);
          return true;
      }
  
      // FIXME: This should handle construction as well. https://bugs.webkit.org/show_bug.cgi?id=155591
<span class="line-modified">!     if (function-&gt;classInfo() == ObjectConstructor::info() &amp;&amp; kind == CodeForCall) {</span>
          insertChecks();
  
          Node* resultNode;
          if (argumentCountIncludingThis &lt;= 1)
<span class="line-modified">!             resultNode = addToGraph(NewObject, OpInfo(m_graph.registerStructure(function-&gt;globalObject(*m_vm)-&gt;objectStructureForObjectConstructor())));</span>
          else
<span class="line-modified">!             resultNode = addToGraph(CallObjectConstructor, OpInfo(m_graph.freeze(function-&gt;globalObject(*m_vm))), OpInfo(prediction), get(virtualRegisterForArgument(1, registerOffset)));</span>
          set(result, resultNode);
          return true;
      }
  
      for (unsigned typeIndex = 0; typeIndex &lt; NumberOfTypedArrayTypes; ++typeIndex) {
<span class="line-new-header">--- 3920,89 ---</span>
      // unlikely that the result operand would be invalid - you&#39;d have to call this via a setter call.
      if (!result.isValid())
          return false;
  
      if (kind == CodeForConstruct) {
<span class="line-modified">!         Node* newTargetNode = get(virtualRegisterForArgumentIncludingThis(0, registerOffset));</span>
          // We cannot handle the case where new.target != callee (i.e. a construct from a super call) because we
          // don&#39;t know what the prototype of the constructed object will be.
          // FIXME: If we have inlined super calls up to the call site, however, we should be able to figure out the structure. https://bugs.webkit.org/show_bug.cgi?id=152700
          if (newTargetNode != callTargetNode)
              return false;
      }
  
<span class="line-modified">!     if (function-&gt;classInfo(*m_vm) == ArrayConstructor::info()) {</span>
<span class="line-modified">!         if (function-&gt;globalObject() != m_inlineStackTop-&gt;m_codeBlock-&gt;globalObject())</span>
              return false;
  
          insertChecks();
          if (argumentCountIncludingThis == 2) {
              set(result,
<span class="line-modified">!                 addToGraph(NewArrayWithSize, OpInfo(ArrayWithUndecided), get(virtualRegisterForArgumentIncludingThis(1, registerOffset))));</span>
              return true;
          }
  
          for (int i = 1; i &lt; argumentCountIncludingThis; ++i)
<span class="line-modified">!             addVarArgChild(get(virtualRegisterForArgumentIncludingThis(i, registerOffset)));</span>
          set(result,
              addToGraph(Node::VarArg, NewArray, OpInfo(ArrayWithUndecided), OpInfo(argumentCountIncludingThis - 1)));
          return true;
      }
  
<span class="line-modified">!     if (function-&gt;classInfo(*m_vm) == NumberConstructor::info()) {</span>
          if (kind == CodeForConstruct)
              return false;
  
          insertChecks();
          if (argumentCountIncludingThis &lt;= 1)
              set(result, jsConstant(jsNumber(0)));
          else
<span class="line-modified">!             set(result, addToGraph(ToNumber, OpInfo(0), OpInfo(prediction), get(virtualRegisterForArgumentIncludingThis(1, registerOffset))));</span>
  
          return true;
      }
  
<span class="line-modified">!     if (function-&gt;classInfo(*m_vm) == StringConstructor::info()) {</span>
          insertChecks();
  
          Node* resultNode;
  
          if (argumentCountIncludingThis &lt;= 1)
              resultNode = jsConstant(m_vm-&gt;smallStrings.emptyString());
          else
<span class="line-modified">!             resultNode = addToGraph(CallStringConstructor, get(virtualRegisterForArgumentIncludingThis(1, registerOffset)));</span>
  
          if (kind == CodeForConstruct)
<span class="line-modified">!             resultNode = addToGraph(NewStringObject, OpInfo(m_graph.registerStructure(function-&gt;globalObject()-&gt;stringObjectStructure())), resultNode);</span>
  
          set(result, resultNode);
          return true;
      }
  
<span class="line-modified">!     if (function-&gt;classInfo(*m_vm) == SymbolConstructor::info() &amp;&amp; kind == CodeForCall) {</span>
          insertChecks();
  
          Node* resultNode;
  
          if (argumentCountIncludingThis &lt;= 1)
              resultNode = addToGraph(NewSymbol);
          else
<span class="line-modified">!             resultNode = addToGraph(NewSymbol, addToGraph(ToString, get(virtualRegisterForArgumentIncludingThis(1, registerOffset))));</span>
  
          set(result, resultNode);
          return true;
      }
  
      // FIXME: This should handle construction as well. https://bugs.webkit.org/show_bug.cgi?id=155591
<span class="line-modified">!     if (function-&gt;classInfo(*m_vm) == ObjectConstructor::info() &amp;&amp; kind == CodeForCall) {</span>
          insertChecks();
  
          Node* resultNode;
          if (argumentCountIncludingThis &lt;= 1)
<span class="line-modified">!             resultNode = addToGraph(NewObject, OpInfo(m_graph.registerStructure(function-&gt;globalObject()-&gt;objectStructureForObjectConstructor())));</span>
          else
<span class="line-modified">!             resultNode = addToGraph(CallObjectConstructor, OpInfo(m_graph.freeze(function-&gt;globalObject())), OpInfo(prediction), get(virtualRegisterForArgumentIncludingThis(1, registerOffset)));</span>
          set(result, resultNode);
          return true;
      }
  
      for (unsigned typeIndex = 0; typeIndex &lt; NumberOfTypedArrayTypes; ++typeIndex) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4159,11 ***</span>
              if (!variant.conditionSet().isEmpty()) {
                  // This means that we&#39;re loading from a prototype or we have a property miss. We expect
                  // the base not to have the property. We can only use ObjectPropertyCondition if all of
                  // the structures in the variant.structureSet() agree on the prototype (it would be
                  // hilariously rare if they didn&#39;t). Note that we are relying on structureSet() having
<span class="line-modified">!                 // at least one element. That will always be true here because of how GetByIdStatus/PutByIdStatus work.</span>
  
                  // FIXME: right now, if we have an OPCS, we have mono proto. However, this will
                  // need to be changed in the future once we have a hybrid data structure for
                  // poly proto:
                  // https://bugs.webkit.org/show_bug.cgi?id=177339
<span class="line-new-header">--- 4338,11 ---</span>
              if (!variant.conditionSet().isEmpty()) {
                  // This means that we&#39;re loading from a prototype or we have a property miss. We expect
                  // the base not to have the property. We can only use ObjectPropertyCondition if all of
                  // the structures in the variant.structureSet() agree on the prototype (it would be
                  // hilariously rare if they didn&#39;t). Note that we are relying on structureSet() having
<span class="line-modified">!                 // at least one element. That will always be true here because of how GetByStatus/PutByIdStatus work.</span>
  
                  // FIXME: right now, if we have an OPCS, we have mono proto. However, this will
                  // need to be changed in the future once we have a hybrid data structure for
                  // poly proto:
                  // https://bugs.webkit.org/show_bug.cgi?id=177339
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4248,13 ***</span>
      return handlePutByOffset(base, identifier, variant.offset(), value);
  }
  
  void ByteCodeParser::handleGetById(
      VirtualRegister destination, SpeculatedType prediction, Node* base, unsigned identifierNumber,
<span class="line-modified">!     GetByIdStatus getByIdStatus, AccessType type, unsigned instructionSize)</span>
  {
<span class="line-modified">!     // Attempt to reduce the set of things in the GetByIdStatus.</span>
      if (base-&gt;op() == NewObject) {
          bool ok = true;
          for (unsigned i = m_currentBlock-&gt;size(); i--;) {
              Node* node = m_currentBlock-&gt;at(i);
              if (node == base)
<span class="line-new-header">--- 4427,13 ---</span>
      return handlePutByOffset(base, identifier, variant.offset(), value);
  }
  
  void ByteCodeParser::handleGetById(
      VirtualRegister destination, SpeculatedType prediction, Node* base, unsigned identifierNumber,
<span class="line-modified">!     GetByStatus getByStatus, AccessType type, unsigned instructionSize)</span>
  {
<span class="line-modified">!     // Attempt to reduce the set of things in the GetByStatus.</span>
      if (base-&gt;op() == NewObject) {
          bool ok = true;
          for (unsigned i = m_currentBlock-&gt;size(); i--;) {
              Node* node = m_currentBlock-&gt;at(i);
              if (node == base)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4263,71 ***</span>
                  ok = false;
                  break;
              }
          }
          if (ok)
<span class="line-modified">!             getByIdStatus.filter(base-&gt;structure().get());</span>
      }
  
      NodeType getById;
<span class="line-modified">!     if (type == AccessType::Get)</span>
<span class="line-modified">!         getById = getByIdStatus.makesCalls() ? GetByIdFlush : GetById;</span>
<span class="line-modified">!     else if (type == AccessType::TryGet)</span>
          getById = TryGetById;
      else
<span class="line-modified">!         getById = getByIdStatus.makesCalls() ? GetByIdDirectFlush : GetByIdDirect;</span>
  
<span class="line-modified">!     if (getById != TryGetById &amp;&amp; getByIdStatus.isModuleNamespace()) {</span>
<span class="line-modified">!         if (handleModuleNamespaceLoad(destination, prediction, base, getByIdStatus)) {</span>
              if (UNLIKELY(m_graph.compilation()))
                  m_graph.compilation()-&gt;noticeInlinedGetById();
              return;
          }
      }
  
      // Special path for custom accessors since custom&#39;s offset does not have any meanings.
      // So, this is completely different from Simple one. But we have a chance to optimize it when we use DOMJIT.
<span class="line-modified">!     if (Options::useDOMJIT() &amp;&amp; getByIdStatus.isCustom()) {</span>
<span class="line-modified">!         ASSERT(getByIdStatus.numVariants() == 1);</span>
<span class="line-modified">!         ASSERT(!getByIdStatus.makesCalls());</span>
<span class="line-modified">!         GetByIdVariant variant = getByIdStatus[0];</span>
          ASSERT(variant.domAttribute());
          if (handleDOMJITGetter(destination, variant, base, identifierNumber, prediction)) {
              if (UNLIKELY(m_graph.compilation()))
                  m_graph.compilation()-&gt;noticeInlinedGetById();
              return;
          }
      }
  
<span class="line-modified">!     ASSERT(type == AccessType::Get || type == AccessType::GetDirect ||  !getByIdStatus.makesCalls());</span>
<span class="line-modified">!     if (!getByIdStatus.isSimple() || !getByIdStatus.numVariants() || !Options::useAccessInlining()) {</span>
          set(destination,
              addToGraph(getById, OpInfo(identifierNumber), OpInfo(prediction), base));
          return;
      }
  
<span class="line-modified">!     // FIXME: If we use the GetByIdStatus for anything then we should record it and insert a node</span>
      // after everything else (like the GetByOffset or whatever) that will filter the recorded
<span class="line-modified">!     // GetByIdStatus. That means that the constant folder also needs to do the same!</span>
  
<span class="line-modified">!     if (getByIdStatus.numVariants() &gt; 1) {</span>
<span class="line-modified">!         if (getByIdStatus.makesCalls() || !m_graph.m_plan.isFTL()</span>
              || !Options::usePolymorphicAccessInlining()
<span class="line-modified">!             || getByIdStatus.numVariants() &gt; Options::maxPolymorphicAccessInliningListSize()) {</span>
              set(destination,
                  addToGraph(getById, OpInfo(identifierNumber), OpInfo(prediction), base));
              return;
          }
  
<span class="line-modified">!         addToGraph(FilterGetByIdStatus, OpInfo(m_graph.m_plan.recordedStatuses().addGetByIdStatus(currentCodeOrigin(), getByIdStatus)), base);</span>
  
          Vector&lt;MultiGetByOffsetCase, 2&gt; cases;
  
          // 1) Emit prototype structure checks for all chains. This could sort of maybe not be
          //    optimal, if there is some rarely executed case in the chain that requires a lot
          //    of checks and those checks are not watchpointable.
<span class="line-modified">!         for (const GetByIdVariant&amp; variant : getByIdStatus.variants()) {</span>
              if (variant.intrinsic() != NoIntrinsic) {
                  set(destination,
                      addToGraph(getById, OpInfo(identifierNumber), OpInfo(prediction), base));
                  return;
              }
<span class="line-new-header">--- 4442,71 ---</span>
                  ok = false;
                  break;
              }
          }
          if (ok)
<span class="line-modified">!             getByStatus.filter(base-&gt;structure().get());</span>
      }
  
      NodeType getById;
<span class="line-modified">!     if (type == AccessType::GetById)</span>
<span class="line-modified">!         getById = getByStatus.makesCalls() ? GetByIdFlush : GetById;</span>
<span class="line-modified">!     else if (type == AccessType::TryGetById)</span>
          getById = TryGetById;
      else
<span class="line-modified">!         getById = getByStatus.makesCalls() ? GetByIdDirectFlush : GetByIdDirect;</span>
  
<span class="line-modified">!     if (getById != TryGetById &amp;&amp; getByStatus.isModuleNamespace()) {</span>
<span class="line-modified">!         if (handleModuleNamespaceLoad(destination, prediction, base, getByStatus)) {</span>
              if (UNLIKELY(m_graph.compilation()))
                  m_graph.compilation()-&gt;noticeInlinedGetById();
              return;
          }
      }
  
      // Special path for custom accessors since custom&#39;s offset does not have any meanings.
      // So, this is completely different from Simple one. But we have a chance to optimize it when we use DOMJIT.
<span class="line-modified">!     if (Options::useDOMJIT() &amp;&amp; getByStatus.isCustom()) {</span>
<span class="line-modified">!         ASSERT(getByStatus.numVariants() == 1);</span>
<span class="line-modified">!         ASSERT(!getByStatus.makesCalls());</span>
<span class="line-modified">!         GetByIdVariant variant = getByStatus[0];</span>
          ASSERT(variant.domAttribute());
          if (handleDOMJITGetter(destination, variant, base, identifierNumber, prediction)) {
              if (UNLIKELY(m_graph.compilation()))
                  m_graph.compilation()-&gt;noticeInlinedGetById();
              return;
          }
      }
  
<span class="line-modified">!     ASSERT(type == AccessType::GetById || type == AccessType::GetByIdDirect ||  !getByStatus.makesCalls());</span>
<span class="line-modified">!     if (!getByStatus.isSimple() || !getByStatus.numVariants() || !Options::useAccessInlining()) {</span>
          set(destination,
              addToGraph(getById, OpInfo(identifierNumber), OpInfo(prediction), base));
          return;
      }
  
<span class="line-modified">!     // FIXME: If we use the GetByStatus for anything then we should record it and insert a node</span>
      // after everything else (like the GetByOffset or whatever) that will filter the recorded
<span class="line-modified">!     // GetByStatus. That means that the constant folder also needs to do the same!</span>
  
<span class="line-modified">!     if (getByStatus.numVariants() &gt; 1) {</span>
<span class="line-modified">!         if (getByStatus.makesCalls() || !m_graph.m_plan.isFTL()</span>
              || !Options::usePolymorphicAccessInlining()
<span class="line-modified">!             || getByStatus.numVariants() &gt; Options::maxPolymorphicAccessInliningListSize()) {</span>
              set(destination,
                  addToGraph(getById, OpInfo(identifierNumber), OpInfo(prediction), base));
              return;
          }
  
<span class="line-modified">!         addToGraph(FilterGetByStatus, OpInfo(m_graph.m_plan.recordedStatuses().addGetByStatus(currentCodeOrigin(), getByStatus)), base);</span>
  
          Vector&lt;MultiGetByOffsetCase, 2&gt; cases;
  
          // 1) Emit prototype structure checks for all chains. This could sort of maybe not be
          //    optimal, if there is some rarely executed case in the chain that requires a lot
          //    of checks and those checks are not watchpointable.
<span class="line-modified">!         for (const GetByIdVariant&amp; variant : getByStatus.variants()) {</span>
              if (variant.intrinsic() != NoIntrinsic) {
                  set(destination,
                      addToGraph(getById, OpInfo(identifierNumber), OpInfo(prediction), base));
                  return;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4360,14 ***</span>
          set(destination,
              addToGraph(MultiGetByOffset, OpInfo(data), OpInfo(prediction), base));
          return;
      }
  
<span class="line-modified">!     addToGraph(FilterGetByIdStatus, OpInfo(m_graph.m_plan.recordedStatuses().addGetByIdStatus(currentCodeOrigin(), getByIdStatus)), base);</span>
  
<span class="line-modified">!     ASSERT(getByIdStatus.numVariants() == 1);</span>
<span class="line-modified">!     GetByIdVariant variant = getByIdStatus[0];</span>
  
      Node* loadedValue = load(prediction, base, identifierNumber, variant);
      if (!loadedValue) {
          set(destination,
              addToGraph(getById, OpInfo(identifierNumber), OpInfo(prediction), base));
<span class="line-new-header">--- 4539,14 ---</span>
          set(destination,
              addToGraph(MultiGetByOffset, OpInfo(data), OpInfo(prediction), base));
          return;
      }
  
<span class="line-modified">!     addToGraph(FilterGetByStatus, OpInfo(m_graph.m_plan.recordedStatuses().addGetByStatus(currentCodeOrigin(), getByStatus)), base);</span>
  
<span class="line-modified">!     ASSERT(getByStatus.numVariants() == 1);</span>
<span class="line-modified">!     GetByIdVariant variant = getByStatus[0];</span>
  
      Node* loadedValue = load(prediction, base, identifierNumber, variant);
      if (!loadedValue) {
          set(destination,
              addToGraph(getById, OpInfo(identifierNumber), OpInfo(prediction), base));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4375,11 ***</span>
      }
  
      if (UNLIKELY(m_graph.compilation()))
          m_graph.compilation()-&gt;noticeInlinedGetById();
  
<span class="line-modified">!     ASSERT(type == AccessType::Get || type == AccessType::GetDirect || !variant.callLinkStatus());</span>
      if (!variant.callLinkStatus() &amp;&amp; variant.intrinsic() == NoIntrinsic) {
          set(destination, loadedValue);
          return;
      }
  
<span class="line-new-header">--- 4554,11 ---</span>
      }
  
      if (UNLIKELY(m_graph.compilation()))
          m_graph.compilation()-&gt;noticeInlinedGetById();
  
<span class="line-modified">!     ASSERT(type == AccessType::GetById || type == AccessType::GetByIdDirect || !variant.callLinkStatus());</span>
      if (!variant.callLinkStatus() &amp;&amp; variant.intrinsic() == NoIntrinsic) {
          set(destination, loadedValue);
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4421,11 ***</span>
      // 1) That&#39;s how handleCall() sees the arguments.
      // 2) If we inline then this ensures that the arguments are flushed so that if you use
      //    the dreaded arguments object on the getter, the right things happen. Well, sort of -
      //    since we only really care about &#39;this&#39; in this case. But we&#39;re not going to take that
      //    shortcut.
<span class="line-modified">!     set(virtualRegisterForArgument(0, registerOffset), base, ImmediateNakedSet);</span>
  
      // We&#39;ve set some locals, but they are not user-visible. It&#39;s still OK to exit from here.
      m_exitOK = true;
      addToGraph(ExitOK);
  
<span class="line-new-header">--- 4600,11 ---</span>
      // 1) That&#39;s how handleCall() sees the arguments.
      // 2) If we inline then this ensures that the arguments are flushed so that if you use
      //    the dreaded arguments object on the getter, the right things happen. Well, sort of -
      //    since we only really care about &#39;this&#39; in this case. But we&#39;re not going to take that
      //    shortcut.
<span class="line-modified">!     set(virtualRegisterForArgumentIncludingThis(0, registerOffset), base, ImmediateNakedSet);</span>
  
      // We&#39;ve set some locals, but they are not user-visible. It&#39;s still OK to exit from here.
      m_exitOK = true;
      addToGraph(ExitOK);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4604,12 ***</span>
  
          ensureLocals(
              m_inlineStackTop-&gt;remapOperand(
                  VirtualRegister(registerOffset)).toLocal());
  
<span class="line-modified">!         set(virtualRegisterForArgument(0, registerOffset), base, ImmediateNakedSet);</span>
<span class="line-modified">!         set(virtualRegisterForArgument(1, registerOffset), value, ImmediateNakedSet);</span>
  
          // We&#39;ve set some locals, but they are not user-visible. It&#39;s still OK to exit from here.
          m_exitOK = true;
          addToGraph(ExitOK);
  
<span class="line-new-header">--- 4783,12 ---</span>
  
          ensureLocals(
              m_inlineStackTop-&gt;remapOperand(
                  VirtualRegister(registerOffset)).toLocal());
  
<span class="line-modified">!         set(virtualRegisterForArgumentIncludingThis(0, registerOffset), base, ImmediateNakedSet);</span>
<span class="line-modified">!         set(virtualRegisterForArgumentIncludingThis(1, registerOffset), value, ImmediateNakedSet);</span>
  
          // We&#39;ve set some locals, but they are not user-visible. It&#39;s still OK to exit from here.
          m_exitOK = true;
          addToGraph(ExitOK);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4644,26 ***</span>
      SpeculatedType prediction = getPrediction();
  
      Node* base = get(bytecode.m_base);
      unsigned identifierNumber = m_inlineStackTop-&gt;m_identifierRemap[bytecode.m_property];
  
<span class="line-modified">!     UniquedStringImpl* uid = m_graph.identifiers()[identifierNumber];</span>
<span class="line-removed">-     GetByIdStatus getByIdStatus = GetByIdStatus::computeFor(</span>
<span class="line-removed">-         m_inlineStackTop-&gt;m_profiledBlock,</span>
<span class="line-removed">-         m_inlineStackTop-&gt;m_baselineMap, m_icContextStack,</span>
<span class="line-removed">-         currentCodeOrigin(), uid);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     AccessType type = AccessType::Get;</span>
      unsigned opcodeLength = currentInstruction-&gt;size();
      if (Op::opcodeID == op_try_get_by_id)
<span class="line-modified">!         type = AccessType::TryGet;</span>
      else if (Op::opcodeID == op_get_by_id_direct)
<span class="line-modified">!         type = AccessType::GetDirect;</span>
  
<span class="line-modified">!     handleGetById(</span>
<span class="line-modified">!         bytecode.m_dst, prediction, base, identifierNumber, getByIdStatus, type, opcodeLength);</span>
  
  }
  
  static uint64_t makeDynamicVarOpInfo(unsigned identifierNumber, unsigned getPutInfo)
  {
      static_assert(sizeof(identifierNumber) == 4,
<span class="line-new-header">--- 4823,24 ---</span>
      SpeculatedType prediction = getPrediction();
  
      Node* base = get(bytecode.m_base);
      unsigned identifierNumber = m_inlineStackTop-&gt;m_identifierRemap[bytecode.m_property];
  
<span class="line-modified">!     AccessType type = AccessType::GetById;</span>
      unsigned opcodeLength = currentInstruction-&gt;size();
      if (Op::opcodeID == op_try_get_by_id)
<span class="line-modified">!         type = AccessType::TryGetById;</span>
      else if (Op::opcodeID == op_get_by_id_direct)
<span class="line-modified">!         type = AccessType::GetByIdDirect;</span>
  
<span class="line-modified">!     GetByStatus getByStatus = GetByStatus::computeFor(</span>
<span class="line-modified">!         m_inlineStackTop-&gt;m_profiledBlock,</span>
<span class="line-added">+         m_inlineStackTop-&gt;m_baselineMap, m_icContextStack,</span>
<span class="line-added">+         currentCodeOrigin());</span>
  
<span class="line-added">+     handleGetById(</span>
<span class="line-added">+         bytecode.m_dst, prediction, base, identifierNumber, getByStatus, type, opcodeLength);</span>
  }
  
  static uint64_t makeDynamicVarOpInfo(unsigned identifierNumber, unsigned getPutInfo)
  {
      static_assert(sizeof(identifierNumber) == 4,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4677,18 ***</span>
  // The more common idiom:
  //     do { ...; } while (false)
  // Doesn&#39;t allow using `continue`.
  #define NEXT_OPCODE(name) \
      if (true) { \
<span class="line-modified">!         m_currentIndex += currentInstruction-&gt;size(); \</span>
          goto WTF_CONCAT(NEXT_OPCODE_, __LINE__); /* Need a unique label: usable more than once per function. */ \
      } else \
          WTF_CONCAT(NEXT_OPCODE_, __LINE__): \
      continue
  
  #define LAST_OPCODE_LINKED(name) do { \
<span class="line-modified">!         m_currentIndex += currentInstruction-&gt;size(); \</span>
          m_exitOK = false; \
          return; \
      } while (false)
  
  #define LAST_OPCODE(name) \
<span class="line-new-header">--- 4854,18 ---</span>
  // The more common idiom:
  //     do { ...; } while (false)
  // Doesn&#39;t allow using `continue`.
  #define NEXT_OPCODE(name) \
      if (true) { \
<span class="line-modified">!         m_currentIndex = BytecodeIndex(m_currentIndex.offset() + currentInstruction-&gt;size()); \</span>
          goto WTF_CONCAT(NEXT_OPCODE_, __LINE__); /* Need a unique label: usable more than once per function. */ \
      } else \
          WTF_CONCAT(NEXT_OPCODE_, __LINE__): \
      continue
  
  #define LAST_OPCODE_LINKED(name) do { \
<span class="line-modified">!         m_currentIndex = BytecodeIndex(m_currentIndex.offset() + currentInstruction-&gt;size()); \</span>
          m_exitOK = false; \
          return; \
      } while (false)
  
  #define LAST_OPCODE(name) \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4708,11 ***</span>
      } while (false)
  
  void ByteCodeParser::parseBlock(unsigned limit)
  {
      auto&amp; instructions = m_inlineStackTop-&gt;m_codeBlock-&gt;instructions();
<span class="line-modified">!     unsigned blockBegin = m_currentIndex;</span>
  
      // If we are the first basic block, introduce markers for arguments. This allows
      // us to track if a use of an argument may use the actual argument passed, as
      // opposed to using a value we set explicitly.
      if (m_currentBlock == m_graph.block(0) &amp;&amp; !inlineCallFrame()) {
<span class="line-new-header">--- 4885,11 ---</span>
      } while (false)
  
  void ByteCodeParser::parseBlock(unsigned limit)
  {
      auto&amp; instructions = m_inlineStackTop-&gt;m_codeBlock-&gt;instructions();
<span class="line-modified">!     BytecodeIndex blockBegin = m_currentIndex;</span>
  
      // If we are the first basic block, introduce markers for arguments. This allows
      // us to track if a use of an argument may use the actual argument passed, as
      // opposed to using a value we set explicitly.
      if (m_currentBlock == m_graph.block(0) &amp;&amp; !inlineCallFrame()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4724,11 ***</span>
          // We will emit SetArgumentDefinitely nodes. They don&#39;t exit, but we&#39;re at the top of an op_enter so
          // exitOK = true.
          m_exitOK = true;
          for (unsigned argument = 0; argument &lt; m_numArguments; ++argument) {
              VariableAccessData* variable = newVariableAccessData(
<span class="line-modified">!                 virtualRegisterForArgument(argument));</span>
              variable-&gt;mergeStructureCheckHoistingFailed(
                  m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCache));
              variable-&gt;mergeCheckArrayHoistingFailed(
                  m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadIndexingType));
  
<span class="line-new-header">--- 4901,11 ---</span>
          // We will emit SetArgumentDefinitely nodes. They don&#39;t exit, but we&#39;re at the top of an op_enter so
          // exitOK = true.
          m_exitOK = true;
          for (unsigned argument = 0; argument &lt; m_numArguments; ++argument) {
              VariableAccessData* variable = newVariableAccessData(
<span class="line-modified">!                 virtualRegisterForArgumentIncludingThis(argument));</span>
              variable-&gt;mergeStructureCheckHoistingFailed(
                  m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCache));
              variable-&gt;mergeCheckArrayHoistingFailed(
                  m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadIndexingType));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4752,21 ***</span>
          m_exitOK = true;
  
          processSetLocalQueue();
  
          // Don&#39;t extend over jump destinations.
<span class="line-modified">!         if (m_currentIndex == limit) {</span>
              // Ordinarily we want to plant a jump. But refuse to do this if the block is
              // empty. This is a special case for inlining, which might otherwise create
              // some empty blocks in some cases. When parseBlock() returns with an empty
              // block, it will get repurposed instead of creating a new one. Note that this
              // logic relies on every bytecode resulting in one or more nodes, which would
              // be true anyway except for op_loop_hint, which emits a Phantom to force this
              // to be true.
  
              if (!m_currentBlock-&gt;isEmpty())
<span class="line-modified">!                 addJumpTo(m_currentIndex);</span>
              return;
          }
  
          // Switch on the current bytecode opcode.
          const Instruction* currentInstruction = instructions.at(m_currentIndex).ptr();
<span class="line-new-header">--- 4929,21 ---</span>
          m_exitOK = true;
  
          processSetLocalQueue();
  
          // Don&#39;t extend over jump destinations.
<span class="line-modified">!         if (m_currentIndex.offset() == limit) {</span>
              // Ordinarily we want to plant a jump. But refuse to do this if the block is
              // empty. This is a special case for inlining, which might otherwise create
              // some empty blocks in some cases. When parseBlock() returns with an empty
              // block, it will get repurposed instead of creating a new one. Note that this
              // logic relies on every bytecode resulting in one or more nodes, which would
              // be true anyway except for op_loop_hint, which emits a Phantom to force this
              // to be true.
  
              if (!m_currentBlock-&gt;isEmpty())
<span class="line-modified">!                 addJumpTo(m_currentIndex.offset());</span>
              return;
          }
  
          // Switch on the current bytecode opcode.
          const Instruction* currentInstruction = instructions.at(m_currentIndex).ptr();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4783,15 ***</span>
          switch (opcodeID) {
  
          // === Function entry opcodes ===
  
          case op_enter: {
<span class="line-removed">-             addToGraph(Options::usePollingTraps() ? CheckTraps : InvalidationPoint);</span>
              Node* undefined = addToGraph(JSConstant, OpInfo(m_constantUndefined));
              // Initialize all locals to undefined.
              for (int i = 0; i &lt; m_inlineStackTop-&gt;m_codeBlock-&gt;numVars(); ++i)
                  set(virtualRegisterForLocal(i), undefined, ImmediateNakedSet);
              NEXT_OPCODE(op_enter);
          }
  
          case op_to_this: {
              Node* op1 = getThis();
<span class="line-new-header">--- 4960,15 ---</span>
          switch (opcodeID) {
  
          // === Function entry opcodes ===
  
          case op_enter: {
              Node* undefined = addToGraph(JSConstant, OpInfo(m_constantUndefined));
              // Initialize all locals to undefined.
              for (int i = 0; i &lt; m_inlineStackTop-&gt;m_codeBlock-&gt;numVars(); ++i)
                  set(virtualRegisterForLocal(i), undefined, ImmediateNakedSet);
<span class="line-added">+ </span>
              NEXT_OPCODE(op_enter);
          }
  
          case op_to_this: {
              Node* op1 = getThis();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4846,21 ***</span>
                              &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {
  
                              m_graph.freeze(rareData);
                              m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());
  
<span class="line-removed">-                             // The callee is still live up to this point.</span>
<span class="line-removed">-                             addToGraph(Phantom, callee);</span>
                              Node* object = addToGraph(NewObject, OpInfo(m_graph.registerStructure(structure)));
                              if (structure-&gt;hasPolyProto()) {
                                  StorageAccessData* data = m_graph.m_storageAccessData.add();
                                  data-&gt;offset = knownPolyProtoOffset;
                                  data-&gt;identifierNumber = m_graph.identifiers().ensure(m_graph.m_vm.propertyNames-&gt;builtinNames().polyProtoName().impl());
                                  ASSERT(isInlineOffset(knownPolyProtoOffset));
                                  addToGraph(PutByOffset, OpInfo(data), object, object, weakJSConstant(prototype));
                              }
                              set(VirtualRegister(bytecode.m_dst), object);
                              alreadyEmitted = true;
                          }
                      }
                  }
              }
<span class="line-new-header">--- 5023,21 ---</span>
                              &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {
  
                              m_graph.freeze(rareData);
                              m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());
  
                              Node* object = addToGraph(NewObject, OpInfo(m_graph.registerStructure(structure)));
                              if (structure-&gt;hasPolyProto()) {
                                  StorageAccessData* data = m_graph.m_storageAccessData.add();
                                  data-&gt;offset = knownPolyProtoOffset;
                                  data-&gt;identifierNumber = m_graph.identifiers().ensure(m_graph.m_vm.propertyNames-&gt;builtinNames().polyProtoName().impl());
                                  ASSERT(isInlineOffset(knownPolyProtoOffset));
                                  addToGraph(PutByOffset, OpInfo(data), object, object, weakJSConstant(prototype));
                              }
                              set(VirtualRegister(bytecode.m_dst), object);
<span class="line-added">+                             // The callee is still live up to this point.</span>
<span class="line-added">+                             addToGraph(Phantom, callee);</span>
                              alreadyEmitted = true;
                          }
                      }
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4869,18 ***</span>
<span class="line-new-header">--- 5046,113 ---</span>
                      addToGraph(CreateThis, OpInfo(bytecode.m_inlineCapacity), callee));
              }
              NEXT_OPCODE(op_create_this);
          }
  
<span class="line-added">+         case op_create_promise: {</span>
<span class="line-added">+             JSGlobalObject* globalObject = m_graph.globalObjectFor(currentNodeOrigin().semantic);</span>
<span class="line-added">+             auto bytecode = currentInstruction-&gt;as&lt;OpCreatePromise&gt;();</span>
<span class="line-added">+             Node* callee = get(VirtualRegister(bytecode.m_callee));</span>
<span class="line-added">+ </span>
<span class="line-added">+             bool alreadyEmitted = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             {</span>
<span class="line-added">+                 // Attempt to convert to NewPromise first in easy case.</span>
<span class="line-added">+                 JSPromiseConstructor* promiseConstructor = callee-&gt;dynamicCastConstant&lt;JSPromiseConstructor*&gt;(*m_vm);</span>
<span class="line-added">+                 if (promiseConstructor == (bytecode.m_isInternalPromise ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor())) {</span>
<span class="line-added">+                     JSCell* cachedFunction = bytecode.metadata(codeBlock).m_cachedCallee.unvalidatedGet();</span>
<span class="line-added">+                     if (cachedFunction</span>
<span class="line-added">+                         &amp;&amp; cachedFunction != JSCell::seenMultipleCalleeObjects()</span>
<span class="line-added">+                         &amp;&amp; !m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCell)</span>
<span class="line-added">+                         &amp;&amp; cachedFunction == (bytecode.m_isInternalPromise ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor())) {</span>
<span class="line-added">+                         FrozenValue* frozen = m_graph.freeze(cachedFunction);</span>
<span class="line-added">+                         addToGraph(CheckCell, OpInfo(frozen), callee);</span>
<span class="line-added">+ </span>
<span class="line-added">+                         promiseConstructor = jsCast&lt;JSPromiseConstructor*&gt;(cachedFunction);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (promiseConstructor) {</span>
<span class="line-added">+                     addToGraph(Phantom, callee);</span>
<span class="line-added">+                     set(VirtualRegister(bytecode.m_dst), addToGraph(NewPromise, OpInfo(m_graph.registerStructure(bytecode.m_isInternalPromise ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure())), OpInfo(bytecode.m_isInternalPromise)));</span>
<span class="line-added">+                     alreadyEmitted = true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Derived function case.</span>
<span class="line-added">+             if (!alreadyEmitted) {</span>
<span class="line-added">+                 JSFunction* function = callee-&gt;dynamicCastConstant&lt;JSFunction*&gt;(*m_vm);</span>
<span class="line-added">+                 if (!function) {</span>
<span class="line-added">+                     JSCell* cachedFunction = bytecode.metadata(codeBlock).m_cachedCallee.unvalidatedGet();</span>
<span class="line-added">+                     if (cachedFunction</span>
<span class="line-added">+                         &amp;&amp; cachedFunction != JSCell::seenMultipleCalleeObjects()</span>
<span class="line-added">+                         &amp;&amp; !m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCell)) {</span>
<span class="line-added">+                         ASSERT(cachedFunction-&gt;inherits&lt;JSFunction&gt;(*m_vm));</span>
<span class="line-added">+ </span>
<span class="line-added">+                         FrozenValue* frozen = m_graph.freeze(cachedFunction);</span>
<span class="line-added">+                         addToGraph(CheckCell, OpInfo(frozen), callee);</span>
<span class="line-added">+ </span>
<span class="line-added">+                         function = static_cast&lt;JSFunction*&gt;(cachedFunction);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (function) {</span>
<span class="line-added">+                     if (FunctionRareData* rareData = function-&gt;rareData()) {</span>
<span class="line-added">+                         if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added">+                             Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="line-added">+                             if (structure</span>
<span class="line-added">+                                 &amp;&amp; structure-&gt;classInfo() == (bytecode.m_isInternalPromise ? JSInternalPromise::info() : JSPromise::info())</span>
<span class="line-added">+                                 &amp;&amp; structure-&gt;globalObject() == globalObject</span>
<span class="line-added">+                                 &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added">+                                 m_graph.freeze(rareData);</span>
<span class="line-added">+                                 m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-added">+ </span>
<span class="line-added">+                                 set(VirtualRegister(bytecode.m_dst), addToGraph(NewPromise, OpInfo(m_graph.registerStructure(structure)), OpInfo(bytecode.m_isInternalPromise)));</span>
<span class="line-added">+                                 // The callee is still live up to this point.</span>
<span class="line-added">+                                 addToGraph(Phantom, callee);</span>
<span class="line-added">+                                 alreadyEmitted = true;</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (!alreadyEmitted)</span>
<span class="line-added">+                     set(VirtualRegister(bytecode.m_dst), addToGraph(CreatePromise, OpInfo(), OpInfo(bytecode.m_isInternalPromise), callee));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             NEXT_OPCODE(op_create_promise);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case op_create_generator: {</span>
<span class="line-added">+             handleCreateInternalFieldObject(JSGenerator::info(), CreateGenerator, NewGenerator, currentInstruction-&gt;as&lt;OpCreateGenerator&gt;());</span>
<span class="line-added">+             NEXT_OPCODE(op_create_generator);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case op_create_async_generator: {</span>
<span class="line-added">+             handleCreateInternalFieldObject(JSAsyncGenerator::info(), CreateAsyncGenerator, NewAsyncGenerator, currentInstruction-&gt;as&lt;OpCreateAsyncGenerator&gt;());</span>
<span class="line-added">+             NEXT_OPCODE(op_create_async_generator);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case op_new_object: {
              auto bytecode = currentInstruction-&gt;as&lt;OpNewObject&gt;();
              set(bytecode.m_dst,
                  addToGraph(NewObject,
                      OpInfo(m_graph.registerStructure(bytecode.metadata(codeBlock).m_objectAllocationProfile.structure()))));
              NEXT_OPCODE(op_new_object);
          }
  
<span class="line-added">+         case op_new_promise: {</span>
<span class="line-added">+             auto bytecode = currentInstruction-&gt;as&lt;OpNewPromise&gt;();</span>
<span class="line-added">+             JSGlobalObject* globalObject = m_graph.globalObjectFor(currentNodeOrigin().semantic);</span>
<span class="line-added">+             set(bytecode.m_dst, addToGraph(NewPromise, OpInfo(m_graph.registerStructure(bytecode.m_isInternalPromise ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure())), OpInfo(bytecode.m_isInternalPromise)));</span>
<span class="line-added">+             NEXT_OPCODE(op_new_promise);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case op_new_generator: {</span>
<span class="line-added">+             auto bytecode = currentInstruction-&gt;as&lt;OpNewGenerator&gt;();</span>
<span class="line-added">+             JSGlobalObject* globalObject = m_graph.globalObjectFor(currentNodeOrigin().semantic);</span>
<span class="line-added">+             set(bytecode.m_dst, addToGraph(NewGenerator, OpInfo(m_graph.registerStructure(globalObject-&gt;generatorStructure()))));</span>
<span class="line-added">+             NEXT_OPCODE(op_new_generator);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case op_new_array: {
              auto bytecode = currentInstruction-&gt;as&lt;OpNewArray&gt;();
              int startOperand = bytecode.m_argv.offset();
              int numOperands = bytecode.m_argc;
              ArrayAllocationProfile&amp; profile = bytecode.metadata(codeBlock).m_arrayAllocationProfile;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4938,11 ***</span>
          }
  
          case op_new_regexp: {
              auto bytecode = currentInstruction-&gt;as&lt;OpNewRegexp&gt;();
              ASSERT(bytecode.m_regexp.isConstant());
<span class="line-modified">!             FrozenValue* frozenRegExp = m_graph.freezeStrong(m_inlineStackTop-&gt;m_codeBlock-&gt;getConstant(bytecode.m_regexp.offset()));</span>
              set(bytecode.m_dst, addToGraph(NewRegexp, OpInfo(frozenRegExp), jsConstant(jsNumber(0))));
              NEXT_OPCODE(op_new_regexp);
          }
  
          case op_get_rest_length: {
<span class="line-new-header">--- 5210,11 ---</span>
          }
  
          case op_new_regexp: {
              auto bytecode = currentInstruction-&gt;as&lt;OpNewRegexp&gt;();
              ASSERT(bytecode.m_regexp.isConstant());
<span class="line-modified">!             FrozenValue* frozenRegExp = m_graph.freezeStrong(m_inlineStackTop-&gt;m_codeBlock-&gt;getConstant(bytecode.m_regexp));</span>
              set(bytecode.m_dst, addToGraph(NewRegexp, OpInfo(frozenRegExp), jsConstant(jsNumber(0))));
              NEXT_OPCODE(op_new_regexp);
          }
  
          case op_get_rest_length: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5024,11 ***</span>
  
          case op_rshift: {
              auto bytecode = currentInstruction-&gt;as&lt;OpRshift&gt;();
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
<span class="line-modified">!             set(bytecode.m_dst, addToGraph(BitRShift, op1, op2));</span>
              NEXT_OPCODE(op_rshift);
          }
  
          case op_lshift: {
              auto bytecode = currentInstruction-&gt;as&lt;OpLshift&gt;();
<span class="line-new-header">--- 5296,16 ---</span>
  
          case op_rshift: {
              auto bytecode = currentInstruction-&gt;as&lt;OpRshift&gt;();
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
<span class="line-modified">!             if (op1-&gt;hasNumberOrAnyIntResult() &amp;&amp; op2-&gt;hasNumberOrAnyIntResult())</span>
<span class="line-added">+                 set(bytecode.m_dst, addToGraph(ArithBitRShift, op1, op2));</span>
<span class="line-added">+             else {</span>
<span class="line-added">+                 SpeculatedType prediction = getPredictionWithoutOSRExit();</span>
<span class="line-added">+                 set(bytecode.m_dst, addToGraph(ValueBitRShift, OpInfo(), OpInfo(prediction), op1, op2));</span>
<span class="line-added">+             }</span>
              NEXT_OPCODE(op_rshift);
          }
  
          case op_lshift: {
              auto bytecode = currentInstruction-&gt;as&lt;OpLshift&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5060,18 ***</span>
          // === Increment/Decrement opcodes ===
  
          case op_inc: {
              auto bytecode = currentInstruction-&gt;as&lt;OpInc&gt;();
              Node* op = get(bytecode.m_srcDst);
<span class="line-modified">!             set(bytecode.m_srcDst, makeSafe(addToGraph(ArithAdd, op, addToGraph(JSConstant, OpInfo(m_constantOne)))));</span>
              NEXT_OPCODE(op_inc);
          }
  
          case op_dec: {
              auto bytecode = currentInstruction-&gt;as&lt;OpDec&gt;();
              Node* op = get(bytecode.m_srcDst);
<span class="line-modified">!             set(bytecode.m_srcDst, makeSafe(addToGraph(ArithSub, op, addToGraph(JSConstant, OpInfo(m_constantOne)))));</span>
              NEXT_OPCODE(op_dec);
          }
  
          // === Arithmetic operations ===
  
<span class="line-new-header">--- 5337,24 ---</span>
          // === Increment/Decrement opcodes ===
  
          case op_inc: {
              auto bytecode = currentInstruction-&gt;as&lt;OpInc&gt;();
              Node* op = get(bytecode.m_srcDst);
<span class="line-modified">!             // FIXME: we can replace the Inc by either ArithAdd with m_constantOne or ArithAdd with the equivalent BigInt in many cases.</span>
<span class="line-added">+             // For now we only do so in DFGFixupPhase.</span>
<span class="line-added">+             // We could probably do it earlier in some cases, but it is not clearly worth the trouble.</span>
<span class="line-added">+             set(bytecode.m_srcDst, makeSafe(addToGraph(Inc, op)));</span>
              NEXT_OPCODE(op_inc);
          }
  
          case op_dec: {
              auto bytecode = currentInstruction-&gt;as&lt;OpDec&gt;();
              Node* op = get(bytecode.m_srcDst);
<span class="line-modified">!             // FIXME: we can replace the Inc by either ArithSub with m_constantOne or ArithSub with the equivalent BigInt in many cases.</span>
<span class="line-added">+             // For now we only do so in DFGFixupPhase.</span>
<span class="line-added">+             // We could probably do it earlier in some cases, but it is not clearly worth the trouble.</span>
<span class="line-added">+             set(bytecode.m_srcDst, makeSafe(addToGraph(Dec, op)));</span>
              NEXT_OPCODE(op_dec);
          }
  
          // === Arithmetic operations ===
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5319,22 ***</span>
              Node* value = get(bytecode.m_src);
              set(bytecode.m_dst, addToGraph(ToPrimitive, value));
              NEXT_OPCODE(op_to_primitive);
          }
  
          case op_strcat: {
              auto bytecode = currentInstruction-&gt;as&lt;OpStrcat&gt;();
              int startOperand = bytecode.m_src.offset();
              int numOperands = bytecode.m_count;
<span class="line-removed">- #if CPU(X86)</span>
<span class="line-removed">-             // X86 doesn&#39;t have enough registers to compile MakeRope with three arguments. The</span>
<span class="line-removed">-             // StrCat we emit here may be turned into a MakeRope. Rather than try to be clever,</span>
<span class="line-removed">-             // we just make StrCat dumber on this processor.</span>
<span class="line-removed">-             const unsigned maxArguments = 2;</span>
<span class="line-removed">- #else</span>
              const unsigned maxArguments = 3;
<span class="line-removed">- #endif</span>
              Node* operands[AdjacencyList::Size];
              unsigned indexInOperands = 0;
              for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i)
                  operands[i] = 0;
              for (int operandIdx = 0; operandIdx &lt; numOperands; ++operandIdx) {
<span class="line-new-header">--- 5602,22 ---</span>
              Node* value = get(bytecode.m_src);
              set(bytecode.m_dst, addToGraph(ToPrimitive, value));
              NEXT_OPCODE(op_to_primitive);
          }
  
<span class="line-added">+         case op_to_property_key: {</span>
<span class="line-added">+             auto bytecode = currentInstruction-&gt;as&lt;OpToPropertyKey&gt;();</span>
<span class="line-added">+             Node* value = get(bytecode.m_src);</span>
<span class="line-added">+             set(bytecode.m_dst, addToGraph(ToPropertyKey, value));</span>
<span class="line-added">+             NEXT_OPCODE(op_to_property_key);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case op_strcat: {
              auto bytecode = currentInstruction-&gt;as&lt;OpStrcat&gt;();
              int startOperand = bytecode.m_src.offset();
              int numOperands = bytecode.m_count;
              const unsigned maxArguments = 3;
              Node* operands[AdjacencyList::Size];
              unsigned indexInOperands = 0;
              for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i)
                  operands[i] = 0;
              for (int operandIdx = 0; operandIdx &lt; numOperands; ++operandIdx) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5457,44 ***</span>
              auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();
              SpeculatedType prediction = getPredictionWithoutOSRExit();
  
              Node* base = get(bytecode.m_base);
              Node* property = get(bytecode.m_property);
<span class="line-modified">!             bool compiledAsGetById = false;</span>
<span class="line-modified">!             GetByIdStatus getByIdStatus;</span>
              unsigned identifierNumber = 0;
<span class="line-removed">-             {</span>
<span class="line-removed">-                 ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);</span>
<span class="line-removed">-                 ByValInfo* byValInfo = m_inlineStackTop-&gt;m_baselineMap.get(CodeOrigin(currentCodeOrigin().bytecodeIndex())).byValInfo;</span>
<span class="line-removed">-                 // FIXME: When the bytecode is not compiled in the baseline JIT, byValInfo becomes null.</span>
<span class="line-removed">-                 // At that time, there is no information.</span>
<span class="line-removed">-                 if (byValInfo</span>
<span class="line-removed">-                     &amp;&amp; byValInfo-&gt;stubInfo</span>
<span class="line-removed">-                     &amp;&amp; !byValInfo-&gt;tookSlowPath</span>
<span class="line-removed">-                     &amp;&amp; !m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadIdent)</span>
<span class="line-removed">-                     &amp;&amp; !m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType)</span>
<span class="line-removed">-                     &amp;&amp; !m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCell)) {</span>
<span class="line-removed">-                     compiledAsGetById = true;</span>
<span class="line-removed">-                     identifierNumber = m_graph.identifiers().ensure(byValInfo-&gt;cachedId.impl());</span>
<span class="line-removed">-                     UniquedStringImpl* uid = m_graph.identifiers()[identifierNumber];</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     if (Symbol* symbol = byValInfo-&gt;cachedSymbol.get()) {</span>
<span class="line-removed">-                         FrozenValue* frozen = m_graph.freezeStrong(symbol);</span>
<span class="line-removed">-                         addToGraph(CheckCell, OpInfo(frozen), property);</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         ASSERT(!uid-&gt;isSymbol());</span>
<span class="line-removed">-                         addToGraph(CheckStringIdent, OpInfo(uid), property);</span>
<span class="line-removed">-                     }</span>
  
<span class="line-modified">!                     getByIdStatus = GetByIdStatus::computeForStubInfo(</span>
<span class="line-modified">!                         locker, m_inlineStackTop-&gt;m_profiledBlock,</span>
<span class="line-modified">!                         byValInfo-&gt;stubInfo, currentCodeOrigin(), uid);</span>
                  }
              }
  
<span class="line-modified">!             if (compiledAsGetById)</span>
<span class="line-modified">!                 handleGetById(bytecode.m_dst, prediction, base, identifierNumber, getByIdStatus, AccessType::Get, currentInstruction-&gt;size());</span>
              else {
                  ArrayMode arrayMode = getArrayMode(bytecode.metadata(codeBlock).m_arrayProfile, Array::Read);
                  // FIXME: We could consider making this not vararg, since it only uses three child
                  // slots.
                  // https://bugs.webkit.org/show_bug.cgi?id=184192
<span class="line-new-header">--- 5740,39 ---</span>
              auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();
              SpeculatedType prediction = getPredictionWithoutOSRExit();
  
              Node* base = get(bytecode.m_base);
              Node* property = get(bytecode.m_property);
<span class="line-modified">!             bool shouldCompileAsGetById = false;</span>
<span class="line-modified">!             GetByStatus getByStatus = GetByStatus::computeFor(m_inlineStackTop-&gt;m_profiledBlock, m_inlineStackTop-&gt;m_baselineMap, m_icContextStack, currentCodeOrigin());</span>
<span class="line-added">+ </span>
              unsigned identifierNumber = 0;
  
<span class="line-modified">!             if (!m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadIdent)</span>
<span class="line-modified">!                 &amp;&amp; !m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadType)</span>
<span class="line-modified">!                 &amp;&amp; !m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCell)) {</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // FIXME: In the future, we should be able to do something like MultiGetByOffset in a multi identifier mode.</span>
<span class="line-added">+                 // That way, we could both switch on multiple structures and multiple identifiers (or int 32 properties).</span>
<span class="line-added">+                 // https://bugs.webkit.org/show_bug.cgi?id=204216</span>
<span class="line-added">+                 if (CacheableIdentifier identifier = getByStatus.singleIdentifier()) {</span>
<span class="line-added">+                     UniquedStringImpl* uid = identifier.uid();</span>
<span class="line-added">+                     identifierNumber = m_graph.identifiers().ensure(identifier.uid());</span>
<span class="line-added">+                     if (identifier.isCell()) {</span>
<span class="line-added">+                         FrozenValue* frozen = m_graph.freezeStrong(identifier.cell());</span>
<span class="line-added">+                         if (identifier.isSymbolCell())</span>
<span class="line-added">+                             addToGraph(CheckCell, OpInfo(frozen), property);</span>
<span class="line-added">+                         else</span>
<span class="line-added">+                             addToGraph(CheckIdent, OpInfo(uid), property);</span>
<span class="line-added">+                     } else</span>
<span class="line-added">+                         addToGraph(CheckIdent, OpInfo(uid), property);</span>
<span class="line-added">+                     shouldCompileAsGetById = true;</span>
                  }
              }
  
<span class="line-modified">!             if (shouldCompileAsGetById)</span>
<span class="line-modified">!                 handleGetById(bytecode.m_dst, prediction, base, identifierNumber, getByStatus, AccessType::GetById, currentInstruction-&gt;size());</span>
              else {
                  ArrayMode arrayMode = getArrayMode(bytecode.metadata(codeBlock).m_arrayProfile, Array::Read);
                  // FIXME: We could consider making this not vararg, since it only uses three child
                  // slots.
                  // https://bugs.webkit.org/show_bug.cgi?id=184192
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5502,10 ***</span>
<span class="line-new-header">--- 5780,12 ---</span>
                  addVarArgChild(property);
                  addVarArgChild(0); // Leave room for property storage.
                  Node* getByVal = addToGraph(Node::VarArg, GetByVal, OpInfo(arrayMode.asWord()), OpInfo(prediction));
                  m_exitOK = false; // GetByVal must be treated as if it clobbers exit state, since FixupPhase may make it generic.
                  set(bytecode.m_dst, getByVal);
<span class="line-added">+                 if (getByStatus.observedStructureStubInfoSlowPath() || bytecode.metadata(codeBlock).m_seenIdentifiers.count() &gt; Options::getByValICMaxNumberOfIdentifiers())</span>
<span class="line-added">+                     m_graph.m_slowGetByVal.add(getByVal);</span>
              }
  
              NEXT_OPCODE(op_get_by_val);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5694,221 ***</span>
  
          case op_jmp: {
              ASSERT(!m_currentBlock-&gt;terminal());
              auto bytecode = currentInstruction-&gt;as&lt;OpJmp&gt;();
              int relativeOffset = jumpTarget(bytecode.m_targetLabel);
<span class="line-modified">!             addToGraph(Jump, OpInfo(m_currentIndex + relativeOffset));</span>
              if (relativeOffset &lt;= 0)
                  flushForTerminal();
              LAST_OPCODE(op_jmp);
          }
  
          case op_jtrue: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJtrue&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* condition = get(bytecode.m_condition);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + relativeOffset, m_currentIndex + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jtrue);
          }
  
          case op_jfalse: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJfalse&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* condition = get(bytecode.m_condition);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + currentInstruction-&gt;size(), m_currentIndex + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jfalse);
          }
  
          case op_jeq_null: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJeqNull&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* value = get(bytecode.m_value);
              Node* nullConstant = addToGraph(JSConstant, OpInfo(m_constantNull));
              Node* condition = addToGraph(CompareEq, value, nullConstant);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + relativeOffset, m_currentIndex + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jeq_null);
          }
  
          case op_jneq_null: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJneqNull&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* value = get(bytecode.m_value);
              Node* nullConstant = addToGraph(JSConstant, OpInfo(m_constantNull));
              Node* condition = addToGraph(CompareEq, value, nullConstant);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + currentInstruction-&gt;size(), m_currentIndex + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jneq_null);
          }
  
          case op_jundefined_or_null: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJundefinedOrNull&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* value = get(bytecode.m_value);
              Node* condition = addToGraph(IsUndefinedOrNull, value);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + relativeOffset, m_currentIndex + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jundefined_or_null);
          }
  
          case op_jnundefined_or_null: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJnundefinedOrNull&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* value = get(bytecode.m_value);
              Node* condition = addToGraph(IsUndefinedOrNull, value);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + currentInstruction-&gt;size(), m_currentIndex + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jnundefined_or_null);
          }
  
          case op_jless: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJless&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareLess, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + relativeOffset, m_currentIndex + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jless);
          }
  
          case op_jlesseq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJlesseq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareLessEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + relativeOffset, m_currentIndex + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jlesseq);
          }
  
          case op_jgreater: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJgreater&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareGreater, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + relativeOffset, m_currentIndex + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jgreater);
          }
  
          case op_jgreatereq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJgreatereq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareGreaterEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + relativeOffset, m_currentIndex + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jgreatereq);
          }
  
          case op_jeq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJeq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + relativeOffset, m_currentIndex + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jeq);
          }
  
          case op_jstricteq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJstricteq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareStrictEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + relativeOffset, m_currentIndex + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jstricteq);
          }
  
          case op_jnless: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJnless&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareLess, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + currentInstruction-&gt;size(), m_currentIndex + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jnless);
          }
  
          case op_jnlesseq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJnlesseq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareLessEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + currentInstruction-&gt;size(), m_currentIndex + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jnlesseq);
          }
  
          case op_jngreater: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJngreater&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareGreater, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + currentInstruction-&gt;size(), m_currentIndex + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jngreater);
          }
  
          case op_jngreatereq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJngreatereq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareGreaterEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + currentInstruction-&gt;size(), m_currentIndex + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jngreatereq);
          }
  
          case op_jneq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJneq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + currentInstruction-&gt;size(), m_currentIndex + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jneq);
          }
  
          case op_jnstricteq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJnstricteq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareStrictEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + currentInstruction-&gt;size(), m_currentIndex + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jnstricteq);
          }
  
          case op_jbelow: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJbelow&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareBelow, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + relativeOffset, m_currentIndex + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jbelow);
          }
  
          case op_jbeloweq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJbeloweq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareBelowEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex + relativeOffset, m_currentIndex + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jbeloweq);
          }
  
          case op_switch_imm: {
              auto bytecode = currentInstruction-&gt;as&lt;OpSwitchImm&gt;();
              SwitchData&amp; data = *m_graph.m_switchData.add();
              data.kind = SwitchImm;
              data.switchTableIndex = m_inlineStackTop-&gt;m_switchRemap[bytecode.m_tableIndex];
<span class="line-modified">!             data.fallThrough.setBytecodeIndex(m_currentIndex + jumpTarget(bytecode.m_defaultOffset));</span>
              SimpleJumpTable&amp; table = m_codeBlock-&gt;switchJumpTable(data.switchTableIndex);
              for (unsigned i = 0; i &lt; table.branchOffsets.size(); ++i) {
                  if (!table.branchOffsets[i])
                      continue;
<span class="line-modified">!                 unsigned target = m_currentIndex + table.branchOffsets[i];</span>
                  if (target == data.fallThrough.bytecodeIndex())
                      continue;
                  data.cases.append(SwitchCase::withBytecodeIndex(m_graph.freeze(jsNumber(static_cast&lt;int32_t&gt;(table.min + i))), target));
              }
              addToGraph(Switch, OpInfo(&amp;data), get(bytecode.m_scrutinee));
<span class="line-new-header">--- 5974,221 ---</span>
  
          case op_jmp: {
              ASSERT(!m_currentBlock-&gt;terminal());
              auto bytecode = currentInstruction-&gt;as&lt;OpJmp&gt;();
              int relativeOffset = jumpTarget(bytecode.m_targetLabel);
<span class="line-modified">!             addToGraph(Jump, OpInfo(m_currentIndex.offset() + relativeOffset));</span>
              if (relativeOffset &lt;= 0)
                  flushForTerminal();
              LAST_OPCODE(op_jmp);
          }
  
          case op_jtrue: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJtrue&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* condition = get(bytecode.m_condition);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + relativeOffset, m_currentIndex.offset() + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jtrue);
          }
  
          case op_jfalse: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJfalse&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* condition = get(bytecode.m_condition);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + currentInstruction-&gt;size(), m_currentIndex.offset() + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jfalse);
          }
  
          case op_jeq_null: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJeqNull&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* value = get(bytecode.m_value);
              Node* nullConstant = addToGraph(JSConstant, OpInfo(m_constantNull));
              Node* condition = addToGraph(CompareEq, value, nullConstant);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + relativeOffset, m_currentIndex.offset() + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jeq_null);
          }
  
          case op_jneq_null: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJneqNull&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* value = get(bytecode.m_value);
              Node* nullConstant = addToGraph(JSConstant, OpInfo(m_constantNull));
              Node* condition = addToGraph(CompareEq, value, nullConstant);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + currentInstruction-&gt;size(), m_currentIndex.offset() + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jneq_null);
          }
  
          case op_jundefined_or_null: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJundefinedOrNull&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* value = get(bytecode.m_value);
              Node* condition = addToGraph(IsUndefinedOrNull, value);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + relativeOffset, m_currentIndex.offset() + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jundefined_or_null);
          }
  
          case op_jnundefined_or_null: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJnundefinedOrNull&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* value = get(bytecode.m_value);
              Node* condition = addToGraph(IsUndefinedOrNull, value);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + currentInstruction-&gt;size(), m_currentIndex.offset() + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jnundefined_or_null);
          }
  
          case op_jless: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJless&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareLess, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + relativeOffset, m_currentIndex.offset() + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jless);
          }
  
          case op_jlesseq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJlesseq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareLessEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + relativeOffset, m_currentIndex.offset() + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jlesseq);
          }
  
          case op_jgreater: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJgreater&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareGreater, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + relativeOffset, m_currentIndex.offset() + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jgreater);
          }
  
          case op_jgreatereq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJgreatereq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareGreaterEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + relativeOffset, m_currentIndex.offset() + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jgreatereq);
          }
  
          case op_jeq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJeq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + relativeOffset, m_currentIndex.offset() + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jeq);
          }
  
          case op_jstricteq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJstricteq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareStrictEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + relativeOffset, m_currentIndex.offset() + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jstricteq);
          }
  
          case op_jnless: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJnless&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareLess, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + currentInstruction-&gt;size(), m_currentIndex.offset() + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jnless);
          }
  
          case op_jnlesseq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJnlesseq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareLessEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + currentInstruction-&gt;size(), m_currentIndex.offset() + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jnlesseq);
          }
  
          case op_jngreater: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJngreater&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareGreater, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + currentInstruction-&gt;size(), m_currentIndex.offset() + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jngreater);
          }
  
          case op_jngreatereq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJngreatereq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareGreaterEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + currentInstruction-&gt;size(), m_currentIndex.offset() + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jngreatereq);
          }
  
          case op_jneq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJneq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + currentInstruction-&gt;size(), m_currentIndex.offset() + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jneq);
          }
  
          case op_jnstricteq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJnstricteq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareStrictEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + currentInstruction-&gt;size(), m_currentIndex.offset() + relativeOffset)), condition);</span>
              LAST_OPCODE(op_jnstricteq);
          }
  
          case op_jbelow: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJbelow&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareBelow, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + relativeOffset, m_currentIndex.offset() + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jbelow);
          }
  
          case op_jbeloweq: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJbeloweq&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
              Node* condition = addToGraph(CompareBelowEq, op1, op2);
<span class="line-modified">!             addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + relativeOffset, m_currentIndex.offset() + currentInstruction-&gt;size())), condition);</span>
              LAST_OPCODE(op_jbeloweq);
          }
  
          case op_switch_imm: {
              auto bytecode = currentInstruction-&gt;as&lt;OpSwitchImm&gt;();
              SwitchData&amp; data = *m_graph.m_switchData.add();
              data.kind = SwitchImm;
              data.switchTableIndex = m_inlineStackTop-&gt;m_switchRemap[bytecode.m_tableIndex];
<span class="line-modified">!             data.fallThrough.setBytecodeIndex(m_currentIndex.offset() + jumpTarget(bytecode.m_defaultOffset));</span>
              SimpleJumpTable&amp; table = m_codeBlock-&gt;switchJumpTable(data.switchTableIndex);
              for (unsigned i = 0; i &lt; table.branchOffsets.size(); ++i) {
                  if (!table.branchOffsets[i])
                      continue;
<span class="line-modified">!                 unsigned target = m_currentIndex.offset() + table.branchOffsets[i];</span>
                  if (target == data.fallThrough.bytecodeIndex())
                      continue;
                  data.cases.append(SwitchCase::withBytecodeIndex(m_graph.freeze(jsNumber(static_cast&lt;int32_t&gt;(table.min + i))), target));
              }
              addToGraph(Switch, OpInfo(&amp;data), get(bytecode.m_scrutinee));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5919,16 ***</span>
          case op_switch_char: {
              auto bytecode = currentInstruction-&gt;as&lt;OpSwitchChar&gt;();
              SwitchData&amp; data = *m_graph.m_switchData.add();
              data.kind = SwitchChar;
              data.switchTableIndex = m_inlineStackTop-&gt;m_switchRemap[bytecode.m_tableIndex];
<span class="line-modified">!             data.fallThrough.setBytecodeIndex(m_currentIndex + jumpTarget(bytecode.m_defaultOffset));</span>
              SimpleJumpTable&amp; table = m_codeBlock-&gt;switchJumpTable(data.switchTableIndex);
              for (unsigned i = 0; i &lt; table.branchOffsets.size(); ++i) {
                  if (!table.branchOffsets[i])
                      continue;
<span class="line-modified">!                 unsigned target = m_currentIndex + table.branchOffsets[i];</span>
                  if (target == data.fallThrough.bytecodeIndex())
                      continue;
                  data.cases.append(
                      SwitchCase::withBytecodeIndex(LazyJSValue::singleCharacterString(table.min + i), target));
              }
<span class="line-new-header">--- 6199,16 ---</span>
          case op_switch_char: {
              auto bytecode = currentInstruction-&gt;as&lt;OpSwitchChar&gt;();
              SwitchData&amp; data = *m_graph.m_switchData.add();
              data.kind = SwitchChar;
              data.switchTableIndex = m_inlineStackTop-&gt;m_switchRemap[bytecode.m_tableIndex];
<span class="line-modified">!             data.fallThrough.setBytecodeIndex(m_currentIndex.offset() + jumpTarget(bytecode.m_defaultOffset));</span>
              SimpleJumpTable&amp; table = m_codeBlock-&gt;switchJumpTable(data.switchTableIndex);
              for (unsigned i = 0; i &lt; table.branchOffsets.size(); ++i) {
                  if (!table.branchOffsets[i])
                      continue;
<span class="line-modified">!                 unsigned target = m_currentIndex.offset() + table.branchOffsets[i];</span>
                  if (target == data.fallThrough.bytecodeIndex())
                      continue;
                  data.cases.append(
                      SwitchCase::withBytecodeIndex(LazyJSValue::singleCharacterString(table.min + i), target));
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5940,16 ***</span>
          case op_switch_string: {
              auto bytecode = currentInstruction-&gt;as&lt;OpSwitchString&gt;();
              SwitchData&amp; data = *m_graph.m_switchData.add();
              data.kind = SwitchString;
              data.switchTableIndex = bytecode.m_tableIndex;
<span class="line-modified">!             data.fallThrough.setBytecodeIndex(m_currentIndex + jumpTarget(bytecode.m_defaultOffset));</span>
              StringJumpTable&amp; table = m_codeBlock-&gt;stringSwitchJumpTable(data.switchTableIndex);
              StringJumpTable::StringOffsetTable::iterator iter;
              StringJumpTable::StringOffsetTable::iterator end = table.offsetTable.end();
              for (iter = table.offsetTable.begin(); iter != end; ++iter) {
<span class="line-modified">!                 unsigned target = m_currentIndex + iter-&gt;value.branchOffset;</span>
                  if (target == data.fallThrough.bytecodeIndex())
                      continue;
                  data.cases.append(
                      SwitchCase::withBytecodeIndex(LazyJSValue::knownStringImpl(iter-&gt;key.get()), target));
              }
<span class="line-new-header">--- 6220,16 ---</span>
          case op_switch_string: {
              auto bytecode = currentInstruction-&gt;as&lt;OpSwitchString&gt;();
              SwitchData&amp; data = *m_graph.m_switchData.add();
              data.kind = SwitchString;
              data.switchTableIndex = bytecode.m_tableIndex;
<span class="line-modified">!             data.fallThrough.setBytecodeIndex(m_currentIndex.offset() + jumpTarget(bytecode.m_defaultOffset));</span>
              StringJumpTable&amp; table = m_codeBlock-&gt;stringSwitchJumpTable(data.switchTableIndex);
              StringJumpTable::StringOffsetTable::iterator iter;
              StringJumpTable::StringOffsetTable::iterator end = table.offsetTable.end();
              for (iter = table.offsetTable.begin(); iter != end; ++iter) {
<span class="line-modified">!                 unsigned target = m_currentIndex.offset() + iter-&gt;value.branchOffset;</span>
                  if (target == data.fallThrough.bytecodeIndex())
                      continue;
                  data.cases.append(
                      SwitchCase::withBytecodeIndex(LazyJSValue::knownStringImpl(iter-&gt;key.get()), target));
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5970,11 ***</span>
  
              flushForReturn();
              if (m_inlineStackTop-&gt;m_returnValue.isValid())
                  setDirect(m_inlineStackTop-&gt;m_returnValue, get(bytecode.m_value), ImmediateSetWithFlush);
  
<span class="line-modified">!             if (!m_inlineStackTop-&gt;m_continuationBlock &amp;&amp; m_currentIndex + currentInstruction-&gt;size() != m_inlineStackTop-&gt;m_codeBlock-&gt;instructions().size()) {</span>
                  // This is an early return from an inlined function and we do not have a continuation block, so we must allocate one.
                  // It is untargetable, because we do not know the appropriate index.
                  // If this block turns out to be a jump target, parseCodeBlock will fix its bytecodeIndex before putting it in m_blockLinkingTargets
                  m_inlineStackTop-&gt;m_continuationBlock = allocateUntargetableBlock();
              }
<span class="line-new-header">--- 6250,11 ---</span>
  
              flushForReturn();
              if (m_inlineStackTop-&gt;m_returnValue.isValid())
                  setDirect(m_inlineStackTop-&gt;m_returnValue, get(bytecode.m_value), ImmediateSetWithFlush);
  
<span class="line-modified">!             if (!m_inlineStackTop-&gt;m_continuationBlock &amp;&amp; m_currentIndex.offset() + currentInstruction-&gt;size() != m_inlineStackTop-&gt;m_codeBlock-&gt;instructions().size()) {</span>
                  // This is an early return from an inlined function and we do not have a continuation block, so we must allocate one.
                  // It is untargetable, because we do not know the appropriate index.
                  // If this block turns out to be a jump target, parseCodeBlock will fix its bytecodeIndex before putting it in m_blockLinkingTargets
                  m_inlineStackTop-&gt;m_continuationBlock = allocateUntargetableBlock();
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6018,11 ***</span>
                  NEXT_OPCODE(op_catch);
              }
  
              RELEASE_ASSERT(!m_currentBlock-&gt;size() || (m_graph.compilation() &amp;&amp; m_currentBlock-&gt;size() == 1 &amp;&amp; m_currentBlock-&gt;at(0)-&gt;op() == CountExecution));
  
<span class="line-modified">!             ValueProfileAndOperandBuffer* buffer = bytecode.metadata(codeBlock).m_buffer;</span>
  
              if (!buffer) {
                  NEXT_OPCODE(op_catch); // This catch has yet to execute. Note: this load can be racy with the main thread.
              }
  
<span class="line-new-header">--- 6298,11 ---</span>
                  NEXT_OPCODE(op_catch);
              }
  
              RELEASE_ASSERT(!m_currentBlock-&gt;size() || (m_graph.compilation() &amp;&amp; m_currentBlock-&gt;size() == 1 &amp;&amp; m_currentBlock-&gt;at(0)-&gt;op() == CountExecution));
  
<span class="line-modified">!             ValueProfileAndVirtualRegisterBuffer* buffer = bytecode.metadata(codeBlock).m_buffer;</span>
  
              if (!buffer) {
                  NEXT_OPCODE(op_catch); // This catch has yet to execute. Note: this load can be racy with the main thread.
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6035,11 ***</span>
              HashSet&lt;unsigned, WTF::IntHash&lt;unsigned&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; seenArguments;
  
              {
                  ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);
  
<span class="line-modified">!                 buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {</span>
                      VirtualRegister operand(profile.m_operand);
                      SpeculatedType prediction = profile.computeUpdatedPrediction(locker);
                      if (operand.isLocal())
                          localPredictions.append(prediction);
                      else {
<span class="line-new-header">--- 6315,11 ---</span>
              HashSet&lt;unsigned, WTF::IntHash&lt;unsigned&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; seenArguments;
  
              {
                  ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);
  
<span class="line-modified">!                 buffer-&gt;forEach([&amp;] (ValueProfileAndVirtualRegister&amp; profile) {</span>
                      VirtualRegister operand(profile.m_operand);
                      SpeculatedType prediction = profile.computeUpdatedPrediction(locker);
                      if (operand.isLocal())
                          localPredictions.append(prediction);
                      else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6063,18 ***</span>
              // We&#39;re not allowed to exit here since we would not properly recover values.
              // We first need to bootstrap the catch entrypoint state.
              m_exitOK = false;
  
              unsigned numberOfLocals = 0;
<span class="line-modified">!             buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {</span>
                  VirtualRegister operand(profile.m_operand);
                  if (operand.isArgument())
                      return;
                  ASSERT(operand.isLocal());
                  Node* value = addToGraph(ExtractCatchLocal, OpInfo(numberOfLocals), OpInfo(localPredictions[numberOfLocals]));
                  ++numberOfLocals;
<span class="line-modified">!                 addToGraph(MovHint, OpInfo(profile.m_operand), value);</span>
                  localsToSet.uncheckedAppend(std::make_pair(operand, value));
              });
              if (numberOfLocals)
                  addToGraph(ClearCatchLocals);
  
<span class="line-new-header">--- 6343,18 ---</span>
              // We&#39;re not allowed to exit here since we would not properly recover values.
              // We first need to bootstrap the catch entrypoint state.
              m_exitOK = false;
  
              unsigned numberOfLocals = 0;
<span class="line-modified">!             buffer-&gt;forEach([&amp;] (ValueProfileAndVirtualRegister&amp; profile) {</span>
                  VirtualRegister operand(profile.m_operand);
                  if (operand.isArgument())
                      return;
                  ASSERT(operand.isLocal());
                  Node* value = addToGraph(ExtractCatchLocal, OpInfo(numberOfLocals), OpInfo(localPredictions[numberOfLocals]));
                  ++numberOfLocals;
<span class="line-modified">!                 addToGraph(MovHint, OpInfo(operand), value);</span>
                  localsToSet.uncheckedAppend(std::make_pair(operand, value));
              });
              if (numberOfLocals)
                  addToGraph(ClearCatchLocals);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6098,14 ***</span>
                  auto addResult = m_graph.m_rootToArguments.add(m_currentBlock, ArgumentsVector());
                  RELEASE_ASSERT(addResult.isNewEntry);
                  ArgumentsVector&amp; entrypointArguments = addResult.iterator-&gt;value;
                  entrypointArguments.resize(m_numArguments);
  
<span class="line-modified">!                 unsigned exitBytecodeIndex = m_currentIndex + currentInstruction-&gt;size();</span>
  
                  for (unsigned argument = 0; argument &lt; argumentPredictions.size(); ++argument) {
<span class="line-modified">!                     VariableAccessData* variable = newVariableAccessData(virtualRegisterForArgument(argument));</span>
                      variable-&gt;predict(argumentPredictions[argument]);
  
                      variable-&gt;mergeStructureCheckHoistingFailed(
                          m_inlineStackTop-&gt;m_exitProfile.hasExitSite(exitBytecodeIndex, BadCache));
                      variable-&gt;mergeCheckArrayHoistingFailed(
<span class="line-new-header">--- 6378,14 ---</span>
                  auto addResult = m_graph.m_rootToArguments.add(m_currentBlock, ArgumentsVector());
                  RELEASE_ASSERT(addResult.isNewEntry);
                  ArgumentsVector&amp; entrypointArguments = addResult.iterator-&gt;value;
                  entrypointArguments.resize(m_numArguments);
  
<span class="line-modified">!                 BytecodeIndex exitBytecodeIndex = BytecodeIndex(m_currentIndex.offset() + currentInstruction-&gt;size());</span>
  
                  for (unsigned argument = 0; argument &lt; argumentPredictions.size(); ++argument) {
<span class="line-modified">!                     VariableAccessData* variable = newVariableAccessData(virtualRegisterForArgumentIncludingThis(argument));</span>
                      variable-&gt;predict(argumentPredictions[argument]);
  
                      variable-&gt;mergeStructureCheckHoistingFailed(
                          m_inlineStackTop-&gt;m_exitProfile.hasExitSite(exitBytecodeIndex, BadCache));
                      variable-&gt;mergeCheckArrayHoistingFailed(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6198,20 ***</span>
              NEXT_OPCODE(op_call_eval);
          }
  
          case op_jneq_ptr: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJneqPtr&gt;();
<span class="line-modified">!             Special::Pointer specialPointer = bytecode.m_specialPointer;</span>
<span class="line-removed">-             ASSERT(pointerIsCell(specialPointer));</span>
<span class="line-removed">-             JSCell* actualPointer = static_cast&lt;JSCell*&gt;(</span>
<span class="line-removed">-                 actualPointerFor(m_inlineStackTop-&gt;m_codeBlock, specialPointer));</span>
<span class="line-removed">-             FrozenValue* frozenPointer = m_graph.freeze(actualPointer);</span>
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* child = get(bytecode.m_value);
              if (bytecode.metadata(codeBlock).m_hasJumped) {
                  Node* condition = addToGraph(CompareEqPtr, OpInfo(frozenPointer), child);
<span class="line-modified">!                 addToGraph(Branch, OpInfo(branchData(m_currentIndex + currentInstruction-&gt;size(), m_currentIndex + relativeOffset)), condition);</span>
                  LAST_OPCODE(op_jneq_ptr);
              }
              addToGraph(CheckCell, OpInfo(frozenPointer), child);
              NEXT_OPCODE(op_jneq_ptr);
          }
<span class="line-new-header">--- 6478,16 ---</span>
              NEXT_OPCODE(op_call_eval);
          }
  
          case op_jneq_ptr: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJneqPtr&gt;();
<span class="line-modified">!             FrozenValue* frozenPointer = m_graph.freezeStrong(m_inlineStackTop-&gt;m_codeBlock-&gt;getConstant(bytecode.m_specialPointer));</span>
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* child = get(bytecode.m_value);
              if (bytecode.metadata(codeBlock).m_hasJumped) {
                  Node* condition = addToGraph(CompareEqPtr, OpInfo(frozenPointer), child);
<span class="line-modified">!                 addToGraph(Branch, OpInfo(branchData(m_currentIndex.offset() + currentInstruction-&gt;size(), m_currentIndex.offset() + relativeOffset)), condition);</span>
                  LAST_OPCODE(op_jneq_ptr);
              }
              addToGraph(CheckCell, OpInfo(frozenPointer), child);
              NEXT_OPCODE(op_jneq_ptr);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6384,12 ***</span>
                          addToGraph(ForceOSRExit);
                  }
  
                  SpeculatedType prediction = getPrediction();
  
<span class="line-modified">!                 GetByIdStatus status = GetByIdStatus::computeFor(structure, uid);</span>
<span class="line-modified">!                 if (status.state() != GetByIdStatus::Simple</span>
                      || status.numVariants() != 1
                      || status[0].structureSet().size() != 1) {
                      set(bytecode.m_dst, addToGraph(GetByIdFlush, OpInfo(identifierNumber), OpInfo(prediction), get(bytecode.m_scope)));
                      break;
                  }
<span class="line-new-header">--- 6660,12 ---</span>
                          addToGraph(ForceOSRExit);
                  }
  
                  SpeculatedType prediction = getPrediction();
  
<span class="line-modified">!                 GetByStatus status = GetByStatus::computeFor(structure, uid);</span>
<span class="line-modified">!                 if (status.state() != GetByStatus::Simple</span>
                      || status.numVariants() != 1
                      || status[0].structureSet().size() != 1) {
                      set(bytecode.m_dst, addToGraph(GetByIdFlush, OpInfo(identifierNumber), OpInfo(prediction), get(bytecode.m_scope)));
                      break;
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6644,14 ***</span>
              // block. Hence, machine code block = true code block = not inline code block.
              if (!m_inlineStackTop-&gt;m_caller)
                  m_currentBlock-&gt;isOSRTarget = true;
  
              addToGraph(LoopHint);
<span class="line-removed">-             addToGraph(Options::usePollingTraps() ? CheckTraps : InvalidationPoint);</span>
              NEXT_OPCODE(op_loop_hint);
          }
  
          case op_nop: {
              addToGraph(Check); // We add a nop here so that basic block linking doesn&#39;t break.
              NEXT_OPCODE(op_nop);
          }
  
<span class="line-new-header">--- 6920,18 ---</span>
              // block. Hence, machine code block = true code block = not inline code block.
              if (!m_inlineStackTop-&gt;m_caller)
                  m_currentBlock-&gt;isOSRTarget = true;
  
              addToGraph(LoopHint);
              NEXT_OPCODE(op_loop_hint);
          }
  
<span class="line-added">+         case op_check_traps: {</span>
<span class="line-added">+             addToGraph(Options::usePollingTraps() ? CheckTraps : InvalidationPoint);</span>
<span class="line-added">+             NEXT_OPCODE(op_check_traps);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case op_nop: {
              addToGraph(Check); // We add a nop here so that basic block linking doesn&#39;t break.
              NEXT_OPCODE(op_nop);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6666,12 ***</span>
          }
  
          case op_create_lexical_environment: {
              auto bytecode = currentInstruction-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
              ASSERT(bytecode.m_symbolTable.isConstant() &amp;&amp; bytecode.m_initialValue.isConstant());
<span class="line-modified">!             FrozenValue* symbolTable = m_graph.freezeStrong(m_inlineStackTop-&gt;m_codeBlock-&gt;getConstant(bytecode.m_symbolTable.offset()));</span>
<span class="line-modified">!             FrozenValue* initialValue = m_graph.freezeStrong(m_inlineStackTop-&gt;m_codeBlock-&gt;getConstant(bytecode.m_initialValue.offset()));</span>
              Node* scope = get(bytecode.m_scope);
              Node* lexicalEnvironment = addToGraph(CreateActivation, OpInfo(symbolTable), OpInfo(initialValue), scope);
              set(bytecode.m_dst, lexicalEnvironment);
              NEXT_OPCODE(op_create_lexical_environment);
          }
<span class="line-new-header">--- 6946,12 ---</span>
          }
  
          case op_create_lexical_environment: {
              auto bytecode = currentInstruction-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
              ASSERT(bytecode.m_symbolTable.isConstant() &amp;&amp; bytecode.m_initialValue.isConstant());
<span class="line-modified">!             FrozenValue* symbolTable = m_graph.freezeStrong(m_inlineStackTop-&gt;m_codeBlock-&gt;getConstant(bytecode.m_symbolTable));</span>
<span class="line-modified">!             FrozenValue* initialValue = m_graph.freezeStrong(m_inlineStackTop-&gt;m_codeBlock-&gt;getConstant(bytecode.m_initialValue));</span>
              Node* scope = get(bytecode.m_scope);
              Node* lexicalEnvironment = addToGraph(CreateActivation, OpInfo(symbolTable), OpInfo(initialValue), scope);
              set(bytecode.m_dst, lexicalEnvironment);
              NEXT_OPCODE(op_create_lexical_environment);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6697,11 ***</span>
              // Help the later stages a bit by doing some small constant folding here. Note that this
              // only helps for the first basic block. It&#39;s extremely important not to constant fold
              // loads from the scope register later, as that would prevent the DFG from tracking the
              // bytecode-level liveness of the scope register.
              auto bytecode = currentInstruction-&gt;as&lt;OpGetScope&gt;();
<span class="line-modified">!             Node* callee = get(VirtualRegister(CallFrameSlot::callee));</span>
              Node* result;
              if (JSFunction* function = callee-&gt;dynamicCastConstant&lt;JSFunction*&gt;(*m_vm))
                  result = weakJSConstant(function-&gt;scope());
              else
                  result = addToGraph(GetScope, callee);
<span class="line-new-header">--- 6977,11 ---</span>
              // Help the later stages a bit by doing some small constant folding here. Note that this
              // only helps for the first basic block. It&#39;s extremely important not to constant fold
              // loads from the scope register later, as that would prevent the DFG from tracking the
              // bytecode-level liveness of the scope register.
              auto bytecode = currentInstruction-&gt;as&lt;OpGetScope&gt;();
<span class="line-modified">!             Node* callee = get(CallFrameSlot::callee);</span>
              Node* result;
              if (JSFunction* function = callee-&gt;dynamicCastConstant&lt;JSFunction*&gt;(*m_vm))
                  result = weakJSConstant(function-&gt;scope());
              else
                  result = addToGraph(GetScope, callee);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6738,10 ***</span>
<span class="line-new-header">--- 7018,17 ---</span>
              Node* createArguments = addToGraph(CreateClonedArguments);
              set(bytecode.m_dst, createArguments);
              NEXT_OPCODE(op_create_cloned_arguments);
          }
  
<span class="line-added">+         case op_create_arguments_butterfly: {</span>
<span class="line-added">+             auto bytecode = currentInstruction-&gt;as&lt;OpCreateArgumentsButterfly&gt;();</span>
<span class="line-added">+             noticeArgumentsUse();</span>
<span class="line-added">+             set(bytecode.m_dst, addToGraph(CreateArgumentsButterfly));</span>
<span class="line-added">+             NEXT_OPCODE(op_create_arguments_butterfly);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case op_get_from_arguments: {
              auto bytecode = currentInstruction-&gt;as&lt;OpGetFromArguments&gt;();
              set(bytecode.m_dst,
                  addToGraph(
                      GetFromArguments,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6767,11 ***</span>
              Node* argument;
              int32_t argumentIndexIncludingThis = bytecode.m_index;
              if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
                  int32_t argumentCountIncludingThisWithFixup = inlineCallFrame-&gt;argumentsWithFixup.size();
                  if (argumentIndexIncludingThis &lt; argumentCountIncludingThisWithFixup)
<span class="line-modified">!                     argument = get(virtualRegisterForArgument(argumentIndexIncludingThis));</span>
                  else
                      argument = addToGraph(JSConstant, OpInfo(m_constantUndefined));
              } else
                  argument = addToGraph(GetArgument, OpInfo(argumentIndexIncludingThis), OpInfo(getPrediction()));
              set(bytecode.m_dst, argument);
<span class="line-new-header">--- 7054,11 ---</span>
              Node* argument;
              int32_t argumentIndexIncludingThis = bytecode.m_index;
              if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
                  int32_t argumentCountIncludingThisWithFixup = inlineCallFrame-&gt;argumentsWithFixup.size();
                  if (argumentIndexIncludingThis &lt; argumentCountIncludingThisWithFixup)
<span class="line-modified">!                     argument = get(virtualRegisterForArgumentIncludingThis(argumentIndexIncludingThis));</span>
                  else
                      argument = addToGraph(JSConstant, OpInfo(m_constantUndefined));
              } else
                  argument = addToGraph(GetArgument, OpInfo(argumentIndexIncludingThis), OpInfo(getPrediction()));
              set(bytecode.m_dst, argument);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6823,10 ***</span>
<span class="line-new-header">--- 7110,18 ---</span>
              Node* value = get(bytecode.m_operand);
              set(bytecode.m_dst, addToGraph(ToNumber, OpInfo(0), OpInfo(prediction), value));
              NEXT_OPCODE(op_to_number);
          }
  
<span class="line-added">+         case op_to_numeric: {</span>
<span class="line-added">+             auto bytecode = currentInstruction-&gt;as&lt;OpToNumeric&gt;();</span>
<span class="line-added">+             SpeculatedType prediction = getPrediction();</span>
<span class="line-added">+             Node* value = get(bytecode.m_operand);</span>
<span class="line-added">+             set(bytecode.m_dst, addToGraph(ToNumeric, OpInfo(0), OpInfo(prediction), value));</span>
<span class="line-added">+             NEXT_OPCODE(op_to_numeric);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case op_to_string: {
              auto bytecode = currentInstruction-&gt;as&lt;OpToString&gt;();
              Node* value = get(bytecode.m_operand);
              set(bytecode.m_dst, addToGraph(ToString, value));
              NEXT_OPCODE(op_to_string);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6968,10 ***</span>
<span class="line-new-header">--- 7263,22 ---</span>
              auto bytecode = currentInstruction-&gt;as&lt;OpToIndexString&gt;();
              set(bytecode.m_dst, addToGraph(ToIndexString, get(bytecode.m_index)));
              NEXT_OPCODE(op_to_index_string);
          }
  
<span class="line-added">+         case op_get_internal_field: {</span>
<span class="line-added">+             auto bytecode = currentInstruction-&gt;as&lt;OpGetInternalField&gt;();</span>
<span class="line-added">+             set(bytecode.m_dst, addToGraph(GetInternalField, OpInfo(bytecode.m_index), OpInfo(getPrediction()), get(bytecode.m_base)));</span>
<span class="line-added">+             NEXT_OPCODE(op_get_internal_field);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case op_put_internal_field: {</span>
<span class="line-added">+             auto bytecode = currentInstruction-&gt;as&lt;OpPutInternalField&gt;();</span>
<span class="line-added">+             addToGraph(PutInternalField, OpInfo(bytecode.m_index), get(bytecode.m_base), get(bytecode.m_value));</span>
<span class="line-added">+             NEXT_OPCODE(op_put_internal_field);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case op_log_shadow_chicken_prologue: {
              auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
              if (!m_inlineStackTop-&gt;m_inlineCallFrame)
                  addToGraph(LogShadowChickenPrologue, get(bytecode.m_scope));
              NEXT_OPCODE(op_log_shadow_chicken_prologue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7010,25 ***</span>
      Node* node = block-&gt;terminal();
      ASSERT(node-&gt;isTerminal());
  
      switch (node-&gt;op()) {
      case Jump:
<span class="line-modified">!         node-&gt;targetBlock() = blockForBytecodeOffset(possibleTargets, node-&gt;targetBytecodeOffsetDuringParsing());</span>
          break;
  
      case Branch: {
          BranchData* data = node-&gt;branchData();
<span class="line-modified">!         data-&gt;taken.block = blockForBytecodeOffset(possibleTargets, data-&gt;takenBytecodeIndex());</span>
<span class="line-modified">!         data-&gt;notTaken.block = blockForBytecodeOffset(possibleTargets, data-&gt;notTakenBytecodeIndex());</span>
          break;
      }
  
      case Switch: {
          SwitchData* data = node-&gt;switchData();
          for (unsigned i = node-&gt;switchData()-&gt;cases.size(); i--;)
<span class="line-modified">!             data-&gt;cases[i].target.block = blockForBytecodeOffset(possibleTargets, data-&gt;cases[i].target.bytecodeIndex());</span>
<span class="line-modified">!         data-&gt;fallThrough.block = blockForBytecodeOffset(possibleTargets, data-&gt;fallThrough.bytecodeIndex());</span>
          break;
      }
  
      default:
          RELEASE_ASSERT_NOT_REACHED();
<span class="line-new-header">--- 7317,25 ---</span>
      Node* node = block-&gt;terminal();
      ASSERT(node-&gt;isTerminal());
  
      switch (node-&gt;op()) {
      case Jump:
<span class="line-modified">!         node-&gt;targetBlock() = blockForBytecodeIndex(possibleTargets, BytecodeIndex(node-&gt;targetBytecodeOffsetDuringParsing()));</span>
          break;
  
      case Branch: {
          BranchData* data = node-&gt;branchData();
<span class="line-modified">!         data-&gt;taken.block = blockForBytecodeIndex(possibleTargets, BytecodeIndex(data-&gt;takenBytecodeIndex()));</span>
<span class="line-modified">!         data-&gt;notTaken.block = blockForBytecodeIndex(possibleTargets, BytecodeIndex(data-&gt;notTakenBytecodeIndex()));</span>
          break;
      }
  
      case Switch: {
          SwitchData* data = node-&gt;switchData();
          for (unsigned i = node-&gt;switchData()-&gt;cases.size(); i--;)
<span class="line-modified">!             data-&gt;cases[i].target.block = blockForBytecodeIndex(possibleTargets, BytecodeIndex(data-&gt;cases[i].target.bytecodeIndex()));</span>
<span class="line-modified">!         data-&gt;fallThrough.block = blockForBytecodeIndex(possibleTargets, BytecodeIndex(data-&gt;fallThrough.bytecodeIndex()));</span>
          break;
      }
  
      default:
          RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7095,12 ***</span>
<span class="line-new-header">--- 7402,14 ---</span>
          m_optimizedContext.inlineCallFrame = m_inlineCallFrame;
  
          // The owner is the machine code block, and we already have a barrier on that when the
          // plan finishes.
          m_inlineCallFrame-&gt;baselineCodeBlock.setWithoutWriteBarrier(codeBlock-&gt;baselineVersion());
<span class="line-added">+         m_inlineCallFrame-&gt;setTmpOffset((m_caller-&gt;m_inlineCallFrame ? m_caller-&gt;m_inlineCallFrame-&gt;tmpOffset : 0) + m_caller-&gt;m_codeBlock-&gt;numTmps());</span>
          m_inlineCallFrame-&gt;setStackOffset(inlineCallFrameStart.offset() - CallFrame::headerSizeInRegisters);
          m_inlineCallFrame-&gt;argumentCountIncludingThis = argumentCountIncludingThis;
<span class="line-added">+         RELEASE_ASSERT(m_inlineCallFrame-&gt;argumentCountIncludingThis == argumentCountIncludingThis);</span>
          if (callee) {
              m_inlineCallFrame-&gt;calleeRecovery = ValueRecovery::constant(callee);
              m_inlineCallFrame-&gt;isClosureCall = false;
          } else
              m_inlineCallFrame-&gt;isClosureCall = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7173,11 ***</span>
              deferredSourceDump.append(dump);
          } else
              deferredSourceDump.append(DeferredSourceDump(codeBlock-&gt;baselineVersion()));
      }
  
<span class="line-modified">!     if (Options::dumpBytecodeAtDFGTime()) {</span>
          dataLog(&quot;Parsing &quot;, *codeBlock);
          if (inlineCallFrame()) {
              dataLog(
                  &quot; for inlining at &quot;, CodeBlockWithJITType(m_codeBlock, JITType::DFGJIT),
                  &quot; &quot;, inlineCallFrame()-&gt;directCaller);
<span class="line-new-header">--- 7482,11 ---</span>
              deferredSourceDump.append(dump);
          } else
              deferredSourceDump.append(DeferredSourceDump(codeBlock-&gt;baselineVersion()));
      }
  
<span class="line-modified">!     if (UNLIKELY(Options::dumpBytecodeAtDFGTime())) {</span>
          dataLog(&quot;Parsing &quot;, *codeBlock);
          if (inlineCallFrame()) {
              dataLog(
                  &quot; for inlining at &quot;, CodeBlockWithJITType(m_codeBlock, JITType::DFGJIT),
                  &quot; &quot;, inlineCallFrame()-&gt;directCaller);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7187,22 ***</span>
          codeBlock-&gt;baselineVersion()-&gt;dumpBytecode();
      }
  
      Vector&lt;InstructionStream::Offset, 32&gt; jumpTargets;
      computePreciseJumpTargets(codeBlock, jumpTargets);
<span class="line-modified">!     if (Options::dumpBytecodeAtDFGTime()) {</span>
          dataLog(&quot;Jump targets: &quot;);
          CommaPrinter comma;
          for (unsigned i = 0; i &lt; jumpTargets.size(); ++i)
              dataLog(comma, jumpTargets[i]);
          dataLog(&quot;\n&quot;);
      }
  
      for (unsigned jumpTargetIndex = 0; jumpTargetIndex &lt;= jumpTargets.size(); ++jumpTargetIndex) {
          // The maximum bytecode offset to go into the current basicblock is either the next jump target, or the end of the instructions.
          unsigned limit = jumpTargetIndex &lt; jumpTargets.size() ? jumpTargets[jumpTargetIndex] : codeBlock-&gt;instructions().size();
<span class="line-modified">!         ASSERT(m_currentIndex &lt; limit);</span>
  
          // Loop until we reach the current limit (i.e. next jump target).
          do {
              // There may already be a currentBlock in two cases:
              // - we may have just entered the loop for the first time
<span class="line-new-header">--- 7496,22 ---</span>
          codeBlock-&gt;baselineVersion()-&gt;dumpBytecode();
      }
  
      Vector&lt;InstructionStream::Offset, 32&gt; jumpTargets;
      computePreciseJumpTargets(codeBlock, jumpTargets);
<span class="line-modified">!     if (UNLIKELY(Options::dumpBytecodeAtDFGTime())) {</span>
          dataLog(&quot;Jump targets: &quot;);
          CommaPrinter comma;
          for (unsigned i = 0; i &lt; jumpTargets.size(); ++i)
              dataLog(comma, jumpTargets[i]);
          dataLog(&quot;\n&quot;);
      }
  
      for (unsigned jumpTargetIndex = 0; jumpTargetIndex &lt;= jumpTargets.size(); ++jumpTargetIndex) {
          // The maximum bytecode offset to go into the current basicblock is either the next jump target, or the end of the instructions.
          unsigned limit = jumpTargetIndex &lt; jumpTargets.size() ? jumpTargets[jumpTargetIndex] : codeBlock-&gt;instructions().size();
<span class="line-modified">!         ASSERT(m_currentIndex.offset() &lt; limit);</span>
  
          // Loop until we reach the current limit (i.e. next jump target).
          do {
              // There may already be a currentBlock in two cases:
              // - we may have just entered the loop for the first time
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7221,27 ***</span>
              }
  
              parseBlock(limit);
  
              // We should not have gone beyond the limit.
<span class="line-modified">!             ASSERT(m_currentIndex &lt;= limit);</span>
  
              if (m_currentBlock-&gt;isEmpty()) {
                  // This case only happens if the last instruction was an inlined call with early returns
                  // or polymorphic (creating an empty continuation block),
                  // and then we hit the limit before putting anything in the continuation block.
<span class="line-modified">!                 ASSERT(m_currentIndex == limit);</span>
                  makeBlockTargetable(m_currentBlock, m_currentIndex);
              } else {
<span class="line-modified">!                 ASSERT(m_currentBlock-&gt;terminal() || (m_currentIndex == codeBlock-&gt;instructions().size() &amp;&amp; inlineCallFrame()));</span>
                  m_currentBlock = nullptr;
              }
<span class="line-modified">!         } while (m_currentIndex &lt; limit);</span>
      }
  
      // Should have reached the end of the instructions.
<span class="line-modified">!     ASSERT(m_currentIndex == codeBlock-&gt;instructions().size());</span>
  
      VERBOSE_LOG(&quot;Done parsing &quot;, *codeBlock, &quot; (fell off end)\n&quot;);
  }
  
  template &lt;typename Bytecode&gt;
<span class="line-new-header">--- 7530,27 ---</span>
              }
  
              parseBlock(limit);
  
              // We should not have gone beyond the limit.
<span class="line-modified">!             ASSERT(m_currentIndex.offset() &lt;= limit);</span>
  
              if (m_currentBlock-&gt;isEmpty()) {
                  // This case only happens if the last instruction was an inlined call with early returns
                  // or polymorphic (creating an empty continuation block),
                  // and then we hit the limit before putting anything in the continuation block.
<span class="line-modified">!                 ASSERT(m_currentIndex.offset() == limit);</span>
                  makeBlockTargetable(m_currentBlock, m_currentIndex);
              } else {
<span class="line-modified">!                 ASSERT(m_currentBlock-&gt;terminal() || (m_currentIndex.offset() == codeBlock-&gt;instructions().size() &amp;&amp; inlineCallFrame()));</span>
                  m_currentBlock = nullptr;
              }
<span class="line-modified">!         } while (m_currentIndex.offset() &lt; limit);</span>
      }
  
      // Should have reached the end of the instructions.
<span class="line-modified">!     ASSERT(m_currentIndex.offset() == codeBlock-&gt;instructions().size());</span>
  
      VERBOSE_LOG(&quot;Done parsing &quot;, *codeBlock, &quot; (fell off end)\n&quot;);
  }
  
  template &lt;typename Bytecode&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7273,11 ***</span>
                  if (Symbol* symbol = byValInfo-&gt;cachedSymbol.get()) {
                      FrozenValue* frozen = m_graph.freezeStrong(symbol);
                      addToGraph(CheckCell, OpInfo(frozen), property);
                  } else {
                      ASSERT(!uid-&gt;isSymbol());
<span class="line-modified">!                     addToGraph(CheckStringIdent, OpInfo(uid), property);</span>
                  }
  
                  putByIdStatus = PutByIdStatus::computeForStubInfo(
                      locker, m_inlineStackTop-&gt;m_profiledBlock,
                      byValInfo-&gt;stubInfo, currentCodeOrigin(), uid);
<span class="line-new-header">--- 7582,11 ---</span>
                  if (Symbol* symbol = byValInfo-&gt;cachedSymbol.get()) {
                      FrozenValue* frozen = m_graph.freezeStrong(symbol);
                      addToGraph(CheckCell, OpInfo(frozen), property);
                  } else {
                      ASSERT(!uid-&gt;isSymbol());
<span class="line-modified">!                     addToGraph(CheckIdent, OpInfo(uid), property);</span>
                  }
  
                  putByIdStatus = PutByIdStatus::computeForStubInfo(
                      locker, m_inlineStackTop-&gt;m_profiledBlock,
                      byValInfo-&gt;stubInfo, currentCodeOrigin(), uid);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7352,14 ***</span>
      // For the non-constant case: NewFunction could be DCE&#39;d, but baseline&#39;s implementation
      // won&#39;t be able to handle an Undefined scope.
      addToGraph(Phantom, scope);
  }
  
  void ByteCodeParser::parse()
  {
      // Set during construction.
<span class="line-modified">!     ASSERT(!m_currentIndex);</span>
  
      VERBOSE_LOG(&quot;Parsing &quot;, *m_codeBlock, &quot;\n&quot;);
  
      InlineStackEntry inlineStackEntry(
          this, m_codeBlock, m_profiledBlock, 0, VirtualRegister(), VirtualRegister(),
<span class="line-new-header">--- 7661,59 ---</span>
      // For the non-constant case: NewFunction could be DCE&#39;d, but baseline&#39;s implementation
      // won&#39;t be able to handle an Undefined scope.
      addToGraph(Phantom, scope);
  }
  
<span class="line-added">+ template &lt;typename Bytecode&gt;</span>
<span class="line-added">+ void ByteCodeParser::handleCreateInternalFieldObject(const ClassInfo* classInfo, NodeType createOp, NodeType newOp, Bytecode bytecode)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     CodeBlock* codeBlock = m_inlineStackTop-&gt;m_codeBlock;</span>
<span class="line-added">+     JSGlobalObject* globalObject = m_graph.globalObjectFor(currentNodeOrigin().semantic);</span>
<span class="line-added">+     Node* callee = get(VirtualRegister(bytecode.m_callee));</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSFunction* function = callee-&gt;dynamicCastConstant&lt;JSFunction*&gt;(*m_vm);</span>
<span class="line-added">+     if (!function) {</span>
<span class="line-added">+         JSCell* cachedFunction = bytecode.metadata(codeBlock).m_cachedCallee.unvalidatedGet();</span>
<span class="line-added">+         if (cachedFunction</span>
<span class="line-added">+             &amp;&amp; cachedFunction != JSCell::seenMultipleCalleeObjects()</span>
<span class="line-added">+             &amp;&amp; !m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCell)) {</span>
<span class="line-added">+             ASSERT(cachedFunction-&gt;inherits&lt;JSFunction&gt;(*m_vm));</span>
<span class="line-added">+ </span>
<span class="line-added">+             FrozenValue* frozen = m_graph.freeze(cachedFunction);</span>
<span class="line-added">+             addToGraph(CheckCell, OpInfo(frozen), callee);</span>
<span class="line-added">+ </span>
<span class="line-added">+             function = static_cast&lt;JSFunction*&gt;(cachedFunction);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (function) {</span>
<span class="line-added">+         if (FunctionRareData* rareData = function-&gt;rareData()) {</span>
<span class="line-added">+             if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added">+                 Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="line-added">+                 if (structure</span>
<span class="line-added">+                     &amp;&amp; structure-&gt;classInfo() == classInfo</span>
<span class="line-added">+                     &amp;&amp; structure-&gt;globalObject() == globalObject</span>
<span class="line-added">+                     &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added">+                     m_graph.freeze(rareData);</span>
<span class="line-added">+                     m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-added">+ </span>
<span class="line-added">+                     set(VirtualRegister(bytecode.m_dst), addToGraph(newOp, OpInfo(m_graph.registerStructure(structure))));</span>
<span class="line-added">+                     // The callee is still live up to this point.</span>
<span class="line-added">+                     addToGraph(Phantom, callee);</span>
<span class="line-added">+                     return;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     set(VirtualRegister(bytecode.m_dst), addToGraph(createOp, callee));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ByteCodeParser::parse()
  {
      // Set during construction.
<span class="line-modified">!     ASSERT(!m_currentIndex.offset());</span>
  
      VERBOSE_LOG(&quot;Parsing &quot;, *m_codeBlock, &quot;\n&quot;);
  
      InlineStackEntry inlineStackEntry(
          this, m_codeBlock, m_profiledBlock, 0, VirtualRegister(), VirtualRegister(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7413,11 ***</span>
              for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
                  {
                      Node* node = block-&gt;at(nodeIndex);
  
                      if (node-&gt;hasVariableAccessData(m_graph))
<span class="line-modified">!                         mapping.operand(node-&gt;local()) = node-&gt;variableAccessData();</span>
  
                      if (node-&gt;op() != ForceOSRExit)
                          continue;
                  }
  
<span class="line-new-header">--- 7767,11 ---</span>
              for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
                  {
                      Node* node = block-&gt;at(nodeIndex);
  
                      if (node-&gt;hasVariableAccessData(m_graph))
<span class="line-modified">!                         mapping.operand(node-&gt;operand()) = node-&gt;variableAccessData();</span>
  
                      if (node-&gt;op() != ForceOSRExit)
                          continue;
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7433,28 ***</span>
                          // parser, we haven&#39;t linked up the predecessor lists yet.
                          for (BasicBlock* successor : block-&gt;successors())
                              RELEASE_ASSERT(successor-&gt;predecessors.isEmpty());
                      }
  
<span class="line-modified">!                     auto insertLivenessPreservingOp = [&amp;] (InlineCallFrame* inlineCallFrame, NodeType op, VirtualRegister operand) {</span>
                          VariableAccessData* variable = mapping.operand(operand);
                          if (!variable) {
                              variable = newVariableAccessData(operand);
                              mapping.operand(operand) = variable;
                          }
  
<span class="line-modified">!                         VirtualRegister argument = operand - (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0);</span>
                          if (argument.isArgument() &amp;&amp; !argument.isHeader()) {
                              const Vector&lt;ArgumentPosition*&gt;&amp; arguments = m_inlineCallFrameToArgumentPositions.get(inlineCallFrame);
                              arguments[argument.toArgument()]-&gt;addVariable(variable);
                          }
                          insertionSet.insertNode(nodeIndex, SpecNone, op, origin, OpInfo(variable));
                      };
<span class="line-modified">!                     auto addFlushDirect = [&amp;] (InlineCallFrame* inlineCallFrame, VirtualRegister operand) {</span>
                          insertLivenessPreservingOp(inlineCallFrame, Flush, operand);
                      };
<span class="line-modified">!                     auto addPhantomLocalDirect = [&amp;] (InlineCallFrame* inlineCallFrame, VirtualRegister operand) {</span>
                          insertLivenessPreservingOp(inlineCallFrame, PhantomLocal, operand);
                      };
                      flushForTerminalImpl(origin.semantic, addFlushDirect, addPhantomLocalDirect);
                  }
  
<span class="line-new-header">--- 7787,28 ---</span>
                          // parser, we haven&#39;t linked up the predecessor lists yet.
                          for (BasicBlock* successor : block-&gt;successors())
                              RELEASE_ASSERT(successor-&gt;predecessors.isEmpty());
                      }
  
<span class="line-modified">!                     auto insertLivenessPreservingOp = [&amp;] (InlineCallFrame* inlineCallFrame, NodeType op, Operand operand) {</span>
                          VariableAccessData* variable = mapping.operand(operand);
                          if (!variable) {
                              variable = newVariableAccessData(operand);
                              mapping.operand(operand) = variable;
                          }
  
<span class="line-modified">!                         Operand argument = unmapOperand(inlineCallFrame, operand);</span>
                          if (argument.isArgument() &amp;&amp; !argument.isHeader()) {
                              const Vector&lt;ArgumentPosition*&gt;&amp; arguments = m_inlineCallFrameToArgumentPositions.get(inlineCallFrame);
                              arguments[argument.toArgument()]-&gt;addVariable(variable);
                          }
                          insertionSet.insertNode(nodeIndex, SpecNone, op, origin, OpInfo(variable));
                      };
<span class="line-modified">!                     auto addFlushDirect = [&amp;] (InlineCallFrame* inlineCallFrame, Operand operand) {</span>
                          insertLivenessPreservingOp(inlineCallFrame, Flush, operand);
                      };
<span class="line-modified">!                     auto addPhantomLocalDirect = [&amp;] (InlineCallFrame* inlineCallFrame, Operand operand) {</span>
                          insertLivenessPreservingOp(inlineCallFrame, PhantomLocal, operand);
                      };
                      flushForTerminalImpl(origin.semantic, addFlushDirect, addPhantomLocalDirect);
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7515,10 ***</span>
<span class="line-new-header">--- 7869,11 ---</span>
          ASSERT(block-&gt;variablesAtHead.numberOfArguments() == m_graph.block(0)-&gt;variablesAtHead.numberOfArguments());
          ASSERT(block-&gt;variablesAtTail.numberOfLocals() == m_graph.block(0)-&gt;variablesAtHead.numberOfLocals());
          ASSERT(block-&gt;variablesAtTail.numberOfArguments() == m_graph.block(0)-&gt;variablesAtHead.numberOfArguments());
      }
  
<span class="line-added">+     m_graph.m_tmps = m_numTmps;</span>
      m_graph.m_localVars = m_numLocals;
      m_graph.m_parameterSlots = m_parameterSlots;
  }
  
  void parse(Graph&amp; graph)
</pre>
<center><a href="DFGBlockInsertionSet.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCFAPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
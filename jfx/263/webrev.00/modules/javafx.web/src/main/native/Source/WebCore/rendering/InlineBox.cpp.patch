diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineBox.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineBox.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineBox.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineBox.cpp
@@ -130,11 +130,11 @@
     if (hasVirtualLogicalHeight())
         return virtualLogicalHeight();
 
     const RenderStyle& lineStyle = this->lineStyle();
     if (renderer().isTextOrLineBreak())
-        return behavesLikeText() ? lineStyle.fontMetrics().height() : 0;
+        return lineStyle.fontMetrics().height();
     if (is<RenderBox>(renderer()) && parent())
         return isHorizontal() ? downcast<RenderBox>(renderer()).height() : downcast<RenderBox>(renderer()).width();
 
     ASSERT(isInlineFlowBox());
     RenderBoxModelObject* flowObject = boxModelObject();
@@ -145,19 +145,15 @@
     return result;
 }
 
 int InlineBox::baselinePosition(FontBaseline baselineType) const
 {
-    if (renderer().isLineBreak() && !behavesLikeText())
-        return 0;
     return boxModelObject()->baselinePosition(baselineType, m_bitfields.firstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOnContainingLine);
 }
 
 LayoutUnit InlineBox::lineHeight() const
 {
-    if (renderer().isLineBreak() && !behavesLikeText())
-        return 0;
     return boxModelObject()->lineHeight(m_bitfields.firstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOnContainingLine);
 }
 
 int InlineBox::caretMinOffset() const
 {
@@ -218,46 +214,46 @@
 
 bool InlineBox::previousOnLineExists() const
 {
     if (!parent())
         return false;
-    if (prevOnLine())
+    if (previousOnLine())
         return true;
     return parent()->previousOnLineExists();
 }
 
-InlineBox* InlineBox::nextLeafChild() const
+InlineBox* InlineBox::nextLeafOnLine() const
 {
     InlineBox* leaf = nullptr;
     for (InlineBox* box = nextOnLine(); box && !leaf; box = box->nextOnLine())
-        leaf = box->isLeaf() ? box : downcast<InlineFlowBox>(*box).firstLeafChild();
+        leaf = box->isLeaf() ? box : downcast<InlineFlowBox>(*box).firstLeafDescendant();
     if (!leaf && parent())
-        leaf = parent()->nextLeafChild();
+        leaf = parent()->nextLeafOnLine();
     return leaf;
 }
 
-InlineBox* InlineBox::prevLeafChild() const
+InlineBox* InlineBox::previousLeafOnLine() const
 {
     InlineBox* leaf = nullptr;
-    for (InlineBox* box = prevOnLine(); box && !leaf; box = box->prevOnLine())
-        leaf = box->isLeaf() ? box : downcast<InlineFlowBox>(*box).lastLeafChild();
+    for (InlineBox* box = previousOnLine(); box && !leaf; box = box->previousOnLine())
+        leaf = box->isLeaf() ? box : downcast<InlineFlowBox>(*box).lastLeafDescendant();
     if (!leaf && parent())
-        leaf = parent()->prevLeafChild();
+        leaf = parent()->previousLeafOnLine();
     return leaf;
 }
 
-InlineBox* InlineBox::nextLeafChildIgnoringLineBreak() const
+InlineBox* InlineBox::nextLeafOnLineIgnoringLineBreak() const
 {
-    InlineBox* leaf = nextLeafChild();
+    InlineBox* leaf = nextLeafOnLine();
     if (leaf && leaf->isLineBreak())
         return nullptr;
     return leaf;
 }
 
-InlineBox* InlineBox::prevLeafChildIgnoringLineBreak() const
+InlineBox* InlineBox::previousLeafOnLineIgnoringLineBreak() const
 {
-    InlineBox* leaf = prevLeafChild();
+    InlineBox* leaf = previousLeafOnLine();
     if (leaf && leaf->isLineBreak())
         return nullptr;
     return leaf;
 }
 

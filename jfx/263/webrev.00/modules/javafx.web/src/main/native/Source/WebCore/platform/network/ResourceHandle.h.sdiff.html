<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/ResourceHandle.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ResourceHandle.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ResourceHandleInternal.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/ResourceHandle.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 69 
 70 namespace WTF {
 71 class SchedulePair;
 72 template&lt;typename T&gt; class MessageQueue;
 73 }
 74 
 75 namespace WebCore {
 76 
 77 class AuthenticationChallenge;
 78 class Credential;
 79 class Frame;
 80 class NetworkingContext;
 81 class ProtectionSpace;
 82 class ResourceError;
 83 class ResourceHandleClient;
 84 class ResourceHandleInternal;
 85 class NetworkLoadMetrics;
 86 class ResourceRequest;
 87 class ResourceResponse;
 88 class SharedBuffer;

 89 class Timer;
 90 
 91 #if USE(CURL)
 92 class CurlRequest;
 93 class CurlResourceHandleDelegate;
 94 #endif
 95 
 96 class ResourceHandle : public RefCounted&lt;ResourceHandle&gt;, public AuthenticationClient {
 97 public:
 98     WEBCORE_EXPORT static RefPtr&lt;ResourceHandle&gt; create(NetworkingContext*, const ResourceRequest&amp;, ResourceHandleClient*, bool defersLoading, bool shouldContentSniff, bool shouldContentEncodingSniff);
 99     WEBCORE_EXPORT static void loadResourceSynchronously(NetworkingContext*, const ResourceRequest&amp;, StoredCredentialsPolicy, ResourceError&amp;, ResourceResponse&amp;, Vector&lt;char&gt;&amp; data);
100     WEBCORE_EXPORT virtual ~ResourceHandle();
101 
102 #if PLATFORM(COCOA) || USE(CFURLCONNECTION)
103     void willSendRequest(ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;);
104 #endif
105 
106 #if PLATFORM(JAVA)
107     void continueAfterWillSendRequest(ResourceRequest&amp;&amp; request);
108     void willSendRequest(const ResourceResponse&amp; response);
</pre>
<hr />
<pre>
111     void didReceiveResponse(ResourceResponse&amp;&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;);
112 
113     bool shouldUseCredentialStorage();
114     void didReceiveAuthenticationChallenge(const AuthenticationChallenge&amp;);
115     void receivedCredential(const AuthenticationChallenge&amp;, const Credential&amp;) override;
116     void receivedRequestToContinueWithoutCredential(const AuthenticationChallenge&amp;) override;
117     void receivedCancellation(const AuthenticationChallenge&amp;) override;
118     void receivedRequestToPerformDefaultHandling(const AuthenticationChallenge&amp;) override;
119     void receivedChallengeRejection(const AuthenticationChallenge&amp;) override;
120 
121 #if PLATFORM(COCOA) || USE(CFURLCONNECTION)
122     bool tryHandlePasswordBasedAuthentication(const AuthenticationChallenge&amp;);
123 #endif
124 
125 #if PLATFORM(COCOA) &amp;&amp; USE(PROTECTION_SPACE_AUTH_CALLBACK)
126     void canAuthenticateAgainstProtectionSpace(const ProtectionSpace&amp;, CompletionHandler&lt;void(bool)&gt;&amp;&amp;);
127 #endif
128 
129 #if PLATFORM(COCOA)
130     WEBCORE_EXPORT NSURLConnection *connection() const;
<span class="line-modified">131     id makeDelegate(bool, WTF::MessageQueue&lt;WTF::Function&lt;void()&gt;&gt;*);</span>
132     id delegate();
133     void releaseDelegate();
134 #endif
135 
136 #if PLATFORM(COCOA)
137 #if USE(CFURLCONNECTION)
138     static void getConnectionTimingData(CFURLConnectionRef, NetworkLoadMetrics&amp;);
139 #else
140     static void getConnectionTimingData(NSURLConnection *, NetworkLoadMetrics&amp;);
141 #endif
142 #endif
143 
144 #if PLATFORM(COCOA)
145     void schedule(WTF::SchedulePair&amp;);
146     void unschedule(WTF::SchedulePair&amp;);
147 #endif
148 
149 #if USE(CFURLCONNECTION)
150     CFURLStorageSessionRef storageSession() const;
151     CFURLConnectionRef connection() const;
152     WEBCORE_EXPORT RetainPtr&lt;CFURLConnectionRef&gt; releaseConnectionForDownload();
153     const ResourceRequest&amp; currentRequest() const;
154     static void setHostAllowsAnyHTTPSCertificate(const String&amp;);
155     static void setClientCertificate(const String&amp; host, CFDataRef);
156 #endif
157 
158 #if OS(WINDOWS) &amp;&amp; USE(CURL)
159     static void setHostAllowsAnyHTTPSCertificate(const String&amp;);
160     static void setClientCertificateInfo(const String&amp;, const String&amp;, const String&amp;);
161 #endif
162 
<span class="line-removed">163 #if OS(WINDOWS) &amp;&amp; USE(CURL) &amp;&amp; USE(CF)</span>
<span class="line-removed">164     static void setClientCertificate(const String&amp; host, CFDataRef);</span>
<span class="line-removed">165 #endif</span>
<span class="line-removed">166 </span>
167     bool shouldContentSniff() const;
168     static bool shouldContentSniffURL(const URL&amp;);
169 
170     bool shouldContentEncodingSniff() const;
171 
172     WEBCORE_EXPORT static void forceContentSniffing();
173 
174 #if USE(CURL)
175     ResourceHandleInternal* getInternal() { return d.get(); }
176 #endif
177 
178 #if USE(CURL)
179     bool cancelledOrClientless();
180     CurlResourceHandleDelegate* delegate();
181 
182     void continueAfterDidReceiveResponse();
183     void willSendRequest();
184     void continueAfterWillSendRequest(ResourceRequest&amp;&amp;);
185 #endif
186 
</pre>
<hr />
<pre>
224         InvalidURLFailure
225     };
226 
227     void platformSetDefersLoading(bool);
228 
229     void platformContinueSynchronousDidReceiveResponse();
230 
231     void scheduleFailure(FailureType);
232 
233     bool start();
234     static void platformLoadResourceSynchronously(NetworkingContext*, const ResourceRequest&amp;, StoredCredentialsPolicy, ResourceError&amp;, ResourceResponse&amp;, Vector&lt;char&gt;&amp; data);
235 
236     void refAuthenticationClient() override { ref(); }
237     void derefAuthenticationClient() override { deref(); }
238 
239 #if PLATFORM(COCOA) || USE(CFURLCONNECTION)
240     enum class SchedulingBehavior { Asynchronous, Synchronous };
241 #endif
242 
243 #if USE(CFURLCONNECTION)
<span class="line-modified">244     void createCFURLConnection(bool shouldUseCredentialStorage, bool shouldContentSniff, bool shouldContentEncodingSniff, WTF::MessageQueue&lt;WTF::Function&lt;void()&gt;&gt;*, CFDictionaryRef clientProperties);</span>
245 #endif
246 
247 #if PLATFORM(MAC)
248     void createNSURLConnection(id delegate, bool shouldUseCredentialStorage, bool shouldContentSniff, bool shouldContentEncodingSniff, SchedulingBehavior);
249 #endif
250 
251 #if PLATFORM(IOS_FAMILY)
252     void createNSURLConnection(id delegate, bool shouldUseCredentialStorage, bool shouldContentSniff, bool shouldContentEncodingSniff, SchedulingBehavior, NSDictionary *connectionProperties);
253 #endif
254 
255 #if PLATFORM(COCOA)
256     NSURLRequest *applySniffingPoliciesIfNeeded(NSURLRequest *, bool shouldContentSniff, bool shouldContentEncodingSniff);
257 #endif
258 
259 #if USE(CURL)
260     enum class RequestStatus {
261         NewRequest,
262         ReusedRequest
263     };
264 
</pre>
</td>
<td>
<hr />
<pre>
 69 
 70 namespace WTF {
 71 class SchedulePair;
 72 template&lt;typename T&gt; class MessageQueue;
 73 }
 74 
 75 namespace WebCore {
 76 
 77 class AuthenticationChallenge;
 78 class Credential;
 79 class Frame;
 80 class NetworkingContext;
 81 class ProtectionSpace;
 82 class ResourceError;
 83 class ResourceHandleClient;
 84 class ResourceHandleInternal;
 85 class NetworkLoadMetrics;
 86 class ResourceRequest;
 87 class ResourceResponse;
 88 class SharedBuffer;
<span class="line-added"> 89 class SynchronousLoaderMessageQueue;</span>
 90 class Timer;
 91 
 92 #if USE(CURL)
 93 class CurlRequest;
 94 class CurlResourceHandleDelegate;
 95 #endif
 96 
 97 class ResourceHandle : public RefCounted&lt;ResourceHandle&gt;, public AuthenticationClient {
 98 public:
 99     WEBCORE_EXPORT static RefPtr&lt;ResourceHandle&gt; create(NetworkingContext*, const ResourceRequest&amp;, ResourceHandleClient*, bool defersLoading, bool shouldContentSniff, bool shouldContentEncodingSniff);
100     WEBCORE_EXPORT static void loadResourceSynchronously(NetworkingContext*, const ResourceRequest&amp;, StoredCredentialsPolicy, ResourceError&amp;, ResourceResponse&amp;, Vector&lt;char&gt;&amp; data);
101     WEBCORE_EXPORT virtual ~ResourceHandle();
102 
103 #if PLATFORM(COCOA) || USE(CFURLCONNECTION)
104     void willSendRequest(ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;);
105 #endif
106 
107 #if PLATFORM(JAVA)
108     void continueAfterWillSendRequest(ResourceRequest&amp;&amp; request);
109     void willSendRequest(const ResourceResponse&amp; response);
</pre>
<hr />
<pre>
112     void didReceiveResponse(ResourceResponse&amp;&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;);
113 
114     bool shouldUseCredentialStorage();
115     void didReceiveAuthenticationChallenge(const AuthenticationChallenge&amp;);
116     void receivedCredential(const AuthenticationChallenge&amp;, const Credential&amp;) override;
117     void receivedRequestToContinueWithoutCredential(const AuthenticationChallenge&amp;) override;
118     void receivedCancellation(const AuthenticationChallenge&amp;) override;
119     void receivedRequestToPerformDefaultHandling(const AuthenticationChallenge&amp;) override;
120     void receivedChallengeRejection(const AuthenticationChallenge&amp;) override;
121 
122 #if PLATFORM(COCOA) || USE(CFURLCONNECTION)
123     bool tryHandlePasswordBasedAuthentication(const AuthenticationChallenge&amp;);
124 #endif
125 
126 #if PLATFORM(COCOA) &amp;&amp; USE(PROTECTION_SPACE_AUTH_CALLBACK)
127     void canAuthenticateAgainstProtectionSpace(const ProtectionSpace&amp;, CompletionHandler&lt;void(bool)&gt;&amp;&amp;);
128 #endif
129 
130 #if PLATFORM(COCOA)
131     WEBCORE_EXPORT NSURLConnection *connection() const;
<span class="line-modified">132     id makeDelegate(bool, RefPtr&lt;SynchronousLoaderMessageQueue&gt;&amp;&amp;);</span>
133     id delegate();
134     void releaseDelegate();
135 #endif
136 
137 #if PLATFORM(COCOA)
138 #if USE(CFURLCONNECTION)
139     static void getConnectionTimingData(CFURLConnectionRef, NetworkLoadMetrics&amp;);
140 #else
141     static void getConnectionTimingData(NSURLConnection *, NetworkLoadMetrics&amp;);
142 #endif
143 #endif
144 
145 #if PLATFORM(COCOA)
146     void schedule(WTF::SchedulePair&amp;);
147     void unschedule(WTF::SchedulePair&amp;);
148 #endif
149 
150 #if USE(CFURLCONNECTION)
151     CFURLStorageSessionRef storageSession() const;
152     CFURLConnectionRef connection() const;
153     WEBCORE_EXPORT RetainPtr&lt;CFURLConnectionRef&gt; releaseConnectionForDownload();
154     const ResourceRequest&amp; currentRequest() const;
155     static void setHostAllowsAnyHTTPSCertificate(const String&amp;);
156     static void setClientCertificate(const String&amp; host, CFDataRef);
157 #endif
158 
159 #if OS(WINDOWS) &amp;&amp; USE(CURL)
160     static void setHostAllowsAnyHTTPSCertificate(const String&amp;);
161     static void setClientCertificateInfo(const String&amp;, const String&amp;, const String&amp;);
162 #endif
163 




164     bool shouldContentSniff() const;
165     static bool shouldContentSniffURL(const URL&amp;);
166 
167     bool shouldContentEncodingSniff() const;
168 
169     WEBCORE_EXPORT static void forceContentSniffing();
170 
171 #if USE(CURL)
172     ResourceHandleInternal* getInternal() { return d.get(); }
173 #endif
174 
175 #if USE(CURL)
176     bool cancelledOrClientless();
177     CurlResourceHandleDelegate* delegate();
178 
179     void continueAfterDidReceiveResponse();
180     void willSendRequest();
181     void continueAfterWillSendRequest(ResourceRequest&amp;&amp;);
182 #endif
183 
</pre>
<hr />
<pre>
221         InvalidURLFailure
222     };
223 
224     void platformSetDefersLoading(bool);
225 
226     void platformContinueSynchronousDidReceiveResponse();
227 
228     void scheduleFailure(FailureType);
229 
230     bool start();
231     static void platformLoadResourceSynchronously(NetworkingContext*, const ResourceRequest&amp;, StoredCredentialsPolicy, ResourceError&amp;, ResourceResponse&amp;, Vector&lt;char&gt;&amp; data);
232 
233     void refAuthenticationClient() override { ref(); }
234     void derefAuthenticationClient() override { deref(); }
235 
236 #if PLATFORM(COCOA) || USE(CFURLCONNECTION)
237     enum class SchedulingBehavior { Asynchronous, Synchronous };
238 #endif
239 
240 #if USE(CFURLCONNECTION)
<span class="line-modified">241     void createCFURLConnection(bool shouldUseCredentialStorage, bool shouldContentSniff, bool shouldContentEncodingSniff, RefPtr&lt;SynchronousLoaderMessageQueue&gt;&amp;&amp;, CFDictionaryRef clientProperties);</span>
242 #endif
243 
244 #if PLATFORM(MAC)
245     void createNSURLConnection(id delegate, bool shouldUseCredentialStorage, bool shouldContentSniff, bool shouldContentEncodingSniff, SchedulingBehavior);
246 #endif
247 
248 #if PLATFORM(IOS_FAMILY)
249     void createNSURLConnection(id delegate, bool shouldUseCredentialStorage, bool shouldContentSniff, bool shouldContentEncodingSniff, SchedulingBehavior, NSDictionary *connectionProperties);
250 #endif
251 
252 #if PLATFORM(COCOA)
253     NSURLRequest *applySniffingPoliciesIfNeeded(NSURLRequest *, bool shouldContentSniff, bool shouldContentEncodingSniff);
254 #endif
255 
256 #if USE(CURL)
257     enum class RequestStatus {
258         NewRequest,
259         ReusedRequest
260     };
261 
</pre>
</td>
</tr>
</table>
<center><a href="ResourceHandle.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ResourceHandleInternal.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoaderClient.h b/modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoaderClient.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoaderClient.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoaderClient.h
@@ -61,14 +61,10 @@
 OBJC_CLASS NSCachedURLResponse;
 OBJC_CLASS NSDictionary;
 OBJC_CLASS NSView;
 #endif
 
-namespace PAL {
-class SessionID;
-}
-
 namespace WebCore {
 
 class AuthenticationChallenge;
 class CachedFrame;
 class CachedResourceRequest;
@@ -86,15 +82,15 @@
 class HTMLFormElement;
 class HTMLFrameOwnerElement;
 class HTMLPlugInElement;
 class HistoryItem;
 class IntSize;
+class LegacyPreviewLoaderClient;
 class MessageEvent;
 class NavigationAction;
 class Page;
 class PluginViewBase;
-class PreviewLoaderClient;
 class ProtectionSpace;
 class RTCPeerConnectionHandler;
 class ResourceError;
 class ResourceHandle;
 class ResourceRequest;
@@ -128,15 +124,14 @@
 
     virtual void makeRepresentation(DocumentLoader*) = 0;
 
     virtual Optional<PageIdentifier> pageID() const = 0;
     virtual Optional<FrameIdentifier> frameID() const = 0;
-    virtual PAL::SessionID sessionID() const = 0;
 
 #if PLATFORM(IOS_FAMILY)
     // Returns true if the client forced the layout.
-    virtual bool forceLayoutOnRestoreFromPageCache() = 0;
+    virtual bool forceLayoutOnRestoreFromBackForwardCache() = 0;
 #endif
     virtual void forceLayoutForNonHTML() = 0;
 
     virtual void setCopiesOnScroll() = 0;
 
@@ -181,11 +176,11 @@
     virtual void dispatchDidCommitLoad(Optional<HasInsecureContent>) = 0;
     virtual void dispatchDidFailProvisionalLoad(const ResourceError&, WillContinueLoading) = 0;
     virtual void dispatchDidFailLoad(const ResourceError&) = 0;
     virtual void dispatchDidFinishDocumentLoad() = 0;
     virtual void dispatchDidFinishLoad() = 0;
-    virtual void dispatchDidExplicitOpen(const URL&) { }
+    virtual void dispatchDidExplicitOpen(const URL&, const String& /* mimeType */) { }
 #if ENABLE(DATA_DETECTION)
     virtual void dispatchDidFinishDataDetection(NSArray *detectionResults) = 0;
 #endif
 
     virtual void dispatchDidLayout() { }
@@ -281,17 +276,16 @@
 #if PLATFORM(IOS_FAMILY)
     virtual void didRestoreFrameHierarchyForCachedFrame() = 0;
 #endif
     virtual void transitionToCommittedForNewPage() = 0;
 
-    virtual void didSaveToPageCache() = 0;
-    virtual void didRestoreFromPageCache() = 0;
+    virtual void didRestoreFromBackForwardCache() = 0;
 
     virtual void dispatchDidBecomeFrameset(bool) = 0; // Can change due to navigation or DOM modification.
 
     virtual bool canCachePage() const = 0;
-    virtual void convertMainResourceLoadToDownload(DocumentLoader*, PAL::SessionID, const ResourceRequest&, const ResourceResponse&) = 0;
+    virtual void convertMainResourceLoadToDownload(DocumentLoader*, const ResourceRequest&, const ResourceResponse&) = 0;
 
     virtual RefPtr<Frame> createFrame(const URL&, const String& name, HTMLFrameOwnerElement&, const String& referrer) = 0;
     virtual RefPtr<Widget> createPlugin(const IntSize&, HTMLPlugInElement&, const URL&, const Vector<String>&, const Vector<String>&, const String&, bool loadManually) = 0;
     virtual void redirectDataToPlugin(Widget&) = 0;
 
@@ -342,26 +336,27 @@
 #endif
 
 #if ENABLE(WEBGL)
     virtual bool allowWebGL(bool enabledPerSettings) { return enabledPerSettings; }
     // Informs the embedder that a WebGL canvas inside this frame received a lost context
-    // notification with the given GL_ARB_robustness guilt/innocence code (see Extensions3D.h).
+    // notification with the given GL_ARB_robustness guilt/innocence code (see ExtensionsGL.h).
     virtual void didLoseWebGLContext(int) { }
     virtual WebGLLoadPolicy webGLPolicyForURL(const URL&) const { return WebGLAllowCreation; }
     virtual WebGLLoadPolicy resolveWebGLPolicyForURL(const URL&) const { return WebGLAllowCreation; }
 #endif
 
     virtual void forcePageTransitionIfNeeded() { }
 
     // FIXME (bug 116233): We need to get rid of EmptyFrameLoaderClient completely, then this will no longer be needed.
-    virtual bool isEmptyFrameLoaderClient() { return false; }
+    virtual bool isEmptyFrameLoaderClient() const { return false; }
+    virtual bool isServiceWorkerFrameLoaderClient() const { return false; }
 
 #if PLATFORM(JAVA)
         virtual bool isJavaFrameLoaderClient() { return false; }
 #endif
 #if USE(QUICK_LOOK)
-    virtual RefPtr<PreviewLoaderClient> createPreviewLoaderClient(const String&, const String&) = 0;
+    virtual RefPtr<LegacyPreviewLoaderClient> createPreviewLoaderClient(const String&, const String&) = 0;
 #endif
 
 #if ENABLE(CONTENT_FILTERING)
     virtual void contentFilterDidBlockLoad(ContentFilterUnblockHandler) { }
 #endif
@@ -379,10 +374,9 @@
     virtual void finishedLoadingApplicationManifest(uint64_t, const Optional<ApplicationManifest>&) { }
 #endif
 
 #if ENABLE(RESOURCE_LOAD_STATISTICS)
     virtual bool hasFrameSpecificStorageAccess() { return false; }
-    virtual void setHasFrameSpecificStorageAccess(bool) { }
 #endif
 };
 
 } // namespace WebCore

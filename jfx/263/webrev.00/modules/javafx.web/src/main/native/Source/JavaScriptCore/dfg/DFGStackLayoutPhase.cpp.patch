diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStackLayoutPhase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStackLayoutPhase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStackLayoutPhase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStackLayoutPhase.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -34,11 +34,11 @@
 #include "JSCInlines.h"
 
 namespace JSC { namespace DFG {
 
 class StackLayoutPhase : public Phase {
-    static const bool verbose = false;
+    static constexpr bool verbose = false;
 
 public:
     StackLayoutPhase(Graph& graph)
         : Phase(graph, "stack layout")
     {
@@ -49,11 +49,11 @@
         // This enumerates the locals that we actually care about and packs them. So for example
         // if we use local 1, 3, 4, 5, 7, then we remap them: 1->0, 3->1, 4->2, 5->3, 7->4. We
         // treat a variable as being "used" if there exists an access to it (SetLocal, GetLocal,
         // Flush, PhantomLocal).
 
-        BitVector usedLocals;
+        Operands<bool> usedOperands(0, graph().m_localVars, graph().m_tmps, false);
 
         // Collect those variables that are used from IR.
         bool hasNodesThatNeedFixup = false;
         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
             BasicBlock* block = m_graph.block(blockIndex);
@@ -65,38 +65,37 @@
                 case GetLocal:
                 case SetLocal:
                 case Flush:
                 case PhantomLocal: {
                     VariableAccessData* variable = node->variableAccessData();
-                    if (variable->local().isArgument())
+                    if (variable->operand().isArgument())
                         break;
-                    usedLocals.set(variable->local().toLocal());
+                    usedOperands.setOperand(variable->operand(), true);
                     break;
                 }
 
                 case LoadVarargs:
                 case ForwardVarargs: {
                     LoadVarargsData* data = node->loadVarargsData();
-                    if (data->count.isLocal())
-                        usedLocals.set(data->count.toLocal());
+                    usedOperands.setOperand(data->count, true);
                     if (data->start.isLocal()) {
                         // This part really relies on the contiguity of stack layout
                         // assignments.
                         ASSERT(VirtualRegister(data->start.offset() + data->limit - 1).isLocal());
                         for (unsigned i = data->limit; i--;)
-                            usedLocals.set(VirtualRegister(data->start.offset() + i).toLocal());
+                            usedOperands.setOperand(VirtualRegister(data->start.offset() + i), true);
                     } // the else case shouldn't happen.
                     hasNodesThatNeedFixup = true;
                     break;
                 }
 
                 case PutStack:
                 case GetStack: {
                     StackAccessData* stack = node->stackAccessData();
-                    if (stack->local.isArgument())
+                    if (stack->operand.isArgument())
                         break;
-                    usedLocals.set(stack->local.toLocal());
+                    usedOperands.setOperand(stack->operand, true);
                     break;
                 }
 
                 default:
                     break;
@@ -106,25 +105,25 @@
 
         for (InlineCallFrameSet::iterator iter = m_graph.m_plan.inlineCallFrames()->begin(); !!iter; ++iter) {
             InlineCallFrame* inlineCallFrame = *iter;
 
             if (inlineCallFrame->isVarargs()) {
-                usedLocals.set(VirtualRegister(
-                    CallFrameSlot::argumentCount + inlineCallFrame->stackOffset).toLocal());
+                usedOperands.setOperand(VirtualRegister(
+                    CallFrameSlot::argumentCountIncludingThis + inlineCallFrame->stackOffset), true);
             }
 
             for (unsigned argument = inlineCallFrame->argumentsWithFixup.size(); argument--;) {
-                usedLocals.set(VirtualRegister(
-                    virtualRegisterForArgument(argument).offset() +
-                    inlineCallFrame->stackOffset).toLocal());
+                usedOperands.setOperand(VirtualRegister(
+                    virtualRegisterForArgumentIncludingThis(argument).offset() +
+                    inlineCallFrame->stackOffset), true);
             }
         }
 
-        Vector<unsigned> allocation(usedLocals.size());
+        Vector<unsigned> allocation(usedOperands.size());
         m_graph.m_nextMachineLocal = codeBlock()->calleeSaveSpaceAsVirtualRegisters();
-        for (unsigned i = 0; i < usedLocals.size(); ++i) {
-            if (!usedLocals.get(i)) {
+        for (unsigned i = 0; i < usedOperands.size(); ++i) {
+            if (!usedOperands.getForOperandIndex(i)) {
                 allocation[i] = UINT_MAX;
                 continue;
             }
 
             allocation[i] = m_graph.m_nextMachineLocal++;
@@ -133,52 +132,53 @@
         for (unsigned i = m_graph.m_variableAccessData.size(); i--;) {
             VariableAccessData* variable = &m_graph.m_variableAccessData[i];
             if (!variable->isRoot())
                 continue;
 
-            if (variable->local().isArgument()) {
-                variable->machineLocal() = variable->local();
+            if (variable->operand().isArgument()) {
+                variable->machineLocal() = variable->operand().virtualRegister();
                 continue;
             }
 
-            size_t local = variable->local().toLocal();
-            if (local >= allocation.size())
+            Operand operand = variable->operand();
+            size_t index = usedOperands.operandIndex(operand);
+            if (index >= allocation.size())
                 continue;
 
-            if (allocation[local] == UINT_MAX)
+            if (allocation[index] == UINT_MAX)
                 continue;
 
-            variable->machineLocal() = assign(allocation, variable->local());
+            variable->machineLocal() = assign(usedOperands, allocation, variable->operand());
         }
 
         for (StackAccessData* data : m_graph.m_stackAccessData) {
-            if (!data->local.isLocal()) {
-                data->machineLocal = data->local;
+            if (data->operand.isArgument()) {
+                data->machineLocal = data->operand.virtualRegister();
                 continue;
             }
 
-            if (static_cast<size_t>(data->local.toLocal()) >= allocation.size())
-                continue;
-            if (allocation[data->local.toLocal()] == UINT_MAX)
-                continue;
+            if (data->operand.isLocal()) {
+                if (static_cast<size_t>(data->operand.toLocal()) >= allocation.size())
+                    continue;
+                if (allocation[data->operand.toLocal()] == UINT_MAX)
+                    continue;
+            }
 
-            data->machineLocal = assign(allocation, data->local);
+            data->machineLocal = assign(usedOperands, allocation, data->operand);
         }
 
         if (!m_graph.needsScopeRegister())
             codeBlock()->setScopeRegister(VirtualRegister());
         else
-            codeBlock()->setScopeRegister(assign(allocation, codeBlock()->scopeRegister()));
+            codeBlock()->setScopeRegister(assign(usedOperands, allocation, codeBlock()->scopeRegister()));
 
         for (unsigned i = m_graph.m_inlineVariableData.size(); i--;) {
             InlineVariableData data = m_graph.m_inlineVariableData[i];
             InlineCallFrame* inlineCallFrame = data.inlineCallFrame;
 
-            if (inlineCallFrame->isVarargs()) {
-                inlineCallFrame->argumentCountRegister = assign(
-                    allocation, VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCount));
-            }
+            if (inlineCallFrame->isVarargs())
+                inlineCallFrame->argumentCountRegister = assign(usedOperands, allocation, VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCountIncludingThis));
 
             for (unsigned argument = inlineCallFrame->argumentsWithFixup.size(); argument--;) {
                 ArgumentPosition& position = m_graph.m_argumentPositions[
                     data.argumentPositionStart + argument];
                 VariableAccessData* variable = position.someVariable();
@@ -213,12 +213,12 @@
                     Node* node = block->at(nodeIndex);
                     switch (node->op()) {
                     case LoadVarargs:
                     case ForwardVarargs: {
                         LoadVarargsData* data = node->loadVarargsData();
-                        data->machineCount = assign(allocation, data->count);
-                        data->machineStart = assign(allocation, data->start);
+                        data->machineCount = assign(usedOperands, allocation, data->count);
+                        data->machineStart = assign(usedOperands, allocation, data->start);
                         break;
                     }
 
                     default:
                         break;
@@ -229,21 +229,20 @@
 
         return true;
     }
 
 private:
-    VirtualRegister assign(const Vector<unsigned>& allocation, VirtualRegister src)
+    VirtualRegister assign(const Operands<bool>& usedOperands, const Vector<unsigned>& allocation, Operand operand)
     {
-        VirtualRegister result = src;
-        if (result.isLocal()) {
-            unsigned myAllocation = allocation[result.toLocal()];
-            if (myAllocation == UINT_MAX)
-                result = VirtualRegister();
-            else
-                result = virtualRegisterForLocal(myAllocation);
-        }
-        return result;
+        if (operand.isArgument())
+            return operand.virtualRegister();
+
+        size_t operandIndex = usedOperands.operandIndex(operand);
+        unsigned myAllocation = allocation[operandIndex];
+        if (myAllocation == UINT_MAX)
+            return VirtualRegister();
+        return virtualRegisterForLocal(myAllocation);
     }
 };
 
 bool performStackLayout(Graph& graph)
 {

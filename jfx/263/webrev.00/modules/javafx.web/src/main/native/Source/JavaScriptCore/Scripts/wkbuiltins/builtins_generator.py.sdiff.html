<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/Scripts/wkbuiltins/builtins_generator.py</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="builtins_generate_separate_header.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="builtins_model.py.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/Scripts/wkbuiltins/builtins_generator.py</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
112         ])
113 
114     def generate_embedded_code_data_for_function(self, function):
115         text = function.function_source
116         # Wrap it in parens to avoid adding to global scope.
117         function_type_string = &quot;function &quot;
118         if function.is_async:
119             function_type_string = &quot;async &quot; + function_type_string
120 
121         text = &quot;(&quot; + function_type_string + text[text.index(&quot;(&quot;):] + &quot;)&quot;
122         embeddedSourceLength = len(text) + 1  # For extra \n.
123         # Lazy way to escape quotes, I think?
124         textLines = json.dumps(text)[1:-1].split(&quot;\\n&quot;)
125         # This looks scary because we need the JS source itself to have newlines.
126         embeddedSource = &#39;\n&#39;.join([&#39;    &quot;%s\\n&quot; \\&#39; % line for line in textLines])
127 
128         constructAbility = &quot;CannotConstruct&quot;
129         if function.is_constructor:
130             constructAbility = &quot;CanConstruct&quot;
131 




132         return {
133             &#39;codeName&#39;: BuiltinsGenerator.mangledNameForFunction(function) + &#39;Code&#39;,
134             &#39;embeddedSource&#39;: embeddedSource,
135             &#39;embeddedSourceLength&#39;: embeddedSourceLength,
136             &#39;originalSource&#39;: text + &quot;\n&quot;,
<span class="line-modified">137             &#39;canConstruct&#39;: constructAbility,</span>

138             &#39;intrinsic&#39;: function.intrinsic
139         }
140 
141     def generate_embedded_code_string_section_for_data(self, data):
142         lines = []
<span class="line-modified">143         lines.append(&quot;const JSC::ConstructAbility s_%(codeName)sConstructAbility = JSC::ConstructAbility::%(canConstruct)s;&quot; % data);</span>

144         lines.append(&quot;const int s_%(codeName)sLength = %(embeddedSourceLength)d;&quot; % data);
145         lines.append(&quot;static const JSC::Intrinsic s_%(codeName)sIntrinsic = JSC::%(intrinsic)s;&quot; % data);
146         lines.append(&quot;const char* const s_%(codeName)s =\n%(embeddedSource)s\n;&quot; % data);
147         return &#39;\n&#39;.join(lines)
148 
149     # Helper methods.
150 
151     @staticmethod
152     def wrap_with_guard(guard, text):
153         if not guard:
154             return text
155         return &#39;\n&#39;.join([
156             &#39;#if %s&#39; % guard,
157             text,
158             &#39;#endif // %s&#39; % guard,
159         ])
160 
161     @staticmethod
162     def mangledNameForObject(object):
163         if not isinstance(object, BuiltinObject):
</pre>
</td>
<td>
<hr />
<pre>
112         ])
113 
114     def generate_embedded_code_data_for_function(self, function):
115         text = function.function_source
116         # Wrap it in parens to avoid adding to global scope.
117         function_type_string = &quot;function &quot;
118         if function.is_async:
119             function_type_string = &quot;async &quot; + function_type_string
120 
121         text = &quot;(&quot; + function_type_string + text[text.index(&quot;(&quot;):] + &quot;)&quot;
122         embeddedSourceLength = len(text) + 1  # For extra \n.
123         # Lazy way to escape quotes, I think?
124         textLines = json.dumps(text)[1:-1].split(&quot;\\n&quot;)
125         # This looks scary because we need the JS source itself to have newlines.
126         embeddedSource = &#39;\n&#39;.join([&#39;    &quot;%s\\n&quot; \\&#39; % line for line in textLines])
127 
128         constructAbility = &quot;CannotConstruct&quot;
129         if function.is_constructor:
130             constructAbility = &quot;CanConstruct&quot;
131 
<span class="line-added">132         constructorKind = &quot;None&quot;</span>
<span class="line-added">133         if function.is_naked_constructor:</span>
<span class="line-added">134             constructorKind = &quot;Naked&quot;</span>
<span class="line-added">135 </span>
136         return {
137             &#39;codeName&#39;: BuiltinsGenerator.mangledNameForFunction(function) + &#39;Code&#39;,
138             &#39;embeddedSource&#39;: embeddedSource,
139             &#39;embeddedSourceLength&#39;: embeddedSourceLength,
140             &#39;originalSource&#39;: text + &quot;\n&quot;,
<span class="line-modified">141             &#39;constructAbility&#39;: constructAbility,</span>
<span class="line-added">142             &#39;constructorKind&#39;: constructorKind,</span>
143             &#39;intrinsic&#39;: function.intrinsic
144         }
145 
146     def generate_embedded_code_string_section_for_data(self, data):
147         lines = []
<span class="line-modified">148         lines.append(&quot;const JSC::ConstructAbility s_%(codeName)sConstructAbility = JSC::ConstructAbility::%(constructAbility)s;&quot; % data);</span>
<span class="line-added">149         lines.append(&quot;const JSC::ConstructorKind s_%(codeName)sConstructorKind = JSC::ConstructorKind::%(constructorKind)s;&quot; % data);</span>
150         lines.append(&quot;const int s_%(codeName)sLength = %(embeddedSourceLength)d;&quot; % data);
151         lines.append(&quot;static const JSC::Intrinsic s_%(codeName)sIntrinsic = JSC::%(intrinsic)s;&quot; % data);
152         lines.append(&quot;const char* const s_%(codeName)s =\n%(embeddedSource)s\n;&quot; % data);
153         return &#39;\n&#39;.join(lines)
154 
155     # Helper methods.
156 
157     @staticmethod
158     def wrap_with_guard(guard, text):
159         if not guard:
160             return text
161         return &#39;\n&#39;.join([
162             &#39;#if %s&#39; % guard,
163             text,
164             &#39;#endif // %s&#39; % guard,
165         ])
166 
167     @staticmethod
168     def mangledNameForObject(object):
169         if not isinstance(object, BuiltinObject):
</pre>
</td>
</tr>
</table>
<center><a href="builtins_generate_separate_header.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="builtins_model.py.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
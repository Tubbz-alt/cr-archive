<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLIntrinsics.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLIntrinsics.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLLexer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLIntrinsics.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41 
 42 class Intrinsics {
 43 public:
 44     Intrinsics();
 45 
 46     void add(AST::NativeFunctionDeclaration&amp;);
 47     void add(AST::NativeTypeDeclaration&amp;);
 48 
 49     AST::NativeTypeDeclaration&amp; voidType() const
 50     {
 51         ASSERT(m_voidType);
 52         return *m_voidType;
 53     }
 54 
 55     AST::NativeTypeDeclaration&amp; boolType() const
 56     {
 57         ASSERT(m_boolType);
 58         return *m_boolType;
 59     }
 60 






 61     AST::NativeTypeDeclaration&amp; uintType() const
 62     {
 63         ASSERT(m_uintType);
 64         return *m_uintType;
 65     }
 66 
 67     AST::NativeTypeDeclaration&amp; intType() const
 68     {
 69         ASSERT(m_intType);
 70         return *m_intType;
 71     }
 72 
 73     AST::NativeTypeDeclaration&amp; uint2Type() const
 74     {
 75         ASSERT(m_vectorUint[0]);
 76         return *m_vectorUint[0];
 77     }
 78 
 79     AST::NativeTypeDeclaration&amp; uint4Type() const
 80     {
 81         ASSERT(m_vectorUint[2]);
 82         return *m_vectorUint[2];
 83     }
 84 






 85     AST::NativeTypeDeclaration&amp; int2Type() const
 86     {
 87         ASSERT(m_vectorInt[0]);
 88         return *m_vectorInt[0];
 89     }
 90 
 91     AST::NativeTypeDeclaration&amp; int4Type() const
 92     {
 93         ASSERT(m_vectorInt[2]);
 94         return *m_vectorInt[2];
 95     }
 96 






 97     AST::NativeTypeDeclaration&amp; samplerType() const
 98     {
 99         ASSERT(m_samplerType);
100         return *m_samplerType;
101     }
102 
103     AST::NativeTypeDeclaration&amp; floatType() const
104     {
105         ASSERT(m_floatType);
106         return *m_floatType;
107     }
108 
109     AST::NativeTypeDeclaration&amp; float2Type() const
110     {
111         ASSERT(m_vectorFloat[0]);
112         return *m_vectorFloat[0];
113     }
114 
115     AST::NativeTypeDeclaration&amp; float3Type() const
116     {
117         ASSERT(m_vectorFloat[1]);
118         return *m_vectorFloat[1];
119     }
120 
121     AST::NativeTypeDeclaration&amp; float4Type() const
122     {
123         ASSERT(m_vectorFloat[2]);
124         return *m_vectorFloat[2];
125     }
126 






127     // These functions may have been pruned from the AST if they are unused.
128     AST::NativeFunctionDeclaration* ddx() const
129     {
130         return m_ddx;
131     }
132 
133     AST::NativeFunctionDeclaration* ddy() const
134     {
135         return m_ddy;
136     }
137 
138     AST::NativeFunctionDeclaration* allMemoryBarrier() const
139     {
140         return m_allMemoryBarrier;
141     }
142 
143     AST::NativeFunctionDeclaration* deviceMemoryBarrier() const
144     {
145         return m_deviceMemoryBarrier;
146     }
</pre>
</td>
<td>
<hr />
<pre>
 41 
 42 class Intrinsics {
 43 public:
 44     Intrinsics();
 45 
 46     void add(AST::NativeFunctionDeclaration&amp;);
 47     void add(AST::NativeTypeDeclaration&amp;);
 48 
 49     AST::NativeTypeDeclaration&amp; voidType() const
 50     {
 51         ASSERT(m_voidType);
 52         return *m_voidType;
 53     }
 54 
 55     AST::NativeTypeDeclaration&amp; boolType() const
 56     {
 57         ASSERT(m_boolType);
 58         return *m_boolType;
 59     }
 60 
<span class="line-added"> 61     AST::NativeTypeDeclaration&amp; boolVectorTypeForSize(unsigned size) const</span>
<span class="line-added"> 62     {</span>
<span class="line-added"> 63         RELEASE_ASSERT(size == 2 || size == 3 || size == 4);</span>
<span class="line-added"> 64         return *m_vectorBool[size - 2];</span>
<span class="line-added"> 65     }</span>
<span class="line-added"> 66 </span>
 67     AST::NativeTypeDeclaration&amp; uintType() const
 68     {
 69         ASSERT(m_uintType);
 70         return *m_uintType;
 71     }
 72 
 73     AST::NativeTypeDeclaration&amp; intType() const
 74     {
 75         ASSERT(m_intType);
 76         return *m_intType;
 77     }
 78 
 79     AST::NativeTypeDeclaration&amp; uint2Type() const
 80     {
 81         ASSERT(m_vectorUint[0]);
 82         return *m_vectorUint[0];
 83     }
 84 
 85     AST::NativeTypeDeclaration&amp; uint4Type() const
 86     {
 87         ASSERT(m_vectorUint[2]);
 88         return *m_vectorUint[2];
 89     }
 90 
<span class="line-added"> 91     AST::NativeTypeDeclaration&amp; uintVectorTypeForSize(unsigned size) const</span>
<span class="line-added"> 92     {</span>
<span class="line-added"> 93         RELEASE_ASSERT(size == 2 || size == 3 || size == 4);</span>
<span class="line-added"> 94         return *m_vectorUint[size - 2];</span>
<span class="line-added"> 95     }</span>
<span class="line-added"> 96 </span>
 97     AST::NativeTypeDeclaration&amp; int2Type() const
 98     {
 99         ASSERT(m_vectorInt[0]);
100         return *m_vectorInt[0];
101     }
102 
103     AST::NativeTypeDeclaration&amp; int4Type() const
104     {
105         ASSERT(m_vectorInt[2]);
106         return *m_vectorInt[2];
107     }
108 
<span class="line-added">109     AST::NativeTypeDeclaration&amp; intVectorTypeForSize(unsigned size) const</span>
<span class="line-added">110     {</span>
<span class="line-added">111         RELEASE_ASSERT(size == 2 || size == 3 || size == 4);</span>
<span class="line-added">112         return *m_vectorInt[size - 2];</span>
<span class="line-added">113     }</span>
<span class="line-added">114 </span>
115     AST::NativeTypeDeclaration&amp; samplerType() const
116     {
117         ASSERT(m_samplerType);
118         return *m_samplerType;
119     }
120 
121     AST::NativeTypeDeclaration&amp; floatType() const
122     {
123         ASSERT(m_floatType);
124         return *m_floatType;
125     }
126 
127     AST::NativeTypeDeclaration&amp; float2Type() const
128     {
129         ASSERT(m_vectorFloat[0]);
130         return *m_vectorFloat[0];
131     }
132 
133     AST::NativeTypeDeclaration&amp; float3Type() const
134     {
135         ASSERT(m_vectorFloat[1]);
136         return *m_vectorFloat[1];
137     }
138 
139     AST::NativeTypeDeclaration&amp; float4Type() const
140     {
141         ASSERT(m_vectorFloat[2]);
142         return *m_vectorFloat[2];
143     }
144 
<span class="line-added">145     AST::NativeTypeDeclaration&amp; floatVectorTypeForSize(unsigned size) const</span>
<span class="line-added">146     {</span>
<span class="line-added">147         RELEASE_ASSERT(size == 2 || size == 3 || size == 4);</span>
<span class="line-added">148         return *m_vectorFloat[size - 2];</span>
<span class="line-added">149     }</span>
<span class="line-added">150 </span>
151     // These functions may have been pruned from the AST if they are unused.
152     AST::NativeFunctionDeclaration* ddx() const
153     {
154         return m_ddx;
155     }
156 
157     AST::NativeFunctionDeclaration* ddy() const
158     {
159         return m_ddy;
160     }
161 
162     AST::NativeFunctionDeclaration* allMemoryBarrier() const
163     {
164         return m_allMemoryBarrier;
165     }
166 
167     AST::NativeFunctionDeclaration* deviceMemoryBarrier() const
168     {
169         return m_deviceMemoryBarrier;
170     }
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLIntrinsics.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLLexer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
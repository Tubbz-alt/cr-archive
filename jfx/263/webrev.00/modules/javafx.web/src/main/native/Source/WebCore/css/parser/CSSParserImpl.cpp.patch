diff a/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserImpl.cpp b/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserImpl.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserImpl.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserImpl.cpp
@@ -83,15 +83,11 @@
 }
 
 CSSParser::ParseResult CSSParserImpl::parseValue(MutableStyleProperties* declaration, CSSPropertyID propertyID, const String& string, bool important, const CSSParserContext& context)
 {
     CSSParserImpl parser(context, string);
-    StyleRule::Type ruleType = StyleRule::Style;
-#if ENABLE(CSS_DEVICE_ADAPTATION)
-    if (declaration->cssParserMode() == CSSViewportRuleMode)
-        ruleType = StyleRule::Viewport;
-#endif
+    auto ruleType = context.enclosingRuleType.valueOr(StyleRuleType::Style);
     parser.consumeDeclarationValue(parser.tokenizer()->tokenRange(), propertyID, important, ruleType);
     if (parser.m_parsedProperties.isEmpty())
         return CSSParser::ParseResult::Error;
     return declaration->addParsedProperties(parser.m_parsedProperties) ? CSSParser::ParseResult::Changed : CSSParser::ParseResult::Unchanged;
 }
@@ -160,22 +156,22 @@
 {
     CSSParserContext context(element->document());
     context.mode = strictToCSSParserMode(element->isHTMLElement() && !element->document().inQuirksMode());
 
     CSSParserImpl parser(context, string);
-    parser.consumeDeclarationList(parser.tokenizer()->tokenRange(), StyleRule::Style);
+    parser.consumeDeclarationList(parser.tokenizer()->tokenRange(), StyleRuleType::Style);
     return createStyleProperties(parser.m_parsedProperties, context.mode);
 }
 
 Ref<ImmutableStyleProperties> CSSParserImpl::parseDeferredDeclaration(CSSParserTokenRange tokenRange, const CSSParserContext& context, StyleSheetContents* styleSheet)
 {
     if (!styleSheet) {
         ParsedPropertyVector properties;
         return createStyleProperties(properties, context.mode);
     }
     CSSParserImpl parser(context, styleSheet);
-    parser.consumeDeclarationList(tokenRange, StyleRule::Style);
+    parser.consumeDeclarationList(tokenRange, StyleRuleType::Style);
     return createStyleProperties(parser.m_parsedProperties, context.mode);
 }
 
 void CSSParserImpl::parseDeferredRuleList(CSSParserTokenRange tokenRange, CSSDeferredParser& deferredParser, Vector<RefPtr<StyleRuleBase>>& childRules)
 {
@@ -199,15 +195,11 @@
 }
 
 bool CSSParserImpl::parseDeclarationList(MutableStyleProperties* declaration, const String& string, const CSSParserContext& context)
 {
     CSSParserImpl parser(context, string);
-    StyleRule::Type ruleType = StyleRule::Style;
-#if ENABLE(CSS_DEVICE_ADAPTATION)
-    if (declaration->cssParserMode() == CSSViewportRuleMode)
-        ruleType = StyleRule::Viewport;
-#endif
+    auto ruleType = context.enclosingRuleType.valueOr(StyleRuleType::Style);
     parser.consumeDeclarationList(parser.tokenizer()->tokenRange(), ruleType);
     if (parser.m_parsedProperties.isEmpty())
         return false;
 
     std::bitset<numCSSProperties> seenProperties;
@@ -304,23 +296,23 @@
 }
 
 bool CSSParserImpl::supportsDeclaration(CSSParserTokenRange& range)
 {
     ASSERT(m_parsedProperties.isEmpty());
-    consumeDeclaration(range, StyleRule::Style);
+    consumeDeclaration(range, StyleRuleType::Style);
     bool result = !m_parsedProperties.isEmpty();
     m_parsedProperties.clear();
     return result;
 }
 
 void CSSParserImpl::parseDeclarationListForInspector(const String& declaration, const CSSParserContext& context, CSSParserObserver& observer)
 {
     CSSParserObserverWrapper wrapper(observer);
     CSSParserImpl parser(context, declaration, nullptr, &wrapper);
-    observer.startRuleHeader(StyleRule::Style, 0);
+    observer.startRuleHeader(StyleRuleType::Style, 0);
     observer.endRuleHeader(1);
-    parser.consumeDeclarationList(parser.tokenizer()->tokenRange(), StyleRule::Style);
+    parser.consumeDeclarationList(parser.tokenizer()->tokenRange(), StyleRuleType::Style);
 }
 
 void CSSParserImpl::parseStyleSheetForInspector(const String& string, const CSSParserContext& context, StyleSheetContents* styleSheet, CSSParserObserver& observer)
 {
     CSSParserObserverWrapper wrapper(observer);
@@ -508,11 +500,11 @@
     if (uri.isNull())
         return nullptr; // Parse error, expected string or URI
 
     if (m_observerWrapper) {
         unsigned endOffset = m_observerWrapper->endOffset(prelude);
-        m_observerWrapper->observer().startRuleHeader(StyleRule::Import, m_observerWrapper->startOffset(prelude));
+        m_observerWrapper->observer().startRuleHeader(StyleRuleType::Import, m_observerWrapper->startOffset(prelude));
         m_observerWrapper->observer().endRuleHeader(endOffset);
         m_observerWrapper->observer().startRuleBody(endOffset);
         m_observerWrapper->observer().endRuleBody(endOffset);
     }
 
@@ -538,11 +530,11 @@
         return StyleRuleMedia::create(MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull(),  makeUnique<DeferredStyleGroupRuleList>(block, *m_deferredParser));
 
     Vector<RefPtr<StyleRuleBase>> rules;
 
     if (m_observerWrapper) {
-        m_observerWrapper->observer().startRuleHeader(StyleRule::Media, m_observerWrapper->startOffset(prelude));
+        m_observerWrapper->observer().startRuleHeader(StyleRuleType::Media, m_observerWrapper->startOffset(prelude));
         m_observerWrapper->observer().endRuleHeader(m_observerWrapper->endOffset(prelude));
         m_observerWrapper->observer().startRuleBody(m_observerWrapper->previousTokenStartOffset(block));
     }
 
     consumeRuleList(block, RegularRuleList, [&rules](RefPtr<StyleRuleBase> rule) {
@@ -564,11 +556,11 @@
 
     if (m_deferredParser)
         return StyleRuleSupports::create(prelude.serialize().stripWhiteSpace(), supported, makeUnique<DeferredStyleGroupRuleList>(block, *m_deferredParser));
 
     if (m_observerWrapper) {
-        m_observerWrapper->observer().startRuleHeader(StyleRule::Supports, m_observerWrapper->startOffset(prelude));
+        m_observerWrapper->observer().startRuleHeader(StyleRuleType::Supports, m_observerWrapper->startOffset(prelude));
         m_observerWrapper->observer().endRuleHeader(m_observerWrapper->endOffset(prelude));
         m_observerWrapper->observer().startRuleBody(m_observerWrapper->previousTokenStartOffset(block));
     }
 
     Vector<RefPtr<StyleRuleBase>> rules;
@@ -589,11 +581,11 @@
     if (!prelude.atEnd())
         return nullptr; // Parser error; @viewport prelude should be empty
 
     if (m_observerWrapper) {
         unsigned endOffset = m_observerWrapper->endOffset(prelude);
-        m_observerWrapper->observer().startRuleHeader(StyleRule::Viewport, m_observerWrapper->startOffset(prelude));
+        m_observerWrapper->observer().startRuleHeader(StyleRuleType::Viewport, m_observerWrapper->startOffset(prelude));
         m_observerWrapper->observer().endRuleHeader(endOffset);
         m_observerWrapper->observer().startRuleBody(endOffset);
         m_observerWrapper->observer().endRuleBody(endOffset);
     }
 
@@ -607,17 +599,17 @@
     if (!prelude.atEnd())
         return nullptr; // Parse error; @font-face prelude should be empty
 
     if (m_observerWrapper) {
         unsigned endOffset = m_observerWrapper->endOffset(prelude);
-        m_observerWrapper->observer().startRuleHeader(StyleRule::FontFace, m_observerWrapper->startOffset(prelude));
+        m_observerWrapper->observer().startRuleHeader(StyleRuleType::FontFace, m_observerWrapper->startOffset(prelude));
         m_observerWrapper->observer().endRuleHeader(endOffset);
         m_observerWrapper->observer().startRuleBody(endOffset);
         m_observerWrapper->observer().endRuleBody(endOffset);
     }
 
-    consumeDeclarationList(block, StyleRule::FontFace);
+    consumeDeclarationList(block, StyleRuleType::FontFace);
     return StyleRuleFontFace::create(createStyleProperties(m_parsedProperties, m_context.mode));
 }
 
 RefPtr<StyleRuleKeyframes> CSSParserImpl::consumeKeyframesRule(bool webkitPrefixed, CSSParserTokenRange prelude, CSSParserTokenRange block)
 {
@@ -636,11 +628,11 @@
 
     if (m_deferredParser)
         return StyleRuleKeyframes::create(name, makeUnique<DeferredStyleGroupRuleList>(block, *m_deferredParser));
 
     if (m_observerWrapper) {
-        m_observerWrapper->observer().startRuleHeader(StyleRule::Keyframes, m_observerWrapper->startOffset(rangeCopy));
+        m_observerWrapper->observer().startRuleHeader(StyleRuleType::Keyframes, m_observerWrapper->startOffset(rangeCopy));
         m_observerWrapper->observer().endRuleHeader(m_observerWrapper->endOffset(prelude));
         m_observerWrapper->observer().startRuleBody(m_observerWrapper->previousTokenStartOffset(block));
         m_observerWrapper->observer().endRuleBody(m_observerWrapper->endOffset(block));
     }
 
@@ -660,15 +652,15 @@
     if (!selectorList.isValid())
         return nullptr; // Parse error, invalid @page selector
 
     if (m_observerWrapper) {
         unsigned endOffset = m_observerWrapper->endOffset(prelude);
-        m_observerWrapper->observer().startRuleHeader(StyleRule::Page, m_observerWrapper->startOffset(prelude));
+        m_observerWrapper->observer().startRuleHeader(StyleRuleType::Page, m_observerWrapper->startOffset(prelude));
         m_observerWrapper->observer().endRuleHeader(endOffset);
     }
 
-    consumeDeclarationList(block, StyleRule::Style);
+    consumeDeclarationList(block, StyleRuleType::Style);
 
     return StyleRulePage::create(createStyleProperties(m_parsedProperties, m_context.mode), WTFMove(selectorList));
 }
 
 // FIXME-NEWPARSER: Support "apply"
@@ -688,24 +680,24 @@
     std::unique_ptr<Vector<double>> keyList = consumeKeyframeKeyList(prelude);
     if (!keyList)
         return nullptr;
 
     if (m_observerWrapper) {
-        m_observerWrapper->observer().startRuleHeader(StyleRule::Keyframe, m_observerWrapper->startOffset(prelude));
+        m_observerWrapper->observer().startRuleHeader(StyleRuleType::Keyframe, m_observerWrapper->startOffset(prelude));
         m_observerWrapper->observer().endRuleHeader(m_observerWrapper->endOffset(prelude));
     }
 
-    consumeDeclarationList(block, StyleRule::Keyframe);
+    consumeDeclarationList(block, StyleRuleType::Keyframe);
     return StyleRuleKeyframe::create(WTFMove(keyList), createStyleProperties(m_parsedProperties, m_context.mode));
 }
 
 static void observeSelectors(CSSParserObserverWrapper& wrapper, CSSParserTokenRange selectors)
 {
     // This is easier than hooking into the CSSSelectorParser
     selectors.consumeWhitespace();
     CSSParserTokenRange originalRange = selectors;
-    wrapper.observer().startRuleHeader(StyleRule::Style, wrapper.startOffset(originalRange));
+    wrapper.observer().startRuleHeader(StyleRuleType::Style, wrapper.startOffset(originalRange));
 
     while (!selectors.atEnd()) {
         const CSSParserToken* selectorStart = &selectors.peek();
         while (!selectors.atEnd() && selectors.peek().type() != CommaToken)
             selectors.consumeComponentValue();
@@ -737,19 +729,19 @@
         if (!blockCopy.atEnd()) {
             return StyleRule::create(createDeferredStyleProperties(block), m_context.hasDocumentSecurityOrigin, WTFMove(selectorList));
         }
     }
 
-    consumeDeclarationList(block, StyleRule::Style);
+    consumeDeclarationList(block, StyleRuleType::Style);
     return StyleRule::create(createStyleProperties(m_parsedProperties, m_context.mode), m_context.hasDocumentSecurityOrigin, WTFMove(selectorList));
 }
 
-void CSSParserImpl::consumeDeclarationList(CSSParserTokenRange range, StyleRule::Type ruleType)
+void CSSParserImpl::consumeDeclarationList(CSSParserTokenRange range, StyleRuleType ruleType)
 {
     ASSERT(m_parsedProperties.isEmpty());
 
-    bool useObserver = m_observerWrapper && (ruleType == StyleRule::Style || ruleType == StyleRule::Keyframe);
+    bool useObserver = m_observerWrapper && (ruleType == StyleRuleType::Style || ruleType == StyleRuleType::Keyframe);
     if (useObserver) {
         m_observerWrapper->observer().startRuleBody(m_observerWrapper->previousTokenStartOffset(range));
         m_observerWrapper->skipCommentsBefore(range, true);
     }
 
@@ -774,11 +766,11 @@
                 m_observerWrapper->skipCommentsBefore(range, false);
             break;
         }
         case AtKeywordToken: {
             // FIXME-NEWPARSER: Support apply
-            AllowedRulesType allowedRules = /* ruleType == StyleRule::Style && RuntimeEnabledFeatures::cssApplyAtRulesEnabled() ? ApplyRules :*/ NoRules;
+            AllowedRulesType allowedRules = /* ruleType == StyleRuleType::Style && RuntimeEnabledFeatures::cssApplyAtRulesEnabled() ? ApplyRules :*/ NoRules;
             RefPtr<StyleRuleBase> rule = consumeAtRule(range, allowedRules);
             ASSERT_UNUSED(rule, !rule);
             break;
         }
         default: // Parse error, unexpected token in declaration list
@@ -793,11 +785,11 @@
         m_observerWrapper->yieldCommentsBefore(range);
         m_observerWrapper->observer().endRuleBody(m_observerWrapper->endOffset(range));
     }
 }
 
-void CSSParserImpl::consumeDeclaration(CSSParserTokenRange range, StyleRule::Type ruleType)
+void CSSParserImpl::consumeDeclaration(CSSParserTokenRange range, StyleRuleType ruleType)
 {
     CSSParserTokenRange rangeCopy = range; // For inspector callbacks
 
     ASSERT(range.peek().type() == IdentToken);
     const CSSParserToken& token = range.consumeIncludingWhitespace();
@@ -824,17 +816,17 @@
     if (propertyID == CSSPropertyInvalid && CSSVariableParser::isValidVariableName(token)) {
         AtomString variableName = token.value().toAtomString();
         consumeCustomPropertyValue(range.makeSubRange(&range.peek(), declarationValueEnd), variableName, important);
     }
 
-    if (important && (ruleType == StyleRule::FontFace || ruleType == StyleRule::Keyframe))
+    if (important && (ruleType == StyleRuleType::FontFace || ruleType == StyleRuleType::Keyframe))
         return;
 
     if (propertyID != CSSPropertyInvalid)
         consumeDeclarationValue(range.makeSubRange(&range.peek(), declarationValueEnd), propertyID, important, ruleType);
 
-    if (m_observerWrapper && (ruleType == StyleRule::Style || ruleType == StyleRule::Keyframe)) {
+    if (m_observerWrapper && (ruleType == StyleRuleType::Style || ruleType == StyleRuleType::Keyframe)) {
         m_observerWrapper->observer().observeProperty(
             m_observerWrapper->startOffset(rangeCopy), m_observerWrapper->endOffset(rangeCopy),
             important, m_parsedProperties.size() != propertiesCount);
     }
 }
@@ -843,11 +835,11 @@
 {
     if (RefPtr<CSSCustomPropertyValue> value = CSSVariableParser::parseDeclarationValue(variableName, range, m_context))
         m_parsedProperties.append(CSSProperty(CSSPropertyCustom, WTFMove(value), important));
 }
 
-void CSSParserImpl::consumeDeclarationValue(CSSParserTokenRange range, CSSPropertyID propertyID, bool important, StyleRule::Type ruleType)
+void CSSParserImpl::consumeDeclarationValue(CSSParserTokenRange range, CSSPropertyID propertyID, bool important, StyleRuleType ruleType)
 {
     CSSPropertyParser::parseValue(propertyID, important, range, m_context, m_parsedProperties, ruleType);
 }
 
 std::unique_ptr<Vector<double>> CSSParserImpl::consumeKeyframeKeyList(CSSParserTokenRange range)

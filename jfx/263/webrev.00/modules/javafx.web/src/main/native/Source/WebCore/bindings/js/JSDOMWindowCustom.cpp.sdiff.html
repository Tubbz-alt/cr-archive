<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowCustom.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMWindowBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMWindowCustom.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowCustom.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;JSDOMWindowCustom.h&quot;
 23 
 24 #include &quot;DOMWindowIndexedDatabase.h&quot;
 25 #include &quot;DOMWindowWebDatabase.h&quot;
 26 #include &quot;Frame.h&quot;
 27 #include &quot;HTMLCollection.h&quot;
 28 #include &quot;HTMLDocument.h&quot;
 29 #include &quot;HTMLFrameOwnerElement.h&quot;
 30 #include &quot;HTTPParsers.h&quot;
 31 #include &quot;JSDOMBindingSecurity.h&quot;

 32 #include &quot;JSDOMConvertNullable.h&quot;
 33 #include &quot;JSDOMConvertNumbers.h&quot;
 34 #include &quot;JSDOMConvertStrings.h&quot;
 35 #include &quot;JSDatabase.h&quot;
 36 #include &quot;JSDatabaseCallback.h&quot;
 37 #include &quot;JSEvent.h&quot;
 38 #include &quot;JSEventListener.h&quot;
 39 #include &quot;JSHTMLAudioElement.h&quot;
 40 #include &quot;JSHTMLCollection.h&quot;
 41 #include &quot;JSHTMLOptionElement.h&quot;
 42 #include &quot;JSIDBFactory.h&quot;
 43 #include &quot;JSRemoteDOMWindow.h&quot;
 44 #include &quot;JSWindowProxy.h&quot;
 45 #include &quot;JSWorker.h&quot;
 46 #include &quot;Location.h&quot;
 47 #include &quot;RuntimeEnabledFeatures.h&quot;
 48 #include &quot;ScheduledAction.h&quot;
 49 #include &quot;Settings.h&quot;
 50 #include &quot;WebCoreJSClientData.h&quot;
 51 #include &lt;JavaScriptCore/BuiltinNames.h&gt;
 52 #include &lt;JavaScriptCore/HeapAnalyzer.h&gt;
 53 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 54 #include &lt;JavaScriptCore/JSFunction.h&gt;
 55 #include &lt;JavaScriptCore/JSMicrotask.h&gt;
 56 #include &lt;JavaScriptCore/Lookup.h&gt;
 57 #include &lt;JavaScriptCore/Structure.h&gt;
 58 
 59 #if ENABLE(USER_MESSAGE_HANDLERS)
 60 #include &quot;JSWebKitNamespace.h&quot;
 61 #endif
 62 
 63 
 64 namespace WebCore {
 65 using namespace JSC;
 66 
<span class="line-modified"> 67 EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionShowModalDialog(ExecState*);</span>
<span class="line-modified"> 68 EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionOpenDatabase(ExecState*);</span>
 69 
 70 void JSDOMWindow::visitAdditionalChildren(SlotVisitor&amp; visitor)
 71 {
 72     if (Frame* frame = wrapped().frame())
 73         visitor.addOpaqueRoot(frame);
 74 
 75     visitor.addOpaqueRoot(&amp;wrapped());
 76 
 77     // Normally JSEventTargetCustom.cpp&#39;s JSEventTarget::visitAdditionalChildren() would call this. But
 78     // even though DOMWindow is an EventTarget, JSDOMWindow does not subclass JSEventTarget, so we need
 79     // to do this here.
 80     wrapped().visitJSEventListeners(visitor);
 81 }
 82 
 83 #if ENABLE(USER_MESSAGE_HANDLERS)
<span class="line-modified"> 84 static EncodedJSValue jsDOMWindowWebKit(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 85 {
<span class="line-modified"> 86     VM&amp; vm = exec-&gt;vm();</span>
 87     JSDOMWindow* castedThis = toJSDOMWindow(vm, JSValue::decode(thisValue));
<span class="line-modified"> 88     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, castedThis-&gt;wrapped()))</span>
 89         return JSValue::encode(jsUndefined());
<span class="line-modified"> 90     return JSValue::encode(toJS(exec, castedThis-&gt;globalObject(), castedThis-&gt;wrapped().webkitNamespace()));</span>
 91 }
 92 #endif
 93 
 94 template &lt;DOMWindowType windowType&gt;
<span class="line-modified"> 95 bool jsDOMWindowGetOwnPropertySlotRestrictedAccess(JSDOMGlobalObject* thisObject, AbstractDOMWindow&amp; window, ExecState&amp; state, PropertyName propertyName, PropertySlot&amp; slot, const String&amp; errorMessage)</span>
 96 {
<span class="line-modified"> 97     VM&amp; vm = state.vm();</span>
 98     auto scope = DECLARE_THROW_SCOPE(vm);
 99 
100     auto&amp; builtinNames = static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames();
101 
102     // https://html.spec.whatwg.org/#crossorigingetownpropertyhelper-(-o,-p-)
103 
104     // These are the functions we allow access to cross-origin (DoNotCheckSecurity in IDL).
105     // Always provide the original function, on a fresh uncached function object.
106     if (propertyName == builtinNames.blurPublicName()) {
107         slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum), windowType == DOMWindowType::Remote ? nonCachingStaticFunctionGetter&lt;jsRemoteDOMWindowInstanceFunctionBlur, 0&gt; : nonCachingStaticFunctionGetter&lt;jsDOMWindowInstanceFunctionBlur, 0&gt;);
108         return true;
109     }
110     if (propertyName == builtinNames.closePublicName()) {
111         slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum), windowType == DOMWindowType::Remote ? nonCachingStaticFunctionGetter&lt;jsRemoteDOMWindowInstanceFunctionClose, 0&gt; : nonCachingStaticFunctionGetter&lt;jsDOMWindowInstanceFunctionClose, 0&gt;);
112         return true;
113     }
114     if (propertyName == builtinNames.focusPublicName()) {
115         slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum), windowType == DOMWindowType::Remote ? nonCachingStaticFunctionGetter&lt;jsRemoteDOMWindowInstanceFunctionFocus, 0&gt; : nonCachingStaticFunctionGetter&lt;jsDOMWindowInstanceFunctionFocus, 0&gt;);
116         return true;
117     }
</pre>
<hr />
<pre>
123     // When accessing cross-origin known Window properties, we always use the original property getter,
124     // even if the property was removed / redefined. As of early 2016, this matches Firefox and Chrome&#39;s
125     // behavior.
126     auto* classInfo = windowType == DOMWindowType::Remote ? JSRemoteDOMWindow::info() : JSDOMWindow::info();
127     if (auto* entry = classInfo-&gt;staticPropHashTable-&gt;entry(propertyName)) {
128         // Only allow access to these specific properties.
129         if (propertyName == builtinNames.locationPublicName()
130             || propertyName == builtinNames.closedPublicName()
131             || propertyName == vm.propertyNames-&gt;length
132             || propertyName == builtinNames.selfPublicName()
133             || propertyName == builtinNames.windowPublicName()
134             || propertyName == builtinNames.framesPublicName()
135             || propertyName == builtinNames.openerPublicName()
136             || propertyName == builtinNames.parentPublicName()
137             || propertyName == builtinNames.topPublicName()) {
138             bool shouldExposeSetter = propertyName == builtinNames.locationPublicName();
139             CustomGetterSetter* customGetterSetter = CustomGetterSetter::create(vm, entry-&gt;propertyGetter(), shouldExposeSetter ? entry-&gt;propertyPutter() : nullptr);
140             slot.setCustomGetterSetter(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DontEnum), customGetterSetter);
141             return true;
142         }
<span class="line-removed">143 </span>
<span class="line-removed">144         // For any other entries in the static property table, deny access. (Early return also prevents</span>
<span class="line-removed">145         // named getter from returning frames with matching names - this seems a little questionable, see</span>
<span class="line-removed">146         // FIXME comment on prototype search below.)</span>
<span class="line-removed">147         throwSecurityError(state, scope, errorMessage);</span>
<span class="line-removed">148         slot.setUndefined();</span>
<span class="line-removed">149         return false;</span>
150     }
151 
152     // Check for child frames by name before built-in properties to match Mozilla. This does
153     // not match IE, but some sites end up naming frames things that conflict with window
154     // properties that are in Moz but not IE. Since we have some of these, we have to do it
155     // the Moz way.
156     // FIXME: Add support to named attributes on RemoteFrames.
157     auto* frame = window.frame();
158     if (frame &amp;&amp; is&lt;Frame&gt;(*frame)) {
159         if (auto* scopedChild = downcast&lt;Frame&gt;(*frame).tree().scopedChild(propertyNameToAtomString(propertyName))) {
<span class="line-modified">160             slot.setValue(thisObject, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum, toJS(&amp;state, scopedChild-&gt;document()-&gt;domWindow()));</span>
161             return true;
162         }
163     }
164 
165     if (handleCommonCrossOriginProperties(thisObject, vm, propertyName, slot))
166         return true;
167 
<span class="line-modified">168     throwSecurityError(state, scope, errorMessage);</span>
169     slot.setUndefined();
170     return false;
171 }
<span class="line-modified">172 template bool jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(JSDOMGlobalObject*, AbstractDOMWindow&amp;, ExecState&amp;, PropertyName, PropertySlot&amp;, const String&amp;);</span>
<span class="line-modified">173 template bool jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Remote&gt;(JSDOMGlobalObject*, AbstractDOMWindow&amp;, ExecState&amp;, PropertyName, PropertySlot&amp;, const String&amp;);</span>
174 
175 // https://html.spec.whatwg.org/#crossorigingetownpropertyhelper-(-o,-p-)
176 bool handleCommonCrossOriginProperties(JSObject* thisObject, VM&amp; vm, PropertyName propertyName, PropertySlot&amp; slot)
177 {
178     auto&amp; propertyNames =  vm.propertyNames;
179     if (propertyName == propertyNames-&gt;builtinNames().thenPublicName() || propertyName == propertyNames-&gt;toStringTagSymbol || propertyName == propertyNames-&gt;hasInstanceSymbol || propertyName == propertyNames-&gt;isConcatSpreadableSymbol) {
180         slot.setValue(thisObject, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum, jsUndefined());
181         return true;
182     }
183     return false;
184 }
185 
186 // Property access sequence is:
187 // (1) indexed properties,
188 // (2) regular own properties,
189 // (3) named properties (in fact, these shouldn&#39;t be on the window, should be on the NPO).
<span class="line-modified">190 bool JSDOMWindow::getOwnPropertySlot(JSObject* object, ExecState* state, PropertyName propertyName, PropertySlot&amp; slot)</span>
191 {
192     // (1) First, indexed properties.
193     // Hand off all indexed access to getOwnPropertySlotByIndex, which supports the indexed getter.
194     if (Optional&lt;unsigned&gt; index = parseIndex(propertyName))
<span class="line-modified">195         return getOwnPropertySlotByIndex(object, state, index.value(), slot);</span>
196 
197     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
198 
199     // Hand off all cross-domain access to jsDOMWindowGetOwnPropertySlotRestrictedAccess.
200     String errorMessage;
<span class="line-modified">201     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*state, thisObject-&gt;wrapped(), errorMessage))</span>
<span class="line-modified">202         return jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(thisObject, thisObject-&gt;wrapped(), *state, propertyName, slot, errorMessage);</span>
203 
204     // FIXME: this needs more explanation.
205     // (Particularly, is it correct that this exists here but not in getOwnPropertySlotByIndex?)
206     slot.setWatchpointSet(thisObject-&gt;m_windowCloseWatchpoints);
207 
208     // (2) Regular own properties.
209     PropertySlot slotCopy = slot;
<span class="line-modified">210     if (Base::getOwnPropertySlot(thisObject, state, propertyName, slot)) {</span>
211         auto* frame = thisObject-&gt;wrapped().frame();
212 
213         // Detect when we&#39;re getting the property &#39;showModalDialog&#39;, this is disabled, and has its original value.
<span class="line-modified">214         bool isShowModalDialogAndShouldHide = propertyName == static_cast&lt;JSVMClientData*&gt;(state-&gt;vm().clientData)-&gt;builtinNames().showModalDialogPublicName()</span>
215             &amp;&amp; (!frame || !DOMWindow::canShowModalDialog(*frame))
<span class="line-modified">216             &amp;&amp; slot.isValue() &amp;&amp; isHostFunction(slot.getValue(state, propertyName), jsDOMWindowInstanceFunctionShowModalDialog);</span>
217         // Unless we&#39;re in the showModalDialog special case, we&#39;re done.
218         if (!isShowModalDialogAndShouldHide)
219             return true;
220         slot = slotCopy;
221     }
222 
223 #if ENABLE(USER_MESSAGE_HANDLERS)
<span class="line-modified">224     if (propertyName == static_cast&lt;JSVMClientData*&gt;(state-&gt;vm().clientData)-&gt;builtinNames().webkitPublicName() &amp;&amp; thisObject-&gt;wrapped().shouldHaveWebKitNamespaceForWorld(thisObject-&gt;world())) {</span>
225         slot.setCacheableCustom(thisObject, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly, jsDOMWindowWebKit);
226         return true;
227     }
228 #endif
229 
230     return false;
231 }
232 
233 // Property access sequence is:
234 // (1) indexed properties,
235 // (2) regular own properties,
236 // (3) named properties (in fact, these shouldn&#39;t be on the window, should be on the NPO).
<span class="line-modified">237 bool JSDOMWindow::getOwnPropertySlotByIndex(JSObject* object, ExecState* state, unsigned index, PropertySlot&amp; slot)</span>
238 {
<span class="line-modified">239     VM&amp; vm = state-&gt;vm();</span>
240     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
241     auto&amp; window = thisObject-&gt;wrapped();
242     auto* frame = window.frame();
243 
244     // Indexed getters take precendence over regular properties, so caching would be invalid.
245     slot.disableCaching();
246 
247     String errorMessage;
248     Optional&lt;bool&gt; cachedIsCrossOriginAccess;
249     auto isCrossOriginAccess = [&amp;] {
250         if (!cachedIsCrossOriginAccess)
<span class="line-modified">251             cachedIsCrossOriginAccess = !BindingSecurity::shouldAllowAccessToDOMWindow(*state, window, errorMessage);</span>
252         return *cachedIsCrossOriginAccess;
253     };
254 
255     // (1) First, indexed properties.
256     // These are also allowed cross-origin, so come before the access check.
257     if (frame &amp;&amp; index &lt; frame-&gt;tree().scopedChildCount()) {
<span class="line-modified">258         slot.setValue(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::ReadOnly), toJS(state, frame-&gt;tree().scopedChild(index)-&gt;document()-&gt;domWindow()));</span>
259         return true;
260     }
261 
262     // Hand off all cross-domain/frameless access to jsDOMWindowGetOwnPropertySlotRestrictedAccess.
263     if (isCrossOriginAccess())
<span class="line-modified">264         return jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(thisObject, window, *state, Identifier::from(vm, index), slot, errorMessage);</span>
265 
266     // (2) Regular own properties.
<span class="line-modified">267     return Base::getOwnPropertySlotByIndex(thisObject, state, index, slot);</span>
268 }
269 
<span class="line-modified">270 void JSDOMWindow::doPutPropertySecurityCheck(JSObject* cell, ExecState* state, PropertyName propertyName, PutPropertySlot&amp;)</span>
271 {
<span class="line-modified">272     VM&amp; vm = state-&gt;vm();</span>
273     auto scope = DECLARE_THROW_SCOPE(vm);
274 
275     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
276     if (!thisObject-&gt;wrapped().frame())
277         return;
278 
279     String errorMessage;
<span class="line-modified">280     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*state, thisObject-&gt;wrapped(), errorMessage)) {</span>
281         // We only allow setting &quot;location&quot; attribute cross-origin.
282         if (propertyName == static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().locationPublicName())
283             return;
<span class="line-modified">284         throwSecurityError(*state, scope, errorMessage);</span>
285         return;
286     }
287 }
288 
<span class="line-modified">289 bool JSDOMWindow::put(JSCell* cell, ExecState* state, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
290 {
<span class="line-modified">291     VM&amp; vm = state-&gt;vm();</span>
292     auto scope = DECLARE_THROW_SCOPE(vm);
293 
294     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
295     if (!thisObject-&gt;wrapped().frame())
296         return false;
297 
298     String errorMessage;
<span class="line-modified">299     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*state, thisObject-&gt;wrapped(), errorMessage)) {</span>
300         // We only allow setting &quot;location&quot; attribute cross-origin.
301         if (propertyName == static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().locationPublicName()) {
302             bool putResult = false;
<span class="line-modified">303             if (lookupPut(state, propertyName, thisObject, value, *s_info.staticPropHashTable, slot, putResult))</span>
304                 return putResult;
305             return false;
306         }
<span class="line-modified">307         throwSecurityError(*state, scope, errorMessage);</span>
308         return false;
309     }
310 
<span class="line-modified">311     return Base::put(thisObject, state, propertyName, value, slot);</span>
312 }
313 
<span class="line-modified">314 bool JSDOMWindow::putByIndex(JSCell* cell, ExecState* exec, unsigned index, JSValue value, bool shouldThrow)</span>
315 {
316     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
<span class="line-modified">317     if (!thisObject-&gt;wrapped().frame() || !BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped()))</span>
318         return false;
319 
<span class="line-modified">320     return Base::putByIndex(thisObject, exec, index, value, shouldThrow);</span>
321 }
322 
<span class="line-modified">323 bool JSDOMWindow::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
324 {
325     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
326     // Only allow deleting properties by frames in the same origin.
<span class="line-modified">327     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), ThrowSecurityError))</span>
328         return false;
<span class="line-modified">329     return Base::deleteProperty(thisObject, exec, propertyName);</span>
330 }
331 
<span class="line-modified">332 bool JSDOMWindow::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned propertyName)</span>
333 {
334     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
335     // Only allow deleting properties by frames in the same origin.
<span class="line-modified">336     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), ThrowSecurityError))</span>
337         return false;
<span class="line-modified">338     return Base::deletePropertyByIndex(thisObject, exec, propertyName);</span>
339 }
340 
341 void JSDOMWindow::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)
342 {
343     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
344     auto&amp; location = thisObject-&gt;wrapped().location();
345     analyzer.setLabelForCell(cell, location.href());
346 
347     Base::analyzeHeap(cell, analyzer);
348 }
349 
350 // https://html.spec.whatwg.org/#crossoriginproperties-(-o-)
351 template &lt;CrossOriginObject objectType&gt;
352 static void addCrossOriginPropertyNames(VM&amp; vm, PropertyNameArray&amp; propertyNames)
353 {
354     auto&amp; builtinNames = static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames();
355     switch (objectType) {
356     case CrossOriginObject::Location: {
357         static const Identifier* const properties[] = { &amp;builtinNames.hrefPublicName(), &amp;vm.propertyNames-&gt;replace };
358         for (auto* property : properties)
</pre>
<hr />
<pre>
360         break;
361     }
362     case CrossOriginObject::Window: {
363         static const Identifier* const properties[] = {
364             &amp;builtinNames.blurPublicName(), &amp;builtinNames.closePublicName(), &amp;builtinNames.closedPublicName(),
365             &amp;builtinNames.focusPublicName(), &amp;builtinNames.framesPublicName(), &amp;vm.propertyNames-&gt;length,
366             &amp;builtinNames.locationPublicName(), &amp;builtinNames.openerPublicName(), &amp;builtinNames.parentPublicName(),
367             &amp;builtinNames.postMessagePublicName(), &amp;builtinNames.selfPublicName(), &amp;builtinNames.topPublicName(),
368             &amp;builtinNames.windowPublicName()
369         };
370 
371         for (auto* property : properties)
372             propertyNames.add(*property);
373         break;
374     }
375     }
376 }
377 
378 // https://html.spec.whatwg.org/#crossoriginownpropertykeys-(-o-)
379 template &lt;CrossOriginObject objectType&gt;
<span class="line-modified">380 void addCrossOriginOwnPropertyNames(JSC::ExecState&amp; state, JSC::PropertyNameArray&amp; propertyNames)</span>
381 {
<span class="line-modified">382     auto&amp; vm = state.vm();</span>
383     addCrossOriginPropertyNames&lt;objectType&gt;(vm, propertyNames);
384 
385     static const Identifier* const properties[] = {
386         &amp;vm.propertyNames-&gt;builtinNames().thenPublicName(), &amp;vm.propertyNames-&gt;toStringTagSymbol, &amp;vm.propertyNames-&gt;hasInstanceSymbol, &amp;vm.propertyNames-&gt;isConcatSpreadableSymbol
387     };
388 
389     for (auto* property : properties)
390         propertyNames.add(*property);
391 
392 }
<span class="line-modified">393 template void addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Window&gt;(JSC::ExecState&amp;, JSC::PropertyNameArray&amp;);</span>
<span class="line-modified">394 template void addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Location&gt;(JSC::ExecState&amp;, JSC::PropertyNameArray&amp;);</span>
395 
<span class="line-modified">396 static void addScopedChildrenIndexes(ExecState&amp; state, DOMWindow&amp; window, PropertyNameArray&amp; propertyNames)</span>
397 {
398     auto* document = window.document();
399     if (!document)
400         return;
401 
402     auto* frame = document-&gt;frame();
403     if (!frame)
404         return;
405 
<span class="line-modified">406     VM&amp; vm = state.vm();</span>
407     unsigned scopedChildCount = frame-&gt;tree().scopedChildCount();
408     for (unsigned i = 0; i &lt; scopedChildCount; ++i)
409         propertyNames.add(Identifier::from(vm, i));
410 }
411 
412 // https://html.spec.whatwg.org/#windowproxy-ownpropertykeys
<span class="line-modified">413 void JSDOMWindow::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
414 {
415     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
416 
<span class="line-modified">417     addScopedChildrenIndexes(*exec, thisObject-&gt;wrapped(), propertyNames);</span>
418 
<span class="line-modified">419     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), DoNotReportSecurityError)) {</span>
420         if (mode.includeDontEnumProperties())
<span class="line-modified">421             addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Window&gt;(*exec, propertyNames);</span>
422         return;
423     }
<span class="line-modified">424     Base::getOwnPropertyNames(thisObject, exec, propertyNames, mode);</span>
425 }
426 
<span class="line-modified">427 bool JSDOMWindow::defineOwnProperty(JSC::JSObject* object, JSC::ExecState* exec, JSC::PropertyName propertyName, const JSC::PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
428 {
<span class="line-modified">429     JSC::VM&amp; vm = exec-&gt;vm();</span>
430     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
431     // Only allow defining properties in this way by frames in the same origin, as it allows setters to be introduced.
<span class="line-modified">432     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), ThrowSecurityError))</span>
433         return false;
434 
435     // Don&#39;t allow shadowing location using accessor properties.
436     if (descriptor.isAccessorDescriptor() &amp;&amp; propertyName == Identifier::fromString(vm, &quot;location&quot;))
437         return false;
438 
<span class="line-modified">439     return Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);</span>
440 }
441 
<span class="line-modified">442 JSValue JSDOMWindow::getPrototype(JSObject* object, ExecState* exec)</span>
443 {
444     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
<span class="line-modified">445     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), DoNotReportSecurityError))</span>
446         return jsNull();
447 
<span class="line-modified">448     return Base::getPrototype(object, exec);</span>
449 }
450 
<span class="line-modified">451 bool JSDOMWindow::preventExtensions(JSObject*, ExecState* exec)</span>
452 {
<span class="line-modified">453     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
454 
<span class="line-modified">455     throwTypeError(exec, scope, &quot;Cannot prevent extensions on this object&quot;_s);</span>
456     return false;
457 }
458 
<span class="line-modified">459 String JSDOMWindow::toStringName(const JSObject* object, ExecState* exec)</span>
460 {
461     auto* thisObject = jsCast&lt;const JSDOMWindow*&gt;(object);
<span class="line-modified">462     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), DoNotReportSecurityError))</span>
463         return &quot;Object&quot;_s;
464     return &quot;Window&quot;_s;
465 }
466 
467 // Custom Attributes
468 
<span class="line-modified">469 JSValue JSDOMWindow::event(ExecState&amp; state) const</span>
470 {
471     Event* event = currentEvent();
472     if (!event)
473         return jsUndefined();
<span class="line-modified">474     return toJS(&amp;state, const_cast&lt;JSDOMWindow*&gt;(this), event);</span>
475 }
476 
477 // Custom functions
478 
479 class DialogHandler {
480 public:
<span class="line-modified">481     explicit DialogHandler(ExecState&amp; exec)</span>
<span class="line-modified">482         : m_exec(exec)</span>

483     {
484     }
485 
486     void dialogCreated(DOMWindow&amp;);
487     JSValue returnValue() const;
488 
489 private:
<span class="line-modified">490     ExecState&amp; m_exec;</span>

491     RefPtr&lt;Frame&gt; m_frame;
492 };
493 
494 inline void DialogHandler::dialogCreated(DOMWindow&amp; dialog)
495 {
<span class="line-modified">496     VM&amp; vm = m_exec.vm();</span>
497     m_frame = dialog.frame();
498 
499     // FIXME: This looks like a leak between the normal world and an isolated
500     //        world if dialogArguments comes from an isolated world.
501     JSDOMWindow* globalObject = toJSDOMWindow(m_frame.get(), normalWorld(vm));
<span class="line-modified">502     if (JSValue dialogArguments = m_exec.argument(1))</span>
503         globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;dialogArguments&quot;), dialogArguments);
504 }
505 
506 inline JSValue DialogHandler::returnValue() const
507 {
<span class="line-modified">508     VM&amp; vm = m_exec.vm();</span>
509     JSDOMWindow* globalObject = toJSDOMWindow(m_frame.get(), normalWorld(vm));
510     if (!globalObject)
511         return jsUndefined();
512     Identifier identifier = Identifier::fromString(vm, &quot;returnValue&quot;);
513     PropertySlot slot(globalObject, PropertySlot::InternalMethodType::Get);
<span class="line-modified">514     if (!JSGlobalObject::getOwnPropertySlot(globalObject, &amp;m_exec, identifier, slot))</span>
515         return jsUndefined();
<span class="line-modified">516     return slot.getValue(&amp;m_exec, identifier);</span>
517 }
518 
<span class="line-modified">519 JSValue JSDOMWindow::showModalDialog(ExecState&amp; state)</span>
520 {
<span class="line-modified">521     VM&amp; vm = state.vm();</span>
522     auto scope = DECLARE_THROW_SCOPE(vm);
523 
<span class="line-modified">524     if (UNLIKELY(state.argumentCount() &lt; 1))</span>
<span class="line-modified">525         return throwException(&amp;state, scope, createNotEnoughArgumentsError(&amp;state));</span>
526 
<span class="line-modified">527     String urlString = convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(state, state.argument(0));</span>
528     RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">529     String dialogFeaturesString = convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(state, state.argument(2));</span>
530     RETURN_IF_EXCEPTION(scope, JSValue());
531 
<span class="line-modified">532     DialogHandler handler(state);</span>
533 
<span class="line-modified">534     wrapped().showModalDialog(urlString, dialogFeaturesString, activeDOMWindow(state), firstDOMWindow(state), [&amp;handler](DOMWindow&amp; dialog) {</span>
535         handler.dialogCreated(dialog);
536     });
537 
538     return handler.returnValue();
539 }
540 
<span class="line-modified">541 JSValue JSDOMWindow::queueMicrotask(ExecState&amp; state)</span>
542 {
<span class="line-modified">543     VM&amp; vm = state.vm();</span>
544     auto scope = DECLARE_THROW_SCOPE(vm);
545 
<span class="line-modified">546     if (UNLIKELY(state.argumentCount() &lt; 1))</span>
<span class="line-modified">547         return throwException(&amp;state, scope, createNotEnoughArgumentsError(&amp;state));</span>
548 
<span class="line-modified">549     JSValue functionValue = state.uncheckedArgument(0);</span>
550     if (UNLIKELY(!functionValue.isFunction(vm)))
<span class="line-modified">551         return JSValue::decode(throwArgumentMustBeFunctionError(state, scope, 0, &quot;callback&quot;, &quot;Window&quot;, &quot;queueMicrotask&quot;));</span>
552 
553     scope.release();
554     Base::queueMicrotask(JSC::createJSMicrotask(vm, functionValue));
555     return jsUndefined();
556 }
557 
558 DOMWindow* JSDOMWindow::toWrapped(VM&amp; vm, JSValue value)
559 {
560     if (!value.isObject())
561         return nullptr;
562     JSObject* object = asObject(value);
563     if (object-&gt;inherits&lt;JSDOMWindow&gt;(vm))
564         return &amp;jsCast&lt;JSDOMWindow*&gt;(object)-&gt;wrapped();
565     if (object-&gt;inherits&lt;JSWindowProxy&gt;(vm)) {
566         if (auto* jsDOMWindow = jsDynamicCast&lt;JSDOMWindow*&gt;(vm, jsCast&lt;JSWindowProxy*&gt;(object)-&gt;window()))
567             return &amp;jsDOMWindow-&gt;wrapped();
568     }
569     return nullptr;
570 }
571 
<span class="line-modified">572 void JSDOMWindow::setOpener(JSC::ExecState&amp; state, JSC::JSValue value)</span>
573 {
<span class="line-modified">574     if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, wrapped(), ThrowSecurityError))</span>
575         return;
576 
577     if (value.isNull()) {
578         wrapped().disownOpener();
579         return;
580     }
<span class="line-modified">581     VM&amp; vm = state.vm();</span>
582     replaceStaticPropertySlot(vm, this, Identifier::fromString(vm, &quot;opener&quot;), value);
583 }
584 
<span class="line-modified">585 JSValue JSDOMWindow::self(JSC::ExecState&amp;) const</span>
586 {
587     return globalThis();
588 }
589 
<span class="line-modified">590 JSValue JSDOMWindow::window(JSC::ExecState&amp;) const</span>
591 {
592     return globalThis();
593 }
594 
<span class="line-modified">595 JSValue JSDOMWindow::frames(JSC::ExecState&amp;) const</span>
596 {
597     return globalThis();
598 }
599 
<span class="line-modified">600 static inline JSC::EncodedJSValue jsDOMWindowInstanceFunctionOpenDatabaseBody(JSC::ExecState* state, typename IDLOperation&lt;JSDOMWindow&gt;::ClassParameter castedThis, JSC::ThrowScope&amp; throwScope)</span>
601 {
<span class="line-modified">602     if (!BindingSecurity::shouldAllowAccessToDOMWindow(state, castedThis-&gt;wrapped(), ThrowSecurityError))</span>
603         return JSValue::encode(jsUndefined());
604     auto&amp; impl = castedThis-&gt;wrapped();
<span class="line-modified">605     if (UNLIKELY(state-&gt;argumentCount() &lt; 4))</span>
<span class="line-modified">606         return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));</span>
<span class="line-modified">607     auto name = convert&lt;IDLDOMString&gt;(*state, state-&gt;uncheckedArgument(0));</span>
608     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">609     auto version = convert&lt;IDLDOMString&gt;(*state, state-&gt;uncheckedArgument(1));</span>
610     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">611     auto displayName = convert&lt;IDLDOMString&gt;(*state, state-&gt;uncheckedArgument(2));</span>
612     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">613     auto estimatedSize = convert&lt;IDLUnsignedLong&gt;(*state, state-&gt;uncheckedArgument(3));</span>
614     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
615 
616     if (!RuntimeEnabledFeatures::sharedFeatures().webSQLEnabled()) {
617         if (name != &quot;null&quot; || version != &quot;null&quot; || displayName != &quot;null&quot; || estimatedSize)
<span class="line-modified">618             propagateException(*state, throwScope, Exception(UnknownError, &quot;Web SQL is deprecated&quot;_s));</span>
<span class="line-modified">619         return JSValue::encode(constructEmptyObject(state, castedThis-&gt;globalObject()-&gt;objectPrototype()));</span>
620     }
621 
<span class="line-modified">622     auto creationCallback = convert&lt;IDLNullable&lt;IDLCallbackFunction&lt;JSDatabaseCallback&gt;&gt;&gt;(*state, state-&gt;argument(4), *castedThis-&gt;globalObject(), [](JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope) {</span>
<span class="line-modified">623         throwArgumentMustBeFunctionError(state, scope, 4, &quot;creationCallback&quot;, &quot;Window&quot;, &quot;openDatabase&quot;);</span>
624     });
625     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">626     return JSValue::encode(toJS&lt;IDLNullable&lt;IDLInterface&lt;Database&gt;&gt;&gt;(*state, *castedThis-&gt;globalObject(), throwScope, WebCore::DOMWindowWebDatabase::openDatabase(impl, WTFMove(name), WTFMove(version), WTFMove(displayName), WTFMove(estimatedSize), WTFMove(creationCallback))));</span>
627 }
628 
<span class="line-modified">629 template&lt;&gt; inline JSDOMWindow* IDLOperation&lt;JSDOMWindow&gt;::cast(ExecState&amp; state)</span>
630 {
<span class="line-modified">631     return toJSDOMWindow(state.vm(), state.thisValue().toThis(&amp;state, NotStrictMode));</span>
632 }
633 
<span class="line-modified">634 EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionOpenDatabase(JSGlobalObject*, CallFrame* callFrame)</span>
635 {
<span class="line-modified">636     return IDLOperation&lt;JSDOMWindow&gt;::call&lt;jsDOMWindowInstanceFunctionOpenDatabaseBody&gt;(*callFrame, &quot;openDatabase&quot;);</span>
637 }
638 
<span class="line-modified">639 // // FIXME-java: Currently WebSQL feature is not implemented completely in JavaFX port.</span>
<span class="line-modified">640 // #if !PLATFORM(JAVA)</span>
<span class="line-modified">641 // JSValue JSDOMWindow::openDatabase(JSC::ExecState&amp; state) const</span>
<span class="line-modified">642 // {</span>
<span class="line-modified">643 //     VM&amp; vm = state.vm();</span>
<span class="line-modified">644 //     StringImpl* name = PropertyName(static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().openDatabasePublicName()).publicName();</span>
<span class="line-modified">645 //     if (RuntimeEnabledFeatures::sharedFeatures().webSQLEnabled())</span>
<span class="line-modified">646 //         return JSFunction::create(vm, state.lexicalGlobalObject(), 4, name, jsDOMWindowInstanceFunctionOpenDatabase, NoIntrinsic);</span>
647 
<span class="line-modified">648 //     return JSFunction::createFunctionThatMasqueradesAsUndefined(vm, state.lexicalGlobalObject(), 4, name, jsDOMWindowInstanceFunctionOpenDatabase, NoIntrinsic);</span>
<span class="line-modified">649 // }</span>
650 
<span class="line-modified">651 // void JSDOMWindow::setOpenDatabase(JSC::ExecState&amp; state, JSC::JSValue value)</span>
<span class="line-modified">652 // {</span>
<span class="line-modified">653 //     if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, wrapped(), ThrowSecurityError))</span>
<span class="line-modified">654 //         return;</span>
655 
<span class="line-modified">656 //     VM&amp; vm = state.vm();</span>
<span class="line-modified">657 //     replaceStaticPropertySlot(vm, this, Identifier::fromString(vm, &quot;openDatabase&quot;), value);</span>
<span class="line-modified">658 // }</span>
<span class="line-modified">659 // #endif</span>
660 
661 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;JSDOMWindowCustom.h&quot;
 23 
 24 #include &quot;DOMWindowIndexedDatabase.h&quot;
 25 #include &quot;DOMWindowWebDatabase.h&quot;
 26 #include &quot;Frame.h&quot;
 27 #include &quot;HTMLCollection.h&quot;
 28 #include &quot;HTMLDocument.h&quot;
 29 #include &quot;HTMLFrameOwnerElement.h&quot;
 30 #include &quot;HTTPParsers.h&quot;
 31 #include &quot;JSDOMBindingSecurity.h&quot;
<span class="line-added"> 32 #include &quot;JSDOMConvertCallbacks.h&quot;</span>
 33 #include &quot;JSDOMConvertNullable.h&quot;
 34 #include &quot;JSDOMConvertNumbers.h&quot;
 35 #include &quot;JSDOMConvertStrings.h&quot;
 36 #include &quot;JSDatabase.h&quot;
 37 #include &quot;JSDatabaseCallback.h&quot;
 38 #include &quot;JSEvent.h&quot;
 39 #include &quot;JSEventListener.h&quot;
 40 #include &quot;JSHTMLAudioElement.h&quot;
 41 #include &quot;JSHTMLCollection.h&quot;
 42 #include &quot;JSHTMLOptionElement.h&quot;
 43 #include &quot;JSIDBFactory.h&quot;
 44 #include &quot;JSRemoteDOMWindow.h&quot;
 45 #include &quot;JSWindowProxy.h&quot;
 46 #include &quot;JSWorker.h&quot;
 47 #include &quot;Location.h&quot;
 48 #include &quot;RuntimeEnabledFeatures.h&quot;
 49 #include &quot;ScheduledAction.h&quot;
 50 #include &quot;Settings.h&quot;
 51 #include &quot;WebCoreJSClientData.h&quot;
 52 #include &lt;JavaScriptCore/BuiltinNames.h&gt;
 53 #include &lt;JavaScriptCore/HeapAnalyzer.h&gt;
 54 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 55 #include &lt;JavaScriptCore/JSFunction.h&gt;
 56 #include &lt;JavaScriptCore/JSMicrotask.h&gt;
 57 #include &lt;JavaScriptCore/Lookup.h&gt;
 58 #include &lt;JavaScriptCore/Structure.h&gt;
 59 
 60 #if ENABLE(USER_MESSAGE_HANDLERS)
 61 #include &quot;JSWebKitNamespace.h&quot;
 62 #endif
 63 
 64 
 65 namespace WebCore {
 66 using namespace JSC;
 67 
<span class="line-modified"> 68 EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionShowModalDialog(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 69 EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionOpenDatabase(JSGlobalObject*, CallFrame*);</span>
 70 
 71 void JSDOMWindow::visitAdditionalChildren(SlotVisitor&amp; visitor)
 72 {
 73     if (Frame* frame = wrapped().frame())
 74         visitor.addOpaqueRoot(frame);
 75 
 76     visitor.addOpaqueRoot(&amp;wrapped());
 77 
 78     // Normally JSEventTargetCustom.cpp&#39;s JSEventTarget::visitAdditionalChildren() would call this. But
 79     // even though DOMWindow is an EventTarget, JSDOMWindow does not subclass JSEventTarget, so we need
 80     // to do this here.
 81     wrapped().visitJSEventListeners(visitor);
 82 }
 83 
 84 #if ENABLE(USER_MESSAGE_HANDLERS)
<span class="line-modified"> 85 static EncodedJSValue jsDOMWindowWebKit(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName)</span>
 86 {
<span class="line-modified"> 87     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
 88     JSDOMWindow* castedThis = toJSDOMWindow(vm, JSValue::decode(thisValue));
<span class="line-modified"> 89     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, castedThis-&gt;wrapped()))</span>
 90         return JSValue::encode(jsUndefined());
<span class="line-modified"> 91     return JSValue::encode(toJS(lexicalGlobalObject, castedThis-&gt;globalObject(), castedThis-&gt;wrapped().webkitNamespace()));</span>
 92 }
 93 #endif
 94 
 95 template &lt;DOMWindowType windowType&gt;
<span class="line-modified"> 96 bool jsDOMWindowGetOwnPropertySlotRestrictedAccess(JSDOMGlobalObject* thisObject, AbstractDOMWindow&amp; window, JSGlobalObject&amp; lexicalGlobalObject, PropertyName propertyName, PropertySlot&amp; slot, const String&amp; errorMessage)</span>
 97 {
<span class="line-modified"> 98     VM&amp; vm = lexicalGlobalObject.vm();</span>
 99     auto scope = DECLARE_THROW_SCOPE(vm);
100 
101     auto&amp; builtinNames = static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames();
102 
103     // https://html.spec.whatwg.org/#crossorigingetownpropertyhelper-(-o,-p-)
104 
105     // These are the functions we allow access to cross-origin (DoNotCheckSecurity in IDL).
106     // Always provide the original function, on a fresh uncached function object.
107     if (propertyName == builtinNames.blurPublicName()) {
108         slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum), windowType == DOMWindowType::Remote ? nonCachingStaticFunctionGetter&lt;jsRemoteDOMWindowInstanceFunctionBlur, 0&gt; : nonCachingStaticFunctionGetter&lt;jsDOMWindowInstanceFunctionBlur, 0&gt;);
109         return true;
110     }
111     if (propertyName == builtinNames.closePublicName()) {
112         slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum), windowType == DOMWindowType::Remote ? nonCachingStaticFunctionGetter&lt;jsRemoteDOMWindowInstanceFunctionClose, 0&gt; : nonCachingStaticFunctionGetter&lt;jsDOMWindowInstanceFunctionClose, 0&gt;);
113         return true;
114     }
115     if (propertyName == builtinNames.focusPublicName()) {
116         slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum), windowType == DOMWindowType::Remote ? nonCachingStaticFunctionGetter&lt;jsRemoteDOMWindowInstanceFunctionFocus, 0&gt; : nonCachingStaticFunctionGetter&lt;jsDOMWindowInstanceFunctionFocus, 0&gt;);
117         return true;
118     }
</pre>
<hr />
<pre>
124     // When accessing cross-origin known Window properties, we always use the original property getter,
125     // even if the property was removed / redefined. As of early 2016, this matches Firefox and Chrome&#39;s
126     // behavior.
127     auto* classInfo = windowType == DOMWindowType::Remote ? JSRemoteDOMWindow::info() : JSDOMWindow::info();
128     if (auto* entry = classInfo-&gt;staticPropHashTable-&gt;entry(propertyName)) {
129         // Only allow access to these specific properties.
130         if (propertyName == builtinNames.locationPublicName()
131             || propertyName == builtinNames.closedPublicName()
132             || propertyName == vm.propertyNames-&gt;length
133             || propertyName == builtinNames.selfPublicName()
134             || propertyName == builtinNames.windowPublicName()
135             || propertyName == builtinNames.framesPublicName()
136             || propertyName == builtinNames.openerPublicName()
137             || propertyName == builtinNames.parentPublicName()
138             || propertyName == builtinNames.topPublicName()) {
139             bool shouldExposeSetter = propertyName == builtinNames.locationPublicName();
140             CustomGetterSetter* customGetterSetter = CustomGetterSetter::create(vm, entry-&gt;propertyGetter(), shouldExposeSetter ? entry-&gt;propertyPutter() : nullptr);
141             slot.setCustomGetterSetter(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DontEnum), customGetterSetter);
142             return true;
143         }







144     }
145 
146     // Check for child frames by name before built-in properties to match Mozilla. This does
147     // not match IE, but some sites end up naming frames things that conflict with window
148     // properties that are in Moz but not IE. Since we have some of these, we have to do it
149     // the Moz way.
150     // FIXME: Add support to named attributes on RemoteFrames.
151     auto* frame = window.frame();
152     if (frame &amp;&amp; is&lt;Frame&gt;(*frame)) {
153         if (auto* scopedChild = downcast&lt;Frame&gt;(*frame).tree().scopedChild(propertyNameToAtomString(propertyName))) {
<span class="line-modified">154             slot.setValue(thisObject, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum, toJS(&amp;lexicalGlobalObject, scopedChild-&gt;document()-&gt;domWindow()));</span>
155             return true;
156         }
157     }
158 
159     if (handleCommonCrossOriginProperties(thisObject, vm, propertyName, slot))
160         return true;
161 
<span class="line-modified">162     throwSecurityError(lexicalGlobalObject, scope, errorMessage);</span>
163     slot.setUndefined();
164     return false;
165 }
<span class="line-modified">166 template bool jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(JSDOMGlobalObject*, AbstractDOMWindow&amp;, JSGlobalObject&amp;, PropertyName, PropertySlot&amp;, const String&amp;);</span>
<span class="line-modified">167 template bool jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Remote&gt;(JSDOMGlobalObject*, AbstractDOMWindow&amp;, JSGlobalObject&amp;, PropertyName, PropertySlot&amp;, const String&amp;);</span>
168 
169 // https://html.spec.whatwg.org/#crossorigingetownpropertyhelper-(-o,-p-)
170 bool handleCommonCrossOriginProperties(JSObject* thisObject, VM&amp; vm, PropertyName propertyName, PropertySlot&amp; slot)
171 {
172     auto&amp; propertyNames =  vm.propertyNames;
173     if (propertyName == propertyNames-&gt;builtinNames().thenPublicName() || propertyName == propertyNames-&gt;toStringTagSymbol || propertyName == propertyNames-&gt;hasInstanceSymbol || propertyName == propertyNames-&gt;isConcatSpreadableSymbol) {
174         slot.setValue(thisObject, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum, jsUndefined());
175         return true;
176     }
177     return false;
178 }
179 
180 // Property access sequence is:
181 // (1) indexed properties,
182 // (2) regular own properties,
183 // (3) named properties (in fact, these shouldn&#39;t be on the window, should be on the NPO).
<span class="line-modified">184 bool JSDOMWindow::getOwnPropertySlot(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
185 {
186     // (1) First, indexed properties.
187     // Hand off all indexed access to getOwnPropertySlotByIndex, which supports the indexed getter.
188     if (Optional&lt;unsigned&gt; index = parseIndex(propertyName))
<span class="line-modified">189         return getOwnPropertySlotByIndex(object, lexicalGlobalObject, index.value(), slot);</span>
190 
191     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
192 
193     // Hand off all cross-domain access to jsDOMWindowGetOwnPropertySlotRestrictedAccess.
194     String errorMessage;
<span class="line-modified">195     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*lexicalGlobalObject, thisObject-&gt;wrapped(), errorMessage))</span>
<span class="line-modified">196         return jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(thisObject, thisObject-&gt;wrapped(), *lexicalGlobalObject, propertyName, slot, errorMessage);</span>
197 
198     // FIXME: this needs more explanation.
199     // (Particularly, is it correct that this exists here but not in getOwnPropertySlotByIndex?)
200     slot.setWatchpointSet(thisObject-&gt;m_windowCloseWatchpoints);
201 
202     // (2) Regular own properties.
203     PropertySlot slotCopy = slot;
<span class="line-modified">204     if (Base::getOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot)) {</span>
205         auto* frame = thisObject-&gt;wrapped().frame();
206 
207         // Detect when we&#39;re getting the property &#39;showModalDialog&#39;, this is disabled, and has its original value.
<span class="line-modified">208         bool isShowModalDialogAndShouldHide = propertyName == static_cast&lt;JSVMClientData*&gt;(lexicalGlobalObject-&gt;vm().clientData)-&gt;builtinNames().showModalDialogPublicName()</span>
209             &amp;&amp; (!frame || !DOMWindow::canShowModalDialog(*frame))
<span class="line-modified">210             &amp;&amp; slot.isValue() &amp;&amp; isHostFunction(slot.getValue(lexicalGlobalObject, propertyName), jsDOMWindowInstanceFunctionShowModalDialog);</span>
211         // Unless we&#39;re in the showModalDialog special case, we&#39;re done.
212         if (!isShowModalDialogAndShouldHide)
213             return true;
214         slot = slotCopy;
215     }
216 
217 #if ENABLE(USER_MESSAGE_HANDLERS)
<span class="line-modified">218     if (propertyName == static_cast&lt;JSVMClientData*&gt;(lexicalGlobalObject-&gt;vm().clientData)-&gt;builtinNames().webkitPublicName() &amp;&amp; thisObject-&gt;wrapped().shouldHaveWebKitNamespaceForWorld(thisObject-&gt;world())) {</span>
219         slot.setCacheableCustom(thisObject, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly, jsDOMWindowWebKit);
220         return true;
221     }
222 #endif
223 
224     return false;
225 }
226 
227 // Property access sequence is:
228 // (1) indexed properties,
229 // (2) regular own properties,
230 // (3) named properties (in fact, these shouldn&#39;t be on the window, should be on the NPO).
<span class="line-modified">231 bool JSDOMWindow::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* lexicalGlobalObject, unsigned index, PropertySlot&amp; slot)</span>
232 {
<span class="line-modified">233     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
234     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
235     auto&amp; window = thisObject-&gt;wrapped();
236     auto* frame = window.frame();
237 
238     // Indexed getters take precendence over regular properties, so caching would be invalid.
239     slot.disableCaching();
240 
241     String errorMessage;
242     Optional&lt;bool&gt; cachedIsCrossOriginAccess;
243     auto isCrossOriginAccess = [&amp;] {
244         if (!cachedIsCrossOriginAccess)
<span class="line-modified">245             cachedIsCrossOriginAccess = !BindingSecurity::shouldAllowAccessToDOMWindow(*lexicalGlobalObject, window, errorMessage);</span>
246         return *cachedIsCrossOriginAccess;
247     };
248 
249     // (1) First, indexed properties.
250     // These are also allowed cross-origin, so come before the access check.
251     if (frame &amp;&amp; index &lt; frame-&gt;tree().scopedChildCount()) {
<span class="line-modified">252         slot.setValue(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::ReadOnly), toJS(lexicalGlobalObject, frame-&gt;tree().scopedChild(index)-&gt;document()-&gt;domWindow()));</span>
253         return true;
254     }
255 
256     // Hand off all cross-domain/frameless access to jsDOMWindowGetOwnPropertySlotRestrictedAccess.
257     if (isCrossOriginAccess())
<span class="line-modified">258         return jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(thisObject, window, *lexicalGlobalObject, Identifier::from(vm, index), slot, errorMessage);</span>
259 
260     // (2) Regular own properties.
<span class="line-modified">261     return Base::getOwnPropertySlotByIndex(thisObject, lexicalGlobalObject, index, slot);</span>
262 }
263 
<span class="line-modified">264 void JSDOMWindow::doPutPropertySecurityCheck(JSObject* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PutPropertySlot&amp;)</span>
265 {
<span class="line-modified">266     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
267     auto scope = DECLARE_THROW_SCOPE(vm);
268 
269     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
270     if (!thisObject-&gt;wrapped().frame())
271         return;
272 
273     String errorMessage;
<span class="line-modified">274     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*lexicalGlobalObject, thisObject-&gt;wrapped(), errorMessage)) {</span>
275         // We only allow setting &quot;location&quot; attribute cross-origin.
276         if (propertyName == static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().locationPublicName())
277             return;
<span class="line-modified">278         throwSecurityError(*lexicalGlobalObject, scope, errorMessage);</span>
279         return;
280     }
281 }
282 
<span class="line-modified">283 bool JSDOMWindow::put(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
284 {
<span class="line-modified">285     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
286     auto scope = DECLARE_THROW_SCOPE(vm);
287 
288     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
289     if (!thisObject-&gt;wrapped().frame())
290         return false;
291 
292     String errorMessage;
<span class="line-modified">293     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*lexicalGlobalObject, thisObject-&gt;wrapped(), errorMessage)) {</span>
294         // We only allow setting &quot;location&quot; attribute cross-origin.
295         if (propertyName == static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().locationPublicName()) {
296             bool putResult = false;
<span class="line-modified">297             if (lookupPut(lexicalGlobalObject, propertyName, thisObject, value, *s_info.staticPropHashTable, slot, putResult))</span>
298                 return putResult;
299             return false;
300         }
<span class="line-modified">301         throwSecurityError(*lexicalGlobalObject, scope, errorMessage);</span>
302         return false;
303     }
304 
<span class="line-modified">305     return Base::put(thisObject, lexicalGlobalObject, propertyName, value, slot);</span>
306 }
307 
<span class="line-modified">308 bool JSDOMWindow::putByIndex(JSCell* cell, JSGlobalObject* lexicalGlobalObject, unsigned index, JSValue value, bool shouldThrow)</span>
309 {
310     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
<span class="line-modified">311     if (!thisObject-&gt;wrapped().frame() || !BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped()))</span>
312         return false;
313 
<span class="line-modified">314     return Base::putByIndex(thisObject, lexicalGlobalObject, index, value, shouldThrow);</span>
315 }
316 
<span class="line-modified">317 bool JSDOMWindow::deleteProperty(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName)</span>
318 {
319     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
320     // Only allow deleting properties by frames in the same origin.
<span class="line-modified">321     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped(), ThrowSecurityError))</span>
322         return false;
<span class="line-modified">323     return Base::deleteProperty(thisObject, lexicalGlobalObject, propertyName);</span>
324 }
325 
<span class="line-modified">326 bool JSDOMWindow::deletePropertyByIndex(JSCell* cell, JSGlobalObject* lexicalGlobalObject, unsigned propertyName)</span>
327 {
328     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
329     // Only allow deleting properties by frames in the same origin.
<span class="line-modified">330     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped(), ThrowSecurityError))</span>
331         return false;
<span class="line-modified">332     return Base::deletePropertyByIndex(thisObject, lexicalGlobalObject, propertyName);</span>
333 }
334 
335 void JSDOMWindow::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)
336 {
337     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
338     auto&amp; location = thisObject-&gt;wrapped().location();
339     analyzer.setLabelForCell(cell, location.href());
340 
341     Base::analyzeHeap(cell, analyzer);
342 }
343 
344 // https://html.spec.whatwg.org/#crossoriginproperties-(-o-)
345 template &lt;CrossOriginObject objectType&gt;
346 static void addCrossOriginPropertyNames(VM&amp; vm, PropertyNameArray&amp; propertyNames)
347 {
348     auto&amp; builtinNames = static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames();
349     switch (objectType) {
350     case CrossOriginObject::Location: {
351         static const Identifier* const properties[] = { &amp;builtinNames.hrefPublicName(), &amp;vm.propertyNames-&gt;replace };
352         for (auto* property : properties)
</pre>
<hr />
<pre>
354         break;
355     }
356     case CrossOriginObject::Window: {
357         static const Identifier* const properties[] = {
358             &amp;builtinNames.blurPublicName(), &amp;builtinNames.closePublicName(), &amp;builtinNames.closedPublicName(),
359             &amp;builtinNames.focusPublicName(), &amp;builtinNames.framesPublicName(), &amp;vm.propertyNames-&gt;length,
360             &amp;builtinNames.locationPublicName(), &amp;builtinNames.openerPublicName(), &amp;builtinNames.parentPublicName(),
361             &amp;builtinNames.postMessagePublicName(), &amp;builtinNames.selfPublicName(), &amp;builtinNames.topPublicName(),
362             &amp;builtinNames.windowPublicName()
363         };
364 
365         for (auto* property : properties)
366             propertyNames.add(*property);
367         break;
368     }
369     }
370 }
371 
372 // https://html.spec.whatwg.org/#crossoriginownpropertykeys-(-o-)
373 template &lt;CrossOriginObject objectType&gt;
<span class="line-modified">374 void addCrossOriginOwnPropertyNames(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::PropertyNameArray&amp; propertyNames)</span>
375 {
<span class="line-modified">376     auto&amp; vm = lexicalGlobalObject.vm();</span>
377     addCrossOriginPropertyNames&lt;objectType&gt;(vm, propertyNames);
378 
379     static const Identifier* const properties[] = {
380         &amp;vm.propertyNames-&gt;builtinNames().thenPublicName(), &amp;vm.propertyNames-&gt;toStringTagSymbol, &amp;vm.propertyNames-&gt;hasInstanceSymbol, &amp;vm.propertyNames-&gt;isConcatSpreadableSymbol
381     };
382 
383     for (auto* property : properties)
384         propertyNames.add(*property);
385 
386 }
<span class="line-modified">387 template void addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Window&gt;(JSC::JSGlobalObject&amp;, JSC::PropertyNameArray&amp;);</span>
<span class="line-modified">388 template void addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Location&gt;(JSC::JSGlobalObject&amp;, JSC::PropertyNameArray&amp;);</span>
389 
<span class="line-modified">390 static void addScopedChildrenIndexes(JSGlobalObject&amp; lexicalGlobalObject, DOMWindow&amp; window, PropertyNameArray&amp; propertyNames)</span>
391 {
392     auto* document = window.document();
393     if (!document)
394         return;
395 
396     auto* frame = document-&gt;frame();
397     if (!frame)
398         return;
399 
<span class="line-modified">400     VM&amp; vm = lexicalGlobalObject.vm();</span>
401     unsigned scopedChildCount = frame-&gt;tree().scopedChildCount();
402     for (unsigned i = 0; i &lt; scopedChildCount; ++i)
403         propertyNames.add(Identifier::from(vm, i));
404 }
405 
406 // https://html.spec.whatwg.org/#windowproxy-ownpropertykeys
<span class="line-modified">407 void JSDOMWindow::getOwnPropertyNames(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
408 {
409     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
410 
<span class="line-modified">411     addScopedChildrenIndexes(*lexicalGlobalObject, thisObject-&gt;wrapped(), propertyNames);</span>
412 
<span class="line-modified">413     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped(), DoNotReportSecurityError)) {</span>
414         if (mode.includeDontEnumProperties())
<span class="line-modified">415             addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Window&gt;(*lexicalGlobalObject, propertyNames);</span>
416         return;
417     }
<span class="line-modified">418     Base::getOwnPropertyNames(thisObject, lexicalGlobalObject, propertyNames, mode);</span>
419 }
420 
<span class="line-modified">421 bool JSDOMWindow::defineOwnProperty(JSC::JSObject* object, JSC::JSGlobalObject* lexicalGlobalObject, JSC::PropertyName propertyName, const JSC::PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
422 {
<span class="line-modified">423     JSC::VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
424     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
425     // Only allow defining properties in this way by frames in the same origin, as it allows setters to be introduced.
<span class="line-modified">426     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped(), ThrowSecurityError))</span>
427         return false;
428 
429     // Don&#39;t allow shadowing location using accessor properties.
430     if (descriptor.isAccessorDescriptor() &amp;&amp; propertyName == Identifier::fromString(vm, &quot;location&quot;))
431         return false;
432 
<span class="line-modified">433     return Base::defineOwnProperty(thisObject, lexicalGlobalObject, propertyName, descriptor, shouldThrow);</span>
434 }
435 
<span class="line-modified">436 JSValue JSDOMWindow::getPrototype(JSObject* object, JSGlobalObject* lexicalGlobalObject)</span>
437 {
438     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
<span class="line-modified">439     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped(), DoNotReportSecurityError))</span>
440         return jsNull();
441 
<span class="line-modified">442     return Base::getPrototype(object, lexicalGlobalObject);</span>
443 }
444 
<span class="line-modified">445 bool JSDOMWindow::preventExtensions(JSObject*, JSGlobalObject* lexicalGlobalObject)</span>
446 {
<span class="line-modified">447     auto scope = DECLARE_THROW_SCOPE(lexicalGlobalObject-&gt;vm());</span>
448 
<span class="line-modified">449     throwTypeError(lexicalGlobalObject, scope, &quot;Cannot prevent extensions on this object&quot;_s);</span>
450     return false;
451 }
452 
<span class="line-modified">453 String JSDOMWindow::toStringName(const JSObject* object, JSGlobalObject* lexicalGlobalObject)</span>
454 {
455     auto* thisObject = jsCast&lt;const JSDOMWindow*&gt;(object);
<span class="line-modified">456     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped(), DoNotReportSecurityError))</span>
457         return &quot;Object&quot;_s;
458     return &quot;Window&quot;_s;
459 }
460 
461 // Custom Attributes
462 
<span class="line-modified">463 JSValue JSDOMWindow::event(JSGlobalObject&amp; lexicalGlobalObject) const</span>
464 {
465     Event* event = currentEvent();
466     if (!event)
467         return jsUndefined();
<span class="line-modified">468     return toJS(&amp;lexicalGlobalObject, const_cast&lt;JSDOMWindow*&gt;(this), event);</span>
469 }
470 
471 // Custom functions
472 
473 class DialogHandler {
474 public:
<span class="line-modified">475     explicit DialogHandler(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)</span>
<span class="line-modified">476         : m_globalObject(lexicalGlobalObject)</span>
<span class="line-added">477         , m_callFrame(callFrame)</span>
478     {
479     }
480 
481     void dialogCreated(DOMWindow&amp;);
482     JSValue returnValue() const;
483 
484 private:
<span class="line-modified">485     JSGlobalObject&amp; m_globalObject;</span>
<span class="line-added">486     CallFrame&amp; m_callFrame;</span>
487     RefPtr&lt;Frame&gt; m_frame;
488 };
489 
490 inline void DialogHandler::dialogCreated(DOMWindow&amp; dialog)
491 {
<span class="line-modified">492     VM&amp; vm = m_globalObject.vm();</span>
493     m_frame = dialog.frame();
494 
495     // FIXME: This looks like a leak between the normal world and an isolated
496     //        world if dialogArguments comes from an isolated world.
497     JSDOMWindow* globalObject = toJSDOMWindow(m_frame.get(), normalWorld(vm));
<span class="line-modified">498     if (JSValue dialogArguments = m_callFrame.argument(1))</span>
499         globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;dialogArguments&quot;), dialogArguments);
500 }
501 
502 inline JSValue DialogHandler::returnValue() const
503 {
<span class="line-modified">504     VM&amp; vm = m_globalObject.vm();</span>
505     JSDOMWindow* globalObject = toJSDOMWindow(m_frame.get(), normalWorld(vm));
506     if (!globalObject)
507         return jsUndefined();
508     Identifier identifier = Identifier::fromString(vm, &quot;returnValue&quot;);
509     PropertySlot slot(globalObject, PropertySlot::InternalMethodType::Get);
<span class="line-modified">510     if (!JSGlobalObject::getOwnPropertySlot(globalObject, &amp;m_globalObject, identifier, slot))</span>
511         return jsUndefined();
<span class="line-modified">512     return slot.getValue(&amp;m_globalObject, identifier);</span>
513 }
514 
<span class="line-modified">515 JSValue JSDOMWindow::showModalDialog(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)</span>
516 {
<span class="line-modified">517     VM&amp; vm = lexicalGlobalObject.vm();</span>
518     auto scope = DECLARE_THROW_SCOPE(vm);
519 
<span class="line-modified">520     if (UNLIKELY(callFrame.argumentCount() &lt; 1))</span>
<span class="line-modified">521         return throwException(&amp;lexicalGlobalObject, scope, createNotEnoughArgumentsError(&amp;lexicalGlobalObject));</span>
522 
<span class="line-modified">523     String urlString = convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(lexicalGlobalObject, callFrame.argument(0));</span>
524     RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">525     String dialogFeaturesString = convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(lexicalGlobalObject, callFrame.argument(2));</span>
526     RETURN_IF_EXCEPTION(scope, JSValue());
527 
<span class="line-modified">528     DialogHandler handler(lexicalGlobalObject, callFrame);</span>
529 
<span class="line-modified">530     wrapped().showModalDialog(urlString, dialogFeaturesString, activeDOMWindow(lexicalGlobalObject), firstDOMWindow(lexicalGlobalObject), [&amp;handler](DOMWindow&amp; dialog) {</span>
531         handler.dialogCreated(dialog);
532     });
533 
534     return handler.returnValue();
535 }
536 
<span class="line-modified">537 JSValue JSDOMWindow::queueMicrotask(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)</span>
538 {
<span class="line-modified">539     VM&amp; vm = lexicalGlobalObject.vm();</span>
540     auto scope = DECLARE_THROW_SCOPE(vm);
541 
<span class="line-modified">542     if (UNLIKELY(callFrame.argumentCount() &lt; 1))</span>
<span class="line-modified">543         return throwException(&amp;lexicalGlobalObject, scope, createNotEnoughArgumentsError(&amp;lexicalGlobalObject));</span>
544 
<span class="line-modified">545     JSValue functionValue = callFrame.uncheckedArgument(0);</span>
546     if (UNLIKELY(!functionValue.isFunction(vm)))
<span class="line-modified">547         return JSValue::decode(throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 0, &quot;callback&quot;, &quot;Window&quot;, &quot;queueMicrotask&quot;));</span>
548 
549     scope.release();
550     Base::queueMicrotask(JSC::createJSMicrotask(vm, functionValue));
551     return jsUndefined();
552 }
553 
554 DOMWindow* JSDOMWindow::toWrapped(VM&amp; vm, JSValue value)
555 {
556     if (!value.isObject())
557         return nullptr;
558     JSObject* object = asObject(value);
559     if (object-&gt;inherits&lt;JSDOMWindow&gt;(vm))
560         return &amp;jsCast&lt;JSDOMWindow*&gt;(object)-&gt;wrapped();
561     if (object-&gt;inherits&lt;JSWindowProxy&gt;(vm)) {
562         if (auto* jsDOMWindow = jsDynamicCast&lt;JSDOMWindow*&gt;(vm, jsCast&lt;JSWindowProxy*&gt;(object)-&gt;window()))
563             return &amp;jsDOMWindow-&gt;wrapped();
564     }
565     return nullptr;
566 }
567 
<span class="line-modified">568 void JSDOMWindow::setOpener(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
569 {
<span class="line-modified">570     if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, wrapped(), ThrowSecurityError))</span>
571         return;
572 
573     if (value.isNull()) {
574         wrapped().disownOpener();
575         return;
576     }
<span class="line-modified">577     VM&amp; vm = lexicalGlobalObject.vm();</span>
578     replaceStaticPropertySlot(vm, this, Identifier::fromString(vm, &quot;opener&quot;), value);
579 }
580 
<span class="line-modified">581 JSValue JSDOMWindow::self(JSC::JSGlobalObject&amp;) const</span>
582 {
583     return globalThis();
584 }
585 
<span class="line-modified">586 JSValue JSDOMWindow::window(JSC::JSGlobalObject&amp;) const</span>
587 {
588     return globalThis();
589 }
590 
<span class="line-modified">591 JSValue JSDOMWindow::frames(JSC::JSGlobalObject&amp;) const</span>
592 {
593     return globalThis();
594 }
595 
<span class="line-modified">596 static inline JSC::EncodedJSValue jsDOMWindowInstanceFunctionOpenDatabaseBody(JSC::JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame, typename IDLOperation&lt;JSDOMWindow&gt;::ClassParameter castedThis, JSC::ThrowScope&amp; throwScope)</span>
597 {
<span class="line-modified">598     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, castedThis-&gt;wrapped(), ThrowSecurityError))</span>
599         return JSValue::encode(jsUndefined());
600     auto&amp; impl = castedThis-&gt;wrapped();
<span class="line-modified">601     if (UNLIKELY(callFrame-&gt;argumentCount() &lt; 4))</span>
<span class="line-modified">602         return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));</span>
<span class="line-modified">603     auto name = convert&lt;IDLDOMString&gt;(*lexicalGlobalObject, callFrame-&gt;uncheckedArgument(0));</span>
604     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">605     auto version = convert&lt;IDLDOMString&gt;(*lexicalGlobalObject, callFrame-&gt;uncheckedArgument(1));</span>
606     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">607     auto displayName = convert&lt;IDLDOMString&gt;(*lexicalGlobalObject, callFrame-&gt;uncheckedArgument(2));</span>
608     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">609     auto estimatedSize = convert&lt;IDLUnsignedLong&gt;(*lexicalGlobalObject, callFrame-&gt;uncheckedArgument(3));</span>
610     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
611 
612     if (!RuntimeEnabledFeatures::sharedFeatures().webSQLEnabled()) {
613         if (name != &quot;null&quot; || version != &quot;null&quot; || displayName != &quot;null&quot; || estimatedSize)
<span class="line-modified">614             propagateException(*lexicalGlobalObject, throwScope, Exception(UnknownError, &quot;Web SQL is deprecated&quot;_s));</span>
<span class="line-modified">615         return JSValue::encode(constructEmptyObject(lexicalGlobalObject, castedThis-&gt;globalObject()-&gt;objectPrototype()));</span>
616     }
617 
<span class="line-modified">618     auto creationCallback = convert&lt;IDLNullable&lt;IDLCallbackFunction&lt;JSDatabaseCallback&gt;&gt;&gt;(*lexicalGlobalObject, callFrame-&gt;argument(4), *castedThis-&gt;globalObject(), [](JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope) {</span>
<span class="line-modified">619         throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 4, &quot;creationCallback&quot;, &quot;Window&quot;, &quot;openDatabase&quot;);</span>
620     });
621     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">622     return JSValue::encode(toJS&lt;IDLNullable&lt;IDLInterface&lt;Database&gt;&gt;&gt;(*lexicalGlobalObject, *castedThis-&gt;globalObject(), throwScope, WebCore::DOMWindowWebDatabase::openDatabase(impl, WTFMove(name), WTFMove(version), WTFMove(displayName), WTFMove(estimatedSize), WTFMove(creationCallback))));</span>
623 }
624 
<span class="line-modified">625 template&lt;&gt; inline JSDOMWindow* IDLOperation&lt;JSDOMWindow&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)</span>
626 {
<span class="line-modified">627     return toJSDOMWindow(lexicalGlobalObject.vm(), callFrame.thisValue().toThis(&amp;lexicalGlobalObject, NotStrictMode));</span>
628 }
629 
<span class="line-modified">630 EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionOpenDatabase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
631 {
<span class="line-modified">632     return IDLOperation&lt;JSDOMWindow&gt;::call&lt;jsDOMWindowInstanceFunctionOpenDatabaseBody&gt;(*globalObject, *callFrame, &quot;openDatabase&quot;);</span>
633 }
634 
<span class="line-modified">635 // FIXME-java: Currently WebSQL feature is not implemented completely in JavaFX port.</span>
<span class="line-modified">636 #if !PLATFORM(JAVA)</span>
<span class="line-modified">637 JSValue JSDOMWindow::openDatabase(JSC::JSGlobalObject&amp; lexicalGlobalObject) const</span>
<span class="line-modified">638 {</span>
<span class="line-modified">639     VM&amp; vm = lexicalGlobalObject.vm();</span>
<span class="line-modified">640     StringImpl* name = PropertyName(static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().openDatabasePublicName()).publicName();</span>
<span class="line-modified">641     if (RuntimeEnabledFeatures::sharedFeatures().webSQLEnabled())</span>
<span class="line-modified">642         return JSFunction::create(vm, &amp;lexicalGlobalObject, 4, name, jsDOMWindowInstanceFunctionOpenDatabase, NoIntrinsic);</span>
643 
<span class="line-modified">644     return JSFunction::createFunctionThatMasqueradesAsUndefined(vm, &amp;lexicalGlobalObject, 4, name, jsDOMWindowInstanceFunctionOpenDatabase, NoIntrinsic);</span>
<span class="line-modified">645 }</span>
646 
<span class="line-modified">647 void JSDOMWindow::setOpenDatabase(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
<span class="line-modified">648 {</span>
<span class="line-modified">649     if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, wrapped(), ThrowSecurityError))</span>
<span class="line-modified">650         return;</span>
651 
<span class="line-modified">652     VM&amp; vm = lexicalGlobalObject.vm();</span>
<span class="line-modified">653     replaceStaticPropertySlot(vm, this, Identifier::fromString(vm, &quot;openDatabase&quot;), value);</span>
<span class="line-modified">654 }</span>
<span class="line-modified">655 #endif</span>
656 
657 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="JSDOMWindowBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMWindowCustom.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
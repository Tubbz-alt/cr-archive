<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WasmToJS.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSWebAssemblyTable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WasmToJS.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WasmToJS.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmToJS.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;FrameTracers.h&quot;

 33 #include &quot;JITExceptions.h&quot;
 34 #include &quot;JSCInlines.h&quot;
 35 #include &quot;JSWebAssemblyHelpers.h&quot;
 36 #include &quot;JSWebAssemblyInstance.h&quot;
 37 #include &quot;JSWebAssemblyRuntimeError.h&quot;
 38 #include &quot;LinkBuffer.h&quot;
 39 #include &quot;NativeErrorConstructor.h&quot;
 40 #include &quot;ThunkGenerators.h&quot;
 41 #include &quot;WasmCallingConvention.h&quot;
<span class="line-modified"> 42 #include &quot;WasmContext.h&quot;</span>
 43 #include &quot;WasmExceptionType.h&quot;
 44 #include &quot;WasmInstance.h&quot;

 45 #include &quot;WasmSignatureInlines.h&quot;
 46 



 47 namespace JSC { namespace Wasm {
 48 
 49 using JIT = CCallHelpers;
 50 
 51 static void materializeImportJSCell(JIT&amp; jit, unsigned importIndex, GPRReg result)
 52 {
 53     // We&#39;re calling out of the current WebAssembly.Instance. That Instance has a list of all its import functions.
 54     jit.loadWasmContextInstance(result);
 55     jit.loadPtr(JIT::Address(result, Instance::offsetOfImportFunction(importIndex)), result);
 56 }
 57 
<span class="line-modified"> 58 static Expected&lt;MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;, BindingFailure&gt; handleBadI64Use(VM* vm, JIT&amp; jit, const Signature&amp; signature, unsigned importIndex)</span>
 59 {
<span class="line-modified"> 60     unsigned argCount = signature.argumentCount();</span>
<span class="line-modified"> 61 </span>
<span class="line-removed"> 62     bool hasBadI64Use = false;</span>
<span class="line-removed"> 63     hasBadI64Use |= signature.returnType() == I64;</span>
<span class="line-removed"> 64     for (unsigned argNum = 0; argNum &lt; argCount &amp;&amp; !hasBadI64Use; ++argNum) {</span>
<span class="line-removed"> 65         Type argType = signature.argument(argNum);</span>
<span class="line-removed"> 66         switch (argType) {</span>
<span class="line-removed"> 67         case Void:</span>
<span class="line-removed"> 68         case Func:</span>
<span class="line-removed"> 69             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 70 </span>
<span class="line-removed"> 71         case I64: {</span>
<span class="line-removed"> 72             hasBadI64Use = true;</span>
<span class="line-removed"> 73             break;</span>
<span class="line-removed"> 74         }</span>
<span class="line-removed"> 75 </span>
<span class="line-removed"> 76         default:</span>
<span class="line-removed"> 77             break;</span>
<span class="line-removed"> 78         }</span>
<span class="line-removed"> 79     }</span>
<span class="line-removed"> 80 </span>
<span class="line-removed"> 81     if (hasBadI64Use) {</span>
<span class="line-removed"> 82         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);</span>
<span class="line-removed"> 83         jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);</span>
<span class="line-removed"> 84         jit.loadWasmContextInstance(GPRInfo::argumentGPR1);</span>
<span class="line-removed"> 85 </span>
<span class="line-removed"> 86         // Store Callee.</span>
<span class="line-removed"> 87         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR1, Instance::offsetOfOwner()), GPRInfo::argumentGPR1);</span>
<span class="line-removed"> 88         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR1, JSWebAssemblyInstance::offsetOfCallee()), GPRInfo::argumentGPR2);</span>
<span class="line-removed"> 89         jit.storePtr(GPRInfo::argumentGPR2, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));</span>
<span class="line-removed"> 90 </span>
<span class="line-removed"> 91         auto call = jit.call(OperationPtrTag);</span>
<span class="line-removed"> 92         jit.jumpToExceptionHandler(*vm);</span>
<span class="line-removed"> 93 </span>
<span class="line-removed"> 94         void (*throwBadI64)(ExecState*, JSWebAssemblyInstance*) = [] (ExecState* exec, JSWebAssemblyInstance* instance) -&gt; void {</span>
<span class="line-removed"> 95             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed"> 96             NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed"> 97 </span>
<span class="line-removed"> 98             {</span>
<span class="line-removed"> 99                 auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">100                 JSGlobalObject* globalObject = instance-&gt;globalObject(vm);</span>
<span class="line-removed">101                 auto* error = ErrorInstance::create(exec, vm, globalObject-&gt;errorStructure(ErrorType::TypeError), &quot;i64 not allowed as return type or argument to an imported function&quot;_s);</span>
<span class="line-removed">102                 throwException(exec, throwScope, error);</span>
<span class="line-removed">103             }</span>
104 
<span class="line-modified">105             genericUnwind(vm, exec);</span>
<span class="line-modified">106             ASSERT(!!vm.callFrameForCatch);</span>
<span class="line-modified">107         };</span>


108 
<span class="line-modified">109         LinkBuffer linkBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);</span>
<span class="line-modified">110         if (UNLIKELY(linkBuffer.didFailToAllocate()))</span>
<span class="line-removed">111             return makeUnexpected(BindingFailure::OutOfMemory);</span>
112 
<span class="line-modified">113         linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(throwBadI64));</span>
<span class="line-modified">114         return FINALIZE_CODE(linkBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript invalid i64 use in import[%i]&quot;, importIndex);</span>
<span class="line-modified">115     }</span>
116 
<span class="line-modified">117     return MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;();</span>

118 }
119 
<span class="line-modified">120 Expected&lt;MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;, BindingFailure&gt; wasmToJS(VM* vm, Bag&lt;CallLinkInfo&gt;&amp; callLinkInfos, SignatureIndex signatureIndex, unsigned importIndex)</span>
121 {
122     // FIXME: This function doesn&#39;t properly abstract away the calling convention.
123     // It&#39;d be super easy to do so: https://bugs.webkit.org/show_bug.cgi?id=169401
<span class="line-modified">124     const WasmCallingConvention&amp; wasmCC = wasmCallingConvention();</span>
<span class="line-modified">125     const JSCCallingConvention&amp; jsCC = jscCallingConvention();</span>
126     const Signature&amp; signature = SignatureInformation::get(signatureIndex);
127     unsigned argCount = signature.argumentCount();
128     JIT jit;
129 



130     // Note: WasmB3IRGenerator assumes that this stub treats SP as a callee save.
131     // If we ever change this, we will also need to change WasmB3IRGenerator.
132 
133     // Below, we assume that the JS calling convention is always on the stack.
<span class="line-modified">134     ASSERT(!jsCC.m_gprArgs.size());</span>
<span class="line-modified">135     ASSERT(!jsCC.m_fprArgs.size());</span>
136 
137     jit.emitFunctionPrologue();
138     jit.store64(JIT::TrustedImm32(0), JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::codeBlock * static_cast&lt;int&gt;(sizeof(Register)))); // FIXME Stop using 0 as codeBlocks. https://bugs.webkit.org/show_bug.cgi?id=165321
139 
<span class="line-modified">140     auto badI64 = handleBadI64Use(vm, jit, signature, importIndex);</span>
<span class="line-modified">141     if (!badI64 || badI64.value())</span>
<span class="line-removed">142         return badI64;</span>
143 
144     // Here we assume that the JS calling convention saves at least all the wasm callee saved. We therefore don&#39;t need to save and restore more registers since the wasm callee already took care of this.
<span class="line-modified">145     RegisterSet missingCalleeSaves = wasmCC.m_calleeSaveRegisters;</span>
<span class="line-modified">146     missingCalleeSaves.exclude(jsCC.m_calleeSaveRegisters);</span>
147     ASSERT(missingCalleeSaves.isEmpty());
148 
<span class="line-removed">149     if (!Options::useCallICsForWebAssemblyToJSCalls()) {</span>
<span class="line-removed">150         ScratchBuffer* scratchBuffer = vm-&gt;scratchBufferForSize(argCount * sizeof(uint64_t));</span>
<span class="line-removed">151         char* buffer = argCount ? static_cast&lt;char*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;</span>
<span class="line-removed">152         unsigned marshalledGPRs = 0;</span>
<span class="line-removed">153         unsigned marshalledFPRs = 0;</span>
<span class="line-removed">154         unsigned bufferOffset = 0;</span>
<span class="line-removed">155         unsigned frOffset = CallFrame::headerSizeInRegisters * static_cast&lt;int&gt;(sizeof(Register));</span>
<span class="line-removed">156         const GPRReg scratchGPR = GPRInfo::regCS0;</span>
<span class="line-removed">157         jit.subPtr(MacroAssembler::TrustedImm32(WTF::roundUpToMultipleOf(stackAlignmentBytes(), sizeof(Register))), MacroAssembler::stackPointerRegister);</span>
<span class="line-removed">158         jit.storePtr(scratchGPR, MacroAssembler::Address(MacroAssembler::stackPointerRegister));</span>
<span class="line-removed">159 </span>
<span class="line-removed">160         for (unsigned argNum = 0; argNum &lt; argCount; ++argNum) {</span>
<span class="line-removed">161             Type argType = signature.argument(argNum);</span>
<span class="line-removed">162             switch (argType) {</span>
<span class="line-removed">163             case Void:</span>
<span class="line-removed">164             case Func:</span>
<span class="line-removed">165             case I64:</span>
<span class="line-removed">166                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">167             case Anyref:</span>
<span class="line-removed">168             case Funcref:</span>
<span class="line-removed">169             case I32: {</span>
<span class="line-removed">170                 GPRReg gprReg;</span>
<span class="line-removed">171                 if (marshalledGPRs &lt; wasmCC.m_gprArgs.size())</span>
<span class="line-removed">172                     gprReg = wasmCC.m_gprArgs[marshalledGPRs].gpr();</span>
<span class="line-removed">173                 else {</span>
<span class="line-removed">174                     // We&#39;ve already spilled all arguments, these registers are available as scratch.</span>
<span class="line-removed">175                     gprReg = GPRInfo::argumentGPR0;</span>
<span class="line-removed">176                     jit.load64(JIT::Address(GPRInfo::callFrameRegister, frOffset), gprReg);</span>
<span class="line-removed">177                     frOffset += sizeof(Register);</span>
<span class="line-removed">178                 }</span>
<span class="line-removed">179                 if (argType == I32)</span>
<span class="line-removed">180                     jit.zeroExtend32ToPtr(gprReg, gprReg);</span>
<span class="line-removed">181                 jit.store64(gprReg, buffer + bufferOffset);</span>
<span class="line-removed">182                 ++marshalledGPRs;</span>
<span class="line-removed">183                 break;</span>
<span class="line-removed">184             }</span>
<span class="line-removed">185             case F32: {</span>
<span class="line-removed">186                 FPRReg fprReg;</span>
<span class="line-removed">187                 if (marshalledFPRs &lt; wasmCC.m_fprArgs.size())</span>
<span class="line-removed">188                     fprReg = wasmCC.m_fprArgs[marshalledFPRs].fpr();</span>
<span class="line-removed">189                 else {</span>
<span class="line-removed">190                     // We&#39;ve already spilled all arguments, these registers are available as scratch.</span>
<span class="line-removed">191                     fprReg = FPRInfo::argumentFPR0;</span>
<span class="line-removed">192                     jit.loadFloat(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);</span>
<span class="line-removed">193                     frOffset += sizeof(Register);</span>
<span class="line-removed">194                 }</span>
<span class="line-removed">195                 jit.convertFloatToDouble(fprReg, fprReg);</span>
<span class="line-removed">196                 jit.moveDoubleTo64(fprReg, scratchGPR);</span>
<span class="line-removed">197                 jit.store64(scratchGPR, buffer + bufferOffset);</span>
<span class="line-removed">198                 ++marshalledFPRs;</span>
<span class="line-removed">199                 break;</span>
<span class="line-removed">200             }</span>
<span class="line-removed">201             case F64: {</span>
<span class="line-removed">202                 FPRReg fprReg;</span>
<span class="line-removed">203                 if (marshalledFPRs &lt; wasmCC.m_fprArgs.size())</span>
<span class="line-removed">204                     fprReg = wasmCC.m_fprArgs[marshalledFPRs].fpr();</span>
<span class="line-removed">205                 else {</span>
<span class="line-removed">206                     // We&#39;ve already spilled all arguments, these registers are available as scratch.</span>
<span class="line-removed">207                     fprReg = FPRInfo::argumentFPR0;</span>
<span class="line-removed">208                     jit.loadDouble(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);</span>
<span class="line-removed">209                     frOffset += sizeof(Register);</span>
<span class="line-removed">210                 }</span>
<span class="line-removed">211                 jit.moveDoubleTo64(fprReg, scratchGPR);</span>
<span class="line-removed">212                 jit.store64(scratchGPR, buffer + bufferOffset);</span>
<span class="line-removed">213                 ++marshalledFPRs;</span>
<span class="line-removed">214                 break;</span>
<span class="line-removed">215             }</span>
<span class="line-removed">216             }</span>
<span class="line-removed">217 </span>
<span class="line-removed">218             bufferOffset += sizeof(Register);</span>
<span class="line-removed">219         }</span>
<span class="line-removed">220         jit.loadPtr(MacroAssembler::Address(MacroAssembler::stackPointerRegister), scratchGPR);</span>
<span class="line-removed">221         if (argCount) {</span>
<span class="line-removed">222             // The GC should not look at this buffer at all, these aren&#39;t JSValues.</span>
<span class="line-removed">223             jit.move(CCallHelpers::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::argumentGPR0);</span>
<span class="line-removed">224             jit.storePtr(CCallHelpers::TrustedImmPtr(nullptr), GPRInfo::argumentGPR0);</span>
<span class="line-removed">225         }</span>
<span class="line-removed">226 </span>
<span class="line-removed">227         uint64_t (*callFunc)(ExecState*, JSObject*, SignatureIndex, uint64_t*) =</span>
<span class="line-removed">228             [] (ExecState* exec, JSObject* callee, SignatureIndex signatureIndex, uint64_t* buffer) -&gt; uint64_t {</span>
<span class="line-removed">229                 VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">230                 NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed">231                 auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">232                 const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-removed">233                 MarkedArgumentBuffer args;</span>
<span class="line-removed">234                 for (unsigned argNum = 0; argNum &lt; signature.argumentCount(); ++argNum) {</span>
<span class="line-removed">235                     Type argType = signature.argument(argNum);</span>
<span class="line-removed">236                     JSValue arg;</span>
<span class="line-removed">237                     switch (argType) {</span>
<span class="line-removed">238                     case Void:</span>
<span class="line-removed">239                     case Func:</span>
<span class="line-removed">240                     case I64:</span>
<span class="line-removed">241                         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">242                     case I32:</span>
<span class="line-removed">243                         arg = jsNumber(static_cast&lt;int32_t&gt;(buffer[argNum]));</span>
<span class="line-removed">244                         break;</span>
<span class="line-removed">245                     case Funcref: {</span>
<span class="line-removed">246                         arg = JSValue::decode(buffer[argNum]);</span>
<span class="line-removed">247                         ASSERT(isWebAssemblyHostFunction(vm, arg) || arg.isNull());</span>
<span class="line-removed">248                         break;</span>
<span class="line-removed">249                     }</span>
<span class="line-removed">250                     case Anyref:</span>
<span class="line-removed">251                         arg = JSValue::decode(buffer[argNum]);</span>
<span class="line-removed">252                         break;</span>
<span class="line-removed">253                     case F32:</span>
<span class="line-removed">254                     case F64:</span>
<span class="line-removed">255                         arg = jsNumber(purifyNaN(bitwise_cast&lt;double&gt;(buffer[argNum])));</span>
<span class="line-removed">256                         break;</span>
<span class="line-removed">257                     }</span>
<span class="line-removed">258                     args.append(arg);</span>
<span class="line-removed">259                 }</span>
<span class="line-removed">260                 if (UNLIKELY(args.hasOverflowed())) {</span>
<span class="line-removed">261                     throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-removed">262                     return 0;</span>
<span class="line-removed">263                 }</span>
<span class="line-removed">264 </span>
<span class="line-removed">265                 CallData callData;</span>
<span class="line-removed">266                 CallType callType = callee-&gt;methodTable(vm)-&gt;getCallData(callee, callData);</span>
<span class="line-removed">267                 RELEASE_ASSERT(callType != CallType::None);</span>
<span class="line-removed">268                 JSValue result = call(exec, callee, callType, callData, jsUndefined(), args);</span>
<span class="line-removed">269                 RETURN_IF_EXCEPTION(throwScope, 0);</span>
<span class="line-removed">270 </span>
<span class="line-removed">271                 uint64_t realResult;</span>
<span class="line-removed">272                 switch (signature.returnType()) {</span>
<span class="line-removed">273                 case Func:</span>
<span class="line-removed">274                 case I64:</span>
<span class="line-removed">275                     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">276                     break;</span>
<span class="line-removed">277                 case Void:</span>
<span class="line-removed">278                     break;</span>
<span class="line-removed">279                 case I32: {</span>
<span class="line-removed">280                     realResult = static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(result.toInt32(exec)));</span>
<span class="line-removed">281                     break;</span>
<span class="line-removed">282                 }</span>
<span class="line-removed">283                 case Funcref: {</span>
<span class="line-removed">284                     realResult = JSValue::encode(result);</span>
<span class="line-removed">285                     ASSERT(result.isFunction(vm) || result.isNull());</span>
<span class="line-removed">286                     break;</span>
<span class="line-removed">287                 }</span>
<span class="line-removed">288                 case Anyref: {</span>
<span class="line-removed">289                     realResult = JSValue::encode(result);</span>
<span class="line-removed">290                     break;</span>
<span class="line-removed">291                 }</span>
<span class="line-removed">292                 case F64:</span>
<span class="line-removed">293                 case F32: {</span>
<span class="line-removed">294                     realResult = bitwise_cast&lt;uint64_t&gt;(result.toNumber(exec));</span>
<span class="line-removed">295                     break;</span>
<span class="line-removed">296                 }</span>
<span class="line-removed">297                 }</span>
<span class="line-removed">298 </span>
<span class="line-removed">299                 RETURN_IF_EXCEPTION(throwScope, 0);</span>
<span class="line-removed">300                 return realResult;</span>
<span class="line-removed">301             };</span>
<span class="line-removed">302 </span>
<span class="line-removed">303         jit.loadWasmContextInstance(GPRInfo::argumentGPR0);</span>
<span class="line-removed">304         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, Instance::offsetOfOwner()), GPRInfo::argumentGPR0);</span>
<span class="line-removed">305         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, JSWebAssemblyInstance::offsetOfCallee()), GPRInfo::argumentGPR0);</span>
<span class="line-removed">306         jit.storePtr(GPRInfo::argumentGPR0, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));</span>
<span class="line-removed">307 </span>
<span class="line-removed">308         materializeImportJSCell(jit, importIndex, GPRInfo::argumentGPR1);</span>
<span class="line-removed">309 </span>
<span class="line-removed">310         static_assert(GPRInfo::numberOfArgumentRegisters &gt;= 4, &quot;We rely on this with the call below.&quot;);</span>
<span class="line-removed">311         static_assert(sizeof(SignatureIndex) == sizeof(uint64_t), &quot;Following code assumes SignatureIndex is 64bit.&quot;);</span>
<span class="line-removed">312         jit.setupArguments&lt;decltype(callFunc)&gt;(GPRInfo::argumentGPR1, CCallHelpers::TrustedImm64(signatureIndex), CCallHelpers::TrustedImmPtr(buffer));</span>
<span class="line-removed">313         auto call = jit.call(OperationPtrTag);</span>
<span class="line-removed">314         auto noException = jit.emitExceptionCheck(*vm, AssemblyHelpers::InvertedExceptionCheck);</span>
<span class="line-removed">315 </span>
<span class="line-removed">316         // Exception here.</span>
<span class="line-removed">317         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);</span>
<span class="line-removed">318         jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);</span>
<span class="line-removed">319         void (*doUnwinding)(ExecState*) = [] (ExecState* exec) -&gt; void {</span>
<span class="line-removed">320             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">321             NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed">322             genericUnwind(vm, exec);</span>
<span class="line-removed">323             ASSERT(!!vm.callFrameForCatch);</span>
<span class="line-removed">324         };</span>
<span class="line-removed">325         auto exceptionCall = jit.call(OperationPtrTag);</span>
<span class="line-removed">326         jit.jumpToExceptionHandler(*vm);</span>
<span class="line-removed">327 </span>
<span class="line-removed">328         noException.link(&amp;jit);</span>
<span class="line-removed">329         switch (signature.returnType()) {</span>
<span class="line-removed">330         case F64: {</span>
<span class="line-removed">331             jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);</span>
<span class="line-removed">332             break;</span>
<span class="line-removed">333         }</span>
<span class="line-removed">334         case F32: {</span>
<span class="line-removed">335             jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);</span>
<span class="line-removed">336             jit.convertDoubleToFloat(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);</span>
<span class="line-removed">337             break;</span>
<span class="line-removed">338         }</span>
<span class="line-removed">339         default:</span>
<span class="line-removed">340             break;</span>
<span class="line-removed">341         }</span>
<span class="line-removed">342 </span>
<span class="line-removed">343         jit.emitFunctionEpilogue();</span>
<span class="line-removed">344         jit.ret();</span>
<span class="line-removed">345 </span>
<span class="line-removed">346         LinkBuffer linkBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);</span>
<span class="line-removed">347         if (UNLIKELY(linkBuffer.didFailToAllocate()))</span>
<span class="line-removed">348             return makeUnexpected(BindingFailure::OutOfMemory);</span>
<span class="line-removed">349 </span>
<span class="line-removed">350         linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(callFunc));</span>
<span class="line-removed">351         linkBuffer.link(exceptionCall, FunctionPtr&lt;OperationPtrTag&gt;(doUnwinding));</span>
<span class="line-removed">352 </span>
<span class="line-removed">353         return FINALIZE_CODE(linkBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript import[%i] %s&quot;, importIndex, signature.toString().ascii().data());</span>
<span class="line-removed">354     }</span>
<span class="line-removed">355 </span>
356     // Note: We don&#39;t need to perform a stack check here since WasmB3IRGenerator
357     // will do the stack check for us. Whenever it detects that it might make
358     // a call to this thunk, it&#39;ll make sure its stack check includes space
359     // for us here.
360 
361     const unsigned numberOfParameters = argCount + 1; // There is a &quot;this&quot; argument.
362     const unsigned numberOfRegsForCall = CallFrame::headerSizeInRegisters + numberOfParameters;
363     const unsigned numberOfBytesForCall = numberOfRegsForCall * sizeof(Register) - sizeof(CallerFrameAndPC);
<span class="line-modified">364     const unsigned stackOffset = WTF::roundUpToMultipleOf(stackAlignmentBytes(), numberOfBytesForCall);</span>
365     jit.subPtr(MacroAssembler::TrustedImm32(stackOffset), MacroAssembler::stackPointerRegister);
366     JIT::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));
367 
368     // FIXME make these loops which switch on Signature if there are many arguments on the stack. It&#39;ll otherwise be huge for huge signatures. https://bugs.webkit.org/show_bug.cgi?id=165547
369 
370     // First go through the integer parameters, freeing up their register for use afterwards.
371     {
372         unsigned marshalledGPRs = 0;
373         unsigned marshalledFPRs = 0;
374         unsigned calleeFrameOffset = CallFrameSlot::firstArgument * static_cast&lt;int&gt;(sizeof(Register));
375         unsigned frOffset = CallFrame::headerSizeInRegisters * static_cast&lt;int&gt;(sizeof(Register));
376         for (unsigned argNum = 0; argNum &lt; argCount; ++argNum) {
377             Type argType = signature.argument(argNum);
378             switch (argType) {
379             case Void:
380             case Func:
381             case I64:
382                 RELEASE_ASSERT_NOT_REACHED(); // Handled above.
383             case Anyref:
384             case Funcref:
385             case I32: {
386                 GPRReg gprReg;
<span class="line-modified">387                 if (marshalledGPRs &lt; wasmCC.m_gprArgs.size())</span>
<span class="line-modified">388                     gprReg = wasmCC.m_gprArgs[marshalledGPRs].gpr();</span>
389                 else {
390                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
391                     gprReg = GPRInfo::argumentGPR0;
392                     jit.load64(JIT::Address(GPRInfo::callFrameRegister, frOffset), gprReg);
393                     frOffset += sizeof(Register);
394                 }
395                 ++marshalledGPRs;
396                 if (argType == I32) {
397                     jit.zeroExtend32ToPtr(gprReg, gprReg); // Clear non-int32 and non-tag bits.
398                     jit.boxInt32(gprReg, JSValueRegs(gprReg), DoNotHaveTagRegisters);
399                 }
400                 jit.store64(gprReg, calleeFrame.withOffset(calleeFrameOffset));
401                 calleeFrameOffset += sizeof(Register);
402                 break;
403             }
404             case F32:
405             case F64:
406                 // Skipped: handled below.
<span class="line-modified">407                 if (marshalledFPRs &gt;= wasmCC.m_fprArgs.size())</span>
408                     frOffset += sizeof(Register);
409                 ++marshalledFPRs;
410                 calleeFrameOffset += sizeof(Register);
411                 break;
412             }
413         }
414     }
415 
416     {
417         // Integer registers have already been spilled, these are now available.
418         GPRReg doubleEncodeOffsetGPRReg = GPRInfo::argumentGPR0;
419         GPRReg scratch = GPRInfo::argumentGPR1;
420         bool hasMaterializedDoubleEncodeOffset = false;
421         auto materializeDoubleEncodeOffset = [&amp;hasMaterializedDoubleEncodeOffset, &amp;jit] (GPRReg dest) {
422             if (!hasMaterializedDoubleEncodeOffset) {
<span class="line-modified">423                 static_assert(DoubleEncodeOffset == 1ll &lt;&lt; 48, &quot;codegen assumes this below&quot;);</span>


424                 jit.move(JIT::TrustedImm32(1), dest);
<span class="line-modified">425                 jit.lshift64(JIT::TrustedImm32(48), dest);</span>

426                 hasMaterializedDoubleEncodeOffset = true;
427             }
428         };
429 
430         unsigned marshalledGPRs = 0;
431         unsigned marshalledFPRs = 0;
432         unsigned calleeFrameOffset = CallFrameSlot::firstArgument * static_cast&lt;int&gt;(sizeof(Register));
433         unsigned frOffset = CallFrame::headerSizeInRegisters * static_cast&lt;int&gt;(sizeof(Register));
434 
435         auto marshallFPR = [&amp;] (FPRReg fprReg) {
436             jit.purifyNaN(fprReg);
437             jit.moveDoubleTo64(fprReg, scratch);
438             materializeDoubleEncodeOffset(doubleEncodeOffsetGPRReg);
439             jit.add64(doubleEncodeOffsetGPRReg, scratch);
440             jit.store64(scratch, calleeFrame.withOffset(calleeFrameOffset));
441             calleeFrameOffset += sizeof(Register);
442             ++marshalledFPRs;
443         };
444 
445         for (unsigned argNum = 0; argNum &lt; argCount; ++argNum) {
446             Type argType = signature.argument(argNum);
447             switch (argType) {
448             case Void:
449             case Func:
450             case I64:
451                 RELEASE_ASSERT_NOT_REACHED(); // Handled above.
452             case Anyref:
453             case Funcref:
454             case I32:
455                 // Skipped: handled above.
<span class="line-modified">456                 if (marshalledGPRs &gt;= wasmCC.m_gprArgs.size())</span>
457                     frOffset += sizeof(Register);
458                 ++marshalledGPRs;
459                 calleeFrameOffset += sizeof(Register);
460                 break;
461             case F32: {
462                 FPRReg fprReg;
<span class="line-modified">463                 if (marshalledFPRs &lt; wasmCC.m_fprArgs.size())</span>
<span class="line-modified">464                     fprReg = wasmCC.m_fprArgs[marshalledFPRs].fpr();</span>
465                 else {
466                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
467                     fprReg = FPRInfo::argumentFPR0;
468                     jit.loadFloat(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);
469                     frOffset += sizeof(Register);
470                 }
471                 jit.convertFloatToDouble(fprReg, fprReg);
472                 marshallFPR(fprReg);
473                 break;
474             }
475             case F64: {
476                 FPRReg fprReg;
<span class="line-modified">477                 if (marshalledFPRs &lt; wasmCC.m_fprArgs.size())</span>
<span class="line-modified">478                     fprReg = wasmCC.m_fprArgs[marshalledFPRs].fpr();</span>
479                 else {
480                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
481                     fprReg = FPRInfo::argumentFPR0;
482                     jit.loadDouble(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);
483                     frOffset += sizeof(Register);
484                 }
485                 marshallFPR(fprReg);
486                 break;
487             }
488             }
489         }
490     }
491 
492     jit.loadWasmContextInstance(GPRInfo::argumentGPR0);
493     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, Instance::offsetOfOwner()), GPRInfo::argumentGPR0);
<span class="line-modified">494     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, JSWebAssemblyInstance::offsetOfCallee()), GPRInfo::argumentGPR0);</span>
495     jit.storePtr(GPRInfo::argumentGPR0, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
496 
497     GPRReg importJSCellGPRReg = GPRInfo::regT0; // Callee needs to be in regT0 for slow path below.
498 
<span class="line-modified">499     ASSERT(!wasmCC.m_calleeSaveRegisters.get(importJSCellGPRReg));</span>
500     materializeImportJSCell(jit, importIndex, importJSCellGPRReg);
501 
502     jit.store64(importJSCellGPRReg, calleeFrame.withOffset(CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
<span class="line-modified">503     jit.store32(JIT::TrustedImm32(numberOfParameters), calleeFrame.withOffset(CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset));</span>
<span class="line-modified">504     jit.store64(JIT::TrustedImm64(ValueUndefined), calleeFrame.withOffset(CallFrameSlot::thisArgument * static_cast&lt;int&gt;(sizeof(Register))));</span>
505 
506     // FIXME Tail call if the wasm return type is void and no registers were spilled. https://bugs.webkit.org/show_bug.cgi?id=165488
507 
508     CallLinkInfo* callLinkInfo = callLinkInfos.add();
509     callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, CodeOrigin(), importJSCellGPRReg);
510     JIT::DataLabelPtr targetToCheck;
511     JIT::TrustedImmPtr initialRightValue(nullptr);
512     JIT::Jump slowPath = jit.branchPtrWithPatch(MacroAssembler::NotEqual, importJSCellGPRReg, targetToCheck, initialRightValue);
513     JIT::Call fastCall = jit.nearCall();
514     JIT::Jump done = jit.jump();
515     slowPath.link(&amp;jit);
516     // Callee needs to be in regT0 here.
517     jit.move(MacroAssembler::TrustedImmPtr(callLinkInfo), GPRInfo::regT2); // Link info needs to be in regT2.



518     JIT::Call slowCall = jit.nearCall();
519     done.link(&amp;jit);
520 
521     CCallHelpers::JumpList exceptionChecks;
522 
<span class="line-modified">523     switch (signature.returnType()) {</span>
<span class="line-modified">524     case Void:</span>
<span class="line-modified">525         // Discard.</span>
<span class="line-modified">526         break;</span>
<span class="line-modified">527     case Func:</span>
<span class="line-modified">528         // For the JavaScript embedding, imports with these types in their signature return are a WebAssembly.Module validation error.</span>
<span class="line-modified">529         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-modified">530         break;</span>
<span class="line-modified">531     case I64: {</span>
<span class="line-modified">532         RELEASE_ASSERT_NOT_REACHED(); // Handled above.</span>
<span class="line-modified">533     }</span>
<span class="line-modified">534     case I32: {</span>
<span class="line-modified">535         CCallHelpers::JumpList done;</span>
<span class="line-modified">536         CCallHelpers::JumpList slowPath;</span>
<span class="line-modified">537 </span>
<span class="line-modified">538         int32_t (*convertToI32)(ExecState*, JSValue) = [] (ExecState* exec, JSValue v) -&gt; int32_t {</span>
<span class="line-modified">539             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">540             NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">541             return v.toInt32(exec);</span>
<span class="line-modified">542         };</span>
<span class="line-modified">543 </span>
<span class="line-modified">544         slowPath.append(jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters));</span>
<span class="line-modified">545         slowPath.append(jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters));</span>
<span class="line-modified">546         jit.zeroExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="line-modified">547         done.append(jit.jump());</span>
<span class="line-modified">548 </span>
<span class="line-modified">549         slowPath.link(&amp;jit);</span>
<span class="line-modified">550         jit.setupArguments&lt;decltype(convertToI32)&gt;(GPRInfo::returnValueGPR);</span>
<span class="line-modified">551         auto call = jit.call(OperationPtrTag);</span>
<span class="line-modified">552         exceptionChecks.append(jit.emitJumpIfException(*vm));</span>
<span class="line-modified">553 </span>
<span class="line-modified">554         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-modified">555             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(convertToI32));</span>
<span class="line-modified">556         });</span>
<span class="line-modified">557 </span>
<span class="line-modified">558         done.link(&amp;jit);</span>
<span class="line-modified">559         break;</span>
<span class="line-modified">560     }</span>
<span class="line-modified">561     case Funcref:</span>
<span class="line-modified">562     case Anyref:</span>
<span class="line-modified">563         break;</span>
<span class="line-modified">564     case F32: {</span>
<span class="line-modified">565         CCallHelpers::JumpList done;</span>
<span class="line-modified">566 </span>
<span class="line-modified">567         float (*convertToF32)(ExecState*, JSValue) = [] (ExecState* exec, JSValue v) -&gt; float {</span>
<span class="line-modified">568             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">569             NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">570             return static_cast&lt;float&gt;(v.toNumber(exec));</span>
<span class="line-modified">571         };</span>
<span class="line-modified">572 </span>
<span class="line-modified">573         auto notANumber = jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters);</span>
<span class="line-modified">574         auto isDouble = jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters);</span>
<span class="line-modified">575         // We&#39;re an int32</span>
<span class="line-modified">576         jit.signExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="line-modified">577         jit.convertInt64ToFloat(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);</span>
<span class="line-modified">578         done.append(jit.jump());</span>
<span class="line-modified">579 </span>
<span class="line-modified">580         isDouble.link(&amp;jit);</span>
<span class="line-modified">581         jit.move(JIT::TrustedImm64(TagTypeNumber), GPRInfo::returnValueGPR2);</span>
<span class="line-modified">582         jit.add64(GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);</span>
<span class="line-modified">583         jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);</span>
<span class="line-modified">584         jit.convertDoubleToFloat(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);</span>
<span class="line-modified">585         done.append(jit.jump());</span>
<span class="line-modified">586 </span>
<span class="line-modified">587         notANumber.link(&amp;jit);</span>
<span class="line-modified">588         jit.setupArguments&lt;decltype(convertToF32)&gt;(GPRInfo::returnValueGPR);</span>
<span class="line-modified">589         auto call = jit.call(OperationPtrTag);</span>
<span class="line-modified">590         exceptionChecks.append(jit.emitJumpIfException(*vm));</span>
<span class="line-modified">591 </span>
<span class="line-modified">592         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-modified">593             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(convertToF32));</span>
<span class="line-modified">594         });</span>
<span class="line-modified">595 </span>
<span class="line-modified">596         done.link(&amp;jit);</span>
<span class="line-modified">597         break;</span>
<span class="line-modified">598     }</span>
<span class="line-modified">599     case F64: {</span>
<span class="line-modified">600         CCallHelpers::JumpList done;</span>
<span class="line-modified">601 </span>
<span class="line-modified">602         double (*convertToF64)(ExecState*, JSValue) = [] (ExecState* exec, JSValue v) -&gt; double {</span>
<span class="line-modified">603             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">604             NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">605             return v.toNumber(exec);</span>
<span class="line-modified">606         };</span>
<span class="line-modified">607 </span>
<span class="line-modified">608         auto notANumber = jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters);</span>
<span class="line-modified">609         auto isDouble = jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters);</span>
<span class="line-modified">610         // We&#39;re an int32</span>
<span class="line-modified">611         jit.signExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="line-modified">612         jit.convertInt64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);</span>
<span class="line-modified">613         done.append(jit.jump());</span>
<span class="line-modified">614 </span>
<span class="line-modified">615         isDouble.link(&amp;jit);</span>
<span class="line-modified">616         jit.move(JIT::TrustedImm64(TagTypeNumber), GPRInfo::returnValueGPR2);</span>
<span class="line-modified">617         jit.add64(GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);</span>
<span class="line-modified">618         jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);</span>
<span class="line-modified">619         done.append(jit.jump());</span>
<span class="line-modified">620 </span>
<span class="line-modified">621         notANumber.link(&amp;jit);</span>
<span class="line-modified">622         jit.setupArguments&lt;decltype(convertToF64)&gt;(GPRInfo::returnValueGPR);</span>
<span class="line-modified">623         auto call = jit.call(OperationPtrTag);</span>
<span class="line-modified">624         exceptionChecks.append(jit.emitJumpIfException(*vm));</span>




625 
<span class="line-modified">626         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-modified">627             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(convertToF64));</span>
<span class="line-modified">628         });</span>
629 
<span class="line-modified">630         done.link(&amp;jit);</span>
<span class="line-modified">631         break;</span>
<span class="line-removed">632     }</span>
633     }
634 
635     jit.emitFunctionEpilogue();
636     jit.ret();
637 
638     if (!exceptionChecks.empty()) {
639         exceptionChecks.link(&amp;jit);
<span class="line-modified">640         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);</span>
641         jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
642         auto call = jit.call(OperationPtrTag);
<span class="line-modified">643         jit.jumpToExceptionHandler(*vm);</span>
<span class="line-removed">644 </span>
<span class="line-removed">645         void (*doUnwinding)(ExecState*) = [] (ExecState* exec) -&gt; void {</span>
<span class="line-removed">646             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">647             NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed">648             genericUnwind(vm, exec);</span>
<span class="line-removed">649             ASSERT(!!vm.callFrameForCatch);</span>
<span class="line-removed">650         };</span>
651 
652         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">653             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(doUnwinding));</span>
654         });
655     }
656 
657     LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);
658     if (UNLIKELY(patchBuffer.didFailToAllocate()))
659         return makeUnexpected(BindingFailure::OutOfMemory);
660 
<span class="line-modified">661     patchBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(vm-&gt;getCTIStub(linkCallThunkGenerator).code()));</span>
662     CodeLocationLabel&lt;JSInternalPtrTag&gt; callReturnLocation(patchBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall));
663     CodeLocationLabel&lt;JSInternalPtrTag&gt; hotPathBegin(patchBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck));
664     CodeLocationNearCall&lt;JSInternalPtrTag&gt; hotPathOther = patchBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall);
665     callLinkInfo-&gt;setCallLocations(callReturnLocation, hotPathBegin, hotPathOther);
666 
<span class="line-modified">667     return FINALIZE_CODE(patchBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript import[%i] %s&quot;, importIndex, signature.toString().ascii().data());</span>
<span class="line-removed">668 }</span>
<span class="line-removed">669 </span>
<span class="line-removed">670 void* wasmToJSException(ExecState* exec, Wasm::ExceptionType type, Instance* wasmInstance)</span>
<span class="line-removed">671 {</span>
<span class="line-removed">672     wasmInstance-&gt;storeTopCallFrame(exec);</span>
<span class="line-removed">673     JSWebAssemblyInstance* instance = wasmInstance-&gt;owner&lt;JSWebAssemblyInstance&gt;();</span>
<span class="line-removed">674     JSGlobalObject* globalObject = instance-&gt;globalObject();</span>
<span class="line-removed">675 </span>
<span class="line-removed">676     // Do not retrieve VM&amp; from ExecState since ExecState&#39;s callee is not a JSCell.</span>
<span class="line-removed">677     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-removed">678 </span>
<span class="line-removed">679     {</span>
<span class="line-removed">680         auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">681 </span>
<span class="line-removed">682         JSObject* error;</span>
<span class="line-removed">683         if (type == ExceptionType::StackOverflow)</span>
<span class="line-removed">684             error = createStackOverflowError(exec, globalObject);</span>
<span class="line-removed">685         else</span>
<span class="line-removed">686             error = JSWebAssemblyRuntimeError::create(exec, vm, globalObject-&gt;webAssemblyRuntimeErrorStructure(), Wasm::errorMessageForExceptionType(type));</span>
<span class="line-removed">687         throwException(exec, throwScope, error);</span>
<span class="line-removed">688     }</span>
<span class="line-removed">689 </span>
<span class="line-removed">690     genericUnwind(vm, exec);</span>
<span class="line-removed">691     ASSERT(!!vm.callFrameForCatch);</span>
<span class="line-removed">692     ASSERT(!!vm.targetMachinePCForThrow);</span>
<span class="line-removed">693     // FIXME: We could make this better:</span>
<span class="line-removed">694     // This is a total hack, but the llint (both op_catch and handleUncaughtException)</span>
<span class="line-removed">695     // require a cell in the callee field to load the VM. (The baseline JIT does not require</span>
<span class="line-removed">696     // this since it is compiled with a constant VM pointer.) We could make the calling convention</span>
<span class="line-removed">697     // for exceptions first load callFrameForCatch info call frame register before jumping</span>
<span class="line-removed">698     // to the exception handler. If we did this, we could remove this terrible hack.</span>
<span class="line-removed">699     // https://bugs.webkit.org/show_bug.cgi?id=170440</span>
<span class="line-removed">700     bitwise_cast&lt;uint64_t*&gt;(exec)[CallFrameSlot::callee] = bitwise_cast&lt;uint64_t&gt;(instance-&gt;webAssemblyToJSCallee());</span>
<span class="line-removed">701     return vm.targetMachinePCForThrow;</span>
702 }
703 
704 void emitThrowWasmToJSException(CCallHelpers&amp; jit, GPRReg wasmInstance, Wasm::ExceptionType type)
705 {
706     ASSERT(wasmInstance != GPRInfo::argumentGPR0);
707     jit.loadPtr(CCallHelpers::Address(wasmInstance, Wasm::Instance::offsetOfPointerToTopEntryFrame()), GPRInfo::argumentGPR0);
708     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0), GPRInfo::argumentGPR0);
709     jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(GPRInfo::argumentGPR0);
710     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
711     jit.move(CCallHelpers::TrustedImm32(static_cast&lt;int32_t&gt;(type)), GPRInfo::argumentGPR1);
712 
713     CCallHelpers::Call call = jit.call(OperationPtrTag);
714 
715     jit.farJump(GPRInfo::returnValueGPR, ExceptionHandlerPtrTag);
716     jit.breakpoint(); // We should not reach this.
717 
718     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">719         linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(Wasm::wasmToJSException));</span>
720     });
721 }
722 
723 } } // namespace JSC::Wasm
724 
725 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmToJS.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;FrameTracers.h&quot;
<span class="line-added"> 33 #include &quot;IteratorOperations.h&quot;</span>
 34 #include &quot;JITExceptions.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 #include &quot;JSWebAssemblyHelpers.h&quot;
 37 #include &quot;JSWebAssemblyInstance.h&quot;
 38 #include &quot;JSWebAssemblyRuntimeError.h&quot;
 39 #include &quot;LinkBuffer.h&quot;
 40 #include &quot;NativeErrorConstructor.h&quot;
 41 #include &quot;ThunkGenerators.h&quot;
 42 #include &quot;WasmCallingConvention.h&quot;
<span class="line-modified"> 43 #include &quot;WasmContextInlines.h&quot;</span>
 44 #include &quot;WasmExceptionType.h&quot;
 45 #include &quot;WasmInstance.h&quot;
<span class="line-added"> 46 #include &quot;WasmOperations.h&quot;</span>
 47 #include &quot;WasmSignatureInlines.h&quot;
 48 
<span class="line-added"> 49 #include &lt;wtf/FunctionTraits.h&gt;</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51 </span>
 52 namespace JSC { namespace Wasm {
 53 
 54 using JIT = CCallHelpers;
 55 
 56 static void materializeImportJSCell(JIT&amp; jit, unsigned importIndex, GPRReg result)
 57 {
 58     // We&#39;re calling out of the current WebAssembly.Instance. That Instance has a list of all its import functions.
 59     jit.loadWasmContextInstance(result);
 60     jit.loadPtr(JIT::Address(result, Instance::offsetOfImportFunction(importIndex)), result);
 61 }
 62 
<span class="line-modified"> 63 static Expected&lt;MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;, BindingFailure&gt; handleBadI64Use(VM&amp; vm, JIT&amp; jit, unsigned importIndex)</span>
 64 {
<span class="line-modified"> 65     jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);</span>
<span class="line-modified"> 66     jit.loadWasmContextInstance(GPRInfo::argumentGPR0);</span>










































 67 
<span class="line-modified"> 68     // Store Callee.</span>
<span class="line-modified"> 69     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, Instance::offsetOfOwner()), GPRInfo::argumentGPR0);</span>
<span class="line-modified"> 70     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, JSWebAssemblyInstance::offsetOfModule()), GPRInfo::argumentGPR1);</span>
<span class="line-added"> 71     jit.prepareCallOperation(vm);</span>
<span class="line-added"> 72     jit.storePtr(GPRInfo::argumentGPR1, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));</span>
 73 
<span class="line-modified"> 74     auto call = jit.call(OperationPtrTag);</span>
<span class="line-modified"> 75     jit.jumpToExceptionHandler(vm);</span>

 76 
<span class="line-modified"> 77     LinkBuffer linkBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);</span>
<span class="line-modified"> 78     if (UNLIKELY(linkBuffer.didFailToAllocate()))</span>
<span class="line-modified"> 79         return makeUnexpected(BindingFailure::OutOfMemory);</span>
 80 
<span class="line-modified"> 81     linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(operationWasmThrowBadI64));</span>
<span class="line-added"> 82     return FINALIZE_WASM_CODE(linkBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript invalid i64 use in import[%i]&quot;, importIndex);</span>
 83 }
 84 
<span class="line-modified"> 85 Expected&lt;MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;, BindingFailure&gt; wasmToJS(VM&amp; vm, Bag&lt;CallLinkInfo&gt;&amp; callLinkInfos, SignatureIndex signatureIndex, unsigned importIndex)</span>
 86 {
 87     // FIXME: This function doesn&#39;t properly abstract away the calling convention.
 88     // It&#39;d be super easy to do so: https://bugs.webkit.org/show_bug.cgi?id=169401
<span class="line-modified"> 89     const auto&amp; wasmCC = wasmCallingConvention();</span>
<span class="line-modified"> 90     const auto&amp; jsCC = jsCallingConvention();</span>
 91     const Signature&amp; signature = SignatureInformation::get(signatureIndex);
 92     unsigned argCount = signature.argumentCount();
 93     JIT jit;
 94 
<span class="line-added"> 95     CallInformation wasmCallInfo = wasmCC.callInformationFor(signature, CallRole::Callee);</span>
<span class="line-added"> 96     RegisterAtOffsetList savedResultRegisters = wasmCallInfo.computeResultsOffsetList();</span>
<span class="line-added"> 97 </span>
 98     // Note: WasmB3IRGenerator assumes that this stub treats SP as a callee save.
 99     // If we ever change this, we will also need to change WasmB3IRGenerator.
100 
101     // Below, we assume that the JS calling convention is always on the stack.
<span class="line-modified">102     ASSERT(!jsCC.gprArgs.size());</span>
<span class="line-modified">103     ASSERT(!jsCC.fprArgs.size());</span>
104 
105     jit.emitFunctionPrologue();
106     jit.store64(JIT::TrustedImm32(0), JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::codeBlock * static_cast&lt;int&gt;(sizeof(Register)))); // FIXME Stop using 0 as codeBlocks. https://bugs.webkit.org/show_bug.cgi?id=165321
107 
<span class="line-modified">108     if (wasmCallInfo.argumentsIncludeI64 || wasmCallInfo.resultsIncludeI64)</span>
<span class="line-modified">109         return handleBadI64Use(vm, jit, importIndex);</span>

110 
111     // Here we assume that the JS calling convention saves at least all the wasm callee saved. We therefore don&#39;t need to save and restore more registers since the wasm callee already took care of this.
<span class="line-modified">112     RegisterSet missingCalleeSaves = wasmCC.calleeSaveRegisters;</span>
<span class="line-modified">113     missingCalleeSaves.exclude(jsCC.calleeSaveRegisters);</span>
114     ASSERT(missingCalleeSaves.isEmpty());
115 















































































































































































































116     // Note: We don&#39;t need to perform a stack check here since WasmB3IRGenerator
117     // will do the stack check for us. Whenever it detects that it might make
118     // a call to this thunk, it&#39;ll make sure its stack check includes space
119     // for us here.
120 
121     const unsigned numberOfParameters = argCount + 1; // There is a &quot;this&quot; argument.
122     const unsigned numberOfRegsForCall = CallFrame::headerSizeInRegisters + numberOfParameters;
123     const unsigned numberOfBytesForCall = numberOfRegsForCall * sizeof(Register) - sizeof(CallerFrameAndPC);
<span class="line-modified">124     const unsigned stackOffset = WTF::roundUpToMultipleOf(stackAlignmentBytes(), std::max&lt;unsigned&gt;(numberOfBytesForCall, savedResultRegisters.size() * sizeof(CPURegister)));</span>
125     jit.subPtr(MacroAssembler::TrustedImm32(stackOffset), MacroAssembler::stackPointerRegister);
126     JIT::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));
127 
128     // FIXME make these loops which switch on Signature if there are many arguments on the stack. It&#39;ll otherwise be huge for huge signatures. https://bugs.webkit.org/show_bug.cgi?id=165547
129 
130     // First go through the integer parameters, freeing up their register for use afterwards.
131     {
132         unsigned marshalledGPRs = 0;
133         unsigned marshalledFPRs = 0;
134         unsigned calleeFrameOffset = CallFrameSlot::firstArgument * static_cast&lt;int&gt;(sizeof(Register));
135         unsigned frOffset = CallFrame::headerSizeInRegisters * static_cast&lt;int&gt;(sizeof(Register));
136         for (unsigned argNum = 0; argNum &lt; argCount; ++argNum) {
137             Type argType = signature.argument(argNum);
138             switch (argType) {
139             case Void:
140             case Func:
141             case I64:
142                 RELEASE_ASSERT_NOT_REACHED(); // Handled above.
143             case Anyref:
144             case Funcref:
145             case I32: {
146                 GPRReg gprReg;
<span class="line-modified">147                 if (marshalledGPRs &lt; wasmCC.gprArgs.size())</span>
<span class="line-modified">148                     gprReg = wasmCC.gprArgs[marshalledGPRs].gpr();</span>
149                 else {
150                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
151                     gprReg = GPRInfo::argumentGPR0;
152                     jit.load64(JIT::Address(GPRInfo::callFrameRegister, frOffset), gprReg);
153                     frOffset += sizeof(Register);
154                 }
155                 ++marshalledGPRs;
156                 if (argType == I32) {
157                     jit.zeroExtend32ToPtr(gprReg, gprReg); // Clear non-int32 and non-tag bits.
158                     jit.boxInt32(gprReg, JSValueRegs(gprReg), DoNotHaveTagRegisters);
159                 }
160                 jit.store64(gprReg, calleeFrame.withOffset(calleeFrameOffset));
161                 calleeFrameOffset += sizeof(Register);
162                 break;
163             }
164             case F32:
165             case F64:
166                 // Skipped: handled below.
<span class="line-modified">167                 if (marshalledFPRs &gt;= wasmCC.fprArgs.size())</span>
168                     frOffset += sizeof(Register);
169                 ++marshalledFPRs;
170                 calleeFrameOffset += sizeof(Register);
171                 break;
172             }
173         }
174     }
175 
176     {
177         // Integer registers have already been spilled, these are now available.
178         GPRReg doubleEncodeOffsetGPRReg = GPRInfo::argumentGPR0;
179         GPRReg scratch = GPRInfo::argumentGPR1;
180         bool hasMaterializedDoubleEncodeOffset = false;
181         auto materializeDoubleEncodeOffset = [&amp;hasMaterializedDoubleEncodeOffset, &amp;jit] (GPRReg dest) {
182             if (!hasMaterializedDoubleEncodeOffset) {
<span class="line-modified">183 #if CPU(ARM64)</span>
<span class="line-added">184                 jit.move(JIT::TrustedImm64(JSValue::DoubleEncodeOffset), dest);</span>
<span class="line-added">185 #else</span>
186                 jit.move(JIT::TrustedImm32(1), dest);
<span class="line-modified">187                 jit.lshift64(JIT::TrustedImm32(JSValue::DoubleEncodeOffsetBit), dest);</span>
<span class="line-added">188 #endif</span>
189                 hasMaterializedDoubleEncodeOffset = true;
190             }
191         };
192 
193         unsigned marshalledGPRs = 0;
194         unsigned marshalledFPRs = 0;
195         unsigned calleeFrameOffset = CallFrameSlot::firstArgument * static_cast&lt;int&gt;(sizeof(Register));
196         unsigned frOffset = CallFrame::headerSizeInRegisters * static_cast&lt;int&gt;(sizeof(Register));
197 
198         auto marshallFPR = [&amp;] (FPRReg fprReg) {
199             jit.purifyNaN(fprReg);
200             jit.moveDoubleTo64(fprReg, scratch);
201             materializeDoubleEncodeOffset(doubleEncodeOffsetGPRReg);
202             jit.add64(doubleEncodeOffsetGPRReg, scratch);
203             jit.store64(scratch, calleeFrame.withOffset(calleeFrameOffset));
204             calleeFrameOffset += sizeof(Register);
205             ++marshalledFPRs;
206         };
207 
208         for (unsigned argNum = 0; argNum &lt; argCount; ++argNum) {
209             Type argType = signature.argument(argNum);
210             switch (argType) {
211             case Void:
212             case Func:
213             case I64:
214                 RELEASE_ASSERT_NOT_REACHED(); // Handled above.
215             case Anyref:
216             case Funcref:
217             case I32:
218                 // Skipped: handled above.
<span class="line-modified">219                 if (marshalledGPRs &gt;= wasmCC.gprArgs.size())</span>
220                     frOffset += sizeof(Register);
221                 ++marshalledGPRs;
222                 calleeFrameOffset += sizeof(Register);
223                 break;
224             case F32: {
225                 FPRReg fprReg;
<span class="line-modified">226                 if (marshalledFPRs &lt; wasmCC.fprArgs.size())</span>
<span class="line-modified">227                     fprReg = wasmCC.fprArgs[marshalledFPRs].fpr();</span>
228                 else {
229                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
230                     fprReg = FPRInfo::argumentFPR0;
231                     jit.loadFloat(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);
232                     frOffset += sizeof(Register);
233                 }
234                 jit.convertFloatToDouble(fprReg, fprReg);
235                 marshallFPR(fprReg);
236                 break;
237             }
238             case F64: {
239                 FPRReg fprReg;
<span class="line-modified">240                 if (marshalledFPRs &lt; wasmCC.fprArgs.size())</span>
<span class="line-modified">241                     fprReg = wasmCC.fprArgs[marshalledFPRs].fpr();</span>
242                 else {
243                     // We&#39;ve already spilled all arguments, these registers are available as scratch.
244                     fprReg = FPRInfo::argumentFPR0;
245                     jit.loadDouble(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);
246                     frOffset += sizeof(Register);
247                 }
248                 marshallFPR(fprReg);
249                 break;
250             }
251             }
252         }
253     }
254 
255     jit.loadWasmContextInstance(GPRInfo::argumentGPR0);
256     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, Instance::offsetOfOwner()), GPRInfo::argumentGPR0);
<span class="line-modified">257     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, JSWebAssemblyInstance::offsetOfModule()), GPRInfo::argumentGPR0);</span>
258     jit.storePtr(GPRInfo::argumentGPR0, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
259 
260     GPRReg importJSCellGPRReg = GPRInfo::regT0; // Callee needs to be in regT0 for slow path below.
261 
<span class="line-modified">262     ASSERT(!wasmCC.calleeSaveRegisters.get(importJSCellGPRReg));</span>
263     materializeImportJSCell(jit, importIndex, importJSCellGPRReg);
264 
265     jit.store64(importJSCellGPRReg, calleeFrame.withOffset(CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
<span class="line-modified">266     jit.store32(JIT::TrustedImm32(numberOfParameters), calleeFrame.withOffset(CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset));</span>
<span class="line-modified">267     jit.store64(JIT::TrustedImm64(JSValue::ValueUndefined), calleeFrame.withOffset(CallFrameSlot::thisArgument * static_cast&lt;int&gt;(sizeof(Register))));</span>
268 
269     // FIXME Tail call if the wasm return type is void and no registers were spilled. https://bugs.webkit.org/show_bug.cgi?id=165488
270 
271     CallLinkInfo* callLinkInfo = callLinkInfos.add();
272     callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, CodeOrigin(), importJSCellGPRReg);
273     JIT::DataLabelPtr targetToCheck;
274     JIT::TrustedImmPtr initialRightValue(nullptr);
275     JIT::Jump slowPath = jit.branchPtrWithPatch(MacroAssembler::NotEqual, importJSCellGPRReg, targetToCheck, initialRightValue);
276     JIT::Call fastCall = jit.nearCall();
277     JIT::Jump done = jit.jump();
278     slowPath.link(&amp;jit);
279     // Callee needs to be in regT0 here.
280     jit.move(MacroAssembler::TrustedImmPtr(callLinkInfo), GPRInfo::regT2); // Link info needs to be in regT2.
<span class="line-added">281     jit.loadWasmContextInstance(GPRInfo::regT3);</span>
<span class="line-added">282     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT3, Instance::offsetOfOwner()), GPRInfo::regT3);</span>
<span class="line-added">283     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT3, JSWebAssemblyInstance::offsetOfGlobalObject()), GPRInfo::regT3);</span>
284     JIT::Call slowCall = jit.nearCall();
285     done.link(&amp;jit);
286 
287     CCallHelpers::JumpList exceptionChecks;
288 
<span class="line-modified">289     if (signature.returnCount() == 1) {</span>
<span class="line-modified">290         switch (signature.returnType(0)) {</span>
<span class="line-modified">291         case Void:</span>
<span class="line-modified">292         case Func:</span>
<span class="line-modified">293             // For the JavaScript embedding, imports with these types in their signature return are a WebAssembly.Module validation error.</span>
<span class="line-modified">294             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-modified">295             break;</span>
<span class="line-modified">296         case I64: {</span>
<span class="line-modified">297             RELEASE_ASSERT_NOT_REACHED(); // Handled above.</span>
<span class="line-modified">298         }</span>
<span class="line-modified">299         case I32: {</span>
<span class="line-modified">300             CCallHelpers::JumpList done;</span>
<span class="line-modified">301             CCallHelpers::JumpList slowPath;</span>
<span class="line-modified">302             GPRReg dest = wasmCallInfo.results[0].gpr();</span>
<span class="line-modified">303 </span>
<span class="line-modified">304             slowPath.append(jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters));</span>
<span class="line-modified">305             slowPath.append(jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters));</span>
<span class="line-modified">306             jit.zeroExtend32ToPtr(GPRInfo::returnValueGPR, dest);</span>
<span class="line-modified">307             done.append(jit.jump());</span>
<span class="line-modified">308 </span>
<span class="line-modified">309             slowPath.link(&amp;jit);</span>
<span class="line-modified">310             jit.setupArguments&lt;decltype(operationConvertToI32)&gt;(GPRInfo::returnValueGPR);</span>
<span class="line-modified">311             auto call = jit.call(OperationPtrTag);</span>
<span class="line-modified">312             exceptionChecks.append(jit.emitJumpIfException(vm));</span>
<span class="line-modified">313             jit.move(GPRInfo::returnValueGPR, dest);</span>
<span class="line-modified">314 </span>
<span class="line-modified">315             jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-modified">316                 linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(operationConvertToI32));</span>
<span class="line-modified">317             });</span>
<span class="line-modified">318 </span>
<span class="line-modified">319             done.link(&amp;jit);</span>
<span class="line-modified">320             break;</span>
<span class="line-modified">321         }</span>
<span class="line-modified">322         case Funcref:</span>
<span class="line-modified">323         case Anyref:</span>
<span class="line-modified">324             jit.move(GPRInfo::returnValueGPR, wasmCallInfo.results[0].gpr());</span>
<span class="line-modified">325             break;</span>
<span class="line-modified">326         case F32: {</span>
<span class="line-modified">327             CCallHelpers::JumpList done;</span>
<span class="line-modified">328             FPRReg dest = wasmCallInfo.results[0].fpr();</span>
<span class="line-modified">329 </span>
<span class="line-modified">330             auto notANumber = jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters);</span>
<span class="line-modified">331             auto isDouble = jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters);</span>
<span class="line-modified">332             // We&#39;re an int32</span>
<span class="line-modified">333             jit.signExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="line-modified">334             jit.convertInt64ToFloat(GPRInfo::returnValueGPR, dest);</span>
<span class="line-modified">335             done.append(jit.jump());</span>
<span class="line-modified">336 </span>
<span class="line-modified">337             isDouble.link(&amp;jit);</span>
<span class="line-modified">338             jit.move(JIT::TrustedImm64(JSValue::NumberTag), GPRInfo::returnValueGPR2);</span>
<span class="line-modified">339             jit.add64(GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);</span>
<span class="line-modified">340             jit.move64ToDouble(GPRInfo::returnValueGPR, dest);</span>
<span class="line-modified">341             jit.convertDoubleToFloat(dest, dest);</span>
<span class="line-modified">342             done.append(jit.jump());</span>
<span class="line-modified">343 </span>
<span class="line-modified">344             notANumber.link(&amp;jit);</span>
<span class="line-modified">345             jit.setupArguments&lt;decltype(operationConvertToF32)&gt;(GPRInfo::returnValueGPR);</span>
<span class="line-modified">346             auto call = jit.call(OperationPtrTag);</span>
<span class="line-modified">347             exceptionChecks.append(jit.emitJumpIfException(vm));</span>
<span class="line-modified">348             jit.move(FPRInfo::returnValueFPR , dest);</span>
<span class="line-modified">349 </span>
<span class="line-modified">350             jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-modified">351                 linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(operationConvertToF32));</span>
<span class="line-modified">352             });</span>
<span class="line-modified">353 </span>
<span class="line-modified">354             done.link(&amp;jit);</span>
<span class="line-modified">355             break;</span>
<span class="line-modified">356         }</span>
<span class="line-modified">357         case F64: {</span>
<span class="line-modified">358             CCallHelpers::JumpList done;</span>
<span class="line-modified">359             FPRReg dest = wasmCallInfo.results[0].fpr();</span>
<span class="line-modified">360 </span>
<span class="line-modified">361             auto notANumber = jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters);</span>
<span class="line-modified">362             auto isDouble = jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters);</span>
<span class="line-modified">363             // We&#39;re an int32</span>
<span class="line-modified">364             jit.signExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="line-modified">365             jit.convertInt64ToDouble(GPRInfo::returnValueGPR, dest);</span>
<span class="line-modified">366             done.append(jit.jump());</span>
<span class="line-modified">367 </span>
<span class="line-modified">368             isDouble.link(&amp;jit);</span>
<span class="line-modified">369             jit.move(JIT::TrustedImm64(JSValue::NumberTag), GPRInfo::returnValueGPR2);</span>
<span class="line-modified">370             jit.add64(GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);</span>
<span class="line-modified">371             jit.move64ToDouble(GPRInfo::returnValueGPR, dest);</span>
<span class="line-modified">372             done.append(jit.jump());</span>
<span class="line-modified">373 </span>
<span class="line-modified">374             notANumber.link(&amp;jit);</span>
<span class="line-modified">375             jit.setupArguments&lt;decltype(operationConvertToF64)&gt;(GPRInfo::returnValueGPR);</span>
<span class="line-modified">376             auto call = jit.call(OperationPtrTag);</span>
<span class="line-modified">377             exceptionChecks.append(jit.emitJumpIfException(vm));</span>
<span class="line-modified">378             jit.move(FPRInfo::returnValueFPR, dest);</span>
<span class="line-modified">379 </span>
<span class="line-modified">380             jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-modified">381                 linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(operationConvertToF64));</span>
<span class="line-modified">382             });</span>
<span class="line-modified">383 </span>
<span class="line-modified">384             done.link(&amp;jit);</span>
<span class="line-modified">385             break;</span>
<span class="line-modified">386         }</span>
<span class="line-modified">387         }</span>
<span class="line-modified">388     } else if (signature.returnCount() &gt; 1) {</span>
<span class="line-modified">389         GPRReg wasmContextInstanceGPR = PinnedRegisterInfo::get().wasmContextInstancePointer;</span>
<span class="line-modified">390         if (Context::useFastTLS()) {</span>
<span class="line-added">391             wasmContextInstanceGPR = GPRInfo::argumentGPR1;</span>
<span class="line-added">392             static_assert(std::is_same_v&lt;Wasm::Instance*, typename FunctionTraits&lt;decltype(operationIterateResults)&gt;::ArgumentType&lt;1&gt;&gt;, &quot;Instance should be the second parameter.&quot;);</span>
<span class="line-added">393             jit.loadWasmContextInstance(wasmContextInstanceGPR);</span>
<span class="line-added">394         }</span>
395 
<span class="line-modified">396         jit.setupArguments&lt;decltype(operationIterateResults)&gt;(wasmContextInstanceGPR, &amp;signature, GPRInfo::returnValueGPR, CCallHelpers::stackPointerRegister, CCallHelpers::framePointerRegister);</span>
<span class="line-modified">397         jit.callOperation(FunctionPtr&lt;OperationPtrTag&gt;(operationIterateResults));</span>
<span class="line-modified">398         exceptionChecks.append(jit.emitJumpIfException(vm));</span>
399 
<span class="line-modified">400         for (RegisterAtOffset location : savedResultRegisters)</span>
<span class="line-modified">401             jit.load64ToReg(CCallHelpers::Address(CCallHelpers::stackPointerRegister, location.offset()), location.reg());</span>

402     }
403 
404     jit.emitFunctionEpilogue();
405     jit.ret();
406 
407     if (!exceptionChecks.empty()) {
408         exceptionChecks.link(&amp;jit);
<span class="line-modified">409         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);</span>
410         jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
411         auto call = jit.call(OperationPtrTag);
<span class="line-modified">412         jit.jumpToExceptionHandler(vm);</span>







413 
414         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">415             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(operationWasmUnwind));</span>
416         });
417     }
418 
419     LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);
420     if (UNLIKELY(patchBuffer.didFailToAllocate()))
421         return makeUnexpected(BindingFailure::OutOfMemory);
422 
<span class="line-modified">423     patchBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(vm.getCTIStub(linkCallThunkGenerator).code()));</span>
424     CodeLocationLabel&lt;JSInternalPtrTag&gt; callReturnLocation(patchBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall));
425     CodeLocationLabel&lt;JSInternalPtrTag&gt; hotPathBegin(patchBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck));
426     CodeLocationNearCall&lt;JSInternalPtrTag&gt; hotPathOther = patchBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall);
427     callLinkInfo-&gt;setCallLocations(callReturnLocation, hotPathBegin, hotPathOther);
428 
<span class="line-modified">429     return FINALIZE_WASM_CODE(patchBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript import[%i] %s&quot;, importIndex, signature.toString().ascii().data());</span>


































430 }
431 
432 void emitThrowWasmToJSException(CCallHelpers&amp; jit, GPRReg wasmInstance, Wasm::ExceptionType type)
433 {
434     ASSERT(wasmInstance != GPRInfo::argumentGPR0);
435     jit.loadPtr(CCallHelpers::Address(wasmInstance, Wasm::Instance::offsetOfPointerToTopEntryFrame()), GPRInfo::argumentGPR0);
436     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0), GPRInfo::argumentGPR0);
437     jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(GPRInfo::argumentGPR0);
438     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
439     jit.move(CCallHelpers::TrustedImm32(static_cast&lt;int32_t&gt;(type)), GPRInfo::argumentGPR1);
440 
441     CCallHelpers::Call call = jit.call(OperationPtrTag);
442 
443     jit.farJump(GPRInfo::returnValueGPR, ExceptionHandlerPtrTag);
444     jit.breakpoint(); // We should not reach this.
445 
446     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">447         linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(Wasm::operationWasmToJSException));</span>
448     });
449 }
450 
451 } } // namespace JSC::Wasm
452 
453 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
</tr>
</table>
<center><a href="JSWebAssemblyTable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WasmToJS.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
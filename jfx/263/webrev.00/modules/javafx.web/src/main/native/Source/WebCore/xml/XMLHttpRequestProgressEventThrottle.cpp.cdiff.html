<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequestProgressEventThrottle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="XMLHttpRequestProgressEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XMLHttpRequestProgressEventThrottle.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequestProgressEventThrottle.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,68 ***</span>
  
  namespace WebCore {
  
  const Seconds XMLHttpRequestProgressEventThrottle::minimumProgressEventDispatchingInterval { 50_ms }; // 50 ms per specification.
  
<span class="line-modified">! XMLHttpRequestProgressEventThrottle::XMLHttpRequestProgressEventThrottle(EventTarget* target)</span>
      : m_target(target)
<span class="line-modified">!     , m_dispatchDeferredEventsTimer(*this, &amp;XMLHttpRequestProgressEventThrottle::dispatchDeferredEvents)</span>
  {
<span class="line-modified">!     ASSERT(target);</span>
  }
  
  XMLHttpRequestProgressEventThrottle::~XMLHttpRequestProgressEventThrottle() = default;
  
  void XMLHttpRequestProgressEventThrottle::dispatchThrottledProgressEvent(bool lengthComputable, unsigned long long loaded, unsigned long long total)
  {
      m_lengthComputable = lengthComputable;
      m_loaded = loaded;
      m_total = total;
  
<span class="line-modified">!     if (!m_target-&gt;hasEventListeners(eventNames().progressEvent))</span>
          return;
  
<span class="line-modified">!     if (m_deferEvents) {</span>
<span class="line-removed">-         // Only store the latest progress event while suspended.</span>
<span class="line-removed">-         m_deferredProgressEvent = XMLHttpRequestProgressEvent::create(eventNames().progressEvent, lengthComputable, loaded, total);</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!isActive()) {</span>
          // The timer is not active so the least frequent event for now is every byte. Just dispatch the event.
  
          // We should not have any throttled progress event.
<span class="line-modified">!         ASSERT(!m_hasThrottledProgressEvent);</span>
  
<span class="line-modified">!         dispatchEvent(XMLHttpRequestProgressEvent::create(eventNames().progressEvent, lengthComputable, loaded, total));</span>
<span class="line-modified">!         startRepeating(minimumProgressEventDispatchingInterval);</span>
<span class="line-modified">!         m_hasThrottledProgressEvent = false;</span>
          return;
      }
  
      // The timer is already active so minimumProgressEventDispatchingInterval is the least frequent event.
<span class="line-modified">!     m_hasThrottledProgressEvent = true;</span>
  }
  
  void XMLHttpRequestProgressEventThrottle::dispatchReadyStateChangeEvent(Event&amp; event, ProgressEventAction progressEventAction)
  {
      if (progressEventAction == FlushProgressEvent)
          flushProgressEvent();
  
<span class="line-modified">!     dispatchEvent(event);</span>
  }
  
<span class="line-modified">! void XMLHttpRequestProgressEventThrottle::dispatchEvent(Event&amp; event)</span>
  {
<span class="line-modified">!     if (m_deferEvents) {</span>
<span class="line-modified">!         if (m_deferredEvents.size() &gt; 1 &amp;&amp; event.type() == eventNames().readystatechangeEvent &amp;&amp; event.type() == m_deferredEvents.last()-&gt;type()) {</span>
              // Readystatechange events are state-less so avoid repeating two identical events in a row on resume.
              return;
          }
<span class="line-modified">!         m_deferredEvents.append(event);</span>
      } else
<span class="line-modified">!         m_target-&gt;dispatchEvent(event);</span>
  }
  
  void XMLHttpRequestProgressEventThrottle::dispatchProgressEvent(const AtomString&amp; type)
  {
      ASSERT(type == eventNames().loadstartEvent || type == eventNames().progressEvent || type == eventNames().loadEvent || type == eventNames().loadendEvent || type == eventNames().abortEvent || type == eventNames().errorEvent || type == eventNames().timeoutEvent);
<span class="line-new-header">--- 33,64 ---</span>
  
  namespace WebCore {
  
  const Seconds XMLHttpRequestProgressEventThrottle::minimumProgressEventDispatchingInterval { 50_ms }; // 50 ms per specification.
  
<span class="line-modified">! XMLHttpRequestProgressEventThrottle::XMLHttpRequestProgressEventThrottle(EventTarget&amp; target)</span>
      : m_target(target)
<span class="line-modified">!     , m_dispatchThrottledProgressEventTimer(target.scriptExecutionContext(), *this, &amp;XMLHttpRequestProgressEventThrottle::dispatchThrottledProgressEventTimerFired)</span>
<span class="line-added">+     , m_dispatchDeferredEventsAfterResumingTimer(target.scriptExecutionContext(), *this, &amp;XMLHttpRequestProgressEventThrottle::dispatchDeferredEventsAfterResuming)</span>
  {
<span class="line-modified">!     m_dispatchThrottledProgressEventTimer.suspendIfNeeded();</span>
<span class="line-added">+     m_dispatchDeferredEventsAfterResumingTimer.suspendIfNeeded();</span>
  }
  
  XMLHttpRequestProgressEventThrottle::~XMLHttpRequestProgressEventThrottle() = default;
  
  void XMLHttpRequestProgressEventThrottle::dispatchThrottledProgressEvent(bool lengthComputable, unsigned long long loaded, unsigned long long total)
  {
      m_lengthComputable = lengthComputable;
      m_loaded = loaded;
      m_total = total;
  
<span class="line-modified">!     if (!m_target.hasEventListeners(eventNames().progressEvent))</span>
          return;
  
<span class="line-modified">!     if (!m_shouldDeferEventsDueToSuspension &amp;&amp; !m_dispatchThrottledProgressEventTimer.isActive()) {</span>
          // The timer is not active so the least frequent event for now is every byte. Just dispatch the event.
  
          // We should not have any throttled progress event.
<span class="line-modified">!         ASSERT(!m_hasPendingThrottledProgressEvent);</span>
  
<span class="line-modified">!         dispatchEventWhenPossible(XMLHttpRequestProgressEvent::create(eventNames().progressEvent, lengthComputable, loaded, total));</span>
<span class="line-modified">!         m_dispatchThrottledProgressEventTimer.startRepeating(minimumProgressEventDispatchingInterval);</span>
<span class="line-modified">!         m_hasPendingThrottledProgressEvent = false;</span>
          return;
      }
  
      // The timer is already active so minimumProgressEventDispatchingInterval is the least frequent event.
<span class="line-modified">!     m_hasPendingThrottledProgressEvent = true;</span>
  }
  
  void XMLHttpRequestProgressEventThrottle::dispatchReadyStateChangeEvent(Event&amp; event, ProgressEventAction progressEventAction)
  {
      if (progressEventAction == FlushProgressEvent)
          flushProgressEvent();
  
<span class="line-modified">!     dispatchEventWhenPossible(event);</span>
  }
  
<span class="line-modified">! void XMLHttpRequestProgressEventThrottle::dispatchEventWhenPossible(Event&amp; event)</span>
  {
<span class="line-modified">!     if (m_shouldDeferEventsDueToSuspension) {</span>
<span class="line-modified">!         if (m_eventsDeferredDueToSuspension.size() &gt; 1 &amp;&amp; event.type() == eventNames().readystatechangeEvent &amp;&amp; event.type() == m_eventsDeferredDueToSuspension.last()-&gt;type()) {</span>
              // Readystatechange events are state-less so avoid repeating two identical events in a row on resume.
              return;
          }
<span class="line-modified">!         m_eventsDeferredDueToSuspension.append(event);</span>
      } else
<span class="line-modified">!         m_target.dispatchEvent(event);</span>
  }
  
  void XMLHttpRequestProgressEventThrottle::dispatchProgressEvent(const AtomString&amp; type)
  {
      ASSERT(type == eventNames().loadstartEvent || type == eventNames().progressEvent || type == eventNames().loadEvent || type == eventNames().loadendEvent || type == eventNames().abortEvent || type == eventNames().errorEvent || type == eventNames().timeoutEvent);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,105 ***</span>
          m_lengthComputable = false;
          m_loaded = 0;
          m_total = 0;
      }
  
<span class="line-modified">!     if (m_target-&gt;hasEventListeners(type))</span>
<span class="line-modified">!         dispatchEvent(XMLHttpRequestProgressEvent::create(type, m_lengthComputable, m_loaded, m_total));</span>
  }
  
  void XMLHttpRequestProgressEventThrottle::flushProgressEvent()
  {
<span class="line-modified">!     if (m_deferEvents &amp;&amp; m_deferredProgressEvent) {</span>
<span class="line-removed">-         // Move the progress event to the queue, to get it in the right order on resume.</span>
<span class="line-removed">-         m_deferredEvents.append(m_deferredProgressEvent.releaseNonNull());</span>
          return;
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!hasEventToDispatch())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     Ref&lt;Event&gt; event = XMLHttpRequestProgressEvent::create(eventNames().progressEvent, m_lengthComputable, m_loaded, m_total);</span>
<span class="line-removed">-     m_hasThrottledProgressEvent = false;</span>
  
      // We stop the timer as this is called when no more events are supposed to occur.
<span class="line-modified">!     stop();</span>
  
<span class="line-modified">!     dispatchEvent(WTFMove(event));</span>
  }
  
<span class="line-modified">! void XMLHttpRequestProgressEventThrottle::dispatchDeferredEvents()</span>
  {
<span class="line-modified">!     ASSERT(m_deferEvents);</span>
<span class="line-modified">!     m_deferEvents = false;</span>
  
      // Take over the deferred events before dispatching them which can potentially add more.
<span class="line-modified">!     auto deferredEvents = WTFMove(m_deferredEvents);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     RefPtr&lt;Event&gt; deferredProgressEvent = WTFMove(m_deferredProgressEvent);</span>
  
<span class="line-modified">!     for (auto&amp; deferredEvent : deferredEvents)</span>
<span class="line-removed">-         dispatchEvent(deferredEvent);</span>
  
<span class="line-modified">!     // The progress event will be in the m_deferredEvents vector if the load was finished while suspended.</span>
<span class="line-modified">!     // If not, just send the most up-to-date progress on resume.</span>
<span class="line-removed">-     if (deferredProgressEvent)</span>
<span class="line-removed">-         dispatchEvent(*deferredProgressEvent);</span>
  }
  
<span class="line-modified">! void XMLHttpRequestProgressEventThrottle::fired()</span>
  {
<span class="line-modified">!     ASSERT(isActive());</span>
<span class="line-modified">!     if (!hasEventToDispatch()) {</span>
          // No progress event was queued since the previous dispatch, we can safely stop the timer.
<span class="line-modified">!         stop();</span>
          return;
      }
  
<span class="line-modified">!     dispatchEvent(XMLHttpRequestProgressEvent::create(eventNames().progressEvent, m_lengthComputable, m_loaded, m_total));</span>
<span class="line-modified">!     m_hasThrottledProgressEvent = false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool XMLHttpRequestProgressEventThrottle::hasEventToDispatch() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_hasThrottledProgressEvent &amp;&amp; isActive();</span>
  }
  
  void XMLHttpRequestProgressEventThrottle::suspend()
  {
<span class="line-modified">!     // If re-suspended before deferred events have been dispatched, just stop the dispatch</span>
<span class="line-removed">-     // and continue the last suspend.</span>
<span class="line-removed">-     if (m_dispatchDeferredEventsTimer.isActive()) {</span>
<span class="line-removed">-         ASSERT(m_deferEvents);</span>
<span class="line-removed">-         m_dispatchDeferredEventsTimer.stop();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     ASSERT(!m_deferredProgressEvent);</span>
<span class="line-removed">-     ASSERT(m_deferredEvents.isEmpty());</span>
<span class="line-removed">-     ASSERT(!m_deferEvents);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_deferEvents = true;</span>
<span class="line-removed">-     // If we have a progress event waiting to be dispatched,</span>
<span class="line-removed">-     // just defer it.</span>
<span class="line-removed">-     if (hasEventToDispatch()) {</span>
<span class="line-removed">-         m_deferredProgressEvent = XMLHttpRequestProgressEvent::create(eventNames().progressEvent, m_lengthComputable, m_loaded, m_total);</span>
<span class="line-removed">-         m_hasThrottledProgressEvent = false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     stop();</span>
  }
  
  void XMLHttpRequestProgressEventThrottle::resume()
  {
<span class="line-modified">!     ASSERT(!m_hasThrottledProgressEvent);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     if (m_deferredEvents.isEmpty() &amp;&amp; !m_deferredProgressEvent) {</span>
<span class="line-removed">-         m_deferEvents = false;</span>
          return;
      }
  
<span class="line-modified">!     // Do not dispatch events inline here, since ScriptExecutionContext is iterating over</span>
<span class="line-removed">-     // the list of active DOM objects to resume them, and any activated JS event-handler</span>
<span class="line-removed">-     // could insert new active DOM objects to the list.</span>
<span class="line-removed">-     // m_deferEvents is kept true until all deferred events have been dispatched.</span>
<span class="line-removed">-     m_dispatchDeferredEventsTimer.startOneShot(0_s);</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 99,64 ---</span>
          m_lengthComputable = false;
          m_loaded = 0;
          m_total = 0;
      }
  
<span class="line-modified">!     if (m_target.hasEventListeners(type))</span>
<span class="line-modified">!         dispatchEventWhenPossible(XMLHttpRequestProgressEvent::create(type, m_lengthComputable, m_loaded, m_total));</span>
  }
  
  void XMLHttpRequestProgressEventThrottle::flushProgressEvent()
  {
<span class="line-modified">!     if (!m_hasPendingThrottledProgressEvent)</span>
          return;
  
<span class="line-added">+     m_hasPendingThrottledProgressEvent = false;</span>
      // We stop the timer as this is called when no more events are supposed to occur.
<span class="line-modified">!     m_dispatchThrottledProgressEventTimer.cancel();</span>
  
<span class="line-modified">!     dispatchEventWhenPossible(XMLHttpRequestProgressEvent::create(eventNames().progressEvent, m_lengthComputable, m_loaded, m_total));</span>
  }
  
<span class="line-modified">! void XMLHttpRequestProgressEventThrottle::dispatchDeferredEventsAfterResuming()</span>
  {
<span class="line-modified">!     ASSERT(m_shouldDeferEventsDueToSuspension);</span>
<span class="line-modified">!     m_shouldDeferEventsDueToSuspension = false;</span>
  
      // Take over the deferred events before dispatching them which can potentially add more.
<span class="line-modified">!     auto eventsDeferredDueToSuspension = WTFMove(m_eventsDeferredDueToSuspension);</span>
  
<span class="line-modified">!     flushProgressEvent();</span>
  
<span class="line-modified">!     for (auto&amp; deferredEvent : eventsDeferredDueToSuspension)</span>
<span class="line-modified">!         dispatchEventWhenPossible(deferredEvent);</span>
  }
  
<span class="line-modified">! void XMLHttpRequestProgressEventThrottle::dispatchThrottledProgressEventTimerFired()</span>
  {
<span class="line-modified">!     ASSERT(m_dispatchThrottledProgressEventTimer.isActive());</span>
<span class="line-modified">!     if (!m_hasPendingThrottledProgressEvent) {</span>
          // No progress event was queued since the previous dispatch, we can safely stop the timer.
<span class="line-modified">!         m_dispatchThrottledProgressEventTimer.cancel();</span>
          return;
      }
  
<span class="line-modified">!     dispatchEventWhenPossible(XMLHttpRequestProgressEvent::create(eventNames().progressEvent, m_lengthComputable, m_loaded, m_total));</span>
<span class="line-modified">!     m_hasPendingThrottledProgressEvent = false;</span>
  }
  
  void XMLHttpRequestProgressEventThrottle::suspend()
  {
<span class="line-modified">!     m_shouldDeferEventsDueToSuspension = true;</span>
  }
  
  void XMLHttpRequestProgressEventThrottle::resume()
  {
<span class="line-modified">!     if (m_eventsDeferredDueToSuspension.isEmpty() &amp;&amp; !m_hasPendingThrottledProgressEvent) {</span>
<span class="line-modified">!         m_shouldDeferEventsDueToSuspension = false;</span>
          return;
      }
  
<span class="line-modified">!     m_dispatchDeferredEventsAfterResumingTimer.startOneShot(0_s);</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="XMLHttpRequestProgressEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XMLHttpRequestProgressEventThrottle.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
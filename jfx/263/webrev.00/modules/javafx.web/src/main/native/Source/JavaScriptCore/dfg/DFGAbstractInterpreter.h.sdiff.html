<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreter.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGAbstractHeap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractInterpreterInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreter.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
165         if (useKind == UntypedUse)
166             return;
167         filterByType(edge, typeFilterFor(useKind));
168     }
169 
170     // Abstractly execute the effects of the given node. This changes the abstract
171     // state assuming that edges have already been filtered.
172     bool executeEffects(unsigned indexInBlock);
173     bool executeEffects(unsigned clobberLimit, Node*);
174 
175     void dump(PrintStream&amp; out) const;
176     void dump(PrintStream&amp; out);
177 
178     template&lt;typename T&gt;
179     FiltrationResult filter(T node, const RegisteredStructureSet&amp; set, SpeculatedType admittedTypes = SpecNone)
180     {
181         return filter(forNode(node), set, admittedTypes);
182     }
183 
184     template&lt;typename T&gt;
<span class="line-modified">185     FiltrationResult filterArrayModes(T node, ArrayModes arrayModes)</span>
186     {
<span class="line-modified">187         return filterArrayModes(forNode(node), arrayModes);</span>
188     }
189 
190     template&lt;typename T&gt;
191     FiltrationResult filter(T node, SpeculatedType type)
192     {
193         return filter(forNode(node), type);
194     }
195 
196     template&lt;typename T&gt;
197     FiltrationResult filterByValue(T node, FrozenValue value)
198     {
199         return filterByValue(forNode(node), value);
200     }
201 
202     template&lt;typename T&gt;
203     FiltrationResult filterClassInfo(T node, const ClassInfo* classInfo)
204     {
205         return filterClassInfo(forNode(node), classInfo);
206     }
207 
208     FiltrationResult filter(AbstractValue&amp;, const RegisteredStructureSet&amp;, SpeculatedType admittedTypes = SpecNone);
<span class="line-modified">209     FiltrationResult filterArrayModes(AbstractValue&amp;, ArrayModes);</span>
210     FiltrationResult filter(AbstractValue&amp;, SpeculatedType);
211     FiltrationResult filterByValue(AbstractValue&amp;, FrozenValue);
212     FiltrationResult filterClassInfo(AbstractValue&amp;, const ClassInfo*);
213 
214     PhiChildren* phiChildren() { return m_phiChildren.get(); }
215 
216     void filterICStatus(Node*);
217 
<span class="line-removed">218 private:</span>
219     void clobberWorld();
220     void didFoldClobberWorld();

221 
222     bool handleConstantBinaryBitwiseOp(Node*);
223 
224     template&lt;typename Functor&gt;
225     void forAllValues(unsigned indexInBlock, Functor&amp;);
226 
227     void clobberStructures();
228     void didFoldClobberStructures();
229 
230     void observeTransition(unsigned indexInBlock, RegisteredStructure from, RegisteredStructure to);

231     void observeTransitions(unsigned indexInBlock, const TransitionVector&amp;);

232 
233     enum BooleanResult {
234         UnknownBooleanResult,
235         DefinitelyFalse,
236         DefinitelyTrue
237     };
238     BooleanResult booleanResult(Node*, AbstractValue&amp;);
239 
240     void setBuiltInConstant(Node* node, FrozenValue value)
241     {
242         AbstractValue&amp; abstractValue = forNode(node);
243         abstractValue.set(m_graph, value, m_state.structureClobberState());
244         abstractValue.fixTypeForRepresentation(m_graph, node);
245     }
246 
247     void setConstant(Node* node, FrozenValue value)
248     {
249         setBuiltInConstant(node, value);
<span class="line-modified">250         m_state.setFoundConstants(true);</span>
251     }
252 
253     ALWAYS_INLINE void filterByType(Edge&amp; edge, SpeculatedType type);
254 
255     void verifyEdge(Node*, Edge);
256     void verifyEdges(Node*);
257     void executeDoubleUnaryOpEffects(Node*, double(*equivalentFunction)(double));
258 
259     bool handleConstantDivOp(Node*);
260 
261     CodeBlock* m_codeBlock;
262     Graph&amp; m_graph;
263     VM&amp; m_vm;
264     AbstractStateType&amp; m_state;
265     std::unique_ptr&lt;PhiChildren&gt; m_phiChildren;
266 };
267 
268 } } // namespace JSC::DFG
269 
270 #endif // ENABLE(DFG_JIT)
</pre>
</td>
<td>
<hr />
<pre>
165         if (useKind == UntypedUse)
166             return;
167         filterByType(edge, typeFilterFor(useKind));
168     }
169 
170     // Abstractly execute the effects of the given node. This changes the abstract
171     // state assuming that edges have already been filtered.
172     bool executeEffects(unsigned indexInBlock);
173     bool executeEffects(unsigned clobberLimit, Node*);
174 
175     void dump(PrintStream&amp; out) const;
176     void dump(PrintStream&amp; out);
177 
178     template&lt;typename T&gt;
179     FiltrationResult filter(T node, const RegisteredStructureSet&amp; set, SpeculatedType admittedTypes = SpecNone)
180     {
181         return filter(forNode(node), set, admittedTypes);
182     }
183 
184     template&lt;typename T&gt;
<span class="line-modified">185     FiltrationResult filterArrayModes(T node, ArrayModes arrayModes, SpeculatedType admittedTypes = SpecNone)</span>
186     {
<span class="line-modified">187         return filterArrayModes(forNode(node), arrayModes, admittedTypes);</span>
188     }
189 
190     template&lt;typename T&gt;
191     FiltrationResult filter(T node, SpeculatedType type)
192     {
193         return filter(forNode(node), type);
194     }
195 
196     template&lt;typename T&gt;
197     FiltrationResult filterByValue(T node, FrozenValue value)
198     {
199         return filterByValue(forNode(node), value);
200     }
201 
202     template&lt;typename T&gt;
203     FiltrationResult filterClassInfo(T node, const ClassInfo* classInfo)
204     {
205         return filterClassInfo(forNode(node), classInfo);
206     }
207 
208     FiltrationResult filter(AbstractValue&amp;, const RegisteredStructureSet&amp;, SpeculatedType admittedTypes = SpecNone);
<span class="line-modified">209     FiltrationResult filterArrayModes(AbstractValue&amp;, ArrayModes, SpeculatedType admittedTypes = SpecNone);</span>
210     FiltrationResult filter(AbstractValue&amp;, SpeculatedType);
211     FiltrationResult filterByValue(AbstractValue&amp;, FrozenValue);
212     FiltrationResult filterClassInfo(AbstractValue&amp;, const ClassInfo*);
213 
214     PhiChildren* phiChildren() { return m_phiChildren.get(); }
215 
216     void filterICStatus(Node*);
217 

218     void clobberWorld();
219     void didFoldClobberWorld();
<span class="line-added">220 private:</span>
221 
222     bool handleConstantBinaryBitwiseOp(Node*);
223 
224     template&lt;typename Functor&gt;
225     void forAllValues(unsigned indexInBlock, Functor&amp;);
226 
227     void clobberStructures();
228     void didFoldClobberStructures();
229 
230     void observeTransition(unsigned indexInBlock, RegisteredStructure from, RegisteredStructure to);
<span class="line-added">231 public:</span>
232     void observeTransitions(unsigned indexInBlock, const TransitionVector&amp;);
<span class="line-added">233 private:</span>
234 
235     enum BooleanResult {
236         UnknownBooleanResult,
237         DefinitelyFalse,
238         DefinitelyTrue
239     };
240     BooleanResult booleanResult(Node*, AbstractValue&amp;);
241 
242     void setBuiltInConstant(Node* node, FrozenValue value)
243     {
244         AbstractValue&amp; abstractValue = forNode(node);
245         abstractValue.set(m_graph, value, m_state.structureClobberState());
246         abstractValue.fixTypeForRepresentation(m_graph, node);
247     }
248 
249     void setConstant(Node* node, FrozenValue value)
250     {
251         setBuiltInConstant(node, value);
<span class="line-modified">252         m_state.setShouldTryConstantFolding(true);</span>
253     }
254 
255     ALWAYS_INLINE void filterByType(Edge&amp; edge, SpeculatedType type);
256 
257     void verifyEdge(Node*, Edge);
258     void verifyEdges(Node*);
259     void executeDoubleUnaryOpEffects(Node*, double(*equivalentFunction)(double));
260 
261     bool handleConstantDivOp(Node*);
262 
263     CodeBlock* m_codeBlock;
264     Graph&amp; m_graph;
265     VM&amp; m_vm;
266     AbstractStateType&amp; m_state;
267     std::unique_ptr&lt;PhiChildren&gt; m_phiChildren;
268 };
269 
270 } } // namespace JSC::DFG
271 
272 #endif // ENABLE(DFG_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGAbstractHeap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractInterpreterInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
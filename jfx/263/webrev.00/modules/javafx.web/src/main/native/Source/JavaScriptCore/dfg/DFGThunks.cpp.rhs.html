<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGThunks.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGThunks.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;DFGJITCode.h&quot;
 33 #include &quot;DFGOSRExit.h&quot;
 34 #include &quot;FPRInfo.h&quot;
 35 #include &quot;GPRInfo.h&quot;
 36 #include &quot;LinkBuffer.h&quot;
 37 #include &quot;MacroAssembler.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;DFGOSRExitCompilerCommon.h&quot;
 40 
 41 namespace JSC { namespace DFG {
 42 
<a name="1" id="anc1"></a>







 43 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; osrExitGenerationThunkGenerator(VM&amp; vm)
 44 {
<a name="2" id="anc2"></a><span class="line-modified"> 45     CCallHelpers jit(nullptr);</span>
 46 
 47     // This needs to happen before we use the scratch buffer because this function also uses the scratch buffer.
 48     adjustFrameAndStackInOSRExitCompilerThunk&lt;DFG::JITCode&gt;(jit, vm, JITType::DFGJIT);
 49 
 50     size_t scratchSize = sizeof(EncodedJSValue) * (GPRInfo::numberOfRegisters + FPRInfo::numberOfRegisters);
 51     ScratchBuffer* scratchBuffer = vm.scratchBufferForSize(scratchSize);
 52     EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 53 
 54     for (unsigned i = 0; i &lt; GPRInfo::numberOfRegisters; ++i) {
 55 #if USE(JSVALUE64)
 56         jit.store64(GPRInfo::toRegister(i), buffer + i);
 57 #else
 58         jit.store32(GPRInfo::toRegister(i), buffer + i);
 59 #endif
 60     }
 61     for (unsigned i = 0; i &lt; FPRInfo::numberOfRegisters; ++i) {
 62         jit.move(MacroAssembler::TrustedImmPtr(buffer + GPRInfo::numberOfRegisters + i), GPRInfo::regT0);
 63         jit.storeDouble(FPRInfo::toRegister(i), MacroAssembler::Address(GPRInfo::regT0));
 64     }
 65 
 66     // Tell GC mark phase how much of the scratch buffer is active during call.
 67     jit.move(MacroAssembler::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::regT0);
 68     jit.storePtr(MacroAssembler::TrustedImmPtr(scratchSize), MacroAssembler::Address(GPRInfo::regT0));
 69 
 70     // Set up one argument.
<a name="3" id="anc3"></a>


 71     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
<a name="4" id="anc4"></a><span class="line-modified"> 72     jit.prepareCallOperation(vm);</span>
 73 
 74     MacroAssembler::Call functionCall = jit.call(OperationPtrTag);
 75 
 76     jit.move(MacroAssembler::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::regT0);
 77     jit.storePtr(MacroAssembler::TrustedImmPtr(nullptr), MacroAssembler::Address(GPRInfo::regT0));
 78 
 79     for (unsigned i = 0; i &lt; FPRInfo::numberOfRegisters; ++i) {
 80         jit.move(MacroAssembler::TrustedImmPtr(buffer + GPRInfo::numberOfRegisters + i), GPRInfo::regT0);
 81         jit.loadDouble(MacroAssembler::Address(GPRInfo::regT0), FPRInfo::toRegister(i));
 82     }
 83     for (unsigned i = 0; i &lt; GPRInfo::numberOfRegisters; ++i) {
 84 #if USE(JSVALUE64)
 85         jit.load64(buffer + i, GPRInfo::toRegister(i));
 86 #else
 87         jit.load32(buffer + i, GPRInfo::toRegister(i));
 88 #endif
 89     }
 90 
 91     jit.farJump(MacroAssembler::AbsoluteAddress(&amp;vm.osrExitJumpDestination), OSRExitPtrTag);
 92 
 93     LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID);
 94 
<a name="5" id="anc5"></a><span class="line-modified"> 95     patchBuffer.link(functionCall, FunctionPtr&lt;OperationPtrTag&gt;(operationCompileOSRExit));</span>
 96 
 97     return FINALIZE_CODE(patchBuffer, JITThunkPtrTag, &quot;DFG OSR exit generation thunk&quot;);
 98 }
 99 
100 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; osrEntryThunkGenerator(VM&amp; vm)
101 {
102     AssemblyHelpers jit(nullptr);
103 
104     // We get passed the address of a scratch buffer in GPRInfo::returnValueGPR2.
105     // The first 8-byte slot of the buffer is the frame size. The second 8-byte slot
106     // is the pointer to where we are supposed to jump. The remaining bytes are
107     // the new call frame header followed by the locals.
108 
109     ptrdiff_t offsetOfFrameSize = 0; // This is the DFG frame count.
110     ptrdiff_t offsetOfTargetPC = offsetOfFrameSize + sizeof(EncodedJSValue);
111     ptrdiff_t offsetOfPayload = offsetOfTargetPC + sizeof(EncodedJSValue);
112     ptrdiff_t offsetOfLocals = offsetOfPayload + sizeof(Register) * CallFrame::headerSizeInRegisters;
113 
114     jit.move(GPRInfo::returnValueGPR2, GPRInfo::regT0);
115     jit.loadPtr(MacroAssembler::Address(GPRInfo::regT0, offsetOfFrameSize), GPRInfo::regT1); // Load the frame size.
116     jit.negPtr(GPRInfo::regT1, GPRInfo::regT2);
117     jit.getEffectiveAddress(MacroAssembler::BaseIndex(GPRInfo::callFrameRegister, GPRInfo::regT2, MacroAssembler::TimesEight), MacroAssembler::stackPointerRegister);
118 
119     MacroAssembler::Label loop = jit.label();
120     jit.subPtr(MacroAssembler::TrustedImm32(1), GPRInfo::regT1);
121     jit.negPtr(GPRInfo::regT1, GPRInfo::regT4);
122     jit.load32(MacroAssembler::BaseIndex(GPRInfo::regT0, GPRInfo::regT1, MacroAssembler::TimesEight, offsetOfLocals), GPRInfo::regT2);
123     jit.load32(MacroAssembler::BaseIndex(GPRInfo::regT0, GPRInfo::regT1, MacroAssembler::TimesEight, offsetOfLocals + sizeof(int32_t)), GPRInfo::regT3);
124     jit.store32(GPRInfo::regT2, MacroAssembler::BaseIndex(GPRInfo::callFrameRegister, GPRInfo::regT4, MacroAssembler::TimesEight, -static_cast&lt;intptr_t&gt;(sizeof(Register))));
125     jit.store32(GPRInfo::regT3, MacroAssembler::BaseIndex(GPRInfo::callFrameRegister, GPRInfo::regT4, MacroAssembler::TimesEight, -static_cast&lt;intptr_t&gt;(sizeof(Register)) + static_cast&lt;intptr_t&gt;(sizeof(int32_t))));
126     jit.branchPtr(MacroAssembler::NotEqual, GPRInfo::regT1, MacroAssembler::TrustedImmPtr(bitwise_cast&lt;void*&gt;(-static_cast&lt;intptr_t&gt;(CallFrame::headerSizeInRegisters)))).linkTo(loop, &amp;jit);
127 
128     jit.loadPtr(MacroAssembler::Address(GPRInfo::regT0, offsetOfTargetPC), GPRInfo::regT1);
129     MacroAssembler::Jump ok = jit.branchPtr(MacroAssembler::Above, GPRInfo::regT1, MacroAssembler::TrustedImmPtr(bitwise_cast&lt;void*&gt;(static_cast&lt;intptr_t&gt;(1000))));
130     jit.abortWithReason(DFGUnreasonableOSREntryJumpDestination);
131 
132     ok.link(&amp;jit);
133     jit.restoreCalleeSavesFromEntryFrameCalleeSavesBuffer(vm.topEntryFrame);
134     jit.emitMaterializeTagCheckRegisters();
135 
136     jit.farJump(GPRInfo::regT1, GPRInfo::callFrameRegister);
137 
138     LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID);
139     return FINALIZE_CODE(patchBuffer, JITThunkPtrTag, &quot;DFG OSR entry thunk&quot;);
140 }
141 
142 } } // namespace JSC::DFG
143 
144 #endif // ENABLE(DFG_JIT)
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/FontFaceSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FontFaceSet.h&quot;
 28 
<a name="1" id="anc1"></a><span class="line-added"> 29 #include &quot;DOMPromiseProxy.h&quot;</span>
 30 #include &quot;Document.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 31 #include &quot;EventLoop.h&quot;</span>
 32 #include &quot;FontFace.h&quot;
 33 #include &quot;FrameLoader.h&quot;
 34 #include &quot;JSDOMBinding.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 35 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 36 #include &quot;JSFontFace.h&quot;
 37 #include &quot;JSFontFaceSet.h&quot;
 38 #include &lt;wtf/IsoMallocInlines.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(FontFaceSet);
 43 
 44 Ref&lt;FontFaceSet&gt; FontFaceSet::create(Document&amp; document, const Vector&lt;RefPtr&lt;FontFace&gt;&gt;&amp; initialFaces)
 45 {
 46     Ref&lt;FontFaceSet&gt; result = adoptRef(*new FontFaceSet(document, initialFaces));
 47     result-&gt;suspendIfNeeded();
 48     return result;
 49 }
 50 
 51 Ref&lt;FontFaceSet&gt; FontFaceSet::create(Document&amp; document, CSSFontFaceSet&amp; backing)
 52 {
 53     Ref&lt;FontFaceSet&gt; result = adoptRef(*new FontFaceSet(document, backing));
 54     result-&gt;suspendIfNeeded();
 55     return result;
 56 }
 57 
 58 FontFaceSet::FontFaceSet(Document&amp; document, const Vector&lt;RefPtr&lt;FontFace&gt;&gt;&amp; initialFaces)
 59     : ActiveDOMObject(document)
 60     , m_backing(CSSFontFaceSet::create())
<a name="4" id="anc4"></a><span class="line-modified"> 61     , m_readyPromise(makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;FontFaceSet::readyPromiseResolve))</span>
 62 {
 63     m_backing-&gt;addClient(*this);
 64     for (auto&amp; face : initialFaces)
 65         add(*face);
 66 }
 67 
 68 FontFaceSet::FontFaceSet(Document&amp; document, CSSFontFaceSet&amp; backing)
 69     : ActiveDOMObject(document)
 70     , m_backing(backing)
<a name="5" id="anc5"></a><span class="line-modified"> 71     , m_readyPromise(makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;FontFaceSet::readyPromiseResolve))</span>
 72 {
 73     if (document.frame())
<a name="6" id="anc6"></a><span class="line-modified"> 74         m_isDocumentLoaded = document.loadEventFinished() &amp;&amp; !document.processingLoadEvent();</span>
 75 
<a name="7" id="anc7"></a><span class="line-modified"> 76     if (m_isDocumentLoaded &amp;&amp; !backing.hasActiveFontFaces())</span>
<span class="line-modified"> 77         m_readyPromise-&gt;resolve(*this);</span>
 78 
 79     m_backing-&gt;addClient(*this);
 80 }
 81 
 82 FontFaceSet::~FontFaceSet()
 83 {
 84     m_backing-&gt;removeClient(*this);
 85 }
 86 
 87 FontFaceSet::Iterator::Iterator(FontFaceSet&amp; set)
 88     : m_target(set)
 89 {
 90 }
 91 
 92 RefPtr&lt;FontFace&gt; FontFaceSet::Iterator::next()
 93 {
 94     if (m_index == m_target-&gt;size())
 95         return nullptr;
 96     return m_target-&gt;backing()[m_index++].wrapper();
 97 }
 98 
 99 FontFaceSet::PendingPromise::PendingPromise(LoadPromise&amp;&amp; promise)
<a name="8" id="anc8"></a><span class="line-modified">100     : promise(makeUniqueRef&lt;LoadPromise&gt;(WTFMove(promise)))</span>
101 {
102 }
103 
104 FontFaceSet::PendingPromise::~PendingPromise() = default;
105 
106 bool FontFaceSet::has(FontFace&amp; face) const
107 {
108     return m_backing-&gt;hasFace(face.backing());
109 }
110 
111 size_t FontFaceSet::size() const
112 {
113     return m_backing-&gt;faceCount();
114 }
115 
116 FontFaceSet&amp; FontFaceSet::add(FontFace&amp; face)
117 {
118     if (!m_backing-&gt;hasFace(face.backing()))
119         m_backing-&gt;add(face.backing());
120     return *this;
121 }
122 
123 bool FontFaceSet::remove(FontFace&amp; face)
124 {
125     bool result = m_backing-&gt;hasFace(face.backing());
126     if (result)
127         m_backing-&gt;remove(face.backing());
128     return result;
129 }
130 
131 void FontFaceSet::clear()
132 {
133     while (m_backing-&gt;faceCount())
134         m_backing-&gt;remove(m_backing.get()[0]);
135 }
136 
137 void FontFaceSet::load(const String&amp; font, const String&amp; text, LoadPromise&amp;&amp; promise)
138 {
139     auto matchingFacesResult = m_backing-&gt;matchingFacesExcludingPreinstalledFonts(font, text);
140     if (matchingFacesResult.hasException()) {
141         promise.reject(matchingFacesResult.releaseException());
142         return;
143     }
144     auto matchingFaces = matchingFacesResult.releaseReturnValue();
145 
146     if (matchingFaces.isEmpty()) {
147         promise.resolve({ });
148         return;
149     }
150 
151     for (auto&amp; face : matchingFaces)
152         face.get().load();
153 
154     for (auto&amp; face : matchingFaces) {
155         if (face.get().status() == CSSFontFace::Status::Failure) {
156             promise.reject(NetworkError);
157             return;
158         }
159     }
160 
161     auto pendingPromise = PendingPromise::create(WTFMove(promise));
162     bool waiting = false;
163 
164     for (auto&amp; face : matchingFaces) {
165         pendingPromise-&gt;faces.append(face.get().wrapper());
166         if (face.get().status() == CSSFontFace::Status::Success)
167             continue;
168         waiting = true;
169         ASSERT(face.get().existingWrapper());
170         m_pendingPromises.add(face.get().existingWrapper(), Vector&lt;Ref&lt;PendingPromise&gt;&gt;()).iterator-&gt;value.append(pendingPromise.copyRef());
171     }
172 
173     if (!waiting)
<a name="9" id="anc9"></a><span class="line-modified">174         pendingPromise-&gt;promise-&gt;resolve(pendingPromise-&gt;faces);</span>
175 }
176 
177 ExceptionOr&lt;bool&gt; FontFaceSet::check(const String&amp; family, const String&amp; text)
178 {
179     return m_backing-&gt;check(family, text);
180 }
181 
182 auto FontFaceSet::status() const -&gt; LoadStatus
183 {
184     switch (m_backing-&gt;status()) {
185     case CSSFontFaceSet::Status::Loading:
186         return LoadStatus::Loading;
187     case CSSFontFaceSet::Status::Loaded:
188         return LoadStatus::Loaded;
189     }
190     ASSERT_NOT_REACHED();
191     return LoadStatus::Loaded;
192 }
193 
<a name="10" id="anc10"></a>




194 void FontFaceSet::startedLoading()
195 {
196     // FIXME: Fire a &quot;loading&quot; event asynchronously.
197 }
198 
<a name="11" id="anc11"></a><span class="line-modified">199 void FontFaceSet::documentDidFinishLoading()</span>
200 {
<a name="12" id="anc12"></a><span class="line-modified">201     m_isDocumentLoaded = true;</span>
<span class="line-modified">202     if (!m_backing-&gt;hasActiveFontFaces() &amp;&amp; !m_readyPromise-&gt;isFulfilled())</span>
<span class="line-modified">203         m_readyPromise-&gt;resolve(*this);</span>
204 }
205 
206 void FontFaceSet::completedLoading()
207 {
<a name="13" id="anc13"></a><span class="line-modified">208     if (m_isDocumentLoaded &amp;&amp; !m_readyPromise-&gt;isFulfilled())</span>
<span class="line-modified">209         m_readyPromise-&gt;resolve(*this);</span>
210 }
211 
212 void FontFaceSet::faceFinished(CSSFontFace&amp; face, CSSFontFace::Status newStatus)
213 {
214     if (!face.existingWrapper())
215         return;
216 
<a name="14" id="anc14"></a><span class="line-modified">217     auto pendingPromises = m_pendingPromises.take(face.existingWrapper());</span>
<span class="line-modified">218     if (pendingPromises.isEmpty())</span>
219         return;
220 
<a name="15" id="anc15"></a><span class="line-modified">221     for (auto&amp; pendingPromise : pendingPromises) {</span>
222         if (pendingPromise-&gt;hasReachedTerminalState)
223             continue;
224         if (newStatus == CSSFontFace::Status::Success) {
225             if (pendingPromise-&gt;hasOneRef()) {
<a name="16" id="anc16"></a><span class="line-modified">226                 pendingPromise-&gt;promise-&gt;resolve(pendingPromise-&gt;faces);</span>
227                 pendingPromise-&gt;hasReachedTerminalState = true;
228             }
229         } else {
230             ASSERT(newStatus == CSSFontFace::Status::Failure);
<a name="17" id="anc17"></a><span class="line-modified">231             pendingPromise-&gt;promise-&gt;reject(NetworkError);</span>
232             pendingPromise-&gt;hasReachedTerminalState = true;
233         }
234     }
<a name="18" id="anc18"></a>

235 }
236 
237 FontFaceSet&amp; FontFaceSet::readyPromiseResolve()
238 {
239     return *this;
240 }
241 
242 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/ElementRareData.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ElementRareData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ErrorEvent.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/ElementRareData.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CustomElementReactionQueue.h&quot;
 25 #include &quot;DOMTokenList.h&quot;
 26 #include &quot;DatasetDOMStringMap.h&quot;
 27 #include &quot;IntersectionObserver.h&quot;

 28 #include &quot;NamedNodeMap.h&quot;
 29 #include &quot;NodeRareData.h&quot;
 30 #include &quot;PseudoElement.h&quot;
 31 #include &quot;RenderElement.h&quot;
 32 #include &quot;ResizeObserver.h&quot;
 33 #include &quot;ShadowRoot.h&quot;

 34 #include &quot;StylePropertyMap.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 inline IntSize defaultMinimumSizeForResizing()
 39 {
 40     return IntSize(LayoutUnit::max(), LayoutUnit::max());
 41 }
 42 
 43 class ElementRareData : public NodeRareData {
 44 public:
 45     explicit ElementRareData();
 46     ~ElementRareData();
 47 
 48     void setBeforePseudoElement(RefPtr&lt;PseudoElement&gt;&amp;&amp;);
 49     void setAfterPseudoElement(RefPtr&lt;PseudoElement&gt;&amp;&amp;);
 50 
 51     PseudoElement* beforePseudoElement() const { return m_beforePseudoElement.get(); }
 52     PseudoElement* afterPseudoElement() const { return m_afterPseudoElement.get(); }
 53 
</pre>
<hr />
<pre>
 82     void setComputedStyle(std::unique_ptr&lt;RenderStyle&gt; computedStyle) { m_computedStyle = WTFMove(computedStyle); }
 83 
 84     DOMTokenList* classList() const { return m_classList.get(); }
 85     void setClassList(std::unique_ptr&lt;DOMTokenList&gt; classList) { m_classList = WTFMove(classList); }
 86 
 87     DatasetDOMStringMap* dataset() const { return m_dataset.get(); }
 88     void setDataset(std::unique_ptr&lt;DatasetDOMStringMap&gt; dataset) { m_dataset = WTFMove(dataset); }
 89 
 90     LayoutSize minimumSizeForResizing() const { return m_minimumSizeForResizing; }
 91     void setMinimumSizeForResizing(LayoutSize size) { m_minimumSizeForResizing = size; }
 92 
 93     IntPoint savedLayerScrollPosition() const { return m_savedLayerScrollPosition; }
 94     void setSavedLayerScrollPosition(IntPoint position) { m_savedLayerScrollPosition = position; }
 95 
 96     bool hasPendingResources() const { return m_hasPendingResources; }
 97     void setHasPendingResources(bool has) { m_hasPendingResources = has; }
 98 
 99     bool hasCSSAnimation() const { return m_hasCSSAnimation; }
100     void setHasCSSAnimation(bool value) { m_hasCSSAnimation = value; }
101 



102     bool hasElementIdentifier() const { return m_hasElementIdentifier; }
103     void setHasElementIdentifier(bool value) { m_hasElementIdentifier = value; }
104 






105 #if ENABLE(INTERSECTION_OBSERVER)
106     IntersectionObserverData* intersectionObserverData() { return m_intersectionObserverData.get(); }
107     void setIntersectionObserverData(std::unique_ptr&lt;IntersectionObserverData&gt;&amp;&amp; data) { m_intersectionObserverData = WTFMove(data); }
108 #endif
109 
110 #if ENABLE(RESIZE_OBSERVER)
111     ResizeObserverData* resizeObserverData() { return m_resizeObserverData.get(); }
112     void setResizeObserverData(std::unique_ptr&lt;ResizeObserverData&gt;&amp;&amp; data) { m_resizeObserverData = WTFMove(data); }
113 #endif
114 
115 #if ENABLE(CSS_TYPED_OM)
116     StylePropertyMap* attributeStyleMap() { return m_attributeStyleMap.get(); }
117     void setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp; map) { m_attributeStyleMap = WTFMove(map); }
118 #endif
119 
120 #if DUMP_NODE_STATISTICS
121     OptionSet&lt;UseType&gt; useTypes() const
122     {
123         auto result = NodeRareData::useTypes();
124         if (m_tabIndexWasSetExplicitly)
</pre>
<hr />
<pre>
162     unsigned m_hasCSSAnimation : 1;
163     unsigned m_hasElementIdentifier : 1;
164 
165     LayoutSize m_minimumSizeForResizing;
166     IntPoint m_savedLayerScrollPosition;
167     std::unique_ptr&lt;RenderStyle&gt; m_computedStyle;
168 
169     std::unique_ptr&lt;DatasetDOMStringMap&gt; m_dataset;
170     std::unique_ptr&lt;DOMTokenList&gt; m_classList;
171     RefPtr&lt;ShadowRoot&gt; m_shadowRoot;
172     std::unique_ptr&lt;CustomElementReactionQueue&gt; m_customElementReactionQueue;
173     std::unique_ptr&lt;NamedNodeMap&gt; m_attributeMap;
174 #if ENABLE(INTERSECTION_OBSERVER)
175     std::unique_ptr&lt;IntersectionObserverData&gt; m_intersectionObserverData;
176 #endif
177 
178 #if ENABLE(RESIZE_OBSERVER)
179     std::unique_ptr&lt;ResizeObserverData&gt; m_resizeObserverData;
180 #endif
181 


182     RefPtr&lt;PseudoElement&gt; m_beforePseudoElement;
183     RefPtr&lt;PseudoElement&gt; m_afterPseudoElement;
184 
185 #if ENABLE(CSS_TYPED_OM)
186     RefPtr&lt;StylePropertyMap&gt; m_attributeStyleMap;
187 #endif
188 



189     void releasePseudoElement(PseudoElement*);
190 };
191 
192 inline ElementRareData::ElementRareData()
193     : NodeRareData(Type::Element)
194     , m_tabIndex(0)
195     , m_childIndex(0)
196     , m_tabIndexWasSetExplicitly(false)
197 #if ENABLE(FULLSCREEN_API)
198     , m_containsFullScreenElement(false)
199 #endif
200     , m_hasPendingResources(false)
201     , m_hasCSSAnimation(false)
202     , m_hasElementIdentifier(false)
203     , m_minimumSizeForResizing(defaultMinimumSizeForResizing())
204 {
205 }
206 
207 inline ElementRareData::~ElementRareData()
208 {
</pre>
</td>
<td>
<hr />
<pre>
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CustomElementReactionQueue.h&quot;
 25 #include &quot;DOMTokenList.h&quot;
 26 #include &quot;DatasetDOMStringMap.h&quot;
 27 #include &quot;IntersectionObserver.h&quot;
<span class="line-added"> 28 #include &quot;KeyframeEffectStack.h&quot;</span>
 29 #include &quot;NamedNodeMap.h&quot;
 30 #include &quot;NodeRareData.h&quot;
 31 #include &quot;PseudoElement.h&quot;
 32 #include &quot;RenderElement.h&quot;
 33 #include &quot;ResizeObserver.h&quot;
 34 #include &quot;ShadowRoot.h&quot;
<span class="line-added"> 35 #include &quot;SpaceSplitString.h&quot;</span>
 36 #include &quot;StylePropertyMap.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 inline IntSize defaultMinimumSizeForResizing()
 41 {
 42     return IntSize(LayoutUnit::max(), LayoutUnit::max());
 43 }
 44 
 45 class ElementRareData : public NodeRareData {
 46 public:
 47     explicit ElementRareData();
 48     ~ElementRareData();
 49 
 50     void setBeforePseudoElement(RefPtr&lt;PseudoElement&gt;&amp;&amp;);
 51     void setAfterPseudoElement(RefPtr&lt;PseudoElement&gt;&amp;&amp;);
 52 
 53     PseudoElement* beforePseudoElement() const { return m_beforePseudoElement.get(); }
 54     PseudoElement* afterPseudoElement() const { return m_afterPseudoElement.get(); }
 55 
</pre>
<hr />
<pre>
 84     void setComputedStyle(std::unique_ptr&lt;RenderStyle&gt; computedStyle) { m_computedStyle = WTFMove(computedStyle); }
 85 
 86     DOMTokenList* classList() const { return m_classList.get(); }
 87     void setClassList(std::unique_ptr&lt;DOMTokenList&gt; classList) { m_classList = WTFMove(classList); }
 88 
 89     DatasetDOMStringMap* dataset() const { return m_dataset.get(); }
 90     void setDataset(std::unique_ptr&lt;DatasetDOMStringMap&gt; dataset) { m_dataset = WTFMove(dataset); }
 91 
 92     LayoutSize minimumSizeForResizing() const { return m_minimumSizeForResizing; }
 93     void setMinimumSizeForResizing(LayoutSize size) { m_minimumSizeForResizing = size; }
 94 
 95     IntPoint savedLayerScrollPosition() const { return m_savedLayerScrollPosition; }
 96     void setSavedLayerScrollPosition(IntPoint position) { m_savedLayerScrollPosition = position; }
 97 
 98     bool hasPendingResources() const { return m_hasPendingResources; }
 99     void setHasPendingResources(bool has) { m_hasPendingResources = has; }
100 
101     bool hasCSSAnimation() const { return m_hasCSSAnimation; }
102     void setHasCSSAnimation(bool value) { m_hasCSSAnimation = value; }
103 
<span class="line-added">104     KeyframeEffectStack* keyframeEffectStack() { return m_keyframeEffectStack.get(); }</span>
<span class="line-added">105     void setKeyframeEffectStack(std::unique_ptr&lt;KeyframeEffectStack&gt;&amp;&amp; keyframeEffectStack) { m_keyframeEffectStack = WTFMove(keyframeEffectStack); }</span>
<span class="line-added">106 </span>
107     bool hasElementIdentifier() const { return m_hasElementIdentifier; }
108     void setHasElementIdentifier(bool value) { m_hasElementIdentifier = value; }
109 
<span class="line-added">110     DOMTokenList* partList() const { return m_partList.get(); }</span>
<span class="line-added">111     void setPartList(std::unique_ptr&lt;DOMTokenList&gt; partList) { m_partList = WTFMove(partList); }</span>
<span class="line-added">112 </span>
<span class="line-added">113     const SpaceSplitString&amp; partNames() const { return m_partNames; }</span>
<span class="line-added">114     void setPartNames(SpaceSplitString&amp;&amp; partNames) { m_partNames = WTFMove(partNames); }</span>
<span class="line-added">115 </span>
116 #if ENABLE(INTERSECTION_OBSERVER)
117     IntersectionObserverData* intersectionObserverData() { return m_intersectionObserverData.get(); }
118     void setIntersectionObserverData(std::unique_ptr&lt;IntersectionObserverData&gt;&amp;&amp; data) { m_intersectionObserverData = WTFMove(data); }
119 #endif
120 
121 #if ENABLE(RESIZE_OBSERVER)
122     ResizeObserverData* resizeObserverData() { return m_resizeObserverData.get(); }
123     void setResizeObserverData(std::unique_ptr&lt;ResizeObserverData&gt;&amp;&amp; data) { m_resizeObserverData = WTFMove(data); }
124 #endif
125 
126 #if ENABLE(CSS_TYPED_OM)
127     StylePropertyMap* attributeStyleMap() { return m_attributeStyleMap.get(); }
128     void setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp; map) { m_attributeStyleMap = WTFMove(map); }
129 #endif
130 
131 #if DUMP_NODE_STATISTICS
132     OptionSet&lt;UseType&gt; useTypes() const
133     {
134         auto result = NodeRareData::useTypes();
135         if (m_tabIndexWasSetExplicitly)
</pre>
<hr />
<pre>
173     unsigned m_hasCSSAnimation : 1;
174     unsigned m_hasElementIdentifier : 1;
175 
176     LayoutSize m_minimumSizeForResizing;
177     IntPoint m_savedLayerScrollPosition;
178     std::unique_ptr&lt;RenderStyle&gt; m_computedStyle;
179 
180     std::unique_ptr&lt;DatasetDOMStringMap&gt; m_dataset;
181     std::unique_ptr&lt;DOMTokenList&gt; m_classList;
182     RefPtr&lt;ShadowRoot&gt; m_shadowRoot;
183     std::unique_ptr&lt;CustomElementReactionQueue&gt; m_customElementReactionQueue;
184     std::unique_ptr&lt;NamedNodeMap&gt; m_attributeMap;
185 #if ENABLE(INTERSECTION_OBSERVER)
186     std::unique_ptr&lt;IntersectionObserverData&gt; m_intersectionObserverData;
187 #endif
188 
189 #if ENABLE(RESIZE_OBSERVER)
190     std::unique_ptr&lt;ResizeObserverData&gt; m_resizeObserverData;
191 #endif
192 
<span class="line-added">193     std::unique_ptr&lt;KeyframeEffectStack&gt; m_keyframeEffectStack;</span>
<span class="line-added">194 </span>
195     RefPtr&lt;PseudoElement&gt; m_beforePseudoElement;
196     RefPtr&lt;PseudoElement&gt; m_afterPseudoElement;
197 
198 #if ENABLE(CSS_TYPED_OM)
199     RefPtr&lt;StylePropertyMap&gt; m_attributeStyleMap;
200 #endif
201 
<span class="line-added">202     std::unique_ptr&lt;DOMTokenList&gt; m_partList;</span>
<span class="line-added">203     SpaceSplitString m_partNames;</span>
<span class="line-added">204 </span>
205     void releasePseudoElement(PseudoElement*);
206 };
207 
208 inline ElementRareData::ElementRareData()
209     : NodeRareData(Type::Element)
210     , m_tabIndex(0)
211     , m_childIndex(0)
212     , m_tabIndexWasSetExplicitly(false)
213 #if ENABLE(FULLSCREEN_API)
214     , m_containsFullScreenElement(false)
215 #endif
216     , m_hasPendingResources(false)
217     , m_hasCSSAnimation(false)
218     , m_hasElementIdentifier(false)
219     , m_minimumSizeForResizing(defaultMinimumSizeForResizing())
220 {
221 }
222 
223 inline ElementRareData::~ElementRareData()
224 {
</pre>
</td>
</tr>
</table>
<center><a href="ElementRareData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ErrorEvent.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
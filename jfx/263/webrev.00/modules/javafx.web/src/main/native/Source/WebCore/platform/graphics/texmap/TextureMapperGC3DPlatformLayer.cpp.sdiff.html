<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperGC3DPlatformLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BitmapTextureJava.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperGC3DPlatformLayer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperGC3DPlatformLayer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Lesser General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Lesser General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Lesser General Public
 15  *  License along with this library; if not, write to the Free
 16  *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  *  Boston, MA 02110-1301 USA
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;TextureMapperGC3DPlatformLayer.h&quot;
 22 
<span class="line-modified"> 23 #if ENABLE(GRAPHICS_CONTEXT_3D) &amp;&amp; USE(TEXTURE_MAPPER) &amp;&amp; !USE(NICOSIA)</span>
 24 
 25 #include &quot;BitmapTextureGL.h&quot;
 26 #include &quot;GLContext.h&quot;
 27 #include &quot;TextureMapperGLHeaders.h&quot;
 28 #include &quot;TextureMapperPlatformLayerBuffer.h&quot;
 29 #include &quot;TextureMapperPlatformLayerProxy.h&quot;
 30 
 31 namespace WebCore {
 32 
<span class="line-modified"> 33 TextureMapperGC3DPlatformLayer::TextureMapperGC3DPlatformLayer(GraphicsContext3D&amp; context, GraphicsContext3D::RenderStyle renderStyle)</span>
 34     : m_context(context)
 35 {
<span class="line-modified"> 36     switch (renderStyle) {</span>
<span class="line-modified"> 37     case GraphicsContext3D::RenderOffscreen:</span>
 38         m_glContext = GLContext::createOffscreenContext(&amp;PlatformDisplay::sharedDisplayForCompositing());
 39         break;
<span class="line-modified"> 40     case GraphicsContext3D::RenderDirectlyToHostWindow:</span>
 41         ASSERT_NOT_REACHED();
 42         break;
 43     }
 44 
 45 #if USE(COORDINATED_GRAPHICS)
 46     m_platformLayerProxy = adoptRef(new TextureMapperPlatformLayerProxy());
 47 #endif
 48 }
 49 
 50 TextureMapperGC3DPlatformLayer::~TextureMapperGC3DPlatformLayer()
 51 {
 52 #if !USE(COORDINATED_GRAPHICS)
 53     if (client())
 54         client()-&gt;platformLayerWillBeDestroyed();
 55 #endif
 56 }
 57 
 58 bool TextureMapperGC3DPlatformLayer::makeContextCurrent()
 59 {
 60     ASSERT(m_glContext);
 61     return m_glContext-&gt;makeContextCurrent();
 62 }
 63 
<span class="line-modified"> 64 PlatformGraphicsContext3D TextureMapperGC3DPlatformLayer::platformContext()</span>
 65 {
 66     ASSERT(m_glContext);
 67     return m_glContext-&gt;platformContext();
 68 }
 69 
 70 #if USE(COORDINATED_GRAPHICS)
 71 RefPtr&lt;TextureMapperPlatformLayerProxy&gt; TextureMapperGC3DPlatformLayer::proxy() const
 72 {
 73     return m_platformLayerProxy.copyRef();
 74 }
 75 
 76 void TextureMapperGC3DPlatformLayer::swapBuffersIfNeeded()
 77 {
 78     if (m_context.layerComposited())
 79         return;
 80 
 81     m_context.prepareTexture();
 82     IntSize textureSize(m_context.m_currentWidth, m_context.m_currentHeight);
 83     TextureMapperGL::Flags flags = TextureMapperGL::ShouldFlipTexture | (m_context.m_attrs.alpha ? TextureMapperGL::ShouldBlend : 0);
 84 
 85     {
 86         LockHolder holder(m_platformLayerProxy-&gt;lock());
 87         m_platformLayerProxy-&gt;pushNextBuffer(makeUnique&lt;TextureMapperPlatformLayerBuffer&gt;(m_context.m_compositorTexture, textureSize, flags, m_context.m_internalColorFormat));
 88     }
 89 
 90     m_context.markLayerComposited();
 91 }
 92 #else
 93 void TextureMapperGC3DPlatformLayer::paintToTextureMapper(TextureMapper&amp; textureMapper, const FloatRect&amp; targetRect, const TransformationMatrix&amp; matrix, float opacity)
 94 {
 95     ASSERT(m_glContext);
 96 
 97     m_context.markLayerComposited();
 98 
 99 #if USE(TEXTURE_MAPPER_GL)
<span class="line-modified">100     if (m_context.m_attrs.antialias &amp;&amp; m_context.m_state.boundFBO == m_context.m_multisampleFBO) {</span>

101         GLContext* previousActiveContext = GLContext::current();
102         if (previousActiveContext != m_glContext.get())
103             m_context.makeContextCurrent();
104 
105         m_context.resolveMultisamplingIfNecessary();
<span class="line-modified">106         ::glBindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_context.m_state.boundFBO);</span>
107 
108         if (previousActiveContext &amp;&amp; previousActiveContext != m_glContext.get())
109             previousActiveContext-&gt;makeContextCurrent();
110     }
111 
112     TextureMapperGL&amp; texmapGL = static_cast&lt;TextureMapperGL&amp;&gt;(textureMapper);
<span class="line-modified">113     TextureMapperGL::Flags flags = TextureMapperGL::ShouldFlipTexture | (m_context.m_attrs.alpha ? TextureMapperGL::ShouldBlend : 0);</span>
114     IntSize textureSize(m_context.m_currentWidth, m_context.m_currentHeight);
115     texmapGL.drawTexture(m_context.m_texture, flags, textureSize, targetRect, matrix, opacity);
116 #endif // USE(TEXTURE_MAPPER_GL)
117 }
118 #endif // USE(COORDINATED_GRAPHICS)
119 
120 } // namespace WebCore
121 
<span class="line-modified">122 #endif // ENABLE(GRAPHICS_CONTEXT_3D) &amp;&amp; USE(TEXTURE_MAPPER)</span>
</pre>
</td>
<td>
<hr />
<pre>
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Lesser General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Lesser General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Lesser General Public
 15  *  License along with this library; if not, write to the Free
 16  *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  *  Boston, MA 02110-1301 USA
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;TextureMapperGC3DPlatformLayer.h&quot;
 22 
<span class="line-modified"> 23 #if ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; USE(TEXTURE_MAPPER) &amp;&amp; !USE(NICOSIA)</span>
 24 
 25 #include &quot;BitmapTextureGL.h&quot;
 26 #include &quot;GLContext.h&quot;
 27 #include &quot;TextureMapperGLHeaders.h&quot;
 28 #include &quot;TextureMapperPlatformLayerBuffer.h&quot;
 29 #include &quot;TextureMapperPlatformLayerProxy.h&quot;
 30 
 31 namespace WebCore {
 32 
<span class="line-modified"> 33 TextureMapperGC3DPlatformLayer::TextureMapperGC3DPlatformLayer(GraphicsContextGLOpenGL&amp; context, GraphicsContextGLOpenGL::Destination destination)</span>
 34     : m_context(context)
 35 {
<span class="line-modified"> 36     switch (destination) {</span>
<span class="line-modified"> 37     case GraphicsContextGLOpenGL::Destination::Offscreen:</span>
 38         m_glContext = GLContext::createOffscreenContext(&amp;PlatformDisplay::sharedDisplayForCompositing());
 39         break;
<span class="line-modified"> 40     case GraphicsContextGLOpenGL::Destination::DirectlyToHostWindow:</span>
 41         ASSERT_NOT_REACHED();
 42         break;
 43     }
 44 
 45 #if USE(COORDINATED_GRAPHICS)
 46     m_platformLayerProxy = adoptRef(new TextureMapperPlatformLayerProxy());
 47 #endif
 48 }
 49 
 50 TextureMapperGC3DPlatformLayer::~TextureMapperGC3DPlatformLayer()
 51 {
 52 #if !USE(COORDINATED_GRAPHICS)
 53     if (client())
 54         client()-&gt;platformLayerWillBeDestroyed();
 55 #endif
 56 }
 57 
 58 bool TextureMapperGC3DPlatformLayer::makeContextCurrent()
 59 {
 60     ASSERT(m_glContext);
 61     return m_glContext-&gt;makeContextCurrent();
 62 }
 63 
<span class="line-modified"> 64 PlatformGraphicsContextGL TextureMapperGC3DPlatformLayer::platformContext() const</span>
 65 {
 66     ASSERT(m_glContext);
 67     return m_glContext-&gt;platformContext();
 68 }
 69 
 70 #if USE(COORDINATED_GRAPHICS)
 71 RefPtr&lt;TextureMapperPlatformLayerProxy&gt; TextureMapperGC3DPlatformLayer::proxy() const
 72 {
 73     return m_platformLayerProxy.copyRef();
 74 }
 75 
 76 void TextureMapperGC3DPlatformLayer::swapBuffersIfNeeded()
 77 {
 78     if (m_context.layerComposited())
 79         return;
 80 
 81     m_context.prepareTexture();
 82     IntSize textureSize(m_context.m_currentWidth, m_context.m_currentHeight);
 83     TextureMapperGL::Flags flags = TextureMapperGL::ShouldFlipTexture | (m_context.m_attrs.alpha ? TextureMapperGL::ShouldBlend : 0);
 84 
 85     {
 86         LockHolder holder(m_platformLayerProxy-&gt;lock());
 87         m_platformLayerProxy-&gt;pushNextBuffer(makeUnique&lt;TextureMapperPlatformLayerBuffer&gt;(m_context.m_compositorTexture, textureSize, flags, m_context.m_internalColorFormat));
 88     }
 89 
 90     m_context.markLayerComposited();
 91 }
 92 #else
 93 void TextureMapperGC3DPlatformLayer::paintToTextureMapper(TextureMapper&amp; textureMapper, const FloatRect&amp; targetRect, const TransformationMatrix&amp; matrix, float opacity)
 94 {
 95     ASSERT(m_glContext);
 96 
 97     m_context.markLayerComposited();
 98 
 99 #if USE(TEXTURE_MAPPER_GL)
<span class="line-modified">100     auto attrs = m_context.contextAttributes();</span>
<span class="line-added">101     if (attrs.antialias &amp;&amp; m_context.m_state.boundFBO == m_context.m_multisampleFBO) {</span>
102         GLContext* previousActiveContext = GLContext::current();
103         if (previousActiveContext != m_glContext.get())
104             m_context.makeContextCurrent();
105 
106         m_context.resolveMultisamplingIfNecessary();
<span class="line-modified">107         ::glBindFramebuffer(GraphicsContextGLOpenGL::FRAMEBUFFER, m_context.m_state.boundFBO);</span>
108 
109         if (previousActiveContext &amp;&amp; previousActiveContext != m_glContext.get())
110             previousActiveContext-&gt;makeContextCurrent();
111     }
112 
113     TextureMapperGL&amp; texmapGL = static_cast&lt;TextureMapperGL&amp;&gt;(textureMapper);
<span class="line-modified">114     TextureMapperGL::Flags flags = TextureMapperGL::ShouldFlipTexture | (attrs.alpha ? TextureMapperGL::ShouldBlend : 0);</span>
115     IntSize textureSize(m_context.m_currentWidth, m_context.m_currentHeight);
116     texmapGL.drawTexture(m_context.m_texture, flags, textureSize, targetRect, matrix, opacity);
117 #endif // USE(TEXTURE_MAPPER_GL)
118 }
119 #endif // USE(COORDINATED_GRAPHICS)
120 
121 } // namespace WebCore
122 
<span class="line-modified">123 #endif // ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; USE(TEXTURE_MAPPER)</span>
</pre>
</td>
</tr>
</table>
<center><a href="BitmapTextureJava.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperGC3DPlatformLayer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
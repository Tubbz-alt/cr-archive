<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/VMInspectorInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CellSize.h&quot;
 29 #include &quot;VMInspector.h&quot;
 30 #include &lt;wtf/Assertions.h&gt;
 31 
 32 namespace JSC {
 33 
 34 #define AUDIT_CONDITION(x) (x), #x
 35 #define AUDIT_VERIFY(action, verifier, cond, ...) do { \
 36         if (action == VerifierAction::ReleaseAssert) \
 37             RELEASE_ASSERT(cond, __VA_ARGS__); \
 38         else if (!verifier(AUDIT_CONDITION(cond), __VA_ARGS__)) \
 39             return false; \
 40     } while (false)
 41 
 42 template&lt;VMInspector::VerifierAction action, VMInspector::VerifyFunctor verifier&gt;
 43 bool VMInspector::verifyCellSize(VM&amp; vm, JSCell* cell, size_t allocatorCellSize)
 44 {
 45     Structure* structure = cell-&gt;structure(vm);
 46     const ClassInfo* classInfo = structure-&gt;classInfo();
 47     JSType cellType = cell-&gt;type();
 48     AUDIT_VERIFY(action, verifier, cellType == structure-&gt;m_blob.type(), cell, cellType, structure-&gt;m_blob.type());
 49 
 50     size_t size = cellSize(vm, cell);
 51     AUDIT_VERIFY(action, verifier, size &lt;= allocatorCellSize, cell, cellType, size, allocatorCellSize, classInfo-&gt;staticClassSize);
 52     if (isDynamicallySizedType(cellType))
 53         AUDIT_VERIFY(action, verifier, size &gt;= classInfo-&gt;staticClassSize, cell, cellType, size, classInfo-&gt;staticClassSize);
 54 
 55     return true;
 56 }
 57 
 58 template&lt;VMInspector::VerifierAction action, VMInspector::VerifyFunctor verifier&gt;
 59 bool VMInspector::verifyCell(VM&amp; vm, JSCell* cell)
 60 {
 61     size_t allocatorCellSize = 0;
 62     if (cell-&gt;isPreciseAllocation()) {
 63         PreciseAllocation&amp; preciseAllocation = cell-&gt;preciseAllocation();
 64         AUDIT_VERIFY(action, verifier, &amp;preciseAllocation.vm() == &amp;vm, cell, cell-&gt;type(), &amp;preciseAllocation.vm(), &amp;vm);
 65 
 66         bool isValidPreciseAllocation = false;
 67         for (auto* i : vm.heap.objectSpace().preciseAllocations()) {
 68             if (i == &amp;preciseAllocation) {
 69                 isValidPreciseAllocation = true;
 70                 break;
 71             }
 72         }
 73         AUDIT_VERIFY(action, verifier, isValidPreciseAllocation, cell, cell-&gt;type());
 74 
 75         allocatorCellSize = preciseAllocation.cellSize();
 76     } else {
 77         MarkedBlock&amp; block = cell-&gt;markedBlock();
 78         MarkedBlock::Handle&amp; blockHandle = block.handle();
 79         AUDIT_VERIFY(action, verifier, &amp;block.vm() == &amp;vm, cell, cell-&gt;type(), &amp;block.vm(), &amp;vm);
 80 
 81         uintptr_t blockStartAddress = reinterpret_cast&lt;uintptr_t&gt;(blockHandle.start());
 82         AUDIT_VERIFY(action, verifier, blockHandle.contains(cell), cell, cell-&gt;type(), blockStartAddress, blockHandle.end());
 83 
 84         uintptr_t cellAddress = reinterpret_cast&lt;uintptr_t&gt;(cell);
 85         uintptr_t cellOffset = cellAddress - blockStartAddress;
 86         allocatorCellSize = block.cellSize();
 87         bool cellIsProperlyAligned = !(cellOffset % allocatorCellSize);
 88         AUDIT_VERIFY(action, verifier, cellIsProperlyAligned, cell, cell-&gt;type(), allocatorCellSize);
 89     }
 90 
 91     auto cellType = cell-&gt;type();
 92     if (cell-&gt;type() != JSImmutableButterflyType)
 93         AUDIT_VERIFY(action, verifier, !Gigacage::contains(cell), cell, cellType);
 94 
 95     if (!verifyCellSize&lt;action, verifier&gt;(vm, cell, allocatorCellSize))
 96         return false;
 97 
 98     if (Gigacage::isEnabled(Gigacage::JSValue) &amp;&amp; cell-&gt;isObject()) {
 99         JSObject* object = asObject(cell);
100         const Butterfly* butterfly = object-&gt;butterfly();
101         AUDIT_VERIFY(action, verifier, !butterfly || Gigacage::isCaged(Gigacage::JSValue, butterfly), cell, cell-&gt;type(), butterfly);
102     }
103 
104     return true;
105 }
106 
107 #undef AUDIT_VERIFY
108 #undef AUDIT_CONDITION
109 
110 } // namespace JSC
    </pre>
  </body>
</html>
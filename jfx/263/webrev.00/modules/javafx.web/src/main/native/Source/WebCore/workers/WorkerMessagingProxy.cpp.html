<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerMessagingProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008-2017 Apple Inc. All Rights Reserved.
  3  * Copyright (C) 2009 Google Inc. All Rights Reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  *
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;WorkerMessagingProxy.h&quot;
 30 
 31 #include &quot;CacheStorageProvider.h&quot;
 32 #include &quot;ContentSecurityPolicy.h&quot;
 33 #include &quot;DOMWindow.h&quot;
 34 #include &quot;DedicatedWorkerGlobalScope.h&quot;
 35 #include &quot;DedicatedWorkerThread.h&quot;
 36 #include &quot;Document.h&quot;
 37 #include &quot;ErrorEvent.h&quot;
 38 #include &quot;EventNames.h&quot;
 39 #include &quot;MessageEvent.h&quot;
 40 #include &quot;Page.h&quot;
 41 #include &quot;ScriptExecutionContext.h&quot;
 42 #include &quot;Worker.h&quot;
 43 #include &quot;WorkerInspectorProxy.h&quot;
 44 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 45 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 46 #include &lt;wtf/MainThread.h&gt;
 47 #include &lt;wtf/RunLoop.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 WorkerGlobalScopeProxy&amp; WorkerGlobalScopeProxy::create(Worker&amp; worker)
 52 {
 53     return *new WorkerMessagingProxy(worker);
 54 }
 55 
 56 WorkerMessagingProxy::WorkerMessagingProxy(Worker&amp; workerObject)
 57     : m_scriptExecutionContext(workerObject.scriptExecutionContext())
 58     , m_inspectorProxy(makeUnique&lt;WorkerInspectorProxy&gt;(workerObject.identifier()))
 59     , m_workerObject(&amp;workerObject)
 60 {
 61     ASSERT((is&lt;Document&gt;(*m_scriptExecutionContext) &amp;&amp; isMainThread())
 62         || (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread().thread() == &amp;Thread::current()));
 63 
 64     // Nobody outside this class ref counts this object. The original ref
 65     // is balanced by the deref in workerGlobalScopeDestroyedInternal.
 66 }
 67 
 68 WorkerMessagingProxy::~WorkerMessagingProxy()
 69 {
 70     ASSERT(!m_workerObject);
 71     ASSERT((is&lt;Document&gt;(*m_scriptExecutionContext) &amp;&amp; isMainThread())
 72         || (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread().thread() == &amp;Thread::current()));
 73 }
 74 
 75 void WorkerMessagingProxy::startWorkerGlobalScope(const URL&amp; scriptURL, const String&amp; name, const String&amp; userAgent, bool isOnline, const String&amp; sourceCode, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders, bool shouldBypassMainWorldContentSecurityPolicy, MonotonicTime timeOrigin, ReferrerPolicy referrerPolicy, JSC::RuntimeFlags runtimeFlags)
 76 {
 77     // FIXME: This need to be revisited when we support nested worker one day
 78     ASSERT(m_scriptExecutionContext);
 79     Document&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
 80     WorkerThreadStartMode startMode = m_inspectorProxy-&gt;workerStartMode(*m_scriptExecutionContext.get());
 81     String identifier = m_inspectorProxy-&gt;identifier();
 82 
 83 #if ENABLE(INDEXED_DATABASE)
 84     IDBClient::IDBConnectionProxy* proxy = document.idbConnectionProxy();
 85 #else
 86     IDBClient::IDBConnectionProxy* proxy = nullptr;
 87 #endif
 88 
 89     SocketProvider* socketProvider = document.socketProvider();
 90 
 91     WorkerParameters params = { scriptURL, name, identifier, userAgent, isOnline, contentSecurityPolicyResponseHeaders, shouldBypassMainWorldContentSecurityPolicy, timeOrigin, referrerPolicy };
 92     auto thread = DedicatedWorkerThread::create(params, sourceCode, *this, *this, *this, startMode, document.topOrigin(), proxy, socketProvider, runtimeFlags);
 93 
 94     workerThreadCreated(thread.get());
 95     thread-&gt;start();
 96 
 97     m_inspectorProxy-&gt;workerStarted(m_scriptExecutionContext.get(), thread.ptr(), scriptURL);
 98 }
 99 
100 void WorkerMessagingProxy::postMessageToWorkerObject(MessageWithMessagePorts&amp;&amp; message)
101 {
102     m_scriptExecutionContext-&gt;postTask([this, message = WTFMove(message)] (ScriptExecutionContext&amp; context) mutable {
103         Worker* workerObject = this-&gt;workerObject();
104         if (!workerObject || askedToTerminate())
105             return;
106 
107         auto ports = MessagePort::entanglePorts(context, WTFMove(message.transferredPorts));
108         ActiveDOMObject::queueTaskToDispatchEvent(*workerObject, TaskSource::PostedMessageQueue, MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));
109     });
110 }
111 
112 void WorkerMessagingProxy::postMessageToWorkerGlobalScope(MessageWithMessagePorts&amp;&amp; message)
113 {
114     if (m_askedToTerminate)
115         return;
116 
117     ScriptExecutionContext::Task task([message = WTFMove(message)] (ScriptExecutionContext&amp; scriptContext) mutable {
118         ASSERT_WITH_SECURITY_IMPLICATION(scriptContext.isWorkerGlobalScope());
119         auto&amp; context = static_cast&lt;DedicatedWorkerGlobalScope&amp;&gt;(scriptContext);
120         auto ports = MessagePort::entanglePorts(scriptContext, WTFMove(message.transferredPorts));
121         context.dispatchEvent(MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));
122         context.thread().workerObjectProxy().confirmMessageFromWorkerObject(context.hasPendingActivity());
123     });
124 
125     if (m_workerThread) {
126         ++m_unconfirmedMessageCount;
127         m_workerThread-&gt;runLoop().postTask(WTFMove(task));
128     } else
129         m_queuedEarlyTasks.append(makeUnique&lt;ScriptExecutionContext::Task&gt;(WTFMove(task)));
130 }
131 
132 void WorkerMessagingProxy::suspendForBackForwardCache()
133 {
134     if (m_workerThread)
135         m_workerThread-&gt;suspend();
136     else
137         m_askedToSuspend = true;
138 }
139 
140 void WorkerMessagingProxy::resumeForBackForwardCache()
141 {
142     if (m_workerThread)
143         m_workerThread-&gt;resume();
144     else
145         m_askedToSuspend = false;
146 }
147 
148 void WorkerMessagingProxy::postTaskToLoader(ScriptExecutionContext::Task&amp;&amp; task)
149 {
150     // FIXME: In case of nested workers, this should go directly to the root Document context.
151     ASSERT(m_scriptExecutionContext-&gt;isDocument());
152     m_scriptExecutionContext-&gt;postTask(WTFMove(task));
153 }
154 
155 Ref&lt;CacheStorageConnection&gt; WorkerMessagingProxy::createCacheStorageConnection()
156 {
157     ASSERT(isMainThread());
158     auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
159     return document.page()-&gt;cacheStorageProvider().createCacheStorageConnection();
160 }
161 
162 bool WorkerMessagingProxy::postTaskForModeToWorkerGlobalScope(ScriptExecutionContext::Task&amp;&amp; task, const String&amp; mode)
163 {
164     if (m_askedToTerminate)
165         return false;
166 
167     ASSERT(m_workerThread);
168     m_workerThread-&gt;runLoop().postTaskForMode(WTFMove(task), mode);
169     return true;
170 }
171 
172 void WorkerMessagingProxy::postExceptionToWorkerObject(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL)
173 {
174     m_scriptExecutionContext-&gt;postTask([this, errorMessage = errorMessage.isolatedCopy(), sourceURL = sourceURL.isolatedCopy(), lineNumber, columnNumber] (ScriptExecutionContext&amp;) {
175         Worker* workerObject = this-&gt;workerObject();
176         if (!workerObject)
177             return;
178 
179         // We don&#39;t bother checking the askedToTerminate() flag here, because exceptions should *always* be reported even if the thread is terminated.
180         // This is intentionally different than the behavior in MessageWorkerTask, because terminated workers no longer deliver messages (section 4.6 of the WebWorker spec), but they do report exceptions.
181         ActiveDOMObject::queueTaskToDispatchEvent(*workerObject, TaskSource::DOMManipulation, ErrorEvent::create(errorMessage, sourceURL, lineNumber, columnNumber, { }));
182     });
183 }
184 
185 void WorkerMessagingProxy::postMessageToDebugger(const String&amp; message)
186 {
187     RunLoop::main().dispatch([this, protectedThis = makeRef(*this), message = message.isolatedCopy()] {
188         if (!m_mayBeDestroyed)
189             m_inspectorProxy-&gt;sendMessageFromWorkerToFrontend(message);
190     });
191 }
192 
193 void WorkerMessagingProxy::setResourceCachingDisabledByWebInspector(bool disabled)
194 {
195     postTaskToLoader([disabled] (ScriptExecutionContext&amp; context) {
196         ASSERT(isMainThread());
197         if (auto* page = downcast&lt;Document&gt;(context).page())
198             page-&gt;setResourceCachingDisabledByWebInspector(disabled);
199     });
200 }
201 
202 void WorkerMessagingProxy::workerThreadCreated(DedicatedWorkerThread&amp; workerThread)
203 {
204     m_workerThread = &amp;workerThread;
205 
206     if (m_askedToTerminate) {
207         // Worker.terminate() could be called from JS before the thread was created.
208         m_workerThread-&gt;stop(nullptr);
209     } else {
210         if (m_askedToSuspend) {
211             m_askedToSuspend = false;
212             m_workerThread-&gt;suspend();
213         }
214 
215         ASSERT(!m_unconfirmedMessageCount);
216         m_unconfirmedMessageCount = m_queuedEarlyTasks.size();
217         m_workerThreadHadPendingActivity = true; // Worker initialization means a pending activity.
218 
219         auto queuedEarlyTasks = WTFMove(m_queuedEarlyTasks);
220         for (auto&amp; task : queuedEarlyTasks)
221             m_workerThread-&gt;runLoop().postTask(WTFMove(*task));
222     }
223 }
224 
225 void WorkerMessagingProxy::workerObjectDestroyed()
226 {
227     m_workerObject = nullptr;
228     m_scriptExecutionContext-&gt;postTask([this] (ScriptExecutionContext&amp;) {
229         m_mayBeDestroyed = true;
230         if (m_workerThread)
231             terminateWorkerGlobalScope();
232         else
233             workerGlobalScopeDestroyedInternal();
234     });
235 }
236 
237 void WorkerMessagingProxy::notifyNetworkStateChange(bool isOnline)
238 {
239     if (m_askedToTerminate)
240         return;
241 
242     if (!m_workerThread)
243         return;
244 
245     m_workerThread-&gt;runLoop().postTask([isOnline] (ScriptExecutionContext&amp; context) {
246         auto&amp; globalScope = downcast&lt;WorkerGlobalScope&gt;(context);
247         globalScope.setIsOnline(isOnline);
248         globalScope.dispatchEvent(Event::create(isOnline ? eventNames().onlineEvent : eventNames().offlineEvent, Event::CanBubble::No, Event::IsCancelable::No));
249     });
250 }
251 
252 void WorkerMessagingProxy::workerGlobalScopeDestroyed()
253 {
254     m_scriptExecutionContext-&gt;postTask([this] (ScriptExecutionContext&amp;) {
255         workerGlobalScopeDestroyedInternal();
256     });
257 }
258 
259 void WorkerMessagingProxy::workerGlobalScopeClosed()
260 {
261     m_scriptExecutionContext-&gt;postTask([this] (ScriptExecutionContext&amp;) {
262         terminateWorkerGlobalScope();
263     });
264 }
265 
266 void WorkerMessagingProxy::workerGlobalScopeDestroyedInternal()
267 {
268     // This is always the last task to be performed, so the proxy is not needed for communication
269     // in either side any more. However, the Worker object may still exist, and it assumes that the proxy exists, too.
270     m_askedToTerminate = true;
271     m_workerThread = nullptr;
272 
273     m_inspectorProxy-&gt;workerTerminated();
274 
275     // This balances the original ref in construction.
276     if (m_mayBeDestroyed)
277         deref();
278 }
279 
280 void WorkerMessagingProxy::terminateWorkerGlobalScope()
281 {
282     if (m_askedToTerminate)
283         return;
284     m_askedToTerminate = true;
285 
286     m_inspectorProxy-&gt;workerTerminated();
287 
288     if (m_workerThread)
289         m_workerThread-&gt;stop(nullptr);
290 }
291 
292 void WorkerMessagingProxy::confirmMessageFromWorkerObject(bool hasPendingActivity)
293 {
294     m_scriptExecutionContext-&gt;postTask([this, hasPendingActivity] (ScriptExecutionContext&amp;) {
295         reportPendingActivityInternal(true, hasPendingActivity);
296     });
297 }
298 
299 void WorkerMessagingProxy::reportPendingActivity(bool hasPendingActivity)
300 {
301     m_scriptExecutionContext-&gt;postTask([this, hasPendingActivity] (ScriptExecutionContext&amp;) {
302         reportPendingActivityInternal(false, hasPendingActivity);
303     });
304 }
305 
306 void WorkerMessagingProxy::reportPendingActivityInternal(bool confirmingMessage, bool hasPendingActivity)
307 {
308     if (confirmingMessage &amp;&amp; !m_askedToTerminate) {
309         ASSERT(m_unconfirmedMessageCount);
310         --m_unconfirmedMessageCount;
311     }
312 
313     m_workerThreadHadPendingActivity = hasPendingActivity;
314 }
315 
316 bool WorkerMessagingProxy::hasPendingActivity() const
317 {
318     return (m_unconfirmedMessageCount || m_workerThreadHadPendingActivity) &amp;&amp; !m_askedToTerminate;
319 }
320 
321 } // namespace WebCore
    </pre>
  </body>
</html>
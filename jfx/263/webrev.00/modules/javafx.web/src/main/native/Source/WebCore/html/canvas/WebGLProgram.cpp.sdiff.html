<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLProgram.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLProgram.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLProgram.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLProgram.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 


 31 #include &quot;WebGLContextGroup.h&quot;
 32 #include &quot;WebGLRenderingContextBase.h&quot;
 33 #include &quot;WebGLShader.h&quot;
<span class="line-removed"> 34 #include &lt;wtf/HashMap.h&gt;</span>
 35 #include &lt;wtf/Lock.h&gt;
 36 #include &lt;wtf/NeverDestroyed.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 HashMap&lt;WebGLProgram*, WebGLRenderingContextBase*&gt;&amp; WebGLProgram::instances(const LockHolder&amp;)
 41 {
 42     static NeverDestroyed&lt;HashMap&lt;WebGLProgram*, WebGLRenderingContextBase*&gt;&gt; instances;
 43     return instances;
 44 }
 45 
 46 Lock&amp; WebGLProgram::instancesMutex()
 47 {
 48     static LazyNeverDestroyed&lt;Lock&gt; mutex;
 49     static std::once_flag initializeMutex;
 50     std::call_once(initializeMutex, [] {
 51         mutex.construct();
 52     });
 53     return mutex.get();
 54 }
 55 
 56 Ref&lt;WebGLProgram&gt; WebGLProgram::create(WebGLRenderingContextBase&amp; ctx)
 57 {
 58     return adoptRef(*new WebGLProgram(ctx));
 59 }
 60 
 61 WebGLProgram::WebGLProgram(WebGLRenderingContextBase&amp; ctx)
 62     : WebGLSharedObject(ctx)

 63 {


 64     {
 65         LockHolder lock(instancesMutex());
 66         instances(lock).add(this, &amp;ctx);
 67     }
 68 
<span class="line-modified"> 69     setObject(ctx.graphicsContext3D()-&gt;createProgram());</span>
 70 }
 71 
 72 WebGLProgram::~WebGLProgram()
 73 {


 74     deleteObject(0);
 75 
 76     {
 77         LockHolder lock(instancesMutex());
 78         ASSERT(instances(lock).contains(this));
 79         instances(lock).remove(this);
 80     }
 81 }
 82 
<span class="line-modified"> 83 void WebGLProgram::deleteObjectImpl(GraphicsContext3D* context3d, Platform3DObject obj)</span>







 84 {
 85     context3d-&gt;deleteProgram(obj);
 86     if (m_vertexShader) {
 87         m_vertexShader-&gt;onDetached(context3d);
 88         m_vertexShader = nullptr;
 89     }
 90     if (m_fragmentShader) {
 91         m_fragmentShader-&gt;onDetached(context3d);
 92         m_fragmentShader = nullptr;
 93     }
 94 }
 95 
 96 unsigned WebGLProgram::numActiveAttribLocations()
 97 {
 98     cacheInfoIfNeeded();
 99     return m_activeAttribLocations.size();
100 }
101 
<span class="line-modified">102 GC3Dint WebGLProgram::getActiveAttribLocation(GC3Duint index)</span>
103 {
104     cacheInfoIfNeeded();
105     if (index &gt;= numActiveAttribLocations())
106         return -1;
107     return m_activeAttribLocations[index];
108 }
109 
110 bool WebGLProgram::isUsingVertexAttrib0()
111 {
112     cacheInfoIfNeeded();
113     for (unsigned ii = 0; ii &lt; numActiveAttribLocations(); ++ii) {
114         if (!getActiveAttribLocation(ii))
115             return true;
116     }
117     return false;
118 }
119 
120 bool WebGLProgram::getLinkStatus()
121 {
122     cacheInfoIfNeeded();
123     return m_linkStatus;
124 }
125 
126 void WebGLProgram::setLinkStatus(bool status)
127 {
128     cacheInfoIfNeeded();
129     m_linkStatus = status;
130 }
131 
132 void WebGLProgram::increaseLinkCount()
133 {
134     ++m_linkCount;
135     m_infoValid = false;
136 }
137 
<span class="line-modified">138 WebGLShader* WebGLProgram::getAttachedShader(GC3Denum type)</span>
139 {
140     switch (type) {
<span class="line-modified">141     case GraphicsContext3D::VERTEX_SHADER:</span>
142         return m_vertexShader.get();
<span class="line-modified">143     case GraphicsContext3D::FRAGMENT_SHADER:</span>
144         return m_fragmentShader.get();
145     default:
146         return 0;
147     }
148 }
149 
150 bool WebGLProgram::attachShader(WebGLShader* shader)
151 {
152     if (!shader || !shader-&gt;object())
153         return false;
154     switch (shader-&gt;getType()) {
<span class="line-modified">155     case GraphicsContext3D::VERTEX_SHADER:</span>
156         if (m_vertexShader)
157             return false;
158         m_vertexShader = shader;
159         return true;
<span class="line-modified">160     case GraphicsContext3D::FRAGMENT_SHADER:</span>
161         if (m_fragmentShader)
162             return false;
163         m_fragmentShader = shader;
164         return true;
165     default:
166         return false;
167     }
168 }
169 
170 bool WebGLProgram::detachShader(WebGLShader* shader)
171 {
172     if (!shader || !shader-&gt;object())
173         return false;
174     switch (shader-&gt;getType()) {
<span class="line-modified">175     case GraphicsContext3D::VERTEX_SHADER:</span>
176         if (m_vertexShader != shader)
177             return false;
178         m_vertexShader = nullptr;
179         return true;
<span class="line-modified">180     case GraphicsContext3D::FRAGMENT_SHADER:</span>
181         if (m_fragmentShader != shader)
182             return false;
183         m_fragmentShader = nullptr;
184         return true;
185     default:
186         return false;
187     }
188 }
189 
<span class="line-modified">190 void WebGLProgram::cacheActiveAttribLocations(GraphicsContext3D* context3d)</span>
191 {
192     m_activeAttribLocations.clear();
193 
<span class="line-modified">194     GC3Dint numAttribs = 0;</span>
<span class="line-modified">195     context3d-&gt;getProgramiv(object(), GraphicsContext3D::ACTIVE_ATTRIBUTES, &amp;numAttribs);</span>
196     m_activeAttribLocations.resize(static_cast&lt;size_t&gt;(numAttribs));
197     for (int i = 0; i &lt; numAttribs; ++i) {
<span class="line-modified">198         ActiveInfo info;</span>
199         context3d-&gt;getActiveAttribImpl(object(), i, info);
200         m_activeAttribLocations[i] = context3d-&gt;getAttribLocation(object(), info.name);
201     }
202 }
203 
204 void WebGLProgram::cacheInfoIfNeeded()
205 {
206     if (m_infoValid)
207         return;
208 
209     if (!object())
210         return;
211 
<span class="line-modified">212     GraphicsContext3D* context = getAGraphicsContext3D();</span>
213     if (!context)
214         return;
<span class="line-modified">215     GC3Dint linkStatus = 0;</span>
<span class="line-modified">216     context-&gt;getProgramiv(object(), GraphicsContext3D::LINK_STATUS, &amp;linkStatus);</span>
217     m_linkStatus = linkStatus;
218     if (m_linkStatus)
219         cacheActiveAttribLocations(context);
220     m_infoValid = true;
221 }
222 
223 }
224 
225 #endif // ENABLE(WEBGL)
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLProgram.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
<span class="line-added"> 31 #include &quot;InspectorInstrumentation.h&quot;</span>
<span class="line-added"> 32 #include &quot;ScriptExecutionContext.h&quot;</span>
 33 #include &quot;WebGLContextGroup.h&quot;
 34 #include &quot;WebGLRenderingContextBase.h&quot;
 35 #include &quot;WebGLShader.h&quot;

 36 #include &lt;wtf/Lock.h&gt;
 37 #include &lt;wtf/NeverDestroyed.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 HashMap&lt;WebGLProgram*, WebGLRenderingContextBase*&gt;&amp; WebGLProgram::instances(const LockHolder&amp;)
 42 {
 43     static NeverDestroyed&lt;HashMap&lt;WebGLProgram*, WebGLRenderingContextBase*&gt;&gt; instances;
 44     return instances;
 45 }
 46 
 47 Lock&amp; WebGLProgram::instancesMutex()
 48 {
 49     static LazyNeverDestroyed&lt;Lock&gt; mutex;
 50     static std::once_flag initializeMutex;
 51     std::call_once(initializeMutex, [] {
 52         mutex.construct();
 53     });
 54     return mutex.get();
 55 }
 56 
 57 Ref&lt;WebGLProgram&gt; WebGLProgram::create(WebGLRenderingContextBase&amp; ctx)
 58 {
 59     return adoptRef(*new WebGLProgram(ctx));
 60 }
 61 
 62 WebGLProgram::WebGLProgram(WebGLRenderingContextBase&amp; ctx)
 63     : WebGLSharedObject(ctx)
<span class="line-added"> 64     , ContextDestructionObserver(ctx.scriptExecutionContext())</span>
 65 {
<span class="line-added"> 66     ASSERT(scriptExecutionContext());</span>
<span class="line-added"> 67 </span>
 68     {
 69         LockHolder lock(instancesMutex());
 70         instances(lock).add(this, &amp;ctx);
 71     }
 72 
<span class="line-modified"> 73     setObject(ctx.graphicsContextGL()-&gt;createProgram());</span>
 74 }
 75 
 76 WebGLProgram::~WebGLProgram()
 77 {
<span class="line-added"> 78     InspectorInstrumentation::willDestroyWebGLProgram(*this);</span>
<span class="line-added"> 79 </span>
 80     deleteObject(0);
 81 
 82     {
 83         LockHolder lock(instancesMutex());
 84         ASSERT(instances(lock).contains(this));
 85         instances(lock).remove(this);
 86     }
 87 }
 88 
<span class="line-modified"> 89 void WebGLProgram::contextDestroyed()</span>
<span class="line-added"> 90 {</span>
<span class="line-added"> 91     InspectorInstrumentation::willDestroyWebGLProgram(*this);</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93     ContextDestructionObserver::contextDestroyed();</span>
<span class="line-added"> 94 }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96 void WebGLProgram::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject obj)</span>
 97 {
 98     context3d-&gt;deleteProgram(obj);
 99     if (m_vertexShader) {
100         m_vertexShader-&gt;onDetached(context3d);
101         m_vertexShader = nullptr;
102     }
103     if (m_fragmentShader) {
104         m_fragmentShader-&gt;onDetached(context3d);
105         m_fragmentShader = nullptr;
106     }
107 }
108 
109 unsigned WebGLProgram::numActiveAttribLocations()
110 {
111     cacheInfoIfNeeded();
112     return m_activeAttribLocations.size();
113 }
114 
<span class="line-modified">115 GCGLint WebGLProgram::getActiveAttribLocation(GCGLuint index)</span>
116 {
117     cacheInfoIfNeeded();
118     if (index &gt;= numActiveAttribLocations())
119         return -1;
120     return m_activeAttribLocations[index];
121 }
122 
123 bool WebGLProgram::isUsingVertexAttrib0()
124 {
125     cacheInfoIfNeeded();
126     for (unsigned ii = 0; ii &lt; numActiveAttribLocations(); ++ii) {
127         if (!getActiveAttribLocation(ii))
128             return true;
129     }
130     return false;
131 }
132 
133 bool WebGLProgram::getLinkStatus()
134 {
135     cacheInfoIfNeeded();
136     return m_linkStatus;
137 }
138 
139 void WebGLProgram::setLinkStatus(bool status)
140 {
141     cacheInfoIfNeeded();
142     m_linkStatus = status;
143 }
144 
145 void WebGLProgram::increaseLinkCount()
146 {
147     ++m_linkCount;
148     m_infoValid = false;
149 }
150 
<span class="line-modified">151 WebGLShader* WebGLProgram::getAttachedShader(GCGLenum type)</span>
152 {
153     switch (type) {
<span class="line-modified">154     case GraphicsContextGL::VERTEX_SHADER:</span>
155         return m_vertexShader.get();
<span class="line-modified">156     case GraphicsContextGL::FRAGMENT_SHADER:</span>
157         return m_fragmentShader.get();
158     default:
159         return 0;
160     }
161 }
162 
163 bool WebGLProgram::attachShader(WebGLShader* shader)
164 {
165     if (!shader || !shader-&gt;object())
166         return false;
167     switch (shader-&gt;getType()) {
<span class="line-modified">168     case GraphicsContextGL::VERTEX_SHADER:</span>
169         if (m_vertexShader)
170             return false;
171         m_vertexShader = shader;
172         return true;
<span class="line-modified">173     case GraphicsContextGL::FRAGMENT_SHADER:</span>
174         if (m_fragmentShader)
175             return false;
176         m_fragmentShader = shader;
177         return true;
178     default:
179         return false;
180     }
181 }
182 
183 bool WebGLProgram::detachShader(WebGLShader* shader)
184 {
185     if (!shader || !shader-&gt;object())
186         return false;
187     switch (shader-&gt;getType()) {
<span class="line-modified">188     case GraphicsContextGL::VERTEX_SHADER:</span>
189         if (m_vertexShader != shader)
190             return false;
191         m_vertexShader = nullptr;
192         return true;
<span class="line-modified">193     case GraphicsContextGL::FRAGMENT_SHADER:</span>
194         if (m_fragmentShader != shader)
195             return false;
196         m_fragmentShader = nullptr;
197         return true;
198     default:
199         return false;
200     }
201 }
202 
<span class="line-modified">203 void WebGLProgram::cacheActiveAttribLocations(GraphicsContextGLOpenGL* context3d)</span>
204 {
205     m_activeAttribLocations.clear();
206 
<span class="line-modified">207     GCGLint numAttribs = 0;</span>
<span class="line-modified">208     context3d-&gt;getProgramiv(object(), GraphicsContextGL::ACTIVE_ATTRIBUTES, &amp;numAttribs);</span>
209     m_activeAttribLocations.resize(static_cast&lt;size_t&gt;(numAttribs));
210     for (int i = 0; i &lt; numAttribs; ++i) {
<span class="line-modified">211         GraphicsContextGL::ActiveInfo info;</span>
212         context3d-&gt;getActiveAttribImpl(object(), i, info);
213         m_activeAttribLocations[i] = context3d-&gt;getAttribLocation(object(), info.name);
214     }
215 }
216 
217 void WebGLProgram::cacheInfoIfNeeded()
218 {
219     if (m_infoValid)
220         return;
221 
222     if (!object())
223         return;
224 
<span class="line-modified">225     GraphicsContextGLOpenGL* context = getAGraphicsContextGL();</span>
226     if (!context)
227         return;
<span class="line-modified">228     GCGLint linkStatus = 0;</span>
<span class="line-modified">229     context-&gt;getProgramiv(object(), GraphicsContextGL::LINK_STATUS, &amp;linkStatus);</span>
230     m_linkStatus = linkStatus;
231     if (m_linkStatus)
232         cacheActiveAttribLocations(context);
233     m_infoValid = true;
234 }
235 
236 }
237 
238 #endif // ENABLE(WEBGL)
</pre>
</td>
</tr>
</table>
<center><a href="WebGLObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLProgram.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
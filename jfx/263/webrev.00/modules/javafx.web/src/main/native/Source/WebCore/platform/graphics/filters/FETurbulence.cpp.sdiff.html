<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FETurbulence.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FETile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Filter.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FETurbulence.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
137 
138 void FETurbulence::initPaint(PaintingData&amp; paintingData)
139 {
140     float normalizationFactor;
141 
142     // The seed value clamp to the range [1, s_randMaximum - 1].
143     if (paintingData.seed &lt;= 0)
144         paintingData.seed = -(paintingData.seed % (s_randMaximum - 1)) + 1;
145     if (paintingData.seed &gt; s_randMaximum - 1)
146         paintingData.seed = s_randMaximum - 1;
147 
148     float* gradient;
149     for (int channel = 0; channel &lt; 4; ++channel) {
150         for (int i = 0; i &lt; s_blockSize; ++i) {
151             paintingData.latticeSelector[i] = i;
152             gradient = paintingData.gradient[channel][i];
153             do {
154                 gradient[0] = static_cast&lt;float&gt;((paintingData.random() % (2 * s_blockSize)) - s_blockSize) / s_blockSize;
155                 gradient[1] = static_cast&lt;float&gt;((paintingData.random() % (2 * s_blockSize)) - s_blockSize) / s_blockSize;
156             } while (!gradient[0] &amp;&amp; !gradient[1]);
<span class="line-modified">157             normalizationFactor = sqrtf(gradient[0] * gradient[0] + gradient[1] * gradient[1]);</span>
158             gradient[0] /= normalizationFactor;
159             gradient[1] /= normalizationFactor;
160         }
161     }
162 
163     for (int i = s_blockSize - 1; i &gt; 0; --i) {
164         int k = paintingData.latticeSelector[i];
165         int j = paintingData.random() % s_blockSize;
166         ASSERT(j &gt;= 0);
167         ASSERT(j &lt; 2 * s_blockSize + 2);
168         paintingData.latticeSelector[i] = paintingData.latticeSelector[j];
169         paintingData.latticeSelector[j] = k;
170     }
171 
172     for (int i = 0; i &lt; s_blockSize + 2; ++i) {
173         paintingData.latticeSelector[s_blockSize + i] = paintingData.latticeSelector[i];
174         for (int channel = 0; channel &lt; 4; ++channel) {
175             paintingData.gradient[channel][s_blockSize + i][0] = paintingData.gradient[channel][i][0];
176             paintingData.gradient[channel][s_blockSize + i][1] = paintingData.gradient[channel][i][1];
177         }
</pre>
</td>
<td>
<hr />
<pre>
137 
138 void FETurbulence::initPaint(PaintingData&amp; paintingData)
139 {
140     float normalizationFactor;
141 
142     // The seed value clamp to the range [1, s_randMaximum - 1].
143     if (paintingData.seed &lt;= 0)
144         paintingData.seed = -(paintingData.seed % (s_randMaximum - 1)) + 1;
145     if (paintingData.seed &gt; s_randMaximum - 1)
146         paintingData.seed = s_randMaximum - 1;
147 
148     float* gradient;
149     for (int channel = 0; channel &lt; 4; ++channel) {
150         for (int i = 0; i &lt; s_blockSize; ++i) {
151             paintingData.latticeSelector[i] = i;
152             gradient = paintingData.gradient[channel][i];
153             do {
154                 gradient[0] = static_cast&lt;float&gt;((paintingData.random() % (2 * s_blockSize)) - s_blockSize) / s_blockSize;
155                 gradient[1] = static_cast&lt;float&gt;((paintingData.random() % (2 * s_blockSize)) - s_blockSize) / s_blockSize;
156             } while (!gradient[0] &amp;&amp; !gradient[1]);
<span class="line-modified">157             normalizationFactor = std::hypot(gradient[0], gradient[1]);</span>
158             gradient[0] /= normalizationFactor;
159             gradient[1] /= normalizationFactor;
160         }
161     }
162 
163     for (int i = s_blockSize - 1; i &gt; 0; --i) {
164         int k = paintingData.latticeSelector[i];
165         int j = paintingData.random() % s_blockSize;
166         ASSERT(j &gt;= 0);
167         ASSERT(j &lt; 2 * s_blockSize + 2);
168         paintingData.latticeSelector[i] = paintingData.latticeSelector[j];
169         paintingData.latticeSelector[j] = k;
170     }
171 
172     for (int i = 0; i &lt; s_blockSize + 2; ++i) {
173         paintingData.latticeSelector[s_blockSize + i] = paintingData.latticeSelector[i];
174         for (int channel = 0; channel &lt; 4; ++channel) {
175             paintingData.gradient[channel][s_blockSize + i][0] = paintingData.gradient[channel][i][0];
176             paintingData.gradient[channel][s_blockSize + i][1] = paintingData.gradient[channel][i][1];
177         }
</pre>
</td>
</tr>
</table>
<center><a href="FETile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Filter.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
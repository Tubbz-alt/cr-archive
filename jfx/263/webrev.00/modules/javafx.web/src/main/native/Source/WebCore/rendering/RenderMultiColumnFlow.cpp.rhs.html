<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderMultiColumnFlow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS IN..0TERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderMultiColumnFlow.h&quot;
 28 
 29 #include &quot;HitTestResult.h&quot;
 30 #include &quot;RenderIterator.h&quot;
 31 #include &quot;RenderLayoutState.h&quot;
 32 #include &quot;RenderMultiColumnSet.h&quot;
 33 #include &quot;RenderMultiColumnSpannerPlaceholder.h&quot;
 34 #include &quot;RenderTreeBuilder.h&quot;
 35 #include &quot;RenderView.h&quot;
 36 #include &quot;TransformState.h&quot;
 37 #include &lt;wtf/IsoMallocInlines.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderMultiColumnFlow);
 42 
 43 RenderMultiColumnFlow::RenderMultiColumnFlow(Document&amp; document, RenderStyle&amp;&amp; style)
 44     : RenderFragmentedFlow(document, WTFMove(style))
 45     , m_spannerMap(makeUnique&lt;SpannerMap&gt;())
 46     , m_lastSetWorkedOn(nullptr)
 47     , m_columnCount(1)
 48     , m_columnWidth(0)
 49     , m_columnHeightAvailable(0)
 50     , m_inLayout(false)
 51     , m_inBalancingPass(false)
 52     , m_needsHeightsRecalculation(false)
 53     , m_progressionIsInline(false)
 54     , m_progressionIsReversed(false)
 55 {
 56     setFragmentedFlowState(InsideInFragmentedFlow);
 57 }
 58 
 59 RenderMultiColumnFlow::~RenderMultiColumnFlow() = default;
 60 
 61 const char* RenderMultiColumnFlow::renderName() const
 62 {
 63     return &quot;RenderMultiColumnFlowThread&quot;;
 64 }
 65 
 66 RenderMultiColumnSet* RenderMultiColumnFlow::firstMultiColumnSet() const
 67 {
 68     for (RenderObject* sibling = nextSibling(); sibling; sibling = sibling-&gt;nextSibling()) {
 69         if (is&lt;RenderMultiColumnSet&gt;(*sibling))
 70             return downcast&lt;RenderMultiColumnSet&gt;(sibling);
 71     }
 72     return nullptr;
 73 }
 74 
 75 RenderMultiColumnSet* RenderMultiColumnFlow::lastMultiColumnSet() const
 76 {
<a name="1" id="anc1"></a><span class="line-added"> 77     ASSERT(multiColumnBlockFlow());</span>
<span class="line-added"> 78 </span>
 79     for (RenderObject* sibling = multiColumnBlockFlow()-&gt;lastChild(); sibling; sibling = sibling-&gt;previousSibling()) {
 80         if (is&lt;RenderMultiColumnSet&gt;(*sibling))
 81             return downcast&lt;RenderMultiColumnSet&gt;(sibling);
 82     }
 83     return nullptr;
 84 }
 85 
 86 RenderBox* RenderMultiColumnFlow::firstColumnSetOrSpanner() const
 87 {
 88     if (RenderObject* sibling = nextSibling()) {
 89         ASSERT(is&lt;RenderBox&gt;(*sibling));
 90         ASSERT(is&lt;RenderMultiColumnSet&gt;(*sibling) || findColumnSpannerPlaceholder(downcast&lt;RenderBox&gt;(sibling)));
 91         return downcast&lt;RenderBox&gt;(sibling);
 92     }
 93     return nullptr;
 94 }
 95 
 96 RenderBox* RenderMultiColumnFlow::nextColumnSetOrSpannerSiblingOf(const RenderBox* child)
 97 {
 98     return child ? child-&gt;nextSiblingBox() : nullptr;
 99 }
100 
101 RenderBox* RenderMultiColumnFlow::previousColumnSetOrSpannerSiblingOf(const RenderBox* child)
102 {
103     if (!child)
104         return nullptr;
105     if (auto* sibling = child-&gt;previousSiblingBox()) {
106         if (!is&lt;RenderFragmentedFlow&gt;(*sibling))
107             return sibling;
108     }
109     return nullptr;
110 }
111 
112 RenderMultiColumnSpannerPlaceholder* RenderMultiColumnFlow::findColumnSpannerPlaceholder(RenderBox* spanner) const
113 {
114     return m_spannerMap-&gt;get(spanner).get();
115 }
116 
117 void RenderMultiColumnFlow::layout()
118 {
119     ASSERT(!m_inLayout);
120     m_inLayout = true;
121     m_lastSetWorkedOn = nullptr;
122     if (RenderBox* first = firstColumnSetOrSpanner()) {
123         if (is&lt;RenderMultiColumnSet&gt;(*first)) {
124             m_lastSetWorkedOn = downcast&lt;RenderMultiColumnSet&gt;(first);
125             m_lastSetWorkedOn-&gt;beginFlow(this);
126         }
127     }
128     RenderFragmentedFlow::layout();
129     if (RenderMultiColumnSet* lastSet = lastMultiColumnSet()) {
130         if (!nextColumnSetOrSpannerSiblingOf(lastSet))
131             lastSet-&gt;endFlow(this, logicalHeight());
132         lastSet-&gt;expandToEncompassFragmentedFlowContentsIfNeeded();
133     }
134     m_inLayout = false;
135     m_lastSetWorkedOn = nullptr;
136 }
137 
138 void RenderMultiColumnFlow::addFragmentToThread(RenderFragmentContainer* RenderFragmentContainer)
139 {
140     auto* columnSet = downcast&lt;RenderMultiColumnSet&gt;(RenderFragmentContainer);
141     if (RenderMultiColumnSet* nextSet = columnSet-&gt;nextSiblingMultiColumnSet()) {
142         RenderFragmentContainerList::iterator it = m_fragmentList.find(nextSet);
143         ASSERT(it != m_fragmentList.end());
144         m_fragmentList.insertBefore(it, columnSet);
145     } else
146         m_fragmentList.add(columnSet);
147     RenderFragmentContainer-&gt;setIsValid(true);
148 }
149 
150 void RenderMultiColumnFlow::willBeRemovedFromTree()
151 {
152     // Detach all column sets from the flow thread. Cannot destroy them at this point, since they
153     // are siblings of this object, and there may be pointers to this object&#39;s sibling somewhere
154     // further up on the call stack.
155     for (RenderMultiColumnSet* columnSet = firstMultiColumnSet(); columnSet; columnSet = columnSet-&gt;nextSiblingMultiColumnSet())
156         columnSet-&gt;detachFragment();
157     RenderFragmentedFlow::willBeRemovedFromTree();
158 }
159 
160 void RenderMultiColumnFlow::fragmentedFlowDescendantBoxLaidOut(RenderBox* descendant)
161 {
162     if (!is&lt;RenderMultiColumnSpannerPlaceholder&gt;(*descendant))
163         return;
164     auto&amp; placeholder = downcast&lt;RenderMultiColumnSpannerPlaceholder&gt;(*descendant);
165     RenderBlock* container = placeholder.containingBlock();
166 
167     for (RenderBox* prev = previousColumnSetOrSpannerSiblingOf(placeholder.spanner()); prev; prev = previousColumnSetOrSpannerSiblingOf(prev)) {
168         if (is&lt;RenderMultiColumnSet&gt;(*prev)) {
169             downcast&lt;RenderMultiColumnSet&gt;(*prev).endFlow(container, placeholder.logicalTop());
170             break;
171         }
172     }
173 
174     for (RenderBox* next = nextColumnSetOrSpannerSiblingOf(placeholder.spanner()); next; next = nextColumnSetOrSpannerSiblingOf(next)) {
175         if (is&lt;RenderMultiColumnSet&gt;(*next)) {
176             m_lastSetWorkedOn = downcast&lt;RenderMultiColumnSet&gt;(next);
177             m_lastSetWorkedOn-&gt;beginFlow(container);
178             break;
179         }
180     }
181 }
182 
183 RenderBox::LogicalExtentComputedValues RenderMultiColumnFlow::computeLogicalHeight(LayoutUnit logicalHeight, LayoutUnit logicalTop) const
184 {
185     // We simply remain at our intrinsic height.
186     return { logicalHeight, logicalTop, ComputedMarginValues() };
187 }
188 
189 LayoutUnit RenderMultiColumnFlow::initialLogicalWidth() const
190 {
191     return columnWidth();
192 }
193 
194 void RenderMultiColumnFlow::setPageBreak(const RenderBlock* block, LayoutUnit offset, LayoutUnit spaceShortage)
195 {
196     if (auto* multicolSet = downcast&lt;RenderMultiColumnSet&gt;(fragmentAtBlockOffset(block, offset)))
197         multicolSet-&gt;recordSpaceShortage(spaceShortage);
198 }
199 
200 void RenderMultiColumnFlow::updateMinimumPageHeight(const RenderBlock* block, LayoutUnit offset, LayoutUnit minHeight)
201 {
202     if (auto* multicolSet = downcast&lt;RenderMultiColumnSet&gt;(fragmentAtBlockOffset(block, offset)))
203         multicolSet-&gt;updateMinimumColumnHeight(minHeight);
204 }
205 
206 RenderFragmentContainer* RenderMultiColumnFlow::fragmentAtBlockOffset(const RenderBox* box, LayoutUnit offset, bool extendLastFragment) const
207 {
208     if (!m_inLayout)
209         return RenderFragmentedFlow::fragmentAtBlockOffset(box, offset, extendLastFragment);
210 
211     // Layout in progress. We are calculating the set heights as we speak, so the fragment range
212     // information is not up-to-date.
213 
214     RenderMultiColumnSet* columnSet = m_lastSetWorkedOn ? m_lastSetWorkedOn : firstMultiColumnSet();
215     if (!columnSet) {
216         // If there&#39;s no set, bail. This multicol is empty or only consists of spanners. There
217         // are no fragments.
218         return nullptr;
219     }
220     // The last set worked on is a good guess. But if we&#39;re not within the bounds, search for the
221     // right one.
222     if (offset &lt; columnSet-&gt;logicalTopInFragmentedFlow()) {
223         do {
224             if (RenderMultiColumnSet* prev = columnSet-&gt;previousSiblingMultiColumnSet())
225                 columnSet = prev;
226             else
227                 break;
228         } while (offset &lt; columnSet-&gt;logicalTopInFragmentedFlow());
229     } else {
230         while (offset &gt;= columnSet-&gt;logicalBottomInFragmentedFlow()) {
231             RenderMultiColumnSet* next = columnSet-&gt;nextSiblingMultiColumnSet();
232             if (!next || !next-&gt;hasBeenFlowed())
233                 break;
234             columnSet = next;
235         }
236     }
237     return columnSet;
238 }
239 
240 void RenderMultiColumnFlow::setFragmentRangeForBox(const RenderBox&amp; box, RenderFragmentContainer* startFragment, RenderFragmentContainer* endFragment)
241 {
242     // Some column sets may have zero height, which means that two or more sets may start at the
243     // exact same flow thread position, which means that some parts of the code may believe that a
244     // given box lives in sets that it doesn&#39;t really live in. Make some adjustments here and
245     // include such sets if they are adjacent to the start and/or end fragments.
246     for (RenderMultiColumnSet* columnSet = downcast&lt;RenderMultiColumnSet&gt;(*startFragment).previousSiblingMultiColumnSet(); columnSet; columnSet = columnSet-&gt;previousSiblingMultiColumnSet()) {
247         if (columnSet-&gt;logicalHeightInFragmentedFlow())
248             break;
249         startFragment = columnSet;
250     }
251     for (RenderMultiColumnSet* columnSet = downcast&lt;RenderMultiColumnSet&gt;(*startFragment).nextSiblingMultiColumnSet(); columnSet; columnSet = columnSet-&gt;nextSiblingMultiColumnSet()) {
252         if (columnSet-&gt;logicalHeightInFragmentedFlow())
253             break;
254         endFragment = columnSet;
255     }
256 
257     RenderFragmentedFlow::setFragmentRangeForBox(box, startFragment, endFragment);
258 }
259 
260 bool RenderMultiColumnFlow::addForcedFragmentBreak(const RenderBlock* block, LayoutUnit offset, RenderBox* /*breakChild*/, bool /*isBefore*/, LayoutUnit* offsetBreakAdjustment)
261 {
262     if (auto* multicolSet = downcast&lt;RenderMultiColumnSet&gt;(fragmentAtBlockOffset(block, offset))) {
263         multicolSet-&gt;addForcedBreak(offset);
264         if (offsetBreakAdjustment)
265             *offsetBreakAdjustment = pageLogicalHeightForOffset(offset) ? pageRemainingLogicalHeightForOffset(offset, IncludePageBoundary) : 0_lu;
266         return true;
267     }
268     return false;
269 }
270 
271 LayoutSize RenderMultiColumnFlow::offsetFromContainer(RenderElement&amp; enclosingContainer, const LayoutPoint&amp; physicalPoint, bool* offsetDependsOnPoint) const
272 {
273     ASSERT(&amp;enclosingContainer == container());
274 
275     if (offsetDependsOnPoint)
276         *offsetDependsOnPoint = true;
277 
278     LayoutPoint translatedPhysicalPoint(physicalPoint);
279     if (RenderFragmentContainer* fragment = physicalTranslationFromFlowToFragment(translatedPhysicalPoint))
280         translatedPhysicalPoint.moveBy(fragment-&gt;topLeftLocation());
281 
282     LayoutSize offset(translatedPhysicalPoint.x(), translatedPhysicalPoint.y());
283     if (is&lt;RenderBox&gt;(enclosingContainer))
284         offset -= toLayoutSize(downcast&lt;RenderBox&gt;(enclosingContainer).scrollPosition());
285     return offset;
286 }
287 
288 void RenderMultiColumnFlow::mapAbsoluteToLocalPoint(MapCoordinatesFlags mode, TransformState&amp; transformState) const
289 {
290     // First get the transform state&#39;s point into the block flow thread&#39;s physical coordinate space.
291     parent()-&gt;mapAbsoluteToLocalPoint(mode, transformState);
292     LayoutPoint transformPoint(transformState.mappedPoint());
293 
294     // Now walk through each fragment.
295     const RenderMultiColumnSet* candidateColumnSet = nullptr;
296     LayoutPoint candidatePoint;
297     LayoutSize candidateContainerOffset;
298 
299     for (const auto&amp; columnSet : childrenOfType&lt;RenderMultiColumnSet&gt;(*parent())) {
300         candidateContainerOffset = columnSet.offsetFromContainer(*parent(), LayoutPoint());
301 
302         candidatePoint = transformPoint - candidateContainerOffset;
303         candidateColumnSet = &amp;columnSet;
304 
305         // We really have no clue what to do with overflow. We&#39;ll just use the closest fragment to the point in that case.
306         LayoutUnit pointOffset = isHorizontalWritingMode() ? candidatePoint.y() : candidatePoint.x();
307         LayoutUnit fragmentOffset = isHorizontalWritingMode() ? columnSet.topLeftLocation().y() : columnSet.topLeftLocation().x();
308         if (pointOffset &lt; fragmentOffset + columnSet.logicalHeight())
309             break;
310     }
311 
312     // Once we have a good guess as to which fragment we hit tested through (and yes, this was just a heuristic, but it&#39;s
313     // the best we could do), then we can map from the fragment into the flow thread.
314     LayoutSize translationOffset = physicalTranslationFromFragmentToFlow(candidateColumnSet, candidatePoint) + candidateContainerOffset;
315     bool preserve3D = mode &amp; UseTransforms &amp;&amp; (parent()-&gt;style().preserves3D() || style().preserves3D());
316     if (mode &amp; UseTransforms &amp;&amp; shouldUseTransformFromContainer(parent())) {
317         TransformationMatrix t;
318         getTransformFromContainer(parent(), translationOffset, t);
319         transformState.applyTransform(t, preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
320     } else
321         transformState.move(translationOffset.width(), translationOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
322 }
323 
324 LayoutSize RenderMultiColumnFlow::physicalTranslationFromFragmentToFlow(const RenderMultiColumnSet* columnSet, const LayoutPoint&amp; physicalPoint) const
325 {
326     LayoutPoint logicalPoint = columnSet-&gt;flipForWritingMode(physicalPoint);
327     LayoutPoint translatedPoint = columnSet-&gt;translateFragmentPointToFragmentedFlow(logicalPoint);
328     LayoutPoint physicalTranslatedPoint = columnSet-&gt;flipForWritingMode(translatedPoint);
329     return physicalPoint - physicalTranslatedPoint;
330 }
331 
332 RenderFragmentContainer* RenderMultiColumnFlow::mapFromFlowToFragment(TransformState&amp; transformState) const
333 {
334     if (!hasValidFragmentInfo())
335         return nullptr;
336 
337     // Get back into our local flow thread space.
338     LayoutRect boxRect = transformState.mappedQuad().enclosingBoundingBox();
339     flipForWritingMode(boxRect);
340 
341     // FIXME: We need to refactor RenderObject::absoluteQuads to be able to split the quads across fragments,
342     // for now we just take the center of the mapped enclosing box and map it to a column.
343     LayoutPoint centerPoint = boxRect.center();
344     LayoutUnit centerLogicalOffset = isHorizontalWritingMode() ? centerPoint.y() : centerPoint.x();
345     RenderFragmentContainer* RenderFragmentContainer = fragmentAtBlockOffset(this, centerLogicalOffset, true);
346     if (!RenderFragmentContainer)
347         return nullptr;
348     transformState.move(physicalTranslationOffsetFromFlowToFragment(RenderFragmentContainer, centerLogicalOffset));
349     return RenderFragmentContainer;
350 }
351 
352 LayoutSize RenderMultiColumnFlow::physicalTranslationOffsetFromFlowToFragment(const RenderFragmentContainer* RenderFragmentContainer, const LayoutUnit logicalOffset) const
353 {
354     // Now that we know which multicolumn set we hit, we need to get the appropriate translation offset for the column.
355     const auto* columnSet = downcast&lt;RenderMultiColumnSet&gt;(RenderFragmentContainer);
356     LayoutPoint translationOffset = columnSet-&gt;columnTranslationForOffset(logicalOffset);
357 
358     // Now we know how we want the rect to be translated into the fragment. At this point we&#39;re converting
359     // back to physical coordinates.
360     if (style().isFlippedBlocksWritingMode()) {
361         LayoutRect portionRect(columnSet-&gt;fragmentedFlowPortionRect());
362         LayoutRect columnRect = columnSet-&gt;columnRectAt(0);
363         LayoutUnit physicalDeltaFromPortionBottom = logicalHeight() - columnSet-&gt;logicalBottomInFragmentedFlow();
364         if (isHorizontalWritingMode())
365             columnRect.setHeight(portionRect.height());
366         else
367             columnRect.setWidth(portionRect.width());
368         columnSet-&gt;flipForWritingMode(columnRect);
369         if (isHorizontalWritingMode())
370             translationOffset.move(0_lu, columnRect.y() - portionRect.y() - physicalDeltaFromPortionBottom);
371         else
372             translationOffset.move(columnRect.x() - portionRect.x() - physicalDeltaFromPortionBottom, 0_lu);
373     }
374 
375     return LayoutSize(translationOffset.x(), translationOffset.y());
376 }
377 
378 RenderFragmentContainer* RenderMultiColumnFlow::physicalTranslationFromFlowToFragment(LayoutPoint&amp; physicalPoint) const
379 {
380     if (!hasValidFragmentInfo())
381         return nullptr;
382 
383     // Put the physical point into the flow thread&#39;s coordinate space.
384     LayoutPoint logicalPoint = flipForWritingMode(physicalPoint);
385 
386     // Now get the fragment that we are in.
387     LayoutUnit logicalOffset = isHorizontalWritingMode() ? logicalPoint.y() : logicalPoint.x();
388     RenderFragmentContainer* RenderFragmentContainer = fragmentAtBlockOffset(this, logicalOffset, true);
389     if (!RenderFragmentContainer)
390         return nullptr;
391 
392     // Translate to the coordinate space of the fragment.
393     LayoutSize translationOffset = physicalTranslationOffsetFromFlowToFragment(RenderFragmentContainer, logicalOffset);
394 
395     // Now shift the physical point into the fragment&#39;s coordinate space.
396     physicalPoint += translationOffset;
397 
398     return RenderFragmentContainer;
399 }
400 
401 bool RenderMultiColumnFlow::isPageLogicalHeightKnown() const
402 {
403     if (RenderMultiColumnSet* columnSet = lastMultiColumnSet())
404         return columnSet-&gt;columnHeightComputed();
405     return false;
406 }
407 
408 bool RenderMultiColumnFlow::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
409 {
410     // You cannot be inside an in-flow RenderFragmentedFlow without a corresponding DOM node. It&#39;s better to
411     // just let the ancestor figure out where we are instead.
412     if (hitTestAction == HitTestBlockBackground)
413         return false;
414     bool inside = RenderFragmentedFlow::nodeAtPoint(request, result, locationInContainer, accumulatedOffset, hitTestAction);
415     if (inside &amp;&amp; !result.innerNode())
416         return false;
417     return inside;
418 }
419 
420 bool RenderMultiColumnFlow::shouldCheckColumnBreaks() const
421 {
422     if (!parent()-&gt;isRenderView())
423         return true;
424     return view().frameView().pagination().behavesLikeColumns;
425 }
426 
427 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
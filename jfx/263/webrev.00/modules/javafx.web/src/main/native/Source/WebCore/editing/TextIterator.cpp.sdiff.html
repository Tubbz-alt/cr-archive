<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SpellingCorrectionCommand.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TextIterator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 457     // reset the run information
 458     m_positionNode = nullptr;
 459     m_copyableText.reset();
 460     m_text = StringView();
 461 
 462     // handle remembered node that needed a newline after the text node&#39;s newline
 463     if (m_nodeForAdditionalNewline) {
 464         // Emit the extra newline, and position it *inside* m_node, after m_node&#39;s
 465         // contents, in case it&#39;s a block, in the same way that we position the first
 466         // newline. The range for the emitted newline should start where the line
 467         // break begins.
 468         // FIXME: It would be cleaner if we emitted two newlines during the last
 469         // iteration, instead of using m_needsAnotherNewline.
 470         emitCharacter(&#39;\n&#39;, *m_nodeForAdditionalNewline-&gt;parentNode(), m_nodeForAdditionalNewline, 1, 1);
 471         m_nodeForAdditionalNewline = nullptr;
 472         return;
 473     }
 474 
 475     if (!m_textBox &amp;&amp; m_remainingTextBox) {
 476         m_textBox = m_remainingTextBox;
<span class="line-modified"> 477         m_remainingTextBox = nullptr;</span>
<span class="line-modified"> 478         m_firstLetterText = nullptr;</span>
 479         m_offset = 0;
 480     }
 481     // handle remembered text box
 482     if (m_textBox) {
 483         handleTextBox();
 484         if (m_positionNode)
 485             return;
 486     }
 487 
 488     while (m_node &amp;&amp; m_node != m_pastEndNode) {
 489         // if the range ends at offset 0 of an element, represent the
 490         // position, but not the content, of that element e.g. if the
 491         // node is a blockflow element, emit a newline that
 492         // precedes the element
 493         if (m_node == m_endContainer &amp;&amp; !m_endOffset) {
 494             representNodeOffsetZero();
 495             m_node = nullptr;
 496             return;
 497         }
 498 
</pre>
<hr />
<pre>
 557 
 558         // how would this ever be?
 559         if (m_positionNode)
 560             return;
 561     }
 562 }
 563 
 564 static bool hasVisibleTextNode(RenderText&amp; renderer)
 565 {
 566     if (renderer.style().visibility() == Visibility::Visible)
 567         return true;
 568     if (is&lt;RenderTextFragment&gt;(renderer)) {
 569         if (auto firstLetter = downcast&lt;RenderTextFragment&gt;(renderer).firstLetter()) {
 570             if (firstLetter-&gt;style().visibility() == Visibility::Visible)
 571                 return true;
 572         }
 573     }
 574     return false;
 575 }
 576 
<span class="line-removed"> 577 static unsigned textNodeOffsetInFlow(const Text&amp; firstTextNodeInRange)</span>
<span class="line-removed"> 578 {</span>
<span class="line-removed"> 579     // Calculate the text offset for simple lines.</span>
<span class="line-removed"> 580     RenderObject* renderer = firstTextNodeInRange.renderer();</span>
<span class="line-removed"> 581     if (!renderer)</span>
<span class="line-removed"> 582         return 0;</span>
<span class="line-removed"> 583     unsigned textOffset = 0;</span>
<span class="line-removed"> 584     for (renderer = renderer-&gt;previousSibling(); renderer; renderer = renderer-&gt;previousSibling()) {</span>
<span class="line-removed"> 585         if (is&lt;RenderText&gt;(renderer))</span>
<span class="line-removed"> 586             textOffset += downcast&lt;RenderText&gt;(renderer)-&gt;text().length();</span>
<span class="line-removed"> 587     }</span>
<span class="line-removed"> 588     return textOffset;</span>
<span class="line-removed"> 589 }</span>
<span class="line-removed"> 590 </span>
<span class="line-removed"> 591 static bool isNewLineOrTabCharacter(UChar character)</span>
<span class="line-removed"> 592 {</span>
<span class="line-removed"> 593     return character == &#39;\n&#39; || character == &#39;\t&#39;;</span>
<span class="line-removed"> 594 }</span>
<span class="line-removed"> 595 </span>
 596 bool TextIterator::handleTextNode()
 597 {
 598     Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
 599 
 600     if (m_fullyClippedStack.top() &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 601         return false;
 602 
 603     auto&amp; renderer = *textNode.renderer();
 604     m_lastTextNode = &amp;textNode;
 605     String rendererText = renderer.text();
 606 
 607     // handle pre-formatted text
 608     if (!renderer.style().collapseWhiteSpace()) {
 609         int runStart = m_offset;
 610         if (m_lastTextNodeEndedWithCollapsedSpace &amp;&amp; hasVisibleTextNode(renderer)) {
 611             emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart);
 612             return false;
 613         }
 614         if (!m_handledFirstLetter &amp;&amp; is&lt;RenderTextFragment&gt;(renderer) &amp;&amp; !m_offset) {
 615             handleTextNodeFirstLetter(downcast&lt;RenderTextFragment&gt;(renderer));
 616             if (m_firstLetterText) {
 617                 String firstLetter = m_firstLetterText-&gt;text();
 618                 emitText(textNode, *m_firstLetterText, m_offset, m_offset + firstLetter.length());
 619                 m_firstLetterText = nullptr;
<span class="line-modified"> 620                 m_textBox = nullptr;</span>
 621                 return false;
 622             }
 623         }
 624         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 625             return false;
 626         int rendererTextLength = rendererText.length();
 627         int end = (&amp;textNode == m_endContainer) ? m_endOffset : INT_MAX;
 628         int runEnd = std::min(rendererTextLength, end);
 629 
 630         if (runStart &gt;= runEnd)
 631             return true;
 632 
 633         emitText(textNode, renderer, runStart, runEnd);
 634         return true;
 635     }
 636 
<span class="line-modified"> 637     if (const auto* layout = renderer.simpleLineLayout()) {</span>
<span class="line-removed"> 638         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))</span>
<span class="line-removed"> 639             return true;</span>
<span class="line-removed"> 640         ASSERT(renderer.parent());</span>
<span class="line-removed"> 641         ASSERT(is&lt;RenderBlockFlow&gt;(*renderer.parent()));</span>
<span class="line-removed"> 642         const auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*renderer.parent());</span>
<span class="line-removed"> 643         // Use the simple layout runs to iterate over the text content.</span>
<span class="line-removed"> 644         bool isNewTextNode = m_previousSimpleTextNodeInFlow &amp;&amp; m_previousSimpleTextNodeInFlow != &amp;textNode;</span>
<span class="line-removed"> 645         // Simple line layout run positions are all absolute to the parent flow.</span>
<span class="line-removed"> 646         // Offsetting is required when multiple renderers are present.</span>
<span class="line-removed"> 647         m_accumulatedSimpleTextLengthInFlow += isNewTextNode ? m_previousSimpleTextNodeInFlow-&gt;renderer()-&gt;text().length() : 0;</span>
<span class="line-removed"> 648         m_previousSimpleTextNodeInFlow = &amp;textNode;</span>
<span class="line-removed"> 649 </span>
<span class="line-removed"> 650         unsigned endPosition = (m_node == m_endContainer) ? static_cast&lt;unsigned&gt;(m_endOffset) : rendererText.length();</span>
<span class="line-removed"> 651         if (!m_flowRunResolverCache || &amp;m_flowRunResolverCache-&gt;flow() != &amp;blockFlow) {</span>
<span class="line-removed"> 652             m_accumulatedSimpleTextLengthInFlow = m_flowRunResolverCache ? 0 : textNodeOffsetInFlow(textNode);</span>
<span class="line-removed"> 653             m_flowRunResolverCache = makeUnique&lt;SimpleLineLayout::RunResolver&gt;(blockFlow, *layout);</span>
<span class="line-removed"> 654         }</span>
<span class="line-removed"> 655         // Skip to m_offset position.</span>
<span class="line-removed"> 656         auto range = m_flowRunResolverCache-&gt;rangeForRenderer(renderer);</span>
<span class="line-removed"> 657         auto it = range.begin();</span>
<span class="line-removed"> 658         auto end = range.end();</span>
<span class="line-removed"> 659         auto startPosition = static_cast&lt;unsigned&gt;(m_offset) + m_accumulatedSimpleTextLengthInFlow;</span>
<span class="line-removed"> 660         while (it != end &amp;&amp; (*it).end() &lt;= startPosition)</span>
<span class="line-removed"> 661             ++it;</span>
<span class="line-removed"> 662         if (m_nextRunNeedsWhitespace &amp;&amp; rendererText[m_offset - 1] == &#39;\n&#39;) {</span>
<span class="line-removed"> 663             emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);</span>
<span class="line-removed"> 664             return it == end;</span>
<span class="line-removed"> 665         }</span>
<span class="line-removed"> 666         if (it == end) {</span>
<span class="line-removed"> 667             // Collapsed trailing whitespace.</span>
<span class="line-removed"> 668             m_offset = endPosition;</span>
<span class="line-removed"> 669             m_lastTextNodeEndedWithCollapsedSpace = true;</span>
<span class="line-removed"> 670             return true;</span>
<span class="line-removed"> 671         }</span>
<span class="line-removed"> 672         if (m_nextRunNeedsWhitespace) {</span>
<span class="line-removed"> 673             emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);</span>
<span class="line-removed"> 674             return false;</span>
<span class="line-removed"> 675         }</span>
<span class="line-removed"> 676         // If the position we are looking for is to the left of the renderer&#39;s first run, it could mean that</span>
<span class="line-removed"> 677         // the runs and the renderers are out of sync (e.g. we skipped a renderer in between).</span>
<span class="line-removed"> 678         // Better bail out at this point.</span>
<span class="line-removed"> 679         auto run = *it;</span>
<span class="line-removed"> 680         if (run.start() &gt; startPosition) {</span>
<span class="line-removed"> 681             ASSERT(m_flowRunResolverCache);</span>
<span class="line-removed"> 682             if (&amp;(rendererForPosition(m_flowRunResolverCache-&gt;flowContents(), startPosition)) != &amp;renderer) {</span>
<span class="line-removed"> 683                 ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 684                 return true;</span>
<span class="line-removed"> 685             }</span>
<span class="line-removed"> 686         }</span>
<span class="line-removed"> 687         ASSERT(run.end() - run.start() &lt;= rendererText.length());</span>
<span class="line-removed"> 688         // contentStart skips leading whitespace.</span>
<span class="line-removed"> 689         unsigned contentStart = std::max&lt;unsigned&gt;(m_offset, run.start() - m_accumulatedSimpleTextLengthInFlow);</span>
<span class="line-removed"> 690         unsigned contentEnd = std::min(endPosition, run.end() - m_accumulatedSimpleTextLengthInFlow);</span>
<span class="line-removed"> 691         ASSERT_WITH_SECURITY_IMPLICATION(contentStart &lt;= contentEnd);</span>
<span class="line-removed"> 692         // Check if whitespace adjustment is needed when crossing renderer boundary.</span>
<span class="line-removed"> 693         if (isNewTextNode) {</span>
<span class="line-removed"> 694             bool lastCharacterIsNotWhitespace = m_lastCharacter &amp;&amp; !renderer.style().isCollapsibleWhiteSpace(m_lastCharacter);</span>
<span class="line-removed"> 695             bool addTrailingWhitespaceForPrevious = m_lastTextNodeEndedWithCollapsedSpace &amp;&amp; lastCharacterIsNotWhitespace;</span>
<span class="line-removed"> 696             bool leadingWhitespaceIsNeededForCurrent = contentStart &gt; static_cast&lt;unsigned&gt;(m_offset) &amp;&amp; lastCharacterIsNotWhitespace;</span>
<span class="line-removed"> 697             if (addTrailingWhitespaceForPrevious || leadingWhitespaceIsNeededForCurrent) {</span>
<span class="line-removed"> 698                 emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);</span>
<span class="line-removed"> 699                 return false;</span>
<span class="line-removed"> 700             }</span>
<span class="line-removed"> 701         }</span>
<span class="line-removed"> 702         // \n \t single whitespace characters need replacing so that the new line/tab characters don&#39;t show up.</span>
<span class="line-removed"> 703         unsigned stopPosition = contentStart;</span>
<span class="line-removed"> 704         while (stopPosition &lt; contentEnd &amp;&amp; !isNewLineOrTabCharacter(rendererText[stopPosition]))</span>
<span class="line-removed"> 705             ++stopPosition;</span>
<span class="line-removed"> 706         // Emit the text up to the new line/tab character.</span>
<span class="line-removed"> 707         if (stopPosition &lt; contentEnd) {</span>
<span class="line-removed"> 708             if (stopPosition == contentStart) {</span>
<span class="line-removed"> 709                 emitCharacter(&#39; &#39;, textNode, nullptr, contentStart, contentStart + 1);</span>
<span class="line-removed"> 710                 m_offset = contentStart + 1;</span>
<span class="line-removed"> 711                 return false;</span>
<span class="line-removed"> 712             }</span>
<span class="line-removed"> 713             emitText(textNode, renderer, contentStart, stopPosition);</span>
<span class="line-removed"> 714             m_offset = stopPosition + 1;</span>
<span class="line-removed"> 715             m_nextRunNeedsWhitespace = true;</span>
<span class="line-removed"> 716             return false;</span>
<span class="line-removed"> 717         }</span>
<span class="line-removed"> 718         emitText(textNode, renderer, contentStart, contentEnd);</span>
<span class="line-removed"> 719         // When line ending with collapsed whitespace is present, we need to carry over one whitespace: foo(end of line)bar -&gt; foo bar (otherwise we would end up with foobar).</span>
<span class="line-removed"> 720         m_nextRunNeedsWhitespace = run.isEndOfLine() &amp;&amp; contentEnd &lt; endPosition &amp;&amp; renderer.style().isCollapsibleWhiteSpace(rendererText[contentEnd]);</span>
<span class="line-removed"> 721         m_offset = contentEnd;</span>
<span class="line-removed"> 722         return static_cast&lt;unsigned&gt;(m_offset) == endPosition;</span>
<span class="line-removed"> 723     }</span>
<span class="line-removed"> 724 </span>
<span class="line-removed"> 725     if (renderer.firstTextBox())</span>
<span class="line-removed"> 726         m_textBox = renderer.firstTextBox();</span>
 727 
 728     bool shouldHandleFirstLetter = !m_handledFirstLetter &amp;&amp; is&lt;RenderTextFragment&gt;(renderer) &amp;&amp; !m_offset;
 729     if (shouldHandleFirstLetter)
 730         handleTextNodeFirstLetter(downcast&lt;RenderTextFragment&gt;(renderer));
 731 
<span class="line-modified"> 732     if (!renderer.firstTextBox() &amp;&amp; rendererText.length() &amp;&amp; !shouldHandleFirstLetter) {</span>
 733         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 734             return false;
 735         m_lastTextNodeEndedWithCollapsedSpace = true; // entire block is collapsed space
 736         return true;
 737     }
 738 
<span class="line-removed"> 739     // Used when text boxes are out of order (Hebrew/Arabic w/ embeded LTR text)</span>
<span class="line-removed"> 740     auto&amp; boxesRenderer = m_firstLetterText ? *m_firstLetterText : renderer;</span>
<span class="line-removed"> 741     if (boxesRenderer.containsReversedText()) {</span>
<span class="line-removed"> 742         m_sortedTextBoxes.clear();</span>
<span class="line-removed"> 743         for (InlineTextBox* textBox = boxesRenderer.firstTextBox(); textBox; textBox = textBox-&gt;nextTextBox())</span>
<span class="line-removed"> 744             m_sortedTextBoxes.append(textBox);</span>
<span class="line-removed"> 745         std::sort(m_sortedTextBoxes.begin(), m_sortedTextBoxes.end(), InlineTextBox::compareByStart);</span>
<span class="line-removed"> 746         m_sortedTextBoxesPosition = 0;</span>
<span class="line-removed"> 747         m_textBox = m_sortedTextBoxes.isEmpty() ? nullptr : m_sortedTextBoxes[0];</span>
<span class="line-removed"> 748     }</span>
<span class="line-removed"> 749 </span>
 750     handleTextBox();
 751     return true;
 752 }
 753 
 754 void TextIterator::handleTextBox()
 755 {
 756     Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
 757 
 758     auto&amp; renderer = m_firstLetterText ? *m_firstLetterText : *textNode.renderer();
 759     if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility)) {
<span class="line-modified"> 760         m_textBox = nullptr;</span>
 761         return;
 762     }



 763     String rendererText = renderer.text();
 764     unsigned start = m_offset;
 765     unsigned end = (&amp;textNode == m_endContainer) ? static_cast&lt;unsigned&gt;(m_endOffset) : UINT_MAX;
 766     while (m_textBox) {
<span class="line-modified"> 767         unsigned textBoxStart = m_textBox-&gt;start();</span>
 768         unsigned runStart = std::max(textBoxStart, start);
 769 
 770         // Check for collapsed space at the start of this run.
<span class="line-removed"> 771         InlineTextBox* firstTextBox = renderer.containsReversedText() ? (m_sortedTextBoxes.isEmpty() ? nullptr : m_sortedTextBoxes[0]) : renderer.firstTextBox();</span>
 772         bool needSpace = m_lastTextNodeEndedWithCollapsedSpace || (m_textBox == firstTextBox &amp;&amp; textBoxStart == runStart &amp;&amp; runStart);
 773         if (needSpace &amp;&amp; !renderer.style().isCollapsibleWhiteSpace(m_lastCharacter) &amp;&amp; m_lastCharacter) {
 774             if (m_lastTextNode == &amp;textNode &amp;&amp; runStart &amp;&amp; rendererText[runStart - 1] == &#39; &#39;) {
 775                 unsigned spaceRunStart = runStart - 1;
 776                 while (spaceRunStart &amp;&amp; rendererText[spaceRunStart - 1] == &#39; &#39;)
 777                     --spaceRunStart;
 778                 emitText(textNode, renderer, spaceRunStart, spaceRunStart + 1);
 779             } else
 780                 emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart);
 781             return;
 782         }
<span class="line-modified"> 783         unsigned textBoxEnd = textBoxStart + m_textBox-&gt;len();</span>
 784         unsigned runEnd = std::min(textBoxEnd, end);
 785 
 786         // Determine what the next text box will be, but don&#39;t advance yet
<span class="line-modified"> 787         InlineTextBox* nextTextBox = nullptr;</span>
<span class="line-modified"> 788         if (renderer.containsReversedText()) {</span>
<span class="line-removed"> 789             if (m_sortedTextBoxesPosition + 1 &lt; m_sortedTextBoxes.size())</span>
<span class="line-removed"> 790                 nextTextBox = m_sortedTextBoxes[m_sortedTextBoxesPosition + 1];</span>
<span class="line-removed"> 791         } else</span>
<span class="line-removed"> 792             nextTextBox = m_textBox-&gt;nextTextBox();</span>
<span class="line-removed"> 793         ASSERT(!nextTextBox || &amp;nextTextBox-&gt;renderer() == &amp;renderer);</span>
 794 
 795         if (runStart &lt; runEnd) {
<span class="line-modified"> 796             // Handle either a single newline character (which becomes a space),</span>
<span class="line-modified"> 797             // or a run of characters that does not include a newline.</span>
<span class="line-modified"> 798             // This effectively translates newlines to spaces without copying the text.</span>
<span class="line-modified"> 799             if (rendererText[runStart] == &#39;\n&#39;) {</span>



 800                 emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart + 1);
 801                 m_offset = runStart + 1;
 802             } else {
<span class="line-modified"> 803                 size_t subrunEnd = rendererText.find(&#39;\n&#39;, runStart);</span>
<span class="line-modified"> 804                 if (subrunEnd == notFound || subrunEnd &gt; runEnd) {</span>
<span class="line-modified"> 805                     subrunEnd = runEnd;</span>
<span class="line-modified"> 806                     bool lastSpaceCollapsedByNextNonTextBox = !nextTextBox &amp;&amp; (m_behavior &amp; TextIteratorBehavesAsIfNodesFollowing) &amp;&amp; rendererText.length() &gt; runEnd;</span>



 807                     if (lastSpaceCollapsedByNextNonTextBox)
 808                         ++subrunEnd; // runEnd stopped before last space. Increment by one to restore the space.
 809                 }
 810                 m_offset = subrunEnd;
 811                 emitText(textNode, renderer, runStart, subrunEnd);
 812             }
 813 
 814             // If we are doing a subrun that doesn&#39;t go to the end of the text box,
 815             // come back again to finish handling this text box; don&#39;t advance to the next one.
 816             if (static_cast&lt;unsigned&gt;(m_positionEndOffset) &lt; textBoxEnd)
 817                 return;
 818 
 819             // Advance and return
<span class="line-modified"> 820             unsigned nextRunStart = nextTextBox ? nextTextBox-&gt;start() : rendererText.length();</span>
 821             if (nextRunStart &gt; runEnd)
 822                 m_lastTextNodeEndedWithCollapsedSpace = true; // collapsed space between runs or at the end
 823             m_textBox = nextTextBox;
<span class="line-removed"> 824             if (renderer.containsReversedText())</span>
<span class="line-removed"> 825                 ++m_sortedTextBoxesPosition;</span>
 826             return;
 827         }
 828         // Advance and continue
 829         m_textBox = nextTextBox;
<span class="line-removed"> 830         if (renderer.containsReversedText())</span>
<span class="line-removed"> 831             ++m_sortedTextBoxesPosition;</span>
 832     }
 833     if (!m_textBox &amp;&amp; m_remainingTextBox) {
 834         m_textBox = m_remainingTextBox;
<span class="line-modified"> 835         m_remainingTextBox = nullptr;</span>
<span class="line-modified"> 836         m_firstLetterText = nullptr;</span>
 837         m_offset = 0;
 838         handleTextBox();
 839     }
 840 }
 841 
 842 static inline RenderText* firstRenderTextInFirstLetter(RenderBoxModelObject* firstLetter)
 843 {
 844     if (!firstLetter)
 845         return nullptr;
 846 
 847     // FIXME: Should this check descendent objects?
 848     return childrenOfType&lt;RenderText&gt;(*firstLetter).first();
 849 }
 850 
 851 void TextIterator::handleTextNodeFirstLetter(RenderTextFragment&amp; renderer)
 852 {
 853     if (auto* firstLetter = renderer.firstLetter()) {
 854         if (firstLetter-&gt;style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 855             return;
 856         if (auto* firstLetterText = firstRenderTextInFirstLetter(firstLetter)) {
 857             m_handledFirstLetter = true;
 858             m_remainingTextBox = m_textBox;
<span class="line-modified"> 859             m_textBox = firstLetterText-&gt;firstTextBox();</span>
<span class="line-removed"> 860             m_sortedTextBoxes.clear();</span>
 861             m_firstLetterText = firstLetterText;
 862         }
 863     }
 864     m_handledFirstLetter = true;
 865 }
 866 
 867 bool TextIterator::handleReplacedElement()
 868 {
 869     if (m_fullyClippedStack.top())
 870         return false;
 871 
 872     auto&amp; renderer = *m_node-&gt;renderer();
 873     if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 874         return false;
 875 
 876     if (m_lastTextNodeEndedWithCollapsedSpace) {
 877         emitCharacter(&#39; &#39;, *m_lastTextNode-&gt;parentNode(), m_lastTextNode, 1, 1);
 878         return false;
 879     }
 880 
</pre>
<hr />
<pre>
1205 
1206     // If nothing was emitted, see if we need to emit a space.
1207     if (!m_positionNode &amp;&amp; shouldEmitSpaceBeforeAndAfterNode(*m_node))
1208         emitCharacter(&#39; &#39;, *baseNode-&gt;parentNode(), baseNode, 1, 1);
1209 }
1210 
1211 void TextIterator::emitCharacter(UChar character, Node&amp; characterNode, Node* offsetBaseNode, int textStartOffset, int textEndOffset)
1212 {
1213     m_hasEmitted = true;
1214 
1215     // remember information with which to construct the TextIterator::range()
1216     m_positionNode = &amp;characterNode;
1217     m_positionOffsetBaseNode = offsetBaseNode;
1218     m_positionStartOffset = textStartOffset;
1219     m_positionEndOffset = textEndOffset;
1220 
1221     m_copyableText.set(character);
1222     m_text = m_copyableText.text();
1223     m_lastCharacter = character;
1224     m_lastTextNodeEndedWithCollapsedSpace = false;
<span class="line-removed">1225     m_nextRunNeedsWhitespace = false;</span>
1226 }
1227 
1228 void TextIterator::emitText(Text&amp; textNode, RenderText&amp; renderer, int textStartOffset, int textEndOffset)
1229 {
1230     ASSERT(textStartOffset &gt;= 0);
1231     ASSERT(textEndOffset &gt;= 0);
1232     ASSERT(textStartOffset &lt;= textEndOffset);
1233 
1234     // FIXME: This probably yields the wrong offsets when text-transform: lowercase turns a single character into two characters.
1235     String string = (m_behavior &amp; TextIteratorEmitsOriginalText) ? renderer.originalText()
1236         : ((m_behavior &amp; TextIteratorEmitsTextsWithoutTranscoding) ? renderer.textWithoutConvertingBackslashToYenSymbol() : renderer.text());
1237 
1238     ASSERT(string.length() &gt;= static_cast&lt;unsigned&gt;(textEndOffset));
1239 
1240     m_positionNode = &amp;textNode;
1241     m_positionOffsetBaseNode = nullptr;
1242     m_positionStartOffset = textStartOffset;
1243     m_positionEndOffset = textEndOffset;
1244 
1245     m_lastCharacter = string[textEndOffset - 1];
1246     m_copyableText.set(WTFMove(string), textStartOffset, textEndOffset - textStartOffset);
1247     m_text = m_copyableText.text();
1248 
1249     m_lastTextNodeEndedWithCollapsedSpace = false;
<span class="line-removed">1250     m_nextRunNeedsWhitespace = false;</span>
1251     m_hasEmitted = true;
1252 }
1253 
1254 Ref&lt;Range&gt; TextIterator::range() const
1255 {
1256     ASSERT(!atEnd());
1257 
1258     // use the current run information, if we have it
1259     if (m_positionOffsetBaseNode) {
1260         unsigned index = m_positionOffsetBaseNode-&gt;computeNodeIndex();
1261         m_positionStartOffset += index;
1262         m_positionEndOffset += index;
1263         m_positionOffsetBaseNode = nullptr;
1264     }
1265     return Range::create(m_positionNode-&gt;document(), m_positionNode, m_positionStartOffset, m_positionNode, m_positionEndOffset);
1266 }
1267 
1268 Node* TextIterator::node() const
1269 {
1270     Ref&lt;Range&gt; textRange = range();
</pre>
</td>
<td>
<hr />
<pre>
 457     // reset the run information
 458     m_positionNode = nullptr;
 459     m_copyableText.reset();
 460     m_text = StringView();
 461 
 462     // handle remembered node that needed a newline after the text node&#39;s newline
 463     if (m_nodeForAdditionalNewline) {
 464         // Emit the extra newline, and position it *inside* m_node, after m_node&#39;s
 465         // contents, in case it&#39;s a block, in the same way that we position the first
 466         // newline. The range for the emitted newline should start where the line
 467         // break begins.
 468         // FIXME: It would be cleaner if we emitted two newlines during the last
 469         // iteration, instead of using m_needsAnotherNewline.
 470         emitCharacter(&#39;\n&#39;, *m_nodeForAdditionalNewline-&gt;parentNode(), m_nodeForAdditionalNewline, 1, 1);
 471         m_nodeForAdditionalNewline = nullptr;
 472         return;
 473     }
 474 
 475     if (!m_textBox &amp;&amp; m_remainingTextBox) {
 476         m_textBox = m_remainingTextBox;
<span class="line-modified"> 477         m_remainingTextBox = { };</span>
<span class="line-modified"> 478         m_firstLetterText = { };</span>
 479         m_offset = 0;
 480     }
 481     // handle remembered text box
 482     if (m_textBox) {
 483         handleTextBox();
 484         if (m_positionNode)
 485             return;
 486     }
 487 
 488     while (m_node &amp;&amp; m_node != m_pastEndNode) {
 489         // if the range ends at offset 0 of an element, represent the
 490         // position, but not the content, of that element e.g. if the
 491         // node is a blockflow element, emit a newline that
 492         // precedes the element
 493         if (m_node == m_endContainer &amp;&amp; !m_endOffset) {
 494             representNodeOffsetZero();
 495             m_node = nullptr;
 496             return;
 497         }
 498 
</pre>
<hr />
<pre>
 557 
 558         // how would this ever be?
 559         if (m_positionNode)
 560             return;
 561     }
 562 }
 563 
 564 static bool hasVisibleTextNode(RenderText&amp; renderer)
 565 {
 566     if (renderer.style().visibility() == Visibility::Visible)
 567         return true;
 568     if (is&lt;RenderTextFragment&gt;(renderer)) {
 569         if (auto firstLetter = downcast&lt;RenderTextFragment&gt;(renderer).firstLetter()) {
 570             if (firstLetter-&gt;style().visibility() == Visibility::Visible)
 571                 return true;
 572         }
 573     }
 574     return false;
 575 }
 576 



















 577 bool TextIterator::handleTextNode()
 578 {
 579     Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
 580 
 581     if (m_fullyClippedStack.top() &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 582         return false;
 583 
 584     auto&amp; renderer = *textNode.renderer();
 585     m_lastTextNode = &amp;textNode;
 586     String rendererText = renderer.text();
 587 
 588     // handle pre-formatted text
 589     if (!renderer.style().collapseWhiteSpace()) {
 590         int runStart = m_offset;
 591         if (m_lastTextNodeEndedWithCollapsedSpace &amp;&amp; hasVisibleTextNode(renderer)) {
 592             emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart);
 593             return false;
 594         }
 595         if (!m_handledFirstLetter &amp;&amp; is&lt;RenderTextFragment&gt;(renderer) &amp;&amp; !m_offset) {
 596             handleTextNodeFirstLetter(downcast&lt;RenderTextFragment&gt;(renderer));
 597             if (m_firstLetterText) {
 598                 String firstLetter = m_firstLetterText-&gt;text();
 599                 emitText(textNode, *m_firstLetterText, m_offset, m_offset + firstLetter.length());
 600                 m_firstLetterText = nullptr;
<span class="line-modified"> 601                 m_textBox = { };</span>
 602                 return false;
 603             }
 604         }
 605         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 606             return false;
 607         int rendererTextLength = rendererText.length();
 608         int end = (&amp;textNode == m_endContainer) ? m_endOffset : INT_MAX;
 609         int runEnd = std::min(rendererTextLength, end);
 610 
 611         if (runStart &gt;= runEnd)
 612             return true;
 613 
 614         emitText(textNode, renderer, runStart, runEnd);
 615         return true;
 616     }
 617 
<span class="line-modified"> 618     m_textBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(renderer);</span>

























































































 619 
 620     bool shouldHandleFirstLetter = !m_handledFirstLetter &amp;&amp; is&lt;RenderTextFragment&gt;(renderer) &amp;&amp; !m_offset;
 621     if (shouldHandleFirstLetter)
 622         handleTextNodeFirstLetter(downcast&lt;RenderTextFragment&gt;(renderer));
 623 
<span class="line-modified"> 624     if (!m_textBox &amp;&amp; rendererText.length() &amp;&amp; !shouldHandleFirstLetter) {</span>
 625         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 626             return false;
 627         m_lastTextNodeEndedWithCollapsedSpace = true; // entire block is collapsed space
 628         return true;
 629     }
 630 











 631     handleTextBox();
 632     return true;
 633 }
 634 
 635 void TextIterator::handleTextBox()
 636 {
 637     Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
 638 
 639     auto&amp; renderer = m_firstLetterText ? *m_firstLetterText : *textNode.renderer();
 640     if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility)) {
<span class="line-modified"> 641         m_textBox = { };</span>
 642         return;
 643     }
<span class="line-added"> 644 </span>
<span class="line-added"> 645     auto firstTextBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(renderer);</span>
<span class="line-added"> 646 </span>
 647     String rendererText = renderer.text();
 648     unsigned start = m_offset;
 649     unsigned end = (&amp;textNode == m_endContainer) ? static_cast&lt;unsigned&gt;(m_endOffset) : UINT_MAX;
 650     while (m_textBox) {
<span class="line-modified"> 651         unsigned textBoxStart = m_textBox-&gt;localStartOffset();</span>
 652         unsigned runStart = std::max(textBoxStart, start);
 653 
 654         // Check for collapsed space at the start of this run.

 655         bool needSpace = m_lastTextNodeEndedWithCollapsedSpace || (m_textBox == firstTextBox &amp;&amp; textBoxStart == runStart &amp;&amp; runStart);
 656         if (needSpace &amp;&amp; !renderer.style().isCollapsibleWhiteSpace(m_lastCharacter) &amp;&amp; m_lastCharacter) {
 657             if (m_lastTextNode == &amp;textNode &amp;&amp; runStart &amp;&amp; rendererText[runStart - 1] == &#39; &#39;) {
 658                 unsigned spaceRunStart = runStart - 1;
 659                 while (spaceRunStart &amp;&amp; rendererText[spaceRunStart - 1] == &#39; &#39;)
 660                     --spaceRunStart;
 661                 emitText(textNode, renderer, spaceRunStart, spaceRunStart + 1);
 662             } else
 663                 emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart);
 664             return;
 665         }
<span class="line-modified"> 666         unsigned textBoxEnd = textBoxStart + m_textBox-&gt;length();</span>
 667         unsigned runEnd = std::min(textBoxEnd, end);
 668 
 669         // Determine what the next text box will be, but don&#39;t advance yet
<span class="line-modified"> 670         auto nextTextBox = m_textBox;</span>
<span class="line-modified"> 671         nextTextBox.traverseNextInTextOrder();</span>





 672 
 673         if (runStart &lt; runEnd) {
<span class="line-modified"> 674             auto isNewlineOrTab = [&amp;](UChar character) {</span>
<span class="line-modified"> 675                 return character == &#39;\n&#39; || character == &#39;\t&#39;;</span>
<span class="line-modified"> 676             };</span>
<span class="line-modified"> 677             // Handle either a single newline or tab character (which becomes a space),</span>
<span class="line-added"> 678             // or a run of characters that does not include newlines or tabs.</span>
<span class="line-added"> 679             // This effectively translates newlines and tabs to spaces without copying the text.</span>
<span class="line-added"> 680             if (isNewlineOrTab(rendererText[runStart])) {</span>
 681                 emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart + 1);
 682                 m_offset = runStart + 1;
 683             } else {
<span class="line-modified"> 684                 auto subrunEnd = runStart + 1;</span>
<span class="line-modified"> 685                 for (; subrunEnd &lt; runEnd; ++subrunEnd) {</span>
<span class="line-modified"> 686                     if (isNewlineOrTab(rendererText[subrunEnd]))</span>
<span class="line-modified"> 687                         break;</span>
<span class="line-added"> 688                 }</span>
<span class="line-added"> 689                 if (subrunEnd == runEnd &amp;&amp; (m_behavior &amp; TextIteratorBehavesAsIfNodesFollowing)) {</span>
<span class="line-added"> 690                     bool lastSpaceCollapsedByNextNonTextBox = !nextTextBox &amp;&amp; rendererText.length() &gt; subrunEnd &amp;&amp; rendererText[subrunEnd] == &#39; &#39;;</span>
 691                     if (lastSpaceCollapsedByNextNonTextBox)
 692                         ++subrunEnd; // runEnd stopped before last space. Increment by one to restore the space.
 693                 }
 694                 m_offset = subrunEnd;
 695                 emitText(textNode, renderer, runStart, subrunEnd);
 696             }
 697 
 698             // If we are doing a subrun that doesn&#39;t go to the end of the text box,
 699             // come back again to finish handling this text box; don&#39;t advance to the next one.
 700             if (static_cast&lt;unsigned&gt;(m_positionEndOffset) &lt; textBoxEnd)
 701                 return;
 702 
 703             // Advance and return
<span class="line-modified"> 704             unsigned nextRunStart = nextTextBox ? nextTextBox-&gt;localStartOffset() : rendererText.length();</span>
 705             if (nextRunStart &gt; runEnd)
 706                 m_lastTextNodeEndedWithCollapsedSpace = true; // collapsed space between runs or at the end
 707             m_textBox = nextTextBox;


 708             return;
 709         }
 710         // Advance and continue
 711         m_textBox = nextTextBox;


 712     }
 713     if (!m_textBox &amp;&amp; m_remainingTextBox) {
 714         m_textBox = m_remainingTextBox;
<span class="line-modified"> 715         m_remainingTextBox = { };</span>
<span class="line-modified"> 716         m_firstLetterText = { };</span>
 717         m_offset = 0;
 718         handleTextBox();
 719     }
 720 }
 721 
 722 static inline RenderText* firstRenderTextInFirstLetter(RenderBoxModelObject* firstLetter)
 723 {
 724     if (!firstLetter)
 725         return nullptr;
 726 
 727     // FIXME: Should this check descendent objects?
 728     return childrenOfType&lt;RenderText&gt;(*firstLetter).first();
 729 }
 730 
 731 void TextIterator::handleTextNodeFirstLetter(RenderTextFragment&amp; renderer)
 732 {
 733     if (auto* firstLetter = renderer.firstLetter()) {
 734         if (firstLetter-&gt;style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 735             return;
 736         if (auto* firstLetterText = firstRenderTextInFirstLetter(firstLetter)) {
 737             m_handledFirstLetter = true;
 738             m_remainingTextBox = m_textBox;
<span class="line-modified"> 739             m_textBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(*firstLetterText);</span>

 740             m_firstLetterText = firstLetterText;
 741         }
 742     }
 743     m_handledFirstLetter = true;
 744 }
 745 
 746 bool TextIterator::handleReplacedElement()
 747 {
 748     if (m_fullyClippedStack.top())
 749         return false;
 750 
 751     auto&amp; renderer = *m_node-&gt;renderer();
 752     if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 753         return false;
 754 
 755     if (m_lastTextNodeEndedWithCollapsedSpace) {
 756         emitCharacter(&#39; &#39;, *m_lastTextNode-&gt;parentNode(), m_lastTextNode, 1, 1);
 757         return false;
 758     }
 759 
</pre>
<hr />
<pre>
1084 
1085     // If nothing was emitted, see if we need to emit a space.
1086     if (!m_positionNode &amp;&amp; shouldEmitSpaceBeforeAndAfterNode(*m_node))
1087         emitCharacter(&#39; &#39;, *baseNode-&gt;parentNode(), baseNode, 1, 1);
1088 }
1089 
1090 void TextIterator::emitCharacter(UChar character, Node&amp; characterNode, Node* offsetBaseNode, int textStartOffset, int textEndOffset)
1091 {
1092     m_hasEmitted = true;
1093 
1094     // remember information with which to construct the TextIterator::range()
1095     m_positionNode = &amp;characterNode;
1096     m_positionOffsetBaseNode = offsetBaseNode;
1097     m_positionStartOffset = textStartOffset;
1098     m_positionEndOffset = textEndOffset;
1099 
1100     m_copyableText.set(character);
1101     m_text = m_copyableText.text();
1102     m_lastCharacter = character;
1103     m_lastTextNodeEndedWithCollapsedSpace = false;

1104 }
1105 
1106 void TextIterator::emitText(Text&amp; textNode, RenderText&amp; renderer, int textStartOffset, int textEndOffset)
1107 {
1108     ASSERT(textStartOffset &gt;= 0);
1109     ASSERT(textEndOffset &gt;= 0);
1110     ASSERT(textStartOffset &lt;= textEndOffset);
1111 
1112     // FIXME: This probably yields the wrong offsets when text-transform: lowercase turns a single character into two characters.
1113     String string = (m_behavior &amp; TextIteratorEmitsOriginalText) ? renderer.originalText()
1114         : ((m_behavior &amp; TextIteratorEmitsTextsWithoutTranscoding) ? renderer.textWithoutConvertingBackslashToYenSymbol() : renderer.text());
1115 
1116     ASSERT(string.length() &gt;= static_cast&lt;unsigned&gt;(textEndOffset));
1117 
1118     m_positionNode = &amp;textNode;
1119     m_positionOffsetBaseNode = nullptr;
1120     m_positionStartOffset = textStartOffset;
1121     m_positionEndOffset = textEndOffset;
1122 
1123     m_lastCharacter = string[textEndOffset - 1];
1124     m_copyableText.set(WTFMove(string), textStartOffset, textEndOffset - textStartOffset);
1125     m_text = m_copyableText.text();
1126 
1127     m_lastTextNodeEndedWithCollapsedSpace = false;

1128     m_hasEmitted = true;
1129 }
1130 
1131 Ref&lt;Range&gt; TextIterator::range() const
1132 {
1133     ASSERT(!atEnd());
1134 
1135     // use the current run information, if we have it
1136     if (m_positionOffsetBaseNode) {
1137         unsigned index = m_positionOffsetBaseNode-&gt;computeNodeIndex();
1138         m_positionStartOffset += index;
1139         m_positionEndOffset += index;
1140         m_positionOffsetBaseNode = nullptr;
1141     }
1142     return Range::create(m_positionNode-&gt;document(), m_positionNode, m_positionStartOffset, m_positionNode, m_positionEndOffset);
1143 }
1144 
1145 Node* TextIterator::node() const
1146 {
1147     Ref&lt;Range&gt; textRange = range();
</pre>
</td>
</tr>
</table>
<center><a href="SpellingCorrectionCommand.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TextIterator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
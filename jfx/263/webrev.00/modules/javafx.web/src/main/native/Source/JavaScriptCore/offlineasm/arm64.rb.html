<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/arm64.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 # Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   2 # Copyright (C) 2014 University of Szeged. All rights reserved.
   3 #
   4 # Redistribution and use in source and binary forms, with or without
   5 # modification, are permitted provided that the following conditions
   6 # are met:
   7 # 1. Redistributions of source code must retain the above copyright
   8 #    notice, this list of conditions and the following disclaimer.
   9 # 2. Redistributions in binary form must reproduce the above copyright
  10 #    notice, this list of conditions and the following disclaimer in the
  11 #    documentation and/or other materials provided with the distribution.
  12 #
  13 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23 # THE POSSIBILITY OF SUCH DAMAGE.
  24 
  25 require &quot;ast&quot;
  26 require &quot;opt&quot;
  27 require &quot;risc&quot;
  28 
  29 # Naming conventions:
  30 #
  31 # x&lt;number&gt;  =&gt; GPR. This is both the generic name of the register, and the name used
  32 #               to indicate that the register is used in 64-bit mode.
  33 # w&lt;number&gt;  =&gt; GPR in 32-bit mode. This is the low 32-bits of the GPR. If it is
  34 #               mutated then the high 32-bit part of the register is zero filled.
  35 # q&lt;number&gt;  =&gt; FPR. This is the generic name of the register.
  36 # d&lt;number&gt;  =&gt; FPR used as an IEEE 64-bit binary floating point number (i.e. double).
  37 #
  38 # GPR conventions, to match the baseline JIT:
  39 #
  40 #  x0  =&gt; t0, a0, r0
  41 #  x1  =&gt; t1, a1, r1
  42 #  x2  =&gt; t2, a2
  43 #  x3  =&gt; t3, a3
  44 #  x4  =&gt; t4
  45 #  x5  =&gt; t5
  46 # x13  =&gt;                  (scratch)
  47 # x16  =&gt;                  (scratch)
  48 # x17  =&gt;                  (scratch)
  49 # x26  =&gt;             csr0 (PB)
  50 # x27  =&gt;             csr1 (numberTag)
  51 # x28  =&gt;             csr2 (notCellMask)
  52 # x29  =&gt; cfr
  53 #  sp  =&gt; sp
  54 #  lr  =&gt; lr
  55 #
  56 # FPR conventions, to match the baseline JIT:
  57 #
  58 #  q0  =&gt; ft0, fa0, fr
  59 #  q1  =&gt; ft1, fa1
  60 #  q2  =&gt; ft2, fa2
  61 #  q3  =&gt; ft3, fa3
  62 #  q4  =&gt; ft4          (unused in baseline)
  63 #  q5  =&gt; ft5          (unused in baseline)
  64 #  q8  =&gt; csfr0        (Only the lower 64 bits)
  65 #  q9  =&gt; csfr1        (Only the lower 64 bits)
  66 # q10  =&gt; csfr2        (Only the lower 64 bits)
  67 # q11  =&gt; csfr3        (Only the lower 64 bits)
  68 # q12  =&gt; csfr4        (Only the lower 64 bits)
  69 # q13  =&gt; csfr5        (Only the lower 64 bits)
  70 # q14  =&gt; csfr6        (Only the lower 64 bits)
  71 # q15  =&gt; csfr7        (Only the lower 64 bits)
  72 # q31  =&gt; scratch
  73 
  74 def arm64GPRName(name, kind)
  75     raise &quot;bad GPR name #{name}&quot; unless name =~ /^x/
  76     number = name[1..-1]
  77     case kind
  78     when :word
  79         &quot;w&quot; + number
  80     when :ptr
  81         prefix = $currentSettings[&quot;ADDRESS64&quot;] ? &quot;x&quot; : &quot;w&quot;
  82         prefix + number
  83     when :quad
  84         &quot;x&quot; + number
  85     else
  86         raise &quot;Wrong kind: #{kind}&quot;
  87     end
  88 end
  89 
  90 def arm64FPRName(name, kind)
  91     raise &quot;bad FPR name #{name}&quot; unless name =~ /^q/
  92     case kind
  93     when :double
  94         &quot;d&quot; + name[1..-1]
  95     when :float
  96         &quot;s&quot; + name[1..-1]
  97     when :vector
  98         &quot;v&quot; + name[1..-1]
  99     else
 100         raise &quot;bad FPR kind #{kind}&quot;
 101     end
 102 end
 103 
 104 class SpecialRegister
 105     def arm64Operand(kind)
 106         case @name
 107         when /^x/
 108             arm64GPRName(@name, kind)
 109         when /^q/
 110             arm64FPRName(@name, kind)
 111         else
 112             raise &quot;Bad name: #{@name}&quot;
 113         end
 114     end
 115 end
 116 
 117 ARM64_EXTRA_GPRS = [SpecialRegister.new(&quot;x16&quot;), SpecialRegister.new(&quot;x17&quot;), SpecialRegister.new(&quot;x13&quot;)]
 118 ARM64_EXTRA_FPRS = [SpecialRegister.new(&quot;q31&quot;)]
 119 
 120 class RegisterID
 121     def arm64Operand(kind)
 122         case @name
 123         when &#39;t0&#39;, &#39;a0&#39;, &#39;r0&#39;, &#39;wa0&#39;
 124             arm64GPRName(&#39;x0&#39;, kind)
 125         when &#39;t1&#39;, &#39;a1&#39;, &#39;r1&#39;, &#39;wa1&#39;
 126             arm64GPRName(&#39;x1&#39;, kind)
 127         when &#39;t2&#39;, &#39;a2&#39;, &#39;wa2&#39;
 128             arm64GPRName(&#39;x2&#39;, kind)
 129         when &#39;t3&#39;, &#39;a3&#39;, &#39;wa3&#39;
 130             arm64GPRName(&#39;x3&#39;, kind)
 131         when &#39;t4&#39;, &#39;wa4&#39;
 132             arm64GPRName(&#39;x4&#39;, kind)
 133         when &#39;t5&#39;, &#39;wa5&#39;
 134           arm64GPRName(&#39;x5&#39;, kind)
 135         when &#39;t6&#39;, &#39;wa6&#39;
 136           arm64GPRName(&#39;x6&#39;, kind)
 137         when &#39;t7&#39;, &#39;wa7&#39;
 138           arm64GPRName(&#39;x7&#39;, kind)
 139         when &#39;ws0&#39;
 140           arm64GPRName(&#39;x9&#39;, kind)
 141         when &#39;ws1&#39;
 142           arm64GPRName(&#39;x10&#39;, kind)
 143         when &#39;cfr&#39;
 144             arm64GPRName(&#39;x29&#39;, kind)
 145         when &#39;csr0&#39;
 146             arm64GPRName(&#39;x19&#39;, kind)
 147         when &#39;csr1&#39;
 148             arm64GPRName(&#39;x20&#39;, kind)
 149         when &#39;csr2&#39;
 150             arm64GPRName(&#39;x21&#39;, kind)
 151         when &#39;csr3&#39;
 152             arm64GPRName(&#39;x22&#39;, kind)
 153         when &#39;csr4&#39;
 154             arm64GPRName(&#39;x23&#39;, kind)
 155         when &#39;csr5&#39;
 156             arm64GPRName(&#39;x24&#39;, kind)
 157         when &#39;csr6&#39;
 158             arm64GPRName(&#39;x25&#39;, kind)
 159         when &#39;csr7&#39;
 160             arm64GPRName(&#39;x26&#39;, kind)
 161         when &#39;csr8&#39;
 162             arm64GPRName(&#39;x27&#39;, kind)
 163         when &#39;csr9&#39;
 164             arm64GPRName(&#39;x28&#39;, kind)
 165         when &#39;sp&#39;
 166             &#39;sp&#39;
 167         when &#39;lr&#39;
 168             &#39;x30&#39;
 169         else
 170             raise &quot;Bad register name #{@name} at #{codeOriginString}&quot;
 171         end
 172     end
 173 end
 174 
 175 class FPRegisterID
 176     def arm64Operand(kind)
 177         case @name
 178         when &#39;ft0&#39;, &#39;fr&#39;, &#39;fa0&#39;, &#39;wfa0&#39;
 179             arm64FPRName(&#39;q0&#39;, kind)
 180         when &#39;ft1&#39;, &#39;fa1&#39;, &#39;wfa1&#39;
 181             arm64FPRName(&#39;q1&#39;, kind)
 182         when &#39;ft2&#39;, &#39;fa2&#39;, &#39;wfa2&#39;
 183             arm64FPRName(&#39;q2&#39;, kind)
 184         when &#39;ft3&#39;, &#39;fa3&#39;, &#39;wfa3&#39;
 185             arm64FPRName(&#39;q3&#39;, kind)
 186         when &#39;ft4&#39;, &#39;wfa4&#39;
 187             arm64FPRName(&#39;q4&#39;, kind)
 188         when &#39;ft5&#39;, &#39;wfa5&#39;
 189             arm64FPRName(&#39;q5&#39;, kind)
 190         when &#39;wfa6&#39;
 191             arm64FPRName(&#39;q6&#39;, kind)
 192         when &#39;wfa7&#39;
 193             arm64FPRName(&#39;q7&#39;, kind)
 194         when &#39;csfr0&#39;
 195             arm64FPRName(&#39;q8&#39;, kind)
 196         when &#39;csfr1&#39;
 197             arm64FPRName(&#39;q9&#39;, kind)
 198         when &#39;csfr2&#39;
 199             arm64FPRName(&#39;q10&#39;, kind)
 200         when &#39;csfr3&#39;
 201             arm64FPRName(&#39;q11&#39;, kind)
 202         when &#39;csfr4&#39;
 203             arm64FPRName(&#39;q12&#39;, kind)
 204         when &#39;csfr5&#39;
 205             arm64FPRName(&#39;q13&#39;, kind)
 206         when &#39;csfr6&#39;
 207             arm64FPRName(&#39;q14&#39;, kind)
 208         when &#39;csfr7&#39;
 209             arm64FPRName(&#39;q15&#39;, kind)
 210         else &quot;Bad register name #{@name} at #{codeOriginString}&quot;
 211         end
 212     end
 213 end
 214 
 215 class Immediate
 216     def arm64Operand(kind)
 217         &quot;\##{value}&quot;
 218     end
 219 end
 220 
 221 class Address
 222     def arm64Operand(kind)
 223         raise &quot;Invalid offset #{offset.value} at #{codeOriginString}&quot; if offset.value &lt; -255 or offset.value &gt; 4095
 224         &quot;[#{base.arm64Operand(:quad)}, \##{offset.value}]&quot;
 225     end
 226     
 227     def arm64EmitLea(destination, kind)
 228         $asm.puts &quot;add #{destination.arm64Operand(kind)}, #{base.arm64Operand(kind)}, \##{offset.value}&quot;
 229     end
 230 end
 231 
 232 class BaseIndex
 233     def arm64Operand(kind)
 234         raise &quot;Invalid offset #{offset.value} at #{codeOriginString}&quot; if offset.value != 0
 235         &quot;[#{base.arm64Operand(:quad)}, #{index.arm64Operand(:quad)}, lsl \##{scaleShift}]&quot;
 236     end
 237 
 238     def arm64EmitLea(destination, kind)
 239         $asm.puts &quot;add #{destination.arm64Operand(kind)}, #{base.arm64Operand(kind)}, #{index.arm64Operand(kind)}, lsl \##{scaleShift}&quot;
 240     end
 241 end
 242 
 243 class AbsoluteAddress
 244     def arm64Operand(kind)
 245         raise &quot;Unconverted absolute address #{address.value} at #{codeOriginString}&quot;
 246     end
 247 end
 248 
 249 # FIXME: We could support AbsoluteAddress for lea, but we don&#39;t.
 250 
 251 #
 252 # Actual lowering code follows.
 253 #
 254 
 255 def arm64LowerMalformedLoadStoreAddresses(list)
 256     newList = []
 257 
 258     def isAddressMalformed(opcode, operand)
 259         malformed = false
 260         if operand.is_a? Address
 261             malformed ||= (not (-255..4095).include? operand.offset.value)
 262             if opcode =~ /q$/ and $currentSettings[&quot;ADDRESS64&quot;]
 263                 malformed ||= operand.offset.value % 8
 264             end
 265         end
 266         malformed
 267     end
 268 
 269     list.each {
 270         | node |
 271         if node.is_a? Instruction
 272             if node.opcode =~ /^store/ and isAddressMalformed(node.opcode, node.operands[1])
 273                 address = node.operands[1]
 274                 tmp = Tmp.new(codeOrigin, :gpr)
 275                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [address.offset, tmp])
 276                 newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [node.operands[0], BaseIndex.new(node.codeOrigin, address.base, tmp, Immediate.new(codeOrigin, 1), Immediate.new(codeOrigin, 0))], node.annotation)
 277             elsif node.opcode =~ /^load/ and isAddressMalformed(node.opcode, node.operands[0])
 278                 address = node.operands[0]
 279                 tmp = Tmp.new(codeOrigin, :gpr)
 280                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [address.offset, tmp])
 281                 newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [BaseIndex.new(node.codeOrigin, address.base, tmp, Immediate.new(codeOrigin, 1), Immediate.new(codeOrigin, 0)), node.operands[1]], node.annotation)
 282             else
 283                 newList &lt;&lt; node
 284             end
 285         else
 286             newList &lt;&lt; node
 287         end
 288     }
 289     newList
 290 end
 291 
 292 def arm64LowerLabelReferences(list)
 293     newList = []
 294     list.each {
 295         | node |
 296         if node.is_a? Instruction
 297             case node.opcode
 298             when &quot;loadi&quot;, &quot;loadis&quot;, &quot;loadp&quot;, &quot;loadq&quot;, &quot;loadb&quot;, &quot;loadbsi&quot;, &quot;loadbsq&quot;, &quot;loadh&quot;, &quot;loadhsi&quot;, &quot;loadhsq&quot;, &quot;leap&quot;
 299                 labelRef = node.operands[0]
 300                 if labelRef.is_a? LabelReference
 301                     tmp = Tmp.new(node.codeOrigin, :gpr)
 302                     newList &lt;&lt; Instruction.new(codeOrigin, &quot;globaladdr&quot;, [LabelReference.new(node.codeOrigin, labelRef.label), tmp])
 303                     newList &lt;&lt; Instruction.new(codeOrigin, node.opcode, [Address.new(node.codeOrigin, tmp, Immediate.new(node.codeOrigin, labelRef.offset)), node.operands[1]])
 304                 else
 305                     newList &lt;&lt; node
 306                 end
 307             else
 308                 newList &lt;&lt; node
 309             end
 310         else
 311             newList &lt;&lt; node
 312         end
 313     }
 314     newList
 315 end
 316 
 317 def arm64FixSpecialRegisterArithmeticMode(list)
 318     newList = []
 319     def usesSpecialRegister(node)
 320         node.children.any? {
 321             |operand|
 322             if operand.is_a? RegisterID and operand.name =~ /sp/
 323                 true
 324             elsif operand.is_a? Address or operand.is_a? BaseIndex
 325                 usesSpecialRegister(operand)
 326             else
 327                 false
 328             end
 329         }
 330     end
 331 
 332 
 333     list.each {
 334         | node |
 335         if node.is_a? Instruction
 336             case node.opcode
 337             when &quot;addp&quot;, &quot;subp&quot;, &quot;mulp&quot;, &quot;divp&quot;, &quot;leap&quot;
 338                 if not $currentSettings[&quot;ADDRESS64&quot;] and usesSpecialRegister(node)
 339                     newOpcode = node.opcode.sub(/(.*)p/, &#39;\1q&#39;)
 340                     node = Instruction.new(node.codeOrigin, newOpcode, node.operands, node.annotation)
 341                 end
 342             when /^bp/
 343                 if not $currentSettings[&quot;ADDRESS64&quot;] and usesSpecialRegister(node)
 344                     newOpcode = node.opcode.sub(/^bp(.*)/, &#39;bq\1&#39;)
 345                     node = Instruction.new(node.codeOrigin, newOpcode, node.operands, node.annotation)
 346                 end
 347             end
 348         end
 349         newList &lt;&lt; node
 350     }
 351     newList
 352 end
 353 
 354 # Workaround for Cortex-A53 erratum (835769)
 355 def arm64CortexA53Fix835769(list)
 356     newList = []
 357     lastOpcodeUnsafe = false
 358 
 359     list.each {
 360         | node |
 361         if node.is_a? Instruction
 362             case node.opcode
 363             when /^store/, /^load/
 364                 # List all macro instructions that can be lowered to a load, store or prefetch ARM64 assembly instruction
 365                 lastOpcodeUnsafe = true
 366             when  &quot;muli&quot;, &quot;mulp&quot;, &quot;mulq&quot;, &quot;smulli&quot;
 367                 # List all macro instructions that can be lowered to a 64-bit multiply-accumulate ARM64 assembly instruction
 368                 # (defined as one of MADD, MSUB, SMADDL, SMSUBL, UMADDL or UMSUBL).
 369                 if lastOpcodeUnsafe
 370                     newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;nopCortexA53Fix835769&quot;, [])
 371                 end
 372                 lastOpcodeUnsafe = false
 373             else
 374                 lastOpcodeUnsafe = false
 375             end
 376         end
 377         newList &lt;&lt; node
 378     }
 379     newList
 380 end
 381 
 382 class Sequence
 383     def getModifiedListARM64(result = @list)
 384         result = riscLowerNot(result)
 385         result = riscLowerSimpleBranchOps(result)
 386 
 387         result = $currentSettings[&quot;ADDRESS64&quot;] ? riscLowerHardBranchOps64(result) : riscLowerHardBranchOps(result)
 388         result = riscLowerShiftOps(result)
 389         result = arm64LowerMalformedLoadStoreAddresses(result)
 390         result = arm64LowerLabelReferences(result)
 391         result = riscLowerMalformedAddresses(result) {
 392             | node, address |
 393             case node.opcode
 394             when &quot;loadb&quot;, &quot;loadbsi&quot;, &quot;loadbsq&quot;, &quot;storeb&quot;, /^bb/, /^btb/, /^cb/, /^tb/
 395                 size = 1
 396             when &quot;loadh&quot;, &quot;loadhsi&quot;, &quot;loadhsq&quot;, &quot;orh&quot;, &quot;storeh&quot;
 397                 size = 2
 398             when &quot;loadi&quot;, &quot;loadis&quot;, &quot;storei&quot;, &quot;addi&quot;, &quot;andi&quot;, &quot;lshifti&quot;, &quot;muli&quot;, &quot;negi&quot;,
 399                 &quot;noti&quot;, &quot;ori&quot;, &quot;rshifti&quot;, &quot;urshifti&quot;, &quot;subi&quot;, &quot;xori&quot;, /^bi/, /^bti/,
 400                 /^ci/, /^ti/, &quot;addis&quot;, &quot;subis&quot;, &quot;mulis&quot;, &quot;smulli&quot;, &quot;leai&quot;, &quot;loadf&quot;, &quot;storef&quot;
 401                 size = 4
 402             when &quot;loadp&quot;, &quot;storep&quot;, &quot;loadq&quot;, &quot;storeq&quot;, &quot;loadd&quot;, &quot;stored&quot;, &quot;lshiftp&quot;, &quot;lshiftq&quot;, &quot;negp&quot;, &quot;negq&quot;, &quot;rshiftp&quot;, &quot;rshiftq&quot;,
 403                 &quot;urshiftp&quot;, &quot;urshiftq&quot;, &quot;addp&quot;, &quot;addq&quot;, &quot;mulp&quot;, &quot;mulq&quot;, &quot;andp&quot;, &quot;andq&quot;, &quot;orp&quot;, &quot;orq&quot;, &quot;subp&quot;, &quot;subq&quot;, &quot;xorp&quot;, &quot;xorq&quot;, &quot;addd&quot;,
 404                 &quot;divd&quot;, &quot;subd&quot;, &quot;muld&quot;, &quot;sqrtd&quot;, /^bp/, /^bq/, /^btp/, /^btq/, /^cp/, /^cq/, /^tp/, /^tq/, /^bd/,
 405                 &quot;jmp&quot;, &quot;call&quot;, &quot;leap&quot;, &quot;leaq&quot;
 406                 size = $currentSettings[&quot;ADDRESS64&quot;] ? 8 : 4
 407             else
 408                 raise &quot;Bad instruction #{node.opcode} for heap access at #{node.codeOriginString}: #{node.dump}&quot;
 409             end
 410             
 411             if address.is_a? BaseIndex
 412                 address.offset.value == 0 and
 413                     (node.opcode =~ /^lea/ or address.scale == 1 or address.scale == size)
 414             elsif address.is_a? Address
 415                 (-255..4095).include? address.offset.value
 416             else
 417                 false
 418             end
 419         }
 420 
 421         result = riscLowerMisplacedImmediates(result, [&quot;storeb&quot;, &quot;storeh&quot;, &quot;storei&quot;, &quot;storep&quot;, &quot;storeq&quot;])
 422 
 423         # The rules for which immediates are valid for and/or/xor instructions are fairly involved, see https://dinfuehr.github.io/blog/encoding-of-immediate-values-on-aarch64/
 424         validLogicalImmediates = []
 425         def rotate(value, n, size)
 426             mask = (1 &lt;&lt; size) - 1
 427             shiftedValue = value &lt;&lt; n
 428             result = (shiftedValue &amp; mask) | ((shiftedValue &amp; ~mask) &gt;&gt; size)
 429             return result
 430         end
 431         def replicate(value, size)
 432             until size == 64 do
 433                 value = value | (value &lt;&lt; size)
 434                 size *= 2
 435             end
 436             return value
 437         end
 438         size = 2
 439         until size &gt; 64 do
 440             for numberOfOnes in 1..(size-1) do
 441                 for rotation in 0..(size-1) do
 442                     immediate = 0;
 443                     for i in 0..(numberOfOnes-1) do
 444                         immediate = immediate*2 + 1
 445                     end
 446                     immediate = rotate(immediate, rotation, size)
 447                     immediate = replicate(immediate, size)
 448                     validLogicalImmediates &lt;&lt; immediate
 449                 end
 450             end
 451             size *= 2
 452         end
 453         result = riscLowerMalformedImmediates(result, 0..4095, validLogicalImmediates)
 454 
 455         result = riscLowerMisplacedAddresses(result)
 456         result = riscLowerMalformedAddresses(result) {
 457             | node, address |
 458             case node.opcode
 459             when /^load/
 460                 true
 461             when /^store/
 462                 not (address.is_a? Address and address.offset.value &lt; 0)
 463             when /^lea/
 464                 true
 465             else
 466                 raise &quot;Bad instruction #{node.opcode} for heap access at #{node.codeOriginString}&quot;
 467             end
 468         }
 469         result = riscLowerTest(result)
 470         result = arm64FixSpecialRegisterArithmeticMode(result)
 471         result = assignRegistersToTemporaries(result, :gpr, ARM64_EXTRA_GPRS)
 472         result = assignRegistersToTemporaries(result, :fpr, ARM64_EXTRA_FPRS)
 473         result = arm64CortexA53Fix835769(result)
 474         return result
 475     end
 476 end
 477 
 478 def arm64Operands(operands, kinds)
 479     if kinds.is_a? Array
 480         raise &quot;Mismatched operand lists: #{operands.inspect} and #{kinds.inspect}&quot; if operands.size != kinds.size
 481     else
 482         kinds = operands.map{ kinds }
 483     end
 484     (0...operands.size).map {
 485         | index |
 486         operands[index].arm64Operand(kinds[index])
 487     }.join(&#39;, &#39;)
 488 end
 489 
 490 def arm64FlippedOperands(operands, kinds)
 491     if kinds.is_a? Array
 492         kinds = [kinds[-1]] + kinds[0..-2]
 493     end
 494     arm64Operands([operands[-1]] + operands[0..-2], kinds)
 495 end
 496 
 497 # TAC = three address code.
 498 def arm64TACOperands(operands, kind)
 499     if operands.size == 3
 500         return arm64FlippedOperands(operands, kind)
 501     end
 502     
 503     raise unless operands.size == 2
 504     
 505     return operands[1].arm64Operand(kind) + &quot;, &quot; + arm64FlippedOperands(operands, kind)
 506 end
 507 
 508 def emitARM64Add(opcode, operands, kind)
 509     if operands.size == 3
 510         raise unless operands[1].register?
 511         raise unless operands[2].register?
 512         
 513         if operands[0].immediate?
 514             if operands[0].value == 0 and opcode !~ /s$/
 515                 if operands[1] != operands[2]
 516                     $asm.puts &quot;mov #{arm64FlippedOperands(operands[1..2], kind)}&quot;
 517                 end
 518             else
 519                 $asm.puts &quot;#{opcode} #{arm64Operands(operands.reverse, kind)}&quot;
 520             end
 521             return
 522         end
 523         
 524         raise unless operands[0].register?
 525         $asm.puts &quot;#{opcode} #{arm64FlippedOperands(operands, kind)}&quot;
 526         return
 527     end
 528     
 529     raise unless operands.size == 2
 530     
 531     if operands[0].immediate? and operands[0].value == 0 and opcode !~ /s$/
 532         return
 533     end
 534     
 535     $asm.puts &quot;#{opcode} #{arm64TACOperands(operands, kind)}&quot;
 536 end
 537 
 538 def emitARM64Mul(opcode, operands, kind)
 539     if operands.size == 2 and operands[0].is_a? Immediate
 540         imm = operands[0].value
 541         if imm &gt; 0 and isPowerOfTwo(imm)
 542             emitARM64LShift([Immediate.new(nil, Math.log2(imm).to_i), operands[1]], kind)
 543             return
 544         end
 545     end
 546 
 547     $asm.puts &quot;madd #{arm64TACOperands(operands, kind)}, #{arm64GPRName(&#39;xzr&#39;, kind)}&quot;
 548 end
 549 
 550 def emitARM64Sub(opcode, operands, kind)
 551     if operands.size == 3
 552         raise unless operands[0].register?
 553         raise unless operands[2].register?
 554 
 555         if operands[1].immediate?
 556             if operands[1].value == 0 and opcode !~ /s$/
 557                 if operands[0] != operands[2]
 558                     $asm.puts &quot;mov #{arm64FlippedOperands([operands[0], operands[2]], kind)}&quot;
 559                 end
 560                 return
 561             end
 562         end
 563     end
 564 
 565     if operands.size == 2
 566         if operands[0].immediate? and operands[0].value == 0 and opcode !~ /s$/
 567             return
 568         end
 569     end
 570 
 571     emitARM64TAC(opcode, operands, kind)
 572 end
 573 
 574 def emitARM64Unflipped(opcode, operands, kind)
 575     $asm.puts &quot;#{opcode} #{arm64Operands(operands, kind)}&quot;
 576 end
 577 
 578 def emitARM64TAC(opcode, operands, kind)
 579     $asm.puts &quot;#{opcode} #{arm64TACOperands(operands, kind)}&quot;
 580 end
 581 
 582 def emitARM64Div(opcode, operands, kind)
 583     if operands.size == 2
 584         operands = [operands[1], operands[1], operands[0]]
 585     elsif operands.size == 3
 586         operands = [operands[2], operands[1], operands[0]]
 587     else
 588         raise
 589     end
 590     $asm.puts &quot;#{opcode} #{arm64Operands(operands, kind)}&quot;
 591 end
 592 
 593 def emitARM64TACWithOperandSuffix(opcode, operands, kind)
 594     raise unless [:float, :double].include? kind
 595     size = kind == :float ? 8 : 16
 596     operands = operands.map { |operand|
 597         raise unless operand.is_a? FPRegisterID
 598         &quot;#{operand.arm64Operand(:vector)}.#{size}b&quot;
 599     }
 600     if operands.length == 2
 601       operands = [operands[1], operands[1], operands[0]]
 602     else
 603       raise unless operands.length == 3
 604       operands = [operands[2], operands[0], operands[1]]
 605     end
 606     $asm.puts &quot;#{opcode} #{operands.join(&quot;, &quot;)}&quot;
 607 end
 608 
 609 def emitARM64(opcode, operands, kind)
 610     $asm.puts &quot;#{opcode} #{arm64FlippedOperands(operands, kind)}&quot;
 611 end
 612 
 613 def emitARM64Access(opcode, opcodeNegativeOffset, register, memory, kind)
 614     if memory.is_a? Address and memory.offset.value &lt; 0
 615         raise unless -256 &lt;= memory.offset.value
 616         $asm.puts &quot;#{opcodeNegativeOffset} #{register.arm64Operand(kind)}, #{memory.arm64Operand(kind)}&quot;
 617         return
 618     end
 619 
 620     $asm.puts &quot;#{opcode} #{register.arm64Operand(kind)}, #{memory.arm64Operand(kind)}&quot;
 621 end
 622 
 623 def emitARM64Shift(opcodeRegs, opcodeImmediate, operands, kind)
 624     if operands.size == 3 and operands[1].immediate?
 625         magicNumbers = yield operands[1].value
 626         $asm.puts &quot;#{opcodeImmediate} #{operands[2].arm64Operand(kind)}, #{operands[0].arm64Operand(kind)}, \##{magicNumbers[0]}, \##{magicNumbers[1]}&quot;
 627         return
 628     end
 629     
 630     if operands.size == 2 and operands[0].immediate?
 631         magicNumbers = yield operands[0].value
 632         $asm.puts &quot;#{opcodeImmediate} #{operands[1].arm64Operand(kind)}, #{operands[1].arm64Operand(kind)}, \##{magicNumbers[0]}, \##{magicNumbers[1]}&quot;
 633         return
 634     end
 635     
 636     emitARM64TAC(opcodeRegs, operands, kind)
 637 end
 638 
 639 def emitARM64LShift(operands, kind)
 640     emitARM64Shift(&quot;lslv&quot;, &quot;ubfm&quot;, operands, kind) {
 641         | value |
 642         case kind
 643         when :word
 644             [32 - value, 31 - value]
 645         when :ptr
 646             bitSize = $currentSettings[&quot;ADDRESS64&quot;] ? 64 : 32
 647             [bitSize - value, bitSize - 1 - value]
 648         when :quad
 649             [64 - value, 63 - value]
 650         end
 651     }
 652 end
 653 
 654 def emitARM64Branch(opcode, operands, kind, branchOpcode)
 655     emitARM64Unflipped(opcode, operands[0..-2], kind)
 656     $asm.puts &quot;#{branchOpcode} #{operands[-1].asmLabel}&quot;
 657 end
 658 
 659 def emitARM64CompareFP(operands, kind, compareCode)
 660     emitARM64Unflipped(&quot;fcmp&quot;, operands[0..-2], kind)
 661     $asm.puts &quot;cset #{operands[-1].arm64Operand(:word)}, #{compareCode}&quot;
 662 end
 663 
 664 def emitARM64Compare(operands, kind, compareCode)
 665     emitARM64Unflipped(&quot;subs #{arm64GPRName(&#39;xzr&#39;, kind)}, &quot;, operands[0..-2], kind)
 666     $asm.puts &quot;csinc #{operands[-1].arm64Operand(:word)}, wzr, wzr, #{compareCode}&quot;
 667 end
 668 
 669 def emitARM64MoveImmediate(value, target)
 670     first = true
 671     isNegative = value &lt; 0
 672     [48, 32, 16, 0].each {
 673         | shift |
 674         currentValue = (value &gt;&gt; shift) &amp; 0xffff
 675         next if currentValue == (isNegative ? 0xffff : 0) and (shift != 0 or !first)
 676         if first
 677             if isNegative
 678                 $asm.puts &quot;movn #{target.arm64Operand(:quad)}, \##{(~currentValue) &amp; 0xffff}, lsl \##{shift}&quot;
 679             else
 680                 $asm.puts &quot;movz #{target.arm64Operand(:quad)}, \##{currentValue}, lsl \##{shift}&quot;
 681             end
 682             first = false
 683         else
 684             $asm.puts &quot;movk #{target.arm64Operand(:quad)}, \##{currentValue}, lsl \##{shift}&quot;
 685         end
 686     }
 687 end
 688 
 689 class Instruction
 690     def lowerARM64
 691         case opcode
 692         when &#39;addi&#39;
 693             emitARM64Add(&quot;add&quot;, operands, :word)
 694         when &#39;addis&#39;
 695             emitARM64Add(&quot;adds&quot;, operands, :word)
 696         when &#39;addp&#39;
 697             emitARM64Add(&quot;add&quot;, operands, :ptr)
 698         when &#39;addps&#39;
 699             emitARM64Add(&quot;adds&quot;, operands, :ptr)
 700         when &#39;addq&#39;
 701             emitARM64Add(&quot;add&quot;, operands, :quad)
 702         when &quot;andi&quot;
 703             emitARM64TAC(&quot;and&quot;, operands, :word)
 704         when &quot;andp&quot;
 705             emitARM64TAC(&quot;and&quot;, operands, :ptr)
 706         when &quot;andq&quot;
 707             emitARM64TAC(&quot;and&quot;, operands, :quad)
 708         when &quot;ori&quot;
 709             emitARM64TAC(&quot;orr&quot;, operands, :word)
 710         when &quot;orp&quot;
 711             emitARM64TAC(&quot;orr&quot;, operands, :ptr)
 712         when &quot;orq&quot;
 713             emitARM64TAC(&quot;orr&quot;, operands, :quad)
 714         when &quot;orh&quot;
 715             emitARM64TAC(&quot;orr&quot;, operands, :word) # not :half because 16-bit registers don&#39;t exist on ARM.
 716         when &quot;xori&quot;
 717             emitARM64TAC(&quot;eor&quot;, operands, :word)
 718         when &quot;xorp&quot;
 719             emitARM64TAC(&quot;eor&quot;, operands, :ptr)
 720         when &quot;xorq&quot;
 721             emitARM64TAC(&quot;eor&quot;, operands, :quad)
 722         when &#39;divi&#39;
 723             emitARM64Div(&quot;udiv&quot;, operands, :word)
 724         when &#39;divis&#39;
 725             emitARM64Div(&quot;sdiv&quot;, operands, :word)
 726         when &#39;divq&#39;
 727             emitARM64Div(&quot;udiv&quot;, operands, :quad)
 728         when &#39;divqs&#39;
 729             emitARM64Div(&quot;sdiv&quot;, operands, :quad)
 730         when &quot;lshifti&quot;
 731             emitARM64LShift(operands, :word)
 732         when &quot;lshiftp&quot;
 733             emitARM64LShift(operands, :ptr)
 734         when &quot;lshiftq&quot;
 735             emitARM64LShift(operands, :quad)
 736         when &quot;rshifti&quot;
 737             emitARM64Shift(&quot;asrv&quot;, &quot;sbfm&quot;, operands, :word) {
 738                 | value |
 739                 [value, 31]
 740             }
 741         when &quot;rshiftp&quot;
 742             emitARM64Shift(&quot;asrv&quot;, &quot;sbfm&quot;, operands, :ptr) {
 743                 | value |
 744                 bitSize = $currentSettings[&quot;ADDRESS64&quot;] ? 64 : 32
 745                 [value, bitSize - 1]
 746             }
 747         when &quot;rshiftq&quot;
 748             emitARM64Shift(&quot;asrv&quot;, &quot;sbfm&quot;, operands, :quad) {
 749                 | value |
 750                 [value, 63]
 751             }
 752         when &quot;urshifti&quot;
 753             emitARM64Shift(&quot;lsrv&quot;, &quot;ubfm&quot;, operands, :word) {
 754                 | value |
 755                 [value, 31]
 756             }
 757         when &quot;urshiftp&quot;
 758             emitARM64Shift(&quot;lsrv&quot;, &quot;ubfm&quot;, operands, :ptr) {
 759                 | value |
 760                 bitSize = $currentSettings[&quot;ADDRESS64&quot;] ? 64 : 32
 761                 [value, bitSize - 1]
 762             }
 763         when &quot;urshiftq&quot;
 764             emitARM64Shift(&quot;lsrv&quot;, &quot;ubfm&quot;, operands, :quad) {
 765                 | value |
 766                 [value, 63]
 767             }
 768         when &quot;muli&quot;
 769             emitARM64Mul(&#39;mul&#39;, operands, :word)
 770         when &quot;mulp&quot;
 771             emitARM64Mul(&#39;mul&#39;, operands, :ptr)
 772         when &quot;mulq&quot;
 773             emitARM64Mul(&#39;mul&#39;, operands, :quad)
 774         when &quot;subi&quot;
 775             emitARM64Sub(&quot;sub&quot;, operands, :word)
 776         when &quot;subp&quot;
 777             emitARM64Sub(&quot;sub&quot;, operands, :ptr)
 778         when &quot;subq&quot;
 779             emitARM64Sub(&quot;sub&quot;, operands, :quad)
 780         when &quot;subis&quot;
 781             emitARM64Sub(&quot;subs&quot;, operands, :word)
 782         when &quot;negi&quot;
 783             $asm.puts &quot;sub #{operands[0].arm64Operand(:word)}, wzr, #{operands[0].arm64Operand(:word)}&quot;
 784         when &quot;negp&quot;
 785             $asm.puts &quot;sub #{operands[0].arm64Operand(:ptr)}, #{arm64GPRName(&#39;xzr&#39;, :ptr)}, #{operands[0].arm64Operand(:ptr)}&quot;
 786         when &quot;negq&quot;
 787             $asm.puts &quot;sub #{operands[0].arm64Operand(:quad)}, xzr, #{operands[0].arm64Operand(:quad)}&quot;
 788         when &quot;loadi&quot;
 789             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :word)
 790         when &quot;loadis&quot;
 791             emitARM64Access(&quot;ldrsw&quot;, &quot;ldursw&quot;, operands[1], operands[0], :quad)
 792         when &quot;loadp&quot;
 793             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :ptr)
 794         when &quot;loadq&quot;
 795             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :quad)
 796         when &quot;storei&quot;
 797             emitARM64Unflipped(&quot;str&quot;, operands, :word)
 798         when &quot;storep&quot;
 799             emitARM64Unflipped(&quot;str&quot;, operands, :ptr)
 800         when &quot;storeq&quot;
 801             emitARM64Unflipped(&quot;str&quot;, operands, :quad)
 802         when &quot;loadb&quot;
 803             emitARM64Access(&quot;ldrb&quot;, &quot;ldurb&quot;, operands[1], operands[0], :word)
 804         when &quot;loadbsi&quot;
 805             emitARM64Access(&quot;ldrsb&quot;, &quot;ldursb&quot;, operands[1], operands[0], :word)
 806         when &quot;loadbsq&quot;
 807             emitARM64Access(&quot;ldrsb&quot;, &quot;ldursb&quot;, operands[1], operands[0], :quad)
 808         when &quot;storeb&quot;
 809             emitARM64Unflipped(&quot;strb&quot;, operands, :word)
 810         when &quot;loadh&quot;
 811             emitARM64Access(&quot;ldrh&quot;, &quot;ldurh&quot;, operands[1], operands[0], :word)
 812         when &quot;loadhsi&quot;
 813             emitARM64Access(&quot;ldrsh&quot;, &quot;ldursh&quot;, operands[1], operands[0], :word)
 814         when &quot;loadhsq&quot;
 815             emitARM64Access(&quot;ldrsh&quot;, &quot;ldursh&quot;, operands[1], operands[0], :quad)
 816         when &quot;storeh&quot;
 817             emitARM64Unflipped(&quot;strh&quot;, operands, :word)
 818         when &quot;loadd&quot;
 819             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :double)
 820         when &quot;stored&quot;
 821             emitARM64Unflipped(&quot;str&quot;, operands, :double)
 822         when &quot;addd&quot;
 823             emitARM64TAC(&quot;fadd&quot;, operands, :double)
 824         when &quot;divd&quot;
 825             emitARM64TAC(&quot;fdiv&quot;, operands, :double)
 826         when &quot;subd&quot;
 827             emitARM64TAC(&quot;fsub&quot;, operands, :double)
 828         when &quot;muld&quot;
 829             emitARM64TAC(&quot;fmul&quot;, operands, :double)
 830         when &quot;sqrtd&quot;
 831             emitARM64(&quot;fsqrt&quot;, operands, :double)
 832         when &quot;bdeq&quot;
 833             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.eq&quot;)
 834         when &quot;bdneq&quot;
 835             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :double)
 836             isUnordered = LocalLabel.unique(&quot;bdneq&quot;)
 837             $asm.puts &quot;b.vs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
 838             $asm.puts &quot;b.ne #{operands[2].asmLabel}&quot;
 839             isUnordered.lower($activeBackend)
 840         when &quot;bdgt&quot;
 841             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.gt&quot;)
 842         when &quot;bdgteq&quot;
 843             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ge&quot;)
 844         when &quot;bdlt&quot;
 845             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.mi&quot;)
 846         when &quot;bdlteq&quot;
 847             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ls&quot;)
 848         when &quot;bdequn&quot;
 849             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :double)
 850             $asm.puts &quot;b.vs #{operands[2].asmLabel}&quot;
 851             $asm.puts &quot;b.eq #{operands[2].asmLabel}&quot;
 852         when &quot;bdnequn&quot;
 853             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ne&quot;)
 854         when &quot;bdgtun&quot;
 855             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.hi&quot;)
 856         when &quot;bdgtequn&quot;
 857             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.pl&quot;)
 858         when &quot;bdltun&quot;
 859             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.lt&quot;)
 860         when &quot;bdltequn&quot;
 861             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.le&quot;)
 862         when &quot;btd2i&quot;
 863             # FIXME: May be a good idea to just get rid of this instruction, since the interpreter
 864             # currently does not use it.
 865             raise &quot;ARM64 does not support this opcode yet, #{codeOriginString}&quot;
 866         when &quot;td2i&quot;
 867             emitARM64(&quot;fcvtzs&quot;, operands, [:double, :word])
 868         when &quot;bcd2i&quot;
 869             # FIXME: Remove this instruction, or use it and implement it. Currently it&#39;s not
 870             # used.
 871             raise &quot;ARM64 does not support this opcode yet, #{codeOriginString}&quot;
 872         when &quot;movdz&quot;
 873             # FIXME: Remove it or support it.
 874             raise &quot;ARM64 does not support this opcode yet, #{codeOriginString}&quot;
 875         when &quot;pop&quot;
 876             operands.each_slice(2) {
 877                 | ops |
 878                 # Note that the operands are in the reverse order of the case for push.
 879                 # This is due to the fact that order matters for pushing and popping, and 
 880                 # on platforms that only push/pop one slot at a time they pop their 
 881                 # arguments in the reverse order that they were pushed. In order to remain 
 882                 # compatible with those platforms we assume here that that&#39;s what has been done.
 883 
 884                 # So for example, if we did push(A, B, C, D), we would then pop(D, C, B, A).
 885                 # But since the ordering of arguments doesn&#39;t change on arm64 between the stp and ldp 
 886                 # instructions we need to flip flop the argument positions that were passed to us.
 887                 $asm.puts &quot;ldp #{ops[1].arm64Operand(:quad)}, #{ops[0].arm64Operand(:quad)}, [sp], #16&quot;
 888             }
 889         when &quot;push&quot;
 890             operands.each_slice(2) {
 891                 | ops |
 892                 $asm.puts &quot;stp #{ops[0].arm64Operand(:quad)}, #{ops[1].arm64Operand(:quad)}, [sp, #-16]!&quot;
 893             }
 894         when &quot;move&quot;
 895             if operands[0].immediate?
 896                 emitARM64MoveImmediate(operands[0].value, operands[1])
 897             else
 898                 emitARM64(&quot;mov&quot;, operands, :quad)
 899             end
 900         when &quot;moved&quot;
 901             emitARM64(&quot;fmov&quot;, operands, :double)
 902         when &quot;sxi2p&quot;
 903             emitARM64(&quot;sxtw&quot;, operands, [:word, :ptr])
 904         when &quot;sxi2q&quot;
 905             emitARM64(&quot;sxtw&quot;, operands, [:word, :quad])
 906         when &quot;zxi2p&quot;
 907             emitARM64(&quot;uxtw&quot;, operands, [:word, :ptr])
 908         when &quot;zxi2q&quot;
 909             emitARM64(&quot;uxtw&quot;, operands, [:word, :quad])
 910         when &quot;nop&quot;
 911             $asm.puts &quot;nop&quot;
 912         when &quot;bieq&quot;, &quot;bbeq&quot;
 913             if operands[0].immediate? and operands[0].value == 0
 914                 $asm.puts &quot;cbz #{operands[1].arm64Operand(:word)}, #{operands[2].asmLabel}&quot;
 915             elsif operands[1].immediate? and operands[1].value == 0
 916                 $asm.puts &quot;cbz #{operands[0].arm64Operand(:word)}, #{operands[2].asmLabel}&quot;
 917             else
 918                 emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.eq&quot;)
 919             end
 920         when &quot;bpeq&quot;
 921             if operands[0].immediate? and operands[0].value == 0
 922                 $asm.puts &quot;cbz #{operands[1].arm64Operand(:ptr)}, #{operands[2].asmLabel}&quot;
 923             elsif operands[1].immediate? and operands[1].value == 0
 924                 $asm.puts &quot;cbz #{operands[0].arm64Operand(:ptr)}, #{operands[2].asmLabel}&quot;
 925             else
 926                 emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.eq&quot;)
 927             end
 928         when &quot;bqeq&quot;
 929             if operands[0].immediate? and operands[0].value == 0
 930                 $asm.puts &quot;cbz #{operands[1].arm64Operand(:quad)}, #{operands[2].asmLabel}&quot;
 931             elsif operands[1].immediate? and operands[1].value == 0
 932                 $asm.puts &quot;cbz #{operands[0].arm64Operand(:quad)}, #{operands[2].asmLabel}&quot;
 933             else
 934                 emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.eq&quot;)
 935             end
 936         when &quot;bineq&quot;, &quot;bbneq&quot;
 937             if operands[0].immediate? and operands[0].value == 0
 938                 $asm.puts &quot;cbnz #{operands[1].arm64Operand(:word)}, #{operands[2].asmLabel}&quot;
 939             elsif operands[1].immediate? and operands[1].value == 0
 940                 $asm.puts &quot;cbnz #{operands[0].arm64Operand(:word)}, #{operands[2].asmLabel}&quot;
 941             else
 942                 emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.ne&quot;)
 943             end
 944         when &quot;bpneq&quot;
 945             if operands[0].immediate? and operands[0].value == 0
 946                 $asm.puts &quot;cbnz #{operands[1].arm64Operand(:ptr)}, #{operands[2].asmLabel}&quot;
 947             elsif operands[1].immediate? and operands[1].value == 0
 948                 $asm.puts &quot;cbnz #{operands[0].arm64Operand(:ptr)}, #{operands[2].asmLabel}&quot;
 949             else
 950                 emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.ne&quot;)
 951             end
 952         when &quot;bqneq&quot;
 953             if operands[0].immediate? and operands[0].value == 0
 954                 $asm.puts &quot;cbnz #{operands[1].arm64Operand(:quad)}, #{operands[2].asmLabel}&quot;
 955             elsif operands[1].immediate? and operands[1].value == 0
 956                 $asm.puts &quot;cbnz #{operands[0].arm64Operand(:quad)}, #{operands[2].asmLabel}&quot;
 957             else
 958                 emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.ne&quot;)
 959             end
 960         when &quot;bia&quot;, &quot;bba&quot;
 961             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.hi&quot;)
 962         when &quot;bpa&quot;
 963             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.hi&quot;)
 964         when &quot;bqa&quot;
 965             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.hi&quot;)
 966         when &quot;biaeq&quot;, &quot;bbaeq&quot;
 967             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.hs&quot;)
 968         when &quot;bpaeq&quot;
 969             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.hs&quot;)
 970         when &quot;bqaeq&quot;
 971             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.hs&quot;)
 972         when &quot;bib&quot;, &quot;bbb&quot;
 973             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.lo&quot;)
 974         when &quot;bpb&quot;
 975             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.lo&quot;)
 976         when &quot;bqb&quot;
 977             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.lo&quot;)
 978         when &quot;bibeq&quot;, &quot;bbbeq&quot;
 979             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.ls&quot;)
 980         when &quot;bpbeq&quot;
 981             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.ls&quot;)
 982         when &quot;bqbeq&quot;
 983             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.ls&quot;)
 984         when &quot;bigt&quot;, &quot;bbgt&quot;
 985             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.gt&quot;)
 986         when &quot;bpgt&quot;
 987             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.gt&quot;)
 988         when &quot;bqgt&quot;
 989             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.gt&quot;)
 990         when &quot;bigteq&quot;, &quot;bbgteq&quot;
 991             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.ge&quot;)
 992         when &quot;bpgteq&quot;
 993             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.ge&quot;)
 994         when &quot;bqgteq&quot;
 995             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.ge&quot;)
 996         when &quot;bilt&quot;, &quot;bblt&quot;
 997             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.lt&quot;)
 998         when &quot;bplt&quot;
 999             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.lt&quot;)
1000         when &quot;bqlt&quot;
1001             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.lt&quot;)
1002         when &quot;bilteq&quot;, &quot;bblteq&quot;
1003             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.le&quot;)
1004         when &quot;bplteq&quot;
1005             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.le&quot;)
1006         when &quot;bqlteq&quot;
1007             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.le&quot;)
1008         when &quot;jmp&quot;
1009             if operands[0].label?
1010                 $asm.puts &quot;b #{operands[0].asmLabel}&quot;
1011             else
1012                 emitARM64Unflipped(&quot;br&quot;, operands, :quad)
1013             end
1014         when &quot;call&quot;
1015             if operands[0].label?
1016                 $asm.puts &quot;bl #{operands[0].asmLabel}&quot;
1017             else
1018                 emitARM64Unflipped(&quot;blr&quot;, operands, :quad)
1019             end
1020         when &quot;break&quot;
1021             $asm.puts &quot;brk \#0&quot;
1022         when &quot;ret&quot;
1023             $asm.puts &quot;ret&quot;
1024         when &quot;cieq&quot;, &quot;cbeq&quot;
1025             emitARM64Compare(operands, :word, &quot;ne&quot;)
1026         when &quot;cpeq&quot;
1027             emitARM64Compare(operands, :ptr, &quot;ne&quot;)
1028         when &quot;cqeq&quot;
1029             emitARM64Compare(operands, :quad, &quot;ne&quot;)
1030         when &quot;cineq&quot;, &quot;cbneq&quot;
1031             emitARM64Compare(operands, :word, &quot;eq&quot;)
1032         when &quot;cpneq&quot;
1033             emitARM64Compare(operands, :ptr, &quot;eq&quot;)
1034         when &quot;cqneq&quot;
1035             emitARM64Compare(operands, :quad, &quot;eq&quot;)
1036         when &quot;cia&quot;, &quot;cba&quot;
1037             emitARM64Compare(operands, :word, &quot;ls&quot;)
1038         when &quot;cpa&quot;
1039             emitARM64Compare(operands, :ptr, &quot;ls&quot;)
1040         when &quot;cqa&quot;
1041             emitARM64Compare(operands, :quad, &quot;ls&quot;)
1042         when &quot;ciaeq&quot;, &quot;cbaeq&quot;
1043             emitARM64Compare(operands, :word, &quot;lo&quot;)
1044         when &quot;cpaeq&quot;
1045             emitARM64Compare(operands, :ptr, &quot;lo&quot;)
1046         when &quot;cqaeq&quot;
1047             emitARM64Compare(operands, :quad, &quot;lo&quot;)
1048         when &quot;cib&quot;, &quot;cbb&quot;
1049             emitARM64Compare(operands, :word, &quot;hs&quot;)
1050         when &quot;cpb&quot;
1051             emitARM64Compare(operands, :ptr, &quot;hs&quot;)
1052         when &quot;cqb&quot;
1053             emitARM64Compare(operands, :quad, &quot;hs&quot;)
1054         when &quot;cibeq&quot;, &quot;cbbeq&quot;
1055             emitARM64Compare(operands, :word, &quot;hi&quot;)
1056         when &quot;cpbeq&quot;
1057             emitARM64Compare(operands, :ptr, &quot;hi&quot;)
1058         when &quot;cqbeq&quot;
1059             emitARM64Compare(operands, :quad, &quot;hi&quot;)
1060         when &quot;cilt&quot;, &quot;cblt&quot;
1061             emitARM64Compare(operands, :word, &quot;ge&quot;)
1062         when &quot;cplt&quot;
1063             emitARM64Compare(operands, :ptr, &quot;ge&quot;)
1064         when &quot;cqlt&quot;
1065             emitARM64Compare(operands, :quad, &quot;ge&quot;)
1066         when &quot;cilteq&quot;, &quot;cblteq&quot;
1067             emitARM64Compare(operands, :word, &quot;gt&quot;)
1068         when &quot;cplteq&quot;
1069             emitARM64Compare(operands, :ptr, &quot;gt&quot;)
1070         when &quot;cqlteq&quot;
1071             emitARM64Compare(operands, :quad, &quot;gt&quot;)
1072         when &quot;cigt&quot;, &quot;cbgt&quot;
1073             emitARM64Compare(operands, :word, &quot;le&quot;)
1074         when &quot;cpgt&quot;
1075             emitARM64Compare(operands, :ptr, &quot;le&quot;)
1076         when &quot;cqgt&quot;
1077             emitARM64Compare(operands, :quad, &quot;le&quot;)
1078         when &quot;cigteq&quot;, &quot;cbgteq&quot;
1079             emitARM64Compare(operands, :word, &quot;lt&quot;)
1080         when &quot;cpgteq&quot;
1081             emitARM64Compare(operands, :ptr, &quot;lt&quot;)
1082         when &quot;cqgteq&quot;
1083             emitARM64Compare(operands, :quad, &quot;lt&quot;)
1084         when &quot;peek&quot;
1085             $asm.puts &quot;ldr #{operands[1].arm64Operand(:quad)}, [sp, \##{operands[0].value * 8}]&quot;
1086         when &quot;poke&quot;
1087             $asm.puts &quot;str #{operands[1].arm64Operand(:quad)}, [sp, \##{operands[0].value * 8}]&quot;
1088         when &quot;fp2d&quot;
1089             emitARM64(&quot;fmov&quot;, operands, [:ptr, :double])
1090         when &quot;fq2d&quot;
1091             emitARM64(&quot;fmov&quot;, operands, [:quad, :double])
1092         when &quot;fd2p&quot;
1093             emitARM64(&quot;fmov&quot;, operands, [:double, :ptr])
1094         when &quot;fd2q&quot;
1095             emitARM64(&quot;fmov&quot;, operands, [:double, :quad])
1096         when &quot;bo&quot;
1097             $asm.puts &quot;b.vs #{operands[0].asmLabel}&quot;
1098         when &quot;bs&quot;
1099             $asm.puts &quot;b.mi #{operands[0].asmLabel}&quot;
1100         when &quot;bz&quot;
1101             $asm.puts &quot;b.eq #{operands[0].asmLabel}&quot;
1102         when &quot;bnz&quot;
1103             $asm.puts &quot;b.ne #{operands[0].asmLabel}&quot;
1104         when &quot;leai&quot;
1105             operands[0].arm64EmitLea(operands[1], :word)
1106         when &quot;leap&quot;
1107             operands[0].arm64EmitLea(operands[1], :ptr)
1108         when &quot;leaq&quot;
1109             operands[0].arm64EmitLea(operands[1], :quad)
1110         when &quot;smulli&quot;
1111             $asm.puts &quot;smaddl #{operands[2].arm64Operand(:quad)}, #{operands[0].arm64Operand(:word)}, #{operands[1].arm64Operand(:word)}, xzr&quot;
1112         when &quot;memfence&quot;
1113             $asm.puts &quot;dmb sy&quot;
1114         when &quot;bfiq&quot;
1115             $asm.puts &quot;bfi #{operands[3].arm64Operand(:quad)}, #{operands[0].arm64Operand(:quad)}, #{operands[1].value}, #{operands[2].value}&quot;
1116         when &quot;pcrtoaddr&quot;
1117             $asm.puts &quot;adr #{operands[1].arm64Operand(:quad)}, #{operands[0].value}&quot;
1118         when &quot;nopCortexA53Fix835769&quot;
1119             $asm.putStr(&quot;#if CPU(ARM64_CORTEXA53)&quot;)
1120             $asm.puts &quot;nop&quot;
1121             $asm.putStr(&quot;#endif&quot;)
1122         when &quot;globaladdr&quot;
1123             uid = $asm.newUID
1124 
1125             # On Darwin, use Macho-O GOT relocation specifiers, along with
1126             # the labels required for the .loh directive.
1127             $asm.putStr(&quot;#if OS(DARWIN)&quot;)
1128             $asm.puts &quot;L_offlineasm_loh_adrp_#{uid}:&quot;
1129             $asm.puts &quot;adrp #{operands[1].arm64Operand(:quad)}, #{operands[0].asmLabel}@GOTPAGE&quot;
1130             $asm.puts &quot;L_offlineasm_loh_ldr_#{uid}:&quot;
1131             $asm.puts &quot;ldr #{operands[1].arm64Operand(:quad)}, [#{operands[1].arm64Operand(:quad)}, #{operands[0].asmLabel}@GOTPAGEOFF]&quot;
1132 
1133             # On Linux, use ELF GOT relocation specifiers.
1134             $asm.putStr(&quot;#elif OS(LINUX)&quot;)
1135             $asm.puts &quot;adrp #{operands[1].arm64Operand(:quad)}, :got:#{operands[0].asmLabel}&quot;
1136             $asm.puts &quot;ldr #{operands[1].arm64Operand(:quad)}, [#{operands[1].arm64Operand(:quad)}, :got_lo12:#{operands[0].asmLabel}]&quot;
1137 
1138             # Throw a compiler error everywhere else.
1139             $asm.putStr(&quot;#else&quot;)
1140             $asm.putStr(&quot;#error Missing globaladdr implementation&quot;)
1141             $asm.putStr(&quot;#endif&quot;)
1142 
1143             $asm.deferAction {
1144                 # On Darwin, also include the .loh directive using the generated labels.
1145                 $asm.putStr(&quot;#if OS(DARWIN)&quot;)
1146                 $asm.puts &quot;.loh AdrpLdrGot L_offlineasm_loh_adrp_#{uid}, L_offlineasm_loh_ldr_#{uid}&quot;
1147                 $asm.putStr(&quot;#endif&quot;)
1148             }
1149 
1150         when &quot;andf&quot;, &quot;andd&quot;
1151             emitARM64TACWithOperandSuffix(&quot;and&quot;, operands, :double)
1152         when &quot;orf&quot;, &quot;ord&quot;
1153             emitARM64TACWithOperandSuffix(&quot;orr&quot;, operands, :double)
1154         when &quot;lrotatei&quot;
1155             tmp = Tmp.new(codeOrigin, :gpr)
1156             Sequence.new(codeOrigin, [
1157                 Instruction.new(codeOrigin, &quot;move&quot;, [operands[0], tmp]),
1158                 Instruction.new(codeOrigin, &quot;negq&quot;, [tmp]),
1159                 Instruction.new(codeOrigin, &quot;rrotatei&quot;, [tmp, operands[1]]),
1160             ]).lower($activeBackend)
1161         when &quot;lrotateq&quot;
1162             tmp = Tmp.new(codeOrigin, :gpr)
1163             Sequence.new(codeOrigin, [
1164                 Instruction.new(codeOrigin, &quot;move&quot;, [operands[0], tmp]),
1165                 Instruction.new(codeOrigin, &quot;negq&quot;, [tmp]),
1166                 Instruction.new(codeOrigin, &quot;rrotateq&quot;, [tmp, operands[1]]),
1167             ]).lower($activeBackend)
1168         when &quot;rrotatei&quot;
1169             emitARM64TAC(&quot;ror&quot;, operands, :word)
1170         when &quot;rrotateq&quot;
1171             emitARM64TAC(&quot;ror&quot;, operands, :quad)
1172         when &quot;loadf&quot;
1173             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :float)
1174         when &quot;storef&quot;
1175             emitARM64Unflipped(&quot;str&quot;, operands, :float)
1176         when &quot;addf&quot;
1177             emitARM64TAC(&quot;fadd&quot;, operands, :float)
1178         when &quot;divf&quot;
1179             emitARM64TAC(&quot;fdiv&quot;, operands, :float)
1180         when &quot;subf&quot;
1181             emitARM64TAC(&quot;fsub&quot;, operands, :float)
1182         when &quot;mulf&quot;
1183             emitARM64TAC(&quot;fmul&quot;, operands, :float)
1184         when &quot;sqrtf&quot;
1185             emitARM64(&quot;fsqrt&quot;, operands, :float)
1186         when &quot;floorf&quot;
1187             emitARM64(&quot;frintm&quot;, operands, :float)
1188         when &quot;floord&quot;
1189             emitARM64(&quot;frintm&quot;, operands, :double)
1190         when &quot;roundf&quot;
1191             emitARM64(&quot;frintn&quot;, operands, :float)
1192         when &quot;roundd&quot;
1193             emitARM64(&quot;frintn&quot;, operands, :double)
1194         when &quot;truncatef&quot;
1195             emitARM64(&quot;frintz&quot;, operands, :float)
1196         when &quot;truncated&quot;
1197             emitARM64(&quot;frintz&quot;, operands, :double)
1198         when &quot;truncatef2i&quot;
1199             emitARM64(&quot;fcvtzu&quot;, operands, [:float, :word])
1200         when &quot;truncatef2q&quot;
1201             emitARM64(&quot;fcvtzu&quot;, operands, [:float, :quad])
1202         when &quot;truncated2q&quot;
1203             emitARM64(&quot;fcvtzu&quot;, operands, [:double, :quad])
1204         when &quot;truncated2i&quot;
1205             emitARM64(&quot;fcvtzu&quot;, operands, [:double, :word])
1206         when &quot;truncatef2is&quot;
1207             emitARM64(&quot;fcvtzs&quot;, operands, [:float, :word])
1208         when &quot;truncated2is&quot;
1209             emitARM64(&quot;fcvtzs&quot;, operands, [:double, :word])
1210         when &quot;truncatef2qs&quot;
1211             emitARM64(&quot;fcvtzs&quot;, operands, [:float, :quad])
1212         when &quot;truncated2qs&quot;
1213             emitARM64(&quot;fcvtzs&quot;, operands, [:double, :quad])
1214         when &quot;ci2d&quot;
1215             emitARM64(&quot;ucvtf&quot;, operands, [:word, :double])
1216         when &quot;ci2ds&quot;
1217             emitARM64(&quot;scvtf&quot;, operands, [:word, :double])
1218         when &quot;ci2f&quot;
1219             emitARM64(&quot;ucvtf&quot;, operands, [:word, :float])
1220         when &quot;ci2fs&quot;
1221             emitARM64(&quot;scvtf&quot;, operands, [:word, :float])
1222         when &quot;cq2f&quot;
1223             emitARM64(&quot;ucvtf&quot;, operands, [:quad, :float])
1224         when &quot;cq2fs&quot;
1225             emitARM64(&quot;scvtf&quot;, operands, [:quad, :float])
1226         when &quot;cq2d&quot;
1227             emitARM64(&quot;ucvtf&quot;, operands, [:quad, :double])
1228         when &quot;cq2ds&quot;
1229             emitARM64(&quot;scvtf&quot;, operands, [:quad, :double])
1230         when &quot;cd2f&quot;
1231             emitARM64(&quot;fcvt&quot;, operands, [:double, :float])
1232         when &quot;cf2d&quot;
1233             emitARM64(&quot;fcvt&quot;, operands, [:float, :double])
1234         when &quot;bfeq&quot;
1235             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.eq&quot;)
1236         when &quot;bfgt&quot;
1237             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.gt&quot;)
1238         when &quot;bflt&quot;
1239             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.mi&quot;)
1240         when &quot;bfgtun&quot;
1241             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.hi&quot;)
1242         when &quot;bfgtequn&quot;
1243             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.pl&quot;)
1244         when &quot;bfltun&quot;
1245             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.lt&quot;)
1246         when &quot;bfltequn&quot;
1247             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.le&quot;)
1248         when &quot;tzcnti&quot;
1249             emitARM64(&quot;rbit&quot;, operands, :word)
1250             emitARM64(&quot;clz&quot;, [operands[1], operands[1]], :word)
1251         when &quot;tzcntq&quot;
1252             emitARM64(&quot;rbit&quot;, operands, :quad)
1253             emitARM64(&quot;clz&quot;, [operands[1], operands[1]], :quad)
1254         when &quot;lzcnti&quot;
1255             emitARM64(&quot;clz&quot;, operands, :word)
1256         when &quot;lzcntq&quot;
1257             emitARM64(&quot;clz&quot;, operands, :quad)
1258         when &quot;absf&quot;
1259             emitARM64(&quot;fabs&quot;, operands, :float)
1260         when &quot;absd&quot;
1261             emitARM64(&quot;fabs&quot;, operands, :double)
1262         when &quot;negf&quot;
1263             emitARM64(&quot;fneg&quot;, operands, :float)
1264         when &quot;negd&quot;
1265             emitARM64(&quot;fneg&quot;, operands, :double)
1266         when &quot;ceilf&quot;
1267             emitARM64(&quot;frintp&quot;, operands, :float)
1268         when &quot;ceild&quot;
1269             emitARM64(&quot;frintp&quot;, operands, :double)
1270         when &quot;cfeq&quot;
1271             emitARM64CompareFP(operands, :float, &quot;eq&quot;)
1272         when &quot;cdeq&quot;
1273             emitARM64CompareFP(operands, :double, &quot;eq&quot;)
1274         when &quot;cfneq&quot;
1275             $asm.puts &quot;move $0, #{operands[2].arm64Operand(:word)}&quot;
1276             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :float)
1277             isUnordered = LocalLabel.unique(&quot;cdneq&quot;)
1278             $asm.puts &quot;b.vs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1279             $asm.puts &quot;cset #{operands[2].arm64Operand(:word)}, ne&quot;
1280             isUnordered.lower($activeBackend)
1281         when &quot;cdneq&quot;
1282             $asm.puts &quot;move $0, #{operands[2].arm64Operand(:word)}&quot;
1283             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :double)
1284             isUnordered = LocalLabel.unique(&quot;cdneq&quot;)
1285             $asm.puts &quot;b.vs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1286             $asm.puts &quot;cset #{operands[2].arm64Operand(:word)}, ne&quot;
1287             isUnordered.lower($activeBackend)
1288         when &quot;cfnequn&quot;
1289             emitARM64CompareFP(operands, :float, &quot;ne&quot;)
1290         when &quot;cdnequn&quot;
1291             emitARM64CompareFP(operands, :double, &quot;ne&quot;)
1292         when &quot;cflt&quot;
1293             emitARM64CompareFP(operands, :float, &quot;mi&quot;)
1294         when &quot;cdlt&quot;
1295             emitARM64CompareFP(operands, :double, &quot;mi&quot;)
1296         when &quot;cflteq&quot;
1297             emitARM64CompareFP(operands, :float, &quot;ls&quot;)
1298         when &quot;cdlteq&quot;
1299             emitARM64CompareFP(operands, :double, &quot;ls&quot;)
1300         when &quot;cfgt&quot;
1301             emitARM64CompareFP(operands, :float, &quot;gt&quot;)
1302         when &quot;cdgt&quot;
1303             emitARM64CompareFP(operands, :double, &quot;gt&quot;)
1304         when &quot;cfgteq&quot;
1305             emitARM64CompareFP(operands, :float, &quot;ge&quot;)
1306         when &quot;cdgteq&quot;
1307             emitARM64CompareFP(operands, :double, &quot;ge&quot;)
1308         when &quot;fi2f&quot;
1309             emitARM64(&quot;fmov&quot;, operands, [:word, :float])
1310         when &quot;ff2i&quot;
1311             emitARM64(&quot;fmov&quot;, operands, [:float, :word])
1312         when &quot;tls_loadp&quot;
1313             tmp = ARM64_EXTRA_GPRS[0].arm64Operand(:ptr)
1314             if operands[0].immediate?
1315               offset = &quot;\##{operands[0].value * 8}&quot;
1316             else
1317               offset = operands[0].arm64Operand(:word)
1318             end
1319             $asm.puts &quot;mrs #{tmp}, tpidrro_el0&quot;
1320             $asm.puts &quot;bic #{tmp}, #{tmp}, #7&quot;
1321             $asm.puts &quot;ldr #{operands[1].arm64Operand(:ptr)}, [#{tmp}, #{offset}]&quot;
1322         when &quot;tls_storep&quot;
1323             tmp = ARM64_EXTRA_GPRS[0].arm64Operand(:ptr)
1324             if operands[1].immediate?
1325               offset = &quot;\##{operands[1].value * 8}&quot;
1326             else
1327               offset = operands[1].arm64Operand(:word)
1328             end
1329             $asm.puts &quot;mrs #{tmp}, tpidrro_el0&quot;
1330             $asm.puts &quot;bic #{tmp}, #{tmp}, #7&quot;
1331             $asm.puts &quot;str #{operands[0].arm64Operand(:ptr)}, [#{tmp}, #{offset}]&quot;
1332         else
1333             lowerDefault
1334         end
1335     end
1336 end
1337 
    </pre>
  </body>
</html>
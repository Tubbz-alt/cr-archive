<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewPrototypeFunctions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGenericTypedArrayViewInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalLexicalEnvironment.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewPrototypeFunctions.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26 #pragma once
 27 
 28 #include &quot;Error.h&quot;
 29 #include &quot;JSArrayBufferViewInlines.h&quot;
 30 #include &quot;JSCBuiltins.h&quot;
 31 #include &quot;JSCJSValueInlines.h&quot;
 32 #include &quot;JSFunction.h&quot;
 33 #include &quot;JSGenericTypedArrayViewInlines.h&quot;
 34 #include &quot;JSGenericTypedArrayViewPrototypeInlines.h&quot;
 35 #include &quot;JSStringJoiner.h&quot;
 36 #include &quot;StructureInlines.h&quot;
 37 #include &quot;TypedArrayAdaptors.h&quot;
 38 #include &quot;TypedArrayController.h&quot;
 39 #include &lt;wtf/StdLibExtras.h&gt;
 40 
 41 namespace JSC {
 42 
 43 // This implements 22.2.4.7 TypedArraySpeciesCreate
 44 // Note, that this function throws.
 45 template&lt;typename Functor&gt;
<span class="line-modified"> 46 inline JSArrayBufferView* speciesConstruct(ExecState* exec, JSObject* exemplar, MarkedArgumentBuffer&amp; args, const Functor&amp; defaultConstructor)</span>
 47 {
<span class="line-modified"> 48     VM&amp; vm = exec-&gt;vm();</span>
 49     auto scope = DECLARE_THROW_SCOPE(vm);
 50 
<span class="line-modified"> 51     JSValue constructor = exemplar-&gt;get(exec, vm.propertyNames-&gt;constructor);</span>
 52     RETURN_IF_EXCEPTION(scope, nullptr);
 53 
 54     if (constructor.isUndefined())
 55         RELEASE_AND_RETURN(scope, defaultConstructor());
 56 
 57     if (!constructor.isObject()) {
<span class="line-modified"> 58         throwTypeError(exec, scope, &quot;constructor Property should not be null&quot;_s);</span>
 59         return nullptr;
 60     }
 61 
<span class="line-modified"> 62     JSValue species = constructor.get(exec, vm.propertyNames-&gt;speciesSymbol);</span>
 63     RETURN_IF_EXCEPTION(scope, nullptr);
 64 
 65     if (species.isUndefinedOrNull())
 66         RELEASE_AND_RETURN(scope, defaultConstructor());
 67 
 68 
<span class="line-modified"> 69     JSValue result = construct(exec, species, args, &quot;species is not a constructor&quot;);</span>
 70     RETURN_IF_EXCEPTION(scope, nullptr);
 71 
 72     if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, result)) {
 73         if (view-&gt;type() == DataViewType) {
<span class="line-modified"> 74             throwTypeError(exec, scope, &quot;species constructor did not return a TypedArray View&quot;_s);</span>
 75             return nullptr;
 76         }
 77 
 78         if (!view-&gt;isNeutered())
 79             return view;
 80 
<span class="line-modified"> 81         throwTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
 82         return nullptr;
 83     }
 84 
<span class="line-modified"> 85     throwTypeError(exec, scope, &quot;species constructor did not return a TypedArray View&quot;_s);</span>
 86     return nullptr;
 87 }
 88 
<span class="line-modified"> 89 inline unsigned argumentClampedIndexFromStartOrEnd(ExecState* exec, int argument, unsigned length, unsigned undefinedValue = 0)</span>
 90 {
<span class="line-removed"> 91     JSValue value = exec-&gt;argument(argument);</span>
 92     if (value.isUndefined())
 93         return undefinedValue;
 94 
<span class="line-modified"> 95     double indexDouble = value.toInteger(exec);</span>
 96     if (indexDouble &lt; 0) {
 97         indexDouble += length;
 98         return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
 99     }
100     return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);
101 }
102 
103 template&lt;typename ViewClass&gt;
<span class="line-modified">104 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncSet(VM&amp; vm, ExecState* exec)</span>
105 {
106     auto scope = DECLARE_THROW_SCOPE(vm);
107 
108     // 22.2.3.22
<span class="line-modified">109     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
110 
<span class="line-modified">111     if (UNLIKELY(!exec-&gt;argumentCount()))</span>
<span class="line-modified">112         return throwVMTypeError(exec, scope, &quot;Expected at least one argument&quot;_s);</span>
113 
114     unsigned offset;
<span class="line-modified">115     if (exec-&gt;argumentCount() &gt;= 2) {</span>
<span class="line-modified">116         double offsetNumber = exec-&gt;uncheckedArgument(1).toInteger(exec);</span>
117         RETURN_IF_EXCEPTION(scope, encodedJSValue());
118         if (UNLIKELY(offsetNumber &lt; 0))
<span class="line-modified">119             return throwVMRangeError(exec, scope, &quot;Offset should not be negative&quot;);</span>
120         offset = static_cast&lt;unsigned&gt;(std::min(offsetNumber, static_cast&lt;double&gt;(std::numeric_limits&lt;unsigned&gt;::max())));
121     } else
122         offset = 0;
123 
124     if (UNLIKELY(thisObject-&gt;isNeutered()))
<span class="line-modified">125         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
126 
<span class="line-modified">127     JSObject* sourceArray = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;uncheckedArgument(0));</span>
128     if (UNLIKELY(!sourceArray))
<span class="line-modified">129         return throwVMTypeError(exec, scope, &quot;First argument should be an object&quot;_s);</span>
130 
131     unsigned length;
132     if (isTypedView(sourceArray-&gt;classInfo(vm)-&gt;typedArrayStorageType)) {
133         JSArrayBufferView* sourceView = jsCast&lt;JSArrayBufferView*&gt;(sourceArray);
134         if (UNLIKELY(sourceView-&gt;isNeutered()))
<span class="line-modified">135             return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
136 
137         length = jsCast&lt;JSArrayBufferView*&gt;(sourceArray)-&gt;length();
138     } else {
<span class="line-modified">139         JSValue lengthValue = sourceArray-&gt;get(exec, vm.propertyNames-&gt;length);</span>
140         RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">141         length = lengthValue.toUInt32(exec);</span>
142     }
143 
144     RETURN_IF_EXCEPTION(scope, encodedJSValue());
145 
146     scope.release();
<span class="line-modified">147     thisObject-&gt;set(exec, offset, sourceArray, 0, length, CopyType::Unobservable);</span>
148     return JSValue::encode(jsUndefined());
149 }
150 
151 template&lt;typename ViewClass&gt;
<span class="line-modified">152 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncCopyWithin(VM&amp; vm, ExecState* exec)</span>
153 {
154     auto scope = DECLARE_THROW_SCOPE(vm);
155 
156     // 22.2.3.5
<span class="line-modified">157     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
158     if (thisObject-&gt;isNeutered())
<span class="line-modified">159         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
160 
161     long length = thisObject-&gt;length();
<span class="line-modified">162     long to = argumentClampedIndexFromStartOrEnd(exec, 0, length);</span>
163     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">164     long from = argumentClampedIndexFromStartOrEnd(exec, 1, length);</span>
165     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">166     long final = argumentClampedIndexFromStartOrEnd(exec, 2, length, length);</span>
167     RETURN_IF_EXCEPTION(scope, encodedJSValue());
168 
169     if (final &lt; from)
<span class="line-modified">170         return JSValue::encode(exec-&gt;thisValue());</span>
171 
172     long count = std::min(length - std::max(to, from), final - from);
173 
174     if (thisObject-&gt;isNeutered())
<span class="line-modified">175         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
176 
177     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
178     memmove(array + to, array + from, count * thisObject-&gt;elementSize);
179 
<span class="line-modified">180     return JSValue::encode(exec-&gt;thisValue());</span>
181 }
182 
183 template&lt;typename ViewClass&gt;
<span class="line-modified">184 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncIncludes(VM&amp; vm, ExecState* exec)</span>
185 {
186     auto scope = DECLARE_THROW_SCOPE(vm);
187 
<span class="line-modified">188     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
189     if (thisObject-&gt;isNeutered())
<span class="line-modified">190         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
191 
192     unsigned length = thisObject-&gt;length();
193 
194     if (!length)
195         return JSValue::encode(jsBoolean(false));
196 
<span class="line-modified">197     JSValue valueToFind = exec-&gt;argument(0);</span>
198 
<span class="line-modified">199     unsigned index = argumentClampedIndexFromStartOrEnd(exec, 1, length);</span>
200     RETURN_IF_EXCEPTION(scope, encodedJSValue());
201 
202     if (thisObject-&gt;isNeutered())
<span class="line-modified">203         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
204 
205     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
206     auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
207     if (!targetOption)
208         return JSValue::encode(jsBoolean(false));
209 
210     scope.assertNoException();
211     RELEASE_ASSERT(!thisObject-&gt;isNeutered());
212 
213     if (std::isnan(static_cast&lt;double&gt;(*targetOption))) {
214         for (; index &lt; length; ++index) {
215             if (std::isnan(static_cast&lt;double&gt;(array[index])))
216                 return JSValue::encode(jsBoolean(true));
217         }
218     } else {
219         for (; index &lt; length; ++index) {
220             if (array[index] == targetOption)
221                 return JSValue::encode(jsBoolean(true));
222         }
223     }
224 
225     return JSValue::encode(jsBoolean(false));
226 }
227 
228 template&lt;typename ViewClass&gt;
<span class="line-modified">229 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncIndexOf(VM&amp; vm, ExecState* exec)</span>
230 {
231     auto scope = DECLARE_THROW_SCOPE(vm);
232 
233     // 22.2.3.13
<span class="line-modified">234     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
235     if (thisObject-&gt;isNeutered())
<span class="line-modified">236         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
237 
<span class="line-modified">238     if (!exec-&gt;argumentCount())</span>
<span class="line-modified">239         return throwVMTypeError(exec, scope, &quot;Expected at least one argument&quot;_s);</span>
240 
241     unsigned length = thisObject-&gt;length();
242 
<span class="line-modified">243     JSValue valueToFind = exec-&gt;argument(0);</span>
<span class="line-modified">244     unsigned index = argumentClampedIndexFromStartOrEnd(exec, 1, length);</span>
245     RETURN_IF_EXCEPTION(scope, encodedJSValue());
246 
247     if (thisObject-&gt;isNeutered())
<span class="line-modified">248         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
249 
250     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
251     auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
252     if (!targetOption)
253         return JSValue::encode(jsNumber(-1));
254     scope.assertNoException();
255     RELEASE_ASSERT(!thisObject-&gt;isNeutered());
256 
257     for (; index &lt; length; ++index) {
258         if (array[index] == targetOption)
259             return JSValue::encode(jsNumber(index));
260     }
261 
262     return JSValue::encode(jsNumber(-1));
263 }
264 
265 template&lt;typename ViewClass&gt;
<span class="line-modified">266 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncJoin(VM&amp; vm, ExecState* exec)</span>
267 {
268     auto scope = DECLARE_THROW_SCOPE(vm);
269 
<span class="line-modified">270     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
271     if (thisObject-&gt;isNeutered())
<span class="line-modified">272         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
273 
274     // 22.2.3.14
275     auto joinWithSeparator = [&amp;] (StringView separator) -&gt; EncodedJSValue {
<span class="line-modified">276         ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
277         unsigned length = thisObject-&gt;length();
278 
<span class="line-modified">279         JSStringJoiner joiner(*exec, separator, length);</span>
280         RETURN_IF_EXCEPTION(scope, encodedJSValue());
281         for (unsigned i = 0; i &lt; length; i++) {
<span class="line-modified">282             joiner.append(*exec, thisObject-&gt;getIndexQuickly(i));</span>
283             RETURN_IF_EXCEPTION(scope, encodedJSValue());
284         }
<span class="line-modified">285         RELEASE_AND_RETURN(scope, JSValue::encode(joiner.join(*exec)));</span>
286     };
287 
<span class="line-modified">288     JSValue separatorValue = exec-&gt;argument(0);</span>
289     if (separatorValue.isUndefined()) {
290         const LChar* comma = reinterpret_cast&lt;const LChar*&gt;(&quot;,&quot;);
291         return joinWithSeparator({ comma, 1 });
292     }
293 
<span class="line-modified">294     JSString* separatorString = separatorValue.toString(exec);</span>
295     RETURN_IF_EXCEPTION(scope, encodedJSValue());
296 
297     if (thisObject-&gt;isNeutered())
<span class="line-modified">298         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
<span class="line-modified">299     auto viewWithString = separatorString-&gt;viewWithUnderlyingString(exec);</span>
300     RETURN_IF_EXCEPTION(scope, encodedJSValue());
301     return joinWithSeparator(viewWithString.view);
302 }
303 
304 template&lt;typename ViewClass&gt;
<span class="line-modified">305 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncLastIndexOf(VM&amp; vm, ExecState* exec)</span>
306 {
307     auto scope = DECLARE_THROW_SCOPE(vm);
308 
309     // 22.2.3.16
<span class="line-modified">310     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
311     if (thisObject-&gt;isNeutered())
<span class="line-modified">312         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
313 
<span class="line-modified">314     if (!exec-&gt;argumentCount())</span>
<span class="line-modified">315         return throwVMTypeError(exec, scope, &quot;Expected at least one argument&quot;_s);</span>
316 
317     unsigned length = thisObject-&gt;length();
318 
<span class="line-modified">319     JSValue valueToFind = exec-&gt;argument(0);</span>
320 
321     int index = length - 1;
<span class="line-modified">322     if (exec-&gt;argumentCount() &gt;= 2) {</span>
<span class="line-modified">323         JSValue fromValue = exec-&gt;uncheckedArgument(1);</span>
<span class="line-modified">324         double fromDouble = fromValue.toInteger(exec);</span>
325         RETURN_IF_EXCEPTION(scope, encodedJSValue());
326         if (fromDouble &lt; 0) {
327             fromDouble += length;
328             if (fromDouble &lt; 0)
329                 return JSValue::encode(jsNumber(-1));
330         }
331         if (fromDouble &lt; length)
332             index = static_cast&lt;unsigned&gt;(fromDouble);
333     }
334 
335     if (thisObject-&gt;isNeutered())
<span class="line-modified">336         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
337 
338     auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
339     if (!targetOption)
340         return JSValue::encode(jsNumber(-1));
341 
342     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
343     scope.assertNoException();
344     RELEASE_ASSERT(!thisObject-&gt;isNeutered());
345 
346     for (; index &gt;= 0; --index) {
347         if (array[index] == targetOption)
348             return JSValue::encode(jsNumber(index));
349     }
350 
351     return JSValue::encode(jsNumber(-1));
352 }
353 
354 template&lt;typename ViewClass&gt;
<span class="line-modified">355 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncBuffer(VM&amp;, ExecState* exec)</span>
356 {
357     // 22.2.3.3
<span class="line-modified">358     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
359 
<span class="line-modified">360     return JSValue::encode(thisObject-&gt;possiblySharedJSBuffer(exec));</span>
361 }
362 
363 template&lt;typename ViewClass&gt;
<span class="line-modified">364 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncLength(VM&amp;, ExecState* exec)</span>
365 {
366     // 22.2.3.17
<span class="line-modified">367     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
368 
369     return JSValue::encode(jsNumber(thisObject-&gt;length()));
370 }
371 
372 template&lt;typename ViewClass&gt;
<span class="line-modified">373 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncByteLength(VM&amp;, ExecState* exec)</span>
374 {
375     // 22.2.3.2
<span class="line-modified">376     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
377 
378     return JSValue::encode(jsNumber(thisObject-&gt;byteLength()));
379 }
380 
381 template&lt;typename ViewClass&gt;
<span class="line-modified">382 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncByteOffset(VM&amp;, ExecState* exec)</span>
383 {
384     // 22.2.3.3
<span class="line-modified">385     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
386 
387     return JSValue::encode(jsNumber(thisObject-&gt;byteOffset()));
388 }
389 
390 template&lt;typename ViewClass&gt;
<span class="line-modified">391 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncReverse(VM&amp; vm, ExecState* exec)</span>
392 {
<span class="line-modified">393 //    VM&amp; vm = exec-&gt;vm();</span>
394     auto scope = DECLARE_THROW_SCOPE(vm);
395 
396     // 22.2.3.21
<span class="line-modified">397     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
398     if (thisObject-&gt;isNeutered())
<span class="line-modified">399         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
400 
401     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
402     std::reverse(array, array + thisObject-&gt;length());
403 
404     return JSValue::encode(thisObject);
405 }
406 
407 template&lt;typename ViewClass&gt;
<span class="line-modified">408 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewPrivateFuncSort(VM&amp; vm, ExecState* exec)</span>
409 {
<span class="line-modified">410 //    VM&amp; vm = exec-&gt;vm();</span>
411     auto scope = DECLARE_THROW_SCOPE(vm);
412 
413     // 22.2.3.25
<span class="line-modified">414     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;argument(0));</span>
415     if (thisObject-&gt;isNeutered())
<span class="line-modified">416         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
417 
418     thisObject-&gt;sort();
419 
420     return JSValue::encode(thisObject);
421 }
422 
423 template&lt;typename ViewClass&gt;
<span class="line-modified">424 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncSlice(VM&amp; vm, ExecState* exec)</span>
425 {
426     auto scope = DECLARE_THROW_SCOPE(vm);
427 
428     // 22.2.3.26
<span class="line-removed">429     JSFunction* callee = jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee());</span>
430 
<span class="line-modified">431     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
432     if (thisObject-&gt;isNeutered())
<span class="line-modified">433         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
434 
435     unsigned thisLength = thisObject-&gt;length();
436 
<span class="line-modified">437     unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, thisLength);</span>
438     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">439     unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, thisLength, thisLength);</span>
440     RETURN_IF_EXCEPTION(scope, encodedJSValue());
441 
442     if (thisObject-&gt;isNeutered())
<span class="line-modified">443         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
444 
445     // Clamp end to begin.
446     end = std::max(begin, end);
447 
448     ASSERT(end &gt;= begin);
449     unsigned length = end - begin;
450 
451     MarkedArgumentBuffer args;
452     args.append(jsNumber(length));
453     ASSERT(!args.hasOverflowed());
454 
<span class="line-modified">455     JSArrayBufferView* result = speciesConstruct(exec, thisObject, args, [&amp;]() {</span>
<span class="line-modified">456         Structure* structure = callee-&gt;globalObject(vm)-&gt;typedArrayStructure(ViewClass::TypedArrayStorageType);</span>
<span class="line-modified">457         return ViewClass::createUninitialized(exec, structure, length);</span>
458     });
459     RETURN_IF_EXCEPTION(scope, encodedJSValue());
460 
461     ASSERT(!result-&gt;isNeutered());
462     if (thisObject-&gt;isNeutered())
<span class="line-modified">463         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
464 
465     // We return early here since we don&#39;t allocate a backing store if length is 0 and memmove does not like nullptrs
466     if (!length)
467         return JSValue::encode(result);
468 
469     // The species constructor may return an array with any arbitrary length.
470     length = std::min(length, result-&gt;length());
471     switch (result-&gt;classInfo(vm)-&gt;typedArrayStorageType) {
472     case TypeInt8:
473         scope.release();
<span class="line-modified">474         jsCast&lt;JSInt8Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
475         return JSValue::encode(result);
476     case TypeInt16:
477         scope.release();
<span class="line-modified">478         jsCast&lt;JSInt16Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
479         return JSValue::encode(result);
480     case TypeInt32:
481         scope.release();
<span class="line-modified">482         jsCast&lt;JSInt32Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
483         return JSValue::encode(result);
484     case TypeUint8:
485         scope.release();
<span class="line-modified">486         jsCast&lt;JSUint8Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
487         return JSValue::encode(result);
488     case TypeUint8Clamped:
489         scope.release();
<span class="line-modified">490         jsCast&lt;JSUint8ClampedArray*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
491         return JSValue::encode(result);
492     case TypeUint16:
493         scope.release();
<span class="line-modified">494         jsCast&lt;JSUint16Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
495         return JSValue::encode(result);
496     case TypeUint32:
497         scope.release();
<span class="line-modified">498         jsCast&lt;JSUint32Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
499         return JSValue::encode(result);
500     case TypeFloat32:
501         scope.release();
<span class="line-modified">502         jsCast&lt;JSFloat32Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
503         return JSValue::encode(result);
504     case TypeFloat64:
505         scope.release();
<span class="line-modified">506         jsCast&lt;JSFloat64Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
507         return JSValue::encode(result);
508     default:
509         RELEASE_ASSERT_NOT_REACHED();
510     }
511 }
512 
513 template&lt;typename ViewClass&gt;
<span class="line-modified">514 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewPrivateFuncSubarrayCreate(VM&amp;vm, ExecState* exec)</span>
515 {
516     auto scope = DECLARE_THROW_SCOPE(vm);
517 
518     // 22.2.3.23
<span class="line-removed">519     JSFunction* callee = jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee());</span>
520 
<span class="line-modified">521     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
522     if (thisObject-&gt;isNeutered())
<span class="line-modified">523         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
524 
525     // Get the length here; later assert that the length didn&#39;t change.
526     unsigned thisLength = thisObject-&gt;length();
527 
528     // I would assert that the arguments are integers here but that&#39;s not true since
529     // https://tc39.github.io/ecma262/#sec-tointeger allows the result of the operation
530     // to be +/- Infinity and -0.
<span class="line-modified">531     ASSERT(exec-&gt;argument(0).isNumber());</span>
<span class="line-modified">532     ASSERT(exec-&gt;argument(1).isUndefined() || exec-&gt;argument(1).isNumber());</span>
<span class="line-modified">533     unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, thisLength);</span>
534     scope.assertNoException();
<span class="line-modified">535     unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, thisLength, thisLength);</span>
536     scope.assertNoException();
537 
538     RELEASE_ASSERT(!thisObject-&gt;isNeutered());
539 
540     // Clamp end to begin.
541     end = std::max(begin, end);
542 
543     ASSERT(end &gt;= begin);
544     unsigned offset = begin;
545     unsigned length = end - begin;
546 
547     RefPtr&lt;ArrayBuffer&gt; arrayBuffer = thisObject-&gt;possiblySharedBuffer();
548     RELEASE_ASSERT(thisLength == thisObject-&gt;length());
549 
550     unsigned newByteOffset = thisObject-&gt;byteOffset() + offset * ViewClass::elementSize;
551 
<span class="line-modified">552     JSObject* defaultConstructor = callee-&gt;globalObject(vm)-&gt;typedArrayConstructor(ViewClass::TypedArrayStorageType);</span>
<span class="line-modified">553     JSValue species = exec-&gt;uncheckedArgument(2);</span>
554     if (species == defaultConstructor) {
<span class="line-modified">555         Structure* structure = callee-&gt;globalObject(vm)-&gt;typedArrayStructure(ViewClass::TypedArrayStorageType);</span>
556 
557         RELEASE_AND_RETURN(scope, JSValue::encode(ViewClass::create(
<span class="line-modified">558             exec, structure, WTFMove(arrayBuffer),</span>
559             thisObject-&gt;byteOffset() + offset * ViewClass::elementSize,
560             length)));
561     }
562 
563     MarkedArgumentBuffer args;
<span class="line-modified">564     args.append(vm.m_typedArrayController-&gt;toJS(exec, thisObject-&gt;globalObject(vm), arrayBuffer.get()));</span>
565     args.append(jsNumber(newByteOffset));
566     args.append(jsNumber(length));
567     ASSERT(!args.hasOverflowed());
568 
<span class="line-modified">569     JSObject* result = construct(exec, species, args, &quot;species is not a constructor&quot;);</span>
570     RETURN_IF_EXCEPTION(scope, encodedJSValue());
571 
572     if (jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, result))
573         return JSValue::encode(result);
574 
<span class="line-modified">575     throwTypeError(exec, scope, &quot;species constructor did not return a TypedArray View&quot;_s);</span>
576     return JSValue::encode(JSValue());
577 }
578 
579 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 26 #pragma once
 27 
 28 #include &quot;Error.h&quot;
 29 #include &quot;JSArrayBufferViewInlines.h&quot;
 30 #include &quot;JSCBuiltins.h&quot;
 31 #include &quot;JSCJSValueInlines.h&quot;
 32 #include &quot;JSFunction.h&quot;
 33 #include &quot;JSGenericTypedArrayViewInlines.h&quot;
 34 #include &quot;JSGenericTypedArrayViewPrototypeInlines.h&quot;
 35 #include &quot;JSStringJoiner.h&quot;
 36 #include &quot;StructureInlines.h&quot;
 37 #include &quot;TypedArrayAdaptors.h&quot;
 38 #include &quot;TypedArrayController.h&quot;
 39 #include &lt;wtf/StdLibExtras.h&gt;
 40 
 41 namespace JSC {
 42 
 43 // This implements 22.2.4.7 TypedArraySpeciesCreate
 44 // Note, that this function throws.
 45 template&lt;typename Functor&gt;
<span class="line-modified"> 46 inline JSArrayBufferView* speciesConstruct(JSGlobalObject* globalObject, JSObject* exemplar, MarkedArgumentBuffer&amp; args, const Functor&amp; defaultConstructor)</span>
 47 {
<span class="line-modified"> 48     VM&amp; vm = getVM(globalObject);</span>
 49     auto scope = DECLARE_THROW_SCOPE(vm);
 50 
<span class="line-modified"> 51     JSValue constructor = exemplar-&gt;get(globalObject, vm.propertyNames-&gt;constructor);</span>
 52     RETURN_IF_EXCEPTION(scope, nullptr);
 53 
 54     if (constructor.isUndefined())
 55         RELEASE_AND_RETURN(scope, defaultConstructor());
 56 
 57     if (!constructor.isObject()) {
<span class="line-modified"> 58         throwTypeError(globalObject, scope, &quot;constructor Property should not be null&quot;_s);</span>
 59         return nullptr;
 60     }
 61 
<span class="line-modified"> 62     JSValue species = constructor.get(globalObject, vm.propertyNames-&gt;speciesSymbol);</span>
 63     RETURN_IF_EXCEPTION(scope, nullptr);
 64 
 65     if (species.isUndefinedOrNull())
 66         RELEASE_AND_RETURN(scope, defaultConstructor());
 67 
 68 
<span class="line-modified"> 69     JSValue result = construct(globalObject, species, args, &quot;species is not a constructor&quot;);</span>
 70     RETURN_IF_EXCEPTION(scope, nullptr);
 71 
 72     if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, result)) {
 73         if (view-&gt;type() == DataViewType) {
<span class="line-modified"> 74             throwTypeError(globalObject, scope, &quot;species constructor did not return a TypedArray View&quot;_s);</span>
 75             return nullptr;
 76         }
 77 
 78         if (!view-&gt;isNeutered())
 79             return view;
 80 
<span class="line-modified"> 81         throwTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
 82         return nullptr;
 83     }
 84 
<span class="line-modified"> 85     throwTypeError(globalObject, scope, &quot;species constructor did not return a TypedArray View&quot;_s);</span>
 86     return nullptr;
 87 }
 88 
<span class="line-modified"> 89 inline unsigned argumentClampedIndexFromStartOrEnd(JSGlobalObject* globalObject, JSValue value, unsigned length, unsigned undefinedValue = 0)</span>
 90 {

 91     if (value.isUndefined())
 92         return undefinedValue;
 93 
<span class="line-modified"> 94     double indexDouble = value.toInteger(globalObject);</span>
 95     if (indexDouble &lt; 0) {
 96         indexDouble += length;
 97         return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
 98     }
 99     return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);
100 }
101 
102 template&lt;typename ViewClass&gt;
<span class="line-modified">103 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncSet(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
104 {
105     auto scope = DECLARE_THROW_SCOPE(vm);
106 
107     // 22.2.3.22
<span class="line-modified">108     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
109 
<span class="line-modified">110     if (UNLIKELY(!callFrame-&gt;argumentCount()))</span>
<span class="line-modified">111         return throwVMTypeError(globalObject, scope, &quot;Expected at least one argument&quot;_s);</span>
112 
113     unsigned offset;
<span class="line-modified">114     if (callFrame-&gt;argumentCount() &gt;= 2) {</span>
<span class="line-modified">115         double offsetNumber = callFrame-&gt;uncheckedArgument(1).toInteger(globalObject);</span>
116         RETURN_IF_EXCEPTION(scope, encodedJSValue());
117         if (UNLIKELY(offsetNumber &lt; 0))
<span class="line-modified">118             return throwVMRangeError(globalObject, scope, &quot;Offset should not be negative&quot;);</span>
119         offset = static_cast&lt;unsigned&gt;(std::min(offsetNumber, static_cast&lt;double&gt;(std::numeric_limits&lt;unsigned&gt;::max())));
120     } else
121         offset = 0;
122 
123     if (UNLIKELY(thisObject-&gt;isNeutered()))
<span class="line-modified">124         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
125 
<span class="line-modified">126     JSObject* sourceArray = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;uncheckedArgument(0));</span>
127     if (UNLIKELY(!sourceArray))
<span class="line-modified">128         return throwVMTypeError(globalObject, scope, &quot;First argument should be an object&quot;_s);</span>
129 
130     unsigned length;
131     if (isTypedView(sourceArray-&gt;classInfo(vm)-&gt;typedArrayStorageType)) {
132         JSArrayBufferView* sourceView = jsCast&lt;JSArrayBufferView*&gt;(sourceArray);
133         if (UNLIKELY(sourceView-&gt;isNeutered()))
<span class="line-modified">134             return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
135 
136         length = jsCast&lt;JSArrayBufferView*&gt;(sourceArray)-&gt;length();
137     } else {
<span class="line-modified">138         JSValue lengthValue = sourceArray-&gt;get(globalObject, vm.propertyNames-&gt;length);</span>
139         RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">140         length = lengthValue.toUInt32(globalObject);</span>
141     }
142 
143     RETURN_IF_EXCEPTION(scope, encodedJSValue());
144 
145     scope.release();
<span class="line-modified">146     thisObject-&gt;set(globalObject, offset, sourceArray, 0, length, CopyType::Unobservable);</span>
147     return JSValue::encode(jsUndefined());
148 }
149 
150 template&lt;typename ViewClass&gt;
<span class="line-modified">151 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncCopyWithin(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
152 {
153     auto scope = DECLARE_THROW_SCOPE(vm);
154 
155     // 22.2.3.5
<span class="line-modified">156     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
157     if (thisObject-&gt;isNeutered())
<span class="line-modified">158         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
159 
160     long length = thisObject-&gt;length();
<span class="line-modified">161     long to = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), length);</span>
162     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">163     long from = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length);</span>
164     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">165     long final = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(2), length, length);</span>
166     RETURN_IF_EXCEPTION(scope, encodedJSValue());
167 
168     if (final &lt; from)
<span class="line-modified">169         return JSValue::encode(callFrame-&gt;thisValue());</span>
170 
171     long count = std::min(length - std::max(to, from), final - from);
172 
173     if (thisObject-&gt;isNeutered())
<span class="line-modified">174         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
175 
176     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
177     memmove(array + to, array + from, count * thisObject-&gt;elementSize);
178 
<span class="line-modified">179     return JSValue::encode(callFrame-&gt;thisValue());</span>
180 }
181 
182 template&lt;typename ViewClass&gt;
<span class="line-modified">183 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncIncludes(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
184 {
185     auto scope = DECLARE_THROW_SCOPE(vm);
186 
<span class="line-modified">187     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
188     if (thisObject-&gt;isNeutered())
<span class="line-modified">189         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
190 
191     unsigned length = thisObject-&gt;length();
192 
193     if (!length)
194         return JSValue::encode(jsBoolean(false));
195 
<span class="line-modified">196     JSValue valueToFind = callFrame-&gt;argument(0);</span>
197 
<span class="line-modified">198     unsigned index = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length);</span>
199     RETURN_IF_EXCEPTION(scope, encodedJSValue());
200 
201     if (thisObject-&gt;isNeutered())
<span class="line-modified">202         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
203 
204     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
205     auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
206     if (!targetOption)
207         return JSValue::encode(jsBoolean(false));
208 
209     scope.assertNoException();
210     RELEASE_ASSERT(!thisObject-&gt;isNeutered());
211 
212     if (std::isnan(static_cast&lt;double&gt;(*targetOption))) {
213         for (; index &lt; length; ++index) {
214             if (std::isnan(static_cast&lt;double&gt;(array[index])))
215                 return JSValue::encode(jsBoolean(true));
216         }
217     } else {
218         for (; index &lt; length; ++index) {
219             if (array[index] == targetOption)
220                 return JSValue::encode(jsBoolean(true));
221         }
222     }
223 
224     return JSValue::encode(jsBoolean(false));
225 }
226 
227 template&lt;typename ViewClass&gt;
<span class="line-modified">228 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncIndexOf(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
229 {
230     auto scope = DECLARE_THROW_SCOPE(vm);
231 
232     // 22.2.3.13
<span class="line-modified">233     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
234     if (thisObject-&gt;isNeutered())
<span class="line-modified">235         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
236 
<span class="line-modified">237     if (!callFrame-&gt;argumentCount())</span>
<span class="line-modified">238         return throwVMTypeError(globalObject, scope, &quot;Expected at least one argument&quot;_s);</span>
239 
240     unsigned length = thisObject-&gt;length();
241 
<span class="line-modified">242     JSValue valueToFind = callFrame-&gt;argument(0);</span>
<span class="line-modified">243     unsigned index = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length);</span>
244     RETURN_IF_EXCEPTION(scope, encodedJSValue());
245 
246     if (thisObject-&gt;isNeutered())
<span class="line-modified">247         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
248 
249     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
250     auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
251     if (!targetOption)
252         return JSValue::encode(jsNumber(-1));
253     scope.assertNoException();
254     RELEASE_ASSERT(!thisObject-&gt;isNeutered());
255 
256     for (; index &lt; length; ++index) {
257         if (array[index] == targetOption)
258             return JSValue::encode(jsNumber(index));
259     }
260 
261     return JSValue::encode(jsNumber(-1));
262 }
263 
264 template&lt;typename ViewClass&gt;
<span class="line-modified">265 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncJoin(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
266 {
267     auto scope = DECLARE_THROW_SCOPE(vm);
268 
<span class="line-modified">269     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
270     if (thisObject-&gt;isNeutered())
<span class="line-modified">271         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
272 
273     // 22.2.3.14
274     auto joinWithSeparator = [&amp;] (StringView separator) -&gt; EncodedJSValue {
<span class="line-modified">275         ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
276         unsigned length = thisObject-&gt;length();
277 
<span class="line-modified">278         JSStringJoiner joiner(globalObject, separator, length);</span>
279         RETURN_IF_EXCEPTION(scope, encodedJSValue());
280         for (unsigned i = 0; i &lt; length; i++) {
<span class="line-modified">281             joiner.append(globalObject, thisObject-&gt;getIndexQuickly(i));</span>
282             RETURN_IF_EXCEPTION(scope, encodedJSValue());
283         }
<span class="line-modified">284         RELEASE_AND_RETURN(scope, JSValue::encode(joiner.join(globalObject)));</span>
285     };
286 
<span class="line-modified">287     JSValue separatorValue = callFrame-&gt;argument(0);</span>
288     if (separatorValue.isUndefined()) {
289         const LChar* comma = reinterpret_cast&lt;const LChar*&gt;(&quot;,&quot;);
290         return joinWithSeparator({ comma, 1 });
291     }
292 
<span class="line-modified">293     JSString* separatorString = separatorValue.toString(globalObject);</span>
294     RETURN_IF_EXCEPTION(scope, encodedJSValue());
295 
296     if (thisObject-&gt;isNeutered())
<span class="line-modified">297         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
<span class="line-modified">298     auto viewWithString = separatorString-&gt;viewWithUnderlyingString(globalObject);</span>
299     RETURN_IF_EXCEPTION(scope, encodedJSValue());
300     return joinWithSeparator(viewWithString.view);
301 }
302 
303 template&lt;typename ViewClass&gt;
<span class="line-modified">304 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncLastIndexOf(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
305 {
306     auto scope = DECLARE_THROW_SCOPE(vm);
307 
308     // 22.2.3.16
<span class="line-modified">309     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
310     if (thisObject-&gt;isNeutered())
<span class="line-modified">311         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
312 
<span class="line-modified">313     if (!callFrame-&gt;argumentCount())</span>
<span class="line-modified">314         return throwVMTypeError(globalObject, scope, &quot;Expected at least one argument&quot;_s);</span>
315 
316     unsigned length = thisObject-&gt;length();
317 
<span class="line-modified">318     JSValue valueToFind = callFrame-&gt;argument(0);</span>
319 
320     int index = length - 1;
<span class="line-modified">321     if (callFrame-&gt;argumentCount() &gt;= 2) {</span>
<span class="line-modified">322         JSValue fromValue = callFrame-&gt;uncheckedArgument(1);</span>
<span class="line-modified">323         double fromDouble = fromValue.toInteger(globalObject);</span>
324         RETURN_IF_EXCEPTION(scope, encodedJSValue());
325         if (fromDouble &lt; 0) {
326             fromDouble += length;
327             if (fromDouble &lt; 0)
328                 return JSValue::encode(jsNumber(-1));
329         }
330         if (fromDouble &lt; length)
331             index = static_cast&lt;unsigned&gt;(fromDouble);
332     }
333 
334     if (thisObject-&gt;isNeutered())
<span class="line-modified">335         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
336 
337     auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
338     if (!targetOption)
339         return JSValue::encode(jsNumber(-1));
340 
341     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
342     scope.assertNoException();
343     RELEASE_ASSERT(!thisObject-&gt;isNeutered());
344 
345     for (; index &gt;= 0; --index) {
346         if (array[index] == targetOption)
347             return JSValue::encode(jsNumber(index));
348     }
349 
350     return JSValue::encode(jsNumber(-1));
351 }
352 
353 template&lt;typename ViewClass&gt;
<span class="line-modified">354 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncBuffer(VM&amp;, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
355 {
356     // 22.2.3.3
<span class="line-modified">357     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
358 
<span class="line-modified">359     return JSValue::encode(thisObject-&gt;possiblySharedJSBuffer(globalObject));</span>
360 }
361 
362 template&lt;typename ViewClass&gt;
<span class="line-modified">363 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncLength(VM&amp;, JSGlobalObject*, CallFrame* callFrame)</span>
364 {
365     // 22.2.3.17
<span class="line-modified">366     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
367 
368     return JSValue::encode(jsNumber(thisObject-&gt;length()));
369 }
370 
371 template&lt;typename ViewClass&gt;
<span class="line-modified">372 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncByteLength(VM&amp;, JSGlobalObject*, CallFrame* callFrame)</span>
373 {
374     // 22.2.3.2
<span class="line-modified">375     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
376 
377     return JSValue::encode(jsNumber(thisObject-&gt;byteLength()));
378 }
379 
380 template&lt;typename ViewClass&gt;
<span class="line-modified">381 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncByteOffset(VM&amp;, JSGlobalObject*, CallFrame* callFrame)</span>
382 {
383     // 22.2.3.3
<span class="line-modified">384     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
385 
386     return JSValue::encode(jsNumber(thisObject-&gt;byteOffset()));
387 }
388 
389 template&lt;typename ViewClass&gt;
<span class="line-modified">390 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncReverse(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
391 {
<span class="line-modified">392 //    VM&amp; vm = getVM(globalObject);</span>
393     auto scope = DECLARE_THROW_SCOPE(vm);
394 
395     // 22.2.3.21
<span class="line-modified">396     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
397     if (thisObject-&gt;isNeutered())
<span class="line-modified">398         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
399 
400     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
401     std::reverse(array, array + thisObject-&gt;length());
402 
403     return JSValue::encode(thisObject);
404 }
405 
406 template&lt;typename ViewClass&gt;
<span class="line-modified">407 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewPrivateFuncSort(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
408 {
<span class="line-modified">409 //    VM&amp; vm = getVM(globalObject);</span>
410     auto scope = DECLARE_THROW_SCOPE(vm);
411 
412     // 22.2.3.25
<span class="line-modified">413     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;argument(0));</span>
414     if (thisObject-&gt;isNeutered())
<span class="line-modified">415         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
416 
417     thisObject-&gt;sort();
418 
419     return JSValue::encode(thisObject);
420 }
421 
422 template&lt;typename ViewClass&gt;
<span class="line-modified">423 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncSlice(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
424 {
425     auto scope = DECLARE_THROW_SCOPE(vm);
426 
427     // 22.2.3.26

428 
<span class="line-modified">429     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
430     if (thisObject-&gt;isNeutered())
<span class="line-modified">431         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
432 
433     unsigned thisLength = thisObject-&gt;length();
434 
<span class="line-modified">435     unsigned begin = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), thisLength);</span>
436     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">437     unsigned end = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), thisLength, thisLength);</span>
438     RETURN_IF_EXCEPTION(scope, encodedJSValue());
439 
440     if (thisObject-&gt;isNeutered())
<span class="line-modified">441         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
442 
443     // Clamp end to begin.
444     end = std::max(begin, end);
445 
446     ASSERT(end &gt;= begin);
447     unsigned length = end - begin;
448 
449     MarkedArgumentBuffer args;
450     args.append(jsNumber(length));
451     ASSERT(!args.hasOverflowed());
452 
<span class="line-modified">453     JSArrayBufferView* result = speciesConstruct(globalObject, thisObject, args, [&amp;]() {</span>
<span class="line-modified">454         Structure* structure = globalObject-&gt;typedArrayStructure(ViewClass::TypedArrayStorageType);</span>
<span class="line-modified">455         return ViewClass::createUninitialized(globalObject, structure, length);</span>
456     });
457     RETURN_IF_EXCEPTION(scope, encodedJSValue());
458 
459     ASSERT(!result-&gt;isNeutered());
460     if (thisObject-&gt;isNeutered())
<span class="line-modified">461         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
462 
463     // We return early here since we don&#39;t allocate a backing store if length is 0 and memmove does not like nullptrs
464     if (!length)
465         return JSValue::encode(result);
466 
467     // The species constructor may return an array with any arbitrary length.
468     length = std::min(length, result-&gt;length());
469     switch (result-&gt;classInfo(vm)-&gt;typedArrayStorageType) {
470     case TypeInt8:
471         scope.release();
<span class="line-modified">472         jsCast&lt;JSInt8Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
473         return JSValue::encode(result);
474     case TypeInt16:
475         scope.release();
<span class="line-modified">476         jsCast&lt;JSInt16Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
477         return JSValue::encode(result);
478     case TypeInt32:
479         scope.release();
<span class="line-modified">480         jsCast&lt;JSInt32Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
481         return JSValue::encode(result);
482     case TypeUint8:
483         scope.release();
<span class="line-modified">484         jsCast&lt;JSUint8Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
485         return JSValue::encode(result);
486     case TypeUint8Clamped:
487         scope.release();
<span class="line-modified">488         jsCast&lt;JSUint8ClampedArray*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
489         return JSValue::encode(result);
490     case TypeUint16:
491         scope.release();
<span class="line-modified">492         jsCast&lt;JSUint16Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
493         return JSValue::encode(result);
494     case TypeUint32:
495         scope.release();
<span class="line-modified">496         jsCast&lt;JSUint32Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
497         return JSValue::encode(result);
498     case TypeFloat32:
499         scope.release();
<span class="line-modified">500         jsCast&lt;JSFloat32Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
501         return JSValue::encode(result);
502     case TypeFloat64:
503         scope.release();
<span class="line-modified">504         jsCast&lt;JSFloat64Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
505         return JSValue::encode(result);
506     default:
507         RELEASE_ASSERT_NOT_REACHED();
508     }
509 }
510 
511 template&lt;typename ViewClass&gt;
<span class="line-modified">512 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewPrivateFuncSubarrayCreate(VM&amp;vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
513 {
514     auto scope = DECLARE_THROW_SCOPE(vm);
515 
516     // 22.2.3.23

517 
<span class="line-modified">518     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
519     if (thisObject-&gt;isNeutered())
<span class="line-modified">520         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
521 
522     // Get the length here; later assert that the length didn&#39;t change.
523     unsigned thisLength = thisObject-&gt;length();
524 
525     // I would assert that the arguments are integers here but that&#39;s not true since
526     // https://tc39.github.io/ecma262/#sec-tointeger allows the result of the operation
527     // to be +/- Infinity and -0.
<span class="line-modified">528     ASSERT(callFrame-&gt;argument(0).isNumber());</span>
<span class="line-modified">529     ASSERT(callFrame-&gt;argument(1).isUndefined() || callFrame-&gt;argument(1).isNumber());</span>
<span class="line-modified">530     unsigned begin = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), thisLength);</span>
531     scope.assertNoException();
<span class="line-modified">532     unsigned end = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), thisLength, thisLength);</span>
533     scope.assertNoException();
534 
535     RELEASE_ASSERT(!thisObject-&gt;isNeutered());
536 
537     // Clamp end to begin.
538     end = std::max(begin, end);
539 
540     ASSERT(end &gt;= begin);
541     unsigned offset = begin;
542     unsigned length = end - begin;
543 
544     RefPtr&lt;ArrayBuffer&gt; arrayBuffer = thisObject-&gt;possiblySharedBuffer();
545     RELEASE_ASSERT(thisLength == thisObject-&gt;length());
546 
547     unsigned newByteOffset = thisObject-&gt;byteOffset() + offset * ViewClass::elementSize;
548 
<span class="line-modified">549     JSObject* defaultConstructor = globalObject-&gt;typedArrayConstructor(ViewClass::TypedArrayStorageType);</span>
<span class="line-modified">550     JSValue species = callFrame-&gt;uncheckedArgument(2);</span>
551     if (species == defaultConstructor) {
<span class="line-modified">552         Structure* structure = globalObject-&gt;typedArrayStructure(ViewClass::TypedArrayStorageType);</span>
553 
554         RELEASE_AND_RETURN(scope, JSValue::encode(ViewClass::create(
<span class="line-modified">555             globalObject, structure, WTFMove(arrayBuffer),</span>
556             thisObject-&gt;byteOffset() + offset * ViewClass::elementSize,
557             length)));
558     }
559 
560     MarkedArgumentBuffer args;
<span class="line-modified">561     args.append(vm.m_typedArrayController-&gt;toJS(globalObject, thisObject-&gt;globalObject(vm), arrayBuffer.get()));</span>
562     args.append(jsNumber(newByteOffset));
563     args.append(jsNumber(length));
564     ASSERT(!args.hasOverflowed());
565 
<span class="line-modified">566     JSObject* result = construct(globalObject, species, args, &quot;species is not a constructor&quot;);</span>
567     RETURN_IF_EXCEPTION(scope, encodedJSValue());
568 
569     if (jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, result))
570         return JSValue::encode(result);
571 
<span class="line-modified">572     throwTypeError(globalObject, scope, &quot;species constructor did not return a TypedArray View&quot;_s);</span>
573     return JSValue::encode(JSValue());
574 }
575 
576 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSGenericTypedArrayViewInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalLexicalEnvironment.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
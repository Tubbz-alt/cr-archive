<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableGrid.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TableFormattingState.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TableGrid.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableGrid.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TableGrid.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &lt;wtf/IsoMallocInlines.h&gt;
 32 
 33 namespace WebCore {
 34 namespace Layout {
 35 
 36 WTF_MAKE_ISO_ALLOCATED_IMPL(TableGrid);
 37 





 38 void TableGrid::Column::setWidthConstraints(FormattingContext::IntrinsicWidthConstraints widthConstraints)
 39 {
<span class="line-modified"> 40 #ifndef NDEBUG</span>
 41     m_hasWidthConstraints = true;
 42 #endif
 43     m_widthConstraints = widthConstraints;
 44 }
 45 
 46 FormattingContext::IntrinsicWidthConstraints TableGrid::Column::widthConstraints() const
 47 {
 48     ASSERT(m_hasWidthConstraints);
 49     return m_widthConstraints;
 50 }
 51 
 52 void TableGrid::Column::setLogicalWidth(LayoutUnit computedLogicalWidth)
 53 {
<span class="line-modified"> 54 #ifndef NDEBUG</span>
 55     m_hasComputedWidth = true;
 56 #endif
 57     m_computedLogicalWidth = computedLogicalWidth;
 58 }
 59 
 60 LayoutUnit TableGrid::Column::logicalWidth() const
 61 {
 62     ASSERT(m_hasComputedWidth);
 63     return m_computedLogicalWidth;
 64 }
 65 
 66 void TableGrid::Column::setLogicalLeft(LayoutUnit computedLogicalLeft)
 67 {
<span class="line-modified"> 68 #ifndef NDEBUG</span>
 69     m_hasComputedLeft = true;
 70 #endif
 71     m_computedLogicalLeft = computedLogicalLeft;
 72 }
 73 
 74 LayoutUnit TableGrid::Column::logicalLeft() const
 75 {
 76     ASSERT(m_hasComputedLeft);
 77     return m_computedLogicalLeft;
 78 }
 79 
<span class="line-modified"> 80 void TableGrid::ColumnsContext::addColumn()</span>
 81 {
<span class="line-modified"> 82     m_columns.append({ });</span>

 83 }
 84 
<span class="line-modified"> 85 void TableGrid::ColumnsContext::useAsLogicalWidth(WidthConstraintsType type)</span>






 86 {
<span class="line-removed"> 87     for (auto&amp; column : m_columns)</span>
<span class="line-removed"> 88         column.setLogicalWidth(type == WidthConstraintsType::Minimum ? column.widthConstraints().minimum : column.widthConstraints().maximum);</span>
 89 }
 90 
 91 TableGrid::CellInfo::CellInfo(const Box&amp; tableCellBox, SlotPosition position, CellSize size)
 92     : tableCellBox(tableCellBox)
 93     , position(position)
 94     , size(size)
 95 {
 96 }
 97 
 98 TableGrid::SlotInfo::SlotInfo(CellInfo&amp; cell)
 99     : cell(makeWeakPtr(cell))
100 {
101 }
102 
103 TableGrid::TableGrid()
104 {
105 }
106 
107 TableGrid::SlotInfo* TableGrid::slot(SlotPosition position)
108 {
</pre>
<hr />
<pre>
125         else
126             initialSlotPosition = SlotPosition { lastSlotPosition.x() + 1, lastSlotPosition.y() };
127 
128         // Pick the next available slot by avoiding row and column spanners.
129         while (true) {
130             if (!m_slotMap.contains(initialSlotPosition))
131                 break;
132             initialSlotPosition.move(1, 0);
133         }
134     }
135     auto cellInfo = makeUnique&lt;CellInfo&gt;(tableCellBox, initialSlotPosition, CellSize { rowSpan, columnSpan });
136     // Row and column spanners create additional slots.
137     for (int row = 1; row &lt;= rowSpan; ++row) {
138         for (int column = 1; column &lt;= columnSpan; ++column) {
139             auto position = SlotPosition { initialSlotPosition.x() + row - 1, initialSlotPosition.y() + column - 1 };
140             ASSERT(!m_slotMap.contains(position));
141             m_slotMap.add(position, makeUnique&lt;SlotInfo&gt;(*cellInfo));
142         }
143     }
144     // Initialize columns/rows if needed.
<span class="line-modified">145     auto missingNumberOfColumns = std::max&lt;unsigned&gt;(0, (initialSlotPosition.x() + columnSpan) - m_columnsContext.columns().size());</span>
<span class="line-modified">146     for (unsigned column = 0; column &lt; missingNumberOfColumns; ++column)</span>
147         m_columnsContext.addColumn();
148 
149     if (isInNewRow)
<span class="line-modified">150         m_rows.append({ });</span>
151 
152     m_cellList.add(WTFMove(cellInfo));
153 }
154 
155 void TableGrid::insertCell(const Box&amp; tableCellBox, const Box&amp; before)
156 {
157     UNUSED_PARAM(tableCellBox);
158     UNUSED_PARAM(before);
159 }
160 
161 void TableGrid::removeCell(const Box&amp; tableCellBox)
162 {
163     UNUSED_PARAM(tableCellBox);
164 }
165 
<span class="line-modified">166 FormattingContext::IntrinsicWidthConstraints TableGrid::widthConstraints() const</span>
167 {
<span class="line-modified">168     // FIXME: We should probably cache this value.</span>
<span class="line-modified">169     auto widthConstraints = FormattingContext::IntrinsicWidthConstraints { };</span>



170     for (auto&amp; column : m_columnsContext.columns())
<span class="line-modified">171         widthConstraints += column.widthConstraints();</span>
<span class="line-modified">172     return widthConstraints;</span>

173 }
174 
175 }
176 }
177 #endif
</pre>
</td>
<td>
<hr />
<pre>
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TableGrid.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &lt;wtf/IsoMallocInlines.h&gt;
 32 
 33 namespace WebCore {
 34 namespace Layout {
 35 
 36 WTF_MAKE_ISO_ALLOCATED_IMPL(TableGrid);
 37 
<span class="line-added"> 38 TableGrid::Column::Column(const Box* columnBox)</span>
<span class="line-added"> 39     : m_columnBox(makeWeakPtr(columnBox))</span>
<span class="line-added"> 40 {</span>
<span class="line-added"> 41 }</span>
<span class="line-added"> 42 </span>
 43 void TableGrid::Column::setWidthConstraints(FormattingContext::IntrinsicWidthConstraints widthConstraints)
 44 {
<span class="line-modified"> 45 #if ASSERT_ENABLED</span>
 46     m_hasWidthConstraints = true;
 47 #endif
 48     m_widthConstraints = widthConstraints;
 49 }
 50 
 51 FormattingContext::IntrinsicWidthConstraints TableGrid::Column::widthConstraints() const
 52 {
 53     ASSERT(m_hasWidthConstraints);
 54     return m_widthConstraints;
 55 }
 56 
 57 void TableGrid::Column::setLogicalWidth(LayoutUnit computedLogicalWidth)
 58 {
<span class="line-modified"> 59 #if ASSERT_ENABLED</span>
 60     m_hasComputedWidth = true;
 61 #endif
 62     m_computedLogicalWidth = computedLogicalWidth;
 63 }
 64 
 65 LayoutUnit TableGrid::Column::logicalWidth() const
 66 {
 67     ASSERT(m_hasComputedWidth);
 68     return m_computedLogicalWidth;
 69 }
 70 
 71 void TableGrid::Column::setLogicalLeft(LayoutUnit computedLogicalLeft)
 72 {
<span class="line-modified"> 73 #if ASSERT_ENABLED</span>
 74     m_hasComputedLeft = true;
 75 #endif
 76     m_computedLogicalLeft = computedLogicalLeft;
 77 }
 78 
 79 LayoutUnit TableGrid::Column::logicalLeft() const
 80 {
 81     ASSERT(m_hasComputedLeft);
 82     return m_computedLogicalLeft;
 83 }
 84 
<span class="line-modified"> 85 bool TableGrid::Column::hasFixedWidth() const</span>
 86 {
<span class="line-modified"> 87     // FIXME: This only covers the &lt;col&gt; attribute case.</span>
<span class="line-added"> 88     return columnBox() &amp;&amp; columnBox()-&gt;columnWidth();</span>
 89 }
 90 
<span class="line-modified"> 91 void TableGrid::ColumnsContext::addColumn(const Box* columnBox)</span>
<span class="line-added"> 92 {</span>
<span class="line-added"> 93     m_columns.append({ columnBox });</span>
<span class="line-added"> 94 }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96 TableGrid::Row::Row(const Box&amp; rowBox)</span>
<span class="line-added"> 97     : m_layoutBox(rowBox)</span>
 98 {


 99 }
100 
101 TableGrid::CellInfo::CellInfo(const Box&amp; tableCellBox, SlotPosition position, CellSize size)
102     : tableCellBox(tableCellBox)
103     , position(position)
104     , size(size)
105 {
106 }
107 
108 TableGrid::SlotInfo::SlotInfo(CellInfo&amp; cell)
109     : cell(makeWeakPtr(cell))
110 {
111 }
112 
113 TableGrid::TableGrid()
114 {
115 }
116 
117 TableGrid::SlotInfo* TableGrid::slot(SlotPosition position)
118 {
</pre>
<hr />
<pre>
135         else
136             initialSlotPosition = SlotPosition { lastSlotPosition.x() + 1, lastSlotPosition.y() };
137 
138         // Pick the next available slot by avoiding row and column spanners.
139         while (true) {
140             if (!m_slotMap.contains(initialSlotPosition))
141                 break;
142             initialSlotPosition.move(1, 0);
143         }
144     }
145     auto cellInfo = makeUnique&lt;CellInfo&gt;(tableCellBox, initialSlotPosition, CellSize { rowSpan, columnSpan });
146     // Row and column spanners create additional slots.
147     for (int row = 1; row &lt;= rowSpan; ++row) {
148         for (int column = 1; column &lt;= columnSpan; ++column) {
149             auto position = SlotPosition { initialSlotPosition.x() + row - 1, initialSlotPosition.y() + column - 1 };
150             ASSERT(!m_slotMap.contains(position));
151             m_slotMap.add(position, makeUnique&lt;SlotInfo&gt;(*cellInfo));
152         }
153     }
154     // Initialize columns/rows if needed.
<span class="line-modified">155     auto missingNumberOfColumns = std::max&lt;int&gt;(0, initialSlotPosition.x() + columnSpan - m_columnsContext.columns().size());</span>
<span class="line-modified">156     for (auto column = 0; column &lt; missingNumberOfColumns; ++column)</span>
157         m_columnsContext.addColumn();
158 
159     if (isInNewRow)
<span class="line-modified">160         m_rows.append({ *tableCellBox.parent() });</span>
161 
162     m_cellList.add(WTFMove(cellInfo));
163 }
164 
165 void TableGrid::insertCell(const Box&amp; tableCellBox, const Box&amp; before)
166 {
167     UNUSED_PARAM(tableCellBox);
168     UNUSED_PARAM(before);
169 }
170 
171 void TableGrid::removeCell(const Box&amp; tableCellBox)
172 {
173     UNUSED_PARAM(tableCellBox);
174 }
175 
<span class="line-modified">176 FormattingContext::IntrinsicWidthConstraints TableGrid::widthConstraints()</span>
177 {
<span class="line-modified">178     // FIXME: Add constraint invalidation for incremental layouts.</span>
<span class="line-modified">179     if (m_intrinsicWidthConstraints)</span>
<span class="line-added">180         return *m_intrinsicWidthConstraints;</span>
<span class="line-added">181 </span>
<span class="line-added">182     m_intrinsicWidthConstraints = FormattingContext::IntrinsicWidthConstraints { };</span>
183     for (auto&amp; column : m_columnsContext.columns())
<span class="line-modified">184         *m_intrinsicWidthConstraints += column.widthConstraints();</span>
<span class="line-modified">185     m_intrinsicWidthConstraints-&gt;expand(totalHorizontalSpacing());</span>
<span class="line-added">186     return *m_intrinsicWidthConstraints;</span>
187 }
188 
189 }
190 }
191 #endif
</pre>
</td>
</tr>
</table>
<center><a href="TableFormattingState.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TableGrid.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
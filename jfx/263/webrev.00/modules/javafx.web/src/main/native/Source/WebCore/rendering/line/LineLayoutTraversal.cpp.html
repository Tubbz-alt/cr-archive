<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/line/LineLayoutTraversal.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LineLayoutTraversal.h&quot;
 28 
 29 #include &quot;LayoutIntegrationLineLayout.h&quot;
 30 #include &quot;RenderLineBreak.h&quot;
 31 
 32 namespace WebCore {
 33 namespace LineLayoutTraversal {
 34 
 35 TextBoxIterator::TextBoxIterator(Box::PathVariant&amp;&amp; pathVariant)
 36     : m_textBox(WTFMove(pathVariant))
 37 {
 38 }
 39 
 40 TextBoxIterator&amp; TextBoxIterator::traverseNextInVisualOrder()
 41 {
 42     WTF::switchOn(m_textBox.m_pathVariant, [](auto&amp; path) {
 43         path.traverseNextTextBoxInVisualOrder();
 44     });
 45     return *this;
 46 }
 47 
 48 TextBoxIterator&amp; TextBoxIterator::traverseNextInTextOrder()
 49 {
 50     WTF::switchOn(m_textBox.m_pathVariant, [](auto&amp; path) {
 51         path.traverseNextTextBoxInTextOrder();
 52     });
 53     return *this;
 54 }
 55 
 56 bool TextBoxIterator::operator==(const TextBoxIterator&amp; other) const
 57 {
 58     if (m_textBox.m_pathVariant.index() != other.m_textBox.m_pathVariant.index())
 59         return false;
 60 
 61     return WTF::switchOn(m_textBox.m_pathVariant, [&amp;](const auto&amp; path) {
 62         return path == WTF::get&lt;std::decay_t&lt;decltype(path)&gt;&gt;(other.m_textBox.m_pathVariant);
 63     });
 64 }
 65 
 66 bool TextBoxIterator::atEnd() const
 67 {
 68     return WTF::switchOn(m_textBox.m_pathVariant, [](auto&amp; path) {
 69         return path.atEnd();
 70     });
 71 }
 72 
 73 static const RenderBlockFlow* lineLayoutSystemFlowForRenderer(const RenderObject&amp; renderer)
 74 {
 75     // In currently supported cases the renderer is always direct child of the flow.
 76     if (!is&lt;RenderBlockFlow&gt;(*renderer.parent()))
 77         return nullptr;
 78     return downcast&lt;RenderBlockFlow&gt;(renderer.parent());
 79 }
 80 
 81 TextBoxIterator firstTextBoxFor(const RenderText&amp; text)
 82 {
 83     if (auto* flow = lineLayoutSystemFlowForRenderer(text)) {
 84         if (auto* simpleLineLayout = flow-&gt;simpleLineLayout()) {
 85             auto range = simpleLineLayout-&gt;runResolver().rangeForRenderer(text);
 86             return { SimplePath { range.begin(), range.end() } };
 87         }
 88 
 89 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 90         if (auto* layoutFormattingContextLineLayout = flow-&gt;layoutFormattingContextLineLayout())
 91             return layoutFormattingContextLineLayout-&gt;textBoxesFor(text);
 92 #endif
 93     }
 94 
 95     return { ComplexPath { text.firstTextBox() } };
 96 }
 97 
 98 TextBoxIterator firstTextBoxInTextOrderFor(const RenderText&amp; text)
 99 {
100     if (text.firstTextBox() &amp;&amp; text.containsReversedText()) {
101         Vector&lt;const InlineTextBox*&gt; sortedTextBoxes;
102         for (auto* textBox = text.firstTextBox(); textBox; textBox = textBox-&gt;nextTextBox())
103             sortedTextBoxes.append(textBox);
104         std::sort(sortedTextBoxes.begin(), sortedTextBoxes.end(), InlineTextBox::compareByStart);
105         auto* first = sortedTextBoxes[0];
106         return { ComplexPath { first, WTFMove(sortedTextBoxes), 0 } };
107     }
108 
109     return firstTextBoxFor(text);
110 }
111 
112 TextBoxRange textBoxesFor(const RenderText&amp; text)
113 {
114     return { firstTextBoxFor(text) };
115 }
116 
117 ElementBoxIterator::ElementBoxIterator(Box::PathVariant&amp;&amp; pathVariant)
118     : m_box(WTFMove(pathVariant))
119 {
120 }
121 
122 bool ElementBoxIterator::atEnd() const
123 {
124     return WTF::switchOn(m_box.m_pathVariant, [](auto&amp; path) {
125         return path.atEnd();
126     });
127 }
128 
129 ElementBoxIterator elementBoxFor(const RenderLineBreak&amp; renderElement)
130 {
131     if (auto* flow = lineLayoutSystemFlowForRenderer(renderElement)) {
132         if (auto* simpleLineLayout = flow-&gt;simpleLineLayout()) {
133             auto range = simpleLineLayout-&gt;runResolver().rangeForRenderer(renderElement);
134             return { SimplePath(range.begin(), range.end()) };
135         }
136 
137 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
138         if (auto* layoutFormattingContextLineLayout = flow-&gt;layoutFormattingContextLineLayout())
139             return layoutFormattingContextLineLayout-&gt;elementBoxFor(renderElement);
140 #endif
141     }
142 
143     return { ComplexPath(renderElement.inlineBoxWrapper()) };
144 }
145 
146 }
147 }
    </pre>
  </body>
</html>
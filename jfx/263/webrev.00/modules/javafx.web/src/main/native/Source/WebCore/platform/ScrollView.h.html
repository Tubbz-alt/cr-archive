<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.
  3  * Copyright (C) 2009 Holger Hans Peter Freyther
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;FloatRect.h&quot;
 30 #include &quot;IntRect.h&quot;
 31 #include &quot;Scrollbar.h&quot;
 32 #include &quot;ScrollableArea.h&quot;
 33 #include &quot;ScrollTypes.h&quot;
 34 #include &quot;Widget.h&quot;
 35 #include &lt;wtf/HashSet.h&gt;
 36 #include &lt;wtf/WeakPtr.h&gt;
 37 
 38 #if PLATFORM(IOS_FAMILY)
 39 
 40 OBJC_CLASS WAKScrollView;
 41 OBJC_CLASS WAKView;
 42 
 43 #ifndef NSScrollView
 44 #define NSScrollView WAKScrollView
 45 #endif
 46 
 47 #ifndef NSView
 48 #define NSView WAKView
 49 #endif
 50 
 51 #endif // PLATFORM(IOS_FAMILY)
 52 
 53 #if PLATFORM(COCOA) &amp;&amp; defined __OBJC__
 54 @class NSScrollView;
 55 @protocol WebCoreFrameScrollView;
 56 #endif
 57 
 58 namespace WebCore {
 59 
 60 class HostWindow;
 61 class LegacyTileCache;
 62 class Scrollbar;
 63 
 64 class ScrollView : public Widget, public ScrollableArea {
 65 public:
 66     virtual ~ScrollView();
 67 
 68     using WeakValueType = Widget::WeakValueType;
 69     using Widget::weakPtrFactory;
 70 
 71     // ScrollableArea functions.
 72     WEBCORE_EXPORT void setScrollOffset(const ScrollOffset&amp;) final;
 73     bool isScrollCornerVisible() const final;
 74     void scrollbarStyleChanged(ScrollbarStyle, bool forceUpdate) override;
 75 
 76     virtual void notifyPageThatContentAreaWillPaint() const;
 77 
 78     IntPoint locationOfContents() const;
 79 
 80     // NOTE: This should only be called by the overridden setScrollOffset from ScrollableArea.
 81     virtual void scrollTo(const ScrollPosition&amp;);
 82 
 83     // The window thats hosts the ScrollView. The ScrollView will communicate scrolls and repaints to the
 84     // host window in the window&#39;s coordinate space.
 85     virtual HostWindow* hostWindow() const = 0;
 86 
 87     // Returns a clip rect in host window coordinates. Used to clip the blit on a scroll.
 88     virtual IntRect windowClipRect() const = 0;
 89 
 90     // Functions for child manipulation and inspection.
 91     const HashSet&lt;Ref&lt;Widget&gt;&gt;&amp; children() const { return m_children; }
 92     WEBCORE_EXPORT virtual void addChild(Widget&amp;);
 93     WEBCORE_EXPORT virtual void removeChild(Widget&amp;);
 94 
 95     // If the scroll view does not use a native widget, then it will have cross-platform Scrollbars. These functions
 96     // can be used to obtain those scrollbars.
 97     Scrollbar* horizontalScrollbar() const final { return m_horizontalScrollbar.get(); }
 98     Scrollbar* verticalScrollbar() const final { return m_verticalScrollbar.get(); }
 99     bool isScrollViewScrollbar(const Widget* child) const { return horizontalScrollbar() == child || verticalScrollbar() == child; }
100 
101     void positionScrollbarLayers();
102 
103     // Functions for setting and retrieving the scrolling mode in each axis (horizontal/vertical). The mode has values of
104     // AlwaysOff, AlwaysOn, and Auto. AlwaysOff means never show a scrollbar, AlwaysOn means always show a scrollbar.
105     // Auto means show a scrollbar only when one is needed.
106     // Note that for platforms with native widgets, these modes are considered advisory. In other words the underlying native
107     // widget may choose not to honor the requested modes.
108     WEBCORE_EXPORT void setScrollbarModes(ScrollbarMode horizontalMode, ScrollbarMode verticalMode, bool horizontalLock = false, bool verticalLock = false);
109     void setHorizontalScrollbarMode(ScrollbarMode mode, bool lock = false) { setScrollbarModes(mode, verticalScrollbarMode(), lock, verticalScrollbarLock()); }
110     void setVerticalScrollbarMode(ScrollbarMode mode, bool lock = false) { setScrollbarModes(horizontalScrollbarMode(), mode, horizontalScrollbarLock(), lock); };
111     WEBCORE_EXPORT void scrollbarModes(ScrollbarMode&amp; horizontalMode, ScrollbarMode&amp; verticalMode) const;
112     ScrollbarMode horizontalScrollbarMode() const final { ScrollbarMode horizontal, vertical; scrollbarModes(horizontal, vertical); return horizontal; }
113     ScrollbarMode verticalScrollbarMode() const final { ScrollbarMode horizontal, vertical; scrollbarModes(horizontal, vertical); return vertical; }
114 
115     void setHorizontalScrollbarLock(bool lock = true) { m_horizontalScrollbarLock = lock; }
116     bool horizontalScrollbarLock() const { return m_horizontalScrollbarLock; }
117     void setVerticalScrollbarLock(bool lock = true) { m_verticalScrollbarLock = lock; }
118     bool verticalScrollbarLock() const { return m_verticalScrollbarLock; }
119 
120     void setScrollingModesLock(bool lock = true) { m_horizontalScrollbarLock = m_verticalScrollbarLock = lock; }
121 
122     WEBCORE_EXPORT virtual void setCanHaveScrollbars(bool);
123 
124     virtual bool avoidScrollbarCreation() const { return false; }
125 
126     void setScrollbarOverlayStyle(ScrollbarOverlayStyle) final;
127 
128     // By default you only receive paint events for the area that is visible. In the case of using a
129     // tiled backing store, this function can be set, so that the view paints the entire contents.
130     bool paintsEntireContents() const { return m_paintsEntireContents; }
131     WEBCORE_EXPORT void setPaintsEntireContents(bool);
132 
133     // By default programmatic scrolling is handled by WebCore and not by the UI application.
134     // In the case of using a tiled backing store, this mode can be set, so that the scroll requests
135     // are delegated to the UI application.
136     bool delegatesScrolling() const { return m_delegatesScrolling; }
137     WEBCORE_EXPORT void setDelegatesScrolling(bool);
138 
139     // Overridden by FrameView to create custom CSS scrollbars if applicable.
140     virtual Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
141 
142     virtual void styleDidChange();
143 
144     // If the prohibits scrolling flag is set, then all scrolling in the view (even programmatic scrolling) is turned off.
145     void setProhibitsScrolling(bool b) { m_prohibitsScrolling = b; }
146     bool prohibitsScrolling() const { return m_prohibitsScrolling; }
147 
148     // Whether or not a scroll view will blit visible contents when it is scrolled. Blitting is disabled in situations
149     // where it would cause rendering glitches (such as with fixed backgrounds or when the view is partially transparent).
150     void setCanBlitOnScroll(bool);
151     bool canBlitOnScroll() const;
152 
153     // There are at least three types of contentInset. Usually we just care about WebCoreContentInset, which is the inset
154     // that is set on a Page that requires WebCore to move its layers to accomodate the inset. However, there are platform
155     // concepts that are similar on both iOS and Mac when there is a platformWidget(). Sometimes we need the Mac platform value
156     // for topContentInset, so when the TopContentInsetType is WebCoreOrPlatformContentInset, platformTopContentInset()
157     // will be returned instead of the value set on Page.
158     enum class TopContentInsetType { WebCoreContentInset, WebCoreOrPlatformContentInset };
159     virtual float topContentInset(TopContentInsetType = TopContentInsetType::WebCoreContentInset) const { return 0; }
160 
161     // The visible content rect has a location that is the scrolled offset of the document. The width and height are the unobscured viewport
162     // width and height. By default the scrollbars themselves are excluded from this rectangle, but an optional boolean argument allows them
163     // to be included.
164     // In the situation the client is responsible for the scrolling (ie. with a tiled backing store) it is possible to use
165     // the setFixedVisibleContentRect instead for the mainframe, though this must be updated manually, e.g just before resuming the page
166     // which usually will happen when panning, pinching and rotation ends, or when scale or position are changed manually.
167     IntSize visibleSize() const final { return visibleContentRect(LegacyIOSDocumentVisibleRect).size(); }
168 
169 #if USE(COORDINATED_GRAPHICS)
170     virtual void setFixedVisibleContentRect(const IntRect&amp; visibleContentRect) { m_fixedVisibleContentRect = visibleContentRect; }
171     IntRect fixedVisibleContentRect() const { return m_fixedVisibleContentRect; }
172 #endif
173 
174     // Parts of the document can be visible through transparent or blured UI widgets of the chrome. Those parts
175     // contribute to painting but not to the scrollable area.
176     // The unobscuredContentRect is the area that is not covered by UI elements.
177     WEBCORE_EXPORT IntRect unobscuredContentRect(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
178 
179 #if PLATFORM(IOS_FAMILY)
180     IntRect unobscuredContentRectIncludingScrollbars() const { return unobscuredContentRect(IncludeScrollbars); }
181 #else
182     IntRect unobscuredContentRectIncludingScrollbars() const { return visibleContentRectIncludingScrollbars(); }
183 #endif
184 
185     // This is the area that is partially or fully exposed, and may extend under overlapping UI elements.
186     WEBCORE_EXPORT FloatRect exposedContentRect() const;
187 
188     // The given rects are only used if there is no platform widget.
189     WEBCORE_EXPORT void setExposedContentRect(const FloatRect&amp;);
190 
191     WEBCORE_EXPORT FloatSize unobscuredContentSize() const;
192     WEBCORE_EXPORT void setUnobscuredContentSize(const FloatSize&amp;);
193 
194 #if PLATFORM(IOS_FAMILY)
195     void setActualScrollPosition(const IntPoint&amp;);
196     LegacyTileCache* legacyTileCache();
197 #endif
198 
199     // Size available for view contents, including content inset areas. Not affected by zooming.
200     IntSize sizeForVisibleContent(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
201     // FIXME: remove this. It&#39;s only used for the incorrectly behaving ScrollView::unobscuredContentRectInternal().
202     virtual float visibleContentScaleFactor() const { return 1; }
203 
204     // Functions for getting/setting the size webkit should use to layout the contents. By default this is the same as the visible
205     // content size. Explicitly setting a layout size value will cause webkit to layout the contents using this size instead.
206     WEBCORE_EXPORT IntSize layoutSize() const;
207     int layoutWidth() const { return layoutSize().width(); }
208     int layoutHeight() const { return layoutSize().height(); }
209 
210     WEBCORE_EXPORT IntSize fixedLayoutSize() const;
211     WEBCORE_EXPORT void setFixedLayoutSize(const IntSize&amp;);
212     WEBCORE_EXPORT bool useFixedLayout() const;
213     WEBCORE_EXPORT void setUseFixedLayout(bool enable);
214 
215     // Functions for getting/setting the size of the document contained inside the ScrollView (as an IntSize or as individual width and height
216     // values).
217     WEBCORE_EXPORT IntSize contentsSize() const final; // Always at least as big as the visibleWidth()/visibleHeight().
218     int contentsWidth() const { return contentsSize().width(); }
219     int contentsHeight() const { return contentsSize().height(); }
220     virtual void setContentsSize(const IntSize&amp;);
221 
222     // Functions for querying the current scrolled position (both as a point, a size, or as individual X and Y values).
223     ScrollPosition scrollPosition() const final { return visibleContentRect(LegacyIOSDocumentVisibleRect).location(); }
224 
225     ScrollPosition maximumScrollPosition() const override; // The maximum position we can be scrolled to.
226 
227     // Adjust the passed in scroll position to keep it between the minimum and maximum positions.
228     ScrollPosition adjustScrollPositionWithinRange(const ScrollPosition&amp;) const;
229     int scrollX() const { return scrollPosition().x(); }
230     int scrollY() const { return scrollPosition().y(); }
231 
232     // Scroll position used by web-exposed features (has legacy iOS behavior).
233     WEBCORE_EXPORT IntPoint contentsScrollPosition() const;
234     void setContentsScrollPosition(const IntPoint&amp;, ScrollClamping = ScrollClamping::Clamped);
235 
236 #if PLATFORM(IOS_FAMILY)
237     int actualScrollX() const { return unobscuredContentRect().x(); }
238     int actualScrollY() const { return unobscuredContentRect().y(); }
239     // FIXME: maybe fix scrollPosition() on iOS to return the actual scroll position.
240     IntPoint actualScrollPosition() const { return unobscuredContentRect().location(); }
241 #endif
242 
243     // scrollOffset() anchors its (0,0) point at the ScrollableArea&#39;s origin. When the Page has a
244     // header, the header is positioned at (0,0), ABOVE the start of the Document. So when a page with
245     // a header is pinned to the top, the scrollOffset() is (0,0), but the Document is actually at
246     // (0, -headerHeight()). documentScrollPositionRelativeToScrollableAreaOrigin() will return this
247     // version of the offset, which tracks the top of Document relative to where scrolling was achored.
248     ScrollPosition documentScrollPositionRelativeToScrollableAreaOrigin() const;
249 
250     // scrollPostion() anchors its (0,0) point at the ScrollableArea&#39;s origin. The top of the scrolling
251     // layer does not represent the top of the view when there is a topContentInset. Additionally, as
252     // detailed above, the origin of the scrolling layer also does not necessarily correspond with the
253     // top of the document anyway, since there could also be header. documentScrollPositionRelativeToViewOrigin()
254     // will return a version of the current scroll offset which tracks the top of the Document
255     // relative to the very top of the view.
256     WEBCORE_EXPORT ScrollPosition documentScrollPositionRelativeToViewOrigin() const;
257 
258     IntSize overhangAmount() const final;
259 
260     void cacheCurrentScrollPosition() { m_cachedScrollPosition = scrollPosition(); }
261     ScrollPosition cachedScrollPosition() const { return m_cachedScrollPosition; }
262 
263     // Functions for scrolling the view.
264     virtual void setScrollPosition(const ScrollPosition&amp;, ScrollClamping = ScrollClamping::Clamped);
265     void scrollBy(const IntSize&amp; s) { return setScrollPosition(scrollPosition() + s); }
266 
267     // This function scrolls by lines, pages or pixels.
268     bool scroll(ScrollDirection, ScrollGranularity);
269 
270     // A logical scroll that just ends up calling the corresponding physical scroll() based off the document&#39;s writing mode.
271     bool logicalScroll(ScrollLogicalDirection, ScrollGranularity);
272 
273     // Scroll the actual contents of the view (either blitting or invalidating as needed).
274     void scrollContents(const IntSize&amp; scrollDelta);
275 
276     // This gives us a means of blocking painting on our scrollbars until the first layout has occurred.
277     WEBCORE_EXPORT void setScrollbarsSuppressed(bool suppressed, bool repaintOnUnsuppress = false);
278     bool scrollbarsSuppressed() const { return m_scrollbarsSuppressed; }
279 
280     WEBCORE_EXPORT IntPoint rootViewToContents(const IntPoint&amp;) const;
281     WEBCORE_EXPORT IntPoint contentsToRootView(const IntPoint&amp;) const;
282     WEBCORE_EXPORT FloatPoint contentsToRootView(const FloatPoint&amp;) const;
283     WEBCORE_EXPORT IntRect rootViewToContents(const IntRect&amp;) const;
284     WEBCORE_EXPORT IntRect contentsToRootView(const IntRect&amp;) const;
285     WEBCORE_EXPORT FloatRect rootViewToContents(const FloatRect&amp;) const;
286     WEBCORE_EXPORT FloatRect contentsToRootView(const FloatRect&amp;) const;
287 
288     IntPoint viewToContents(const IntPoint&amp;) const;
289     IntPoint contentsToView(const IntPoint&amp;) const;
290 
291     FloatPoint viewToContents(const FloatPoint&amp;) const;
292     FloatPoint contentsToView(const FloatPoint&amp;) const;
293 
294     IntRect viewToContents(IntRect) const;
295     IntRect contentsToView(IntRect) const;
296 
297     FloatRect viewToContents(FloatRect) const;
298     FloatRect contentsToView(FloatRect) const;
299 
300     IntPoint contentsToContainingViewContents(const IntPoint&amp;) const;
301     IntRect contentsToContainingViewContents(IntRect) const;
302 
303     WEBCORE_EXPORT IntPoint rootViewToTotalContents(const IntPoint&amp;) const;
304 
305     // Event coordinates are assumed to be in the coordinate space of a window that contains
306     // the entire widget hierarchy. It is up to the platform to decide what the precise definition
307     // of containing window is. (For example on Mac it is the containing NSWindow.)
308     WEBCORE_EXPORT IntPoint windowToContents(const IntPoint&amp;) const;
309     WEBCORE_EXPORT IntPoint contentsToWindow(const IntPoint&amp;) const;
310     WEBCORE_EXPORT IntRect windowToContents(const IntRect&amp;) const;
311     WEBCORE_EXPORT IntRect contentsToWindow(const IntRect&amp;) const;
312 
313     // Functions for converting to and from screen coordinates.
314     WEBCORE_EXPORT IntRect contentsToScreen(const IntRect&amp;) const;
315     IntPoint screenToContents(const IntPoint&amp;) const;
316 
317     // The purpose of this function is to answer whether or not the scroll view is currently visible. Animations and painting updates can be suspended if
318     // we know that we are either not in a window right now or if that window is not visible.
319     bool isOffscreen() const;
320 
321     // Called when our frame rect changes (or the rect/scroll position of an ancestor changes).
322     void frameRectsChanged() final;
323 
324     // Widget override to update our scrollbars and notify our contents of the resize.
325     void setFrameRect(const IntRect&amp;) override;
326 
327     // Widget override to notify our contents of a cliprect change.
328     void clipRectChanged() final;
329 
330     // For platforms that need to hit test scrollbars from within the engine&#39;s event handlers (like Win32).
331     Scrollbar* scrollbarAtPoint(const IntPoint&amp; windowPoint);
332 
333     IntPoint convertChildToSelf(const Widget* child, const IntPoint&amp; point) const
334     {
335         IntPoint newPoint = point;
336         if (!isScrollViewScrollbar(child))
337             newPoint = point - toIntSize(scrollPosition());
338         newPoint.moveBy(child-&gt;location());
339         return newPoint;
340     }
341 
342     IntPoint convertSelfToChild(const Widget* child, const IntPoint&amp; point) const
343     {
344         IntPoint newPoint = point;
345         if (!isScrollViewScrollbar(child))
346             newPoint = point + toIntSize(scrollPosition());
347         newPoint.moveBy(-child-&gt;location());
348         return newPoint;
349     }
350 
351     // Widget override. Handles painting of the contents of the view as well as the scrollbars.
352     WEBCORE_EXPORT void paint(GraphicsContext&amp;, const IntRect&amp;, Widget::SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin) final;
353     void paintScrollbars(GraphicsContext&amp;, const IntRect&amp;);
354 
355     // Widget overrides to ensure that our children&#39;s visibility status is kept up to date when we get shown and hidden.
356     WEBCORE_EXPORT void show() override;
357     WEBCORE_EXPORT void hide() override;
358     WEBCORE_EXPORT void setParentVisible(bool) final;
359 
360     // Pan scrolling.
361     static const int noPanScrollRadius = 15;
362     void addPanScrollIcon(const IntPoint&amp;);
363     void removePanScrollIcon();
364     void paintPanScrollIcon(GraphicsContext&amp;);
365 
366     bool isPointInScrollbarCorner(const IntPoint&amp;);
367     bool scrollbarCornerPresent() const;
368     IntRect scrollCornerRect() const final;
369     virtual void paintScrollCorner(GraphicsContext&amp;, const IntRect&amp; cornerRect);
370     virtual void paintScrollbar(GraphicsContext&amp;, Scrollbar&amp;, const IntRect&amp;);
371 
372     IntRect convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntRect&amp;) const final;
373     IntRect convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntRect&amp;) const final;
374     IntPoint convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntPoint&amp;) const final;
375     IntPoint convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntPoint&amp;) const final;
376 
377     void calculateAndPaintOverhangAreas(GraphicsContext&amp;, const IntRect&amp; dirtyRect);
378 
379     WEBCORE_EXPORT void scrollOffsetChangedViaPlatformWidget(const ScrollOffset&amp; oldOffset, const ScrollOffset&amp; newOffset);
380 
381     void setAllowsUnclampedScrollPositionForTesting(bool allowsUnclampedScrollPosition) { m_allowsUnclampedScrollPosition = allowsUnclampedScrollPosition; }
382     bool allowsUnclampedScrollPosition() const { return m_allowsUnclampedScrollPosition; }
383 
384     bool managesScrollbars() const;
385 
386 protected:
387     ScrollView();
388 
389     virtual void repaintContentRectangle(const IntRect&amp;);
390     virtual void paintContents(GraphicsContext&amp;, const IntRect&amp; damageRect, SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin) = 0;
391 
392     virtual void paintOverhangAreas(GraphicsContext&amp;, const IntRect&amp; horizontalOverhangArea, const IntRect&amp; verticalOverhangArea, const IntRect&amp; dirtyRect);
393 
394     void availableContentSizeChanged(AvailableSizeChangeReason) override;
395     virtual void addedOrRemovedScrollbar() = 0;
396     virtual void delegatesScrollingDidChange() = 0;
397 
398     // These functions are used to create/destroy scrollbars.
399     // They return true if the scrollbar was added or removed.
400     bool setHasHorizontalScrollbar(bool, bool* contentSizeAffected = nullptr);
401     bool setHasVerticalScrollbar(bool, bool* contentSizeAffected = nullptr);
402 
403     virtual void updateScrollCorner() = 0;
404     void invalidateScrollCornerRect(const IntRect&amp;) final;
405 
406     // Scroll the content by blitting the pixels.
407     virtual bool scrollContentsFastPath(const IntSize&amp; scrollDelta, const IntRect&amp; rectToScroll, const IntRect&amp; clipRect) = 0;
408     // Scroll the content by invalidating everything.
409     virtual void scrollContentsSlowPath(const IntRect&amp; updateRect);
410 
411     void setScrollOrigin(const IntPoint&amp;, bool updatePositionAtAll, bool updatePositionSynchronously);
412 
413     // Subclassed by FrameView to check the writing-mode of the document.
414     virtual bool isVerticalDocument() const = 0;
415     virtual bool isFlippedDocument() const = 0;
416 
417     // Called to update the scrollbars to accurately reflect the state of the view.
418     void updateScrollbars(const ScrollPosition&amp; desiredPosition);
419 
420     float platformTopContentInset() const;
421     void platformSetTopContentInset(float);
422 
423     void handleDeferredScrollUpdateAfterContentSizeChange();
424 
425     virtual bool shouldDeferScrollUpdateAfterContentSizeChange() = 0;
426 
427     virtual void scrollOffsetChangedViaPlatformWidgetImpl(const ScrollOffset&amp;, const ScrollOffset&amp;) = 0;
428 
429     virtual void unobscuredContentSizeChanged() = 0;
430 
431 #if PLATFORM(COCOA) &amp;&amp; defined __OBJC__
432 public:
433     WEBCORE_EXPORT NSView* documentView() const;
434 
435 private:
436     NSScrollView&lt;WebCoreFrameScrollView&gt;* scrollView() const;
437 #endif
438 
439 private:
440     // Size available for view contents, excluding content insets. Not affected by zooming.
441     IntSize sizeForUnobscuredContent(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
442 
443     IntRect visibleContentRectInternal(VisibleContentRectIncludesScrollbars, VisibleContentRectBehavior) const final;
444     WEBCORE_EXPORT IntRect unobscuredContentRectInternal(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
445 
446     void completeUpdatesAfterScrollTo(const IntSize&amp; scrollDelta);
447 
448     bool setHasScrollbarInternal(RefPtr&lt;Scrollbar&gt;&amp;, ScrollbarOrientation, bool hasBar, bool* contentSizeAffected);
449 
450     bool isScrollView() const final { return true; }
451 
452     void init();
453     void destroy();
454 
455     IntRect rectToCopyOnScroll() const;
456 
457     // Called when the scroll position within this view changes. FrameView overrides this to generate repaint invalidations.
458     virtual void updateLayerPositionsAfterScrolling() = 0;
459     virtual void updateCompositingLayersAfterScrolling() = 0;
460 
461     void platformAddChild(Widget*);
462     void platformRemoveChild(Widget*);
463     void platformSetScrollbarModes();
464     void platformScrollbarModes(ScrollbarMode&amp; horizontal, ScrollbarMode&amp; vertical) const;
465     void platformSetCanBlitOnScroll(bool);
466     bool platformCanBlitOnScroll() const;
467 
468     IntRect platformVisibleContentRect(bool includeScrollbars) const;
469     IntSize platformVisibleContentSize(bool includeScrollbars) const;
470     IntRect platformVisibleContentRectIncludingObscuredArea(bool includeScrollbars) const;
471     IntSize platformVisibleContentSizeIncludingObscuredArea(bool includeScrollbars) const;
472 
473     IntRect platformUnobscuredContentRect(VisibleContentRectIncludesScrollbars) const;
474     FloatRect platformExposedContentRect() const;
475 
476     void platformSetContentsSize();
477 
478     IntRect platformContentsToScreen(const IntRect&amp;) const;
479     IntPoint platformScreenToContents(const IntPoint&amp;) const;
480 
481     void platformSetScrollPosition(const IntPoint&amp;);
482     bool platformScroll(ScrollDirection, ScrollGranularity);
483     void platformSetScrollbarsSuppressed(bool repaintOnUnsuppress);
484     void platformRepaintContentRectangle(const IntRect&amp;);
485     bool platformIsOffscreen() const;
486     void platformSetScrollbarOverlayStyle(ScrollbarOverlayStyle);
487     void platformSetScrollOrigin(const IntPoint&amp;, bool updatePositionAtAll, bool updatePositionSynchronously);
488 
489     void calculateOverhangAreasForPainting(IntRect&amp; horizontalOverhangRect, IntRect&amp; verticalOverhangRect);
490     void updateOverhangAreas();
491 
492     HashSet&lt;Ref&lt;Widget&gt;&gt; m_children;
493 
494     RefPtr&lt;Scrollbar&gt; m_horizontalScrollbar;
495     RefPtr&lt;Scrollbar&gt; m_verticalScrollbar;
496     ScrollbarMode m_horizontalScrollbarMode { ScrollbarAuto };
497     ScrollbarMode m_verticalScrollbarMode { ScrollbarAuto };
498 
499 
500     // FIXME: More things will move into here.
501     struct DelegatedScrollingGeometry {
502         FloatSize unobscuredContentSize;
503         FloatRect exposedContentRect;
504     };
505     Optional&lt;DelegatedScrollingGeometry&gt; m_delegatedScrollingGeometry;
506 
507 #if USE(COORDINATED_GRAPHICS)
508     // FIXME: exposedContentRect is a very similar concept to fixedVisibleContentRect except it does not differentiate
509     // between exposed and unobscured areas. The two attributes should eventually be merged.
510     IntRect m_fixedVisibleContentRect;
511 #endif
512     ScrollPosition m_scrollPosition;
513     IntPoint m_cachedScrollPosition;
514     IntSize m_fixedLayoutSize;
515     IntSize m_contentsSize;
516 
517     Optional&lt;IntSize&gt; m_deferredScrollDelta; // Needed for WebKit scrolling
518     Optional&lt;std::pair&lt;ScrollOffset, ScrollOffset&gt;&gt; m_deferredScrollOffsets; // Needed for platform widget scrolling
519 
520     IntPoint m_panScrollIconPoint;
521 
522     unsigned m_updateScrollbarsPass { 0 };
523 
524     bool m_horizontalScrollbarLock { false };
525     bool m_verticalScrollbarLock { false };
526 
527     bool m_prohibitsScrolling { false };
528     bool m_allowsUnclampedScrollPosition { false };
529 
530     // This bool is unused on Mac OS because we directly ask the platform widget
531     // whether it is safe to blit on scroll.
532     bool m_canBlitOnScroll { true };
533 
534     bool m_scrollbarsSuppressed { false };
535     bool m_inUpdateScrollbars { false };
536 
537     bool m_drawPanScrollIcon { false };
538     bool m_useFixedLayout { false };
539 
540     bool m_paintsEntireContents { false };
541     bool m_delegatesScrolling { false };
542 
543 }; // class ScrollView
544 
545 } // namespace WebCore
546 
547 SPECIALIZE_TYPE_TRAITS_WIDGET(ScrollView, isScrollView())
    </pre>
  </body>
</html>
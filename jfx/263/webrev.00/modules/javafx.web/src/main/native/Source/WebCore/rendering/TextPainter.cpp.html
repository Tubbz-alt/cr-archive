<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/TextPainter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * (C) 1999 Lars Knoll (knoll@kde.org)
  3  * (C) 2000 Dirk Mueller (mueller@kde.org)
  4  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;TextPainter.h&quot;
 25 
 26 #include &quot;DisplayListReplayer.h&quot;
 27 #include &quot;DisplayRun.h&quot;
 28 #include &quot;FilterOperations.h&quot;
 29 #include &quot;GraphicsContext.h&quot;
 30 #include &quot;InlineTextBox.h&quot;
 31 #include &quot;RenderCombineText.h&quot;
 32 #include &quot;RenderLayer.h&quot;
 33 #include &quot;RuntimeEnabledFeatures.h&quot;
 34 #include &quot;ShadowData.h&quot;
 35 #include &lt;wtf/NeverDestroyed.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 ShadowApplier::ShadowApplier(GraphicsContext&amp; context, const ShadowData* shadow, const FilterOperations* colorFilter, const FloatRect&amp; textRect, bool lastShadowIterationShouldDrawText, bool opaque, FontOrientation orientation)
 40     : m_context { context }
 41     , m_shadow { shadow }
 42     , m_onlyDrawsShadow { !isLastShadowIteration() || !lastShadowIterationShouldDrawText }
 43     , m_avoidDrawingShadow { shadowIsCompletelyCoveredByText(opaque) }
 44     , m_nothingToDraw { shadow &amp;&amp; m_avoidDrawingShadow &amp;&amp; m_onlyDrawsShadow }
 45     , m_didSaveContext { false }
 46 {
 47     if (!shadow || m_nothingToDraw) {
 48         m_shadow = nullptr;
 49         return;
 50     }
 51 
 52     int shadowX = orientation == FontOrientation::Horizontal ? shadow-&gt;x() : shadow-&gt;y();
 53     int shadowY = orientation == FontOrientation::Horizontal ? shadow-&gt;y() : -shadow-&gt;x();
 54     FloatSize shadowOffset(shadowX, shadowY);
 55     int shadowRadius = shadow-&gt;radius();
 56     Color shadowColor = shadow-&gt;color();
 57     if (colorFilter)
 58         colorFilter-&gt;transformColor(shadowColor);
 59 
 60     // When drawing shadows, we usually clip the context to the area the shadow will reside, and then
 61     // draw the text itself outside the clipped area (so only the shadow shows up). However, we can
 62     // often draw the *last* shadow and the text itself in a single call.
 63     if (m_onlyDrawsShadow) {
 64         FloatRect shadowRect(textRect);
 65         shadowRect.inflate(shadow-&gt;paintingExtent() + 3 * textRect.height());
 66         shadowRect.move(shadowOffset);
 67         context.save();
 68         context.clip(shadowRect);
 69 
 70         m_didSaveContext = true;
 71         m_extraOffset = FloatSize(0, 2 * shadowRect.height() + std::max(0.0f, shadowOffset.height()) + shadowRadius);
 72         shadowOffset -= m_extraOffset;
 73     }
 74 
 75     if (!m_avoidDrawingShadow)
 76         context.setShadow(shadowOffset, shadowRadius, shadowColor);
 77 }
 78 
 79 inline bool ShadowApplier::isLastShadowIteration()
 80 {
 81     return m_shadow &amp;&amp; !m_shadow-&gt;next();
 82 }
 83 
 84 inline bool ShadowApplier::shadowIsCompletelyCoveredByText(bool textIsOpaque)
 85 {
 86     return textIsOpaque &amp;&amp; m_shadow &amp;&amp; m_shadow-&gt;location().isZero() &amp;&amp; !m_shadow-&gt;radius();
 87 }
 88 
 89 ShadowApplier::~ShadowApplier()
 90 {
 91     if (!m_shadow)
 92         return;
 93     if (m_onlyDrawsShadow)
 94         m_context.restore();
 95     else if (!m_avoidDrawingShadow)
 96         m_context.clearShadow();
 97 }
 98 
 99 TextPainter::TextPainter(GraphicsContext&amp; context)
100     : m_context(context)
101 {
102 }
103 
104 void TextPainter::paintTextOrEmphasisMarks(const FontCascade&amp; font, const TextRun&amp; textRun, const AtomString&amp; emphasisMark,
105     float emphasisMarkOffset, const FloatPoint&amp; textOrigin, unsigned startOffset, unsigned endOffset)
106 {
107     ASSERT(startOffset &lt; endOffset);
108     if (!emphasisMark.isEmpty())
109         m_context.drawEmphasisMarks(font, textRun, emphasisMark, textOrigin + FloatSize(0, emphasisMarkOffset), startOffset, endOffset);
110     else if (startOffset || endOffset &lt; textRun.length() || !m_glyphDisplayList)
111         m_context.drawText(font, textRun, textOrigin, startOffset, endOffset);
112     else {
113         // Replaying back a whole cached glyph run to the GraphicsContext.
114         m_context.translate(textOrigin);
115         DisplayList::Replayer replayer(m_context, *m_glyphDisplayList);
116         replayer.replay();
117         m_context.translate(-textOrigin);
118     }
119     m_glyphDisplayList = nullptr;
120 }
121 
122 void TextPainter::paintTextWithShadows(const ShadowData* shadow, const FilterOperations* colorFilter, const FontCascade&amp; font, const TextRun&amp; textRun, const FloatRect&amp; boxRect, const FloatPoint&amp; textOrigin,
123     unsigned startOffset, unsigned endOffset, const AtomString&amp; emphasisMark, float emphasisMarkOffset, bool stroked)
124 {
125     if (!shadow) {
126         paintTextOrEmphasisMarks(font, textRun, emphasisMark, emphasisMarkOffset, textOrigin, startOffset, endOffset);
127         return;
128     }
129 
130     Color fillColor = m_context.fillColor();
131     bool opaque = fillColor.isOpaque();
132     bool lastShadowIterationShouldDrawText = !stroked &amp;&amp; opaque;
133     if (!opaque)
134         m_context.setFillColor(Color::black);
135     while (shadow) {
136         ShadowApplier shadowApplier(m_context, shadow, colorFilter, boxRect, lastShadowIterationShouldDrawText, opaque, m_textBoxIsHorizontal ? FontOrientation::Horizontal : FontOrientation::Vertical);
137         if (!shadowApplier.nothingToDraw())
138             paintTextOrEmphasisMarks(font, textRun, emphasisMark, emphasisMarkOffset, textOrigin + shadowApplier.extraOffset(), startOffset, endOffset);
139         shadow = shadow-&gt;next();
140     }
141 
142     if (!lastShadowIterationShouldDrawText) {
143         if (!opaque)
144             m_context.setFillColor(fillColor);
145         paintTextOrEmphasisMarks(font, textRun, emphasisMark, emphasisMarkOffset, textOrigin, startOffset, endOffset);
146     }
147 }
148 
149 void TextPainter::paintTextAndEmphasisMarksIfNeeded(const TextRun&amp; textRun, const FloatRect&amp; boxRect, const FloatPoint&amp; textOrigin, unsigned startOffset, unsigned endOffset,
150     const TextPaintStyle&amp; paintStyle, const ShadowData* shadow, const FilterOperations* shadowColorFilter)
151 {
152     if (paintStyle.paintOrder == PaintOrder::Normal) {
153         // FIXME: Truncate right-to-left text correctly.
154         paintTextWithShadows(shadow, shadowColorFilter, *m_font, textRun, boxRect, textOrigin, startOffset, endOffset, nullAtom(), 0, paintStyle.strokeWidth &gt; 0);
155     } else {
156         auto textDrawingMode = m_context.textDrawingMode();
157         auto paintOrder = RenderStyle::paintTypesForPaintOrder(paintStyle.paintOrder);
158         auto shadowToUse = shadow;
159 
160         for (auto order : paintOrder) {
161             switch (order) {
162             case PaintType::Fill:
163                 m_context.setTextDrawingMode(textDrawingMode &amp; ~TextModeStroke);
164                 paintTextWithShadows(shadowToUse, shadowColorFilter, *m_font, textRun, boxRect, textOrigin, startOffset, endOffset, nullAtom(), 0, false);
165                 shadowToUse = nullptr;
166                 m_context.setTextDrawingMode(textDrawingMode);
167                 break;
168             case PaintType::Stroke:
169                 m_context.setTextDrawingMode(textDrawingMode &amp; ~TextModeFill);
170                 paintTextWithShadows(shadowToUse, shadowColorFilter, *m_font, textRun, boxRect, textOrigin, startOffset, endOffset, nullAtom(), 0, paintStyle.strokeWidth &gt; 0);
171                 shadowToUse = nullptr;
172                 m_context.setTextDrawingMode(textDrawingMode);
173                 break;
174             case PaintType::Markers:
175                 continue;
176             }
177         }
178     }
179 
180     if (m_emphasisMark.isEmpty())
181         return;
182 
183     FloatPoint boxOrigin = boxRect.location();
184     updateGraphicsContext(m_context, paintStyle, UseEmphasisMarkColor);
185     static NeverDestroyed&lt;TextRun&gt; objectReplacementCharacterTextRun(StringView(&amp;objectReplacementCharacter, 1));
186     const TextRun&amp; emphasisMarkTextRun = m_combinedText ? objectReplacementCharacterTextRun.get() : textRun;
187     FloatPoint emphasisMarkTextOrigin = m_combinedText ? FloatPoint(boxOrigin.x() + boxRect.width() / 2, boxOrigin.y() + m_font-&gt;fontMetrics().ascent()) : textOrigin;
188     if (m_combinedText)
189         m_context.concatCTM(rotation(boxRect, Clockwise));
190 
191     // FIXME: Truncate right-to-left text correctly.
192     paintTextWithShadows(shadow, shadowColorFilter, m_combinedText ? m_combinedText-&gt;originalFont() : *m_font, emphasisMarkTextRun, boxRect, emphasisMarkTextOrigin, startOffset, endOffset,
193         m_emphasisMark, m_emphasisMarkOffset, paintStyle.strokeWidth &gt; 0);
194 
195     if (m_combinedText)
196         m_context.concatCTM(rotation(boxRect, Counterclockwise));
197 }
198 
199 void TextPainter::paint(const TextRun&amp; textRun, const FloatRect&amp; boxRect, const FloatPoint&amp; textOrigin)
200 {
201     paintRange(textRun, boxRect, textOrigin, 0, textRun.length());
202 }
203 
204 void TextPainter::paintRange(const TextRun&amp; textRun, const FloatRect&amp; boxRect, const FloatPoint&amp; textOrigin, unsigned start, unsigned end)
205 {
206     ASSERT(m_font);
207     ASSERT(start &lt; end);
208 
209     GraphicsContextStateSaver stateSaver(m_context, m_style.strokeWidth &gt; 0);
210     updateGraphicsContext(m_context, m_style);
211     paintTextAndEmphasisMarksIfNeeded(textRun, boxRect, textOrigin, start, end, m_style, m_shadow, m_shadowColorFilter);
212 }
213 
214 void TextPainter::clearGlyphDisplayLists()
215 {
216     GlyphDisplayListCache&lt;InlineTextBox&gt;::singleton().clear();
217     GlyphDisplayListCache&lt;SimpleLineLayout::Run&gt;::singleton().clear();
218 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
219     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled())
220         GlyphDisplayListCache&lt;Display::Run&gt;::singleton().clear();
221 #endif
222 }
223 
224 bool TextPainter::shouldUseGlyphDisplayList(const PaintInfo&amp; paintInfo)
225 {
226     return !paintInfo.context().paintingDisabled() &amp;&amp; paintInfo.enclosingSelfPaintingLayer() &amp;&amp; paintInfo.enclosingSelfPaintingLayer()-&gt;paintingFrequently();
227 }
228 
229 } // namespace WebCore
    </pre>
  </body>
</html>
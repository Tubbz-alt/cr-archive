diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromiseDeferred.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromiseDeferred.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromiseDeferred.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromiseDeferred.cpp
@@ -31,215 +31,231 @@
 #include "JSDOMWindow.h"
 #include <JavaScriptCore/BuiltinNames.h>
 #include <JavaScriptCore/Exception.h>
 #include <JavaScriptCore/JSONObject.h>
 #include <JavaScriptCore/JSPromiseConstructor.h>
+#include <JavaScriptCore/Strong.h>
 
 namespace WebCore {
 using namespace JSC;
 
 JSC::JSValue DeferredPromise::promise() const
 {
     ASSERT(deferred());
-    return deferred()->promise();
+    return deferred();
 }
 
-void DeferredPromise::callFunction(ExecState& exec, JSValue function, JSValue resolution)
+void DeferredPromise::callFunction(JSGlobalObject& lexicalGlobalObject, ResolveMode mode, JSValue resolution)
 {
-    if (!canInvokeCallback())
+    if (shouldIgnoreRequestToFulfill())
         return;
 
-    VM& vm = exec.vm();
-    auto scope = DECLARE_THROW_SCOPE(vm);
+    if (activeDOMObjectsAreSuspended()) {
+        JSC::Strong<JSC::Unknown, ShouldStrongDestructorGrabLock::Yes> strongResolution(lexicalGlobalObject.vm(), resolution);
+        scriptExecutionContext()->eventLoop().queueTask(TaskSource::Networking, [this, protectedThis = makeRef(*this), mode, strongResolution = WTFMove(strongResolution)]() mutable {
+            if (shouldIgnoreRequestToFulfill())
+                return;
 
-    CallData callData;
-    CallType callType = getCallData(vm, function, callData);
-    ASSERT(callType != CallType::None);
-
-    MarkedArgumentBuffer arguments;
-    arguments.append(resolution);
-    ASSERT(!arguments.hasOverflowed());
-
-    call(&exec, function, callType, callData, jsUndefined(), arguments);
+            JSC::JSGlobalObject* lexicalGlobalObject = globalObject();
+            JSC::JSLockHolder locker(lexicalGlobalObject);
+            callFunction(*globalObject(), mode, strongResolution.get());
+        });
+        return;
+    }
 
-    // DeferredPromise should only be used by internal implementations that are well behaved.
-    // In practice, the only exception we should ever see here is the TerminatedExecutionException.
-    EXCEPTION_ASSERT_UNUSED(scope, !scope.exception() || isTerminatedExecutionException(vm, scope.exception()));
+    // FIXME: We could have error since any JS call can throw stack-overflow errors.
+    // https://bugs.webkit.org/show_bug.cgi?id=203402
+    switch (mode) {
+    case ResolveMode::Resolve:
+        deferred()->resolve(&lexicalGlobalObject, resolution);
+        break;
+    case ResolveMode::Reject:
+        deferred()->reject(&lexicalGlobalObject, resolution);
+        break;
+    }
 
     if (m_mode == Mode::ClearPromiseOnResolve)
         clear();
 }
 
-void DeferredPromise::whenSettled(std::function<void()>&& callback)
+void DeferredPromise::whenSettled(Function<void()>&& callback)
 {
-    DOMPromise::whenPromiseIsSettled(globalObject(), deferred()->promise(), WTFMove(callback));
+    if (shouldIgnoreRequestToFulfill())
+        return;
+
+    if (activeDOMObjectsAreSuspended()) {
+        scriptExecutionContext()->eventLoop().queueTask(TaskSource::Networking, [this, protectedThis = makeRef(*this), callback = WTFMove(callback)]() mutable {
+            whenSettled(WTFMove(callback));
+        });
+        return;
+    }
+
+    DOMPromise::whenPromiseIsSettled(globalObject(), deferred(), WTFMove(callback));
 }
 
 void DeferredPromise::reject()
 {
-    if (isSuspended())
+    if (shouldIgnoreRequestToFulfill())
         return;
 
     ASSERT(deferred());
     ASSERT(m_globalObject);
-    auto& state = *m_globalObject->globalExec();
-    JSC::JSLockHolder locker(&state);
-    reject(state, JSC::jsUndefined());
+    auto& lexicalGlobalObject = *m_globalObject;
+    JSC::JSLockHolder locker(&lexicalGlobalObject);
+    reject(lexicalGlobalObject, JSC::jsUndefined());
 }
 
 void DeferredPromise::reject(std::nullptr_t)
 {
-    if (isSuspended())
+    if (shouldIgnoreRequestToFulfill())
         return;
 
     ASSERT(deferred());
     ASSERT(m_globalObject);
-    auto& state = *m_globalObject->globalExec();
-    JSC::JSLockHolder locker(&state);
-    reject(state, JSC::jsNull());
+    auto& lexicalGlobalObject = *m_globalObject;
+    JSC::JSLockHolder locker(&lexicalGlobalObject);
+    reject(lexicalGlobalObject, JSC::jsNull());
 }
 
 void DeferredPromise::reject(Exception exception)
 {
-    if (isSuspended())
+    if (shouldIgnoreRequestToFulfill())
         return;
 
     ASSERT(deferred());
     ASSERT(m_globalObject);
-    auto& state = *m_globalObject->globalExec();
-    JSC::JSLockHolder locker(&state);
+    auto& lexicalGlobalObject = *m_globalObject;
+    JSC::JSLockHolder locker(&lexicalGlobalObject);
 
     if (exception.code() == ExistingExceptionError) {
-        auto scope = DECLARE_CATCH_SCOPE(state.vm());
+        auto scope = DECLARE_CATCH_SCOPE(lexicalGlobalObject.vm());
 
         EXCEPTION_ASSERT(scope.exception());
 
         auto error = scope.exception()->value();
         scope.clearException();
 
         reject<IDLAny>(error);
         return;
     }
 
-    auto scope = DECLARE_THROW_SCOPE(state.vm());
-    auto error = createDOMException(state, WTFMove(exception));
+    auto scope = DECLARE_THROW_SCOPE(lexicalGlobalObject.vm());
+    auto error = createDOMException(lexicalGlobalObject, WTFMove(exception));
     if (UNLIKELY(scope.exception())) {
-        ASSERT(isTerminatedExecutionException(state.vm(), scope.exception()));
+        ASSERT(isTerminatedExecutionException(lexicalGlobalObject.vm(), scope.exception()));
         return;
     }
 
-    reject(state, error);
+    reject(lexicalGlobalObject, error);
 }
 
 void DeferredPromise::reject(ExceptionCode ec, const String& message)
 {
-    if (isSuspended())
+    if (shouldIgnoreRequestToFulfill())
         return;
 
     ASSERT(deferred());
     ASSERT(m_globalObject);
-    auto& state = *m_globalObject->globalExec();
-    JSC::JSLockHolder locker(&state);
+    auto& lexicalGlobalObject = *m_globalObject;
+    JSC::JSLockHolder locker(&lexicalGlobalObject);
 
     if (ec == ExistingExceptionError) {
-        auto scope = DECLARE_CATCH_SCOPE(state.vm());
+        auto scope = DECLARE_CATCH_SCOPE(lexicalGlobalObject.vm());
 
         EXCEPTION_ASSERT(scope.exception());
 
         auto error = scope.exception()->value();
         scope.clearException();
 
         reject<IDLAny>(error);
         return;
     }
 
-    auto scope = DECLARE_THROW_SCOPE(state.vm());
-    auto error = createDOMException(&state, ec, message);
+    auto scope = DECLARE_THROW_SCOPE(lexicalGlobalObject.vm());
+    auto error = createDOMException(&lexicalGlobalObject, ec, message);
     if (UNLIKELY(scope.exception())) {
-        ASSERT(isTerminatedExecutionException(state.vm(), scope.exception()));
+        ASSERT(isTerminatedExecutionException(lexicalGlobalObject.vm(), scope.exception()));
         return;
     }
 
 
-    reject(state, error);
+    reject(lexicalGlobalObject, error);
 }
 
 void DeferredPromise::reject(const JSC::PrivateName& privateName)
 {
-    if (isSuspended())
+    if (shouldIgnoreRequestToFulfill())
         return;
 
     ASSERT(deferred());
     ASSERT(m_globalObject);
-    JSC::ExecState* state = m_globalObject->globalExec();
-    JSC::JSLockHolder locker(state);
-    reject(*state, JSC::Symbol::create(state->vm(), privateName.uid()));
+    JSC::JSGlobalObject* lexicalGlobalObject = m_globalObject.get();
+    JSC::JSLockHolder locker(lexicalGlobalObject);
+    reject(*lexicalGlobalObject, JSC::Symbol::create(lexicalGlobalObject->vm(), privateName.uid()));
 }
 
-void rejectPromiseWithExceptionIfAny(JSC::ExecState& state, JSDOMGlobalObject& globalObject, JSPromiseDeferred& promiseDeferred)
+void rejectPromiseWithExceptionIfAny(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, JSPromise& promise)
 {
-    VM& vm = state.vm();
+    VM& vm = lexicalGlobalObject.vm();
     auto scope = DECLARE_CATCH_SCOPE(vm);
 
     if (LIKELY(!scope.exception()))
         return;
 
     JSValue error = scope.exception()->value();
     scope.clearException();
 
-    DeferredPromise::create(globalObject, promiseDeferred)->reject<IDLAny>(error);
+    DeferredPromise::create(globalObject, promise)->reject<IDLAny>(error);
 }
 
-Ref<DeferredPromise> createDeferredPromise(JSC::ExecState& state, JSDOMWindow& domWindow)
+Ref<DeferredPromise> createDeferredPromise(JSC::JSGlobalObject&, JSDOMWindow& domWindow)
 {
-    JSC::JSPromiseDeferred* deferred = JSC::JSPromiseDeferred::tryCreate(&state, &domWindow);
-    // deferred can only be null in workers.
-    RELEASE_ASSERT(deferred);
-    return DeferredPromise::create(domWindow, *deferred);
+    auto* promise = JSPromise::create(domWindow.vm(), domWindow.promiseStructure());
+    RELEASE_ASSERT(promise);
+    return DeferredPromise::create(domWindow, *promise);
 }
 
-JSC::EncodedJSValue createRejectedPromiseWithTypeError(JSC::ExecState& state, const String& errorMessage, RejectedPromiseWithTypeErrorCause cause)
+JSC::EncodedJSValue createRejectedPromiseWithTypeError(JSC::JSGlobalObject& lexicalGlobalObject, const String& errorMessage, RejectedPromiseWithTypeErrorCause cause)
 {
-    ASSERT(state.lexicalGlobalObject());
-    auto& globalObject = *state.lexicalGlobalObject();
+    auto& globalObject = lexicalGlobalObject;
 
     auto promiseConstructor = globalObject.promiseConstructor();
-    auto rejectFunction = promiseConstructor->get(&state, state.vm().propertyNames->builtinNames().rejectPrivateName());
-    auto* rejectionValue = static_cast<ErrorInstance*>(createTypeError(&state, errorMessage));
+    auto rejectFunction = promiseConstructor->get(&lexicalGlobalObject, lexicalGlobalObject.vm().propertyNames->builtinNames().rejectPrivateName());
+    auto* rejectionValue = static_cast<ErrorInstance*>(createTypeError(&lexicalGlobalObject, errorMessage));
     if (cause == RejectedPromiseWithTypeErrorCause::NativeGetter)
         rejectionValue->setNativeGetterTypeError();
 
     CallData callData;
-    auto callType = getCallData(state.vm(), rejectFunction, callData);
+    auto callType = getCallData(lexicalGlobalObject.vm(), rejectFunction, callData);
     ASSERT(callType != CallType::None);
 
     MarkedArgumentBuffer arguments;
     arguments.append(rejectionValue);
     ASSERT(!arguments.hasOverflowed());
 
-    return JSValue::encode(call(&state, rejectFunction, callType, callData, promiseConstructor, arguments));
+    return JSValue::encode(call(&lexicalGlobalObject, rejectFunction, callType, callData, promiseConstructor, arguments));
 }
 
-static inline JSC::JSValue parseAsJSON(JSC::ExecState* state, const String& data)
+static inline JSC::JSValue parseAsJSON(JSC::JSGlobalObject* lexicalGlobalObject, const String& data)
 {
-    JSC::JSLockHolder lock(state);
-    return JSC::JSONParse(state, data);
+    JSC::JSLockHolder lock(lexicalGlobalObject);
+    return JSC::JSONParse(lexicalGlobalObject, data);
 }
 
 void fulfillPromiseWithJSON(Ref<DeferredPromise>&& promise, const String& data)
 {
-    JSC::JSValue value = parseAsJSON(promise->globalObject()->globalExec(), data);
+    JSC::JSValue value = parseAsJSON(promise->globalObject(), data);
     if (!value)
         promise->reject(SyntaxError);
     else
         promise->resolve<IDLAny>(value);
 }
 
 void fulfillPromiseWithArrayBuffer(Ref<DeferredPromise>&& promise, ArrayBuffer* arrayBuffer)
 {
     if (!arrayBuffer) {
-        promise->reject<IDLAny>(createOutOfMemoryError(promise->globalObject()->globalExec()));
+        promise->reject<IDLAny>(createOutOfMemoryError(promise->globalObject()));
         return;
     }
     promise->resolve<IDLInterface<ArrayBuffer>>(*arrayBuffer);
 }
 

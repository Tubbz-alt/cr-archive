<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptExecutionContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008-2017 Apple Inc. All Rights Reserved.
  3  * Copyright (C) 2012 Google Inc. All Rights Reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  *
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;ActiveDOMObject.h&quot;
 31 #include &quot;DOMTimer.h&quot;
 32 #include &quot;SecurityContext.h&quot;
 33 #include &quot;ServiceWorkerTypes.h&quot;
 34 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 35 #include &lt;JavaScriptCore/HandleTypes.h&gt;
 36 #include &lt;wtf/CrossThreadTask.h&gt;
 37 #include &lt;wtf/Function.h&gt;
 38 #include &lt;wtf/HashSet.h&gt;
 39 #include &lt;wtf/ObjectIdentifier.h&gt;
 40 #include &lt;wtf/text/WTFString.h&gt;
 41 
 42 namespace JSC {
<a name="1" id="anc1"></a>
 43 class Exception;
<a name="2" id="anc2"></a><span class="line-removed"> 44 class ExecState;</span>
 45 class JSPromise;
 46 class VM;
<a name="3" id="anc3"></a><span class="line-removed"> 47 template&lt;typename&gt; class Strong;</span>
 48 }
 49 
 50 namespace Inspector {
 51 class ConsoleMessage;
 52 class ScriptCallStack;
 53 }
 54 
<a name="4" id="anc4"></a><span class="line-removed"> 55 namespace PAL {</span>
<span class="line-removed"> 56 class SessionID;</span>
<span class="line-removed"> 57 }</span>
<span class="line-removed"> 58 </span>
 59 namespace WebCore {
 60 
<a name="5" id="anc5"></a>
 61 class CachedScript;
 62 class DatabaseContext;
 63 class EventQueue;
<a name="6" id="anc6"></a>
 64 class EventTarget;
 65 class MessagePort;
 66 class PublicURLManager;
 67 class RejectedPromiseTracker;
 68 class ResourceRequest;
 69 class SecurityOrigin;
 70 class SocketProvider;
<a name="7" id="anc7"></a>

 71 
 72 #if ENABLE(SERVICE_WORKER)
 73 class ServiceWorker;
 74 class ServiceWorkerContainer;
 75 #endif
 76 
 77 namespace IDBClient {
 78 class IDBConnectionProxy;
 79 }
 80 
 81 enum ScriptExecutionContextIdentifierType { };
 82 using ScriptExecutionContextIdentifier = ObjectIdentifier&lt;ScriptExecutionContextIdentifierType&gt;;
 83 
 84 class ScriptExecutionContext : public SecurityContext {
 85 public:
 86     ScriptExecutionContext();
 87     virtual ~ScriptExecutionContext();
 88 
 89     virtual bool isDocument() const { return false; }
 90     virtual bool isWorkerGlobalScope() const { return false; }
 91     virtual bool isWorkletGlobalScope() const { return false; }
 92 
 93     virtual bool isContextThread() const { return true; }
 94     virtual bool isJSExecutionForbidden() const = 0;
 95 
<a name="8" id="anc8"></a>

 96     virtual const URL&amp; url() const = 0;
<a name="9" id="anc9"></a><span class="line-modified"> 97     virtual URL completeURL(const String&amp; url) const = 0;</span>
<span class="line-modified"> 98     virtual PAL::SessionID sessionID() const = 0;</span>
 99 
100     virtual String userAgent(const URL&amp;) const = 0;
101 
<a name="10" id="anc10"></a>

102     virtual void disableEval(const String&amp; errorMessage) = 0;
103     virtual void disableWebAssembly(const String&amp; errorMessage) = 0;
104 
105 #if ENABLE(INDEXED_DATABASE)
106     virtual IDBClient::IDBConnectionProxy* idbConnectionProxy() = 0;
107 #endif
108     virtual SocketProvider* socketProvider() = 0;
109 
110     virtual String resourceRequestIdentifier() const { return String(); };
111 
112     bool canIncludeErrorDetails(CachedScript*, const String&amp; sourceURL);
113     void reportException(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception*, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, CachedScript* = nullptr);
<a name="11" id="anc11"></a><span class="line-modified">114     void reportUnhandledPromiseRejection(JSC::ExecState&amp;, JSC::JSPromise&amp;, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;);</span>
115 
116     virtual void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) = 0;
117 
118     // The following addConsoleMessage functions are deprecated.
119     // Callers should try to create the ConsoleMessage themselves.
<a name="12" id="anc12"></a><span class="line-modified">120     void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, JSC::ExecState* = nullptr, unsigned long requestIdentifier = 0);</span>
121     virtual void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) = 0;
122 
123     virtual SecurityOrigin&amp; topOrigin() const = 0;
<a name="13" id="anc13"></a><span class="line-removed">124     virtual String origin() const = 0;</span>
125 
126     virtual bool shouldBypassMainWorldContentSecurityPolicy() const { return false; }
127 
128     PublicURLManager&amp; publicURLManager();
129 
<a name="14" id="anc14"></a><span class="line-removed">130     // Active objects are not garbage collected even if inaccessible, e.g. because their activity may result in callbacks being invoked.</span>
<span class="line-removed">131     WEBCORE_EXPORT bool canSuspendActiveDOMObjectsForDocumentSuspension(Vector&lt;ActiveDOMObject*&gt;* unsuspendableObjects = nullptr);</span>
<span class="line-removed">132 </span>
<span class="line-removed">133     // Active objects can be asked to suspend even if canSuspendActiveDOMObjectsForDocumentSuspension() returns &#39;false&#39; -</span>
<span class="line-removed">134     // step-by-step JS debugging is one example.</span>
135     virtual void suspendActiveDOMObjects(ReasonForSuspension);
136     virtual void resumeActiveDOMObjects(ReasonForSuspension);
137     virtual void stopActiveDOMObjects();
138 
139     bool activeDOMObjectsAreSuspended() const { return m_activeDOMObjectsAreSuspended; }
140     bool activeDOMObjectsAreStopped() const { return m_activeDOMObjectsAreStopped; }
141 
142     // Called from the constructor and destructors of ActiveDOMObject.
143     void didCreateActiveDOMObject(ActiveDOMObject&amp;);
144     void willDestroyActiveDOMObject(ActiveDOMObject&amp;);
145 
146     // Called after the construction of an ActiveDOMObject to synchronize suspend state.
147     void suspendActiveDOMObjectIfNeeded(ActiveDOMObject&amp;);
148 
149     void didCreateDestructionObserver(ContextDestructionObserver&amp;);
150     void willDestroyDestructionObserver(ContextDestructionObserver&amp;);
151 
152     // MessagePort is conceptually a kind of ActiveDOMObject, but it needs to be tracked separately for message dispatch.
153     void processMessageWithMessagePortsSoon();
154     void dispatchMessagePortEvents();
155     void createdMessagePort(MessagePort&amp;);
156     void destroyedMessagePort(MessagePort&amp;);
157 
158     virtual void didLoadResourceSynchronously();
159 
160     void ref() { refScriptExecutionContext(); }
161     void deref() { derefScriptExecutionContext(); }
162 
163     class Task {
164         WTF_MAKE_FAST_ALLOCATED;
165     public:
166         enum CleanupTaskTag { CleanupTask };
167 
168         template&lt;typename T, typename = typename std::enable_if&lt;!std::is_base_of&lt;Task, T&gt;::value &amp;&amp; std::is_convertible&lt;T, WTF::Function&lt;void (ScriptExecutionContext&amp;)&gt;&gt;::value&gt;::type&gt;
169         Task(T task)
170             : m_task(WTFMove(task))
171             , m_isCleanupTask(false)
172         {
173         }
174 
175         Task(WTF::Function&lt;void ()&gt;&amp;&amp; task)
176             : m_task([task = WTFMove(task)](ScriptExecutionContext&amp;) { task(); })
177             , m_isCleanupTask(false)
178         {
179         }
180 
181         template&lt;typename T, typename = typename std::enable_if&lt;std::is_convertible&lt;T, WTF::Function&lt;void (ScriptExecutionContext&amp;)&gt;&gt;::value&gt;::type&gt;
182         Task(CleanupTaskTag, T task)
183             : m_task(WTFMove(task))
184             , m_isCleanupTask(true)
185         {
186         }
187 
188         void performTask(ScriptExecutionContext&amp; context) { m_task(context); }
189         bool isCleanupTask() const { return m_isCleanupTask; }
190 
191     protected:
192         WTF::Function&lt;void (ScriptExecutionContext&amp;)&gt; m_task;
193         bool m_isCleanupTask;
194     };
195 
<a name="15" id="anc15"></a>
196     virtual void postTask(Task&amp;&amp;) = 0; // Executes the task on context&#39;s thread asynchronously.
197 
198     template&lt;typename... Arguments&gt;
199     void postCrossThreadTask(Arguments&amp;&amp;... arguments)
200     {
201         postTask([crossThreadTask = createCrossThreadTask(arguments...)](ScriptExecutionContext&amp;) mutable {
202             crossThreadTask.performTask();
203         });
204     }
205 
206     // Gets the next id in a circular sequence from 1 to 2^31-1.
207     int circularSequentialID();
208 
<a name="16" id="anc16"></a><span class="line-modified">209     bool addTimeout(int timeoutId, DOMTimer&amp; timer) { return m_timeouts.add(timeoutId, &amp;timer).isNewEntry; }</span>
210     void removeTimeout(int timeoutId) { m_timeouts.remove(timeoutId); }
211     DOMTimer* findTimeout(int timeoutId) { return m_timeouts.get(timeoutId); }
212 
213     WEBCORE_EXPORT JSC::VM&amp; vm();
214 
215     void adjustMinimumDOMTimerInterval(Seconds oldMinimumTimerInterval);
216     virtual Seconds minimumDOMTimerInterval() const;
217 
218     void didChangeTimerAlignmentInterval();
219     virtual Seconds domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const;
220 
<a name="17" id="anc17"></a><span class="line-removed">221     virtual EventQueue&amp; eventQueue() const = 0;</span>
222     virtual EventTarget* errorEventTarget() = 0;
223 
224     DatabaseContext* databaseContext() { return m_databaseContext.get(); }
225     void setDatabaseContext(DatabaseContext*);
226 
227 #if ENABLE(WEB_CRYPTO)
<a name="18" id="anc18"></a>


228     virtual bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) = 0;
229     virtual bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) = 0;
230 #endif
231 
232     int timerNestingLevel() const { return m_timerNestingLevel; }
233     void setTimerNestingLevel(int timerNestingLevel) { m_timerNestingLevel = timerNestingLevel; }
234 
235     RejectedPromiseTracker&amp; ensureRejectedPromiseTracker()
236     {
237         if (m_rejectedPromiseTracker)
238             return *m_rejectedPromiseTracker.get();
239         return ensureRejectedPromiseTrackerSlow();
240     }
241 
<a name="19" id="anc19"></a><span class="line-modified">242     WEBCORE_EXPORT JSC::ExecState* execState();</span>
243 
244     WEBCORE_EXPORT String domainForCachePartition() const;
245     void setDomainForCachePartition(String&amp;&amp; domain) { m_domainForCachePartition = WTFMove(domain); }
246 
247     bool allowsMediaDevices() const;
248     bool hasServiceWorkerScheme() const;
249 #if ENABLE(SERVICE_WORKER)
250     ServiceWorker* activeServiceWorker() const;
251     void setActiveServiceWorker(RefPtr&lt;ServiceWorker&gt;&amp;&amp;);
252 
253     void registerServiceWorker(ServiceWorker&amp;);
254     void unregisterServiceWorker(ServiceWorker&amp;);
255     ServiceWorker* serviceWorker(ServiceWorkerIdentifier identifier) { return m_serviceWorkers.get(identifier); }
256 
257     ServiceWorkerContainer* serviceWorkerContainer();
<a name="20" id="anc20"></a><span class="line-modified">258 </span>
<span class="line-removed">259     WEBCORE_EXPORT static bool postTaskTo(const DocumentOrWorkerIdentifier&amp;, WTF::Function&lt;void(ScriptExecutionContext&amp;)&gt;&amp;&amp;);</span>
260 #endif
261     WEBCORE_EXPORT static bool postTaskTo(ScriptExecutionContextIdentifier, Task&amp;&amp;);
262 
263     ScriptExecutionContextIdentifier contextIdentifier() const;
264 
265 protected:
266     class AddConsoleMessageTask : public Task {
267     public:
268         AddConsoleMessageTask(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
269             : Task([&amp;consoleMessage](ScriptExecutionContext&amp; context) {
270                 context.addConsoleMessage(WTFMove(consoleMessage));
271             })
272         {
273         }
274 
275         AddConsoleMessageTask(MessageSource source, MessageLevel level, const String&amp; message)
276             : Task([source, level, message = message.isolatedCopy()](ScriptExecutionContext&amp; context) {
277                 context.addConsoleMessage(source, level, message);
278             })
279         {
280         }
281     };
282 
283     ReasonForSuspension reasonForSuspendingActiveDOMObjects() const { return m_reasonForSuspendingActiveDOMObjects; }
284 
285     bool hasPendingActivity() const;
286     void removeFromContextsMap();
287     void removeRejectedPromiseTracker();
288 
289 private:
290     // The following addMessage function is deprecated.
291     // Callers should try to create the ConsoleMessage themselves.
<a name="21" id="anc21"></a><span class="line-modified">292     virtual void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::ExecState* = nullptr, unsigned long requestIdentifier = 0) = 0;</span>
293     virtual void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) = 0;
294     bool dispatchErrorEvent(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception*, CachedScript*);
295 
296     virtual void refScriptExecutionContext() = 0;
297     virtual void derefScriptExecutionContext() = 0;
298 
299     enum class ShouldContinue { No, Yes };
300     void forEachActiveDOMObject(const Function&lt;ShouldContinue(ActiveDOMObject&amp;)&gt;&amp;) const;
301 
302     RejectedPromiseTracker&amp; ensureRejectedPromiseTrackerSlow();
303 
304     void checkConsistency() const;
305 
306     HashSet&lt;MessagePort*&gt; m_messagePorts;
307     HashSet&lt;ContextDestructionObserver*&gt; m_destructionObservers;
308     HashSet&lt;ActiveDOMObject*&gt; m_activeDOMObjects;
309 
<a name="22" id="anc22"></a><span class="line-modified">310     HashMap&lt;int, RefPtr&lt;DOMTimer&gt;&gt; m_timeouts;</span>
311 
312     struct PendingException;
313     std::unique_ptr&lt;Vector&lt;std::unique_ptr&lt;PendingException&gt;&gt;&gt; m_pendingExceptions;
314     std::unique_ptr&lt;RejectedPromiseTracker&gt; m_rejectedPromiseTracker;
315 
316     ReasonForSuspension m_reasonForSuspendingActiveDOMObjects { static_cast&lt;ReasonForSuspension&gt;(-1) };
317 
318     std::unique_ptr&lt;PublicURLManager&gt; m_publicURLManager;
319 
320     RefPtr&lt;DatabaseContext&gt; m_databaseContext;
321 
322     int m_circularSequentialID { 0 };
323     int m_timerNestingLevel { 0 };
324 
325     bool m_activeDOMObjectsAreSuspended { false };
326     bool m_activeDOMObjectsAreStopped { false };
327     bool m_inDispatchErrorEvent { false };
328     mutable bool m_activeDOMObjectAdditionForbidden { false };
329     bool m_willprocessMessageWithMessagePortsSoon { false };
330 
<a name="23" id="anc23"></a><span class="line-modified">331 #if !ASSERT_DISABLED</span>
332     bool m_inScriptExecutionContextDestructor { false };
333 #endif
334 
335 #if ENABLE(SERVICE_WORKER)
336     RefPtr&lt;ServiceWorker&gt; m_activeServiceWorker;
337     HashMap&lt;ServiceWorkerIdentifier, ServiceWorker*&gt; m_serviceWorkers;
338 #endif
339 
340     String m_domainForCachePartition;
341     mutable ScriptExecutionContextIdentifier m_contextIdentifier;
342 };
343 
344 } // namespace WebCore
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineFlowBox.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineFlowBox.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineFlowBox.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineFlowBox.cpp
@@ -94,20 +94,20 @@
 
 void InlineFlowBox::addToLine(InlineBox* child)
 {
     ASSERT(!child->parent());
     ASSERT(!child->nextOnLine());
-    ASSERT(!child->prevOnLine());
+    ASSERT(!child->previousOnLine());
     checkConsistency();
 
     child->setParent(this);
     if (!m_firstChild) {
         m_firstChild = child;
         m_lastChild = child;
     } else {
         m_lastChild->setNextOnLine(child);
-        child->setPrevOnLine(m_lastChild);
+        child->setPreviousOnLine(m_lastChild);
         m_lastChild = child;
     }
     child->setIsFirstLine(isFirstLine());
     child->setIsHorizontal(isHorizontal());
     if (child->behavesLikeText()) {
@@ -193,15 +193,15 @@
     root().childRemoved(child);
 
     if (child == m_firstChild)
         m_firstChild = child->nextOnLine();
     if (child == m_lastChild)
-        m_lastChild = child->prevOnLine();
+        m_lastChild = child->previousOnLine();
     if (child->nextOnLine())
-        child->nextOnLine()->setPrevOnLine(child->prevOnLine());
-    if (child->prevOnLine())
-        child->prevOnLine()->setNextOnLine(child->nextOnLine());
+        child->nextOnLine()->setPreviousOnLine(child->previousOnLine());
+    if (child->previousOnLine())
+        child->previousOnLine()->setNextOnLine(child->nextOnLine());
 
     child->setParent(nullptr);
 
     checkConsistency();
 }
@@ -390,11 +390,11 @@
             auto& textBox = downcast<InlineTextBox>(*child);
             RenderText& renderText = textBox.renderer();
             if (renderText.text().length()) {
                 if (needsWordSpacing && isSpaceOrNewline(renderText.characterAt(textBox.start())))
                     logicalLeft += textBox.lineStyle().fontCascade().wordSpacing();
-                needsWordSpacing = !isSpaceOrNewline(renderText.characterAt(textBox.end()));
+                needsWordSpacing = !isSpaceOrNewline(renderText.characterAt(textBox.end() - 1));
             }
             textBox.setLogicalLeft(logicalLeft);
             if (knownToHaveNoOverflow())
                 minLogicalLeft = std::min(logicalLeft, minLogicalLeft);
             logicalLeft += textBox.logicalWidth();
@@ -1066,11 +1066,11 @@
         return false;
 
     // Check children first.
     // We need to account for culled inline parents of the hit-tested nodes, so that they may also get included in area-based hit-tests.
     RenderElement* culledParent = nullptr;
-    for (InlineBox* child = lastChild(); child; child = child->prevOnLine()) {
+    for (InlineBox* child = lastChild(); child; child = child->previousOnLine()) {
         if (is<RenderText>(child->renderer()) || !child->boxModelObject()->hasSelfPaintingLayer()) {
             RenderElement* newParent = nullptr;
             // Culled parents are only relevant for area-based hit-tests, so ignore it in point-based ones.
             if (locationInContainer.isRectBasedTest()) {
                 newParent = child->renderer().parent();
@@ -1365,19 +1365,19 @@
     LayoutPoint adjustedPaintoffset = paintOffset + localRect.location();
     GraphicsContext& context = paintInfo.context();
     LayoutRect paintRect = LayoutRect(adjustedPaintoffset, frameRect.size());
     // Shadow comes first and is behind the background and border.
     if (!renderer().boxShadowShouldBeAppliedToBackground(adjustedPaintoffset, BackgroundBleedNone, this))
-        paintBoxShadow(paintInfo, lineStyle, Normal, paintRect);
+        paintBoxShadow(paintInfo, lineStyle, ShadowStyle::Normal, paintRect);
 
     auto color = lineStyle.visitedDependentColor(CSSPropertyBackgroundColor);
     auto compositeOp = renderer().document().compositeOperatorForBackgroundColor(color, renderer());
 
     color = lineStyle.colorByApplyingColorFilter(color);
 
     paintFillLayers(paintInfo, color, lineStyle.backgroundLayers(), paintRect, compositeOp);
-    paintBoxShadow(paintInfo, lineStyle, Inset, paintRect);
+    paintBoxShadow(paintInfo, lineStyle, ShadowStyle::Inset, paintRect);
 
     // :first-line cannot be used to put borders on a line. Always paint borders with our
     // non-first-line style.
     if (!parent() || !renderer().style().hasVisibleBorderDecoration())
         return;
@@ -1436,20 +1436,20 @@
 
     // Figure out if we need to push a transparency layer to render our mask.
     bool pushTransparencyLayer = false;
     bool compositedMask = renderer().hasLayer() && renderer().layer()->hasCompositedMask();
     bool flattenCompositingLayers = renderer().view().frameView().paintBehavior().contains(PaintBehavior::FlattenCompositingLayers);
-    CompositeOperator compositeOp = CompositeSourceOver;
+    CompositeOperator compositeOp = CompositeOperator::SourceOver;
     if (!compositedMask || flattenCompositingLayers) {
         if ((maskBoxImage && renderer().style().maskLayers().hasImage()) || renderer().style().maskLayers().next())
             pushTransparencyLayer = true;
 
-        compositeOp = CompositeDestinationIn;
+        compositeOp = CompositeOperator::DestinationIn;
         if (pushTransparencyLayer) {
-            paintInfo.context().setCompositeOperation(CompositeDestinationIn);
+            paintInfo.context().setCompositeOperation(CompositeOperator::DestinationIn);
             paintInfo.context().beginTransparencyLayer(1.0f);
-            compositeOp = CompositeSourceOver;
+            compositeOp = CompositeOperator::SourceOver;
         }
     }
 
     LayoutRect paintRect = LayoutRect(adjustedPaintOffset, frameRect.size());
     paintFillLayers(paintInfo, Color(), renderer().style().maskLayers(), paintRect, compositeOp);
@@ -1487,23 +1487,23 @@
 
     if (pushTransparencyLayer)
         paintInfo.context().endTransparencyLayer();
 }
 
-InlineBox* InlineFlowBox::firstLeafChild() const
+InlineBox* InlineFlowBox::firstLeafDescendant() const
 {
     InlineBox* leaf = nullptr;
     for (InlineBox* child = firstChild(); child && !leaf; child = child->nextOnLine())
-        leaf = child->isLeaf() ? child : downcast<InlineFlowBox>(*child).firstLeafChild();
+        leaf = child->isLeaf() ? child : downcast<InlineFlowBox>(*child).firstLeafDescendant();
     return leaf;
 }
 
-InlineBox* InlineFlowBox::lastLeafChild() const
+InlineBox* InlineFlowBox::lastLeafDescendant() const
 {
     InlineBox* leaf = nullptr;
-    for (InlineBox* child = lastChild(); child && !leaf; child = child->prevOnLine())
-        leaf = child->isLeaf() ? child : downcast<InlineFlowBox>(*child).lastLeafChild();
+    for (InlineBox* child = lastChild(); child && !leaf; child = child->previousOnLine())
+        leaf = child->isLeaf() ? child : downcast<InlineFlowBox>(*child).lastLeafDescendant();
     return leaf;
 }
 
 RenderObject::SelectionState InlineFlowBox::selectionState()
 {
@@ -1541,11 +1541,11 @@
             visibleLeftEdge += box->logicalWidth();
             box = box->nextOnLine();
         }
         else {
             visibleRightEdge -= box->logicalWidth();
-            box = box->prevOnLine();
+            box = box->previousOnLine();
         }
     }
     return result;
 }
 
@@ -1651,19 +1651,19 @@
     return result;
 }
 
 void InlineFlowBox::collectLeafBoxesInLogicalOrder(Vector<InlineBox*>& leafBoxesInLogicalOrder, CustomInlineBoxRangeReverse customReverseImplementation, void* userData) const
 {
-    InlineBox* leaf = firstLeafChild();
+    InlineBox* leaf = firstLeafDescendant();
 
     // FIXME: The reordering code is a copy of parts from BidiResolver::createBidiRunsForLine, operating directly on InlineBoxes, instead of BidiRuns.
     // Investigate on how this code could possibly be shared.
     unsigned char minLevel = 128;
     unsigned char maxLevel = 0;
 
     // First find highest and lowest levels, and initialize leafBoxesInLogicalOrder with the leaf boxes in visual order.
-    for (; leaf; leaf = leaf->nextLeafChild()) {
+    for (; leaf; leaf = leaf->nextLeafOnLine()) {
         minLevel = std::min(minLevel, leaf->bidiLevel());
         maxLevel = std::max(maxLevel, leaf->bidiLevel());
         leafBoxesInLogicalOrder.append(leaf);
     }
 
@@ -1742,11 +1742,11 @@
     ASSERT_WITH_SECURITY_IMPLICATION(!m_hasBadChildList);
 #ifdef CHECK_CONSISTENCY
     const InlineBox* previousChild = nullptr;
     for (const InlineBox* child = firstChild(); child; child = child->nextOnLine()) {
         ASSERT(child->parent() == this);
-        ASSERT(child->prevOnLine() == previousChild);
+        ASSERT(child->previousOnLine() == previousChild);
         previousChild = child;
     }
     ASSERT(previousChild == m_lastChild);
 #endif
 }

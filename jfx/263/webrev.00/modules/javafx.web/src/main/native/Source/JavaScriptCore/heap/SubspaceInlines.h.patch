diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/SubspaceInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/SubspaceInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/SubspaceInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/SubspaceInlines.h
@@ -58,13 +58,13 @@
             directory.forEachNotEmptyBlock(func);
         });
 }
 
 template<typename Func>
-void Subspace::forEachLargeAllocation(const Func& func)
+void Subspace::forEachPreciseAllocation(const Func& func)
 {
-    for (LargeAllocation* allocation = m_largeAllocations.begin(); allocation != m_largeAllocations.end(); allocation = allocation->next())
+    for (PreciseAllocation* allocation = m_preciseAllocations.begin(); allocation != m_preciseAllocations.end(); allocation = allocation->next())
         func(allocation);
 }
 
 template<typename Func>
 void Subspace::forEachMarkedCell(const Func& func)
@@ -76,12 +76,12 @@
                     func(cell, kind);
                     return IterationStatus::Continue;
                 });
         });
     CellAttributes attributes = this->attributes();
-    forEachLargeAllocation(
-        [&] (LargeAllocation* allocation) {
+    forEachPreciseAllocation(
+        [&] (PreciseAllocation* allocation) {
             if (allocation->isMarked())
                 func(allocation->cell(), attributes.cellKind);
         });
 }
 
@@ -107,29 +107,29 @@
                     });
             }
 
             {
                 auto locker = holdLock(m_lock);
-                if (!m_needToVisitLargeAllocations)
+                if (!m_needToVisitPreciseAllocations)
                     return;
-                m_needToVisitLargeAllocations = false;
+                m_needToVisitPreciseAllocations = false;
             }
 
             CellAttributes attributes = m_subspace.attributes();
-            m_subspace.forEachLargeAllocation(
-                [&] (LargeAllocation* allocation) {
+            m_subspace.forEachPreciseAllocation(
+                [&] (PreciseAllocation* allocation) {
                     if (allocation->isMarked())
                         m_func(visitor, allocation->cell(), attributes.cellKind);
                 });
         }
 
     private:
         Subspace& m_subspace;
         Ref<SharedTask<MarkedBlock::Handle*()>> m_blockSource;
         Func m_func;
         Lock m_lock;
-        bool m_needToVisitLargeAllocations { true };
+        bool m_needToVisitPreciseAllocations { true };
     };
 
     return adoptRef(*new Task(*this, func));
 }
 
@@ -143,12 +143,12 @@
                     func(cell, kind);
                     return IterationStatus::Continue;
                 });
         });
     CellAttributes attributes = this->attributes();
-    forEachLargeAllocation(
-        [&] (LargeAllocation* allocation) {
+    forEachPreciseAllocation(
+        [&] (PreciseAllocation* allocation) {
             if (allocation->isLive())
                 func(allocation->cell(), attributes.cellKind);
         });
 }
 

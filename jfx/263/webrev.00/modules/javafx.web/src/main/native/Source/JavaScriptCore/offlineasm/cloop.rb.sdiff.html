<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="asm.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="instructions.rb.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  71 class RegisterID
  72     def clDump
  73         case name
  74         # The cloop is modelled on the ARM implementation. Hence, the a0-a3
  75         # registers are aliases for r0-r3 i.e. t0-t3 in our case.
  76         when &quot;t0&quot;, &quot;a0&quot;, &quot;r0&quot;
  77             &quot;t0&quot;
  78         when &quot;t1&quot;, &quot;a1&quot;, &quot;r1&quot;
  79             &quot;t1&quot;
  80         when &quot;t2&quot;, &quot;a2&quot;
  81             &quot;t2&quot;
  82         when &quot;t3&quot;, &quot;a3&quot;
  83             &quot;t3&quot;
  84         when &quot;t4&quot;
  85             &quot;pc&quot;
  86         when &quot;t5&quot;
  87             &quot;t5&quot;
  88         when &quot;csr0&quot;
  89             &quot;pcBase&quot;
  90         when &quot;csr1&quot;
<span class="line-modified">  91             &quot;tagTypeNumber&quot;</span>
  92         when &quot;csr2&quot;
<span class="line-modified">  93             &quot;tagMask&quot;</span>
  94         when &quot;csr3&quot;
  95             &quot;metadataTable&quot;
  96         when &quot;cfr&quot;
  97             &quot;cfr&quot;
  98         when &quot;lr&quot;
  99             &quot;lr&quot;
 100         when &quot;sp&quot;
 101             &quot;sp&quot;
 102         else
 103             raise &quot;Bad register #{name} for C_LOOP at #{codeOriginString}&quot;
 104         end
 105     end
 106     def clLValue(type=:intptr)
 107         clDump
 108     end
 109     def clValue(type=:intptr)
 110         clDump + cloopMapType(type)
 111     end
 112 end
 113 
</pre>
<hr />
<pre>
 143         &quot;#{value}&quot;
 144     end
 145     def clLValue(type=:intptr)
 146         raise &quot;Immediate cannot be used as an LValue&quot;
 147     end
 148     def clValue(type=:intptr)
 149         # There is a case of a very large unsigned number (0x8000000000000000)
 150         # which we wish to encode.  Unfortunately, the C/C++ compiler
 151         # complains if we express that number as a positive decimal integer.
 152         # Hence, for positive values, we just convert the number into hex form
 153         # to keep the compiler happy.
 154         #
 155         # However, for negative values, the to_s(16) hex conversion method does
 156         # not strip the &quot;-&quot; sign resulting in a meaningless &quot;0x-...&quot; valueStr.
 157         # To workaround this, we simply don&#39;t encode negative numbers as hex.
 158 
 159         valueStr = (value &lt; 0) ? &quot;#{value}&quot; : &quot;0x#{value.to_s(16)}&quot;
 160 
 161         case type
 162         when :int8;    &quot;int8_t(#{valueStr})&quot;

 163         when :int32;   &quot;int32_t(#{valueStr})&quot;
 164         when :int64;   &quot;int64_t(#{valueStr})&quot;
 165         when :intptr;  &quot;intptr_t(#{valueStr})&quot;
 166         when :uint8;   &quot;uint8_t(#{valueStr})&quot;
 167         when :uint32;  &quot;uint32_t(#{valueStr})&quot;
 168         when :uint64;  &quot;uint64_t(#{valueStr})&quot;
 169         when :uintptr; &quot;uintptr_t(#{valueStr})&quot;
 170         else
 171             raise &quot;Not implemented immediate of type: #{type}&quot; 
 172         end
 173     end
 174 end
 175 
 176 class Address
 177     def clDump
 178         &quot;[#{base.clDump}, #{offset.value}]&quot;
 179     end
 180     def clLValue(type=:intptr)
 181         clValue(type)
 182     end
 183     def clValue(type=:intptr)
 184         case type
 185         when :int8;         int8MemRef

 186         when :int32;        int32MemRef
 187         when :int64;        int64MemRef
 188         when :intptr;       intptrMemRef
 189         when :uint8;        uint8MemRef
 190         when :uint32;       uint32MemRef
 191         when :uint64;       uint64MemRef
 192         when :uintptr;      uintptrMemRef
 193         when :opcode;       opcodeMemRef
 194         when :nativeFunc;   nativeFuncMemRef
 195         else
 196             raise &quot;Unexpected Address type: #{type}&quot;
 197         end
 198     end
 199     def pointerExpr
 200         if  offset.value == 0
 201             &quot;#{base.clValue(:int8Ptr)}&quot;
 202         elsif offset.value &gt; 0
 203             &quot;#{base.clValue(:int8Ptr)} + #{offset.value}&quot;
 204         else
 205             &quot;#{base.clValue(:int8Ptr)} - #{-offset.value}&quot;
</pre>
<hr />
<pre>
 369             | node |
 370             unless node.is_a? Instruction or
 371                     node.is_a? Label or
 372                     node.is_a? LocalLabel or
 373                     node.is_a? Skip
 374                 raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
 375             end
 376         }
 377         
 378         return myList
 379     end
 380 end
 381 
 382 def clOperands(operands)
 383     operands.map{|v| v.clDump}.join(&quot;, &quot;)
 384 end
 385 
 386 
 387 def cloopEmitOperation(operands, type, operator)
 388     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || \
<span class="line-modified"> 389         type == :int64 || type == :uint64 || type == :double</span>
 390     if operands.size == 3
 391         op1 = operands[0]
 392         op2 = operands[1]
 393         dst = operands[2]
 394     else
 395         raise unless operands.size == 2
 396         op1 = operands[1]
 397         op2 = operands[0]
 398         dst = operands[1]
 399     end
 400     raise unless not dst.is_a? Immediate
 401     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 402         truncationHeader = &quot;(uint32_t)(&quot;
 403         truncationFooter = &quot;)&quot;



 404     else
 405         truncationHeader = &quot;&quot;
 406         truncationFooter = &quot;&quot;
 407     end
 408     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{op1.clValue(type)} #{operator} #{op2.clValue(type)}#{truncationFooter};&quot;
 409 end
 410 
 411 def cloopEmitShiftOperation(operands, type, operator)
 412     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || type == :int64 || type == :uint64
 413     if operands.size == 3
 414         op1 = operands[0]
 415         op2 = operands[1]
 416         dst = operands[2]
 417     else
 418         op1 = operands[1]
 419         op2 = operands[0]
 420         dst = operands[1]
 421     end
 422     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 423         truncationHeader = &quot;(uint32_t)(&quot;
</pre>
<hr />
<pre>
 568         when &quot;addi&quot;
 569             cloopEmitOperation(operands, :int32, &quot;+&quot;)
 570         when &quot;addq&quot;
 571             cloopEmitOperation(operands, :int64, &quot;+&quot;)
 572         when &quot;addp&quot;
 573             cloopEmitOperation(operands, :intptr, &quot;+&quot;)
 574 
 575         when &quot;andi&quot;
 576             cloopEmitOperation(operands, :int32, &quot;&amp;&quot;)
 577         when &quot;andq&quot;
 578             cloopEmitOperation(operands, :int64, &quot;&amp;&quot;)
 579         when &quot;andp&quot;
 580             cloopEmitOperation(operands, :intptr, &quot;&amp;&quot;)
 581 
 582         when &quot;ori&quot;
 583             cloopEmitOperation(operands, :int32, &quot;|&quot;)
 584         when &quot;orq&quot;
 585             cloopEmitOperation(operands, :int64, &quot;|&quot;)
 586         when &quot;orp&quot;
 587             cloopEmitOperation(operands, :intptr, &quot;|&quot;)


 588 
 589         when &quot;xori&quot;
 590             cloopEmitOperation(operands, :int32, &quot;^&quot;)
 591         when &quot;xorq&quot;
 592             cloopEmitOperation(operands, :int64, &quot;^&quot;)
 593         when &quot;xorp&quot;
 594             cloopEmitOperation(operands, :intptr, &quot;^&quot;)
 595 
 596         when &quot;lshifti&quot;
 597             cloopEmitShiftOperation(operands, :int32, &quot;&lt;&lt;&quot;)
 598         when &quot;lshiftq&quot;
 599             cloopEmitShiftOperation(operands, :int64, &quot;&lt;&lt;&quot;)
 600         when &quot;lshiftp&quot;
 601             cloopEmitShiftOperation(operands, :intptr, &quot;&lt;&lt;&quot;)
 602 
 603         when &quot;rshifti&quot;
 604             cloopEmitShiftOperation(operands, :int32, &quot;&gt;&gt;&quot;)
 605         when &quot;rshiftq&quot;
 606             cloopEmitShiftOperation(operands, :int64, &quot;&gt;&gt;&quot;)
 607         when &quot;rshiftp&quot;
</pre>
<hr />
<pre>
 668             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = (uint32_t)((int32_t)#{operands[0].int16MemRef});&quot;
 669         when &quot;loadhsq&quot;
 670             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = (int64_t)#{operands[0].int16MemRef};&quot;
 671         when &quot;storeh&quot;
 672             $asm.putc &quot;*#{operands[1].uint16MemRef} = #{operands[0].clValue(:int16)};&quot;
 673         when &quot;loadd&quot;
 674             $asm.putc &quot;#{operands[1].clLValue(:double)} = #{operands[0].dblMemRef};&quot;
 675         when &quot;stored&quot;
 676             $asm.putc &quot;#{operands[1].dblMemRef} = #{operands[0].clValue(:double)};&quot;
 677 
 678         when &quot;addd&quot;
 679             cloopEmitOperation(operands, :double, &quot;+&quot;)
 680         when &quot;divd&quot;
 681             cloopEmitOperation(operands, :double, &quot;/&quot;)
 682         when &quot;subd&quot;
 683             cloopEmitOperation(operands, :double, &quot;-&quot;)
 684         when &quot;muld&quot;
 685             cloopEmitOperation(operands, :double, &quot;*&quot;)
 686 
 687         # Convert an int value to its double equivalent, and store it in a double register.
<span class="line-modified"> 688         when &quot;ci2d&quot;</span>
<span class="line-modified"> 689             $asm.putc &quot;#{operands[1].clLValue(:double)} = (double)#{operands[0].clValue(:int32)}; // ci2d&quot;</span>
 690 
 691         when &quot;bdeq&quot;
 692             cloopEmitCompareAndBranch(operands, :double, &quot;==&quot;)
 693         when &quot;bdneq&quot;
 694             cloopEmitCompareAndBranch(operands, :double, &quot;!=&quot;)
 695         when &quot;bdgt&quot;
 696             cloopEmitCompareAndBranch(operands, :double, &quot;&gt;&quot;);
 697         when &quot;bdgteq&quot;
 698             cloopEmitCompareAndBranch(operands, :double, &quot;&gt;=&quot;);
 699         when &quot;bdlt&quot;
 700             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;&quot;);
 701         when &quot;bdlteq&quot;
 702             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;=&quot;);
 703 
 704         when &quot;bdequn&quot;
 705             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;==&quot;)
 706         when &quot;bdnequn&quot;
 707             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;!=&quot;)
 708         when &quot;bdgtun&quot;
 709             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&gt;&quot;)
</pre>
<hr />
<pre>
1109         # A convenience and compact call to crash because we don&#39;t want to use
1110         # the generic llint crash mechanism which relies on the availability
1111         # of the call instruction (which cannot be implemented in a generic
1112         # way, and can be abused if we made it just work for this special case).
1113         # Using a special cloopCrash instruction is cleaner.
1114         when &quot;cloopCrash&quot;
1115             $asm.putc &quot;CRASH();&quot;
1116 
1117         # We can&#39;t rely on the llint JS call mechanism which actually makes
1118         # use of the call instruction. Instead, we just implement JS calls
1119         # as an opcode dispatch.
1120         when &quot;cloopCallJSFunction&quot;
1121             uid = $asm.newUID
1122             $asm.putc &quot;lr = getOpcode(llint_cloop_did_return_from_js_#{uid});&quot;
1123             $asm.putc &quot;opcode = #{operands[0].clValue(:opcode)};&quot;
1124             $asm.putc &quot;DISPATCH_OPCODE();&quot;
1125             $asm.putsLabel(&quot;llint_cloop_did_return_from_js_#{uid}&quot;, false)
1126 
1127         # We can&#39;t do generic function calls with an arbitrary set of args, but
1128         # fortunately we don&#39;t have to here. All native function calls always
<span class="line-modified">1129         # have a fixed prototype of 1 args: the passed ExecState.</span>
1130         when &quot;cloopCallNative&quot;
1131             $asm.putc &quot;cloopStack.setCurrentStackPointer(sp.vp());&quot;
1132             $asm.putc &quot;nativeFunc = #{operands[0].clValue(:nativeFunc)};&quot;
<span class="line-modified">1133             $asm.putc &quot;functionReturnValue = JSValue::decode(nativeFunc(t0.execState()));&quot;</span>
1134             $asm.putc &quot;#if USE(JSVALUE32_64)&quot;
1135             $asm.putc &quot;    t1 = functionReturnValue.tag();&quot;
1136             $asm.putc &quot;    t0 = functionReturnValue.payload();&quot;
1137             $asm.putc &quot;#else // USE_JSVALUE64)&quot;
1138             $asm.putc &quot;    t0 = JSValue::encode(functionReturnValue);&quot;
1139             $asm.putc &quot;#endif // USE_JSVALUE64)&quot;
1140 
1141         # We can&#39;t do generic function calls with an arbitrary set of args, but
1142         # fortunately we don&#39;t have to here. All slow path function calls always
1143         # have a fixed prototype too. See cloopEmitCallSlowPath() for details.
1144         when &quot;cloopCallSlowPath&quot;
1145             cloopEmitCallSlowPath(operands)
1146 
1147         when &quot;cloopCallSlowPathVoid&quot;
1148             cloopEmitCallSlowPathVoid(operands)
1149 
1150         # For debugging only. This is used to insert instrumentation into the
1151         # generated LLIntAssembly.h during llint development only. Do not use
1152         # for production code.
1153         when &quot;cloopDo&quot;
</pre>
</td>
<td>
<hr />
<pre>
  71 class RegisterID
  72     def clDump
  73         case name
  74         # The cloop is modelled on the ARM implementation. Hence, the a0-a3
  75         # registers are aliases for r0-r3 i.e. t0-t3 in our case.
  76         when &quot;t0&quot;, &quot;a0&quot;, &quot;r0&quot;
  77             &quot;t0&quot;
  78         when &quot;t1&quot;, &quot;a1&quot;, &quot;r1&quot;
  79             &quot;t1&quot;
  80         when &quot;t2&quot;, &quot;a2&quot;
  81             &quot;t2&quot;
  82         when &quot;t3&quot;, &quot;a3&quot;
  83             &quot;t3&quot;
  84         when &quot;t4&quot;
  85             &quot;pc&quot;
  86         when &quot;t5&quot;
  87             &quot;t5&quot;
  88         when &quot;csr0&quot;
  89             &quot;pcBase&quot;
  90         when &quot;csr1&quot;
<span class="line-modified">  91             &quot;numberTag&quot;</span>
  92         when &quot;csr2&quot;
<span class="line-modified">  93             &quot;notCellMask&quot;</span>
  94         when &quot;csr3&quot;
  95             &quot;metadataTable&quot;
  96         when &quot;cfr&quot;
  97             &quot;cfr&quot;
  98         when &quot;lr&quot;
  99             &quot;lr&quot;
 100         when &quot;sp&quot;
 101             &quot;sp&quot;
 102         else
 103             raise &quot;Bad register #{name} for C_LOOP at #{codeOriginString}&quot;
 104         end
 105     end
 106     def clLValue(type=:intptr)
 107         clDump
 108     end
 109     def clValue(type=:intptr)
 110         clDump + cloopMapType(type)
 111     end
 112 end
 113 
</pre>
<hr />
<pre>
 143         &quot;#{value}&quot;
 144     end
 145     def clLValue(type=:intptr)
 146         raise &quot;Immediate cannot be used as an LValue&quot;
 147     end
 148     def clValue(type=:intptr)
 149         # There is a case of a very large unsigned number (0x8000000000000000)
 150         # which we wish to encode.  Unfortunately, the C/C++ compiler
 151         # complains if we express that number as a positive decimal integer.
 152         # Hence, for positive values, we just convert the number into hex form
 153         # to keep the compiler happy.
 154         #
 155         # However, for negative values, the to_s(16) hex conversion method does
 156         # not strip the &quot;-&quot; sign resulting in a meaningless &quot;0x-...&quot; valueStr.
 157         # To workaround this, we simply don&#39;t encode negative numbers as hex.
 158 
 159         valueStr = (value &lt; 0) ? &quot;#{value}&quot; : &quot;0x#{value.to_s(16)}&quot;
 160 
 161         case type
 162         when :int8;    &quot;int8_t(#{valueStr})&quot;
<span class="line-added"> 163         when :int16;   &quot;int16_t(#{valueStr})&quot;</span>
 164         when :int32;   &quot;int32_t(#{valueStr})&quot;
 165         when :int64;   &quot;int64_t(#{valueStr})&quot;
 166         when :intptr;  &quot;intptr_t(#{valueStr})&quot;
 167         when :uint8;   &quot;uint8_t(#{valueStr})&quot;
 168         when :uint32;  &quot;uint32_t(#{valueStr})&quot;
 169         when :uint64;  &quot;uint64_t(#{valueStr})&quot;
 170         when :uintptr; &quot;uintptr_t(#{valueStr})&quot;
 171         else
 172             raise &quot;Not implemented immediate of type: #{type}&quot; 
 173         end
 174     end
 175 end
 176 
 177 class Address
 178     def clDump
 179         &quot;[#{base.clDump}, #{offset.value}]&quot;
 180     end
 181     def clLValue(type=:intptr)
 182         clValue(type)
 183     end
 184     def clValue(type=:intptr)
 185         case type
 186         when :int8;         int8MemRef
<span class="line-added"> 187         when :int16;        int16MemRef</span>
 188         when :int32;        int32MemRef
 189         when :int64;        int64MemRef
 190         when :intptr;       intptrMemRef
 191         when :uint8;        uint8MemRef
 192         when :uint32;       uint32MemRef
 193         when :uint64;       uint64MemRef
 194         when :uintptr;      uintptrMemRef
 195         when :opcode;       opcodeMemRef
 196         when :nativeFunc;   nativeFuncMemRef
 197         else
 198             raise &quot;Unexpected Address type: #{type}&quot;
 199         end
 200     end
 201     def pointerExpr
 202         if  offset.value == 0
 203             &quot;#{base.clValue(:int8Ptr)}&quot;
 204         elsif offset.value &gt; 0
 205             &quot;#{base.clValue(:int8Ptr)} + #{offset.value}&quot;
 206         else
 207             &quot;#{base.clValue(:int8Ptr)} - #{-offset.value}&quot;
</pre>
<hr />
<pre>
 371             | node |
 372             unless node.is_a? Instruction or
 373                     node.is_a? Label or
 374                     node.is_a? LocalLabel or
 375                     node.is_a? Skip
 376                 raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
 377             end
 378         }
 379         
 380         return myList
 381     end
 382 end
 383 
 384 def clOperands(operands)
 385     operands.map{|v| v.clDump}.join(&quot;, &quot;)
 386 end
 387 
 388 
 389 def cloopEmitOperation(operands, type, operator)
 390     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || \
<span class="line-modified"> 391         type == :int64 || type == :uint64 || type == :double || type == :int16</span>
 392     if operands.size == 3
 393         op1 = operands[0]
 394         op2 = operands[1]
 395         dst = operands[2]
 396     else
 397         raise unless operands.size == 2
 398         op1 = operands[1]
 399         op2 = operands[0]
 400         dst = operands[1]
 401     end
 402     raise unless not dst.is_a? Immediate
 403     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 404         truncationHeader = &quot;(uint32_t)(&quot;
 405         truncationFooter = &quot;)&quot;
<span class="line-added"> 406     elsif dst.is_a? RegisterID and (type == :int16)</span>
<span class="line-added"> 407         truncationHeader = &quot;(uint16_t)(&quot;</span>
<span class="line-added"> 408         truncationFooter = &quot;)&quot;</span>
 409     else
 410         truncationHeader = &quot;&quot;
 411         truncationFooter = &quot;&quot;
 412     end
 413     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{op1.clValue(type)} #{operator} #{op2.clValue(type)}#{truncationFooter};&quot;
 414 end
 415 
 416 def cloopEmitShiftOperation(operands, type, operator)
 417     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || type == :int64 || type == :uint64
 418     if operands.size == 3
 419         op1 = operands[0]
 420         op2 = operands[1]
 421         dst = operands[2]
 422     else
 423         op1 = operands[1]
 424         op2 = operands[0]
 425         dst = operands[1]
 426     end
 427     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 428         truncationHeader = &quot;(uint32_t)(&quot;
</pre>
<hr />
<pre>
 573         when &quot;addi&quot;
 574             cloopEmitOperation(operands, :int32, &quot;+&quot;)
 575         when &quot;addq&quot;
 576             cloopEmitOperation(operands, :int64, &quot;+&quot;)
 577         when &quot;addp&quot;
 578             cloopEmitOperation(operands, :intptr, &quot;+&quot;)
 579 
 580         when &quot;andi&quot;
 581             cloopEmitOperation(operands, :int32, &quot;&amp;&quot;)
 582         when &quot;andq&quot;
 583             cloopEmitOperation(operands, :int64, &quot;&amp;&quot;)
 584         when &quot;andp&quot;
 585             cloopEmitOperation(operands, :intptr, &quot;&amp;&quot;)
 586 
 587         when &quot;ori&quot;
 588             cloopEmitOperation(operands, :int32, &quot;|&quot;)
 589         when &quot;orq&quot;
 590             cloopEmitOperation(operands, :int64, &quot;|&quot;)
 591         when &quot;orp&quot;
 592             cloopEmitOperation(operands, :intptr, &quot;|&quot;)
<span class="line-added"> 593         when &quot;orh&quot;</span>
<span class="line-added"> 594             cloopEmitOperation(operands, :int16, &quot;|&quot;)</span>
 595 
 596         when &quot;xori&quot;
 597             cloopEmitOperation(operands, :int32, &quot;^&quot;)
 598         when &quot;xorq&quot;
 599             cloopEmitOperation(operands, :int64, &quot;^&quot;)
 600         when &quot;xorp&quot;
 601             cloopEmitOperation(operands, :intptr, &quot;^&quot;)
 602 
 603         when &quot;lshifti&quot;
 604             cloopEmitShiftOperation(operands, :int32, &quot;&lt;&lt;&quot;)
 605         when &quot;lshiftq&quot;
 606             cloopEmitShiftOperation(operands, :int64, &quot;&lt;&lt;&quot;)
 607         when &quot;lshiftp&quot;
 608             cloopEmitShiftOperation(operands, :intptr, &quot;&lt;&lt;&quot;)
 609 
 610         when &quot;rshifti&quot;
 611             cloopEmitShiftOperation(operands, :int32, &quot;&gt;&gt;&quot;)
 612         when &quot;rshiftq&quot;
 613             cloopEmitShiftOperation(operands, :int64, &quot;&gt;&gt;&quot;)
 614         when &quot;rshiftp&quot;
</pre>
<hr />
<pre>
 675             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = (uint32_t)((int32_t)#{operands[0].int16MemRef});&quot;
 676         when &quot;loadhsq&quot;
 677             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = (int64_t)#{operands[0].int16MemRef};&quot;
 678         when &quot;storeh&quot;
 679             $asm.putc &quot;*#{operands[1].uint16MemRef} = #{operands[0].clValue(:int16)};&quot;
 680         when &quot;loadd&quot;
 681             $asm.putc &quot;#{operands[1].clLValue(:double)} = #{operands[0].dblMemRef};&quot;
 682         when &quot;stored&quot;
 683             $asm.putc &quot;#{operands[1].dblMemRef} = #{operands[0].clValue(:double)};&quot;
 684 
 685         when &quot;addd&quot;
 686             cloopEmitOperation(operands, :double, &quot;+&quot;)
 687         when &quot;divd&quot;
 688             cloopEmitOperation(operands, :double, &quot;/&quot;)
 689         when &quot;subd&quot;
 690             cloopEmitOperation(operands, :double, &quot;-&quot;)
 691         when &quot;muld&quot;
 692             cloopEmitOperation(operands, :double, &quot;*&quot;)
 693 
 694         # Convert an int value to its double equivalent, and store it in a double register.
<span class="line-modified"> 695         when &quot;ci2ds&quot;</span>
<span class="line-modified"> 696             $asm.putc &quot;#{operands[1].clLValue(:double)} = (double)#{operands[0].clValue(:int32)}; // ci2ds&quot;</span>
 697 
 698         when &quot;bdeq&quot;
 699             cloopEmitCompareAndBranch(operands, :double, &quot;==&quot;)
 700         when &quot;bdneq&quot;
 701             cloopEmitCompareAndBranch(operands, :double, &quot;!=&quot;)
 702         when &quot;bdgt&quot;
 703             cloopEmitCompareAndBranch(operands, :double, &quot;&gt;&quot;);
 704         when &quot;bdgteq&quot;
 705             cloopEmitCompareAndBranch(operands, :double, &quot;&gt;=&quot;);
 706         when &quot;bdlt&quot;
 707             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;&quot;);
 708         when &quot;bdlteq&quot;
 709             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;=&quot;);
 710 
 711         when &quot;bdequn&quot;
 712             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;==&quot;)
 713         when &quot;bdnequn&quot;
 714             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;!=&quot;)
 715         when &quot;bdgtun&quot;
 716             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&gt;&quot;)
</pre>
<hr />
<pre>
1116         # A convenience and compact call to crash because we don&#39;t want to use
1117         # the generic llint crash mechanism which relies on the availability
1118         # of the call instruction (which cannot be implemented in a generic
1119         # way, and can be abused if we made it just work for this special case).
1120         # Using a special cloopCrash instruction is cleaner.
1121         when &quot;cloopCrash&quot;
1122             $asm.putc &quot;CRASH();&quot;
1123 
1124         # We can&#39;t rely on the llint JS call mechanism which actually makes
1125         # use of the call instruction. Instead, we just implement JS calls
1126         # as an opcode dispatch.
1127         when &quot;cloopCallJSFunction&quot;
1128             uid = $asm.newUID
1129             $asm.putc &quot;lr = getOpcode(llint_cloop_did_return_from_js_#{uid});&quot;
1130             $asm.putc &quot;opcode = #{operands[0].clValue(:opcode)};&quot;
1131             $asm.putc &quot;DISPATCH_OPCODE();&quot;
1132             $asm.putsLabel(&quot;llint_cloop_did_return_from_js_#{uid}&quot;, false)
1133 
1134         # We can&#39;t do generic function calls with an arbitrary set of args, but
1135         # fortunately we don&#39;t have to here. All native function calls always
<span class="line-modified">1136         # have a fixed prototype of 2 args: the passed JSGlobalObject* and CallFrame*.</span>
1137         when &quot;cloopCallNative&quot;
1138             $asm.putc &quot;cloopStack.setCurrentStackPointer(sp.vp());&quot;
1139             $asm.putc &quot;nativeFunc = #{operands[0].clValue(:nativeFunc)};&quot;
<span class="line-modified">1140             $asm.putc &quot;functionReturnValue = JSValue::decode(nativeFunc(jsCast&lt;JSGlobalObject*&gt;(t0.cell()), t1.callFrame()));&quot;</span>
1141             $asm.putc &quot;#if USE(JSVALUE32_64)&quot;
1142             $asm.putc &quot;    t1 = functionReturnValue.tag();&quot;
1143             $asm.putc &quot;    t0 = functionReturnValue.payload();&quot;
1144             $asm.putc &quot;#else // USE_JSVALUE64)&quot;
1145             $asm.putc &quot;    t0 = JSValue::encode(functionReturnValue);&quot;
1146             $asm.putc &quot;#endif // USE_JSVALUE64)&quot;
1147 
1148         # We can&#39;t do generic function calls with an arbitrary set of args, but
1149         # fortunately we don&#39;t have to here. All slow path function calls always
1150         # have a fixed prototype too. See cloopEmitCallSlowPath() for details.
1151         when &quot;cloopCallSlowPath&quot;
1152             cloopEmitCallSlowPath(operands)
1153 
1154         when &quot;cloopCallSlowPathVoid&quot;
1155             cloopEmitCallSlowPathVoid(operands)
1156 
1157         # For debugging only. This is used to insert instrumentation into the
1158         # generated LLIntAssembly.h during llint development only. Do not use
1159         # for production code.
1160         when &quot;cloopDo&quot;
</pre>
</td>
</tr>
</table>
<center><a href="asm.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="instructions.rb.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewConstructorInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGenericTypedArrayView.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGenericTypedArrayViewInlines.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewConstructorInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 36,25 ***</span>
  #include &quot;StructureInlines.h&quot;
  
  namespace JSC {
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL callGenericTypedArrayView(ExecState*);</span>
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL constructGenericTypedArrayView(ExecState*);</span>
  
  template&lt;typename ViewClass&gt;
  JSGenericTypedArrayViewConstructor&lt;ViewClass&gt;::JSGenericTypedArrayViewConstructor(VM&amp; vm, Structure* structure)
      : Base(vm, structure, callGenericTypedArrayView&lt;ViewClass&gt;, constructGenericTypedArrayView&lt;ViewClass&gt;)
  {
  }
  
  template&lt;typename ViewClass&gt;
  void JSGenericTypedArrayViewConstructor&lt;ViewClass&gt;::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, JSObject* prototype, const String&amp; name, FunctionExecutable* privateAllocator)
  {
<span class="line-modified">!     Base::finishCreation(vm, name, NameVisibility::Visible, NameAdditionMode::WithoutStructureTransition);</span>
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(3), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;BYTES_PER_ELEMENT, jsNumber(ViewClass::elementSize), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete);
  
      if (privateAllocator)
<span class="line-new-header">--- 36,25 ---</span>
  #include &quot;StructureInlines.h&quot;
  
  namespace JSC {
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL callGenericTypedArrayView(JSGlobalObject*, CallFrame*);</span>
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL constructGenericTypedArrayView(JSGlobalObject*, CallFrame*);</span>
  
  template&lt;typename ViewClass&gt;
  JSGenericTypedArrayViewConstructor&lt;ViewClass&gt;::JSGenericTypedArrayViewConstructor(VM&amp; vm, Structure* structure)
      : Base(vm, structure, callGenericTypedArrayView&lt;ViewClass&gt;, constructGenericTypedArrayView&lt;ViewClass&gt;)
  {
  }
  
  template&lt;typename ViewClass&gt;
  void JSGenericTypedArrayViewConstructor&lt;ViewClass&gt;::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, JSObject* prototype, const String&amp; name, FunctionExecutable* privateAllocator)
  {
<span class="line-modified">!     Base::finishCreation(vm, name, NameAdditionMode::WithoutStructureTransition);</span>
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(3), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;BYTES_PER_ELEMENT, jsNumber(ViewClass::elementSize), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete);
  
      if (privateAllocator)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,44 ***</span>
      return Structure::create(
          vm, globalObject, prototype, TypeInfo(InternalFunctionType, StructureFlags), info());
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! inline JSObject* constructGenericTypedArrayViewFromIterator(ExecState* exec, Structure* structure, JSObject* iterable, JSValue iteratorMethod)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      MarkedArgumentBuffer storage;
<span class="line-modified">!     forEachInIterable(*exec, iterable, iteratorMethod, [&amp;] (VM&amp;, ExecState&amp;, JSValue value) {</span>
          storage.append(value);
          if (UNLIKELY(storage.hasOverflowed())) {
<span class="line-modified">!             throwOutOfMemoryError(exec, scope);</span>
              return;
          }
      });
      RETURN_IF_EXCEPTION(scope, nullptr);
  
<span class="line-modified">!     ViewClass* result = ViewClass::createUninitialized(exec, structure, storage.size());</span>
      EXCEPTION_ASSERT(!!scope.exception() == !result);
      if (UNLIKELY(!result))
          return nullptr;
  
      for (unsigned i = 0; i &lt; storage.size(); ++i) {
<span class="line-modified">!         bool success = result-&gt;setIndex(exec, i, storage.at(i));</span>
          EXCEPTION_ASSERT(scope.exception() || success);
          if (!success)
              return nullptr;
      }
  
      return result;
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! inline JSObject* constructGenericTypedArrayViewWithArguments(ExecState* exec, Structure* structure, EncodedJSValue firstArgument, unsigned offset, Optional&lt;unsigned&gt; lengthOpt)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue firstValue = JSValue::decode(firstArgument);
  
      if (JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, firstValue)) {
<span class="line-new-header">--- 81,44 ---</span>
      return Structure::create(
          vm, globalObject, prototype, TypeInfo(InternalFunctionType, StructureFlags), info());
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! inline JSObject* constructGenericTypedArrayViewFromIterator(JSGlobalObject* globalObject, Structure* structure, JSObject* iterable, JSValue iteratorMethod)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      MarkedArgumentBuffer storage;
<span class="line-modified">!     forEachInIterable(*globalObject, iterable, iteratorMethod, [&amp;] (VM&amp;, JSGlobalObject&amp;, JSValue value) {</span>
          storage.append(value);
          if (UNLIKELY(storage.hasOverflowed())) {
<span class="line-modified">!             throwOutOfMemoryError(globalObject, scope);</span>
              return;
          }
      });
      RETURN_IF_EXCEPTION(scope, nullptr);
  
<span class="line-modified">!     ViewClass* result = ViewClass::createUninitialized(globalObject, structure, storage.size());</span>
      EXCEPTION_ASSERT(!!scope.exception() == !result);
      if (UNLIKELY(!result))
          return nullptr;
  
      for (unsigned i = 0; i &lt; storage.size(); ++i) {
<span class="line-modified">!         bool success = result-&gt;setIndex(globalObject, i, storage.at(i));</span>
          EXCEPTION_ASSERT(scope.exception() || success);
          if (!success)
              return nullptr;
      }
  
      return result;
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! inline JSObject* constructGenericTypedArrayViewWithArguments(JSGlobalObject* globalObject, Structure* structure, EncodedJSValue firstArgument, unsigned offset, Optional&lt;unsigned&gt; lengthOpt)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue firstValue = JSValue::decode(firstArgument);
  
      if (JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, firstValue)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 127,22 ***</span>
  
          if (lengthOpt)
              length = lengthOpt.value();
          else {
              if (UNLIKELY((buffer-&gt;byteLength() - offset) % ViewClass::elementSize)) {
<span class="line-modified">!                 throwRangeError(exec, scope, &quot;ArrayBuffer length minus the byteOffset is not a multiple of the element size&quot;_s);</span>
                  return nullptr;
              }
              length = (buffer-&gt;byteLength() - offset) / ViewClass::elementSize;
          }
  
<span class="line-modified">!         RELEASE_AND_RETURN(scope, ViewClass::create(exec, structure, WTFMove(buffer), offset, length));</span>
      }
      ASSERT(!offset &amp;&amp; !lengthOpt);
  
      if (UNLIKELY(ViewClass::TypedArrayStorageType == TypeDataView)) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Expected ArrayBuffer for the first argument.&quot;_s);</span>
          return nullptr;
      }
  
      // For everything but DataView, we allow construction with any of:
      // - Another array. This creates a copy of the of that array.
<span class="line-new-header">--- 127,22 ---</span>
  
          if (lengthOpt)
              length = lengthOpt.value();
          else {
              if (UNLIKELY((buffer-&gt;byteLength() - offset) % ViewClass::elementSize)) {
<span class="line-modified">!                 throwRangeError(globalObject, scope, &quot;ArrayBuffer length minus the byteOffset is not a multiple of the element size&quot;_s);</span>
                  return nullptr;
              }
              length = (buffer-&gt;byteLength() - offset) / ViewClass::elementSize;
          }
  
<span class="line-modified">!         RELEASE_AND_RETURN(scope, ViewClass::create(globalObject, structure, WTFMove(buffer), offset, length));</span>
      }
      ASSERT(!offset &amp;&amp; !lengthOpt);
  
      if (UNLIKELY(ViewClass::TypedArrayStorageType == TypeDataView)) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Expected ArrayBuffer for the first argument.&quot;_s);</span>
          return nullptr;
      }
  
      // For everything but DataView, we allow construction with any of:
      // - Another array. This creates a copy of the of that array.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,14 ***</span>
              length = jsCast&lt;JSArrayBufferView*&gt;(object)-&gt;length();
          else {
              // This getPropertySlot operation should not be observed by the Proxy.
              // So we use VMInquiry. And purge the opaque object cases (proxy and namespace object) by isTaintedByOpaqueObject() guard.
              PropertySlot lengthSlot(object, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!             object-&gt;getPropertySlot(exec, vm.propertyNames-&gt;length, lengthSlot);</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
  
<span class="line-modified">!             JSValue iteratorFunc = object-&gt;get(exec, vm.propertyNames-&gt;iteratorSymbol);</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
  
              // We would like not use the iterator as it is painfully slow. Fortunately, unless
              // 1) The iterator is not a known iterator.
              // 2) The base object does not have a length getter.
<span class="line-new-header">--- 155,14 ---</span>
              length = jsCast&lt;JSArrayBufferView*&gt;(object)-&gt;length();
          else {
              // This getPropertySlot operation should not be observed by the Proxy.
              // So we use VMInquiry. And purge the opaque object cases (proxy and namespace object) by isTaintedByOpaqueObject() guard.
              PropertySlot lengthSlot(object, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!             object-&gt;getPropertySlot(globalObject, vm.propertyNames-&gt;length, lengthSlot);</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
  
<span class="line-modified">!             JSValue iteratorFunc = object-&gt;get(globalObject, vm.propertyNames-&gt;iteratorSymbol);</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
  
              // We would like not use the iterator as it is painfully slow. Fortunately, unless
              // 1) The iterator is not a known iterator.
              // 2) The base object does not have a length getter.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,90 ***</span>
              if (!iteratorFunc.isUndefined()
                  &amp;&amp; (iteratorFunc != object-&gt;globalObject(vm)-&gt;arrayProtoValuesFunction()
                      || lengthSlot.isAccessor() || lengthSlot.isCustom() || lengthSlot.isTaintedByOpaqueObject()
                      || hasAnyArrayStorage(object-&gt;indexingType()))) {
  
<span class="line-modified">!                     RELEASE_AND_RETURN(scope, constructGenericTypedArrayViewFromIterator&lt;ViewClass&gt;(exec, structure, object, iteratorFunc));</span>
              }
  
              if (lengthSlot.isUnset())
                  length = 0;
              else {
<span class="line-modified">!                 JSValue value = lengthSlot.getValue(exec, vm.propertyNames-&gt;length);</span>
                  RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!                 length = value.toUInt32(exec);</span>
                  RETURN_IF_EXCEPTION(scope, nullptr);
              }
          }
  
  
<span class="line-modified">!         ViewClass* result = ViewClass::createUninitialized(exec, structure, length);</span>
          EXCEPTION_ASSERT(!!scope.exception() == !result);
          if (UNLIKELY(!result))
              return nullptr;
  
          scope.release();
<span class="line-modified">!         if (!result-&gt;set(exec, 0, object, 0, length))</span>
              return nullptr;
  
          return result;
      }
  
<span class="line-modified">!     unsigned length = firstValue.toIndex(exec, &quot;length&quot;);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, ViewClass::create(exec, structure, length));</span>
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL constructGenericTypedArrayView(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     InternalFunction* function = jsCast&lt;InternalFunction*&gt;(exec-&gt;jsCallee());</span>
<span class="line-modified">!     Structure* parentStructure = function-&gt;globalObject(vm)-&gt;typedArrayStructure(ViewClass::TypedArrayStorageType);</span>
<span class="line-modified">!     Structure* structure = InternalFunction::createSubclassStructure(exec, exec-&gt;newTarget(), parentStructure);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     size_t argCount = exec-&gt;argumentCount();</span>
  
      if (!argCount) {
          if (ViewClass::TypedArrayStorageType == TypeDataView)
<span class="line-modified">!             return throwVMTypeError(exec, scope, &quot;DataView constructor requires at least one argument.&quot;_s);</span>
  
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(ViewClass::create(exec, structure, 0)));</span>
      }
  
<span class="line-modified">!     JSValue firstValue = exec-&gt;uncheckedArgument(0);</span>
      unsigned offset = 0;
      Optional&lt;unsigned&gt; length = WTF::nullopt;
      if (jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, firstValue) &amp;&amp; argCount &gt; 1) {
<span class="line-modified">!         offset = exec-&gt;uncheckedArgument(1).toIndex(exec, &quot;byteOffset&quot;);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
          if (argCount &gt; 2) {
              if (ViewClass::TypedArrayStorageType == TypeDataView) {
                  // If the DataView byteLength is present but undefined, treat it as missing.
<span class="line-modified">!                 JSValue byteLengthValue = exec-&gt;uncheckedArgument(2);</span>
                  if (!byteLengthValue.isUndefined()) {
<span class="line-modified">!                     length = byteLengthValue.toIndex(exec, &quot;byteLength&quot;);</span>
                      RETURN_IF_EXCEPTION(scope, encodedJSValue());
                  }
              } else {
<span class="line-modified">!                 length = exec-&gt;uncheckedArgument(2).toIndex(exec, &quot;length&quot;);</span>
                  RETURN_IF_EXCEPTION(scope, encodedJSValue());
              }
          }
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(constructGenericTypedArrayViewWithArguments&lt;ViewClass&gt;(exec, structure, JSValue::encode(firstValue), offset, length)));</span>
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL callGenericTypedArrayView(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     return JSValue::encode(throwConstructorCannotBeCalledAsFunctionTypeError(exec, scope, ViewClass::info()-&gt;className));</span>
  }
  
  } // namespace JSC
<span class="line-new-header">--- 172,90 ---</span>
              if (!iteratorFunc.isUndefined()
                  &amp;&amp; (iteratorFunc != object-&gt;globalObject(vm)-&gt;arrayProtoValuesFunction()
                      || lengthSlot.isAccessor() || lengthSlot.isCustom() || lengthSlot.isTaintedByOpaqueObject()
                      || hasAnyArrayStorage(object-&gt;indexingType()))) {
  
<span class="line-modified">!                     RELEASE_AND_RETURN(scope, constructGenericTypedArrayViewFromIterator&lt;ViewClass&gt;(globalObject, structure, object, iteratorFunc));</span>
              }
  
              if (lengthSlot.isUnset())
                  length = 0;
              else {
<span class="line-modified">!                 JSValue value = lengthSlot.getValue(globalObject, vm.propertyNames-&gt;length);</span>
                  RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!                 length = value.toUInt32(globalObject);</span>
                  RETURN_IF_EXCEPTION(scope, nullptr);
              }
          }
  
  
<span class="line-modified">!         ViewClass* result = ViewClass::createUninitialized(globalObject, structure, length);</span>
          EXCEPTION_ASSERT(!!scope.exception() == !result);
          if (UNLIKELY(!result))
              return nullptr;
  
          scope.release();
<span class="line-modified">!         if (!result-&gt;set(globalObject, 0, object, 0, length))</span>
              return nullptr;
  
          return result;
      }
  
<span class="line-modified">!     unsigned length = firstValue.toIndex(globalObject, &quot;length&quot;);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, ViewClass::create(globalObject, structure, length));</span>
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL constructGenericTypedArrayView(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     InternalFunction* function = jsCast&lt;InternalFunction*&gt;(callFrame-&gt;jsCallee());</span>
<span class="line-modified">!     Structure* parentStructure = function-&gt;globalObject()-&gt;typedArrayStructure(ViewClass::TypedArrayStorageType);</span>
<span class="line-modified">!     Structure* structure = InternalFunction::createSubclassStructure(globalObject, callFrame-&gt;jsCallee(), callFrame-&gt;newTarget(), parentStructure);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     size_t argCount = callFrame-&gt;argumentCount();</span>
  
      if (!argCount) {
          if (ViewClass::TypedArrayStorageType == TypeDataView)
<span class="line-modified">!             return throwVMTypeError(globalObject, scope, &quot;DataView constructor requires at least one argument.&quot;_s);</span>
  
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(ViewClass::create(globalObject, structure, 0)));</span>
      }
  
<span class="line-modified">!     JSValue firstValue = callFrame-&gt;uncheckedArgument(0);</span>
      unsigned offset = 0;
      Optional&lt;unsigned&gt; length = WTF::nullopt;
      if (jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, firstValue) &amp;&amp; argCount &gt; 1) {
<span class="line-modified">!         offset = callFrame-&gt;uncheckedArgument(1).toIndex(globalObject, &quot;byteOffset&quot;);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
          if (argCount &gt; 2) {
              if (ViewClass::TypedArrayStorageType == TypeDataView) {
                  // If the DataView byteLength is present but undefined, treat it as missing.
<span class="line-modified">!                 JSValue byteLengthValue = callFrame-&gt;uncheckedArgument(2);</span>
                  if (!byteLengthValue.isUndefined()) {
<span class="line-modified">!                     length = byteLengthValue.toIndex(globalObject, &quot;byteLength&quot;);</span>
                      RETURN_IF_EXCEPTION(scope, encodedJSValue());
                  }
              } else {
<span class="line-modified">!                 length = callFrame-&gt;uncheckedArgument(2).toIndex(globalObject, &quot;length&quot;);</span>
                  RETURN_IF_EXCEPTION(scope, encodedJSValue());
              }
          }
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(constructGenericTypedArrayViewWithArguments&lt;ViewClass&gt;(globalObject, structure, JSValue::encode(firstValue), offset, length)));</span>
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL callGenericTypedArrayView(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     return JSValue::encode(throwConstructorCannotBeCalledAsFunctionTypeError(globalObject, scope, ViewClass::info()-&gt;className));</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="JSGenericTypedArrayView.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGenericTypedArrayViewInlines.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLChecker.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLArrayReferenceType.h&quot;
  32 #include &quot;WHLSLArrayType.h&quot;
  33 #include &quot;WHLSLAssignmentExpression.h&quot;
  34 #include &quot;WHLSLCallExpression.h&quot;
  35 #include &quot;WHLSLCommaExpression.h&quot;
  36 #include &quot;WHLSLDereferenceExpression.h&quot;
  37 #include &quot;WHLSLDoWhileLoop.h&quot;
  38 #include &quot;WHLSLDotExpression.h&quot;
  39 #include &quot;WHLSLEntryPointType.h&quot;
  40 #include &quot;WHLSLForLoop.h&quot;
  41 #include &quot;WHLSLGatherEntryPointItems.h&quot;
  42 #include &quot;WHLSLIfStatement.h&quot;
  43 #include &quot;WHLSLIndexExpression.h&quot;
  44 #include &quot;WHLSLInferTypes.h&quot;
  45 #include &quot;WHLSLLogicalExpression.h&quot;
  46 #include &quot;WHLSLLogicalNotExpression.h&quot;
  47 #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;
  48 #include &quot;WHLSLMakePointerExpression.h&quot;
  49 #include &quot;WHLSLNameContext.h&quot;
  50 #include &quot;WHLSLPointerType.h&quot;
  51 #include &quot;WHLSLProgram.h&quot;
  52 #include &quot;WHLSLReadModifyWriteExpression.h&quot;
  53 #include &quot;WHLSLResolvableType.h&quot;
  54 #include &quot;WHLSLResolveOverloadImpl.h&quot;
  55 #include &quot;WHLSLResolvingType.h&quot;
  56 #include &quot;WHLSLReturn.h&quot;
  57 #include &quot;WHLSLSwitchStatement.h&quot;
  58 #include &quot;WHLSLTernaryExpression.h&quot;
  59 #include &quot;WHLSLVisitor.h&quot;
  60 #include &quot;WHLSLWhileLoop.h&quot;
  61 #include &lt;wtf/HashMap.h&gt;
  62 #include &lt;wtf/HashSet.h&gt;
  63 #include &lt;wtf/Ref.h&gt;
  64 #include &lt;wtf/Vector.h&gt;
  65 #include &lt;wtf/text/WTFString.h&gt;
  66 
  67 namespace WebCore {
  68 
  69 namespace WHLSL {
  70 
  71 class PODChecker : public Visitor {
  72 public:
  73     PODChecker() = default;
  74 
  75     virtual ~PODChecker() = default;
  76 
  77     void visit(AST::EnumerationDefinition&amp; enumerationDefinition) override
  78     {
  79         Visitor::visit(enumerationDefinition);
  80     }
  81 
  82     void visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration) override
  83     {
  84         if (!nativeTypeDeclaration.isNumber()
  85             &amp;&amp; !nativeTypeDeclaration.isVector()
  86             &amp;&amp; !nativeTypeDeclaration.isMatrix())
  87             setError(Error(&quot;Use of native type is not a POD in entrypoint semantic.&quot;, nativeTypeDeclaration.codeLocation()));
  88     }
  89 
  90     void visit(AST::StructureDefinition&amp; structureDefinition) override
  91     {
  92         Visitor::visit(structureDefinition);
  93     }
  94 
  95     void visit(AST::TypeDefinition&amp; typeDefinition) override
  96     {
  97         Visitor::visit(typeDefinition);
  98     }
  99 
 100     void visit(AST::ArrayType&amp; arrayType) override
 101     {
 102         Visitor::visit(arrayType);
 103     }
 104 
 105     void visit(AST::PointerType&amp; pointerType) override
 106     {
 107         setError(Error(&quot;Illegal use of pointer in entrypoint semantic.&quot;, pointerType.codeLocation()));
 108     }
 109 
 110     void visit(AST::ArrayReferenceType&amp; arrayReferenceType) override
 111     {
 112         setError(Error(&quot;Illegal use of array reference in entrypoint semantic.&quot;, arrayReferenceType.codeLocation()));
 113     }
 114 
 115     void visit(AST::TypeReference&amp; typeReference) override
 116     {
 117         checkErrorAndVisit(typeReference.resolvedType());
 118     }
 119 };
 120 
 121 class FunctionKey {
 122 public:
 123     FunctionKey() = default;
 124     FunctionKey(WTF::HashTableDeletedValueType)
 125     {
 126         m_castReturnType = bitwise_cast&lt;AST::NamedType*&gt;(static_cast&lt;uintptr_t&gt;(1));
 127     }
 128 
 129     FunctionKey(String name, Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; types, AST::NamedType* castReturnType = nullptr)
 130         : m_name(WTFMove(name))
 131         , m_types(WTFMove(types))
 132         , m_castReturnType(castReturnType)
 133     { }
 134 
 135     bool isEmptyValue() const { return m_name.isNull(); }
 136     bool isHashTableDeletedValue() const { return m_castReturnType == bitwise_cast&lt;AST::NamedType*&gt;(static_cast&lt;uintptr_t&gt;(1)); }
 137 
 138     unsigned hash() const
 139     {
 140         unsigned hash = IntHash&lt;size_t&gt;::hash(m_types.size());
 141         hash ^= m_name.hash();
 142         for (size_t i = 0; i &lt; m_types.size(); ++i)
 143             hash ^= m_types[i].get().hash() + i;
 144 
 145         if (m_castReturnType)
 146             hash ^= WTF::PtrHash&lt;AST::Type*&gt;::hash(&amp;m_castReturnType-&gt;unifyNode());
 147 
 148         return hash;
 149     }
 150 
 151     bool operator==(const FunctionKey&amp; other) const
 152     {
 153         if (m_types.size() != other.m_types.size())
 154             return false;
 155 
 156         if (m_name != other.m_name)
 157             return false;
 158 
 159         for (size_t i = 0; i &lt; m_types.size(); ++i) {
 160             if (!matches(m_types[i].get(), other.m_types[i].get()))
 161                 return false;
 162         }
 163 
 164         if (static_cast&lt;bool&gt;(m_castReturnType) != static_cast&lt;bool&gt;(other.m_castReturnType))
 165             return false;
 166 
 167         if (!m_castReturnType)
 168             return true;
 169 
 170         if (&amp;m_castReturnType-&gt;unifyNode() == &amp;other.m_castReturnType-&gt;unifyNode())
 171             return true;
 172 
 173         return false;
 174     }
 175 
 176     struct Hash {
 177         static unsigned hash(const FunctionKey&amp; key)
 178         {
 179             return key.hash();
 180         }
 181 
 182         static bool equal(const FunctionKey&amp; a, const FunctionKey&amp; b)
 183         {
 184             return a == b;
 185         }
 186 
 187         static const bool safeToCompareToEmptyOrDeleted = false;
 188         static const bool emptyValueIsZero = false;
 189     };
 190 
 191     struct Traits : public WTF::SimpleClassHashTraits&lt;FunctionKey&gt; {
 192         static const bool hasIsEmptyValueFunction = true;
 193         static bool isEmptyValue(const FunctionKey&amp; key) { return key.isEmptyValue(); }
 194     };
 195 
 196 private:
 197     String m_name;
 198     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; m_types;
 199     AST::NamedType* m_castReturnType;
 200 };
 201 
<a name="1" id="anc1"></a><span class="line-removed"> 202 class AndOverloadTypeKey {</span>
<span class="line-removed"> 203 public:</span>
<span class="line-removed"> 204     AndOverloadTypeKey() = default;</span>
<span class="line-removed"> 205     AndOverloadTypeKey(WTF::HashTableDeletedValueType)</span>
<span class="line-removed"> 206     {</span>
<span class="line-removed"> 207         m_type = bitwise_cast&lt;AST::UnnamedType*&gt;(static_cast&lt;uintptr_t&gt;(1));</span>
<span class="line-removed"> 208     }</span>
<span class="line-removed"> 209 </span>
<span class="line-removed"> 210     AndOverloadTypeKey(AST::UnnamedType&amp; type, AST::AddressSpace addressSpace)</span>
<span class="line-removed"> 211         : m_type(&amp;type)</span>
<span class="line-removed"> 212         , m_addressSpace(addressSpace)</span>
<span class="line-removed"> 213     { }</span>
<span class="line-removed"> 214 </span>
<span class="line-removed"> 215     bool isEmptyValue() const { return !m_type; }</span>
<span class="line-removed"> 216     bool isHashTableDeletedValue() const { return m_type == bitwise_cast&lt;AST::UnnamedType*&gt;(static_cast&lt;uintptr_t&gt;(1)); }</span>
<span class="line-removed"> 217 </span>
<span class="line-removed"> 218     unsigned hash() const</span>
<span class="line-removed"> 219     {</span>
<span class="line-removed"> 220         return IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(m_addressSpace)) ^ m_type-&gt;hash();</span>
<span class="line-removed"> 221     }</span>
<span class="line-removed"> 222 </span>
<span class="line-removed"> 223     bool operator==(const AndOverloadTypeKey&amp; other) const</span>
<span class="line-removed"> 224     {</span>
<span class="line-removed"> 225         return m_addressSpace == other.m_addressSpace</span>
<span class="line-removed"> 226             &amp;&amp; *m_type == *other.m_type;</span>
<span class="line-removed"> 227     }</span>
<span class="line-removed"> 228 </span>
<span class="line-removed"> 229     struct Hash {</span>
<span class="line-removed"> 230         static unsigned hash(const AndOverloadTypeKey&amp; key)</span>
<span class="line-removed"> 231         {</span>
<span class="line-removed"> 232             return key.hash();</span>
<span class="line-removed"> 233         }</span>
<span class="line-removed"> 234 </span>
<span class="line-removed"> 235         static bool equal(const AndOverloadTypeKey&amp; a, const AndOverloadTypeKey&amp; b)</span>
<span class="line-removed"> 236         {</span>
<span class="line-removed"> 237             return a == b;</span>
<span class="line-removed"> 238         }</span>
<span class="line-removed"> 239 </span>
<span class="line-removed"> 240         static const bool safeToCompareToEmptyOrDeleted = false;</span>
<span class="line-removed"> 241     };</span>
<span class="line-removed"> 242 </span>
<span class="line-removed"> 243     struct Traits : public WTF::SimpleClassHashTraits&lt;AndOverloadTypeKey&gt; {</span>
<span class="line-removed"> 244         static const bool hasIsEmptyValueFunction = true;</span>
<span class="line-removed"> 245         static bool isEmptyValue(const AndOverloadTypeKey&amp; key) { return key.isEmptyValue(); }</span>
<span class="line-removed"> 246     };</span>
<span class="line-removed"> 247 </span>
<span class="line-removed"> 248 private:</span>
<span class="line-removed"> 249     AST::UnnamedType* m_type { nullptr };</span>
<span class="line-removed"> 250     AST::AddressSpace m_addressSpace;</span>
<span class="line-removed"> 251 };</span>
<span class="line-removed"> 252 </span>
<span class="line-removed"> 253 static AST::NativeFunctionDeclaration resolveWithOperatorAnderIndexer(CodeLocation location, AST::ArrayReferenceType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
<span class="line-removed"> 254 {</span>
<span class="line-removed"> 255     const bool isOperator = true;</span>
<span class="line-removed"> 256     auto returnType = AST::PointerType::create(location, firstArgument.addressSpace(), firstArgument.elementType());</span>
<span class="line-removed"> 257     AST::VariableDeclarations parameters;</span>
<span class="line-removed"> 258     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), &amp;firstArgument, String(), nullptr, nullptr));</span>
<span class="line-removed"> 259     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), AST::TypeReference::wrap(location, intrinsics.uintType()), String(), nullptr, nullptr));</span>
<span class="line-removed"> 260     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator&amp;[]&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
<span class="line-removed"> 261 }</span>
<span class="line-removed"> 262 </span>
<span class="line-removed"> 263 static AST::NativeFunctionDeclaration resolveWithOperatorLength(CodeLocation location, AST::UnnamedType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
<span class="line-removed"> 264 {</span>
<span class="line-removed"> 265     const bool isOperator = true;</span>
<span class="line-removed"> 266     auto returnType = AST::TypeReference::wrap(location, intrinsics.uintType());</span>
<span class="line-removed"> 267     AST::VariableDeclarations parameters;</span>
<span class="line-removed"> 268     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), &amp;firstArgument, String(), nullptr, nullptr));</span>
<span class="line-removed"> 269     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator.length&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
<span class="line-removed"> 270 }</span>
<span class="line-removed"> 271 </span>
 272 static AST::NativeFunctionDeclaration resolveWithReferenceComparator(CodeLocation location, ResolvingType&amp; firstArgument, ResolvingType&amp; secondArgument, const Intrinsics&amp; intrinsics)
 273 {
 274     const bool isOperator = true;
 275     auto returnType = AST::TypeReference::wrap(location, intrinsics.boolType());
 276     auto argumentType = firstArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {
 277         return unnamedType.copyRef();
 278     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {
 279         return secondArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {
 280             return unnamedType.copyRef();
 281         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {
 282             // We encountered &quot;null == null&quot;.
 283             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198162 This can probably be generalized, using the &quot;preferred type&quot; infrastructure used by generic literals
 284             ASSERT_NOT_REACHED();
 285             return AST::TypeReference::wrap(location, intrinsics.intType());
 286         }));
 287     }));
 288     AST::VariableDeclarations parameters;
 289     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), argumentType.copyRef(), String(), nullptr, nullptr));
 290     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), WTFMove(argumentType), String(), nullptr, nullptr));
 291     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator==&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));
 292 }
 293 
 294 enum class Acceptability {
 295     Yes,
<a name="2" id="anc2"></a><span class="line-removed"> 296     Maybe,</span>
 297     No
 298 };
 299 
 300 static Optional&lt;AST::NativeFunctionDeclaration&gt; resolveByInstantiation(const String&amp; name, CodeLocation location, const Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const Intrinsics&amp; intrinsics)
 301 {
<a name="3" id="anc3"></a><span class="line-modified"> 302     if (name == &quot;operator&amp;[]&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-removed"> 303         auto* firstArgumentArrayRef = types[0].get().visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::ArrayReferenceType* {</span>
<span class="line-removed"> 304             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))</span>
<span class="line-removed"> 305                 return &amp;downcast&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));</span>
<span class="line-removed"> 306             return nullptr;</span>
<span class="line-removed"> 307         }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::ArrayReferenceType* {</span>
<span class="line-removed"> 308             return nullptr;</span>
<span class="line-removed"> 309         }));</span>
<span class="line-removed"> 310         bool secondArgumentIsUint = types[1].get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
<span class="line-removed"> 311             return matches(unnamedType, intrinsics.uintType());</span>
<span class="line-removed"> 312         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
<span class="line-removed"> 313             return resolvableTypeReference-&gt;resolvableType().canResolve(intrinsics.uintType());</span>
<span class="line-removed"> 314         }));</span>
<span class="line-removed"> 315         if (firstArgumentArrayRef &amp;&amp; secondArgumentIsUint)</span>
<span class="line-removed"> 316             return resolveWithOperatorAnderIndexer(location, *firstArgumentArrayRef, intrinsics);</span>
<span class="line-removed"> 317     } else if (name == &quot;operator.length&quot; &amp;&amp; types.size() == 1) {</span>
<span class="line-removed"> 318         auto* firstArgumentReference = types[0].get().visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
<span class="line-removed"> 319             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)) || is&lt;AST::ArrayType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))</span>
<span class="line-removed"> 320                 return unnamedType.ptr();</span>
<span class="line-removed"> 321             return nullptr;</span>
<span class="line-removed"> 322         }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::UnnamedType* {</span>
<span class="line-removed"> 323             return nullptr;</span>
<span class="line-removed"> 324         }));</span>
<span class="line-removed"> 325         if (firstArgumentReference)</span>
<span class="line-removed"> 326             return resolveWithOperatorLength(location, *firstArgumentReference, intrinsics);</span>
<span class="line-removed"> 327     } else if (name == &quot;operator==&quot; &amp;&amp; types.size() == 2) {</span>
 328         auto acceptability = [](ResolvingType&amp; resolvingType) -&gt; Acceptability {
 329             return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Acceptability {
 330                 auto&amp; unifyNode = unnamedType-&gt;unifyNode();
 331                 return is&lt;AST::UnnamedType&gt;(unifyNode) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(unifyNode)) ? Acceptability::Yes : Acceptability::No;
<a name="4" id="anc4"></a><span class="line-modified"> 332             }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; Acceptability {</span>
<span class="line-modified"> 333                 return is&lt;AST::NullLiteralType&gt;(resolvableTypeReference-&gt;resolvableType()) ? Acceptability::Maybe : Acceptability::No;</span>
 334             }));
 335         };
 336         auto leftAcceptability = acceptability(types[0].get());
 337         auto rightAcceptability = acceptability(types[1].get());
 338         bool success = false;
 339         if (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Yes) {
 340             auto&amp; unnamedType1 = *types[0].get().getUnnamedType();
 341             auto&amp; unnamedType2 = *types[1].get().getUnnamedType();
 342             success = matches(unnamedType1, unnamedType2);
<a name="5" id="anc5"></a><span class="line-modified"> 343         } else if ((leftAcceptability == Acceptability::Maybe &amp;&amp; rightAcceptability == Acceptability::Yes)</span>
<span class="line-removed"> 344             || (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Maybe))</span>
<span class="line-removed"> 345             success = true;</span>
 346         if (success)
 347             return resolveWithReferenceComparator(location, types[0].get(), types[1].get(), intrinsics);
 348     }
 349     return WTF::nullopt;
 350 }
 351 
 352 static bool checkSemantics(Vector&lt;EntryPointItem&gt;&amp; inputItems, Vector&lt;EntryPointItem&gt;&amp; outputItems, const Optional&lt;AST::EntryPointType&gt;&amp; entryPointType, const Intrinsics&amp; intrinsics)
 353 {
 354     {
 355         auto checkDuplicateSemantics = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 356             for (size_t i = 0; i &lt; items.size(); ++i) {
 357                 for (size_t j = i + 1; j &lt; items.size(); ++j) {
 358                     if (items[i].semantic == items[j].semantic)
 359                         return false;
 360                 }
 361             }
 362             return true;
 363         };
 364         if (!checkDuplicateSemantics(inputItems))
 365             return false;
 366         if (!checkDuplicateSemantics(outputItems))
 367             return false;
 368     }
 369 
 370     {
 371         auto checkSemanticTypes = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 372             for (auto&amp; item : items) {
 373                 auto acceptable = WTF::visit(WTF::makeVisitor([&amp;](const AST::BaseSemantic&amp; semantic) -&gt; bool {
 374                     return semantic.isAcceptableType(*item.unnamedType, intrinsics);
 375                 }), *item.semantic);
 376                 if (!acceptable)
 377                     return false;
 378             }
 379             return true;
 380         };
 381         if (!checkSemanticTypes(inputItems))
 382             return false;
 383         if (!checkSemanticTypes(outputItems))
 384             return false;
 385     }
 386 
 387     {
 388         auto checkSemanticForShaderType = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items, AST::BaseSemantic::ShaderItemDirection direction) -&gt; bool {
 389             for (auto&amp; item : items) {
 390                 auto acceptable = WTF::visit(WTF::makeVisitor([&amp;](const AST::BaseSemantic&amp; semantic) -&gt; bool {
 391                     return semantic.isAcceptableForShaderItemDirection(direction, entryPointType);
 392                 }), *item.semantic);
 393                 if (!acceptable)
 394                     return false;
 395             }
 396             return true;
 397         };
 398         if (!checkSemanticForShaderType(inputItems, AST::BaseSemantic::ShaderItemDirection::Input))
 399             return false;
 400         if (!checkSemanticForShaderType(outputItems, AST::BaseSemantic::ShaderItemDirection::Output))
 401             return false;
 402     }
 403 
 404     {
 405         auto checkPODData = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 406             for (auto&amp; item : items) {
 407                 PODChecker podChecker;
 408                 if (is&lt;AST::PointerType&gt;(item.unnamedType))
 409                     podChecker.checkErrorAndVisit(downcast&lt;AST::PointerType&gt;(*item.unnamedType).elementType());
 410                 else if (is&lt;AST::ArrayReferenceType&gt;(item.unnamedType))
 411                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(*item.unnamedType).elementType());
 412                 else if (is&lt;AST::ArrayType&gt;(item.unnamedType))
 413                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(*item.unnamedType).type());
 414                 else
 415                     continue;
 416                 if (podChecker.hasError())
 417                     return false;
 418             }
 419             return true;
 420         };
 421         if (!checkPODData(inputItems))
 422             return false;
 423         if (!checkPODData(outputItems))
 424             return false;
 425     }
 426 
 427     return true;
 428 }
 429 
<a name="6" id="anc6"></a><span class="line-modified"> 430 static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition, NameContext&amp; nameContext, AST::NameSpace currentNameSpace)</span>
 431 {
 432     enum class CheckKind {
 433         Index,
 434         Dot
 435     };
 436 
<a name="7" id="anc7"></a><span class="line-removed"> 437     auto checkGetter = [&amp;](CheckKind kind) -&gt; bool {</span>
<span class="line-removed"> 438         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;</span>
<span class="line-removed"> 439         if (functionDefinition.parameters().size() != numExpectedParameters)</span>
<span class="line-removed"> 440             return false;</span>
<span class="line-removed"> 441         auto&amp; firstParameterUnifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="line-removed"> 442         if (is&lt;AST::UnnamedType&gt;(firstParameterUnifyNode)) {</span>
<span class="line-removed"> 443             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstParameterUnifyNode);</span>
<span class="line-removed"> 444             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-removed"> 445                 return false;</span>
<span class="line-removed"> 446         }</span>
<span class="line-removed"> 447         if (kind == CheckKind::Index) {</span>
<span class="line-removed"> 448             auto&amp; secondParameterUnifyNode = functionDefinition.parameters()[1]-&gt;type()-&gt;unifyNode();</span>
<span class="line-removed"> 449             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))</span>
<span class="line-removed"> 450                 return false;</span>
<span class="line-removed"> 451             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);</span>
<span class="line-removed"> 452             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))</span>
<span class="line-removed"> 453                 return false;</span>
<span class="line-removed"> 454             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);</span>
<span class="line-removed"> 455             if (!nativeTypeDeclaration.isInt())</span>
<span class="line-removed"> 456                 return false;</span>
<span class="line-removed"> 457         }</span>
<span class="line-removed"> 458         return true;</span>
<span class="line-removed"> 459     };</span>
<span class="line-removed"> 460 </span>
<span class="line-removed"> 461     auto checkSetter = [&amp;](CheckKind kind) -&gt; bool {</span>
<span class="line-removed"> 462         size_t numExpectedParameters = kind == CheckKind::Index ? 3 : 2;</span>
<span class="line-removed"> 463         if (functionDefinition.parameters().size() != numExpectedParameters)</span>
<span class="line-removed"> 464             return false;</span>
<span class="line-removed"> 465         auto&amp; firstArgumentUnifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="line-removed"> 466         if (is&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode)) {</span>
<span class="line-removed"> 467             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode);</span>
<span class="line-removed"> 468             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-removed"> 469                 return false;</span>
<span class="line-removed"> 470         }</span>
<span class="line-removed"> 471         if (kind == CheckKind::Index) {</span>
<span class="line-removed"> 472             auto&amp; secondParameterUnifyNode = functionDefinition.parameters()[1]-&gt;type()-&gt;unifyNode();</span>
<span class="line-removed"> 473             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))</span>
<span class="line-removed"> 474                 return false;</span>
<span class="line-removed"> 475             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);</span>
<span class="line-removed"> 476             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))</span>
<span class="line-removed"> 477                 return false;</span>
<span class="line-removed"> 478             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);</span>
<span class="line-removed"> 479             if (!nativeTypeDeclaration.isInt())</span>
<span class="line-removed"> 480                 return false;</span>
<span class="line-removed"> 481         }</span>
<span class="line-removed"> 482         if (!matches(functionDefinition.type(), *functionDefinition.parameters()[0]-&gt;type()))</span>
<span class="line-removed"> 483             return false;</span>
<span class="line-removed"> 484         auto&amp; valueType = *functionDefinition.parameters()[numExpectedParameters - 1]-&gt;type();</span>
<span class="line-removed"> 485         auto getterName = functionDefinition.name().substring(0, functionDefinition.name().length() - 1);</span>
<span class="line-removed"> 486         auto getterFuncs = nameContext.getFunctions(getterName, currentNameSpace);</span>
<span class="line-removed"> 487         Vector&lt;ResolvingType&gt; argumentTypes;</span>
<span class="line-removed"> 488         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; argumentTypeReferences;</span>
<span class="line-removed"> 489         for (size_t i = 0; i &lt; numExpectedParameters - 1; ++i)</span>
<span class="line-removed"> 490             argumentTypes.append(*functionDefinition.parameters()[i]-&gt;type());</span>
<span class="line-removed"> 491         for (auto&amp; argumentType : argumentTypes)</span>
<span class="line-removed"> 492             argumentTypeReferences.append(argumentType);</span>
<span class="line-removed"> 493         auto* overload = resolveFunctionOverload(getterFuncs, argumentTypeReferences, currentNameSpace);</span>
<span class="line-removed"> 494         if (!overload)</span>
<span class="line-removed"> 495             return false;</span>
<span class="line-removed"> 496         auto&amp; resultType = overload-&gt;type();</span>
<span class="line-removed"> 497         return matches(resultType, valueType);</span>
<span class="line-removed"> 498     };</span>
<span class="line-removed"> 499 </span>
<span class="line-removed"> 500     auto checkAnder = [&amp;](CheckKind kind) -&gt; bool {</span>
<span class="line-removed"> 501         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;</span>
<span class="line-removed"> 502         if (functionDefinition.parameters().size() != numExpectedParameters)</span>
<span class="line-removed"> 503             return false;</span>
<span class="line-removed"> 504         {</span>
<span class="line-removed"> 505             auto&amp; unifyNode = functionDefinition.type().unifyNode();</span>
<span class="line-removed"> 506             if (!is&lt;AST::UnnamedType&gt;(unifyNode))</span>
<span class="line-removed"> 507                 return false;</span>
<span class="line-removed"> 508             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-removed"> 509             if (!is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="line-removed"> 510                 return false;</span>
<span class="line-removed"> 511         }</span>
<span class="line-removed"> 512         {</span>
<span class="line-removed"> 513             auto&amp; unifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="line-removed"> 514             if (!is&lt;AST::UnnamedType&gt;(unifyNode))</span>
<span class="line-removed"> 515                 return false;</span>
<span class="line-removed"> 516             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-removed"> 517             return is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="line-removed"> 518         }</span>
<span class="line-removed"> 519     };</span>
<span class="line-removed"> 520 </span>
 521     if (!functionDefinition.isOperator())
 522         return true;
 523     if (functionDefinition.isCast())
 524         return true;
 525     if (functionDefinition.name() == &quot;operator++&quot; || functionDefinition.name() == &quot;operator--&quot;) {
 526         return functionDefinition.parameters().size() == 1
 527             &amp;&amp; matches(*functionDefinition.parameters()[0]-&gt;type(), functionDefinition.type());
 528     }
 529     if (functionDefinition.name() == &quot;operator+&quot; || functionDefinition.name() == &quot;operator-&quot;)
 530         return functionDefinition.parameters().size() == 1 || functionDefinition.parameters().size() == 2;
 531     if (functionDefinition.name() == &quot;operator*&quot;
 532         || functionDefinition.name() == &quot;operator/&quot;
 533         || functionDefinition.name() == &quot;operator%&quot;
 534         || functionDefinition.name() == &quot;operator&amp;&quot;
 535         || functionDefinition.name() == &quot;operator|&quot;
 536         || functionDefinition.name() == &quot;operator^&quot;
 537         || functionDefinition.name() == &quot;operator&lt;&lt;&quot;
 538         || functionDefinition.name() == &quot;operator&gt;&gt;&quot;)
 539         return functionDefinition.parameters().size() == 2;
 540     if (functionDefinition.name() == &quot;operator~&quot;)
 541         return functionDefinition.parameters().size() == 1;
<a name="8" id="anc8"></a><span class="line-removed"> 542     if (functionDefinition.name() == &quot;operator[]&quot;)</span>
<span class="line-removed"> 543         return checkGetter(CheckKind::Index);</span>
<span class="line-removed"> 544     if (functionDefinition.name() == &quot;operator[]=&quot;)</span>
<span class="line-removed"> 545         return checkSetter(CheckKind::Index);</span>
<span class="line-removed"> 546     if (functionDefinition.name() == &quot;operator&amp;[]&quot;)</span>
<span class="line-removed"> 547         return checkAnder(CheckKind::Index);</span>
<span class="line-removed"> 548     if (functionDefinition.name().startsWith(&quot;operator.&quot;)) {</span>
<span class="line-removed"> 549         if (functionDefinition.name().endsWith(&quot;=&quot;))</span>
<span class="line-removed"> 550             return checkSetter(CheckKind::Dot);</span>
<span class="line-removed"> 551         return checkGetter(CheckKind::Dot);</span>
<span class="line-removed"> 552     }</span>
<span class="line-removed"> 553     if (functionDefinition.name().startsWith(&quot;operator&amp;.&quot;))</span>
<span class="line-removed"> 554         return checkAnder(CheckKind::Dot);</span>
 555     return false;
 556 }
 557 
 558 class Checker : public Visitor {
 559 public:
 560     Checker(const Intrinsics&amp; intrinsics, Program&amp; program)
 561         : m_intrinsics(intrinsics)
 562         , m_program(program)
 563     {
 564         auto addFunction = [&amp;] (AST::FunctionDeclaration&amp; function) {
 565             AST::NamedType* castReturnType = nullptr;
 566             if (function.isCast() &amp;&amp; is&lt;AST::NamedType&gt;(function.type().unifyNode()))
 567                 castReturnType = &amp;downcast&lt;AST::NamedType&gt;(function.type().unifyNode());
 568 
 569             Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; types;
 570             types.reserveInitialCapacity(function.parameters().size());
 571 
 572             for (auto&amp; param : function.parameters())
 573                 types.uncheckedAppend(normalizedTypeForFunctionKey(*param-&gt;type()));
 574 
 575             auto addResult = m_functions.add(FunctionKey { function.name(), WTFMove(types), castReturnType }, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;());
 576             addResult.iterator-&gt;value.append(function);
 577         };
 578 
 579         for (auto&amp; function : m_program.functionDefinitions())
 580             addFunction(function.get());
 581         for (auto&amp; function : m_program.nativeFunctionDeclarations())
 582             addFunction(function.get());
 583     }
 584 
 585     virtual ~Checker() = default;
 586 
 587     void visit(Program&amp;) override;
 588 
 589     Expected&lt;void, Error&gt; assignTypes();
 590 
 591 private:
 592     bool checkShaderType(const AST::FunctionDefinition&amp;);
 593     bool isBoolType(ResolvingType&amp;);
 594     struct RecurseInfo {
 595         ResolvingType&amp; resolvingType;
 596         const AST::TypeAnnotation typeAnnotation;
 597     };
 598     Optional&lt;RecurseInfo&gt; recurseAndGetInfo(AST::Expression&amp;, bool requiresLeftValue = false);
 599     Optional&lt;RecurseInfo&gt; getInfo(AST::Expression&amp;, bool requiresLeftValue = false);
 600     RefPtr&lt;AST::UnnamedType&gt; recurseAndWrapBaseType(AST::PropertyAccessExpression&amp;);
 601     bool recurseAndRequireBoolType(AST::Expression&amp;);
 602     void assignConcreteType(AST::Expression&amp;, Ref&lt;AST::UnnamedType&gt;, AST::TypeAnnotation);
<a name="9" id="anc9"></a>
 603     void assignType(AST::Expression&amp;, RefPtr&lt;ResolvableTypeReference&gt;, AST::TypeAnnotation);
 604     void forwardType(AST::Expression&amp;, ResolvingType&amp;, AST::TypeAnnotation);
 605 
 606     void visit(AST::FunctionDefinition&amp;) override;
<a name="10" id="anc10"></a>
 607     void visit(AST::EnumerationDefinition&amp;) override;
 608     void visit(AST::TypeReference&amp;) override;
 609     void visit(AST::VariableDeclaration&amp;) override;
 610     void visit(AST::AssignmentExpression&amp;) override;
 611     void visit(AST::ReadModifyWriteExpression&amp;) override;
 612     void visit(AST::DereferenceExpression&amp;) override;
 613     void visit(AST::MakePointerExpression&amp;) override;
 614     void visit(AST::MakeArrayReferenceExpression&amp;) override;
 615     void visit(AST::DotExpression&amp;) override;
 616     void visit(AST::IndexExpression&amp;) override;
 617     void visit(AST::VariableReference&amp;) override;
 618     void visit(AST::Return&amp;) override;
 619     void visit(AST::PointerType&amp;) override;
 620     void visit(AST::ArrayReferenceType&amp;) override;
 621     void visit(AST::IntegerLiteral&amp;) override;
 622     void visit(AST::UnsignedIntegerLiteral&amp;) override;
 623     void visit(AST::FloatLiteral&amp;) override;
<a name="11" id="anc11"></a><span class="line-removed"> 624     void visit(AST::NullLiteral&amp;) override;</span>
 625     void visit(AST::BooleanLiteral&amp;) override;
 626     void visit(AST::EnumerationMemberLiteral&amp;) override;
 627     void visit(AST::LogicalNotExpression&amp;) override;
 628     void visit(AST::LogicalExpression&amp;) override;
 629     void visit(AST::IfStatement&amp;) override;
 630     void visit(AST::WhileLoop&amp;) override;
 631     void visit(AST::DoWhileLoop&amp;) override;
 632     void visit(AST::ForLoop&amp;) override;
 633     void visit(AST::SwitchStatement&amp;) override;
 634     void visit(AST::CommaExpression&amp;) override;
 635     void visit(AST::TernaryExpression&amp;) override;
 636     void visit(AST::CallExpression&amp;) override;
 637 
<a name="12" id="anc12"></a><span class="line-removed"> 638     void finishVisiting(AST::PropertyAccessExpression&amp;, ResolvingType* additionalArgumentType = nullptr);</span>
<span class="line-removed"> 639 </span>
 640     AST::FunctionDeclaration* resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation, AST::NamedType* castReturnType = nullptr);
 641 
<a name="13" id="anc13"></a><span class="line-removed"> 642     RefPtr&lt;AST::UnnamedType&gt; argumentTypeForAndOverload(AST::UnnamedType&amp; baseType, AST::AddressSpace);</span>
<span class="line-removed"> 643 </span>
 644     AST::UnnamedType&amp; wrappedFloatType()
 645     {
 646         if (!m_wrappedFloatType)
 647             m_wrappedFloatType = AST::TypeReference::wrap({ }, m_intrinsics.floatType());
 648         return *m_wrappedFloatType;
 649     }
 650 
<a name="14" id="anc14"></a><span class="line-modified"> 651     AST::UnnamedType&amp; genericPointerType()</span>
 652     {
<a name="15" id="anc15"></a><span class="line-modified"> 653         if (!m_genericPointerType)</span>
<span class="line-modified"> 654             m_genericPointerType = AST::PointerType::create({ }, AST::AddressSpace::Thread, AST::TypeReference::wrap({ }, m_intrinsics.floatType()));</span>
<span class="line-modified"> 655         return *m_genericPointerType;</span>
 656     }
 657 
 658     AST::UnnamedType&amp; normalizedTypeForFunctionKey(AST::UnnamedType&amp; type)
 659     {
 660         auto* unifyNode = &amp;type.unifyNode();
 661         if (unifyNode == &amp;m_intrinsics.uintType() || unifyNode == &amp;m_intrinsics.intType())
 662             return wrappedFloatType();
 663 
<a name="16" id="anc16"></a><span class="line-removed"> 664         if (is&lt;AST::ReferenceType&gt;(type))</span>
<span class="line-removed"> 665             return genericPointerType();</span>
<span class="line-removed"> 666 </span>
 667         return type;
 668     }
 669 
 670     RefPtr&lt;AST::TypeReference&gt; m_wrappedFloatType;
<a name="17" id="anc17"></a><span class="line-modified"> 671     RefPtr&lt;AST::UnnamedType&gt; m_genericPointerType;</span>
 672     HashMap&lt;AST::Expression*, std::unique_ptr&lt;ResolvingType&gt;&gt; m_typeMap;
 673     HashSet&lt;String&gt; m_vertexEntryPoints[AST::nameSpaceCount];
 674     HashSet&lt;String&gt; m_fragmentEntryPoints[AST::nameSpaceCount];
 675     HashSet&lt;String&gt; m_computeEntryPoints[AST::nameSpaceCount];
 676     const Intrinsics&amp; m_intrinsics;
 677     Program&amp; m_program;
 678     AST::FunctionDefinition* m_currentFunction { nullptr };
 679     HashMap&lt;FunctionKey, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;, FunctionKey::Hash, FunctionKey::Traits&gt; m_functions;
<a name="18" id="anc18"></a><span class="line-removed"> 680     HashMap&lt;AndOverloadTypeKey, RefPtr&lt;AST::UnnamedType&gt;, AndOverloadTypeKey::Hash, AndOverloadTypeKey::Traits&gt; m_andOverloadTypeMap;</span>
 681     AST::NameSpace m_currentNameSpace { AST::NameSpace::StandardLibrary };
<a name="19" id="anc19"></a>
 682 };
 683 
 684 void Checker::visit(Program&amp; program)
 685 {
 686     // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
 687     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
 688         checkErrorAndVisit(program.typeDefinitions()[i]);
 689     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
 690         checkErrorAndVisit(program.structureDefinitions()[i]);
 691     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
 692         checkErrorAndVisit(program.enumerationDefinitions()[i]);
 693     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
 694         checkErrorAndVisit(program.nativeTypeDeclarations()[i]);
 695 
 696     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
 697         checkErrorAndVisit(program.functionDefinitions()[i]);
 698     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
 699         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
 700 }
 701 
 702 Expected&lt;void, Error&gt; Checker::assignTypes()
 703 {
 704     for (auto&amp; keyValuePair : m_typeMap) {
 705         auto success = keyValuePair.value-&gt;visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {
 706             keyValuePair.key-&gt;setType(unnamedType.copyRef());
 707             return true;
 708         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {
 709             if (!resolvableTypeReference-&gt;resolvableType().maybeResolvedType()) {
 710                 if (!static_cast&lt;bool&gt;(commit(resolvableTypeReference-&gt;resolvableType())))
 711                     return false;
 712             }
 713             keyValuePair.key-&gt;setType(resolvableTypeReference-&gt;resolvableType().resolvedType());
 714             return true;
 715         }));
 716         if (!success)
 717             return makeUnexpected(Error(&quot;Could not resolve the type of a constant.&quot;));
 718     }
 719 
 720     return { };
 721 }
 722 
 723 bool Checker::checkShaderType(const AST::FunctionDefinition&amp; functionDefinition)
 724 {
 725     auto index = static_cast&lt;unsigned&gt;(m_currentNameSpace);
 726     switch (*functionDefinition.entryPointType()) {
 727     case AST::EntryPointType::Vertex:
 728         return static_cast&lt;bool&gt;(m_vertexEntryPoints[index].add(functionDefinition.name()));
 729     case AST::EntryPointType::Fragment:
 730         return static_cast&lt;bool&gt;(m_fragmentEntryPoints[index].add(functionDefinition.name()));
 731     case AST::EntryPointType::Compute:
 732         return static_cast&lt;bool&gt;(m_computeEntryPoints[index].add(functionDefinition.name()));
 733     }
 734 }
 735 
<a name="20" id="anc20"></a>






 736 void Checker::visit(AST::FunctionDefinition&amp; functionDefinition)
 737 {
 738     m_currentNameSpace = functionDefinition.nameSpace();
 739     m_currentFunction = &amp;functionDefinition;
 740     if (functionDefinition.entryPointType()) {
 741         if (!checkShaderType(functionDefinition)) {
 742             setError(Error(&quot;Duplicate entrypoint function.&quot;, functionDefinition.codeLocation()));
 743             return;
 744         }
 745         auto entryPointItems = gatherEntryPointItems(m_intrinsics, functionDefinition);
 746         if (!entryPointItems) {
 747             setError(entryPointItems.error());
 748             return;
 749         }
 750         if (!checkSemantics(entryPointItems-&gt;inputs, entryPointItems-&gt;outputs, functionDefinition.entryPointType(), m_intrinsics)) {
 751             setError(Error(&quot;Bad semantics for entrypoint.&quot;, functionDefinition.codeLocation()));
 752             return;
 753         }
 754     }
<a name="21" id="anc21"></a><span class="line-modified"> 755     if (!checkOperatorOverload(functionDefinition, m_program.nameContext(), m_currentNameSpace)) {</span>
 756         setError(Error(&quot;Operator does not match expected signature.&quot;, functionDefinition.codeLocation()));
 757         return;
 758     }
 759 
 760     Visitor::visit(functionDefinition);
 761 }
 762 
 763 static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; left, ResolvingType&amp; right)
 764 {
 765     return left.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 766         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 767             if (matches(left, right))
 768                 return left.copyRef();
 769             return nullptr;
 770         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 771             return matchAndCommit(left, right-&gt;resolvableType());
 772         }));
 773     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 774         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 775             return matchAndCommit(right, left-&gt;resolvableType());
 776         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 777             return matchAndCommit(left-&gt;resolvableType(), right-&gt;resolvableType());
 778         }));
 779     }));
 780 }
 781 
 782 static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::UnnamedType&amp; unnamedType)
 783 {
 784     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 785         if (matches(unnamedType, resolvingType))
 786             return &amp;unnamedType;
 787         return nullptr;
 788     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 789         return matchAndCommit(unnamedType, resolvingType-&gt;resolvableType());
 790     }));
 791 }
 792 
<a name="22" id="anc22"></a>










 793 static RefPtr&lt;AST::UnnamedType&gt; commit(ResolvingType&amp; resolvingType)
 794 {
 795     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 796         return unnamedType.copyRef();
 797     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 798         if (!resolvableTypeReference-&gt;resolvableType().maybeResolvedType())
 799             return commit(resolvableTypeReference-&gt;resolvableType());
 800         return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();
 801     }));
 802 }
 803 
 804 AST::FunctionDeclaration* Checker::resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation location, AST::NamedType* castReturnType)
 805 {
 806     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; unnamedTypes;
 807     unnamedTypes.reserveInitialCapacity(types.size());
 808 
 809     for (auto resolvingType : types) {
 810         AST::UnnamedType* type = resolvingType.get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {
 811             return unnamedType.ptr();
 812         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; AST::UnnamedType* {
 813             if (resolvableTypeReference-&gt;resolvableType().maybeResolvedType())
 814                 return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();
 815 
 816             if (resolvableTypeReference-&gt;resolvableType().isFloatLiteralType()
 817                 || resolvableTypeReference-&gt;resolvableType().isIntegerLiteralType()
 818                 || resolvableTypeReference-&gt;resolvableType().isUnsignedIntegerLiteralType())
 819                 return &amp;wrappedFloatType();
 820 
<a name="23" id="anc23"></a><span class="line-removed"> 821             if (resolvableTypeReference-&gt;resolvableType().isNullLiteralType())</span>
<span class="line-removed"> 822                 return &amp;genericPointerType();</span>
<span class="line-removed"> 823 </span>
 824             return commit(resolvableTypeReference-&gt;resolvableType()).get();
 825         }));
 826 
 827         if (!type) {
 828             setError(Error(&quot;Could not resolve the type of a constant.&quot;));
 829             return nullptr;
 830         }
 831 
 832         unnamedTypes.uncheckedAppend(normalizedTypeForFunctionKey(*type));
 833     }
 834 
 835     {
 836         auto iter = m_functions.find(FunctionKey { name, WTFMove(unnamedTypes), castReturnType });
 837         if (iter != m_functions.end()) {
 838             if (AST::FunctionDeclaration* function = resolveFunctionOverload(iter-&gt;value, types, castReturnType, m_currentNameSpace))
 839                 return function;
 840         }
 841     }
 842 
 843     if (auto newFunction = resolveByInstantiation(name, location, types, m_intrinsics)) {
 844         m_program.append(WTFMove(*newFunction));
 845         return &amp;m_program.nativeFunctionDeclarations().last();
 846     }
 847 
 848     return nullptr;
 849 }
 850 
 851 void Checker::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
 852 {
 853     bool isSigned;
 854     auto* baseType = ([&amp;]() -&gt; AST::NativeTypeDeclaration* {
 855         checkErrorAndVisit(enumerationDefinition.type());
 856         auto&amp; baseType = enumerationDefinition.type().unifyNode();
 857         if (!is&lt;AST::NamedType&gt;(baseType))
 858             return nullptr;
 859         auto&amp; namedType = downcast&lt;AST::NamedType&gt;(baseType);
 860         if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 861             return nullptr;
 862         auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 863         if (!nativeTypeDeclaration.isInt())
 864             return nullptr;
 865         isSigned = nativeTypeDeclaration.isSigned();
 866         return &amp;nativeTypeDeclaration;
 867     })();
 868     if (!baseType) {
 869         setError(Error(&quot;Invalid base type for enum.&quot;, enumerationDefinition.codeLocation()));
 870         return;
 871     }
 872 
 873     auto enumerationMembers = enumerationDefinition.enumerationMembers();
 874 
 875     for (auto&amp; member : enumerationMembers) {
 876         int64_t value = member.get().value();
 877         if (isSigned) {
 878             if (static_cast&lt;int64_t&gt;(static_cast&lt;int32_t&gt;(value)) != value) {
 879                 setError(Error(&quot;Invalid enumeration value.&quot;, member.get().codeLocation()));
 880                 return;
 881             }
 882         } else {
 883             if (static_cast&lt;int64_t&gt;(static_cast&lt;uint32_t&gt;(value)) != value) {
 884                 setError(Error(&quot;Invalid enumeration value.&quot;, member.get().codeLocation()));
 885                 return;
 886             }
 887         }
 888     }
 889 
 890     for (size_t i = 0; i &lt; enumerationMembers.size(); ++i) {
 891         auto value = enumerationMembers[i].get().value();
 892         for (size_t j = i + 1; j &lt; enumerationMembers.size(); ++j) {
 893             auto otherValue = enumerationMembers[j].get().value();
 894             if (value == otherValue) {
 895                 setError(Error(&quot;Cannot declare duplicate enumeration values.&quot;, enumerationMembers[j].get().codeLocation()));
 896                 return;
 897             }
 898         }
 899     }
 900 
 901     bool foundZero = false;
 902     for (auto&amp; member : enumerationMembers) {
 903         if (!member.get().value()) {
 904             foundZero = true;
 905             break;
 906         }
 907     }
 908     if (!foundZero) {
 909         setError(Error(&quot;enum definition must contain a zero value.&quot;, enumerationDefinition.codeLocation()));
 910         return;
 911     }
 912 }
 913 
 914 void Checker::visit(AST::TypeReference&amp; typeReference)
 915 {
 916     ASSERT(typeReference.maybeResolvedType());
 917 
 918     for (auto&amp; typeArgument : typeReference.typeArguments())
 919         checkErrorAndVisit(typeArgument);
 920 }
 921 
 922 auto Checker::recurseAndGetInfo(AST::Expression&amp; expression, bool requiresLeftValue) -&gt; Optional&lt;RecurseInfo&gt;
 923 {
 924     Visitor::visit(expression);
 925     if (hasError())
 926         return WTF::nullopt;
 927     return getInfo(expression, requiresLeftValue);
 928 }
 929 
 930 auto Checker::getInfo(AST::Expression&amp; expression, bool requiresLeftValue) -&gt; Optional&lt;RecurseInfo&gt;
 931 {
 932     auto typeIterator = m_typeMap.find(&amp;expression);
 933     ASSERT(typeIterator != m_typeMap.end());
 934 
 935     const auto&amp; typeAnnotation = expression.typeAnnotation();
 936     if (requiresLeftValue &amp;&amp; typeAnnotation.isRightValue()) {
 937         setError(Error(&quot;Unexpected rvalue.&quot;, expression.codeLocation()));
 938         return WTF::nullopt;
 939     }
 940     return {{ *typeIterator-&gt;value, typeAnnotation }};
 941 }
 942 
 943 void Checker::visit(AST::VariableDeclaration&amp; variableDeclaration)
 944 {
 945     // ReadModifyWriteExpressions are the only place where anonymous variables exist,
 946     // and that doesn&#39;t recurse on the anonymous variables, so we can assume the variable has a type.
 947     checkErrorAndVisit(*variableDeclaration.type());
 948     if (matches(*variableDeclaration.type(), m_intrinsics.voidType())) {
 949         setError(Error(&quot;Variables can&#39;t have void type.&quot;, variableDeclaration.codeLocation()));
 950         return;
 951     }
 952     if (variableDeclaration.initializer()) {
 953         auto&amp; lhsType = *variableDeclaration.type();
 954         auto initializerInfo = recurseAndGetInfo(*variableDeclaration.initializer());
 955         if (!initializerInfo)
 956             return;
 957         if (!matchAndCommit(initializerInfo-&gt;resolvingType, lhsType)) {
 958             setError(Error(&quot;Declared variable type does not match its initializer&#39;s type.&quot;, variableDeclaration.codeLocation()));
 959             return;
 960         }
<a name="24" id="anc24"></a>







 961     }
 962 }
 963 
 964 void Checker::assignConcreteType(AST::Expression&amp; expression, Ref&lt;AST::UnnamedType&gt; unnamedType, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 965 {
 966     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(unnamedType)));
 967     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 968     expression.setTypeAnnotation(WTFMove(typeAnnotation));
 969 }
 970 
<a name="25" id="anc25"></a>






 971 void Checker::assignType(AST::Expression&amp; expression, RefPtr&lt;ResolvableTypeReference&gt; resolvableTypeReference, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 972 {
 973     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(resolvableTypeReference)));
 974     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 975     expression.setTypeAnnotation(WTFMove(typeAnnotation));
 976 }
 977 
 978 void Checker::forwardType(AST::Expression&amp; expression, ResolvingType&amp; resolvingType, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 979 {
 980     resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; result) {
 981         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));
 982         ASSERT_UNUSED(addResult, addResult.isNewEntry);
 983     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; result) {
 984         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));
 985         ASSERT_UNUSED(addResult, addResult.isNewEntry);
 986     }));
 987     expression.setTypeAnnotation(WTFMove(typeAnnotation));
 988 }
 989 
 990 void Checker::visit(AST::AssignmentExpression&amp; assignmentExpression)
 991 {
 992     auto leftInfo = recurseAndGetInfo(assignmentExpression.left(), true);
 993     if (!leftInfo)
 994         return;
 995 
 996     auto rightInfo = recurseAndGetInfo(assignmentExpression.right());
 997     if (!rightInfo)
 998         return;
 999 
1000     auto resultType = matchAndCommit(leftInfo-&gt;resolvingType, rightInfo-&gt;resolvingType);
1001     if (!resultType) {
1002         setError(Error(&quot;Left hand side of assignment does not match the type of the right hand side.&quot;, assignmentExpression.codeLocation()));
1003         return;
1004     }
1005 
1006     assignConcreteType(assignmentExpression, *resultType);
1007 }
1008 
1009 void Checker::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
1010 {
1011     auto leftValueInfo = recurseAndGetInfo(readModifyWriteExpression.leftValue(), true);
1012     if (!leftValueInfo)
1013         return;
1014 
1015     readModifyWriteExpression.oldValue().setType(*leftValueInfo-&gt;resolvingType.getUnnamedType());
1016 
1017     auto newValueInfo = recurseAndGetInfo(readModifyWriteExpression.newValueExpression());
1018     if (!newValueInfo)
1019         return;
1020 
1021     if (RefPtr&lt;AST::UnnamedType&gt; matchedType = matchAndCommit(leftValueInfo-&gt;resolvingType, newValueInfo-&gt;resolvingType))
1022         readModifyWriteExpression.newValue().setType(*matchedType);
1023     else {
1024         setError(Error(&quot;Base of the read-modify-write expression does not match the type of the new value.&quot;, readModifyWriteExpression.codeLocation()));
1025         return;
1026     }
1027 
1028     auto resultInfo = recurseAndGetInfo(readModifyWriteExpression.resultExpression());
1029     if (!resultInfo)
1030         return;
1031 
<a name="26" id="anc26"></a><span class="line-modified">1032     forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType);</span>
1033 }
1034 
1035 static AST::UnnamedType* getUnnamedType(ResolvingType&amp; resolvingType)
1036 {
1037     return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; type) -&gt; AST::UnnamedType* {
1038         return type.ptr();
1039     }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; type) -&gt; AST::UnnamedType* {
1040         // FIXME: If the type isn&#39;t committed, should we just commit() it now?
1041         return type-&gt;resolvableType().maybeResolvedType();
1042     }));
1043 }
1044 
1045 void Checker::visit(AST::DereferenceExpression&amp; dereferenceExpression)
1046 {
1047     auto pointerInfo = recurseAndGetInfo(dereferenceExpression.pointer());
1048     if (!pointerInfo)
1049         return;
1050 
1051     auto* unnamedType = getUnnamedType(pointerInfo-&gt;resolvingType);
1052 
1053     auto* pointerType = ([&amp;](AST::UnnamedType* unnamedType) -&gt; AST::PointerType* {
1054         if (!unnamedType)
1055             return nullptr;
1056         auto&amp; unifyNode = unnamedType-&gt;unifyNode();
1057         if (!is&lt;AST::UnnamedType&gt;(unifyNode))
1058             return nullptr;
1059         auto&amp; unnamedUnifyType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
1060         if (!is&lt;AST::PointerType&gt;(unnamedUnifyType))
1061             return nullptr;
1062         return &amp;downcast&lt;AST::PointerType&gt;(unnamedUnifyType);
1063     })(unnamedType);
1064     if (!pointerType) {
1065         setError(Error(&quot;Cannot dereference a non-pointer type.&quot;, dereferenceExpression.codeLocation()));
1066         return;
1067     }
1068 
1069     assignConcreteType(dereferenceExpression, pointerType-&gt;elementType(), AST::LeftValue { pointerType-&gt;addressSpace() });
1070 }
1071 
1072 void Checker::visit(AST::MakePointerExpression&amp; makePointerExpression)
1073 {
1074     auto leftValueInfo = recurseAndGetInfo(makePointerExpression.leftValue(), true);
1075     if (!leftValueInfo)
1076         return;
1077 
1078     auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();
1079     if (!leftAddressSpace) {
1080         setError(Error(&quot;Cannot take the address of a non lvalue.&quot;, makePointerExpression.codeLocation()));
1081         return;
1082     }
1083 
1084     auto* leftValueType = getUnnamedType(leftValueInfo-&gt;resolvingType);
1085     if (!leftValueType) {
1086         setError(Error(&quot;Cannot take the address of a value without a type.&quot;, makePointerExpression.codeLocation()));
1087         return;
1088     }
1089 
1090     assignConcreteType(makePointerExpression, AST::PointerType::create(makePointerExpression.codeLocation(), *leftAddressSpace, *leftValueType));
1091 }
1092 
1093 void Checker::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
1094 {
1095     auto leftValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.leftValue());
1096     if (!leftValueInfo)
1097         return;
1098 
1099     auto* leftValueType = getUnnamedType(leftValueInfo-&gt;resolvingType);
1100     if (!leftValueType) {
1101         setError(Error(&quot;Cannot make an array reference of a value without a type.&quot;, makeArrayReferenceExpression.codeLocation()));
1102         return;
1103     }
1104 
1105     auto&amp; unifyNode = leftValueType-&gt;unifyNode();
1106     if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
1107         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
1108         if (is&lt;AST::PointerType&gt;(unnamedType)) {
1109             auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);
<a name="27" id="anc27"></a><span class="line-removed">1110             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the fact that we&#39;re not targetting the item; we&#39;re targetting the item&#39;s inner element.</span>
1111             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), pointerType.addressSpace(), pointerType.elementType()));
1112             return;
1113         }
1114 
1115         auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();
1116         if (!leftAddressSpace) {
1117             setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));
1118             return;
1119         }
1120 
1121         if (is&lt;AST::ArrayType&gt;(unnamedType)) {
1122             auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);
1123             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the number of elements.
1124             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, arrayType.type()));
1125             return;
1126         }
1127     }
1128 
1129     auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();
1130     if (!leftAddressSpace) {
1131         setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));
1132         return;
1133     }
1134 
1135     assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, *leftValueType));
1136 }
1137 
<a name="28" id="anc28"></a><span class="line-modified">1138 RefPtr&lt;AST::UnnamedType&gt; Checker::argumentTypeForAndOverload(AST::UnnamedType&amp; baseType, AST::AddressSpace addressSpace)</span>
<span class="line-removed">1139 {</span>
<span class="line-removed">1140     AndOverloadTypeKey key { baseType, addressSpace };</span>
<span class="line-removed">1141     {</span>
<span class="line-removed">1142         auto iter = m_andOverloadTypeMap.find(key);</span>
<span class="line-removed">1143         if (iter != m_andOverloadTypeMap.end())</span>
<span class="line-removed">1144             return iter-&gt;value;</span>
<span class="line-removed">1145     }</span>
<span class="line-removed">1146 </span>
<span class="line-removed">1147     auto createArgumentType = [&amp;] () -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-removed">1148         auto&amp; unifyNode = baseType.unifyNode();</span>
<span class="line-removed">1149         if (is&lt;AST::NamedType&gt;(unifyNode)) {</span>
<span class="line-removed">1150             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-removed">1151             return { AST::PointerType::create(namedType.codeLocation(), addressSpace, AST::TypeReference::wrap(namedType.codeLocation(), namedType)) };</span>
<span class="line-removed">1152         }</span>
<span class="line-removed">1153 </span>
<span class="line-removed">1154         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-removed">1155 </span>
<span class="line-removed">1156         if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))</span>
<span class="line-removed">1157             return &amp;unnamedType;</span>
<span class="line-removed">1158 </span>
<span class="line-removed">1159         if (is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-removed">1160             return { AST::ArrayReferenceType::create(unnamedType.codeLocation(), addressSpace, downcast&lt;AST::ArrayType&gt;(unnamedType).type()) };</span>
<span class="line-removed">1161 </span>
<span class="line-removed">1162         if (is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="line-removed">1163             return nullptr;</span>
<span class="line-removed">1164 </span>
<span class="line-removed">1165         return { AST::PointerType::create(unnamedType.codeLocation(), addressSpace, unnamedType) };</span>
<span class="line-removed">1166     };</span>
<span class="line-removed">1167 </span>
<span class="line-removed">1168     auto result = createArgumentType();</span>
<span class="line-removed">1169     m_andOverloadTypeMap.add(key, result);</span>
<span class="line-removed">1170     return result;</span>
<span class="line-removed">1171 }</span>
<span class="line-removed">1172 </span>
<span class="line-removed">1173 void Checker::finishVisiting(AST::PropertyAccessExpression&amp; propertyAccessExpression, ResolvingType* additionalArgumentType)</span>
1174 {
<a name="29" id="anc29"></a><span class="line-modified">1175     auto baseInfo = recurseAndGetInfo(propertyAccessExpression.base());</span>
1176     if (!baseInfo)
1177         return;
<a name="30" id="anc30"></a>
1178     auto baseUnnamedType = commit(baseInfo-&gt;resolvingType);
1179     if (!baseUnnamedType) {
<a name="31" id="anc31"></a><span class="line-modified">1180         setError(Error(&quot;Cannot resolve the type of the base of a property access expression.&quot;, propertyAccessExpression.codeLocation()));</span>
1181         return;
1182     }
1183 
<a name="32" id="anc32"></a><span class="line-modified">1184     AST::FunctionDeclaration* getterFunction = nullptr;</span>
<span class="line-modified">1185     RefPtr&lt;AST::UnnamedType&gt; getterReturnType = nullptr;</span>
<span class="line-modified">1186     {</span>
<span class="line-modified">1187         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; getterArgumentTypes { baseInfo-&gt;resolvingType };</span>
<span class="line-modified">1188         if (additionalArgumentType)</span>
<span class="line-modified">1189             getterArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-modified">1190         auto getterName = propertyAccessExpression.getterFunctionName();</span>
<span class="line-removed">1191         getterFunction = resolveFunction(getterArgumentTypes, getterName, propertyAccessExpression.codeLocation());</span>
<span class="line-removed">1192         if (hasError())</span>
1193             return;
<a name="33" id="anc33"></a><span class="line-removed">1194         if (getterFunction)</span>
<span class="line-removed">1195             getterReturnType = &amp;getterFunction-&gt;type();</span>
<span class="line-removed">1196     }</span>
<span class="line-removed">1197 </span>
<span class="line-removed">1198     AST::FunctionDeclaration* anderFunction = nullptr;</span>
<span class="line-removed">1199     RefPtr&lt;AST::UnnamedType&gt; anderReturnType = nullptr;</span>
<span class="line-removed">1200     auto leftAddressSpace = baseInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-removed">1201     if (leftAddressSpace) {</span>
<span class="line-removed">1202         if (auto argumentTypeForAndOverload = this-&gt;argumentTypeForAndOverload(*baseUnnamedType, *leftAddressSpace)) {</span>
<span class="line-removed">1203             ResolvingType argumentType = { Ref&lt;AST::UnnamedType&gt;(*argumentTypeForAndOverload) };</span>
<span class="line-removed">1204             Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; anderArgumentTypes { argumentType };</span>
<span class="line-removed">1205             if (additionalArgumentType)</span>
<span class="line-removed">1206                 anderArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-removed">1207             auto anderName = propertyAccessExpression.anderFunctionName();</span>
<span class="line-removed">1208             anderFunction = resolveFunction(anderArgumentTypes, anderName, propertyAccessExpression.codeLocation());</span>
<span class="line-removed">1209             if (hasError())</span>
<span class="line-removed">1210                 return;</span>
<span class="line-removed">1211             if (anderFunction)</span>
<span class="line-removed">1212                 anderReturnType = &amp;downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer</span>
1213         }
<a name="34" id="anc34"></a><span class="line-modified">1214     }</span>
<span class="line-modified">1215 </span>
<span class="line-modified">1216     AST::FunctionDeclaration* threadAnderFunction = nullptr;</span>
<span class="line-modified">1217     RefPtr&lt;AST::UnnamedType&gt; threadAnderReturnType = nullptr;</span>
<span class="line-modified">1218     if (auto argumentTypeForAndOverload = this-&gt;argumentTypeForAndOverload(*baseUnnamedType, AST::AddressSpace::Thread)) {</span>
<span class="line-modified">1219         ResolvingType argumentType = { Ref&lt;AST::UnnamedType&gt;(AST::PointerType::create(propertyAccessExpression.codeLocation(), AST::AddressSpace::Thread, *baseUnnamedType)) };</span>
<span class="line-modified">1220         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; threadAnderArgumentTypes { argumentType };</span>
<span class="line-removed">1221         if (additionalArgumentType)</span>
<span class="line-removed">1222             threadAnderArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-removed">1223         auto anderName = propertyAccessExpression.anderFunctionName();</span>
<span class="line-removed">1224         threadAnderFunction = resolveFunction(threadAnderArgumentTypes, anderName, propertyAccessExpression.codeLocation());</span>
<span class="line-removed">1225         if (hasError())</span>
1226             return;
<a name="35" id="anc35"></a><span class="line-modified">1227         if (threadAnderFunction)</span>
<span class="line-modified">1228             threadAnderReturnType = &amp;downcast&lt;AST::PointerType&gt;(threadAnderFunction-&gt;type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer</span>
<span class="line-modified">1229     }</span>
<span class="line-modified">1230 </span>
<span class="line-modified">1231     if (leftAddressSpace &amp;&amp; !anderFunction &amp;&amp; !getterFunction) {</span>
<span class="line-modified">1232         setError(Error(&quot;Property access instruction must either have an ander or a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-removed">1233         return;</span>
<span class="line-removed">1234     }</span>
1235 
<a name="36" id="anc36"></a><span class="line-modified">1236     if (!leftAddressSpace &amp;&amp; !threadAnderFunction &amp;&amp; !getterFunction) {</span>
<span class="line-modified">1237         setError(Error(&quot;Property access instruction must either have a thread ander or a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-modified">1238         return;</span>
<span class="line-modified">1239     }</span>

















1240 
<a name="37" id="anc37"></a><span class="line-modified">1241     if (threadAnderFunction &amp;&amp; getterFunction) {</span>
<span class="line-modified">1242         setError(Error(&quot;Cannot have both a thread ander and a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-modified">1243         return;</span>
<span class="line-modified">1244     }</span>


1245 
<a name="38" id="anc38"></a><span class="line-modified">1246     if (anderFunction &amp;&amp; threadAnderFunction &amp;&amp; !matches(*anderReturnType, *threadAnderReturnType)) {</span>
<span class="line-modified">1247         setError(Error(&quot;Return type of ander must match the return type of the thread ander.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-modified">1248         return;</span>

1249     }
1250 
<a name="39" id="anc39"></a><span class="line-modified">1251     if (getterFunction &amp;&amp; anderFunction &amp;&amp; !matches(*getterReturnType, *anderReturnType)) {</span>
<span class="line-modified">1252         setError(Error(&quot;Return type of ander must match the return type of the getter.&quot;, propertyAccessExpression.codeLocation()));</span>
1253         return;
<a name="40" id="anc40"></a><span class="line-removed">1254     }</span>
1255 
<a name="41" id="anc41"></a><span class="line-modified">1256     if (getterFunction &amp;&amp; threadAnderFunction &amp;&amp; !matches(*getterReturnType, *threadAnderReturnType)) {</span>
<span class="line-modified">1257         setError(Error(&quot;Return type of the thread ander must match the return type of the getter.&quot;, propertyAccessExpression.codeLocation()));</span>

1258         return;
1259     }
1260 
<a name="42" id="anc42"></a><span class="line-modified">1261     Ref&lt;AST::UnnamedType&gt; fieldType = getterReturnType ? *getterReturnType : anderReturnType ? *anderReturnType : *threadAnderReturnType;</span>
<span class="line-modified">1262 </span>
<span class="line-modified">1263     AST::FunctionDeclaration* setterFunction = nullptr;</span>
<span class="line-modified">1264     AST::UnnamedType* setterReturnType = nullptr;</span>
<span class="line-modified">1265     {</span>
<span class="line-modified">1266         ResolvingType fieldResolvingType(fieldType.copyRef());</span>
<span class="line-modified">1267         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; setterArgumentTypes { baseInfo-&gt;resolvingType };</span>
<span class="line-modified">1268         if (additionalArgumentType)</span>
<span class="line-modified">1269             setterArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-modified">1270         setterArgumentTypes.append(fieldResolvingType);</span>
<span class="line-modified">1271         auto setterName = propertyAccessExpression.setterFunctionName();</span>
<span class="line-modified">1272         setterFunction = resolveFunction(setterArgumentTypes, setterName, propertyAccessExpression.codeLocation());</span>
<span class="line-modified">1273         if (hasError())</span>









1274             return;
<a name="43" id="anc43"></a><span class="line-modified">1275         if (setterFunction)</span>
<span class="line-modified">1276             setterReturnType = &amp;setterFunction-&gt;type();</span>
<span class="line-modified">1277     }</span>
<span class="line-removed">1278 </span>
<span class="line-removed">1279     if (setterFunction &amp;&amp; !getterFunction) {</span>
<span class="line-removed">1280         setError(Error(&quot;Cannot define a setter function without a corresponding getter.&quot;, propertyAccessExpression.codeLocation()));</span>
1281         return;
1282     }
<a name="44" id="anc44"></a><span class="line-removed">1283 </span>
<span class="line-removed">1284     propertyAccessExpression.setGetterFunction(getterFunction);</span>
<span class="line-removed">1285     propertyAccessExpression.setAnderFunction(anderFunction);</span>
<span class="line-removed">1286     propertyAccessExpression.setThreadAnderFunction(threadAnderFunction);</span>
<span class="line-removed">1287     propertyAccessExpression.setSetterFunction(setterFunction);</span>
<span class="line-removed">1288 </span>
<span class="line-removed">1289     AST::TypeAnnotation typeAnnotation = AST::RightValue();</span>
<span class="line-removed">1290     if (auto leftAddressSpace = baseInfo-&gt;typeAnnotation.leftAddressSpace()) {</span>
<span class="line-removed">1291         if (anderFunction)</span>
<span class="line-removed">1292             typeAnnotation = AST::LeftValue { downcast&lt;AST::ReferenceType&gt;(anderFunction-&gt;type()).addressSpace() };</span>
<span class="line-removed">1293         else if (setterFunction)</span>
<span class="line-removed">1294             typeAnnotation = AST::AbstractLeftValue();</span>
<span class="line-removed">1295     } else if (!baseInfo-&gt;typeAnnotation.isRightValue() &amp;&amp; (setterFunction || threadAnderFunction))</span>
<span class="line-removed">1296         typeAnnotation = AST::AbstractLeftValue();</span>
<span class="line-removed">1297     assignConcreteType(propertyAccessExpression, WTFMove(fieldType), WTFMove(typeAnnotation));</span>
<span class="line-removed">1298 }</span>
<span class="line-removed">1299 </span>
<span class="line-removed">1300 void Checker::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-removed">1301 {</span>
<span class="line-removed">1302     finishVisiting(dotExpression);</span>
<span class="line-removed">1303 }</span>
<span class="line-removed">1304 </span>
<span class="line-removed">1305 void Checker::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-removed">1306 {</span>
<span class="line-removed">1307     auto baseInfo = recurseAndGetInfo(indexExpression.indexExpression());</span>
<span class="line-removed">1308     if (!baseInfo)</span>
<span class="line-removed">1309         return;</span>
<span class="line-removed">1310     finishVisiting(indexExpression, &amp;baseInfo-&gt;resolvingType);</span>
1311 }
1312 
1313 void Checker::visit(AST::VariableReference&amp; variableReference)
1314 {
1315     ASSERT(variableReference.variable());
1316     ASSERT(variableReference.variable()-&gt;type());
1317 
1318     assignConcreteType(variableReference, *variableReference.variable()-&gt;type(), AST::LeftValue { AST::AddressSpace::Thread });
1319 }
1320 
1321 void Checker::visit(AST::Return&amp; returnStatement)
1322 {
1323     if (returnStatement.value()) {
1324         auto valueInfo = recurseAndGetInfo(*returnStatement.value());
1325         if (!valueInfo)
1326             return;
1327         if (!matchAndCommit(valueInfo-&gt;resolvingType, m_currentFunction-&gt;type()))
1328             setError(Error(&quot;Type of the return value must match the return type of the function.&quot;, returnStatement.codeLocation()));
1329         return;
1330     }
1331 
1332     if (!matches(m_currentFunction-&gt;type(), m_intrinsics.voidType()))
1333         setError(Error(&quot;Cannot return a value from a void function.&quot;, returnStatement.codeLocation()));
1334 }
1335 
1336 void Checker::visit(AST::PointerType&amp;)
1337 {
1338     // Following pointer types can cause infinite loops because of data structures
1339     // like linked lists.
1340     // FIXME: Make sure this function should be empty
1341 }
1342 
1343 void Checker::visit(AST::ArrayReferenceType&amp;)
1344 {
1345     // Following array reference types can cause infinite loops because of data
1346     // structures like linked lists.
1347     // FIXME: Make sure this function should be empty
1348 }
1349 
1350 void Checker::visit(AST::IntegerLiteral&amp; integerLiteral)
1351 {
1352     assignType(integerLiteral, adoptRef(*new ResolvableTypeReference(integerLiteral.type())));
1353 }
1354 
1355 void Checker::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
1356 {
1357     assignType(unsignedIntegerLiteral, adoptRef(*new ResolvableTypeReference(unsignedIntegerLiteral.type())));
1358 }
1359 
1360 void Checker::visit(AST::FloatLiteral&amp; floatLiteral)
1361 {
1362     assignType(floatLiteral, adoptRef(*new ResolvableTypeReference(floatLiteral.type())));
1363 }
1364 
<a name="45" id="anc45"></a><span class="line-removed">1365 void Checker::visit(AST::NullLiteral&amp; nullLiteral)</span>
<span class="line-removed">1366 {</span>
<span class="line-removed">1367     assignType(nullLiteral, adoptRef(*new ResolvableTypeReference(nullLiteral.type())));</span>
<span class="line-removed">1368 }</span>
<span class="line-removed">1369 </span>
1370 void Checker::visit(AST::BooleanLiteral&amp; booleanLiteral)
1371 {
1372     assignConcreteType(booleanLiteral, AST::TypeReference::wrap(booleanLiteral.codeLocation(), m_intrinsics.boolType()));
1373 }
1374 
1375 void Checker::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
1376 {
1377     ASSERT(enumerationMemberLiteral.enumerationDefinition());
1378     auto&amp; enumerationDefinition = *enumerationMemberLiteral.enumerationDefinition();
1379     assignConcreteType(enumerationMemberLiteral, AST::TypeReference::wrap(enumerationMemberLiteral.codeLocation(), enumerationDefinition));
1380 }
1381 
1382 bool Checker::isBoolType(ResolvingType&amp; resolvingType)
1383 {
1384     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; bool {
1385         return matches(left, m_intrinsics.boolType());
1386     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; bool {
1387         return static_cast&lt;bool&gt;(matchAndCommit(m_intrinsics.boolType(), left-&gt;resolvableType()));
1388     }));
1389 }
1390 
1391 bool Checker::recurseAndRequireBoolType(AST::Expression&amp; expression)
1392 {
1393     auto expressionInfo = recurseAndGetInfo(expression);
1394     if (!expressionInfo)
1395         return false;
1396     if (!isBoolType(expressionInfo-&gt;resolvingType)) {
1397         setError(Error(&quot;Expected bool type from expression.&quot;, expression.codeLocation()));
1398         return false;
1399     }
1400     return true;
1401 }
1402 
1403 void Checker::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
1404 {
1405     if (!recurseAndRequireBoolType(logicalNotExpression.operand()))
1406         return;
1407     assignConcreteType(logicalNotExpression, AST::TypeReference::wrap(logicalNotExpression.codeLocation(), m_intrinsics.boolType()));
1408 }
1409 
1410 void Checker::visit(AST::LogicalExpression&amp; logicalExpression)
1411 {
1412     if (!recurseAndRequireBoolType(logicalExpression.left()))
1413         return;
1414     if (!recurseAndRequireBoolType(logicalExpression.right()))
1415         return;
1416     assignConcreteType(logicalExpression, AST::TypeReference::wrap(logicalExpression.codeLocation(), m_intrinsics.boolType()));
1417 }
1418 
1419 void Checker::visit(AST::IfStatement&amp; ifStatement)
1420 {
1421     if (!recurseAndRequireBoolType(ifStatement.conditional()))
1422         return;
1423     checkErrorAndVisit(ifStatement.body());
1424     if (ifStatement.elseBody())
1425         checkErrorAndVisit(*ifStatement.elseBody());
1426 }
1427 
1428 void Checker::visit(AST::WhileLoop&amp; whileLoop)
1429 {
1430     if (!recurseAndRequireBoolType(whileLoop.conditional()))
1431         return;
1432     checkErrorAndVisit(whileLoop.body());
1433 }
1434 
1435 void Checker::visit(AST::DoWhileLoop&amp; doWhileLoop)
1436 {
1437     checkErrorAndVisit(doWhileLoop.body());
1438     recurseAndRequireBoolType(doWhileLoop.conditional());
1439 }
1440 
1441 void Checker::visit(AST::ForLoop&amp; forLoop)
1442 {
1443     checkErrorAndVisit(forLoop.initialization());
1444     if (hasError())
1445         return;
1446     if (forLoop.condition()) {
1447         if (!recurseAndRequireBoolType(*forLoop.condition()))
1448             return;
1449     }
1450     if (forLoop.increment())
1451         checkErrorAndVisit(*forLoop.increment());
1452     checkErrorAndVisit(forLoop.body());
1453 }
1454 
1455 void Checker::visit(AST::SwitchStatement&amp; switchStatement)
1456 {
1457     auto* valueType = ([&amp;]() -&gt; AST::NamedType* {
1458         auto valueInfo = recurseAndGetInfo(switchStatement.value());
1459         if (!valueInfo)
1460             return nullptr;
1461         auto* valueType = getUnnamedType(valueInfo-&gt;resolvingType);
1462         if (!valueType)
1463             return nullptr;
1464         auto&amp; valueUnifyNode = valueType-&gt;unifyNode();
1465         if (!is&lt;AST::NamedType&gt;(valueUnifyNode))
1466             return nullptr;
1467         auto&amp; valueNamedUnifyNode = downcast&lt;AST::NamedType&gt;(valueUnifyNode);
1468         if (!(is&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode).isInt())
1469             &amp;&amp; !is&lt;AST::EnumerationDefinition&gt;(valueNamedUnifyNode))
1470             return nullptr;
1471         return &amp;valueNamedUnifyNode;
1472     })();
1473     if (!valueType) {
1474         setError(Error(&quot;Invalid type for the expression condition of the switch statement.&quot;, switchStatement.codeLocation()));
1475         return;
1476     }
1477 
1478     bool hasDefault = false;
1479     for (auto&amp; switchCase : switchStatement.switchCases()) {
1480         checkErrorAndVisit(switchCase.block());
1481         if (!switchCase.value()) {
1482             hasDefault = true;
1483             continue;
1484         }
1485         auto success = switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) -&gt; bool {
1486             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, integerLiteral.type()));
1487         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; bool {
1488             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));
1489         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) -&gt; bool {
1490             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, floatLiteral.type()));
<a name="46" id="anc46"></a><span class="line-removed">1491         }, [&amp;](AST::NullLiteral&amp; nullLiteral) -&gt; bool {</span>
<span class="line-removed">1492             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, nullLiteral.type()));</span>
1493         }, [&amp;](AST::BooleanLiteral&amp;) -&gt; bool {
1494             return matches(*valueType, m_intrinsics.boolType());
1495         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) -&gt; bool {
1496             ASSERT(enumerationMemberLiteral.enumerationDefinition());
1497             return matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());
1498         }));
1499         if (!success) {
1500             setError(Error(&quot;Invalid type for switch case.&quot;, switchCase.codeLocation()));
1501             return;
1502         }
1503     }
1504 
1505     for (size_t i = 0; i &lt; switchStatement.switchCases().size(); ++i) {
1506         auto&amp; firstCase = switchStatement.switchCases()[i];
1507         for (size_t j = i + 1; j &lt; switchStatement.switchCases().size(); ++j) {
1508             auto&amp; secondCase = switchStatement.switchCases()[j];
1509 
1510             if (static_cast&lt;bool&gt;(firstCase.value()) != static_cast&lt;bool&gt;(secondCase.value()))
1511                 continue;
1512 
1513             if (!static_cast&lt;bool&gt;(firstCase.value())) {
1514                 setError(Error(&quot;Cannot define multiple default cases in switch statement.&quot;, secondCase.codeLocation()));
1515                 return;
1516             }
1517 
1518             auto success = firstCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; firstIntegerLiteral) -&gt; bool {
1519                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) -&gt; bool {
1520                     return firstIntegerLiteral.value() != secondIntegerLiteral.value();
1521                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) -&gt; bool {
1522                     return static_cast&lt;int64_t&gt;(firstIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondUnsignedIntegerLiteral.value());
1523                 }, [](auto&amp;) -&gt; bool {
1524                     return true;
1525                 }));
1526             }, [&amp;](AST::UnsignedIntegerLiteral&amp; firstUnsignedIntegerLiteral) -&gt; bool {
1527                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) -&gt; bool {
1528                     return static_cast&lt;int64_t&gt;(firstUnsignedIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondIntegerLiteral.value());
1529                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) -&gt; bool {
1530                     return firstUnsignedIntegerLiteral.value() != secondUnsignedIntegerLiteral.value();
1531                 }, [](auto&amp;) -&gt; bool {
1532                     return true;
1533                 }));
1534             }, [&amp;](AST::EnumerationMemberLiteral&amp; firstEnumerationMemberLiteral) -&gt; bool {
1535                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; secondEnumerationMemberLiteral) -&gt; bool {
1536                     ASSERT(firstEnumerationMemberLiteral.enumerationMember());
1537                     ASSERT(secondEnumerationMemberLiteral.enumerationMember());
1538                     return firstEnumerationMemberLiteral.enumerationMember() != secondEnumerationMemberLiteral.enumerationMember();
1539                 }, [](auto&amp;) -&gt; bool {
1540                     return true;
1541                 }));
1542             }, [](auto&amp;) -&gt; bool {
1543                 return true;
1544             }));
1545             if (!success) {
1546                 setError(Error(&quot;Cannot define duplicate case statements in a switch.&quot;, secondCase.codeLocation()));
1547                 return;
1548             }
1549         }
1550     }
1551 
1552     if (!hasDefault) {
1553         if (is&lt;AST::NativeTypeDeclaration&gt;(*valueType)) {
1554             HashSet&lt;int64_t&gt; values;
1555             bool zeroValueExists;
1556             for (auto&amp; switchCase : switchStatement.switchCases()) {
1557                 auto value = switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) -&gt; int64_t {
1558                     return integerLiteral.valueForSelectedType();
1559                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; int64_t {
1560                     return unsignedIntegerLiteral.valueForSelectedType();
1561                 }, [](auto&amp;) -&gt; int64_t {
1562                     ASSERT_NOT_REACHED();
1563                     return 0;
1564                 }));
1565                 if (!value)
1566                     zeroValueExists = true;
1567                 else
1568                     values.add(value);
1569             }
1570             bool success = true;
1571             downcast&lt;AST::NativeTypeDeclaration&gt;(*valueType).iterateAllValues([&amp;](int64_t value) -&gt; bool {
1572                 if (!value) {
1573                     if (!zeroValueExists) {
1574                         success = false;
1575                         return true;
1576                     }
1577                     return false;
1578                 }
1579                 if (!values.contains(value)) {
1580                     success = false;
1581                     return true;
1582                 }
1583                 return false;
1584             });
1585             if (!success) {
1586                 setError(Error(&quot;Switch cases must be exhaustive or you must define a default case.&quot;, switchStatement.codeLocation()));
1587                 return;
1588             }
1589         } else {
1590             HashSet&lt;AST::EnumerationMember*&gt; values;
1591             for (auto&amp; switchCase : switchStatement.switchCases()) {
1592                 switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
1593                     ASSERT(enumerationMemberLiteral.enumerationMember());
1594                     values.add(enumerationMemberLiteral.enumerationMember());
1595                 }, [](auto&amp;) {
1596                     ASSERT_NOT_REACHED();
1597                 }));
1598             }
1599             for (auto&amp; enumerationMember : downcast&lt;AST::EnumerationDefinition&gt;(*valueType).enumerationMembers()) {
1600                 if (!values.contains(&amp;enumerationMember.get())) {
1601                     setError(Error(&quot;Switch cases over an enum must be exhaustive or you must define a default case.&quot;, switchStatement.codeLocation()));
1602                     return;
1603                 }
1604             }
1605         }
1606     }
1607 }
1608 
1609 void Checker::visit(AST::CommaExpression&amp; commaExpression)
1610 {
1611     ASSERT(commaExpression.list().size() &gt; 0);
1612     Visitor::visit(commaExpression);
1613     if (hasError())
1614         return;
1615     auto lastInfo = getInfo(commaExpression.list().last());
1616     forwardType(commaExpression, lastInfo-&gt;resolvingType);
1617 }
1618 
1619 void Checker::visit(AST::TernaryExpression&amp; ternaryExpression)
1620 {
1621     auto predicateInfo = recurseAndRequireBoolType(ternaryExpression.predicate());
1622     if (!predicateInfo)
1623         return;
1624 
1625     auto bodyInfo = recurseAndGetInfo(ternaryExpression.bodyExpression());
1626     auto elseInfo = recurseAndGetInfo(ternaryExpression.elseExpression());
1627 
1628     auto resultType = matchAndCommit(bodyInfo-&gt;resolvingType, elseInfo-&gt;resolvingType);
1629     if (!resultType) {
1630         setError(Error(&quot;lhs and rhs of a ternary expression must match.&quot;, ternaryExpression.codeLocation()));
1631         return;
1632     }
1633 
1634     assignConcreteType(ternaryExpression, *resultType);
1635 }
1636 
1637 void Checker::visit(AST::CallExpression&amp; callExpression)
1638 {
1639     Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; types;
1640     types.reserveInitialCapacity(callExpression.arguments().size());
1641     for (auto&amp; argument : callExpression.arguments()) {
1642         auto argumentInfo = recurseAndGetInfo(argument);
1643         if (!argumentInfo)
1644             return;
1645         types.uncheckedAppend(argumentInfo-&gt;resolvingType);
1646     }
1647     // Don&#39;t recurse on the castReturnType, because it&#39;s guaranteed to be a NamedType, which will get visited later.
1648     // We don&#39;t want to recurse to the same node twice.
1649 
1650     auto* function = resolveFunction(types, callExpression.name(), callExpression.codeLocation());
1651     if (hasError())
1652         return;
1653 
1654     if (!function) {
1655         NameContext&amp; nameContext = m_program.nameContext();
1656         auto castTypes = nameContext.getTypes(callExpression.name(), m_currentNameSpace);
1657         if (castTypes.size() == 1) {
1658             AST::NamedType&amp; castType = castTypes[0].get();
1659             function = resolveFunction(types, &quot;operator cast&quot;_str, callExpression.codeLocation(), &amp;castType);
1660             if (hasError())
1661                 return;
1662             if (function)
1663                 callExpression.setCastData(castType);
1664         }
1665     }
1666 
1667     if (!function) {
1668         // FIXME: Add better error messages for why we can&#39;t resolve to one of the overrides.
1669         // https://bugs.webkit.org/show_bug.cgi?id=200133
1670         setError(Error(&quot;Cannot resolve function call to a concrete callee. Make sure you are using compatible types.&quot;, callExpression.codeLocation()));
1671         return;
1672     }
1673 
1674     for (size_t i = 0; i &lt; function-&gt;parameters().size(); ++i) {
1675         if (!matchAndCommit(types[i].get(), *function-&gt;parameters()[i]-&gt;type())) {
1676             setError(Error(makeString(&quot;Invalid type for parameter number &quot;, i + 1, &quot; in function call.&quot;), callExpression.codeLocation()));
1677             return;
1678         }
1679     }
1680 
1681     callExpression.setFunction(*function);
1682 
1683     assignConcreteType(callExpression, function-&gt;type());
1684 }
1685 
1686 Expected&lt;void, Error&gt; check(Program&amp; program)
1687 {
1688     Checker checker(program.intrinsics(), program);
1689     checker.checkErrorAndVisit(program);
1690     if (checker.hasError())
1691         return checker.result();
1692     return checker.assignTypes();
1693 }
1694 
1695 } // namespace WHLSL
1696 
1697 } // namespace WebCore
1698 
1699 #endif // ENABLE(WEBGPU)
<a name="47" id="anc47"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="47" type="hidden" />
</body>
</html>
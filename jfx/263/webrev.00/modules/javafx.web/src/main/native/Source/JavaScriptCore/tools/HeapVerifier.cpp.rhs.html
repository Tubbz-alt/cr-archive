<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/HeapVerifier.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;HeapVerifier.h&quot;
 28 
<a name="1" id="anc1"></a><span class="line-added"> 29 #include &quot;ButterflyInlines.h&quot;</span>
 30 #include &quot;CodeBlockInlines.h&quot;
 31 #include &quot;HeapIterationScope.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;JSObject.h&quot;
 34 #include &quot;MarkedSpaceInlines.h&quot;
 35 #include &quot;VMInspector.h&quot;
 36 #include &quot;ValueProfile.h&quot;
 37 #include &lt;wtf/ProcessID.h&gt;
 38 
 39 namespace JSC {
 40 
 41 HeapVerifier::HeapVerifier(Heap* heap, unsigned numberOfGCCyclesToRecord)
 42     : m_heap(heap)
 43     , m_currentCycle(0)
 44     , m_numberOfCycles(numberOfGCCyclesToRecord)
 45 {
 46     RELEASE_ASSERT(m_numberOfCycles &gt; 0);
 47     m_cycles = makeUniqueArray&lt;GCCycle&gt;(m_numberOfCycles);
 48 }
 49 
 50 const char* HeapVerifier::phaseName(HeapVerifier::Phase phase)
 51 {
 52     switch (phase) {
 53     case Phase::BeforeGC:
 54         return &quot;BeforeGC&quot;;
 55     case Phase::BeforeMarking:
 56         return &quot;BeforeMarking&quot;;
 57     case Phase::AfterMarking:
 58         return &quot;AfterMarking&quot;;
 59     case Phase::AfterGC:
 60         return &quot;AfterGC&quot;;
 61     }
 62     RELEASE_ASSERT_NOT_REACHED();
 63     return nullptr; // Silencing a compiler warning.
 64 }
 65 
 66 void HeapVerifier::startGC()
 67 {
 68     Heap* heap = m_heap;
 69     incrementCycle();
 70     currentCycle().reset();
 71     currentCycle().scope = *heap-&gt;collectionScope();
 72     currentCycle().timestamp = MonotonicTime::now();
 73     ASSERT(!m_didPrintLogs);
 74 }
 75 
 76 void HeapVerifier::endGC()
 77 {
 78     if (m_didPrintLogs) {
 79         dataLog(&quot;END &quot;);
 80         printVerificationHeader();
 81         dataLog(&quot;\n\n&quot;);
 82         m_didPrintLogs = false;
 83     }
 84 }
 85 
 86 void HeapVerifier::gatherLiveCells(HeapVerifier::Phase phase)
 87 {
 88     Heap* heap = m_heap;
 89     CellList&amp; list = *cellListForGathering(phase);
 90 
 91     list.reset();
 92     heap-&gt;m_objectSpace.forEachLiveCell([&amp;list] (HeapCell* cell, HeapCell::Kind kind) {
 93         list.add({ cell, kind, CellProfile::Live });
 94         return IterationStatus::Continue;
 95     });
 96 }
 97 
 98 CellList* HeapVerifier::cellListForGathering(HeapVerifier::Phase phase)
 99 {
100     switch (phase) {
101     case Phase::BeforeMarking:
102         return &amp;currentCycle().before;
103     case Phase::AfterMarking:
104         return &amp;currentCycle().after;
105     case Phase::BeforeGC:
106     case Phase::AfterGC:
107         // We should not be gathering live cells during these phases.
108         break;
109     }
110     RELEASE_ASSERT_NOT_REACHED();
111     return nullptr; // Silencing a compiler warning.
112 }
113 
114 static void trimDeadCellsFromList(CellList&amp; knownLiveSet, CellList&amp; list)
115 {
116     if (!list.size())
117         return;
118 
119     for (auto&amp; cellProfile : list.cells()) {
120         if (cellProfile.isDead())
121             continue; // Don&#39;t &quot;resurrect&quot; known dead cells.
122         if (!knownLiveSet.find(cellProfile.cell())) {
123             cellProfile.setIsDead();
124             continue;
125         }
126         cellProfile.setIsLive();
127     }
128 }
129 
130 void HeapVerifier::trimDeadCells()
131 {
132     CellList&amp; knownLiveSet = currentCycle().after;
133 
134     trimDeadCellsFromList(knownLiveSet, currentCycle().before);
135 
136     for (int i = -1; i &gt; -m_numberOfCycles; i--) {
137         trimDeadCellsFromList(knownLiveSet, cycleForIndex(i).before);
138         trimDeadCellsFromList(knownLiveSet, cycleForIndex(i).after);
139     }
140 }
141 
142 void HeapVerifier::printVerificationHeader()
143 {
144     RELEASE_ASSERT(m_heap-&gt;collectionScope());
145     CollectionScope scope = currentCycle().scope;
146     MonotonicTime gcCycleTimestamp = currentCycle().timestamp;
147     dataLog(&quot;Verifying heap in [p&quot;, getCurrentProcessID(), &quot;, &quot;, Thread::current(), &quot;] vm &quot;,
148         RawPointer(&amp;m_heap-&gt;vm()), &quot; on &quot;, scope, &quot; GC @ &quot;, gcCycleTimestamp, &quot;\n&quot;);
149 }
150 
151 bool HeapVerifier::verifyCellList(Phase phase, CellList&amp; list)
152 {
153     VM&amp; vm = m_heap-&gt;vm();
154     auto&amp; liveCells = list.cells();
155 
156     bool listNamePrinted = false;
157     auto printHeaderIfNeeded = scopedLambda&lt;void()&gt;([&amp;] () {
158         if (listNamePrinted)
159             return;
160 
161         printVerificationHeader();
162         dataLog(&quot; @ phase &quot;, phaseName(phase), &quot;: FAILED in cell list &#39;&quot;, list.name(), &quot;&#39; (size &quot;, liveCells.size(), &quot;)\n&quot;);
163         listNamePrinted = true;
164         m_didPrintLogs = true;
165     });
166 
167     bool success = true;
168     for (size_t i = 0; i &lt; liveCells.size(); i++) {
169         CellProfile&amp; profile = liveCells[i];
170         if (!profile.isLive())
171             continue;
172 
173         if (!profile.isJSCell())
174             continue;
175 
176         JSCell* cell = profile.jsCell();
177         success |= validateJSCell(&amp;vm, cell, &amp;profile, &amp;list, printHeaderIfNeeded, &quot;  &quot;);
178     }
179 
180     return success;
181 }
182 
183 bool HeapVerifier::validateCell(HeapCell* cell, VM* expectedVM)
184 {
185     auto printNothing = scopedLambda&lt;void()&gt;([] () { });
186 
187     if (cell-&gt;isZapped()) {
188         dataLog(&quot;    cell &quot;, RawPointer(cell), &quot; is ZAPPED\n&quot;);
189         return false;
190     }
191 
192     if (!isJSCellKind(cell-&gt;cellKind()))
193         return true; // Nothing more to validate.
194 
195     JSCell* jsCell = static_cast&lt;JSCell*&gt;(cell);
196     return validateJSCell(expectedVM, jsCell, nullptr, nullptr, printNothing);
197 }
198 
199 bool HeapVerifier::validateJSCell(VM* expectedVM, JSCell* cell, CellProfile* profile, CellList* list, const ScopedLambda&lt;void()&gt;&amp; printHeaderIfNeeded, const char* prefix)
200 {
201     auto printHeaderAndCell = [cell, profile, &amp;printHeaderIfNeeded, prefix] () {
202         printHeaderIfNeeded();
203         dataLog(prefix, &quot;cell &quot;, RawPointer(cell));
204         if (profile)
205             dataLog(&quot; [&quot;, profile-&gt;className(), &quot;]&quot;);
206     };
207 
208     // 1. Validate the cell.
209 
210     if (cell-&gt;isZapped()) {
211         printHeaderAndCell();
212         dataLog(&quot; is zapped\n&quot;);
213         return false;
214     }
215 
216     StructureID structureID = cell-&gt;structureID();
217     if (!structureID) {
218         printHeaderAndCell();
219         dataLog(&quot; has NULL structureID\n&quot;);
220         return false;
221     }
222 
223     if (expectedVM) {
224         VM&amp; vm = *expectedVM;
225 
226         VM* cellVM = &amp;cell-&gt;vm();
227         if (cellVM != expectedVM) {
228             printHeaderAndCell();
229             dataLog(&quot; is from a different VM: expected:&quot;, RawPointer(expectedVM), &quot; actual:&quot;, RawPointer(cellVM), &quot;\n&quot;);
230             return false;
231         }
232 
233         // 2. Validate the cell&#39;s structure
234 
235         Structure* structure = vm.getStructure(structureID);
236         if (!structure) {
237             printHeaderAndCell();
238 #if USE(JSVALUE64)
239             uint32_t structureIDAsUint32 = structureID;
240 #else
241             uint32_t structureIDAsUint32 = reinterpret_cast&lt;uint32_t&gt;(structureID);
242 #endif
243             dataLog(&quot; with structureID &quot;, structureIDAsUint32, &quot; maps to a NULL Structure pointer\n&quot;);
244             return false;
245         }
246 
247         if (structure-&gt;isZapped()) {
248             printHeaderAndCell();
249             dataLog(&quot; has ZAPPED structure &quot;, RawPointer(structure), &quot;\n&quot;);
250             return false;
251         }
252 
253         if (!structure-&gt;structureID()) {
254             printHeaderAndCell();
255             dataLog(&quot; has structure &quot;, RawPointer(structure), &quot; whose structureID is NULL\n&quot;);
256             return false;
257         }
258 
259         VM* structureVM = &amp;structure-&gt;vm();
260         if (structureVM != expectedVM) {
261             printHeaderAndCell();
262             dataLog(&quot; has structure &quot;, RawPointer(structure), &quot; from a different VM: expected:&quot;, RawPointer(expectedVM), &quot; actual:&quot;, RawPointer(structureVM), &quot;\n&quot;);
263             return false;
264         }
265 
266         if (list) {
267             auto* structureProfile = list-&gt;find(structure);
268             if (!structureProfile) {
269                 printHeaderAndCell();
270                 dataLog(&quot; has structure &quot;, RawPointer(structure), &quot; NOT found in the live cell list\n&quot;);
271                 return false;
272             }
273 
274             if (!structureProfile-&gt;isLive()) {
275                 printHeaderAndCell();
276                 dataLog(&quot; has DEAD structure &quot;, RawPointer(structure), &quot;\n&quot;);
277                 return false;
278             }
279         }
280 
281         StructureID structureStructureID = structure-&gt;structureID();
282         if (!structureStructureID) {
283             printHeaderAndCell();
284             dataLog(&quot; has structure &quot;, RawPointer(structure), &quot; with a NULL structureID\n&quot;);
285             return false;
286         }
287 
288         // 3. Validate the cell&#39;s structure&#39;s structure.
289 
290         Structure* structureStructure = vm.getStructure(structureID);
291         if (!structureStructure) {
292             printHeaderAndCell();
293             dataLog(&quot; has structure &quot;, RawPointer(structure), &quot; whose structure is NULL\n&quot;);
294             return false;
295         }
296 
297         if (structureStructure-&gt;isZapped()) {
298             printHeaderAndCell();
299             dataLog(&quot; has structure &quot;, RawPointer(structure), &quot; whose structure &quot;, RawPointer(structureStructure), &quot; is ZAPPED\n&quot;);
300             return false;
301         }
302 
303         if (!structureStructure-&gt;structureID()) {
304             printHeaderAndCell();
305             dataLog(&quot; has structure &quot;, RawPointer(structure), &quot; whose structure &quot;, RawPointer(structureStructure), &quot; has a NULL structureID\n&quot;);
306             return false;
307         }
308 
309         VM* structureStructureVM = &amp;structureStructure-&gt;vm();
310         if (structureStructureVM != expectedVM) {
311             printHeaderAndCell();
312             dataLog(&quot; has structure &quot;, RawPointer(structure), &quot; whose structure &quot;, RawPointer(structureStructure), &quot; is from a different VM: expected:&quot;, RawPointer(expectedVM), &quot; actual:&quot;, RawPointer(structureStructureVM), &quot;\n&quot;);
313             return false;
314         }
315 
316         if (list) {
317             auto* structureStructureProfile = list-&gt;find(structureStructure);
318             if (!structureStructureProfile) {
319                 printHeaderAndCell();
320                 dataLog(&quot; has structure &quot;, RawPointer(structure), &quot; whose structure &quot;, RawPointer(structureStructure), &quot; is NOT found in the live cell list\n&quot;);
321                 return false;
322             }
323 
324             if (!structureStructureProfile-&gt;isLive()) {
325                 printHeaderAndCell();
326                 dataLog(&quot; has structure &quot;, RawPointer(structure), &quot; whose structure &quot;, RawPointer(structureStructure), &quot; is DEAD\n&quot;);
327                 return false;
328             }
329         }
330 
331         CodeBlock* codeBlock = jsDynamicCast&lt;CodeBlock*&gt;(vm, cell);
332         if (UNLIKELY(codeBlock)) {
333             bool success = true;
334             codeBlock-&gt;forEachValueProfile([&amp;](ValueProfile&amp; valueProfile, bool) {
335                 for (unsigned i = 0; i &lt; ValueProfile::totalNumberOfBuckets; ++i) {
336                     JSValue value = JSValue::decode(valueProfile.m_buckets[i]);
337                     if (!value)
338                         continue;
339                     if (!value.isCell())
340                         continue;
341                     JSCell* valueCell = value.asCell();
342                     if (valueCell-&gt;isZapped()) {
343                         printHeaderIfNeeded();
344                         dataLog(prefix, &quot;CodeBlock &quot;, RawPointer(codeBlock), &quot; has ZAPPED ValueProfile cell &quot;, RawPointer(valueCell), &quot;\n&quot;);
345                         success = false;
346                         continue;
347                     }
348                 }
349             });
350             if (!success)
351                 return false;
352         }
353     }
354 
355     return true;
356 }
357 
358 void HeapVerifier::verify(HeapVerifier::Phase phase)
359 {
360     if (phase == Phase::AfterGC) {
361         bool verified = verifyCellList(phase, currentCycle().after);
362         RELEASE_ASSERT(verified);
363     }
364 }
365 
366 void HeapVerifier::reportCell(CellProfile&amp; profile, int cycleIndex, HeapVerifier::GCCycle&amp; cycle, CellList&amp; list, const char* prefix)
367 {
368     HeapCell* cell = profile.cell();
369     VM&amp; vm = m_heap-&gt;vm();
370 
371     if (prefix)
372         dataLog(prefix);
373 
374     dataLog(&quot;FOUND&quot;);
375     if (profile.isLive())
376         dataLog(&quot; LIVE&quot;);
377     else if (profile.isDead())
378         dataLog(&quot; DEAD&quot;);
379 
380     if (!profile.isJSCell())
381         dataLog(&quot; HeapCell &quot;);
382     else
383         dataLog(&quot; JSCell &quot;);
384     dataLog(RawPointer(cell));
385 
386     if (profile.className())
387         dataLog(&quot; [&quot;, profile.className(), &quot;]&quot;);
388 
389     if (profile.isLive() &amp;&amp; profile.isJSCell()) {
390         JSCell* jsCell = profile.jsCell();
391         Structure* structure = jsCell-&gt;structure(vm);
392         dataLog(&quot; structure:&quot;, RawPointer(structure));
393         if (jsCell-&gt;isObject()) {
394             JSObject* obj = static_cast&lt;JSObject*&gt;(cell);
395             Butterfly* butterfly = obj-&gt;butterfly();
396             void* butterflyBase = butterfly-&gt;base(structure);
397 
398             dataLog(&quot; butterfly:&quot;, RawPointer(butterfly), &quot; (base:&quot;, RawPointer(butterflyBase), &quot;)&quot;);
399         }
400     }
401 
402     dataLog(&quot; in &quot;, cycle.scope, &quot; GC[&quot;, cycleIndex, &quot;] in &#39;&quot;, list.name(), &quot;&#39; list in VM &quot;,
403         RawPointer(&amp;vm), &quot; recorded at time &quot;, profile.timestamp(), &quot;\n&quot;);
404     if (profile.stackTrace())
405         dataLog(*profile.stackTrace());
406 }
407 
408 void HeapVerifier::checkIfRecorded(HeapCell* cell)
409 {
410     bool found = false;
411     const char* const prefix = &quot;  &quot;;
<a name="2" id="anc2"></a><span class="line-modified">412     static constexpr bool verbose = true;</span>
413 
414     for (int cycleIndex = 0; cycleIndex &gt; -m_numberOfCycles; cycleIndex--) {
415         GCCycle&amp; cycle = cycleForIndex(cycleIndex);
416         CellList* lists[] = { &amp;cycle.before, &amp;cycle.after };
417 
418         if (verbose)
419             dataLog(&quot;Checking &quot;, cycle.scope, &quot; GC&lt;&quot;, cycle.timestamp, &quot;&gt;, cycle [&quot;, cycleIndex, &quot;]:\n&quot;);
420 
421         const char* resultPrefix = &quot;    &quot;;
422         for (auto* list : lists) {
423             if (verbose)
424                 dataLog(prefix, &quot;Cycle [&quot;, cycleIndex, &quot;] &#39;&quot;, list-&gt;name(), &quot;&#39; list: &quot;);
425 
426             CellProfile* profile = list-&gt;find(cell);
427             if (profile) {
428                 reportCell(*profile, cycleIndex, cycle, *list, resultPrefix);
429                 found = true;
430             } else if (verbose)
431                 dataLog(resultPrefix, &quot;cell NOT found\n&quot;);
432         }
433     }
434 
435     if (!found)
436         dataLog(prefix, &quot;cell &quot;, RawPointer(cell), &quot; NOT FOUND\n&quot;);
437 }
438 
439 // The following are slower but more robust versions of the corresponding functions of the same name.
440 // These robust versions are designed so that we can call them interactively from a C++ debugger
441 // to query if a candidate is recorded cell.
442 
443 void HeapVerifier::checkIfRecorded(uintptr_t candidateCell)
444 {
445     HeapCell* candidateHeapCell = reinterpret_cast&lt;HeapCell*&gt;(candidateCell);
446 
447     VMInspector&amp; inspector = VMInspector::instance();
448     auto expectedLocker = inspector.lock(Seconds(2));
449     if (!expectedLocker) {
450         ASSERT(expectedLocker.error() == VMInspector::Error::TimedOut);
451         dataLog(&quot;ERROR: Timed out while waiting to iterate VMs.&quot;);
452         return;
453     }
454 
455     auto&amp; locker = expectedLocker.value();
456     inspector.iterate(locker, [&amp;] (VM&amp; vm) {
457         if (!vm.heap.m_verifier)
458             return VMInspector::FunctorStatus::Continue;
459 
460         auto* verifier = vm.heap.m_verifier.get();
461         dataLog(&quot;Search for cell &quot;, RawPointer(candidateHeapCell), &quot; in VM &quot;, RawPointer(&amp;vm), &quot;:\n&quot;);
462         verifier-&gt;checkIfRecorded(candidateHeapCell);
463         return VMInspector::FunctorStatus::Continue;
464     });
465 }
466 
467 } // namespace JSC
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
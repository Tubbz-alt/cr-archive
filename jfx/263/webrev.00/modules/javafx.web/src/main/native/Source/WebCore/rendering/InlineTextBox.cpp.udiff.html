<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineTextBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineFlowBox.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineTextBox.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineTextBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,18 +22,22 @@</span>
  
  #include &quot;config.h&quot;
  #include &quot;InlineTextBox.h&quot;
  
  #include &quot;BreakLines.h&quot;
<span class="udiff-line-added">+ #include &quot;CompositionHighlight.h&quot;</span>
  #include &quot;DashArray.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;DocumentMarkerController.h&quot;
  #include &quot;Editor.h&quot;
<span class="udiff-line-added">+ #include &quot;ElementRuleCollector.h&quot;</span>
  #include &quot;EllipsisBox.h&quot;
  #include &quot;EventRegion.h&quot;
<span class="udiff-line-added">+ #include &quot;FloatRoundedRect.h&quot;</span>
  #include &quot;Frame.h&quot;
  #include &quot;GraphicsContext.h&quot;
<span class="udiff-line-added">+ #include &quot;HighlightMap.h&quot;</span>
  #include &quot;HitTestResult.h&quot;
  #include &quot;ImageBuffer.h&quot;
  #include &quot;InlineTextBoxStyle.h&quot;
  #include &quot;MarkedText.h&quot;
  #include &quot;Page.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -44,10 +48,12 @@</span>
  #include &quot;RenderRubyRun.h&quot;
  #include &quot;RenderRubyText.h&quot;
  #include &quot;RenderTheme.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;RenderedDocumentMarker.h&quot;
<span class="udiff-line-added">+ #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;SelectionRangeData.h&quot;</span>
  #include &quot;Text.h&quot;
  #include &quot;TextDecorationPainter.h&quot;
  #include &quot;TextPaintStyle.h&quot;
  #include &quot;TextPainter.h&quot;
  #include &lt;stdio.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -150,34 +156,16 @@</span>
      return clampedOffset(startPosition) &lt; clampedOffset(endPosition);
  }
  
  RenderObject::SelectionState InlineTextBox::selectionState()
  {
<span class="udiff-line-modified-removed">-     RenderObject::SelectionState state = renderer().selectionState();</span>
<span class="udiff-line-removed">-     if (state == RenderObject::SelectionStart || state == RenderObject::SelectionEnd || state == RenderObject::SelectionBoth) {</span>
<span class="udiff-line-removed">-         auto&amp; selection = renderer().view().selection();</span>
<span class="udiff-line-removed">-         auto startPos = selection.startPosition();</span>
<span class="udiff-line-removed">-         auto endPos = selection.endPosition();</span>
<span class="udiff-line-removed">-         // The position after a hard line break is considered to be past its end.</span>
<span class="udiff-line-removed">-         ASSERT(start() + len() &gt;= (isLineBreak() ? 1 : 0));</span>
<span class="udiff-line-removed">-         unsigned lastSelectable = start() + len() - (isLineBreak() ? 1 : 0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         bool start = (state != RenderObject::SelectionEnd &amp;&amp; startPos &gt;= m_start &amp;&amp; startPos &lt; m_start + m_len);</span>
<span class="udiff-line-removed">-         bool end = (state != RenderObject::SelectionStart &amp;&amp; endPos &gt; m_start &amp;&amp; endPos &lt;= lastSelectable);</span>
<span class="udiff-line-removed">-         if (start &amp;&amp; end)</span>
<span class="udiff-line-removed">-             state = RenderObject::SelectionBoth;</span>
<span class="udiff-line-removed">-         else if (start)</span>
<span class="udiff-line-removed">-             state = RenderObject::SelectionStart;</span>
<span class="udiff-line-removed">-         else if (end)</span>
<span class="udiff-line-removed">-             state = RenderObject::SelectionEnd;</span>
<span class="udiff-line-removed">-         else if ((state == RenderObject::SelectionEnd || startPos &lt; m_start) &amp;&amp;</span>
<span class="udiff-line-removed">-                  (state == RenderObject::SelectionStart || endPos &gt; lastSelectable))</span>
<span class="udiff-line-removed">-             state = RenderObject::SelectionInside;</span>
<span class="udiff-line-removed">-         else if (state == RenderObject::SelectionBoth)</span>
<span class="udiff-line-removed">-             state = RenderObject::SelectionNone;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     auto state = verifySelectionState(renderer().selectionState(), renderer().view().selection());</span>
  
<span class="udiff-line-added">+     // FIXME: this code mutates selection state, but it&#39;s used at a simple getter elsewhere</span>
<span class="udiff-line-added">+     // in this file. This code should likely live in SelectionRangeData, or somewhere else.</span>
<span class="udiff-line-added">+     // &lt;rdar://problem/58125978&gt;</span>
<span class="udiff-line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=205528</span>
      // If there are ellipsis following, make sure their selection is updated.
      if (m_truncation != cNoTruncation &amp;&amp; root().ellipsisBox()) {
          EllipsisBox* ellipsis = root().ellipsisBox();
          if (state != RenderObject::SelectionNone) {
              auto [selectionStart, selectionEnd] = selectionStartEnd();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -192,15 +180,66 @@</span>
      }
  
      return state;
  }
  
<span class="udiff-line-added">+ RenderObject::SelectionState InlineTextBox::verifySelectionState(RenderObject::SelectionState state, SelectionRangeData&amp; selection) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (state == RenderObject::SelectionStart || state == RenderObject::SelectionEnd || state == RenderObject::SelectionBoth) {</span>
<span class="udiff-line-added">+         auto startOffset = selection.startOffset();</span>
<span class="udiff-line-added">+         auto endOffset = selection.endOffset();</span>
<span class="udiff-line-added">+         // The position after a hard line break is considered to be past its end.</span>
<span class="udiff-line-added">+         ASSERT(start() + len() &gt;= (isLineBreak() ? 1 : 0));</span>
<span class="udiff-line-added">+         unsigned lastSelectable = start() + len() - (isLineBreak() ? 1 : 0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         bool start = (state != RenderObject::SelectionEnd &amp;&amp; startOffset &gt;= m_start &amp;&amp; startOffset &lt; m_start + m_len);</span>
<span class="udiff-line-added">+         bool end = (state != RenderObject::SelectionStart &amp;&amp; endOffset &gt; m_start &amp;&amp; endOffset &lt;= lastSelectable);</span>
<span class="udiff-line-added">+         if (start &amp;&amp; end)</span>
<span class="udiff-line-added">+             state = RenderObject::SelectionBoth;</span>
<span class="udiff-line-added">+         else if (start)</span>
<span class="udiff-line-added">+             state = RenderObject::SelectionStart;</span>
<span class="udiff-line-added">+         else if (end)</span>
<span class="udiff-line-added">+             state = RenderObject::SelectionEnd;</span>
<span class="udiff-line-added">+         else if ((state == RenderObject::SelectionEnd || startOffset &lt; m_start)</span>
<span class="udiff-line-added">+             &amp;&amp; (state == RenderObject::SelectionStart || endOffset &gt; lastSelectable))</span>
<span class="udiff-line-added">+             state = RenderObject::SelectionInside;</span>
<span class="udiff-line-added">+         else if (state == RenderObject::SelectionBoth)</span>
<span class="udiff-line-added">+             state = RenderObject::SelectionNone;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return state;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  inline const FontCascade&amp; InlineTextBox::lineFont() const
  {
      return combinedText() ? combinedText()-&gt;textCombineFont() : lineStyle().fontCascade();
  }
  
<span class="udiff-line-added">+ LayoutRect snappedSelectionRect(const LayoutRect&amp; selectionRect, float logicalRight, float selectionTop, float selectionHeight, bool isHorizontal)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto snappedSelectionRect = enclosingIntRect(selectionRect);</span>
<span class="udiff-line-added">+     LayoutUnit logicalWidth = snappedSelectionRect.width();</span>
<span class="udiff-line-added">+     if (snappedSelectionRect.x() &gt; logicalRight)</span>
<span class="udiff-line-added">+         logicalWidth = 0;</span>
<span class="udiff-line-added">+     else if (snappedSelectionRect.maxX() &gt; logicalRight)</span>
<span class="udiff-line-added">+         logicalWidth = logicalRight - snappedSelectionRect.x();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     LayoutPoint topPoint;</span>
<span class="udiff-line-added">+     LayoutUnit width;</span>
<span class="udiff-line-added">+     LayoutUnit height;</span>
<span class="udiff-line-added">+     if (isHorizontal) {</span>
<span class="udiff-line-added">+         topPoint = LayoutPoint { snappedSelectionRect.x(), selectionTop };</span>
<span class="udiff-line-added">+         width = logicalWidth;</span>
<span class="udiff-line-added">+         height = selectionHeight;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+         topPoint = LayoutPoint { selectionTop, snappedSelectionRect.x() };</span>
<span class="udiff-line-added">+         width = selectionHeight;</span>
<span class="udiff-line-added">+         height = logicalWidth;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return LayoutRect { topPoint, LayoutSize { width, height } };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // FIXME: Share more code with paintMarkedTextBackground().
  LayoutRect InlineTextBox::localSelectionRect(unsigned startPos, unsigned endPos) const
  {
      unsigned sPos = clampedOffset(startPos);
      unsigned ePos = clampedOffset(endPos);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -217,22 +256,11 @@</span>
      // Avoid measuring the text when the entire line box is selected as an optimization.
      if (sPos || ePos != textRun.length())
          lineFont().adjustSelectionRectForText(textRun, selectionRect, sPos, ePos);
      // FIXME: The computation of the snapped selection rect differs from the computation of this rect
      // in paintMarkedTextBackground(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=138913&gt;.
<span class="udiff-line-modified-removed">-     IntRect snappedSelectionRect = enclosingIntRect(selectionRect);</span>
<span class="udiff-line-removed">-     LayoutUnit logicalWidth = snappedSelectionRect.width();</span>
<span class="udiff-line-removed">-     if (snappedSelectionRect.x() &gt; logicalRight())</span>
<span class="udiff-line-removed">-         logicalWidth  = 0;</span>
<span class="udiff-line-removed">-     else if (snappedSelectionRect.maxX() &gt; logicalRight())</span>
<span class="udiff-line-removed">-         logicalWidth = logicalRight() - snappedSelectionRect.x();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     LayoutPoint topPoint = isHorizontal() ? LayoutPoint(snappedSelectionRect.x(), selectionTop) : LayoutPoint(selectionTop, snappedSelectionRect.x());</span>
<span class="udiff-line-removed">-     LayoutUnit width = isHorizontal() ? logicalWidth : selectionHeight;</span>
<span class="udiff-line-removed">-     LayoutUnit height = isHorizontal() ? selectionHeight : logicalWidth;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return LayoutRect(topPoint, LayoutSize(width, height));</span>
<span class="udiff-line-modified-added">+     return snappedSelectionRect(selectionRect, logicalRight(), selectionTop, selectionHeight, isHorizontal());</span>
  }
  
  void InlineTextBox::deleteLine()
  {
      renderer().removeTextBox(*this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -522,10 +550,13 @@</span>
      if (paintInfo.phase != PaintPhase::Selection &amp;&amp; paintInfo.phase != PaintPhase::TextClip &amp;&amp; !isPrinting) {
          if (containsComposition &amp;&amp; !useCustomUnderlines)
              paintCompositionBackground(paintInfo, boxOrigin);
  
          Vector&lt;MarkedText&gt; markedTexts = collectMarkedTextsForDocumentMarkers(TextPaintPhase::Background);
<span class="udiff-line-added">+         auto highlightMarkedTexts = collectMarkedTextsForHighlights(TextPaintPhase::Background);</span>
<span class="udiff-line-added">+         if (!highlightMarkedTexts.isEmpty())</span>
<span class="udiff-line-added">+             markedTexts.appendVector(WTFMove(highlightMarkedTexts));</span>
  #if ENABLE(TEXT_SELECTION)
          if (haveSelection &amp;&amp; !useCustomUnderlines &amp;&amp; !context.paintingDisabled()) {
              auto selectionMarkedText = createMarkedTextFromSelectionInBox(*this);
              if (!selectionMarkedText.isEmpty())
                  markedTexts.append(WTFMove(selectionMarkedText));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -552,13 +583,16 @@</span>
      // 2. Now paint the foreground, including text and decorations like underline/overline (in quirks mode only).
      bool shouldPaintSelectionForeground = haveSelection &amp;&amp; !useCustomUnderlines;
      Vector&lt;MarkedText&gt; markedTexts;
      if (paintInfo.phase != PaintPhase::Selection) {
          // The marked texts for the gaps between document markers and selection are implicitly created by subdividing the entire line.
<span class="udiff-line-modified-removed">-         markedTexts.append({ clampedOffset(m_start), clampedOffset(end() + 1), MarkedText::Unmarked });</span>
<span class="udiff-line-modified-added">+         markedTexts.append({ clampedOffset(m_start), clampedOffset(end()), MarkedText::Unmarked });</span>
          if (!isPrinting) {
              markedTexts.appendVector(collectMarkedTextsForDocumentMarkers(TextPaintPhase::Foreground));
<span class="udiff-line-added">+             auto highlightMarkedTexts = collectMarkedTextsForHighlights(TextPaintPhase::Foreground);</span>
<span class="udiff-line-added">+             if (!highlightMarkedTexts.isEmpty())</span>
<span class="udiff-line-added">+                 markedTexts.appendVector(WTFMove(highlightMarkedTexts));</span>
  
              bool shouldPaintDraggedContent = !(paintInfo.paintBehavior.contains(PaintBehavior::ExcludeSelection));
              if (shouldPaintDraggedContent) {
                  auto markedTextsForDraggedContent = collectMarkedTextsForDraggedContent();
                  if (!markedTextsForDraggedContent.isEmpty()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -650,25 +684,40 @@</span>
              offset += lineStyle().hyphenString().length();
      }
      return offset;
  }
  
<span class="udiff-line-modified-removed">- std::pair&lt;unsigned, unsigned&gt; InlineTextBox::selectionStartEnd() const</span>
<span class="udiff-line-modified-added">+ std::pair&lt;unsigned, unsigned&gt; InlineTextBox::clampedStartEndForState(unsigned start, unsigned end, RenderObject::SelectionState selectionState) const</span>
  {
<span class="udiff-line-removed">-     auto selectionState = renderer().selectionState();</span>
      if (selectionState == RenderObject::SelectionInside)
          return { 0, clampedOffset(m_start + m_len) };
  
<span class="udiff-line-removed">-     auto start = renderer().view().selection().startPosition();</span>
<span class="udiff-line-removed">-     auto end = renderer().view().selection().endPosition();</span>
      if (selectionState == RenderObject::SelectionStart)
          end = renderer().text().length();
      else if (selectionState == RenderObject::SelectionEnd)
          start = 0;
      return { clampedOffset(start), clampedOffset(end) };
  }
  
<span class="udiff-line-added">+ std::pair&lt;unsigned, unsigned&gt; InlineTextBox::selectionStartEnd() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto selectionState = renderer().selectionState();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return clampedStartEndForState(renderer().view().selection().startOffset(), renderer().view().selection().endOffset(), selectionState);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ std::pair&lt;unsigned, unsigned&gt; InlineTextBox::highlightStartEnd(SelectionRangeData &amp;rangeData) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto state = rangeData.selectionStateForRenderer(renderer());</span>
<span class="udiff-line-added">+     state = verifySelectionState(state, rangeData);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (state == RenderObject::SelectionNone)</span>
<span class="udiff-line-added">+         return {0, 0};</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return clampedStartEndForState(rangeData.startOffset(), rangeData.endOffset(), state);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  bool InlineTextBox::hasMarkers() const
  {
      return collectMarkedTextsForDocumentMarkers(TextPaintPhase::Decoration).size();
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -695,11 +744,11 @@</span>
      auto fontSize = std::min(std::max(font.size(), 10.0f), 40.0f);
      auto y = ascent + 0.11035 * fontSize;
      auto height = 0.13247 * fontSize;
  
      // Avoid measuring the text when the entire line box is selected as an optimization.
<span class="udiff-line-modified-removed">-     if (markedText.startOffset || markedText.endOffset != clampedOffset(end() + 1)) {</span>
<span class="udiff-line-modified-added">+     if (markedText.startOffset || markedText.endOffset != clampedOffset(end())) {</span>
          TextRun run = createTextRun();
          LayoutRect selectionRect = LayoutRect(0, y, 0, height);
          lineFont().adjustSelectionRectForText(run, selectionRect, markedText.startOffset, markedText.endOffset);
          return selectionRect;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -768,10 +817,26 @@</span>
  #endif
      case MarkedText::GrammarError:
      case MarkedText::SpellingError:
      case MarkedText::Unmarked:
          break;
<span class="udiff-line-added">+     case MarkedText::Highlight:</span>
<span class="udiff-line-added">+         if (auto renderStyle = parent()-&gt;renderer().getUncachedPseudoStyle({ PseudoId::Highlight, markedText.highlightName }, &amp;parent()-&gt;renderer().style())) {</span>
<span class="udiff-line-added">+             style.backgroundColor = renderStyle-&gt;backgroundColor();</span>
<span class="udiff-line-added">+             style.textStyles.fillColor = renderStyle-&gt;computedStrokeColor();</span>
<span class="udiff-line-added">+             style.textStyles.strokeColor = renderStyle-&gt;computedStrokeColor();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             auto color = renderStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyWebkitTextFillColor);</span>
<span class="udiff-line-added">+             auto decorationStyle = renderStyle-&gt;textDecorationStyle();</span>
<span class="udiff-line-added">+             auto decorations = renderStyle-&gt;textDecorationsInEffect();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (decorations.containsAny({ TextDecoration::Underline, TextDecoration::Overline, TextDecoration::LineThrough })) {</span>
<span class="udiff-line-added">+                 style.textDecorationStyles.underlineColor = color;</span>
<span class="udiff-line-added">+                 style.textDecorationStyles.underlineStyle = decorationStyle;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         break;</span>
      case MarkedText::DraggedContent:
          style.alpha = 0.25;
          break;
      case MarkedText::Selection: {
          style.textStyles = computeTextSelectionPaintStyle(style.textStyles, renderer(), lineStyle(), paintInfo, style.textShadow);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -930,11 +995,11 @@</span>
              // Marker is completely before this run. This might be a marker that sits before the
              // first run we draw, or markers that were within runs we skipped due to truncation.
              continue;
          }
  
<span class="udiff-line-modified-removed">-         if (marker-&gt;startOffset() &gt; end()) {</span>
<span class="udiff-line-modified-added">+         if (marker-&gt;startOffset() &gt;= end()) {</span>
              // Marker is completely after this run, bail. A later run will paint it.
              break;
          }
  
          // Marker intersects this run. Collect it.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -961,10 +1026,49 @@</span>
          }
      }
      return markedTexts;
  }
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ Vector&lt;MarkedText&gt; InlineTextBox::collectMarkedTextsForHighlights(TextPaintPhase phase) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!RuntimeEnabledFeatures::sharedFeatures().highlightAPIEnabled())</span>
<span class="udiff-line-added">+         return { };</span>
<span class="udiff-line-added">+     ASSERT_ARG(phase, phase == TextPaintPhase::Background || phase == TextPaintPhase::Foreground || phase == TextPaintPhase::Decoration);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(phase);</span>
<span class="udiff-line-added">+     if (!renderer().textNode())</span>
<span class="udiff-line-added">+         return { };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Vector&lt;MarkedText&gt; markedTexts;</span>
<span class="udiff-line-added">+     auto&amp; parentRenderer = parent()-&gt;renderer();</span>
<span class="udiff-line-added">+     auto&amp; parentStyle = parentRenderer.style();</span>
<span class="udiff-line-added">+     for (auto&amp; highlight : renderer().document().highlightMap().map()) {</span>
<span class="udiff-line-added">+         auto renderStyle = parentRenderer.getUncachedPseudoStyle({ PseudoId::Highlight, highlight.key }, &amp;parentStyle);</span>
<span class="udiff-line-added">+         if (!renderStyle)</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+         for (auto&amp; rangeData : highlight.value-&gt;rangesData()) {</span>
<span class="udiff-line-added">+             if (rangeData-&gt;startPosition &amp;&amp; rangeData-&gt;endPosition) {</span>
<span class="udiff-line-added">+                 Position startPos = rangeData-&gt;startPosition.value();</span>
<span class="udiff-line-added">+                 Position endPos = rangeData-&gt;endPosition.value();</span>
<span class="udiff-line-added">+                 RenderObject* startRenderer = startPos.deprecatedNode()-&gt;renderer();</span>
<span class="udiff-line-added">+                 int startOffset = startPos.deprecatedEditingOffset();</span>
<span class="udiff-line-added">+                 RenderObject* endRenderer = endPos.deprecatedNode()-&gt;renderer();</span>
<span class="udiff-line-added">+                 int endOffset = endPos.deprecatedEditingOffset();</span>
<span class="udiff-line-added">+                 ASSERT(startOffset &gt;= 0 &amp;&amp; endOffset &gt;= 0);</span>
<span class="udiff-line-added">+                 if (!startRenderer || !endRenderer)</span>
<span class="udiff-line-added">+                     continue;</span>
<span class="udiff-line-added">+                 auto highlightData = SelectionRangeData(renderer().view());</span>
<span class="udiff-line-added">+                 highlightData.setContext({startRenderer, endRenderer, static_cast&lt;unsigned&gt;(startOffset), static_cast&lt;unsigned&gt;(endOffset)});</span>
<span class="udiff-line-added">+                 auto [highlightStart, highlightEnd] = highlightStartEnd(highlightData);</span>
<span class="udiff-line-added">+                 if (highlightStart &lt; highlightEnd)</span>
<span class="udiff-line-added">+                     markedTexts.append({ highlightStart, highlightEnd, MarkedText::Highlight, nullptr, highlight.key });</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return markedTexts;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  FloatPoint InlineTextBox::textOriginFromBoxRect(const FloatRect&amp; boxRect) const
  {
      FloatPoint textOrigin { boxRect.x(), boxRect.y() + lineFont().fontMetrics().ascent() };
      if (auto* combinedText = this-&gt;combinedText()) {
          if (auto newOrigin = combinedText-&gt;computeTextOrigin(boxRect))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1120,11 +1224,27 @@</span>
          context.concatCTM(rotation(boxRect, Counterclockwise));
  }
  
  void InlineTextBox::paintCompositionBackground(PaintInfo&amp; paintInfo, const FloatPoint&amp; boxOrigin)
  {
<span class="udiff-line-modified-removed">-     paintMarkedTextBackground(paintInfo, boxOrigin, Color::compositionFill, clampedOffset(renderer().frame().editor().compositionStart()), clampedOffset(renderer().frame().editor().compositionEnd()));</span>
<span class="udiff-line-modified-added">+     if (!renderer().frame().editor().compositionUsesCustomHighlights()) {</span>
<span class="udiff-line-added">+         paintMarkedTextBackground(paintInfo, boxOrigin, Color::compositionFill, clampedOffset(renderer().frame().editor().compositionStart()), clampedOffset(renderer().frame().editor().compositionEnd()));</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (auto&amp; highlight : renderer().frame().editor().customCompositionHighlights()) {</span>
<span class="udiff-line-added">+         if (highlight.endOffset &lt;= m_start)</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (highlight.startOffset &gt;= end())</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         paintMarkedTextBackground(paintInfo, boxOrigin, highlight.color, clampedOffset(highlight.startOffset), clampedOffset(highlight.endOffset));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (highlight.endOffset &gt; end())</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+     }</span>
  }
  
  void InlineTextBox::paintCompositionUnderlines(PaintInfo&amp; paintInfo, const FloatPoint&amp; boxOrigin) const
  {
      if (m_truncation == cFullTruncation)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1136,17 +1256,17 @@</span>
              // before the first run we draw, or underlines that were within runs we skipped
              // due to truncation.
              continue;
          }
  
<span class="udiff-line-modified-removed">-         if (underline.startOffset &gt; end())</span>
<span class="udiff-line-modified-added">+         if (underline.startOffset &gt;= end())</span>
              break; // Underline is completely after this run, bail. A later run will paint it.
  
          // Underline intersects this run. Paint it.
          paintCompositionUnderline(paintInfo, boxOrigin, underline);
  
<span class="udiff-line-modified-removed">-         if (underline.endOffset &gt; end() + 1)</span>
<span class="udiff-line-modified-added">+         if (underline.endOffset &gt; end())</span>
              break; // Underline also runs into the next run. Bail now, no more marker advancement.
      }
  }
  
  static inline void mirrorRTLSegment(float logicalWidth, TextDirection direction, float&amp; start, float width)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1163,11 +1283,11 @@</span>
  
      float start = 0; // start of line to draw, relative to tx
      float width = logicalWidth(); // how much line to draw
      bool useWholeWidth = true;
      unsigned paintStart = m_start;
<span class="udiff-line-modified-removed">-     unsigned paintEnd = end() + 1; // end points at the last char, not past it</span>
<span class="udiff-line-modified-added">+     unsigned paintEnd = end();</span>
      if (paintStart &lt;= underline.startOffset) {
          paintStart = underline.startOffset;
          useWholeWidth = false;
          start = renderer().width(m_start, paintStart - m_start, textPos(), isFirstLine());
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1302,11 +1422,11 @@</span>
          leadingBehavior = ForbidLeadingExpansion;
  
      ExpansionBehavior trailingBehavior;
      if (forceTrailingExpansion())
          trailingBehavior = ForceTrailingExpansion;
<span class="udiff-line-modified-removed">-     else if (expansion() &amp;&amp; nextLeafChild() &amp;&amp; !nextLeafChild()-&gt;isLineBreak())</span>
<span class="udiff-line-modified-added">+     else if (expansion() &amp;&amp; nextLeafOnLine() &amp;&amp; !nextLeafOnLine()-&gt;isLineBreak())</span>
          trailingBehavior = AllowTrailingExpansion;
      else
          trailingBehavior = ForbidTrailingExpansion;
  
      return leadingBehavior | trailingBehavior;
</pre>
<center><a href="InlineFlowBox.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineTextBox.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
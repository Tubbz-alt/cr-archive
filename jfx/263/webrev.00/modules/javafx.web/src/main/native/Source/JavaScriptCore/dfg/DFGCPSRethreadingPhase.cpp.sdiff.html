<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCPSRethreadingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGCFGSimplificationPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCSEPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCPSRethreadingPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 37 
 38 class CPSRethreadingPhase : public Phase {
 39 public:
 40     CPSRethreadingPhase(Graph&amp; graph)
 41         : Phase(graph, &quot;CPS rethreading&quot;)
 42     {
 43     }
 44 
 45     bool run()
 46     {
 47         RELEASE_ASSERT(m_graph.m_refCountState == EverythingIsLive);
 48 
 49         if (m_graph.m_form == ThreadedCPS)
 50             return false;
 51 
 52         clearIsLoadedFrom();
 53         freeUnnecessaryNodes();
 54         m_graph.clearReplacements();
 55         canonicalizeLocalsInBlocks();
 56         specialCaseArguments();
<span class="line-modified"> 57         propagatePhis&lt;LocalOperand&gt;();</span>
<span class="line-modified"> 58         propagatePhis&lt;ArgumentOperand&gt;();</span>

 59         computeIsFlushed();
 60 
 61         m_graph.m_form = ThreadedCPS;
 62         return true;
 63     }
 64 
 65 private:
 66 
 67     void clearIsLoadedFrom()
 68     {
 69         for (unsigned i = 0; i &lt; m_graph.m_variableAccessData.size(); ++i)
 70             m_graph.m_variableAccessData[i].setIsLoadedFrom(false);
 71     }
 72 
 73     void freeUnnecessaryNodes()
 74     {
 75         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 76             BasicBlock* block = m_graph.block(blockIndex);
 77             if (!block)
 78                 continue;
</pre>
<hr />
<pre>
194                 // Replace all references to this GetLocal with otherNode.
195                 node-&gt;replaceWith(m_graph, otherNode);
196                 return;
197             }
198 
199             ASSERT(otherNode-&gt;op() == SetLocal);
200             node-&gt;replaceWith(m_graph, otherNode-&gt;child1().node());
201             return;
202         }
203 
204         variable-&gt;setIsLoadedFrom(true);
205         Node* phi = addPhi&lt;operandKind&gt;(node-&gt;origin, variable, idx);
206         node-&gt;children.setChild1(Edge(phi));
207         m_block-&gt;variablesAtHead.atFor&lt;operandKind&gt;(idx) = phi;
208         m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(idx) = node;
209     }
210 
211     void canonicalizeGetLocal(Node* node)
212     {
213         VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">214         if (variable-&gt;local().isArgument())</span>
<span class="line-modified">215             canonicalizeGetLocalFor&lt;ArgumentOperand&gt;(node, variable, variable-&gt;local().toArgument());</span>
<span class="line-modified">216         else</span>
<span class="line-modified">217             canonicalizeGetLocalFor&lt;LocalOperand&gt;(node, variable, variable-&gt;local().toLocal());</span>










218     }
219 
220     template&lt;NodeType nodeType, OperandKind operandKind&gt;
221     void canonicalizeFlushOrPhantomLocalFor(Node* node, VariableAccessData* variable, size_t idx)
222     {
223         ASSERT(!node-&gt;child1());
224 
225         if (Node* otherNode = m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(idx)) {
226             ASSERT(otherNode-&gt;variableAccessData() == variable);
227 
228             switch (otherNode-&gt;op()) {
229             case Flush:
230             case PhantomLocal:
231             case GetLocal:

232                 otherNode = otherNode-&gt;child1().node();
233                 break;
234             default:
235                 break;
236             }
237 
238             ASSERT(otherNode-&gt;op() == Phi || otherNode-&gt;op() == SetLocal || otherNode-&gt;op() == SetArgumentDefinitely || otherNode-&gt;op() == SetArgumentMaybe);
239 
240             if (nodeType == PhantomLocal &amp;&amp; otherNode-&gt;op() == SetLocal) {
241                 // PhantomLocal(SetLocal) doesn&#39;t make sense. PhantomLocal means: at this
242                 // point I know I would have been interested in the value of this variable
243                 // for the purpose of OSR. PhantomLocal(SetLocal) means: at this point I
244                 // know that I would have read the value written by that SetLocal. This is
245                 // redundant and inefficient, since really it just means that we want to
246                 // keep the last MovHinted value of that local alive.
247 
248                 node-&gt;remove(m_graph);
249                 return;
250             }
251 
</pre>
<hr />
<pre>
253             // There is nothing wrong with having redundant Flush&#39;s. It just needs to
254             // be linked appropriately. Note that if there had already been a previous
255             // use at tail then we don&#39;t override it. It&#39;s fine for variablesAtTail to
256             // omit Flushes and PhantomLocals. On the other hand, having it refer to a
257             // Flush or a PhantomLocal if just before it the last use was a GetLocal would
258             // seriously confuse the CFA.
259             node-&gt;children.setChild1(Edge(otherNode));
260             return;
261         }
262 
263         variable-&gt;setIsLoadedFrom(true);
264         node-&gt;children.setChild1(Edge(addPhi&lt;operandKind&gt;(node-&gt;origin, variable, idx)));
265         m_block-&gt;variablesAtHead.atFor&lt;operandKind&gt;(idx) = node;
266         m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(idx) = node;
267     }
268 
269     template&lt;NodeType nodeType&gt;
270     void canonicalizeFlushOrPhantomLocal(Node* node)
271     {
272         VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">273         if (variable-&gt;local().isArgument())</span>
<span class="line-modified">274             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, ArgumentOperand&gt;(node, variable, variable-&gt;local().toArgument());</span>
<span class="line-modified">275         else</span>
<span class="line-modified">276             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, LocalOperand&gt;(node, variable, variable-&gt;local().toLocal());</span>










277     }
278 
279     void canonicalizeSet(Node* node)
280     {
<span class="line-modified">281         m_block-&gt;variablesAtTail.setOperand(node-&gt;local(), node);</span>
282     }
283 
284     void canonicalizeLocalsInBlock()
285     {
286         if (!m_block)
287             return;
288         ASSERT(m_block-&gt;isReachable);
289 
<span class="line-modified">290         clearVariables&lt;ArgumentOperand&gt;();</span>
<span class="line-modified">291         clearVariables&lt;LocalOperand&gt;();</span>

292 
293         // Assumes that all phi references have been removed. Assumes that things that
294         // should be live have a non-zero ref count, but doesn&#39;t assume that the ref
295         // counts are correct beyond that (more formally !!logicalRefCount == !!actualRefCount
296         // but not logicalRefCount == actualRefCount). Assumes that it can break ref
297         // counts.
298 
299         for (auto* node : *m_block) {
300             m_graph.performSubstitution(node);
301 
302             // The rules for threaded CPS form:
303             //
304             // Head variable: describes what is live at the head of the basic block.
305             // Head variable links may refer to Flush, PhantomLocal, Phi, or SetArgumentDefinitely/SetArgumentMaybe.
306             // SetArgumentDefinitely/SetArgumentMaybe may only appear in the root block.
307             //
308             // Tail variable: the last thing that happened to the variable in the block.
309             // It may be a Flush, PhantomLocal, GetLocal, SetLocal, SetArgumentDefinitely/SetArgumentMaybe, or Phi.
310             // SetArgumentDefinitely/SetArgumentMaybe may only appear in the root block. Note that if there ever
311             // was a GetLocal to the variable, and it was followed by PhantomLocals and
</pre>
<hr />
<pre>
371     }
372 
373     void specialCaseArguments()
374     {
375         // Normally, a SetArgumentDefinitely denotes the start of a live range for a local&#39;s value on the stack.
376         // But those SetArguments used for the actual arguments to the machine CodeBlock get
377         // special-cased. We could have instead used two different node types - one for the arguments
378         // at the prologue case, and another for the other uses. But this seemed like IR overkill.
379 
380         for (auto&amp; pair : m_graph.m_rootToArguments) {
381             BasicBlock* entrypoint = pair.key;
382             const ArgumentsVector&amp; arguments = pair.value;
383             for (unsigned i = arguments.size(); i--;)
384                 entrypoint-&gt;variablesAtHead.setArgumentFirstTime(i, arguments[i]);
385         }
386     }
387 
388     template&lt;OperandKind operandKind&gt;
389     void propagatePhis()
390     {
<span class="line-modified">391         Vector&lt;PhiStackEntry, 128&gt;&amp; phiStack = operandKind == ArgumentOperand ? m_argumentPhiStack : m_localPhiStack;</span>
392 
393         // Ensure that attempts to use this fail instantly.
394         m_block = 0;
395 
396         while (!phiStack.isEmpty()) {
397             PhiStackEntry entry = phiStack.last();
398             phiStack.removeLast();
399 
400             BasicBlock* block = entry.m_block;
401             PredecessorList&amp; predecessors = block-&gt;predecessors;
402             Node* currentPhi = entry.m_phi;
403             VariableAccessData* variable = currentPhi-&gt;variableAccessData();
404             size_t index = entry.m_index;
405 
406             for (size_t i = predecessors.size(); i--;) {
407                 BasicBlock* predecessorBlock = predecessors[i];
408 
409                 Node* variableInPrevious = predecessorBlock-&gt;variablesAtTail.atFor&lt;operandKind&gt;(index);
410                 if (!variableInPrevious) {
411                     variableInPrevious = addPhi&lt;operandKind&gt;(predecessorBlock, currentPhi-&gt;origin, variable, index);
</pre>
<hr />
<pre>
449             }
450         }
451     }
452 
453     struct PhiStackEntry {
454         PhiStackEntry(BasicBlock* block, size_t index, Node* phi)
455             : m_block(block)
456             , m_index(index)
457             , m_phi(phi)
458         {
459         }
460 
461         BasicBlock* m_block;
462         size_t m_index;
463         Node* m_phi;
464     };
465 
466     template&lt;OperandKind operandKind&gt;
467     Vector&lt;PhiStackEntry, 128&gt;&amp; phiStackFor()
468     {
<span class="line-modified">469         if (operandKind == ArgumentOperand)</span>
<span class="line-modified">470             return m_argumentPhiStack;</span>
<span class="line-modified">471         return m_localPhiStack;</span>



472     }
473 
474     void computeIsFlushed()
475     {
476         m_graph.clearFlagsOnAllNodes(NodeIsFlushed);
477 
478         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
479             BasicBlock* block = m_graph.block(blockIndex);
480             if (!block)
481                 continue;
482             for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
483                 Node* node = block-&gt;at(nodeIndex);
484                 if (node-&gt;op() != Flush)
485                     continue;
486                 addFlushedLocalOp(node);
487             }
488         }
489         while (!m_flushedLocalOpWorklist.isEmpty()) {
490             Node* node = m_flushedLocalOpWorklist.takeLast();
491             switch (node-&gt;op()) {
</pre>
<hr />
<pre>
504                 DFG_CRASH(m_graph, node, &quot;Invalid node in flush graph&quot;);
505                 break;
506             }
507         }
508     }
509 
510     void addFlushedLocalOp(Node* node)
511     {
512         if (node-&gt;mergeFlags(NodeIsFlushed))
513             m_flushedLocalOpWorklist.append(node);
514     }
515 
516     void addFlushedLocalEdge(Node*, Edge edge)
517     {
518         addFlushedLocalOp(edge.node());
519     }
520 
521     BasicBlock* m_block;
522     Vector&lt;PhiStackEntry, 128&gt; m_argumentPhiStack;
523     Vector&lt;PhiStackEntry, 128&gt; m_localPhiStack;

524     Vector&lt;Node*, 128&gt; m_flushedLocalOpWorklist;
525 };
526 
527 bool performCPSRethreading(Graph&amp; graph)
528 {
529     return runPhase&lt;CPSRethreadingPhase&gt;(graph);
530 }
531 
532 } } // namespace JSC::DFG
533 
534 #endif // ENABLE(DFG_JIT)
535 
</pre>
</td>
<td>
<hr />
<pre>
 37 
 38 class CPSRethreadingPhase : public Phase {
 39 public:
 40     CPSRethreadingPhase(Graph&amp; graph)
 41         : Phase(graph, &quot;CPS rethreading&quot;)
 42     {
 43     }
 44 
 45     bool run()
 46     {
 47         RELEASE_ASSERT(m_graph.m_refCountState == EverythingIsLive);
 48 
 49         if (m_graph.m_form == ThreadedCPS)
 50             return false;
 51 
 52         clearIsLoadedFrom();
 53         freeUnnecessaryNodes();
 54         m_graph.clearReplacements();
 55         canonicalizeLocalsInBlocks();
 56         specialCaseArguments();
<span class="line-modified"> 57         propagatePhis&lt;OperandKind::Local&gt;();</span>
<span class="line-modified"> 58         propagatePhis&lt;OperandKind::Argument&gt;();</span>
<span class="line-added"> 59         propagatePhis&lt;OperandKind::Tmp&gt;();</span>
 60         computeIsFlushed();
 61 
 62         m_graph.m_form = ThreadedCPS;
 63         return true;
 64     }
 65 
 66 private:
 67 
 68     void clearIsLoadedFrom()
 69     {
 70         for (unsigned i = 0; i &lt; m_graph.m_variableAccessData.size(); ++i)
 71             m_graph.m_variableAccessData[i].setIsLoadedFrom(false);
 72     }
 73 
 74     void freeUnnecessaryNodes()
 75     {
 76         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 77             BasicBlock* block = m_graph.block(blockIndex);
 78             if (!block)
 79                 continue;
</pre>
<hr />
<pre>
195                 // Replace all references to this GetLocal with otherNode.
196                 node-&gt;replaceWith(m_graph, otherNode);
197                 return;
198             }
199 
200             ASSERT(otherNode-&gt;op() == SetLocal);
201             node-&gt;replaceWith(m_graph, otherNode-&gt;child1().node());
202             return;
203         }
204 
205         variable-&gt;setIsLoadedFrom(true);
206         Node* phi = addPhi&lt;operandKind&gt;(node-&gt;origin, variable, idx);
207         node-&gt;children.setChild1(Edge(phi));
208         m_block-&gt;variablesAtHead.atFor&lt;operandKind&gt;(idx) = phi;
209         m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(idx) = node;
210     }
211 
212     void canonicalizeGetLocal(Node* node)
213     {
214         VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">215         switch (variable-&gt;operand().kind()) {</span>
<span class="line-modified">216         case OperandKind::Argument: {</span>
<span class="line-modified">217             canonicalizeGetLocalFor&lt;OperandKind::Argument&gt;(node, variable, variable-&gt;operand().toArgument());</span>
<span class="line-modified">218             break;</span>
<span class="line-added">219         }</span>
<span class="line-added">220         case OperandKind::Local: {</span>
<span class="line-added">221             canonicalizeGetLocalFor&lt;OperandKind::Local&gt;(node, variable, variable-&gt;operand().toLocal());</span>
<span class="line-added">222             break;</span>
<span class="line-added">223         }</span>
<span class="line-added">224         case OperandKind::Tmp: {</span>
<span class="line-added">225             canonicalizeGetLocalFor&lt;OperandKind::Tmp&gt;(node, variable, variable-&gt;operand().value());</span>
<span class="line-added">226             break;</span>
<span class="line-added">227         }</span>
<span class="line-added">228         }</span>
229     }
230 
231     template&lt;NodeType nodeType, OperandKind operandKind&gt;
232     void canonicalizeFlushOrPhantomLocalFor(Node* node, VariableAccessData* variable, size_t idx)
233     {
234         ASSERT(!node-&gt;child1());
235 
236         if (Node* otherNode = m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(idx)) {
237             ASSERT(otherNode-&gt;variableAccessData() == variable);
238 
239             switch (otherNode-&gt;op()) {
240             case Flush:
241             case PhantomLocal:
242             case GetLocal:
<span class="line-added">243                 ASSERT(otherNode-&gt;child1().node());</span>
244                 otherNode = otherNode-&gt;child1().node();
245                 break;
246             default:
247                 break;
248             }
249 
250             ASSERT(otherNode-&gt;op() == Phi || otherNode-&gt;op() == SetLocal || otherNode-&gt;op() == SetArgumentDefinitely || otherNode-&gt;op() == SetArgumentMaybe);
251 
252             if (nodeType == PhantomLocal &amp;&amp; otherNode-&gt;op() == SetLocal) {
253                 // PhantomLocal(SetLocal) doesn&#39;t make sense. PhantomLocal means: at this
254                 // point I know I would have been interested in the value of this variable
255                 // for the purpose of OSR. PhantomLocal(SetLocal) means: at this point I
256                 // know that I would have read the value written by that SetLocal. This is
257                 // redundant and inefficient, since really it just means that we want to
258                 // keep the last MovHinted value of that local alive.
259 
260                 node-&gt;remove(m_graph);
261                 return;
262             }
263 
</pre>
<hr />
<pre>
265             // There is nothing wrong with having redundant Flush&#39;s. It just needs to
266             // be linked appropriately. Note that if there had already been a previous
267             // use at tail then we don&#39;t override it. It&#39;s fine for variablesAtTail to
268             // omit Flushes and PhantomLocals. On the other hand, having it refer to a
269             // Flush or a PhantomLocal if just before it the last use was a GetLocal would
270             // seriously confuse the CFA.
271             node-&gt;children.setChild1(Edge(otherNode));
272             return;
273         }
274 
275         variable-&gt;setIsLoadedFrom(true);
276         node-&gt;children.setChild1(Edge(addPhi&lt;operandKind&gt;(node-&gt;origin, variable, idx)));
277         m_block-&gt;variablesAtHead.atFor&lt;operandKind&gt;(idx) = node;
278         m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(idx) = node;
279     }
280 
281     template&lt;NodeType nodeType&gt;
282     void canonicalizeFlushOrPhantomLocal(Node* node)
283     {
284         VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">285         switch (variable-&gt;operand().kind()) {</span>
<span class="line-modified">286         case OperandKind::Argument: {</span>
<span class="line-modified">287             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, OperandKind::Argument&gt;(node, variable, variable-&gt;operand().toArgument());</span>
<span class="line-modified">288             break;</span>
<span class="line-added">289         }</span>
<span class="line-added">290         case OperandKind::Local: {</span>
<span class="line-added">291             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, OperandKind::Local&gt;(node, variable, variable-&gt;operand().toLocal());</span>
<span class="line-added">292             break;</span>
<span class="line-added">293         }</span>
<span class="line-added">294         case OperandKind::Tmp: {</span>
<span class="line-added">295             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, OperandKind::Tmp&gt;(node, variable, variable-&gt;operand().value());</span>
<span class="line-added">296             break;</span>
<span class="line-added">297         }</span>
<span class="line-added">298         }</span>
299     }
300 
301     void canonicalizeSet(Node* node)
302     {
<span class="line-modified">303         m_block-&gt;variablesAtTail.setOperand(node-&gt;operand(), node);</span>
304     }
305 
306     void canonicalizeLocalsInBlock()
307     {
308         if (!m_block)
309             return;
310         ASSERT(m_block-&gt;isReachable);
311 
<span class="line-modified">312         clearVariables&lt;OperandKind::Argument&gt;();</span>
<span class="line-modified">313         clearVariables&lt;OperandKind::Local&gt;();</span>
<span class="line-added">314         clearVariables&lt;OperandKind::Tmp&gt;();</span>
315 
316         // Assumes that all phi references have been removed. Assumes that things that
317         // should be live have a non-zero ref count, but doesn&#39;t assume that the ref
318         // counts are correct beyond that (more formally !!logicalRefCount == !!actualRefCount
319         // but not logicalRefCount == actualRefCount). Assumes that it can break ref
320         // counts.
321 
322         for (auto* node : *m_block) {
323             m_graph.performSubstitution(node);
324 
325             // The rules for threaded CPS form:
326             //
327             // Head variable: describes what is live at the head of the basic block.
328             // Head variable links may refer to Flush, PhantomLocal, Phi, or SetArgumentDefinitely/SetArgumentMaybe.
329             // SetArgumentDefinitely/SetArgumentMaybe may only appear in the root block.
330             //
331             // Tail variable: the last thing that happened to the variable in the block.
332             // It may be a Flush, PhantomLocal, GetLocal, SetLocal, SetArgumentDefinitely/SetArgumentMaybe, or Phi.
333             // SetArgumentDefinitely/SetArgumentMaybe may only appear in the root block. Note that if there ever
334             // was a GetLocal to the variable, and it was followed by PhantomLocals and
</pre>
<hr />
<pre>
394     }
395 
396     void specialCaseArguments()
397     {
398         // Normally, a SetArgumentDefinitely denotes the start of a live range for a local&#39;s value on the stack.
399         // But those SetArguments used for the actual arguments to the machine CodeBlock get
400         // special-cased. We could have instead used two different node types - one for the arguments
401         // at the prologue case, and another for the other uses. But this seemed like IR overkill.
402 
403         for (auto&amp; pair : m_graph.m_rootToArguments) {
404             BasicBlock* entrypoint = pair.key;
405             const ArgumentsVector&amp; arguments = pair.value;
406             for (unsigned i = arguments.size(); i--;)
407                 entrypoint-&gt;variablesAtHead.setArgumentFirstTime(i, arguments[i]);
408         }
409     }
410 
411     template&lt;OperandKind operandKind&gt;
412     void propagatePhis()
413     {
<span class="line-modified">414         Vector&lt;PhiStackEntry, 128&gt;&amp; phiStack = phiStackFor&lt;operandKind&gt;();</span>
415 
416         // Ensure that attempts to use this fail instantly.
417         m_block = 0;
418 
419         while (!phiStack.isEmpty()) {
420             PhiStackEntry entry = phiStack.last();
421             phiStack.removeLast();
422 
423             BasicBlock* block = entry.m_block;
424             PredecessorList&amp; predecessors = block-&gt;predecessors;
425             Node* currentPhi = entry.m_phi;
426             VariableAccessData* variable = currentPhi-&gt;variableAccessData();
427             size_t index = entry.m_index;
428 
429             for (size_t i = predecessors.size(); i--;) {
430                 BasicBlock* predecessorBlock = predecessors[i];
431 
432                 Node* variableInPrevious = predecessorBlock-&gt;variablesAtTail.atFor&lt;operandKind&gt;(index);
433                 if (!variableInPrevious) {
434                     variableInPrevious = addPhi&lt;operandKind&gt;(predecessorBlock, currentPhi-&gt;origin, variable, index);
</pre>
<hr />
<pre>
472             }
473         }
474     }
475 
476     struct PhiStackEntry {
477         PhiStackEntry(BasicBlock* block, size_t index, Node* phi)
478             : m_block(block)
479             , m_index(index)
480             , m_phi(phi)
481         {
482         }
483 
484         BasicBlock* m_block;
485         size_t m_index;
486         Node* m_phi;
487     };
488 
489     template&lt;OperandKind operandKind&gt;
490     Vector&lt;PhiStackEntry, 128&gt;&amp; phiStackFor()
491     {
<span class="line-modified">492         switch (operandKind) {</span>
<span class="line-modified">493         case OperandKind::Argument: return m_argumentPhiStack;</span>
<span class="line-modified">494         case OperandKind::Local: return m_localPhiStack;</span>
<span class="line-added">495         case OperandKind::Tmp: return m_tmpPhiStack;</span>
<span class="line-added">496         }</span>
<span class="line-added">497         RELEASE_ASSERT_NOT_REACHED();</span>
498     }
499 
500     void computeIsFlushed()
501     {
502         m_graph.clearFlagsOnAllNodes(NodeIsFlushed);
503 
504         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
505             BasicBlock* block = m_graph.block(blockIndex);
506             if (!block)
507                 continue;
508             for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
509                 Node* node = block-&gt;at(nodeIndex);
510                 if (node-&gt;op() != Flush)
511                     continue;
512                 addFlushedLocalOp(node);
513             }
514         }
515         while (!m_flushedLocalOpWorklist.isEmpty()) {
516             Node* node = m_flushedLocalOpWorklist.takeLast();
517             switch (node-&gt;op()) {
</pre>
<hr />
<pre>
530                 DFG_CRASH(m_graph, node, &quot;Invalid node in flush graph&quot;);
531                 break;
532             }
533         }
534     }
535 
536     void addFlushedLocalOp(Node* node)
537     {
538         if (node-&gt;mergeFlags(NodeIsFlushed))
539             m_flushedLocalOpWorklist.append(node);
540     }
541 
542     void addFlushedLocalEdge(Node*, Edge edge)
543     {
544         addFlushedLocalOp(edge.node());
545     }
546 
547     BasicBlock* m_block;
548     Vector&lt;PhiStackEntry, 128&gt; m_argumentPhiStack;
549     Vector&lt;PhiStackEntry, 128&gt; m_localPhiStack;
<span class="line-added">550     Vector&lt;PhiStackEntry, 128&gt; m_tmpPhiStack;</span>
551     Vector&lt;Node*, 128&gt; m_flushedLocalOpWorklist;
552 };
553 
554 bool performCPSRethreading(Graph&amp; graph)
555 {
556     return runPhase&lt;CPSRethreadingPhase&gt;(graph);
557 }
558 
559 } } // namespace JSC::DFG
560 
561 #endif // ENABLE(DFG_JIT)
562 
</pre>
</td>
</tr>
</table>
<center><a href="DFGCFGSimplificationPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCSEPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
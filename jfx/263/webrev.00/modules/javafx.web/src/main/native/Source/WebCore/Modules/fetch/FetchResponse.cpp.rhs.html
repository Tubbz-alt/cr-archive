<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchResponse.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016 Canon Inc.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted, provided that the following conditions
  6  * are required to be met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Canon Inc. nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY CANON INC. AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL CANON INC. AND ITS CONTRIBUTORS BE LIABLE FOR
 21  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 24  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 25  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;FetchResponse.h&quot;
 31 
 32 #include &quot;FetchRequest.h&quot;
 33 #include &quot;HTTPParsers.h&quot;
 34 #include &quot;InspectorInstrumentation.h&quot;
 35 #include &quot;JSBlob.h&quot;
 36 #include &quot;MIMETypeRegistry.h&quot;
 37 #include &quot;ReadableStreamSink.h&quot;
 38 #include &quot;ResourceError.h&quot;
 39 #include &quot;ScriptExecutionContext.h&quot;
 40 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 // https://fetch.spec.whatwg.org/#null-body-status
 45 static inline bool isNullBodyStatus(int status)
 46 {
 47     return status == 101 || status == 204 || status == 205 || status == 304;
 48 }
 49 
 50 Ref&lt;FetchResponse&gt; FetchResponse::create(ScriptExecutionContext&amp; context, Optional&lt;FetchBody&gt;&amp;&amp; body, FetchHeaders::Guard guard, ResourceResponse&amp;&amp; response)
 51 {
 52     bool isSynthetic = response.type() == ResourceResponse::Type::Default || response.type() == ResourceResponse::Type::Error;
 53     bool isOpaque = response.tainting() == ResourceResponse::Tainting::Opaque;
 54     auto headers = isOpaque ? FetchHeaders::create(guard) : FetchHeaders::create(guard, HTTPHeaderMap { response.httpHeaderFields() });
 55 
 56     auto fetchResponse = adoptRef(*new FetchResponse(context, WTFMove(body), WTFMove(headers), WTFMove(response)));
<a name="1" id="anc1"></a><span class="line-added"> 57     fetchResponse-&gt;updateContentType();</span>
 58     if (!isSynthetic)
 59         fetchResponse-&gt;m_filteredResponse = ResourceResponseBase::filter(fetchResponse-&gt;m_internalResponse);
 60     if (isOpaque)
 61         fetchResponse-&gt;setBodyAsOpaque();
 62     return fetchResponse;
 63 }
 64 
 65 ExceptionOr&lt;Ref&lt;FetchResponse&gt;&gt; FetchResponse::create(ScriptExecutionContext&amp; context, Optional&lt;FetchBody::Init&gt;&amp;&amp; body, Init&amp;&amp; init)
 66 {
 67     // 1. If init’s status member is not in the range 200 to 599, inclusive, then throw a RangeError.
 68     if (init.status &lt; 200  || init.status &gt; 599)
 69         return Exception { RangeError, &quot;Status must be between 200 and 599&quot;_s };
 70 
 71     // 2. If init’s statusText member does not match the reason-phrase token production, then throw a TypeError.
 72     if (!isValidReasonPhrase(init.statusText))
 73         return Exception { TypeError, &quot;Status text must be a valid reason-phrase.&quot;_s };
 74 
 75     // 3. Let r be a new Response object associated with a new response.
 76     // NOTE: Creation of the Response object is delayed until all potential exceptional cases are handled.
 77 
 78     // 4. Set r’s headers to a new Headers object, whose header list is r’s response’s header list, and guard is &quot;response&quot;.
 79     auto headers = FetchHeaders::create(FetchHeaders::Guard::Response);
 80 
 81     // 5. Set r’s response’s status to init’s status member.
 82     auto status = init.status;
 83 
 84     // 6. Set r’s response’s status message to init’s statusText member.
 85     auto statusText = init.statusText;
 86 
 87     // 7. If init’s headers member is present, then fill r’s headers with init’s headers member.
 88     if (init.headers) {
 89         auto result = headers-&gt;fill(*init.headers);
 90         if (result.hasException())
 91             return result.releaseException();
 92     }
 93 
 94     Optional&lt;FetchBody&gt; extractedBody;
 95 
 96     // 8. If body is non-null, run these substeps:
 97     if (body) {
 98         // 8.1 If init’s status member is a null body status, then throw a TypeError.
 99         //     (NOTE: 101 is included in null body status due to its use elsewhere. It does not affect this step.)
100         if (isNullBodyStatus(init.status))
101             return Exception { TypeError, &quot;Response cannot have a body with the given status.&quot;_s };
102 
103         // 8.2 Let Content-Type be null.
104         String contentType;
105 
106         // 8.3 Set r’s response’s body and Content-Type to the result of extracting body.
107         auto result = FetchBody::extract(WTFMove(*body), contentType);
108         if (result.hasException())
109             return result.releaseException();
110         extractedBody = result.releaseReturnValue();
111 
112         // 8.4 If Content-Type is non-null and r’s response’s header list does not contain `Content-Type`, then append
113         //     `Content-Type`/Content-Type to r’s response’s header list.
114         if (!contentType.isNull() &amp;&amp; !headers-&gt;fastHas(HTTPHeaderName::ContentType))
115             headers-&gt;fastSet(HTTPHeaderName::ContentType, contentType);
116     }
117 
118     // 9. Set r’s MIME type to the result of extracting a MIME type from r’s response’s header list.
119     auto contentType = headers-&gt;fastGet(HTTPHeaderName::ContentType);
120 
121     // 10. Set r’s response’s HTTPS state to current settings object’s HTTPS state.
122     // FIXME: Implement.
123 
124     // 11. Resolve r’s trailer promise with a new Headers object whose guard is &quot;immutable&quot;.
125     // FIXME: Implement.
126 
127     // 12. Return r.
128     auto r = adoptRef(*new FetchResponse(context, WTFMove(extractedBody), WTFMove(headers), { }));
129 
130     r-&gt;m_contentType = contentType;
131     auto mimeType = extractMIMETypeFromMediaType(contentType);
132     r-&gt;m_internalResponse.setMimeType(mimeType.isEmpty() ? defaultMIMEType() : mimeType);
133     r-&gt;m_internalResponse.setTextEncodingName(extractCharsetFromMediaType(contentType));
134 
135     r-&gt;m_internalResponse.setHTTPStatusCode(status);
136     r-&gt;m_internalResponse.setHTTPStatusText(statusText);
137 
138     return r;
139 }
140 
141 Ref&lt;FetchResponse&gt; FetchResponse::error(ScriptExecutionContext&amp; context)
142 {
143     auto response = adoptRef(*new FetchResponse(context, { }, FetchHeaders::create(FetchHeaders::Guard::Immutable), { }));
144     response-&gt;m_internalResponse.setType(Type::Error);
145     return response;
146 }
147 
148 ExceptionOr&lt;Ref&lt;FetchResponse&gt;&gt; FetchResponse::redirect(ScriptExecutionContext&amp; context, const String&amp; url, int status)
149 {
150     // FIXME: Tighten the URL parsing algorithm according https://url.spec.whatwg.org/#concept-url-parser.
151     URL requestURL = context.completeURL(url);
152     if (!requestURL.isValid())
153         return Exception { TypeError, makeString(&quot;Redirection URL &#39;&quot;, requestURL.string(), &quot;&#39; is invalid&quot;) };
154     if (!requestURL.user().isEmpty() || !requestURL.pass().isEmpty())
155         return Exception { TypeError, &quot;Redirection URL contains credentials&quot;_s };
156     if (!ResourceResponse::isRedirectionStatusCode(status))
157         return Exception { RangeError, makeString(&quot;Status code &quot;, status, &quot;is not a redirection status code&quot;) };
158     auto redirectResponse = adoptRef(*new FetchResponse(context, { }, FetchHeaders::create(FetchHeaders::Guard::Immutable), { }));
159     redirectResponse-&gt;m_internalResponse.setHTTPStatusCode(status);
160     redirectResponse-&gt;m_internalResponse.setHTTPHeaderField(HTTPHeaderName::Location, requestURL.string());
161     redirectResponse-&gt;m_headers-&gt;fastSet(HTTPHeaderName::Location, requestURL.string());
162     return redirectResponse;
163 }
164 
165 FetchResponse::FetchResponse(ScriptExecutionContext&amp; context, Optional&lt;FetchBody&gt;&amp;&amp; body, Ref&lt;FetchHeaders&gt;&amp;&amp; headers, ResourceResponse&amp;&amp; response)
166     : FetchBodyOwner(context, WTFMove(body), WTFMove(headers))
167     , m_internalResponse(WTFMove(response))
168 {
169 }
170 
171 ExceptionOr&lt;Ref&lt;FetchResponse&gt;&gt; FetchResponse::clone(ScriptExecutionContext&amp; context)
172 {
173     if (isDisturbedOrLocked())
174         return Exception { TypeError, &quot;Body is disturbed or locked&quot;_s };
175 
176     ASSERT(scriptExecutionContext());
177 
178     // If loading, let&#39;s create a stream so that data is teed on both clones.
179     if (isLoading() &amp;&amp; !m_readableStreamSource)
180         createReadableStream(*context.execState());
181 
182     // Synthetic responses do not store headers in m_internalResponse.
183     if (m_internalResponse.type() == ResourceResponse::Type::Default)
184         m_internalResponse.setHTTPHeaderFields(HTTPHeaderMap { headers().internalHeaders() });
185 
186     auto clone = FetchResponse::create(context, WTF::nullopt, headers().guard(), ResourceResponse { m_internalResponse });
187     clone-&gt;cloneBody(*this);
188     clone-&gt;m_opaqueLoadIdentifier = m_opaqueLoadIdentifier;
189     clone-&gt;m_bodySizeWithPadding = m_bodySizeWithPadding;
190     return clone;
191 }
192 
193 void FetchResponse::addAbortSteps(Ref&lt;AbortSignal&gt;&amp;&amp; signal)
194 {
195     m_abortSignal = WTFMove(signal);
196     m_abortSignal-&gt;addAlgorithm([this, weakThis = makeWeakPtr(this)] {
197         // FIXME: Cancel request body if it is a stream.
198         if (!weakThis)
199             return;
200 
201         m_abortSignal = nullptr;
202 
203         setLoadingError(Exception { AbortError, &quot;Fetch is aborted&quot;_s });
204 
205         if (m_bodyLoader) {
206             if (auto callback = m_bodyLoader-&gt;takeNotificationCallback())
207                 callback(Exception { AbortError, &quot;Fetch is aborted&quot;_s });
208 
209             if (auto callback = m_bodyLoader-&gt;takeConsumeDataCallback())
210                 callback(Exception { AbortError, &quot;Fetch is aborted&quot;_s });
211         }
212 
213         if (m_readableStreamSource) {
214             if (!m_readableStreamSource-&gt;isCancelling())
215                 m_readableStreamSource-&gt;error(*loadingException());
216             m_readableStreamSource = nullptr;
217         }
218         if (m_body)
219             m_body-&gt;loadingFailed(*loadingException());
220 
221         if (auto bodyLoader = WTFMove(m_bodyLoader))
222             bodyLoader-&gt;stop();
223     });
224 }
225 
226 void FetchResponse::fetch(ScriptExecutionContext&amp; context, FetchRequest&amp; request, NotificationCallback&amp;&amp; responseCallback)
227 {
228     if (request.signal().aborted()) {
229         responseCallback(Exception { AbortError, &quot;Request signal is aborted&quot;_s });
230         // FIXME: Cancel request body if it is a stream.
231         return;
232     }
233 
234     if (request.hasReadableStreamBody()) {
235         responseCallback(Exception { NotSupportedError, &quot;ReadableStream uploading is not supported&quot;_s });
236         return;
237     }
238 
239     InspectorInstrumentation::willFetch(context, request.url());
240 
241     auto response = adoptRef(*new FetchResponse(context, FetchBody { }, FetchHeaders::create(FetchHeaders::Guard::Immutable), { }));
242 
243     response-&gt;body().consumer().setAsLoading();
244 
245     response-&gt;addAbortSteps(request.signal());
246 
247     response-&gt;m_bodyLoader = makeUnique&lt;BodyLoader&gt;(response.get(), WTFMove(responseCallback));
248     if (!response-&gt;m_bodyLoader-&gt;start(context, request))
249         response-&gt;m_bodyLoader = nullptr;
250 }
251 
252 const String&amp; FetchResponse::url() const
253 {
254     if (m_responseURL.isNull()) {
255         URL url = filteredResponse().url();
256         url.removeFragmentIdentifier();
257         m_responseURL = url.string();
258     }
259     return m_responseURL;
260 }
261 
262 const ResourceResponse&amp; FetchResponse::filteredResponse() const
263 {
264     if (m_filteredResponse)
265         return m_filteredResponse.value();
266     return m_internalResponse;
267 }
268 
269 void FetchResponse::BodyLoader::didSucceed()
270 {
271     ASSERT(m_response.hasPendingActivity());
272     m_response.m_body-&gt;loadingSucceeded();
273 
274 #if ENABLE(STREAMS_API)
275     if (m_response.m_readableStreamSource) {
276         if (m_response.body().consumer().hasData())
277             m_response.m_readableStreamSource-&gt;enqueue(m_response.body().consumer().takeAsArrayBuffer());
278 
279         m_response.closeStream();
280     }
281 #endif
282     if (auto consumeDataCallback = WTFMove(m_consumeDataCallback))
283         consumeDataCallback(nullptr);
284 
285     if (m_loader-&gt;isStarted()) {
286         Ref&lt;FetchResponse&gt; protector(m_response);
287         m_response.m_bodyLoader = nullptr;
288     }
289 }
290 
291 void FetchResponse::BodyLoader::didFail(const ResourceError&amp; error)
292 {
293     ASSERT(m_response.hasPendingActivity());
294 
295     m_response.setLoadingError(ResourceError { error });
296 
297     if (auto responseCallback = WTFMove(m_responseCallback))
298         responseCallback(Exception { TypeError, error.localizedDescription() });
299 
300     if (auto consumeDataCallback = WTFMove(m_consumeDataCallback))
301         consumeDataCallback(Exception { TypeError, error.localizedDescription() });
302 
303 #if ENABLE(STREAMS_API)
304     if (m_response.m_readableStreamSource) {
305         if (!m_response.m_readableStreamSource-&gt;isCancelling())
306             m_response.m_readableStreamSource-&gt;error(*m_response.loadingException());
307         m_response.m_readableStreamSource = nullptr;
308     }
309 #endif
<a name="2" id="anc2"></a><span class="line-added">310     if (m_response.m_body)</span>
<span class="line-added">311         m_response.m_body-&gt;loadingFailed(*m_response.loadingException());</span>
312 
313     // Check whether didFail is called as part of FetchLoader::start.
314     if (m_loader &amp;&amp; m_loader-&gt;isStarted()) {
315         Ref&lt;FetchResponse&gt; protector(m_response);
316         m_response.m_bodyLoader = nullptr;
317     }
318 }
319 
320 FetchResponse::BodyLoader::BodyLoader(FetchResponse&amp; response, NotificationCallback&amp;&amp; responseCallback)
321     : m_response(response)
322     , m_responseCallback(WTFMove(responseCallback))
323     , m_pendingActivity(m_response.makePendingActivity(m_response))
324 {
325 }
326 
327 FetchResponse::BodyLoader::~BodyLoader()
328 {
329 }
330 
331 static uint64_t nextOpaqueLoadIdentifier { 0 };
332 void FetchResponse::BodyLoader::didReceiveResponse(const ResourceResponse&amp; resourceResponse)
333 {
334     m_response.m_filteredResponse = ResourceResponseBase::filter(resourceResponse);
335     m_response.m_internalResponse = resourceResponse;
336     m_response.m_internalResponse.setType(m_response.m_filteredResponse-&gt;type());
337     if (resourceResponse.tainting() == ResourceResponse::Tainting::Opaque) {
338         m_response.m_opaqueLoadIdentifier = ++nextOpaqueLoadIdentifier;
339         m_response.setBodyAsOpaque();
340     }
341 
342     m_response.m_headers-&gt;filterAndFill(m_response.m_filteredResponse-&gt;httpHeaderFields(), FetchHeaders::Guard::Response);
343     m_response.updateContentType();
344 
345     if (auto responseCallback = WTFMove(m_responseCallback))
346         responseCallback(m_response);
347 }
348 
349 void FetchResponse::BodyLoader::didReceiveData(const char* data, size_t size)
350 {
351 #if ENABLE(STREAMS_API)
352     ASSERT(m_response.m_readableStreamSource || m_consumeDataCallback);
353 #else
354     ASSERT(m_consumeDataCallback);
355 #endif
356 
357     if (m_consumeDataCallback) {
358         ReadableStreamChunk chunk { reinterpret_cast&lt;const uint8_t*&gt;(data), size };
359         m_consumeDataCallback(&amp;chunk);
360         return;
361     }
362 
363 #if ENABLE(STREAMS_API)
364     auto&amp; source = *m_response.m_readableStreamSource;
365 
366     if (!source.isPulling()) {
367         m_response.body().consumer().append(data, size);
368         return;
369     }
370 
371     if (m_response.body().consumer().hasData() &amp;&amp; !source.enqueue(m_response.body().consumer().takeAsArrayBuffer())) {
372         stop();
373         return;
374     }
375     if (!source.enqueue(ArrayBuffer::tryCreate(data, size))) {
376         stop();
377         return;
378     }
379     source.resolvePullPromise();
380 #else
381     UNUSED_PARAM(data);
382     UNUSED_PARAM(size);
383 #endif
384 }
385 
386 bool FetchResponse::BodyLoader::start(ScriptExecutionContext&amp; context, const FetchRequest&amp; request)
387 {
388     m_loader = makeUnique&lt;FetchLoader&gt;(*this, &amp;m_response.m_body-&gt;consumer());
389     m_loader-&gt;start(context, request);
390     return m_loader-&gt;isStarted();
391 }
392 
393 void FetchResponse::BodyLoader::stop()
394 {
395     m_responseCallback = { };
396     if (m_loader)
397         m_loader-&gt;stop();
398 }
399 
400 void FetchResponse::BodyLoader::consumeDataByChunk(ConsumeDataByChunkCallback&amp;&amp; consumeDataCallback)
401 {
402     ASSERT(!m_consumeDataCallback);
403     m_consumeDataCallback = WTFMove(consumeDataCallback);
404     auto data = m_loader-&gt;startStreaming();
405     if (!data)
406         return;
407 
408     ReadableStreamChunk chunk { reinterpret_cast&lt;const uint8_t*&gt;(data-&gt;data()), data-&gt;size() };
409     m_consumeDataCallback(&amp;chunk);
410 }
411 
412 FetchResponse::ResponseData FetchResponse::consumeBody()
413 {
414     ASSERT(!isBodyReceivedByChunk());
415 
416     if (isBodyNull())
417         return nullptr;
418 
419     ASSERT(!m_isDisturbed);
420     m_isDisturbed = true;
421 
422     return body().take();
423 }
424 
425 void FetchResponse::consumeBodyReceivedByChunk(ConsumeDataByChunkCallback&amp;&amp; callback)
426 {
427     ASSERT(isBodyReceivedByChunk());
428     ASSERT(!isDisturbed());
429     m_isDisturbed = true;
430 
431     if (hasReadableStreamBody()) {
432         m_body-&gt;consumer().extract(*m_body-&gt;readableStream(), WTFMove(callback));
433         return;
434     }
435 
436     ASSERT(isLoading());
437     m_bodyLoader-&gt;consumeDataByChunk(WTFMove(callback));
438 }
439 
440 void FetchResponse::setBodyData(ResponseData&amp;&amp; data, uint64_t bodySizeWithPadding)
441 {
442     m_bodySizeWithPadding = bodySizeWithPadding;
443     WTF::switchOn(data,
444         [this](Ref&lt;FormData&gt;&amp; formData) {
445             if (isBodyNull())
446                 setBody({ });
447             body().setAsFormData(WTFMove(formData));
448         },
449         [this](Ref&lt;SharedBuffer&gt;&amp; buffer) {
450             if (isBodyNull())
451                 setBody({ });
452             body().consumer().setData(WTFMove(buffer));
453         },
454         [](std::nullptr_t&amp;) {
455         }
456     );
457 }
458 
459 #if ENABLE(STREAMS_API)
460 void FetchResponse::consumeChunk(Ref&lt;JSC::Uint8Array&gt;&amp;&amp; chunk)
461 {
462     body().consumer().append(chunk-&gt;data(), chunk-&gt;byteLength());
463 }
464 
465 void FetchResponse::consumeBodyAsStream()
466 {
467     ASSERT(m_readableStreamSource);
468     if (!isLoading()) {
469         FetchBodyOwner::consumeBodyAsStream();
470         return;
471     }
472 
473     ASSERT(m_bodyLoader);
474 
475     auto data = m_bodyLoader-&gt;startStreaming();
476     if (data) {
477         if (!m_readableStreamSource-&gt;enqueue(data-&gt;tryCreateArrayBuffer())) {
478             stop();
479             return;
480         }
481         m_readableStreamSource-&gt;resolvePullPromise();
482     }
483 }
484 
485 void FetchResponse::closeStream()
486 {
487     ASSERT(m_readableStreamSource);
488     m_readableStreamSource-&gt;close();
489     m_readableStreamSource = nullptr;
490 }
491 
492 void FetchResponse::feedStream()
493 {
494     ASSERT(m_readableStreamSource);
495     bool shouldCloseStream = !m_bodyLoader;
496 
497     if (body().consumer().hasData()) {
498         if (!m_readableStreamSource-&gt;enqueue(body().consumer().takeAsArrayBuffer())) {
499             stop();
500             return;
501         }
502         if (!shouldCloseStream) {
503             m_readableStreamSource-&gt;resolvePullPromise();
504             return;
505         }
506     } else if (!shouldCloseStream)
507         return;
508 
509     closeStream();
510 }
511 
512 RefPtr&lt;SharedBuffer&gt; FetchResponse::BodyLoader::startStreaming()
513 {
514     ASSERT(m_loader);
515     return m_loader-&gt;startStreaming();
516 }
517 
518 void FetchResponse::cancel()
519 {
520     m_isDisturbed = true;
521     stop();
522 }
523 
524 #endif
525 
526 void FetchResponse::stop()
527 {
528     RefPtr&lt;FetchResponse&gt; protectedThis(this);
529     FetchBodyOwner::stop();
530     if (auto bodyLoader = WTFMove(m_bodyLoader))
531         bodyLoader-&gt;stop();
532 }
533 
534 const char* FetchResponse::activeDOMObjectName() const
535 {
536     return &quot;Response&quot;;
537 }
538 
<a name="3" id="anc3"></a>





539 ResourceResponse FetchResponse::resourceResponse() const
540 {
541     auto response = m_internalResponse;
542 
543     if (headers().guard() != FetchHeaders::Guard::Immutable) {
544         // FIXME: Add a setHTTPHeaderFields on ResourceResponseBase.
545         for (auto&amp; header : headers().internalHeaders())
546             response.setHTTPHeaderField(header.key, header.value);
547     }
548 
549     return response;
550 }
551 
552 } // namespace WebCore
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
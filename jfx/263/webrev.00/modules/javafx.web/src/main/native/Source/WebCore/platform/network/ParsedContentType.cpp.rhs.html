<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/network/ParsedContentType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1  /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2012 Intel Corporation. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;ParsedContentType.h&quot;
 34 
 35 #include &quot;HTTPParsers.h&quot;
 36 #include &lt;wtf/text/CString.h&gt;
 37 #include &lt;wtf/text/StringBuilder.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 static void skipSpaces(StringView input, unsigned&amp; startIndex)
 42 {
 43     while (startIndex &lt; input.length() &amp;&amp; isHTTPSpace(input[startIndex]))
 44         ++startIndex;
 45 }
 46 
 47 static bool isQuotedStringTokenCharacter(UChar c)
 48 {
 49     return (c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;~&#39;) || (c &gt;= 0x80 &amp;&amp; c &lt;= 0xFF) || c == &#39;\t&#39;;
 50 }
 51 
 52 static bool isTokenCharacter(UChar c)
 53 {
 54     return isASCII(c) &amp;&amp; c &gt; &#39; &#39; &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;(&#39; &amp;&amp; c != &#39;)&#39; &amp;&amp; c != &#39;,&#39; &amp;&amp; c != &#39;/&#39; &amp;&amp; (c &lt; &#39;:&#39; || c &gt; &#39;@&#39;) &amp;&amp; (c &lt; &#39;[&#39; || c &gt; &#39;]&#39;);
 55 }
 56 
 57 using CharacterMeetsCondition = bool (*)(UChar);
 58 
<a name="1" id="anc1"></a><span class="line-modified"> 59 static StringView parseToken(StringView input, unsigned&amp; startIndex, CharacterMeetsCondition characterMeetsCondition, Mode mode, bool skipTrailingWhitespace = false)</span>
 60 {
 61     unsigned inputLength = input.length();
 62     unsigned tokenStart = startIndex;
 63     unsigned&amp; tokenEnd = startIndex;
 64 
 65     if (tokenEnd &gt;= inputLength)
<a name="2" id="anc2"></a><span class="line-modified"> 66         return StringView();</span>
 67 
 68     while (tokenEnd &lt; inputLength &amp;&amp; characterMeetsCondition(input[tokenEnd])) {
 69         if (mode == Mode::Rfc2045 &amp;&amp; !isTokenCharacter(input[tokenEnd]))
 70             break;
 71         ++tokenEnd;
 72     }
 73 
 74     if (tokenEnd == tokenStart)
<a name="3" id="anc3"></a><span class="line-modified"> 75         return StringView();</span>
 76     if (skipTrailingWhitespace) {
 77         while (input[tokenEnd - 1] == &#39; &#39;)
 78             --tokenEnd;
 79     }
 80     return input.substring(tokenStart, tokenEnd - tokenStart);
 81 }
 82 
 83 static bool isNotQuoteOrBackslash(UChar ch)
 84 {
 85     return ch != &#39;&quot;&#39; &amp;&amp; ch != &#39;\\&#39;;
 86 }
 87 
 88 static String collectHTTPQuotedString(StringView input, unsigned&amp; startIndex)
 89 {
 90     ASSERT(input[startIndex] == &#39;&quot;&#39;);
 91     unsigned inputLength = input.length();
 92     unsigned&amp; position = startIndex;
 93     position++;
 94     StringBuilder builder;
 95     while (true) {
 96         unsigned positionStart = position;
 97         parseToken(input, position, isNotQuoteOrBackslash, Mode::MimeSniff);
 98         builder.append(input.substring(positionStart, position - positionStart));
 99         if (position &gt;= inputLength)
100             break;
101         UChar quoteOrBackslash = input[position++];
102         if (quoteOrBackslash == &#39;\\&#39;) {
103             if (position &gt;= inputLength) {
104                 builder.append(quoteOrBackslash);
105                 break;
106             }
107             builder.append(input[position++]);
108         } else {
109             ASSERT(quoteOrBackslash == &#39;&quot;&#39;);
110             break;
111         }
112 
113     }
114     return builder.toString();
115 }
116 
117 static bool containsNonTokenCharacters(StringView input, Mode mode)
118 {
119     if (mode == Mode::MimeSniff)
120         return !isValidHTTPToken(input.toStringWithoutCopying());
121     for (unsigned index = 0; index &lt; input.length(); ++index) {
122         if (!isTokenCharacter(input[index]))
123             return true;
124     }
125     return false;
126 }
127 
<a name="4" id="anc4"></a><span class="line-modified">128 static StringView parseQuotedString(StringView input, unsigned&amp; startIndex)</span>
129 {
130     unsigned inputLength = input.length();
131     unsigned quotedStringStart = startIndex + 1;
132     unsigned&amp; quotedStringEnd = startIndex;
133 
134     if (quotedStringEnd &gt;= inputLength)
<a name="5" id="anc5"></a><span class="line-modified">135         return StringView();</span>
136 
137     if (input[quotedStringEnd++] != &#39;&quot;&#39; || quotedStringEnd &gt;= inputLength)
<a name="6" id="anc6"></a><span class="line-modified">138         return StringView();</span>
139 
140     bool lastCharacterWasBackslash = false;
141     char currentCharacter;
142     while ((currentCharacter = input[quotedStringEnd++]) != &#39;&quot;&#39; || lastCharacterWasBackslash) {
143         if (quotedStringEnd &gt;= inputLength)
<a name="7" id="anc7"></a><span class="line-modified">144             return StringView();</span>
145         if (currentCharacter == &#39;\\&#39; &amp;&amp; !lastCharacterWasBackslash) {
146             lastCharacterWasBackslash = true;
147             continue;
148         }
149         if (lastCharacterWasBackslash)
150             lastCharacterWasBackslash = false;
151     }
152     if (input[quotedStringEnd - 1] == &#39;&quot;&#39;)
153         quotedStringEnd++;
154     return input.substring(quotedStringStart, quotedStringEnd - quotedStringStart);
155 }
156 
157 // From http://tools.ietf.org/html/rfc2045#section-5.1:
158 //
159 // content := &quot;Content-Type&quot; &quot;:&quot; type &quot;/&quot; subtype
160 //            *(&quot;;&quot; parameter)
161 //            ; Matching of media type and subtype
162 //            ; is ALWAYS case-insensitive.
163 //
164 // type := discrete-type / composite-type
165 //
166 // discrete-type := &quot;text&quot; / &quot;image&quot; / &quot;audio&quot; / &quot;video&quot; /
167 //                  &quot;application&quot; / extension-token
168 //
169 // composite-type := &quot;message&quot; / &quot;multipart&quot; / extension-token
170 //
171 // extension-token := ietf-token / x-token
172 //
173 // ietf-token := &lt;An extension token defined by a
174 //                standards-track RFC and registered
175 //                with IANA.&gt;
176 //
177 // x-token := &lt;The two characters &quot;X-&quot; or &quot;x-&quot; followed, with
178 //             no intervening white space, by any token&gt;
179 //
180 // subtype := extension-token / iana-token
181 //
182 // iana-token := &lt;A publicly-defined extension token. Tokens
183 //                of this form must be registered with IANA
184 //                as specified in RFC 2048.&gt;
185 //
186 // parameter := attribute &quot;=&quot; value
187 //
188 // attribute := token
189 //              ; Matching of attributes
190 //              ; is ALWAYS case-insensitive.
191 //
192 // value := token / quoted-string
193 //
194 // token := 1*&lt;any (US-ASCII) CHAR except SPACE, CTLs,
195 //             or tspecials&gt;
196 //
197 // tspecials :=  &quot;(&quot; / &quot;)&quot; / &quot;&lt;&quot; / &quot;&gt;&quot; / &quot;@&quot; /
198 //               &quot;,&quot; / &quot;;&quot; / &quot;:&quot; / &quot;\&quot; / &lt;&quot;&gt;
199 //               &quot;/&quot; / &quot;[&quot; / &quot;]&quot; / &quot;?&quot; / &quot;=&quot;
200 //               ; Must be in quoted-string,
201 //               ; to use within parameter values
202 
203 static bool isNotForwardSlash(UChar ch)
204 {
205     return ch != &#39;/&#39;;
206 }
207 
208 static bool isNotSemicolon(UChar ch)
209 {
210     return ch != &#39;;&#39;;
211 }
212 
213 static bool isNotSemicolonOrEqualSign(UChar ch)
214 {
215     return ch != &#39;;&#39; &amp;&amp; ch != &#39;=&#39;;
216 }
217 
218 static bool containsNewline(UChar ch)
219 {
220     return ch == &#39;\r&#39; || ch == &#39;\n&#39;;
221 }
222 
223 bool ParsedContentType::parseContentType(Mode mode)
224 {
225     if (mode == Mode::Rfc2045 &amp;&amp; m_contentType.find(containsNewline) != notFound)
226         return false;
227     unsigned index = 0;
228     unsigned contentTypeLength = m_contentType.length();
229     skipSpaces(m_contentType, index);
230     if (index &gt;= contentTypeLength)  {
231         LOG_ERROR(&quot;Invalid Content-Type string &#39;%s&#39;&quot;, m_contentType.ascii().data());
232         return false;
233     }
234 
235     unsigned contentTypeStart = index;
236     auto typeRange = parseToken(m_contentType, index, isNotForwardSlash, mode);
<a name="8" id="anc8"></a><span class="line-modified">237     if (typeRange.isNull() || containsNonTokenCharacters(typeRange, mode)) {</span>
238         LOG_ERROR(&quot;Invalid Content-Type, invalid type value.&quot;);
239         return false;
240     }
241 
242     if (index &gt;= contentTypeLength || m_contentType[index++] != &#39;/&#39;) {
243         LOG_ERROR(&quot;Invalid Content-Type, missing &#39;/&#39;.&quot;);
244         return false;
245     }
246 
247     auto subTypeRange = parseToken(m_contentType, index, isNotSemicolon, mode, mode == Mode::MimeSniff);
<a name="9" id="anc9"></a><span class="line-modified">248     if (subTypeRange.isNull() || containsNonTokenCharacters(subTypeRange, mode)) {</span>
249         LOG_ERROR(&quot;Invalid Content-Type, invalid subtype value.&quot;);
250         return false;
251     }
252 
253     // There should not be any quoted strings until we reach the parameters.
254     size_t semiColonIndex = m_contentType.find(&#39;;&#39;, contentTypeStart);
255     if (semiColonIndex == notFound) {
256         setContentType(m_contentType.substring(contentTypeStart, contentTypeLength - contentTypeStart), mode);
257         return true;
258     }
259 
260     setContentType(m_contentType.substring(contentTypeStart, semiColonIndex - contentTypeStart), mode);
261     index = semiColonIndex + 1;
262     while (true) {
263         skipSpaces(m_contentType, index);
264         auto keyRange = parseToken(m_contentType, index, isNotSemicolonOrEqualSign, mode);
<a name="10" id="anc10"></a><span class="line-modified">265         if (mode == Mode::Rfc2045 &amp;&amp; (keyRange.isNull() || index &gt;= contentTypeLength)) {</span>
266             LOG_ERROR(&quot;Invalid Content-Type parameter name.&quot;);
267             return false;
268         }
269 
270         // Should we tolerate spaces here?
271         if (mode == Mode::Rfc2045) {
272             if (index &gt;= contentTypeLength || m_contentType[index++] != &#39;=&#39;) {
273                 LOG_ERROR(&quot;Invalid Content-Type malformed parameter.&quot;);
274                 return false;
275             }
276         } else {
277             if (index &gt;= contentTypeLength)
278                 break;
279             if (m_contentType[index] != &#39;=&#39; &amp;&amp; m_contentType[index] != &#39;;&#39;) {
280                 LOG_ERROR(&quot;Invalid Content-Type malformed parameter.&quot;);
281                 return false;
282             }
283             if (m_contentType[index++] == &#39;;&#39;)
284                 continue;
285         }
<a name="11" id="anc11"></a>
286 
287         // Should we tolerate spaces here?
288         String parameterValue;
<a name="12" id="anc12"></a><span class="line-modified">289         StringView valueRange;</span>
290         if (index &lt; contentTypeLength &amp;&amp; m_contentType[index] == &#39;&quot;&#39;) {
291             if (mode == Mode::MimeSniff) {
292                 parameterValue = collectHTTPQuotedString(m_contentType, index);
293                 parseToken(m_contentType, index, isNotSemicolon, mode);
294             } else
295                 valueRange = parseQuotedString(m_contentType, index);
296         } else
297             valueRange = parseToken(m_contentType, index, isNotSemicolon, mode, mode == Mode::MimeSniff);
298 
<a name="13" id="anc13"></a>
299         if (parameterValue.isNull()) {
<a name="14" id="anc14"></a><span class="line-modified">300             if (valueRange.isNull()) {</span>
301                 if (mode == Mode::MimeSniff)
302                     continue;
303                 LOG_ERROR(&quot;Invalid Content-Type, invalid parameter value.&quot;);
304                 return false;
305             }
<a name="15" id="anc15"></a><span class="line-modified">306             parameterValue = valueRange.toString();</span>
307         }
308 
309         // Should we tolerate spaces here?
310         if (mode == Mode::Rfc2045 &amp;&amp; index &lt; contentTypeLength &amp;&amp; m_contentType[index++] != &#39;;&#39;) {
311             LOG_ERROR(&quot;Invalid Content-Type, invalid character at the end of key/value parameter.&quot;);
312             return false;
313         }
314 
<a name="16" id="anc16"></a><span class="line-modified">315         if (!keyRange.isNull())</span>
<span class="line-added">316             setContentTypeParameter(keyRange.toString(), parameterValue, mode);</span>
317 
318         if (index &gt;= contentTypeLength)
319             return true;
320     }
321 
322     return true;
323 }
324 
325 Optional&lt;ParsedContentType&gt; ParsedContentType::create(const String&amp; contentType, Mode mode)
326 {
327     ParsedContentType parsedContentType(mode == Mode::Rfc2045 ? contentType : stripLeadingAndTrailingHTTPSpaces(contentType));
328     if (!parsedContentType.parseContentType(mode))
329         return WTF::nullopt;
330     return { WTFMove(parsedContentType) };
331 }
332 
333 bool isValidContentType(const String&amp; contentType, Mode mode)
334 {
335     return ParsedContentType::create(contentType, mode) != WTF::nullopt;
336 }
337 
338 ParsedContentType::ParsedContentType(const String&amp; contentType)
339     : m_contentType(contentType)
340 {
341 }
342 
343 String ParsedContentType::charset() const
344 {
345     return parameterValueForName(&quot;charset&quot;);
346 }
347 
348 void ParsedContentType::setCharset(String&amp;&amp; charset)
349 {
350     m_parameterValues.set(&quot;charset&quot;_s, WTFMove(charset));
351 }
352 
353 String ParsedContentType::parameterValueForName(const String&amp; name) const
354 {
355     return m_parameterValues.get(name);
356 }
357 
358 size_t ParsedContentType::parameterCount() const
359 {
360     return m_parameterValues.size();
361 }
362 
363 void ParsedContentType::setContentType(StringView contentRange, Mode mode)
364 {
365     m_mimeType = contentRange.toString();
366     if (mode == Mode::MimeSniff)
367         m_mimeType = stripLeadingAndTrailingHTTPSpaces(m_mimeType).convertToASCIILowercase();
368     else
369         m_mimeType = m_mimeType.stripWhiteSpace();
370 }
371 
372 static bool containsNonQuoteStringTokenCharacters(const String&amp; input)
373 {
374     for (unsigned index = 0; index &lt; input.length(); ++index) {
375         if (!isQuotedStringTokenCharacter(input[index]))
376             return true;
377     }
378     return false;
379 }
380 
381 void ParsedContentType::setContentTypeParameter(const String&amp; keyName, const String&amp; keyValue, Mode mode)
382 {
383     String name = keyName;
384     if (mode == Mode::MimeSniff) {
385         if (m_parameterValues.contains(name) || !isValidHTTPToken(name) || containsNonQuoteStringTokenCharacters(keyValue))
386             return;
387         name = name.convertToASCIILowercase();
388     }
389     m_parameterValues.set(name, keyValue);
390     m_parameterNames.append(name);
391 }
392 
393 String ParsedContentType::serialize() const
394 {
395     StringBuilder builder;
396     builder.append(m_mimeType);
397     for (auto&amp; name : m_parameterNames) {
398         builder.append(&#39;;&#39;);
399         builder.append(name);
400         builder.append(&#39;=&#39;);
401         String value = m_parameterValues.get(name);
402         if (value.isEmpty() || !isValidHTTPToken(value)) {
403             builder.append(&#39;&quot;&#39;);
404             for (unsigned index = 0; index &lt; value.length(); ++index) {
405                 auto ch = value[index];
406                 if (ch == &#39;\\&#39; || ch ==&#39;&quot;&#39;)
407                     builder.append(&#39;\\&#39;);
408                 builder.append(ch);
409             }
410             builder.append(&#39;&quot;&#39;);
411         } else
412             builder.append(value);
413     }
414     return builder.toString();
415 }
416 
417 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
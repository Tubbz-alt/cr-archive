diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyHelpers.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyHelpers.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyHelpers.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyHelpers.h
@@ -25,42 +25,44 @@
 
 #pragma once
 
 #if ENABLE(WEBASSEMBLY)
 
+#include "Error.h"
 #include "JSArrayBuffer.h"
+#include "JSArrayBufferView.h"
 #include "JSCJSValue.h"
 #include "JSSourceCode.h"
 #include "WebAssemblyFunction.h"
 #include "WebAssemblyWrapperFunction.h"
 
 namespace JSC {
 
-ALWAYS_INLINE uint32_t toNonWrappingUint32(ExecState* exec, JSValue value)
+ALWAYS_INLINE uint32_t toNonWrappingUint32(JSGlobalObject* globalObject, JSValue value)
 {
-    VM& vm = exec->vm();
+    VM& vm = getVM(globalObject);
     auto throwScope = DECLARE_THROW_SCOPE(vm);
 
     if (value.isUInt32())
         return value.asUInt32();
 
-    double doubleValue = value.toNumber(exec);
+    double doubleValue = value.toNumber(globalObject);
     RETURN_IF_EXCEPTION(throwScope, { });
 
     if (!std::isnan(doubleValue) && !std::isinf(doubleValue)) {
         double truncedValue = trunc(doubleValue);
         if (truncedValue >= 0 && truncedValue <= UINT_MAX)
             return static_cast<uint32_t>(truncedValue);
     }
 
-    throwException(exec, throwScope, createTypeError(exec, "Expect an integer argument in the range: [0, 2^32 - 1]"_s));
+    throwException(globalObject, throwScope, createTypeError(globalObject, "Expect an integer argument in the range: [0, 2^32 - 1]"_s));
     return { };
 }
 
-ALWAYS_INLINE std::pair<const uint8_t*, size_t> getWasmBufferFromValue(ExecState* exec, JSValue value)
+ALWAYS_INLINE std::pair<const uint8_t*, size_t> getWasmBufferFromValue(JSGlobalObject* globalObject, JSValue value)
 {
-    VM& vm = exec->vm();
+    VM& vm = getVM(globalObject);
     auto throwScope = DECLARE_THROW_SCOPE(vm);
 
     if (auto* source = jsDynamicCast<JSSourceCode*>(vm, value)) {
         auto* provider = static_cast<WebAssemblySourceProvider*>(source->sourceCode().provider());
         return { provider->data().data(), provider->data().size() };
@@ -68,35 +70,35 @@
 
     // If the given bytes argument is not a BufferSource, a TypeError exception is thrown.
     JSArrayBuffer* arrayBuffer = value.getObject() ? jsDynamicCast<JSArrayBuffer*>(vm, value.getObject()) : nullptr;
     JSArrayBufferView* arrayBufferView = value.getObject() ? jsDynamicCast<JSArrayBufferView*>(vm, value.getObject()) : nullptr;
     if (!(arrayBuffer || arrayBufferView)) {
-        throwException(exec, throwScope, createTypeError(exec,
+        throwException(globalObject, throwScope, createTypeError(globalObject,
             "first argument must be an ArrayBufferView or an ArrayBuffer"_s, defaultSourceAppender, runtimeTypeForValue(vm, value)));
         return { nullptr, 0 };
     }
 
     if (arrayBufferView ? arrayBufferView->isNeutered() : arrayBuffer->impl()->isNeutered()) {
-        throwException(exec, throwScope, createTypeError(exec,
+        throwException(globalObject, throwScope, createTypeError(globalObject,
             "underlying TypedArray has been detatched from the ArrayBuffer"_s, defaultSourceAppender, runtimeTypeForValue(vm, value)));
         return { nullptr, 0 };
     }
 
     uint8_t* base = arrayBufferView ? static_cast<uint8_t*>(arrayBufferView->vector()) : static_cast<uint8_t*>(arrayBuffer->impl()->data());
     size_t byteSize = arrayBufferView ? arrayBufferView->length() : arrayBuffer->impl()->byteLength();
     return { base, byteSize };
 }
 
-ALWAYS_INLINE Vector<uint8_t> createSourceBufferFromValue(VM& vm, ExecState* exec, JSValue value)
+ALWAYS_INLINE Vector<uint8_t> createSourceBufferFromValue(VM& vm, JSGlobalObject* globalObject, JSValue value)
 {
     auto throwScope = DECLARE_THROW_SCOPE(vm);
-    auto [data, byteSize] = getWasmBufferFromValue(exec, value);
+    auto [data, byteSize] = getWasmBufferFromValue(globalObject, value);
     RETURN_IF_EXCEPTION(throwScope, Vector<uint8_t>());
 
     Vector<uint8_t> result;
     if (!result.tryReserveCapacity(byteSize)) {
-        throwException(exec, throwScope, createOutOfMemoryError(exec));
+        throwException(globalObject, throwScope, createOutOfMemoryError(globalObject));
         return result;
     }
 
     result.grow(byteSize);
     memcpy(result.data(), data, byteSize);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/displaytree/DisplayRect.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DisplayBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DisplayRun.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/displaytree/DisplayRect.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 29 

 30 #include &quot;LayoutUnits.h&quot;
 31 
 32 namespace WebCore {
<span class="line-removed"> 33 </span>
<span class="line-removed"> 34 class RenderStyle;</span>
<span class="line-removed"> 35 </span>
 36 namespace Display {
 37 
 38 class Rect {
 39 public:
 40     Rect() = default;
 41     Rect(LayoutUnit top, LayoutUnit left, LayoutUnit width, LayoutUnit height);

 42 
 43     LayoutUnit top() const;
 44     LayoutUnit left() const;
 45     LayoutPoint topLeft() const;
 46 
 47     LayoutUnit bottom() const;
 48     LayoutUnit right() const;
 49     LayoutPoint bottomRight() const;
 50 
 51     LayoutUnit width() const;
 52     LayoutUnit height() const;
 53     LayoutSize size() const;
 54 
 55     void setTop(LayoutUnit);
 56     void setLeft(LayoutUnit);
 57     void setTopLeft(const LayoutPoint&amp;);
 58     void setWidth(LayoutUnit);
 59     void setHeight(LayoutUnit);
 60     void setSize(const LayoutSize&amp;);
 61 
 62     void shiftLeftTo(LayoutUnit);
 63     void shiftRightTo(LayoutUnit);
 64     void shiftTopTo(LayoutUnit);
 65     void shiftBottomTo(LayoutUnit);
 66 
 67     void moveHorizontally(LayoutUnit);
 68     void moveVertically(LayoutUnit);
 69 
<span class="line-modified"> 70     void expand(LayoutUnit, LayoutUnit);</span>
<span class="line-modified"> 71     void expandHorizontally(LayoutUnit delta) { expand(delta, 0); }</span>
<span class="line-modified"> 72     void expandVertically(LayoutUnit delta) { expand(0, delta); }</span>
 73     bool intersects(const Rect&amp; rect) const { return m_rect.intersects(rect); }
 74 
 75     Rect clone() const;
 76     operator LayoutRect() const;
 77 
 78 private:
<span class="line-modified"> 79 #if !ASSERT_DISABLED</span>
 80     void invalidateTop() { m_hasValidTop = false; }
 81     void invalidateLeft() { m_hasValidLeft = false; }
 82     void invalidateWidth() { m_hasValidWidth = false; }
 83     void invalidateHeight() { m_hasValidHeight = false; }
 84     void invalidatePosition();
 85 
 86     bool hasValidPosition() const { return m_hasValidTop &amp;&amp; m_hasValidLeft; }
 87     bool hasValidSize() const { return m_hasValidWidth &amp;&amp; m_hasValidHeight; }
 88     bool hasValidGeometry() const { return hasValidPosition() &amp;&amp; hasValidSize(); }
 89 
 90     void setHasValidPosition();
 91     void setHasValidSize();
 92 
 93     bool m_hasValidTop { false };
 94     bool m_hasValidLeft { false };
 95     bool m_hasValidWidth { false };
 96     bool m_hasValidHeight { false };
<span class="line-modified"> 97 #endif</span>
 98     LayoutRect m_rect;
 99 };
100 
101 inline Rect::Rect(LayoutUnit top, LayoutUnit left, LayoutUnit width, LayoutUnit height)
102     : m_rect(left, top, width, height)
103 {
<span class="line-modified">104 #if !ASSERT_DISABLED</span>
105     m_hasValidTop = true;
106     m_hasValidLeft = true;
107     m_hasValidWidth = true;
108     m_hasValidHeight = true;
109 #endif
110 }
111 
<span class="line-modified">112 #if !ASSERT_DISABLED</span>





113 inline void Rect::invalidatePosition()
114 {
115     invalidateTop();
116     invalidateLeft();
117 }
118 
119 inline void Rect::setHasValidPosition()
120 {
121     m_hasValidTop = true;
122     m_hasValidLeft = true;
123 }
124 
125 inline void Rect::setHasValidSize()
126 {
127     m_hasValidWidth = true;
128     m_hasValidHeight = true;
129 }
130 #endif
131 
132 inline LayoutUnit Rect::top() const
</pre>
<hr />
<pre>
168 inline LayoutSize Rect::size() const
169 {
170     ASSERT(hasValidSize());
171     return m_rect.size();
172 }
173 
174 inline LayoutUnit Rect::width() const
175 {
176     ASSERT(m_hasValidWidth);
177     return m_rect.width();
178 }
179 
180 inline LayoutUnit Rect::height() const
181 {
182     ASSERT(m_hasValidHeight);
183     return m_rect.height();
184 }
185 
186 inline void Rect::setTopLeft(const LayoutPoint&amp; topLeft)
187 {
<span class="line-modified">188 #if !ASSERT_DISABLED</span>
189     setHasValidPosition();
190 #endif
191     m_rect.setLocation(topLeft);
192 }
193 
194 inline void Rect::setTop(LayoutUnit top)
195 {
<span class="line-modified">196 #if !ASSERT_DISABLED</span>
197     m_hasValidTop = true;
198 #endif
199     m_rect.setY(top);
200 }
201 
202 inline void Rect::setLeft(LayoutUnit left)
203 {
<span class="line-modified">204 #if !ASSERT_DISABLED</span>
205     m_hasValidLeft = true;
206 #endif
207     m_rect.setX(left);
208 }
209 
210 inline void Rect::setWidth(LayoutUnit width)
211 {
<span class="line-modified">212 #if !ASSERT_DISABLED</span>
213     m_hasValidWidth = true;
214 #endif
215     m_rect.setWidth(width);
216 }
217 
218 inline void Rect::setHeight(LayoutUnit height)
219 {
<span class="line-modified">220 #if !ASSERT_DISABLED</span>
221     m_hasValidHeight = true;
222 #endif
223     m_rect.setHeight(height);
224 }
225 
226 inline void Rect::setSize(const LayoutSize&amp; size)
227 {
<span class="line-modified">228 #if !ASSERT_DISABLED</span>
229     setHasValidSize();
230 #endif
231     m_rect.setSize(size);
232 }
233 
234 inline void Rect::shiftLeftTo(LayoutUnit left)
235 {
236     ASSERT(m_hasValidLeft);
237     m_rect.shiftXEdgeTo(left);
238 }
239 
240 inline void Rect::shiftRightTo(LayoutUnit right)
241 {
242     ASSERT(m_hasValidLeft &amp;&amp; m_hasValidWidth);
243     m_rect.shiftMaxXEdgeTo(right);
244 }
245 
246 inline void Rect::shiftTopTo(LayoutUnit top)
247 {
248     ASSERT(m_hasValidTop);
</pre>
<hr />
<pre>
250 }
251 
252 inline void Rect::shiftBottomTo(LayoutUnit bottom)
253 {
254     ASSERT(m_hasValidTop &amp;&amp; m_hasValidHeight);
255     m_rect.shiftMaxYEdgeTo(bottom);
256 }
257 
258 inline void Rect::moveHorizontally(LayoutUnit offset)
259 {
260     ASSERT(m_hasValidLeft);
261     m_rect.move(LayoutSize { offset, 0 });
262 }
263 
264 inline void Rect::moveVertically(LayoutUnit offset)
265 {
266     ASSERT(m_hasValidTop);
267     m_rect.move(LayoutSize { 0, offset });
268 }
269 
<span class="line-modified">270 inline void Rect::expand(LayoutUnit width, LayoutUnit height)</span>
271 {
<span class="line-modified">272     ASSERT(hasValidGeometry());</span>
<span class="line-modified">273     m_rect.expand(width, height);</span>

274 }
275 
276 inline Rect Rect::clone() const
277 {
278     Rect rect;
<span class="line-modified">279 #if !ASSERT_DISABLED</span>
280     rect.m_hasValidTop = m_hasValidTop;
281     rect.m_hasValidLeft = m_hasValidLeft;
282     rect.m_hasValidWidth = m_hasValidWidth;
283     rect.m_hasValidHeight  = m_hasValidHeight;
284 #endif
285     rect.m_rect = m_rect;
286     return rect;
287 }
288 
289 inline Rect::operator LayoutRect() const
290 {
291     ASSERT(hasValidGeometry());
292     return m_rect;
293 }
294 
295 }
296 }
297 #endif
</pre>
</td>
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 29 
<span class="line-added"> 30 #include &quot;LayoutRect.h&quot;</span>
 31 #include &quot;LayoutUnits.h&quot;
 32 
 33 namespace WebCore {



 34 namespace Display {
 35 
 36 class Rect {
 37 public:
 38     Rect() = default;
 39     Rect(LayoutUnit top, LayoutUnit left, LayoutUnit width, LayoutUnit height);
<span class="line-added"> 40     Rect(LayoutPoint topLeft, LayoutUnit width, LayoutUnit height);</span>
 41 
 42     LayoutUnit top() const;
 43     LayoutUnit left() const;
 44     LayoutPoint topLeft() const;
 45 
 46     LayoutUnit bottom() const;
 47     LayoutUnit right() const;
 48     LayoutPoint bottomRight() const;
 49 
 50     LayoutUnit width() const;
 51     LayoutUnit height() const;
 52     LayoutSize size() const;
 53 
 54     void setTop(LayoutUnit);
 55     void setLeft(LayoutUnit);
 56     void setTopLeft(const LayoutPoint&amp;);
 57     void setWidth(LayoutUnit);
 58     void setHeight(LayoutUnit);
 59     void setSize(const LayoutSize&amp;);
 60 
 61     void shiftLeftTo(LayoutUnit);
 62     void shiftRightTo(LayoutUnit);
 63     void shiftTopTo(LayoutUnit);
 64     void shiftBottomTo(LayoutUnit);
 65 
 66     void moveHorizontally(LayoutUnit);
 67     void moveVertically(LayoutUnit);
 68 
<span class="line-modified"> 69     void expand(Optional&lt;LayoutUnit&gt;, Optional&lt;LayoutUnit&gt;);</span>
<span class="line-modified"> 70     void expandHorizontally(LayoutUnit delta) { expand(delta, { }); }</span>
<span class="line-modified"> 71     void expandVertically(LayoutUnit delta) { expand({ }, delta); }</span>
 72     bool intersects(const Rect&amp; rect) const { return m_rect.intersects(rect); }
 73 
 74     Rect clone() const;
 75     operator LayoutRect() const;
 76 
 77 private:
<span class="line-modified"> 78 #if ASSERT_ENABLED</span>
 79     void invalidateTop() { m_hasValidTop = false; }
 80     void invalidateLeft() { m_hasValidLeft = false; }
 81     void invalidateWidth() { m_hasValidWidth = false; }
 82     void invalidateHeight() { m_hasValidHeight = false; }
 83     void invalidatePosition();
 84 
 85     bool hasValidPosition() const { return m_hasValidTop &amp;&amp; m_hasValidLeft; }
 86     bool hasValidSize() const { return m_hasValidWidth &amp;&amp; m_hasValidHeight; }
 87     bool hasValidGeometry() const { return hasValidPosition() &amp;&amp; hasValidSize(); }
 88 
 89     void setHasValidPosition();
 90     void setHasValidSize();
 91 
 92     bool m_hasValidTop { false };
 93     bool m_hasValidLeft { false };
 94     bool m_hasValidWidth { false };
 95     bool m_hasValidHeight { false };
<span class="line-modified"> 96 #endif // ASSERT_ENABLED</span>
 97     LayoutRect m_rect;
 98 };
 99 
100 inline Rect::Rect(LayoutUnit top, LayoutUnit left, LayoutUnit width, LayoutUnit height)
101     : m_rect(left, top, width, height)
102 {
<span class="line-modified">103 #if ASSERT_ENABLED</span>
104     m_hasValidTop = true;
105     m_hasValidLeft = true;
106     m_hasValidWidth = true;
107     m_hasValidHeight = true;
108 #endif
109 }
110 
<span class="line-modified">111 inline Rect::Rect(LayoutPoint topLeft, LayoutUnit width, LayoutUnit height)</span>
<span class="line-added">112     : Rect(topLeft.y(), topLeft.x(), width, height)</span>
<span class="line-added">113 {</span>
<span class="line-added">114 }</span>
<span class="line-added">115 </span>
<span class="line-added">116 #if ASSERT_ENABLED</span>
117 inline void Rect::invalidatePosition()
118 {
119     invalidateTop();
120     invalidateLeft();
121 }
122 
123 inline void Rect::setHasValidPosition()
124 {
125     m_hasValidTop = true;
126     m_hasValidLeft = true;
127 }
128 
129 inline void Rect::setHasValidSize()
130 {
131     m_hasValidWidth = true;
132     m_hasValidHeight = true;
133 }
134 #endif
135 
136 inline LayoutUnit Rect::top() const
</pre>
<hr />
<pre>
172 inline LayoutSize Rect::size() const
173 {
174     ASSERT(hasValidSize());
175     return m_rect.size();
176 }
177 
178 inline LayoutUnit Rect::width() const
179 {
180     ASSERT(m_hasValidWidth);
181     return m_rect.width();
182 }
183 
184 inline LayoutUnit Rect::height() const
185 {
186     ASSERT(m_hasValidHeight);
187     return m_rect.height();
188 }
189 
190 inline void Rect::setTopLeft(const LayoutPoint&amp; topLeft)
191 {
<span class="line-modified">192 #if ASSERT_ENABLED</span>
193     setHasValidPosition();
194 #endif
195     m_rect.setLocation(topLeft);
196 }
197 
198 inline void Rect::setTop(LayoutUnit top)
199 {
<span class="line-modified">200 #if ASSERT_ENABLED</span>
201     m_hasValidTop = true;
202 #endif
203     m_rect.setY(top);
204 }
205 
206 inline void Rect::setLeft(LayoutUnit left)
207 {
<span class="line-modified">208 #if ASSERT_ENABLED</span>
209     m_hasValidLeft = true;
210 #endif
211     m_rect.setX(left);
212 }
213 
214 inline void Rect::setWidth(LayoutUnit width)
215 {
<span class="line-modified">216 #if ASSERT_ENABLED</span>
217     m_hasValidWidth = true;
218 #endif
219     m_rect.setWidth(width);
220 }
221 
222 inline void Rect::setHeight(LayoutUnit height)
223 {
<span class="line-modified">224 #if ASSERT_ENABLED</span>
225     m_hasValidHeight = true;
226 #endif
227     m_rect.setHeight(height);
228 }
229 
230 inline void Rect::setSize(const LayoutSize&amp; size)
231 {
<span class="line-modified">232 #if ASSERT_ENABLED</span>
233     setHasValidSize();
234 #endif
235     m_rect.setSize(size);
236 }
237 
238 inline void Rect::shiftLeftTo(LayoutUnit left)
239 {
240     ASSERT(m_hasValidLeft);
241     m_rect.shiftXEdgeTo(left);
242 }
243 
244 inline void Rect::shiftRightTo(LayoutUnit right)
245 {
246     ASSERT(m_hasValidLeft &amp;&amp; m_hasValidWidth);
247     m_rect.shiftMaxXEdgeTo(right);
248 }
249 
250 inline void Rect::shiftTopTo(LayoutUnit top)
251 {
252     ASSERT(m_hasValidTop);
</pre>
<hr />
<pre>
254 }
255 
256 inline void Rect::shiftBottomTo(LayoutUnit bottom)
257 {
258     ASSERT(m_hasValidTop &amp;&amp; m_hasValidHeight);
259     m_rect.shiftMaxYEdgeTo(bottom);
260 }
261 
262 inline void Rect::moveHorizontally(LayoutUnit offset)
263 {
264     ASSERT(m_hasValidLeft);
265     m_rect.move(LayoutSize { offset, 0 });
266 }
267 
268 inline void Rect::moveVertically(LayoutUnit offset)
269 {
270     ASSERT(m_hasValidTop);
271     m_rect.move(LayoutSize { 0, offset });
272 }
273 
<span class="line-modified">274 inline void Rect::expand(Optional&lt;LayoutUnit&gt; width, Optional&lt;LayoutUnit&gt; height)</span>
275 {
<span class="line-modified">276     ASSERT(!width || m_hasValidWidth);</span>
<span class="line-modified">277     ASSERT(!height || m_hasValidHeight);</span>
<span class="line-added">278     m_rect.expand(width.valueOr(0), height.valueOr(0));</span>
279 }
280 
281 inline Rect Rect::clone() const
282 {
283     Rect rect;
<span class="line-modified">284 #if ASSERT_ENABLED</span>
285     rect.m_hasValidTop = m_hasValidTop;
286     rect.m_hasValidLeft = m_hasValidLeft;
287     rect.m_hasValidWidth = m_hasValidWidth;
288     rect.m_hasValidHeight  = m_hasValidHeight;
289 #endif
290     rect.m_rect = m_rect;
291     return rect;
292 }
293 
294 inline Rect::operator LayoutRect() const
295 {
296     ASSERT(hasValidGeometry());
297     return m_rect;
298 }
299 
300 }
301 }
302 #endif
</pre>
</td>
</tr>
</table>
<center><a href="DisplayBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DisplayRun.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  5  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
  6  *  Copyright (C) 2007 Maks Orlovich
  7  *
  8  *  This library is free software; you can redistribute it and/or
  9  *  modify it under the terms of the GNU Library General Public
 10  *  License as published by the Free Software Foundation; either
 11  *  version 2 of the License, or (at your option) any later version.
 12  *
 13  *  This library is distributed in the hope that it will be useful,
 14  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  *  Library General Public License for more details.
 17  *
 18  *  You should have received a copy of the GNU Library General Public License
 19  *  along with this library; see the file COPYING.LIB.  If not, write to
 20  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  *  Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;JSGlobalObjectFunctions.h&quot;
 27 
 28 #include &quot;CallFrame.h&quot;
 29 #include &quot;CatchScope.h&quot;
 30 #include &quot;EvalExecutable.h&quot;
 31 #include &quot;Exception.h&quot;
 32 #include &quot;IndirectEvalExecutable.h&quot;
 33 #include &quot;Interpreter.h&quot;
 34 #include &quot;IntlDateTimeFormat.h&quot;
 35 #include &quot;IntlObject.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 #include &quot;JSFunction.h&quot;
 38 #include &quot;JSGlobalObject.h&quot;
 39 #include &quot;JSInternalPromise.h&quot;
 40 #include &quot;JSModuleLoader.h&quot;
 41 #include &quot;JSPromise.h&quot;
<a name="1" id="anc1"></a>
 42 #include &quot;JSString.h&quot;
 43 #include &quot;Lexer.h&quot;
 44 #include &quot;LiteralParser.h&quot;
 45 #include &quot;Nodes.h&quot;
 46 #include &quot;ObjectConstructor.h&quot;
 47 #include &quot;JSCInlines.h&quot;
 48 #include &quot;ParseInt.h&quot;
 49 #include &quot;Parser.h&quot;
 50 #include &quot;StackVisitor.h&quot;
 51 #include &lt;stdio.h&gt;
 52 #include &lt;stdlib.h&gt;
 53 #include &lt;unicode/utf8.h&gt;
 54 #include &lt;wtf/ASCIICType.h&gt;
 55 #include &lt;wtf/Assertions.h&gt;
 56 #include &lt;wtf/HexNumber.h&gt;
 57 #include &lt;wtf/MathExtras.h&gt;
 58 #include &lt;wtf/dtoa.h&gt;
 59 #include &lt;wtf/text/StringBuilder.h&gt;
 60 
 61 namespace JSC {
 62 
 63 const ASCIILiteral ObjectProtoCalledOnNullOrUndefinedError { &quot;Object.prototype.__proto__ called on null or undefined&quot;_s };
 64 
 65 template&lt;unsigned charactersCount&gt;
 66 static Bitmap&lt;256&gt; makeCharacterBitmap(const char (&amp;characters)[charactersCount])
 67 {
 68     static_assert(charactersCount &gt; 0, &quot;Since string literal is null terminated, characterCount is always larger than 0&quot;);
 69     Bitmap&lt;256&gt; bitmap;
 70     for (unsigned i = 0; i &lt; charactersCount - 1; ++i)
 71         bitmap.set(characters[i]);
 72     return bitmap;
 73 }
 74 
 75 template&lt;typename CharacterType&gt;
<a name="2" id="anc2"></a><span class="line-modified"> 76 static JSValue encode(JSGlobalObject* globalObject, const Bitmap&lt;256&gt;&amp; doNotEscape, const CharacterType* characters, unsigned length)</span>
 77 {
<a name="3" id="anc3"></a><span class="line-modified"> 78     VM&amp; vm = globalObject-&gt;vm();</span>
 79     auto scope = DECLARE_THROW_SCOPE(vm);
 80 
 81     // 18.2.6.1.1 Runtime Semantics: Encode ( string, unescapedSet )
 82     // https://tc39.github.io/ecma262/#sec-encode
 83 
<a name="4" id="anc4"></a><span class="line-modified"> 84     auto throwException = [&amp;scope, globalObject] {</span>
<span class="line-modified"> 85         return JSC::throwException(globalObject, scope, createURIError(globalObject, &quot;String contained an illegal UTF-16 sequence.&quot;_s));</span>
 86     };
 87 
 88     StringBuilder builder(StringBuilder::OverflowHandler::RecordOverflow);
 89     builder.reserveCapacity(length);
 90 
 91     // 4. Repeat
 92     auto* end = characters + length;
 93     for (auto* cursor = characters; cursor != end; ++cursor) {
 94         auto character = *cursor;
 95 
 96         // 4-c. If C is in unescapedSet, then
 97         if (character &lt; doNotEscape.size() &amp;&amp; doNotEscape.get(character)) {
 98             // 4-c-i. Let S be a String containing only the code unit C.
 99             // 4-c-ii. Let R be a new String value computed by concatenating the previous value of R and S.
100             builder.append(static_cast&lt;LChar&gt;(character));
101             continue;
102         }
103 
104         // 4-d-i. If the code unit value of C is not less than 0xDC00 and not greater than 0xDFFF, throw a URIError exception.
105         if (U16_IS_TRAIL(character))
106             return throwException();
107 
108         // 4-d-ii. If the code unit value of C is less than 0xD800 or greater than 0xDBFF, then
109         // 4-d-ii-1. Let V be the code unit value of C.
110         UChar32 codePoint;
111         if (!U16_IS_LEAD(character))
112             codePoint = character;
113         else {
114             // 4-d-iii. Else,
115             // 4-d-iii-1. Increase k by 1.
116             ++cursor;
117 
118             // 4-d-iii-2. If k equals strLen, throw a URIError exception.
119             if (cursor == end)
120                 return throwException();
121 
122             // 4-d-iii-3. Let kChar be the code unit value of the code unit at index k within string.
123             auto trail = *cursor;
124 
125             // 4-d-iii-4. If kChar is less than 0xDC00 or greater than 0xDFFF, throw a URIError exception.
126             if (!U16_IS_TRAIL(trail))
127                 return throwException();
128 
129             // 4-d-iii-5. Let V be UTF16Decode(C, kChar).
130             codePoint = U16_GET_SUPPLEMENTARY(character, trail);
131         }
132 
133         // 4-d-iv. Let Octets be the array of octets resulting by applying the UTF-8 transformation to V, and let L be the array size.
134         LChar utf8OctetsBuffer[U8_MAX_LENGTH];
135         unsigned utf8Length = 0;
136         // We can use U8_APPEND_UNSAFE here since codePoint is either
137         // 1. non surrogate one, correct code point.
138         // 2. correct code point generated from validated lead and trail surrogates.
139         U8_APPEND_UNSAFE(utf8OctetsBuffer, utf8Length, codePoint);
140 
141         // 4-d-v. Let j be 0.
142         // 4-d-vi. Repeat, while j &lt; L
143         for (unsigned index = 0; index &lt; utf8Length; ++index) {
144             // 4-d-vi-1. Let jOctet be the value at index j within Octets.
145             // 4-d-vi-2. Let S be a String containing three code units &quot;%XY&quot; where XY are two uppercase hexadecimal digits encoding the value of jOctet.
146             // 4-d-vi-3. Let R be a new String value computed by concatenating the previous value of R and S.
147             builder.append(&#39;%&#39;);
<a name="5" id="anc5"></a><span class="line-modified">148             builder.append(hex(utf8OctetsBuffer[index], 2));</span>
149         }
150     }
151 
152     if (UNLIKELY(builder.hasOverflowed()))
<a name="6" id="anc6"></a><span class="line-modified">153         return throwOutOfMemoryError(globalObject, scope);</span>
154     return jsString(vm, builder.toString());
155 }
156 
<a name="7" id="anc7"></a><span class="line-modified">157 static JSValue encode(JSGlobalObject* globalObject, JSValue argument, const Bitmap&lt;256&gt;&amp; doNotEscape)</span>
158 {
<a name="8" id="anc8"></a><span class="line-modified">159     return toStringView(globalObject, argument, [&amp;] (StringView view) {</span>
160         if (view.is8Bit())
<a name="9" id="anc9"></a><span class="line-modified">161             return encode(globalObject, doNotEscape, view.characters8(), view.length());</span>
<span class="line-modified">162         return encode(globalObject, doNotEscape, view.characters16(), view.length());</span>
163     });
164 }
165 
166 template &lt;typename CharType&gt;
167 ALWAYS_INLINE
<a name="10" id="anc10"></a><span class="line-modified">168 static JSValue decode(JSGlobalObject* globalObject, const CharType* characters, int length, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)</span>
169 {
<a name="11" id="anc11"></a><span class="line-modified">170     VM&amp; vm = globalObject-&gt;vm();</span>
171     auto scope = DECLARE_THROW_SCOPE(vm);
172 
173     StringBuilder builder(StringBuilder::OverflowHandler::RecordOverflow);
174     int k = 0;
175     UChar u = 0;
176     while (k &lt; length) {
177         const CharType* p = characters + k;
178         CharType c = *p;
179         if (c == &#39;%&#39;) {
180             int charLen = 0;
181             if (k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(p[1]) &amp;&amp; isASCIIHexDigit(p[2])) {
182                 const char b0 = Lexer&lt;CharType&gt;::convertHex(p[1], p[2]);
183                 const int sequenceLen = 1 + U8_COUNT_TRAIL_BYTES(b0);
184                 if (k &lt;= length - sequenceLen * 3) {
185                     charLen = sequenceLen * 3;
186 #if U_ICU_VERSION_MAJOR_NUM &gt;= 60
187                     uint8_t sequence[U8_MAX_LENGTH];
188 #else
189                     // In pre-60 ICU, U8_COUNT_TRAIL_BYTES returns 0..5
190                     uint8_t sequence[6];
191 #endif
192                     sequence[0] = b0;
193                     for (int i = 1; i &lt; sequenceLen; ++i) {
194                         const CharType* q = p + i * 3;
195                         if (q[0] == &#39;%&#39; &amp;&amp; isASCIIHexDigit(q[1]) &amp;&amp; isASCIIHexDigit(q[2]))
196                             sequence[i] = Lexer&lt;CharType&gt;::convertHex(q[1], q[2]);
197                         else {
198                             charLen = 0;
199                             break;
200                         }
201                     }
202                     if (charLen != 0) {
203                         UChar32 character;
204                         int32_t offset = 0;
205                         U8_NEXT(sequence, offset, sequenceLen, character);
206                         if (character &lt; 0)
207                             charLen = 0;
208                         else if (!U_IS_BMP(character)) {
209                             // Convert to surrogate pair.
210                             ASSERT(U_IS_SUPPLEMENTARY(character));
211                             builder.append(U16_LEAD(character));
212                             u = U16_TRAIL(character);
213                         } else {
214                             ASSERT(!U_IS_SURROGATE(character));
215                             u = static_cast&lt;UChar&gt;(character);
216                         }
217                     }
218                 }
219             }
220             if (charLen == 0) {
221                 if (strict)
<a name="12" id="anc12"></a><span class="line-modified">222                     return throwException(globalObject, scope, createURIError(globalObject, &quot;URI error&quot;_s));</span>
223                 // The only case where we don&#39;t use &quot;strict&quot; mode is the &quot;unescape&quot; function.
224                 // For that, it&#39;s good to support the wonky &quot;%u&quot; syntax for compatibility with WinIE.
225                 if (k &lt;= length - 6 &amp;&amp; p[1] == &#39;u&#39;
226                         &amp;&amp; isASCIIHexDigit(p[2]) &amp;&amp; isASCIIHexDigit(p[3])
227                         &amp;&amp; isASCIIHexDigit(p[4]) &amp;&amp; isASCIIHexDigit(p[5])) {
228                     charLen = 6;
229                     u = Lexer&lt;UChar&gt;::convertUnicode(p[2], p[3], p[4], p[5]);
230                 }
231             }
232             if (charLen &amp;&amp; (u &gt;= 128 || !doNotUnescape.get(static_cast&lt;LChar&gt;(u)))) {
233                 builder.append(u);
234                 k += charLen;
235                 continue;
236             }
237         }
238         k++;
239         builder.append(c);
240     }
241     if (UNLIKELY(builder.hasOverflowed()))
<a name="13" id="anc13"></a><span class="line-modified">242         return throwOutOfMemoryError(globalObject, scope);</span>
243     RELEASE_AND_RETURN(scope, jsString(vm, builder.toString()));
244 }
245 
<a name="14" id="anc14"></a><span class="line-modified">246 static JSValue decode(JSGlobalObject* globalObject, JSValue argument, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)</span>
247 {
<a name="15" id="anc15"></a><span class="line-modified">248     return toStringView(globalObject, argument, [&amp;] (StringView view) {</span>
249         if (view.is8Bit())
<a name="16" id="anc16"></a><span class="line-modified">250             return decode(globalObject, view.characters8(), view.length(), doNotUnescape, strict);</span>
<span class="line-modified">251         return decode(globalObject, view.characters16(), view.length(), doNotUnescape, strict);</span>
252     });
253 }
254 
255 static const int SizeOfInfinity = 8;
256 
257 template &lt;typename CharType&gt;
258 static bool isInfinity(const CharType* data, const CharType* end)
259 {
260     return (end - data) &gt;= SizeOfInfinity
261         &amp;&amp; data[0] == &#39;I&#39;
262         &amp;&amp; data[1] == &#39;n&#39;
263         &amp;&amp; data[2] == &#39;f&#39;
264         &amp;&amp; data[3] == &#39;i&#39;
265         &amp;&amp; data[4] == &#39;n&#39;
266         &amp;&amp; data[5] == &#39;i&#39;
267         &amp;&amp; data[6] == &#39;t&#39;
268         &amp;&amp; data[7] == &#39;y&#39;;
269 }
270 
271 // See ecma-262 6th 11.8.3
272 template &lt;typename CharType&gt;
273 static double jsBinaryIntegerLiteral(const CharType*&amp; data, const CharType* end)
274 {
275     // Binary number.
276     data += 2;
277     const CharType* firstDigitPosition = data;
278     double number = 0;
279     while (true) {
280         number = number * 2 + (*data - &#39;0&#39;);
281         ++data;
282         if (data == end)
283             break;
284         if (!isASCIIBinaryDigit(*data))
285             break;
286     }
287     if (number &gt;= mantissaOverflowLowerBound)
288         number = parseIntOverflow(firstDigitPosition, data - firstDigitPosition, 2);
289 
290     return number;
291 }
292 
293 // See ecma-262 6th 11.8.3
294 template &lt;typename CharType&gt;
295 static double jsOctalIntegerLiteral(const CharType*&amp; data, const CharType* end)
296 {
297     // Octal number.
298     data += 2;
299     const CharType* firstDigitPosition = data;
300     double number = 0;
301     while (true) {
302         number = number * 8 + (*data - &#39;0&#39;);
303         ++data;
304         if (data == end)
305             break;
306         if (!isASCIIOctalDigit(*data))
307             break;
308     }
309     if (number &gt;= mantissaOverflowLowerBound)
310         number = parseIntOverflow(firstDigitPosition, data - firstDigitPosition, 8);
311 
312     return number;
313 }
314 
315 // See ecma-262 6th 11.8.3
316 template &lt;typename CharType&gt;
317 static double jsHexIntegerLiteral(const CharType*&amp; data, const CharType* end)
318 {
319     // Hex number.
320     data += 2;
321     const CharType* firstDigitPosition = data;
322     double number = 0;
323     while (true) {
324         number = number * 16 + toASCIIHexValue(*data);
325         ++data;
326         if (data == end)
327             break;
328         if (!isASCIIHexDigit(*data))
329             break;
330     }
331     if (number &gt;= mantissaOverflowLowerBound)
332         number = parseIntOverflow(firstDigitPosition, data - firstDigitPosition, 16);
333 
334     return number;
335 }
336 
337 // See ecma-262 6th 11.8.3
338 template &lt;typename CharType&gt;
339 static double jsStrDecimalLiteral(const CharType*&amp; data, const CharType* end)
340 {
341     RELEASE_ASSERT(data &lt; end);
342 
343     size_t parsedLength;
344     double number = parseDouble(data, end - data, parsedLength);
345     if (parsedLength) {
346         data += parsedLength;
347         return number;
348     }
349 
350     // Check for [+-]?Infinity
351     switch (*data) {
352     case &#39;I&#39;:
353         if (isInfinity(data, end)) {
354             data += SizeOfInfinity;
355             return std::numeric_limits&lt;double&gt;::infinity();
356         }
357         break;
358 
359     case &#39;+&#39;:
360         if (isInfinity(data + 1, end)) {
361             data += SizeOfInfinity + 1;
362             return std::numeric_limits&lt;double&gt;::infinity();
363         }
364         break;
365 
366     case &#39;-&#39;:
367         if (isInfinity(data + 1, end)) {
368             data += SizeOfInfinity + 1;
369             return -std::numeric_limits&lt;double&gt;::infinity();
370         }
371         break;
372     }
373 
374     // Not a number.
375     return PNaN;
376 }
377 
378 template &lt;typename CharType&gt;
379 static double toDouble(const CharType* characters, unsigned size)
380 {
381     const CharType* endCharacters = characters + size;
382 
383     // Skip leading white space.
384     for (; characters &lt; endCharacters; ++characters) {
385         if (!isStrWhiteSpace(*characters))
386             break;
387     }
388 
389     // Empty string.
390     if (characters == endCharacters)
391         return 0.0;
392 
393     double number;
394     if (characters[0] == &#39;0&#39; &amp;&amp; characters + 2 &lt; endCharacters) {
395         if ((characters[1] | 0x20) == &#39;x&#39; &amp;&amp; isASCIIHexDigit(characters[2]))
396             number = jsHexIntegerLiteral(characters, endCharacters);
397         else if ((characters[1] | 0x20) == &#39;o&#39; &amp;&amp; isASCIIOctalDigit(characters[2]))
398             number = jsOctalIntegerLiteral(characters, endCharacters);
399         else if ((characters[1] | 0x20) == &#39;b&#39; &amp;&amp; isASCIIBinaryDigit(characters[2]))
400             number = jsBinaryIntegerLiteral(characters, endCharacters);
401         else
402             number = jsStrDecimalLiteral(characters, endCharacters);
403     } else
404         number = jsStrDecimalLiteral(characters, endCharacters);
405 
406     // Allow trailing white space.
407     for (; characters &lt; endCharacters; ++characters) {
408         if (!isStrWhiteSpace(*characters))
409             break;
410     }
411     if (characters != endCharacters)
412         return PNaN;
413 
414     return number;
415 }
416 
417 // See ecma-262 6th 11.8.3
418 double jsToNumber(StringView s)
419 {
420     unsigned size = s.length();
421 
422     if (size == 1) {
423         UChar c = s[0];
424         if (isASCIIDigit(c))
425             return c - &#39;0&#39;;
426         if (isStrWhiteSpace(c))
427             return 0;
428         return PNaN;
429     }
430 
431     if (s.is8Bit())
432         return toDouble(s.characters8(), size);
433     return toDouble(s.characters16(), size);
434 }
435 
436 static double parseFloat(StringView s)
437 {
438     unsigned size = s.length();
439 
440     if (size == 1) {
441         UChar c = s[0];
442         if (isASCIIDigit(c))
443             return c - &#39;0&#39;;
444         return PNaN;
445     }
446 
447     if (s.is8Bit()) {
448         const LChar* data = s.characters8();
449         const LChar* end = data + size;
450 
451         // Skip leading white space.
452         for (; data &lt; end; ++data) {
453             if (!isStrWhiteSpace(*data))
454                 break;
455         }
456 
457         // Empty string.
458         if (data == end)
459             return PNaN;
460 
461         return jsStrDecimalLiteral(data, end);
462     }
463 
464     const UChar* data = s.characters16();
465     const UChar* end = data + size;
466 
467     // Skip leading white space.
468     for (; data &lt; end; ++data) {
469         if (!isStrWhiteSpace(*data))
470             break;
471     }
472 
473     // Empty string.
474     if (data == end)
475         return PNaN;
476 
477     return jsStrDecimalLiteral(data, end);
478 }
479 
<a name="17" id="anc17"></a><span class="line-modified">480 EncodedJSValue JSC_HOST_CALL globalFuncEval(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
481 {
<a name="18" id="anc18"></a><span class="line-modified">482     VM&amp; vm = globalObject-&gt;vm();</span>
483     auto scope = DECLARE_THROW_SCOPE(vm);
484 
<a name="19" id="anc19"></a><span class="line-modified">485     JSValue x = callFrame-&gt;argument(0);</span>
486     if (!x.isString())
487         return JSValue::encode(x);
488 
<a name="20" id="anc20"></a>
489     if (!globalObject-&gt;evalEnabled()) {
<a name="21" id="anc21"></a><span class="line-modified">490         throwException(globalObject, scope, createEvalError(globalObject, globalObject-&gt;evalDisabledErrorMessage()));</span>
491         return JSValue::encode(jsUndefined());
492     }
493 
<a name="22" id="anc22"></a><span class="line-modified">494     String s = asString(x)-&gt;value(globalObject);</span>
495     RETURN_IF_EXCEPTION(scope, encodedJSValue());
496 
497     JSValue parsedObject;
498     if (s.is8Bit()) {
<a name="23" id="anc23"></a><span class="line-modified">499         LiteralParser&lt;LChar&gt; preparser(globalObject, s.characters8(), s.length(), NonStrictJSON, nullptr);</span>
500         parsedObject = preparser.tryLiteralParse();
501     } else {
<a name="24" id="anc24"></a><span class="line-modified">502         LiteralParser&lt;UChar&gt; preparser(globalObject, s.characters16(), s.length(), NonStrictJSON, nullptr);</span>
503         parsedObject = preparser.tryLiteralParse();
504     }
505     RETURN_IF_EXCEPTION(scope, encodedJSValue());
506     if (parsedObject)
507         return JSValue::encode(parsedObject);
508 
<a name="25" id="anc25"></a><span class="line-modified">509     SourceOrigin sourceOrigin = callFrame-&gt;callerSourceOrigin(vm);</span>
<span class="line-modified">510     EvalExecutable* eval = IndirectEvalExecutable::create(globalObject, makeSource(s, sourceOrigin), false, DerivedContextType::None, false, EvalContextType::None);</span>

511     EXCEPTION_ASSERT(!!scope.exception() == !eval);
512     if (!eval)
513         return encodedJSValue();
514 
<a name="26" id="anc26"></a><span class="line-modified">515     RELEASE_AND_RETURN(scope, JSValue::encode(vm.interpreter-&gt;execute(eval, globalObject, globalObject-&gt;globalThis(), globalObject-&gt;globalScope())));</span>
516 }
517 
<a name="27" id="anc27"></a><span class="line-modified">518 EncodedJSValue JSC_HOST_CALL globalFuncParseInt(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
519 {
<a name="28" id="anc28"></a><span class="line-modified">520     JSValue value = callFrame-&gt;argument(0);</span>
<span class="line-modified">521     JSValue radixValue = callFrame-&gt;argument(1);</span>
522 
523     // Optimized handling for numbers:
524     // If the argument is 0 or a number in range 10^-6 &lt;= n &lt; INT_MAX+1, then parseInt
525     // results in a truncation to integer. In the case of -0, this is converted to 0.
526     //
527     // This is also a truncation for values in the range INT_MAX+1 &lt;= n &lt; 10^21,
528     // however these values cannot be trivially truncated to int since 10^21 exceeds
529     // even the int64_t range. Negative numbers are a little trickier, the case for
530     // values in the range -10^21 &lt; n &lt;= -1 are similar to those for integer, but
531     // values in the range -1 &lt; n &lt;= -10^-6 need to truncate to -0, not 0.
532     static const double tenToTheMinus6 = 0.000001;
533     static const double intMaxPlusOne = 2147483648.0;
534     if (value.isNumber()) {
535         double n = value.asNumber();
536         if (((n &lt; intMaxPlusOne &amp;&amp; n &gt;= tenToTheMinus6) || !n) &amp;&amp; radixValue.isUndefinedOrNull())
537             return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(n)));
538     }
539 
540     // If ToString throws, we shouldn&#39;t call ToInt32.
<a name="29" id="anc29"></a><span class="line-modified">541     return toStringView(globalObject, value, [&amp;] (StringView view) {</span>
<span class="line-modified">542         return JSValue::encode(jsNumber(parseInt(view, radixValue.toInt32(globalObject))));</span>
543     });
544 }
545 
<a name="30" id="anc30"></a><span class="line-modified">546 EncodedJSValue JSC_HOST_CALL globalFuncParseFloat(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
547 {
<a name="31" id="anc31"></a><span class="line-modified">548     auto viewWithString = callFrame-&gt;argument(0).toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
549     return JSValue::encode(jsNumber(parseFloat(viewWithString.view)));
550 }
551 
<a name="32" id="anc32"></a><span class="line-modified">552 EncodedJSValue JSC_HOST_CALL globalFuncDecodeURI(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
553 {
554     static Bitmap&lt;256&gt; doNotUnescapeWhenDecodingURI = makeCharacterBitmap(
555         &quot;#$&amp;+,/:;=?@&quot;
556     );
557 
<a name="33" id="anc33"></a><span class="line-modified">558     return JSValue::encode(decode(globalObject, callFrame-&gt;argument(0), doNotUnescapeWhenDecodingURI, true));</span>
559 }
560 
<a name="34" id="anc34"></a><span class="line-modified">561 EncodedJSValue JSC_HOST_CALL globalFuncDecodeURIComponent(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
562 {
563     static Bitmap&lt;256&gt; emptyBitmap;
<a name="35" id="anc35"></a><span class="line-modified">564     return JSValue::encode(decode(globalObject, callFrame-&gt;argument(0), emptyBitmap, true));</span>
565 }
566 
<a name="36" id="anc36"></a><span class="line-modified">567 EncodedJSValue JSC_HOST_CALL globalFuncEncodeURI(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
568 {
569     static Bitmap&lt;256&gt; doNotEscapeWhenEncodingURI = makeCharacterBitmap(
570         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
571         &quot;abcdefghijklmnopqrstuvwxyz&quot;
572         &quot;0123456789&quot;
573         &quot;!#$&amp;&#39;()*+,-./:;=?@_~&quot;
574     );
575 
<a name="37" id="anc37"></a><span class="line-modified">576     return JSValue::encode(encode(globalObject, callFrame-&gt;argument(0), doNotEscapeWhenEncodingURI));</span>
577 }
578 
<a name="38" id="anc38"></a><span class="line-modified">579 EncodedJSValue JSC_HOST_CALL globalFuncEncodeURIComponent(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
580 {
581     static Bitmap&lt;256&gt; doNotEscapeWhenEncodingURIComponent = makeCharacterBitmap(
582         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
583         &quot;abcdefghijklmnopqrstuvwxyz&quot;
584         &quot;0123456789&quot;
585         &quot;!&#39;()*-._~&quot;
586     );
587 
<a name="39" id="anc39"></a><span class="line-modified">588     return JSValue::encode(encode(globalObject, callFrame-&gt;argument(0), doNotEscapeWhenEncodingURIComponent));</span>
589 }
590 
<a name="40" id="anc40"></a><span class="line-modified">591 EncodedJSValue JSC_HOST_CALL globalFuncEscape(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
592 {
593     static Bitmap&lt;256&gt; doNotEscape = makeCharacterBitmap(
594         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
595         &quot;abcdefghijklmnopqrstuvwxyz&quot;
596         &quot;0123456789&quot;
597         &quot;*+-./@_&quot;
598     );
599 
<a name="41" id="anc41"></a><span class="line-modified">600     return JSValue::encode(toStringView(globalObject, callFrame-&gt;argument(0), [&amp;] (StringView view) {</span>
<span class="line-modified">601         VM&amp; vm = globalObject-&gt;vm();</span>
602         StringBuilder builder;
603         if (view.is8Bit()) {
604             const LChar* c = view.characters8();
605             for (unsigned k = 0; k &lt; view.length(); k++, c++) {
606                 int u = c[0];
607                 if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
608                     builder.append(*c);
609                 else {
610                     builder.append(&#39;%&#39;);
<a name="42" id="anc42"></a><span class="line-modified">611                     builder.append(hex(u, 2));</span>
612                 }
613             }
614             return jsString(vm, builder.toString());
615         }
616 
617         const UChar* c = view.characters16();
618         for (unsigned k = 0; k &lt; view.length(); k++, c++) {
619             UChar u = c[0];
620             if (u &gt;= doNotEscape.size()) {
621                 builder.appendLiteral(&quot;%u&quot;);
<a name="43" id="anc43"></a><span class="line-modified">622                 builder.append(hex(static_cast&lt;unsigned char&gt;(u &gt;&gt; 8), 2));</span>
<span class="line-modified">623                 builder.append(hex(static_cast&lt;unsigned char&gt;(u &amp; 0xFF), 2));</span>
624             } else if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
625                 builder.append(*c);
626             else {
627                 builder.append(&#39;%&#39;);
<a name="44" id="anc44"></a><span class="line-modified">628                 builder.append(hex(static_cast&lt;unsigned char&gt;(u), 2));</span>
629             }
630         }
631 
632         return jsString(vm, builder.toString());
633     }));
634 }
635 
<a name="45" id="anc45"></a><span class="line-modified">636 EncodedJSValue JSC_HOST_CALL globalFuncUnescape(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
637 {
<a name="46" id="anc46"></a><span class="line-modified">638     return JSValue::encode(toStringView(globalObject, callFrame-&gt;argument(0), [&amp;] (StringView view) {</span>
639         // We use int for k and length intentionally since we would like to evaluate
640         // the condition `k &lt;= length -6` even if length is less than 6.
641         int k = 0;
642         int length = view.length();
643 
644         StringBuilder builder;
645         builder.reserveCapacity(length);
646 
647         if (view.is8Bit()) {
648             const LChar* characters = view.characters8();
649             LChar convertedLChar;
650             while (k &lt; length) {
651                 const LChar* c = characters + k;
652                 if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 6 &amp;&amp; c[1] == &#39;u&#39;) {
653                     if (isASCIIHexDigit(c[2]) &amp;&amp; isASCIIHexDigit(c[3]) &amp;&amp; isASCIIHexDigit(c[4]) &amp;&amp; isASCIIHexDigit(c[5])) {
654                         builder.append(Lexer&lt;UChar&gt;::convertUnicode(c[2], c[3], c[4], c[5]));
655                         k += 6;
656                         continue;
657                     }
658                 } else if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(c[1]) &amp;&amp; isASCIIHexDigit(c[2])) {
659                     convertedLChar = LChar(Lexer&lt;LChar&gt;::convertHex(c[1], c[2]));
660                     c = &amp;convertedLChar;
661                     k += 2;
662                 }
663                 builder.append(*c);
664                 k++;
665             }
666         } else {
667             const UChar* characters = view.characters16();
668 
669             while (k &lt; length) {
670                 const UChar* c = characters + k;
671                 UChar convertedUChar;
672                 if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 6 &amp;&amp; c[1] == &#39;u&#39;) {
673                     if (isASCIIHexDigit(c[2]) &amp;&amp; isASCIIHexDigit(c[3]) &amp;&amp; isASCIIHexDigit(c[4]) &amp;&amp; isASCIIHexDigit(c[5])) {
674                         convertedUChar = Lexer&lt;UChar&gt;::convertUnicode(c[2], c[3], c[4], c[5]);
675                         c = &amp;convertedUChar;
676                         k += 5;
677                     }
678                 } else if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(c[1]) &amp;&amp; isASCIIHexDigit(c[2])) {
679                     convertedUChar = UChar(Lexer&lt;UChar&gt;::convertHex(c[1], c[2]));
680                     c = &amp;convertedUChar;
681                     k += 2;
682                 }
683                 k++;
684                 builder.append(*c);
685             }
686         }
687 
<a name="47" id="anc47"></a><span class="line-modified">688         return jsString(globalObject-&gt;vm(), builder.toString());</span>
689     }));
690 }
691 
<a name="48" id="anc48"></a><span class="line-modified">692 EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeError(JSGlobalObject* globalObject, CallFrame*)</span>
693 {
<a name="49" id="anc49"></a><span class="line-modified">694     VM&amp; vm = globalObject-&gt;vm();</span>
695     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="50" id="anc50"></a><span class="line-modified">696     return throwVMTypeError(globalObject, scope);</span>
697 }
698 
<a name="51" id="anc51"></a><span class="line-modified">699 EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeErrorArgumentsCalleeAndCaller(JSGlobalObject* globalObject, CallFrame*)</span>
700 {
<a name="52" id="anc52"></a><span class="line-modified">701     VM&amp; vm = globalObject-&gt;vm();</span>
702     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="53" id="anc53"></a><span class="line-modified">703     return throwVMTypeError(globalObject, scope, &quot;&#39;arguments&#39;, &#39;callee&#39;, and &#39;caller&#39; cannot be accessed in this context.&quot;);</span>
704 }
705 
<a name="54" id="anc54"></a><span class="line-modified">706 EncodedJSValue JSC_HOST_CALL globalFuncMakeTypeError(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
707 {
<a name="55" id="anc55"></a>
708     Structure* errorStructure = globalObject-&gt;errorStructure(ErrorType::TypeError);
<a name="56" id="anc56"></a><span class="line-modified">709     return JSValue::encode(ErrorInstance::create(globalObject, errorStructure, callFrame-&gt;argument(0), nullptr, TypeNothing, false));</span>
710 }
711 
<a name="57" id="anc57"></a><span class="line-modified">712 EncodedJSValue JSC_HOST_CALL globalFuncProtoGetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
713 {
<a name="58" id="anc58"></a><span class="line-modified">714     VM&amp; vm = globalObject-&gt;vm();</span>
715     auto scope = DECLARE_THROW_SCOPE(vm);
716 
<a name="59" id="anc59"></a><span class="line-modified">717     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
718     if (thisValue.isUndefinedOrNull())
<a name="60" id="anc60"></a><span class="line-modified">719         return throwVMError(globalObject, scope, createNotAnObjectError(globalObject, thisValue));</span>
720 
721     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
722     if (!thisObject) {
<a name="61" id="anc61"></a><span class="line-modified">723         JSObject* prototype = thisValue.synthesizePrototype(globalObject);</span>
724         EXCEPTION_ASSERT(!!scope.exception() == !prototype);
725         if (UNLIKELY(!prototype))
726             return JSValue::encode(JSValue());
727         return JSValue::encode(prototype);
728     }
729 
<a name="62" id="anc62"></a><span class="line-modified">730     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, globalObject)));</span>
731 }
732 
<a name="63" id="anc63"></a><span class="line-modified">733 EncodedJSValue JSC_HOST_CALL globalFuncProtoSetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
734 {
<a name="64" id="anc64"></a><span class="line-modified">735     VM&amp; vm = globalObject-&gt;vm();</span>
736     auto scope = DECLARE_THROW_SCOPE(vm);
737 
<a name="65" id="anc65"></a><span class="line-modified">738     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
739     if (thisValue.isUndefinedOrNull())
<a name="66" id="anc66"></a><span class="line-modified">740         return throwVMTypeError(globalObject, scope, ObjectProtoCalledOnNullOrUndefinedError);</span>
741 
<a name="67" id="anc67"></a><span class="line-modified">742     JSValue value = callFrame-&gt;argument(0);</span>
743 
744     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
745 
746     // Setting __proto__ of a primitive should have no effect.
747     if (!thisObject)
748         return JSValue::encode(jsUndefined());
749 
750     // Setting __proto__ to a non-object, non-null value is silently ignored to match Mozilla.
751     if (!value.isObject() &amp;&amp; !value.isNull())
752         return JSValue::encode(jsUndefined());
753 
754     scope.release();
755     bool shouldThrowIfCantSet = true;
<a name="68" id="anc68"></a><span class="line-modified">756     thisObject-&gt;setPrototype(vm, globalObject, value, shouldThrowIfCantSet);</span>
757     return JSValue::encode(jsUndefined());
758 }
759 
<a name="69" id="anc69"></a><span class="line-modified">760 EncodedJSValue JSC_HOST_CALL globalFuncHostPromiseRejectionTracker(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
761 {
<a name="70" id="anc70"></a>
762     VM&amp; vm = globalObject-&gt;vm();
763     auto scope = DECLARE_THROW_SCOPE(vm);
764 
<a name="71" id="anc71"></a><span class="line-modified">765     JSPromise* promise = jsCast&lt;JSPromise*&gt;(callFrame-&gt;argument(0));</span>
766 
767     // InternalPromises should not be exposed to user scripts.
768     if (jsDynamicCast&lt;JSInternalPromise*&gt;(vm, promise))
769         return JSValue::encode(jsUndefined());
770 
<a name="72" id="anc72"></a><span class="line-modified">771     JSValue operationValue = callFrame-&gt;argument(1);</span>
772 
773     ASSERT(operationValue.isNumber());
<a name="73" id="anc73"></a><span class="line-modified">774     auto operation = static_cast&lt;JSPromiseRejectionOperation&gt;(operationValue.toUInt32(globalObject));</span>
775     ASSERT(operation == JSPromiseRejectionOperation::Reject || operation == JSPromiseRejectionOperation::Handle);
776     scope.assertNoException();
777 
778     if (globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker)
<a name="74" id="anc74"></a><span class="line-modified">779         globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker(globalObject, promise, operation);</span>
780     else {
781         switch (operation) {
782         case JSPromiseRejectionOperation::Reject:
783             vm.promiseRejected(promise);
784             break;
785         case JSPromiseRejectionOperation::Handle:
786             // do nothing
787             break;
788         }
789     }
790     RETURN_IF_EXCEPTION(scope, { });
791 
792     return JSValue::encode(jsUndefined());
793 }
794 
<a name="75" id="anc75"></a><span class="line-modified">795 EncodedJSValue JSC_HOST_CALL globalFuncBuiltinLog(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
796 {
<a name="76" id="anc76"></a><span class="line-modified">797     dataLog(callFrame-&gt;argument(0).toWTFString(globalObject), &quot;\n&quot;);</span>
798     return JSValue::encode(jsUndefined());
799 }
800 
<a name="77" id="anc77"></a><span class="line-modified">801 EncodedJSValue JSC_HOST_CALL globalFuncBuiltinDescribe(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
802 {
<a name="78" id="anc78"></a><span class="line-modified">803     return JSValue::encode(jsString(globalObject-&gt;vm(), toString(callFrame-&gt;argument(0))));</span>
804 }
805 
<a name="79" id="anc79"></a><span class="line-modified">806 EncodedJSValue JSC_HOST_CALL globalFuncImportModule(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
807 {
<a name="80" id="anc80"></a><span class="line-modified">808     VM&amp; vm = globalObject-&gt;vm();</span>



809 
<a name="81" id="anc81"></a><span class="line-modified">810     auto* promise = JSPromise::create(vm, globalObject-&gt;promiseStructure());</span>

811 
812     auto catchScope = DECLARE_CATCH_SCOPE(vm);
813     auto reject = [&amp;] (JSValue rejectionReason) {
814         catchScope.clearException();
<a name="82" id="anc82"></a><span class="line-modified">815         promise-&gt;reject(globalObject, rejectionReason);</span>
816         catchScope.clearException();
<a name="83" id="anc83"></a><span class="line-modified">817         return JSValue::encode(promise);</span>
818     };
819 
<a name="84" id="anc84"></a><span class="line-modified">820     auto sourceOrigin = callFrame-&gt;callerSourceOrigin(vm);</span>
<span class="line-modified">821     RELEASE_ASSERT(callFrame-&gt;argumentCount() == 1);</span>
<span class="line-modified">822     auto* specifier = callFrame-&gt;uncheckedArgument(0).toString(globalObject);</span>
823     if (Exception* exception = catchScope.exception())
824         return reject(exception-&gt;value());
825 
826     // We always specify parameters as undefined. Once dynamic import() starts accepting fetching parameters,
827     // we should retrieve this from the arguments.
828     JSValue parameters = jsUndefined();
<a name="85" id="anc85"></a><span class="line-modified">829     auto* internalPromise = globalObject-&gt;moduleLoader()-&gt;importModule(globalObject, specifier, parameters, sourceOrigin);</span>
830     if (Exception* exception = catchScope.exception())
831         return reject(exception-&gt;value());
<a name="86" id="anc86"></a><span class="line-modified">832     promise-&gt;resolve(globalObject, internalPromise);</span>
833 
834     catchScope.clearException();
<a name="87" id="anc87"></a><span class="line-modified">835     return JSValue::encode(promise);</span>
836 }
837 
<a name="88" id="anc88"></a><span class="line-modified">838 EncodedJSValue JSC_HOST_CALL globalFuncPropertyIsEnumerable(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
839 {
<a name="89" id="anc89"></a><span class="line-modified">840     VM&amp; vm = globalObject-&gt;vm();</span>
841     auto scope = DECLARE_THROW_SCOPE(vm);
842 
<a name="90" id="anc90"></a><span class="line-modified">843     RELEASE_ASSERT(callFrame-&gt;argumentCount() == 2);</span>
<span class="line-modified">844     JSObject* object = jsCast&lt;JSObject*&gt;(callFrame-&gt;uncheckedArgument(0));</span>
<span class="line-modified">845     auto propertyName = callFrame-&gt;uncheckedArgument(1).toPropertyKey(globalObject);</span>
846     RETURN_IF_EXCEPTION(scope, encodedJSValue());
847 
848     scope.release();
849     PropertyDescriptor descriptor;
<a name="91" id="anc91"></a><span class="line-modified">850     bool enumerable = object-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor) &amp;&amp; descriptor.enumerable();</span>
851     return JSValue::encode(jsBoolean(enumerable));
852 }
853 
<a name="92" id="anc92"></a><span class="line-modified">854 EncodedJSValue JSC_HOST_CALL globalFuncOwnKeys(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
855 {
<a name="93" id="anc93"></a><span class="line-modified">856     VM&amp; vm = globalObject-&gt;vm();</span>
857     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="94" id="anc94"></a><span class="line-modified">858     JSObject* object = callFrame-&gt;argument(0).toObject(globalObject);</span>
859     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="95" id="anc95"></a><span class="line-modified">860     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(globalObject, object, PropertyNameMode::StringsAndSymbols, DontEnumPropertiesMode::Include)));</span>
861 }
862 
863 #if ENABLE(INTL)
<a name="96" id="anc96"></a><span class="line-modified">864 EncodedJSValue JSC_HOST_CALL globalFuncDateTimeFormat(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
865 {
<a name="97" id="anc97"></a><span class="line-modified">866     VM&amp; vm = globalObject-&gt;vm();</span>
867     auto scope = DECLARE_THROW_SCOPE(vm);
868 
<a name="98" id="anc98"></a>
869     IntlDateTimeFormat* dateTimeFormat = IntlDateTimeFormat::create(vm, globalObject-&gt;dateTimeFormatStructure());
<a name="99" id="anc99"></a><span class="line-modified">870     dateTimeFormat-&gt;initializeDateTimeFormat(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1));</span>
871     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="100" id="anc100"></a><span class="line-modified">872     double value = callFrame-&gt;argument(2).toNumber(globalObject);</span>
873     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="101" id="anc101"></a><span class="line-modified">874     RELEASE_AND_RETURN(scope, JSValue::encode(dateTimeFormat-&gt;format(globalObject, value)));</span>
875 }
876 #endif
877 
878 } // namespace JSC
<a name="102" id="anc102"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="102" type="hidden" />
</body>
</html>
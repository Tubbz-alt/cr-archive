<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLEmbedElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLFormControlElement.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLEmbedElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 77 
 78     return nullptr;
 79 }
 80 
 81 RenderWidget* HTMLEmbedElement::renderWidgetLoadingPlugin() const
 82 {
 83     RefPtr&lt;FrameView&gt; view = document().view();
 84     if (!view || (!view-&gt;layoutContext().isInRenderTreeLayout() &amp;&amp; !view-&gt;isPainting())) {
 85         // Needs to load the plugin immediatedly because this function is called
 86         // when JavaScript code accesses the plugin.
 87         // FIXME: &lt;rdar://16893708&gt; Check if dispatching events here is safe.
 88         document().updateLayoutIgnorePendingStylesheets(Document::RunPostLayoutTasks::Synchronously);
 89     }
 90     return findWidgetRenderer(this);
 91 }
 92 
 93 void HTMLEmbedElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
 94 {
 95     if (name == hiddenAttr) {
 96         if (equalLettersIgnoringASCIICase(value, &quot;yes&quot;) || equalLettersIgnoringASCIICase(value, &quot;true&quot;)) {
<span class="line-modified"> 97             addPropertyToPresentationAttributeStyle(style, CSSPropertyWidth, 0, CSSPrimitiveValue::CSS_PX);</span>
<span class="line-modified"> 98             addPropertyToPresentationAttributeStyle(style, CSSPropertyHeight, 0, CSSPrimitiveValue::CSS_PX);</span>
 99         }
100     } else
101         HTMLPlugInImageElement::collectStyleForPresentationAttribute(name, value, style);
102 }
103 
104 static bool hasTypeOrSrc(const HTMLEmbedElement&amp; embed)
105 {
106     return embed.hasAttributeWithoutSynchronization(typeAttr) || embed.hasAttributeWithoutSynchronization(srcAttr);
107 }
108 
109 void HTMLEmbedElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
110 {
111     if (name == typeAttr) {
112         m_serviceType = value.string().left(value.find(&#39;;&#39;)).convertToASCIILowercase();
113         // FIXME: The only difference between this and HTMLObjectElement&#39;s corresponding
114         // code is that HTMLObjectElement does setNeedsWidgetUpdate(true). Consider moving
115         // this up to the HTMLPlugInImageElement to be shared.
116         if (renderer() &amp;&amp; !hasTypeOrSrc(*this))
117             invalidateStyle();
118     } else if (name == codeAttr) {
</pre>
</td>
<td>
<hr />
<pre>
 77 
 78     return nullptr;
 79 }
 80 
 81 RenderWidget* HTMLEmbedElement::renderWidgetLoadingPlugin() const
 82 {
 83     RefPtr&lt;FrameView&gt; view = document().view();
 84     if (!view || (!view-&gt;layoutContext().isInRenderTreeLayout() &amp;&amp; !view-&gt;isPainting())) {
 85         // Needs to load the plugin immediatedly because this function is called
 86         // when JavaScript code accesses the plugin.
 87         // FIXME: &lt;rdar://16893708&gt; Check if dispatching events here is safe.
 88         document().updateLayoutIgnorePendingStylesheets(Document::RunPostLayoutTasks::Synchronously);
 89     }
 90     return findWidgetRenderer(this);
 91 }
 92 
 93 void HTMLEmbedElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
 94 {
 95     if (name == hiddenAttr) {
 96         if (equalLettersIgnoringASCIICase(value, &quot;yes&quot;) || equalLettersIgnoringASCIICase(value, &quot;true&quot;)) {
<span class="line-modified"> 97             addPropertyToPresentationAttributeStyle(style, CSSPropertyWidth, 0, CSSUnitType::CSS_PX);</span>
<span class="line-modified"> 98             addPropertyToPresentationAttributeStyle(style, CSSPropertyHeight, 0, CSSUnitType::CSS_PX);</span>
 99         }
100     } else
101         HTMLPlugInImageElement::collectStyleForPresentationAttribute(name, value, style);
102 }
103 
104 static bool hasTypeOrSrc(const HTMLEmbedElement&amp; embed)
105 {
106     return embed.hasAttributeWithoutSynchronization(typeAttr) || embed.hasAttributeWithoutSynchronization(srcAttr);
107 }
108 
109 void HTMLEmbedElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
110 {
111     if (name == typeAttr) {
112         m_serviceType = value.string().left(value.find(&#39;;&#39;)).convertToASCIILowercase();
113         // FIXME: The only difference between this and HTMLObjectElement&#39;s corresponding
114         // code is that HTMLObjectElement does setNeedsWidgetUpdate(true). Consider moving
115         // this up to the HTMLPlugInImageElement to be shared.
116         if (renderer() &amp;&amp; !hasTypeOrSrc(*this))
117             invalidateStyle();
118     } else if (name == codeAttr) {
</pre>
</td>
</tr>
</table>
<center><a href="HTMLElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLFormControlElement.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpCachedResult.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RegExpCachedResult.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpConstructor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpCachedResult.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
37 // RegExpCachedResult is used to track the cached results of the last
38 // match, stores on the RegExp constructor (e.g. $&amp;, $_, $1, $2 ...).
39 // These values will be lazily generated on demand, so the cached result
40 // may be in a lazy or reified state. A lazy state is indicated by a
41 // value of m_result indicating a successful match, and a reified state
42 // is indicated by setting m_result to MatchResult::failed().
43 // Following a successful match, m_result, m_lastInput and m_lastRegExp
44 // can be used to reify the results from the match, following reification
45 // m_reifiedResult and m_reifiedInput hold the cached results.
46 class RegExpCachedResult {
47 public:
48     ALWAYS_INLINE void record(VM&amp; vm, JSObject* owner, RegExp* regExp, JSString* input, MatchResult result)
49     {
50         m_lastRegExp.setWithoutWriteBarrier(regExp);
51         m_lastInput.setWithoutWriteBarrier(input);
52         m_result = result;
53         m_reified = false;
54         vm.heap.writeBarrier(owner);
55     }
56 
<span class="line-modified">57     JSArray* lastResult(ExecState*, JSObject* owner);</span>
<span class="line-modified">58     void setInput(ExecState*, JSObject* owner, JSString*);</span>
59 
<span class="line-modified">60     JSString* leftContext(ExecState*, JSObject* owner);</span>
<span class="line-modified">61     JSString* rightContext(ExecState*, JSObject* owner);</span>
62 
63     JSString* input()
64     {
65         return m_reified ? m_reifiedInput.get() : m_lastInput.get();
66     }
67 
68     void visitAggregate(SlotVisitor&amp;);
69 
70     // m_lastRegExp would be nullptr when RegExpCachedResult is not reified.
71     // If we find m_lastRegExp is nullptr, it means this should hold the empty RegExp.
72     static ptrdiff_t offsetOfLastRegExp() { return OBJECT_OFFSETOF(RegExpCachedResult, m_lastRegExp); }
73     static ptrdiff_t offsetOfLastInput() { return OBJECT_OFFSETOF(RegExpCachedResult, m_lastInput); }
74     static ptrdiff_t offsetOfResult() { return OBJECT_OFFSETOF(RegExpCachedResult, m_result); }
75     static ptrdiff_t offsetOfReified() { return OBJECT_OFFSETOF(RegExpCachedResult, m_reified); }
76 
77 private:
78     MatchResult m_result { 0, 0 };
79     bool m_reified { false };
80     WriteBarrier&lt;JSString&gt; m_lastInput;
81     WriteBarrier&lt;RegExp&gt; m_lastRegExp;
</pre>
</td>
<td>
<hr />
<pre>
37 // RegExpCachedResult is used to track the cached results of the last
38 // match, stores on the RegExp constructor (e.g. $&amp;, $_, $1, $2 ...).
39 // These values will be lazily generated on demand, so the cached result
40 // may be in a lazy or reified state. A lazy state is indicated by a
41 // value of m_result indicating a successful match, and a reified state
42 // is indicated by setting m_result to MatchResult::failed().
43 // Following a successful match, m_result, m_lastInput and m_lastRegExp
44 // can be used to reify the results from the match, following reification
45 // m_reifiedResult and m_reifiedInput hold the cached results.
46 class RegExpCachedResult {
47 public:
48     ALWAYS_INLINE void record(VM&amp; vm, JSObject* owner, RegExp* regExp, JSString* input, MatchResult result)
49     {
50         m_lastRegExp.setWithoutWriteBarrier(regExp);
51         m_lastInput.setWithoutWriteBarrier(input);
52         m_result = result;
53         m_reified = false;
54         vm.heap.writeBarrier(owner);
55     }
56 
<span class="line-modified">57     JSArray* lastResult(JSGlobalObject*, JSObject* owner);</span>
<span class="line-modified">58     void setInput(JSGlobalObject*, JSObject* owner, JSString*);</span>
59 
<span class="line-modified">60     JSString* leftContext(JSGlobalObject*, JSObject* owner);</span>
<span class="line-modified">61     JSString* rightContext(JSGlobalObject*, JSObject* owner);</span>
62 
63     JSString* input()
64     {
65         return m_reified ? m_reifiedInput.get() : m_lastInput.get();
66     }
67 
68     void visitAggregate(SlotVisitor&amp;);
69 
70     // m_lastRegExp would be nullptr when RegExpCachedResult is not reified.
71     // If we find m_lastRegExp is nullptr, it means this should hold the empty RegExp.
72     static ptrdiff_t offsetOfLastRegExp() { return OBJECT_OFFSETOF(RegExpCachedResult, m_lastRegExp); }
73     static ptrdiff_t offsetOfLastInput() { return OBJECT_OFFSETOF(RegExpCachedResult, m_lastInput); }
74     static ptrdiff_t offsetOfResult() { return OBJECT_OFFSETOF(RegExpCachedResult, m_result); }
75     static ptrdiff_t offsetOfReified() { return OBJECT_OFFSETOF(RegExpCachedResult, m_reified); }
76 
77 private:
78     MatchResult m_result { 0, 0 };
79     bool m_reified { false };
80     WriteBarrier&lt;JSString&gt; m_lastInput;
81     WriteBarrier&lt;RegExp&gt; m_lastRegExp;
</pre>
</td>
</tr>
</table>
<center><a href="RegExpCachedResult.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpConstructor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
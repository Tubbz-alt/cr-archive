<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleColor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleProperties.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  32 #include &quot;CSSTokenizer.h&quot;
  33 #include &quot;CSSValueKeywords.h&quot;
  34 #include &quot;CSSValueList.h&quot;
  35 #include &quot;CSSValuePool.h&quot;
  36 #include &quot;Color.h&quot;
  37 #include &quot;Document.h&quot;
  38 #include &quot;PropertySetCSSStyleDeclaration.h&quot;
  39 #include &quot;StylePropertyShorthand.h&quot;
  40 #include &quot;StylePropertyShorthandFunctions.h&quot;
  41 #include &quot;StyleSheetContents.h&quot;
  42 #include &lt;bitset&gt;
  43 #include &lt;wtf/text/StringBuilder.h&gt;
  44 
  45 #ifndef NDEBUG
  46 #include &lt;stdio.h&gt;
  47 #include &lt;wtf/text/CString.h&gt;
  48 #endif
  49 
  50 namespace WebCore {
  51 




  52 static size_t sizeForImmutableStylePropertiesWithPropertyCount(unsigned count)
  53 {
<span class="line-modified">  54     return sizeof(ImmutableStyleProperties) - sizeof(void*) + sizeof(CSSValue*) * count + sizeof(StylePropertyMetadata) * count;</span>
  55 }
  56 
  57 static bool isInitialOrInherit(const String&amp; value)
  58 {
  59     return value.length() == 7 &amp;&amp; (value == &quot;initial&quot; || value == &quot;inherit&quot;);
  60 }
  61 
  62 Ref&lt;ImmutableStyleProperties&gt; ImmutableStyleProperties::create(const CSSProperty* properties, unsigned count, CSSParserMode cssParserMode)
  63 {
<span class="line-modified">  64     void* slot = WTF::fastMalloc(sizeForImmutableStylePropertiesWithPropertyCount(count));</span>
  65     return adoptRef(*new (NotNull, slot) ImmutableStyleProperties(properties, count, cssParserMode));
  66 }
  67 
  68 Ref&lt;ImmutableStyleProperties&gt; StyleProperties::immutableCopyIfNeeded() const
  69 {
  70     if (is&lt;ImmutableStyleProperties&gt;(*this))
  71         return downcast&lt;ImmutableStyleProperties&gt;(const_cast&lt;StyleProperties&amp;&gt;(*this));
  72     const MutableStyleProperties&amp; mutableThis = downcast&lt;MutableStyleProperties&gt;(*this);
  73     return ImmutableStyleProperties::create(mutableThis.m_propertyVector.data(), mutableThis.m_propertyVector.size(), cssParserMode());
  74 }
  75 
  76 MutableStyleProperties::MutableStyleProperties(CSSParserMode cssParserMode)
  77     : StyleProperties(cssParserMode, MutablePropertiesType)
  78 {
  79 }
  80 
<span class="line-modified">  81 MutableStyleProperties::MutableStyleProperties(const CSSProperty* properties, unsigned length)</span>
  82     : StyleProperties(HTMLStandardMode, MutablePropertiesType)

  83 {
<span class="line-removed">  84     m_propertyVector.reserveInitialCapacity(length);</span>
<span class="line-removed">  85     for (unsigned i = 0; i &lt; length; ++i)</span>
<span class="line-removed">  86         m_propertyVector.uncheckedAppend(properties[i]);</span>
  87 }
  88 
  89 MutableStyleProperties::~MutableStyleProperties() = default;
  90 
  91 ImmutableStyleProperties::ImmutableStyleProperties(const CSSProperty* properties, unsigned length, CSSParserMode cssParserMode)
  92     : StyleProperties(cssParserMode, length)
  93 {
  94     StylePropertyMetadata* metadataArray = const_cast&lt;StylePropertyMetadata*&gt;(this-&gt;metadataArray());
<span class="line-modified">  95     CSSValue** valueArray = const_cast&lt;CSSValue**&gt;(this-&gt;valueArray());</span>
  96     for (unsigned i = 0; i &lt; length; ++i) {
  97         metadataArray[i] = properties[i].metadata();
<span class="line-modified">  98         valueArray[i] = properties[i].value();</span>
<span class="line-modified">  99         valueArray[i]-&gt;ref();</span>

 100     }
 101 }
 102 
 103 ImmutableStyleProperties::~ImmutableStyleProperties()
 104 {
<span class="line-modified"> 105     CSSValue** valueArray = const_cast&lt;CSSValue**&gt;(this-&gt;valueArray());</span>
 106     for (unsigned i = 0; i &lt; m_arraySize; ++i)
 107         valueArray[i]-&gt;deref();
 108 }
 109 
 110 MutableStyleProperties::MutableStyleProperties(const StyleProperties&amp; other)
 111     : StyleProperties(other.cssParserMode(), MutablePropertiesType)
 112 {
 113     ASSERT(other.type() != DeferredPropertiesType);
 114     if (is&lt;MutableStyleProperties&gt;(other))
 115         m_propertyVector = downcast&lt;MutableStyleProperties&gt;(other).m_propertyVector;
 116     else {
 117         const auto&amp; immutableOther = downcast&lt;ImmutableStyleProperties&gt;(other);
 118         unsigned propertyCount = immutableOther.propertyCount();
 119         m_propertyVector.reserveInitialCapacity(propertyCount);
 120         for (unsigned i = 0; i &lt; propertyCount; ++i)
 121             m_propertyVector.uncheckedAppend(immutableOther.propertyAt(i).toCSSProperty());
 122     }
 123 }
 124 
 125 String StyleProperties::getPropertyValue(CSSPropertyID propertyID) const
 126 {
 127     RefPtr&lt;CSSValue&gt; value = getPropertyCSSValue(propertyID);
<span class="line-modified"> 128     if (value)</span>
<span class="line-modified"> 129         return value-&gt;cssText();</span>















 130 
 131     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(propertyID);
 132     if (shorthand.length()) {
 133         RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[0]);
 134         if (!value || value-&gt;isPendingSubstitutionValue())
 135             return String();
 136     // FIXME: If all longhands are the same css-generic keyword(e.g. initial or inherit),
 137     // then the shorthand should be serialized to that keyword.
 138     // It seems to be needed to handle this in a single function commonly for all the shorthands,
 139     // not in each of the shorthand serialization function.
 140     // We could call that function here.
 141     }
 142 
 143     // Shorthand and 4-values properties
 144     switch (propertyID) {
 145     case CSSPropertyAll:
 146         return getCommonValue(allShorthand());
 147     case CSSPropertyAnimation:
 148         return getLayeredShorthandValue(animationShorthand());
 149     case CSSPropertyBorderSpacing:
</pre>
<hr />
<pre>
 188         return getShorthandValue(borderInlineStartShorthand());
 189     case CSSPropertyBorderInlineEnd:
 190         return getShorthandValue(borderInlineEndShorthand());
 191     case CSSPropertyOutline:
 192         return getShorthandValue(outlineShorthand());
 193     case CSSPropertyBorderColor:
 194         return get4Values(borderColorShorthand());
 195     case CSSPropertyBorderWidth:
 196         return get4Values(borderWidthShorthand());
 197     case CSSPropertyBorderStyle:
 198         return get4Values(borderStyleShorthand());
 199     case CSSPropertyColumnRule:
 200         return getShorthandValue(columnRuleShorthand());
 201     case CSSPropertyColumns:
 202         return getShorthandValue(columnsShorthand());
 203     case CSSPropertyFlex:
 204         return getShorthandValue(flexShorthand());
 205     case CSSPropertyFlexFlow:
 206         return getShorthandValue(flexFlowShorthand());
 207     case CSSPropertyGridArea:
<span class="line-modified"> 208         return getShorthandValue(gridAreaShorthand());</span>
 209     case CSSPropertyGridTemplate:
<span class="line-modified"> 210         return getShorthandValue(gridTemplateShorthand());</span>
 211     case CSSPropertyGrid:
<span class="line-modified"> 212         return getShorthandValue(gridShorthand());</span>
 213     case CSSPropertyGridColumn:
<span class="line-modified"> 214         return getShorthandValue(gridColumnShorthand());</span>
 215     case CSSPropertyGridRow:
<span class="line-modified"> 216         return getShorthandValue(gridRowShorthand());</span>
 217     case CSSPropertyPageBreakAfter:
 218         return pageBreakPropertyValue(pageBreakAfterShorthand());
 219     case CSSPropertyPageBreakBefore:
 220         return pageBreakPropertyValue(pageBreakBeforeShorthand());
 221     case CSSPropertyPageBreakInside:
 222         return pageBreakPropertyValue(pageBreakInsideShorthand());
 223     case CSSPropertyPlaceContent:
 224         return getAlignmentShorthandValue(placeContentShorthand());
 225     case CSSPropertyPlaceItems:
 226         return getAlignmentShorthandValue(placeItemsShorthand());
 227     case CSSPropertyPlaceSelf:
 228         return getAlignmentShorthandValue(placeSelfShorthand());
 229     case CSSPropertyFont:
 230         return fontValue();
 231     case CSSPropertyInset:
 232         return get4Values(insetShorthand());
 233     case CSSPropertyInsetBlock:
 234         return get2Values(insetBlockShorthand());
 235     case CSSPropertyInsetInline:
 236         return get2Values(insetInlineShorthand());
 237     case CSSPropertyMargin:
 238         return get4Values(marginShorthand());
 239     case CSSPropertyMarginBlock:
 240         return get2Values(marginBlockShorthand());
 241     case CSSPropertyMarginInline:
 242         return get2Values(marginInlineShorthand());
 243     case CSSPropertyWebkitMarginCollapse:
 244         return getShorthandValue(webkitMarginCollapseShorthand());
 245     case CSSPropertyOverflow:
<span class="line-modified"> 246         return getCommonValue(overflowShorthand());</span>
 247     case CSSPropertyPadding:
 248         return get4Values(paddingShorthand());
 249     case CSSPropertyPaddingBlock:
 250         return get2Values(paddingBlockShorthand());
 251     case CSSPropertyPaddingInline:
 252         return get2Values(paddingInlineShorthand());
 253     case CSSPropertyTransition:
 254         return getLayeredShorthandValue(transitionShorthand());
 255     case CSSPropertyListStyle:
 256         return getShorthandValue(listStyleShorthand());
<span class="line-removed"> 257     case CSSPropertyWebkitMarquee:</span>
<span class="line-removed"> 258         return getShorthandValue(webkitMarqueeShorthand());</span>
 259     case CSSPropertyWebkitMaskPosition:
 260         return getLayeredShorthandValue(webkitMaskPositionShorthand());
 261     case CSSPropertyWebkitMaskRepeat:
 262         return getLayeredShorthandValue(webkitMaskRepeatShorthand());
 263     case CSSPropertyWebkitMask:
 264         return getLayeredShorthandValue(webkitMaskShorthand());
 265     case CSSPropertyWebkitTextEmphasis:
 266         return getShorthandValue(webkitTextEmphasisShorthand());
 267     case CSSPropertyWebkitTextStroke:
 268         return getShorthandValue(webkitTextStrokeShorthand());
 269     case CSSPropertyPerspectiveOrigin:
 270         return getShorthandValue(perspectiveOriginShorthand());
 271     case CSSPropertyTransformOrigin:
 272         return getShorthandValue(transformOriginShorthand());
 273     case CSSPropertyMarker: {
 274         RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(CSSPropertyMarkerStart);
 275         if (value)
 276             return value-&gt;cssText();
 277         return String();
 278     }
</pre>
<hr />
<pre>
 620                 commonValueInitialized = true;
 621             } else if (!commonValue.isNull() &amp;&amp; commonValue != valueText)
 622                 commonValue = String();
 623         }
 624 
 625         if (!layerResult.isEmpty()) {
 626             if (!result.isEmpty())
 627                 result.appendLiteral(&quot;, &quot;);
 628             result.append(layerResult);
 629         }
 630     }
 631 
 632     if (isInitialOrInherit(commonValue))
 633         return commonValue;
 634 
 635     if (result.isEmpty())
 636         return String();
 637     return result.toString();
 638 }
 639 
<span class="line-modified"> 640 String StyleProperties::getShorthandValue(const StylePropertyShorthand&amp; shorthand) const</span>





 641 {
 642     String commonValue;
 643     StringBuilder result;
 644     for (unsigned i = 0; i &lt; shorthand.length(); ++i) {
 645         if (!isPropertyImplicit(shorthand.properties()[i])) {
 646             RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[i]);
 647             if (!value)
 648                 return String();
 649             String valueText = value-&gt;cssText();
 650             if (!i)
 651                 commonValue = valueText;
 652             else if (!commonValue.isNull() &amp;&amp; commonValue != valueText)
 653                 commonValue = String();
 654             if (value-&gt;isInitialValue())
 655                 continue;
 656             if (!result.isEmpty())
<span class="line-modified"> 657                 result.append(&#39; &#39;);</span>
 658             result.append(valueText);
 659         } else
 660             commonValue = String();
 661     }
 662     if (isInitialOrInherit(commonValue))
 663         return commonValue;
 664     if (result.isEmpty())
 665         return String();
 666     return result.toString();
 667 }
 668 
 669 // only returns a non-null value if all properties have the same, non-null value
 670 String StyleProperties::getCommonValue(const StylePropertyShorthand&amp; shorthand) const
 671 {
 672     String res;
 673     bool lastPropertyWasImportant = false;
 674     for (unsigned i = 0; i &lt; shorthand.length(); ++i) {
 675         RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[i]);
 676         if (!value)
 677             return String();
</pre>
<hr />
<pre>
1253             continue;
1254 
1255         if (numDecls++)
1256             result.append(&#39; &#39;);
1257 
1258         if (propertyID == CSSPropertyCustom)
1259             result.append(downcast&lt;CSSCustomPropertyValue&gt;(*property.value()).name());
1260         else
1261             result.append(getPropertyName(propertyID));
1262 
1263         result.appendLiteral(&quot;: &quot;);
1264         result.append(value);
1265         if (property.isImportant())
1266             result.appendLiteral(&quot; !important&quot;);
1267         result.append(&#39;;&#39;);
1268     }
1269 
1270     // FIXME: This is a not-so-nice way to turn x/y positions into single background-position in output.
1271     // It is required because background-position-x/y are non-standard properties and WebKit generated output
1272     // would not work in Firefox (&lt;rdar://problem/5143183&gt;)
<span class="line-modified">1273     // It would be a better solution if background-position was CSS_PAIR.</span>
1274     if (positionXPropertyIndex != -1 &amp;&amp; positionYPropertyIndex != -1 &amp;&amp; propertyAt(positionXPropertyIndex).isImportant() == propertyAt(positionYPropertyIndex).isImportant()) {
1275         PropertyReference positionXProperty = propertyAt(positionXPropertyIndex);
1276         PropertyReference positionYProperty = propertyAt(positionYPropertyIndex);
1277 
1278         if (numDecls++)
1279             result.append(&#39; &#39;);
1280         result.appendLiteral(&quot;background-position: &quot;);
1281         if (positionXProperty.value()-&gt;isValueList() || positionYProperty.value()-&gt;isValueList())
1282             result.append(getLayeredShorthandValue(backgroundPositionShorthand()));
1283         else {
1284             result.append(positionXProperty.value()-&gt;cssText());
1285             result.append(&#39; &#39;);
1286             result.append(positionYProperty.value()-&gt;cssText());
1287         }
1288         if (positionXProperty.isImportant())
1289             result.appendLiteral(&quot; !important&quot;);
1290         result.append(&#39;;&#39;);
1291     } else {
1292         if (positionXPropertyIndex != -1) {
1293             if (numDecls++)
</pre>
<hr />
<pre>
1434 int MutableStyleProperties::findPropertyIndex(CSSPropertyID propertyID) const
1435 {
1436     // Convert here propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1437     // the compiler converting it to an int multiple times in the loop.
1438     uint16_t id = static_cast&lt;uint16_t&gt;(propertyID);
1439     for (int n = m_propertyVector.size() - 1 ; n &gt;= 0; --n) {
1440         if (m_propertyVector.at(n).metadata().m_propertyID == id)
1441             return n;
1442     }
1443 
1444     return -1;
1445 }
1446 
1447 int ImmutableStyleProperties::findCustomPropertyIndex(const String&amp; propertyName) const
1448 {
1449     // Convert the propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1450     // the compiler converting it to an int multiple times in the loop.
1451     for (int n = m_arraySize - 1 ; n &gt;= 0; --n) {
1452         if (metadataArray()[n].m_propertyID == CSSPropertyCustom) {
1453             // We found a custom property. See if the name matches.
<span class="line-modified">1454             if (!valueArray()[n])</span>

1455                 continue;
<span class="line-modified">1456             if (downcast&lt;CSSCustomPropertyValue&gt;(*valueArray()[n]).name() == propertyName)</span>
1457                 return n;
1458         }
1459     }
1460 
1461     return -1;
1462 }
1463 
1464 int MutableStyleProperties::findCustomPropertyIndex(const String&amp; propertyName) const
1465 {
1466     // Convert the propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1467     // the compiler converting it to an int multiple times in the loop.
1468     for (int n = m_propertyVector.size() - 1 ; n &gt;= 0; --n) {
1469         if (m_propertyVector.at(n).metadata().m_propertyID == CSSPropertyCustom) {
1470             // We found a custom property. See if the name matches.
1471             if (!m_propertyVector.at(n).value())
1472                 continue;
1473             if (downcast&lt;CSSCustomPropertyValue&gt;(*m_propertyVector.at(n).value()).name() == propertyName)
1474                 return n;
1475         }
1476     }
</pre>
<hr />
<pre>
1492     if (foundPropertyIndex == -1)
1493         return 0;
1494     return &amp;m_propertyVector.at(foundPropertyIndex);
1495 }
1496 
1497 bool StyleProperties::propertyMatches(CSSPropertyID propertyID, const CSSValue* propertyValue) const
1498 {
1499     int foundPropertyIndex = findPropertyIndex(propertyID);
1500     if (foundPropertyIndex == -1)
1501         return false;
1502     return propertyAt(foundPropertyIndex).value()-&gt;equals(*propertyValue);
1503 }
1504 
1505 Ref&lt;MutableStyleProperties&gt; StyleProperties::mutableCopy() const
1506 {
1507     return adoptRef(*new MutableStyleProperties(*this));
1508 }
1509 
1510 Ref&lt;MutableStyleProperties&gt; StyleProperties::copyPropertiesInSet(const CSSPropertyID* set, unsigned length) const
1511 {
<span class="line-modified">1512     Vector&lt;CSSProperty, 256&gt; list;</span>
1513     list.reserveInitialCapacity(length);
1514     for (unsigned i = 0; i &lt; length; ++i) {
1515         if (auto value = getPropertyCSSValueInternal(set[i]))
1516             list.uncheckedAppend(CSSProperty(set[i], WTFMove(value), false));
1517     }
<span class="line-modified">1518     return MutableStyleProperties::create(list.data(), list.size());</span>
1519 }
1520 
1521 PropertySetCSSStyleDeclaration* MutableStyleProperties::cssStyleDeclaration()
1522 {
1523     return m_cssomWrapper.get();
1524 }
1525 
1526 CSSStyleDeclaration&amp; MutableStyleProperties::ensureCSSStyleDeclaration()
1527 {
1528     if (m_cssomWrapper) {
1529         ASSERT(!static_cast&lt;CSSStyleDeclaration*&gt;(m_cssomWrapper.get())-&gt;parentRule());
1530         ASSERT(!m_cssomWrapper-&gt;parentElement());
1531         return *m_cssomWrapper;
1532     }
1533     m_cssomWrapper = makeUnique&lt;PropertySetCSSStyleDeclaration&gt;(*this);
1534     return *m_cssomWrapper;
1535 }
1536 
1537 CSSStyleDeclaration&amp; MutableStyleProperties::ensureInlineCSSStyleDeclaration(StyledElement&amp; parentElement)
1538 {
</pre>
<hr />
<pre>
1551 }
1552 
1553 // See the function above if you need to update this.
1554 struct SameSizeAsStyleProperties : public RefCounted&lt;SameSizeAsStyleProperties&gt; {
1555     unsigned bitfield;
1556 };
1557 COMPILE_ASSERT(sizeof(StyleProperties) == sizeof(SameSizeAsStyleProperties), style_property_set_should_stay_small);
1558 
1559 #ifndef NDEBUG
1560 void StyleProperties::showStyle()
1561 {
1562     fprintf(stderr, &quot;%s\n&quot;, asText().ascii().data());
1563 }
1564 #endif
1565 
1566 Ref&lt;MutableStyleProperties&gt; MutableStyleProperties::create(CSSParserMode cssParserMode)
1567 {
1568     return adoptRef(*new MutableStyleProperties(cssParserMode));
1569 }
1570 
<span class="line-modified">1571 Ref&lt;MutableStyleProperties&gt; MutableStyleProperties::create(const CSSProperty* properties, unsigned count)</span>
1572 {
<span class="line-modified">1573     return adoptRef(*new MutableStyleProperties(properties, count));</span>
1574 }
1575 
1576 String StyleProperties::PropertyReference::cssName() const
1577 {
1578     if (id() == CSSPropertyCustom)
1579         return downcast&lt;CSSCustomPropertyValue&gt;(*value()).name();
1580     return getPropertyNameString(id());
1581 }
1582 
1583 String StyleProperties::PropertyReference::cssText() const
1584 {
1585     StringBuilder result;
1586     result.append(cssName());
1587     result.appendLiteral(&quot;: &quot;);
1588     result.append(m_value-&gt;cssText());
1589     if (isImportant())
1590         result.appendLiteral(&quot; !important&quot;);
1591     result.append(&#39;;&#39;);
1592     return result.toString();
1593 }
</pre>
</td>
<td>
<hr />
<pre>
  32 #include &quot;CSSTokenizer.h&quot;
  33 #include &quot;CSSValueKeywords.h&quot;
  34 #include &quot;CSSValueList.h&quot;
  35 #include &quot;CSSValuePool.h&quot;
  36 #include &quot;Color.h&quot;
  37 #include &quot;Document.h&quot;
  38 #include &quot;PropertySetCSSStyleDeclaration.h&quot;
  39 #include &quot;StylePropertyShorthand.h&quot;
  40 #include &quot;StylePropertyShorthandFunctions.h&quot;
  41 #include &quot;StyleSheetContents.h&quot;
  42 #include &lt;bitset&gt;
  43 #include &lt;wtf/text/StringBuilder.h&gt;
  44 
  45 #ifndef NDEBUG
  46 #include &lt;stdio.h&gt;
  47 #include &lt;wtf/text/CString.h&gt;
  48 #endif
  49 
  50 namespace WebCore {
  51 
<span class="line-added">  52 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleProperties);</span>
<span class="line-added">  53 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ImmutableStyleProperties);</span>
<span class="line-added">  54 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MutableStyleProperties);</span>
<span class="line-added">  55 </span>
  56 static size_t sizeForImmutableStylePropertiesWithPropertyCount(unsigned count)
  57 {
<span class="line-modified">  58     return sizeof(ImmutableStyleProperties) - sizeof(void*) + sizeof(StylePropertyMetadata) * count + sizeof(PackedPtr&lt;const CSSValue&gt;) * count;</span>
  59 }
  60 
  61 static bool isInitialOrInherit(const String&amp; value)
  62 {
  63     return value.length() == 7 &amp;&amp; (value == &quot;initial&quot; || value == &quot;inherit&quot;);
  64 }
  65 
  66 Ref&lt;ImmutableStyleProperties&gt; ImmutableStyleProperties::create(const CSSProperty* properties, unsigned count, CSSParserMode cssParserMode)
  67 {
<span class="line-modified">  68     void* slot = ImmutableStylePropertiesMalloc::malloc(sizeForImmutableStylePropertiesWithPropertyCount(count));</span>
  69     return adoptRef(*new (NotNull, slot) ImmutableStyleProperties(properties, count, cssParserMode));
  70 }
  71 
  72 Ref&lt;ImmutableStyleProperties&gt; StyleProperties::immutableCopyIfNeeded() const
  73 {
  74     if (is&lt;ImmutableStyleProperties&gt;(*this))
  75         return downcast&lt;ImmutableStyleProperties&gt;(const_cast&lt;StyleProperties&amp;&gt;(*this));
  76     const MutableStyleProperties&amp; mutableThis = downcast&lt;MutableStyleProperties&gt;(*this);
  77     return ImmutableStyleProperties::create(mutableThis.m_propertyVector.data(), mutableThis.m_propertyVector.size(), cssParserMode());
  78 }
  79 
  80 MutableStyleProperties::MutableStyleProperties(CSSParserMode cssParserMode)
  81     : StyleProperties(cssParserMode, MutablePropertiesType)
  82 {
  83 }
  84 
<span class="line-modified">  85 MutableStyleProperties::MutableStyleProperties(Vector&lt;CSSProperty&gt;&amp;&amp; properties)</span>
  86     : StyleProperties(HTMLStandardMode, MutablePropertiesType)
<span class="line-added">  87     , m_propertyVector(WTFMove(properties))</span>
  88 {



  89 }
  90 
  91 MutableStyleProperties::~MutableStyleProperties() = default;
  92 
  93 ImmutableStyleProperties::ImmutableStyleProperties(const CSSProperty* properties, unsigned length, CSSParserMode cssParserMode)
  94     : StyleProperties(cssParserMode, length)
  95 {
  96     StylePropertyMetadata* metadataArray = const_cast&lt;StylePropertyMetadata*&gt;(this-&gt;metadataArray());
<span class="line-modified">  97     PackedPtr&lt;CSSValue&gt;* valueArray = bitwise_cast&lt;PackedPtr&lt;CSSValue&gt;*&gt;(this-&gt;valueArray());</span>
  98     for (unsigned i = 0; i &lt; length; ++i) {
  99         metadataArray[i] = properties[i].metadata();
<span class="line-modified"> 100         auto* value = properties[i].value();</span>
<span class="line-modified"> 101         valueArray[i] = value;</span>
<span class="line-added"> 102         value-&gt;ref();</span>
 103     }
 104 }
 105 
 106 ImmutableStyleProperties::~ImmutableStyleProperties()
 107 {
<span class="line-modified"> 108     PackedPtr&lt;CSSValue&gt;* valueArray = bitwise_cast&lt;PackedPtr&lt;CSSValue&gt;*&gt;(this-&gt;valueArray());</span>
 109     for (unsigned i = 0; i &lt; m_arraySize; ++i)
 110         valueArray[i]-&gt;deref();
 111 }
 112 
 113 MutableStyleProperties::MutableStyleProperties(const StyleProperties&amp; other)
 114     : StyleProperties(other.cssParserMode(), MutablePropertiesType)
 115 {
 116     ASSERT(other.type() != DeferredPropertiesType);
 117     if (is&lt;MutableStyleProperties&gt;(other))
 118         m_propertyVector = downcast&lt;MutableStyleProperties&gt;(other).m_propertyVector;
 119     else {
 120         const auto&amp; immutableOther = downcast&lt;ImmutableStyleProperties&gt;(other);
 121         unsigned propertyCount = immutableOther.propertyCount();
 122         m_propertyVector.reserveInitialCapacity(propertyCount);
 123         for (unsigned i = 0; i &lt; propertyCount; ++i)
 124             m_propertyVector.uncheckedAppend(immutableOther.propertyAt(i).toCSSProperty());
 125     }
 126 }
 127 
 128 String StyleProperties::getPropertyValue(CSSPropertyID propertyID) const
 129 {
 130     RefPtr&lt;CSSValue&gt; value = getPropertyCSSValue(propertyID);
<span class="line-modified"> 131     if (value) {</span>
<span class="line-modified"> 132         switch (propertyID) {</span>
<span class="line-added"> 133         case CSSPropertyFillOpacity:</span>
<span class="line-added"> 134         case CSSPropertyFloodOpacity:</span>
<span class="line-added"> 135         case CSSPropertyOpacity:</span>
<span class="line-added"> 136         case CSSPropertyStopOpacity:</span>
<span class="line-added"> 137         case CSSPropertyStrokeOpacity:</span>
<span class="line-added"> 138             // Opacity values always serializes as a number.</span>
<span class="line-added"> 139             if (value-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value.get())-&gt;isPercentage()) {</span>
<span class="line-added"> 140                 auto doubleValue = downcast&lt;CSSPrimitiveValue&gt;(value.get())-&gt;doubleValue();</span>
<span class="line-added"> 141                 return makeString(doubleValue / 100.0);</span>
<span class="line-added"> 142             }</span>
<span class="line-added"> 143             FALLTHROUGH;</span>
<span class="line-added"> 144         default:</span>
<span class="line-added"> 145             return value-&gt;cssText();</span>
<span class="line-added"> 146         }</span>
<span class="line-added"> 147     }</span>
 148 
 149     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(propertyID);
 150     if (shorthand.length()) {
 151         RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[0]);
 152         if (!value || value-&gt;isPendingSubstitutionValue())
 153             return String();
 154     // FIXME: If all longhands are the same css-generic keyword(e.g. initial or inherit),
 155     // then the shorthand should be serialized to that keyword.
 156     // It seems to be needed to handle this in a single function commonly for all the shorthands,
 157     // not in each of the shorthand serialization function.
 158     // We could call that function here.
 159     }
 160 
 161     // Shorthand and 4-values properties
 162     switch (propertyID) {
 163     case CSSPropertyAll:
 164         return getCommonValue(allShorthand());
 165     case CSSPropertyAnimation:
 166         return getLayeredShorthandValue(animationShorthand());
 167     case CSSPropertyBorderSpacing:
</pre>
<hr />
<pre>
 206         return getShorthandValue(borderInlineStartShorthand());
 207     case CSSPropertyBorderInlineEnd:
 208         return getShorthandValue(borderInlineEndShorthand());
 209     case CSSPropertyOutline:
 210         return getShorthandValue(outlineShorthand());
 211     case CSSPropertyBorderColor:
 212         return get4Values(borderColorShorthand());
 213     case CSSPropertyBorderWidth:
 214         return get4Values(borderWidthShorthand());
 215     case CSSPropertyBorderStyle:
 216         return get4Values(borderStyleShorthand());
 217     case CSSPropertyColumnRule:
 218         return getShorthandValue(columnRuleShorthand());
 219     case CSSPropertyColumns:
 220         return getShorthandValue(columnsShorthand());
 221     case CSSPropertyFlex:
 222         return getShorthandValue(flexShorthand());
 223     case CSSPropertyFlexFlow:
 224         return getShorthandValue(flexFlowShorthand());
 225     case CSSPropertyGridArea:
<span class="line-modified"> 226         return getGridShorthandValue(gridAreaShorthand());</span>
 227     case CSSPropertyGridTemplate:
<span class="line-modified"> 228         return getGridShorthandValue(gridTemplateShorthand());</span>
 229     case CSSPropertyGrid:
<span class="line-modified"> 230         return getGridShorthandValue(gridShorthand());</span>
 231     case CSSPropertyGridColumn:
<span class="line-modified"> 232         return getGridShorthandValue(gridColumnShorthand());</span>
 233     case CSSPropertyGridRow:
<span class="line-modified"> 234         return getGridShorthandValue(gridRowShorthand());</span>
 235     case CSSPropertyPageBreakAfter:
 236         return pageBreakPropertyValue(pageBreakAfterShorthand());
 237     case CSSPropertyPageBreakBefore:
 238         return pageBreakPropertyValue(pageBreakBeforeShorthand());
 239     case CSSPropertyPageBreakInside:
 240         return pageBreakPropertyValue(pageBreakInsideShorthand());
 241     case CSSPropertyPlaceContent:
 242         return getAlignmentShorthandValue(placeContentShorthand());
 243     case CSSPropertyPlaceItems:
 244         return getAlignmentShorthandValue(placeItemsShorthand());
 245     case CSSPropertyPlaceSelf:
 246         return getAlignmentShorthandValue(placeSelfShorthand());
 247     case CSSPropertyFont:
 248         return fontValue();
 249     case CSSPropertyInset:
 250         return get4Values(insetShorthand());
 251     case CSSPropertyInsetBlock:
 252         return get2Values(insetBlockShorthand());
 253     case CSSPropertyInsetInline:
 254         return get2Values(insetInlineShorthand());
 255     case CSSPropertyMargin:
 256         return get4Values(marginShorthand());
 257     case CSSPropertyMarginBlock:
 258         return get2Values(marginBlockShorthand());
 259     case CSSPropertyMarginInline:
 260         return get2Values(marginInlineShorthand());
 261     case CSSPropertyWebkitMarginCollapse:
 262         return getShorthandValue(webkitMarginCollapseShorthand());
 263     case CSSPropertyOverflow:
<span class="line-modified"> 264         return get2Values(overflowShorthand());</span>
 265     case CSSPropertyPadding:
 266         return get4Values(paddingShorthand());
 267     case CSSPropertyPaddingBlock:
 268         return get2Values(paddingBlockShorthand());
 269     case CSSPropertyPaddingInline:
 270         return get2Values(paddingInlineShorthand());
 271     case CSSPropertyTransition:
 272         return getLayeredShorthandValue(transitionShorthand());
 273     case CSSPropertyListStyle:
 274         return getShorthandValue(listStyleShorthand());


 275     case CSSPropertyWebkitMaskPosition:
 276         return getLayeredShorthandValue(webkitMaskPositionShorthand());
 277     case CSSPropertyWebkitMaskRepeat:
 278         return getLayeredShorthandValue(webkitMaskRepeatShorthand());
 279     case CSSPropertyWebkitMask:
 280         return getLayeredShorthandValue(webkitMaskShorthand());
 281     case CSSPropertyWebkitTextEmphasis:
 282         return getShorthandValue(webkitTextEmphasisShorthand());
 283     case CSSPropertyWebkitTextStroke:
 284         return getShorthandValue(webkitTextStrokeShorthand());
 285     case CSSPropertyPerspectiveOrigin:
 286         return getShorthandValue(perspectiveOriginShorthand());
 287     case CSSPropertyTransformOrigin:
 288         return getShorthandValue(transformOriginShorthand());
 289     case CSSPropertyMarker: {
 290         RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(CSSPropertyMarkerStart);
 291         if (value)
 292             return value-&gt;cssText();
 293         return String();
 294     }
</pre>
<hr />
<pre>
 636                 commonValueInitialized = true;
 637             } else if (!commonValue.isNull() &amp;&amp; commonValue != valueText)
 638                 commonValue = String();
 639         }
 640 
 641         if (!layerResult.isEmpty()) {
 642             if (!result.isEmpty())
 643                 result.appendLiteral(&quot;, &quot;);
 644             result.append(layerResult);
 645         }
 646     }
 647 
 648     if (isInitialOrInherit(commonValue))
 649         return commonValue;
 650 
 651     if (result.isEmpty())
 652         return String();
 653     return result.toString();
 654 }
 655 
<span class="line-modified"> 656 String StyleProperties::getGridShorthandValue(const StylePropertyShorthand&amp; shorthand) const</span>
<span class="line-added"> 657 {</span>
<span class="line-added"> 658     return getShorthandValue(shorthand, &quot; / &quot;);</span>
<span class="line-added"> 659 }</span>
<span class="line-added"> 660 </span>
<span class="line-added"> 661 String StyleProperties::getShorthandValue(const StylePropertyShorthand&amp; shorthand, const char* separator) const</span>
 662 {
 663     String commonValue;
 664     StringBuilder result;
 665     for (unsigned i = 0; i &lt; shorthand.length(); ++i) {
 666         if (!isPropertyImplicit(shorthand.properties()[i])) {
 667             RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[i]);
 668             if (!value)
 669                 return String();
 670             String valueText = value-&gt;cssText();
 671             if (!i)
 672                 commonValue = valueText;
 673             else if (!commonValue.isNull() &amp;&amp; commonValue != valueText)
 674                 commonValue = String();
 675             if (value-&gt;isInitialValue())
 676                 continue;
 677             if (!result.isEmpty())
<span class="line-modified"> 678                 result.append(separator);</span>
 679             result.append(valueText);
 680         } else
 681             commonValue = String();
 682     }
 683     if (isInitialOrInherit(commonValue))
 684         return commonValue;
 685     if (result.isEmpty())
 686         return String();
 687     return result.toString();
 688 }
 689 
 690 // only returns a non-null value if all properties have the same, non-null value
 691 String StyleProperties::getCommonValue(const StylePropertyShorthand&amp; shorthand) const
 692 {
 693     String res;
 694     bool lastPropertyWasImportant = false;
 695     for (unsigned i = 0; i &lt; shorthand.length(); ++i) {
 696         RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[i]);
 697         if (!value)
 698             return String();
</pre>
<hr />
<pre>
1274             continue;
1275 
1276         if (numDecls++)
1277             result.append(&#39; &#39;);
1278 
1279         if (propertyID == CSSPropertyCustom)
1280             result.append(downcast&lt;CSSCustomPropertyValue&gt;(*property.value()).name());
1281         else
1282             result.append(getPropertyName(propertyID));
1283 
1284         result.appendLiteral(&quot;: &quot;);
1285         result.append(value);
1286         if (property.isImportant())
1287             result.appendLiteral(&quot; !important&quot;);
1288         result.append(&#39;;&#39;);
1289     }
1290 
1291     // FIXME: This is a not-so-nice way to turn x/y positions into single background-position in output.
1292     // It is required because background-position-x/y are non-standard properties and WebKit generated output
1293     // would not work in Firefox (&lt;rdar://problem/5143183&gt;)
<span class="line-modified">1294     // It would be a better solution if background-position was CSSUnitType::CSS_PAIR.</span>
1295     if (positionXPropertyIndex != -1 &amp;&amp; positionYPropertyIndex != -1 &amp;&amp; propertyAt(positionXPropertyIndex).isImportant() == propertyAt(positionYPropertyIndex).isImportant()) {
1296         PropertyReference positionXProperty = propertyAt(positionXPropertyIndex);
1297         PropertyReference positionYProperty = propertyAt(positionYPropertyIndex);
1298 
1299         if (numDecls++)
1300             result.append(&#39; &#39;);
1301         result.appendLiteral(&quot;background-position: &quot;);
1302         if (positionXProperty.value()-&gt;isValueList() || positionYProperty.value()-&gt;isValueList())
1303             result.append(getLayeredShorthandValue(backgroundPositionShorthand()));
1304         else {
1305             result.append(positionXProperty.value()-&gt;cssText());
1306             result.append(&#39; &#39;);
1307             result.append(positionYProperty.value()-&gt;cssText());
1308         }
1309         if (positionXProperty.isImportant())
1310             result.appendLiteral(&quot; !important&quot;);
1311         result.append(&#39;;&#39;);
1312     } else {
1313         if (positionXPropertyIndex != -1) {
1314             if (numDecls++)
</pre>
<hr />
<pre>
1455 int MutableStyleProperties::findPropertyIndex(CSSPropertyID propertyID) const
1456 {
1457     // Convert here propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1458     // the compiler converting it to an int multiple times in the loop.
1459     uint16_t id = static_cast&lt;uint16_t&gt;(propertyID);
1460     for (int n = m_propertyVector.size() - 1 ; n &gt;= 0; --n) {
1461         if (m_propertyVector.at(n).metadata().m_propertyID == id)
1462             return n;
1463     }
1464 
1465     return -1;
1466 }
1467 
1468 int ImmutableStyleProperties::findCustomPropertyIndex(const String&amp; propertyName) const
1469 {
1470     // Convert the propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1471     // the compiler converting it to an int multiple times in the loop.
1472     for (int n = m_arraySize - 1 ; n &gt;= 0; --n) {
1473         if (metadataArray()[n].m_propertyID == CSSPropertyCustom) {
1474             // We found a custom property. See if the name matches.
<span class="line-modified">1475             auto* value = valueArray()[n].get();</span>
<span class="line-added">1476             if (!value)</span>
1477                 continue;
<span class="line-modified">1478             if (downcast&lt;CSSCustomPropertyValue&gt;(*value).name() == propertyName)</span>
1479                 return n;
1480         }
1481     }
1482 
1483     return -1;
1484 }
1485 
1486 int MutableStyleProperties::findCustomPropertyIndex(const String&amp; propertyName) const
1487 {
1488     // Convert the propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1489     // the compiler converting it to an int multiple times in the loop.
1490     for (int n = m_propertyVector.size() - 1 ; n &gt;= 0; --n) {
1491         if (m_propertyVector.at(n).metadata().m_propertyID == CSSPropertyCustom) {
1492             // We found a custom property. See if the name matches.
1493             if (!m_propertyVector.at(n).value())
1494                 continue;
1495             if (downcast&lt;CSSCustomPropertyValue&gt;(*m_propertyVector.at(n).value()).name() == propertyName)
1496                 return n;
1497         }
1498     }
</pre>
<hr />
<pre>
1514     if (foundPropertyIndex == -1)
1515         return 0;
1516     return &amp;m_propertyVector.at(foundPropertyIndex);
1517 }
1518 
1519 bool StyleProperties::propertyMatches(CSSPropertyID propertyID, const CSSValue* propertyValue) const
1520 {
1521     int foundPropertyIndex = findPropertyIndex(propertyID);
1522     if (foundPropertyIndex == -1)
1523         return false;
1524     return propertyAt(foundPropertyIndex).value()-&gt;equals(*propertyValue);
1525 }
1526 
1527 Ref&lt;MutableStyleProperties&gt; StyleProperties::mutableCopy() const
1528 {
1529     return adoptRef(*new MutableStyleProperties(*this));
1530 }
1531 
1532 Ref&lt;MutableStyleProperties&gt; StyleProperties::copyPropertiesInSet(const CSSPropertyID* set, unsigned length) const
1533 {
<span class="line-modified">1534     Vector&lt;CSSProperty&gt; list;</span>
1535     list.reserveInitialCapacity(length);
1536     for (unsigned i = 0; i &lt; length; ++i) {
1537         if (auto value = getPropertyCSSValueInternal(set[i]))
1538             list.uncheckedAppend(CSSProperty(set[i], WTFMove(value), false));
1539     }
<span class="line-modified">1540     return MutableStyleProperties::create(WTFMove(list));</span>
1541 }
1542 
1543 PropertySetCSSStyleDeclaration* MutableStyleProperties::cssStyleDeclaration()
1544 {
1545     return m_cssomWrapper.get();
1546 }
1547 
1548 CSSStyleDeclaration&amp; MutableStyleProperties::ensureCSSStyleDeclaration()
1549 {
1550     if (m_cssomWrapper) {
1551         ASSERT(!static_cast&lt;CSSStyleDeclaration*&gt;(m_cssomWrapper.get())-&gt;parentRule());
1552         ASSERT(!m_cssomWrapper-&gt;parentElement());
1553         return *m_cssomWrapper;
1554     }
1555     m_cssomWrapper = makeUnique&lt;PropertySetCSSStyleDeclaration&gt;(*this);
1556     return *m_cssomWrapper;
1557 }
1558 
1559 CSSStyleDeclaration&amp; MutableStyleProperties::ensureInlineCSSStyleDeclaration(StyledElement&amp; parentElement)
1560 {
</pre>
<hr />
<pre>
1573 }
1574 
1575 // See the function above if you need to update this.
1576 struct SameSizeAsStyleProperties : public RefCounted&lt;SameSizeAsStyleProperties&gt; {
1577     unsigned bitfield;
1578 };
1579 COMPILE_ASSERT(sizeof(StyleProperties) == sizeof(SameSizeAsStyleProperties), style_property_set_should_stay_small);
1580 
1581 #ifndef NDEBUG
1582 void StyleProperties::showStyle()
1583 {
1584     fprintf(stderr, &quot;%s\n&quot;, asText().ascii().data());
1585 }
1586 #endif
1587 
1588 Ref&lt;MutableStyleProperties&gt; MutableStyleProperties::create(CSSParserMode cssParserMode)
1589 {
1590     return adoptRef(*new MutableStyleProperties(cssParserMode));
1591 }
1592 
<span class="line-modified">1593 Ref&lt;MutableStyleProperties&gt; MutableStyleProperties::create(Vector&lt;CSSProperty&gt;&amp;&amp; properties)</span>
1594 {
<span class="line-modified">1595     return adoptRef(*new MutableStyleProperties(WTFMove(properties)));</span>
1596 }
1597 
1598 String StyleProperties::PropertyReference::cssName() const
1599 {
1600     if (id() == CSSPropertyCustom)
1601         return downcast&lt;CSSCustomPropertyValue&gt;(*value()).name();
1602     return getPropertyNameString(id());
1603 }
1604 
1605 String StyleProperties::PropertyReference::cssText() const
1606 {
1607     StringBuilder result;
1608     result.append(cssName());
1609     result.appendLiteral(&quot;: &quot;);
1610     result.append(m_value-&gt;cssText());
1611     if (isImportant())
1612         result.appendLiteral(&quot; !important&quot;);
1613     result.append(&#39;;&#39;);
1614     return result.toString();
1615 }
</pre>
</td>
</tr>
</table>
<center><a href="StyleColor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleProperties.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Register.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ShadowChicken.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2016 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 32,24 ***</span>
  #include &lt;wtf/ListDump.h&gt;
  
  namespace JSC {
  
  namespace ShadowChickenInternal {
<span class="line-modified">! static const bool verbose = false;</span>
  }
  
  void ShadowChicken::Packet::dump(PrintStream&amp; out) const
  {
      if (!*this) {
          out.print(&quot;empty&quot;);
          return;
      }
  
      if (isPrologue()) {
          out.print(
              &quot;{callee = &quot;, RawPointer(callee), &quot;, frame = &quot;, RawPointer(frame), &quot;, callerFrame = &quot;,
<span class="line-modified">!             RawPointer(callerFrame), &quot;}&quot;);</span>
          return;
      }
  
      if (isTail()) {
          out.print(&quot;tail-packet:{frame = &quot;, RawPointer(frame), &quot;}&quot;);
<span class="line-new-header">--- 32,31 ---</span>
  #include &lt;wtf/ListDump.h&gt;
  
  namespace JSC {
  
  namespace ShadowChickenInternal {
<span class="line-modified">! static constexpr bool verbose = false;</span>
  }
  
  void ShadowChicken::Packet::dump(PrintStream&amp; out) const
  {
      if (!*this) {
          out.print(&quot;empty&quot;);
          return;
      }
  
      if (isPrologue()) {
<span class="line-added">+         String name = &quot;?&quot;_s;</span>
<span class="line-added">+         if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(callee-&gt;vm(), callee)) {</span>
<span class="line-added">+             name = function-&gt;name(callee-&gt;vm());</span>
<span class="line-added">+             if (name.isEmpty())</span>
<span class="line-added">+                 name = &quot;?&quot;_s;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          out.print(
              &quot;{callee = &quot;, RawPointer(callee), &quot;, frame = &quot;, RawPointer(frame), &quot;, callerFrame = &quot;,
<span class="line-modified">!             RawPointer(callerFrame), &quot;, name = &quot;, name, &quot;}&quot;);</span>
          return;
      }
  
      if (isTail()) {
          out.print(&quot;tail-packet:{frame = &quot;, RawPointer(frame), &quot;}&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,35 ***</span>
      out.print(&quot;throw&quot;);
  }
  
  void ShadowChicken::Frame::dump(PrintStream&amp; out) const
  {
      out.print(
<span class="line-modified">!         &quot;{callee = &quot;, RawPointer(callee), &quot;, frame = &quot;, RawPointer(frame), &quot;, isTailDeleted = &quot;,</span>
<span class="line-modified">!         isTailDeleted, &quot;}&quot;);</span>
  }
  
  ShadowChicken::ShadowChicken()
      : m_logSize(Options::shadowChickenLogSize())
  {
<span class="line-modified">!     m_log = static_cast&lt;Packet*&gt;(fastZeroedMalloc(sizeof(Packet) * m_logSize));</span>
      m_logCursor = m_log;
      m_logEnd = m_log + m_logSize;
  }
  
  ShadowChicken::~ShadowChicken()
  {
      fastFree(m_log);
  }
  
<span class="line-modified">! void ShadowChicken::log(VM&amp; vm, ExecState* exec, const Packet&amp; packet)</span>
  {
<span class="line-modified">!     update(vm, exec);</span>
      *m_logCursor++ = packet;
  }
  
<span class="line-modified">! void ShadowChicken::update(VM&amp; vm, ExecState* exec)</span>
  {
      if (ShadowChickenInternal::verbose) {
          dataLog(&quot;Running update on: &quot;, *this, &quot;\n&quot;);
          WTFReportBacktrace();
      }
<span class="line-new-header">--- 67,48 ---</span>
      out.print(&quot;throw&quot;);
  }
  
  void ShadowChicken::Frame::dump(PrintStream&amp; out) const
  {
<span class="line-added">+     String name = &quot;?&quot;_s;</span>
<span class="line-added">+     if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(callee-&gt;vm(), callee)) {</span>
<span class="line-added">+         name = function-&gt;name(callee-&gt;vm());</span>
<span class="line-added">+         if (name.isEmpty())</span>
<span class="line-added">+             name = &quot;?&quot;_s;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      out.print(
<span class="line-modified">!         &quot;{callee = &quot;, *callee, &quot;, frame = &quot;, RawPointer(frame), &quot;, isTailDeleted = &quot;,</span>
<span class="line-modified">!         isTailDeleted, &quot;, name = &quot;, name, &quot;}&quot;);</span>
  }
  
  ShadowChicken::ShadowChicken()
      : m_logSize(Options::shadowChickenLogSize())
  {
<span class="line-modified">!     // Allow one additional packet beyond m_logEnd. This is useful for the moment we</span>
<span class="line-added">+     // log a packet when the log is full and force an update. At that moment the packet</span>
<span class="line-added">+     // that is being logged should be included in the update because it may be</span>
<span class="line-added">+     // a critical prologue needed to rationalize the current machine stack with the</span>
<span class="line-added">+     // shadow stack.</span>
<span class="line-added">+     m_log = static_cast&lt;Packet*&gt;(fastZeroedMalloc(sizeof(Packet) * (m_logSize + 1)));</span>
      m_logCursor = m_log;
      m_logEnd = m_log + m_logSize;
  }
  
  ShadowChicken::~ShadowChicken()
  {
      fastFree(m_log);
  }
  
<span class="line-modified">! void ShadowChicken::log(VM&amp; vm, CallFrame* callFrame, const Packet&amp; packet)</span>
  {
<span class="line-modified">!     // This write is allowed because we construct the log with space for 1 additional packet.</span>
      *m_logCursor++ = packet;
<span class="line-added">+     update(vm, callFrame);</span>
  }
  
<span class="line-modified">! void ShadowChicken::update(VM&amp; vm, CallFrame* callFrame)</span>
  {
      if (ShadowChickenInternal::verbose) {
          dataLog(&quot;Running update on: &quot;, *this, &quot;\n&quot;);
          WTFReportBacktrace();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,11 ***</span>
      // that by figuring out how much of the shadow stack to pop. We apply three different rules. The
      // precise rule relies on the log. The log contains caller frames, which means that we know
      // where we bottomed out after making any call. If we bottomed out but made no calls then &#39;exec&#39;
      // will tell us. That&#39;s why &quot;highestPointSinceLastTime&quot; will go no lower than exec. The third
      // rule, based on comparing to the current real stack, is executed in a later loop.
<span class="line-modified">!     CallFrame* highestPointSinceLastTime = exec;</span>
      for (unsigned i = logCursorIndex; i--;) {
          Packet packet = m_log[i];
          if (packet.isPrologue()) {
              CallFrame* watermark;
              if (i &amp;&amp; m_log[i - 1].isTail())
<span class="line-new-header">--- 119,11 ---</span>
      // that by figuring out how much of the shadow stack to pop. We apply three different rules. The
      // precise rule relies on the log. The log contains caller frames, which means that we know
      // where we bottomed out after making any call. If we bottomed out but made no calls then &#39;exec&#39;
      // will tell us. That&#39;s why &quot;highestPointSinceLastTime&quot; will go no lower than exec. The third
      // rule, based on comparing to the current real stack, is executed in a later loop.
<span class="line-modified">!     CallFrame* highestPointSinceLastTime = callFrame;</span>
      for (unsigned i = logCursorIndex; i--;) {
          Packet packet = m_log[i];
          if (packet.isPrologue()) {
              CallFrame* watermark;
              if (i &amp;&amp; m_log[i - 1].isTail())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,23 ***</span>
                  break;
              }
          }
      }
  
<span class="line-removed">- </span>
      if (ShadowChickenInternal::verbose)
          dataLog(&quot;    Revised stack: &quot;, listDump(m_stack), &quot;\n&quot;);
  
<span class="line-modified">!     // The log-based and exec-based rules require that ShadowChicken was enabled. The point of</span>
      // ShadowChicken is to give sensible-looking results even if we had not logged. This means that
      // we need to reconcile the shadow stack and the real stack by actually looking at the real
      // stack. This reconciliation allows the shadow stack to have extra tail-deleted frames, but it
      // forbids it from diverging from the real stack on normal frames.
      if (!m_stack.isEmpty()) {
          Vector&lt;Frame&gt; stackRightNow;
          StackVisitor::visit(
<span class="line-modified">!             exec, &amp;vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
                  if (visitor-&gt;isInlinedFrame())
                      return StackVisitor::Continue;
                  if (visitor-&gt;isWasmFrame()) {
                      // FIXME: Make shadow chicken work with Wasm.
                      // https://bugs.webkit.org/show_bug.cgi?id=165441
<span class="line-new-header">--- 160,22 ---</span>
                  break;
              }
          }
      }
  
      if (ShadowChickenInternal::verbose)
          dataLog(&quot;    Revised stack: &quot;, listDump(m_stack), &quot;\n&quot;);
  
<span class="line-modified">!     // The log-based and callFrame-based rules require that ShadowChicken was enabled. The point of</span>
      // ShadowChicken is to give sensible-looking results even if we had not logged. This means that
      // we need to reconcile the shadow stack and the real stack by actually looking at the real
      // stack. This reconciliation allows the shadow stack to have extra tail-deleted frames, but it
      // forbids it from diverging from the real stack on normal frames.
      if (!m_stack.isEmpty()) {
          Vector&lt;Frame&gt; stackRightNow;
          StackVisitor::visit(
<span class="line-modified">!             callFrame, vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
                  if (visitor-&gt;isInlinedFrame())
                      return StackVisitor::Continue;
                  if (visitor-&gt;isWasmFrame()) {
                      // FIXME: Make shadow chicken work with Wasm.
                      // https://bugs.webkit.org/show_bug.cgi?id=165441
</pre>
<hr />
<pre>
<span class="line-old-header">*** 273,11 ***</span>
          return false;
      };
  
      Vector&lt;Frame&gt; toPush;
      StackVisitor::visit(
<span class="line-modified">!         exec, &amp;vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
              if (visitor-&gt;isInlinedFrame()) {
                  // FIXME: Handle inlining.
                  // https://bugs.webkit.org/show_bug.cgi?id=155686
                  return StackVisitor::Continue;
              }
<span class="line-new-header">--- 292,11 ---</span>
          return false;
      };
  
      Vector&lt;Frame&gt; toPush;
      StackVisitor::visit(
<span class="line-modified">!         callFrame, vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
              if (visitor-&gt;isInlinedFrame()) {
                  // FIXME: Handle inlining.
                  // https://bugs.webkit.org/show_bug.cgi?id=155686
                  return StackVisitor::Continue;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,23 ***</span>
                  // FIXME: Make shadow chicken work with Wasm.
                  return StackVisitor::Continue;
              }
  
              CallFrame* callFrame = visitor-&gt;callFrame();
<span class="line-modified">!             if (ShadowChickenInternal::verbose)</span>
<span class="line-modified">!                 dataLog(&quot;    Examining &quot;, RawPointer(callFrame), &quot;\n&quot;);</span>
              if (callFrame == highestPointSinceLastTime) {
                  if (ShadowChickenInternal::verbose)
<span class="line-modified">!                     dataLog(&quot;    Bailing at &quot;, RawPointer(callFrame), &quot; because it&#39;s the highest point since last time.\n&quot;);</span>
                  return StackVisitor::Done;
              }
  
              bool foundFrame = advanceIndexInLogTo(callFrame, callFrame-&gt;jsCallee(), callFrame-&gt;callerFrame());
              bool isTailDeleted = false;
              JSScope* scope = nullptr;
              CodeBlock* codeBlock = callFrame-&gt;codeBlock();
<span class="line-modified">!             JSValue scopeValue = callFrame-&gt;bytecodeOffset() &amp;&amp; codeBlock &amp;&amp; codeBlock-&gt;scopeRegister().isValid()</span>
                  ? callFrame-&gt;registers()[codeBlock-&gt;scopeRegister().offset()].jsValue()
                  : jsUndefined();
              if (!scopeValue.isUndefined() &amp;&amp; codeBlock-&gt;wasCompiledWithDebuggingOpcodes()) {
                  scope = jsCast&lt;JSScope*&gt;(scopeValue.asCell());
                  RELEASE_ASSERT(scope-&gt;inherits&lt;JSScope&gt;(vm));
<span class="line-new-header">--- 305,33 ---</span>
                  // FIXME: Make shadow chicken work with Wasm.
                  return StackVisitor::Continue;
              }
  
              CallFrame* callFrame = visitor-&gt;callFrame();
<span class="line-modified">!             if (ShadowChickenInternal::verbose) {</span>
<span class="line-modified">!                 dataLog(&quot;    Examining callFrame:&quot;, RawPointer(callFrame), &quot;, callee:&quot;, RawPointer(callFrame-&gt;jsCallee()), &quot;, callerFrame:&quot;, RawPointer(callFrame-&gt;callerFrame()), &quot;\n&quot;);</span>
<span class="line-added">+                 JSObject* callee = callFrame-&gt;jsCallee();</span>
<span class="line-added">+                 if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(callee-&gt;vm(), callee))</span>
<span class="line-added">+                     dataLog(&quot;      Function = &quot;, function-&gt;name(callee-&gt;vm()), &quot;\n&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              if (callFrame == highestPointSinceLastTime) {
                  if (ShadowChickenInternal::verbose)
<span class="line-modified">!                     dataLog(&quot;    Bailing at &quot;, RawPointer(callFrame), &quot; because it&#39;s the highest point since last time\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // FIXME: At this point the shadow stack may still have tail deleted frames</span>
<span class="line-added">+                 // that do not run into the current call frame but are left in the shadow stack.</span>
<span class="line-added">+                 // Those tail deleted frames should be validated somehow.</span>
<span class="line-added">+ </span>
                  return StackVisitor::Done;
              }
  
              bool foundFrame = advanceIndexInLogTo(callFrame, callFrame-&gt;jsCallee(), callFrame-&gt;callerFrame());
              bool isTailDeleted = false;
              JSScope* scope = nullptr;
              CodeBlock* codeBlock = callFrame-&gt;codeBlock();
<span class="line-modified">!             JSValue scopeValue = callFrame-&gt;bytecodeIndex() &amp;&amp; codeBlock &amp;&amp; codeBlock-&gt;scopeRegister().isValid()</span>
                  ? callFrame-&gt;registers()[codeBlock-&gt;scopeRegister().offset()].jsValue()
                  : jsUndefined();
              if (!scopeValue.isUndefined() &amp;&amp; codeBlock-&gt;wasCompiledWithDebuggingOpcodes()) {
                  scope = jsCast&lt;JSScope*&gt;(scopeValue.asCell());
                  RELEASE_ASSERT(scope-&gt;inherits&lt;JSScope&gt;(vm));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,11 ***</span>
              if (indexInLog &lt; logCursorIndex
                  // This condition protects us from the case where advanceIndexInLogTo didn&#39;t find
                  // anything.
                  &amp;&amp; m_log[indexInLog].frame == toPush.last().frame) {
                  if (ShadowChickenInternal::verbose)
<span class="line-modified">!                     dataLog(&quot;    Going to loop through to find tail deleted frames with indexInLog = &quot;, indexInLog, &quot; and push-stack top = &quot;, toPush.last(), &quot;\n&quot;);</span>
                  for (;;) {
                      ASSERT(m_log[indexInLog].frame == toPush.last().frame);
  
                      // Right now the index is pointing at a prologue packet of the last frame that
                      // we pushed. Peek behind that packet to see if there is a tail packet. If there
<span class="line-new-header">--- 345,11 ---</span>
              if (indexInLog &lt; logCursorIndex
                  // This condition protects us from the case where advanceIndexInLogTo didn&#39;t find
                  // anything.
                  &amp;&amp; m_log[indexInLog].frame == toPush.last().frame) {
                  if (ShadowChickenInternal::verbose)
<span class="line-modified">!                     dataLog(&quot;    Going to loop through to find tail deleted frames using &quot;, RawPointer(callFrame), &quot; with indexInLog = &quot;, indexInLog, &quot; and push-stack top = &quot;, toPush.last(), &quot;\n&quot;);</span>
                  for (;;) {
                      ASSERT(m_log[indexInLog].frame == toPush.last().frame);
  
                      // Right now the index is pointing at a prologue packet of the last frame that
                      // we pushed. Peek behind that packet to see if there is a tail packet. If there
</pre>
<hr />
<pre>
<span class="line-old-header">*** 339,10 ***</span>
<span class="line-new-header">--- 368,14 ---</span>
                          // https://bugs.webkit.org/show_bug.cgi?id=155687
                          break;
                      }
                      indexInLog--; // Skip over the tail packet.
  
<span class="line-added">+                     // FIXME: After a few iterations the tail packet referenced frame may not be the</span>
<span class="line-added">+                     // same as the original callFrame for the real stack frame we started with.</span>
<span class="line-added">+                     // It is unclear when we should break.</span>
<span class="line-added">+ </span>
                      if (!advanceIndexInLogTo(tailPacket.frame, nullptr, nullptr)) {
                          if (ShadowChickenInternal::verbose)
                              dataLog(&quot;Can&#39;t find prologue packet for tail: &quot;, RawPointer(tailPacket.frame), &quot;\n&quot;);
                          // We were unable to locate the prologue packet for this tail packet.
                          // This is rare but can happen in a situation like:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 377,11 ***</span>
          m_logCursor = m_log + 1;
      } else
          m_logCursor = m_log;
  
      if (ShadowChickenInternal::verbose)
<span class="line-modified">!         dataLog(&quot;    After pushing: &quot;, *this, &quot;\n&quot;);</span>
  
      // Remove tail frames until the number of tail deleted frames is small enough.
      const unsigned maxTailDeletedFrames = Options::shadowChickenMaxTailDeletedFramesSize();
      if (m_stack.size() &gt; maxTailDeletedFrames) {
          unsigned numberOfTailDeletedFrames = 0;
<span class="line-new-header">--- 410,11 ---</span>
          m_logCursor = m_log + 1;
      } else
          m_logCursor = m_log;
  
      if (ShadowChickenInternal::verbose)
<span class="line-modified">!         dataLog(&quot;    After pushing: &quot;, listDump(m_stack), &quot;\n&quot;);</span>
  
      // Remove tail frames until the number of tail deleted frames is small enough.
      const unsigned maxTailDeletedFrames = Options::shadowChickenMaxTailDeletedFramesSize();
      if (m_stack.size() &gt; maxTailDeletedFrames) {
          unsigned numberOfTailDeletedFrames = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 445,25 ***</span>
  
      CommaPrinter comma;
      unsigned limit = static_cast&lt;unsigned&gt;(m_logCursor - m_log);
      out.print(&quot;\n&quot;);
      for (unsigned i = 0; i &lt; limit; ++i)
<span class="line-modified">!         out.print(&quot;\t&quot;, comma, m_log[i], &quot;\n&quot;);</span>
      out.print(&quot;]}&quot;);
  }
  
<span class="line-modified">! JSArray* ShadowChicken::functionsOnStack(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSArray* result = constructEmptyArray(exec, 0);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      iterate(
<span class="line-modified">!         vm, exec,</span>
          [&amp;] (const Frame&amp; frame) -&gt; bool {
<span class="line-modified">!             result-&gt;push(exec, frame.callee);</span>
              scope.releaseAssertNoException(); // This function is only called from tests.
              return true;
          });
  
      return result;
<span class="line-new-header">--- 478,25 ---</span>
  
      CommaPrinter comma;
      unsigned limit = static_cast&lt;unsigned&gt;(m_logCursor - m_log);
      out.print(&quot;\n&quot;);
      for (unsigned i = 0; i &lt; limit; ++i)
<span class="line-modified">!         out.print(&quot;\t&quot;, comma, &quot;[&quot;, i, &quot;] &quot;, m_log[i], &quot;\n&quot;);</span>
      out.print(&quot;]}&quot;);
  }
  
<span class="line-modified">! JSArray* ShadowChicken::functionsOnStack(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSArray* result = constructEmptyArray(globalObject, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      iterate(
<span class="line-modified">!         vm, callFrame,</span>
          [&amp;] (const Frame&amp; frame) -&gt; bool {
<span class="line-modified">!             result-&gt;push(globalObject, frame.callee);</span>
              scope.releaseAssertNoException(); // This function is only called from tests.
              return true;
          });
  
      return result;
</pre>
<center><a href="Register.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ShadowChicken.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
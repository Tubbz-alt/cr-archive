<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyModuleRecord.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebAssemblyModuleRecord.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;Error.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;JSLexicalEnvironment.h&quot;
 34 #include &quot;JSModuleEnvironment.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 35 #include &quot;JSWebAssemblyGlobal.h&quot;</span>
 36 #include &quot;JSWebAssemblyHelpers.h&quot;
 37 #include &quot;JSWebAssemblyInstance.h&quot;
 38 #include &quot;JSWebAssemblyLinkError.h&quot;
 39 #include &quot;JSWebAssemblyModule.h&quot;
 40 #include &quot;ProtoCallFrame.h&quot;
 41 #include &quot;WasmSignatureInlines.h&quot;
 42 #include &quot;WebAssemblyFunction.h&quot;
 43 #include &lt;limits&gt;
 44 
 45 namespace JSC {
 46 
 47 const ClassInfo WebAssemblyModuleRecord::s_info = { &quot;WebAssemblyModuleRecord&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WebAssemblyModuleRecord) };
 48 
 49 Structure* WebAssemblyModuleRecord::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 50 {
 51     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 52 }
 53 
<a name="2" id="anc2"></a><span class="line-modified"> 54 WebAssemblyModuleRecord* WebAssemblyModuleRecord::create(JSGlobalObject* globalObject, VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey, const Wasm::ModuleInformation&amp; moduleInformation)</span>
 55 {
 56     WebAssemblyModuleRecord* instance = new (NotNull, allocateCell&lt;WebAssemblyModuleRecord&gt;(vm.heap)) WebAssemblyModuleRecord(vm, structure, moduleKey);
<a name="3" id="anc3"></a><span class="line-modified"> 57     instance-&gt;finishCreation(globalObject, vm, moduleInformation);</span>
 58     return instance;
 59 }
 60 
 61 WebAssemblyModuleRecord::WebAssemblyModuleRecord(VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey)
 62     : Base(vm, structure, moduleKey)
 63 {
 64 }
 65 
 66 void WebAssemblyModuleRecord::destroy(JSCell* cell)
 67 {
 68     WebAssemblyModuleRecord* thisObject = static_cast&lt;WebAssemblyModuleRecord*&gt;(cell);
 69     thisObject-&gt;WebAssemblyModuleRecord::~WebAssemblyModuleRecord();
 70 }
 71 
<a name="4" id="anc4"></a><span class="line-modified"> 72 void WebAssemblyModuleRecord::finishCreation(JSGlobalObject* globalObject, VM&amp; vm, const Wasm::ModuleInformation&amp; moduleInformation)</span>
 73 {
<a name="5" id="anc5"></a><span class="line-modified"> 74     Base::finishCreation(globalObject, vm);</span>
 75     ASSERT(inherits(vm, info()));
 76     for (const auto&amp; exp : moduleInformation.exports) {
 77         Identifier field = Identifier::fromString(vm, String::fromUTF8(exp.field));
 78         addExportEntry(ExportEntry::createLocal(field, field));
 79     }
 80 }
 81 
 82 void WebAssemblyModuleRecord::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 83 {
 84     WebAssemblyModuleRecord* thisObject = jsCast&lt;WebAssemblyModuleRecord*&gt;(cell);
 85     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 86     Base::visitChildren(thisObject, visitor);
 87     visitor.append(thisObject-&gt;m_instance);
 88     visitor.append(thisObject-&gt;m_startFunction);
 89 }
 90 
 91 void WebAssemblyModuleRecord::prepareLink(VM&amp; vm, JSWebAssemblyInstance* instance)
 92 {
 93     RELEASE_ASSERT(!m_instance);
 94     m_instance.set(vm, this, instance);
 95 }
 96 
<a name="6" id="anc6"></a><span class="line-modified"> 97 void WebAssemblyModuleRecord::link(JSGlobalObject* globalObject, JSValue, JSObject* importObject, Wasm::CreationMode creationMode)</span>
 98 {
<a name="7" id="anc7"></a><span class="line-modified"> 99     VM&amp; vm = globalObject-&gt;vm();</span>
100     auto scope = DECLARE_THROW_SCOPE(vm);
101     UNUSED_PARAM(scope);
<a name="8" id="anc8"></a>
102 
103     RELEASE_ASSERT(m_instance);
104 
105     Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
106     JSWebAssemblyModule* module = m_instance-&gt;module();
107     const Wasm::ModuleInformation&amp; moduleInformation = module-&gt;moduleInformation();
108 
109     auto exception = [&amp;] (JSObject* error) {
<a name="9" id="anc9"></a><span class="line-modified">110         throwException(globalObject, scope, error);</span>
111     };
112 
113     auto importFailMessage = [&amp;] (const Wasm::Import&amp; import, const char* before, const char* after) {
114         return makeString(before, &quot; &quot;, String::fromUTF8(import.module), &quot;:&quot;, String::fromUTF8(import.field), &quot; &quot;, after);
115     };
116 
117     for (const auto&amp; import : moduleInformation.imports) {
118         // Validation and linking other than Wasm::ExternalKind::Function is already done in JSWebAssemblyInstance.
119         // Eventually we will move all the linking code in JSWebAssemblyInstance here and remove this switch statement.
120         switch (import.kind) {
121         case Wasm::ExternalKind::Function:
122         case Wasm::ExternalKind::Global:
123         case Wasm::ExternalKind::Table:
124             break;
125         case Wasm::ExternalKind::Memory:
126             continue;
127         }
128 
129         Identifier moduleName = Identifier::fromString(vm, String::fromUTF8(import.module));
130         Identifier fieldName = Identifier::fromString(vm, String::fromUTF8(import.field));
131         JSValue value;
132         if (creationMode == Wasm::CreationMode::FromJS) {
133             // 1. Let o be the resultant value of performing Get(importObject, i.module_name).
<a name="10" id="anc10"></a><span class="line-modified">134             JSValue importModuleValue = importObject-&gt;get(globalObject, moduleName);</span>
135             RETURN_IF_EXCEPTION(scope, void());
136             // 2. If Type(o) is not Object, throw a TypeError.
137             if (!importModuleValue.isObject())
<a name="11" id="anc11"></a><span class="line-modified">138                 return exception(createTypeError(globalObject, importFailMessage(import, &quot;import&quot;, &quot;must be an object&quot;), defaultSourceAppender, runtimeTypeForValue(vm, importModuleValue)));</span>
139 
140             // 3. Let v be the value of performing Get(o, i.item_name)
141             JSObject* object = jsCast&lt;JSObject*&gt;(importModuleValue);
<a name="12" id="anc12"></a><span class="line-modified">142             value = object-&gt;get(globalObject, fieldName);</span>
143             RETURN_IF_EXCEPTION(scope, void());
144         } else {
<a name="13" id="anc13"></a><span class="line-modified">145             AbstractModuleRecord* importedModule = hostResolveImportedModule(globalObject, moduleName);</span>
146             RETURN_IF_EXCEPTION(scope, void());
<a name="14" id="anc14"></a><span class="line-modified">147             Resolution resolution = importedModule-&gt;resolveExport(globalObject, fieldName);</span>
148             RETURN_IF_EXCEPTION(scope, void());
149             switch (resolution.type) {
150             case Resolution::Type::NotFound:
<a name="15" id="anc15"></a><span class="line-modified">151                 throwSyntaxError(globalObject, scope, makeString(&quot;Importing binding name &#39;&quot;, String(fieldName.impl()), &quot;&#39; is not found.&quot;));</span>
152                 return;
153 
154             case Resolution::Type::Ambiguous:
<a name="16" id="anc16"></a><span class="line-modified">155                 throwSyntaxError(globalObject, scope, makeString(&quot;Importing binding name &#39;&quot;, String(fieldName.impl()), &quot;&#39; cannot be resolved due to ambiguous multiple bindings.&quot;));</span>
156                 return;
157 
158             case Resolution::Type::Error:
<a name="17" id="anc17"></a><span class="line-modified">159                 throwSyntaxError(globalObject, scope, makeString(&quot;Importing binding name &#39;default&#39; cannot be resolved by star export entries.&quot;));</span>
160                 return;
161 
162             case Resolution::Type::Resolved:
163                 break;
164             }
165 
166             AbstractModuleRecord* importedRecord = resolution.moduleRecord;
167             JSModuleEnvironment* importedEnvironment = importedRecord-&gt;moduleEnvironmentMayBeNull();
168             // It means that target module is not linked yet. In wasm loading, we allow this since we do not solve cyclic resolution as if JS&#39;s bindings.
169             // At that time, error occurs since |value| is an empty, and later |value| becomes an undefined.
170             // https://github.com/WebAssembly/esm-integration/tree/master/proposals/esm-integration#js---wasm-cycle-where-js-is-higher-in-the-module-graph
171             if (importedEnvironment) {
172                 SymbolTable* symbolTable = importedEnvironment-&gt;symbolTable();
173                 ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
174                 auto iter = symbolTable-&gt;find(locker, resolution.localName.impl());
175                 ASSERT(iter != symbolTable-&gt;end(locker));
176                 SymbolTableEntry&amp; entry = iter-&gt;value;
177                 ASSERT(!entry.isNull());
178                 ASSERT(importedEnvironment-&gt;isValidScopeOffset(entry.scopeOffset()));
179 
180                 // Snapshotting a value.
181                 value = importedEnvironment-&gt;variableAt(entry.scopeOffset()).get();
182             }
183         }
184         if (!value)
185             value = jsUndefined();
186 
187         switch (import.kind) {
188         case Wasm::ExternalKind::Function: {
189             // 4. If i is a function import:
190             // i. If IsCallable(v) is false, throw a WebAssembly.LinkError.
191             if (!value.isFunction(vm))
<a name="18" id="anc18"></a><span class="line-modified">192                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;import function&quot;, &quot;must be callable&quot;)));</span>
193 
194             Wasm::Instance* calleeInstance = nullptr;
195             WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = nullptr;
196             JSObject* function = jsCast&lt;JSObject*&gt;(value);
197 
198             // ii. If v is an Exported Function Exotic Object:
199             WebAssemblyFunction* wasmFunction;
200             WebAssemblyWrapperFunction* wasmWrapperFunction;
201             if (isWebAssemblyHostFunction(vm, function, wasmFunction, wasmWrapperFunction)) {
202                 // a. If the signature of v does not match the signature of i, throw a WebAssembly.LinkError.
203                 Wasm::SignatureIndex importedSignatureIndex;
204                 if (wasmFunction) {
205                     importedSignatureIndex = wasmFunction-&gt;signatureIndex();
206                     calleeInstance = &amp;wasmFunction-&gt;instance()-&gt;instance();
207                     entrypointLoadLocation = wasmFunction-&gt;entrypointLoadLocation();
208                 } else {
209                     importedSignatureIndex = wasmWrapperFunction-&gt;signatureIndex();
210                     // b. Let closure be v.[[Closure]].
211                     function = wasmWrapperFunction-&gt;function();
212                 }
213                 Wasm::SignatureIndex expectedSignatureIndex = moduleInformation.importFunctionSignatureIndices[import.kindIndex];
214                 if (importedSignatureIndex != expectedSignatureIndex)
<a name="19" id="anc19"></a><span class="line-modified">215                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported function&quot;, &quot;signature doesn&#39;t match the provided WebAssembly function&#39;s signature&quot;)));</span>
216             }
217             // iii. Otherwise:
218             // a. Let closure be a new host function of the given signature which calls v by coercing WebAssembly arguments to JavaScript arguments via ToJSValue and returns the result, if any, by coercing via ToWebAssemblyValue.
219             // Note: done as part of Plan compilation.
220             // iv. Append v to funcs.
221             // Note: adding the JSCell to the instance list fulfills closure requirements b. above (the WebAssembly.Instance wil be kept alive) and v. below (the JSFunction).
222 
223             auto* info = m_instance-&gt;instance().importFunctionInfo(import.kindIndex);
224             info-&gt;targetInstance = calleeInstance;
225             info-&gt;wasmEntrypointLoadLocation = entrypointLoadLocation;
226             m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(import.kindIndex)-&gt;set(vm, m_instance.get(), function);
227             break;
228         }
229 
230         case Wasm::ExternalKind::Global: {
231             // 5. If i is a global import:
<a name="20" id="anc20"></a><span class="line-modified">232             const Wasm::GlobalInformation&amp; global = moduleInformation.globals[import.kindIndex];</span>
<span class="line-modified">233             if (global.mutability == Wasm::GlobalInformation::Immutable) {</span>
<span class="line-modified">234                 if (value.inherits&lt;JSWebAssemblyGlobal&gt;(vm)) {</span>
<span class="line-modified">235                     JSWebAssemblyGlobal* globalValue = jsCast&lt;JSWebAssemblyGlobal*&gt;(value);</span>
<span class="line-modified">236                     if (globalValue-&gt;global()-&gt;type() != global.type)</span>
<span class="line-modified">237                         return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a same type&quot;)));</span>
<span class="line-modified">238                     if (globalValue-&gt;global()-&gt;mutability() != Wasm::GlobalInformation::Immutable)</span>
<span class="line-modified">239                         return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a same mutability&quot;)));</span>
<span class="line-modified">240                     switch (moduleInformation.globals[import.kindIndex].type) {</span>
<span class="line-modified">241                     case Wasm::Funcref:</span>
<span class="line-modified">242                         value = globalValue-&gt;global()-&gt;get();</span>
<span class="line-modified">243                         if (!isWebAssemblyHostFunction(vm, value) &amp;&amp; !value.isNull())</span>
<span class="line-modified">244                             return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a wasm exported function or null&quot;)));</span>
<span class="line-modified">245                         m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-modified">246                         break;</span>
<span class="line-modified">247                     case Wasm::Anyref:</span>
<span class="line-modified">248                         value = globalValue-&gt;global()-&gt;get();</span>
<span class="line-modified">249                         m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-modified">250                         break;</span>
<span class="line-modified">251                     case Wasm::I32:</span>
<span class="line-modified">252                     case Wasm::I64:</span>
<span class="line-modified">253                     case Wasm::F32:</span>
<span class="line-modified">254                     case Wasm::F64:</span>
<span class="line-modified">255                         m_instance-&gt;instance().setGlobal(import.kindIndex, globalValue-&gt;global()-&gt;getPrimitive());</span>
<span class="line-modified">256                         break;</span>
<span class="line-modified">257                     default:</span>
<span class="line-modified">258                         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-modified">259                     }</span>
<span class="line-added">260                 } else {</span>
<span class="line-added">261                     // ii. If the global_type of i is i64 or Type(v) is not Number, throw a WebAssembly.LinkError.</span>
<span class="line-added">262                     if (moduleInformation.globals[import.kindIndex].type == Wasm::I64)</span>
<span class="line-added">263                         return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;cannot be an i64&quot;)));</span>
<span class="line-added">264                     if (!isSubtype(moduleInformation.globals[import.kindIndex].type, Wasm::Anyref) &amp;&amp; !value.isNumber())</span>
<span class="line-added">265                         return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a number&quot;)));</span>
<span class="line-added">266 </span>
<span class="line-added">267                     // iii. Append ToWebAssemblyValue(v) to imports.</span>
<span class="line-added">268                     switch (moduleInformation.globals[import.kindIndex].type) {</span>
<span class="line-added">269                     case Wasm::Funcref:</span>
<span class="line-added">270                         if (!isWebAssemblyHostFunction(vm, value) &amp;&amp; !value.isNull())</span>
<span class="line-added">271                             return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a wasm exported function or null&quot;)));</span>
<span class="line-added">272                         m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-added">273                         break;</span>
<span class="line-added">274                     case Wasm::Anyref:</span>
<span class="line-added">275                         m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-added">276                         break;</span>
<span class="line-added">277                     case Wasm::I32:</span>
<span class="line-added">278                         m_instance-&gt;instance().setGlobal(import.kindIndex, value.toInt32(globalObject));</span>
<span class="line-added">279                         break;</span>
<span class="line-added">280                     case Wasm::F32:</span>
<span class="line-added">281                         m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint32_t&gt;(value.toFloat(globalObject)));</span>
<span class="line-added">282                         break;</span>
<span class="line-added">283                     case Wasm::F64:</span>
<span class="line-added">284                         m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint64_t&gt;(value.asNumber()));</span>
<span class="line-added">285                         break;</span>
<span class="line-added">286                     default:</span>
<span class="line-added">287                         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">288                     }</span>
<span class="line-added">289                 }</span>
<span class="line-added">290             } else {</span>
<span class="line-added">291                 if (!value.inherits&lt;JSWebAssemblyGlobal&gt;(vm))</span>
<span class="line-added">292                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a WebAssembly.Global object since it is mutable&quot;)));</span>
<span class="line-added">293                 JSWebAssemblyGlobal* globalValue = jsCast&lt;JSWebAssemblyGlobal*&gt;(value);</span>
<span class="line-added">294                 if (globalValue-&gt;global()-&gt;type() != global.type)</span>
<span class="line-added">295                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a same type&quot;)));</span>
<span class="line-added">296                 if (globalValue-&gt;global()-&gt;mutability() != global.mutability)</span>
<span class="line-added">297                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a same mutability&quot;)));</span>
<span class="line-added">298                 m_instance-&gt;linkGlobal(vm, import.kindIndex, globalValue);</span>
299             }
300             scope.assertNoException();
301             break;
302         }
303 
304         case Wasm::ExternalKind::Table: {
305             // 7. Otherwise (i is a table import):
306             JSWebAssemblyTable* table = jsDynamicCast&lt;JSWebAssemblyTable*&gt;(vm, value);
307             // i. If v is not a WebAssembly.Table object, throw a WebAssembly.LinkError.
308             if (!table)
<a name="21" id="anc21"></a><span class="line-modified">309                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Table import&quot;, &quot;is not an instance of WebAssembly.Table&quot;)));</span>
310 
311             uint32_t expectedInitial = moduleInformation.tables[import.kindIndex].initial();
312             uint32_t actualInitial = table-&gt;length();
313             if (actualInitial &lt; expectedInitial)
<a name="22" id="anc22"></a><span class="line-modified">314                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided an &#39;initial&#39; that is too small&quot;)));</span>
315 
316             if (Optional&lt;uint32_t&gt; expectedMaximum = moduleInformation.tables[import.kindIndex].maximum()) {
317                 Optional&lt;uint32_t&gt; actualMaximum = table-&gt;maximum();
318                 if (!actualMaximum)
<a name="23" id="anc23"></a><span class="line-modified">319                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Table import&quot;, &quot;does not have a &#39;maximum&#39; but the module requires that it does&quot;)));</span>
320                 if (*actualMaximum &gt; *expectedMaximum)
<a name="24" id="anc24"></a><span class="line-modified">321                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Imported Table&quot;, &quot;&#39;maximum&#39; is larger than the module&#39;s expected &#39;maximum&#39;&quot;)));</span>
322             }
323 
324             auto expectedType = moduleInformation.tables[import.kindIndex].type();
325             auto actualType = table-&gt;table()-&gt;type();
326             if (expectedType != actualType)
<a name="25" id="anc25"></a><span class="line-modified">327                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided a &#39;type&#39; that is wrong&quot;)));</span>
328 
329             // ii. Append v to tables.
330             // iii. Append v.[[Table]] to imports.
331             m_instance-&gt;setTable(vm, import.kindIndex, table);
332             RETURN_IF_EXCEPTION(scope, void());
333             break;
334         }
335 
336         case Wasm::ExternalKind::Memory:
337             break;
338         }
339     }
340 
341     for (unsigned i = 0; i &lt; moduleInformation.tableCount(); ++i) {
342         if (moduleInformation.tables[i].isImport()) {
343             // We should either have a Table import or we should have thrown an exception.
344             RELEASE_ASSERT(m_instance-&gt;table(i));
345         }
346 
347         if (!m_instance-&gt;table(i)) {
348             RELEASE_ASSERT(!moduleInformation.tables[i].isImport());
349             // We create a Table when it&#39;s a Table definition.
350             RefPtr&lt;Wasm::Table&gt; wasmTable = Wasm::Table::tryCreate(moduleInformation.tables[i].initial(), moduleInformation.tables[i].maximum(), moduleInformation.tables[i].type());
351             if (!wasmTable)
<a name="26" id="anc26"></a><span class="line-modified">352                 return exception(createJSWebAssemblyLinkError(globalObject, vm, &quot;couldn&#39;t create Table&quot;));</span>
<span class="line-modified">353             JSWebAssemblyTable* table = JSWebAssemblyTable::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyTableStructure(), wasmTable.releaseNonNull());</span>
354             // We should always be able to allocate a JSWebAssemblyTable we&#39;ve defined.
355             // If it&#39;s defined to be too large, we should have thrown a validation error.
356             scope.assertNoException();
357             ASSERT(table);
358             m_instance-&gt;setTable(vm, i, table);
359             RETURN_IF_EXCEPTION(scope, void());
360         }
361     }
362 
363     unsigned functionImportCount = codeBlock-&gt;functionImportCount();
364     auto makeFunctionWrapper = [&amp;] (const String&amp; field, uint32_t index) -&gt; JSValue {
365         // If we already made a wrapper, do not make a new one.
366         JSValue wrapper = m_instance-&gt;instance().getFunctionWrapper(index);
367 
368         if (!wrapper.isNull())
369             return wrapper;
370 
371         // 1. If e is a closure c:
372         //   i. If there is an Exported Function Exotic Object func in funcs whose func.[[Closure]] equals c, then return func.
373         //   ii. (Note: At most one wrapper is created for any closure, so func is unique, even if there are multiple occurrances in the list. Moreover, if the item was an import that is already an Exported Function Exotic Object, then the original function object will be found. For imports that are regular JS functions, a new wrapper will be created.)
374         if (index &lt; functionImportCount) {
375             JSObject* functionImport = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(index)-&gt;get();
376             if (isWebAssemblyHostFunction(vm, functionImport))
377                 wrapper = functionImport;
378             else {
379                 Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(index);
380                 wrapper = WebAssemblyWrapperFunction::create(vm, globalObject, globalObject-&gt;webAssemblyWrapperFunctionStructure(), functionImport, index, m_instance.get(), signatureIndex);
381             }
382         } else {
383             //   iii. Otherwise:
384             //     a. Let func be an Exported Function Exotic Object created from c.
385             //     b. Append func to funcs.
386             //     c. Return func.
387             Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(index);
388             Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(index);
389             Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(index);
390             const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
391             WebAssemblyFunction* function = WebAssemblyFunction::create(vm, globalObject, globalObject-&gt;webAssemblyFunctionStructure(), signature.argumentCount(), field, m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);
392             wrapper = function;
393         }
394 
395         ASSERT(wrapper.isFunction(vm));
396         m_instance-&gt;instance().setFunctionWrapper(index, wrapper);
397 
398         return wrapper;
399     };
400 
401     for (auto index : moduleInformation.referencedFunctions())
402         makeFunctionWrapper(&quot;Referenced function&quot;, index);
403 
404     // Globals
405     {
406         for (size_t globalIndex = moduleInformation.firstInternalGlobal; globalIndex &lt; moduleInformation.globals.size(); ++globalIndex) {
407             const auto&amp; global = moduleInformation.globals[globalIndex];
<a name="27" id="anc27"></a><span class="line-modified">408             ASSERT(global.initializationType != Wasm::GlobalInformation::IsImport);</span>
<span class="line-modified">409             uint64_t initialBits = 0;</span>
<span class="line-added">410             if (global.initializationType == Wasm::GlobalInformation::FromGlobalImport) {</span>
411                 ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.firstInternalGlobal);
<a name="28" id="anc28"></a><span class="line-modified">412                 initialBits = m_instance-&gt;instance().loadI64Global(global.initialBitsOrImportNumber);</span>
<span class="line-modified">413             } else if (global.initializationType == Wasm::GlobalInformation::FromRefFunc) {</span>
414                 ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.functionIndexSpaceSize());
415                 ASSERT(makeFunctionWrapper(&quot;Global init expr&quot;, global.initialBitsOrImportNumber).isFunction(vm));
<a name="29" id="anc29"></a><span class="line-modified">416                 initialBits = JSValue::encode(makeFunctionWrapper(&quot;Global init expr&quot;, global.initialBitsOrImportNumber));</span>
417             } else
<a name="30" id="anc30"></a><span class="line-modified">418                 initialBits = global.initialBitsOrImportNumber;</span>
<span class="line-added">419 </span>
<span class="line-added">420             switch (global.bindingMode) {</span>
<span class="line-added">421             case Wasm::GlobalInformation::BindingMode::EmbeddedInInstance: {</span>
<span class="line-added">422                 m_instance-&gt;instance().setGlobal(globalIndex, initialBits);</span>
<span class="line-added">423                 break;</span>
<span class="line-added">424             }</span>
<span class="line-added">425             case Wasm::GlobalInformation::BindingMode::Portable: {</span>
<span class="line-added">426                 ASSERT(global.mutability == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">427                 Ref&lt;Wasm::Global&gt; globalRef = Wasm::Global::create(global.type, Wasm::GlobalInformation::Mutability::Mutable, initialBits);</span>
<span class="line-added">428                 JSWebAssemblyGlobal* globalValue = JSWebAssemblyGlobal::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyGlobalStructure(), WTFMove(globalRef));</span>
<span class="line-added">429                 scope.assertNoException();</span>
<span class="line-added">430                 m_instance-&gt;linkGlobal(vm, globalIndex, globalValue);</span>
<span class="line-added">431                 keepAlive(bitwise_cast&lt;void*&gt;(initialBits)); // Ensure this is kept alive while creating JSWebAssemblyGlobal.</span>
<span class="line-added">432                 break;</span>
<span class="line-added">433             }</span>
<span class="line-added">434             }</span>
435         }
436     }
437 
438     SymbolTable* exportSymbolTable = module-&gt;exportSymbolTable();
439 
440     // Let exports be a list of (string, JS value) pairs that is mapped from each external value e in instance.exports as follows:
441     JSModuleEnvironment* moduleEnvironment = JSModuleEnvironment::create(vm, globalObject, nullptr, exportSymbolTable, JSValue(), this);
442     for (const auto&amp; exp : moduleInformation.exports) {
443         JSValue exportedValue;
444         switch (exp.kind) {
445         case Wasm::ExternalKind::Function: {
446             exportedValue = makeFunctionWrapper(String::fromUTF8(exp.field), exp.kindIndex);
447             ASSERT(exportedValue.isFunction(vm));
448             ASSERT(makeFunctionWrapper(String::fromUTF8(exp.field), exp.kindIndex) == exportedValue);
449             break;
450         }
451         case Wasm::ExternalKind::Table: {
452             // This should be guaranteed by module verification.
453             RELEASE_ASSERT(m_instance-&gt;table(exp.kindIndex));
454             exportedValue = m_instance-&gt;table(exp.kindIndex);
455             break;
456         }
457         case Wasm::ExternalKind::Memory: {
458             ASSERT(exp.kindIndex == 0);
459 
460             exportedValue = m_instance-&gt;memory();
461             break;
462         }
463         case Wasm::ExternalKind::Global: {
<a name="31" id="anc31"></a><span class="line-modified">464             const Wasm::GlobalInformation&amp; global = moduleInformation.globals[exp.kindIndex];</span>



465             switch (global.type) {
466             case Wasm::Anyref:
467             case Wasm::Funcref:
<a name="32" id="anc32"></a>


468             case Wasm::I32:
<a name="33" id="anc33"></a>


469             case Wasm::I64:
<a name="34" id="anc34"></a>


470             case Wasm::F32:
<a name="35" id="anc35"></a><span class="line-modified">471             case Wasm::F64: {</span>
<span class="line-modified">472                 // If global is immutable, we are not creating a binding internally.</span>
<span class="line-modified">473                 // But we need to create a binding just to export it. This binding is not actually connected. But this is OK since it is immutable.</span>
<span class="line-modified">474                 if (global.bindingMode == Wasm::GlobalInformation::BindingMode::EmbeddedInInstance) {</span>
<span class="line-modified">475                     uint64_t initialValue = m_instance-&gt;instance().loadI64Global(exp.kindIndex);</span>
<span class="line-added">476                     Ref&lt;Wasm::Global&gt; globalRef = Wasm::Global::create(global.type, global.mutability, initialValue);</span>
<span class="line-added">477                     exportedValue = JSWebAssemblyGlobal::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyGlobalStructure(), WTFMove(globalRef));</span>
<span class="line-added">478                     scope.assertNoException();</span>
<span class="line-added">479                 } else {</span>
<span class="line-added">480                     ASSERT(global.mutability == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">481                     RefPtr&lt;Wasm::Global&gt; globalRef = m_instance-&gt;instance().getGlobalBinding(exp.kindIndex);</span>
<span class="line-added">482                     ASSERT(globalRef);</span>
<span class="line-added">483                     ASSERT(globalRef-&gt;type() == global.type);</span>
<span class="line-added">484                     ASSERT(globalRef-&gt;mutability() == global.mutability);</span>
<span class="line-added">485                     ASSERT(globalRef-&gt;mutability() == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">486                     ASSERT(globalRef-&gt;owner&lt;JSWebAssemblyGlobal&gt;());</span>
<span class="line-added">487                     exportedValue = globalRef-&gt;owner&lt;JSWebAssemblyGlobal&gt;();</span>
<span class="line-added">488                 }</span>
489                 break;
<a name="36" id="anc36"></a><span class="line-modified">490             }</span>
491             default:
492                 RELEASE_ASSERT_NOT_REACHED();
493             }
494             break;
495         }
496         }
497 
498         bool shouldThrowReadOnlyError = false;
499         bool ignoreReadOnlyErrors = true;
500         bool putResult = false;
<a name="37" id="anc37"></a><span class="line-modified">501         symbolTablePutTouchWatchpointSet(moduleEnvironment, globalObject, Identifier::fromString(vm, String::fromUTF8(exp.field)), exportedValue, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
502         scope.assertNoException();
503         RELEASE_ASSERT(putResult);
504     }
505 
506     bool hasStart = !!moduleInformation.startFunctionIndexSpace;
507     if (hasStart) {
508         auto startFunctionIndexSpace = moduleInformation.startFunctionIndexSpace.valueOr(0);
509         Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndexSpace);
510         const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
511         // The start function must not take any arguments or return anything. This is enforced by the parser.
512         ASSERT(!signature.argumentCount());
<a name="38" id="anc38"></a><span class="line-modified">513         ASSERT(signature.returnsVoid());</span>
514         if (startFunctionIndexSpace &lt; codeBlock-&gt;functionImportCount()) {
515             JSObject* startFunction = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(startFunctionIndexSpace)-&gt;get();
516             m_startFunction.set(vm, this, startFunction);
517         } else {
518             Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(startFunctionIndexSpace);
519             Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(startFunctionIndexSpace);
520             WebAssemblyFunction* function = WebAssemblyFunction::create(vm, globalObject, globalObject-&gt;webAssemblyFunctionStructure(), signature.argumentCount(), &quot;start&quot;, m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);
521             m_startFunction.set(vm, this, function);
522         }
523     }
524     m_moduleEnvironment.set(vm, this, moduleEnvironment);
525 }
526 
527 template &lt;typename Scope, typename M, typename N, typename ...Args&gt;
<a name="39" id="anc39"></a><span class="line-modified">528 NEVER_INLINE static JSValue dataSegmentFail(JSGlobalObject* globalObject, VM&amp; vm, Scope&amp; scope, M memorySize, N segmentSize, N offset, Args... args)</span>
529 {
<a name="40" id="anc40"></a><span class="line-modified">530     return throwException(globalObject, scope, createJSWebAssemblyLinkError(globalObject, vm, makeString(&quot;Invalid data segment initialization: segment of &quot;_s, String::number(segmentSize), &quot; bytes memory of &quot;_s, String::number(memorySize), &quot; bytes, at offset &quot;_s, String::number(offset), args...)));</span>
531 }
532 
<a name="41" id="anc41"></a><span class="line-modified">533 JSValue WebAssemblyModuleRecord::evaluate(JSGlobalObject* globalObject)</span>
534 {
<a name="42" id="anc42"></a><span class="line-modified">535     VM&amp; vm = globalObject-&gt;vm();</span>
536     auto scope = DECLARE_THROW_SCOPE(vm);
537 
538     Wasm::Module&amp; module = m_instance-&gt;instance().module();
539     Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
540     const Wasm::ModuleInformation&amp; moduleInformation = module.moduleInformation();
541 
542     const Vector&lt;Wasm::Segment::Ptr&gt;&amp; data = moduleInformation.data;
543 
544     Optional&lt;JSValue&gt; exception;
545 
546     auto forEachElement = [&amp;] (auto fn) {
547         for (const Wasm::Element&amp; element : moduleInformation.elements) {
548             // It should be a validation error to have any elements without a table.
549             // Also, it could be that a table wasn&#39;t imported, or that the table
550             // imported wasn&#39;t compatible. However, those should error out before
551             // getting here.
552             ASSERT(!!m_instance-&gt;table(element.tableIndex));
553 
554             if (!element.functionIndices.size())
555                 continue;
556 
557             uint32_t elementIndex = element.offset.isGlobalImport()
558                 ? static_cast&lt;uint32_t&gt;(m_instance-&gt;instance().loadI32Global(element.offset.globalImportIndex()))
559                 : element.offset.constValue();
560 
561             fn(element, element.tableIndex, elementIndex);
562 
563             if (exception)
564                 break;
565         }
566     };
567 
568     auto forEachSegment = [&amp;] (auto fn) {
569         uint8_t* memory = reinterpret_cast&lt;uint8_t*&gt;(m_instance-&gt;instance().cachedMemory());
570         uint64_t sizeInBytes = m_instance-&gt;instance().cachedMemorySize();
571 
572         for (const Wasm::Segment::Ptr&amp; segment : data) {
573             uint32_t offset = segment-&gt;offset.isGlobalImport()
574                 ? static_cast&lt;uint32_t&gt;(m_instance-&gt;instance().loadI32Global(segment-&gt;offset.globalImportIndex()))
575                 : segment-&gt;offset.constValue();
576 
577             fn(memory, sizeInBytes, segment, offset);
578 
579             if (exception)
580                 break;
581         }
582     };
583 
584     // Validation of all element ranges comes before all Table and Memory initialization.
585     forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex, uint32_t elementIndex) {
586         uint64_t lastWrittenIndex = static_cast&lt;uint64_t&gt;(elementIndex) + static_cast&lt;uint64_t&gt;(element.functionIndices.size()) - 1;
587         if (UNLIKELY(lastWrittenIndex &gt;= m_instance-&gt;table(tableIndex)-&gt;length()))
<a name="43" id="anc43"></a><span class="line-modified">588             exception = JSValue(throwException(globalObject, scope, createJSWebAssemblyLinkError(globalObject, vm, &quot;Element is trying to set an out of bounds table index&quot;_s)));</span>
589     });
590 
591     if (UNLIKELY(exception))
592         return exception.value();
593 
594     // Validation of all segment ranges comes before all Table and Memory initialization.
595     forEachSegment([&amp;] (uint8_t*, uint64_t sizeInBytes, const Wasm::Segment::Ptr&amp; segment, uint32_t offset) {
596         if (UNLIKELY(sizeInBytes &lt; segment-&gt;sizeInBytes))
<a name="44" id="anc44"></a><span class="line-modified">597             exception = dataSegmentFail(globalObject, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment is too big&quot;_s);</span>
598         else if (UNLIKELY(offset &gt; sizeInBytes - segment-&gt;sizeInBytes))
<a name="45" id="anc45"></a><span class="line-modified">599             exception = dataSegmentFail(globalObject, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment writes outside of memory&quot;_s);</span>
600     });
601 
602     if (UNLIKELY(exception))
603         return exception.value();
604 
<a name="46" id="anc46"></a>
605     forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex, uint32_t elementIndex) {
606         for (uint32_t i = 0; i &lt; element.functionIndices.size(); ++i) {
607             // FIXME: This essentially means we&#39;re exporting an import.
608             // We need a story here. We need to create a WebAssemblyFunction
609             // for the import.
610             // https://bugs.webkit.org/show_bug.cgi?id=165510
611             uint32_t functionIndex = element.functionIndices[i];
612             Wasm::SignatureIndex signatureIndex = module.signatureIndexFromFunctionIndexSpace(functionIndex);
613             if (functionIndex &lt; codeBlock-&gt;functionImportCount()) {
614                 JSObject* functionImport = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(functionIndex)-&gt;get();
615                 if (isWebAssemblyHostFunction(vm, functionImport)) {
616                     WebAssemblyFunction* wasmFunction = jsDynamicCast&lt;WebAssemblyFunction*&gt;(vm, functionImport);
617                     // If we ever import a WebAssemblyWrapperFunction, we set the import as the unwrapped value.
618                     // Because a WebAssemblyWrapperFunction can never wrap another WebAssemblyWrapperFunction,
619                     // the only type this could be is WebAssemblyFunction.
620                     RELEASE_ASSERT(wasmFunction);
621                     m_instance-&gt;table(tableIndex)-&gt;set(elementIndex, wasmFunction);
622                     ++elementIndex;
623                     continue;
624                 }
625 
626                 m_instance-&gt;table(tableIndex)-&gt;set(elementIndex,
627                     WebAssemblyWrapperFunction::create(vm, globalObject, globalObject-&gt;webAssemblyWrapperFunctionStructure(), functionImport, functionIndex, m_instance.get(), signatureIndex));
628                 ++elementIndex;
629                 continue;
630             }
631 
632             Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(functionIndex);
633             Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(functionIndex);
634             const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
635             // FIXME: Say we export local function &quot;foo&quot; at function index 0.
636             // What if we also set it to the table an Element w/ index 0.
637             // Does (new Instance(...)).exports.foo === table.get(0)?
638             // https://bugs.webkit.org/show_bug.cgi?id=165825
639             WebAssemblyFunction* function = WebAssemblyFunction::create(
640                 vm, globalObject, globalObject-&gt;webAssemblyFunctionStructure(), signature.argumentCount(), String(), m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);
641 
642             m_instance-&gt;table(tableIndex)-&gt;set(elementIndex, function);
643             ++elementIndex;
644         }
645     });
646 
647     ASSERT(!exception);
648 
649     forEachSegment([&amp;] (uint8_t* memory, uint64_t, const Wasm::Segment::Ptr&amp; segment, uint32_t offset) {
650         // Empty segments are valid, but only if memory isn&#39;t present, which would be undefined behavior in memcpy.
651         if (segment-&gt;sizeInBytes) {
652             RELEASE_ASSERT(memory);
653             memcpy(memory + offset, &amp;segment-&gt;byte(0), segment-&gt;sizeInBytes);
654         }
655     });
656 
657     ASSERT(!exception);
658 
659     if (JSObject* startFunction = m_startFunction.get()) {
660         CallData callData;
661         CallType callType = JSC::getCallData(vm, startFunction, callData);
<a name="47" id="anc47"></a><span class="line-modified">662         call(globalObject, startFunction, callType, callData, jsUndefined(), *vm.emptyList);</span>
663         RETURN_IF_EXCEPTION(scope, { });
664     }
665 
666     return jsUndefined();
667 }
668 
669 } // namespace JSC
670 
671 #endif // ENABLE(WEBASSEMBLY)
<a name="48" id="anc48"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="48" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScopedArguments.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SamplingProfiler.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScopedArguments.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScopedArguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,15 ***</span>
  
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(ScopedArguments);
  
  const ClassInfo ScopedArguments::s_info = { &quot;Arguments&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ScopedArguments) };
  
<span class="line-modified">! ScopedArguments::ScopedArguments(VM&amp; vm, Structure* structure, WriteBarrier&lt;Unknown&gt;* storage)</span>
      : GenericArguments(vm, structure)
<span class="line-modified">!     , m_storage(vm, this, storage)</span>
  {
<span class="line-modified">!     ASSERT(!storageHeader(storage).overrodeThings);</span>
  }
  
  void ScopedArguments::finishCreation(VM&amp; vm, JSFunction* callee, ScopedArgumentsTable* table, JSLexicalEnvironment* scope)
  {
      Base::finishCreation(vm);
<span class="line-new-header">--- 33,16 ---</span>
  
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(ScopedArguments);
  
  const ClassInfo ScopedArguments::s_info = { &quot;Arguments&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ScopedArguments) };
  
<span class="line-modified">! ScopedArguments::ScopedArguments(VM&amp; vm, Structure* structure, WriteBarrier&lt;Unknown&gt;* storage, unsigned totalLength)</span>
      : GenericArguments(vm, structure)
<span class="line-modified">!     , m_totalLength(totalLength)</span>
  {
<span class="line-modified">!     if (storage)</span>
<span class="line-added">+         m_storage.set(vm, this, storage);</span>
  }
  
  void ScopedArguments::finishCreation(VM&amp; vm, JSFunction* callee, ScopedArgumentsTable* table, JSLexicalEnvironment* scope)
  {
      Base::finishCreation(vm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,26 ***</span>
      m_scope.set(vm, this, scope);
  }
  
  ScopedArguments* ScopedArguments::createUninitialized(VM&amp; vm, Structure* structure, JSFunction* callee, ScopedArgumentsTable* table, JSLexicalEnvironment* scope, unsigned totalLength)
  {
<span class="line-modified">!     unsigned overflowLength;</span>
<span class="line-modified">!     if (totalLength &gt; table-&gt;length())</span>
<span class="line-modified">!         overflowLength = totalLength - table-&gt;length();</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!         overflowLength = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void* rawStoragePtr = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(</span>
<span class="line-removed">-         vm, storageSize(overflowLength), nullptr, AllocationFailureMode::Assert);</span>
<span class="line-removed">-     WriteBarrier&lt;Unknown&gt;* storage = static_cast&lt;WriteBarrier&lt;Unknown&gt;*&gt;(rawStoragePtr) + 1;</span>
<span class="line-removed">-     storageHeader(storage).overrodeThings = false;</span>
<span class="line-removed">-     storageHeader(storage).totalLength = totalLength;</span>
  
      ScopedArguments* result = new (
          NotNull,
          allocateCell&lt;ScopedArguments&gt;(vm.heap))
<span class="line-modified">!         ScopedArguments(vm, structure, storage);</span>
      result-&gt;finishCreation(vm, callee, table, scope);
      return result;
  }
  
  ScopedArguments* ScopedArguments::create(VM&amp; vm, Structure* structure, JSFunction* callee, ScopedArgumentsTable* table, JSLexicalEnvironment* scope, unsigned totalLength)
<span class="line-new-header">--- 51,20 ---</span>
      m_scope.set(vm, this, scope);
  }
  
  ScopedArguments* ScopedArguments::createUninitialized(VM&amp; vm, Structure* structure, JSFunction* callee, ScopedArgumentsTable* table, JSLexicalEnvironment* scope, unsigned totalLength)
  {
<span class="line-modified">!     WriteBarrier&lt;Unknown&gt;* storage = nullptr;</span>
<span class="line-modified">!     if (totalLength &gt; table-&gt;length()) {</span>
<span class="line-modified">!         Checked&lt;unsigned&gt; overflowLength = totalLength - table-&gt;length();</span>
<span class="line-modified">!         storage = static_cast&lt;WriteBarrier&lt;Unknown&gt;*&gt;(vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, (overflowLength * sizeof(WriteBarrier&lt;Unknown&gt;)).unsafeGet(), nullptr, AllocationFailureMode::Assert));</span>
<span class="line-modified">!     }</span>
  
      ScopedArguments* result = new (
          NotNull,
          allocateCell&lt;ScopedArguments&gt;(vm.heap))
<span class="line-modified">!         ScopedArguments(vm, structure, storage, totalLength);</span>
      result-&gt;finishCreation(vm, callee, table, scope);
      return result;
  }
  
  ScopedArguments* ScopedArguments::create(VM&amp; vm, Structure* structure, JSFunction* callee, ScopedArgumentsTable* table, JSLexicalEnvironment* scope, unsigned totalLength)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,31 ***</span>
      ScopedArguments* result =
          createUninitialized(vm, structure, callee, table, scope, totalLength);
  
      unsigned namedLength = table-&gt;length();
      for (unsigned i = namedLength; i &lt; totalLength; ++i)
<span class="line-modified">!         result-&gt;overflowStorage()[i - namedLength].clear();</span>
  
      return result;
  }
  
<span class="line-modified">! ScopedArguments* ScopedArguments::createByCopying(ExecState* exec, ScopedArgumentsTable* table, JSLexicalEnvironment* scope)</span>
  {
      return createByCopyingFrom(
<span class="line-modified">!         exec-&gt;vm(), exec-&gt;lexicalGlobalObject()-&gt;scopedArgumentsStructure(),</span>
<span class="line-modified">!         exec-&gt;registers() + CallFrame::argumentOffset(0), exec-&gt;argumentCount(),</span>
<span class="line-modified">!         jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee()), table, scope);</span>
  }
  
  ScopedArguments* ScopedArguments::createByCopyingFrom(VM&amp; vm, Structure* structure, Register* argumentsStart, unsigned totalLength, JSFunction* callee, ScopedArgumentsTable* table, JSLexicalEnvironment* scope)
  {
      ScopedArguments* result =
          createUninitialized(vm, structure, callee, table, scope, totalLength);
  
      unsigned namedLength = table-&gt;length();
      for (unsigned i = namedLength; i &lt; totalLength; ++i)
<span class="line-modified">!         result-&gt;overflowStorage()[i - namedLength].set(vm, result, argumentsStart[i].jsValue());</span>
  
      return result;
  }
  
  void ScopedArguments::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
<span class="line-new-header">--- 72,31 ---</span>
      ScopedArguments* result =
          createUninitialized(vm, structure, callee, table, scope, totalLength);
  
      unsigned namedLength = table-&gt;length();
      for (unsigned i = namedLength; i &lt; totalLength; ++i)
<span class="line-modified">!         result-&gt;storage()[i - namedLength].clear();</span>
  
      return result;
  }
  
<span class="line-modified">! ScopedArguments* ScopedArguments::createByCopying(JSGlobalObject* globalObject, CallFrame* callFrame, ScopedArgumentsTable* table, JSLexicalEnvironment* scope)</span>
  {
      return createByCopyingFrom(
<span class="line-modified">!         globalObject-&gt;vm(), globalObject-&gt;scopedArgumentsStructure(),</span>
<span class="line-modified">!         callFrame-&gt;registers() + CallFrame::argumentOffset(0), callFrame-&gt;argumentCount(),</span>
<span class="line-modified">!         jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee()), table, scope);</span>
  }
  
  ScopedArguments* ScopedArguments::createByCopyingFrom(VM&amp; vm, Structure* structure, Register* argumentsStart, unsigned totalLength, JSFunction* callee, ScopedArgumentsTable* table, JSLexicalEnvironment* scope)
  {
      ScopedArguments* result =
          createUninitialized(vm, structure, callee, table, scope, totalLength);
  
      unsigned namedLength = table-&gt;length();
      for (unsigned i = namedLength; i &lt; totalLength; ++i)
<span class="line-modified">!         result-&gt;storage()[i - namedLength].set(vm, result, argumentsStart[i].jsValue());</span>
  
      return result;
  }
  
  void ScopedArguments::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,52 ***</span>
  
      visitor.append(thisObject-&gt;m_callee);
      visitor.append(thisObject-&gt;m_table);
      visitor.append(thisObject-&gt;m_scope);
  
<span class="line-modified">!     visitor.markAuxiliary(&amp;thisObject-&gt;storageHeader());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (thisObject-&gt;storageHeader().totalLength &gt; thisObject-&gt;m_table-&gt;length()) {</span>
<span class="line-modified">!         visitor.appendValues(</span>
<span class="line-removed">-             thisObject-&gt;overflowStorage(), thisObject-&gt;storageHeader().totalLength - thisObject-&gt;m_table-&gt;length());</span>
      }
  }
  
  Structure* ScopedArguments::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  {
      return Structure::create(vm, globalObject, prototype, TypeInfo(ScopedArgumentsType, StructureFlags), info());
  }
  
<span class="line-modified">! void ScopedArguments::overrideThings(VM&amp; vm)</span>
  {
<span class="line-modified">!     RELEASE_ASSERT(!storageHeader().overrodeThings);</span>
  
      putDirect(vm, vm.propertyNames-&gt;length, jsNumber(m_table-&gt;length()), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      putDirect(vm, vm.propertyNames-&gt;callee, m_callee.get(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<span class="line-modified">!     putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject(vm)-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
  
<span class="line-modified">!     storageHeader().overrodeThings = true;</span>
  }
  
<span class="line-modified">! void ScopedArguments::overrideThingsIfNecessary(VM&amp; vm)</span>
  {
<span class="line-modified">!     if (!storageHeader().overrodeThings)</span>
<span class="line-modified">!         overrideThings(vm);</span>
  }
  
<span class="line-modified">! void ScopedArguments::unmapArgument(VM&amp; vm, uint32_t i)</span>
  {
<span class="line-modified">!     ASSERT_WITH_SECURITY_IMPLICATION(i &lt; storageHeader().totalLength);</span>
      unsigned namedLength = m_table-&gt;length();
      if (i &lt; namedLength)
          m_table.set(vm, this, m_table-&gt;set(vm, i, ScopeOffset()));
      else
<span class="line-modified">!         overflowStorage()[i - namedLength].clear();</span>
  }
  
<span class="line-modified">! void ScopedArguments::copyToArguments(ExecState* exec, VirtualRegister firstElementDest, unsigned offset, unsigned length)</span>
  {
<span class="line-modified">!     GenericArguments::copyToArguments(exec, firstElementDest, offset, length);</span>
  }
  
  } // namespace JSC
  
<span class="line-new-header">--- 107,54 ---</span>
  
      visitor.append(thisObject-&gt;m_callee);
      visitor.append(thisObject-&gt;m_table);
      visitor.append(thisObject-&gt;m_scope);
  
<span class="line-modified">!     if (WriteBarrier&lt;Unknown&gt;* storage = thisObject-&gt;m_storage.get()) {</span>
<span class="line-modified">!         visitor.markAuxiliary(storage);</span>
<span class="line-modified">!         if (thisObject-&gt;m_totalLength &gt; thisObject-&gt;m_table-&gt;length())</span>
<span class="line-modified">!             visitor.appendValues(storage, thisObject-&gt;m_totalLength - thisObject-&gt;m_table-&gt;length());</span>
      }
  }
  
  Structure* ScopedArguments::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  {
      return Structure::create(vm, globalObject, prototype, TypeInfo(ScopedArgumentsType, StructureFlags), info());
  }
  
<span class="line-modified">! void ScopedArguments::overrideThings(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+ </span>
<span class="line-added">+     RELEASE_ASSERT(!m_overrodeThings);</span>
  
      putDirect(vm, vm.propertyNames-&gt;length, jsNumber(m_table-&gt;length()), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      putDirect(vm, vm.propertyNames-&gt;callee, m_callee.get(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<span class="line-modified">!     putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
  
<span class="line-modified">!     m_overrodeThings = true;</span>
  }
  
<span class="line-modified">! void ScopedArguments::overrideThingsIfNecessary(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     if (!m_overrodeThings)</span>
<span class="line-modified">!         overrideThings(globalObject);</span>
  }
  
<span class="line-modified">! void ScopedArguments::unmapArgument(JSGlobalObject* globalObject, uint32_t i)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     ASSERT_WITH_SECURITY_IMPLICATION(i &lt; m_totalLength);</span>
      unsigned namedLength = m_table-&gt;length();
      if (i &lt; namedLength)
          m_table.set(vm, this, m_table-&gt;set(vm, i, ScopeOffset()));
      else
<span class="line-modified">!         storage()[i - namedLength].clear();</span>
  }
  
<span class="line-modified">! void ScopedArguments::copyToArguments(JSGlobalObject* globalObject, JSValue* firstElementDest, unsigned offset, unsigned length)</span>
  {
<span class="line-modified">!     GenericArguments::copyToArguments(globalObject, firstElementDest, offset, length);</span>
  }
  
  } // namespace JSC
  
</pre>
<center><a href="SamplingProfiler.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScopedArguments.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
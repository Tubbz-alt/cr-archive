<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/WeakSet.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WeakSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WeakSetInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/WeakSet.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CellContainer.h&quot;
 29 #include &quot;WeakBlock.h&quot;
 30 #include &lt;wtf/SentinelLinkedList.h&gt;
 31 
 32 namespace JSC {
 33 
 34 class Heap;
 35 class WeakImpl;
 36 
 37 class WeakSet : public BasicRawSentinelNode&lt;WeakSet&gt; {
 38     friend class LLIntOffsetsExtractor;
 39 
 40 public:
 41     static WeakImpl* allocate(JSValue, WeakHandleOwner* = 0, void* context = 0);
 42     static void deallocate(WeakImpl*);
 43 
<span class="line-modified"> 44     WeakSet(VM&amp;, CellContainer);</span>
 45     ~WeakSet();
 46     void lastChanceToFinalize();
 47 
<span class="line-removed"> 48     CellContainer container() const { return m_container; }</span>
<span class="line-removed"> 49     void setContainer(CellContainer container) { m_container = container; }</span>
<span class="line-removed"> 50 </span>
 51     Heap* heap() const;
 52     VM&amp; vm() const;
 53 
 54     bool isEmpty() const;
 55     bool isTriviallyDestructible() const;
 56 
 57     void visit(SlotVisitor&amp;);
 58 
 59     void reap();
 60     void sweep();
 61     void shrink();
 62     void resetAllocator();
 63 
 64 private:
<span class="line-modified"> 65     JS_EXPORT_PRIVATE WeakBlock::FreeCell* findAllocator();</span>
 66     WeakBlock::FreeCell* tryFindAllocator();
<span class="line-modified"> 67     WeakBlock::FreeCell* addAllocator();</span>
 68     void removeAllocator(WeakBlock*);
 69 
<span class="line-modified"> 70     WeakBlock::FreeCell* m_allocator;</span>
<span class="line-modified"> 71     WeakBlock* m_nextAllocator;</span>
 72     DoublyLinkedList&lt;WeakBlock&gt; m_blocks;
<span class="line-modified"> 73     VM&amp; m_vm;</span>
<span class="line-modified"> 74     CellContainer m_container;</span>

 75 };
 76 
<span class="line-modified"> 77 inline WeakSet::WeakSet(VM&amp; vm, CellContainer container)</span>
<span class="line-modified"> 78     : m_allocator(0)</span>
<span class="line-removed"> 79     , m_nextAllocator(0)</span>
<span class="line-removed"> 80     , m_vm(vm)</span>
<span class="line-removed"> 81     , m_container(container)</span>
 82 {
 83 }
 84 
 85 inline VM&amp; WeakSet::vm() const
 86 {
<span class="line-modified"> 87     return m_vm;</span>
 88 }
 89 
 90 inline bool WeakSet::isEmpty() const
 91 {
 92     for (WeakBlock* block = m_blocks.head(); block; block = block-&gt;next()) {
 93         if (!block-&gt;isEmpty())
 94             return false;
 95     }
 96 
 97     return true;
 98 }
 99 
100 inline bool WeakSet::isTriviallyDestructible() const
101 {
102     if (!m_blocks.isEmpty())
103         return false;
104     if (isOnList())
105         return false;
106     return true;
107 }
</pre>
<hr />
<pre>
114 inline void WeakSet::lastChanceToFinalize()
115 {
116     for (WeakBlock* block = m_blocks.head(); block; block = block-&gt;next())
117         block-&gt;lastChanceToFinalize();
118 }
119 
120 inline void WeakSet::visit(SlotVisitor&amp; visitor)
121 {
122     for (WeakBlock* block = m_blocks.head(); block; block = block-&gt;next())
123         block-&gt;visit(visitor);
124 }
125 
126 inline void WeakSet::reap()
127 {
128     for (WeakBlock* block = m_blocks.head(); block; block = block-&gt;next())
129         block-&gt;reap();
130 }
131 
132 inline void WeakSet::resetAllocator()
133 {
<span class="line-modified">134     m_allocator = 0;</span>
135     m_nextAllocator = m_blocks.head();
136 }
137 
138 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CellContainer.h&quot;
 29 #include &quot;WeakBlock.h&quot;
 30 #include &lt;wtf/SentinelLinkedList.h&gt;
 31 
 32 namespace JSC {
 33 
 34 class Heap;
 35 class WeakImpl;
 36 
 37 class WeakSet : public BasicRawSentinelNode&lt;WeakSet&gt; {
 38     friend class LLIntOffsetsExtractor;
 39 
 40 public:
 41     static WeakImpl* allocate(JSValue, WeakHandleOwner* = 0, void* context = 0);
 42     static void deallocate(WeakImpl*);
 43 
<span class="line-modified"> 44     WeakSet(VM&amp;);</span>
 45     ~WeakSet();
 46     void lastChanceToFinalize();
 47 



 48     Heap* heap() const;
 49     VM&amp; vm() const;
 50 
 51     bool isEmpty() const;
 52     bool isTriviallyDestructible() const;
 53 
 54     void visit(SlotVisitor&amp;);
 55 
 56     void reap();
 57     void sweep();
 58     void shrink();
 59     void resetAllocator();
 60 
 61 private:
<span class="line-modified"> 62     JS_EXPORT_PRIVATE WeakBlock::FreeCell* findAllocator(CellContainer);</span>
 63     WeakBlock::FreeCell* tryFindAllocator();
<span class="line-modified"> 64     WeakBlock::FreeCell* addAllocator(CellContainer);</span>
 65     void removeAllocator(WeakBlock*);
 66 
<span class="line-modified"> 67     WeakBlock::FreeCell* m_allocator { nullptr };</span>
<span class="line-modified"> 68     WeakBlock* m_nextAllocator { nullptr };</span>
 69     DoublyLinkedList&lt;WeakBlock&gt; m_blocks;
<span class="line-modified"> 70     // m_vm must be a pointer (instead of a reference) because the JSCLLIntOffsetsExtractor</span>
<span class="line-modified"> 71     // cannot handle it being a reference.</span>
<span class="line-added"> 72     VM* m_vm;</span>
 73 };
 74 
<span class="line-modified"> 75 inline WeakSet::WeakSet(VM&amp; vm)</span>
<span class="line-modified"> 76     : m_vm(&amp;vm)</span>



 77 {
 78 }
 79 
 80 inline VM&amp; WeakSet::vm() const
 81 {
<span class="line-modified"> 82     return *m_vm;</span>
 83 }
 84 
 85 inline bool WeakSet::isEmpty() const
 86 {
 87     for (WeakBlock* block = m_blocks.head(); block; block = block-&gt;next()) {
 88         if (!block-&gt;isEmpty())
 89             return false;
 90     }
 91 
 92     return true;
 93 }
 94 
 95 inline bool WeakSet::isTriviallyDestructible() const
 96 {
 97     if (!m_blocks.isEmpty())
 98         return false;
 99     if (isOnList())
100         return false;
101     return true;
102 }
</pre>
<hr />
<pre>
109 inline void WeakSet::lastChanceToFinalize()
110 {
111     for (WeakBlock* block = m_blocks.head(); block; block = block-&gt;next())
112         block-&gt;lastChanceToFinalize();
113 }
114 
115 inline void WeakSet::visit(SlotVisitor&amp; visitor)
116 {
117     for (WeakBlock* block = m_blocks.head(); block; block = block-&gt;next())
118         block-&gt;visit(visitor);
119 }
120 
121 inline void WeakSet::reap()
122 {
123     for (WeakBlock* block = m_blocks.head(); block; block = block-&gt;next())
124         block-&gt;reap();
125 }
126 
127 inline void WeakSet::resetAllocator()
128 {
<span class="line-modified">129     m_allocator = nullptr;</span>
130     m_nextAllocator = m_blocks.head();
131 }
132 
133 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="WeakSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WeakSetInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
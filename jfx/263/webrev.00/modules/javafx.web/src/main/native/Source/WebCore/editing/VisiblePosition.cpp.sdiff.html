<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/VisiblePosition.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TypingCommand.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VisiblePosition.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/VisiblePosition.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
119     if (p.isNull())
120         return Position();
121 
122     Position downstreamStart = p.downstream();
123     TextDirection primaryDirection = p.primaryDirection();
124 
125     while (true) {
126         InlineBox* box;
127         int offset;
128         p.getInlineBoxAndOffset(m_affinity, primaryDirection, box, offset);
129         if (!box)
130             return primaryDirection == TextDirection::LTR ? previousVisuallyDistinctCandidate(m_deepPosition) : nextVisuallyDistinctCandidate(m_deepPosition);
131 
132         RenderObject* renderer = &amp;box-&gt;renderer();
133 
134         while (true) {
135             if ((renderer-&gt;isReplaced() || renderer-&gt;isBR()) &amp;&amp; offset == box-&gt;caretRightmostOffset())
136                 return box-&gt;isLeftToRightDirection() ? previousVisuallyDistinctCandidate(m_deepPosition) : nextVisuallyDistinctCandidate(m_deepPosition);
137 
138             if (!renderer-&gt;node()) {
<span class="line-modified">139                 box = box-&gt;prevLeafChild();</span>
140                 if (!box)
141                     return primaryDirection == TextDirection::LTR ? previousVisuallyDistinctCandidate(m_deepPosition) : nextVisuallyDistinctCandidate(m_deepPosition);
142                 renderer = &amp;box-&gt;renderer();
143                 offset = box-&gt;caretRightmostOffset();
144                 continue;
145             }
146 
147             offset = box-&gt;isLeftToRightDirection() ? renderer-&gt;previousOffset(offset) : renderer-&gt;nextOffset(offset);
148 
149             int caretMinOffset = box-&gt;caretMinOffset();
150             int caretMaxOffset = box-&gt;caretMaxOffset();
151 
152             if (offset &gt; caretMinOffset &amp;&amp; offset &lt; caretMaxOffset)
153                 break;
154 
155             if (box-&gt;isLeftToRightDirection() ? offset &lt; caretMinOffset : offset &gt; caretMaxOffset) {
156                 // Overshot to the left.
<span class="line-modified">157                 InlineBox* prevBox = box-&gt;prevLeafChildIgnoringLineBreak();</span>
158                 if (!prevBox) {
159                     Position positionOnLeft = primaryDirection == TextDirection::LTR ? previousVisuallyDistinctCandidate(m_deepPosition) : nextVisuallyDistinctCandidate(m_deepPosition);
160                     if (positionOnLeft.isNull())
161                         return Position();
162 
163                     InlineBox* boxOnLeft;
164                     int offsetOnLeft;
165                     positionOnLeft.getInlineBoxAndOffset(m_affinity, primaryDirection, boxOnLeft, offsetOnLeft);
166                     if (boxOnLeft &amp;&amp; &amp;boxOnLeft-&gt;root() == &amp;box-&gt;root())
167                         return Position();
168                     return positionOnLeft;
169                 }
170 
171                 // Reposition at the other logical position corresponding to our edge&#39;s visual position and go for another round.
172                 box = prevBox;
173                 renderer = &amp;box-&gt;renderer();
174                 offset = prevBox-&gt;caretRightmostOffset();
175                 continue;
176             }
177 
178             ASSERT(offset == box-&gt;caretLeftmostOffset());
179 
180             unsigned char level = box-&gt;bidiLevel();
<span class="line-modified">181             InlineBox* prevBox = box-&gt;prevLeafChild();</span>
182 
183             if (box-&gt;direction() == primaryDirection) {
184                 if (!prevBox) {
185                     InlineBox* logicalStart = nullptr;
186                     if (primaryDirection == TextDirection::LTR ? box-&gt;root().getLogicalStartBoxWithNode(logicalStart) : box-&gt;root().getLogicalEndBoxWithNode(logicalStart)) {
187                         box = logicalStart;
188                         renderer = &amp;box-&gt;renderer();
189                         offset = primaryDirection == TextDirection::LTR ? box-&gt;caretMinOffset() : box-&gt;caretMaxOffset();
190                     }
191                     break;
192                 }
193                 if (prevBox-&gt;bidiLevel() &gt;= level)
194                     break;
195 
196                 level = prevBox-&gt;bidiLevel();
197 
198                 InlineBox* nextBox = box;
199                 do {
<span class="line-modified">200                     nextBox = nextBox-&gt;nextLeafChild();</span>
201                 } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; level);
202 
203                 if (nextBox &amp;&amp; nextBox-&gt;bidiLevel() == level)
204                     break;
205 
206                 box = prevBox;
207                 renderer = &amp;box-&gt;renderer();
208                 offset = box-&gt;caretRightmostOffset();
209                 if (box-&gt;direction() == primaryDirection)
210                     break;
211                 continue;
212             }
213 
214             while (prevBox &amp;&amp; !prevBox-&gt;renderer().node())
<span class="line-modified">215                 prevBox = prevBox-&gt;prevLeafChild();</span>
216 
217             if (prevBox) {
218                 box = prevBox;
219                 renderer = &amp;box-&gt;renderer();
220                 offset = box-&gt;caretRightmostOffset();
221                 if (box-&gt;bidiLevel() &gt; level) {
222                     do {
<span class="line-modified">223                         prevBox = prevBox-&gt;prevLeafChild();</span>
224                     } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; level);
225 
226                     if (!prevBox || prevBox-&gt;bidiLevel() &lt; level)
227                         continue;
228                 }
229             } else {
230                 // Trailing edge of a secondary run. Set to the leading edge of the entire run.
231                 while (true) {
<span class="line-modified">232                     while (InlineBox* nextBox = box-&gt;nextLeafChild()) {</span>
233                         if (nextBox-&gt;bidiLevel() &lt; level)
234                             break;
235                         box = nextBox;
236                     }
237                     if (box-&gt;bidiLevel() == level)
238                         break;
239                     level = box-&gt;bidiLevel();
<span class="line-modified">240                     while (InlineBox* prevBox = box-&gt;prevLeafChild()) {</span>
241                         if (prevBox-&gt;bidiLevel() &lt; level)
242                             break;
243                         box = prevBox;
244                     }
245                     if (box-&gt;bidiLevel() == level)
246                         break;
247                     level = box-&gt;bidiLevel();
248                 }
249                 renderer = &amp;box-&gt;renderer();
250                 offset = primaryDirection == TextDirection::LTR ? box-&gt;caretMinOffset() : box-&gt;caretMaxOffset();
251             }
252             break;
253         }
254 
255         p = createLegacyEditingPosition(renderer-&gt;node(), offset);
256 
257         if ((p.isCandidate() &amp;&amp; p.downstream() != downstreamStart) || p.atStartOfTree() || p.atEndOfTree())
258             return p;
259 
260         ASSERT(p != m_deepPosition);
</pre>
<hr />
<pre>
289     if (p.isNull())
290         return Position();
291 
292     Position downstreamStart = p.downstream();
293     TextDirection primaryDirection = p.primaryDirection();
294 
295     while (true) {
296         InlineBox* box;
297         int offset;
298         p.getInlineBoxAndOffset(m_affinity, primaryDirection, box, offset);
299         if (!box)
300             return primaryDirection == TextDirection::LTR ? nextVisuallyDistinctCandidate(m_deepPosition) : previousVisuallyDistinctCandidate(m_deepPosition);
301 
302         RenderObject* renderer = &amp;box-&gt;renderer();
303 
304         while (true) {
305             if ((renderer-&gt;isReplaced() || renderer-&gt;isBR()) &amp;&amp; offset == box-&gt;caretLeftmostOffset())
306                 return box-&gt;isLeftToRightDirection() ? nextVisuallyDistinctCandidate(m_deepPosition) : previousVisuallyDistinctCandidate(m_deepPosition);
307 
308             if (!renderer-&gt;node()) {
<span class="line-modified">309                 box = box-&gt;nextLeafChild();</span>
310                 if (!box)
311                     return primaryDirection == TextDirection::LTR ? nextVisuallyDistinctCandidate(m_deepPosition) : previousVisuallyDistinctCandidate(m_deepPosition);
312                 renderer = &amp;box-&gt;renderer();
313                 offset = box-&gt;caretLeftmostOffset();
314                 continue;
315             }
316 
317             offset = box-&gt;isLeftToRightDirection() ? renderer-&gt;nextOffset(offset) : renderer-&gt;previousOffset(offset);
318 
319             int caretMinOffset = box-&gt;caretMinOffset();
320             int caretMaxOffset = box-&gt;caretMaxOffset();
321 
322             if (offset &gt; caretMinOffset &amp;&amp; offset &lt; caretMaxOffset)
323                 break;
324 
325             if (box-&gt;isLeftToRightDirection() ? offset &gt; caretMaxOffset : offset &lt; caretMinOffset) {
326                 // Overshot to the right.
<span class="line-modified">327                 InlineBox* nextBox = box-&gt;nextLeafChildIgnoringLineBreak();</span>
328                 if (!nextBox) {
329                     Position positionOnRight = primaryDirection == TextDirection::LTR ? nextVisuallyDistinctCandidate(m_deepPosition) : previousVisuallyDistinctCandidate(m_deepPosition);
330                     if (positionOnRight.isNull())
331                         return Position();
332 
333                     InlineBox* boxOnRight;
334                     int offsetOnRight;
335                     positionOnRight.getInlineBoxAndOffset(m_affinity, primaryDirection, boxOnRight, offsetOnRight);
336                     if (boxOnRight &amp;&amp; &amp;boxOnRight-&gt;root() == &amp;box-&gt;root())
337                         return Position();
338                     return positionOnRight;
339                 }
340 
341                 // Reposition at the other logical position corresponding to our edge&#39;s visual position and go for another round.
342                 box = nextBox;
343                 renderer = &amp;box-&gt;renderer();
344                 offset = nextBox-&gt;caretLeftmostOffset();
345                 continue;
346             }
347 
348             ASSERT(offset == box-&gt;caretRightmostOffset());
349 
350             unsigned char level = box-&gt;bidiLevel();
<span class="line-modified">351             InlineBox* nextBox = box-&gt;nextLeafChild();</span>
352 
353             if (box-&gt;direction() == primaryDirection) {
354                 if (!nextBox) {
355                     InlineBox* logicalEnd = nullptr;
356                     if (primaryDirection == TextDirection::LTR ? box-&gt;root().getLogicalEndBoxWithNode(logicalEnd) : box-&gt;root().getLogicalStartBoxWithNode(logicalEnd)) {
357                         box = logicalEnd;
358                         renderer = &amp;box-&gt;renderer();
359                         offset = primaryDirection == TextDirection::LTR ? box-&gt;caretMaxOffset() : box-&gt;caretMinOffset();
360                     }
361                     break;
362                 }
363 
364                 if (nextBox-&gt;bidiLevel() &gt;= level)
365                     break;
366 
367                 level = nextBox-&gt;bidiLevel();
368 
369                 InlineBox* prevBox = box;
370                 do {
<span class="line-modified">371                     prevBox = prevBox-&gt;prevLeafChild();</span>
372                 } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; level);
373 
374                 if (prevBox &amp;&amp; prevBox-&gt;bidiLevel() == level)   // For example, abc FED 123 ^ CBA
375                     break;
376 
377                 // For example, abc 123 ^ CBA or 123 ^ CBA abc
378                 box = nextBox;
379                 renderer = &amp;box-&gt;renderer();
380                 offset = box-&gt;caretLeftmostOffset();
381                 if (box-&gt;direction() == primaryDirection)
382                     break;
383                 continue;
384             }
385 
386             while (nextBox &amp;&amp; !nextBox-&gt;renderer().node())
<span class="line-modified">387                 nextBox = nextBox-&gt;nextLeafChild();</span>
388 
389             if (nextBox) {
390                 box = nextBox;
391                 renderer = &amp;box-&gt;renderer();
392                 offset = box-&gt;caretLeftmostOffset();
393 
394                 if (box-&gt;bidiLevel() &gt; level) {
395                     do {
<span class="line-modified">396                         nextBox = nextBox-&gt;nextLeafChild();</span>
397                     } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; level);
398 
399                     if (!nextBox || nextBox-&gt;bidiLevel() &lt; level)
400                         continue;
401                 }
402             } else {
403                 // Trailing edge of a secondary run. Set to the leading edge of the entire run.
404                 while (true) {
<span class="line-modified">405                     while (InlineBox* prevBox = box-&gt;prevLeafChild()) {</span>
406                         if (prevBox-&gt;bidiLevel() &lt; level)
407                             break;
408                         box = prevBox;
409                     }
410                     if (box-&gt;bidiLevel() == level)
411                         break;
412                     level = box-&gt;bidiLevel();
<span class="line-modified">413                     while (InlineBox* nextBox = box-&gt;nextLeafChild()) {</span>
414                         if (nextBox-&gt;bidiLevel() &lt; level)
415                             break;
416                         box = nextBox;
417                     }
418                     if (box-&gt;bidiLevel() == level)
419                         break;
420                     level = box-&gt;bidiLevel();
421                 }
422                 renderer = &amp;box-&gt;renderer();
423                 offset = primaryDirection == TextDirection::LTR ? box-&gt;caretMaxOffset() : box-&gt;caretMinOffset();
424             }
425             break;
426         }
427 
428         p = createLegacyEditingPosition(renderer-&gt;node(), offset);
429 
430         if ((p.isCandidate() &amp;&amp; p.downstream() != downstreamStart) || p.atStartOfTree() || p.atEndOfTree())
431             return p;
432 
433         ASSERT(p != m_deepPosition);
</pre>
<hr />
<pre>
650     if (!renderer)
651         return LayoutRect();
652 
653     InlineBox* inlineBox;
654     int caretOffset;
655     getInlineBoxAndOffset(inlineBox, caretOffset);
656 
657     if (inlineBox)
658         renderer = &amp;inlineBox-&gt;renderer();
659 
660     return renderer-&gt;localCaretRect(inlineBox, caretOffset);
661 }
662 
663 IntRect VisiblePosition::absoluteCaretBounds(bool* insideFixed) const
664 {
665     RenderBlock* renderer = nullptr;
666     LayoutRect localRect = localCaretRectInRendererForCaretPainting(*this, renderer);
667     return absoluteBoundsForLocalCaretRect(renderer, localRect, insideFixed);
668 }
669 





















670 int VisiblePosition::lineDirectionPointForBlockDirectionNavigation() const
671 {
672     RenderObject* renderer;
673     LayoutRect localRect = localCaretRect(renderer);
674     if (localRect.isEmpty() || !renderer)
675         return 0;
676 
677     // This ignores transforms on purpose, for now. Vertical navigation is done
678     // without consulting transforms, so that &#39;up&#39; in transformed text is &#39;up&#39;
679     // relative to the text, not absolute &#39;up&#39;.
680     FloatPoint caretPoint = renderer-&gt;localToAbsolute(localRect.location());
681     RenderObject* containingBlock = renderer-&gt;containingBlock();
682     if (!containingBlock)
683         containingBlock = renderer; // Just use ourselves to determine the writing mode if we have no containing block.
684     return containingBlock-&gt;isHorizontalWritingMode() ? caretPoint.x() : caretPoint.y();
685 }
686 
687 #if ENABLE(TREE_DEBUGGING)
688 
689 void VisiblePosition::debugPosition(const char* msg) const
</pre>
<hr />
<pre>
771 
772     if (!visiblePosition.deepEquivalent().containerNode()-&gt;isDescendantOf(node))
773         return false;
774 
775     VisiblePosition previous = visiblePosition.previous();
776     return previous.isNull() || !previous.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(node);
777 }
778 
779 bool isLastVisiblePositionInNode(const VisiblePosition &amp;visiblePosition, const Node *node)
780 {
781     if (visiblePosition.isNull())
782         return false;
783 
784     if (!visiblePosition.deepEquivalent().containerNode()-&gt;isDescendantOf(node))
785         return false;
786 
787     VisiblePosition next = visiblePosition.next();
788     return next.isNull() || !next.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(node);
789 }
790 





791 bool VisiblePosition::equals(const VisiblePosition&amp; other) const
792 {
793     return m_affinity == other.m_affinity &amp;&amp; m_deepPosition.equals(other.m_deepPosition);
794 }
795 
796 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, EAffinity affinity)
797 {
798     switch (affinity) {
799     case UPSTREAM:
800         stream &lt;&lt; &quot;upstream&quot;;
801         break;
802     case DOWNSTREAM:
803         stream &lt;&lt; &quot;downstream&quot;;
804         break;
805     }
806     return stream;
807 }
808 
809 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const VisiblePosition&amp; visiblePosition)
810 {
</pre>
</td>
<td>
<hr />
<pre>
119     if (p.isNull())
120         return Position();
121 
122     Position downstreamStart = p.downstream();
123     TextDirection primaryDirection = p.primaryDirection();
124 
125     while (true) {
126         InlineBox* box;
127         int offset;
128         p.getInlineBoxAndOffset(m_affinity, primaryDirection, box, offset);
129         if (!box)
130             return primaryDirection == TextDirection::LTR ? previousVisuallyDistinctCandidate(m_deepPosition) : nextVisuallyDistinctCandidate(m_deepPosition);
131 
132         RenderObject* renderer = &amp;box-&gt;renderer();
133 
134         while (true) {
135             if ((renderer-&gt;isReplaced() || renderer-&gt;isBR()) &amp;&amp; offset == box-&gt;caretRightmostOffset())
136                 return box-&gt;isLeftToRightDirection() ? previousVisuallyDistinctCandidate(m_deepPosition) : nextVisuallyDistinctCandidate(m_deepPosition);
137 
138             if (!renderer-&gt;node()) {
<span class="line-modified">139                 box = box-&gt;previousLeafOnLine();</span>
140                 if (!box)
141                     return primaryDirection == TextDirection::LTR ? previousVisuallyDistinctCandidate(m_deepPosition) : nextVisuallyDistinctCandidate(m_deepPosition);
142                 renderer = &amp;box-&gt;renderer();
143                 offset = box-&gt;caretRightmostOffset();
144                 continue;
145             }
146 
147             offset = box-&gt;isLeftToRightDirection() ? renderer-&gt;previousOffset(offset) : renderer-&gt;nextOffset(offset);
148 
149             int caretMinOffset = box-&gt;caretMinOffset();
150             int caretMaxOffset = box-&gt;caretMaxOffset();
151 
152             if (offset &gt; caretMinOffset &amp;&amp; offset &lt; caretMaxOffset)
153                 break;
154 
155             if (box-&gt;isLeftToRightDirection() ? offset &lt; caretMinOffset : offset &gt; caretMaxOffset) {
156                 // Overshot to the left.
<span class="line-modified">157                 InlineBox* prevBox = box-&gt;previousLeafOnLineIgnoringLineBreak();</span>
158                 if (!prevBox) {
159                     Position positionOnLeft = primaryDirection == TextDirection::LTR ? previousVisuallyDistinctCandidate(m_deepPosition) : nextVisuallyDistinctCandidate(m_deepPosition);
160                     if (positionOnLeft.isNull())
161                         return Position();
162 
163                     InlineBox* boxOnLeft;
164                     int offsetOnLeft;
165                     positionOnLeft.getInlineBoxAndOffset(m_affinity, primaryDirection, boxOnLeft, offsetOnLeft);
166                     if (boxOnLeft &amp;&amp; &amp;boxOnLeft-&gt;root() == &amp;box-&gt;root())
167                         return Position();
168                     return positionOnLeft;
169                 }
170 
171                 // Reposition at the other logical position corresponding to our edge&#39;s visual position and go for another round.
172                 box = prevBox;
173                 renderer = &amp;box-&gt;renderer();
174                 offset = prevBox-&gt;caretRightmostOffset();
175                 continue;
176             }
177 
178             ASSERT(offset == box-&gt;caretLeftmostOffset());
179 
180             unsigned char level = box-&gt;bidiLevel();
<span class="line-modified">181             InlineBox* prevBox = box-&gt;previousLeafOnLine();</span>
182 
183             if (box-&gt;direction() == primaryDirection) {
184                 if (!prevBox) {
185                     InlineBox* logicalStart = nullptr;
186                     if (primaryDirection == TextDirection::LTR ? box-&gt;root().getLogicalStartBoxWithNode(logicalStart) : box-&gt;root().getLogicalEndBoxWithNode(logicalStart)) {
187                         box = logicalStart;
188                         renderer = &amp;box-&gt;renderer();
189                         offset = primaryDirection == TextDirection::LTR ? box-&gt;caretMinOffset() : box-&gt;caretMaxOffset();
190                     }
191                     break;
192                 }
193                 if (prevBox-&gt;bidiLevel() &gt;= level)
194                     break;
195 
196                 level = prevBox-&gt;bidiLevel();
197 
198                 InlineBox* nextBox = box;
199                 do {
<span class="line-modified">200                     nextBox = nextBox-&gt;nextLeafOnLine();</span>
201                 } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; level);
202 
203                 if (nextBox &amp;&amp; nextBox-&gt;bidiLevel() == level)
204                     break;
205 
206                 box = prevBox;
207                 renderer = &amp;box-&gt;renderer();
208                 offset = box-&gt;caretRightmostOffset();
209                 if (box-&gt;direction() == primaryDirection)
210                     break;
211                 continue;
212             }
213 
214             while (prevBox &amp;&amp; !prevBox-&gt;renderer().node())
<span class="line-modified">215                 prevBox = prevBox-&gt;previousLeafOnLine();</span>
216 
217             if (prevBox) {
218                 box = prevBox;
219                 renderer = &amp;box-&gt;renderer();
220                 offset = box-&gt;caretRightmostOffset();
221                 if (box-&gt;bidiLevel() &gt; level) {
222                     do {
<span class="line-modified">223                         prevBox = prevBox-&gt;previousLeafOnLine();</span>
224                     } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; level);
225 
226                     if (!prevBox || prevBox-&gt;bidiLevel() &lt; level)
227                         continue;
228                 }
229             } else {
230                 // Trailing edge of a secondary run. Set to the leading edge of the entire run.
231                 while (true) {
<span class="line-modified">232                     while (InlineBox* nextBox = box-&gt;nextLeafOnLine()) {</span>
233                         if (nextBox-&gt;bidiLevel() &lt; level)
234                             break;
235                         box = nextBox;
236                     }
237                     if (box-&gt;bidiLevel() == level)
238                         break;
239                     level = box-&gt;bidiLevel();
<span class="line-modified">240                     while (InlineBox* prevBox = box-&gt;previousLeafOnLine()) {</span>
241                         if (prevBox-&gt;bidiLevel() &lt; level)
242                             break;
243                         box = prevBox;
244                     }
245                     if (box-&gt;bidiLevel() == level)
246                         break;
247                     level = box-&gt;bidiLevel();
248                 }
249                 renderer = &amp;box-&gt;renderer();
250                 offset = primaryDirection == TextDirection::LTR ? box-&gt;caretMinOffset() : box-&gt;caretMaxOffset();
251             }
252             break;
253         }
254 
255         p = createLegacyEditingPosition(renderer-&gt;node(), offset);
256 
257         if ((p.isCandidate() &amp;&amp; p.downstream() != downstreamStart) || p.atStartOfTree() || p.atEndOfTree())
258             return p;
259 
260         ASSERT(p != m_deepPosition);
</pre>
<hr />
<pre>
289     if (p.isNull())
290         return Position();
291 
292     Position downstreamStart = p.downstream();
293     TextDirection primaryDirection = p.primaryDirection();
294 
295     while (true) {
296         InlineBox* box;
297         int offset;
298         p.getInlineBoxAndOffset(m_affinity, primaryDirection, box, offset);
299         if (!box)
300             return primaryDirection == TextDirection::LTR ? nextVisuallyDistinctCandidate(m_deepPosition) : previousVisuallyDistinctCandidate(m_deepPosition);
301 
302         RenderObject* renderer = &amp;box-&gt;renderer();
303 
304         while (true) {
305             if ((renderer-&gt;isReplaced() || renderer-&gt;isBR()) &amp;&amp; offset == box-&gt;caretLeftmostOffset())
306                 return box-&gt;isLeftToRightDirection() ? nextVisuallyDistinctCandidate(m_deepPosition) : previousVisuallyDistinctCandidate(m_deepPosition);
307 
308             if (!renderer-&gt;node()) {
<span class="line-modified">309                 box = box-&gt;nextLeafOnLine();</span>
310                 if (!box)
311                     return primaryDirection == TextDirection::LTR ? nextVisuallyDistinctCandidate(m_deepPosition) : previousVisuallyDistinctCandidate(m_deepPosition);
312                 renderer = &amp;box-&gt;renderer();
313                 offset = box-&gt;caretLeftmostOffset();
314                 continue;
315             }
316 
317             offset = box-&gt;isLeftToRightDirection() ? renderer-&gt;nextOffset(offset) : renderer-&gt;previousOffset(offset);
318 
319             int caretMinOffset = box-&gt;caretMinOffset();
320             int caretMaxOffset = box-&gt;caretMaxOffset();
321 
322             if (offset &gt; caretMinOffset &amp;&amp; offset &lt; caretMaxOffset)
323                 break;
324 
325             if (box-&gt;isLeftToRightDirection() ? offset &gt; caretMaxOffset : offset &lt; caretMinOffset) {
326                 // Overshot to the right.
<span class="line-modified">327                 InlineBox* nextBox = box-&gt;nextLeafOnLineIgnoringLineBreak();</span>
328                 if (!nextBox) {
329                     Position positionOnRight = primaryDirection == TextDirection::LTR ? nextVisuallyDistinctCandidate(m_deepPosition) : previousVisuallyDistinctCandidate(m_deepPosition);
330                     if (positionOnRight.isNull())
331                         return Position();
332 
333                     InlineBox* boxOnRight;
334                     int offsetOnRight;
335                     positionOnRight.getInlineBoxAndOffset(m_affinity, primaryDirection, boxOnRight, offsetOnRight);
336                     if (boxOnRight &amp;&amp; &amp;boxOnRight-&gt;root() == &amp;box-&gt;root())
337                         return Position();
338                     return positionOnRight;
339                 }
340 
341                 // Reposition at the other logical position corresponding to our edge&#39;s visual position and go for another round.
342                 box = nextBox;
343                 renderer = &amp;box-&gt;renderer();
344                 offset = nextBox-&gt;caretLeftmostOffset();
345                 continue;
346             }
347 
348             ASSERT(offset == box-&gt;caretRightmostOffset());
349 
350             unsigned char level = box-&gt;bidiLevel();
<span class="line-modified">351             InlineBox* nextBox = box-&gt;nextLeafOnLine();</span>
352 
353             if (box-&gt;direction() == primaryDirection) {
354                 if (!nextBox) {
355                     InlineBox* logicalEnd = nullptr;
356                     if (primaryDirection == TextDirection::LTR ? box-&gt;root().getLogicalEndBoxWithNode(logicalEnd) : box-&gt;root().getLogicalStartBoxWithNode(logicalEnd)) {
357                         box = logicalEnd;
358                         renderer = &amp;box-&gt;renderer();
359                         offset = primaryDirection == TextDirection::LTR ? box-&gt;caretMaxOffset() : box-&gt;caretMinOffset();
360                     }
361                     break;
362                 }
363 
364                 if (nextBox-&gt;bidiLevel() &gt;= level)
365                     break;
366 
367                 level = nextBox-&gt;bidiLevel();
368 
369                 InlineBox* prevBox = box;
370                 do {
<span class="line-modified">371                     prevBox = prevBox-&gt;previousLeafOnLine();</span>
372                 } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; level);
373 
374                 if (prevBox &amp;&amp; prevBox-&gt;bidiLevel() == level)   // For example, abc FED 123 ^ CBA
375                     break;
376 
377                 // For example, abc 123 ^ CBA or 123 ^ CBA abc
378                 box = nextBox;
379                 renderer = &amp;box-&gt;renderer();
380                 offset = box-&gt;caretLeftmostOffset();
381                 if (box-&gt;direction() == primaryDirection)
382                     break;
383                 continue;
384             }
385 
386             while (nextBox &amp;&amp; !nextBox-&gt;renderer().node())
<span class="line-modified">387                 nextBox = nextBox-&gt;nextLeafOnLine();</span>
388 
389             if (nextBox) {
390                 box = nextBox;
391                 renderer = &amp;box-&gt;renderer();
392                 offset = box-&gt;caretLeftmostOffset();
393 
394                 if (box-&gt;bidiLevel() &gt; level) {
395                     do {
<span class="line-modified">396                         nextBox = nextBox-&gt;nextLeafOnLine();</span>
397                     } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; level);
398 
399                     if (!nextBox || nextBox-&gt;bidiLevel() &lt; level)
400                         continue;
401                 }
402             } else {
403                 // Trailing edge of a secondary run. Set to the leading edge of the entire run.
404                 while (true) {
<span class="line-modified">405                     while (InlineBox* prevBox = box-&gt;previousLeafOnLine()) {</span>
406                         if (prevBox-&gt;bidiLevel() &lt; level)
407                             break;
408                         box = prevBox;
409                     }
410                     if (box-&gt;bidiLevel() == level)
411                         break;
412                     level = box-&gt;bidiLevel();
<span class="line-modified">413                     while (InlineBox* nextBox = box-&gt;nextLeafOnLine()) {</span>
414                         if (nextBox-&gt;bidiLevel() &lt; level)
415                             break;
416                         box = nextBox;
417                     }
418                     if (box-&gt;bidiLevel() == level)
419                         break;
420                     level = box-&gt;bidiLevel();
421                 }
422                 renderer = &amp;box-&gt;renderer();
423                 offset = primaryDirection == TextDirection::LTR ? box-&gt;caretMaxOffset() : box-&gt;caretMinOffset();
424             }
425             break;
426         }
427 
428         p = createLegacyEditingPosition(renderer-&gt;node(), offset);
429 
430         if ((p.isCandidate() &amp;&amp; p.downstream() != downstreamStart) || p.atStartOfTree() || p.atEndOfTree())
431             return p;
432 
433         ASSERT(p != m_deepPosition);
</pre>
<hr />
<pre>
650     if (!renderer)
651         return LayoutRect();
652 
653     InlineBox* inlineBox;
654     int caretOffset;
655     getInlineBoxAndOffset(inlineBox, caretOffset);
656 
657     if (inlineBox)
658         renderer = &amp;inlineBox-&gt;renderer();
659 
660     return renderer-&gt;localCaretRect(inlineBox, caretOffset);
661 }
662 
663 IntRect VisiblePosition::absoluteCaretBounds(bool* insideFixed) const
664 {
665     RenderBlock* renderer = nullptr;
666     LayoutRect localRect = localCaretRectInRendererForCaretPainting(*this, renderer);
667     return absoluteBoundsForLocalCaretRect(renderer, localRect, insideFixed);
668 }
669 
<span class="line-added">670 FloatRect VisiblePosition::absoluteSelectionBoundsForLine() const</span>
<span class="line-added">671 {</span>
<span class="line-added">672     if (m_deepPosition.isNull())</span>
<span class="line-added">673         return { };</span>
<span class="line-added">674 </span>
<span class="line-added">675     auto* node = m_deepPosition.anchorNode();</span>
<span class="line-added">676     if (!node-&gt;renderer())</span>
<span class="line-added">677         return { };</span>
<span class="line-added">678 </span>
<span class="line-added">679     InlineBox* inlineBox = nullptr;</span>
<span class="line-added">680     int caretOffset = 0;</span>
<span class="line-added">681     getInlineBoxAndOffset(inlineBox, caretOffset);</span>
<span class="line-added">682 </span>
<span class="line-added">683     if (!inlineBox)</span>
<span class="line-added">684         return { };</span>
<span class="line-added">685 </span>
<span class="line-added">686     auto&amp; root = inlineBox-&gt;root();</span>
<span class="line-added">687     auto localRect = FloatRect { root.x(), root.selectionTop(), root.width(), root.selectionHeight() };</span>
<span class="line-added">688     return root.renderer().localToAbsoluteQuad(localRect).boundingBox();</span>
<span class="line-added">689 }</span>
<span class="line-added">690 </span>
691 int VisiblePosition::lineDirectionPointForBlockDirectionNavigation() const
692 {
693     RenderObject* renderer;
694     LayoutRect localRect = localCaretRect(renderer);
695     if (localRect.isEmpty() || !renderer)
696         return 0;
697 
698     // This ignores transforms on purpose, for now. Vertical navigation is done
699     // without consulting transforms, so that &#39;up&#39; in transformed text is &#39;up&#39;
700     // relative to the text, not absolute &#39;up&#39;.
701     FloatPoint caretPoint = renderer-&gt;localToAbsolute(localRect.location());
702     RenderObject* containingBlock = renderer-&gt;containingBlock();
703     if (!containingBlock)
704         containingBlock = renderer; // Just use ourselves to determine the writing mode if we have no containing block.
705     return containingBlock-&gt;isHorizontalWritingMode() ? caretPoint.x() : caretPoint.y();
706 }
707 
708 #if ENABLE(TREE_DEBUGGING)
709 
710 void VisiblePosition::debugPosition(const char* msg) const
</pre>
<hr />
<pre>
792 
793     if (!visiblePosition.deepEquivalent().containerNode()-&gt;isDescendantOf(node))
794         return false;
795 
796     VisiblePosition previous = visiblePosition.previous();
797     return previous.isNull() || !previous.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(node);
798 }
799 
800 bool isLastVisiblePositionInNode(const VisiblePosition &amp;visiblePosition, const Node *node)
801 {
802     if (visiblePosition.isNull())
803         return false;
804 
805     if (!visiblePosition.deepEquivalent().containerNode()-&gt;isDescendantOf(node))
806         return false;
807 
808     VisiblePosition next = visiblePosition.next();
809     return next.isNull() || !next.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(node);
810 }
811 
<span class="line-added">812 bool areVisiblePositionsInSameTreeScope(const VisiblePosition&amp; a, const VisiblePosition&amp; b)</span>
<span class="line-added">813 {</span>
<span class="line-added">814     return areNodesConnectedInSameTreeScope(a.deepEquivalent().anchorNode(), b.deepEquivalent().anchorNode());</span>
<span class="line-added">815 }</span>
<span class="line-added">816 </span>
817 bool VisiblePosition::equals(const VisiblePosition&amp; other) const
818 {
819     return m_affinity == other.m_affinity &amp;&amp; m_deepPosition.equals(other.m_deepPosition);
820 }
821 
822 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, EAffinity affinity)
823 {
824     switch (affinity) {
825     case UPSTREAM:
826         stream &lt;&lt; &quot;upstream&quot;;
827         break;
828     case DOWNSTREAM:
829         stream &lt;&lt; &quot;downstream&quot;;
830         break;
831     }
832     return stream;
833 }
834 
835 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const VisiblePosition&amp; visiblePosition)
836 {
</pre>
</td>
</tr>
</table>
<center><a href="TypingCommand.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VisiblePosition.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
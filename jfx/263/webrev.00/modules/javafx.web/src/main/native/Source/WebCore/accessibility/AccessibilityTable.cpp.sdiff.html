<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityTable.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilitySpinButton.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityTableCell.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
521 }
522 
523 const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityTable::rows()
524 {
525     updateChildrenIfNecessary();
526 
527     return m_rows;
528 }
529 
530 void AccessibilityTable::columnHeaders(AccessibilityChildrenVector&amp; headers)
531 {
532     if (!m_renderer)
533         return;
534 
535     updateChildrenIfNecessary();
536 
537     // Sometimes m_columns can be reset during the iteration, we cache it here to be safe.
538     AccessibilityChildrenVector columnsCopy = m_columns;
539 
540     for (const auto&amp; column : columnsCopy) {
<span class="line-modified">541         if (AccessibilityObject* header = downcast&lt;AccessibilityTableColumn&gt;(*column).headerObject())</span>
542             headers.append(header);
543     }
544 }
545 
546 void AccessibilityTable::rowHeaders(AccessibilityChildrenVector&amp; headers)
547 {
548     if (!m_renderer)
549         return;
550 
551     updateChildrenIfNecessary();
552 
553     // Sometimes m_rows can be reset during the iteration, we cache it here to be safe.
554     AccessibilityChildrenVector rowsCopy = m_rows;
555 
556     for (const auto&amp; row : rowsCopy) {
<span class="line-modified">557         if (AccessibilityObject* header = downcast&lt;AccessibilityTableRow&gt;(*row).headerObject())</span>
558             headers.append(header);
559     }
560 }
561 
562 void AccessibilityTable::visibleRows(AccessibilityChildrenVector&amp; rows)
563 {
564     if (!m_renderer)
565         return;
566 
567     updateChildrenIfNecessary();
568 
569     for (const auto&amp; row : m_rows) {
570         if (row &amp;&amp; !row-&gt;isOffScreen())
571             rows.append(row);
572     }
573 }
574 
575 void AccessibilityTable::cells(AccessibilityObject::AccessibilityChildrenVector&amp; cells)
576 {
577     if (!m_renderer)
</pre>
<hr />
<pre>
605             ++level;
606     }
607 
608     return level;
609 }
610 
611 AccessibilityTableCell* AccessibilityTable::cellForColumnAndRow(unsigned column, unsigned row)
612 {
613     updateChildrenIfNecessary();
614     if (column &gt;= columnCount() || row &gt;= rowCount())
615         return nullptr;
616 
617     // Iterate backwards through the rows in case the desired cell has a rowspan and exists in a previous row.
618     for (unsigned rowIndexCounter = row + 1; rowIndexCounter &gt; 0; --rowIndexCounter) {
619         unsigned rowIndex = rowIndexCounter - 1;
620         const auto&amp; children = m_rows[rowIndex]-&gt;children();
621         // Since some cells may have colspans, we have to check the actual range of each
622         // cell to determine which is the right one.
623         for (unsigned colIndexCounter = std::min(static_cast&lt;unsigned&gt;(children.size()), column + 1); colIndexCounter &gt; 0; --colIndexCounter) {
624             unsigned colIndex = colIndexCounter - 1;
<span class="line-modified">625             AccessibilityObject* child = children[colIndex].get();</span>
626             ASSERT(is&lt;AccessibilityTableCell&gt;(*child));
627             if (!is&lt;AccessibilityTableCell&gt;(*child))
628                 continue;
629 
630             std::pair&lt;unsigned, unsigned&gt; columnRange;
631             std::pair&lt;unsigned, unsigned&gt; rowRange;
632             auto&amp; tableCellChild = downcast&lt;AccessibilityTableCell&gt;(*child);
633             tableCellChild.columnIndexRange(columnRange);
634             tableCellChild.rowIndexRange(rowRange);
635 
636             if ((column &gt;= columnRange.first &amp;&amp; column &lt; (columnRange.first + columnRange.second))
637                 &amp;&amp; (row &gt;= rowRange.first &amp;&amp; row &lt; (rowRange.first + rowRange.second)))
638                 return &amp;tableCellChild;
639         }
640     }
641 
642     return nullptr;
643 }
644 
645 AccessibilityRole AccessibilityTable::roleValue() const
</pre>
</td>
<td>
<hr />
<pre>
521 }
522 
523 const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityTable::rows()
524 {
525     updateChildrenIfNecessary();
526 
527     return m_rows;
528 }
529 
530 void AccessibilityTable::columnHeaders(AccessibilityChildrenVector&amp; headers)
531 {
532     if (!m_renderer)
533         return;
534 
535     updateChildrenIfNecessary();
536 
537     // Sometimes m_columns can be reset during the iteration, we cache it here to be safe.
538     AccessibilityChildrenVector columnsCopy = m_columns;
539 
540     for (const auto&amp; column : columnsCopy) {
<span class="line-modified">541         if (AXCoreObject* header = downcast&lt;AccessibilityTableColumn&gt;(*column).headerObject())</span>
542             headers.append(header);
543     }
544 }
545 
546 void AccessibilityTable::rowHeaders(AccessibilityChildrenVector&amp; headers)
547 {
548     if (!m_renderer)
549         return;
550 
551     updateChildrenIfNecessary();
552 
553     // Sometimes m_rows can be reset during the iteration, we cache it here to be safe.
554     AccessibilityChildrenVector rowsCopy = m_rows;
555 
556     for (const auto&amp; row : rowsCopy) {
<span class="line-modified">557         if (AXCoreObject* header = downcast&lt;AccessibilityTableRow&gt;(*row).headerObject())</span>
558             headers.append(header);
559     }
560 }
561 
562 void AccessibilityTable::visibleRows(AccessibilityChildrenVector&amp; rows)
563 {
564     if (!m_renderer)
565         return;
566 
567     updateChildrenIfNecessary();
568 
569     for (const auto&amp; row : m_rows) {
570         if (row &amp;&amp; !row-&gt;isOffScreen())
571             rows.append(row);
572     }
573 }
574 
575 void AccessibilityTable::cells(AccessibilityObject::AccessibilityChildrenVector&amp; cells)
576 {
577     if (!m_renderer)
</pre>
<hr />
<pre>
605             ++level;
606     }
607 
608     return level;
609 }
610 
611 AccessibilityTableCell* AccessibilityTable::cellForColumnAndRow(unsigned column, unsigned row)
612 {
613     updateChildrenIfNecessary();
614     if (column &gt;= columnCount() || row &gt;= rowCount())
615         return nullptr;
616 
617     // Iterate backwards through the rows in case the desired cell has a rowspan and exists in a previous row.
618     for (unsigned rowIndexCounter = row + 1; rowIndexCounter &gt; 0; --rowIndexCounter) {
619         unsigned rowIndex = rowIndexCounter - 1;
620         const auto&amp; children = m_rows[rowIndex]-&gt;children();
621         // Since some cells may have colspans, we have to check the actual range of each
622         // cell to determine which is the right one.
623         for (unsigned colIndexCounter = std::min(static_cast&lt;unsigned&gt;(children.size()), column + 1); colIndexCounter &gt; 0; --colIndexCounter) {
624             unsigned colIndex = colIndexCounter - 1;
<span class="line-modified">625             AXCoreObject* child = children[colIndex].get();</span>
626             ASSERT(is&lt;AccessibilityTableCell&gt;(*child));
627             if (!is&lt;AccessibilityTableCell&gt;(*child))
628                 continue;
629 
630             std::pair&lt;unsigned, unsigned&gt; columnRange;
631             std::pair&lt;unsigned, unsigned&gt; rowRange;
632             auto&amp; tableCellChild = downcast&lt;AccessibilityTableCell&gt;(*child);
633             tableCellChild.columnIndexRange(columnRange);
634             tableCellChild.rowIndexRange(rowRange);
635 
636             if ((column &gt;= columnRange.first &amp;&amp; column &lt; (columnRange.first + columnRange.second))
637                 &amp;&amp; (row &gt;= rowRange.first &amp;&amp; row &lt; (rowRange.first + rowRange.second)))
638                 return &amp;tableCellChild;
639         }
640     }
641 
642     return nullptr;
643 }
644 
645 AccessibilityRole AccessibilityTable::roleValue() const
</pre>
</td>
</tr>
</table>
<center><a href="AccessibilitySpinButton.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityTableCell.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
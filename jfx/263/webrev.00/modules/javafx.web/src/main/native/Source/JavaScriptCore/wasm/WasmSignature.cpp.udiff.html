<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSignature.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmSections.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSignature.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSignature.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27,84 +27,154 @@</span>
  #include &quot;WasmSignature.h&quot;
  
  #if ENABLE(WEBASSEMBLY)
  
  #include &quot;WasmSignatureInlines.h&quot;
<span class="udiff-line-added">+ #include &lt;wtf/CommaPrinter.h&gt;</span>
  #include &lt;wtf/FastMalloc.h&gt;
  #include &lt;wtf/HashFunctions.h&gt;
  #include &lt;wtf/PrintStream.h&gt;
<span class="udiff-line-added">+ #include &lt;wtf/StringPrintStream.h&gt;</span>
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace JSC { namespace Wasm {
  
  namespace {
  namespace WasmSignatureInternal {
<span class="udiff-line-modified-removed">- static const bool verbose = false;</span>
<span class="udiff-line-modified-added">+ static constexpr bool verbose = false;</span>
  }
  }
  
  SignatureInformation* SignatureInformation::theOne { nullptr };
  std::once_flag SignatureInformation::signatureInformationFlag;
  
  String Signature::toString() const
  {
<span class="udiff-line-modified-removed">-     String result(makeString(returnType()));</span>
<span class="udiff-line-removed">-     result.append(&quot; (&quot;);</span>
<span class="udiff-line-removed">-     for (SignatureArgCount arg = 0; arg &lt; argumentCount(); ++arg) {</span>
<span class="udiff-line-removed">-         if (arg)</span>
<span class="udiff-line-removed">-             result.append(&quot;, &quot;);</span>
<span class="udiff-line-removed">-         result.append(makeString(argument(arg)));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     result.append(&#39;)&#39;);</span>
<span class="udiff-line-removed">-     return result;</span>
<span class="udiff-line-modified-added">+     return WTF::toString(*this);</span>
  }
  
  void Signature::dump(PrintStream&amp; out) const
  {
<span class="udiff-line-modified-removed">-     out.print(toString());</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-added">+         out.print(&quot;(&quot;);</span>
<span class="udiff-line-added">+         CommaPrinter comma;</span>
<span class="udiff-line-added">+         for (SignatureArgCount arg = 0; arg &lt; argumentCount(); ++arg)</span>
<span class="udiff-line-added">+             out.print(comma, makeString(argument(arg)));</span>
<span class="udiff-line-added">+         out.print(&quot;)&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         CommaPrinter comma;</span>
<span class="udiff-line-added">+         out.print(&quot; -&gt; [&quot;);</span>
<span class="udiff-line-added">+         for (SignatureArgCount ret = 0; ret &lt; returnCount(); ++ret)</span>
<span class="udiff-line-added">+             out.print(comma, makeString(returnType(ret)));</span>
<span class="udiff-line-added">+         out.print(&quot;]&quot;);</span>
<span class="udiff-line-added">+     }</span>
  }
  
<span class="udiff-line-modified-removed">- unsigned Signature::hash() const</span>
<span class="udiff-line-modified-added">+ static unsigned computeHash(size_t returnCount, const Type* returnTypes, size_t argumentCount, const Type* argumentTypes)</span>
  {
      unsigned accumulator = 0xa1bcedd8u;
<span class="udiff-line-modified-removed">-     for (uint32_t i = 0; i &lt; argumentCount(); ++i)</span>
<span class="udiff-line-modified-removed">-         accumulator = WTF::pairIntHash(accumulator, WTF::IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(argument(i))));</span>
<span class="udiff-line-modified-removed">-     accumulator = WTF::pairIntHash(accumulator, WTF::IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(returnType())));</span>
<span class="udiff-line-modified-added">+     for (uint32_t i = 0; i &lt; argumentCount; ++i)</span>
<span class="udiff-line-modified-added">+         accumulator = WTF::pairIntHash(accumulator, WTF::IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(argumentTypes[i])));</span>
<span class="udiff-line-modified-added">+     for (uint32_t i = 0; i &lt; returnCount; ++i)</span>
<span class="udiff-line-added">+         accumulator = WTF::pairIntHash(accumulator, WTF::IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(returnTypes[i])));</span>
      return accumulator;
  }
  
<span class="udiff-line-modified-removed">- RefPtr&lt;Signature&gt; Signature::tryCreate(SignatureArgCount argumentCount)</span>
<span class="udiff-line-modified-added">+ unsigned Signature::hash() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return computeHash(returnCount(), storage(0), argumentCount(), storage(returnCount()));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ RefPtr&lt;Signature&gt; Signature::tryCreate(SignatureArgCount returnCount, SignatureArgCount argumentCount)</span>
  {
      // We use WTF_MAKE_FAST_ALLOCATED for this class.
<span class="udiff-line-modified-removed">-     auto result = tryFastMalloc(allocatedSize(argumentCount));</span>
<span class="udiff-line-modified-added">+     auto result = tryFastMalloc(allocatedSize(returnCount, argumentCount));</span>
      void* memory = nullptr;
      if (!result.getValue(memory))
          return nullptr;
<span class="udiff-line-modified-removed">-     Signature* signature = new (NotNull, memory) Signature(argumentCount);</span>
<span class="udiff-line-modified-added">+     Signature* signature = new (NotNull, memory) Signature(returnCount, argumentCount);</span>
      return adoptRef(signature);
  }
  
  SignatureInformation::SignatureInformation()
  {
<span class="udiff-line-added">+ #define MAKE_THUNK_SIGNATURE(type, enc, str, val)                          \</span>
<span class="udiff-line-added">+     do {                                                                   \</span>
<span class="udiff-line-added">+         if (type != Void) {                                                \</span>
<span class="udiff-line-added">+             RefPtr&lt;Signature&gt; sig = Signature::tryCreate(1, 0);            \</span>
<span class="udiff-line-added">+             sig-&gt;ref();                                                    \</span>
<span class="udiff-line-added">+             sig-&gt;getReturnType(0) = type;                                  \</span>
<span class="udiff-line-added">+             thunkSignatures[linearizeType(type)] = sig.get();              \</span>
<span class="udiff-line-added">+             m_signatureSet.add(SignatureHash { sig.releaseNonNull() });    \</span>
<span class="udiff-line-added">+         }                                                                  \</span>
<span class="udiff-line-added">+     } while (false);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     FOR_EACH_WASM_TYPE(MAKE_THUNK_SIGNATURE);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Make Void again because we don&#39;t use the one that has void in it.</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         RefPtr&lt;Signature&gt; sig = Signature::tryCreate(0, 0);</span>
<span class="udiff-line-added">+         sig-&gt;ref();</span>
<span class="udiff-line-added">+         thunkSignatures[linearizeType(Void)] = sig.get();</span>
<span class="udiff-line-added">+         m_signatureSet.add(SignatureHash { sig.releaseNonNull() });</span>
<span class="udiff-line-added">+     }</span>
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;Signature&gt; SignatureInformation::adopt(Ref&lt;Signature&gt;&amp;&amp; signature)</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ struct ParameterTypes {</span>
<span class="udiff-line-added">+     const Vector&lt;Type, 1&gt;&amp; returnTypes;</span>
<span class="udiff-line-added">+     const Vector&lt;Type&gt;&amp; argumentTypes;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static unsigned hash(const ParameterTypes&amp; params)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         return computeHash(params.returnTypes.size(), params.returnTypes.data(), params.argumentTypes.size(), params.argumentTypes.data());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static bool equal(const SignatureHash&amp; sig, const ParameterTypes&amp; params)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (sig.key-&gt;argumentCount() != params.argumentTypes.size())</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         if (sig.key-&gt;returnCount() != params.returnTypes.size())</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (unsigned i = 0; i &lt; sig.key-&gt;argumentCount(); ++i) {</span>
<span class="udiff-line-added">+             if (sig.key-&gt;argument(i) != params.argumentTypes[i])</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (unsigned i = 0; i &lt; sig.key-&gt;returnCount(); ++i) {</span>
<span class="udiff-line-added">+             if (sig.key-&gt;returnType(i) != params.returnTypes[i])</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static void translate(SignatureHash&amp; entry, const ParameterTypes&amp; params, unsigned)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         RefPtr&lt;Signature&gt; signature = Signature::tryCreate(params.returnTypes.size(), params.argumentTypes.size());</span>
<span class="udiff-line-added">+         RELEASE_ASSERT(signature);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (unsigned i = 0; i &lt; params.returnTypes.size(); ++i)</span>
<span class="udiff-line-added">+             signature-&gt;getReturnType(i) = params.returnTypes[i];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (unsigned i = 0; i &lt; params.argumentTypes.size(); ++i)</span>
<span class="udiff-line-added">+             signature-&gt;getArgument(i) = params.argumentTypes[i];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         entry.key = WTFMove(signature);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ RefPtr&lt;Signature&gt; SignatureInformation::signatureFor(const Vector&lt;Type, 1&gt;&amp; results, const Vector&lt;Type&gt;&amp; args)</span>
  {
      SignatureInformation&amp; info = singleton();
      LockHolder lock(info.m_lock);
  
<span class="udiff-line-modified-removed">-     SignatureIndex nextValue = signature-&gt;index();</span>
<span class="udiff-line-modified-removed">-     auto addResult = info.m_signatureSet.add(SignatureHash { signature.copyRef() });</span>
<span class="udiff-line-removed">-     if (addResult.isNewEntry) {</span>
<span class="udiff-line-removed">-         if (WasmSignatureInternal::verbose)</span>
<span class="udiff-line-removed">-             dataLogLn(&quot;Adopt new signature &quot;, signature.get(), &quot; with index &quot;, nextValue, &quot; hash: &quot;, signature-&gt;hash());</span>
<span class="udiff-line-removed">-         return WTFMove(signature);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     nextValue = addResult.iterator-&gt;key-&gt;index();</span>
<span class="udiff-line-removed">-     if (WasmSignatureInternal::verbose)</span>
<span class="udiff-line-removed">-         dataLogLn(&quot;Existing signature &quot;, signature.get(), &quot; with index &quot;, nextValue, &quot; hash: &quot;, signature-&gt;hash());</span>
<span class="udiff-line-removed">-     return Ref&lt;Signature&gt;(*addResult.iterator-&gt;key);</span>
<span class="udiff-line-modified-added">+     auto addResult = info.m_signatureSet.template add&lt;ParameterTypes&gt;(ParameterTypes { results, args });</span>
<span class="udiff-line-modified-added">+     return makeRef(*addResult.iterator-&gt;key);</span>
  }
  
  void SignatureInformation::tryCleanup()
  {
      SignatureInformation&amp; info = singleton();
</pre>
<center><a href="WasmSections.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSignature.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/Timer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ThreadTimers.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UserAgentQuirks.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/Timer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,17 ***</span>
  
  #include &quot;RuntimeApplicationChecks.h&quot;
  #include &quot;SharedTimer.h&quot;
  #include &quot;ThreadGlobalData.h&quot;
  #include &quot;ThreadTimers.h&quot;
<span class="line-removed">- #include &lt;limits.h&gt;</span>
  #include &lt;limits&gt;
  #include &lt;math.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/Vector.h&gt;
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY) || PLATFORM(MAC)</span>
  #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
  #endif
  
  namespace WebCore {
  
<span class="line-new-header">--- 29,16 ---</span>
  
  #include &quot;RuntimeApplicationChecks.h&quot;
  #include &quot;SharedTimer.h&quot;
  #include &quot;ThreadGlobalData.h&quot;
  #include &quot;ThreadTimers.h&quot;
  #include &lt;limits&gt;
  #include &lt;math.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/Vector.h&gt;
  
<span class="line-modified">! #if PLATFORM(COCOA)</span>
  #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
  #endif
  
  namespace WebCore {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,11 ***</span>
  // Timers are stored in a heap data structure, used to implement a priority queue.
  // This allows us to efficiently determine which timer needs to fire the soonest.
  // Then we set a single shared system timer to fire at that time.
  //
  // When a timer&#39;s &quot;next fire time&quot; changes, we need to move it around in the priority queue.
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  static ThreadTimerHeap&amp; threadGlobalTimerHeap()
  {
      return threadGlobalData().threadTimers().timerHeap();
  }
  #endif
<span class="line-new-header">--- 47,11 ---</span>
  // Timers are stored in a heap data structure, used to implement a priority queue.
  // This allows us to efficiently determine which timer needs to fire the soonest.
  // Then we set a single shared system timer to fire at that time.
  //
  // When a timer&#39;s &quot;next fire time&quot; changes, we need to move it around in the priority queue.
<span class="line-modified">! #if ASSERT_ENABLED</span>
  static ThreadTimerHeap&amp; threadGlobalTimerHeap()
  {
      return threadGlobalData().threadTimers().timerHeap();
  }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 257,30 ***</span>
  {
  }
  
  TimerBase::~TimerBase()
  {
<span class="line-modified">!     ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));</span>
<span class="line-modified">!     RELEASE_ASSERT(canAccessThreadLocalDataForThread(m_thread.get()) || shouldSuppressThreadSafetyCheck());</span>
      stop();
      ASSERT(!inHeap());
      if (m_heapItem)
          m_heapItem-&gt;clearTimer();
      m_unalignedNextFireTime = MonotonicTime::nan();
  }
  
  void TimerBase::start(Seconds nextFireInterval, Seconds repeatInterval)
  {
<span class="line-modified">!     ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));</span>
  
      m_repeatInterval = repeatInterval;
      setNextFireTime(MonotonicTime::now() + nextFireInterval);
  }
  
  void TimerBase::stop()
  {
<span class="line-modified">!     ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));</span>
  
      m_repeatInterval = 0_s;
      setNextFireTime(MonotonicTime { });
  
      ASSERT(!static_cast&lt;bool&gt;(nextFireTime()));
<span class="line-new-header">--- 256,30 ---</span>
  {
  }
  
  TimerBase::~TimerBase()
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));</span>
<span class="line-modified">!     RELEASE_ASSERT(canCurrentThreadAccessThreadLocalData(m_thread) || shouldSuppressThreadSafetyCheck());</span>
      stop();
      ASSERT(!inHeap());
      if (m_heapItem)
          m_heapItem-&gt;clearTimer();
      m_unalignedNextFireTime = MonotonicTime::nan();
  }
  
  void TimerBase::start(Seconds nextFireInterval, Seconds repeatInterval)
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));</span>
  
      m_repeatInterval = repeatInterval;
      setNextFireTime(MonotonicTime::now() + nextFireInterval);
  }
  
  void TimerBase::stop()
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));</span>
  
      m_repeatInterval = 0_s;
      setNextFireTime(MonotonicTime { });
  
      ASSERT(!static_cast&lt;bool&gt;(nextFireTime()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,11 ***</span>
      return fireTime - current;
  }
  
  inline void TimerBase::checkHeapIndex() const
  {
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      ASSERT(m_heapItem);
      auto&amp; heap = m_heapItem-&gt;timerHeap();
      ASSERT(&amp;heap == &amp;threadGlobalTimerHeap());
      ASSERT(!heap.isEmpty());
      ASSERT(m_heapItem-&gt;isInHeap());
<span class="line-new-header">--- 298,11 ---</span>
      return fireTime - current;
  }
  
  inline void TimerBase::checkHeapIndex() const
  {
<span class="line-modified">! #if ASSERT_ENABLED</span>
      ASSERT(m_heapItem);
      auto&amp; heap = m_heapItem-&gt;timerHeap();
      ASSERT(&amp;heap == &amp;threadGlobalTimerHeap());
      ASSERT(!heap.isEmpty());
      ASSERT(m_heapItem-&gt;isInHeap());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 433,11 ***</span>
  {
      auto fireTime = nextFireTime();
      if (fireTime &amp;&amp; hasValidHeapPosition())
          return;
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      Optional&lt;unsigned&gt; oldHeapIndex;
      if (m_heapItem-&gt;isInHeap())
          oldHeapIndex = m_heapItem-&gt;heapIndex();
  #endif
  
<span class="line-new-header">--- 432,11 ---</span>
  {
      auto fireTime = nextFireTime();
      if (fireTime &amp;&amp; hasValidHeapPosition())
          return;
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      Optional&lt;unsigned&gt; oldHeapIndex;
      if (m_heapItem-&gt;isInHeap())
          oldHeapIndex = m_heapItem-&gt;heapIndex();
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 448,11 ***</span>
      else if (fireTime &lt; oldTime)
          heapDecreaseKey();
      else
          heapIncreaseKey();
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      Optional&lt;unsigned&gt; newHeapIndex;
      if (m_heapItem-&gt;isInHeap())
          newHeapIndex = m_heapItem-&gt;heapIndex();
      ASSERT(newHeapIndex != oldHeapIndex);
  #endif
<span class="line-new-header">--- 447,11 ---</span>
      else if (fireTime &lt; oldTime)
          heapDecreaseKey();
      else
          heapIncreaseKey();
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      Optional&lt;unsigned&gt; newHeapIndex;
      if (m_heapItem-&gt;isInHeap())
          newHeapIndex = m_heapItem-&gt;heapIndex();
      ASSERT(newHeapIndex != oldHeapIndex);
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 460,12 ***</span>
      ASSERT(!inHeap() || hasValidHeapPosition());
  }
  
  void TimerBase::setNextFireTime(MonotonicTime newTime)
  {
<span class="line-modified">!     ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));</span>
<span class="line-modified">!     RELEASE_ASSERT(canAccessThreadLocalDataForThread(m_thread.get()) || shouldSuppressThreadSafetyCheck());</span>
      bool timerHasBeenDeleted = std::isnan(m_unalignedNextFireTime);
      RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!timerHasBeenDeleted);
  
      if (m_unalignedNextFireTime != newTime) {
          RELEASE_ASSERT(!std::isnan(newTime));
<span class="line-new-header">--- 459,12 ---</span>
      ASSERT(!inHeap() || hasValidHeapPosition());
  }
  
  void TimerBase::setNextFireTime(MonotonicTime newTime)
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));</span>
<span class="line-modified">!     RELEASE_ASSERT(canCurrentThreadAccessThreadLocalData(m_thread) || shouldSuppressThreadSafetyCheck());</span>
      bool timerHasBeenDeleted = std::isnan(m_unalignedNextFireTime);
      RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!timerHasBeenDeleted);
  
      if (m_unalignedNextFireTime != newTime) {
          RELEASE_ASSERT(!std::isnan(newTime));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 479,13 ***</span>
          if (auto newAlignedTime = alignedFireTime(newTime))
              newTime = newAlignedTime.value();
      }
  
      if (oldTime != newTime) {
<span class="line-modified">!         // FIXME: This should be part of ThreadTimers, or another per-thread structure.</span>
<span class="line-removed">-         static std::atomic&lt;unsigned&gt; currentHeapInsertionOrder;</span>
<span class="line-removed">-         auto newOrder = currentHeapInsertionOrder++;</span>
  
          if (!m_heapItem)
              m_heapItem = ThreadTimerHeapItem::create(*this, newTime, 0);
          m_heapItem-&gt;time = newTime;
          m_heapItem-&gt;insertionOrder = newOrder;
<span class="line-new-header">--- 478,11 ---</span>
          if (auto newAlignedTime = alignedFireTime(newTime))
              newTime = newAlignedTime.value();
      }
  
      if (oldTime != newTime) {
<span class="line-modified">!         auto newOrder = threadGlobalData().threadTimers().nextHeapInsertionCount();</span>
  
          if (!m_heapItem)
              m_heapItem = ThreadTimerHeapItem::create(*this, newTime, 0);
          m_heapItem-&gt;time = newTime;
          m_heapItem-&gt;insertionOrder = newOrder;
</pre>
<center><a href="ThreadTimers.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UserAgentQuirks.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
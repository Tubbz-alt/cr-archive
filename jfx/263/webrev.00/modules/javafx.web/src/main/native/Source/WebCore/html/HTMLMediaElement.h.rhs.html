<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(VIDEO)
  29 
  30 #include &quot;ActiveDOMObject.h&quot;
<a name="2" id="anc2"></a>
  31 #include &quot;AutoplayEvent.h&quot;
  32 #include &quot;DeferrableTask.h&quot;
  33 #include &quot;GenericEventQueue.h&quot;
  34 #include &quot;HTMLElement.h&quot;
  35 #include &quot;HTMLMediaElementEnums.h&quot;
  36 #include &quot;MediaCanStartListener.h&quot;
  37 #include &quot;MediaControllerInterface.h&quot;
  38 #include &quot;MediaElementSession.h&quot;
  39 #include &quot;MediaPlayer.h&quot;
  40 #include &quot;MediaProducer.h&quot;
  41 #include &quot;VisibilityChangeClient.h&quot;
  42 #include &lt;wtf/Function.h&gt;
  43 #include &lt;wtf/LoggerHelper.h&gt;
  44 #include &lt;wtf/WeakPtr.h&gt;
  45 
  46 #if ENABLE(VIDEO_TRACK)
  47 #include &quot;AudioTrack.h&quot;
  48 #include &quot;CaptionUserPreferences.h&quot;
<a name="3" id="anc3"></a>
  49 #include &quot;TextTrack.h&quot;
  50 #include &quot;TextTrackCue.h&quot;
  51 #include &quot;VTTCue.h&quot;
  52 #include &quot;VideoTrack.h&quot;
  53 #endif
  54 
  55 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
  56 #include &quot;AudioSession.h&quot;
  57 #endif
  58 
  59 #if ENABLE(ENCRYPTED_MEDIA)
  60 #include &quot;CDMClient.h&quot;
  61 #endif
  62 
  63 #ifndef NDEBUG
  64 #include &lt;wtf/StringPrintStream.h&gt;
  65 #endif
  66 
  67 namespace PAL {
  68 class SleepDisabler;
  69 }
  70 
  71 namespace WebCore {
  72 
  73 class AudioSourceProvider;
  74 class AudioTrackList;
  75 class AudioTrackPrivate;
  76 class Blob;
  77 class DOMException;
  78 class DOMWrapperWorld;
  79 class DeferredPromise;
  80 class Event;
  81 class HTMLSourceElement;
  82 class HTMLTrackElement;
  83 class InbandTextTrackPrivate;
  84 class JSDOMGlobalObject;
  85 class MediaController;
  86 class MediaControls;
  87 class MediaControlsHost;
  88 class MediaElementAudioSourceNode;
  89 class MediaError;
  90 class MediaKeys;
  91 class MediaResourceLoader;
  92 class MediaSession;
  93 class MediaSource;
  94 class MediaStream;
  95 class RenderMedia;
  96 class ScriptController;
  97 class ScriptExecutionContext;
  98 class SourceBuffer;
  99 class TextTrackList;
 100 class TimeRanges;
 101 class VideoPlaybackQuality;
 102 class VideoTrackList;
 103 class VideoTrackPrivate;
 104 class WebKitMediaKeys;
 105 
 106 template&lt;typename&gt; class DOMPromiseDeferred;
<a name="4" id="anc4"></a><span class="line-added"> 107 template&lt;typename, typename&gt; class PODInterval;</span>
<span class="line-added"> 108 </span>
<span class="line-added"> 109 #if ENABLE(WIRELESS_PLAYBACK_TARGET)</span>
<span class="line-added"> 110 class RemotePlayback;</span>
<span class="line-added"> 111 #endif</span>
 112 
 113 #if ENABLE(VIDEO_TRACK)
<a name="5" id="anc5"></a><span class="line-modified"> 114 using CueInterval = PODInterval&lt;MediaTime, TextTrackCue*&gt;;</span>

 115 using CueList = Vector&lt;CueInterval&gt;;
 116 #endif
 117 
 118 using MediaProvider = Optional&lt;Variant&lt;
 119 #if ENABLE(MEDIA_STREAM)
 120     RefPtr&lt;MediaStream&gt;,
 121 #endif
 122 #if ENABLE(MEDIA_SOURCE)
 123     RefPtr&lt;MediaSource&gt;,
 124 #endif
 125     RefPtr&lt;Blob&gt;&gt;&gt;;
 126 
 127 class HTMLMediaElement
 128     : public HTMLElement
 129     , public ActiveDOMObject
 130     , public MediaControllerInterface
 131     , public PlatformMediaSessionClient
 132     , private MediaCanStartListener
 133     , private MediaPlayerClient
 134     , private MediaProducer
 135     , private VisibilityChangeClient
<a name="6" id="anc6"></a>
 136 #if ENABLE(VIDEO_TRACK)
 137     , private AudioTrackClient
 138     , private TextTrackClient
 139     , private VideoTrackClient
 140 #endif
 141 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 142     , private AudioSession::MutedStateObserver
 143 #endif
 144 #if ENABLE(ENCRYPTED_MEDIA)
 145     , private CDMClient
 146 #endif
 147 #if !RELEASE_LOG_DISABLED
 148     , private LoggerHelper
 149 #endif
<a name="7" id="anc7"></a><span class="line-added"> 150     , public CanMakeWeakPtr&lt;HTMLMediaElement, WeakPtrFactoryInitialization::Eager&gt;</span>
 151 {
 152     WTF_MAKE_ISO_ALLOCATED(HTMLMediaElement);
 153 public:
 154     using WeakValueType = HTMLElement::WeakValueType;
 155     using HTMLElement::weakPtrFactory;
 156 
 157     RefPtr&lt;MediaPlayer&gt; player() const { return m_player; }
 158 
 159     virtual bool isVideo() const { return false; }
 160     bool hasVideo() const override { return false; }
 161     bool hasAudio() const override;
 162 
 163     static HashSet&lt;HTMLMediaElement*&gt;&amp; allMediaElements();
 164 
 165     WEBCORE_EXPORT static RefPtr&lt;HTMLMediaElement&gt; bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose);
 166 
<a name="8" id="anc8"></a>

 167     WEBCORE_EXPORT void rewind(double timeDelta);
 168     WEBCORE_EXPORT void returnToRealtime() override;
 169 
 170     // Eventually overloaded in HTMLVideoElement
 171     bool supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenMode) const override { return false; };
 172 
 173     bool supportsScanning() const override;
 174 
 175     bool canSaveMediaData() const;
 176 
 177     bool doesHaveAttribute(const AtomString&amp;, AtomString* value = nullptr) const override;
 178 
 179     PlatformLayer* platformLayer() const;
 180     bool isVideoLayerInline();
 181     void setPreparedToReturnVideoLayerToInline(bool);
 182     void waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 183 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 184     void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 185 #ifdef __OBJC__
 186     PlatformLayer* videoFullscreenLayer() const { return m_videoFullscreenLayer.get(); }
 187 #endif
<a name="9" id="anc9"></a><span class="line-modified"> 188     virtual void setVideoFullscreenFrame(FloatRect);</span>
<span class="line-modified"> 189     void setVideoFullscreenGravity(MediaPlayer::VideoGravity);</span>
<span class="line-modified"> 190     MediaPlayer::VideoGravity videoFullscreenGravity() const { return m_videoFullscreenGravity; }</span>
 191 #endif
 192 
 193     void scheduleCheckPlaybackTargetCompatability();
 194     void checkPlaybackTargetCompatablity();
 195     void scheduleResolvePendingPlayPromises();
 196     void scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp;);
 197     using PlayPromiseVector = Vector&lt;DOMPromiseDeferred&lt;void&gt;&gt;;
 198     void rejectPendingPlayPromises(PlayPromiseVector&amp;&amp;, Ref&lt;DOMException&gt;&amp;&amp;);
 199     void resolvePendingPlayPromises(PlayPromiseVector&amp;&amp;);
 200     void scheduleNotifyAboutPlaying();
 201     void notifyAboutPlaying(PlayPromiseVector&amp;&amp;);
 202 
<a name="10" id="anc10"></a><span class="line-modified"> 203     MediaPlayer::MovieLoadType movieLoadType() const;</span>
 204 
 205     bool inActiveDocument() const { return m_inActiveDocument; }
 206 
 207     Document* hostingDocument() const final { return &amp;document(); }
 208 
 209 // DOM API
 210 // error state
 211     WEBCORE_EXPORT MediaError* error() const;
 212 
 213     const URL&amp; currentSrc() const { return m_currentSrc; }
 214 
 215     const MediaProvider&amp; srcObject() const { return m_mediaProvider; }
 216     void setSrcObject(MediaProvider&amp;&amp;);
 217 
 218     WEBCORE_EXPORT void setCrossOrigin(const AtomString&amp;);
 219     WEBCORE_EXPORT String crossOrigin() const;
 220 
 221 // network state
 222     using HTMLMediaElementEnums::NetworkState;
 223     WEBCORE_EXPORT NetworkState networkState() const;
 224 
 225     WEBCORE_EXPORT String preload() const;
 226     WEBCORE_EXPORT void setPreload(const String&amp;);
 227 
 228     Ref&lt;TimeRanges&gt; buffered() const override;
 229     WEBCORE_EXPORT void load();
 230     WEBCORE_EXPORT String canPlayType(const String&amp; mimeType) const;
 231 
 232 // ready state
 233     using HTMLMediaElementEnums::ReadyState;
 234     ReadyState readyState() const override;
 235     WEBCORE_EXPORT bool seeking() const;
 236 
 237 // playback state
 238     WEBCORE_EXPORT double currentTime() const override;
 239     WEBCORE_EXPORT void setCurrentTime(double) override;
 240     void setCurrentTimeWithTolerance(double, double toleranceBefore, double toleranceAfter);
 241     double currentTimeForBindings() const { return currentTime(); }
 242     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setCurrentTimeForBindings(double);
 243     WEBCORE_EXPORT double getStartDate() const;
 244     WEBCORE_EXPORT double duration() const override;
 245     WEBCORE_EXPORT bool paused() const override;
 246     double defaultPlaybackRate() const override;
 247     void setDefaultPlaybackRate(double) override;
 248     WEBCORE_EXPORT double playbackRate() const override;
 249     void setPlaybackRate(double) override;
 250 
 251 // MediaTime versions of playback state
 252     MediaTime currentMediaTime() const;
 253     void setCurrentTime(const MediaTime&amp;);
 254     MediaTime durationMediaTime() const;
 255     WEBCORE_EXPORT void fastSeek(const MediaTime&amp;);
 256 
 257     void updatePlaybackRate();
 258     WEBCORE_EXPORT bool webkitPreservesPitch() const;
 259     WEBCORE_EXPORT void setWebkitPreservesPitch(bool);
 260     Ref&lt;TimeRanges&gt; played() override;
 261     Ref&lt;TimeRanges&gt; seekable() const override;
 262     double seekableTimeRangesLastModifiedTime() const;
 263     double liveUpdateInterval() const;
 264     WEBCORE_EXPORT bool ended() const;
 265     bool autoplay() const;
 266     bool isAutoplaying() const { return m_autoplaying; }
 267     bool loop() const;
 268     void setLoop(bool b);
 269 
 270     void play(DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
 271 
 272     WEBCORE_EXPORT void play() override;
 273     WEBCORE_EXPORT void pause() override;
 274     WEBCORE_EXPORT void fastSeek(double);
 275     double minFastReverseRate() const;
 276     double maxFastForwardRate() const;
 277 
 278     using HTMLMediaElementEnums::BufferingPolicy;
 279     void setBufferingPolicy(BufferingPolicy);
 280     WEBCORE_EXPORT BufferingPolicy bufferingPolicy() const;
 281     WEBCORE_EXPORT void purgeBufferedDataIfPossible();
 282 
 283 // captions
 284     WEBCORE_EXPORT bool webkitHasClosedCaptions() const;
 285     WEBCORE_EXPORT bool webkitClosedCaptionsVisible() const;
 286     WEBCORE_EXPORT void setWebkitClosedCaptionsVisible(bool);
 287 
 288     bool elementIsHidden() const { return m_elementIsHidden; }
 289 
 290 #if ENABLE(MEDIA_STATISTICS)
 291 // Statistics
 292     unsigned webkitAudioDecodedByteCount() const;
 293     unsigned webkitVideoDecodedByteCount() const;
 294 #endif
 295 
 296 #if ENABLE(MEDIA_SOURCE)
 297 //  Media Source.
 298     void detachMediaSource();
 299     void incrementDroppedFrameCount() { ++m_droppedVideoFrames; }
 300     size_t maximumSourceBufferSize(const SourceBuffer&amp;) const;
 301 #endif
 302 
 303 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 304     WebKitMediaKeys* webkitKeys() const { return m_webKitMediaKeys.get(); }
 305     void webkitSetMediaKeys(WebKitMediaKeys*);
 306 
 307     void keyAdded();
 308 #endif
 309 
 310 #if ENABLE(ENCRYPTED_MEDIA)
 311     MediaKeys* mediaKeys() const;
 312 
 313     void setMediaKeys(MediaKeys*, Ref&lt;DeferredPromise&gt;&amp;&amp;);
 314 #endif
 315 
 316 // controls
 317     WEBCORE_EXPORT bool controls() const;
 318     WEBCORE_EXPORT void setControls(bool);
 319     WEBCORE_EXPORT double volume() const override;
 320     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setVolume(double) override;
 321     WEBCORE_EXPORT bool muted() const override;
 322     WEBCORE_EXPORT void setMuted(bool) override;
 323 
 324     WEBCORE_EXPORT void togglePlayState();
 325     WEBCORE_EXPORT void beginScrubbing() override;
 326     WEBCORE_EXPORT void endScrubbing() override;
 327 
 328     void beginScanning(ScanDirection) override;
 329     void endScanning() override;
 330     double nextScanRate();
 331 
 332     WEBCORE_EXPORT bool canPlay() const override;
 333 
 334     double percentLoaded() const;
 335 
 336     bool shouldForceControlsDisplay() const;
 337 
 338 #if ENABLE(VIDEO_TRACK)
 339     ExceptionOr&lt;TextTrack&amp;&gt; addTextTrack(const String&amp; kind, const String&amp; label, const String&amp; language);
 340 
 341     AudioTrackList&amp; ensureAudioTracks();
 342     TextTrackList&amp; ensureTextTracks();
 343     VideoTrackList&amp; ensureVideoTracks();
 344     AudioTrackList* audioTracks() const { return m_audioTracks.get(); }
 345     TextTrackList* textTracks() const { return m_textTracks.get(); }
 346     VideoTrackList* videoTracks() const { return m_videoTracks.get(); }
 347 
<a name="11" id="anc11"></a><span class="line-modified"> 348     CueList currentlyActiveCues() const;</span>
 349 
 350     void addAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
 351     void addTextTrack(Ref&lt;TextTrack&gt;&amp;&amp;);
 352     void addVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp;);
 353     void removeAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
 354     void removeTextTrack(Ref&lt;TextTrack&gt;&amp;&amp;, bool scheduleEvent = true);
 355     void removeVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp;);
 356     void forgetResourceSpecificTracks();
 357     void closeCaptionTracksChanged();
 358     void notifyMediaPlayerOfTextTrackChanges();
 359 
 360     virtual void didAddTextTrack(HTMLTrackElement&amp;);
 361     virtual void didRemoveTextTrack(HTMLTrackElement&amp;);
 362 
 363     void mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp;) final;
 364     void mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp;) final;
 365     void mediaPlayerDidAddVideoTrack(VideoTrackPrivate&amp;) final;
 366     void mediaPlayerDidRemoveAudioTrack(AudioTrackPrivate&amp;) final;
 367     void mediaPlayerDidRemoveTextTrack(InbandTextTrackPrivate&amp;) final;
 368     void mediaPlayerDidRemoveVideoTrack(VideoTrackPrivate&amp;) final;
 369 
 370 #if ENABLE(AVF_CAPTIONS)
 371     Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources() final;
 372 #endif
 373 
 374     struct TrackGroup;
 375     void configureTextTrackGroupForLanguage(const TrackGroup&amp;) const;
 376     void scheduleConfigureTextTracks();
 377     void configureTextTracks();
 378     void configureTextTrackGroup(const TrackGroup&amp;);
 379 
 380     void setSelectedTextTrack(TextTrack*);
 381 
 382     bool textTracksAreReady() const;
 383     using HTMLMediaElementEnums::TextTrackVisibilityCheckType;
 384     void configureTextTrackDisplay(TextTrackVisibilityCheckType checkType = CheckTextTrackVisibility);
 385     void updateTextTrackDisplay();
 386 
 387     // AudioTrackClient
 388     void audioTrackEnabledChanged(AudioTrack&amp;) final;
 389 
 390     void textTrackReadyStateChanged(TextTrack*);
 391 
 392     // TextTrackClient
 393     void textTrackKindChanged(TextTrack&amp;) override;
 394     void textTrackModeChanged(TextTrack&amp;) override;
 395     void textTrackAddCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 396     void textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 397     void textTrackAddCue(TextTrack&amp;, TextTrackCue&amp;) override;
 398     void textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp;) override;
 399 
 400     // VideoTrackClient
 401     void videoTrackSelectedChanged(VideoTrack&amp;) final;
 402 
 403     bool requiresTextTrackRepresentation() const;
 404     void setTextTrackRepresentation(TextTrackRepresentation*);
 405     void syncTextTrackBounds();
<a name="12" id="anc12"></a><span class="line-added"> 406 </span>
<span class="line-added"> 407     void captionPreferencesChanged();</span>
 408 #endif
 409 
 410 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 411     void webkitShowPlaybackTargetPicker();
 412     bool addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;
 413     bool removeEventListener(const AtomString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;
 414 
 415     void wirelessRoutesAvailableDidChange() override;
 416     void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;) override;
 417     void setShouldPlayToPlaybackTarget(bool) override;
<a name="13" id="anc13"></a><span class="line-added"> 418     void playbackTargetPickerWasDismissed() override;</span>
 419 #endif
 420     bool isPlayingToWirelessPlaybackTarget() const override { return m_isPlayingToWirelessTarget; };
 421     void setIsPlayingToWirelessTarget(bool);
 422     bool webkitCurrentPlaybackTargetIsWireless() const;
 423 
 424     void setPlayingOnSecondScreen(bool value);
 425     bool isPlayingOnSecondScreen() const override { return m_playingOnSecondScreen; }
 426 
 427     bool isPlayingToExternalTarget() const { return isPlayingToWirelessPlaybackTarget() || isPlayingOnSecondScreen(); }
 428 
 429     // EventTarget function.
 430     // Both Node (via HTMLElement) and ActiveDOMObject define this method, which
 431     // causes an ambiguity error at compile time. This class&#39;s constructor
 432     // ensures that both implementations return document, so return the result
 433     // of one of them here.
 434     using HTMLElement::scriptExecutionContext;
 435 
 436     bool hasSingleSecurityOrigin() const { return !m_player || m_player-&gt;hasSingleSecurityOrigin(); }
 437     bool didPassCORSAccessCheck() const { return m_player &amp;&amp; m_player-&gt;didPassCORSAccessCheck(); }
 438     bool wouldTaintOrigin(const SecurityOrigin&amp; origin) const { return m_player &amp;&amp; m_player-&gt;wouldTaintOrigin(origin); }
 439 
 440     WEBCORE_EXPORT bool isFullscreen() const override;
 441     bool isStandardFullscreen() const;
 442     void toggleStandardFullscreenState();
 443 
 444     using MediaPlayerEnums::VideoFullscreenMode;
 445     VideoFullscreenMode fullscreenMode() const { return m_videoFullscreenMode; }
 446     virtual void fullscreenModeChanged(VideoFullscreenMode);
 447 
 448     void enterFullscreen(VideoFullscreenMode);
 449     void enterFullscreen() override;
 450     WEBCORE_EXPORT void exitFullscreen();
 451     WEBCORE_EXPORT void setVideoFullscreenStandby(bool);
 452 
 453     bool hasClosedCaptions() const override;
 454     bool closedCaptionsVisible() const override;
 455     void setClosedCaptionsVisible(bool) override;
 456 
 457     MediaControls* mediaControls() const;
 458 
 459     void sourceWasRemoved(HTMLSourceElement&amp;);
 460     void sourceWasAdded(HTMLSourceElement&amp;);
 461 
<a name="14" id="anc14"></a>

 462     // Media cache management.
 463     WEBCORE_EXPORT static void setMediaCacheDirectory(const String&amp;);
 464     WEBCORE_EXPORT static const String&amp; mediaCacheDirectory();
 465     WEBCORE_EXPORT static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;);
 466     WEBCORE_EXPORT static void clearMediaCache(const String&amp;, WallTime modifiedSince = { });
 467     WEBCORE_EXPORT static void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);
 468     static void resetMediaEngines();
 469 
 470     bool isPlaying() const { return m_playing; }
 471 
 472     bool hasPendingActivity() const override;
 473 
 474 #if ENABLE(WEB_AUDIO)
 475     MediaElementAudioSourceNode* audioSourceNode() { return m_audioSourceNode; }
 476     void setAudioSourceNode(MediaElementAudioSourceNode*);
 477 
 478     AudioSourceProvider* audioSourceProvider();
 479 #endif
 480 
 481     using HTMLMediaElementEnums::InvalidURLAction;
 482     bool isSafeToLoadURL(const URL&amp;, InvalidURLAction);
 483 
 484     const String&amp; mediaGroup() const;
 485     void setMediaGroup(const String&amp;);
 486 
 487     MediaController* controller() const;
 488     void setController(RefPtr&lt;MediaController&gt;&amp;&amp;);
 489 
 490     MediaController* controllerForBindings() const { return controller(); }
 491     void setControllerForBindings(MediaController*);
 492 
 493     void enteredOrExitedFullscreen() { configureMediaControls(); }
 494 
 495     unsigned long long fileSize() const;
 496 
<a name="15" id="anc15"></a><span class="line-modified"> 497     void mediaLoadingFailed(MediaPlayer::NetworkState);</span>
<span class="line-modified"> 498     void mediaLoadingFailedFatally(MediaPlayer::NetworkState);</span>
 499 
 500 #if ENABLE(MEDIA_SESSION)
 501     WEBCORE_EXPORT double playerVolume() const;
 502 
 503     const String&amp; kind() const { return m_kind; }
 504     void setKind(const String&amp; kind) { m_kind = kind; }
 505 
 506     MediaSession* session() const;
 507     void setSession(MediaSession*);
 508 
 509     void setShouldDuck(bool);
 510 
 511     static HTMLMediaElement* elementWithID(uint64_t);
 512     uint64_t elementID() const { return m_elementID; }
 513 #endif
 514 
 515     RefPtr&lt;VideoPlaybackQuality&gt; getVideoPlaybackQuality();
 516 
<a name="16" id="anc16"></a><span class="line-modified"> 517     MediaPlayer::Preload preloadValue() const { return m_preload; }</span>
 518     MediaElementSession&amp; mediaSession() const { return *m_mediaSession; }
 519 
 520 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 521     void pageScaleFactorChanged();
 522     void userInterfaceLayoutDirectionChanged();
 523     WEBCORE_EXPORT String getCurrentMediaControlsStatus();
 524 
 525     MediaControlsHost* mediaControlsHost() { return m_mediaControlsHost.get(); }
 526 #endif
 527 
 528     bool isDisablingSleep() const { return m_sleepDisabler.get(); }
 529 
 530     double maxBufferedTime() const;
 531 
 532     MediaProducer::MediaStateFlags mediaState() const override;
 533 
 534     void layoutSizeChanged();
 535     void visibilityDidChange();
 536 
 537     void allowsMediaDocumentInlinePlaybackChanged();
 538     void updateShouldPlay();
 539 
 540     RenderMedia* renderer() const;
 541 
 542     void resetPlaybackSessionState();
 543     bool isVisibleInViewport() const;
 544     bool hasEverNotifiedAboutPlaying() const;
 545     void setShouldDelayLoadEvent(bool);
 546 
 547     bool hasEverHadAudio() const { return m_hasEverHadAudio; }
 548     bool hasEverHadVideo() const { return m_hasEverHadVideo; }
 549 
 550     double playbackStartedTime() const { return m_playbackStartedTime; }
 551 
 552     bool isTemporarilyAllowingInlinePlaybackAfterFullscreen() const {return m_temporarilyAllowingInlinePlaybackAfterFullscreen; }
 553 
 554     void isVisibleInViewportChanged();
 555     void updateRateChangeRestrictions();
 556 
 557     WEBCORE_EXPORT const MediaResourceLoader* lastMediaResourceLoaderForTesting() const;
 558 
 559 #if ENABLE(MEDIA_STREAM)
<a name="17" id="anc17"></a><span class="line-modified"> 560     void mediaStreamCaptureStarted();</span>
 561     bool hasMediaStreamSrcObject() const { return m_mediaProvider &amp;&amp; WTF::holds_alternative&lt;RefPtr&lt;MediaStream&gt;&gt;(*m_mediaProvider); }
 562 #endif
 563 
 564     bool supportsSeeking() const override;
 565 
 566 #if !RELEASE_LOG_DISABLED
 567     const Logger&amp; logger() const final { return *m_logger.get(); }
 568     const void* logIdentifier() const final { return m_logIdentifier; }
 569     const char* logClassName() const final { return &quot;HTMLMediaElement&quot;; }
 570     WTFLogChannel&amp; logChannel() const final;
 571 #endif
 572 
 573     bool willLog(WTFLogLevel) const;
 574 
 575     bool isSuspended() const final;
 576 
 577     WEBCORE_EXPORT void didBecomeFullscreenElement() override;
 578     WEBCORE_EXPORT void willExitFullscreen();
 579 
<a name="18" id="anc18"></a><span class="line-added"> 580 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added"> 581     void scheduleEvent(Ref&lt;Event&gt;&amp;&amp;);</span>
<span class="line-added"> 582 #endif</span>
<span class="line-added"> 583 </span>
 584     enum class AutoplayEventPlaybackState { None, PreventedAutoplay, StartedWithUserGesture, StartedWithoutUserGesture };
 585 
<a name="19" id="anc19"></a><span class="line-added"> 586 #if ENABLE(WIRELESS_PLAYBACK_TARGET)</span>
<span class="line-added"> 587     RemotePlayback&amp; remote() { return m_remote; }</span>
<span class="line-added"> 588     void remoteHasAvailabilityCallbacksChanged();</span>
<span class="line-added"> 589 #endif</span>
<span class="line-added"> 590 </span>
<span class="line-added"> 591     void privateBrowsingStateDidChange(PAL::SessionID);</span>
<span class="line-added"> 592     void mediaVolumeDidChange();</span>
<span class="line-added"> 593     void applicationWillResignActive();</span>
<span class="line-added"> 594     void applicationDidBecomeActive();</span>
<span class="line-added"> 595 </span>
 596 protected:
 597     HTMLMediaElement(const QualifiedName&amp;, Document&amp;, bool createdByParser);
 598     virtual void finishInitialization();
 599     virtual ~HTMLMediaElement();
 600 
 601     void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) override;
 602     void finishParsingChildren() override;
 603     bool isURLAttribute(const Attribute&amp;) const override;
 604     void willAttachRenderers() override;
 605     void didAttachRenderers() override;
 606     void willDetachRenderers() override;
 607     void didDetachRenderers() override;
 608 
 609     void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument) override;
 610 
 611     enum DisplayMode { Unknown, None, Poster, PosterWaitingForVideo, Video };
 612     DisplayMode displayMode() const { return m_displayMode; }
 613     virtual void setDisplayMode(DisplayMode mode) { m_displayMode = mode; }
 614 
 615     bool isMediaElement() const final { return true; }
 616 
<a name="20" id="anc20"></a>





 617     RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) override;
 618 
 619 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 620     bool mediaControlsDependOnPageScaleFactor() const { return m_mediaControlsDependOnPageScaleFactor; }
 621     void setMediaControlsDependOnPageScaleFactor(bool);
 622     void updateMediaControlsAfterPresentationModeChange();
 623 #endif
 624 
<a name="21" id="anc21"></a><span class="line-modified"> 625     void scheduleEvent(const AtomString&amp;);</span>
 626 
 627 private:
 628     void createMediaPlayer();
 629 
 630     bool supportsFocus() const override;
 631     bool isMouseFocusable() const override;
 632     bool rendererIsNeeded(const RenderStyle&amp;) override;
 633     bool childShouldCreateRenderer(const Node&amp;) const override;
 634     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
 635     void didFinishInsertingNode() override;
 636     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
 637     void didRecalcStyle(Style::Change) override;
 638     bool isInteractiveContent() const override;
 639 
 640     void willBecomeFullscreenElement() override;
 641     void willStopBeingFullscreenElement() override;
 642 
 643     // ActiveDOMObject API.
 644     const char* activeDOMObjectName() const override;
<a name="22" id="anc22"></a>
 645     void suspend(ReasonForSuspension) override;
 646     void resume() override;
 647     void stop() override;
 648     void stopWithoutDestroyingMediaPlayer();
 649     void contextDestroyed() override;
 650 
<a name="23" id="anc23"></a><span class="line-modified"> 651     void visibilityStateChanged() final;</span>


 652 
 653     virtual void updateDisplayState() { }
 654 
<a name="24" id="anc24"></a><span class="line-modified"> 655     void setReadyState(MediaPlayer::ReadyState);</span>
<span class="line-modified"> 656     void setNetworkState(MediaPlayer::NetworkState);</span>
 657 
 658     double effectivePlaybackRate() const;
 659     double requestedPlaybackRate() const;
 660 
<a name="25" id="anc25"></a><span class="line-modified"> 661     void mediaPlayerNetworkStateChanged() final;</span>
<span class="line-modified"> 662     void mediaPlayerReadyStateChanged() final;</span>
<span class="line-modified"> 663     void mediaPlayerTimeChanged() final;</span>
<span class="line-modified"> 664     void mediaPlayerVolumeChanged() final;</span>
<span class="line-modified"> 665     void mediaPlayerMuteChanged() final;</span>
<span class="line-modified"> 666     void mediaPlayerDurationChanged() final;</span>
<span class="line-modified"> 667     void mediaPlayerRateChanged() final;</span>
<span class="line-modified"> 668     void mediaPlayerPlaybackStateChanged() final;</span>
<span class="line-modified"> 669     void mediaPlayerResourceNotSupported() final;</span>
<span class="line-modified"> 670     void mediaPlayerRepaint() final;</span>
<span class="line-modified"> 671     void mediaPlayerSizeChanged() final;</span>
<span class="line-modified"> 672     bool mediaPlayerRenderingCanBeAccelerated() final;</span>
<span class="line-modified"> 673     void mediaPlayerRenderingModeChanged() final;</span>
<span class="line-modified"> 674     bool mediaPlayerAcceleratedCompositingEnabled() final;</span>
<span class="line-modified"> 675     void mediaPlayerEngineUpdated() final;</span>

 676 
 677     void scheduleMediaEngineWasUpdated();
 678     void mediaEngineWasUpdated();
 679 
<a name="26" id="anc26"></a><span class="line-modified"> 680     void mediaPlayerFirstVideoFrameAvailable() final;</span>
<span class="line-modified"> 681     void mediaPlayerCharacteristicChanged() final;</span>
 682 
 683 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
<a name="27" id="anc27"></a><span class="line-modified"> 684     RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const final;</span>
<span class="line-modified"> 685     bool mediaPlayerKeyNeeded(Uint8Array*) final;</span>
<span class="line-modified"> 686     String mediaPlayerMediaKeysStorageDirectory() const final;</span>
 687 #endif
 688 
 689 #if ENABLE(ENCRYPTED_MEDIA)
 690     void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) final;
 691     void mediaPlayerWaitingForKeyChanged() final;
 692 
 693     void attemptToDecrypt();
 694     void attemptToResumePlaybackIfNecessary();
 695 
 696     // CDMClient
 697     void cdmClientAttemptToResumePlaybackIfNecessary() final;
 698 #endif
 699 
 700 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<a name="28" id="anc28"></a><span class="line-modified"> 701     void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(bool) final;</span>
 702     void enqueuePlaybackTargetAvailabilityChangedEvent();
 703 
 704     using EventTarget::dispatchEvent;
 705     void dispatchEvent(Event&amp;) override;
 706 #endif
 707 
 708 #if ENABLE(MEDIA_SESSION)
 709     void setSessionInternal(MediaSession&amp;);
 710 #endif
 711 
 712     String mediaPlayerReferrer() const override;
 713     String mediaPlayerUserAgent() const override;
 714 
 715     void mediaPlayerEnterFullscreen() override;
 716     void mediaPlayerExitFullscreen() override;
 717     bool mediaPlayerIsFullscreen() const override;
 718     bool mediaPlayerIsFullscreenPermitted() const override;
 719     bool mediaPlayerIsVideo() const override;
 720     LayoutRect mediaPlayerContentBoxRect() const override;
 721     float mediaPlayerContentsScale() const override;
<a name="29" id="anc29"></a>
 722     void mediaPlayerPause() override;
 723     void mediaPlayerPlay() override;
 724     bool mediaPlayerPlatformVolumeConfigurationRequired() const override;
<a name="30" id="anc30"></a>
 725     bool mediaPlayerIsLooping() const override;
 726     CachedResourceLoader* mediaPlayerCachedResourceLoader() override;
 727     RefPtr&lt;PlatformMediaResourceLoader&gt; mediaPlayerCreateResourceLoader() override;
 728     bool mediaPlayerShouldUsePersistentCache() const override;
 729     const String&amp; mediaPlayerMediaCacheDirectory() const override;
 730 
 731 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
<a name="31" id="anc31"></a><span class="line-modified"> 732     GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter() const override;</span>
 733 #endif
 734 
<a name="32" id="anc32"></a><span class="line-modified"> 735     void mediaPlayerActiveSourceBuffersChanged() override;</span>
 736 
<a name="33" id="anc33"></a>
 737     String sourceApplicationIdentifier() const override;
 738     String mediaPlayerSourceApplicationIdentifier() const override { return sourceApplicationIdentifier(); }
 739     Vector&lt;String&gt; mediaPlayerPreferredAudioCharacteristics() const override;
 740 
 741 #if PLATFORM(IOS_FAMILY)
 742     String mediaPlayerNetworkInterfaceName() const override;
 743     bool mediaPlayerGetRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const override;
 744 #endif
 745 
<a name="34" id="anc34"></a>
 746     void mediaPlayerEngineFailedToLoad() const final;
 747 
 748     double mediaPlayerRequestedPlaybackRate() const final;
 749     VideoFullscreenMode mediaPlayerFullscreenMode() const final { return fullscreenMode(); }
 750     bool mediaPlayerIsVideoFullscreenStandby() const final { return m_videoFullscreenStandby; }
 751     bool mediaPlayerShouldDisableSleep() const final { return shouldDisableSleep() == SleepType::Display; }
 752     bool mediaPlayerShouldCheckHardwareSupport() const final;
 753     const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const final;
 754 
 755 #if USE(GSTREAMER)
 756     void requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp;) final;
 757 #endif
 758 
 759     void pendingActionTimerFired();
 760     void progressEventTimerFired();
 761     void playbackProgressTimerFired();
 762     void scanTimerFired();
 763     void seekTask();
 764     void startPlaybackProgressTimer();
 765     void startProgressEventTimer();
 766     void stopPeriodicTimers();
 767     void cancelPendingTasks();
 768     void closeTaskQueues();
 769 
 770     void seek(const MediaTime&amp;);
 771     void seekInternal(const MediaTime&amp;);
 772     void seekWithTolerance(const MediaTime&amp;, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance, bool fromDOM);
 773     void finishSeek();
 774     void clearSeeking();
 775     void addPlayedRange(const MediaTime&amp; start, const MediaTime&amp; end);
 776 
 777     void scheduleTimeupdateEvent(bool periodicEvent);
 778     virtual void scheduleResizeEvent() { }
 779     virtual void scheduleResizeEventIfSizeChanged() { }
 780 
 781     void selectMediaResource();
 782     void loadResource(const URL&amp;, ContentType&amp;, const String&amp; keySystem);
 783     void scheduleNextSourceChild();
 784     void loadNextSourceChild();
 785     void userCancelledLoad();
 786     void clearMediaPlayer();
 787     bool havePotentialSourceChild();
 788     void noneSupported();
 789     void cancelPendingEventsAndCallbacks();
 790     void waitForSourceChange();
 791     void prepareToPlay();
 792 
 793     URL selectNextSourceChild(ContentType*, String* keySystem, InvalidURLAction);
 794 
 795 #if ENABLE(VIDEO_TRACK)
<a name="35" id="anc35"></a><span class="line-added"> 796     bool ignoreTrackDisplayUpdateRequests() const;</span>
<span class="line-added"> 797     void beginIgnoringTrackDisplayUpdateRequests();</span>
<span class="line-added"> 798     void endIgnoringTrackDisplayUpdateRequests();</span>
<span class="line-added"> 799 </span>
 800     void updateActiveTextTrackCues(const MediaTime&amp;);
 801     HTMLTrackElement* showingTrackWithSameKind(HTMLTrackElement*) const;
 802 
<a name="36" id="anc36"></a><span class="line-modified"> 803     enum ReconfigureMode { Immediately, AfterDelay };</span>



 804     void markCaptionAndSubtitleTracksAsUnconfigured(ReconfigureMode);
<a name="37" id="anc37"></a>
 805     CaptionUserPreferences::CaptionDisplayMode captionDisplayMode();
 806 #endif
 807 
 808     // These &quot;internal&quot; functions do not check user gesture restrictions.
 809     void playInternal();
 810     void pauseInternal();
 811 
 812     void prepareForLoad();
 813     void allowVideoRendering();
 814 
 815     bool processingMediaPlayerCallback() const { return m_processingMediaPlayerCallback &gt; 0; }
 816     void beginProcessingMediaPlayerCallback() { ++m_processingMediaPlayerCallback; }
 817     void endProcessingMediaPlayerCallback() { ASSERT(m_processingMediaPlayerCallback); --m_processingMediaPlayerCallback; }
 818 
 819     void scheduleUpdatePlayState();
 820     void updatePlayState();
 821 
 822     void updateVolume();
 823     void setPlaying(bool);
 824     bool potentiallyPlaying() const;
 825     bool endedPlayback() const;
 826     bool stoppedDueToErrors() const;
 827     bool pausedForUserInteraction() const;
 828     bool couldPlayIfEnoughData() const;
 829     void dispatchPlayPauseEventsIfNeedsQuirks();
 830     SuccessOr&lt;MediaPlaybackDenialReason&gt; canTransitionFromAutoplayToPlay() const;
 831 
 832     void setAutoplayEventPlaybackState(AutoplayEventPlaybackState);
 833     void userDidInterfereWithAutoplay();
 834     void handleAutoplayEvent(AutoplayEvent);
 835 
 836     MediaTime minTimeSeekable() const;
 837     MediaTime maxTimeSeekable() const;
 838 
 839     // Pauses playback without changing any states or generating events
 840     void setPausedInternal(bool);
<a name="38" id="anc38"></a><span class="line-added"> 841     void pauseAndUpdatePlayStateImmediately();</span>
 842 
 843     void setPlaybackRateInternal(double);
 844 
 845     void mediaCanStart(Document&amp;) final;
 846 
 847     void invalidateCachedTime() const;
 848     void refreshCachedTime() const;
 849 
 850     bool hasMediaControls() const;
 851     bool createMediaControls();
 852     void configureMediaControls();
 853 
 854     void prepareMediaFragmentURI();
 855     void applyMediaFragmentURI();
 856 
 857     void changeNetworkStateFromLoadingToIdle();
 858 
 859     void removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask = MediaElementSession::AllRestrictions);
 860 
 861     void updateMediaController();
 862     bool isBlocked() const;
 863     bool isBlockedOnMediaController() const;
 864     bool hasCurrentSrc() const override { return !m_currentSrc.isEmpty(); }
<a name="39" id="anc39"></a><span class="line-modified"> 865     bool isLiveStream() const override { return movieLoadType() == MovieLoadType::LiveStream; }</span>
 866 
 867     void updateSleepDisabling();
<a name="40" id="anc40"></a><span class="line-modified"> 868     enum class SleepType { None, Display, System };</span>




 869     SleepType shouldDisableSleep() const;
 870 
 871 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 872     void didAddUserAgentShadowRoot(ShadowRoot&amp;) override;
 873     DOMWrapperWorld&amp; ensureIsolatedWorld();
 874     bool ensureMediaControlsInjectedScript();
 875 #endif
 876 
 877     PlatformMediaSession::MediaType mediaType() const override;
 878     PlatformMediaSession::MediaType presentationType() const override;
 879     PlatformMediaSession::DisplayType displayType() const override;
 880     PlatformMediaSession::CharacteristicsFlags characteristics() const final;
 881 
 882     void suspendPlayback() override;
 883     void resumeAutoplaying() override;
 884     void mayResumePlayback(bool shouldResume) override;
 885     uint64_t mediaSessionUniqueIdentifier() const final;
 886     String mediaSessionTitle() const override;
 887     double mediaSessionDuration() const override { return duration(); }
 888     double mediaSessionCurrentTime() const override { return currentTime(); }
 889     bool canReceiveRemoteControlCommands() const override { return true; }
 890     void didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType, const PlatformMediaSession::RemoteCommandArgument*) override;
 891     bool shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType) const override;
 892     bool shouldOverrideBackgroundLoadingRestriction() const override;
 893     bool canProduceAudio() const final;
 894     bool processingUserGestureForMedia() const final;
 895     bool hasMediaStreamSource() const final;
 896     void processIsSuspendedChanged() final;
 897 
 898     void pageMutedStateDidChange() override;
 899 
 900 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 901     void hardwareMutedStateDidChange(AudioSession*) final;
 902 #endif
 903 
 904     bool effectiveMuted() const;
 905     double effectiveVolume() const;
 906 
 907     void registerWithDocument(Document&amp;);
 908     void unregisterWithDocument(Document&amp;);
 909 
 910     void updateCaptionContainer();
 911     void ensureMediaControlsShadowRoot();
 912 
<a name="41" id="anc41"></a><span class="line-modified"> 913     using JSSetupFunction = WTF::Function&lt;bool(JSDOMGlobalObject&amp;, JSC::JSGlobalObject&amp;, ScriptController&amp;, DOMWrapperWorld&amp;)&gt;;</span>
 914     bool setupAndCallJS(const JSSetupFunction&amp;);
 915 
 916 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 917     void prepareForDocumentSuspension() final;
 918     void resumeFromDocumentSuspension() final;
 919 
 920     void scheduleUpdateMediaState();
 921     void updateMediaState();
 922     bool hasPlaybackTargetAvailabilityListeners() const { return m_hasPlaybackTargetAvailabilityListeners; }
 923 #endif
 924 
 925     bool isVideoTooSmallForInlinePlayback();
 926     void updateShouldAutoplay();
 927 
 928     void pauseAfterDetachedTask();
 929     void updatePlaybackControlsManager();
 930     void schedulePlaybackControlsManagerUpdate();
 931     void playbackControlsManagerBehaviorRestrictionsTimerFired();
 932 
 933     void updateRenderer();
 934 
 935     void updatePageScaleFactorJSProperty();
 936     void updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
 937     void setControllerJSProperty(const char*, JSC::JSValue);
 938 
 939     void addBehaviorRestrictionsOnEndIfNecessary();
 940     void handleSeekToPlaybackPosition(double);
 941     void seekToPlaybackPositionEndedTimerFired();
 942 
<a name="42" id="anc42"></a>


 943     void setInActiveDocument(bool);
 944 
 945 #if !RELEASE_LOG_DISABLED
 946     const void* mediaPlayerLogIdentifier() final { return logIdentifier(); }
 947     const Logger&amp; mediaPlayerLogger() final { return logger(); }
 948 #endif
 949 
<a name="43" id="anc43"></a><span class="line-added"> 950     friend class TaskDispatcher&lt;HTMLMediaElement&gt;;</span>
<span class="line-added"> 951     void enqueueTaskForDispatcher(Function&lt;void()&gt;&amp;&amp;);</span>
<span class="line-added"> 952 </span>
 953     Timer m_progressEventTimer;
 954     Timer m_playbackProgressTimer;
 955     Timer m_scanTimer;
 956     Timer m_playbackControlsManagerBehaviorRestrictionsTimer;
 957     Timer m_seekToPlaybackPositionEndedTimer;
 958     DeferrableTask&lt;Timer&gt; m_configureTextTracksTask;
 959     DeferrableTask&lt;Timer&gt; m_checkPlaybackTargetCompatablityTask;
 960     DeferrableTask&lt;Timer&gt; m_updateMediaStateTask;
 961     DeferrableTask&lt;Timer&gt; m_mediaEngineUpdatedTask;
<a name="44" id="anc44"></a><span class="line-modified"> 962     DeferrableTask&lt;HTMLMediaElement&gt; m_updatePlayStateTask;</span>
 963     DeferrableTask&lt;Timer&gt; m_resumeTaskQueue;
 964     DeferrableTask&lt;Timer&gt; m_seekTaskQueue;
 965     DeferrableTask&lt;Timer&gt; m_playbackControlsManagerBehaviorRestrictionsQueue;
 966     GenericTaskQueue&lt;Timer&gt; m_promiseTaskQueue;
 967     GenericTaskQueue&lt;Timer&gt; m_pauseAfterDetachedTaskQueue;
 968     GenericTaskQueue&lt;Timer&gt; m_resourceSelectionTaskQueue;
 969     GenericTaskQueue&lt;Timer&gt; m_visibilityChangeTaskQueue;
 970     GenericTaskQueue&lt;Timer&gt; m_fullscreenTaskQueue;
 971     GenericTaskQueue&lt;Timer&gt; m_playbackTargetIsWirelessQueue;
 972     RefPtr&lt;TimeRanges&gt; m_playedTimeRanges;
<a name="45" id="anc45"></a><span class="line-modified"> 973     UniqueRef&lt;MainThreadGenericEventQueue&gt; m_asyncEventQueue;</span>
 974 #if PLATFORM(IOS_FAMILY)
 975     DeferrableTask&lt;Timer&gt; m_volumeRevertTaskQueue;
 976 #endif
 977 
 978     PlayPromiseVector m_pendingPlayPromises;
 979 
 980     double m_requestedPlaybackRate { 1 };
 981     double m_reportedPlaybackRate { 1 };
 982     double m_defaultPlaybackRate { 1 };
 983     bool m_webkitPreservesPitch { true };
 984     NetworkState m_networkState { NETWORK_EMPTY };
 985     ReadyState m_readyState { HAVE_NOTHING };
 986     ReadyState m_readyStateMaximum { HAVE_NOTHING };
 987     URL m_currentSrc;
 988 
 989     RefPtr&lt;MediaError&gt; m_error;
 990 
 991     struct PendingSeek {
 992         WTF_MAKE_STRUCT_FAST_ALLOCATED;
 993         PendingSeek(const MediaTime&amp; now, const MediaTime&amp; targetTime, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance)
 994             : now(now)
 995             , targetTime(targetTime)
 996             , negativeTolerance(negativeTolerance)
 997             , positiveTolerance(positiveTolerance)
 998         {
 999         }
1000         MediaTime now;
1001         MediaTime targetTime;
1002         MediaTime negativeTolerance;
1003         MediaTime positiveTolerance;
1004     };
1005     std::unique_ptr&lt;PendingSeek&gt; m_pendingSeek;
1006     SeekType m_pendingSeekType { NoSeek };
1007 
1008     double m_volume { 1 };
1009     bool m_volumeInitialized { false };
1010     MediaTime m_lastSeekTime;
1011 
1012     MonotonicTime m_previousProgressTime { MonotonicTime::infinity() };
1013     double m_playbackStartedTime { 0 };
1014 
1015     // The last time a timeupdate event was sent (based on monotonic clock).
1016     MonotonicTime m_clockTimeAtLastUpdateEvent;
1017 
1018     // The last time a timeupdate event was sent in movie time.
1019     MediaTime m_lastTimeUpdateEventMovieTime;
1020 
1021     // Loading state.
1022     enum LoadState { WaitingForSource, LoadingFromSrcAttr, LoadingFromSourceElement };
1023     LoadState m_loadState { WaitingForSource };
1024     RefPtr&lt;HTMLSourceElement&gt; m_currentSourceNode;
1025     RefPtr&lt;HTMLSourceElement&gt; m_nextChildNodeToConsider;
1026 
1027     VideoFullscreenMode m_videoFullscreenMode { VideoFullscreenModeNone };
1028     bool m_videoFullscreenStandby { false };
1029     bool m_preparedForInline;
1030     WTF::Function&lt;void()&gt; m_preparedForInlineCompletionHandler;
1031 
1032     bool m_temporarilyAllowingInlinePlaybackAfterFullscreen { false };
1033 
1034 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
1035     RetainPtr&lt;PlatformLayer&gt; m_videoFullscreenLayer;
1036     FloatRect m_videoFullscreenFrame;
<a name="46" id="anc46"></a><span class="line-modified">1037     MediaPlayer::VideoGravity m_videoFullscreenGravity { MediaPlayer::VideoGravity::ResizeAspect };</span>
1038 #endif
1039 
1040     RefPtr&lt;MediaPlayer&gt; m_player;
1041 
<a name="47" id="anc47"></a><span class="line-modified">1042     MediaPlayer::Preload m_preload { Preload::Auto };</span>
1043 
1044     DisplayMode m_displayMode { Unknown };
1045 
1046     // Counter incremented while processing a callback from the media player, so we can avoid
1047     // calling the media engine recursively.
1048     int m_processingMediaPlayerCallback { 0 };
1049 
1050 #if ENABLE(MEDIA_SESSION)
1051     String m_kind;
1052     RefPtr&lt;MediaSession&gt; m_session;
1053     bool m_shouldDuck { false };
1054     uint64_t m_elementID;
1055 #endif
1056 
1057 #if ENABLE(MEDIA_SOURCE)
1058     RefPtr&lt;MediaSource&gt; m_mediaSource;
1059     unsigned m_droppedVideoFrames { 0 };
1060 #endif
1061 
1062     mutable MediaTime m_cachedTime;
1063     mutable MonotonicTime m_clockTimeAtLastCachedTimeUpdate;
1064     mutable MonotonicTime m_minimumClockTimeToUpdateCachedTime;
1065 
1066     MediaTime m_fragmentStartTime;
1067     MediaTime m_fragmentEndTime;
1068 
1069     using PendingActionFlags = unsigned;
1070     PendingActionFlags m_pendingActionFlags { 0 };
1071 
1072     enum ActionAfterScanType { Nothing, Play, Pause };
1073     ActionAfterScanType m_actionAfterScan { Nothing };
1074 
1075     enum ScanType { Seek, Scan };
1076     ScanType m_scanType { Scan };
1077     ScanDirection m_scanDirection { Forward };
1078 
1079     BufferingPolicy m_bufferingPolicy { BufferingPolicy::Default };
1080 
1081     bool m_firstTimePlaying : 1;
1082     bool m_playing : 1;
1083     bool m_isWaitingUntilMediaCanStart : 1;
1084     bool m_shouldDelayLoadEvent : 1;
1085     bool m_haveFiredLoadedData : 1;
1086     bool m_inActiveDocument : 1;
1087     bool m_autoplaying : 1;
1088     bool m_muted : 1;
1089     bool m_explicitlyMuted : 1;
1090     bool m_initiallyMuted : 1;
1091     bool m_paused : 1;
1092     bool m_seeking : 1;
1093     bool m_seekRequested : 1;
1094 
1095     // data has not been loaded since sending a &quot;stalled&quot; event
1096     bool m_sentStalledEvent : 1;
1097 
1098     // time has not changed since sending an &quot;ended&quot; event
1099     bool m_sentEndEvent : 1;
1100 
1101     bool m_pausedInternal : 1;
1102 
1103     bool m_closedCaptionsVisible : 1;
1104     bool m_webkitLegacyClosedCaptionOverride : 1;
1105     bool m_completelyLoaded : 1;
1106     bool m_havePreparedToPlay : 1;
1107     bool m_parsingInProgress : 1;
1108     bool m_elementIsHidden : 1;
1109     bool m_elementWasRemovedFromDOM : 1;
1110     bool m_creatingControls : 1;
1111     bool m_receivedLayoutSizeChanged : 1;
1112     bool m_hasEverNotifiedAboutPlaying : 1;
1113 
1114     bool m_hasEverHadAudio : 1;
1115     bool m_hasEverHadVideo : 1;
1116 
1117 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1118     bool m_mediaControlsDependOnPageScaleFactor : 1;
1119     bool m_haveSetUpCaptionContainer : 1;
1120 #endif
1121 
1122     bool m_isScrubbingRemotely : 1;
1123     bool m_waitingToEnterFullscreen : 1;
1124 
1125 #if ENABLE(VIDEO_TRACK)
1126     bool m_tracksAreReady : 1;
1127     bool m_haveVisibleTextTrack : 1;
1128     bool m_processingPreferenceChange : 1;
1129 
1130     AutoplayEventPlaybackState m_autoplayEventPlaybackState { AutoplayEventPlaybackState::None };
1131 
1132     String m_subtitleTrackLanguage;
1133     MediaTime m_lastTextTrackUpdateTime { -1, 1 };
1134 
1135     Optional&lt;CaptionUserPreferences::CaptionDisplayMode&gt; m_captionDisplayMode;
1136 
1137     RefPtr&lt;AudioTrackList&gt; m_audioTracks;
1138     RefPtr&lt;TextTrackList&gt; m_textTracks;
1139     RefPtr&lt;VideoTrackList&gt; m_videoTracks;
1140     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; m_textTracksWhenResourceSelectionBegan;
1141 
<a name="48" id="anc48"></a><span class="line-modified">1142     struct CueData;</span>
<span class="line-added">1143     std::unique_ptr&lt;CueData&gt; m_cueData;</span>
1144 
<a name="49" id="anc49"></a>
1145     int m_ignoreTrackDisplayUpdate { 0 };
1146 
1147     bool m_requireCaptionPreferencesChangedCallbacks { false };
1148 #endif
1149 
1150 #if ENABLE(WEB_AUDIO)
1151     // This is a weak reference, since m_audioSourceNode holds a reference to us.
1152     // The value is set just after the MediaElementAudioSourceNode is created.
1153     // The value is cleared in MediaElementAudioSourceNode::~MediaElementAudioSourceNode().
1154     MediaElementAudioSourceNode* m_audioSourceNode { nullptr };
1155 #endif
1156 
1157     String m_mediaGroup;
1158     friend class MediaController;
1159     RefPtr&lt;MediaController&gt; m_mediaController;
1160 
1161     std::unique_ptr&lt;PAL::SleepDisabler&gt; m_sleepDisabler;
1162 
1163     WeakPtr&lt;const MediaResourceLoader&gt; m_lastMediaResourceLoaderForTesting;
1164 
1165     friend class TrackDisplayUpdateScope;
1166 
1167     RefPtr&lt;Blob&gt; m_blob;
1168     MediaProvider m_mediaProvider;
1169 
1170 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
1171     RefPtr&lt;WebKitMediaKeys&gt; m_webKitMediaKeys;
1172 #endif
<a name="50" id="anc50"></a><span class="line-added">1173 </span>
1174 #if ENABLE(ENCRYPTED_MEDIA)
1175     RefPtr&lt;MediaKeys&gt; m_mediaKeys;
1176     bool m_attachingMediaKeys { false };
1177     bool m_playbackBlockedWaitingForKey { false };
1178     GenericTaskQueue&lt;Timer&gt; m_encryptedMediaQueue;
1179 #endif
1180 
<a name="51" id="anc51"></a><span class="line-added">1181 #if ENABLE(WIRELESS_PLAYBACK_TARGET)</span>
<span class="line-added">1182     Ref&lt;RemotePlayback&gt; m_remote;</span>
<span class="line-added">1183 #endif</span>
<span class="line-added">1184 </span>
1185     std::unique_ptr&lt;MediaElementSession&gt; m_mediaSession;
1186     size_t m_reportedExtraMemoryCost { 0 };
1187 
1188 #if !RELEASE_LOG_DISABLED
1189     RefPtr&lt;Logger&gt; m_logger;
1190     const void* m_logIdentifier;
1191 #endif
1192 
1193 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1194     friend class MediaControlsHost;
1195     RefPtr&lt;MediaControlsHost&gt; m_mediaControlsHost;
1196     RefPtr&lt;DOMWrapperWorld&gt; m_isolatedWorld;
1197 #endif
1198 
1199 #if ENABLE(MEDIA_STREAM)
1200     RefPtr&lt;MediaStream&gt; m_mediaStreamSrcObject;
1201     bool m_settingMediaStreamSrcObject { false };
1202 #endif
1203 
1204 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1205     MediaProducer::MediaStateFlags m_mediaState { MediaProducer::IsNotPlaying };
1206     bool m_hasPlaybackTargetAvailabilityListeners { false };
1207     bool m_failedToPlayToWirelessTarget { false };
1208 #endif
1209 
1210     bool m_isPlayingToWirelessTarget { false };
1211     bool m_playingOnSecondScreen { false };
1212     bool m_removedBehaviorRestrictionsAfterFirstUserGesture { false };
1213 };
1214 
1215 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState);
1216 
1217 } // namespace WebCore
1218 
1219 namespace WTF {
1220 
1221 template&lt;&gt; struct LogArgument&lt;WebCore::HTMLMediaElement::AutoplayEventPlaybackState&gt; {
1222     static String toString(WebCore::HTMLMediaElement::AutoplayEventPlaybackState reason) { return convertEnumerationToString(reason); }
1223 };
1224 
<a name="52" id="anc52"></a>
















1225 } // namespace WTF
1226 
1227 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::HTMLMediaElement)
1228     static bool isType(const WebCore::Element&amp; element) { return element.isMediaElement(); }
1229     static bool isType(const WebCore::Node&amp; node) { return is&lt;WebCore::Element&gt;(node) &amp;&amp; isType(downcast&lt;WebCore::Element&gt;(node)); }
1230 SPECIALIZE_TYPE_TRAITS_END()
1231 
1232 #endif
<a name="53" id="anc53"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="53" type="hidden" />
</body>
</html>
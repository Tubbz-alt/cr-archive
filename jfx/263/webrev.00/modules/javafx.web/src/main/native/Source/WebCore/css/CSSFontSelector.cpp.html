<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/CSSFontSelector.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2007, 2008, 2011, 2013 Apple Inc. All rights reserved.
  3  *           (C) 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;CSSFontSelector.h&quot;
 29 
 30 #include &quot;CachedFont.h&quot;
 31 #include &quot;CSSFontFace.h&quot;
 32 #include &quot;CSSFontFaceSource.h&quot;
 33 #include &quot;CSSFontFamily.h&quot;
 34 #include &quot;CSSPrimitiveValue.h&quot;
 35 #include &quot;CSSPropertyNames.h&quot;
 36 #include &quot;CSSSegmentedFontFace.h&quot;
 37 #include &quot;CSSValueKeywords.h&quot;
 38 #include &quot;CSSValueList.h&quot;
 39 #include &quot;CachedResourceLoader.h&quot;
 40 #include &quot;Document.h&quot;
 41 #include &quot;Font.h&quot;
 42 #include &quot;FontCache.h&quot;
 43 #include &quot;FontFace.h&quot;
 44 #include &quot;FontFaceSet.h&quot;
 45 #include &quot;FontSelectorClient.h&quot;
 46 #include &quot;Frame.h&quot;
 47 #include &quot;FrameLoader.h&quot;
 48 #include &quot;Logging.h&quot;
 49 #include &quot;ResourceLoadObserver.h&quot;
 50 #include &quot;RuntimeEnabledFeatures.h&quot;
 51 #include &quot;Settings.h&quot;
 52 #include &quot;StyleProperties.h&quot;
 53 #include &quot;StyleResolver.h&quot;
 54 #include &quot;StyleRule.h&quot;
 55 #include &quot;WebKitFontFamilyNames.h&quot;
 56 #include &lt;wtf/Ref.h&gt;
 57 #include &lt;wtf/SetForScope.h&gt;
 58 #include &lt;wtf/text/AtomString.h&gt;
 59 
 60 namespace WebCore {
 61 
 62 static unsigned fontSelectorId;
 63 
 64 CSSFontSelector::CSSFontSelector(Document&amp; document)
 65     : m_document(makeWeakPtr(document))
 66     , m_cssFontFaceSet(CSSFontFaceSet::create(this))
 67     , m_beginLoadingTimer(*this, &amp;CSSFontSelector::beginLoadTimerFired)
 68     , m_uniqueId(++fontSelectorId)
 69     , m_version(0)
 70 {
 71     ASSERT(m_document);
 72     FontCache::singleton().addClient(*this);
 73     m_cssFontFaceSet-&gt;addClient(*this);
 74     LOG(Fonts, &quot;CSSFontSelector %p ctor&quot;, this);
 75 }
 76 
 77 CSSFontSelector::~CSSFontSelector()
 78 {
 79     LOG(Fonts, &quot;CSSFontSelector %p dtor&quot;, this);
 80 
 81     clearDocument();
 82     m_cssFontFaceSet-&gt;removeClient(*this);
 83     FontCache::singleton().removeClient(*this);
 84 }
 85 
 86 FontFaceSet* CSSFontSelector::fontFaceSetIfExists()
 87 {
 88     return m_fontFaceSet.get();
 89 }
 90 
 91 FontFaceSet&amp; CSSFontSelector::fontFaceSet()
 92 {
 93     if (!m_fontFaceSet) {
 94         ASSERT(m_document);
 95         m_fontFaceSet = FontFaceSet::create(*m_document, m_cssFontFaceSet.get());
 96     }
 97 
 98     return *m_fontFaceSet;
 99 }
100 
101 bool CSSFontSelector::isEmpty() const
102 {
103     return !m_cssFontFaceSet-&gt;faceCount();
104 }
105 
106 void CSSFontSelector::emptyCaches()
107 {
108     m_cssFontFaceSet-&gt;emptyCaches();
109 }
110 
111 void CSSFontSelector::buildStarted()
112 {
113     m_buildIsUnderway = true;
114     m_cssFontFaceSet-&gt;purge();
115     ++m_version;
116 
117     ASSERT(m_cssConnectionsPossiblyToRemove.isEmpty());
118     ASSERT(m_cssConnectionsEncounteredDuringBuild.isEmpty());
119     ASSERT(m_stagingArea.isEmpty());
120     for (size_t i = 0; i &lt; m_cssFontFaceSet-&gt;faceCount(); ++i) {
121         CSSFontFace&amp; face = m_cssFontFaceSet.get()[i];
122         if (face.cssConnection())
123             m_cssConnectionsPossiblyToRemove.add(&amp;face);
124     }
125 }
126 
127 void CSSFontSelector::buildCompleted()
128 {
129     if (!m_buildIsUnderway)
130         return;
131 
132     m_buildIsUnderway = false;
133 
134     // Some font faces weren&#39;t re-added during the build process.
135     for (auto&amp; face : m_cssConnectionsPossiblyToRemove) {
136         auto* connection = face-&gt;cssConnection();
137         ASSERT(connection);
138         if (!m_cssConnectionsEncounteredDuringBuild.contains(connection))
139             m_cssFontFaceSet-&gt;remove(*face);
140     }
141 
142     for (auto&amp; item : m_stagingArea)
143         addFontFaceRule(item.styleRuleFontFace, item.isInitiatingElementInUserAgentShadowTree);
144     m_cssConnectionsEncounteredDuringBuild.clear();
145     m_stagingArea.clear();
146     m_cssConnectionsPossiblyToRemove.clear();
147 }
148 
149 void CSSFontSelector::addFontFaceRule(StyleRuleFontFace&amp; fontFaceRule, bool isInitiatingElementInUserAgentShadowTree)
150 {
151     if (m_buildIsUnderway) {
152         m_cssConnectionsEncounteredDuringBuild.add(&amp;fontFaceRule);
153         m_stagingArea.append({fontFaceRule, isInitiatingElementInUserAgentShadowTree});
154         return;
155     }
156 
157     const StyleProperties&amp; style = fontFaceRule.properties();
158     RefPtr&lt;CSSValue&gt; fontFamily = style.getPropertyCSSValue(CSSPropertyFontFamily);
159     RefPtr&lt;CSSValue&gt; fontStyle = style.getPropertyCSSValue(CSSPropertyFontStyle);
160     RefPtr&lt;CSSValue&gt; fontWeight = style.getPropertyCSSValue(CSSPropertyFontWeight);
161     RefPtr&lt;CSSValue&gt; fontStretch = style.getPropertyCSSValue(CSSPropertyFontStretch);
162     RefPtr&lt;CSSValue&gt; src = style.getPropertyCSSValue(CSSPropertySrc);
163     RefPtr&lt;CSSValue&gt; unicodeRange = style.getPropertyCSSValue(CSSPropertyUnicodeRange);
164     RefPtr&lt;CSSValue&gt; featureSettings = style.getPropertyCSSValue(CSSPropertyFontFeatureSettings);
165     RefPtr&lt;CSSValue&gt; loadingBehavior = style.getPropertyCSSValue(CSSPropertyFontDisplay);
166     if (!is&lt;CSSValueList&gt;(fontFamily) || !is&lt;CSSValueList&gt;(src) || (unicodeRange &amp;&amp; !is&lt;CSSValueList&gt;(*unicodeRange)))
167         return;
168 
169     CSSValueList&amp; familyList = downcast&lt;CSSValueList&gt;(*fontFamily);
170     if (!familyList.length())
171         return;
172 
173     CSSValueList* rangeList = downcast&lt;CSSValueList&gt;(unicodeRange.get());
174 
175     CSSValueList&amp; srcList = downcast&lt;CSSValueList&gt;(*src);
176     if (!srcList.length())
177         return;
178 
179     SetForScope&lt;bool&gt; creatingFont(m_creatingFont, true);
180     Ref&lt;CSSFontFace&gt; fontFace = CSSFontFace::create(this, &amp;fontFaceRule);
181 
182     if (!fontFace-&gt;setFamilies(*fontFamily))
183         return;
184     if (fontStyle)
185         fontFace-&gt;setStyle(*fontStyle);
186     if (fontWeight)
187         fontFace-&gt;setWeight(*fontWeight);
188     if (fontStretch)
189         fontFace-&gt;setStretch(*fontStretch);
190     if (rangeList &amp;&amp; !fontFace-&gt;setUnicodeRange(*rangeList))
191         return;
192     if (featureSettings)
193         fontFace-&gt;setFeatureSettings(*featureSettings);
194     if (loadingBehavior)
195         fontFace-&gt;setLoadingBehavior(*loadingBehavior);
196 
197     CSSFontFace::appendSources(fontFace, srcList, m_document.get(), isInitiatingElementInUserAgentShadowTree);
198     if (fontFace-&gt;computeFailureState())
199         return;
200 
201     if (RefPtr&lt;CSSFontFace&gt; existingFace = m_cssFontFaceSet-&gt;lookUpByCSSConnection(fontFaceRule)) {
202         // This adoption is fairly subtle. Script can trigger a purge of m_cssFontFaceSet at any time,
203         // which will cause us to just rely on the memory cache to retain the bytes of the file the next
204         // time we build up the CSSFontFaceSet. However, when the CSS Font Loading API is involved,
205         // the FontFace and FontFaceSet objects need to retain state. We create the new CSSFontFace object
206         // while the old one is still in scope so that the memory cache will be forced to retain the bytes
207         // of the resource. This means that the CachedFont will temporarily have two clients (until the
208         // old CSSFontFace goes out of scope, which should happen at the end of this &quot;if&quot; block). Because
209         // the CSSFontFaceSource objects will inspect their CachedFonts, the new CSSFontFace is smart enough
210         // to enter the correct state() during the next pump(). This approach of making a new CSSFontFace is
211         // simpler than computing and applying a diff of the StyleProperties.
212         m_cssFontFaceSet-&gt;remove(*existingFace);
213         if (auto* existingWrapper = existingFace-&gt;existingWrapper())
214             existingWrapper-&gt;adopt(fontFace.get());
215     }
216 
217     m_cssFontFaceSet-&gt;add(fontFace.get());
218     ++m_version;
219 }
220 
221 void CSSFontSelector::registerForInvalidationCallbacks(FontSelectorClient&amp; client)
222 {
223     m_clients.add(&amp;client);
224 }
225 
226 void CSSFontSelector::unregisterForInvalidationCallbacks(FontSelectorClient&amp; client)
227 {
228     m_clients.remove(&amp;client);
229 }
230 
231 void CSSFontSelector::dispatchInvalidationCallbacks()
232 {
233     ++m_version;
234 
235     for (auto&amp; client : copyToVector(m_clients))
236         client-&gt;fontsNeedUpdate(*this);
237 }
238 
239 void CSSFontSelector::opportunisticallyStartFontDataURLLoading(const FontCascadeDescription&amp; description, const AtomString&amp; familyName)
240 {
241     const auto&amp; segmentedFontFace = m_cssFontFaceSet-&gt;fontFace(description.fontSelectionRequest(), familyName);
242     if (!segmentedFontFace)
243         return;
244     for (auto&amp; face : segmentedFontFace-&gt;constituentFaces())
245         face-&gt;opportunisticallyStartFontDataURLLoading(*this);
246 }
247 
248 void CSSFontSelector::fontLoaded()
249 {
250     dispatchInvalidationCallbacks();
251 }
252 
253 void CSSFontSelector::fontModified()
254 {
255     if (!m_creatingFont &amp;&amp; !m_buildIsUnderway)
256         dispatchInvalidationCallbacks();
257 }
258 
259 void CSSFontSelector::fontCacheInvalidated()
260 {
261     dispatchInvalidationCallbacks();
262 }
263 
264 static Optional&lt;AtomString&gt; resolveGenericFamily(Document* document, const FontDescription&amp; fontDescription, const AtomString&amp; familyName)
265 {
266     auto platformResult = FontDescription::platformResolveGenericFamily(fontDescription.script(), fontDescription.locale(), familyName);
267     if (!platformResult.isNull())
268         return platformResult;
269 
270     if (!document)
271         return WTF::nullopt;
272 
273     const Settings&amp; settings = document-&gt;settings();
274 
275     UScriptCode script = fontDescription.script();
276     if (familyName == serifFamily)
277         return settings.serifFontFamily(script);
278     if (familyName == sansSerifFamily)
279         return settings.sansSerifFontFamily(script);
280     if (familyName == cursiveFamily)
281         return settings.cursiveFontFamily(script);
282     if (familyName == fantasyFamily)
283         return settings.fantasyFontFamily(script);
284     if (familyName == monospaceFamily)
285         return settings.fixedFontFamily(script);
286     if (familyName == pictographFamily)
287         return settings.pictographFontFamily(script);
288     if (familyName == standardFamily)
289         return settings.standardFontFamily(script);
290 
291     return WTF::nullopt;
292 }
293 
294 FontRanges CSSFontSelector::fontRangesForFamily(const FontDescription&amp; fontDescription, const AtomString&amp; familyName)
295 {
296     // If this ASSERT() fires, it usually means you forgot a document.updateStyleIfNeeded() somewhere.
297     ASSERT(!m_buildIsUnderway || m_computingRootStyleFontCount);
298 
299     // FIXME: The spec (and Firefox) says user specified generic families (sans-serif etc.) should be resolved before the @font-face lookup too.
300     bool resolveGenericFamilyFirst = familyName == standardFamily;
301 
302     AtomString familyForLookup = familyName;
303     Optional&lt;FontDescription&gt; overrideFontDescription;
304     const FontDescription* fontDescriptionForLookup = &amp;fontDescription;
305     auto resolveGenericFamily = [&amp;]() {
306         if (auto genericFamilyOptional = WebCore::resolveGenericFamily(m_document.get(), fontDescription, familyName))
307             familyForLookup = *genericFamilyOptional;
308     };
309 
310     if (resolveGenericFamilyFirst)
311         resolveGenericFamily();
312     auto* face = m_cssFontFaceSet-&gt;fontFace(fontDescriptionForLookup-&gt;fontSelectionRequest(), familyForLookup);
313     if (face) {
314         if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled()) {
315             if (m_document)
316                 ResourceLoadObserver::shared().logFontLoad(*m_document, familyForLookup.string(), true);
317         }
318         return face-&gt;fontRanges(*fontDescriptionForLookup);
319     }
320 
321     if (!resolveGenericFamilyFirst)
322         resolveGenericFamily();
323     auto font = FontCache::singleton().fontForFamily(*fontDescriptionForLookup, familyForLookup);
324     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled()) {
325         if (m_document)
326             ResourceLoadObserver::shared().logFontLoad(*m_document, familyForLookup.string(), !!font);
327     }
328     return FontRanges { WTFMove(font) };
329 }
330 
331 void CSSFontSelector::clearDocument()
332 {
333     if (!m_document) {
334         ASSERT(!m_beginLoadingTimer.isActive());
335         ASSERT(m_fontsToBeginLoading.isEmpty());
336         return;
337     }
338 
339     m_beginLoadingTimer.stop();
340 
341     CachedResourceLoader&amp; cachedResourceLoader = m_document-&gt;cachedResourceLoader();
342     for (auto&amp; fontHandle : m_fontsToBeginLoading) {
343         // Balances incrementRequestCount() in beginLoadingFontSoon().
344         cachedResourceLoader.decrementRequestCount(*fontHandle);
345     }
346     m_fontsToBeginLoading.clear();
347 
348     m_document = nullptr;
349 
350     m_cssFontFaceSet-&gt;clear();
351     m_clients.clear();
352 }
353 
354 void CSSFontSelector::beginLoadingFontSoon(CachedFont&amp; font)
355 {
356     if (!m_document)
357         return;
358 
359     m_fontsToBeginLoading.append(&amp;font);
360     // Increment the request count now, in order to prevent didFinishLoad from being dispatched
361     // after this font has been requested but before it began loading. Balanced by
362     // decrementRequestCount() in beginLoadTimerFired() and in clearDocument().
363     m_document-&gt;cachedResourceLoader().incrementRequestCount(font);
364 
365     m_beginLoadingTimer.startOneShot(0_s);
366 }
367 
368 void CSSFontSelector::beginLoadTimerFired()
369 {
370     Vector&lt;CachedResourceHandle&lt;CachedFont&gt;&gt; fontsToBeginLoading;
371     fontsToBeginLoading.swap(m_fontsToBeginLoading);
372 
373     // CSSFontSelector could get deleted via beginLoadIfNeeded() or loadDone() unless protected.
374     Ref&lt;CSSFontSelector&gt; protectedThis(*this);
375 
376     CachedResourceLoader&amp; cachedResourceLoader = m_document-&gt;cachedResourceLoader();
377     for (auto&amp; fontHandle : fontsToBeginLoading) {
378         fontHandle-&gt;beginLoadIfNeeded(cachedResourceLoader);
379         // Balances incrementRequestCount() in beginLoadingFontSoon().
380         cachedResourceLoader.decrementRequestCount(*fontHandle);
381     }
382     // FIXME: Use SubresourceLoader instead.
383     // Call FrameLoader::loadDone before FrameLoader::subresourceLoadDone to match the order in SubresourceLoader::notifyDone.
384     cachedResourceLoader.loadDone(LoadCompletionType::Finish);
385     // Ensure that if the request count reaches zero, the frame loader will know about it.
386     // New font loads may be triggered by layout after the document load is complete but before we have dispatched
387     // didFinishLoading for the frame. Make sure the delegate is always dispatched by checking explicitly.
388     if (m_document &amp;&amp; m_document-&gt;frame())
389         m_document-&gt;frame()-&gt;loader().checkLoadComplete();
390 }
391 
392 
393 size_t CSSFontSelector::fallbackFontCount()
394 {
395     if (!m_document)
396         return 0;
397 
398     return m_document-&gt;settings().fontFallbackPrefersPictographs() ? 1 : 0;
399 }
400 
401 RefPtr&lt;Font&gt; CSSFontSelector::fallbackFontAt(const FontDescription&amp; fontDescription, size_t index)
402 {
403     ASSERT_UNUSED(index, !index);
404 
405     if (!m_document)
406         return nullptr;
407 
408     if (!m_document-&gt;settings().fontFallbackPrefersPictographs())
409         return nullptr;
410     auto&amp; pictographFontFamily = m_document-&gt;settings().pictographFontFamily();
411     auto font = FontCache::singleton().fontForFamily(fontDescription, pictographFontFamily);
412     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
413         ResourceLoadObserver::shared().logFontLoad(*m_document, pictographFontFamily.string(), !!font);
414 
415     return font;
416 }
417 
418 }
    </pre>
  </body>
</html>
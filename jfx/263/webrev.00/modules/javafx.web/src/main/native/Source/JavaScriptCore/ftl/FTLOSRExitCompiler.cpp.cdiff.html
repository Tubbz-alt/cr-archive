<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOSRExitCompiler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLOSRExit.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOSRExitCompiler.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOSRExitCompiler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,23 ***</span>
  #include &quot;config.h&quot;
  #include &quot;FTLOSRExitCompiler.h&quot;
  
  #if ENABLE(FTL_JIT)
  
  #include &quot;DFGOSRExitCompilerCommon.h&quot;
<span class="line-removed">- #include &quot;DFGOSRExitPreparation.h&quot;</span>
  #include &quot;FTLExitArgumentForOperand.h&quot;
  #include &quot;FTLJITCode.h&quot;
  #include &quot;FTLLocation.h&quot;
  #include &quot;FTLOSRExit.h&quot;
  #include &quot;FTLOperations.h&quot;
  #include &quot;FTLState.h&quot;
  #include &quot;FTLSaveRestore.h&quot;
  #include &quot;LinkBuffer.h&quot;
  #include &quot;MaxFrameExtentForSlowPathCall.h&quot;
  #include &quot;OperandsInlines.h&quot;
<span class="line-modified">! #include &quot;JSCInlines.h&quot;</span>
  
  namespace JSC { namespace FTL {
  
  using namespace DFG;
  
<span class="line-new-header">--- 26,25 ---</span>
  #include &quot;config.h&quot;
  #include &quot;FTLOSRExitCompiler.h&quot;
  
  #if ENABLE(FTL_JIT)
  
<span class="line-added">+ #include &quot;BytecodeStructs.h&quot;</span>
<span class="line-added">+ #include &quot;CheckpointOSRExitSideState.h&quot;</span>
  #include &quot;DFGOSRExitCompilerCommon.h&quot;
  #include &quot;FTLExitArgumentForOperand.h&quot;
  #include &quot;FTLJITCode.h&quot;
  #include &quot;FTLLocation.h&quot;
  #include &quot;FTLOSRExit.h&quot;
  #include &quot;FTLOperations.h&quot;
  #include &quot;FTLState.h&quot;
  #include &quot;FTLSaveRestore.h&quot;
<span class="line-added">+ #include &quot;JSCInlines.h&quot;</span>
  #include &quot;LinkBuffer.h&quot;
  #include &quot;MaxFrameExtentForSlowPathCall.h&quot;
  #include &quot;OperandsInlines.h&quot;
<span class="line-modified">! #include &quot;ProbeContext.h&quot;</span>
  
  namespace JSC { namespace FTL {
  
  using namespace DFG;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,11 ***</span>
      DataFormat format, AssemblyHelpers&amp; jit, GPRReg value, GPRReg scratch1, GPRReg scratch2)
  {
      switch (format) {
      case DataFormatInt32: {
          jit.zeroExtend32ToPtr(value, value);
<span class="line-modified">!         jit.or64(GPRInfo::tagTypeNumberRegister, value);</span>
          break;
      }
  
      case DataFormatInt52: {
          jit.rshift64(AssemblyHelpers::TrustedImm32(JSValue::int52ShiftAmount), value);
<span class="line-new-header">--- 52,11 ---</span>
      DataFormat format, AssemblyHelpers&amp; jit, GPRReg value, GPRReg scratch1, GPRReg scratch2)
  {
      switch (format) {
      case DataFormatInt32: {
          jit.zeroExtend32ToPtr(value, value);
<span class="line-modified">!         jit.or64(GPRInfo::numberTagRegister, value);</span>
          break;
      }
  
      case DataFormatInt52: {
          jit.rshift64(AssemblyHelpers::TrustedImm32(JSValue::int52ShiftAmount), value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,11 ***</span>
          break;
      }
  
      case DataFormatBoolean: {
          jit.zeroExtend32ToPtr(value, value);
<span class="line-modified">!         jit.or32(MacroAssembler::TrustedImm32(ValueFalse), value);</span>
          break;
      }
  
      case DataFormatJS: {
          // Done already!
<span class="line-new-header">--- 73,11 ---</span>
          break;
      }
  
      case DataFormatBoolean: {
          jit.zeroExtend32ToPtr(value, value);
<span class="line-modified">!         jit.or32(MacroAssembler::TrustedImm32(JSValue::ValueFalse), value);</span>
          break;
      }
  
      case DataFormatJS: {
          // Done already!
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,23 ***</span>
  
      reboxAccordingToFormat(
          value.dataFormat(), jit, GPRInfo::regT0, GPRInfo::regT1, GPRInfo::regT2);
  }
  
<span class="line-modified">! static void compileStub(</span>
<span class="line-removed">-     unsigned exitID, JITCode* jitCode, OSRExit&amp; exit, VM* vm, CodeBlock* codeBlock)</span>
  {
      // This code requires framePointerRegister is the same as callFrameRegister
      static_assert(MacroAssembler::framePointerRegister == GPRInfo::callFrameRegister, &quot;MacroAssembler::framePointerRegister and GPRInfo::callFrameRegister must be the same&quot;);
  
      CCallHelpers jit(codeBlock);
  
      // The first thing we need to do is restablish our frame in the case of an exception.
      if (exit.isGenericUnwindHandler()) {
<span class="line-modified">!         RELEASE_ASSERT(vm-&gt;callFrameForCatch); // The first time we hit this exit, like at all other times, this field should be non-null.</span>
<span class="line-modified">!         jit.restoreCalleeSavesFromEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);</span>
<span class="line-modified">!         jit.loadPtr(vm-&gt;addressOfCallFrameForCatch(), MacroAssembler::framePointerRegister);</span>
          jit.addPtr(CCallHelpers::TrustedImm32(codeBlock-&gt;stackPointerOffset() * sizeof(Register)),
              MacroAssembler::framePointerRegister, CCallHelpers::stackPointerRegister);
  
          // Do a pushToSave because that&#39;s what the exit compiler below expects the stack
          // to look like because that&#39;s the last thing the ExitThunkGenerator does. The code
<span class="line-new-header">--- 137,22 ---</span>
  
      reboxAccordingToFormat(
          value.dataFormat(), jit, GPRInfo::regT0, GPRInfo::regT1, GPRInfo::regT2);
  }
  
<span class="line-modified">! static void compileStub(VM&amp; vm, unsigned exitID, JITCode* jitCode, OSRExit&amp; exit, CodeBlock* codeBlock)</span>
  {
      // This code requires framePointerRegister is the same as callFrameRegister
      static_assert(MacroAssembler::framePointerRegister == GPRInfo::callFrameRegister, &quot;MacroAssembler::framePointerRegister and GPRInfo::callFrameRegister must be the same&quot;);
  
      CCallHelpers jit(codeBlock);
  
      // The first thing we need to do is restablish our frame in the case of an exception.
      if (exit.isGenericUnwindHandler()) {
<span class="line-modified">!         RELEASE_ASSERT(vm.callFrameForCatch); // The first time we hit this exit, like at all other times, this field should be non-null.</span>
<span class="line-modified">!         jit.restoreCalleeSavesFromEntryFrameCalleeSavesBuffer(vm.topEntryFrame);</span>
<span class="line-modified">!         jit.loadPtr(vm.addressOfCallFrameForCatch(), MacroAssembler::framePointerRegister);</span>
          jit.addPtr(CCallHelpers::TrustedImm32(codeBlock-&gt;stackPointerOffset() * sizeof(Register)),
              MacroAssembler::framePointerRegister, CCallHelpers::stackPointerRegister);
  
          // Do a pushToSave because that&#39;s what the exit compiler below expects the stack
          // to look like because that&#39;s the last thing the ExitThunkGenerator does. The code
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,11 ***</span>
          maxMaterializationNumArguments = std::max(
              maxMaterializationNumArguments,
              materialization-&gt;properties().size());
      }
  
<span class="line-modified">!     ScratchBuffer* scratchBuffer = vm-&gt;scratchBufferForSize(</span>
          sizeof(EncodedJSValue) * (
              exit.m_descriptor-&gt;m_values.size() + numMaterializations + maxMaterializationNumArguments) +
          requiredScratchMemorySizeInBytes() +
          codeBlock-&gt;calleeSaveRegisters()-&gt;size() * sizeof(uint64_t));
      EncodedJSValue* scratch = scratchBuffer ? static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer()) : 0;
<span class="line-new-header">--- 174,11 ---</span>
          maxMaterializationNumArguments = std::max(
              maxMaterializationNumArguments,
              materialization-&gt;properties().size());
      }
  
<span class="line-modified">!     ScratchBuffer* scratchBuffer = vm.scratchBufferForSize(</span>
          sizeof(EncodedJSValue) * (
              exit.m_descriptor-&gt;m_values.size() + numMaterializations + maxMaterializationNumArguments) +
          requiredScratchMemorySizeInBytes() +
          codeBlock-&gt;calleeSaveRegisters()-&gt;size() * sizeof(uint64_t));
      EncodedJSValue* scratch = scratchBuffer ? static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer()) : 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 213,19 ***</span>
  
          // Even though we set Heap::m_expectDoesGC in compileFTLOSRExit(), we also need
          // to set it here because compileFTLOSRExit() is only called on the first time
          // we exit from this site, but all subsequent exits will take this compiled
          // ramp without calling compileFTLOSRExit() first.
<span class="line-modified">!         jit.store8(CCallHelpers::TrustedImm32(true), vm-&gt;heap.addressOfExpectDoesGC());</span>
      }
  
      // Bring the stack back into a sane form and assert that it&#39;s sane.
      jit.popToRestore(GPRInfo::regT0);
      jit.checkStackPointerAlignment();
  
<span class="line-modified">!     if (UNLIKELY(vm-&gt;m_perBytecodeProfiler &amp;&amp; jitCode-&gt;dfgCommon()-&gt;compilation)) {</span>
<span class="line-modified">!         Profiler::Database&amp; database = *vm-&gt;m_perBytecodeProfiler;</span>
          Profiler::Compilation* compilation = jitCode-&gt;dfgCommon()-&gt;compilation.get();
  
          Profiler::OSRExit* profilerExit = compilation-&gt;addOSRExit(
              exitID, Profiler::OriginStack(database, codeBlock, exit.m_codeOrigin),
              exit.m_kind, exit.m_kind == UncountableInvalidation);
<span class="line-new-header">--- 214,19 ---</span>
  
          // Even though we set Heap::m_expectDoesGC in compileFTLOSRExit(), we also need
          // to set it here because compileFTLOSRExit() is only called on the first time
          // we exit from this site, but all subsequent exits will take this compiled
          // ramp without calling compileFTLOSRExit() first.
<span class="line-modified">!         jit.store8(CCallHelpers::TrustedImm32(true), vm.heap.addressOfExpectDoesGC());</span>
      }
  
      // Bring the stack back into a sane form and assert that it&#39;s sane.
      jit.popToRestore(GPRInfo::regT0);
      jit.checkStackPointerAlignment();
  
<span class="line-modified">!     if (UNLIKELY(vm.m_perBytecodeProfiler &amp;&amp; jitCode-&gt;dfgCommon()-&gt;compilation)) {</span>
<span class="line-modified">!         Profiler::Database&amp; database = *vm.m_perBytecodeProfiler;</span>
          Profiler::Compilation* compilation = jitCode-&gt;dfgCommon()-&gt;compilation.get();
  
          Profiler::OSRExit* profilerExit = compilation-&gt;addOSRExit(
              exitID, Profiler::OriginStack(database, codeBlock, exit.m_codeOrigin),
              exit.m_kind, exit.m_kind == UncountableInvalidation);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,22 ***</span>
      // The remaining code assumes that SP/FP are in the same state that they were in the FTL&#39;s
      // call frame.
  
      // Get the call frame and tag thingies.
      // Restore the exiting function&#39;s callFrame value into a regT4
<span class="line-modified">!     jit.move(MacroAssembler::TrustedImm64(TagTypeNumber), GPRInfo::tagTypeNumberRegister);</span>
<span class="line-modified">!     jit.move(MacroAssembler::TrustedImm64(TagMask), GPRInfo::tagMaskRegister);</span>
  
      // Do some value profiling.
      if (exit.m_descriptor-&gt;m_profileDataFormat != DataFormatNone) {
          Location::forValueRep(exit.m_valueReps[0]).restoreInto(jit, registerScratch, GPRInfo::regT0);
          reboxAccordingToFormat(
              exit.m_descriptor-&gt;m_profileDataFormat, jit, GPRInfo::regT0, GPRInfo::regT1, GPRInfo::regT2);
  
          if (exit.m_kind == BadCache || exit.m_kind == BadIndexingType) {
              CodeOrigin codeOrigin = exit.m_codeOriginForExitProfile;
<span class="line-modified">!             if (ArrayProfile* arrayProfile = jit.baselineCodeBlockFor(codeOrigin)-&gt;getArrayProfile(codeOrigin.bytecodeIndex())) {</span>
                  jit.load32(MacroAssembler::Address(GPRInfo::regT0, JSCell::structureIDOffset()), GPRInfo::regT1);
                  jit.store32(GPRInfo::regT1, arrayProfile-&gt;addressOfLastSeenStructureID());
  
                  jit.load8(MacroAssembler::Address(GPRInfo::regT0, JSCell::typeInfoTypeOffset()), GPRInfo::regT2);
                  jit.sub32(MacroAssembler::TrustedImm32(FirstTypedArrayType), GPRInfo::regT2);
<span class="line-new-header">--- 236,30 ---</span>
      // The remaining code assumes that SP/FP are in the same state that they were in the FTL&#39;s
      // call frame.
  
      // Get the call frame and tag thingies.
      // Restore the exiting function&#39;s callFrame value into a regT4
<span class="line-modified">!     jit.move(MacroAssembler::TrustedImm64(JSValue::NumberTag), GPRInfo::numberTagRegister);</span>
<span class="line-modified">!     jit.move(MacroAssembler::TrustedImm64(JSValue::NotCellMask), GPRInfo::notCellMaskRegister);</span>
  
      // Do some value profiling.
      if (exit.m_descriptor-&gt;m_profileDataFormat != DataFormatNone) {
          Location::forValueRep(exit.m_valueReps[0]).restoreInto(jit, registerScratch, GPRInfo::regT0);
          reboxAccordingToFormat(
              exit.m_descriptor-&gt;m_profileDataFormat, jit, GPRInfo::regT0, GPRInfo::regT1, GPRInfo::regT2);
  
          if (exit.m_kind == BadCache || exit.m_kind == BadIndexingType) {
              CodeOrigin codeOrigin = exit.m_codeOriginForExitProfile;
<span class="line-modified">!             CodeBlock* codeBlock = jit.baselineCodeBlockFor(codeOrigin);</span>
<span class="line-added">+             if (ArrayProfile* arrayProfile = codeBlock-&gt;getArrayProfile(codeOrigin.bytecodeIndex())) {</span>
<span class="line-added">+                 const Instruction* instruction = codeBlock-&gt;instructions().at(codeOrigin.bytecodeIndex()).ptr();</span>
<span class="line-added">+                 CCallHelpers::Jump skipProfile;</span>
<span class="line-added">+                 if (instruction-&gt;is&lt;OpGetById&gt;()) {</span>
<span class="line-added">+                     auto&amp; metadata = instruction-&gt;as&lt;OpGetById&gt;().metadata(codeBlock);</span>
<span class="line-added">+                     skipProfile = jit.branch8(CCallHelpers::NotEqual, CCallHelpers::AbsoluteAddress(&amp;metadata.m_modeMetadata.mode), CCallHelpers::TrustedImm32(static_cast&lt;uint8_t&gt;(GetByIdMode::ArrayLength)));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
                  jit.load32(MacroAssembler::Address(GPRInfo::regT0, JSCell::structureIDOffset()), GPRInfo::regT1);
                  jit.store32(GPRInfo::regT1, arrayProfile-&gt;addressOfLastSeenStructureID());
  
                  jit.load8(MacroAssembler::Address(GPRInfo::regT0, JSCell::typeInfoTypeOffset()), GPRInfo::regT2);
                  jit.sub32(MacroAssembler::TrustedImm32(FirstTypedArrayType), GPRInfo::regT2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,10 ***</span>
<span class="line-new-header">--- 273,13 ---</span>
                  jit.and32(MacroAssembler::TrustedImm32(IndexingModeMask), GPRInfo::regT1);
                  jit.move(MacroAssembler::TrustedImm32(1), GPRInfo::regT2);
                  jit.lshift32(GPRInfo::regT1, GPRInfo::regT2);
                  storeArrayModes.link(&amp;jit);
                  jit.or32(GPRInfo::regT2, MacroAssembler::AbsoluteAddress(arrayProfile-&gt;addressOfArrayModes()));
<span class="line-added">+ </span>
<span class="line-added">+                 if (skipProfile.isSet())</span>
<span class="line-added">+                     skipProfile.link(&amp;jit);</span>
              }
          }
  
          if (exit.m_descriptor-&gt;m_valueProfile)
              exit.m_descriptor-&gt;m_valueProfile.emitReportValue(jit, JSValueRegs(GPRInfo::regT0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,12 ***</span>
<span class="line-new-header">--- 331,14 ---</span>
                  jit.storePtr(GPRInfo::regT0, materializationArguments + propertyIndex);
              }
  
              static_assert(FunctionTraits&lt;decltype(operationMaterializeObjectInOSR)&gt;::arity &lt; GPRInfo::numberOfArgumentRegisters, &quot;This call assumes that we don&#39;t pass arguments on the stack.&quot;);
              jit.setupArguments&lt;decltype(operationMaterializeObjectInOSR)&gt;(
<span class="line-added">+                 CCallHelpers::TrustedImmPtr(codeBlock-&gt;globalObjectFor(materialization-&gt;origin())),</span>
                  CCallHelpers::TrustedImmPtr(materialization),
                  CCallHelpers::TrustedImmPtr(materializationArguments));
<span class="line-added">+             jit.prepareCallOperation(vm);</span>
              jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationMaterializeObjectInOSR)), GPRInfo::nonArgGPR0);
              jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
              jit.storePtr(GPRInfo::returnValueGPR, materializationToPointer.get(materialization));
  
              // Let everyone know that we&#39;re done.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 346,13 ***</span>
<span class="line-new-header">--- 360,15 ---</span>
              jit.storePtr(GPRInfo::regT0, materializationArguments + propertyIndex);
          }
  
          static_assert(FunctionTraits&lt;decltype(operationPopulateObjectInOSR)&gt;::arity &lt; GPRInfo::numberOfArgumentRegisters, &quot;This call assumes that we don&#39;t pass arguments on the stack.&quot;);
          jit.setupArguments&lt;decltype(operationPopulateObjectInOSR)&gt;(
<span class="line-added">+             CCallHelpers::TrustedImmPtr(codeBlock-&gt;globalObjectFor(materialization-&gt;origin())),</span>
              CCallHelpers::TrustedImmPtr(materialization),
              CCallHelpers::TrustedImmPtr(materializationToPointer.get(materialization)),
              CCallHelpers::TrustedImmPtr(materializationArguments));
<span class="line-added">+         jit.prepareCallOperation(vm);</span>
          jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationPopulateObjectInOSR)), GPRInfo::nonArgGPR0);
          jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
      }
  
      // Save all state from wherever the exit data tells us it was, into the appropriate place in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 395,11 ***</span>
      RegisterSet allFTLCalleeSaves = RegisterSet::ftlCalleeSaveRegisters();
      const RegisterAtOffsetList* baselineCalleeSaves = baselineCodeBlock-&gt;calleeSaveRegisters();
      RegisterAtOffsetList* vmCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();
      RegisterSet vmCalleeSavesToSkip = RegisterSet::stackRegisters();
      if (exit.isExceptionHandler()) {
<span class="line-modified">!         jit.loadPtr(&amp;vm-&gt;topEntryFrame, GPRInfo::regT1);</span>
          jit.addPtr(CCallHelpers::TrustedImm32(EntryFrame::calleeSaveRegistersBufferOffset()), GPRInfo::regT1);
      }
  
      for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
          if (!allFTLCalleeSaves.get(reg)) {
<span class="line-new-header">--- 411,11 ---</span>
      RegisterSet allFTLCalleeSaves = RegisterSet::ftlCalleeSaveRegisters();
      const RegisterAtOffsetList* baselineCalleeSaves = baselineCodeBlock-&gt;calleeSaveRegisters();
      RegisterAtOffsetList* vmCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();
      RegisterSet vmCalleeSavesToSkip = RegisterSet::stackRegisters();
      if (exit.isExceptionHandler()) {
<span class="line-modified">!         jit.loadPtr(&amp;vm.topEntryFrame, GPRInfo::regT1);</span>
          jit.addPtr(CCallHelpers::TrustedImm32(EntryFrame::calleeSaveRegistersBufferOffset()), GPRInfo::regT1);
      }
  
      for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
          if (!allFTLCalleeSaves.get(reg)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 449,34 ***</span>
                  jit.storeDouble(fpRegToLoad, MacroAssembler::Address(GPRInfo::regT1, vmCalleeSave-&gt;offset()));
          }
      }
  
      if (exit.isExceptionHandler()) {
<span class="line-modified">!         RegisterAtOffset* vmCalleeSave = vmCalleeSaves-&gt;find(GPRInfo::tagTypeNumberRegister);</span>
<span class="line-modified">!         jit.store64(GPRInfo::tagTypeNumberRegister, MacroAssembler::Address(GPRInfo::regT1, vmCalleeSave-&gt;offset()));</span>
  
<span class="line-modified">!         vmCalleeSave = vmCalleeSaves-&gt;find(GPRInfo::tagMaskRegister);</span>
<span class="line-modified">!         jit.store64(GPRInfo::tagMaskRegister, MacroAssembler::Address(GPRInfo::regT1, vmCalleeSave-&gt;offset()));</span>
      }
  
      size_t baselineVirtualRegistersForCalleeSaves = baselineCodeBlock-&gt;calleeSaveSpaceAsVirtualRegisters();
  
      // Now get state out of the scratch buffer and place it back into the stack. The values are
      // already reboxed so we just move them.
      for (unsigned index = exit.m_descriptor-&gt;m_values.size(); index--;) {
<span class="line-modified">!         VirtualRegister reg = exit.m_descriptor-&gt;m_values.virtualRegisterForIndex(index);</span>
  
<span class="line-modified">!         if (reg.isLocal() &amp;&amp; reg.toLocal() &lt; static_cast&lt;int&gt;(baselineVirtualRegistersForCalleeSaves))</span>
              continue;
  
          jit.load64(scratch + index, GPRInfo::regT0);
<span class="line-modified">!         jit.store64(GPRInfo::regT0, AssemblyHelpers::addressFor(reg));</span>
      }
  
<span class="line-modified">!     handleExitCounts(jit, exit);</span>
      reifyInlinedCallFrames(jit, exit);
<span class="line-modified">!     adjustAndJumpToTarget(*vm, jit, exit);</span>
  
      LinkBuffer patchBuffer(jit, codeBlock);
      exit.m_code = FINALIZE_CODE_IF(
          shouldDumpDisassembly() || Options::verboseOSR() || Options::verboseFTLOSRExit(),
          patchBuffer, OSRExitPtrTag,
<span class="line-new-header">--- 465,70 ---</span>
                  jit.storeDouble(fpRegToLoad, MacroAssembler::Address(GPRInfo::regT1, vmCalleeSave-&gt;offset()));
          }
      }
  
      if (exit.isExceptionHandler()) {
<span class="line-modified">!         RegisterAtOffset* vmCalleeSave = vmCalleeSaves-&gt;find(GPRInfo::numberTagRegister);</span>
<span class="line-modified">!         jit.store64(GPRInfo::numberTagRegister, MacroAssembler::Address(GPRInfo::regT1, vmCalleeSave-&gt;offset()));</span>
  
<span class="line-modified">!         vmCalleeSave = vmCalleeSaves-&gt;find(GPRInfo::notCellMaskRegister);</span>
<span class="line-modified">!         jit.store64(GPRInfo::notCellMaskRegister, MacroAssembler::Address(GPRInfo::regT1, vmCalleeSave-&gt;offset()));</span>
      }
  
      size_t baselineVirtualRegistersForCalleeSaves = baselineCodeBlock-&gt;calleeSaveSpaceAsVirtualRegisters();
  
<span class="line-added">+     if (exit.m_codeOrigin.inlineStackContainsActiveCheckpoint()) {</span>
<span class="line-added">+         JSValue* tmpScratch = reinterpret_cast&lt;JSValue*&gt;(scratch + exit.m_descriptor-&gt;m_values.tmpIndex(0));</span>
<span class="line-added">+         VM* vmPtr = &amp;vm;</span>
<span class="line-added">+         jit.probe([=] (Probe::Context&amp; context) {</span>
<span class="line-added">+             auto addSideState = [&amp;] (CallFrame* frame, BytecodeIndex index, size_t tmpOffset) {</span>
<span class="line-added">+                 std::unique_ptr&lt;CheckpointOSRExitSideState&gt; sideState = WTF::makeUnique&lt;CheckpointOSRExitSideState&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+                 sideState-&gt;bytecodeIndex = index;</span>
<span class="line-added">+                 for (size_t i = 0; i &lt; maxNumCheckpointTmps; ++i)</span>
<span class="line-added">+                     sideState-&gt;tmps[i] = tmpScratch[i + tmpOffset];</span>
<span class="line-added">+ </span>
<span class="line-added">+                 vmPtr-&gt;addCheckpointOSRSideState(frame, WTFMove(sideState));</span>
<span class="line-added">+             };</span>
<span class="line-added">+ </span>
<span class="line-added">+             const CodeOrigin* codeOrigin;</span>
<span class="line-added">+             CallFrame* callFrame = context.gpr&lt;CallFrame*&gt;(GPRInfo::callFrameRegister);</span>
<span class="line-added">+             for (codeOrigin = &amp;exit.m_codeOrigin; codeOrigin &amp;&amp; codeOrigin-&gt;inlineCallFrame(); codeOrigin = codeOrigin-&gt;inlineCallFrame()-&gt;getCallerSkippingTailCalls()) {</span>
<span class="line-added">+                 BytecodeIndex callBytecodeIndex = codeOrigin-&gt;bytecodeIndex();</span>
<span class="line-added">+                 if (!callBytecodeIndex.checkpoint())</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 auto* inlineCallFrame = codeOrigin-&gt;inlineCallFrame();</span>
<span class="line-added">+                 addSideState(reinterpret_cast&lt;CallFrame*&gt;(reinterpret_cast&lt;char*&gt;(callFrame) + inlineCallFrame-&gt;returnPCOffset() - sizeof(CPURegister)), callBytecodeIndex, inlineCallFrame-&gt;tmpOffset);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (!codeOrigin)</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (BytecodeIndex bytecodeIndex = codeOrigin-&gt;bytecodeIndex(); bytecodeIndex.checkpoint())</span>
<span class="line-added">+                 addSideState(callFrame, bytecodeIndex, 0);</span>
<span class="line-added">+         });</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // Now get state out of the scratch buffer and place it back into the stack. The values are
      // already reboxed so we just move them.
      for (unsigned index = exit.m_descriptor-&gt;m_values.size(); index--;) {
<span class="line-modified">!         Operand operand = exit.m_descriptor-&gt;m_values.operandForIndex(index);</span>
  
<span class="line-modified">!         if (operand.isTmp())</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (operand.isLocal() &amp;&amp; operand.toLocal() &lt; static_cast&lt;int&gt;(baselineVirtualRegistersForCalleeSaves))</span>
              continue;
  
          jit.load64(scratch + index, GPRInfo::regT0);
<span class="line-modified">!         jit.store64(GPRInfo::regT0, AssemblyHelpers::addressFor(operand.virtualRegister()));</span>
      }
  
<span class="line-modified">!     handleExitCounts(vm, jit, exit);</span>
      reifyInlinedCallFrames(jit, exit);
<span class="line-modified">!     adjustAndJumpToTarget(vm, jit, exit);</span>
  
      LinkBuffer patchBuffer(jit, codeBlock);
      exit.m_code = FINALIZE_CODE_IF(
          shouldDumpDisassembly() || Options::verboseOSR() || Options::verboseFTLOSRExit(),
          patchBuffer, OSRExitPtrTag,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 485,27 ***</span>
              exitKindToString(exit.m_kind), toCString(*codeBlock).data(),
              toCString(ignoringContext&lt;DumpContext&gt;(exit.m_descriptor-&gt;m_values)).data()
          );
  }
  
<span class="line-modified">! extern &quot;C&quot; void* compileFTLOSRExit(ExecState* exec, unsigned exitID)</span>
  {
      if (shouldDumpDisassembly() || Options::verboseOSR() || Options::verboseFTLOSRExit())
          dataLog(&quot;Compiling OSR exit with exitID = &quot;, exitID, &quot;\n&quot;);
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      if (validateDFGDoesGC) {
          // We&#39;re about to exit optimized code. So, there&#39;s no longer any optimized
          // code running that expects no GC.
          vm.heap.setExpectDoesGC(true);
      }
  
      if (vm.callFrameForCatch)
<span class="line-modified">!         RELEASE_ASSERT(vm.callFrameForCatch == exec);</span>
  
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
  
      ASSERT(codeBlock);
      ASSERT(codeBlock-&gt;jitType() == JITType::FTLJIT);
  
      // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t
<span class="line-new-header">--- 537,27 ---</span>
              exitKindToString(exit.m_kind), toCString(*codeBlock).data(),
              toCString(ignoringContext&lt;DumpContext&gt;(exit.m_descriptor-&gt;m_values)).data()
          );
  }
  
<span class="line-modified">! extern &quot;C&quot; JIT_OPERATION void* operationCompileFTLOSRExit(CallFrame* callFrame, unsigned exitID)</span>
  {
      if (shouldDumpDisassembly() || Options::verboseOSR() || Options::verboseFTLOSRExit())
          dataLog(&quot;Compiling OSR exit with exitID = &quot;, exitID, &quot;\n&quot;);
  
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
  
      if (validateDFGDoesGC) {
          // We&#39;re about to exit optimized code. So, there&#39;s no longer any optimized
          // code running that expects no GC.
          vm.heap.setExpectDoesGC(true);
      }
  
      if (vm.callFrameForCatch)
<span class="line-modified">!         RELEASE_ASSERT(vm.callFrameForCatch == callFrame);</span>
  
<span class="line-modified">!     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
  
      ASSERT(codeBlock);
      ASSERT(codeBlock-&gt;jitType() == JITType::FTLJIT);
  
      // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t
</pre>
<hr />
<pre>
<span class="line-old-header">*** 518,11 ***</span>
      if (shouldDumpDisassembly() || Options::verboseOSR() || Options::verboseFTLOSRExit()) {
          dataLog(&quot;    Owning block: &quot;, pointerDump(codeBlock), &quot;\n&quot;);
          dataLog(&quot;    Origin: &quot;, exit.m_codeOrigin, &quot;\n&quot;);
          if (exit.m_codeOriginForExitProfile != exit.m_codeOrigin)
              dataLog(&quot;    Origin for exit profile: &quot;, exit.m_codeOriginForExitProfile, &quot;\n&quot;);
<span class="line-modified">!         dataLog(&quot;    Current call site index: &quot;, exec-&gt;callSiteIndex().bits(), &quot;\n&quot;);</span>
          dataLog(&quot;    Exit is exception handler: &quot;, exit.isExceptionHandler(), &quot;\n&quot;);
          dataLog(&quot;    Is unwind handler: &quot;, exit.isGenericUnwindHandler(), &quot;\n&quot;);
          dataLog(&quot;    Exit values: &quot;, exit.m_descriptor-&gt;m_values, &quot;\n&quot;);
          dataLog(&quot;    Value reps: &quot;, listDump(exit.m_valueReps), &quot;\n&quot;);
          if (!exit.m_descriptor-&gt;m_materializations.isEmpty()) {
<span class="line-new-header">--- 570,11 ---</span>
      if (shouldDumpDisassembly() || Options::verboseOSR() || Options::verboseFTLOSRExit()) {
          dataLog(&quot;    Owning block: &quot;, pointerDump(codeBlock), &quot;\n&quot;);
          dataLog(&quot;    Origin: &quot;, exit.m_codeOrigin, &quot;\n&quot;);
          if (exit.m_codeOriginForExitProfile != exit.m_codeOrigin)
              dataLog(&quot;    Origin for exit profile: &quot;, exit.m_codeOriginForExitProfile, &quot;\n&quot;);
<span class="line-modified">!         dataLog(&quot;    Current call site index: &quot;, callFrame-&gt;callSiteIndex().bits(), &quot;\n&quot;);</span>
          dataLog(&quot;    Exit is exception handler: &quot;, exit.isExceptionHandler(), &quot;\n&quot;);
          dataLog(&quot;    Is unwind handler: &quot;, exit.isGenericUnwindHandler(), &quot;\n&quot;);
          dataLog(&quot;    Exit values: &quot;, exit.m_descriptor-&gt;m_values, &quot;\n&quot;);
          dataLog(&quot;    Value reps: &quot;, listDump(exit.m_valueReps), &quot;\n&quot;);
          if (!exit.m_descriptor-&gt;m_materializations.isEmpty()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 530,13 ***</span>
              for (ExitTimeObjectMaterialization* materialization : exit.m_descriptor-&gt;m_materializations)
                  dataLog(&quot;        &quot;, pointerDump(materialization), &quot;\n&quot;);
          }
      }
  
<span class="line-modified">!     prepareCodeOriginForOSRExit(exec, exit.m_codeOrigin);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     compileStub(exitID, jitCode, exit, &amp;vm, codeBlock);</span>
  
      MacroAssembler::repatchJump(
          exit.codeLocationForRepatch(codeBlock), CodeLocationLabel&lt;OSRExitPtrTag&gt;(exit.m_code.code()));
  
      return exit.m_code.code().executableAddress();
<span class="line-new-header">--- 582,11 ---</span>
              for (ExitTimeObjectMaterialization* materialization : exit.m_descriptor-&gt;m_materializations)
                  dataLog(&quot;        &quot;, pointerDump(materialization), &quot;\n&quot;);
          }
      }
  
<span class="line-modified">!     compileStub(vm, exitID, jitCode, exit, codeBlock);</span>
  
      MacroAssembler::repatchJump(
          exit.codeLocationForRepatch(codeBlock), CodeLocationLabel&lt;OSRExitPtrTag&gt;(exit.m_code.code()));
  
      return exit.m_code.code().executableAddress();
</pre>
<center><a href="FTLOSRExit.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOSRExitCompiler.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRootInlineBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006 Oliver Hunt &lt;ojh16@student.canterbury.ac.nz&gt;
  3  * Copyright (C) 2006 Apple Inc.
  4  * Copyright (C) 2007 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  5  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  6  * Copyright (C) 2011 Torch Mobile (Beijing) CO. Ltd. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;SVGRootInlineBox.h&quot;
 26 
 27 #include &quot;GraphicsContext.h&quot;
 28 #include &quot;RenderSVGText.h&quot;
 29 #include &quot;RenderSVGTextPath.h&quot;
 30 #include &quot;SVGInlineFlowBox.h&quot;
 31 #include &quot;SVGInlineTextBox.h&quot;
 32 #include &quot;SVGNames.h&quot;
 33 #include &quot;SVGRenderingContext.h&quot;
 34 #include &quot;SVGTextPositioningElement.h&quot;
 35 #include &lt;wtf/IsoMallocInlines.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGRootInlineBox);
 40 
 41 SVGRootInlineBox::SVGRootInlineBox(RenderSVGText&amp; renderSVGText)
 42     : RootInlineBox(renderSVGText)
 43     , m_logicalHeight(0)
 44 {
 45 }
 46 
 47 RenderSVGText&amp; SVGRootInlineBox::renderSVGText()
 48 {
 49     return downcast&lt;RenderSVGText&gt;(blockFlow());
 50 }
 51 
 52 void SVGRootInlineBox::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, LayoutUnit, LayoutUnit)
 53 {
 54     ASSERT(paintInfo.phase == PaintPhase::Foreground || paintInfo.phase == PaintPhase::Selection);
 55     ASSERT(!paintInfo.context().paintingDisabled());
 56 
 57     bool isPrinting = renderSVGText().document().printing();
 58     bool hasSelection = !isPrinting &amp;&amp; selectionState() != RenderObject::SelectionNone;
 59     bool shouldPaintSelectionHighlight = !(paintInfo.paintBehavior.contains(PaintBehavior::SkipSelectionHighlight));
 60 
 61     PaintInfo childPaintInfo(paintInfo);
 62     if (hasSelection &amp;&amp; shouldPaintSelectionHighlight) {
 63         for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine()) {
 64             if (is&lt;SVGInlineTextBox&gt;(*child))
 65                 downcast&lt;SVGInlineTextBox&gt;(*child).paintSelectionBackground(childPaintInfo);
 66             else if (is&lt;SVGInlineFlowBox&gt;(*child))
 67                 downcast&lt;SVGInlineFlowBox&gt;(*child).paintSelectionBackground(childPaintInfo);
 68         }
 69     }
 70 
 71     SVGRenderingContext renderingContext(renderSVGText(), paintInfo, SVGRenderingContext::SaveGraphicsContext);
 72     if (renderingContext.isRenderingPrepared()) {
 73         for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine())
 74             child-&gt;paint(paintInfo, paintOffset, 0, 0);
 75     }
 76 }
 77 
 78 void SVGRootInlineBox::computePerCharacterLayoutInformation()
 79 {
 80     auto&amp; textRoot = downcast&lt;RenderSVGText&gt;(blockFlow());
 81 
 82     Vector&lt;SVGTextLayoutAttributes*&gt;&amp; layoutAttributes = textRoot.layoutAttributes();
 83     if (layoutAttributes.isEmpty())
 84         return;
 85 
 86     if (textRoot.needsReordering())
 87         reorderValueLists(layoutAttributes);
 88 
 89     // Perform SVG text layout phase two (see SVGTextLayoutEngine for details).
 90     SVGTextLayoutEngine characterLayout(layoutAttributes);
 91     layoutCharactersInTextBoxes(this, characterLayout);
 92 
 93     // Perform SVG text layout phase three (see SVGTextChunkBuilder for details).
 94     characterLayout.finishLayout();
 95 
 96     // Perform SVG text layout phase four
 97     // Position &amp; resize all SVGInlineText/FlowBoxes in the inline box tree, resize the root box as well as the RenderSVGText parent block.
 98     FloatRect childRect;
 99     layoutChildBoxes(this, &amp;childRect);
100     layoutRootBox(childRect);
101 }
102 
103 void SVGRootInlineBox::layoutCharactersInTextBoxes(InlineFlowBox* start, SVGTextLayoutEngine&amp; characterLayout)
104 {
105     for (InlineBox* child = start-&gt;firstChild(); child; child = child-&gt;nextOnLine()) {
106         if (is&lt;SVGInlineTextBox&gt;(*child)) {
107             ASSERT(is&lt;RenderSVGInlineText&gt;(child-&gt;renderer()));
108             characterLayout.layoutInlineTextBox(downcast&lt;SVGInlineTextBox&gt;(*child));
109         } else {
110             // Skip generated content.
111             Node* node = child-&gt;renderer().node();
112             if (!node)
113                 continue;
114 
115             auto&amp; flowBox = downcast&lt;SVGInlineFlowBox&gt;(*child);
116             bool isTextPath = node-&gt;hasTagName(SVGNames::textPathTag);
117             if (isTextPath) {
118                 // Build text chunks for all &lt;textPath&gt; children, using the line layout algorithm.
119                 // This is needeed as text-anchor is just an additional startOffset for text paths.
120                 SVGTextLayoutEngine lineLayout(characterLayout.layoutAttributes());
121                 layoutCharactersInTextBoxes(&amp;flowBox, lineLayout);
122 
123                 characterLayout.beginTextPathLayout(downcast&lt;RenderSVGTextPath&gt;(child-&gt;renderer()), lineLayout);
124             }
125 
126             layoutCharactersInTextBoxes(&amp;flowBox, characterLayout);
127 
128             if (isTextPath)
129                 characterLayout.endTextPathLayout();
130         }
131     }
132 }
133 
134 void SVGRootInlineBox::layoutChildBoxes(InlineFlowBox* start, FloatRect* childRect)
135 {
136     for (InlineBox* child = start-&gt;firstChild(); child; child = child-&gt;nextOnLine()) {
137         FloatRect boxRect;
138         if (is&lt;SVGInlineTextBox&gt;(*child)) {
139             ASSERT(is&lt;RenderSVGInlineText&gt;(child-&gt;renderer()));
140 
141             auto&amp; textBox = downcast&lt;SVGInlineTextBox&gt;(*child);
142             boxRect = textBox.calculateBoundaries();
143             textBox.setX(boxRect.x());
144             textBox.setY(boxRect.y());
145             textBox.setLogicalWidth(boxRect.width());
146             textBox.setLogicalHeight(boxRect.height());
147         } else {
148             // Skip generated content.
149             if (!child-&gt;renderer().node())
150                 continue;
151 
152             auto&amp; flowBox = downcast&lt;SVGInlineFlowBox&gt;(*child);
153             layoutChildBoxes(&amp;flowBox);
154 
155             boxRect = flowBox.calculateBoundaries();
156             flowBox.setX(boxRect.x());
157             flowBox.setY(boxRect.y());
158             flowBox.setLogicalWidth(boxRect.width());
159             flowBox.setLogicalHeight(boxRect.height());
160         }
161         if (childRect)
162             childRect-&gt;unite(boxRect);
163     }
164 }
165 
166 void SVGRootInlineBox::layoutRootBox(const FloatRect&amp; childRect)
167 {
168     RenderSVGText&amp; parentBlock = renderSVGText();
169 
170     // Finally, assign the root block position, now that all content is laid out.
171     LayoutRect boundingRect = enclosingLayoutRect(childRect);
172     parentBlock.setLocation(boundingRect.location());
173     parentBlock.setSize(boundingRect.size());
174 
175     // Position all children relative to the parent block.
176     for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine()) {
177         // Skip generated content.
178         if (!child-&gt;renderer().node())
179             continue;
180         child-&gt;adjustPosition(-childRect.x(), -childRect.y());
181     }
182 
183     // Position ourselves.
184     setX(0);
185     setY(0);
186     setLogicalWidth(childRect.width());
187     setLogicalHeight(childRect.height());
188     setLineTopBottomPositions(0, boundingRect.height(), 0, boundingRect.height());
189 }
190 
191 InlineBox* SVGRootInlineBox::closestLeafChildForPosition(const LayoutPoint&amp; point)
192 {
<a name="1" id="anc1"></a><span class="line-modified">193     InlineBox* firstLeaf = firstLeafDescendant();</span>
<span class="line-modified">194     InlineBox* lastLeaf = lastLeafDescendant();</span>
195     if (firstLeaf == lastLeaf)
196         return firstLeaf;
197 
198     // FIXME: Check for vertical text!
199     InlineBox* closestLeaf = nullptr;
<a name="2" id="anc2"></a><span class="line-modified">200     for (InlineBox* leaf = firstLeaf; leaf; leaf = leaf-&gt;nextLeafOnLine()) {</span>
201         if (!leaf-&gt;isSVGInlineTextBox())
202             continue;
203         if (point.y() &lt; leaf-&gt;y())
204             continue;
205         if (point.y() &gt; leaf-&gt;y() + leaf-&gt;virtualLogicalHeight())
206             continue;
207 
208         closestLeaf = leaf;
209         if (point.x() &lt; leaf-&gt;left() + leaf-&gt;logicalWidth())
210             return leaf;
211     }
212 
213     return closestLeaf ? closestLeaf : lastLeaf;
214 }
215 
216 bool SVGRootInlineBox::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, LayoutUnit lineTop, LayoutUnit lineBottom, HitTestAction hitTestAction)
217 {
<a name="3" id="anc3"></a><span class="line-modified">218     for (InlineBox* leaf = firstLeafDescendant(); leaf; leaf = leaf-&gt;nextLeafOnLine()) {</span>
219         if (!leaf-&gt;isSVGInlineTextBox())
220             continue;
221         if (leaf-&gt;nodeAtPoint(request, result, locationInContainer, accumulatedOffset, lineTop, lineBottom, hitTestAction))
222             return true;
223     }
224 
225     return false;
226 }
227 
228 static inline void swapItemsInLayoutAttributes(SVGTextLayoutAttributes* firstAttributes, SVGTextLayoutAttributes* lastAttributes, unsigned firstPosition, unsigned lastPosition)
229 {
230     SVGCharacterDataMap::iterator itFirst = firstAttributes-&gt;characterDataMap().find(firstPosition + 1);
231     SVGCharacterDataMap::iterator itLast = lastAttributes-&gt;characterDataMap().find(lastPosition + 1);
232     bool firstPresent = itFirst != firstAttributes-&gt;characterDataMap().end();
233     bool lastPresent = itLast != lastAttributes-&gt;characterDataMap().end();
234     if (!firstPresent &amp;&amp; !lastPresent)
235         return;
236 
237     if (firstPresent &amp;&amp; lastPresent) {
238         std::swap(itFirst-&gt;value, itLast-&gt;value);
239         return;
240     }
241 
242     if (firstPresent &amp;&amp; !lastPresent) {
243         lastAttributes-&gt;characterDataMap().set(lastPosition + 1, itFirst-&gt;value);
244         return;
245     }
246 
247     // !firstPresent &amp;&amp; lastPresent
248     firstAttributes-&gt;characterDataMap().set(firstPosition + 1, itLast-&gt;value);
249 }
250 
251 static inline void findFirstAndLastAttributesInVector(Vector&lt;SVGTextLayoutAttributes*&gt;&amp; attributes, RenderSVGInlineText* firstContext, RenderSVGInlineText* lastContext,
252                                                       SVGTextLayoutAttributes*&amp; first, SVGTextLayoutAttributes*&amp; last)
253 {
254     first = nullptr;
255     last = nullptr;
256 
257     unsigned attributesSize = attributes.size();
258     for (unsigned i = 0; i &lt; attributesSize; ++i) {
259         SVGTextLayoutAttributes* current = attributes[i];
260         if (!first &amp;&amp; firstContext == &amp;current-&gt;context())
261             first = current;
262         if (!last &amp;&amp; lastContext == &amp;current-&gt;context())
263             last = current;
264         if (first &amp;&amp; last)
265             break;
266     }
267 
268     ASSERT(first);
269     ASSERT(last);
270 }
271 
272 static inline void reverseInlineBoxRangeAndValueListsIfNeeded(void* userData, Vector&lt;InlineBox*&gt;::iterator first, Vector&lt;InlineBox*&gt;::iterator last)
273 {
274     ASSERT(userData);
275     Vector&lt;SVGTextLayoutAttributes*&gt;&amp; attributes = *reinterpret_cast&lt;Vector&lt;SVGTextLayoutAttributes*&gt;*&gt;(userData);
276 
277     // This is a copy of std::reverse(first, last). It additionally assures that the metrics map within the renderers belonging to the InlineBoxes are reordered as well.
278     while (true)  {
279         if (first == last || first == --last)
280             return;
281 
282         if (!is&lt;SVGInlineTextBox&gt;(**last) || !is&lt;SVGInlineTextBox&gt;(**first)) {
283             InlineBox* temp = *first;
284             *first = *last;
285             *last = temp;
286             ++first;
287             continue;
288         }
289 
290         auto&amp; firstTextBox = downcast&lt;SVGInlineTextBox&gt;(**first);
291         auto&amp; lastTextBox = downcast&lt;SVGInlineTextBox&gt;(**last);
292 
293         // Reordering is only necessary for BiDi text that is _absolutely_ positioned.
294         if (firstTextBox.len() == 1 &amp;&amp; firstTextBox.len() == lastTextBox.len()) {
295             RenderSVGInlineText&amp; firstContext = firstTextBox.renderer();
296             RenderSVGInlineText&amp; lastContext = lastTextBox.renderer();
297 
298             SVGTextLayoutAttributes* firstAttributes = nullptr;
299             SVGTextLayoutAttributes* lastAttributes = nullptr;
300             findFirstAndLastAttributesInVector(attributes, &amp;firstContext, &amp;lastContext, firstAttributes, lastAttributes);
301             swapItemsInLayoutAttributes(firstAttributes, lastAttributes, firstTextBox.start(), lastTextBox.start());
302         }
303 
304         InlineBox* temp = *first;
305         *first = *last;
306         *last = temp;
307 
308         ++first;
309     }
310 }
311 
312 void SVGRootInlineBox::reorderValueLists(Vector&lt;SVGTextLayoutAttributes*&gt;&amp; attributes)
313 {
314     Vector&lt;InlineBox*&gt; leafBoxesInLogicalOrder;
315     collectLeafBoxesInLogicalOrder(leafBoxesInLogicalOrder, reverseInlineBoxRangeAndValueListsIfNeeded, &amp;attributes);
316 }
317 
318 } // namespace WebCore
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
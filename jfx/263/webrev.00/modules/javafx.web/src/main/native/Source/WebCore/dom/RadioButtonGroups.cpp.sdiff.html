<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/RadioButtonGroups.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="QualifiedName.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RadioButtonGroups.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/RadioButtonGroups.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;RadioButtonGroups.h&quot;
 23 
 24 #include &quot;HTMLInputElement.h&quot;
 25 #include &quot;Range.h&quot;
<span class="line-modified"> 26 #include &lt;wtf/HashSet.h&gt;</span>

 27 
 28 namespace WebCore {
 29 
 30 class RadioButtonGroup {
 31     WTF_MAKE_FAST_ALLOCATED;
 32 public:
<span class="line-modified"> 33     bool isEmpty() const { return m_members.isEmpty(); }</span>
 34     bool isRequired() const { return m_requiredCount; }
<span class="line-modified"> 35     HTMLInputElement* checkedButton() const { return m_checkedButton; }</span>
 36     void add(HTMLInputElement&amp;);
 37     void updateCheckedState(HTMLInputElement&amp;);
 38     void requiredStateChanged(HTMLInputElement&amp;);
 39     void remove(HTMLInputElement&amp;);
 40     bool contains(HTMLInputElement&amp;) const;
<span class="line-modified"> 41     Vector&lt;HTMLInputElement*&gt; members() const;</span>
 42 
 43 private:
 44     void setNeedsStyleRecalcForAllButtons();
 45     void updateValidityForAllButtons();
 46     bool isValid() const;
 47     void setCheckedButton(HTMLInputElement*);
 48 
<span class="line-modified"> 49     HashSet&lt;HTMLInputElement*&gt; m_members;</span>
<span class="line-modified"> 50     HTMLInputElement* m_checkedButton { nullptr };</span>
 51     size_t m_requiredCount { 0 };
 52 };
 53 
 54 inline bool RadioButtonGroup::isValid() const
 55 {
 56     return !isRequired() || m_checkedButton;
 57 }
 58 
<span class="line-modified"> 59 Vector&lt;HTMLInputElement*&gt; RadioButtonGroup::members() const</span>
 60 {
<span class="line-modified"> 61     auto members = copyToVector(m_members);</span>
<span class="line-modified"> 62     std::sort(members.begin(), members.end(), documentOrderComparator);</span>
<span class="line-modified"> 63     return members;</span>




 64 }
 65 
 66 void RadioButtonGroup::setCheckedButton(HTMLInputElement* button)
 67 {
<span class="line-modified"> 68     RefPtr&lt;HTMLInputElement&gt; oldCheckedButton = m_checkedButton;</span>
 69     if (oldCheckedButton == button)
 70         return;
 71 
<span class="line-modified"> 72     bool hadCheckedButton = m_checkedButton;</span>
 73     bool willHaveCheckedButton = button;
 74     if (hadCheckedButton != willHaveCheckedButton)
 75         setNeedsStyleRecalcForAllButtons();
 76 
<span class="line-modified"> 77     m_checkedButton = button;</span>
 78     if (oldCheckedButton)
 79         oldCheckedButton-&gt;setChecked(false);
 80 }
 81 
 82 void RadioButtonGroup::add(HTMLInputElement&amp; button)
 83 {
 84     ASSERT(button.isRadioButton());
 85     if (!m_members.add(&amp;button).isNewEntry)
 86         return;
 87     bool groupWasValid = isValid();
 88     if (button.isRequired())
 89         ++m_requiredCount;
 90     if (button.checked())
 91         setCheckedButton(&amp;button);
 92 
 93     bool groupIsValid = isValid();
 94     if (groupWasValid != groupIsValid)
 95         updateValidityForAllButtons();
 96     else if (!groupIsValid) {
 97         // A radio button not in a group is always valid. We need to make it
 98         // invalid only if the group is invalid.
 99         button.updateValidity();
100     }
101 }
102 
103 void RadioButtonGroup::updateCheckedState(HTMLInputElement&amp; button)
104 {
105     ASSERT(button.isRadioButton());
<span class="line-modified">106     ASSERT(m_members.contains(&amp;button));</span>
107     bool wasValid = isValid();
108     if (button.checked())
109         setCheckedButton(&amp;button);
110     else {
111         if (m_checkedButton == &amp;button)
112             setCheckedButton(nullptr);
113     }
114     if (wasValid != isValid())
115         updateValidityForAllButtons();
116 }
117 
118 void RadioButtonGroup::requiredStateChanged(HTMLInputElement&amp; button)
119 {
120     ASSERT(button.isRadioButton());
<span class="line-modified">121     ASSERT(m_members.contains(&amp;button));</span>
122     bool wasValid = isValid();
123     if (button.isRequired())
124         ++m_requiredCount;
125     else {
126         ASSERT(m_requiredCount);
127         --m_requiredCount;
128     }
129     if (wasValid != isValid())
130         updateValidityForAllButtons();
131 }
132 
133 void RadioButtonGroup::remove(HTMLInputElement&amp; button)
134 {
135     ASSERT(button.isRadioButton());
<span class="line-modified">136     auto it = m_members.find(&amp;button);</span>
<span class="line-removed">137     if (it == m_members.end())</span>
138         return;
139 
140     bool wasValid = isValid();
<span class="line-modified">141     m_members.remove(it);</span>
142     if (button.isRequired()) {
143         ASSERT(m_requiredCount);
144         --m_requiredCount;
145     }
146     if (m_checkedButton) {
147         button.invalidateStyleForSubtree();
148         if (m_checkedButton == &amp;button) {
149             m_checkedButton = nullptr;
150             setNeedsStyleRecalcForAllButtons();
151         }
152     }
153 
<span class="line-modified">154     if (m_members.isEmpty()) {</span>
155         ASSERT(!m_requiredCount);
156         ASSERT(!m_checkedButton);
157     } else if (wasValid != isValid())
158         updateValidityForAllButtons();
159     if (!wasValid) {
160         // A radio button not in a group is always valid. We need to make it
161         // valid only if the group was invalid.
162         button.updateValidity();
163     }
164 }
165 
166 void RadioButtonGroup::setNeedsStyleRecalcForAllButtons()
167 {
168     for (auto&amp; button : m_members) {
<span class="line-modified">169         ASSERT(button-&gt;isRadioButton());</span>
<span class="line-modified">170         button-&gt;invalidateStyleForSubtree();</span>
171     }
172 }
173 
174 void RadioButtonGroup::updateValidityForAllButtons()
175 {
176     for (auto&amp; button : m_members) {
<span class="line-modified">177         ASSERT(button-&gt;isRadioButton());</span>
<span class="line-modified">178         button-&gt;updateValidity();</span>
179     }
180 }
181 
182 bool RadioButtonGroup::contains(HTMLInputElement&amp; button) const
183 {
<span class="line-modified">184     return m_members.contains(&amp;button);</span>
185 }
186 
187 // ----------------------------------------------------------------
188 
189 // Explicitly define default constructor and destructor here outside the header
190 // so we can compile the header without including the definition of RadioButtonGroup.
191 RadioButtonGroups::RadioButtonGroups() = default;
192 RadioButtonGroups::~RadioButtonGroups() = default;
193 
194 void RadioButtonGroups::addButton(HTMLInputElement&amp; element)
195 {
196     ASSERT(element.isRadioButton());
197     if (element.name().isEmpty())
198         return;
199 
<span class="line-modified">200     if (!m_nameToGroupMap)</span>
<span class="line-removed">201         m_nameToGroupMap = makeUnique&lt;NameToGroupMap&gt;();</span>
<span class="line-removed">202 </span>
<span class="line-removed">203     auto&amp; group = m_nameToGroupMap-&gt;add(element.name().impl(), nullptr).iterator-&gt;value;</span>
204     if (!group)
205         group = makeUnique&lt;RadioButtonGroup&gt;();
206     group-&gt;add(element);
207 }
208 
<span class="line-modified">209 Vector&lt;HTMLInputElement*&gt; RadioButtonGroups::groupMembers(const HTMLInputElement&amp; element) const</span>
210 {
211     ASSERT(element.isRadioButton());
212     if (!element.isRadioButton())
213         return { };
214 
215     auto* name = element.name().impl();
216     if (!name)
217         return { };
218 
<span class="line-modified">219     if (!m_nameToGroupMap)</span>
<span class="line-removed">220         return { };</span>
<span class="line-removed">221 </span>
<span class="line-removed">222     auto* group = m_nameToGroupMap-&gt;get(name);</span>
223     if (!group)
224         return { };
225     return group-&gt;members();
226 }
227 
228 void RadioButtonGroups::updateCheckedState(HTMLInputElement&amp; element)
229 {
230     ASSERT(element.isRadioButton());
231     if (element.name().isEmpty())
232         return;
<span class="line-modified">233     ASSERT(m_nameToGroupMap);</span>
<span class="line-removed">234     if (!m_nameToGroupMap)</span>
<span class="line-removed">235         return;</span>
<span class="line-removed">236     m_nameToGroupMap-&gt;get(element.name().impl())-&gt;updateCheckedState(element);</span>
237 }
238 
239 void RadioButtonGroups::requiredStateChanged(HTMLInputElement&amp; element)
240 {
241     ASSERT(element.isRadioButton());
242     if (element.name().isEmpty())
243         return;
<span class="line-modified">244     ASSERT(m_nameToGroupMap);</span>
<span class="line-removed">245     if (!m_nameToGroupMap)</span>
<span class="line-removed">246         return;</span>
<span class="line-removed">247     auto* group = m_nameToGroupMap-&gt;get(element.name().impl());</span>
248     ASSERT(group);
249     group-&gt;requiredStateChanged(element);
250 }
251 
<span class="line-modified">252 HTMLInputElement* RadioButtonGroups::checkedButtonForGroup(const AtomString&amp; name) const</span>
253 {
<span class="line-modified">254     if (!m_nameToGroupMap)</span>
<span class="line-modified">255         return nullptr;</span>
<span class="line-removed">256     m_nameToGroupMap-&gt;checkConsistency();</span>
<span class="line-removed">257     RadioButtonGroup* group = m_nameToGroupMap-&gt;get(name.impl());</span>
258     return group ? group-&gt;checkedButton() : nullptr;
259 }
260 
261 bool RadioButtonGroups::hasCheckedButton(const HTMLInputElement&amp; element) const
262 {
263     ASSERT(element.isRadioButton());
264     const AtomString&amp; name = element.name();
<span class="line-modified">265     if (name.isEmpty() || !m_nameToGroupMap)</span>
266         return element.checked();
<span class="line-modified">267     return m_nameToGroupMap-&gt;get(name.impl())-&gt;checkedButton();</span>



268 }
269 
270 bool RadioButtonGroups::isInRequiredGroup(HTMLInputElement&amp; element) const
271 {
272     ASSERT(element.isRadioButton());
273     if (element.name().isEmpty())
274         return false;
<span class="line-modified">275     if (!m_nameToGroupMap)</span>
<span class="line-removed">276         return false;</span>
<span class="line-removed">277     auto* group = m_nameToGroupMap-&gt;get(element.name().impl());</span>
278     return group &amp;&amp; group-&gt;isRequired() &amp;&amp; group-&gt;contains(element);
279 }
280 
281 void RadioButtonGroups::removeButton(HTMLInputElement&amp; element)
282 {
283     ASSERT(element.isRadioButton());
284     if (element.name().isEmpty())
285         return;
<span class="line-removed">286     if (!m_nameToGroupMap)</span>
<span class="line-removed">287         return;</span>
288 
<span class="line-modified">289     m_nameToGroupMap-&gt;checkConsistency();</span>
<span class="line-modified">290     auto it = m_nameToGroupMap-&gt;find(element.name().impl());</span>
<span class="line-modified">291     if (it == m_nameToGroupMap-&gt;end())</span>
292         return;
293     it-&gt;value-&gt;remove(element);
<span class="line-modified">294     if (it-&gt;value-&gt;isEmpty()) {</span>
<span class="line-modified">295         // FIXME: We may skip deallocating the empty RadioButtonGroup for</span>
<span class="line-removed">296         // performance improvement. If we do so, we need to change the key type</span>
<span class="line-removed">297         // of m_nameToGroupMap from AtomStringImpl* to RefPtr&lt;AtomStringImpl&gt;.</span>
<span class="line-removed">298         m_nameToGroupMap-&gt;remove(it);</span>
<span class="line-removed">299         if (m_nameToGroupMap-&gt;isEmpty())</span>
<span class="line-removed">300             m_nameToGroupMap = nullptr;</span>
<span class="line-removed">301     }</span>
302 }
303 
304 } // namespace
</pre>
</td>
<td>
<hr />
<pre>
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;RadioButtonGroups.h&quot;
 23 
 24 #include &quot;HTMLInputElement.h&quot;
 25 #include &quot;Range.h&quot;
<span class="line-modified"> 26 #include &lt;wtf/WeakHashSet.h&gt;</span>
<span class="line-added"> 27 #include &lt;wtf/WeakPtr.h&gt;</span>
 28 
 29 namespace WebCore {
 30 
 31 class RadioButtonGroup {
 32     WTF_MAKE_FAST_ALLOCATED;
 33 public:
<span class="line-modified"> 34     bool isEmpty() const { return m_members.computesEmpty(); }</span>
 35     bool isRequired() const { return m_requiredCount; }
<span class="line-modified"> 36     RefPtr&lt;HTMLInputElement&gt; checkedButton() const { return m_checkedButton.get(); }</span>
 37     void add(HTMLInputElement&amp;);
 38     void updateCheckedState(HTMLInputElement&amp;);
 39     void requiredStateChanged(HTMLInputElement&amp;);
 40     void remove(HTMLInputElement&amp;);
 41     bool contains(HTMLInputElement&amp;) const;
<span class="line-modified"> 42     Vector&lt;Ref&lt;HTMLInputElement&gt;&gt; members() const;</span>
 43 
 44 private:
 45     void setNeedsStyleRecalcForAllButtons();
 46     void updateValidityForAllButtons();
 47     bool isValid() const;
 48     void setCheckedButton(HTMLInputElement*);
 49 
<span class="line-modified"> 50     WeakHashSet&lt;HTMLInputElement&gt; m_members;</span>
<span class="line-modified"> 51     WeakPtr&lt;HTMLInputElement&gt; m_checkedButton;</span>
 52     size_t m_requiredCount { 0 };
 53 };
 54 
 55 inline bool RadioButtonGroup::isValid() const
 56 {
 57     return !isRequired() || m_checkedButton;
 58 }
 59 
<span class="line-modified"> 60 Vector&lt;Ref&lt;HTMLInputElement&gt;&gt; RadioButtonGroup::members() const</span>
 61 {
<span class="line-modified"> 62     Vector&lt;Ref&lt;HTMLInputElement&gt;&gt; sortedMembers;</span>
<span class="line-modified"> 63     for (auto&amp; memeber : m_members)</span>
<span class="line-modified"> 64         sortedMembers.append(memeber);</span>
<span class="line-added"> 65     std::sort(sortedMembers.begin(), sortedMembers.end(), [](auto&amp; a, auto&amp; b) {</span>
<span class="line-added"> 66         return documentOrderComparator(a.ptr(), b.ptr());</span>
<span class="line-added"> 67     });</span>
<span class="line-added"> 68     return sortedMembers;</span>
 69 }
 70 
 71 void RadioButtonGroup::setCheckedButton(HTMLInputElement* button)
 72 {
<span class="line-modified"> 73     RefPtr&lt;HTMLInputElement&gt; oldCheckedButton = m_checkedButton.get();</span>
 74     if (oldCheckedButton == button)
 75         return;
 76 
<span class="line-modified"> 77     bool hadCheckedButton = m_checkedButton.get();</span>
 78     bool willHaveCheckedButton = button;
 79     if (hadCheckedButton != willHaveCheckedButton)
 80         setNeedsStyleRecalcForAllButtons();
 81 
<span class="line-modified"> 82     m_checkedButton = makeWeakPtr(button);</span>
 83     if (oldCheckedButton)
 84         oldCheckedButton-&gt;setChecked(false);
 85 }
 86 
 87 void RadioButtonGroup::add(HTMLInputElement&amp; button)
 88 {
 89     ASSERT(button.isRadioButton());
 90     if (!m_members.add(&amp;button).isNewEntry)
 91         return;
 92     bool groupWasValid = isValid();
 93     if (button.isRequired())
 94         ++m_requiredCount;
 95     if (button.checked())
 96         setCheckedButton(&amp;button);
 97 
 98     bool groupIsValid = isValid();
 99     if (groupWasValid != groupIsValid)
100         updateValidityForAllButtons();
101     else if (!groupIsValid) {
102         // A radio button not in a group is always valid. We need to make it
103         // invalid only if the group is invalid.
104         button.updateValidity();
105     }
106 }
107 
108 void RadioButtonGroup::updateCheckedState(HTMLInputElement&amp; button)
109 {
110     ASSERT(button.isRadioButton());
<span class="line-modified">111     ASSERT(m_members.contains(button));</span>
112     bool wasValid = isValid();
113     if (button.checked())
114         setCheckedButton(&amp;button);
115     else {
116         if (m_checkedButton == &amp;button)
117             setCheckedButton(nullptr);
118     }
119     if (wasValid != isValid())
120         updateValidityForAllButtons();
121 }
122 
123 void RadioButtonGroup::requiredStateChanged(HTMLInputElement&amp; button)
124 {
125     ASSERT(button.isRadioButton());
<span class="line-modified">126     ASSERT(m_members.contains(button));</span>
127     bool wasValid = isValid();
128     if (button.isRequired())
129         ++m_requiredCount;
130     else {
131         ASSERT(m_requiredCount);
132         --m_requiredCount;
133     }
134     if (wasValid != isValid())
135         updateValidityForAllButtons();
136 }
137 
138 void RadioButtonGroup::remove(HTMLInputElement&amp; button)
139 {
140     ASSERT(button.isRadioButton());
<span class="line-modified">141     if (!m_members.contains(button))</span>

142         return;
143 
144     bool wasValid = isValid();
<span class="line-modified">145     m_members.remove(button);</span>
146     if (button.isRequired()) {
147         ASSERT(m_requiredCount);
148         --m_requiredCount;
149     }
150     if (m_checkedButton) {
151         button.invalidateStyleForSubtree();
152         if (m_checkedButton == &amp;button) {
153             m_checkedButton = nullptr;
154             setNeedsStyleRecalcForAllButtons();
155         }
156     }
157 
<span class="line-modified">158     if (m_members.computesEmpty()) {</span>
159         ASSERT(!m_requiredCount);
160         ASSERT(!m_checkedButton);
161     } else if (wasValid != isValid())
162         updateValidityForAllButtons();
163     if (!wasValid) {
164         // A radio button not in a group is always valid. We need to make it
165         // valid only if the group was invalid.
166         button.updateValidity();
167     }
168 }
169 
170 void RadioButtonGroup::setNeedsStyleRecalcForAllButtons()
171 {
172     for (auto&amp; button : m_members) {
<span class="line-modified">173         ASSERT(button.isRadioButton());</span>
<span class="line-modified">174         button.invalidateStyleForSubtree();</span>
175     }
176 }
177 
178 void RadioButtonGroup::updateValidityForAllButtons()
179 {
180     for (auto&amp; button : m_members) {
<span class="line-modified">181         ASSERT(button.isRadioButton());</span>
<span class="line-modified">182         button.updateValidity();</span>
183     }
184 }
185 
186 bool RadioButtonGroup::contains(HTMLInputElement&amp; button) const
187 {
<span class="line-modified">188     return m_members.contains(button);</span>
189 }
190 
191 // ----------------------------------------------------------------
192 
193 // Explicitly define default constructor and destructor here outside the header
194 // so we can compile the header without including the definition of RadioButtonGroup.
195 RadioButtonGroups::RadioButtonGroups() = default;
196 RadioButtonGroups::~RadioButtonGroups() = default;
197 
198 void RadioButtonGroups::addButton(HTMLInputElement&amp; element)
199 {
200     ASSERT(element.isRadioButton());
201     if (element.name().isEmpty())
202         return;
203 
<span class="line-modified">204     auto&amp; group = m_nameToGroupMap.add(element.name().impl(), nullptr).iterator-&gt;value;</span>



205     if (!group)
206         group = makeUnique&lt;RadioButtonGroup&gt;();
207     group-&gt;add(element);
208 }
209 
<span class="line-modified">210 Vector&lt;Ref&lt;HTMLInputElement&gt;&gt; RadioButtonGroups::groupMembers(const HTMLInputElement&amp; element) const</span>
211 {
212     ASSERT(element.isRadioButton());
213     if (!element.isRadioButton())
214         return { };
215 
216     auto* name = element.name().impl();
217     if (!name)
218         return { };
219 
<span class="line-modified">220     auto* group = m_nameToGroupMap.get(name);</span>



221     if (!group)
222         return { };
223     return group-&gt;members();
224 }
225 
226 void RadioButtonGroups::updateCheckedState(HTMLInputElement&amp; element)
227 {
228     ASSERT(element.isRadioButton());
229     if (element.name().isEmpty())
230         return;
<span class="line-modified">231     m_nameToGroupMap.get(element.name().impl())-&gt;updateCheckedState(element);</span>



232 }
233 
234 void RadioButtonGroups::requiredStateChanged(HTMLInputElement&amp; element)
235 {
236     ASSERT(element.isRadioButton());
237     if (element.name().isEmpty())
238         return;
<span class="line-modified">239     auto* group = m_nameToGroupMap.get(element.name().impl());</span>



240     ASSERT(group);
241     group-&gt;requiredStateChanged(element);
242 }
243 
<span class="line-modified">244 RefPtr&lt;HTMLInputElement&gt; RadioButtonGroups::checkedButtonForGroup(const AtomString&amp; name) const</span>
245 {
<span class="line-modified">246     m_nameToGroupMap.checkConsistency();</span>
<span class="line-modified">247     RadioButtonGroup* group = m_nameToGroupMap.get(name.impl());</span>


248     return group ? group-&gt;checkedButton() : nullptr;
249 }
250 
251 bool RadioButtonGroups::hasCheckedButton(const HTMLInputElement&amp; element) const
252 {
253     ASSERT(element.isRadioButton());
254     const AtomString&amp; name = element.name();
<span class="line-modified">255     if (name.isEmpty())</span>
256         return element.checked();
<span class="line-modified">257     auto* group = m_nameToGroupMap.get(name.impl());</span>
<span class="line-added">258     if (!group)</span>
<span class="line-added">259         return false; // FIXME: Update the radio button group before author script had a chance to run in didFinishInsertingNode().</span>
<span class="line-added">260     return group-&gt;checkedButton();</span>
261 }
262 
263 bool RadioButtonGroups::isInRequiredGroup(HTMLInputElement&amp; element) const
264 {
265     ASSERT(element.isRadioButton());
266     if (element.name().isEmpty())
267         return false;
<span class="line-modified">268     auto* group = m_nameToGroupMap.get(element.name().impl());</span>


269     return group &amp;&amp; group-&gt;isRequired() &amp;&amp; group-&gt;contains(element);
270 }
271 
272 void RadioButtonGroups::removeButton(HTMLInputElement&amp; element)
273 {
274     ASSERT(element.isRadioButton());
275     if (element.name().isEmpty())
276         return;


277 
<span class="line-modified">278     m_nameToGroupMap.checkConsistency();</span>
<span class="line-modified">279     auto it = m_nameToGroupMap.find(element.name().impl());</span>
<span class="line-modified">280     if (it == m_nameToGroupMap.end())</span>
281         return;
282     it-&gt;value-&gt;remove(element);
<span class="line-modified">283     if (it-&gt;value-&gt;isEmpty())</span>
<span class="line-modified">284         m_nameToGroupMap.remove(it);</span>






285 }
286 
287 } // namespace
</pre>
</td>
</tr>
</table>
<center><a href="QualifiedName.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RadioButtonGroups.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
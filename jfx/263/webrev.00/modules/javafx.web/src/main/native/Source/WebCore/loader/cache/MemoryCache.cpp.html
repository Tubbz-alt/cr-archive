<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/cache/MemoryCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2     Copyright (C) 1998 Lars Knoll (knoll@mpi-hd.mpg.de)
  3     Copyright (C) 2001 Dirk Mueller (mueller@kde.org)
  4     Copyright (C) 2002 Waldo Bastian (bastian@kde.org)
  5     Copyright (C) 2004, 2005, 2006, 2007, 2008 Apple Inc. All rights reserved.
  6 
  7     This library is free software; you can redistribute it and/or
  8     modify it under the terms of the GNU Library General Public
  9     License as published by the Free Software Foundation; either
 10     version 2 of the License, or (at your option) any later version.
 11 
 12     This library is distributed in the hope that it will be useful,
 13     but WITHOUT ANY WARRANTY; without even the implied warranty of
 14     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15     Library General Public License for more details.
 16 
 17     You should have received a copy of the GNU Library General Public License
 18     along with this library; see the file COPYING.LIB.  If not, write to
 19     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20     Boston, MA 02110-1301, USA.
 21 */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;MemoryCache.h&quot;
 25 
 26 #include &quot;BitmapImage.h&quot;
 27 #include &quot;CachedImage.h&quot;
 28 #include &quot;CachedImageClient.h&quot;
 29 #include &quot;CachedResource.h&quot;
 30 #include &quot;CachedResourceHandle.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;FrameLoader.h&quot;
 33 #include &quot;FrameLoaderTypes.h&quot;
 34 #include &quot;FrameView.h&quot;
 35 #include &quot;Image.h&quot;
 36 #include &quot;Logging.h&quot;
 37 #include &quot;PublicSuffix.h&quot;
 38 #include &quot;SharedBuffer.h&quot;
 39 #include &quot;WorkerGlobalScope.h&quot;
 40 #include &quot;WorkerLoaderProxy.h&quot;
 41 #include &quot;WorkerThread.h&quot;
 42 #include &lt;pal/Logging.h&gt;
 43 #include &lt;stdio.h&gt;
 44 #include &lt;wtf/MathExtras.h&gt;
 45 #include &lt;wtf/NeverDestroyed.h&gt;
 46 #include &lt;wtf/SetForScope.h&gt;
 47 #include &lt;wtf/text/CString.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 static const int cDefaultCacheCapacity = 8192 * 1024;
 52 static const Seconds cMinDelayBeforeLiveDecodedPrune { 1_s };
 53 static const float cTargetPrunePercentage = .95f; // Percentage of capacity toward which we prune, to avoid immediately pruning again.
 54 
 55 MemoryCache&amp; MemoryCache::singleton()
 56 {
 57     ASSERT(WTF::isMainThread());
 58     static NeverDestroyed&lt;MemoryCache&gt; memoryCache;
 59     return memoryCache;
 60 }
 61 
 62 MemoryCache::MemoryCache()
 63     : m_capacity(cDefaultCacheCapacity)
 64     , m_maxDeadCapacity(cDefaultCacheCapacity)
 65     , m_pruneTimer(*this, &amp;MemoryCache::prune)
 66 {
 67     static_assert(sizeof(long long) &gt; sizeof(unsigned), &quot;Numerical overflow can happen when adjusting the size of the cached memory.&quot;);
 68 
 69     static std::once_flag onceFlag;
 70     std::call_once(onceFlag, [] {
 71         PAL::registerNotifyCallback(&quot;com.apple.WebKit.showMemoryCache&quot;, [] {
 72             MemoryCache::singleton().dumpStats();
 73             MemoryCache::singleton().dumpLRULists(true);
 74         });
 75     });
 76 }
 77 
 78 auto MemoryCache::sessionResourceMap(PAL::SessionID sessionID) const -&gt; CachedResourceMap*
 79 {
 80     ASSERT(sessionID.isValid());
 81     return m_sessionResources.get(sessionID);
 82 }
 83 
 84 auto MemoryCache::ensureSessionResourceMap(PAL::SessionID sessionID) -&gt; CachedResourceMap&amp;
 85 {
 86     ASSERT(sessionID.isValid());
 87     auto&amp; map = m_sessionResources.add(sessionID, nullptr).iterator-&gt;value;
 88     if (!map)
 89         map = makeUnique&lt;CachedResourceMap&gt;();
 90     return *map;
 91 }
 92 
 93 bool MemoryCache::shouldRemoveFragmentIdentifier(const URL&amp; originalURL)
 94 {
 95     if (!originalURL.hasFragmentIdentifier())
 96         return false;
 97     // Strip away fragment identifier from HTTP URLs.
 98     // Data URLs must be unmodified. For file and custom URLs clients may expect resources
 99     // to be unique even when they differ by the fragment identifier only.
100     return originalURL.protocolIsInHTTPFamily();
101 }
102 
103 URL MemoryCache::removeFragmentIdentifierIfNeeded(const URL&amp; originalURL)
104 {
105     if (!shouldRemoveFragmentIdentifier(originalURL))
106         return originalURL;
107     URL url = originalURL;
108     url.removeFragmentIdentifier();
109     return url;
110 }
111 
112 bool MemoryCache::add(CachedResource&amp; resource)
113 {
114     if (disabled())
115         return false;
116 
117     ASSERT(WTF::isMainThread());
118 
119     auto key = std::make_pair(resource.url(), resource.cachePartition());
120 
121     ensureSessionResourceMap(resource.sessionID()).set(key, &amp;resource);
122     resource.setInCache(true);
123 
124     resourceAccessed(resource);
125 
126     LOG(ResourceLoading, &quot;MemoryCache::add Added &#39;%.255s&#39;, resource %p\n&quot;, resource.url().string().latin1().data(), &amp;resource);
127     return true;
128 }
129 
130 void MemoryCache::revalidationSucceeded(CachedResource&amp; revalidatingResource, const ResourceResponse&amp; response)
131 {
132     ASSERT(response.source() == ResourceResponse::Source::MemoryCacheAfterValidation);
133     ASSERT(revalidatingResource.resourceToRevalidate());
134     CachedResource&amp; resource = *revalidatingResource.resourceToRevalidate();
135     ASSERT(!resource.inCache());
136     ASSERT(resource.isLoaded());
137 
138     // Calling remove() can potentially delete revalidatingResource, which we use
139     // below. This mustn&#39;t be the case since revalidation means it is loaded
140     // and so canDelete() is false.
141     ASSERT(!revalidatingResource.canDelete());
142 
143     remove(revalidatingResource);
144 
145     auto&amp; resources = ensureSessionResourceMap(resource.sessionID());
146     auto key = std::make_pair(resource.url(), resource.cachePartition());
147 
148     ASSERT(!resources.get(key));
149     resources.set(key, &amp;resource);
150     resource.setInCache(true);
151     resource.updateResponseAfterRevalidation(response);
152     insertInLRUList(resource);
153     long long delta = resource.size();
154     if (resource.decodedSize() &amp;&amp; resource.hasClients())
155         insertInLiveDecodedResourcesList(resource);
156     if (delta)
157         adjustSize(resource.hasClients(), delta);
158 
159     revalidatingResource.switchClientsToRevalidatedResource();
160     ASSERT(!revalidatingResource.m_deleted);
161     // this deletes the revalidating resource
162     revalidatingResource.clearResourceToRevalidate();
163 }
164 
165 void MemoryCache::revalidationFailed(CachedResource&amp; revalidatingResource)
166 {
167     ASSERT(WTF::isMainThread());
168     LOG(ResourceLoading, &quot;Revalidation failed for %p&quot;, &amp;revalidatingResource);
169     ASSERT(revalidatingResource.resourceToRevalidate());
170     revalidatingResource.clearResourceToRevalidate();
171 }
172 
173 CachedResource* MemoryCache::resourceForRequest(const ResourceRequest&amp; request, PAL::SessionID sessionID)
174 {
175     // FIXME: Change all clients to make sure HTTP(s) URLs have no fragment identifiers before calling here.
176     // CachedResourceLoader is now doing this. Add an assertion once all other clients are doing it too.
177     auto* resources = sessionResourceMap(sessionID);
178     if (!resources)
179         return nullptr;
180     return resourceForRequestImpl(request, *resources);
181 }
182 
183 CachedResource* MemoryCache::resourceForRequestImpl(const ResourceRequest&amp; request, CachedResourceMap&amp; resources)
184 {
185     ASSERT(WTF::isMainThread());
186     URL url = removeFragmentIdentifierIfNeeded(request.url());
187 
188     auto key = std::make_pair(url, request.cachePartition());
189     return resources.get(key);
190 }
191 
192 unsigned MemoryCache::deadCapacity() const
193 {
194     // Dead resource capacity is whatever space is not occupied by live resources, bounded by an independent minimum and maximum.
195     unsigned capacity = m_capacity - std::min(m_liveSize, m_capacity); // Start with available capacity.
196     capacity = std::max(capacity, m_minDeadCapacity); // Make sure it&#39;s above the minimum.
197     capacity = std::min(capacity, m_maxDeadCapacity); // Make sure it&#39;s below the maximum.
198     return capacity;
199 }
200 
201 unsigned MemoryCache::liveCapacity() const
202 {
203     // Live resource capacity is whatever is left over after calculating dead resource capacity.
204     return m_capacity - deadCapacity();
205 }
206 
207 void MemoryCache::pruneLiveResources(bool shouldDestroyDecodedDataForAllLiveResources)
208 {
209     unsigned capacity = shouldDestroyDecodedDataForAllLiveResources ? 0 : liveCapacity();
210     if (capacity &amp;&amp; m_liveSize &lt;= capacity)
211         return;
212 
213     unsigned targetSize = static_cast&lt;unsigned&gt;(capacity * cTargetPrunePercentage); // Cut by a percentage to avoid immediately pruning again.
214 
215     pruneLiveResourcesToSize(targetSize, shouldDestroyDecodedDataForAllLiveResources);
216 }
217 
218 void MemoryCache::forEachResource(const WTF::Function&lt;void(CachedResource&amp;)&gt;&amp; function)
219 {
220     for (auto&amp; unprotectedLRUList : m_allResources) {
221         for (auto&amp; resource : copyToVector(*unprotectedLRUList))
222             function(*resource);
223     }
224 }
225 
226 void MemoryCache::forEachSessionResource(PAL::SessionID sessionID, const WTF::Function&lt;void (CachedResource&amp;)&gt;&amp; function)
227 {
228     auto it = m_sessionResources.find(sessionID);
229     if (it == m_sessionResources.end())
230         return;
231 
232     for (auto&amp; resource : copyToVector(it-&gt;value-&gt;values()))
233         function(*resource);
234 }
235 
236 void MemoryCache::destroyDecodedDataForAllImages()
237 {
238     MemoryCache::singleton().forEachResource([](CachedResource&amp; resource) {
239         if (!resource.isImage())
240             return;
241 
242         if (auto image = downcast&lt;CachedImage&gt;(resource).image())
243             image-&gt;destroyDecodedData();
244     });
245 }
246 
247 void MemoryCache::pruneLiveResourcesToSize(unsigned targetSize, bool shouldDestroyDecodedDataForAllLiveResources)
248 {
249     if (m_inPruneResources)
250         return;
251 
252     LOG(ResourceLoading, &quot;MemoryCache::pruneLiveResourcesToSize(%d, shouldDestroyDecodedDataForAllLiveResources = %d)&quot;, targetSize, shouldDestroyDecodedDataForAllLiveResources);
253 
254     SetForScope&lt;bool&gt; reentrancyProtector(m_inPruneResources, true);
255 
256     MonotonicTime currentTime = FrameView::currentPaintTimeStamp();
257     if (!currentTime) // In case prune is called directly, outside of a Frame paint.
258         currentTime = MonotonicTime::now();
259 
260     // Destroy any decoded data in live objects that we can.
261     // Start from the head, since this is the least recently accessed of the objects.
262 
263     // The list might not be sorted by the m_lastDecodedAccessTime. The impact
264     // of this weaker invariant is minor as the below if statement to check the
265     // elapsedTime will evaluate to false as the currentTime will be a lot
266     // greater than the current-&gt;m_lastDecodedAccessTime.
267     // For more details see: https://bugs.webkit.org/show_bug.cgi?id=30209
268     auto it = m_liveDecodedResources.begin();
269     while (it != m_liveDecodedResources.end()) {
270         auto* current = *it;
271 
272         LOG(ResourceLoading, &quot; live resource %p %.255s - loaded %d, decodedSize %u&quot;, current, current-&gt;url().string().utf8().data(), current-&gt;isLoaded(), current-&gt;decodedSize());
273 
274         // Increment the iterator now because the call to destroyDecodedData() below
275         // may cause a call to ListHashSet::remove() and invalidate the current
276         // iterator. Note that this is safe because unlike iteration of most
277         // WTF Hash data structures, iteration is guaranteed safe against mutation
278         // of the ListHashSet, except for removal of the item currently pointed to
279         // by a given iterator.
280         ++it;
281 
282         ASSERT(current-&gt;hasClients());
283         if (current-&gt;isLoaded() &amp;&amp; current-&gt;decodedSize()) {
284             // Check to see if the remaining resources are too new to prune.
285             Seconds elapsedTime = currentTime - current-&gt;m_lastDecodedAccessTime;
286             if (!shouldDestroyDecodedDataForAllLiveResources &amp;&amp; elapsedTime &lt; cMinDelayBeforeLiveDecodedPrune) {
287                 LOG(ResourceLoading, &quot; current time is less than min delay before pruning (%.3fms)&quot;, elapsedTime.milliseconds());
288                 return;
289             }
290 
291             // Destroy our decoded data. This will remove us from m_liveDecodedResources, and possibly move us
292             // to a different LRU list in m_allResources.
293             current-&gt;destroyDecodedData();
294 
295             if (targetSize &amp;&amp; m_liveSize &lt;= targetSize)
296                 return;
297         }
298     }
299 }
300 
301 void MemoryCache::pruneDeadResources()
302 {
303     LOG(ResourceLoading, &quot;MemoryCache::pruneDeadResources&quot;);
304 
305     unsigned capacity = deadCapacity();
306     if (capacity &amp;&amp; m_deadSize &lt;= capacity)
307         return;
308 
309     unsigned targetSize = static_cast&lt;unsigned&gt;(capacity * cTargetPrunePercentage); // Cut by a percentage to avoid immediately pruning again.
310     pruneDeadResourcesToSize(targetSize);
311 }
312 
313 void MemoryCache::pruneDeadResourcesToSize(unsigned targetSize)
314 {
315     if (m_inPruneResources)
316         return;
317 
318     LOG(ResourceLoading, &quot;MemoryCache::pruneDeadResourcesToSize(%d)&quot;, targetSize);
319 
320     SetForScope&lt;bool&gt; reentrancyProtector(m_inPruneResources, true);
321 
322     if (targetSize &amp;&amp; m_deadSize &lt;= targetSize)
323         return;
324 
325     bool canShrinkLRULists = true;
326     for (int i = m_allResources.size() - 1; i &gt;= 0; i--) {
327         // Make a copy of the LRUList first (and ref the resources) as calling
328         // destroyDecodedData() can alter the LRUList.
329         auto lruList = copyToVector(*m_allResources[i]);
330 
331         LOG(ResourceLoading, &quot; lru list (size %lu) - flushing stage&quot;, lruList.size());
332 
333         // First flush all the decoded data in this queue.
334         // Remove from the head, since this is the least frequently accessed of the objects.
335         for (auto&amp; resource : lruList) {
336             LOG(ResourceLoading, &quot; lru resource %p - in cache %d, has clients %d, preloaded %d, loaded %d&quot;, resource, resource-&gt;inCache(), resource-&gt;hasClients(), resource-&gt;isPreloaded(), resource-&gt;isLoaded());
337             if (!resource-&gt;inCache())
338                 continue;
339 
340             if (!resource-&gt;hasClients() &amp;&amp; !resource-&gt;isPreloaded() &amp;&amp; resource-&gt;isLoaded()) {
341                 // Destroy our decoded data. This will remove us from
342                 // m_liveDecodedResources, and possibly move us to a different
343                 // LRU list in m_allResources.
344 
345                 LOG(ResourceLoading, &quot; lru resource %p destroyDecodedData&quot;, resource);
346 
347                 resource-&gt;destroyDecodedData();
348 
349                 if (targetSize &amp;&amp; m_deadSize &lt;= targetSize)
350                     return;
351             }
352         }
353 
354         LOG(ResourceLoading, &quot; lru list (size %lu) - eviction stage&quot;, lruList.size());
355 
356         // Now evict objects from this list.
357         // Remove from the head, since this is the least frequently accessed of the objects.
358         for (auto&amp; resource : lruList) {
359             LOG(ResourceLoading, &quot; lru resource %p - in cache %d, has clients %d, preloaded %d, loaded %d&quot;, resource, resource-&gt;inCache(), resource-&gt;hasClients(), resource-&gt;isPreloaded(), resource-&gt;isLoaded());
360             if (!resource-&gt;inCache())
361                 continue;
362 
363             if (!resource-&gt;hasClients() &amp;&amp; !resource-&gt;isPreloaded() &amp;&amp; !resource-&gt;isCacheValidator()) {
364                 remove(*resource);
365                 if (targetSize &amp;&amp; m_deadSize &lt;= targetSize)
366                     return;
367             }
368         }
369 
370         // Shrink the vector back down so we don&#39;t waste time inspecting
371         // empty LRU lists on future prunes.
372         if (!m_allResources[i]-&gt;isEmpty())
373             canShrinkLRULists = false;
374         else if (canShrinkLRULists)
375             m_allResources.shrink(i);
376     }
377 }
378 
379 void MemoryCache::setCapacities(unsigned minDeadBytes, unsigned maxDeadBytes, unsigned totalBytes)
380 {
381     ASSERT(minDeadBytes &lt;= maxDeadBytes);
382     ASSERT(maxDeadBytes &lt;= totalBytes);
383     m_minDeadCapacity = minDeadBytes;
384     m_maxDeadCapacity = maxDeadBytes;
385     m_capacity = totalBytes;
386     prune();
387 }
388 
389 void MemoryCache::remove(CachedResource&amp; resource)
390 {
391     ASSERT(WTF::isMainThread());
392     LOG(ResourceLoading, &quot;Evicting resource %p for &#39;%.255s&#39; from cache&quot;, &amp;resource, resource.url().string().latin1().data());
393     // The resource may have already been removed by someone other than our caller,
394     // who needed a fresh copy for a reload. See &lt;http://bugs.webkit.org/show_bug.cgi?id=12479#c6&gt;.
395     if (auto* resources = sessionResourceMap(resource.sessionID())) {
396         auto key = std::make_pair(resource.url(), resource.cachePartition());
397 
398         if (resource.inCache()) {
399             ASSERT_WITH_MESSAGE(resource.response().source() != ResourceResponse::Source::InspectorOverride, &quot;InspectorOverride responses should not get into the MemoryCache&quot;);
400 
401             // Remove resource from the resource map.
402             resources-&gt;remove(key);
403             resource.setInCache(false);
404 
405             // If the resource map is now empty, remove it from m_sessionResources.
406             if (resources-&gt;isEmpty())
407                 m_sessionResources.remove(resource.sessionID());
408 
409             // Remove from the appropriate LRU list.
410             removeFromLRUList(resource);
411             removeFromLiveDecodedResourcesList(resource);
412             adjustSize(resource.hasClients(), -static_cast&lt;long long&gt;(resource.size()));
413         } else {
414             ASSERT(resources-&gt;get(key) != &amp;resource);
415             LOG(ResourceLoading, &quot;  resource %p is not in cache&quot;, &amp;resource);
416         }
417     }
418 
419     resource.deleteIfPossible();
420 }
421 
422 auto MemoryCache::lruListFor(CachedResource&amp; resource) -&gt; LRUList&amp;
423 {
424     unsigned accessCount = std::max(resource.accessCount(), 1U);
425     unsigned queueIndex = WTF::fastLog2(resource.size() / accessCount);
426 #if ASSERT_ENABLED
427     resource.m_lruIndex = queueIndex;
428 #endif
429 
430     m_allResources.reserveCapacity(queueIndex + 1);
431     while (m_allResources.size() &lt;= queueIndex)
432         m_allResources.uncheckedAppend(makeUnique&lt;LRUList&gt;());
433     return *m_allResources[queueIndex];
434 }
435 
436 void MemoryCache::removeFromLRUList(CachedResource&amp; resource)
437 {
438     // If we&#39;ve never been accessed, then we&#39;re brand new and not in any list.
439     if (!resource.accessCount())
440         return;
441 
442 #if ASSERT_ENABLED
443     unsigned oldListIndex = resource.m_lruIndex;
444 #endif
445 
446     LRUList&amp; list = lruListFor(resource);
447 
448     // Verify that the list we got is the list we want.
449     ASSERT(resource.m_lruIndex == oldListIndex);
450 
451     bool removed = list.remove(&amp;resource);
452     ASSERT_UNUSED(removed, removed);
453 }
454 
455 void MemoryCache::insertInLRUList(CachedResource&amp; resource)
456 {
457     ASSERT(resource.inCache());
458     ASSERT(resource.accessCount() &gt; 0);
459 
460     auto addResult = lruListFor(resource).add(&amp;resource);
461     ASSERT_UNUSED(addResult, addResult.isNewEntry);
462 }
463 
464 void MemoryCache::resourceAccessed(CachedResource&amp; resource)
465 {
466     ASSERT(resource.inCache());
467 
468     // Need to make sure to remove before we increase the access count, since
469     // the queue will possibly change.
470     removeFromLRUList(resource);
471 
472     // If this is the first time the resource has been accessed, adjust the size of the cache to account for its initial size.
473     if (!resource.accessCount())
474         adjustSize(resource.hasClients(), resource.size());
475 
476     // Add to our access count.
477     resource.increaseAccessCount();
478 
479     // Now insert into the new queue.
480     insertInLRUList(resource);
481 }
482 
483 void MemoryCache::removeResourcesWithOrigin(SecurityOrigin&amp; origin)
484 {
485     String originPartition = ResourceRequest::partitionName(origin.host());
486 
487     Vector&lt;CachedResource*&gt; resourcesWithOrigin;
488     for (auto&amp; resources : m_sessionResources.values()) {
489         for (auto&amp; keyValue : *resources) {
490             auto&amp; resource = *keyValue.value;
491             auto&amp; partitionName = keyValue.key.second;
492             if (partitionName == originPartition) {
493                 resourcesWithOrigin.append(&amp;resource);
494                 continue;
495             }
496             auto resourceOrigin = SecurityOrigin::create(resource.url());
497             if (resourceOrigin-&gt;equal(&amp;origin))
498                 resourcesWithOrigin.append(&amp;resource);
499         }
500     }
501 
502     for (auto* resource : resourcesWithOrigin)
503         remove(*resource);
504 }
505 
506 void MemoryCache::removeResourcesWithOrigins(PAL::SessionID sessionID, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
507 {
508     auto* resourceMap = sessionResourceMap(sessionID);
509     if (!resourceMap)
510         return;
511 
512     HashSet&lt;String&gt; originPartitions;
513 
514     for (auto&amp; origin : origins)
515         originPartitions.add(ResourceRequest::partitionName(origin-&gt;host()));
516 
517     Vector&lt;CachedResource*&gt; resourcesToRemove;
518     for (auto&amp; keyValuePair : *resourceMap) {
519         auto&amp; resource = *keyValuePair.value;
520         auto&amp; partitionName = keyValuePair.key.second;
521         if (originPartitions.contains(partitionName)) {
522             resourcesToRemove.append(&amp;resource);
523             continue;
524         }
525         if (origins.contains(SecurityOrigin::create(resource.url()).ptr()))
526             resourcesToRemove.append(&amp;resource);
527     }
528 
529     for (auto&amp; resource : resourcesToRemove)
530         remove(*resource);
531 }
532 
533 void MemoryCache::getOriginsWithCache(SecurityOriginSet&amp; origins)
534 {
535     for (auto&amp; resources : m_sessionResources.values()) {
536         for (auto&amp; keyValue : *resources) {
537             auto&amp; resource = *keyValue.value;
538             auto&amp; partitionName = keyValue.key.second;
539             if (!partitionName.isEmpty())
540                 origins.add(SecurityOrigin::create(&quot;http&quot;_s, partitionName, 0));
541             else
542                 origins.add(SecurityOrigin::create(resource.url()));
543         }
544     }
545 }
546 
547 HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; MemoryCache::originsWithCache(PAL::SessionID sessionID) const
548 {
549     HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; origins;
550 
551     auto it = m_sessionResources.find(sessionID);
552     if (it != m_sessionResources.end()) {
553         for (auto&amp; keyValue : *it-&gt;value) {
554             auto&amp; resource = *keyValue.value;
555             auto&amp; partitionName = keyValue.key.second;
556             if (!partitionName.isEmpty())
557                 origins.add(SecurityOrigin::create(&quot;http&quot;, partitionName, 0));
558             else
559                 origins.add(SecurityOrigin::create(resource.url()));
560         }
561     }
562 
563     return origins;
564 }
565 
566 void MemoryCache::removeFromLiveDecodedResourcesList(CachedResource&amp; resource)
567 {
568     m_liveDecodedResources.remove(&amp;resource);
569 }
570 
571 void MemoryCache::insertInLiveDecodedResourcesList(CachedResource&amp; resource)
572 {
573     // Make sure we aren&#39;t in the list already.
574     ASSERT(!m_liveDecodedResources.contains(&amp;resource));
575     m_liveDecodedResources.add(&amp;resource);
576 }
577 
578 void MemoryCache::addToLiveResourcesSize(CachedResource&amp; resource)
579 {
580     m_liveSize += resource.size();
581     m_deadSize -= resource.size();
582 }
583 
584 void MemoryCache::removeFromLiveResourcesSize(CachedResource&amp; resource)
585 {
586     m_liveSize -= resource.size();
587     m_deadSize += resource.size();
588 }
589 
590 void MemoryCache::adjustSize(bool live, long long delta)
591 {
592     if (live) {
593         ASSERT(delta &gt;= 0 || (static_cast&lt;long long&gt;(m_liveSize) + delta &gt;= 0));
594         m_liveSize += delta;
595     } else {
596         ASSERT(delta &gt;= 0 || (static_cast&lt;long long&gt;(m_deadSize) + delta &gt;= 0));
597         m_deadSize += delta;
598     }
599 }
600 
601 void MemoryCache::removeRequestFromSessionCaches(ScriptExecutionContext&amp; context, const ResourceRequest&amp; request)
602 {
603     if (is&lt;WorkerGlobalScope&gt;(context)) {
604         downcast&lt;WorkerGlobalScope&gt;(context).thread().workerLoaderProxy().postTaskToLoader([request = request.isolatedCopy()] (ScriptExecutionContext&amp; context) {
605             MemoryCache::removeRequestFromSessionCaches(context, request);
606         });
607         return;
608     }
609 
610     auto&amp; memoryCache = MemoryCache::singleton();
611     for (auto&amp; resources : memoryCache.m_sessionResources) {
612         if (CachedResource* resource = memoryCache.resourceForRequestImpl(request, *resources.value))
613             memoryCache.remove(*resource);
614     }
615 }
616 
617 void MemoryCache::TypeStatistic::addResource(CachedResource&amp; resource)
618 {
619     count++;
620     size += resource.size();
621     liveSize += resource.hasClients() ? resource.size() : 0;
622     decodedSize += resource.decodedSize();
623 }
624 
625 MemoryCache::Statistics MemoryCache::getStatistics()
626 {
627     Statistics stats;
628 
629     for (auto&amp; resources : m_sessionResources.values()) {
630         for (auto* resource : resources-&gt;values()) {
631             switch (resource-&gt;type()) {
632             case CachedResource::Type::ImageResource:
633                 stats.images.addResource(*resource);
634                 break;
635             case CachedResource::Type::CSSStyleSheet:
636                 stats.cssStyleSheets.addResource(*resource);
637                 break;
638             case CachedResource::Type::Script:
639                 stats.scripts.addResource(*resource);
640                 break;
641 #if ENABLE(XSLT)
642             case CachedResource::Type::XSLStyleSheet:
643                 stats.xslStyleSheets.addResource(*resource);
644                 break;
645 #endif
646 #if ENABLE(SVG_FONTS)
647             case CachedResource::Type::SVGFontResource:
648 #endif
649             case CachedResource::Type::FontResource:
650                 stats.fonts.addResource(*resource);
651                 break;
652             default:
653                 break;
654             }
655         }
656     }
657     return stats;
658 }
659 
660 void MemoryCache::setDisabled(bool disabled)
661 {
662     m_disabled = disabled;
663     if (!m_disabled)
664         return;
665 
666     while (!m_sessionResources.isEmpty()) {
667         auto&amp; resources = *m_sessionResources.begin()-&gt;value;
668         ASSERT(!resources.isEmpty());
669         remove(*resources.begin()-&gt;value);
670     }
671 }
672 
673 void MemoryCache::evictResources()
674 {
675     if (disabled())
676         return;
677 
678     setDisabled(true);
679     setDisabled(false);
680 }
681 
682 void MemoryCache::evictResources(PAL::SessionID sessionID)
683 {
684     if (disabled())
685         return;
686 
687     forEachSessionResource(sessionID, [this] (CachedResource&amp; resource) { remove(resource); });
688 
689     ASSERT(!m_sessionResources.contains(sessionID));
690 }
691 
692 bool MemoryCache::needsPruning() const
693 {
694     return m_liveSize + m_deadSize &gt; m_capacity || m_deadSize &gt; m_maxDeadCapacity;
695 }
696 
697 void MemoryCache::prune()
698 {
699     if (!needsPruning())
700         return;
701 
702     pruneDeadResources(); // Prune dead first, in case it was &quot;borrowing&quot; capacity from live.
703     pruneLiveResources();
704 }
705 
706 void MemoryCache::pruneSoon()
707 {
708     if (m_pruneTimer.isActive())
709         return;
710     if (!needsPruning())
711         return;
712     m_pruneTimer.startOneShot(0_s);
713 }
714 
715 void MemoryCache::dumpStats()
716 {
717     Statistics s = getStatistics();
718     WTFLogAlways(&quot;\nMemory Cache&quot;);
719     WTFLogAlways(&quot;%-13s %-13s %-13s %-13s %-13s\n&quot;, &quot;&quot;, &quot;Count&quot;, &quot;Size&quot;, &quot;LiveSize&quot;, &quot;DecodedSize&quot;);
720     WTFLogAlways(&quot;%-13s %-13s %-13s %-13s %-13s\n&quot;, &quot;-------------&quot;, &quot;-------------&quot;, &quot;-------------&quot;, &quot;-------------&quot;, &quot;-------------&quot;);
721     WTFLogAlways(&quot;%-13s %13d %13d %13d %13d\n&quot;, &quot;Images&quot;, s.images.count, s.images.size, s.images.liveSize, s.images.decodedSize);
722     WTFLogAlways(&quot;%-13s %13d %13d %13d %13d\n&quot;, &quot;CSS&quot;, s.cssStyleSheets.count, s.cssStyleSheets.size, s.cssStyleSheets.liveSize, s.cssStyleSheets.decodedSize);
723 #if ENABLE(XSLT)
724     WTFLogAlways(&quot;%-13s %13d %13d %13d %13d\n&quot;, &quot;XSL&quot;, s.xslStyleSheets.count, s.xslStyleSheets.size, s.xslStyleSheets.liveSize, s.xslStyleSheets.decodedSize);
725 #endif
726     WTFLogAlways(&quot;%-13s %13d %13d %13d %13d\n&quot;, &quot;JavaScript&quot;, s.scripts.count, s.scripts.size, s.scripts.liveSize, s.scripts.decodedSize);
727     WTFLogAlways(&quot;%-13s %13d %13d %13d %13d\n&quot;, &quot;Fonts&quot;, s.fonts.count, s.fonts.size, s.fonts.liveSize, s.fonts.decodedSize);
728     WTFLogAlways(&quot;%-13s %-13s %-13s %-13s %-13s\n\n&quot;, &quot;-------------&quot;, &quot;-------------&quot;, &quot;-------------&quot;, &quot;-------------&quot;, &quot;-------------&quot;);
729 
730     unsigned countTotal = s.images.count + s.cssStyleSheets.count + s.scripts.count + s.fonts.count;
731     unsigned sizeTotal = s.images.size + s.cssStyleSheets.size + s.scripts.size + s.fonts.size;
732     unsigned liveSizeTotal = s.images.liveSize + s.cssStyleSheets.liveSize + s.scripts.liveSize + s.fonts.liveSize;
733     unsigned decodedSizeTotal = s.images.decodedSize + s.cssStyleSheets.decodedSize + s.scripts.decodedSize + s.fonts.decodedSize;
734 #if ENABLE(XSLT)
735     countTotal += s.xslStyleSheets.count;
736     sizeTotal += s.xslStyleSheets.size;
737     liveSizeTotal += s.xslStyleSheets.liveSize;
738     decodedSizeTotal += s.xslStyleSheets.decodedSize;
739 #endif
740 
741     WTFLogAlways(&quot;%-13s %13d %11.2fKB %11.2fKB %11.2fKB\n&quot;, &quot;Total&quot;, countTotal, sizeTotal / 1024., liveSizeTotal / 1024., decodedSizeTotal / 1024.);
742 }
743 
744 void MemoryCache::dumpLRULists(bool includeLive) const
745 {
746     WTFLogAlways(&quot;LRU-SP lists in eviction order (Kilobytes decoded, Kilobytes encoded, Access count, Referenced):\n&quot;);
747 
748     int size = m_allResources.size();
749     for (int i = size - 1; i &gt;= 0; i--) {
750         WTFLogAlways(&quot;\nList %d:\n&quot;, i);
751         for (auto* resource : *m_allResources[i]) {
752             if (includeLive || !resource-&gt;hasClients())
753                 WTFLogAlways(&quot;  %p %.255s %.1fK, %.1fK, accesses: %u, clients: %d\n&quot;, resource, resource-&gt;url().string().utf8().data(), resource-&gt;decodedSize() / 1024.0f, (resource-&gt;encodedSize() + resource-&gt;overheadSize()) / 1024.0f, resource-&gt;accessCount(), resource-&gt;numberOfClients());
754         }
755     }
756 }
757 
758 } // namespace WebCore
    </pre>
  </body>
</html>
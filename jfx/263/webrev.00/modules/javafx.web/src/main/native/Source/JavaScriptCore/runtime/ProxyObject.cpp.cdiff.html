<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ProxyObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ProxyConstructor.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProxyObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ProxyObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 49,22 ***</span>
  ProxyObject::ProxyObject(VM&amp; vm, Structure* structure)
      : Base(vm, structure)
  {
  }
  
<span class="line-modified">! String ProxyObject::toStringName(const JSObject* object, ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      const ProxyObject* proxy = jsCast&lt;const ProxyObject*&gt;(object);
      while (proxy) {
          const JSObject* target = proxy-&gt;target();
<span class="line-modified">!         bool targetIsArray = isArray(exec, target);</span>
          if (UNLIKELY(scope.exception()))
              break;
          if (targetIsArray)
<span class="line-modified">!             RELEASE_AND_RETURN(scope, target-&gt;classInfo(vm)-&gt;methodTable.toStringName(target, exec));</span>
  
          proxy = jsDynamicCast&lt;const ProxyObject*&gt;(vm, target);
      }
      return &quot;Object&quot;_s;
  }
<span class="line-new-header">--- 49,22 ---</span>
  ProxyObject::ProxyObject(VM&amp; vm, Structure* structure)
      : Base(vm, structure)
  {
  }
  
<span class="line-modified">! String ProxyObject::toStringName(const JSObject* object, JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      const ProxyObject* proxy = jsCast&lt;const ProxyObject*&gt;(object);
      while (proxy) {
          const JSObject* target = proxy-&gt;target();
<span class="line-modified">!         bool targetIsArray = isArray(globalObject, target);</span>
          if (UNLIKELY(scope.exception()))
              break;
          if (targetIsArray)
<span class="line-modified">!             RELEASE_AND_RETURN(scope, target-&gt;classInfo(vm)-&gt;methodTable.toStringName(target, globalObject));</span>
  
          proxy = jsDynamicCast&lt;const ProxyObject*&gt;(vm, target);
      }
      return &quot;Object&quot;_s;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,32 ***</span>
      VM&amp; vm = globalObject-&gt;vm();
      bool isCallable = targetAsObject-&gt;methodTable(vm)-&gt;getCallData(targetAsObject, ignoredCallData) != CallType::None;
      return isCallable ? globalObject-&gt;callableProxyObjectStructure() : globalObject-&gt;proxyObjectStructure();
  }
  
<span class="line-modified">! void ProxyObject::finishCreation(VM&amp; vm, ExecState* exec, JSValue target, JSValue handler)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      Base::finishCreation(vm);
      ASSERT(type() == ProxyObjectType);
      if (!target.isObject()) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;target&#39; should be an Object&quot;_s);</span>
          return;
      }
      if (ProxyObject* targetAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, target)) {
          if (targetAsProxy-&gt;isRevoked()) {
<span class="line-modified">!             throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;target&#39; shouldn&#39;t be a revoked Proxy&quot;_s);</span>
              return;
          }
      }
      if (!handler.isObject()) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;handler&#39; should be an Object&quot;_s);</span>
          return;
      }
      if (ProxyObject* handlerAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, handler)) {
          if (handlerAsProxy-&gt;isRevoked()) {
<span class="line-modified">!             throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;handler&#39; shouldn&#39;t be a revoked Proxy&quot;_s);</span>
              return;
          }
      }
  
      JSObject* targetAsObject = jsCast&lt;JSObject*&gt;(target);
<span class="line-new-header">--- 79,32 ---</span>
      VM&amp; vm = globalObject-&gt;vm();
      bool isCallable = targetAsObject-&gt;methodTable(vm)-&gt;getCallData(targetAsObject, ignoredCallData) != CallType::None;
      return isCallable ? globalObject-&gt;callableProxyObjectStructure() : globalObject-&gt;proxyObjectStructure();
  }
  
<span class="line-modified">! void ProxyObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, JSValue target, JSValue handler)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      Base::finishCreation(vm);
      ASSERT(type() == ProxyObjectType);
      if (!target.isObject()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;A Proxy&#39;s &#39;target&#39; should be an Object&quot;_s);</span>
          return;
      }
      if (ProxyObject* targetAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, target)) {
          if (targetAsProxy-&gt;isRevoked()) {
<span class="line-modified">!             throwTypeError(globalObject, scope, &quot;A Proxy&#39;s &#39;target&#39; shouldn&#39;t be a revoked Proxy&quot;_s);</span>
              return;
          }
      }
      if (!handler.isObject()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;A Proxy&#39;s &#39;handler&#39; should be an Object&quot;_s);</span>
          return;
      }
      if (ProxyObject* handlerAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, handler)) {
          if (handlerAsProxy-&gt;isRevoked()) {
<span class="line-modified">!             throwTypeError(globalObject, scope, &quot;A Proxy&#39;s &#39;handler&#39; shouldn&#39;t be a revoked Proxy&quot;_s);</span>
              return;
          }
      }
  
      JSObject* targetAsObject = jsCast&lt;JSObject*&gt;(target);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,330 ***</span>
      m_handler.set(vm, this, handler);
  }
  
  static const ASCIILiteral s_proxyAlreadyRevokedErrorMessage { &quot;Proxy has already been revoked. No more operations are allowed to be performed on it&quot;_s };
  
<span class="line-modified">! static JSValue performProxyGet(ExecState* exec, ProxyObject* proxyObject, JSValue receiver, PropertyName propertyName)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return { };
      }
  
      JSObject* target = proxyObject-&gt;target();
  
      auto performDefaultGet = [&amp;] {
          scope.release();
          PropertySlot slot(receiver, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!         bool hasProperty = target-&gt;getPropertySlot(exec, propertyName, slot);</span>
          EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
          if (hasProperty)
<span class="line-modified">!             RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));</span>
  
          return jsUndefined();
      };
  
      if (propertyName.isPrivateName())
          return jsUndefined();
  
      JSValue handlerValue = proxyObject-&gt;handler();
      if (handlerValue.isNull())
<span class="line-modified">!         return throwTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue getHandler = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;get, &quot;&#39;get&#39; property of a Proxy&#39;s handler object should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (getHandler.isUndefined())
          return performDefaultGet();
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
      arguments.append(receiver);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(exec, getHandler, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool result = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
      EXCEPTION_ASSERT(!scope.exception() || !result);
      if (result) {
          if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
<span class="line-modified">!             if (!sameValue(exec, descriptor.value(), trapResult))</span>
<span class="line-modified">!                 return throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable and non-writable property should be the same value as the target&#39;s property&quot;_s);</span>
          } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.getter().isUndefined()) {
              if (!trapResult.isUndefined())
<span class="line-modified">!                 return throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable accessor property without a getter should be undefined&quot;_s);</span>
          }
      }
  
      RETURN_IF_EXCEPTION(scope, { });
  
      return trapResult;
  }
  
<span class="line-modified">! bool ProxyObject::performGet(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue result = performProxyGet(exec, this, slot.thisValue(), propertyName);</span>
      RETURN_IF_EXCEPTION(scope, false);
      unsigned ignoredAttributes = 0;
      slot.setValue(this, ignoredAttributes, result);
      return true;
  }
  
<span class="line-modified">! bool ProxyObject::performInternalMethodGetOwnProperty(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return false;
      }
      JSObject* target = this-&gt;target();
  
      auto performDefaultGetOwnProperty = [&amp;] {
<span class="line-modified">!         return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);</span>
      };
  
      if (propertyName.isPrivateName())
          return false;
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue getOwnPropertyDescriptorMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;getOwnPropertyDescriptor&quot;), &quot;&#39;getOwnPropertyDescriptor&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (getOwnPropertyDescriptorMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultGetOwnProperty());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(exec, getOwnPropertyDescriptorMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!trapResult.isUndefined() &amp;&amp; !trapResult.isObject()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, &quot;result of &#39;getOwnPropertyDescriptor&#39; call should either be an Object or undefined&quot;_s);</span>
          return false;
      }
  
      PropertyDescriptor targetPropertyDescriptor;
<span class="line-modified">!     bool isTargetPropertyDescriptorDefined = target-&gt;getOwnPropertyDescriptor(exec, propertyName, targetPropertyDescriptor);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (trapResult.isUndefined()) {
          if (!isTargetPropertyDescriptorDefined)
              return false;
          if (!targetPropertyDescriptor.configurable()) {
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;When the result of &#39;getOwnPropertyDescriptor&#39; is undefined the target must be configurable&quot;_s);</span>
              return false;
          }
<span class="line-modified">!         // FIXME: this doesn&#39;t work if &#39;target&#39; is another Proxy. We don&#39;t have isExtensible implemented in a way that fits w/ Proxys.</span>
<span class="line-removed">-         // https://bugs.webkit.org/show_bug.cgi?id=154375</span>
<span class="line-removed">-         bool isExtensible = target-&gt;isExtensible(exec);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (!isExtensible) {
<span class="line-modified">!             // FIXME: Come up with a test for this error. I&#39;m not sure how to because</span>
<span class="line-removed">-             // Object.seal(o) will make all fields [[Configurable]] false.</span>
<span class="line-removed">-             // https://bugs.webkit.org/show_bug.cgi?id=154376</span>
<span class="line-removed">-             throwVMTypeError(exec, scope, &quot;When &#39;getOwnPropertyDescriptor&#39; returns undefined, the &#39;target&#39; of a Proxy should be extensible&quot;_s);</span>
              return false;
          }
  
          return false;
      }
  
<span class="line-modified">!     bool isExtensible = target-&gt;isExtensible(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
      PropertyDescriptor trapResultAsDescriptor;
<span class="line-modified">!     toPropertyDescriptor(exec, trapResult, trapResultAsDescriptor);</span>
      RETURN_IF_EXCEPTION(scope, false);
      bool throwException = false;
<span class="line-modified">!     bool valid = validateAndApplyPropertyDescriptor(exec, nullptr, propertyName, isExtensible,</span>
          trapResultAsDescriptor, isTargetPropertyDescriptorDefined, targetPropertyDescriptor, throwException);
      RETURN_IF_EXCEPTION(scope, false);
      if (!valid) {
<span class="line-modified">!         throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; fails the IsCompatiblePropertyDescriptor test&quot;_s);</span>
          return false;
      }
  
      if (!trapResultAsDescriptor.configurable()) {
          if (!isTargetPropertyDescriptorDefined || targetPropertyDescriptor.configurable()) {
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable when the &#39;target&#39; doesn&#39;t have it as an own property or if it is a configurable own property on &#39;target&#39;&quot;_s);</span>
              return false;
          }
          if (trapResultAsDescriptor.writablePresent() &amp;&amp; !trapResultAsDescriptor.writable() &amp;&amp; targetPropertyDescriptor.writable()) {
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable and non-writable when the target&#39;s property is writable&quot;_s);</span>
              return false;
          }
      }
  
      if (trapResultAsDescriptor.isAccessorDescriptor()) {
<span class="line-modified">!         GetterSetter* getterSetter = trapResultAsDescriptor.slowGetterSetter(exec);</span>
          RETURN_IF_EXCEPTION(scope, false);
          slot.setGetterSlot(this, trapResultAsDescriptor.attributes(), getterSetter);
      } else if (trapResultAsDescriptor.isDataDescriptor() &amp;&amp; !trapResultAsDescriptor.value().isEmpty())
          slot.setValue(this, trapResultAsDescriptor.attributes(), trapResultAsDescriptor.value());
      else
          slot.setValue(this, trapResultAsDescriptor.attributes(), jsUndefined()); // We use undefined because it&#39;s the default value in object properties.
  
      return true;
  }
  
<span class="line-modified">! bool ProxyObject::performHasProperty(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return false;
      }
      JSObject* target = this-&gt;target();
      slot.setValue(this, static_cast&lt;unsigned&gt;(PropertyAttribute::None), jsUndefined()); // Nobody should rely on our value, but be safe and protect against any bad actors reading our value.
  
      auto performDefaultHasProperty = [&amp;] {
<span class="line-modified">!         return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);</span>
      };
  
      if (propertyName.isPrivateName())
          return false;
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue hasMethod = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;has, &quot;&#39;has&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (hasMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultHasProperty());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(exec, hasMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!trapResultAsBool) {
          PropertyDescriptor descriptor;
<span class="line-modified">!         bool isPropertyDescriptorDefined = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (isPropertyDescriptorDefined) {
              if (!descriptor.configurable()) {
<span class="line-modified">!                 throwVMTypeError(exec, scope, &quot;Proxy &#39;has&#39; must return &#39;true&#39; for non-configurable properties&quot;_s);</span>
                  return false;
              }
<span class="line-modified">!             bool isExtensible = target-&gt;isExtensible(exec);</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (!isExtensible) {
<span class="line-modified">!                 throwVMTypeError(exec, scope, &quot;Proxy &#39;has&#39; must return &#39;true&#39; for a non-extensible &#39;target&#39; object with a configurable property&quot;_s);</span>
                  return false;
              }
          }
      }
  
      return trapResultAsBool;
  }
  
<span class="line-modified">! bool ProxyObject::getOwnPropertySlotCommon(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      slot.disableCaching();
      slot.setIsTaintedByOpaqueObject();
  
      if (slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry)
          return false;
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return false;
      }
      switch (slot.internalMethodType()) {
      case PropertySlot::InternalMethodType::Get:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, performGet(exec, propertyName, slot));</span>
      case PropertySlot::InternalMethodType::GetOwnProperty:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, performInternalMethodGetOwnProperty(exec, propertyName, slot));</span>
      case PropertySlot::InternalMethodType::HasProperty:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, performHasProperty(exec, propertyName, slot));</span>
      default:
          return false;
      }
  
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="line-modified">! bool ProxyObject::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified">!     return thisObject-&gt;getOwnPropertySlotCommon(exec, propertyName, slot);</span>
  }
  
<span class="line-modified">! bool ProxyObject::getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
      Identifier ident = Identifier::from(vm, propertyName);
<span class="line-modified">!     return thisObject-&gt;getOwnPropertySlotCommon(exec, ident.impl(), slot);</span>
  }
  
  template &lt;typename PerformDefaultPutFunction&gt;
<span class="line-modified">! bool ProxyObject::performPut(ExecState* exec, JSValue putValue, JSValue thisValue, PropertyName propertyName, PerformDefaultPutFunction performDefaultPut, bool shouldThrow)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return false;
      }
  
      if (propertyName.isPrivateName())
          return false;
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue setMethod = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;set, &quot;&#39;set&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
      JSObject* target = this-&gt;target();
      if (setMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultPut());
  
<span class="line-new-header">--- 122,327 ---</span>
      m_handler.set(vm, this, handler);
  }
  
  static const ASCIILiteral s_proxyAlreadyRevokedErrorMessage { &quot;Proxy has already been revoked. No more operations are allowed to be performed on it&quot;_s };
  
<span class="line-modified">! static JSValue performProxyGet(JSGlobalObject* globalObject, ProxyObject* proxyObject, JSValue receiver, PropertyName propertyName)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return { };
      }
  
      JSObject* target = proxyObject-&gt;target();
  
      auto performDefaultGet = [&amp;] {
          scope.release();
          PropertySlot slot(receiver, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!         bool hasProperty = target-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
          EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
          if (hasProperty)
<span class="line-modified">!             RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));</span>
  
          return jsUndefined();
      };
  
      if (propertyName.isPrivateName())
          return jsUndefined();
  
      JSValue handlerValue = proxyObject-&gt;handler();
      if (handlerValue.isNull())
<span class="line-modified">!         return throwTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue getHandler = handler-&gt;getMethod(globalObject, callData, callType, vm.propertyNames-&gt;get, &quot;&#39;get&#39; property of a Proxy&#39;s handler object should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (getHandler.isUndefined())
          return performDefaultGet();
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
      arguments.append(receiver);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(globalObject, getHandler, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool result = target-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor);</span>
      EXCEPTION_ASSERT(!scope.exception() || !result);
      if (result) {
          if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
<span class="line-modified">!             bool isSame = sameValue(globalObject, descriptor.value(), trapResult);</span>
<span class="line-modified">!             RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+             if (!isSame)</span>
<span class="line-added">+                 return throwTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable and non-writable property should be the same value as the target&#39;s property&quot;_s);</span>
          } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.getter().isUndefined()) {
              if (!trapResult.isUndefined())
<span class="line-modified">!                 return throwTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable accessor property without a getter should be undefined&quot;_s);</span>
          }
      }
  
      RETURN_IF_EXCEPTION(scope, { });
  
      return trapResult;
  }
  
<span class="line-modified">! bool ProxyObject::performGet(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue result = performProxyGet(globalObject, this, slot.thisValue(), propertyName);</span>
      RETURN_IF_EXCEPTION(scope, false);
      unsigned ignoredAttributes = 0;
      slot.setValue(this, ignoredAttributes, result);
      return true;
  }
  
<span class="line-modified">! bool ProxyObject::performInternalMethodGetOwnProperty(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return false;
      }
      JSObject* target = this-&gt;target();
  
      auto performDefaultGetOwnProperty = [&amp;] {
<span class="line-modified">!         return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, globalObject, propertyName, slot);</span>
      };
  
      if (propertyName.isPrivateName())
          return false;
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue getOwnPropertyDescriptorMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;getOwnPropertyDescriptor&quot;), &quot;&#39;getOwnPropertyDescriptor&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (getOwnPropertyDescriptorMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultGetOwnProperty());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(globalObject, getOwnPropertyDescriptorMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!trapResult.isUndefined() &amp;&amp; !trapResult.isObject()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, &quot;result of &#39;getOwnPropertyDescriptor&#39; call should either be an Object or undefined&quot;_s);</span>
          return false;
      }
  
      PropertyDescriptor targetPropertyDescriptor;
<span class="line-modified">!     bool isTargetPropertyDescriptorDefined = target-&gt;getOwnPropertyDescriptor(globalObject, propertyName, targetPropertyDescriptor);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (trapResult.isUndefined()) {
          if (!isTargetPropertyDescriptorDefined)
              return false;
          if (!targetPropertyDescriptor.configurable()) {
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;When the result of &#39;getOwnPropertyDescriptor&#39; is undefined the target must be configurable&quot;_s);</span>
              return false;
          }
<span class="line-modified">!         bool isExtensible = target-&gt;isExtensible(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (!isExtensible) {
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;When &#39;getOwnPropertyDescriptor&#39; returns undefined, the &#39;target&#39; of a Proxy should be extensible&quot;_s);</span>
              return false;
          }
  
          return false;
      }
  
<span class="line-modified">!     bool isExtensible = target-&gt;isExtensible(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
      PropertyDescriptor trapResultAsDescriptor;
<span class="line-modified">!     toPropertyDescriptor(globalObject, trapResult, trapResultAsDescriptor);</span>
      RETURN_IF_EXCEPTION(scope, false);
      bool throwException = false;
<span class="line-modified">!     bool valid = validateAndApplyPropertyDescriptor(globalObject, nullptr, propertyName, isExtensible,</span>
          trapResultAsDescriptor, isTargetPropertyDescriptorDefined, targetPropertyDescriptor, throwException);
      RETURN_IF_EXCEPTION(scope, false);
      if (!valid) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; fails the IsCompatiblePropertyDescriptor test&quot;_s);</span>
          return false;
      }
  
      if (!trapResultAsDescriptor.configurable()) {
          if (!isTargetPropertyDescriptorDefined || targetPropertyDescriptor.configurable()) {
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable when the &#39;target&#39; doesn&#39;t have it as an own property or if it is a configurable own property on &#39;target&#39;&quot;_s);</span>
              return false;
          }
          if (trapResultAsDescriptor.writablePresent() &amp;&amp; !trapResultAsDescriptor.writable() &amp;&amp; targetPropertyDescriptor.writable()) {
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable and non-writable when the target&#39;s property is writable&quot;_s);</span>
              return false;
          }
      }
  
      if (trapResultAsDescriptor.isAccessorDescriptor()) {
<span class="line-modified">!         GetterSetter* getterSetter = trapResultAsDescriptor.slowGetterSetter(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          slot.setGetterSlot(this, trapResultAsDescriptor.attributes(), getterSetter);
      } else if (trapResultAsDescriptor.isDataDescriptor() &amp;&amp; !trapResultAsDescriptor.value().isEmpty())
          slot.setValue(this, trapResultAsDescriptor.attributes(), trapResultAsDescriptor.value());
      else
          slot.setValue(this, trapResultAsDescriptor.attributes(), jsUndefined()); // We use undefined because it&#39;s the default value in object properties.
  
      return true;
  }
  
<span class="line-modified">! bool ProxyObject::performHasProperty(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return false;
      }
      JSObject* target = this-&gt;target();
      slot.setValue(this, static_cast&lt;unsigned&gt;(PropertyAttribute::None), jsUndefined()); // Nobody should rely on our value, but be safe and protect against any bad actors reading our value.
  
      auto performDefaultHasProperty = [&amp;] {
<span class="line-modified">!         return target-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
      };
  
      if (propertyName.isPrivateName())
          return false;
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue hasMethod = handler-&gt;getMethod(globalObject, callData, callType, vm.propertyNames-&gt;has, &quot;&#39;has&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (hasMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultHasProperty());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(globalObject, hasMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!trapResultAsBool) {
          PropertyDescriptor descriptor;
<span class="line-modified">!         bool isPropertyDescriptorDefined = target-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (isPropertyDescriptorDefined) {
              if (!descriptor.configurable()) {
<span class="line-modified">!                 throwVMTypeError(globalObject, scope, &quot;Proxy &#39;has&#39; must return &#39;true&#39; for non-configurable properties&quot;_s);</span>
                  return false;
              }
<span class="line-modified">!             bool isExtensible = target-&gt;isExtensible(globalObject);</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (!isExtensible) {
<span class="line-modified">!                 throwVMTypeError(globalObject, scope, &quot;Proxy &#39;has&#39; must return &#39;true&#39; for a non-extensible &#39;target&#39; object with a configurable property&quot;_s);</span>
                  return false;
              }
          }
      }
  
      return trapResultAsBool;
  }
  
<span class="line-modified">! bool ProxyObject::getOwnPropertySlotCommon(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      slot.disableCaching();
      slot.setIsTaintedByOpaqueObject();
  
      if (slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry)
          return false;
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return false;
      }
      switch (slot.internalMethodType()) {
      case PropertySlot::InternalMethodType::Get:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, performGet(globalObject, propertyName, slot));</span>
      case PropertySlot::InternalMethodType::GetOwnProperty:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, performInternalMethodGetOwnProperty(globalObject, propertyName, slot));</span>
      case PropertySlot::InternalMethodType::HasProperty:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, performHasProperty(globalObject, propertyName, slot));</span>
      default:
          return false;
      }
  
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="line-modified">! bool ProxyObject::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified">!     return thisObject-&gt;getOwnPropertySlotCommon(globalObject, propertyName, slot);</span>
  }
  
<span class="line-modified">! bool ProxyObject::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* globalObject, unsigned propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
      Identifier ident = Identifier::from(vm, propertyName);
<span class="line-modified">!     return thisObject-&gt;getOwnPropertySlotCommon(globalObject, ident.impl(), slot);</span>
  }
  
  template &lt;typename PerformDefaultPutFunction&gt;
<span class="line-modified">! bool ProxyObject::performPut(JSGlobalObject* globalObject, JSValue putValue, JSValue thisValue, PropertyName propertyName, PerformDefaultPutFunction performDefaultPut, bool shouldThrow)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return false;
      }
  
      if (propertyName.isPrivateName())
          return false;
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue setMethod = handler-&gt;getMethod(globalObject, callData, callType, vm.propertyNames-&gt;set, &quot;&#39;set&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
      JSObject* target = this-&gt;target();
      if (setMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultPut());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 453,107 ***</span>
      arguments.append(target);
      arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
      arguments.append(putValue);
      arguments.append(thisValue);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(exec, setMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (!trapResultAsBool) {
          if (shouldThrow)
<span class="line-modified">!             throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s &#39;set&#39; trap returned falsy value for property &#39;&quot;, String(propertyName.uid()), &quot;&#39;&quot;));</span>
          return false;
      }
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool hasProperty = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
          if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
<span class="line-modified">!             if (!sameValue(exec, descriptor.value(), putValue)) {</span>
<span class="line-modified">!                 throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;set&#39; on a non-configurable and non-writable property on &#39;target&#39; should either return false or be the same value already on the &#39;target&#39;&quot;_s);</span>
                  return false;
              }
          } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.setter().isUndefined()) {
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;set&#39; method on a non-configurable accessor property without a setter should return false&quot;_s);</span>
              return false;
          }
      }
      return true;
  }
  
<span class="line-modified">! bool ProxyObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      slot.disableCaching();
  
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
      auto performDefaultPut = [&amp;] () {
          JSObject* target = jsCast&lt;JSObject*&gt;(thisObject-&gt;target());
<span class="line-modified">!         return target-&gt;methodTable(vm)-&gt;put(target, exec, propertyName, value, slot);</span>
      };
<span class="line-modified">!     return thisObject-&gt;performPut(exec, value, slot.thisValue(), propertyName, performDefaultPut, slot.isStrictMode());</span>
  }
  
<span class="line-modified">! bool ProxyObject::putByIndexCommon(ExecState* exec, JSValue thisValue, unsigned propertyName, JSValue putValue, bool shouldThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      Identifier ident = Identifier::from(vm, propertyName);
      RETURN_IF_EXCEPTION(scope, false);
      auto performDefaultPut = [&amp;] () {
          JSObject* target = this-&gt;target();
          bool isStrictMode = shouldThrow;
          PutPropertySlot slot(thisValue, isStrictMode); // We must preserve the &quot;this&quot; target of the putByIndex.
<span class="line-modified">!         return target-&gt;methodTable(vm)-&gt;put(target, exec, ident.impl(), putValue, slot);</span>
      };
<span class="line-modified">!     RELEASE_AND_RETURN(scope, performPut(exec, putValue, thisValue, ident.impl(), performDefaultPut, shouldThrow));</span>
  }
  
<span class="line-modified">! bool ProxyObject::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)</span>
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
<span class="line-modified">!     return thisObject-&gt;putByIndexCommon(exec, thisObject, propertyName, value, shouldThrow);</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL performProxyCall(ExecState* exec)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return encodedJSValue();
      }
<span class="line-modified">!     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(exec-&gt;jsCallee());</span>
      JSValue handlerValue = proxy-&gt;handler();
      if (handlerValue.isNull())
<span class="line-modified">!         return throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue applyMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;apply&quot;), &quot;&#39;apply&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      JSObject* target = proxy-&gt;target();
      if (applyMethod.isUndefined()) {
          CallData callData;
          CallType callType = target-&gt;methodTable(vm)-&gt;getCallData(target, callData);
          RELEASE_ASSERT(callType != CallType::None);
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, target, callType, callData, exec-&gt;thisValue(), ArgList(exec))));</span>
      }
  
<span class="line-modified">!     JSArray* argArray = constructArray(exec, static_cast&lt;ArrayAllocationProfile*&gt;(nullptr), ArgList(exec));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(exec-&gt;thisValue().toThis(exec, ECMAMode::StrictMode));</span>
      arguments.append(argArray);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, applyMethod, callType, callData, handler, arguments)));</span>
  }
  
  CallType ProxyObject::getCallData(JSCell* cell, CallData&amp; callData)
  {
      ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(cell);
<span class="line-new-header">--- 450,109 ---</span>
      arguments.append(target);
      arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
      arguments.append(putValue);
      arguments.append(thisValue);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(globalObject, setMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (!trapResultAsBool) {
          if (shouldThrow)
<span class="line-modified">!             throwVMTypeError(globalObject, scope, makeString(&quot;Proxy object&#39;s &#39;set&#39; trap returned falsy value for property &#39;&quot;, String(propertyName.uid()), &quot;&#39;&quot;));</span>
          return false;
      }
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool hasProperty = target-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
          if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
<span class="line-modified">!             bool isSame = sameValue(globalObject, descriptor.value(), putValue);</span>
<span class="line-modified">!             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+             if (!isSame) {</span>
<span class="line-added">+                 throwVMTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;set&#39; on a non-configurable and non-writable property on &#39;target&#39; should either return false or be the same value already on the &#39;target&#39;&quot;_s);</span>
                  return false;
              }
          } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.setter().isUndefined()) {
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;set&#39; method on a non-configurable accessor property without a setter should return false&quot;_s);</span>
              return false;
          }
      }
      return true;
  }
  
<span class="line-modified">! bool ProxyObject::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      slot.disableCaching();
  
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
      auto performDefaultPut = [&amp;] () {
          JSObject* target = jsCast&lt;JSObject*&gt;(thisObject-&gt;target());
<span class="line-modified">!         return target-&gt;methodTable(vm)-&gt;put(target, globalObject, propertyName, value, slot);</span>
      };
<span class="line-modified">!     return thisObject-&gt;performPut(globalObject, value, slot.thisValue(), propertyName, performDefaultPut, slot.isStrictMode());</span>
  }
  
<span class="line-modified">! bool ProxyObject::putByIndexCommon(JSGlobalObject* globalObject, JSValue thisValue, unsigned propertyName, JSValue putValue, bool shouldThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      Identifier ident = Identifier::from(vm, propertyName);
      RETURN_IF_EXCEPTION(scope, false);
      auto performDefaultPut = [&amp;] () {
          JSObject* target = this-&gt;target();
          bool isStrictMode = shouldThrow;
          PutPropertySlot slot(thisValue, isStrictMode); // We must preserve the &quot;this&quot; target of the putByIndex.
<span class="line-modified">!         return target-&gt;methodTable(vm)-&gt;put(target, globalObject, ident.impl(), putValue, slot);</span>
      };
<span class="line-modified">!     RELEASE_AND_RETURN(scope, performPut(globalObject, putValue, thisValue, ident.impl(), performDefaultPut, shouldThrow));</span>
  }
  
<span class="line-modified">! bool ProxyObject::putByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool shouldThrow)</span>
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
<span class="line-modified">!     return thisObject-&gt;putByIndexCommon(globalObject, thisObject, propertyName, value, shouldThrow);</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL performProxyCall(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return encodedJSValue();
      }
<span class="line-modified">!     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(callFrame-&gt;jsCallee());</span>
      JSValue handlerValue = proxy-&gt;handler();
      if (handlerValue.isNull())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue applyMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;apply&quot;), &quot;&#39;apply&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      JSObject* target = proxy-&gt;target();
      if (applyMethod.isUndefined()) {
          CallData callData;
          CallType callType = target-&gt;methodTable(vm)-&gt;getCallData(target, callData);
          RELEASE_ASSERT(callType != CallType::None);
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(call(globalObject, target, callType, callData, callFrame-&gt;thisValue(), ArgList(callFrame))));</span>
      }
  
<span class="line-modified">!     JSArray* argArray = constructArray(globalObject, static_cast&lt;ArrayAllocationProfile*&gt;(nullptr), ArgList(callFrame));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      MarkedArgumentBuffer arguments;
      arguments.append(target);
<span class="line-modified">!     arguments.append(callFrame-&gt;thisValue().toThis(globalObject, ECMAMode::StrictMode));</span>
      arguments.append(argArray);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(call(globalObject, applyMethod, callType, callData, handler, arguments)));</span>
  }
  
  CallType ProxyObject::getCallData(JSCell* cell, CallData&amp; callData)
  {
      ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(cell);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 565,49 ***</span>
  
      callData.native.function = performProxyCall;
      return CallType::Host;
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL performProxyConstruct(ExecState* exec)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return encodedJSValue();
      }
<span class="line-modified">!     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(exec-&gt;jsCallee());</span>
      JSValue handlerValue = proxy-&gt;handler();
      if (handlerValue.isNull())
<span class="line-modified">!         return throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue constructMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;construct&quot;), &quot;&#39;construct&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      JSObject* target = proxy-&gt;target();
      if (constructMethod.isUndefined()) {
          ConstructData constructData;
          ConstructType constructType = target-&gt;methodTable(vm)-&gt;getConstructData(target, constructData);
          RELEASE_ASSERT(constructType != ConstructType::None);
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(construct(exec, target, constructType, constructData, ArgList(exec), exec-&gt;newTarget())));</span>
      }
  
<span class="line-modified">!     JSArray* argArray = constructArray(exec, static_cast&lt;ArrayAllocationProfile*&gt;(nullptr), ArgList(exec));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(argArray);
<span class="line-modified">!     arguments.append(exec-&gt;newTarget());</span>
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue result = call(exec, constructMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (!result.isObject())
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Result from Proxy handler&#39;s &#39;construct&#39; method should be an object&quot;_s);</span>
      return JSValue::encode(result);
  }
  
  ConstructType ProxyObject::getConstructData(JSCell* cell, ConstructData&amp; constructData)
  {
<span class="line-new-header">--- 564,49 ---</span>
  
      callData.native.function = performProxyCall;
      return CallType::Host;
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL performProxyConstruct(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return encodedJSValue();
      }
<span class="line-modified">!     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(callFrame-&gt;jsCallee());</span>
      JSValue handlerValue = proxy-&gt;handler();
      if (handlerValue.isNull())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue constructMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;construct&quot;), &quot;&#39;construct&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      JSObject* target = proxy-&gt;target();
      if (constructMethod.isUndefined()) {
          ConstructData constructData;
          ConstructType constructType = target-&gt;methodTable(vm)-&gt;getConstructData(target, constructData);
          RELEASE_ASSERT(constructType != ConstructType::None);
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(construct(globalObject, target, constructType, constructData, ArgList(callFrame), callFrame-&gt;newTarget())));</span>
      }
  
<span class="line-modified">!     JSArray* argArray = constructArray(globalObject, static_cast&lt;ArrayAllocationProfile*&gt;(nullptr), ArgList(callFrame));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(argArray);
<span class="line-modified">!     arguments.append(callFrame-&gt;newTarget());</span>
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue result = call(globalObject, constructMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (!result.isObject())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Result from Proxy handler&#39;s &#39;construct&#39; method should be an object&quot;_s);</span>
      return JSValue::encode(result);
  }
  
  ConstructType ProxyObject::getConstructData(JSCell* cell, ConstructData&amp; constructData)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 621,346 ***</span>
      constructData.native.function = performProxyConstruct;
      return ConstructType::Host;
  }
  
  template &lt;typename DefaultDeleteFunction&gt;
<span class="line-modified">! bool ProxyObject::performDelete(ExecState* exec, PropertyName propertyName, DefaultDeleteFunction performDefaultDelete)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return false;
      }
  
      if (propertyName.isPrivateName())
          return false;
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue deletePropertyMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;deleteProperty&quot;), &quot;&#39;deleteProperty&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
      JSObject* target = this-&gt;target();
      if (deletePropertyMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultDelete());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(exec, deletePropertyMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!trapResultAsBool)
          return false;
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool result = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
      EXCEPTION_ASSERT(!scope.exception() || !result);
      if (result) {
          if (!descriptor.configurable()) {
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target&#39;s property is not configurable&quot;_s);</span>
              return false;
          }
<span class="line-modified">!         bool targetIsExtensible = target-&gt;isExtensible(exec);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (!targetIsExtensible) {
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target has property and is not extensible&quot;_s);</span>
              return false;
          }
      }
  
      RETURN_IF_EXCEPTION(scope, false);
  
      return true;
  }
  
<span class="line-modified">! bool ProxyObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
      auto performDefaultDelete = [&amp;] () -&gt; bool {
          JSObject* target = thisObject-&gt;target();
<span class="line-modified">!         return target-&gt;methodTable(exec-&gt;vm())-&gt;deleteProperty(target, exec, propertyName);</span>
      };
<span class="line-modified">!     return thisObject-&gt;performDelete(exec, propertyName, performDefaultDelete);</span>
  }
  
<span class="line-modified">! bool ProxyObject::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
      Identifier ident = Identifier::from(vm, propertyName);
      auto performDefaultDelete = [&amp;] () -&gt; bool {
          JSObject* target = thisObject-&gt;target();
<span class="line-modified">!         return target-&gt;methodTable(vm)-&gt;deletePropertyByIndex(target, exec, propertyName);</span>
      };
<span class="line-modified">!     return thisObject-&gt;performDelete(exec, ident.impl(), performDefaultDelete);</span>
  }
  
<span class="line-modified">! bool ProxyObject::performPreventExtensions(ExecState* exec)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return false;
      }
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue preventExtensionsMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;preventExtensions&quot;), &quot;&#39;preventExtensions&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
      JSObject* target = this-&gt;target();
      if (preventExtensionsMethod.isUndefined())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, target-&gt;methodTable(vm)-&gt;preventExtensions(target, exec));</span>
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(exec, preventExtensionsMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (trapResultAsBool) {
<span class="line-modified">!         bool targetIsExtensible = target-&gt;isExtensible(exec);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (targetIsExtensible) {
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;preventExtensions&#39; trap returned true even though its target is extensible. It should have returned false&quot;_s);</span>
              return false;
          }
      }
  
      return trapResultAsBool;
  }
  
<span class="line-modified">! bool ProxyObject::preventExtensions(JSObject* object, ExecState* exec)</span>
  {
<span class="line-modified">!     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performPreventExtensions(exec);</span>
  }
  
<span class="line-modified">! bool ProxyObject::performIsExtensible(ExecState* exec)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return false;
      }
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue isExtensibleMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;isExtensible&quot;), &quot;&#39;isExtensible&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      JSObject* target = this-&gt;target();
      if (isExtensibleMethod.isUndefined())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, target-&gt;isExtensible(exec));</span>
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(exec, isExtensibleMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool isTargetExtensible = target-&gt;isExtensible(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (trapResultAsBool != isTargetExtensible) {
          if (isTargetExtensible) {
              ASSERT(!trapResultAsBool);
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Proxy object&#39;s &#39;isExtensible&#39; trap returned false when the target is extensible. It should have returned true&quot;_s);</span>
          } else {
              ASSERT(!isTargetExtensible);
              ASSERT(trapResultAsBool);
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Proxy object&#39;s &#39;isExtensible&#39; trap returned true when the target is non-extensible. It should have returned false&quot;_s);</span>
          }
      }
  
      return trapResultAsBool;
  }
  
<span class="line-modified">! bool ProxyObject::isExtensible(JSObject* object, ExecState* exec)</span>
  {
<span class="line-modified">!     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performIsExtensible(exec);</span>
  }
  
<span class="line-modified">! bool ProxyObject::performDefineOwnProperty(ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return false;
      }
  
      JSObject* target = this-&gt;target();
      auto performDefaultDefineOwnProperty = [&amp;] {
<span class="line-modified">!         RELEASE_AND_RETURN(scope, target-&gt;methodTable(vm)-&gt;defineOwnProperty(target, exec, propertyName, descriptor, shouldThrow));</span>
      };
  
      if (propertyName.isPrivateName())
          return false;
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue definePropertyMethod = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;defineProperty, &quot;&#39;defineProperty&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (definePropertyMethod.isUndefined())
          return performDefaultDefineOwnProperty();
  
<span class="line-modified">!     JSObject* descriptorObject = constructObjectFromPropertyDescriptor(exec, descriptor);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
      arguments.append(descriptorObject);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(exec, definePropertyMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!trapResultAsBool)
          return false;
  
      PropertyDescriptor targetDescriptor;
<span class="line-modified">!     bool isTargetDescriptorDefined = target-&gt;getOwnPropertyDescriptor(exec, propertyName, targetDescriptor);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool targetIsExtensible = target-&gt;isExtensible(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
      bool settingConfigurableToFalse = descriptor.configurablePresent() &amp;&amp; !descriptor.configurable();
  
      if (!isTargetDescriptorDefined) {
          if (!targetIsExtensible) {
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true even though getOwnPropertyDescriptor of the Proxy&#39;s target returned undefined and the target is non-extensible&quot;_s);</span>
              return false;
          }
          if (settingConfigurableToFalse) {
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true for a non-configurable field even though getOwnPropertyDescriptor of the Proxy&#39;s target returned undefined&quot;_s);</span>
              return false;
          }
  
          return true;
      }
  
      ASSERT(isTargetDescriptorDefined);
      bool isCurrentDefined = isTargetDescriptorDefined;
      const PropertyDescriptor&amp; current = targetDescriptor;
      bool throwException = false;
<span class="line-modified">!     bool isCompatibleDescriptor = validateAndApplyPropertyDescriptor(exec, nullptr, propertyName, targetIsExtensible, descriptor, isCurrentDefined, current, throwException);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (!isCompatibleDescriptor) {
<span class="line-modified">!         throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a property on its target that is compatible with the trap&#39;s input descriptor&quot;_s);</span>
          return false;
      }
      if (settingConfigurableToFalse &amp;&amp; targetDescriptor.configurable()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a non-configurable property on its target even though the input descriptor to the trap said it must do so&quot;_s);</span>
          return false;
      }
      if (targetDescriptor.isDataDescriptor() &amp;&amp; !targetDescriptor.configurable() &amp;&amp; targetDescriptor.writable()) {
          if (descriptor.writablePresent() &amp;&amp; !descriptor.writable()) {
<span class="line-modified">!             throwTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true for a non-writable input descriptor when the target&#39;s property is non-configurable and writable&quot;_s);</span>
              return false;
          }
      }
  
      return true;
  }
  
<span class="line-modified">! bool ProxyObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified">!     return thisObject-&gt;performDefineOwnProperty(exec, propertyName, descriptor, shouldThrow);</span>
  }
  
<span class="line-modified">! void ProxyObject::performGetOwnPropertyNames(ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode enumerationMode)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return;
      }
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue ownKeysMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;ownKeys&quot;), &quot;&#39;ownKeys&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, void());
      JSObject* target = this-&gt;target();
      if (ownKeysMethod.isUndefined()) {
          scope.release();
<span class="line-modified">!         target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, propertyNames, enumerationMode);</span>
          return;
      }
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue arrayLikeObject = call(exec, ownKeysMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-removed">-     PropertyNameArray trapResult(vm, propertyNames.propertyNameMode(), propertyNames.privateSymbolMode());</span>
      HashSet&lt;UniquedStringImpl*&gt; uncheckedResultKeys;
      {
<span class="line-removed">-         HashSet&lt;RefPtr&lt;UniquedStringImpl&gt;&gt; seenKeys;</span>
<span class="line-removed">- </span>
          RuntimeTypeMask resultFilter = 0;
          switch (propertyNames.propertyNameMode()) {
          case PropertyNameMode::Symbols:
              resultFilter = TypeSymbol;
              break;
<span class="line-new-header">--- 620,344 ---</span>
      constructData.native.function = performProxyConstruct;
      return ConstructType::Host;
  }
  
  template &lt;typename DefaultDeleteFunction&gt;
<span class="line-modified">! bool ProxyObject::performDelete(JSGlobalObject* globalObject, PropertyName propertyName, DefaultDeleteFunction performDefaultDelete)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return false;
      }
  
      if (propertyName.isPrivateName())
          return false;
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue deletePropertyMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;deleteProperty&quot;), &quot;&#39;deleteProperty&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
      JSObject* target = this-&gt;target();
      if (deletePropertyMethod.isUndefined())
          RELEASE_AND_RETURN(scope, performDefaultDelete());
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(globalObject, deletePropertyMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!trapResultAsBool)
          return false;
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool result = target-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor);</span>
      EXCEPTION_ASSERT(!scope.exception() || !result);
      if (result) {
          if (!descriptor.configurable()) {
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target&#39;s property is not configurable&quot;_s);</span>
              return false;
          }
<span class="line-modified">!         bool targetIsExtensible = target-&gt;isExtensible(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (!targetIsExtensible) {
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target has property and is not extensible&quot;_s);</span>
              return false;
          }
      }
  
      RETURN_IF_EXCEPTION(scope, false);
  
      return true;
  }
  
<span class="line-modified">! bool ProxyObject::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
      auto performDefaultDelete = [&amp;] () -&gt; bool {
          JSObject* target = thisObject-&gt;target();
<span class="line-modified">!         return target-&gt;methodTable(globalObject-&gt;vm())-&gt;deleteProperty(target, globalObject, propertyName);</span>
      };
<span class="line-modified">!     return thisObject-&gt;performDelete(globalObject, propertyName, performDefaultDelete);</span>
  }
  
<span class="line-modified">! bool ProxyObject::deletePropertyByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
      Identifier ident = Identifier::from(vm, propertyName);
      auto performDefaultDelete = [&amp;] () -&gt; bool {
          JSObject* target = thisObject-&gt;target();
<span class="line-modified">!         return target-&gt;methodTable(vm)-&gt;deletePropertyByIndex(target, globalObject, propertyName);</span>
      };
<span class="line-modified">!     return thisObject-&gt;performDelete(globalObject, ident.impl(), performDefaultDelete);</span>
  }
  
<span class="line-modified">! bool ProxyObject::performPreventExtensions(JSGlobalObject* globalObject)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return false;
      }
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue preventExtensionsMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;preventExtensions&quot;), &quot;&#39;preventExtensions&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
      JSObject* target = this-&gt;target();
      if (preventExtensionsMethod.isUndefined())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, target-&gt;methodTable(vm)-&gt;preventExtensions(target, globalObject));</span>
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(globalObject, preventExtensionsMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (trapResultAsBool) {
<span class="line-modified">!         bool targetIsExtensible = target-&gt;isExtensible(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (targetIsExtensible) {
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;preventExtensions&#39; trap returned true even though its target is extensible. It should have returned false&quot;_s);</span>
              return false;
          }
      }
  
      return trapResultAsBool;
  }
  
<span class="line-modified">! bool ProxyObject::preventExtensions(JSObject* object, JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performPreventExtensions(globalObject);</span>
  }
  
<span class="line-modified">! bool ProxyObject::performIsExtensible(JSGlobalObject* globalObject)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return false;
      }
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue isExtensibleMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;isExtensible&quot;), &quot;&#39;isExtensible&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      JSObject* target = this-&gt;target();
      if (isExtensibleMethod.isUndefined())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, target-&gt;isExtensible(globalObject));</span>
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(globalObject, isExtensibleMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool isTargetExtensible = target-&gt;isExtensible(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (trapResultAsBool != isTargetExtensible) {
          if (isTargetExtensible) {
              ASSERT(!trapResultAsBool);
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;Proxy object&#39;s &#39;isExtensible&#39; trap returned false when the target is extensible. It should have returned true&quot;_s);</span>
          } else {
              ASSERT(!isTargetExtensible);
              ASSERT(trapResultAsBool);
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;Proxy object&#39;s &#39;isExtensible&#39; trap returned true when the target is non-extensible. It should have returned false&quot;_s);</span>
          }
      }
  
      return trapResultAsBool;
  }
  
<span class="line-modified">! bool ProxyObject::isExtensible(JSObject* object, JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performIsExtensible(globalObject);</span>
  }
  
<span class="line-modified">! bool ProxyObject::performDefineOwnProperty(JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return false;
      }
  
      JSObject* target = this-&gt;target();
      auto performDefaultDefineOwnProperty = [&amp;] {
<span class="line-modified">!         RELEASE_AND_RETURN(scope, target-&gt;methodTable(vm)-&gt;defineOwnProperty(target, globalObject, propertyName, descriptor, shouldThrow));</span>
      };
  
      if (propertyName.isPrivateName())
          return false;
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue definePropertyMethod = handler-&gt;getMethod(globalObject, callData, callType, vm.propertyNames-&gt;defineProperty, &quot;&#39;defineProperty&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (definePropertyMethod.isUndefined())
          return performDefaultDefineOwnProperty();
  
<span class="line-modified">!     JSObject* descriptorObject = constructObjectFromPropertyDescriptor(globalObject, descriptor);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
      arguments.append(descriptorObject);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(globalObject, definePropertyMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!trapResultAsBool)
          return false;
  
      PropertyDescriptor targetDescriptor;
<span class="line-modified">!     bool isTargetDescriptorDefined = target-&gt;getOwnPropertyDescriptor(globalObject, propertyName, targetDescriptor);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool targetIsExtensible = target-&gt;isExtensible(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
      bool settingConfigurableToFalse = descriptor.configurablePresent() &amp;&amp; !descriptor.configurable();
  
      if (!isTargetDescriptorDefined) {
          if (!targetIsExtensible) {
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true even though getOwnPropertyDescriptor of the Proxy&#39;s target returned undefined and the target is non-extensible&quot;_s);</span>
              return false;
          }
          if (settingConfigurableToFalse) {
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true for a non-configurable field even though getOwnPropertyDescriptor of the Proxy&#39;s target returned undefined&quot;_s);</span>
              return false;
          }
  
          return true;
      }
  
      ASSERT(isTargetDescriptorDefined);
      bool isCurrentDefined = isTargetDescriptorDefined;
      const PropertyDescriptor&amp; current = targetDescriptor;
      bool throwException = false;
<span class="line-modified">!     bool isCompatibleDescriptor = validateAndApplyPropertyDescriptor(globalObject, nullptr, propertyName, targetIsExtensible, descriptor, isCurrentDefined, current, throwException);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (!isCompatibleDescriptor) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a property on its target that is compatible with the trap&#39;s input descriptor&quot;_s);</span>
          return false;
      }
      if (settingConfigurableToFalse &amp;&amp; targetDescriptor.configurable()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a non-configurable property on its target even though the input descriptor to the trap said it must do so&quot;_s);</span>
          return false;
      }
      if (targetDescriptor.isDataDescriptor() &amp;&amp; !targetDescriptor.configurable() &amp;&amp; targetDescriptor.writable()) {
          if (descriptor.writablePresent() &amp;&amp; !descriptor.writable()) {
<span class="line-modified">!             throwTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true for a non-writable input descriptor when the target&#39;s property is non-configurable and writable&quot;_s);</span>
              return false;
          }
      }
  
      return true;
  }
  
<span class="line-modified">! bool ProxyObject::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified">!     return thisObject-&gt;performDefineOwnProperty(globalObject, propertyName, descriptor, shouldThrow);</span>
  }
  
<span class="line-modified">! void ProxyObject::performGetOwnPropertyNames(JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return;
      }
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue ownKeysMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;ownKeys&quot;), &quot;&#39;ownKeys&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, void());
      JSObject* target = this-&gt;target();
<span class="line-added">+     EnumerationMode enumerationMode(DontEnumPropertiesMode::Include);</span>
      if (ownKeysMethod.isUndefined()) {
          scope.release();
<span class="line-modified">!         target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, globalObject, propertyNames, enumerationMode);</span>
          return;
      }
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(globalObject, ownKeysMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      HashSet&lt;UniquedStringImpl*&gt; uncheckedResultKeys;
      {
          RuntimeTypeMask resultFilter = 0;
          switch (propertyNames.propertyNameMode()) {
          case PropertyNameMode::Symbols:
              resultFilter = TypeSymbol;
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 972,52 ***</span>
              break;
          }
          ASSERT(resultFilter);
  
          auto addPropName = [&amp;] (JSValue value, RuntimeType type) -&gt; bool {
<span class="line-modified">!             static const bool doExitEarly = true;</span>
<span class="line-modified">!             static const bool dontExitEarly = false;</span>
  
<span class="line-modified">!             Identifier ident = value.toPropertyKey(exec);</span>
              RETURN_IF_EXCEPTION(scope, doExitEarly);
  
<span class="line-modified">!             // If trapResult contains any duplicate entries, throw a TypeError exception.</span>
<span class="line-modified">!             //</span>
<span class="line-removed">-             // Per spec[1], filtering by type should occur _after_ [[OwnPropertyKeys]], so duplicates</span>
<span class="line-removed">-             // are tracked in a separate hashtable from uncheckedResultKeys (which only contain the</span>
<span class="line-removed">-             // keys filtered by type).</span>
<span class="line-removed">-             //</span>
<span class="line-removed">-             // [1] Per https://tc39.github.io/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeysmust not contain any duplicate names&quot;_s);</span>
<span class="line-removed">-             if (!seenKeys.add(ident.impl()).isNewEntry) {</span>
<span class="line-removed">-                 throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; trap result must not contain any duplicate names&quot;_s);</span>
                  return doExitEarly;
              }
  
<span class="line-modified">!             if (!(type &amp; resultFilter))</span>
<span class="line-modified">!                 return dontExitEarly;</span>
  
<span class="line-removed">-             uncheckedResultKeys.add(ident.impl());</span>
<span class="line-removed">-             trapResult.add(ident.impl());</span>
              return dontExitEarly;
          };
  
          RuntimeTypeMask dontThrowAnExceptionTypeFilter = TypeString | TypeSymbol;
<span class="line-modified">!         createListFromArrayLike(exec, arrayLikeObject, dontThrowAnExceptionTypeFilter, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an object&quot;_s, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an array-like object containing only Strings and Symbols&quot;_s, addPropName);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
  
<span class="line-modified">!     bool targetIsExensible = target-&gt;isExtensible(exec);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!     PropertyNameArray targetKeys(vm, propertyNames.propertyNameMode(), propertyNames.privateSymbolMode());</span>
<span class="line-modified">!     target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, targetKeys, enumerationMode);</span>
      RETURN_IF_EXCEPTION(scope, void());
      Vector&lt;UniquedStringImpl*&gt; targetConfigurableKeys;
      Vector&lt;UniquedStringImpl*&gt; targetNonConfigurableKeys;
      for (const Identifier&amp; ident : targetKeys) {
          PropertyDescriptor descriptor;
<span class="line-modified">!         bool isPropertyDefined = target-&gt;getOwnPropertyDescriptor(exec, ident.impl(), descriptor);</span>
          RETURN_IF_EXCEPTION(scope, void());
          if (isPropertyDefined &amp;&amp; !descriptor.configurable())
              targetNonConfigurableKeys.append(ident.impl());
          else
              targetConfigurableKeys.append(ident.impl());
<span class="line-new-header">--- 969,43 ---</span>
              break;
          }
          ASSERT(resultFilter);
  
          auto addPropName = [&amp;] (JSValue value, RuntimeType type) -&gt; bool {
<span class="line-modified">!             static constexpr bool doExitEarly = true;</span>
<span class="line-modified">!             static constexpr bool dontExitEarly = false;</span>
  
<span class="line-modified">!             Identifier ident = value.toPropertyKey(globalObject);</span>
              RETURN_IF_EXCEPTION(scope, doExitEarly);
  
<span class="line-modified">!             if (!uncheckedResultKeys.add(ident.impl()).isNewEntry) {</span>
<span class="line-modified">!                 throwTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; trap result must not contain any duplicate names&quot;_s);</span>
                  return doExitEarly;
              }
  
<span class="line-modified">!             if (type &amp; resultFilter)</span>
<span class="line-modified">!                 propertyNames.add(ident.impl());</span>
  
              return dontExitEarly;
          };
  
          RuntimeTypeMask dontThrowAnExceptionTypeFilter = TypeString | TypeSymbol;
<span class="line-modified">!         createListFromArrayLike(globalObject, trapResult, dontThrowAnExceptionTypeFilter, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an object&quot;_s, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an array-like object containing only Strings and Symbols&quot;_s, addPropName);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
  
<span class="line-modified">!     bool targetIsExensible = target-&gt;isExtensible(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!     PropertyNameArray targetKeys(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);</span>
<span class="line-modified">!     target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, globalObject, targetKeys, enumerationMode);</span>
      RETURN_IF_EXCEPTION(scope, void());
      Vector&lt;UniquedStringImpl*&gt; targetConfigurableKeys;
      Vector&lt;UniquedStringImpl*&gt; targetNonConfigurableKeys;
      for (const Identifier&amp; ident : targetKeys) {
          PropertyDescriptor descriptor;
<span class="line-modified">!         bool isPropertyDefined = target-&gt;getOwnPropertyDescriptor(globalObject, ident.impl(), descriptor);</span>
          RETURN_IF_EXCEPTION(scope, void());
          if (isPropertyDefined &amp;&amp; !descriptor.configurable())
              targetNonConfigurableKeys.append(ident.impl());
          else
              targetConfigurableKeys.append(ident.impl());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1033,196 ***</span>
          return IsContainedIn;
      };
  
      for (UniquedStringImpl* impl : targetNonConfigurableKeys) {
          if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {
<span class="line-modified">!             throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s &#39;target&#39; has the non-configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));</span>
              return;
          }
      }
  
      if (!targetIsExensible) {
          for (UniquedStringImpl* impl : targetConfigurableKeys) {
              if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {
<span class="line-modified">!                 throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s non-extensible &#39;target&#39; has configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));</span>
                  return;
              }
          }
  
          if (uncheckedResultKeys.size()) {
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method returned a key that was not present in its non-extensible target&quot;_s);</span>
              return;
          }
      }
  
<span class="line-modified">!     if (!enumerationMode.includeDontEnumProperties()) {</span>
<span class="line-modified">!         // Filtering DontEnum properties is observable in proxies and must occur following the invariant checks above.</span>
<span class="line-modified">!         for (auto propertyName : trapResult) {</span>
<span class="line-modified">!             PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);</span>
<span class="line-modified">!             auto result = getOwnPropertySlotCommon(exec, propertyName, slot);</span>
<span class="line-modified">!             RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-modified">!             if (!result)</span>
<span class="line-modified">!                 continue;</span>
<span class="line-modified">!             if (slot.attributes() &amp; PropertyAttribute::DontEnum)</span>
<span class="line-modified">!                 continue;</span>
<span class="line-modified">!             propertyNames.add(propertyName.impl());</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         for (auto propertyName : trapResult)</span>
<span class="line-modified">!             propertyNames.add(propertyName.impl());</span>
      }
  }
  
<span class="line-modified">! void ProxyObject::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified">!     thisObject-&gt;performGetOwnPropertyNames(exec, propertyNameArray, enumerationMode);</span>
  }
  
<span class="line-modified">! void ProxyObject::getPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
  {
      NO_TAIL_CALLS();
<span class="line-modified">!     JSObject::getPropertyNames(object, exec, propertyNameArray, enumerationMode);</span>
  }
  
<span class="line-modified">! void ProxyObject::getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! void ProxyObject::getStructurePropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      // We should always go down the getOwnPropertyNames path.
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! void ProxyObject::getGenericPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! bool ProxyObject::performSetPrototype(ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)</span>
  {
      NO_TAIL_CALLS();
  
      ASSERT(prototype.isObject() || prototype.isNull());
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return false;
      }
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue setPrototypeOfMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;setPrototypeOf&quot;), &quot;&#39;setPrototypeOf&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      JSObject* target = this-&gt;target();
      if (setPrototypeOfMethod.isUndefined())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, target-&gt;setPrototype(vm, exec, prototype, shouldThrowIfCantSet));</span>
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(prototype);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(exec, setPrototypeOfMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!trapResultAsBool) {
          if (shouldThrowIfCantSet)
<span class="line-modified">!             throwVMTypeError(exec, scope, &quot;Proxy &#39;setPrototypeOf&#39; returned false indicating it could not set the prototype value. The operation was expected to succeed&quot;_s);</span>
          return false;
      }
  
<span class="line-modified">!     bool targetIsExtensible = target-&gt;isExtensible(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (targetIsExtensible)
          return true;
  
<span class="line-modified">!     JSValue targetPrototype = target-&gt;getPrototype(vm, exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!     if (!sameValue(exec, prototype, targetPrototype)) {</span>
<span class="line-modified">!         throwVMTypeError(exec, scope, &quot;Proxy &#39;setPrototypeOf&#39; trap returned true when its target is non-extensible and the new prototype value is not the same as the current prototype value. It should have returned false&quot;_s);</span>
          return false;
      }
  
      return true;
  }
  
<span class="line-modified">! bool ProxyObject::setPrototype(JSObject* object, ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)</span>
  {
<span class="line-modified">!     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performSetPrototype(exec, prototype, shouldThrowIfCantSet);</span>
  }
  
<span class="line-modified">! JSValue ProxyObject::performGetPrototype(ExecState* exec)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(exec, scope);</span>
          return { };
      }
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return { };
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue getPrototypeOfMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;getPrototypeOf&quot;), &quot;&#39;getPrototypeOf&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      JSObject* target = this-&gt;target();
      if (getPrototypeOfMethod.isUndefined())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, target-&gt;getPrototype(vm, exec));</span>
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(exec, getPrototypeOfMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (!trapResult.isObject() &amp;&amp; !trapResult.isNull()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;getPrototypeOf&#39; trap should either return an object or null&quot;_s);</span>
          return { };
      }
  
<span class="line-modified">!     bool targetIsExtensible = target-&gt;isExtensible(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
      if (targetIsExtensible)
          return trapResult;
  
<span class="line-modified">!     JSValue targetPrototype = target-&gt;getPrototype(vm, exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     if (!sameValue(exec, targetPrototype, trapResult)) {</span>
<span class="line-modified">!         throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;getPrototypeOf&#39; trap for a non-extensible target should return the same value as the target&#39;s prototype&quot;_s);</span>
          return { };
      }
  
      return trapResult;
  }
  
<span class="line-modified">! JSValue ProxyObject::getPrototype(JSObject* object, ExecState* exec)</span>
  {
<span class="line-modified">!     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performGetPrototype(exec);</span>
  }
  
  void ProxyObject::revoke(VM&amp; vm)
  {
      // This should only ever be called once and we should strictly transition from Object to null.
<span class="line-new-header">--- 1021,207 ---</span>
          return IsContainedIn;
      };
  
      for (UniquedStringImpl* impl : targetNonConfigurableKeys) {
          if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {
<span class="line-modified">!             throwVMTypeError(globalObject, scope, makeString(&quot;Proxy object&#39;s &#39;target&#39; has the non-configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));</span>
              return;
          }
      }
  
      if (!targetIsExensible) {
          for (UniquedStringImpl* impl : targetConfigurableKeys) {
              if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {
<span class="line-modified">!                 throwVMTypeError(globalObject, scope, makeString(&quot;Proxy object&#39;s non-extensible &#39;target&#39; has configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));</span>
                  return;
              }
          }
  
          if (uncheckedResultKeys.size()) {
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method returned a key that was not present in its non-extensible target&quot;_s);</span>
              return;
          }
      }
<span class="line-added">+ }</span>
  
<span class="line-modified">! void ProxyObject::performGetOwnEnumerablePropertyNames(JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     PropertyNameArray unfilteredNames(vm, propertyNames.propertyNameMode(), propertyNames.privateSymbolMode());</span>
<span class="line-modified">!     performGetOwnPropertyNames(globalObject, unfilteredNames);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-modified">!     // Filtering DontEnum properties is observable in proxies and must occur after the invariant checks pass.</span>
<span class="line-modified">!     for (const auto&amp; propertyName : unfilteredNames) {</span>
<span class="line-modified">!         PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);</span>
<span class="line-modified">!         auto isPropertyDefined = getOwnPropertySlotCommon(globalObject, propertyName, slot);</span>
<span class="line-modified">!         RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-modified">!         if (!isPropertyDefined)</span>
<span class="line-modified">!             continue;</span>
<span class="line-added">+         if (slot.attributes() &amp; PropertyAttribute::DontEnum)</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         propertyNames.add(propertyName.impl());</span>
      }
  }
  
<span class="line-modified">! void ProxyObject::getOwnPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
  {
      ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified">!     if (enumerationMode.includeDontEnumProperties())</span>
<span class="line-added">+         thisObject-&gt;performGetOwnPropertyNames(globalObject, propertyNameArray);</span>
<span class="line-added">+     else</span>
<span class="line-added">+         thisObject-&gt;performGetOwnEnumerablePropertyNames(globalObject, propertyNameArray);</span>
  }
  
<span class="line-modified">! void ProxyObject::getPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
  {
      NO_TAIL_CALLS();
<span class="line-modified">!     JSObject::getPropertyNames(object, globalObject, propertyNameArray, enumerationMode);</span>
  }
  
<span class="line-modified">! void ProxyObject::getOwnNonIndexPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! void ProxyObject::getStructurePropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      // We should always go down the getOwnPropertyNames path.
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! void ProxyObject::getGenericPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode)</span>
  {
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! bool ProxyObject::performSetPrototype(JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)</span>
  {
      NO_TAIL_CALLS();
  
      ASSERT(prototype.isObject() || prototype.isNull());
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return false;
      }
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return false;
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue setPrototypeOfMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;setPrototypeOf&quot;), &quot;&#39;setPrototypeOf&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      JSObject* target = this-&gt;target();
      if (setPrototypeOfMethod.isUndefined())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, target-&gt;setPrototype(vm, globalObject, prototype, shouldThrowIfCantSet));</span>
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      arguments.append(prototype);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(globalObject, setPrototypeOfMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!trapResultAsBool) {
          if (shouldThrowIfCantSet)
<span class="line-modified">!             throwVMTypeError(globalObject, scope, &quot;Proxy &#39;setPrototypeOf&#39; returned false indicating it could not set the prototype value. The operation was expected to succeed&quot;_s);</span>
          return false;
      }
  
<span class="line-modified">!     bool targetIsExtensible = target-&gt;isExtensible(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (targetIsExtensible)
          return true;
  
<span class="line-modified">!     JSValue targetPrototype = target-&gt;getPrototype(vm, globalObject);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+     bool isSame = sameValue(globalObject, prototype, targetPrototype);</span>
      RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!     if (!isSame) {</span>
<span class="line-modified">!         throwVMTypeError(globalObject, scope, &quot;Proxy &#39;setPrototypeOf&#39; trap returned true when its target is non-extensible and the new prototype value is not the same as the current prototype value. It should have returned false&quot;_s);</span>
          return false;
      }
  
      return true;
  }
  
<span class="line-modified">! bool ProxyObject::setPrototype(JSObject* object, JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)</span>
  {
<span class="line-modified">!     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performSetPrototype(globalObject, prototype, shouldThrowIfCantSet);</span>
  }
  
<span class="line-modified">! JSValue ProxyObject::performGetPrototype(JSGlobalObject* globalObject)</span>
  {
      NO_TAIL_CALLS();
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return { };
      }
  
      JSValue handlerValue = this-&gt;handler();
      if (handlerValue.isNull()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
          return { };
      }
  
      JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue getPrototypeOfMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;getPrototypeOf&quot;), &quot;&#39;getPrototypeOf&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      JSObject* target = this-&gt;target();
      if (getPrototypeOfMethod.isUndefined())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, target-&gt;getPrototype(vm, globalObject));</span>
  
      MarkedArgumentBuffer arguments;
      arguments.append(target);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     JSValue trapResult = call(globalObject, getPrototypeOfMethod, callType, callData, handler, arguments);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (!trapResult.isObject() &amp;&amp; !trapResult.isNull()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;getPrototypeOf&#39; trap should either return an object or null&quot;_s);</span>
          return { };
      }
  
<span class="line-modified">!     bool targetIsExtensible = target-&gt;isExtensible(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
      if (targetIsExtensible)
          return trapResult;
  
<span class="line-modified">!     JSValue targetPrototype = target-&gt;getPrototype(vm, globalObject);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+     bool isSame = sameValue(globalObject, targetPrototype, trapResult);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     if (!isSame) {</span>
<span class="line-modified">!         throwVMTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;getPrototypeOf&#39; trap for a non-extensible target should return the same value as the target&#39;s prototype&quot;_s);</span>
          return { };
      }
  
      return trapResult;
  }
  
<span class="line-modified">! JSValue ProxyObject::getPrototype(JSObject* object, JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performGetPrototype(globalObject);</span>
  }
  
  void ProxyObject::revoke(VM&amp; vm)
  {
      // This should only ever be called once and we should strictly transition from Object to null.
</pre>
<center><a href="ProxyConstructor.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProxyObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLOperations.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOutput.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2017 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
316     return result.second;
317 }
318 
319 LValue Output::doubleSqrt(LValue value)
320 {
321     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Sqrt, origin(), value);
322 }
323 
324 LValue Output::doubleToInt(LValue value)
325 {
326     PatchpointValue* result = patchpoint(Int32);
327     result-&gt;append(value, ValueRep::SomeRegister);
328     result-&gt;setGenerator(
329         [] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
330             jit.truncateDoubleToInt32(params[1].fpr(), params[0].gpr());
331         });
332     result-&gt;effects = Effects::none();
333     return result;
334 }
335 












336 LValue Output::doubleToUInt(LValue value)
337 {
338     PatchpointValue* result = patchpoint(Int32);
339     result-&gt;append(value, ValueRep::SomeRegister);
340     result-&gt;setGenerator(
341         [] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
342             jit.truncateDoubleToUint32(params[1].fpr(), params[0].gpr());
343         });
344     result-&gt;effects = Effects::none();
345     return result;
346 }
347 
348 LValue Output::signExt32To64(LValue value)
349 {
350     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::SExt32, origin(), value);
351 }
352 
353 LValue Output::signExt32ToPtr(LValue value)
354 {
355     return signExt32To64(value);
</pre>
<hr />
<pre>
626 LValue Output::isZero32(LValue value)
627 {
628     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Equal, origin(), value, int32Zero);
629 }
630 
631 LValue Output::notZero32(LValue value)
632 {
633     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::NotEqual, origin(), value, int32Zero);
634 }
635 
636 LValue Output::isZero64(LValue value)
637 {
638     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Equal, origin(), value, int64Zero);
639 }
640 
641 LValue Output::notZero64(LValue value)
642 {
643     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::NotEqual, origin(), value, int64Zero);
644 }
645 
<span class="line-modified">646 LValue Output::select(LValue value, LValue taken, LValue notTaken)</span>
647 {
648     if (value-&gt;hasInt32()) {
649         if (value-&gt;asInt32())
<span class="line-modified">650             return taken;</span>
651         else
<span class="line-modified">652             return notTaken;</span>
653     }
<span class="line-modified">654     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Select, origin(), value, taken, notTaken);</span>






















655 }
656 
657 LValue Output::atomicXchgAdd(LValue operand, TypedPointer pointer, Width width)
658 {
659     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicXchgAdd, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());
660     m_heaps-&gt;decorateMemory(pointer.heap(), result);
661     return result;
662 }
663 
664 LValue Output::atomicXchgAnd(LValue operand, TypedPointer pointer, Width width)
665 {
666     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicXchgAnd, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());
667     m_heaps-&gt;decorateMemory(pointer.heap(), result);
668     return result;
669 }
670 
671 LValue Output::atomicXchgOr(LValue operand, TypedPointer pointer, Width width)
672 {
673     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicXchgOr, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());
674     m_heaps-&gt;decorateMemory(pointer.heap(), result);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
316     return result.second;
317 }
318 
319 LValue Output::doubleSqrt(LValue value)
320 {
321     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Sqrt, origin(), value);
322 }
323 
324 LValue Output::doubleToInt(LValue value)
325 {
326     PatchpointValue* result = patchpoint(Int32);
327     result-&gt;append(value, ValueRep::SomeRegister);
328     result-&gt;setGenerator(
329         [] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
330             jit.truncateDoubleToInt32(params[1].fpr(), params[0].gpr());
331         });
332     result-&gt;effects = Effects::none();
333     return result;
334 }
335 
<span class="line-added">336 LValue Output::doubleToInt64(LValue value)</span>
<span class="line-added">337 {</span>
<span class="line-added">338     PatchpointValue* result = patchpoint(Int64);</span>
<span class="line-added">339     result-&gt;append(value, ValueRep::SomeRegister);</span>
<span class="line-added">340     result-&gt;setGenerator(</span>
<span class="line-added">341         [] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">342             jit.truncateDoubleToInt64(params[1].fpr(), params[0].gpr());</span>
<span class="line-added">343         });</span>
<span class="line-added">344     result-&gt;effects = Effects::none();</span>
<span class="line-added">345     return result;</span>
<span class="line-added">346 }</span>
<span class="line-added">347 </span>
348 LValue Output::doubleToUInt(LValue value)
349 {
350     PatchpointValue* result = patchpoint(Int32);
351     result-&gt;append(value, ValueRep::SomeRegister);
352     result-&gt;setGenerator(
353         [] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
354             jit.truncateDoubleToUint32(params[1].fpr(), params[0].gpr());
355         });
356     result-&gt;effects = Effects::none();
357     return result;
358 }
359 
360 LValue Output::signExt32To64(LValue value)
361 {
362     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::SExt32, origin(), value);
363 }
364 
365 LValue Output::signExt32ToPtr(LValue value)
366 {
367     return signExt32To64(value);
</pre>
<hr />
<pre>
638 LValue Output::isZero32(LValue value)
639 {
640     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Equal, origin(), value, int32Zero);
641 }
642 
643 LValue Output::notZero32(LValue value)
644 {
645     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::NotEqual, origin(), value, int32Zero);
646 }
647 
648 LValue Output::isZero64(LValue value)
649 {
650     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Equal, origin(), value, int64Zero);
651 }
652 
653 LValue Output::notZero64(LValue value)
654 {
655     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::NotEqual, origin(), value, int64Zero);
656 }
657 
<span class="line-modified">658 LValue Output::select(LValue value, LValue left, LValue right, SelectPredictability predictability)</span>
659 {
660     if (value-&gt;hasInt32()) {
661         if (value-&gt;asInt32())
<span class="line-modified">662             return left;</span>
663         else
<span class="line-modified">664             return right;</span>
665     }
<span class="line-modified">666 </span>
<span class="line-added">667     if (predictability == SelectPredictability::NotPredictable)</span>
<span class="line-added">668         return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Select, origin(), value, left, right);</span>
<span class="line-added">669 </span>
<span class="line-added">670     LBasicBlock continuation = newBlock();</span>
<span class="line-added">671     LBasicBlock leftTakenBlock = newBlock();</span>
<span class="line-added">672     LBasicBlock rightTakenBlock = newBlock();</span>
<span class="line-added">673 </span>
<span class="line-added">674     m_block-&gt;appendNewControlValue(</span>
<span class="line-added">675         m_proc, B3::Branch, origin(), value,</span>
<span class="line-added">676         FrequentedBlock(leftTakenBlock, predictability != SelectPredictability::RightLikely ? FrequencyClass::Normal : FrequencyClass::Rare),</span>
<span class="line-added">677         FrequentedBlock(rightTakenBlock, predictability != SelectPredictability::LeftLikely ? FrequencyClass::Normal : FrequencyClass::Rare));</span>
<span class="line-added">678 </span>
<span class="line-added">679     LValue phi = continuation-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Phi, left-&gt;type(), origin());</span>
<span class="line-added">680 </span>
<span class="line-added">681     leftTakenBlock-&gt;appendNew&lt;B3::UpsilonValue&gt;(m_proc, origin(), left, phi);</span>
<span class="line-added">682     leftTakenBlock-&gt;appendNewControlValue(m_proc, B3::Jump, origin(), B3::FrequentedBlock(continuation));</span>
<span class="line-added">683 </span>
<span class="line-added">684     rightTakenBlock-&gt;appendNew&lt;B3::UpsilonValue&gt;(m_proc, origin(), right, phi);</span>
<span class="line-added">685     rightTakenBlock-&gt;appendNewControlValue(m_proc, B3::Jump, origin(), B3::FrequentedBlock(continuation));</span>
<span class="line-added">686 </span>
<span class="line-added">687     m_block = continuation;</span>
<span class="line-added">688     return phi;</span>
689 }
690 
691 LValue Output::atomicXchgAdd(LValue operand, TypedPointer pointer, Width width)
692 {
693     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicXchgAdd, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());
694     m_heaps-&gt;decorateMemory(pointer.heap(), result);
695     return result;
696 }
697 
698 LValue Output::atomicXchgAnd(LValue operand, TypedPointer pointer, Width width)
699 {
700     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicXchgAnd, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());
701     m_heaps-&gt;decorateMemory(pointer.heap(), result);
702     return result;
703 }
704 
705 LValue Output::atomicXchgOr(LValue operand, TypedPointer pointer, Width width)
706 {
707     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicXchgOr, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());
708     m_heaps-&gt;decorateMemory(pointer.heap(), result);
</pre>
</td>
</tr>
</table>
<center><a href="FTLOperations.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOutput.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
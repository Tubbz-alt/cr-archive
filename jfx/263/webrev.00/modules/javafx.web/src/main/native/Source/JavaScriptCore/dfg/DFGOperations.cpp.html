<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGOperations.h&quot;
  28 
  29 #include &quot;ArrayConstructor.h&quot;
  30 #include &quot;ButterflyInlines.h&quot;
  31 #include &quot;ClonedArguments.h&quot;
  32 #include &quot;CodeBlock.h&quot;
  33 #include &quot;CommonSlowPaths.h&quot;
  34 #include &quot;DFGDriver.h&quot;
  35 #include &quot;DFGJITCode.h&quot;
  36 #include &quot;DFGOSRExit.h&quot;
  37 #include &quot;DFGThunks.h&quot;
  38 #include &quot;DFGToFTLDeferredCompilationCallback.h&quot;
  39 #include &quot;DFGToFTLForOSREntryDeferredCompilationCallback.h&quot;
  40 #include &quot;DFGWorklist.h&quot;
  41 #include &quot;DateInstance.h&quot;
  42 #include &quot;DefinePropertyAttributes.h&quot;
  43 #include &quot;DirectArguments.h&quot;
  44 #include &quot;EvalCodeBlock.h&quot;
  45 #include &quot;FTLForOSREntryJITCode.h&quot;
  46 #include &quot;FTLOSREntry.h&quot;
  47 #include &quot;FrameTracers.h&quot;
  48 #include &quot;HasOwnPropertyCache.h&quot;
  49 #include &quot;HostCallReturnValue.h&quot;
  50 #include &quot;Interpreter.h&quot;
  51 #include &quot;JIT.h&quot;
  52 #include &quot;JITExceptions.h&quot;
  53 #include &quot;JSArrayInlines.h&quot;
  54 #include &quot;JSArrayIterator.h&quot;
  55 #include &quot;JSAsyncGenerator.h&quot;
  56 #include &quot;JSBigInt.h&quot;
  57 #include &quot;JSCInlines.h&quot;
  58 #include &quot;JSGenericTypedArrayViewConstructorInlines.h&quot;
  59 #include &quot;JSGlobalObjectFunctions.h&quot;
  60 #include &quot;JSImmutableButterfly.h&quot;
  61 #include &quot;JSInternalPromise.h&quot;
  62 #include &quot;JSInternalPromiseConstructor.h&quot;
  63 #include &quot;JSLexicalEnvironment.h&quot;
  64 #include &quot;JSMap.h&quot;
  65 #include &quot;JSPromiseConstructor.h&quot;
  66 #include &quot;JSPropertyNameEnumerator.h&quot;
  67 #include &quot;JSSet.h&quot;
  68 #include &quot;JSWeakMap.h&quot;
  69 #include &quot;JSWeakSet.h&quot;
  70 #include &quot;ModuleProgramCodeBlock.h&quot;
  71 #include &quot;NumberConstructor.h&quot;
  72 #include &quot;ObjectConstructor.h&quot;
  73 #include &quot;Operations.h&quot;
  74 #include &quot;ParseInt.h&quot;
  75 #include &quot;ProgramCodeBlock.h&quot;
  76 #include &quot;RegExpGlobalDataInlines.h&quot;
  77 #include &quot;RegExpMatchesArray.h&quot;
  78 #include &quot;RegExpObjectInlines.h&quot;
  79 #include &quot;Repatch.h&quot;
  80 #include &quot;ScopedArguments.h&quot;
  81 #include &quot;StringConstructor.h&quot;
  82 #include &quot;StringPrototypeInlines.h&quot;
  83 #include &quot;SuperSampler.h&quot;
  84 #include &quot;Symbol.h&quot;
  85 #include &quot;TypeProfilerLog.h&quot;
  86 #include &quot;TypedArrayInlines.h&quot;
  87 #include &quot;VMInlines.h&quot;
  88 #include &lt;wtf/InlineASM.h&gt;
  89 #include &lt;wtf/Variant.h&gt;
  90 
  91 #if ENABLE(JIT)
  92 #if ENABLE(DFG_JIT)
  93 
  94 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)
  95 
  96 namespace JSC { namespace DFG {
  97 
  98 template&lt;bool strict, bool direct&gt;
  99 static inline void putByVal(JSGlobalObject* globalObject, VM&amp; vm, JSValue baseValue, uint32_t index, JSValue value)
 100 {
 101     ASSERT(isIndex(index));
 102     if (direct) {
 103         RELEASE_ASSERT(baseValue.isObject());
 104         asObject(baseValue)-&gt;putDirectIndex(globalObject, index, value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);
 105         return;
 106     }
 107     if (baseValue.isObject()) {
 108         JSObject* object = asObject(baseValue);
 109         if (object-&gt;canSetIndexQuickly(index, value)) {
 110             object-&gt;setIndexQuickly(vm, index, value);
 111             return;
 112         }
 113 
 114         object-&gt;methodTable(vm)-&gt;putByIndex(object, globalObject, index, value, strict);
 115         return;
 116     }
 117 
 118     baseValue.putByIndex(globalObject, index, value, strict);
 119 }
 120 
 121 template&lt;bool strict, bool direct&gt;
 122 ALWAYS_INLINE static void putByValInternal(JSGlobalObject* globalObject, VM&amp; vm, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 123 {
 124     auto scope = DECLARE_THROW_SCOPE(vm);
 125 
 126     JSValue baseValue = JSValue::decode(encodedBase);
 127     JSValue property = JSValue::decode(encodedProperty);
 128     JSValue value = JSValue::decode(encodedValue);
 129 
 130     if (LIKELY(property.isUInt32())) {
 131         // Despite its name, JSValue::isUInt32 will return true only for positive boxed int32_t; all those values are valid array indices.
 132         ASSERT(isIndex(property.asUInt32()));
 133         scope.release();
 134         putByVal&lt;strict, direct&gt;(globalObject, vm, baseValue, property.asUInt32(), value);
 135         return;
 136     }
 137 
 138     if (property.isDouble()) {
 139         double propertyAsDouble = property.asDouble();
 140         uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
 141         if (propertyAsDouble == propertyAsUInt32 &amp;&amp; isIndex(propertyAsUInt32)) {
 142             scope.release();
 143             putByVal&lt;strict, direct&gt;(globalObject, vm, baseValue, propertyAsUInt32, value);
 144             return;
 145         }
 146     }
 147 
 148     // Don&#39;t put to an object if toString throws an exception.
 149     auto propertyName = property.toPropertyKey(globalObject);
 150     RETURN_IF_EXCEPTION(scope, void());
 151 
 152     PutPropertySlot slot(baseValue, strict);
 153     if (direct) {
 154         RELEASE_ASSERT(baseValue.isObject());
 155         JSObject* baseObject = asObject(baseValue);
 156         if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
 157             scope.release();
 158             baseObject-&gt;putDirectIndex(globalObject, index.value(), value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);
 159             return;
 160         }
 161         scope.release();
 162         CommonSlowPaths::putDirectWithReify(vm, globalObject, baseObject, propertyName, value, slot);
 163         return;
 164     }
 165     scope.release();
 166     baseValue.put(globalObject, propertyName, value, slot);
 167 }
 168 
 169 template&lt;bool strict, bool direct&gt;
 170 ALWAYS_INLINE static void putByValCellInternal(JSGlobalObject* globalObject, VM&amp; vm, JSCell* base, PropertyName propertyName, JSValue value)
 171 {
 172     PutPropertySlot slot(base, strict);
 173     if (direct) {
 174         RELEASE_ASSERT(base-&gt;isObject());
 175         JSObject* baseObject = asObject(base);
 176         if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
 177             baseObject-&gt;putDirectIndex(globalObject, index.value(), value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);
 178             return;
 179         }
 180         CommonSlowPaths::putDirectWithReify(vm, globalObject, baseObject, propertyName, value, slot);
 181         return;
 182     }
 183     base-&gt;putInline(globalObject, propertyName, value, slot);
 184 }
 185 
 186 template&lt;bool strict, bool direct&gt;
 187 ALWAYS_INLINE static void putByValCellStringInternal(JSGlobalObject* globalObject, VM&amp; vm, JSCell* base, JSString* property, JSValue value)
 188 {
 189     auto scope = DECLARE_THROW_SCOPE(vm);
 190 
 191     auto propertyName = property-&gt;toIdentifier(globalObject);
 192     RETURN_IF_EXCEPTION(scope, void());
 193 
 194     scope.release();
 195     putByValCellInternal&lt;strict, direct&gt;(globalObject, vm, base, propertyName, value);
 196 }
 197 
 198 template&lt;typename ViewClass&gt;
 199 char* newTypedArrayWithSize(JSGlobalObject* globalObject, VM&amp; vm, Structure* structure, int32_t size, char* vector)
 200 {
 201     auto scope = DECLARE_THROW_SCOPE(vm);
 202 
 203     if (size &lt; 0) {
 204         throwException(globalObject, scope, createRangeError(globalObject, &quot;Requested length is negative&quot;_s));
 205         return 0;
 206     }
 207 
 208     if (vector)
 209         return bitwise_cast&lt;char*&gt;(ViewClass::createWithFastVector(globalObject, structure, size, untagArrayPtr(vector, size)));
 210 
 211     RELEASE_AND_RETURN(scope, bitwise_cast&lt;char*&gt;(ViewClass::create(globalObject, structure, size)));
 212 }
 213 
 214 template &lt;bool strict&gt;
 215 static ALWAYS_INLINE void putWithThis(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, const Identifier&amp; ident)
 216 {
 217     JSValue baseValue = JSValue::decode(encodedBase);
 218     JSValue thisVal = JSValue::decode(encodedThis);
 219     JSValue putValue = JSValue::decode(encodedValue);
 220     PutPropertySlot slot(thisVal, strict);
 221     baseValue.putInline(globalObject, ident, putValue, slot);
 222 }
 223 
 224 template&lt;typename BigIntOperation, typename NumberOperation&gt;
 225 static ALWAYS_INLINE EncodedJSValue binaryOp(JSGlobalObject* globalObject, VM&amp; vm, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, NumberOperation&amp;&amp; numberOp, const char* errorMessage)
 226 {
 227     auto scope = DECLARE_THROW_SCOPE(vm);
 228 
 229     JSValue op1 = JSValue::decode(encodedOp1);
 230     JSValue op2 = JSValue::decode(encodedOp2);
 231 
 232     auto leftNumeric = op1.toNumeric(globalObject);
 233     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 234     auto rightNumeric = op2.toNumeric(globalObject);
 235     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 236 
 237     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 238         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))
 239             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));
 240 
 241         return throwVMTypeError(globalObject, scope, errorMessage);
 242     }
 243 
 244     scope.release();
 245 
 246     return JSValue::encode(jsNumber(numberOp(WTF::get&lt;double&gt;(leftNumeric), WTF::get&lt;double&gt;(rightNumeric))));
 247 }
 248 
 249 template&lt;typename BigIntOperation, typename Int32Operation&gt;
 250 static ALWAYS_INLINE EncodedJSValue bitwiseBinaryOp(JSGlobalObject* globalObject, VM&amp; vm, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, Int32Operation&amp;&amp; int32Op, const char* errorMessage)
 251 {
 252     auto scope = DECLARE_THROW_SCOPE(vm);
 253 
 254     JSValue op1 = JSValue::decode(encodedOp1);
 255     JSValue op2 = JSValue::decode(encodedOp2);
 256 
 257     auto leftNumeric = op1.toBigIntOrInt32(globalObject);
 258     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 259     auto rightNumeric = op2.toBigIntOrInt32(globalObject);
 260     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 261 
 262     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 263         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))
 264             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));
 265 
 266         return throwVMTypeError(globalObject, scope, errorMessage);
 267     }
 268 
 269     scope.release();
 270 
 271     return JSValue::encode(jsNumber(int32Op(WTF::get&lt;int32_t&gt;(leftNumeric), WTF::get&lt;int32_t&gt;(rightNumeric))));
 272 }
 273 
 274 static ALWAYS_INLINE EncodedJSValue parseIntResult(double input)
 275 {
 276     int asInt = static_cast&lt;int&gt;(input);
 277     if (static_cast&lt;double&gt;(asInt) == input)
 278         return JSValue::encode(jsNumber(asInt));
 279     return JSValue::encode(jsNumber(input));
 280 }
 281 
 282 ALWAYS_INLINE static JSValue getByValObject(JSGlobalObject* globalObject, VM&amp; vm, JSObject* base, PropertyName propertyName)
 283 {
 284     Structure&amp; structure = *base-&gt;structure(vm);
 285     if (JSCell::canUseFastGetOwnProperty(structure)) {
 286         if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, propertyName))
 287             return result;
 288     }
 289     return base-&gt;get(globalObject, propertyName);
 290 }
 291 
 292 extern &quot;C&quot; {
 293 
 294 EncodedJSValue JIT_OPERATION operationToThis(JSGlobalObject* globalObject, EncodedJSValue encodedOp)
 295 {
 296     VM&amp; vm = globalObject-&gt;vm();
 297     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 298     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 299 
 300     return JSValue::encode(JSValue::decode(encodedOp).toThis(globalObject, NotStrictMode));
 301 }
 302 
 303 EncodedJSValue JIT_OPERATION operationToThisStrict(JSGlobalObject* globalObject, EncodedJSValue encodedOp)
 304 {
 305     VM&amp; vm = globalObject-&gt;vm();
 306     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 307     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 308 
 309     return JSValue::encode(JSValue::decode(encodedOp).toThis(globalObject, StrictMode));
 310 }
 311 
 312 JSArray* JIT_OPERATION operationObjectKeys(JSGlobalObject* globalObject, EncodedJSValue encodedObject)
 313 {
 314     VM&amp; vm = globalObject-&gt;vm();
 315     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 316     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 317     auto scope = DECLARE_THROW_SCOPE(vm);
 318 
 319     JSObject* object = JSValue::decode(encodedObject).toObject(globalObject);
 320     RETURN_IF_EXCEPTION(scope, nullptr);
 321     scope.release();
 322     return ownPropertyKeys(globalObject, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);
 323 }
 324 
 325 JSArray* JIT_OPERATION operationObjectKeysObject(JSGlobalObject* globalObject, JSObject* object)
 326 {
 327     VM&amp; vm = globalObject-&gt;vm();
 328     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 329     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 330     return ownPropertyKeys(globalObject, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);
 331 }
 332 
 333 JSCell* JIT_OPERATION operationObjectCreate(JSGlobalObject* globalObject, EncodedJSValue encodedPrototype)
 334 {
 335     VM&amp; vm = globalObject-&gt;vm();
 336     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 337     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 338     auto scope = DECLARE_THROW_SCOPE(vm);
 339 
 340     JSValue prototype = JSValue::decode(encodedPrototype);
 341 
 342     if (!prototype.isObject() &amp;&amp; !prototype.isNull()) {
 343         throwVMTypeError(globalObject, scope, &quot;Object prototype may only be an Object or null.&quot;_s);
 344         return nullptr;
 345     }
 346 
 347     if (prototype.isObject())
 348         RELEASE_AND_RETURN(scope, constructEmptyObject(globalObject, asObject(prototype)));
 349     RELEASE_AND_RETURN(scope, constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure()));
 350 }
 351 
 352 JSCell* JIT_OPERATION operationObjectCreateObject(JSGlobalObject* globalObject, JSObject* prototype)
 353 {
 354     VM&amp; vm = globalObject-&gt;vm();
 355     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 356     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 357     return constructEmptyObject(globalObject, prototype);
 358 }
 359 
 360 JSCell* JIT_OPERATION operationCreateThis(JSGlobalObject* globalObject, JSObject* constructor, uint32_t inlineCapacity)
 361 {
 362     VM&amp; vm = globalObject-&gt;vm();
 363     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 364     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 365     auto scope = DECLARE_THROW_SCOPE(vm);
 366     if (constructor-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructor)-&gt;canUseAllocationProfile()) {
 367         auto rareData = jsCast&lt;JSFunction*&gt;(constructor)-&gt;ensureRareDataAndAllocationProfile(globalObject, inlineCapacity);
 368         scope.releaseAssertNoException();
 369         ObjectAllocationProfileWithPrototype* allocationProfile = rareData-&gt;objectAllocationProfile();
 370         Structure* structure = allocationProfile-&gt;structure();
 371         JSObject* result = constructEmptyObject(vm, structure);
 372         if (structure-&gt;hasPolyProto()) {
 373             JSObject* prototype = allocationProfile-&gt;prototype();
 374             ASSERT(prototype == jsCast&lt;JSFunction*&gt;(constructor)-&gt;prototypeForConstruction(vm, globalObject));
 375             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 376             prototype-&gt;didBecomePrototype();
 377             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 378         }
 379         return result;
 380     }
 381 
 382     JSValue proto = constructor-&gt;get(globalObject, vm.propertyNames-&gt;prototype);
 383     RETURN_IF_EXCEPTION(scope, nullptr);
 384     if (proto.isObject())
 385         return constructEmptyObject(globalObject, asObject(proto));
 386     return constructEmptyObject(globalObject);
 387 }
 388 
 389 JSCell* JIT_OPERATION operationCreatePromise(JSGlobalObject* globalObject, JSObject* constructor)
 390 {
 391     VM&amp; vm = globalObject-&gt;vm();
 392     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 393     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 394     auto scope = DECLARE_THROW_SCOPE(vm);
 395     Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;promiseConstructor(), constructor, globalObject-&gt;promiseStructure());
 396     RETURN_IF_EXCEPTION(scope, nullptr);
 397     RELEASE_AND_RETURN(scope, JSPromise::create(vm, structure));
 398 }
 399 
 400 JSCell* JIT_OPERATION operationCreateInternalPromise(JSGlobalObject* globalObject, JSObject* constructor)
 401 {
 402     VM&amp; vm = globalObject-&gt;vm();
 403     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 404     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 405     auto scope = DECLARE_THROW_SCOPE(vm);
 406     Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;internalPromiseConstructor(), constructor, globalObject-&gt;internalPromiseStructure());
 407     RETURN_IF_EXCEPTION(scope, nullptr);
 408     RELEASE_AND_RETURN(scope, JSInternalPromise::create(vm, structure));
 409 }
 410 
 411 JSCell* JIT_OPERATION operationCreateGenerator(JSGlobalObject* globalObject, JSObject* constructor)
 412 {
 413     VM&amp; vm = globalObject-&gt;vm();
 414     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 415     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 416     auto scope = DECLARE_THROW_SCOPE(vm);
 417     Structure* structure = InternalFunction::createSubclassStructure(globalObject, nullptr, constructor, globalObject-&gt;generatorStructure());
 418     RETURN_IF_EXCEPTION(scope, nullptr);
 419     RELEASE_AND_RETURN(scope, JSGenerator::create(vm, structure));
 420 }
 421 
 422 JSCell* JIT_OPERATION operationCreateAsyncGenerator(JSGlobalObject* globalObject, JSObject* constructor)
 423 {
 424     VM&amp; vm = globalObject-&gt;vm();
 425     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 426     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 427     auto scope = DECLARE_THROW_SCOPE(vm);
 428     Structure* structure = InternalFunction::createSubclassStructure(globalObject, nullptr, constructor, globalObject-&gt;asyncGeneratorStructure());
 429     RETURN_IF_EXCEPTION(scope, nullptr);
 430     RELEASE_AND_RETURN(scope, JSAsyncGenerator::create(vm, structure));
 431 }
 432 
 433 JSCell* JIT_OPERATION operationCallObjectConstructor(JSGlobalObject* globalObject, EncodedJSValue encodedTarget)
 434 {
 435     VM&amp; vm = globalObject-&gt;vm();
 436     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 437     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 438 
 439     JSValue value = JSValue::decode(encodedTarget);
 440     ASSERT(!value.isObject());
 441 
 442     if (value.isUndefinedOrNull())
 443         return constructEmptyObject(globalObject, globalObject-&gt;objectPrototype());
 444     return value.toObject(globalObject);
 445 }
 446 
 447 JSCell* JIT_OPERATION operationToObject(JSGlobalObject* globalObject, EncodedJSValue encodedTarget, UniquedStringImpl* errorMessage)
 448 {
 449     VM&amp; vm = globalObject-&gt;vm();
 450     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 451     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 452     auto scope = DECLARE_THROW_SCOPE(vm);
 453 
 454     JSValue value = JSValue::decode(encodedTarget);
 455     ASSERT(!value.isObject());
 456 
 457     if (UNLIKELY(value.isUndefinedOrNull())) {
 458         if (errorMessage &amp;&amp; errorMessage-&gt;length()) {
 459             throwVMTypeError(globalObject, scope, errorMessage);
 460             return nullptr;
 461         }
 462     }
 463 
 464     RELEASE_AND_RETURN(scope, value.toObject(globalObject));
 465 }
 466 
 467 EncodedJSValue JIT_OPERATION operationValueMod(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 468 {
 469     VM&amp; vm = globalObject-&gt;vm();
 470     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 471     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 472 
 473     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {
 474         return JSBigInt::remainder(globalObject, left, right);
 475     };
 476 
 477     auto numberOp = [] (double left, double right) -&gt; double {
 478         return jsMod(left, right);
 479     };
 480 
 481     return binaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;);
 482 }
 483 
 484 EncodedJSValue JIT_OPERATION operationInc(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)
 485 {
 486     VM&amp; vm = globalObject-&gt;vm();
 487     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 488     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 489     auto scope = DECLARE_THROW_SCOPE(vm);
 490 
 491     JSValue op1 = JSValue::decode(encodedOp1);
 492 
 493     auto operandNumeric = op1.toNumeric(globalObject);
 494     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 495 
 496     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))
 497         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::inc(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));
 498 
 499     double value = WTF::get&lt;double&gt;(operandNumeric);
 500     return JSValue::encode(jsNumber(value + 1));
 501 }
 502 
 503 EncodedJSValue JIT_OPERATION operationDec(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)
 504 {
 505     VM&amp; vm = globalObject-&gt;vm();
 506     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 507     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 508     auto scope = DECLARE_THROW_SCOPE(vm);
 509 
 510     JSValue op1 = JSValue::decode(encodedOp1);
 511 
 512     auto operandNumeric = op1.toNumeric(globalObject);
 513     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 514 
 515     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))
 516         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::dec(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));
 517 
 518     double value = WTF::get&lt;double&gt;(operandNumeric);
 519     return JSValue::encode(jsNumber(value - 1));
 520 }
 521 
 522 EncodedJSValue JIT_OPERATION operationValueBitNot(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)
 523 {
 524     VM&amp; vm = globalObject-&gt;vm();
 525     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 526     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 527     auto scope = DECLARE_THROW_SCOPE(vm);
 528 
 529     JSValue op1 = JSValue::decode(encodedOp1);
 530 
 531     auto operandNumeric = op1.toBigIntOrInt32(globalObject);
 532     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 533 
 534     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))
 535         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::bitwiseNot(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));
 536 
 537     return JSValue::encode(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
 538 }
 539 
 540 EncodedJSValue JIT_OPERATION operationValueBitAnd(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 541 {
 542     VM&amp; vm = globalObject-&gt;vm();
 543     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 544     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 545 
 546     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {
 547         return JSBigInt::bitwiseAnd(globalObject, left, right);
 548     };
 549 
 550     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 551         return left &amp; right;
 552     };
 553 
 554     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;_s);
 555 }
 556 
 557 EncodedJSValue JIT_OPERATION operationValueBitOr(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 558 {
 559     VM&amp; vm = globalObject-&gt;vm();
 560     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 561     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 562 
 563     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {
 564         return JSBigInt::bitwiseOr(globalObject, left, right);
 565     };
 566 
 567     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 568         return left | right;
 569     };
 570 
 571     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;_s);
 572 }
 573 
 574 EncodedJSValue JIT_OPERATION operationValueBitXor(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 575 {
 576     VM&amp; vm = globalObject-&gt;vm();
 577     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 578     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 579 
 580     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {
 581         return JSBigInt::bitwiseXor(globalObject, left, right);
 582     };
 583 
 584     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 585         return left ^ right;
 586     };
 587 
 588     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;_s);
 589 }
 590 
 591 EncodedJSValue JIT_OPERATION operationValueBitLShift(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 592 {
 593     VM&amp; vm = globalObject-&gt;vm();
 594     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 595     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 596 
 597     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {
 598         return JSBigInt::leftShift(globalObject, left, right);
 599     };
 600 
 601     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 602         return left &lt;&lt; (right &amp; 0x1f);
 603     };
 604 
 605     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;_s);
 606 }
 607 
 608 EncodedJSValue JIT_OPERATION operationValueBitRShift(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 609 {
 610     VM&amp; vm = globalObject-&gt;vm();
 611     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 612     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 613 
 614     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {
 615         return JSBigInt::signedRightShift(globalObject, left, right);
 616     };
 617 
 618     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 619         return left &gt;&gt; (right &amp; 0x1f);
 620     };
 621 
 622     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in signed right shift operation.&quot;_s);
 623 }
 624 
 625 EncodedJSValue JIT_OPERATION operationValueBitURShift(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 626 {
 627     VM&amp; vm = globalObject-&gt;vm();
 628     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 629     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 630     auto scope = DECLARE_THROW_SCOPE(vm);
 631 
 632     JSValue op1 = JSValue::decode(encodedOp1);
 633     JSValue op2 = JSValue::decode(encodedOp2);
 634 
 635     uint32_t a = op1.toUInt32(globalObject);
 636     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 637     scope.release();
 638     uint32_t b = op2.toUInt32(globalObject);
 639     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 0x1f))));
 640 }
 641 
 642 EncodedJSValue JIT_OPERATION operationValueAddNotNumber(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 643 {
 644     VM&amp; vm = globalObject-&gt;vm();
 645     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 646     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 647 
 648     JSValue op1 = JSValue::decode(encodedOp1);
 649     JSValue op2 = JSValue::decode(encodedOp2);
 650 
 651     return JSValue::encode(jsAddNonNumber(globalObject, op1, op2));
 652 }
 653 
 654 EncodedJSValue JIT_OPERATION operationValueDiv(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 655 {
 656     VM&amp; vm = globalObject-&gt;vm();
 657     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 658     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 659 
 660     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {
 661         return JSBigInt::divide(globalObject, left, right);
 662     };
 663 
 664     auto numberOp = [] (double left, double right) -&gt; double {
 665         return left / right;
 666     };
 667 
 668     return binaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in division operation.&quot;);
 669 }
 670 
 671 EncodedJSValue JIT_OPERATION operationValuePow(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
 672 {
 673     VM&amp; vm = globalObject-&gt;vm();
 674     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 675     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 676 
 677     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {
 678         return JSBigInt::exponentiate(globalObject, left, right);
 679     };
 680 
 681     auto numberOp = [] (double left, double right) -&gt; double {
 682         return operationMathPow(left, right);
 683     };
 684 
 685     return binaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;_s);
 686 }
 687 
 688 double JIT_OPERATION operationArithAbs(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)
 689 {
 690     VM&amp; vm = globalObject-&gt;vm();
 691     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 692     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 693     auto scope = DECLARE_THROW_SCOPE(vm);
 694 
 695     JSValue op1 = JSValue::decode(encodedOp1);
 696     double a = op1.toNumber(globalObject);
 697     RETURN_IF_EXCEPTION(scope, PNaN);
 698     return fabs(a);
 699 }
 700 
 701 uint32_t JIT_OPERATION operationArithClz32(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)
 702 {
 703     VM&amp; vm = globalObject-&gt;vm();
 704     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 705     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 706     auto scope = DECLARE_THROW_SCOPE(vm);
 707 
 708     JSValue op1 = JSValue::decode(encodedOp1);
 709     uint32_t value = op1.toUInt32(globalObject);
 710     RETURN_IF_EXCEPTION(scope, 0);
 711     return clz(value);
 712 }
 713 
 714 double JIT_OPERATION operationArithFRound(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)
 715 {
 716     VM&amp; vm = globalObject-&gt;vm();
 717     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 718     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 719     auto scope = DECLARE_THROW_SCOPE(vm);
 720 
 721     JSValue op1 = JSValue::decode(encodedOp1);
 722     double a = op1.toNumber(globalObject);
 723     RETURN_IF_EXCEPTION(scope, PNaN);
 724     return static_cast&lt;float&gt;(a);
 725 }
 726 
 727 #define DFG_ARITH_UNARY(capitalizedName, lowerName) \
 728 double JIT_OPERATION operationArith##capitalizedName(JSGlobalObject* globalObject, EncodedJSValue encodedOp1) \
 729 { \
 730     VM&amp; vm = globalObject-&gt;vm(); \
 731     CallFrame* callFrame = DECLARE_CALL_FRAME(vm); \
 732     JITOperationPrologueCallFrameTracer tracer(vm, callFrame); \
 733     auto scope = DECLARE_THROW_SCOPE(vm); \
 734     JSValue op1 = JSValue::decode(encodedOp1); \
 735     double result = op1.toNumber(globalObject); \
 736     RETURN_IF_EXCEPTION(scope, PNaN); \
 737     return JSC::Math::lowerName(result); \
 738 }
 739     FOR_EACH_DFG_ARITH_UNARY_OP(DFG_ARITH_UNARY)
 740 #undef DFG_ARITH_UNARY
 741 
 742 double JIT_OPERATION operationArithSqrt(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)
 743 {
 744     VM&amp; vm = globalObject-&gt;vm();
 745     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 746     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 747     auto scope = DECLARE_THROW_SCOPE(vm);
 748 
 749     JSValue op1 = JSValue::decode(encodedOp1);
 750     double a = op1.toNumber(globalObject);
 751     RETURN_IF_EXCEPTION(scope, PNaN);
 752     return sqrt(a);
 753 }
 754 
 755 EncodedJSValue JIT_OPERATION operationArithRound(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)
 756 {
 757     VM&amp; vm = globalObject-&gt;vm();
 758     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 759     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 760     auto scope = DECLARE_THROW_SCOPE(vm);
 761 
 762     JSValue argument = JSValue::decode(encodedArgument);
 763     double valueOfArgument = argument.toNumber(globalObject);
 764     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 765     return JSValue::encode(jsNumber(jsRound(valueOfArgument)));
 766 }
 767 
 768 EncodedJSValue JIT_OPERATION operationArithFloor(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)
 769 {
 770     VM&amp; vm = globalObject-&gt;vm();
 771     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 772     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 773     auto scope = DECLARE_THROW_SCOPE(vm);
 774 
 775     JSValue argument = JSValue::decode(encodedArgument);
 776     double valueOfArgument = argument.toNumber(globalObject);
 777     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 778     return JSValue::encode(jsNumber(floor(valueOfArgument)));
 779 }
 780 
 781 EncodedJSValue JIT_OPERATION operationArithCeil(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)
 782 {
 783     VM&amp; vm = globalObject-&gt;vm();
 784     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 785     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 786     auto scope = DECLARE_THROW_SCOPE(vm);
 787 
 788     JSValue argument = JSValue::decode(encodedArgument);
 789     double valueOfArgument = argument.toNumber(globalObject);
 790     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 791     return JSValue::encode(jsNumber(ceil(valueOfArgument)));
 792 }
 793 
 794 EncodedJSValue JIT_OPERATION operationArithTrunc(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)
 795 {
 796     VM&amp; vm = globalObject-&gt;vm();
 797     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 798     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 799     auto scope = DECLARE_THROW_SCOPE(vm);
 800 
 801     JSValue argument = JSValue::decode(encodedArgument);
 802     double truncatedValueOfArgument = argument.toIntegerPreserveNaN(globalObject);
 803     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 804     return JSValue::encode(jsNumber(truncatedValueOfArgument));
 805 }
 806 
 807 EncodedJSValue JIT_OPERATION operationGetByValCell(JSGlobalObject* globalObject, JSCell* base, EncodedJSValue encodedProperty)
 808 {
 809     VM&amp; vm = globalObject-&gt;vm();
 810     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 811     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 812     auto scope = DECLARE_THROW_SCOPE(vm);
 813 
 814     JSValue property = JSValue::decode(encodedProperty);
 815 
 816     if (property.isUInt32())
 817         RELEASE_AND_RETURN(scope, getByValWithIndex(globalObject, base, property.asUInt32()));
 818 
 819     if (property.isDouble()) {
 820         double propertyAsDouble = property.asDouble();
 821         uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
 822         if (propertyAsUInt32 == propertyAsDouble)
 823             RELEASE_AND_RETURN(scope, getByValWithIndex(globalObject, base, propertyAsUInt32));
 824 
 825     } else if (property.isString()) {
 826         Structure&amp; structure = *base-&gt;structure(vm);
 827         if (JSCell::canUseFastGetOwnProperty(structure)) {
 828             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(property)-&gt;toExistingAtomString(globalObject);
 829             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 830             if (existingAtomString) {
 831                 if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
 832                     return JSValue::encode(result);
 833             }
 834         }
 835     }
 836 
 837     auto propertyName = property.toPropertyKey(globalObject);
 838     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 839     RELEASE_AND_RETURN(scope, JSValue::encode(JSValue(base).get(globalObject, propertyName)));
 840 }
 841 
 842 ALWAYS_INLINE EncodedJSValue getByValCellInt(JSGlobalObject* globalObject, VM&amp; vm, JSCell* base, int32_t index)
 843 {
 844     if (index &lt; 0) {
 845         // Go the slowest way possible because negative indices don&#39;t use indexed storage.
 846         return JSValue::encode(JSValue(base).get(globalObject, Identifier::from(vm, index)));
 847     }
 848 
 849     // Use this since we know that the value is out of bounds.
 850     return JSValue::encode(JSValue(base).get(globalObject, static_cast&lt;unsigned&gt;(index)));
 851 }
 852 
 853 EncodedJSValue JIT_OPERATION operationGetByValObjectInt(JSGlobalObject* globalObject, JSObject* base, int32_t index)
 854 {
 855     VM&amp; vm = globalObject-&gt;vm();
 856     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 857     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 858 
 859     return getByValCellInt(globalObject, vm, base, index);
 860 }
 861 
 862 EncodedJSValue JIT_OPERATION operationGetByValStringInt(JSGlobalObject* globalObject, JSString* base, int32_t index)
 863 {
 864     VM&amp; vm = globalObject-&gt;vm();
 865     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 866     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 867 
 868     return getByValCellInt(globalObject, vm, base, index);
 869 }
 870 
 871 EncodedJSValue JIT_OPERATION operationGetByValObjectString(JSGlobalObject* globalObject, JSCell* base, JSCell* string)
 872 {
 873     VM&amp; vm = globalObject-&gt;vm();
 874     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 875     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 876 
 877     auto scope = DECLARE_THROW_SCOPE(vm);
 878 
 879     auto propertyName = asString(string)-&gt;toIdentifier(globalObject);
 880     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 881 
 882     RELEASE_AND_RETURN(scope, JSValue::encode(getByValObject(globalObject, vm, asObject(base), propertyName)));
 883 }
 884 
 885 EncodedJSValue JIT_OPERATION operationGetByValObjectSymbol(JSGlobalObject* globalObject, JSCell* base, JSCell* symbol)
 886 {
 887     VM&amp; vm = globalObject-&gt;vm();
 888     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 889     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 890 
 891     auto propertyName = asSymbol(symbol)-&gt;privateName();
 892     return JSValue::encode(getByValObject(globalObject, vm, asObject(base), propertyName));
 893 }
 894 
 895 void JIT_OPERATION operationPutByValStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 896 {
 897     VM&amp; vm = globalObject-&gt;vm();
 898     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 899     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 900 
 901     putByValInternal&lt;true, false&gt;(globalObject, vm, encodedBase, encodedProperty, encodedValue);
 902 }
 903 
 904 void JIT_OPERATION operationPutByValNonStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 905 {
 906     VM&amp; vm = globalObject-&gt;vm();
 907     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 908     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 909 
 910     putByValInternal&lt;false, false&gt;(globalObject, vm, encodedBase, encodedProperty, encodedValue);
 911 }
 912 
 913 void JIT_OPERATION operationPutByValCellStrict(JSGlobalObject* globalObject, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 914 {
 915     VM&amp; vm = globalObject-&gt;vm();
 916     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 917     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 918 
 919     putByValInternal&lt;true, false&gt;(globalObject, vm, JSValue::encode(cell), encodedProperty, encodedValue);
 920 }
 921 
 922 void JIT_OPERATION operationPutByValCellNonStrict(JSGlobalObject* globalObject, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
 923 {
 924     VM&amp; vm = globalObject-&gt;vm();
 925     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 926     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 927 
 928     putByValInternal&lt;false, false&gt;(globalObject, vm, JSValue::encode(cell), encodedProperty, encodedValue);
 929 }
 930 
 931 void JIT_OPERATION operationPutByValCellStringStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
 932 {
 933     VM&amp; vm = globalObject-&gt;vm();
 934     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 935     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 936 
 937     putByValCellStringInternal&lt;true, false&gt;(globalObject, vm, cell, asString(string), JSValue::decode(encodedValue));
 938 }
 939 
 940 void JIT_OPERATION operationPutByValCellStringNonStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
 941 {
 942     VM&amp; vm = globalObject-&gt;vm();
 943     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 944     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 945 
 946     putByValCellStringInternal&lt;false, false&gt;(globalObject, vm, cell, asString(string), JSValue::decode(encodedValue));
 947 }
 948 
 949 void JIT_OPERATION operationPutByValCellSymbolStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
 950 {
 951     VM&amp; vm = globalObject-&gt;vm();
 952     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 953     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 954 
 955     auto propertyName = asSymbol(symbol)-&gt;privateName();
 956     putByValCellInternal&lt;true, false&gt;(globalObject, vm, cell, propertyName, JSValue::decode(encodedValue));
 957 }
 958 
 959 void JIT_OPERATION operationPutByValCellSymbolNonStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
 960 {
 961     VM&amp; vm = globalObject-&gt;vm();
 962     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 963     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 964 
 965     auto propertyName = asSymbol(symbol)-&gt;privateName();
 966     putByValCellInternal&lt;false, false&gt;(globalObject, vm, cell, propertyName, JSValue::decode(encodedValue));
 967 }
 968 
 969 void JIT_OPERATION operationPutByValBeyondArrayBoundsStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, EncodedJSValue encodedValue)
 970 {
 971     VM&amp; vm = globalObject-&gt;vm();
 972     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 973     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 974 
 975     if (index &gt;= 0) {
 976         object-&gt;putByIndexInline(globalObject, index, JSValue::decode(encodedValue), true);
 977         return;
 978     }
 979 
 980     PutPropertySlot slot(object, true);
 981     object-&gt;methodTable(vm)-&gt;put(
 982         object, globalObject, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);
 983 }
 984 
 985 void JIT_OPERATION operationPutByValBeyondArrayBoundsNonStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, EncodedJSValue encodedValue)
 986 {
 987     VM&amp; vm = globalObject-&gt;vm();
 988     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 989     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 990 
 991     if (index &gt;= 0) {
 992         object-&gt;putByIndexInline(globalObject, index, JSValue::decode(encodedValue), false);
 993         return;
 994     }
 995 
 996     PutPropertySlot slot(object, false);
 997     object-&gt;methodTable(vm)-&gt;put(
 998         object, globalObject, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);
 999 }
1000 
1001 void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, double value)
1002 {
1003     VM&amp; vm = globalObject-&gt;vm();
1004     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1005     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1006 
1007     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
1008 
1009     if (index &gt;= 0) {
1010         object-&gt;putByIndexInline(globalObject, index, jsValue, true);
1011         return;
1012     }
1013 
1014     PutPropertySlot slot(object, true);
1015     object-&gt;methodTable(vm)-&gt;put(
1016         object, globalObject, Identifier::from(vm, index), jsValue, slot);
1017 }
1018 
1019 void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsNonStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, double value)
1020 {
1021     VM&amp; vm = globalObject-&gt;vm();
1022     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1023     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1024 
1025     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
1026 
1027     if (index &gt;= 0) {
1028         object-&gt;putByIndexInline(globalObject, index, jsValue, false);
1029         return;
1030     }
1031 
1032     PutPropertySlot slot(object, false);
1033     object-&gt;methodTable(vm)-&gt;put(
1034         object, globalObject, Identifier::from(vm, index), jsValue, slot);
1035 }
1036 
1037 void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, double value)
1038 {
1039     VM&amp; vm = globalObject-&gt;vm();
1040     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1041     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1042 
1043     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
1044 
1045     if (index &gt;= 0) {
1046         object-&gt;putDirectIndex(globalObject, index, jsValue, 0, PutDirectIndexShouldThrow);
1047         return;
1048     }
1049 
1050     PutPropertySlot slot(object, true);
1051     CommonSlowPaths::putDirectWithReify(vm, globalObject, object, Identifier::from(vm, index), jsValue, slot);
1052 }
1053 
1054 void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsNonStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, double value)
1055 {
1056     VM&amp; vm = globalObject-&gt;vm();
1057     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1058     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1059 
1060     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
1061 
1062     if (index &gt;= 0) {
1063         object-&gt;putDirectIndex(globalObject, index, jsValue);
1064         return;
1065     }
1066 
1067     PutPropertySlot slot(object, false);
1068     CommonSlowPaths::putDirectWithReify(vm, globalObject, object, Identifier::from(vm, index), jsValue, slot);
1069 }
1070 
1071 void JIT_OPERATION operationPutByValDirectStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
1072 {
1073     VM&amp; vm = globalObject-&gt;vm();
1074     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1075     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1076 
1077     putByValInternal&lt;true, true&gt;(globalObject, vm, encodedBase, encodedProperty, encodedValue);
1078 }
1079 
1080 void JIT_OPERATION operationPutByValDirectNonStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
1081 {
1082     VM&amp; vm = globalObject-&gt;vm();
1083     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1084     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1085 
1086     putByValInternal&lt;false, true&gt;(globalObject, vm, encodedBase, encodedProperty, encodedValue);
1087 }
1088 
1089 void JIT_OPERATION operationPutByValDirectCellStrict(JSGlobalObject* globalObject, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
1090 {
1091     VM&amp; vm = globalObject-&gt;vm();
1092     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1093     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1094 
1095     putByValInternal&lt;true, true&gt;(globalObject, vm, JSValue::encode(cell), encodedProperty, encodedValue);
1096 }
1097 
1098 void JIT_OPERATION operationPutByValDirectCellNonStrict(JSGlobalObject* globalObject, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
1099 {
1100     VM&amp; vm = globalObject-&gt;vm();
1101     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1102     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1103 
1104     putByValInternal&lt;false, true&gt;(globalObject, vm, JSValue::encode(cell), encodedProperty, encodedValue);
1105 }
1106 
1107 void JIT_OPERATION operationPutByValDirectCellStringStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
1108 {
1109     VM&amp; vm = globalObject-&gt;vm();
1110     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1111     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1112 
1113     putByValCellStringInternal&lt;true, true&gt;(globalObject, vm, cell, asString(string), JSValue::decode(encodedValue));
1114 }
1115 
1116 void JIT_OPERATION operationPutByValDirectCellStringNonStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
1117 {
1118     VM&amp; vm = globalObject-&gt;vm();
1119     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1120     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1121 
1122     putByValCellStringInternal&lt;false, true&gt;(globalObject, vm, cell, asString(string), JSValue::decode(encodedValue));
1123 }
1124 
1125 void JIT_OPERATION operationPutByValDirectCellSymbolStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
1126 {
1127     VM&amp; vm = globalObject-&gt;vm();
1128     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1129     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1130 
1131     auto propertyName = asSymbol(symbol)-&gt;privateName();
1132     putByValCellInternal&lt;true, true&gt;(globalObject, vm, cell, propertyName, JSValue::decode(encodedValue));
1133 }
1134 
1135 void JIT_OPERATION operationPutByValDirectCellSymbolNonStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
1136 {
1137     VM&amp; vm = globalObject-&gt;vm();
1138     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1139     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1140 
1141     auto propertyName = asSymbol(symbol)-&gt;privateName();
1142     putByValCellInternal&lt;false, true&gt;(globalObject, vm, cell, propertyName, JSValue::decode(encodedValue));
1143 }
1144 
1145 void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, EncodedJSValue encodedValue)
1146 {
1147     VM&amp; vm = globalObject-&gt;vm();
1148     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1149     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1150     if (index &gt;= 0) {
1151         object-&gt;putDirectIndex(globalObject, index, JSValue::decode(encodedValue), 0, PutDirectIndexShouldThrow);
1152         return;
1153     }
1154 
1155     PutPropertySlot slot(object, true);
1156     CommonSlowPaths::putDirectWithReify(vm, globalObject, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);
1157 }
1158 
1159 void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsNonStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, EncodedJSValue encodedValue)
1160 {
1161     VM&amp; vm = globalObject-&gt;vm();
1162     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1163     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1164 
1165     if (index &gt;= 0) {
1166         object-&gt;putDirectIndex(globalObject, index, JSValue::decode(encodedValue));
1167         return;
1168     }
1169 
1170     PutPropertySlot slot(object, false);
1171     CommonSlowPaths::putDirectWithReify(vm, globalObject, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);
1172 }
1173 
1174 EncodedJSValue JIT_OPERATION operationArrayPush(JSGlobalObject* globalObject, EncodedJSValue encodedValue, JSArray* array)
1175 {
1176     VM&amp; vm = globalObject-&gt;vm();
1177     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1178     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1179 
1180     array-&gt;pushInline(globalObject, JSValue::decode(encodedValue));
1181     return JSValue::encode(jsNumber(array-&gt;length()));
1182 }
1183 
1184 EncodedJSValue JIT_OPERATION operationArrayPushDouble(JSGlobalObject* globalObject, double value, JSArray* array)
1185 {
1186     VM&amp; vm = globalObject-&gt;vm();
1187     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1188     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1189 
1190     array-&gt;pushInline(globalObject, JSValue(JSValue::EncodeAsDouble, value));
1191     return JSValue::encode(jsNumber(array-&gt;length()));
1192 }
1193 
1194 EncodedJSValue JIT_OPERATION operationArrayPushMultiple(JSGlobalObject* globalObject, JSArray* array, void* buffer, int32_t elementCount)
1195 {
1196     VM&amp; vm = globalObject-&gt;vm();
1197     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1198     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1199     auto scope = DECLARE_THROW_SCOPE(vm);
1200 
1201     // We assume that multiple JSArray::push calls with ArrayWithInt32/ArrayWithContiguous do not cause JS traps.
1202     // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
1203     // content of ScratchBuffer. If the IndexingType is now ArrayWithInt32/ArrayWithContiguous, we can ensure
1204     // that there is no indexed accessors in this object and its prototype chain.
1205     //
1206     // ArrayWithArrayStorage is also OK. It can have indexed accessors. But if you define an indexed accessor, the array&#39;s length
1207     // becomes larger than that index. So Array#push never overlaps with this accessor. So accessors are never called unless
1208     // the IndexingType is ArrayWithSlowPutArrayStorage which could have an indexed accessor in a prototype chain.
1209     RELEASE_ASSERT(!shouldUseSlowPut(array-&gt;indexingType()));
1210 
1211     EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
1212     for (int32_t i = 0; i &lt; elementCount; ++i) {
1213         array-&gt;pushInline(globalObject, JSValue::decode(values[i]));
1214         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1215     }
1216     return JSValue::encode(jsNumber(array-&gt;length()));
1217 }
1218 
1219 EncodedJSValue JIT_OPERATION operationArrayPushDoubleMultiple(JSGlobalObject* globalObject, JSArray* array, void* buffer, int32_t elementCount)
1220 {
1221     VM&amp; vm = globalObject-&gt;vm();
1222     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1223     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1224     auto scope = DECLARE_THROW_SCOPE(vm);
1225 
1226     // We assume that multiple JSArray::push calls with ArrayWithDouble do not cause JS traps.
1227     // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
1228     // content of ScratchBuffer. If the IndexingType is now ArrayWithDouble, we can ensure
1229     // that there is no indexed accessors in this object and its prototype chain.
1230     ASSERT(array-&gt;indexingMode() == ArrayWithDouble);
1231 
1232     double* values = static_cast&lt;double*&gt;(buffer);
1233     for (int32_t i = 0; i &lt; elementCount; ++i) {
1234         array-&gt;pushInline(globalObject, JSValue(JSValue::EncodeAsDouble, values[i]));
1235         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1236     }
1237     return JSValue::encode(jsNumber(array-&gt;length()));
1238 }
1239 
1240 EncodedJSValue JIT_OPERATION operationArrayPop(JSGlobalObject* globalObject, JSArray* array)
1241 {
1242     VM&amp; vm = globalObject-&gt;vm();
1243     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1244     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1245 
1246     return JSValue::encode(array-&gt;pop(globalObject));
1247 }
1248 
1249 EncodedJSValue JIT_OPERATION operationArrayPopAndRecoverLength(JSGlobalObject* globalObject, JSArray* array)
1250 {
1251     VM&amp; vm = globalObject-&gt;vm();
1252     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1253     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1254 
1255     array-&gt;butterfly()-&gt;setPublicLength(array-&gt;butterfly()-&gt;publicLength() + 1);
1256 
1257     return JSValue::encode(array-&gt;pop(globalObject));
1258 }
1259 
1260 EncodedJSValue JIT_OPERATION operationRegExpExecString(JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)
1261 {
1262     SuperSamplerScope superSamplerScope(false);
1263 
1264     VM&amp; vm = globalObject-&gt;vm();
1265     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1266     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1267 
1268     return JSValue::encode(regExpObject-&gt;execInline(globalObject, argument));
1269 }
1270 
1271 EncodedJSValue JIT_OPERATION operationRegExpExec(JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)
1272 {
1273     SuperSamplerScope superSamplerScope(false);
1274 
1275     VM&amp; vm = globalObject-&gt;vm();
1276     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1277     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1278     auto scope = DECLARE_THROW_SCOPE(vm);
1279 
1280     JSValue argument = JSValue::decode(encodedArgument);
1281 
1282     JSString* input = argument.toStringOrNull(globalObject);
1283     EXCEPTION_ASSERT(!!scope.exception() == !input);
1284     if (!input)
1285         return encodedJSValue();
1286     RELEASE_AND_RETURN(scope, JSValue::encode(regExpObject-&gt;execInline(globalObject, input)));
1287 }
1288 
1289 EncodedJSValue JIT_OPERATION operationRegExpExecGeneric(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)
1290 {
1291     SuperSamplerScope superSamplerScope(false);
1292 
1293     VM&amp; vm = globalObject-&gt;vm();
1294     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1295     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1296     auto scope = DECLARE_THROW_SCOPE(vm);
1297 
1298     JSValue base = JSValue::decode(encodedBase);
1299     JSValue argument = JSValue::decode(encodedArgument);
1300 
1301     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
1302     if (UNLIKELY(!regexp))
1303         return throwVMTypeError(globalObject, scope);
1304 
1305     JSString* input = argument.toStringOrNull(globalObject);
1306     EXCEPTION_ASSERT(!!scope.exception() == !input);
1307     if (!input)
1308         return JSValue::encode(jsUndefined());
1309     RELEASE_AND_RETURN(scope, JSValue::encode(regexp-&gt;exec(globalObject, input)));
1310 }
1311 
1312 EncodedJSValue JIT_OPERATION operationRegExpExecNonGlobalOrSticky(JSGlobalObject* globalObject, RegExp* regExp, JSString* string)
1313 {
1314     SuperSamplerScope superSamplerScope(false);
1315 
1316     VM&amp; vm = globalObject-&gt;vm();
1317     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1318     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1319 
1320     auto scope = DECLARE_THROW_SCOPE(vm);
1321 
1322     String input = string-&gt;value(globalObject);
1323     RETURN_IF_EXCEPTION(scope, { });
1324 
1325     unsigned lastIndex = 0;
1326     MatchResult result;
1327     JSArray* array = createRegExpMatchesArray(vm, globalObject, string, input, regExp, lastIndex, result);
1328     RETURN_IF_EXCEPTION(scope, { });
1329     if (!array)
1330         return JSValue::encode(jsNull());
1331 
1332     globalObject-&gt;regExpGlobalData().recordMatch(vm, globalObject, regExp, string, result);
1333     return JSValue::encode(array);
1334 }
1335 
1336 EncodedJSValue JIT_OPERATION operationRegExpMatchFastString(JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)
1337 {
1338     SuperSamplerScope superSamplerScope(false);
1339 
1340     VM&amp; vm = globalObject-&gt;vm();
1341     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1342     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1343 
1344     if (!regExpObject-&gt;regExp()-&gt;global())
1345         return JSValue::encode(regExpObject-&gt;execInline(globalObject, argument));
1346     return JSValue::encode(regExpObject-&gt;matchGlobal(globalObject, argument));
1347 }
1348 
1349 EncodedJSValue JIT_OPERATION operationRegExpMatchFastGlobalString(JSGlobalObject* globalObject, RegExp* regExp, JSString* string)
1350 {
1351     SuperSamplerScope superSamplerScope(false);
1352 
1353     VM&amp; vm = globalObject-&gt;vm();
1354     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1355     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1356 
1357     auto scope = DECLARE_THROW_SCOPE(vm);
1358 
1359     ASSERT(regExp-&gt;global());
1360 
1361     String s = string-&gt;value(globalObject);
1362     RETURN_IF_EXCEPTION(scope, { });
1363 
1364     if (regExp-&gt;unicode()) {
1365         unsigned stringLength = s.length();
1366         RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
1367             vm, globalObject, string, s, regExp,
1368             [&amp;] (size_t end) -&gt; size_t {
1369                 return advanceStringUnicode(s, stringLength, end);
1370             })));
1371     }
1372 
1373     RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
1374         vm, globalObject, string, s, regExp,
1375         [&amp;] (size_t end) -&gt; size_t {
1376             return end + 1;
1377         })));
1378 }
1379 
1380 EncodedJSValue JIT_OPERATION operationParseIntNoRadixGeneric(JSGlobalObject* globalObject, EncodedJSValue value)
1381 {
1382     VM&amp; vm = globalObject-&gt;vm();
1383     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1384     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1385 
1386     return toStringView(globalObject, JSValue::decode(value), [&amp;] (StringView view) {
1387         // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
1388         return parseIntResult(parseInt(view, 0));
1389     });
1390 }
1391 
1392 EncodedJSValue JIT_OPERATION operationParseIntStringNoRadix(JSGlobalObject* globalObject, JSString* string)
1393 {
1394     VM&amp; vm = globalObject-&gt;vm();
1395     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1396     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1397     auto scope = DECLARE_THROW_SCOPE(vm);
1398 
1399     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);
1400     RETURN_IF_EXCEPTION(scope, { });
1401 
1402     // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
1403     return parseIntResult(parseInt(viewWithString.view, 0));
1404 }
1405 
1406 EncodedJSValue JIT_OPERATION operationParseIntString(JSGlobalObject* globalObject, JSString* string, int32_t radix)
1407 {
1408     VM&amp; vm = globalObject-&gt;vm();
1409     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1410     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1411     auto scope = DECLARE_THROW_SCOPE(vm);
1412 
1413     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);
1414     RETURN_IF_EXCEPTION(scope, { });
1415 
1416     return parseIntResult(parseInt(viewWithString.view, radix));
1417 }
1418 
1419 EncodedJSValue JIT_OPERATION operationParseIntGeneric(JSGlobalObject* globalObject, EncodedJSValue value, int32_t radix)
1420 {
1421     VM&amp; vm = globalObject-&gt;vm();
1422     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1423     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1424 
1425     return toStringView(globalObject, JSValue::decode(value), [&amp;] (StringView view) {
1426         return parseIntResult(parseInt(view, radix));
1427     });
1428 }
1429 
1430 size_t JIT_OPERATION operationRegExpTestString(JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* input)
1431 {
1432     SuperSamplerScope superSamplerScope(false);
1433 
1434     VM&amp; vm = globalObject-&gt;vm();
1435     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1436     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1437 
1438     return regExpObject-&gt;testInline(globalObject, input);
1439 }
1440 
1441 size_t JIT_OPERATION operationRegExpTest(JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)
1442 {
1443     SuperSamplerScope superSamplerScope(false);
1444 
1445     VM&amp; vm = globalObject-&gt;vm();
1446     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1447     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1448 
1449     JSValue argument = JSValue::decode(encodedArgument);
1450 
1451     JSString* input = argument.toStringOrNull(globalObject);
1452     if (!input)
1453         return false;
1454     return regExpObject-&gt;testInline(globalObject, input);
1455 }
1456 
1457 size_t JIT_OPERATION operationRegExpTestGeneric(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)
1458 {
1459     SuperSamplerScope superSamplerScope(false);
1460 
1461     VM&amp; vm = globalObject-&gt;vm();
1462     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1463     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1464     auto scope = DECLARE_THROW_SCOPE(vm);
1465 
1466     JSValue base = JSValue::decode(encodedBase);
1467     JSValue argument = JSValue::decode(encodedArgument);
1468 
1469     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
1470     if (UNLIKELY(!regexp)) {
1471         throwTypeError(globalObject, scope);
1472         return false;
1473     }
1474 
1475     JSString* input = argument.toStringOrNull(globalObject);
1476     EXCEPTION_ASSERT(!!scope.exception() == !input);
1477     if (!input)
1478         return false;
1479     RELEASE_AND_RETURN(scope, regexp-&gt;test(globalObject, input));
1480 }
1481 
1482 JSCell* JIT_OPERATION operationSubBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)
1483 {
1484     VM&amp; vm = globalObject-&gt;vm();
1485     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1486     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1487 
1488     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1489     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1490 
1491     return JSBigInt::sub(globalObject, leftOperand, rightOperand);
1492 }
1493 
1494 JSCell* JIT_OPERATION operationBitNotBigInt(JSGlobalObject* globalObject, JSCell* op1)
1495 {
1496     VM&amp; vm = globalObject-&gt;vm();
1497     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1498     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1499 
1500     JSBigInt* operand = jsCast&lt;JSBigInt*&gt;(op1);
1501 
1502     return JSBigInt::bitwiseNot(globalObject, operand);
1503 }
1504 
1505 JSCell* JIT_OPERATION operationMulBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)
1506 {
1507     VM&amp; vm = globalObject-&gt;vm();
1508     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1509     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1510 
1511     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1512     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1513 
1514     return JSBigInt::multiply(globalObject, leftOperand, rightOperand);
1515 }
1516 
1517 JSCell* JIT_OPERATION operationModBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)
1518 {
1519     VM&amp; vm = globalObject-&gt;vm();
1520     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1521     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1522 
1523     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1524     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1525 
1526     return JSBigInt::remainder(globalObject, leftOperand, rightOperand);
1527 }
1528 
1529 JSCell* JIT_OPERATION operationDivBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)
1530 {
1531     VM&amp; vm = globalObject-&gt;vm();
1532     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1533     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1534 
1535     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1536     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1537 
1538     return JSBigInt::divide(globalObject, leftOperand, rightOperand);
1539 }
1540 
1541 JSCell* JIT_OPERATION operationPowBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)
1542 {
1543     VM&amp; vm = globalObject-&gt;vm();
1544     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1545     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1546 
1547     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1548     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1549 
1550     return JSBigInt::exponentiate(globalObject, leftOperand, rightOperand);
1551 }
1552 
1553 JSCell* JIT_OPERATION operationBitAndBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)
1554 {
1555     VM&amp; vm = globalObject-&gt;vm();
1556     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1557     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1558 
1559     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1560     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1561 
1562     return JSBigInt::bitwiseAnd(globalObject, leftOperand, rightOperand);
1563 }
1564 
1565 JSCell* JIT_OPERATION operationBitLShiftBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)
1566 {
1567     VM&amp; vm = globalObject-&gt;vm();
1568     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1569     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1570 
1571     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1572     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1573 
1574     return JSBigInt::leftShift(globalObject, leftOperand, rightOperand);
1575 }
1576 
1577 JSCell* JIT_OPERATION operationAddBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)
1578 {
1579     VM&amp; vm = globalObject-&gt;vm();
1580     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1581     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1582 
1583     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1584     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1585 
1586     return JSBigInt::add(globalObject, leftOperand, rightOperand);
1587 }
1588 
1589 JSCell* JIT_OPERATION operationBitRShiftBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)
1590 {
1591     VM&amp; vm = globalObject-&gt;vm();
1592     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1593     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1594 
1595     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1596     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1597 
1598     return JSBigInt::signedRightShift(globalObject, leftOperand, rightOperand);
1599 }
1600 
1601 JSCell* JIT_OPERATION operationBitOrBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)
1602 {
1603     VM&amp; vm = globalObject-&gt;vm();
1604     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1605     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1606 
1607     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1608     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1609 
1610     return JSBigInt::bitwiseOr(globalObject, leftOperand, rightOperand);
1611 }
1612 
1613 JSCell* JIT_OPERATION operationBitXorBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)
1614 {
1615     VM&amp; vm = globalObject-&gt;vm();
1616     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1617     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1618 
1619     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1620     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1621 
1622     return JSBigInt::bitwiseXor(globalObject, leftOperand, rightOperand);
1623 }
1624 
1625 size_t JIT_OPERATION operationCompareStrictEqCell(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)
1626 {
1627     VM&amp; vm = globalObject-&gt;vm();
1628     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1629     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1630 
1631     return JSValue::strictEqualSlowCaseInline(globalObject, op1, op2);
1632 }
1633 
1634 size_t JIT_OPERATION operationSameValue(JSGlobalObject* globalObject, EncodedJSValue arg1, EncodedJSValue arg2)
1635 {
1636     VM&amp; vm = globalObject-&gt;vm();
1637     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1638     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1639 
1640     return sameValue(globalObject, JSValue::decode(arg1), JSValue::decode(arg2));
1641 }
1642 
1643 EncodedJSValue JIT_OPERATION operationToPrimitive(JSGlobalObject* globalObject, EncodedJSValue value)
1644 {
1645     VM&amp; vm = globalObject-&gt;vm();
1646     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1647     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1648 
1649     return JSValue::encode(JSValue::decode(value).toPrimitive(globalObject));
1650 }
1651 
1652 EncodedJSValue JIT_OPERATION operationToPropertyKey(JSGlobalObject* globalObject, EncodedJSValue value)
1653 {
1654     VM&amp; vm = globalObject-&gt;vm();
1655     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1656     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1657 
1658     return JSValue::encode(JSValue::decode(value).toPropertyKeyValue(globalObject));
1659 }
1660 
1661 EncodedJSValue JIT_OPERATION operationToNumber(JSGlobalObject* globalObject, EncodedJSValue value)
1662 {
1663     VM&amp; vm = globalObject-&gt;vm();
1664     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1665     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1666 
1667     return JSValue::encode(jsNumber(JSValue::decode(value).toNumber(globalObject)));
1668 }
1669 
1670 EncodedJSValue JIT_OPERATION operationToNumeric(JSGlobalObject* globalObject, EncodedJSValue value)
1671 {
1672     VM&amp; vm = globalObject-&gt;vm();
1673     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1674     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1675 
1676     auto variant = JSValue::decode(value).toNumeric(globalObject);
1677     if (WTF::holds_alternative&lt;JSBigInt*&gt;(variant))
1678         return JSValue::encode(WTF::get&lt;JSBigInt*&gt;(variant));
1679     return JSValue::encode(jsNumber(WTF::get&lt;double&gt;(variant)));
1680 }
1681 
1682 EncodedJSValue JIT_OPERATION operationGetByValWithThis(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript)
1683 {
1684     VM&amp; vm = globalObject-&gt;vm();
1685     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1686     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1687     auto scope = DECLARE_THROW_SCOPE(vm);
1688 
1689     JSValue baseValue = JSValue::decode(encodedBase);
1690     JSValue thisVal = JSValue::decode(encodedThis);
1691     JSValue subscript = JSValue::decode(encodedSubscript);
1692 
1693     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1694         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1695         if (JSCell::canUseFastGetOwnProperty(structure)) {
1696             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(globalObject);
1697             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1698             if (existingAtomString) {
1699                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
1700                     return JSValue::encode(result);
1701             }
1702         }
1703     }
1704 
1705     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
1706     if (subscript.isUInt32()) {
1707         uint32_t i = subscript.asUInt32();
1708         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
1709             return JSValue::encode(asString(baseValue)-&gt;getIndex(globalObject, i));
1710 
1711         RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(globalObject, i, slot)));
1712     }
1713 
1714     baseValue.requireObjectCoercible(globalObject);
1715     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1716 
1717     auto property = subscript.toPropertyKey(globalObject);
1718     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1719     RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(globalObject, property, slot)));
1720 }
1721 
1722 void JIT_OPERATION operationPutByIdWithThisStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)
1723 {
1724     VM&amp; vm = globalObject-&gt;vm();
1725     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1726     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1727 
1728     putWithThis&lt;true&gt;(globalObject, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));
1729 }
1730 
1731 void JIT_OPERATION operationPutByIdWithThis(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)
1732 {
1733     VM&amp; vm = globalObject-&gt;vm();
1734     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1735     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1736 
1737     putWithThis&lt;false&gt;(globalObject, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));
1738 }
1739 
1740 void JIT_OPERATION operationPutByValWithThisStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)
1741 {
1742     VM&amp; vm = globalObject-&gt;vm();
1743     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1744     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1745     auto scope = DECLARE_THROW_SCOPE(vm);
1746 
1747     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(globalObject);
1748     RETURN_IF_EXCEPTION(scope, void());
1749     scope.release();
1750     putWithThis&lt;true&gt;(globalObject, encodedBase, encodedThis, encodedValue, property);
1751 }
1752 
1753 void JIT_OPERATION operationPutByValWithThis(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)
1754 {
1755     VM&amp; vm = globalObject-&gt;vm();
1756     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1757     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1758     auto scope = DECLARE_THROW_SCOPE(vm);
1759 
1760     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(globalObject);
1761     RETURN_IF_EXCEPTION(scope, void());
1762     scope.release();
1763     putWithThis&lt;false&gt;(globalObject, encodedBase, encodedThis, encodedValue, property);
1764 }
1765 
1766 ALWAYS_INLINE static void defineDataProperty(JSGlobalObject* globalObject, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSValue value, int32_t attributes)
1767 {
1768     PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes));
1769     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1770     if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
1771         JSObject::defineOwnProperty(base, globalObject, propertyName, descriptor, true);
1772     else
1773         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);
1774 }
1775 
1776 void JIT_OPERATION operationDefineDataProperty(JSGlobalObject* globalObject, JSObject* base, EncodedJSValue encodedProperty, EncodedJSValue encodedValue, int32_t attributes)
1777 {
1778     VM&amp; vm = globalObject-&gt;vm();
1779     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1780     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1781     auto scope = DECLARE_THROW_SCOPE(vm);
1782 
1783     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(globalObject);
1784     RETURN_IF_EXCEPTION(scope, void());
1785     scope.release();
1786     defineDataProperty(globalObject, vm, base, propertyName, JSValue::decode(encodedValue), attributes);
1787 }
1788 
1789 void JIT_OPERATION operationDefineDataPropertyString(JSGlobalObject* globalObject, JSObject* base, JSString* property, EncodedJSValue encodedValue, int32_t attributes)
1790 {
1791     VM&amp; vm = globalObject-&gt;vm();
1792     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1793     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1794     auto scope = DECLARE_THROW_SCOPE(vm);
1795 
1796     Identifier propertyName = property-&gt;toIdentifier(globalObject);
1797     RETURN_IF_EXCEPTION(scope, void());
1798     scope.release();
1799     defineDataProperty(globalObject, vm, base, propertyName, JSValue::decode(encodedValue), attributes);
1800 }
1801 
1802 void JIT_OPERATION operationDefineDataPropertyStringIdent(JSGlobalObject* globalObject, JSObject* base, UniquedStringImpl* property, EncodedJSValue encodedValue, int32_t attributes)
1803 {
1804     VM&amp; vm = globalObject-&gt;vm();
1805     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1806     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1807     defineDataProperty(globalObject, vm, base, Identifier::fromUid(vm, property), JSValue::decode(encodedValue), attributes);
1808 }
1809 
1810 void JIT_OPERATION operationDefineDataPropertySymbol(JSGlobalObject* globalObject, JSObject* base, Symbol* property, EncodedJSValue encodedValue, int32_t attributes)
1811 {
1812     VM&amp; vm = globalObject-&gt;vm();
1813     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1814     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1815     defineDataProperty(globalObject, vm, base, Identifier::fromUid(property-&gt;privateName()), JSValue::decode(encodedValue), attributes);
1816 }
1817 
1818 ALWAYS_INLINE static void defineAccessorProperty(JSGlobalObject* globalObject, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSObject* getter, JSObject* setter, int32_t attributes)
1819 {
1820     PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes));
1821     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1822     if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
1823         JSObject::defineOwnProperty(base, globalObject, propertyName, descriptor, true);
1824     else
1825         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);
1826 }
1827 
1828 void JIT_OPERATION operationDefineAccessorProperty(JSGlobalObject* globalObject, JSObject* base, EncodedJSValue encodedProperty, JSObject* getter, JSObject* setter, int32_t attributes)
1829 {
1830     VM&amp; vm = globalObject-&gt;vm();
1831     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1832     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1833     auto scope = DECLARE_THROW_SCOPE(vm);
1834 
1835     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(globalObject);
1836     RETURN_IF_EXCEPTION(scope, void());
1837     defineAccessorProperty(globalObject, vm, base, propertyName, getter, setter, attributes);
1838 }
1839 
1840 void JIT_OPERATION operationDefineAccessorPropertyString(JSGlobalObject* globalObject, JSObject* base, JSString* property, JSObject* getter, JSObject* setter, int32_t attributes)
1841 {
1842     VM&amp; vm = globalObject-&gt;vm();
1843     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1844     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1845     auto scope = DECLARE_THROW_SCOPE(vm);
1846 
1847     Identifier propertyName = property-&gt;toIdentifier(globalObject);
1848     RETURN_IF_EXCEPTION(scope, void());
1849     defineAccessorProperty(globalObject, vm, base, propertyName, getter, setter, attributes);
1850 }
1851 
1852 void JIT_OPERATION operationDefineAccessorPropertyStringIdent(JSGlobalObject* globalObject, JSObject* base, UniquedStringImpl* property, JSObject* getter, JSObject* setter, int32_t attributes)
1853 {
1854     VM&amp; vm = globalObject-&gt;vm();
1855     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1856     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1857     defineAccessorProperty(globalObject, vm, base, Identifier::fromUid(vm, property), getter, setter, attributes);
1858 }
1859 
1860 void JIT_OPERATION operationDefineAccessorPropertySymbol(JSGlobalObject* globalObject, JSObject* base, Symbol* property, JSObject* getter, JSObject* setter, int32_t attributes)
1861 {
1862     VM&amp; vm = globalObject-&gt;vm();
1863     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1864     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1865     defineAccessorProperty(globalObject, vm, base, Identifier::fromUid(property-&gt;privateName()), getter, setter, attributes);
1866 }
1867 
1868 char* JIT_OPERATION operationNewArray(JSGlobalObject* globalObject, Structure* arrayStructure, void* buffer, size_t size)
1869 {
1870     VM&amp; vm = globalObject-&gt;vm();
1871     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1872     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1873 
1874     return bitwise_cast&lt;char*&gt;(constructArray(globalObject, arrayStructure, static_cast&lt;JSValue*&gt;(buffer), size));
1875 }
1876 
1877 char* JIT_OPERATION operationNewEmptyArray(VM* vmPointer, Structure* arrayStructure)
1878 {
1879     VM&amp; vm = *vmPointer;
1880     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1881     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1882 
1883     return bitwise_cast&lt;char*&gt;(JSArray::create(vm, arrayStructure));
1884 }
1885 
1886 char* JIT_OPERATION operationNewArrayWithSize(JSGlobalObject* globalObject, Structure* arrayStructure, int32_t size, Butterfly* butterfly)
1887 {
1888     VM&amp; vm = globalObject-&gt;vm();
1889     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1890     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1891     auto scope = DECLARE_THROW_SCOPE(vm);
1892 
1893     if (UNLIKELY(size &lt; 0))
1894         return bitwise_cast&lt;char*&gt;(throwException(globalObject, scope, createRangeError(globalObject, &quot;Array size is not a small enough positive integer.&quot;_s)));
1895 
1896     JSArray* result;
1897     if (butterfly)
1898         result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
1899     else
1900         result = JSArray::create(vm, arrayStructure, size);
1901     return bitwise_cast&lt;char*&gt;(result);
1902 }
1903 
1904 char* JIT_OPERATION operationNewArrayWithSizeAndHint(JSGlobalObject* globalObject, Structure* arrayStructure, int32_t size, int32_t vectorLengthHint, Butterfly* butterfly)
1905 {
1906     VM&amp; vm = globalObject-&gt;vm();
1907     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1908     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1909     auto scope = DECLARE_THROW_SCOPE(vm);
1910 
1911     if (UNLIKELY(size &lt; 0))
1912         return bitwise_cast&lt;char*&gt;(throwException(globalObject, scope, createRangeError(globalObject, &quot;Array size is not a small enough positive integer.&quot;_s)));
1913 
1914     JSArray* result;
1915     if (butterfly)
1916         result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
1917     else {
1918         result = JSArray::tryCreate(vm, arrayStructure, size, vectorLengthHint);
1919         RELEASE_ASSERT(result);
1920     }
1921     return bitwise_cast&lt;char*&gt;(result);
1922 }
1923 
1924 JSCell* JIT_OPERATION operationNewArrayBuffer(VM* vmPointer, Structure* arrayStructure, JSCell* immutableButterflyCell)
1925 {
1926     VM&amp; vm = *vmPointer;
1927     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1928     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1929     ASSERT(!arrayStructure-&gt;outOfLineCapacity());
1930     auto* immutableButterfly = jsCast&lt;JSImmutableButterfly*&gt;(immutableButterflyCell);
1931     ASSERT(arrayStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode() || hasAnyArrayStorage(arrayStructure-&gt;indexingMode()));
1932     auto* result = CommonSlowPaths::allocateNewArrayBuffer(vm, arrayStructure, immutableButterfly);
1933     ASSERT(result-&gt;indexingMode() == result-&gt;structure(vm)-&gt;indexingMode());
1934     ASSERT(result-&gt;structure(vm) == arrayStructure);
1935     return result;
1936 }
1937 
1938 char* JIT_OPERATION operationNewInt8ArrayWithSize(
1939     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)
1940 {
1941     VM&amp; vm = globalObject-&gt;vm();
1942     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1943     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1944     return newTypedArrayWithSize&lt;JSInt8Array&gt;(globalObject, vm, structure, length, vector);
1945 }
1946 
1947 char* JIT_OPERATION operationNewInt8ArrayWithOneArgument(
1948     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)
1949 {
1950     VM&amp; vm = globalObject-&gt;vm();
1951     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1952     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1953     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt8Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));
1954 }
1955 
1956 char* JIT_OPERATION operationNewInt16ArrayWithSize(
1957     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)
1958 {
1959     VM&amp; vm = globalObject-&gt;vm();
1960     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1961     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1962     return newTypedArrayWithSize&lt;JSInt16Array&gt;(globalObject, vm, structure, length, vector);
1963 }
1964 
1965 char* JIT_OPERATION operationNewInt16ArrayWithOneArgument(
1966     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)
1967 {
1968     VM&amp; vm = globalObject-&gt;vm();
1969     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1970     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1971     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt16Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));
1972 }
1973 
1974 char* JIT_OPERATION operationNewInt32ArrayWithSize(
1975     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)
1976 {
1977     VM&amp; vm = globalObject-&gt;vm();
1978     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1979     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1980     return newTypedArrayWithSize&lt;JSInt32Array&gt;(globalObject, vm, structure, length, vector);
1981 }
1982 
1983 char* JIT_OPERATION operationNewInt32ArrayWithOneArgument(
1984     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)
1985 {
1986     VM&amp; vm = globalObject-&gt;vm();
1987     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1988     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1989     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt32Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));
1990 }
1991 
1992 char* JIT_OPERATION operationNewUint8ArrayWithSize(
1993     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)
1994 {
1995     VM&amp; vm = globalObject-&gt;vm();
1996     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1997     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1998     return newTypedArrayWithSize&lt;JSUint8Array&gt;(globalObject, vm, structure, length, vector);
1999 }
2000 
2001 char* JIT_OPERATION operationNewUint8ArrayWithOneArgument(
2002     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)
2003 {
2004     VM&amp; vm = globalObject-&gt;vm();
2005     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2006     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2007     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));
2008 }
2009 
2010 char* JIT_OPERATION operationNewUint8ClampedArrayWithSize(
2011     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)
2012 {
2013     VM&amp; vm = globalObject-&gt;vm();
2014     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2015     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2016     return newTypedArrayWithSize&lt;JSUint8ClampedArray&gt;(globalObject, vm, structure, length, vector);
2017 }
2018 
2019 char* JIT_OPERATION operationNewUint8ClampedArrayWithOneArgument(
2020     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)
2021 {
2022     VM&amp; vm = globalObject-&gt;vm();
2023     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2024     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2025     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8ClampedArray&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));
2026 }
2027 
2028 char* JIT_OPERATION operationNewUint16ArrayWithSize(
2029     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)
2030 {
2031     VM&amp; vm = globalObject-&gt;vm();
2032     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2033     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2034     return newTypedArrayWithSize&lt;JSUint16Array&gt;(globalObject, vm, structure, length, vector);
2035 }
2036 
2037 char* JIT_OPERATION operationNewUint16ArrayWithOneArgument(
2038     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)
2039 {
2040     VM&amp; vm = globalObject-&gt;vm();
2041     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2042     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2043     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint16Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));
2044 }
2045 
2046 char* JIT_OPERATION operationNewUint32ArrayWithSize(
2047     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)
2048 {
2049     VM&amp; vm = globalObject-&gt;vm();
2050     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2051     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2052     return newTypedArrayWithSize&lt;JSUint32Array&gt;(globalObject, vm, structure, length, vector);
2053 }
2054 
2055 char* JIT_OPERATION operationNewUint32ArrayWithOneArgument(
2056     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)
2057 {
2058     VM&amp; vm = globalObject-&gt;vm();
2059     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2060     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2061     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint32Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));
2062 }
2063 
2064 char* JIT_OPERATION operationNewFloat32ArrayWithSize(
2065     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)
2066 {
2067     VM&amp; vm = globalObject-&gt;vm();
2068     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2069     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2070     return newTypedArrayWithSize&lt;JSFloat32Array&gt;(globalObject, vm, structure, length, vector);
2071 }
2072 
2073 char* JIT_OPERATION operationNewFloat32ArrayWithOneArgument(
2074     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)
2075 {
2076     VM&amp; vm = globalObject-&gt;vm();
2077     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2078     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2079     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat32Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));
2080 }
2081 
2082 char* JIT_OPERATION operationNewFloat64ArrayWithSize(
2083     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)
2084 {
2085     VM&amp; vm = globalObject-&gt;vm();
2086     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2087     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2088     return newTypedArrayWithSize&lt;JSFloat64Array&gt;(globalObject, vm, structure, length, vector);
2089 }
2090 
2091 char* JIT_OPERATION operationNewFloat64ArrayWithOneArgument(
2092     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)
2093 {
2094     VM&amp; vm = globalObject-&gt;vm();
2095     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2096     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2097     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat64Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));
2098 }
2099 
2100 JSCell* JIT_OPERATION operationNewArrayIterator(VM* vmPointer, Structure* structure)
2101 {
2102     VM&amp; vm = *vmPointer;
2103     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2104     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2105 
2106     return JSArrayIterator::createWithInitialValues(vm, structure);
2107 }
2108 
2109 JSCell* JIT_OPERATION operationCreateActivationDirect(VM* vmPointer, Structure* structure, JSScope* scope, SymbolTable* table, EncodedJSValue initialValueEncoded)
2110 {
2111     VM&amp; vm = *vmPointer;
2112     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2113     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2114     JSValue initialValue = JSValue::decode(initialValueEncoded);
2115     ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
2116     return JSLexicalEnvironment::create(vm, structure, scope, table, initialValue);
2117 }
2118 
2119 JSCell* JIT_OPERATION operationCreateDirectArguments(VM* vmPointer, Structure* structure, uint32_t length, uint32_t minCapacity)
2120 {
2121     VM&amp; vm = *vmPointer;
2122     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2123     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2124     DirectArguments* result = DirectArguments::create(
2125         vm, structure, length, std::max(length, minCapacity));
2126     // The caller will store to this object without barriers. Most likely, at this point, this is
2127     // still a young object and so no barriers are needed. But it&#39;s good to be careful anyway,
2128     // since the GC should be allowed to do crazy (like pretenuring, for example).
2129     vm.heap.writeBarrier(result);
2130     return result;
2131 }
2132 
2133 JSCell* JIT_OPERATION operationCreateScopedArguments(JSGlobalObject* globalObject, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee, JSLexicalEnvironment* scope)
2134 {
2135     VM&amp; vm = globalObject-&gt;vm();
2136     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2137     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2138 
2139     // We could pass the ScopedArgumentsTable* as an argument. We currently don&#39;t because I
2140     // didn&#39;t feel like changing the max number of arguments for a slow path call from 6 to 7.
2141     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
2142 
2143     return ScopedArguments::createByCopyingFrom(
2144         vm, structure, argumentStart, length, callee, table, scope);
2145 }
2146 
2147 JSCell* JIT_OPERATION operationCreateClonedArguments(JSGlobalObject* globalObject, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee)
2148 {
2149     VM&amp; vm = globalObject-&gt;vm();
2150     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2151     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2152     return ClonedArguments::createByCopyingFrom(
2153         globalObject, structure, argumentStart, length, callee);
2154 }
2155 
2156 JSCell* JIT_OPERATION operationCreateArgumentsButterfly(JSGlobalObject* globalObject, Register* argumentStart, uint32_t argumentCount)
2157 {
2158     VM&amp; vm = globalObject-&gt;vm();
2159     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2160     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2161     auto scope = DECLARE_THROW_SCOPE(vm);
2162 
2163     JSImmutableButterfly* butterfly = JSImmutableButterfly::tryCreate(vm, vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), argumentCount);
2164     if (!butterfly) {
2165         throwOutOfMemoryError(globalObject, scope);
2166         return nullptr;
2167     }
2168     for (unsigned index = 0; index &lt; argumentCount; ++index)
2169         butterfly-&gt;setIndex(vm, index, argumentStart[index].jsValue());
2170     return butterfly;
2171 }
2172 
2173 JSCell* JIT_OPERATION operationCreateDirectArgumentsDuringExit(VM* vmPointer, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)
2174 {
2175     VM&amp; vm = *vmPointer;
2176     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2177     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2178 
2179     DeferGCForAWhile deferGC(vm.heap);
2180 
2181     CodeBlock* codeBlock;
2182     if (inlineCallFrame)
2183         codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
2184     else
2185         codeBlock = callFrame-&gt;codeBlock();
2186 
2187     unsigned length = argumentCount - 1;
2188     unsigned capacity = std::max(length, static_cast&lt;unsigned&gt;(codeBlock-&gt;numParameters() - 1));
2189     DirectArguments* result = DirectArguments::create(
2190         vm, codeBlock-&gt;globalObject()-&gt;directArgumentsStructure(), length, capacity);
2191 
2192     result-&gt;setCallee(vm, callee);
2193 
2194     Register* arguments =
2195         callFrame-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +
2196         CallFrame::argumentOffset(0);
2197     for (unsigned i = length; i--;)
2198         result-&gt;setIndexQuickly(vm, i, arguments[i].jsValue());
2199 
2200     return result;
2201 }
2202 
2203 JSCell* JIT_OPERATION operationCreateClonedArgumentsDuringExit(VM* vmPointer, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)
2204 {
2205     VM&amp; vm = *vmPointer;
2206     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2207     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2208 
2209     DeferGCForAWhile deferGC(vm.heap);
2210 
2211     CodeBlock* codeBlock;
2212     if (inlineCallFrame)
2213         codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
2214     else
2215         codeBlock = callFrame-&gt;codeBlock();
2216 
2217     unsigned length = argumentCount - 1;
2218     JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
2219     ClonedArguments* result = ClonedArguments::createEmpty(
2220         vm, globalObject-&gt;clonedArgumentsStructure(), callee, length);
2221 
2222     Register* arguments =
2223         callFrame-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +
2224         CallFrame::argumentOffset(0);
2225     for (unsigned i = length; i--;)
2226         result-&gt;putDirectIndex(globalObject, i, arguments[i].jsValue());
2227 
2228 
2229     return result;
2230 }
2231 
2232 JSCell* JIT_OPERATION operationCreateRest(JSGlobalObject* globalObject, Register* argumentStart, unsigned numberOfParamsToSkip, unsigned arraySize)
2233 {
2234     VM&amp; vm = globalObject-&gt;vm();
2235     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2236     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2237 
2238     Structure* structure = globalObject-&gt;restParameterStructure();
2239     static_assert(sizeof(Register) == sizeof(JSValue), &quot;This is a strong assumption here.&quot;);
2240     JSValue* argumentsToCopyRegion = bitwise_cast&lt;JSValue*&gt;(argumentStart) + numberOfParamsToSkip;
2241     return constructArray(globalObject, structure, argumentsToCopyRegion, arraySize);
2242 }
2243 
2244 size_t JIT_OPERATION operationObjectIsObject(JSGlobalObject* globalObject, JSCell* object)
2245 {
2246     VM&amp; vm = globalObject-&gt;vm();
2247     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2248     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2249 
2250     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2251 
2252     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2253         return false;
2254     if (object-&gt;isFunction(vm))
2255         return false;
2256     return true;
2257 }
2258 
2259 size_t JIT_OPERATION operationObjectIsFunction(JSGlobalObject* globalObject, JSCell* object)
2260 {
2261     VM&amp; vm = globalObject-&gt;vm();
2262     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2263     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2264 
2265     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2266 
2267     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2268         return false;
2269     if (object-&gt;isFunction(vm))
2270         return true;
2271     return false;
2272 }
2273 
2274 JSCell* JIT_OPERATION operationTypeOfObject(JSGlobalObject* globalObject, JSCell* object)
2275 {
2276     VM&amp; vm = globalObject-&gt;vm();
2277     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2278     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2279 
2280     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2281 
2282     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2283         return vm.smallStrings.undefinedString();
2284     if (object-&gt;isFunction(vm))
2285         return vm.smallStrings.functionString();
2286     return vm.smallStrings.objectString();
2287 }
2288 
2289 int32_t JIT_OPERATION operationTypeOfObjectAsTypeofType(JSGlobalObject* globalObject, JSCell* object)
2290 {
2291     VM&amp; vm = globalObject-&gt;vm();
2292     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2293     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2294 
2295     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2296 
2297     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2298         return static_cast&lt;int32_t&gt;(TypeofType::Undefined);
2299     if (object-&gt;isFunction(vm))
2300         return static_cast&lt;int32_t&gt;(TypeofType::Function);
2301     return static_cast&lt;int32_t&gt;(TypeofType::Object);
2302 }
2303 
2304 char* JIT_OPERATION operationAllocateSimplePropertyStorageWithInitialCapacity(VM* vmPointer)
2305 {
2306     VM&amp; vm = *vmPointer;
2307     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2308     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2309 
2310     return reinterpret_cast&lt;char*&gt;(
2311         Butterfly::createUninitialized(vm, 0, 0, initialOutOfLineCapacity, false, 0));
2312 }
2313 
2314 char* JIT_OPERATION operationAllocateSimplePropertyStorage(VM* vmPointer, size_t newSize)
2315 {
2316     VM&amp; vm = *vmPointer;
2317     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2318     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2319 
2320     return reinterpret_cast&lt;char*&gt;(
2321         Butterfly::createUninitialized(vm, 0, 0, newSize, false, 0));
2322 }
2323 
2324 char* JIT_OPERATION operationAllocateComplexPropertyStorageWithInitialCapacity(VM* vmPointer, JSObject* object)
2325 {
2326     VM&amp; vm = *vmPointer;
2327     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2328     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2329 
2330     ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
2331     return reinterpret_cast&lt;char*&gt;(
2332         object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity));
2333 }
2334 
2335 char* JIT_OPERATION operationAllocateComplexPropertyStorage(VM* vmPointer, JSObject* object, size_t newSize)
2336 {
2337     VM&amp; vm = *vmPointer;
2338     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2339     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2340 
2341     return reinterpret_cast&lt;char*&gt;(
2342         object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize));
2343 }
2344 
2345 char* JIT_OPERATION operationEnsureInt32(VM* vmPointer, JSCell* cell)
2346 {
2347     VM&amp; vm = *vmPointer;
2348     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2349     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2350 
2351     if (!cell-&gt;isObject())
2352         return 0;
2353 
2354     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableInt32(vm).data());
2355     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasInt32(cell-&gt;indexingMode())) || !result);
2356     return result;
2357 }
2358 
2359 char* JIT_OPERATION operationEnsureDouble(VM* vmPointer, JSCell* cell)
2360 {
2361     VM&amp; vm = *vmPointer;
2362     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2363     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2364 
2365     if (!cell-&gt;isObject())
2366         return 0;
2367 
2368     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableDouble(vm).data());
2369     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasDouble(cell-&gt;indexingMode())) || !result);
2370     return result;
2371 }
2372 
2373 char* JIT_OPERATION operationEnsureContiguous(VM* vmPointer, JSCell* cell)
2374 {
2375     VM&amp; vm = *vmPointer;
2376     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2377     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2378 
2379     if (!cell-&gt;isObject())
2380         return 0;
2381 
2382     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableContiguous(vm).data());
2383     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasContiguous(cell-&gt;indexingMode())) || !result);
2384     return result;
2385 }
2386 
2387 char* JIT_OPERATION operationEnsureArrayStorage(VM* vmPointer, JSCell* cell)
2388 {
2389     VM&amp; vm = *vmPointer;
2390     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2391     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2392 
2393     if (!cell-&gt;isObject())
2394         return 0;
2395 
2396     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;ensureArrayStorage(vm));
2397     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasAnyArrayStorage(cell-&gt;indexingMode())) || !result);
2398     return result;
2399 }
2400 
2401 EncodedJSValue JIT_OPERATION operationHasGenericProperty(JSGlobalObject* globalObject, EncodedJSValue encodedBaseValue, JSCell* property)
2402 {
2403     VM&amp; vm = globalObject-&gt;vm();
2404     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2405     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2406     auto scope = DECLARE_THROW_SCOPE(vm);
2407 
2408     JSValue baseValue = JSValue::decode(encodedBaseValue);
2409     if (baseValue.isUndefinedOrNull())
2410         return JSValue::encode(jsBoolean(false));
2411 
2412     JSObject* base = baseValue.toObject(globalObject);
2413     EXCEPTION_ASSERT(!scope.exception() || !base);
2414     if (!base)
2415         return JSValue::encode(JSValue());
2416     auto propertyName = asString(property)-&gt;toIdentifier(globalObject);
2417     RETURN_IF_EXCEPTION(scope, { });
2418     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::GetOwnProperty))));
2419 }
2420 
2421 size_t JIT_OPERATION operationHasIndexedPropertyByInt(JSGlobalObject* globalObject, JSCell* baseCell, int32_t subscript, int32_t internalMethodType)
2422 {
2423     VM&amp; vm = globalObject-&gt;vm();
2424     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2425     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2426     JSObject* object = baseCell-&gt;toObject(globalObject);
2427     if (UNLIKELY(subscript &lt; 0)) {
2428         // Go the slowest way possible because negative indices don&#39;t use indexed storage.
2429         return object-&gt;hasPropertyGeneric(globalObject, Identifier::from(vm, subscript), static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));
2430     }
2431     return object-&gt;hasPropertyGeneric(globalObject, subscript, static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));
2432 }
2433 
2434 JSCell* JIT_OPERATION operationGetPropertyEnumerator(JSGlobalObject* globalObject, EncodedJSValue encodedBase)
2435 {
2436     VM&amp; vm = globalObject-&gt;vm();
2437     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2438     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2439     auto scope = DECLARE_THROW_SCOPE(vm);
2440 
2441     JSValue base = JSValue::decode(encodedBase);
2442     if (base.isUndefinedOrNull())
2443         return vm.emptyPropertyNameEnumerator();
2444 
2445     JSObject* baseObject = base.toObject(globalObject);
2446     RETURN_IF_EXCEPTION(scope, { });
2447 
2448     RELEASE_AND_RETURN(scope, propertyNameEnumerator(globalObject, baseObject));
2449 }
2450 
2451 JSCell* JIT_OPERATION operationGetPropertyEnumeratorCell(JSGlobalObject* globalObject, JSCell* cell)
2452 {
2453     VM&amp; vm = globalObject-&gt;vm();
2454     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2455     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2456     auto scope = DECLARE_THROW_SCOPE(vm);
2457 
2458     JSObject* base = cell-&gt;toObject(globalObject);
2459     RETURN_IF_EXCEPTION(scope, { });
2460 
2461     RELEASE_AND_RETURN(scope, propertyNameEnumerator(globalObject, base));
2462 }
2463 
2464 JSCell* JIT_OPERATION operationToIndexString(JSGlobalObject* globalObject, int32_t index)
2465 {
2466     VM&amp; vm = globalObject-&gt;vm();
2467     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2468     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2469     return jsString(vm, Identifier::from(vm, index).string());
2470 }
2471 
2472 JSCell* JIT_OPERATION operationNewRegexpWithLastIndex(JSGlobalObject* globalObject, JSCell* regexpPtr, EncodedJSValue encodedLastIndex)
2473 {
2474     VM&amp; vm = globalObject-&gt;vm();
2475     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2476     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2477 
2478     RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
2479     ASSERT(regexp-&gt;isValid());
2480     return RegExpObject::create(vm, globalObject-&gt;regExpStructure(), regexp, JSValue::decode(encodedLastIndex));
2481 }
2482 
2483 StringImpl* JIT_OPERATION operationResolveRope(JSGlobalObject* globalObject, JSString* string)
2484 {
2485     VM&amp; vm = globalObject-&gt;vm();
2486     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2487     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2488 
2489     return string-&gt;value(globalObject).impl();
2490 }
2491 
2492 JSString* JIT_OPERATION operationStringValueOf(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)
2493 {
2494     VM&amp; vm = globalObject-&gt;vm();
2495     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2496     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2497     auto scope = DECLARE_THROW_SCOPE(vm);
2498 
2499     JSValue argument = JSValue::decode(encodedArgument);
2500 
2501     if (argument.isString())
2502         return asString(argument);
2503 
2504     if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, argument))
2505         return stringObject-&gt;internalValue();
2506 
2507     throwVMTypeError(globalObject, scope);
2508     return nullptr;
2509 }
2510 
2511 JSCell* JIT_OPERATION operationStringSubstr(JSGlobalObject* globalObject, JSCell* cell, int32_t from, int32_t span)
2512 {
2513     VM&amp; vm = globalObject-&gt;vm();
2514     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2515     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2516 
2517     return jsSubstring(vm, globalObject, jsCast&lt;JSString*&gt;(cell), from, span);
2518 }
2519 
2520 JSCell* JIT_OPERATION operationStringSlice(JSGlobalObject* globalObject, JSCell* cell, int32_t start, int32_t end)
2521 {
2522     VM&amp; vm = globalObject-&gt;vm();
2523     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2524     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2525 
2526     JSString* string = asString(cell);
2527     static_assert(static_cast&lt;uint64_t&gt;(JSString::MaxLength) &lt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()), &quot;&quot;);
2528     return stringSlice(globalObject, vm, string, string-&gt;length(), start, end);
2529 }
2530 
2531 JSString* JIT_OPERATION operationToLowerCase(JSGlobalObject* globalObject, JSString* string, uint32_t failingIndex)
2532 {
2533     VM&amp; vm = globalObject-&gt;vm();
2534     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2535     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2536 
2537     auto scope = DECLARE_THROW_SCOPE(vm);
2538 
2539     String inputString = string-&gt;value(globalObject);
2540     RETURN_IF_EXCEPTION(scope, nullptr);
2541     if (!inputString.length())
2542         return vm.smallStrings.emptyString();
2543 
2544     String lowercasedString = inputString.is8Bit() ? inputString.convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(failingIndex) : inputString.convertToLowercaseWithoutLocale();
2545     if (lowercasedString.impl() == inputString.impl())
2546         return string;
2547     RELEASE_AND_RETURN(scope, jsString(vm, lowercasedString));
2548 }
2549 
2550 char* JIT_OPERATION operationInt32ToString(JSGlobalObject* globalObject, int32_t value, int32_t radix)
2551 {
2552     VM&amp; vm = globalObject-&gt;vm();
2553     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2554     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2555 
2556     auto scope = DECLARE_THROW_SCOPE(vm);
2557 
2558     if (radix &lt; 2 || radix &gt; 36) {
2559         throwVMError(globalObject, scope, createRangeError(globalObject, &quot;toString() radix argument must be between 2 and 36&quot;_s));
2560         return nullptr;
2561     }
2562 
2563     return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
2564 }
2565 
2566 char* JIT_OPERATION operationInt52ToString(JSGlobalObject* globalObject, int64_t value, int32_t radix)
2567 {
2568     VM&amp; vm = globalObject-&gt;vm();
2569     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2570     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2571 
2572     auto scope = DECLARE_THROW_SCOPE(vm);
2573 
2574     if (radix &lt; 2 || radix &gt; 36) {
2575         throwVMError(globalObject, scope, createRangeError(globalObject, &quot;toString() radix argument must be between 2 and 36&quot;_s));
2576         return nullptr;
2577     }
2578 
2579     return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
2580 }
2581 
2582 char* JIT_OPERATION operationDoubleToString(JSGlobalObject* globalObject, double value, int32_t radix)
2583 {
2584     VM&amp; vm = globalObject-&gt;vm();
2585     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2586     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2587 
2588     auto scope = DECLARE_THROW_SCOPE(vm);
2589 
2590     if (radix &lt; 2 || radix &gt; 36) {
2591         throwVMError(globalObject, scope, createRangeError(globalObject, &quot;toString() radix argument must be between 2 and 36&quot;_s));
2592         return nullptr;
2593     }
2594 
2595     return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
2596 }
2597 
2598 char* JIT_OPERATION operationInt32ToStringWithValidRadix(JSGlobalObject* globalObject, int32_t value, int32_t radix)
2599 {
2600     VM&amp; vm = globalObject-&gt;vm();
2601     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2602     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2603 
2604     return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
2605 }
2606 
2607 char* JIT_OPERATION operationInt52ToStringWithValidRadix(JSGlobalObject* globalObject, int64_t value, int32_t radix)
2608 {
2609     VM&amp; vm = globalObject-&gt;vm();
2610     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2611     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2612 
2613     return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
2614 }
2615 
2616 char* JIT_OPERATION operationDoubleToStringWithValidRadix(JSGlobalObject* globalObject, double value, int32_t radix)
2617 {
2618     VM&amp; vm = globalObject-&gt;vm();
2619     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2620     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2621 
2622     return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
2623 }
2624 
2625 JSString* JIT_OPERATION operationSingleCharacterString(VM* vmPointer, int32_t character)
2626 {
2627     VM&amp; vm = *vmPointer;
2628     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2629     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2630 
2631     return jsSingleCharacterString(vm, static_cast&lt;UChar&gt;(character));
2632 }
2633 
2634 Symbol* JIT_OPERATION operationNewSymbol(VM* vmPointer)
2635 {
2636     VM&amp; vm = *vmPointer;
2637     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2638     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2639 
2640     return Symbol::create(vm);
2641 }
2642 
2643 Symbol* JIT_OPERATION operationNewSymbolWithDescription(JSGlobalObject* globalObject, JSString* description)
2644 {
2645     VM&amp; vm = globalObject-&gt;vm();
2646     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2647     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2648     auto scope = DECLARE_THROW_SCOPE(vm);
2649 
2650     String string = description-&gt;value(globalObject);
2651     RETURN_IF_EXCEPTION(scope, nullptr);
2652 
2653     return Symbol::createWithDescription(vm, string);
2654 }
2655 
2656 JSCell* JIT_OPERATION operationNewStringObject(VM* vmPointer, JSString* string, Structure* structure)
2657 {
2658     VM&amp; vm = *vmPointer;
2659     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2660     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2661 
2662     return StringObject::create(vm, structure, string);
2663 }
2664 
2665 JSString* JIT_OPERATION operationToStringOnCell(JSGlobalObject* globalObject, JSCell* cell)
2666 {
2667     VM&amp; vm = globalObject-&gt;vm();
2668     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2669     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2670 
2671     return JSValue(cell).toString(globalObject);
2672 }
2673 
2674 JSString* JIT_OPERATION operationToString(JSGlobalObject* globalObject, EncodedJSValue value)
2675 {
2676     VM&amp; vm = globalObject-&gt;vm();
2677     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2678     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2679 
2680     return JSValue::decode(value).toString(globalObject);
2681 }
2682 
2683 JSString* JIT_OPERATION operationCallStringConstructorOnCell(JSGlobalObject* globalObject, JSCell* cell)
2684 {
2685     VM&amp; vm = globalObject-&gt;vm();
2686     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2687     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2688 
2689     return stringConstructor(globalObject, cell);
2690 }
2691 
2692 JSString* JIT_OPERATION operationCallStringConstructor(JSGlobalObject* globalObject, EncodedJSValue value)
2693 {
2694     VM&amp; vm = globalObject-&gt;vm();
2695     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2696     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2697 
2698     return stringConstructor(globalObject, JSValue::decode(value));
2699 }
2700 
2701 JSString* JIT_OPERATION operationMakeRope2(JSGlobalObject* globalObject, JSString* left, JSString* right)
2702 {
2703     VM&amp; vm = globalObject-&gt;vm();
2704     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2705     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2706 
2707     return jsString(globalObject, left, right);
2708 }
2709 
2710 JSString* JIT_OPERATION operationMakeRope3(JSGlobalObject* globalObject, JSString* a, JSString* b, JSString* c)
2711 {
2712     VM&amp; vm = globalObject-&gt;vm();
2713     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2714     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2715 
2716     return jsString(globalObject, a, b, c);
2717 }
2718 
2719 JSString* JIT_OPERATION operationStrCat2(JSGlobalObject* globalObject, EncodedJSValue a, EncodedJSValue b)
2720 {
2721     VM&amp; vm = globalObject-&gt;vm();
2722     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2723     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2724     auto scope = DECLARE_THROW_SCOPE(vm);
2725 
2726     ASSERT(!JSValue::decode(a).isSymbol());
2727     ASSERT(!JSValue::decode(b).isSymbol());
2728     JSString* str1 = JSValue::decode(a).toString(globalObject);
2729     scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
2730     JSString* str2 = JSValue::decode(b).toString(globalObject);
2731     scope.assertNoException();
2732 
2733     RELEASE_AND_RETURN(scope, jsString(globalObject, str1, str2));
2734 }
2735 
2736 JSString* JIT_OPERATION operationStrCat3(JSGlobalObject* globalObject, EncodedJSValue a, EncodedJSValue b, EncodedJSValue c)
2737 {
2738     VM&amp; vm = globalObject-&gt;vm();
2739     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2740     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2741     auto scope = DECLARE_THROW_SCOPE(vm);
2742 
2743     ASSERT(!JSValue::decode(a).isSymbol());
2744     ASSERT(!JSValue::decode(b).isSymbol());
2745     ASSERT(!JSValue::decode(c).isSymbol());
2746     JSString* str1 = JSValue::decode(a).toString(globalObject);
2747     scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
2748     JSString* str2 = JSValue::decode(b).toString(globalObject);
2749     scope.assertNoException();
2750     JSString* str3 = JSValue::decode(c).toString(globalObject);
2751     scope.assertNoException();
2752 
2753     RELEASE_AND_RETURN(scope, jsString(globalObject, str1, str2, str3));
2754 }
2755 
2756 char* JIT_OPERATION operationFindSwitchImmTargetForDouble(VM* vmPointer, EncodedJSValue encodedValue, size_t tableIndex)
2757 {
2758     VM&amp; vm = *vmPointer;
2759     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2760     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2761     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
2762     SimpleJumpTable&amp; table = codeBlock-&gt;switchJumpTable(tableIndex);
2763     JSValue value = JSValue::decode(encodedValue);
2764     ASSERT(value.isDouble());
2765     double asDouble = value.asDouble();
2766     int32_t asInt32 = static_cast&lt;int32_t&gt;(asDouble);
2767     if (asDouble == asInt32)
2768         return table.ctiForValue(asInt32).executableAddress&lt;char*&gt;();
2769     return table.ctiDefault.executableAddress&lt;char*&gt;();
2770 }
2771 
2772 char* JIT_OPERATION operationSwitchString(JSGlobalObject* globalObject, size_t tableIndex, JSString* string)
2773 {
2774     VM&amp; vm = globalObject-&gt;vm();
2775     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2776     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2777     auto throwScope = DECLARE_THROW_SCOPE(vm);
2778 
2779     StringImpl* strImpl = string-&gt;value(globalObject).impl();
2780 
2781     RETURN_IF_EXCEPTION(throwScope, nullptr);
2782 
2783     return callFrame-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).ctiForValue(strImpl).executableAddress&lt;char*&gt;();
2784 }
2785 
2786 int32_t JIT_OPERATION operationSwitchStringAndGetBranchOffset(JSGlobalObject* globalObject, size_t tableIndex, JSString* string)
2787 {
2788     VM&amp; vm = globalObject-&gt;vm();
2789     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2790     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2791     auto throwScope = DECLARE_THROW_SCOPE(vm);
2792 
2793     StringImpl* strImpl = string-&gt;value(globalObject).impl();
2794 
2795     RETURN_IF_EXCEPTION(throwScope, 0);
2796 
2797     return callFrame-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).offsetForValue(strImpl, std::numeric_limits&lt;int32_t&gt;::min());
2798 }
2799 
2800 uintptr_t JIT_OPERATION operationCompareStringImplLess(StringImpl* a, StringImpl* b)
2801 {
2802     return codePointCompare(a, b) &lt; 0;
2803 }
2804 
2805 uintptr_t JIT_OPERATION operationCompareStringImplLessEq(StringImpl* a, StringImpl* b)
2806 {
2807     return codePointCompare(a, b) &lt;= 0;
2808 }
2809 
2810 uintptr_t JIT_OPERATION operationCompareStringImplGreater(StringImpl* a, StringImpl* b)
2811 {
2812     return codePointCompare(a, b) &gt; 0;
2813 }
2814 
2815 uintptr_t JIT_OPERATION operationCompareStringImplGreaterEq(StringImpl* a, StringImpl* b)
2816 {
2817     return codePointCompare(a, b) &gt;= 0;
2818 }
2819 
2820 uintptr_t JIT_OPERATION operationCompareStringLess(JSGlobalObject* globalObject, JSString* a, JSString* b)
2821 {
2822     VM&amp; vm = globalObject-&gt;vm();
2823     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2824     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2825 
2826     return codePointCompareLessThan(asString(a)-&gt;value(globalObject), asString(b)-&gt;value(globalObject));
2827 }
2828 
2829 uintptr_t JIT_OPERATION operationCompareStringLessEq(JSGlobalObject* globalObject, JSString* a, JSString* b)
2830 {
2831     VM&amp; vm = globalObject-&gt;vm();
2832     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2833     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2834 
2835     return !codePointCompareLessThan(asString(b)-&gt;value(globalObject), asString(a)-&gt;value(globalObject));
2836 }
2837 
2838 uintptr_t JIT_OPERATION operationCompareStringGreater(JSGlobalObject* globalObject, JSString* a, JSString* b)
2839 {
2840     VM&amp; vm = globalObject-&gt;vm();
2841     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2842     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2843 
2844     return codePointCompareLessThan(asString(b)-&gt;value(globalObject), asString(a)-&gt;value(globalObject));
2845 }
2846 
2847 uintptr_t JIT_OPERATION operationCompareStringGreaterEq(JSGlobalObject* globalObject, JSString* a, JSString* b)
2848 {
2849     VM&amp; vm = globalObject-&gt;vm();
2850     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2851     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2852 
2853     return !codePointCompareLessThan(asString(a)-&gt;value(globalObject), asString(b)-&gt;value(globalObject));
2854 }
2855 
2856 void JIT_OPERATION operationNotifyWrite(VM* vmPointer, WatchpointSet* set)
2857 {
2858     VM&amp; vm = *vmPointer;
2859     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2860     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2861 
2862     set-&gt;touch(vm, &quot;Executed NotifyWrite&quot;);
2863 }
2864 
2865 void JIT_OPERATION operationThrowStackOverflowForVarargs(JSGlobalObject* globalObject)
2866 {
2867     VM&amp; vm = globalObject-&gt;vm();
2868     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2869     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2870     auto scope = DECLARE_THROW_SCOPE(vm);
2871     throwStackOverflowError(globalObject, scope);
2872 }
2873 
2874 int32_t JIT_OPERATION operationSizeOfVarargs(JSGlobalObject* globalObject, EncodedJSValue encodedArguments, uint32_t firstVarArgOffset)
2875 {
2876     VM&amp; vm = globalObject-&gt;vm();
2877     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2878     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2879     JSValue arguments = JSValue::decode(encodedArguments);
2880 
2881     return sizeOfVarargs(globalObject, arguments, firstVarArgOffset);
2882 }
2883 
2884 int32_t JIT_OPERATION operationHasOwnProperty(JSGlobalObject* globalObject, JSObject* thisObject, EncodedJSValue encodedKey)
2885 {
2886     VM&amp; vm = globalObject-&gt;vm();
2887     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2888     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2889     auto scope = DECLARE_THROW_SCOPE(vm);
2890 
2891     JSValue key = JSValue::decode(encodedKey);
2892     Identifier propertyName = key.toPropertyKey(globalObject);
2893     RETURN_IF_EXCEPTION(scope, false);
2894 
2895     PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
2896     bool result = thisObject-&gt;hasOwnProperty(globalObject, propertyName.impl(), slot);
2897     RETURN_IF_EXCEPTION(scope, false);
2898 
2899     HasOwnPropertyCache* hasOwnPropertyCache = vm.hasOwnPropertyCache();
2900     ASSERT(hasOwnPropertyCache);
2901     hasOwnPropertyCache-&gt;tryAdd(vm, slot, thisObject, propertyName.impl(), result);
2902     return result;
2903 }
2904 
2905 int32_t JIT_OPERATION operationNumberIsInteger(JSGlobalObject* globalObject, EncodedJSValue value)
2906 {
2907     VM&amp; vm = globalObject-&gt;vm();
2908     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2909     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2910     return NumberConstructor::isIntegerImpl(JSValue::decode(value));
2911 }
2912 
2913 int32_t JIT_OPERATION operationArrayIndexOfString(JSGlobalObject* globalObject, Butterfly* butterfly, JSString* searchElement, int32_t index)
2914 {
2915     VM&amp; vm = globalObject-&gt;vm();
2916     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2917     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2918     auto scope = DECLARE_THROW_SCOPE(vm);
2919 
2920     int32_t length = butterfly-&gt;publicLength();
2921     auto data = butterfly-&gt;contiguous().data();
2922     for (; index &lt; length; ++index) {
2923         JSValue value = data[index].get();
2924         if (!value || !value.isString())
2925             continue;
2926         auto* string = asString(value);
2927         if (string == searchElement)
2928             return index;
2929         if (string-&gt;equal(globalObject, searchElement)) {
2930             scope.assertNoException();
2931             return index;
2932         }
2933         RETURN_IF_EXCEPTION(scope, { });
2934     }
2935     return -1;
2936 }
2937 
2938 int32_t JIT_OPERATION operationArrayIndexOfValueInt32OrContiguous(JSGlobalObject* globalObject, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)
2939 {
2940     VM&amp; vm = globalObject-&gt;vm();
2941     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2942     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2943     auto scope = DECLARE_THROW_SCOPE(vm);
2944 
2945     JSValue searchElement = JSValue::decode(encodedValue);
2946 
2947     int32_t length = butterfly-&gt;publicLength();
2948     auto data = butterfly-&gt;contiguous().data();
2949     for (; index &lt; length; ++index) {
2950         JSValue value = data[index].get();
2951         if (!value)
2952             continue;
2953         bool isEqual = JSValue::strictEqual(globalObject, searchElement, value);
2954         RETURN_IF_EXCEPTION(scope, { });
2955         if (isEqual)
2956             return index;
2957     }
2958     return -1;
2959 }
2960 
2961 int32_t JIT_OPERATION operationArrayIndexOfValueDouble(JSGlobalObject* globalObject, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)
2962 {
2963     VM&amp; vm = globalObject-&gt;vm();
2964     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2965     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2966 
2967     JSValue searchElement = JSValue::decode(encodedValue);
2968 
2969     if (!searchElement.isNumber())
2970         return -1;
2971     double number = searchElement.asNumber();
2972 
2973     int32_t length = butterfly-&gt;publicLength();
2974     const double* data = butterfly-&gt;contiguousDouble().data();
2975     for (; index &lt; length; ++index) {
2976         // This comparison ignores NaN.
2977         if (data[index] == number)
2978             return index;
2979     }
2980     return -1;
2981 }
2982 
2983 void JIT_OPERATION operationLoadVarargs(JSGlobalObject* globalObject, int32_t firstElementDest, EncodedJSValue encodedArguments, uint32_t offset, uint32_t lengthIncludingThis, uint32_t mandatoryMinimum)
2984 {
2985     VirtualRegister firstElement { firstElementDest };
2986     VM&amp; vm = globalObject-&gt;vm();
2987     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
2988     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
2989     JSValue arguments = JSValue::decode(encodedArguments);
2990 
2991     loadVarargs(globalObject, bitwise_cast&lt;JSValue*&gt;(&amp;callFrame-&gt;r(firstElement)), arguments, offset, lengthIncludingThis - 1);
2992 
2993     for (uint32_t i = lengthIncludingThis - 1; i &lt; mandatoryMinimum; ++i)
2994         callFrame-&gt;r(firstElement + i) = jsUndefined();
2995 }
2996 
2997 double JIT_OPERATION operationFModOnInts(int32_t a, int32_t b)
2998 {
2999     return fmod(a, b);
3000 }
3001 
3002 #if USE(JSVALUE32_64)
3003 double JIT_OPERATION operationRandom(JSGlobalObject* globalObject)
3004 {
3005     return globalObject-&gt;weakRandomNumber();
3006 }
3007 #endif
3008 
3009 JSCell* JIT_OPERATION operationStringFromCharCode(JSGlobalObject* globalObject, int32_t op1)
3010 {
3011     VM&amp; vm = globalObject-&gt;vm();
3012     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3013     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3014     return JSC::stringFromCharCode(globalObject, op1);
3015 }
3016 
3017 EncodedJSValue JIT_OPERATION operationStringFromCharCodeUntyped(JSGlobalObject* globalObject, EncodedJSValue encodedValue)
3018 {
3019     VM&amp; vm = globalObject-&gt;vm();
3020     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3021     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3022     JSValue charValue = JSValue::decode(encodedValue);
3023     int32_t chInt = charValue.toUInt32(globalObject);
3024     return JSValue::encode(JSC::stringFromCharCode(globalObject, chInt));
3025 }
3026 
3027 int64_t JIT_OPERATION operationConvertBoxedDoubleToInt52(EncodedJSValue encodedValue)
3028 {
3029     JSValue value = JSValue::decode(encodedValue);
3030     if (!value.isDouble())
3031         return JSValue::notInt52;
3032     return tryConvertToInt52(value.asDouble());
3033 }
3034 
3035 int64_t JIT_OPERATION operationConvertDoubleToInt52(double value)
3036 {
3037     return tryConvertToInt52(value);
3038 }
3039 
3040 char* JIT_OPERATION operationNewRawObject(VM* vmPointer, Structure* structure, int32_t length, Butterfly* butterfly)
3041 {
3042     VM&amp; vm = *vmPointer;
3043     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3044     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3045 
3046     if (!butterfly
3047         &amp;&amp; (structure-&gt;outOfLineCapacity() || hasIndexedProperties(structure-&gt;indexingType()))) {
3048         IndexingHeader header;
3049         header.setVectorLength(length);
3050         header.setPublicLength(0);
3051 
3052         butterfly = Butterfly::create(
3053             vm, nullptr, 0, structure-&gt;outOfLineCapacity(),
3054             hasIndexedProperties(structure-&gt;indexingType()), header,
3055             length * sizeof(EncodedJSValue));
3056     }
3057 
3058     JSObject* result = JSObject::createRawObject(vm, structure, butterfly);
3059     return bitwise_cast&lt;char*&gt;(result);
3060 }
3061 
3062 JSCell* JIT_OPERATION operationNewObjectWithButterfly(VM* vmPointer, Structure* structure, Butterfly* butterfly)
3063 {
3064     VM&amp; vm = *vmPointer;
3065     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3066     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3067 
3068     if (!butterfly) {
3069         butterfly = Butterfly::create(
3070             vm, nullptr, 0, structure-&gt;outOfLineCapacity(), false, IndexingHeader(), 0);
3071     }
3072 
3073     JSObject* result = JSObject::createRawObject(vm, structure, butterfly);
3074     return result;
3075 }
3076 
3077 JSCell* JIT_OPERATION operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength(VM* vmPointer, Structure* structure, unsigned length, Butterfly* butterfly)
3078 {
3079     VM&amp; vm = *vmPointer;
3080     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3081     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3082 
3083     IndexingHeader header;
3084     header.setVectorLength(length);
3085     header.setPublicLength(0);
3086     if (butterfly)
3087         *butterfly-&gt;indexingHeader() = header;
3088     else {
3089         butterfly = Butterfly::create(
3090             vm, nullptr, 0, structure-&gt;outOfLineCapacity(), true, header,
3091             sizeof(EncodedJSValue) * length);
3092     }
3093 
3094     // Paradoxically this may allocate a JSArray. That&#39;s totally cool.
3095     JSObject* result = JSObject::createRawObject(vm, structure, butterfly);
3096     return result;
3097 }
3098 
3099 JSCell* JIT_OPERATION operationNewArrayWithSpreadSlow(JSGlobalObject* globalObject, void* buffer, uint32_t numItems)
3100 {
3101     VM&amp; vm = globalObject-&gt;vm();
3102     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3103     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3104     auto scope = DECLARE_THROW_SCOPE(vm);
3105 
3106     EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
3107     Checked&lt;unsigned, RecordOverflow&gt; checkedLength = 0;
3108     for (unsigned i = 0; i &lt; numItems; i++) {
3109         JSValue value = JSValue::decode(values[i]);
3110         if (JSImmutableButterfly* array = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, value))
3111             checkedLength += array-&gt;publicLength();
3112         else
3113             ++checkedLength;
3114     }
3115 
3116     if (UNLIKELY(checkedLength.hasOverflowed())) {
3117         throwOutOfMemoryError(globalObject, scope);
3118         return nullptr;
3119     }
3120 
3121     unsigned length = checkedLength.unsafeGet();
3122     if (UNLIKELY(length &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)) {
3123         throwOutOfMemoryError(globalObject, scope);
3124         return nullptr;
3125     }
3126 
3127     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
3128 
3129     JSArray* result = JSArray::tryCreate(vm, structure, length);
3130     if (UNLIKELY(!result)) {
3131         throwOutOfMemoryError(globalObject, scope);
3132         return nullptr;
3133     }
3134     RETURN_IF_EXCEPTION(scope, nullptr);
3135 
3136     unsigned index = 0;
3137     for (unsigned i = 0; i &lt; numItems; i++) {
3138         JSValue value = JSValue::decode(values[i]);
3139         if (JSImmutableButterfly* array = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, value)) {
3140             // We are spreading.
3141             for (unsigned i = 0; i &lt; array-&gt;publicLength(); i++) {
3142                 result-&gt;putDirectIndex(globalObject, index, array-&gt;get(i));
3143                 RETURN_IF_EXCEPTION(scope, nullptr);
3144                 ++index;
3145             }
3146         } else {
3147             // We are not spreading.
3148             result-&gt;putDirectIndex(globalObject, index, value);
3149             RETURN_IF_EXCEPTION(scope, nullptr);
3150             ++index;
3151         }
3152     }
3153 
3154     return result;
3155 }
3156 
3157 JSCell* operationCreateImmutableButterfly(JSGlobalObject* globalObject, unsigned length)
3158 {
3159     VM&amp; vm = globalObject-&gt;vm();
3160     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3161     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3162     auto scope = DECLARE_THROW_SCOPE(vm);
3163 
3164     if (JSImmutableButterfly* result = JSImmutableButterfly::tryCreate(vm, vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), length))
3165         return result;
3166 
3167     throwOutOfMemoryError(globalObject, scope);
3168     return nullptr;
3169 }
3170 
3171 JSCell* JIT_OPERATION operationSpreadGeneric(JSGlobalObject* globalObject, JSCell* iterable)
3172 {
3173     VM&amp; vm = globalObject-&gt;vm();
3174     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3175     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3176 
3177     auto throwScope = DECLARE_THROW_SCOPE(vm);
3178 
3179     if (isJSArray(iterable)) {
3180         JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
3181         if (array-&gt;isIteratorProtocolFastAndNonObservable())
3182             RELEASE_AND_RETURN(throwScope, JSImmutableButterfly::createFromArray(globalObject, vm, array));
3183     }
3184 
3185     // FIXME: we can probably make this path faster by having our caller JS code call directly into
3186     // the iteration protocol builtin: https://bugs.webkit.org/show_bug.cgi?id=164520
3187 
3188     JSArray* array;
3189     {
3190         JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
3191         CallData callData;
3192         CallType callType = JSC::getCallData(vm, iterationFunction, callData);
3193         ASSERT(callType != CallType::None);
3194 
3195         MarkedArgumentBuffer arguments;
3196         arguments.append(iterable);
3197         ASSERT(!arguments.hasOverflowed());
3198         JSValue arrayResult = call(globalObject, iterationFunction, callType, callData, jsNull(), arguments);
3199         RETURN_IF_EXCEPTION(throwScope, nullptr);
3200         array = jsCast&lt;JSArray*&gt;(arrayResult);
3201     }
3202 
3203     RELEASE_AND_RETURN(throwScope, JSImmutableButterfly::createFromArray(globalObject, vm, array));
3204 }
3205 
3206 JSCell* JIT_OPERATION operationSpreadFastArray(JSGlobalObject* globalObject, JSCell* cell)
3207 {
3208     VM&amp; vm = globalObject-&gt;vm();
3209     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3210     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3211 
3212     ASSERT(isJSArray(cell));
3213     JSArray* array = jsCast&lt;JSArray*&gt;(cell);
3214     ASSERT(array-&gt;isIteratorProtocolFastAndNonObservable());
3215 
3216     return JSImmutableButterfly::createFromArray(globalObject, vm, array);
3217 }
3218 
3219 void JIT_OPERATION operationProcessTypeProfilerLogDFG(VM* vmPointer)
3220 {
3221     VM&amp; vm = *vmPointer;
3222     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3223     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3224 
3225     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside DFG.&quot;_s);
3226 }
3227 
3228 EncodedJSValue JIT_OPERATION operationResolveScopeForHoistingFuncDeclInEval(JSGlobalObject* globalObject, JSScope* scope, UniquedStringImpl* impl)
3229 {
3230     VM&amp; vm = globalObject-&gt;vm();
3231     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3232     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3233 
3234     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, Identifier::fromUid(vm, impl));
3235     return JSValue::encode(resolvedScope);
3236 }
3237 
3238 JSCell* JIT_OPERATION operationResolveScope(JSGlobalObject* globalObject, JSScope* scope, UniquedStringImpl* impl)
3239 {
3240     VM&amp; vm = globalObject-&gt;vm();
3241     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3242     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3243 
3244     JSObject* resolvedScope = JSScope::resolve(globalObject, scope, Identifier::fromUid(vm, impl));
3245     return resolvedScope;
3246 }
3247 
3248 EncodedJSValue JIT_OPERATION operationGetDynamicVar(JSGlobalObject* globalObject, JSObject* scope, UniquedStringImpl* impl, unsigned getPutInfoBits)
3249 {
3250     VM&amp; vm = globalObject-&gt;vm();
3251     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3252     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3253     auto throwScope = DECLARE_THROW_SCOPE(vm);
3254 
3255     Identifier ident = Identifier::fromUid(vm, impl);
3256     RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(globalObject, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
3257         if (!found) {
3258             GetPutInfo getPutInfo(getPutInfoBits);
3259             if (getPutInfo.resolveMode() == ThrowIfNotFound)
3260                 throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, ident));
3261             return jsUndefined();
3262         }
3263 
3264         if (scope-&gt;isGlobalLexicalEnvironment()) {
3265             // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
3266             JSValue result = slot.getValue(globalObject, ident);
3267             if (result == jsTDZValue()) {
3268                 throwException(globalObject, throwScope, createTDZError(globalObject));
3269                 return jsUndefined();
3270             }
3271             return result;
3272         }
3273 
3274         return slot.getValue(globalObject, ident);
3275     })));
3276 }
3277 
3278 ALWAYS_INLINE static void putDynamicVar(JSGlobalObject* globalObject, VM&amp; vm, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits, bool isStrictMode)
3279 {
3280     auto throwScope = DECLARE_THROW_SCOPE(vm);
3281 
3282     const Identifier&amp; ident = Identifier::fromUid(vm, impl);
3283     GetPutInfo getPutInfo(getPutInfoBits);
3284     bool hasProperty = scope-&gt;hasProperty(globalObject, ident);
3285     RETURN_IF_EXCEPTION(throwScope, void());
3286     if (hasProperty
3287         &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
3288         &amp;&amp; !isInitialization(getPutInfo.initializationMode())) {
3289         // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
3290         PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
3291         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, globalObject, ident, slot);
3292         if (slot.getValue(globalObject, ident) == jsTDZValue()) {
3293             throwException(globalObject, throwScope, createTDZError(globalObject));
3294             return;
3295         }
3296     }
3297 
3298     if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
3299         throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, ident));
3300         return;
3301     }
3302 
3303     PutPropertySlot slot(scope, isStrictMode, PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));
3304     throwScope.release();
3305     scope-&gt;methodTable(vm)-&gt;put(scope, globalObject, ident, JSValue::decode(value), slot);
3306 }
3307 
3308 void JIT_OPERATION operationPutDynamicVarStrict(JSGlobalObject* globalObject, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)
3309 {
3310     VM&amp; vm = globalObject-&gt;vm();
3311     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3312     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3313     constexpr bool isStrictMode = true;
3314     return putDynamicVar(globalObject, vm, scope, value, impl, getPutInfoBits, isStrictMode);
3315 }
3316 
3317 void JIT_OPERATION operationPutDynamicVarNonStrict(JSGlobalObject* globalObject, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)
3318 {
3319     VM&amp; vm = globalObject-&gt;vm();
3320     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3321     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3322     constexpr bool isStrictMode = false;
3323     return putDynamicVar(globalObject, vm, scope, value, impl, getPutInfoBits, isStrictMode);
3324 }
3325 
3326 int32_t JIT_OPERATION operationMapHash(JSGlobalObject* globalObject, EncodedJSValue input)
3327 {
3328     VM&amp; vm = globalObject-&gt;vm();
3329     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3330     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3331 
3332     return jsMapHash(globalObject, vm, JSValue::decode(input));
3333 }
3334 
3335 JSCell* JIT_OPERATION operationJSMapFindBucket(JSGlobalObject* globalObject, JSCell* map, EncodedJSValue key, int32_t hash)
3336 {
3337     VM&amp; vm = globalObject-&gt;vm();
3338     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3339     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3340     JSMap::BucketType** bucket = jsCast&lt;JSMap*&gt;(map)-&gt;findBucket(globalObject, JSValue::decode(key), hash);
3341     if (!bucket)
3342         return vm.sentinelMapBucket();
3343     return *bucket;
3344 }
3345 
3346 JSCell* JIT_OPERATION operationJSSetFindBucket(JSGlobalObject* globalObject, JSCell* map, EncodedJSValue key, int32_t hash)
3347 {
3348     VM&amp; vm = globalObject-&gt;vm();
3349     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3350     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3351     JSSet::BucketType** bucket = jsCast&lt;JSSet*&gt;(map)-&gt;findBucket(globalObject, JSValue::decode(key), hash);
3352     if (!bucket)
3353         return vm.sentinelSetBucket();
3354     return *bucket;
3355 }
3356 
3357 JSCell* JIT_OPERATION operationSetAdd(JSGlobalObject* globalObject, JSCell* set, EncodedJSValue key, int32_t hash)
3358 {
3359     VM&amp; vm = globalObject-&gt;vm();
3360     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3361     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3362     auto* bucket = jsCast&lt;JSSet*&gt;(set)-&gt;addNormalized(globalObject, JSValue::decode(key), JSValue(), hash);
3363     if (!bucket)
3364         return vm.sentinelSetBucket();
3365     return bucket;
3366 }
3367 
3368 JSCell* JIT_OPERATION operationMapSet(JSGlobalObject* globalObject, JSCell* map, EncodedJSValue key, EncodedJSValue value, int32_t hash)
3369 {
3370     VM&amp; vm = globalObject-&gt;vm();
3371     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3372     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3373     auto* bucket = jsCast&lt;JSMap*&gt;(map)-&gt;addNormalized(globalObject, JSValue::decode(key), JSValue::decode(value), hash);
3374     if (!bucket)
3375         return vm.sentinelMapBucket();
3376     return bucket;
3377 }
3378 
3379 void JIT_OPERATION operationWeakSetAdd(VM* vmPointer, JSCell* set, JSCell* key, int32_t hash)
3380 {
3381     VM&amp; vm = *vmPointer;
3382     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3383     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3384     jsCast&lt;JSWeakSet*&gt;(set)-&gt;add(vm, asObject(key), JSValue(), hash);
3385 }
3386 
3387 void JIT_OPERATION operationWeakMapSet(VM* vmPointer, JSCell* map, JSCell* key, EncodedJSValue value, int32_t hash)
3388 {
3389     VM&amp; vm = *vmPointer;
3390     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3391     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3392     jsCast&lt;JSWeakMap*&gt;(map)-&gt;add(vm, asObject(key), JSValue::decode(value), hash);
3393 }
3394 
3395 EncodedJSValue JIT_OPERATION operationGetPrototypeOfObject(JSGlobalObject* globalObject, JSObject* thisObject)
3396 {
3397     VM&amp; vm = globalObject-&gt;vm();
3398     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3399     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3400     return JSValue::encode(thisObject-&gt;getPrototype(vm, globalObject));
3401 }
3402 
3403 EncodedJSValue JIT_OPERATION operationGetPrototypeOf(JSGlobalObject* globalObject, EncodedJSValue encodedValue)
3404 {
3405     VM&amp; vm = globalObject-&gt;vm();
3406     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3407     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3408     auto scope = DECLARE_THROW_SCOPE(vm);
3409 
3410     JSValue thisValue = JSValue::decode(encodedValue).toThis(globalObject, StrictMode);
3411     if (thisValue.isUndefinedOrNull())
3412         return throwVMError(globalObject, scope, createNotAnObjectError(globalObject, thisValue));
3413 
3414     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
3415     if (!thisObject) {
3416         JSObject* prototype = thisValue.synthesizePrototype(globalObject);
3417         EXCEPTION_ASSERT(!!scope.exception() == !prototype);
3418         if (UNLIKELY(!prototype))
3419             return JSValue::encode(JSValue());
3420         return JSValue::encode(prototype);
3421     }
3422 
3423     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, globalObject)));
3424 }
3425 
3426 EncodedJSValue JIT_OPERATION operationDateGetFullYear(VM* vmPointer, DateInstance* date)
3427 {
3428     VM&amp; vm = *vmPointer;
3429     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3430     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3431 
3432     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);
3433     if (!gregorianDateTime)
3434         return JSValue::encode(jsNaN());
3435     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));
3436 }
3437 
3438 EncodedJSValue JIT_OPERATION operationDateGetUTCFullYear(VM* vmPointer, DateInstance* date)
3439 {
3440     VM&amp; vm = *vmPointer;
3441     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3442     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3443 
3444     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);
3445     if (!gregorianDateTime)
3446         return JSValue::encode(jsNaN());
3447     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));
3448 }
3449 
3450 EncodedJSValue JIT_OPERATION operationDateGetMonth(VM* vmPointer, DateInstance* date)
3451 {
3452     VM&amp; vm = *vmPointer;
3453     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3454     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3455 
3456     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);
3457     if (!gregorianDateTime)
3458         return JSValue::encode(jsNaN());
3459     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));
3460 }
3461 
3462 EncodedJSValue JIT_OPERATION operationDateGetUTCMonth(VM* vmPointer, DateInstance* date)
3463 {
3464     VM&amp; vm = *vmPointer;
3465     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3466     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3467 
3468     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);
3469     if (!gregorianDateTime)
3470         return JSValue::encode(jsNaN());
3471     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));
3472 }
3473 
3474 EncodedJSValue JIT_OPERATION operationDateGetDate(VM* vmPointer, DateInstance* date)
3475 {
3476     VM&amp; vm = *vmPointer;
3477     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3478     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3479 
3480     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);
3481     if (!gregorianDateTime)
3482         return JSValue::encode(jsNaN());
3483     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));
3484 }
3485 
3486 EncodedJSValue JIT_OPERATION operationDateGetUTCDate(VM* vmPointer, DateInstance* date)
3487 {
3488     VM&amp; vm = *vmPointer;
3489     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3490     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3491 
3492     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);
3493     if (!gregorianDateTime)
3494         return JSValue::encode(jsNaN());
3495     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));
3496 }
3497 
3498 EncodedJSValue JIT_OPERATION operationDateGetDay(VM* vmPointer, DateInstance* date)
3499 {
3500     VM&amp; vm = *vmPointer;
3501     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3502     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3503 
3504     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);
3505     if (!gregorianDateTime)
3506         return JSValue::encode(jsNaN());
3507     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));
3508 }
3509 
3510 EncodedJSValue JIT_OPERATION operationDateGetUTCDay(VM* vmPointer, DateInstance* date)
3511 {
3512     VM&amp; vm = *vmPointer;
3513     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3514     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3515 
3516     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);
3517     if (!gregorianDateTime)
3518         return JSValue::encode(jsNaN());
3519     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));
3520 }
3521 
3522 EncodedJSValue JIT_OPERATION operationDateGetHours(VM* vmPointer, DateInstance* date)
3523 {
3524     VM&amp; vm = *vmPointer;
3525     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3526     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3527 
3528     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);
3529     if (!gregorianDateTime)
3530         return JSValue::encode(jsNaN());
3531     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));
3532 }
3533 
3534 EncodedJSValue JIT_OPERATION operationDateGetUTCHours(VM* vmPointer, DateInstance* date)
3535 {
3536     VM&amp; vm = *vmPointer;
3537     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3538     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3539 
3540     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);
3541     if (!gregorianDateTime)
3542         return JSValue::encode(jsNaN());
3543     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));
3544 }
3545 
3546 EncodedJSValue JIT_OPERATION operationDateGetMinutes(VM* vmPointer, DateInstance* date)
3547 {
3548     VM&amp; vm = *vmPointer;
3549     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3550     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3551 
3552     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);
3553     if (!gregorianDateTime)
3554         return JSValue::encode(jsNaN());
3555     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));
3556 }
3557 
3558 EncodedJSValue JIT_OPERATION operationDateGetUTCMinutes(VM* vmPointer, DateInstance* date)
3559 {
3560     VM&amp; vm = *vmPointer;
3561     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3562     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3563 
3564     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);
3565     if (!gregorianDateTime)
3566         return JSValue::encode(jsNaN());
3567     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));
3568 }
3569 
3570 EncodedJSValue JIT_OPERATION operationDateGetSeconds(VM* vmPointer, DateInstance* date)
3571 {
3572     VM&amp; vm = *vmPointer;
3573     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3574     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3575 
3576     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);
3577     if (!gregorianDateTime)
3578         return JSValue::encode(jsNaN());
3579     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));
3580 }
3581 
3582 EncodedJSValue JIT_OPERATION operationDateGetUTCSeconds(VM* vmPointer, DateInstance* date)
3583 {
3584     VM&amp; vm = *vmPointer;
3585     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3586     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3587 
3588     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);
3589     if (!gregorianDateTime)
3590         return JSValue::encode(jsNaN());
3591     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));
3592 }
3593 
3594 EncodedJSValue JIT_OPERATION operationDateGetTimezoneOffset(VM* vmPointer, DateInstance* date)
3595 {
3596     VM&amp; vm = *vmPointer;
3597     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3598     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3599 
3600     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);
3601     if (!gregorianDateTime)
3602         return JSValue::encode(jsNaN());
3603     return JSValue::encode(jsNumber(-gregorianDateTime-&gt;utcOffsetInMinute()));
3604 }
3605 
3606 EncodedJSValue JIT_OPERATION operationDateGetYear(VM* vmPointer, DateInstance* date)
3607 {
3608     VM&amp; vm = *vmPointer;
3609     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3610     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3611 
3612     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);
3613     if (!gregorianDateTime)
3614         return JSValue::encode(jsNaN());
3615     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year() - 1900));
3616 }
3617 
3618 void JIT_OPERATION operationThrowDFG(JSGlobalObject* globalObject, EncodedJSValue valueToThrow)
3619 {
3620     VM&amp; vm = globalObject-&gt;vm();
3621     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3622     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3623     auto scope = DECLARE_THROW_SCOPE(vm);
3624     scope.throwException(globalObject, JSValue::decode(valueToThrow));
3625 }
3626 
3627 void JIT_OPERATION operationThrowStaticError(JSGlobalObject* globalObject, JSString* message, uint32_t errorType)
3628 {
3629     VM&amp; vm = globalObject-&gt;vm();
3630     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3631     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3632     auto scope = DECLARE_THROW_SCOPE(vm);
3633     String errorMessage = message-&gt;value(globalObject);
3634     scope.throwException(globalObject, createError(globalObject, static_cast&lt;ErrorType&gt;(errorType), errorMessage));
3635 }
3636 
3637 void JIT_OPERATION operationLinkDirectCall(CallLinkInfo* callLinkInfo, JSFunction* callee)
3638 {
3639     JSGlobalObject* globalObject = callee-&gt;globalObject();
3640     VM&amp; vm = globalObject-&gt;vm();
3641     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3642     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3643     auto throwScope = DECLARE_THROW_SCOPE(vm);
3644 
3645     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
3646 
3647     RELEASE_ASSERT(callLinkInfo-&gt;isDirect());
3648 
3649     // This would happen if the executable died during GC but the CodeBlock did not die. That should
3650     // not happen because the CodeBlock should have a weak reference to any executable it uses for
3651     // this purpose.
3652     RELEASE_ASSERT(callLinkInfo-&gt;executable());
3653 
3654     // Having a CodeBlock indicates that this is linked. We shouldn&#39;t be taking this path if it&#39;s
3655     // linked.
3656     RELEASE_ASSERT(!callLinkInfo-&gt;codeBlock());
3657 
3658     // We just don&#39;t support this yet.
3659     RELEASE_ASSERT(!callLinkInfo-&gt;isVarargs());
3660 
3661     ExecutableBase* executable = callLinkInfo-&gt;executable();
3662     RELEASE_ASSERT(callee-&gt;executable() == callLinkInfo-&gt;executable());
3663 
3664     JSScope* scope = callee-&gt;scopeUnchecked();
3665 
3666     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
3667     CodeBlock* codeBlock = nullptr;
3668     if (executable-&gt;isHostFunction())
3669         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);
3670     else {
3671         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
3672 
3673         RELEASE_ASSERT(isCall(kind) || functionExecutable-&gt;constructAbility() != ConstructAbility::CannotConstruct);
3674 
3675         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, codeBlock);
3676         EXCEPTION_ASSERT_UNUSED(throwScope, throwScope.exception() == error);
3677         if (UNLIKELY(error))
3678             return;
3679         unsigned argumentStackSlots = callLinkInfo-&gt;maxArgumentCountIncludingThis();
3680         if (argumentStackSlots &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))
3681             codePtr = functionExecutable-&gt;entrypointFor(kind, MustCheckArity);
3682         else
3683             codePtr = functionExecutable-&gt;entrypointFor(kind, ArityCheckNotRequired);
3684     }
3685 
3686     linkDirectFor(callFrame, *callLinkInfo, codeBlock, codePtr);
3687 }
3688 
3689 void triggerReoptimizationNow(CodeBlock* codeBlock, CodeBlock* optimizedCodeBlock, OSRExitBase* exit)
3690 {
3691     // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t
3692     // really be profitable.
3693     DeferGCForAWhile deferGC(codeBlock-&gt;vm().heap);
3694 
3695     sanitizeStackForVM(codeBlock-&gt;vm());
3696 
3697     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Entered reoptimize&quot;);
3698     // We must be called with the baseline code block.
3699     ASSERT(JITCode::isBaselineCode(codeBlock-&gt;jitType()));
3700 
3701     // If I am my own replacement, then reoptimization has already been triggered.
3702     // This can happen in recursive functions.
3703     //
3704     // Note that even if optimizedCodeBlock is an FTLForOSREntry style CodeBlock, this condition is a
3705     // sure bet that we don&#39;t have anything else left to do.
3706     CodeBlock* replacement = codeBlock-&gt;replacement();
3707     if (!replacement || replacement == codeBlock) {
3708         dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Not reoptimizing because we&#39;ve already been jettisoned.&quot;);
3709         return;
3710     }
3711 
3712     // Otherwise, the replacement must be optimized code. Use this as an opportunity
3713     // to check our logic.
3714     ASSERT(codeBlock-&gt;hasOptimizedReplacement());
3715     ASSERT(JITCode::isOptimizingJIT(optimizedCodeBlock-&gt;jitType()));
3716 
3717     bool didTryToEnterIntoInlinedLoops = false;
3718     for (InlineCallFrame* inlineCallFrame = exit-&gt;m_codeOrigin.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame()) {
3719         if (inlineCallFrame-&gt;baselineCodeBlock-&gt;ownerExecutable()-&gt;didTryToEnterInLoop()) {
3720             didTryToEnterIntoInlinedLoops = true;
3721             break;
3722         }
3723     }
3724 
3725     // In order to trigger reoptimization, one of two things must have happened:
3726     // 1) We exited more than some number of times.
3727     // 2) We exited and got stuck in a loop, and now we&#39;re exiting again.
3728     bool didExitABunch = optimizedCodeBlock-&gt;shouldReoptimizeNow();
3729     bool didGetStuckInLoop =
3730         (codeBlock-&gt;checkIfOptimizationThresholdReached() || didTryToEnterIntoInlinedLoops)
3731         &amp;&amp; optimizedCodeBlock-&gt;shouldReoptimizeFromLoopNow();
3732 
3733     if (!didExitABunch &amp;&amp; !didGetStuckInLoop) {
3734         dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Not reoptimizing &quot;, *optimizedCodeBlock, &quot; because it either didn&#39;t exit enough or didn&#39;t loop enough after exit.&quot;);
3735         codeBlock-&gt;optimizeAfterLongWarmUp();
3736         return;
3737     }
3738 
3739     optimizedCodeBlock-&gt;jettison(Profiler::JettisonDueToOSRExit, CountReoptimization);
3740 }
3741 
3742 void JIT_OPERATION operationTriggerReoptimizationNow(CodeBlock* codeBlock, CodeBlock* optimizedCodeBlock, OSRExitBase* exit)
3743 {
3744     triggerReoptimizationNow(codeBlock, optimizedCodeBlock, exit);
3745 }
3746 
3747 #if ENABLE(FTL_JIT)
3748 static bool shouldTriggerFTLCompile(CodeBlock* codeBlock, JITCode* jitCode)
3749 {
3750     if (codeBlock-&gt;baselineVersion()-&gt;m_didFailFTLCompilation) {
3751         CODEBLOCK_LOG_EVENT(codeBlock, &quot;abortFTLCompile&quot;, ());
3752         dataLogLnIf(Options::verboseOSR(), &quot;Deferring FTL-optimization of &quot;, *codeBlock, &quot; indefinitely because there was an FTL failure.&quot;);
3753         jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3754         return false;
3755     }
3756 
3757     if (!codeBlock-&gt;hasOptimizedReplacement()
3758         &amp;&amp; !jitCode-&gt;checkIfOptimizationThresholdReached(codeBlock)) {
3759         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;counter = &quot;, jitCode-&gt;tierUpCounter));
3760         dataLogLnIf(Options::verboseOSR(), &quot;Choosing not to FTL-optimize &quot;, *codeBlock, &quot; yet.&quot;);
3761         return false;
3762     }
3763     return true;
3764 }
3765 
3766 static void triggerFTLReplacementCompile(VM&amp; vm, CodeBlock* codeBlock, JITCode* jitCode)
3767 {
3768     if (codeBlock-&gt;codeType() == GlobalCode) {
3769         // Global code runs once, so we don&#39;t want to do anything. We don&#39;t want to defer indefinitely,
3770         // since this may have been spuriously called from tier-up initiated in a loop, and that loop may
3771         // later want to run faster code. Deferring for warm-up seems safest.
3772         jitCode-&gt;optimizeAfterWarmUp(codeBlock);
3773         return;
3774     }
3775 
3776     Worklist::State worklistState;
3777     if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
3778         worklistState = worklist-&gt;completeAllReadyPlansForVM(
3779             vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLMode));
3780     } else
3781         worklistState = Worklist::NotKnown;
3782 
3783     if (worklistState == Worklist::Compiling) {
3784         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;still compiling&quot;));
3785         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3786             codeBlock, CompilationDeferred);
3787         return;
3788     }
3789 
3790     if (codeBlock-&gt;hasOptimizedReplacement()) {
3791         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;has replacement&quot;));
3792         // That&#39;s great, we&#39;ve compiled the code - next time we call this function,
3793         // we&#39;ll enter that replacement.
3794         jitCode-&gt;optimizeSoon(codeBlock);
3795         return;
3796     }
3797 
3798     if (worklistState == Worklist::Compiled) {
3799         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;compiled and failed&quot;));
3800         // This means that we finished compiling, but failed somehow; in that case the
3801         // thresholds will be set appropriately.
3802         dataLogLnIf(Options::verboseOSR(), &quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.&quot;);
3803         return;
3804     }
3805 
3806     CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLReplacement&quot;, ());
3807     // We need to compile the code.
3808     compile(
3809         vm, codeBlock-&gt;newReplacement(), codeBlock, FTLMode, BytecodeIndex(),
3810         Operands&lt;Optional&lt;JSValue&gt;&gt;(), ToFTLDeferredCompilationCallback::create());
3811 
3812     // If we reached here, the counter has not be reset. Do that now.
3813     jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3814         codeBlock, CompilationDeferred);
3815 }
3816 
3817 void JIT_OPERATION operationTriggerTierUpNow(VM* vmPointer)
3818 {
3819     VM&amp; vm = *vmPointer;
3820     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
3821     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
3822     DeferGCForAWhile deferGC(vm.heap);
3823     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
3824 
3825     sanitizeStackForVM(vm);
3826 
3827     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
3828         dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
3829         RELEASE_ASSERT_NOT_REACHED();
3830     }
3831 
3832     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3833 
3834     dataLogLnIf(Options::verboseOSR(),
3835         *codeBlock, &quot;: Entered triggerTierUpNow with executeCounter = &quot;, jitCode-&gt;tierUpCounter);
3836 
3837     if (shouldTriggerFTLCompile(codeBlock, jitCode))
3838         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3839 
3840     if (codeBlock-&gt;hasOptimizedReplacement()) {
3841         if (jitCode-&gt;tierUpEntryTriggers.isEmpty()) {
3842             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;replacement in place, delaying indefinitely&quot;));
3843             // There is nothing more we can do, the only way this will be entered
3844             // is through the function entry point.
3845             jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3846             return;
3847         }
3848         if (jitCode-&gt;osrEntryBlock() &amp;&amp; jitCode-&gt;tierUpEntryTriggers.size() == 1) {
3849             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;trigger in place, delaying indefinitely&quot;));
3850             // There is only one outer loop and its trigger must have been set
3851             // when the plan completed.
3852             // Exiting the inner loop is useless, we can ignore the counter and leave
3853             // the trigger do its job.
3854             jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3855             return;
3856         }
3857     }
3858 }
3859 
3860 static char* tierUpCommon(VM&amp; vm, CallFrame* callFrame, BytecodeIndex originBytecodeIndex, bool canOSREnterHere)
3861 {
3862     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
3863 
3864     // Resolve any pending plan for OSR Enter on this function.
3865     Worklist::State worklistState;
3866     if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
3867         worklistState = worklist-&gt;completeAllReadyPlansForVM(
3868             vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLForOSREntryMode));
3869     } else
3870         worklistState = Worklist::NotKnown;
3871 
3872     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3873 
3874     bool triggeredSlowPathToStartCompilation = false;
3875     auto tierUpEntryTriggers = jitCode-&gt;tierUpEntryTriggers.find(originBytecodeIndex);
3876     if (tierUpEntryTriggers != jitCode-&gt;tierUpEntryTriggers.end()) {
3877         switch (tierUpEntryTriggers-&gt;value) {
3878         case JITCode::TriggerReason::DontTrigger:
3879             // The trigger isn&#39;t set, we entered because the counter reached its
3880             // threshold.
3881             break;
3882 
3883         case JITCode::TriggerReason::CompilationDone:
3884             // The trigger was set because compilation completed. Don&#39;t unset it
3885             // so that further DFG executions OSR enter as well.
3886             break;
3887 
3888         case JITCode::TriggerReason::StartCompilation:
3889             // We were asked to enter as soon as possible and start compiling an
3890             // entry for the current bytecode location. Unset this trigger so we
3891             // don&#39;t continually enter.
3892             tierUpEntryTriggers-&gt;value = JITCode::TriggerReason::DontTrigger;
3893             triggeredSlowPathToStartCompilation = true;
3894             break;
3895         }
3896     }
3897 
3898     if (worklistState == Worklist::Compiling) {
3899         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;still compiling&quot;));
3900         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
3901         return nullptr;
3902     }
3903 
3904     // If we can OSR Enter, do it right away.
3905     if (canOSREnterHere) {
3906         auto iter = jitCode-&gt;bytecodeIndexToStreamIndex.find(originBytecodeIndex);
3907         if (iter != jitCode-&gt;bytecodeIndexToStreamIndex.end()) {
3908             unsigned streamIndex = iter-&gt;value;
3909             if (CodeBlock* entryBlock = jitCode-&gt;osrEntryBlock()) {
3910                 dataLogLnIf(Options::verboseOSR(), &quot;OSR entry: From &quot;, RawPointer(jitCode), &quot; got entry block &quot;, RawPointer(entryBlock));
3911                 if (void* address = FTL::prepareOSREntry(vm, callFrame, codeBlock, entryBlock, originBytecodeIndex, streamIndex)) {
3912                     CODEBLOCK_LOG_EVENT(entryBlock, &quot;osrEntry&quot;, (&quot;at &quot;, originBytecodeIndex));
3913                     return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(callFrame));
3914                 }
3915             }
3916         }
3917     }
3918 
3919     if (worklistState == Worklist::Compiled) {
3920         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;compiled and failed&quot;));
3921         // This means that compilation failed and we already set the thresholds.
3922         dataLogLnIf(Options::verboseOSR(), &quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.&quot;);
3923         return nullptr;
3924     }
3925 
3926     // - If we don&#39;t have an FTL code block, then try to compile one.
3927     // - If we do have an FTL code block, then try to enter for a while.
3928     // - If we couldn&#39;t enter for a while, then trigger OSR entry.
3929 
3930     if (!shouldTriggerFTLCompile(codeBlock, jitCode) &amp;&amp; !triggeredSlowPathToStartCompilation)
3931         return nullptr;
3932 
3933     if (!jitCode-&gt;neverExecutedEntry &amp;&amp; !triggeredSlowPathToStartCompilation) {
3934         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3935 
3936         if (!codeBlock-&gt;hasOptimizedReplacement())
3937             return nullptr;
3938 
3939         if (jitCode-&gt;osrEntryRetry &lt; Options::ftlOSREntryRetryThreshold()) {
3940             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;avoiding OSR entry compile&quot;));
3941             jitCode-&gt;osrEntryRetry++;
3942             return nullptr;
3943         }
3944     } else
3945         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;avoiding replacement compile&quot;));
3946 
3947     if (CodeBlock* entryBlock = jitCode-&gt;osrEntryBlock()) {
3948         if (jitCode-&gt;osrEntryRetry &lt; Options::ftlOSREntryRetryThreshold()) {
3949             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR entry failed, OSR entry threshold not met&quot;));
3950             jitCode-&gt;osrEntryRetry++;
3951             jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3952                 codeBlock, CompilationDeferred);
3953             return nullptr;
3954         }
3955 
3956         FTL::ForOSREntryJITCode* entryCode = entryBlock-&gt;jitCode()-&gt;ftlForOSREntry();
3957         entryCode-&gt;countEntryFailure();
3958         if (entryCode-&gt;entryFailureCount() &lt;
3959             Options::ftlOSREntryFailureCountForReoptimization()) {
3960             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR entry failed&quot;));
3961             jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3962                 codeBlock, CompilationDeferred);
3963             return nullptr;
3964         }
3965 
3966         // OSR entry failed. Oh no! This implies that we need to retry. We retry
3967         // without exponential backoff and we only do this for the entry code block.
3968         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR entry failed too many times&quot;));
3969         jitCode-&gt;clearOSREntryBlockAndResetThresholds(codeBlock);
3970         return nullptr;
3971     }
3972 
3973     // It&#39;s time to try to compile code for OSR entry.
3974 
3975     if (!triggeredSlowPathToStartCompilation) {
3976 
3977         // An inner loop didn&#39;t specifically ask for us to kick off a compilation. This means the counter
3978         // crossed its threshold. We either fall through and kick off a compile for originBytecodeIndex,
3979         // or we flag an outer loop to immediately try to compile itself. If there are outer loops,
3980         // we first try to make them compile themselves. But we will eventually fall back to compiling
3981         // a progressively inner loop if it takes too long for control to reach an outer loop.
3982 
3983         auto tryTriggerOuterLoopToCompile = [&amp;] {
3984             auto tierUpHierarchyEntry = jitCode-&gt;tierUpInLoopHierarchy.find(originBytecodeIndex);
3985             if (tierUpHierarchyEntry == jitCode-&gt;tierUpInLoopHierarchy.end())
3986                 return false;
3987 
3988             // This vector is ordered from innermost to outermost loop. Every bytecode entry in this vector is
3989             // allowed to do OSR entry. We start with the outermost loop and make our way inwards (hence why we
3990             // iterate the vector in reverse). Our policy is that we will trigger an outer loop to compile
3991             // immediately when program control reaches it. If program control is taking too long to reach that
3992             // outer loop, we progressively move inwards, meaning, we&#39;ll eventually trigger some loop that is
3993             // executing to compile. We start with trying to compile outer loops since we believe outer loop
3994             // compilations reveal the best opportunities for optimizing code.
3995             for (auto iter = tierUpHierarchyEntry-&gt;value.rbegin(), end = tierUpHierarchyEntry-&gt;value.rend(); iter != end; ++iter) {
3996                 BytecodeIndex osrEntryCandidate = *iter;
3997 
3998                 if (jitCode-&gt;tierUpEntryTriggers.get(osrEntryCandidate) == JITCode::TriggerReason::StartCompilation) {
3999                     // This means that we already asked this loop to compile. If we&#39;ve reached here, it
4000                     // means program control has not yet reached that loop. So it&#39;s taking too long to compile.
4001                     // So we move on to asking the inner loop of this loop to compile itself.
4002                     continue;
4003                 }
4004 
4005                 // This is where we ask the outer to loop to immediately compile itself if program
4006                 // control reaches it.
4007                 dataLogLnIf(Options::verboseOSR(), &quot;Inner-loop &quot;, originBytecodeIndex, &quot; in &quot;, *codeBlock, &quot; setting parent loop &quot;, osrEntryCandidate, &quot;&#39;s trigger and backing off.&quot;);
4008                 jitCode-&gt;tierUpEntryTriggers.set(osrEntryCandidate, JITCode::TriggerReason::StartCompilation);
4009                 return true;
4010             }
4011 
4012             return false;
4013         };
4014 
4015         if (tryTriggerOuterLoopToCompile()) {
4016             jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
4017             return nullptr;
4018         }
4019     }
4020 
4021     if (!canOSREnterHere) {
4022         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
4023         return nullptr;
4024     }
4025 
4026     // We aren&#39;t compiling and haven&#39;t compiled anything for OSR entry. So, try to compile
4027     // something.
4028 
4029     auto triggerIterator = jitCode-&gt;tierUpEntryTriggers.find(originBytecodeIndex);
4030     if (triggerIterator == jitCode-&gt;tierUpEntryTriggers.end()) {
4031         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
4032         return nullptr;
4033     }
4034 
4035     JITCode::TriggerReason* triggerAddress = &amp;(triggerIterator-&gt;value);
4036 
4037     Operands&lt;Optional&lt;JSValue&gt;&gt; mustHandleValues;
4038     unsigned streamIndex = jitCode-&gt;bytecodeIndexToStreamIndex.get(originBytecodeIndex);
4039     jitCode-&gt;reconstruct(callFrame, codeBlock, CodeOrigin(originBytecodeIndex), streamIndex, mustHandleValues);
4040     CodeBlock* replacementCodeBlock = codeBlock-&gt;newReplacement();
4041 
4042     CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLOSR&quot;, ());
4043     CompilationResult forEntryResult = compile(
4044         vm, replacementCodeBlock, codeBlock, FTLForOSREntryMode, originBytecodeIndex,
4045         mustHandleValues, ToFTLForOSREntryDeferredCompilationCallback::create(triggerAddress));
4046 
4047     if (jitCode-&gt;neverExecutedEntry)
4048         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
4049 
4050     if (forEntryResult != CompilationSuccessful) {
4051         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR ecompilation not successful&quot;));
4052         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
4053             codeBlock, CompilationDeferred);
4054         return nullptr;
4055     }
4056 
4057     CODEBLOCK_LOG_EVENT(jitCode-&gt;osrEntryBlock(), &quot;osrEntry&quot;, (&quot;at &quot;, originBytecodeIndex));
4058     // It&#39;s possible that the for-entry compile already succeeded. In that case OSR
4059     // entry will succeed unless we ran out of stack. It&#39;s not clear what we should do.
4060     // We signal to try again after a while if that happens.
4061     dataLogLnIf(Options::verboseOSR(), &quot;Immediate OSR entry: From &quot;, RawPointer(jitCode), &quot; got entry block &quot;, RawPointer(jitCode-&gt;osrEntryBlock()));
4062 
4063     void* address = FTL::prepareOSREntry(vm, callFrame, codeBlock, jitCode-&gt;osrEntryBlock(), originBytecodeIndex, streamIndex);
4064     if (!address)
4065         return nullptr;
4066     return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(callFrame));
4067 }
4068 
4069 void JIT_OPERATION operationTriggerTierUpNowInLoop(VM* vmPointer, unsigned bytecodeIndexBits)
4070 {
4071     VM&amp; vm = *vmPointer;
4072     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
4073     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
4074     DeferGCForAWhile deferGC(vm.heap);
4075     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
4076     BytecodeIndex bytecodeIndex = BytecodeIndex::fromBits(bytecodeIndexBits);
4077 
4078     sanitizeStackForVM(vm);
4079 
4080     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
4081         dataLogLn(&quot;Unexpected code block in DFG-&gt;FTL trigger tier up now in loop: &quot;, *codeBlock);
4082         RELEASE_ASSERT_NOT_REACHED();
4083     }
4084 
4085     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
4086 
4087     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Entered triggerTierUpNowInLoop with executeCounter = &quot;, jitCode-&gt;tierUpCounter);
4088 
4089     if (jitCode-&gt;tierUpInLoopHierarchy.contains(bytecodeIndex))
4090         tierUpCommon(vm, callFrame, bytecodeIndex, false);
4091     else if (shouldTriggerFTLCompile(codeBlock, jitCode))
4092         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
4093 
4094     // Since we cannot OSR Enter here, the default &quot;optimizeSoon()&quot; is not useful.
4095     if (codeBlock-&gt;hasOptimizedReplacement()) {
4096         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR in loop failed, deferring&quot;));
4097         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
4098     }
4099 }
4100 
4101 char* JIT_OPERATION operationTriggerOSREntryNow(VM* vmPointer, unsigned bytecodeIndexBits)
4102 {
4103     VM&amp; vm = *vmPointer;
4104     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
4105     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
4106     DeferGCForAWhile deferGC(vm.heap);
4107     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
4108     BytecodeIndex bytecodeIndex = BytecodeIndex::fromBits(bytecodeIndexBits);
4109 
4110     sanitizeStackForVM(vm);
4111 
4112     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
4113         dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
4114         RELEASE_ASSERT_NOT_REACHED();
4115     }
4116 
4117     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
4118 
4119     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Entered triggerOSREntryNow with executeCounter = &quot;, jitCode-&gt;tierUpCounter);
4120 
4121     return tierUpCommon(vm, callFrame, bytecodeIndex, true);
4122 }
4123 
4124 #endif // ENABLE(FTL_JIT)
4125 
4126 } // extern &quot;C&quot;
4127 } } // namespace JSC::DFG
4128 
4129 IGNORE_WARNINGS_END
4130 
4131 #endif // ENABLE(DFG_JIT)
4132 
4133 #endif // ENABLE(JIT)
    </pre>
  </body>
</html>
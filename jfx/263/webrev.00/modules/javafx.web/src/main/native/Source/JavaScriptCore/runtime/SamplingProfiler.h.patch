diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SamplingProfiler.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SamplingProfiler.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SamplingProfiler.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SamplingProfiler.h
@@ -103,11 +103,11 @@
                 return codeBlockHash.isSet();
             }
 
             bool hasBytecodeIndex() const
             {
-                return bytecodeIndex != std::numeric_limits<unsigned>::max();
+                return !!bytecodeIndex;
             }
 
             bool hasExpressionInfo() const
             {
                 return lineNumber != std::numeric_limits<unsigned>::max()
@@ -115,11 +115,11 @@
             }
 
             // These attempt to be expression-level line and column number.
             unsigned lineNumber { std::numeric_limits<unsigned>::max() };
             unsigned columnNumber { std::numeric_limits<unsigned>::max() };
-            unsigned bytecodeIndex { std::numeric_limits<unsigned>::max() };
+            BytecodeIndex bytecodeIndex;
             CodeBlockHash codeBlockHash;
             JITType jitType { JITType::None };
         };
 
         CodeLocation semanticLocation;
@@ -178,11 +178,11 @@
     void start(const AbstractLocker&);
     Vector<StackTrace> releaseStackTraces(const AbstractLocker&);
     JS_EXPORT_PRIVATE String stackTracesAsJSON();
     JS_EXPORT_PRIVATE void noticeCurrentThreadAsJSCExecutionThread();
     void noticeCurrentThreadAsJSCExecutionThread(const AbstractLocker&);
-    void processUnverifiedStackTraces(); // You should call this only after acquiring the lock.
+    void processUnverifiedStackTraces(const AbstractLocker&);
     void setStopWatch(const AbstractLocker&, Ref<Stopwatch>&& stopwatch) { m_stopwatch = WTFMove(stopwatch); }
     void pause(const AbstractLocker&);
     void clearData(const AbstractLocker&);
 
     // Used for debugging in the JSC shell/DRT.

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBoxModelObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2005 Allan Sandfeld Jensen (kde@carewolf.com)
   5  *           (C) 2005, 2006 Samuel Weinig (sam.weinig@gmail.com)
   6  * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2013 Apple Inc. All rights reserved.
   7  * Copyright (C) 2010 Google Inc. All rights reserved.
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  *
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;RenderBoxModelObject.h&quot;
  28 
  29 #include &quot;BitmapImage.h&quot;
  30 #include &quot;BorderEdge.h&quot;
  31 #include &quot;CachedImage.h&quot;
  32 #include &quot;Document.h&quot;
  33 #include &quot;DocumentTimeline.h&quot;
  34 #include &quot;FloatRoundedRect.h&quot;
  35 #include &quot;Frame.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;GeometryUtilities.h&quot;
  38 #include &quot;GraphicsContext.h&quot;
  39 #include &quot;HTMLFrameOwnerElement.h&quot;
  40 #include &quot;HTMLFrameSetElement.h&quot;
  41 #include &quot;HTMLImageElement.h&quot;
  42 #include &quot;HTMLNames.h&quot;
  43 #include &quot;ImageBuffer.h&quot;
  44 #include &quot;ImageQualityController.h&quot;
  45 #include &quot;Path.h&quot;
  46 #include &quot;RenderBlock.h&quot;
  47 #include &quot;RenderFlexibleBox.h&quot;
  48 #include &quot;RenderFragmentContainer.h&quot;
  49 #include &quot;RenderInline.h&quot;
  50 #include &quot;RenderLayer.h&quot;
  51 #include &quot;RenderLayerBacking.h&quot;
  52 #include &quot;RenderLayerCompositor.h&quot;
  53 #include &quot;RenderMultiColumnFlow.h&quot;
  54 #include &quot;RenderTable.h&quot;
  55 #include &quot;RenderTableRow.h&quot;
  56 #include &quot;RenderText.h&quot;
  57 #include &quot;RenderTextFragment.h&quot;
  58 #include &quot;RenderTreeBuilder.h&quot;
  59 #include &quot;RenderView.h&quot;
  60 #include &quot;ScrollingConstraints.h&quot;
  61 #include &quot;Settings.h&quot;
  62 #include &quot;TransformState.h&quot;
  63 #include &lt;wtf/IsoMallocInlines.h&gt;
  64 #include &lt;wtf/NeverDestroyed.h&gt;
<a name="1" id="anc1"></a><span class="line-modified">  65 #if ASSERT_ENABLED</span>
  66 #include &lt;wtf/SetForScope.h&gt;
  67 #endif
  68 
  69 #if PLATFORM(IOS_FAMILY)
  70 #include &quot;RuntimeApplicationChecks.h&quot;
  71 #endif
  72 
  73 namespace WebCore {
  74 
  75 using namespace HTMLNames;
  76 
  77 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderBoxModelObject);
  78 
  79 // The HashMap for storing continuation pointers.
  80 // An inline can be split with blocks occuring in between the inline content.
  81 // When this occurs we need a pointer to the next object. We can basically be
  82 // split into a sequence of inlines and blocks. The continuation will either be
  83 // an anonymous block (that houses other blocks) or it will be an inline flow.
  84 // &lt;b&gt;&lt;i&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/i&gt;&lt;/b&gt;. In this example the &lt;i&gt; will have a block as
  85 // its continuation but the &lt;b&gt; will just have an inline as its continuation.
  86 RenderBoxModelObject::ContinuationChainNode::ContinuationChainNode(RenderBoxModelObject&amp; renderer)
  87     : renderer(makeWeakPtr(renderer))
  88 {
  89 }
  90 
  91 RenderBoxModelObject::ContinuationChainNode::~ContinuationChainNode()
  92 {
  93     if (next) {
  94         ASSERT(previous);
  95         ASSERT(next-&gt;previous == this);
  96         next-&gt;previous = previous;
  97     }
  98     if (previous) {
  99         ASSERT(previous-&gt;next == this);
 100         previous-&gt;next = next;
 101     }
 102 }
 103 
 104 void RenderBoxModelObject::ContinuationChainNode::insertAfter(ContinuationChainNode&amp; after)
 105 {
 106     ASSERT(!previous);
 107     ASSERT(!next);
 108     if ((next = after.next)) {
 109         ASSERT(next-&gt;previous == &amp;after);
 110         next-&gt;previous = this;
 111     }
 112     previous = &amp;after;
 113     after.next = this;
 114 }
 115 
 116 using ContinuationChainNodeMap = HashMap&lt;const RenderBoxModelObject*, std::unique_ptr&lt;RenderBoxModelObject::ContinuationChainNode&gt;&gt;;
 117 
 118 static ContinuationChainNodeMap&amp; continuationChainNodeMap()
 119 {
 120     static NeverDestroyed&lt;ContinuationChainNodeMap&gt; map;
 121     return map;
 122 }
 123 
 124 using FirstLetterRemainingTextMap = HashMap&lt;const RenderBoxModelObject*, WeakPtr&lt;RenderTextFragment&gt;&gt;;
 125 
 126 static FirstLetterRemainingTextMap&amp; firstLetterRemainingTextMap()
 127 {
 128     static NeverDestroyed&lt;FirstLetterRemainingTextMap&gt; map;
 129     return map;
 130 }
 131 
 132 void RenderBoxModelObject::setSelectionState(SelectionState state)
 133 {
 134     if (state == SelectionInside &amp;&amp; selectionState() != SelectionNone)
 135         return;
 136 
 137     if ((state == SelectionStart &amp;&amp; selectionState() == SelectionEnd)
 138         || (state == SelectionEnd &amp;&amp; selectionState() == SelectionStart))
 139         RenderLayerModelObject::setSelectionState(SelectionBoth);
 140     else
 141         RenderLayerModelObject::setSelectionState(state);
 142 
 143     // FIXME: We should consider whether it is OK propagating to ancestor RenderInlines.
 144     // This is a workaround for http://webkit.org/b/32123
 145     // The containing block can be null in case of an orphaned tree.
 146     RenderBlock* containingBlock = this-&gt;containingBlock();
 147     if (containingBlock &amp;&amp; !containingBlock-&gt;isRenderView())
 148         containingBlock-&gt;setSelectionState(state);
 149 }
 150 
 151 void RenderBoxModelObject::contentChanged(ContentChangeType changeType)
 152 {
 153     if (!hasLayer())
 154         return;
 155 
 156     layer()-&gt;contentChanged(changeType);
 157 }
 158 
 159 bool RenderBoxModelObject::hasAcceleratedCompositing() const
 160 {
 161     return view().compositor().hasAcceleratedCompositing();
 162 }
 163 
 164 RenderBoxModelObject::RenderBoxModelObject(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 165     : RenderLayerModelObject(element, WTFMove(style), baseTypeFlags | RenderBoxModelObjectFlag)
 166 {
 167 }
 168 
 169 RenderBoxModelObject::RenderBoxModelObject(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 170     : RenderLayerModelObject(document, WTFMove(style), baseTypeFlags | RenderBoxModelObjectFlag)
 171 {
 172 }
 173 
 174 RenderBoxModelObject::~RenderBoxModelObject()
 175 {
 176     // Do not add any code here. Add it to willBeDestroyed() instead.
 177     ASSERT(!continuation());
 178 }
 179 
 180 void RenderBoxModelObject::willBeDestroyed()
 181 {
 182     if (hasContinuationChainNode())
 183         removeFromContinuationChain();
 184 
 185     if (isFirstLetter())
 186         clearFirstLetterRemainingText();
 187 
 188     if (!renderTreeBeingDestroyed())
 189         view().imageQualityController().rendererWillBeDestroyed(*this);
 190 
 191     RenderLayerModelObject::willBeDestroyed();
 192 }
 193 
 194 bool RenderBoxModelObject::hasVisibleBoxDecorationStyle() const
 195 {
 196     return hasBackground() || style().hasVisibleBorderDecoration() || style().hasAppearance() || style().boxShadow();
 197 }
 198 
 199 void RenderBoxModelObject::updateFromStyle()
 200 {
 201     RenderLayerModelObject::updateFromStyle();
 202 
 203     // Set the appropriate bits for a box model object.  Since all bits are cleared in styleWillChange,
 204     // we only check for bits that could possibly be set to true.
 205     const RenderStyle&amp; styleToUse = style();
 206     setHasVisibleBoxDecorations(hasVisibleBoxDecorationStyle());
 207     setInline(styleToUse.isDisplayInlineType());
 208     setPositionState(styleToUse.position());
 209     setHorizontalWritingMode(styleToUse.isHorizontalWritingMode());
 210     if (styleToUse.isFlippedBlocksWritingMode())
 211         view().frameView().setHasFlippedBlockRenderers(true);
 212 }
 213 
 214 static LayoutSize accumulateInFlowPositionOffsets(const RenderObject* child)
 215 {
 216     if (!child-&gt;isAnonymousBlock() || !child-&gt;isInFlowPositioned())
 217         return LayoutSize();
 218     LayoutSize offset;
 219     for (RenderElement* parent = downcast&lt;RenderBlock&gt;(*child).inlineContinuation(); is&lt;RenderInline&gt;(parent); parent = parent-&gt;parent()) {
 220         if (parent-&gt;isInFlowPositioned())
 221             offset += downcast&lt;RenderInline&gt;(*parent).offsetForInFlowPosition();
 222     }
 223     return offset;
 224 }
 225 
 226 static inline bool isOutOfFlowPositionedWithImplicitHeight(const RenderBoxModelObject&amp; child)
 227 {
 228     return child.isOutOfFlowPositioned() &amp;&amp; !child.style().logicalTop().isAuto() &amp;&amp; !child.style().logicalBottom().isAuto();
 229 }
 230 
 231 RenderBlock* RenderBoxModelObject::containingBlockForAutoHeightDetection(Length logicalHeight) const
 232 {
 233     // For percentage heights: The percentage is calculated with respect to the
 234     // height of the generated box&#39;s containing block. If the height of the
 235     // containing block is not specified explicitly (i.e., it depends on content
 236     // height), and this element is not absolutely positioned, the used height is
 237     // calculated as if &#39;auto&#39; was specified.
 238     if (!logicalHeight.isPercentOrCalculated() || isOutOfFlowPositioned())
 239         return nullptr;
 240 
 241     // Anonymous block boxes are ignored when resolving percentage values that
 242     // would refer to it: the closest non-anonymous ancestor box is used instead.
 243     auto* cb = containingBlock();
 244     while (cb &amp;&amp; cb-&gt;isAnonymous() &amp;&amp; !is&lt;RenderView&gt;(cb))
 245         cb = cb-&gt;containingBlock();
 246     if (!cb)
 247         return nullptr;
 248 
 249     // Matching RenderBox::percentageLogicalHeightIsResolvable() by
 250     // ignoring table cell&#39;s attribute value, where it says that table cells
 251     // violate what the CSS spec says to do with heights. Basically we don&#39;t care
 252     // if the cell specified a height or not.
 253     if (cb-&gt;isTableCell())
 254         return nullptr;
 255 
 256     // Match RenderBox::availableLogicalHeightUsing by special casing the layout
 257     // view. The available height is taken from the frame.
 258     if (cb-&gt;isRenderView())
 259         return nullptr;
 260 
 261     if (isOutOfFlowPositionedWithImplicitHeight(*cb))
 262         return nullptr;
 263 
 264     return cb;
 265 }
 266 
 267 bool RenderBoxModelObject::hasAutoHeightOrContainingBlockWithAutoHeight() const
 268 {
 269     const auto* thisBox = isBox() ? downcast&lt;RenderBox&gt;(this) : nullptr;
 270     Length logicalHeightLength = style().logicalHeight();
 271     auto* cb = containingBlockForAutoHeightDetection(logicalHeightLength);
 272 
 273     if (logicalHeightLength.isPercentOrCalculated() &amp;&amp; cb &amp;&amp; isBox())
 274         cb-&gt;addPercentHeightDescendant(*const_cast&lt;RenderBox*&gt;(downcast&lt;RenderBox&gt;(this)));
 275 
 276     if (thisBox &amp;&amp; thisBox-&gt;isFlexItem()) {
 277         auto&amp; flexBox = downcast&lt;RenderFlexibleBox&gt;(*parent());
 278         if (flexBox.childLogicalHeightForPercentageResolution(*thisBox))
 279             return false;
 280     }
 281 
 282     if (thisBox &amp;&amp; thisBox-&gt;isGridItem() &amp;&amp; thisBox-&gt;hasOverrideContainingBlockContentLogicalHeight())
 283         return false;
 284 
 285     if (logicalHeightLength.isAuto() &amp;&amp; !isOutOfFlowPositionedWithImplicitHeight(*this))
 286         return true;
 287 
 288     if (document().inQuirksMode())
 289         return false;
 290 
 291     if (cb)
 292         return !cb-&gt;hasDefiniteLogicalHeight();
 293 
 294     return false;
 295 }
 296 
 297 DecodingMode RenderBoxModelObject::decodingModeForImageDraw(const Image&amp; image, const PaintInfo&amp; paintInfo) const
 298 {
 299     if (!is&lt;BitmapImage&gt;(image))
 300         return DecodingMode::Synchronous;
 301 
 302     const BitmapImage&amp; bitmapImage = downcast&lt;BitmapImage&gt;(image);
 303     if (bitmapImage.canAnimate()) {
 304         // The DecodingMode for the current frame has to be Synchronous. The DecodingMode
 305         // for the next frame will be calculated in BitmapImage::internalStartAnimation().
 306         return DecodingMode::Synchronous;
 307     }
 308 
 309     // Large image case.
 310 #if PLATFORM(IOS_FAMILY)
 311     if (IOSApplication::isIBooksStorytime())
 312         return DecodingMode::Synchronous;
 313 #endif
 314     if (is&lt;HTMLImageElement&gt;(element())) {
 315         auto decodingMode = downcast&lt;HTMLImageElement&gt;(*element()).decodingMode();
 316         if (decodingMode != DecodingMode::Auto)
 317             return decodingMode;
 318     }
 319     if (bitmapImage.isLargeImageAsyncDecodingEnabledForTesting())
 320         return DecodingMode::Asynchronous;
 321     if (document().isImageDocument())
 322         return DecodingMode::Synchronous;
 323     if (paintInfo.paintBehavior.contains(PaintBehavior::Snapshotting))
 324         return DecodingMode::Synchronous;
 325     if (!settings().largeImageAsyncDecodingEnabled())
 326         return DecodingMode::Synchronous;
 327     if (!bitmapImage.canUseAsyncDecodingForLargeImages())
 328         return DecodingMode::Synchronous;
 329     if (paintInfo.paintBehavior.contains(PaintBehavior::TileFirstPaint))
 330         return DecodingMode::Asynchronous;
 331     // FIXME: isVisibleInViewport() is not cheap. Find a way to make this condition faster.
 332     if (!isVisibleInViewport())
 333         return DecodingMode::Asynchronous;
 334     return DecodingMode::Synchronous;
 335 }
 336 
 337 LayoutSize RenderBoxModelObject::relativePositionOffset() const
 338 {
 339     // This function has been optimized to avoid calls to containingBlock() in the common case
 340     // where all values are either auto or fixed.
 341 
 342     LayoutSize offset = accumulateInFlowPositionOffsets(this);
 343 
 344     // Objects that shrink to avoid floats normally use available line width when computing containing block width.  However
 345     // in the case of relative positioning using percentages, we can&#39;t do this.  The offset should always be resolved using the
 346     // available width of the containing block.  Therefore we don&#39;t use containingBlockLogicalWidthForContent() here, but instead explicitly
 347     // call availableWidth on our containing block.
 348     // However for grid items the containing block is the grid area, so offsets should be resolved against that:
 349     // https://drafts.csswg.org/css-grid/#grid-item-sizing
 350     if (!style().left().isAuto() || !style().right().isAuto()) {
 351         LayoutUnit availableWidth = hasOverrideContainingBlockContentWidth()
 352             ? overrideContainingBlockContentWidth().valueOr(LayoutUnit()) : containingBlock()-&gt;availableWidth();
 353         if (!style().left().isAuto()) {
 354             if (!style().right().isAuto() &amp;&amp; !containingBlock()-&gt;style().isLeftToRightDirection())
 355                 offset.setWidth(-valueForLength(style().right(), !style().right().isFixed() ? availableWidth : 0_lu));
 356             else
 357                 offset.expand(valueForLength(style().left(), !style().left().isFixed() ? availableWidth : 0_lu), 0_lu);
 358         } else if (!style().right().isAuto())
 359             offset.expand(-valueForLength(style().right(), !style().right().isFixed() ? availableWidth : 0_lu), 0_lu);
 360     }
 361 
 362     // If the containing block of a relatively positioned element does not
 363     // specify a height, a percentage top or bottom offset should be resolved as
 364     // auto. An exception to this is if the containing block has the WinIE quirk
 365     // where &lt;html&gt; and &lt;body&gt; assume the size of the viewport. In this case,
 366     // calculate the percent offset based on this height.
 367     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=26396&gt;.
 368     // Another exception is a grid item, as the containing block is the grid area:
 369     // https://drafts.csswg.org/css-grid/#grid-item-sizing
 370     if (!style().top().isAuto()
 371         &amp;&amp; (!style().top().isPercentOrCalculated()
 372             || !containingBlock()-&gt;hasAutoHeightOrContainingBlockWithAutoHeight()
 373             || containingBlock()-&gt;stretchesToViewport()
 374             || hasOverrideContainingBlockContentHeight())) {
 375         // FIXME: The computation of the available height is repeated later for &quot;bottom&quot;.
 376         // We could refactor this and move it to some common code for both ifs, however moving it outside of the ifs
 377         // is not possible as it&#39;d cause performance regressions.
 378         offset.expand(0_lu, valueForLength(style().top(), !style().top().isFixed()
 379             ? (hasOverrideContainingBlockContentHeight() ? overrideContainingBlockContentHeight().valueOr(0_lu) : containingBlock()-&gt;availableHeight())
 380             : LayoutUnit()));
 381     } else if (!style().bottom().isAuto()
 382         &amp;&amp; (!style().bottom().isPercentOrCalculated()
 383             || !containingBlock()-&gt;hasAutoHeightOrContainingBlockWithAutoHeight()
 384             || containingBlock()-&gt;stretchesToViewport()
 385             || hasOverrideContainingBlockContentHeight())) {
 386         // FIXME: Check comment above for &quot;top&quot;, it applies here too.
 387         offset.expand(0_lu, -valueForLength(style().bottom(), !style().bottom().isFixed()
 388             ? (hasOverrideContainingBlockContentHeight() ? overrideContainingBlockContentHeight().valueOr(0_lu) : containingBlock()-&gt;availableHeight())
 389             : LayoutUnit()));
 390     }
 391 
 392     return offset;
 393 }
 394 
 395 LayoutPoint RenderBoxModelObject::adjustedPositionRelativeToOffsetParent(const LayoutPoint&amp; startPoint) const
 396 {
 397     // If the element is the HTML body element or doesn&#39;t have a parent
 398     // return 0 and stop this algorithm.
 399     if (isBody() || !parent())
 400         return LayoutPoint();
 401 
 402     LayoutPoint referencePoint = startPoint;
 403 
 404     // If the offsetParent of the element is null, or is the HTML body element,
 405     // return the distance between the canvas origin and the left border edge
 406     // of the element and stop this algorithm.
 407     if (const RenderBoxModelObject* offsetParent = this-&gt;offsetParent()) {
 408         if (is&lt;RenderBox&gt;(*offsetParent) &amp;&amp; !offsetParent-&gt;isBody() &amp;&amp; !is&lt;RenderTable&gt;(*offsetParent))
 409             referencePoint.move(-downcast&lt;RenderBox&gt;(*offsetParent).borderLeft(), -downcast&lt;RenderBox&gt;(*offsetParent).borderTop());
 410         if (!isOutOfFlowPositioned() || enclosingFragmentedFlow()) {
 411             if (isRelativelyPositioned())
 412                 referencePoint.move(relativePositionOffset());
 413             else if (isStickilyPositioned())
 414                 referencePoint.move(stickyPositionOffset());
 415 
 416             // CSS regions specification says that region flows should return the body element as their offsetParent.
 417             // Since we will bypass the body’s renderer anyway, just end the loop if we encounter a region flow (named flow thread).
 418             // See http://dev.w3.org/csswg/css-regions/#cssomview-offset-attributes
 419             auto* ancestor = parent();
 420             while (ancestor != offsetParent) {
 421                 // FIXME: What are we supposed to do inside SVG content?
 422 
 423                 if (is&lt;RenderMultiColumnFlow&gt;(*ancestor)) {
 424                     // We need to apply a translation based off what region we are inside.
 425                     RenderFragmentContainer* fragment = downcast&lt;RenderMultiColumnFlow&gt;(*ancestor).physicalTranslationFromFlowToFragment(referencePoint);
 426                     if (fragment)
 427                         referencePoint.moveBy(fragment-&gt;topLeftLocation());
 428                 } else if (!isOutOfFlowPositioned()) {
 429                     if (is&lt;RenderBox&gt;(*ancestor) &amp;&amp; !is&lt;RenderTableRow&gt;(*ancestor))
 430                         referencePoint.moveBy(downcast&lt;RenderBox&gt;(*ancestor).topLeftLocation());
 431                 }
 432 
 433                 ancestor = ancestor-&gt;parent();
 434             }
 435 
 436             if (is&lt;RenderBox&gt;(*offsetParent) &amp;&amp; offsetParent-&gt;isBody() &amp;&amp; !offsetParent-&gt;isPositioned())
 437                 referencePoint.moveBy(downcast&lt;RenderBox&gt;(*offsetParent).topLeftLocation());
 438         }
 439     }
 440 
 441     return referencePoint;
 442 }
 443 
 444 const RenderBox&amp; RenderBoxModelObject::enclosingClippingBoxForStickyPosition(const RenderLayer** enclosingClippingLayer) const
 445 {
 446     ASSERT(isStickilyPositioned());
 447 
<a name="2" id="anc2"></a><span class="line-modified"> 448     RenderLayer* clipLayer = hasLayer() ? layer()-&gt;enclosingOverflowClipLayer(ExcludeSelf) : nullptr;</span>
<span class="line-added"> 449 </span>
 450     if (enclosingClippingLayer)
 451         *enclosingClippingLayer = clipLayer;
 452 
 453     return clipLayer ? downcast&lt;RenderBox&gt;(clipLayer-&gt;renderer()) : view();
 454 }
 455 
 456 void RenderBoxModelObject::computeStickyPositionConstraints(StickyPositionViewportConstraints&amp; constraints, const FloatRect&amp; constrainingRect) const
 457 {
 458     constraints.setConstrainingRectAtLastLayout(constrainingRect);
 459 
 460     RenderBlock* containingBlock = this-&gt;containingBlock();
 461     const RenderLayer* enclosingClippingLayer = nullptr;
 462     auto&amp; enclosingClippingBox = enclosingClippingBoxForStickyPosition(&amp;enclosingClippingLayer);
 463 
 464     LayoutRect containerContentRect;
 465     if (!enclosingClippingLayer || (containingBlock != &amp;enclosingClippingBox))
 466         containerContentRect = containingBlock-&gt;contentBoxRect();
 467     else {
 468         containerContentRect = containingBlock-&gt;layoutOverflowRect();
 469         LayoutPoint containerLocation = containerContentRect.location() + LayoutPoint(containingBlock-&gt;borderLeft() + containingBlock-&gt;paddingLeft(),
 470             containingBlock-&gt;borderTop() + containingBlock-&gt;paddingTop());
 471         containerContentRect.setLocation(containerLocation);
 472     }
 473 
 474     LayoutUnit maxWidth = containingBlock-&gt;availableLogicalWidth();
 475 
 476     // Sticky positioned element ignore any override logical width on the containing block (as they don&#39;t call
 477     // containingBlockLogicalWidthForContent). It&#39;s unclear whether this is totally fine.
 478     LayoutBoxExtent minMargin(minimumValueForLength(style().marginTop(), maxWidth),
 479         minimumValueForLength(style().marginRight(), maxWidth),
 480         minimumValueForLength(style().marginBottom(), maxWidth),
 481         minimumValueForLength(style().marginLeft(), maxWidth));
 482 
 483     // Compute the container-relative area within which the sticky element is allowed to move.
 484     containerContentRect.contract(minMargin);
 485 
 486     // Finally compute container rect relative to the scrolling ancestor.
 487     FloatRect containerRectRelativeToScrollingAncestor = containingBlock-&gt;localToContainerQuad(FloatRect(containerContentRect), &amp;enclosingClippingBox).boundingBox();
 488     if (enclosingClippingLayer) {
 489         FloatPoint containerLocationRelativeToScrollingAncestor = containerRectRelativeToScrollingAncestor.location() -
 490             FloatSize(enclosingClippingBox.borderLeft() + enclosingClippingBox.paddingLeft(),
 491             enclosingClippingBox.borderTop() + enclosingClippingBox.paddingTop());
 492         if (&amp;enclosingClippingBox != containingBlock)
 493             containerLocationRelativeToScrollingAncestor += enclosingClippingLayer-&gt;scrollOffset();
 494         containerRectRelativeToScrollingAncestor.setLocation(containerLocationRelativeToScrollingAncestor);
 495     }
 496     constraints.setContainingBlockRect(containerRectRelativeToScrollingAncestor);
 497 
 498     // Now compute the sticky box rect, also relative to the scrolling ancestor.
 499     LayoutRect stickyBoxRect = frameRectForStickyPositioning();
 500     LayoutRect flippedStickyBoxRect = stickyBoxRect;
 501     containingBlock-&gt;flipForWritingMode(flippedStickyBoxRect);
 502     FloatRect stickyBoxRelativeToScrollingAnecstor = flippedStickyBoxRect;
 503 
 504     // FIXME: sucks to call localToContainerQuad again, but we can&#39;t just offset from the previously computed rect if there are transforms.
 505     // Map to the view to avoid including page scale factor.
 506     FloatPoint stickyLocationRelativeToScrollingAncestor = flippedStickyBoxRect.location() + containingBlock-&gt;localToContainerQuad(FloatRect(FloatPoint(), containingBlock-&gt;size()), &amp;enclosingClippingBox).boundingBox().location();
 507     if (enclosingClippingLayer) {
 508         stickyLocationRelativeToScrollingAncestor -= FloatSize(enclosingClippingBox.borderLeft() + enclosingClippingBox.paddingLeft(),
 509             enclosingClippingBox.borderTop() + enclosingClippingBox.paddingTop());
 510         if (&amp;enclosingClippingBox != containingBlock)
 511             stickyLocationRelativeToScrollingAncestor += enclosingClippingLayer-&gt;scrollOffset();
 512     }
 513     // FIXME: For now, assume that |this| is not transformed.
 514     stickyBoxRelativeToScrollingAnecstor.setLocation(stickyLocationRelativeToScrollingAncestor);
 515     constraints.setStickyBoxRect(stickyBoxRelativeToScrollingAnecstor);
 516 
 517     if (!style().left().isAuto()) {
 518         constraints.setLeftOffset(valueForLength(style().left(), constrainingRect.width()));
 519         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeLeft);
 520     }
 521 
 522     if (!style().right().isAuto()) {
 523         constraints.setRightOffset(valueForLength(style().right(), constrainingRect.width()));
 524         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeRight);
 525     }
 526 
 527     if (!style().top().isAuto()) {
 528         constraints.setTopOffset(valueForLength(style().top(), constrainingRect.height()));
 529         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
 530     }
 531 
 532     if (!style().bottom().isAuto()) {
 533         constraints.setBottomOffset(valueForLength(style().bottom(), constrainingRect.height()));
 534         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeBottom);
 535     }
 536 }
 537 
 538 FloatRect RenderBoxModelObject::constrainingRectForStickyPosition() const
 539 {
<a name="3" id="anc3"></a><span class="line-modified"> 540     RenderLayer* enclosingClippingLayer = hasLayer() ? layer()-&gt;enclosingOverflowClipLayer(ExcludeSelf) : nullptr;</span>
<span class="line-added"> 541 </span>
 542     if (enclosingClippingLayer) {
 543         RenderBox&amp; enclosingClippingBox = downcast&lt;RenderBox&gt;(enclosingClippingLayer-&gt;renderer());
 544         LayoutRect clipRect = enclosingClippingBox.overflowClipRect(LayoutPoint(), nullptr); // FIXME: make this work in regions.
 545         clipRect.contract(LayoutSize(enclosingClippingBox.paddingLeft() + enclosingClippingBox.paddingRight(),
 546             enclosingClippingBox.paddingTop() + enclosingClippingBox.paddingBottom()));
 547 
 548         FloatRect constrainingRect = enclosingClippingBox.localToContainerQuad(FloatRect(clipRect), &amp;view()).boundingBox();
 549 
 550         FloatPoint scrollOffset = FloatPoint() + enclosingClippingLayer-&gt;scrollOffset();
 551 
 552         float scrollbarOffset = 0;
 553         if (enclosingClippingBox.hasLayer() &amp;&amp; enclosingClippingBox.shouldPlaceBlockDirectionScrollbarOnLeft())
 554             scrollbarOffset = enclosingClippingBox.layer()-&gt;verticalScrollbarWidth(IgnoreOverlayScrollbarSize);
 555 
 556         constrainingRect.setLocation(FloatPoint(scrollOffset.x() + scrollbarOffset, scrollOffset.y()));
 557         return constrainingRect;
 558     }
 559 
 560     return view().frameView().rectForFixedPositionLayout();
 561 }
 562 
 563 LayoutSize RenderBoxModelObject::stickyPositionOffset() const
 564 {
<a name="4" id="anc4"></a>

 565     FloatRect constrainingRect = constrainingRectForStickyPosition();
 566     StickyPositionViewportConstraints constraints;
 567     computeStickyPositionConstraints(constraints, constrainingRect);
 568 
 569     // The sticky offset is physical, so we can just return the delta computed in absolute coords (though it may be wrong with transforms).
 570     return LayoutSize(constraints.computeStickyOffset(constrainingRect));
 571 }
 572 
 573 LayoutSize RenderBoxModelObject::offsetForInFlowPosition() const
 574 {
 575     if (isRelativelyPositioned())
 576         return relativePositionOffset();
 577 
 578     if (isStickilyPositioned())
 579         return stickyPositionOffset();
 580 
 581     return LayoutSize();
 582 }
 583 
 584 LayoutUnit RenderBoxModelObject::offsetLeft() const
 585 {
 586     // Note that RenderInline and RenderBox override this to pass a different
 587     // startPoint to adjustedPositionRelativeToOffsetParent.
 588     return adjustedPositionRelativeToOffsetParent(LayoutPoint()).x();
 589 }
 590 
 591 LayoutUnit RenderBoxModelObject::offsetTop() const
 592 {
 593     // Note that RenderInline and RenderBox override this to pass a different
 594     // startPoint to adjustedPositionRelativeToOffsetParent.
 595     return adjustedPositionRelativeToOffsetParent(LayoutPoint()).y();
 596 }
 597 
 598 LayoutUnit RenderBoxModelObject::computedCSSPadding(const Length&amp; padding) const
 599 {
 600     LayoutUnit w;
 601     if (padding.isPercentOrCalculated())
 602         w = containingBlockLogicalWidthForContent();
 603     return minimumValueForLength(padding, w);
 604 }
 605 
 606 RoundedRect RenderBoxModelObject::getBackgroundRoundedRect(const LayoutRect&amp; borderRect, InlineFlowBox* box, LayoutUnit inlineBoxWidth, LayoutUnit inlineBoxHeight,
 607     bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
 608 {
 609     RoundedRect border = style().getRoundedBorderFor(borderRect, includeLogicalLeftEdge, includeLogicalRightEdge);
 610     if (box &amp;&amp; (box-&gt;nextLineBox() || box-&gt;prevLineBox())) {
 611         RoundedRect segmentBorder = style().getRoundedBorderFor(LayoutRect(0_lu, 0_lu, inlineBoxWidth, inlineBoxHeight), includeLogicalLeftEdge, includeLogicalRightEdge);
 612         border.setRadii(segmentBorder.radii());
 613     }
 614     return border;
 615 }
 616 
 617 void RenderBoxModelObject::clipRoundedInnerRect(GraphicsContext&amp; context, const FloatRect&amp; rect, const FloatRoundedRect&amp; clipRect)
 618 {
 619     if (clipRect.isRenderable())
 620         context.clipRoundedRect(clipRect);
 621     else {
 622         // We create a rounded rect for each of the corners and clip it, while making sure we clip opposing corners together.
 623         if (!clipRect.radii().topLeft().isEmpty() || !clipRect.radii().bottomRight().isEmpty()) {
 624             FloatRect topCorner(clipRect.rect().x(), clipRect.rect().y(), rect.maxX() - clipRect.rect().x(), rect.maxY() - clipRect.rect().y());
 625             FloatRoundedRect::Radii topCornerRadii;
 626             topCornerRadii.setTopLeft(clipRect.radii().topLeft());
 627             context.clipRoundedRect(FloatRoundedRect(topCorner, topCornerRadii));
 628 
 629             FloatRect bottomCorner(rect.x(), rect.y(), clipRect.rect().maxX() - rect.x(), clipRect.rect().maxY() - rect.y());
 630             FloatRoundedRect::Radii bottomCornerRadii;
 631             bottomCornerRadii.setBottomRight(clipRect.radii().bottomRight());
 632             context.clipRoundedRect(FloatRoundedRect(bottomCorner, bottomCornerRadii));
 633         }
 634 
 635         if (!clipRect.radii().topRight().isEmpty() || !clipRect.radii().bottomLeft().isEmpty()) {
 636             FloatRect topCorner(rect.x(), clipRect.rect().y(), clipRect.rect().maxX() - rect.x(), rect.maxY() - clipRect.rect().y());
 637             FloatRoundedRect::Radii topCornerRadii;
 638             topCornerRadii.setTopRight(clipRect.radii().topRight());
 639             context.clipRoundedRect(FloatRoundedRect(topCorner, topCornerRadii));
 640 
 641             FloatRect bottomCorner(clipRect.rect().x(), rect.y(), rect.maxX() - clipRect.rect().x(), clipRect.rect().maxY() - rect.y());
 642             FloatRoundedRect::Radii bottomCornerRadii;
 643             bottomCornerRadii.setBottomLeft(clipRect.radii().bottomLeft());
 644             context.clipRoundedRect(FloatRoundedRect(bottomCorner, bottomCornerRadii));
 645         }
 646     }
 647 }
 648 
 649 static LayoutRect shrinkRectByOneDevicePixel(const GraphicsContext&amp; context, const LayoutRect&amp; rect, float devicePixelRatio)
 650 {
 651     LayoutRect shrunkRect = rect;
 652     AffineTransform transform = context.getCTM();
 653     shrunkRect.inflateX(-ceilToDevicePixel(1_lu / transform.xScale(), devicePixelRatio));
 654     shrunkRect.inflateY(-ceilToDevicePixel(1_lu / transform.yScale(), devicePixelRatio));
 655     return shrunkRect;
 656 }
 657 
 658 LayoutRect RenderBoxModelObject::borderInnerRectAdjustedForBleedAvoidance(const GraphicsContext&amp; context, const LayoutRect&amp; rect, BackgroundBleedAvoidance bleedAvoidance) const
 659 {
 660     if (bleedAvoidance != BackgroundBleedBackgroundOverBorder)
 661         return rect;
 662 
 663     // We shrink the rectangle by one device pixel on each side to make it fully overlap the anti-aliased background border
 664     return shrinkRectByOneDevicePixel(context, rect, document().deviceScaleFactor());
 665 }
 666 
 667 RoundedRect RenderBoxModelObject::backgroundRoundedRectAdjustedForBleedAvoidance(const GraphicsContext&amp; context, const LayoutRect&amp; borderRect, BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox* box, const LayoutSize&amp; boxSize, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
 668 {
 669     if (bleedAvoidance == BackgroundBleedShrinkBackground) {
 670         // We shrink the rectangle by one device pixel on each side because the bleed is one pixel maximum.
 671         return getBackgroundRoundedRect(shrinkRectByOneDevicePixel(context, borderRect, document().deviceScaleFactor()), box, boxSize.width(), boxSize.height(),
 672             includeLogicalLeftEdge, includeLogicalRightEdge);
 673     }
 674     if (bleedAvoidance == BackgroundBleedBackgroundOverBorder)
 675         return style().getRoundedInnerBorderFor(borderRect, includeLogicalLeftEdge, includeLogicalRightEdge);
 676 
 677     return getBackgroundRoundedRect(borderRect, box, boxSize.width(), boxSize.height(), includeLogicalLeftEdge, includeLogicalRightEdge);
 678 }
 679 
 680 static void applyBoxShadowForBackground(GraphicsContext&amp; context, const RenderStyle&amp; style)
 681 {
 682     const ShadowData* boxShadow = style.boxShadow();
<a name="5" id="anc5"></a><span class="line-modified"> 683     while (boxShadow-&gt;style() != ShadowStyle::Normal)</span>
 684         boxShadow = boxShadow-&gt;next();
 685 
 686     FloatSize shadowOffset(boxShadow-&gt;x(), boxShadow-&gt;y());
 687     if (!boxShadow-&gt;isWebkitBoxShadow())
 688         context.setShadow(shadowOffset, boxShadow-&gt;radius(), style.colorByApplyingColorFilter(boxShadow-&gt;color()));
 689     else
 690         context.setLegacyShadow(shadowOffset, boxShadow-&gt;radius(), style.colorByApplyingColorFilter(boxShadow-&gt;color()));
 691 }
 692 
 693 InterpolationQuality RenderBoxModelObject::chooseInterpolationQuality(GraphicsContext&amp; context, Image&amp; image, const void* layer, const LayoutSize&amp; size)
 694 {
 695     return view().imageQualityController().chooseInterpolationQuality(context, this, image, layer, size);
 696 }
 697 
 698 void RenderBoxModelObject::paintMaskForTextFillBox(ImageBuffer* maskImage, const IntRect&amp; maskRect, InlineFlowBox* box, const LayoutRect&amp; scrolledPaintRect)
 699 {
 700     GraphicsContext&amp; maskImageContext = maskImage-&gt;context();
 701     maskImageContext.translate(-maskRect.location());
 702 
 703     // Now add the text to the clip. We do this by painting using a special paint phase that signals to
 704     // InlineTextBoxes that they should just add their contents to the clip.
 705     PaintInfo info(maskImageContext, maskRect, PaintPhase::TextClip, PaintBehavior::ForceBlackText);
 706     if (box) {
 707         const RootInlineBox&amp; rootBox = box-&gt;root();
 708         box-&gt;paint(info, LayoutPoint(scrolledPaintRect.x() - box-&gt;x(), scrolledPaintRect.y() - box-&gt;y()), rootBox.lineTop(), rootBox.lineBottom());
 709     } else {
 710         LayoutSize localOffset = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).locationOffset() : LayoutSize();
 711         paint(info, scrolledPaintRect.location() - localOffset);
 712     }
 713 }
 714 
 715 void RenderBoxModelObject::paintFillLayerExtended(const PaintInfo&amp; paintInfo, const Color&amp; color, const FillLayer&amp; bgLayer, const LayoutRect&amp; rect,
 716     BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox* box, const LayoutSize&amp; boxSize, CompositeOperator op, RenderElement* backgroundObject, BaseBackgroundColorUsage baseBgColorUsage)
 717 {
 718     GraphicsContext&amp; context = paintInfo.context();
 719     if (context.paintingDisabled() || rect.isEmpty())
 720         return;
 721 
 722     bool includeLeftEdge = box ? box-&gt;includeLogicalLeftEdge() : true;
 723     bool includeRightEdge = box ? box-&gt;includeLogicalRightEdge() : true;
 724 
 725     bool hasRoundedBorder = style().hasBorderRadius() &amp;&amp; (includeLeftEdge || includeRightEdge);
 726     bool clippedWithLocalScrolling = hasOverflowClip() &amp;&amp; bgLayer.attachment() == FillAttachment::LocalBackground;
 727     bool isBorderFill = bgLayer.clip() == FillBox::Border;
 728     bool isRoot = this-&gt;isDocumentElementRenderer();
 729 
 730     Color bgColor = color;
 731     StyleImage* bgImage = bgLayer.image();
 732     bool shouldPaintBackgroundImage = bgImage &amp;&amp; bgImage-&gt;canRender(this, style().effectiveZoom());
 733 
 734     if (context.invalidatingImagesWithAsyncDecodes()) {
 735         if (shouldPaintBackgroundImage &amp;&amp; bgImage-&gt;cachedImage()-&gt;isClientWaitingForAsyncDecoding(*this))
 736             bgImage-&gt;cachedImage()-&gt;removeAllClientsWaitingForAsyncDecoding();
 737         return;
 738     }
 739 
 740     bool forceBackgroundToWhite = false;
 741     if (document().printing()) {
 742         if (style().printColorAdjust() == PrintColorAdjust::Economy)
 743             forceBackgroundToWhite = true;
 744         if (settings().shouldPrintBackgrounds())
 745             forceBackgroundToWhite = false;
 746     }
 747 
 748     // When printing backgrounds is disabled or using economy mode,
 749     // change existing background colors and images to a solid white background.
 750     // If there&#39;s no bg color or image, leave it untouched to avoid affecting transparency.
 751     // We don&#39;t try to avoid loading the background images, because this style flag is only set
 752     // when printing, and at that point we&#39;ve already loaded the background images anyway. (To avoid
 753     // loading the background images we&#39;d have to do this check when applying styles rather than
 754     // while rendering.)
 755     if (forceBackgroundToWhite) {
 756         // Note that we can&#39;t reuse this variable below because the bgColor might be changed
 757         bool shouldPaintBackgroundColor = !bgLayer.next() &amp;&amp; bgColor.isVisible();
 758         if (shouldPaintBackgroundImage || shouldPaintBackgroundColor) {
 759             bgColor = Color::white;
 760             shouldPaintBackgroundImage = false;
 761         }
 762     }
 763 
 764     bool baseBgColorOnly = (baseBgColorUsage == BaseBackgroundColorOnly);
 765     if (baseBgColorOnly &amp;&amp; (!isRoot || bgLayer.next() || bgColor.isOpaque()))
 766         return;
 767 
 768     bool colorVisible = bgColor.isVisible();
 769     float deviceScaleFactor = document().deviceScaleFactor();
 770     FloatRect pixelSnappedRect = snapRectToDevicePixels(rect, deviceScaleFactor);
 771 
 772     // Fast path for drawing simple color backgrounds.
 773     if (!isRoot &amp;&amp; !clippedWithLocalScrolling &amp;&amp; !shouldPaintBackgroundImage &amp;&amp; isBorderFill &amp;&amp; !bgLayer.next()) {
 774         if (!colorVisible)
 775             return;
 776 
 777         bool boxShadowShouldBeAppliedToBackground = this-&gt;boxShadowShouldBeAppliedToBackground(rect.location(), bleedAvoidance, box);
 778         GraphicsContextStateSaver shadowStateSaver(context, boxShadowShouldBeAppliedToBackground);
 779         if (boxShadowShouldBeAppliedToBackground)
 780             applyBoxShadowForBackground(context, style());
 781 
 782         if (hasRoundedBorder &amp;&amp; bleedAvoidance != BackgroundBleedUseTransparencyLayer) {
 783             FloatRoundedRect pixelSnappedBorder = backgroundRoundedRectAdjustedForBleedAvoidance(context, rect, bleedAvoidance, box, boxSize,
 784                 includeLeftEdge, includeRightEdge).pixelSnappedRoundedRectForPainting(deviceScaleFactor);
 785             if (pixelSnappedBorder.isRenderable()) {
 786                 CompositeOperator previousOperator = context.compositeOperation();
 787                 bool saveRestoreCompositeOp = op != previousOperator;
 788                 if (saveRestoreCompositeOp)
 789                     context.setCompositeOperation(op);
 790 
 791                 context.fillRoundedRect(pixelSnappedBorder, bgColor);
 792 
 793                 if (saveRestoreCompositeOp)
 794                     context.setCompositeOperation(previousOperator);
 795             } else {
 796                 context.save();
 797                 clipRoundedInnerRect(context, pixelSnappedRect, pixelSnappedBorder);
 798                 context.fillRect(pixelSnappedBorder.rect(), bgColor, op);
 799                 context.restore();
 800             }
 801         } else
 802             context.fillRect(pixelSnappedRect, bgColor, op);
 803 
 804         return;
 805     }
 806 
 807     // FillBox::Border radius clipping is taken care of by BackgroundBleedUseTransparencyLayer
 808     bool clipToBorderRadius = hasRoundedBorder &amp;&amp; !(isBorderFill &amp;&amp; bleedAvoidance == BackgroundBleedUseTransparencyLayer);
 809     GraphicsContextStateSaver clipToBorderStateSaver(context, clipToBorderRadius);
 810     if (clipToBorderRadius) {
 811         RoundedRect border = isBorderFill ? backgroundRoundedRectAdjustedForBleedAvoidance(context, rect, bleedAvoidance, box, boxSize, includeLeftEdge, includeRightEdge) : getBackgroundRoundedRect(rect, box, boxSize.width(), boxSize.height(), includeLeftEdge, includeRightEdge);
 812 
 813         // Clip to the padding or content boxes as necessary.
 814         if (bgLayer.clip() == FillBox::Content) {
 815             border = style().getRoundedInnerBorderFor(border.rect(),
 816                 paddingTop() + borderTop(), paddingBottom() + borderBottom(), paddingLeft() + borderLeft(), paddingRight() + borderRight(), includeLeftEdge, includeRightEdge);
 817         } else if (bgLayer.clip() == FillBox::Padding)
 818             border = style().getRoundedInnerBorderFor(border.rect(), includeLeftEdge, includeRightEdge);
 819 
 820         clipRoundedInnerRect(context, pixelSnappedRect, border.pixelSnappedRoundedRectForPainting(deviceScaleFactor));
 821     }
 822 
 823     LayoutUnit bLeft = includeLeftEdge ? borderLeft() : 0_lu;
 824     LayoutUnit bRight = includeRightEdge ? borderRight() : 0_lu;
 825     LayoutUnit pLeft = includeLeftEdge ? paddingLeft() : 0_lu;
 826     LayoutUnit pRight = includeRightEdge ? paddingRight() : 0_lu;
 827 
 828     GraphicsContextStateSaver clipWithScrollingStateSaver(context, clippedWithLocalScrolling);
 829     LayoutRect scrolledPaintRect = rect;
 830     if (clippedWithLocalScrolling) {
 831         // Clip to the overflow area.
 832         auto&amp; thisBox = downcast&lt;RenderBox&gt;(*this);
 833         context.clip(thisBox.overflowClipRect(rect.location()));
 834 
 835         // Adjust the paint rect to reflect a scrolled content box with borders at the ends.
 836         scrolledPaintRect.moveBy(-thisBox.scrollPosition());
 837         scrolledPaintRect.setWidth(bLeft + layer()-&gt;scrollWidth() + bRight);
 838         scrolledPaintRect.setHeight(borderTop() + layer()-&gt;scrollHeight() + borderBottom());
 839     }
 840 
 841     GraphicsContextStateSaver backgroundClipStateSaver(context, false);
 842     std::unique_ptr&lt;ImageBuffer&gt; maskImage;
 843     IntRect maskRect;
 844 
 845     if (bgLayer.clip() == FillBox::Padding || bgLayer.clip() == FillBox::Content) {
 846         // Clip to the padding or content boxes as necessary.
 847         if (!clipToBorderRadius) {
 848             bool includePadding = bgLayer.clip() == FillBox::Content;
 849             LayoutRect clipRect = LayoutRect(scrolledPaintRect.x() + bLeft + (includePadding ? pLeft : 0_lu),
 850                 scrolledPaintRect.y() + borderTop() + (includePadding ? paddingTop() : 0_lu),
 851                 scrolledPaintRect.width() - bLeft - bRight - (includePadding ? pLeft + pRight : 0_lu),
 852                 scrolledPaintRect.height() - borderTop() - borderBottom() - (includePadding ? paddingTop() + paddingBottom() : 0_lu));
 853             backgroundClipStateSaver.save();
 854             context.clip(clipRect);
 855         }
 856     } else if (bgLayer.clip() == FillBox::Text) {
 857         // We have to draw our text into a mask that can then be used to clip background drawing.
 858         // First figure out how big the mask has to be.  It should be no bigger than what we need
 859         // to actually render, so we should intersect the dirty rect with the border box of the background.
 860         maskRect = snappedIntRect(rect);
 861         maskRect.intersect(snappedIntRect(paintInfo.rect));
 862 
 863         // Now create the mask.
<a name="6" id="anc6"></a><span class="line-modified"> 864         maskImage = ImageBuffer::createCompatibleBuffer(maskRect.size(), ColorSpace::SRGB, context);</span>
 865         if (!maskImage)
 866             return;
 867         paintMaskForTextFillBox(maskImage.get(), maskRect, box, scrolledPaintRect);
 868 
 869         // The mask has been created.  Now we just need to clip to it.
 870         backgroundClipStateSaver.save();
 871         context.clip(maskRect);
 872         context.beginTransparencyLayer(1);
 873     }
 874 
 875     // Only fill with a base color (e.g., white) if we&#39;re the root document, since iframes/frames with
 876     // no background in the child document should show the parent&#39;s background.
 877     bool isOpaqueRoot = false;
 878     if (isRoot) {
 879         isOpaqueRoot = true;
 880         if (!bgLayer.next() &amp;&amp; !bgColor.isOpaque()) {
 881             HTMLFrameOwnerElement* ownerElement = document().ownerElement();
 882             if (ownerElement) {
 883                 if (!ownerElement-&gt;hasTagName(frameTag)) {
 884                     // Locate the &lt;body&gt; element using the DOM.  This is easier than trying
 885                     // to crawl around a render tree with potential :before/:after content and
 886                     // anonymous blocks created by inline &lt;body&gt; tags etc.  We can locate the &lt;body&gt;
 887                     // render object very easily via the DOM.
 888                     if (HTMLElement* body = document().bodyOrFrameset()) {
 889                         // Can&#39;t scroll a frameset document anyway.
 890                         isOpaqueRoot = is&lt;HTMLFrameSetElement&gt;(*body);
 891                     } else {
 892                         // SVG documents and XML documents with SVG root nodes are transparent.
 893                         isOpaqueRoot = !document().hasSVGRootNode();
 894                     }
 895                 }
 896             } else
 897                 isOpaqueRoot = !view().frameView().isTransparent();
 898         }
 899         view().frameView().setContentIsOpaque(isOpaqueRoot);
 900     }
 901 
 902     // Paint the color first underneath all images, culled if background image occludes it.
 903     // FIXME: In the bgLayer.hasFiniteBounds() case, we could improve the culling test
 904     // by verifying whether the background image covers the entire layout rect.
 905     if (!bgLayer.next()) {
 906         LayoutRect backgroundRect(scrolledPaintRect);
 907         bool boxShadowShouldBeAppliedToBackground = this-&gt;boxShadowShouldBeAppliedToBackground(rect.location(), bleedAvoidance, box);
 908         if (boxShadowShouldBeAppliedToBackground || !shouldPaintBackgroundImage || !bgLayer.hasOpaqueImage(*this) || !bgLayer.hasRepeatXY() || bgLayer.isEmpty()) {
 909             if (!boxShadowShouldBeAppliedToBackground)
 910                 backgroundRect.intersect(paintInfo.rect);
 911 
 912             // If we have an alpha and we are painting the root element, blend with the base background color.
 913             Color baseColor;
 914             bool shouldClearBackground = false;
 915             if ((baseBgColorUsage != BaseBackgroundColorSkip) &amp;&amp; isOpaqueRoot) {
 916                 baseColor = view().frameView().baseBackgroundColor();
 917                 if (!baseColor.isVisible())
 918                     shouldClearBackground = true;
 919             }
 920 
 921             GraphicsContextStateSaver shadowStateSaver(context, boxShadowShouldBeAppliedToBackground);
 922             if (boxShadowShouldBeAppliedToBackground)
 923                 applyBoxShadowForBackground(context, style());
 924 
 925             FloatRect backgroundRectForPainting = snapRectToDevicePixels(backgroundRect, deviceScaleFactor);
 926             if (baseColor.isVisible()) {
 927                 if (!baseBgColorOnly &amp;&amp; bgColor.isVisible())
 928                     baseColor = baseColor.blend(bgColor);
<a name="7" id="anc7"></a><span class="line-modified"> 929                 context.fillRect(backgroundRectForPainting, baseColor, CompositeOperator::Copy);</span>
 930             } else if (!baseBgColorOnly &amp;&amp; bgColor.isVisible()) {
 931                 auto operation = context.compositeOperation();
 932                 if (shouldClearBackground) {
<a name="8" id="anc8"></a><span class="line-modified"> 933                     if (op == CompositeOperator::DestinationOut) // We&#39;re punching out the background.</span>
 934                         operation = op;
 935                     else
<a name="9" id="anc9"></a><span class="line-modified"> 936                         operation = CompositeOperator::Copy;</span>
 937                 }
 938                 context.fillRect(backgroundRectForPainting, bgColor, operation);
 939             } else if (shouldClearBackground)
 940                 context.clearRect(backgroundRectForPainting);
 941         }
 942     }
 943 
 944     // no progressive loading of the background image
 945     if (!baseBgColorOnly &amp;&amp; shouldPaintBackgroundImage) {
 946         auto geometry = calculateBackgroundImageGeometry(paintInfo.paintContainer, bgLayer, rect.location(), scrolledPaintRect, backgroundObject);
 947         geometry.clip(LayoutRect(pixelSnappedRect));
 948         RefPtr&lt;Image&gt; image;
 949         if (!geometry.destRect().isEmpty() &amp;&amp; (image = bgImage-&gt;image(backgroundObject ? backgroundObject : this, geometry.tileSize()))) {
<a name="10" id="anc10"></a>
 950             context.setDrawLuminanceMask(bgLayer.maskSourceType() == MaskSourceType::Luminance);
 951 
 952             if (is&lt;BitmapImage&gt;(image))
 953                 downcast&lt;BitmapImage&gt;(*image).updateFromSettings(settings());
 954 
<a name="11" id="anc11"></a><span class="line-modified"> 955             ImagePaintingOptions options = {</span>
<span class="line-modified"> 956                 op == CompositeOperator::SourceOver ? bgLayer.composite() : op,</span>
<span class="line-modified"> 957                 bgLayer.blendMode(),</span>
<span class="line-added"> 958                 decodingModeForImageDraw(*image, paintInfo),</span>
<span class="line-added"> 959                 ImageOrientation::FromImage,</span>
<span class="line-added"> 960                 chooseInterpolationQuality(context, *image, &amp;bgLayer, geometry.tileSize())</span>
<span class="line-added"> 961             };</span>
<span class="line-added"> 962 </span>
<span class="line-added"> 963             auto drawResult = context.drawTiledImage(*image, geometry.destRect(), toLayoutPoint(geometry.relativePhase()), geometry.tileSize(), geometry.spaceSize(), options);</span>
 964             if (drawResult == ImageDrawResult::DidRequestDecoding) {
<a name="12" id="anc12"></a><span class="line-modified"> 965                 ASSERT(bgImage-&gt;hasCachedImage());</span>
 966                 bgImage-&gt;cachedImage()-&gt;addClientWaitingForAsyncDecoding(*this);
 967             }
 968         }
 969     }
 970 
 971     if (maskImage &amp;&amp; bgLayer.clip() == FillBox::Text) {
<a name="13" id="anc13"></a><span class="line-modified"> 972         context.drawConsumingImageBuffer(WTFMove(maskImage), maskRect, CompositeOperator::DestinationIn);</span>
 973         context.endTransparencyLayer();
 974     }
 975 }
 976 
 977 static inline LayoutUnit resolveWidthForRatio(LayoutUnit height, const LayoutSize&amp; intrinsicRatio)
 978 {
 979     return height * intrinsicRatio.width() / intrinsicRatio.height();
 980 }
 981 
 982 static inline LayoutUnit resolveHeightForRatio(LayoutUnit width, const LayoutSize&amp; intrinsicRatio)
 983 {
 984     return width * intrinsicRatio.height() / intrinsicRatio.width();
 985 }
 986 
 987 static inline LayoutSize resolveAgainstIntrinsicWidthOrHeightAndRatio(const LayoutSize&amp; size, const LayoutSize&amp; intrinsicRatio, LayoutUnit useWidth, LayoutUnit useHeight)
 988 {
 989     if (intrinsicRatio.isEmpty()) {
 990         if (useWidth)
 991             return LayoutSize(useWidth, size.height());
 992         return LayoutSize(size.width(), useHeight);
 993     }
 994 
 995     if (useWidth)
 996         return LayoutSize(useWidth, resolveHeightForRatio(useWidth, intrinsicRatio));
 997     return LayoutSize(resolveWidthForRatio(useHeight, intrinsicRatio), useHeight);
 998 }
 999 
1000 static inline LayoutSize resolveAgainstIntrinsicRatio(const LayoutSize&amp; size, const LayoutSize&amp; intrinsicRatio)
1001 {
1002     // Two possible solutions: (size.width(), solutionHeight) or (solutionWidth, size.height())
1003     // &quot;... must be assumed to be the largest dimensions...&quot; = easiest answer: the rect with the largest surface area.
1004 
1005     LayoutUnit solutionWidth = resolveWidthForRatio(size.height(), intrinsicRatio);
1006     LayoutUnit solutionHeight = resolveHeightForRatio(size.width(), intrinsicRatio);
1007     if (solutionWidth &lt;= size.width()) {
1008         if (solutionHeight &lt;= size.height()) {
1009             // If both solutions fit, choose the one covering the larger area.
1010             LayoutUnit areaOne = solutionWidth * size.height();
1011             LayoutUnit areaTwo = size.width() * solutionHeight;
1012             if (areaOne &lt; areaTwo)
1013                 return LayoutSize(size.width(), solutionHeight);
1014             return LayoutSize(solutionWidth, size.height());
1015         }
1016 
1017         // Only the first solution fits.
1018         return LayoutSize(solutionWidth, size.height());
1019     }
1020 
1021     // Only the second solution fits, assert that.
1022     ASSERT(solutionHeight &lt;= size.height());
1023     return LayoutSize(size.width(), solutionHeight);
1024 }
1025 
1026 LayoutSize RenderBoxModelObject::calculateImageIntrinsicDimensions(StyleImage* image, const LayoutSize&amp; positioningAreaSize, ScaleByEffectiveZoomOrNot shouldScaleOrNot) const
1027 {
1028     // A generated image without a fixed size, will always return the container size as intrinsic size.
1029     if (image-&gt;isGeneratedImage() &amp;&amp; image-&gt;usesImageContainerSize())
1030         return LayoutSize(positioningAreaSize.width(), positioningAreaSize.height());
1031 
1032     Length intrinsicWidth;
1033     Length intrinsicHeight;
1034     FloatSize intrinsicRatio;
1035     image-&gt;computeIntrinsicDimensions(this, intrinsicWidth, intrinsicHeight, intrinsicRatio);
1036 
1037     ASSERT(!intrinsicWidth.isPercentOrCalculated());
1038     ASSERT(!intrinsicHeight.isPercentOrCalculated());
1039 
1040     LayoutSize resolvedSize(intrinsicWidth.value(), intrinsicHeight.value());
1041     LayoutSize minimumSize(resolvedSize.width() &gt; 0 ? 1 : 0, resolvedSize.height() &gt; 0 ? 1 : 0);
1042 
1043     if (shouldScaleOrNot == ScaleByEffectiveZoom)
1044         resolvedSize.scale(style().effectiveZoom());
1045     resolvedSize.clampToMinimumSize(minimumSize);
1046 
1047     if (!resolvedSize.isEmpty())
1048         return resolvedSize;
1049 
1050     // If the image has one of either an intrinsic width or an intrinsic height:
1051     // * and an intrinsic aspect ratio, then the missing dimension is calculated from the given dimension and the ratio.
1052     // * and no intrinsic aspect ratio, then the missing dimension is assumed to be the size of the rectangle that
1053     //   establishes the coordinate system for the &#39;background-position&#39; property.
1054     if (resolvedSize.width() &gt; 0 || resolvedSize.height() &gt; 0)
1055         return resolveAgainstIntrinsicWidthOrHeightAndRatio(positioningAreaSize, LayoutSize(intrinsicRatio), resolvedSize.width(), resolvedSize.height());
1056 
1057     // If the image has no intrinsic dimensions and has an intrinsic ratio the dimensions must be assumed to be the
1058     // largest dimensions at that ratio such that neither dimension exceeds the dimensions of the rectangle that
1059     // establishes the coordinate system for the &#39;background-position&#39; property.
1060     if (!intrinsicRatio.isEmpty())
1061         return resolveAgainstIntrinsicRatio(positioningAreaSize, LayoutSize(intrinsicRatio));
1062 
1063     // If the image has no intrinsic ratio either, then the dimensions must be assumed to be the rectangle that
1064     // establishes the coordinate system for the &#39;background-position&#39; property.
1065     return positioningAreaSize;
1066 }
1067 
1068 LayoutSize RenderBoxModelObject::calculateFillTileSize(const FillLayer&amp; fillLayer, const LayoutSize&amp; positioningAreaSize) const
1069 {
1070     StyleImage* image = fillLayer.image();
1071     FillSizeType type = fillLayer.size().type;
1072 
1073     LayoutSize imageIntrinsicSize;
1074     if (image) {
1075         imageIntrinsicSize = calculateImageIntrinsicDimensions(image, positioningAreaSize, ScaleByEffectiveZoom);
1076         imageIntrinsicSize.scale(1 / image-&gt;imageScaleFactor(), 1 / image-&gt;imageScaleFactor());
1077     } else
1078         imageIntrinsicSize = positioningAreaSize;
1079 
1080     switch (type) {
1081     case FillSizeType::Size: {
1082         LayoutSize tileSize = positioningAreaSize;
1083 
1084         Length layerWidth = fillLayer.size().size.width;
1085         Length layerHeight = fillLayer.size().size.height;
1086 
1087         if (layerWidth.isFixed())
1088             tileSize.setWidth(layerWidth.value());
1089         else if (layerWidth.isPercentOrCalculated())
1090             tileSize.setWidth(valueForLength(layerWidth, positioningAreaSize.width()));
1091 
1092         if (layerHeight.isFixed())
1093             tileSize.setHeight(layerHeight.value());
1094         else if (layerHeight.isPercentOrCalculated())
1095             tileSize.setHeight(valueForLength(layerHeight, positioningAreaSize.height()));
1096 
1097         // If one of the values is auto we have to use the appropriate
1098         // scale to maintain our aspect ratio.
1099         if (layerWidth.isAuto() &amp;&amp; !layerHeight.isAuto()) {
1100             if (imageIntrinsicSize.height())
1101                 tileSize.setWidth(imageIntrinsicSize.width() * tileSize.height() / imageIntrinsicSize.height());
1102         } else if (!layerWidth.isAuto() &amp;&amp; layerHeight.isAuto()) {
1103             if (imageIntrinsicSize.width())
1104                 tileSize.setHeight(imageIntrinsicSize.height() * tileSize.width() / imageIntrinsicSize.width());
1105         } else if (layerWidth.isAuto() &amp;&amp; layerHeight.isAuto()) {
1106             // If both width and height are auto, use the image&#39;s intrinsic size.
1107             tileSize = imageIntrinsicSize;
1108         }
1109 
1110         tileSize.clampNegativeToZero();
1111         return tileSize;
1112     }
1113     case FillSizeType::None: {
1114         // If both values are ‘auto’ then the intrinsic width and/or height of the image should be used, if any.
1115         if (!imageIntrinsicSize.isEmpty())
1116             return imageIntrinsicSize;
1117 
1118         // If the image has neither an intrinsic width nor an intrinsic height, its size is determined as for ‘contain’.
1119         type = FillSizeType::Contain;
1120     }
1121     FALLTHROUGH;
1122     case FillSizeType::Contain:
1123     case FillSizeType::Cover: {
1124         // Scale computation needs higher precision than what LayoutUnit can offer.
1125         FloatSize localImageIntrinsicSize = imageIntrinsicSize;
1126         FloatSize localPositioningAreaSize = positioningAreaSize;
1127 
1128         float horizontalScaleFactor = localImageIntrinsicSize.width() ? (localPositioningAreaSize.width() / localImageIntrinsicSize.width()) : 1;
1129         float verticalScaleFactor = localImageIntrinsicSize.height() ? (localPositioningAreaSize.height() / localImageIntrinsicSize.height()) : 1;
1130         float scaleFactor = type == FillSizeType::Contain ? std::min(horizontalScaleFactor, verticalScaleFactor) : std::max(horizontalScaleFactor, verticalScaleFactor);
1131         float singleScaledPixel = 1.0 / document().deviceScaleFactor();
1132 
1133         if (localImageIntrinsicSize.isEmpty())
1134             return { };
1135 
1136         return LayoutSize(localImageIntrinsicSize.scaled(scaleFactor).expandedTo({ singleScaledPixel, singleScaledPixel }));
1137     }
1138     }
1139 
1140     ASSERT_NOT_REACHED();
1141     return { };
1142 }
1143 
1144 static void pixelSnapBackgroundImageGeometryForPainting(LayoutRect&amp; destinationRect, LayoutSize&amp; tileSize, LayoutSize&amp; phase, LayoutSize&amp; space, float scaleFactor)
1145 {
1146     tileSize = LayoutSize(snapRectToDevicePixels(LayoutRect(destinationRect.location(), tileSize), scaleFactor).size());
1147     phase = LayoutSize(snapRectToDevicePixels(LayoutRect(destinationRect.location(), phase), scaleFactor).size());
1148     space = LayoutSize(snapRectToDevicePixels(LayoutRect(LayoutPoint(), space), scaleFactor).size());
1149     destinationRect = LayoutRect(snapRectToDevicePixels(destinationRect, scaleFactor));
1150 }
1151 
1152 bool RenderBoxModelObject::fixedBackgroundPaintsInLocalCoordinates() const
1153 {
1154     if (!isDocumentElementRenderer())
1155         return false;
1156 
1157     if (view().frameView().paintBehavior().contains(PaintBehavior::FlattenCompositingLayers))
1158         return false;
1159 
1160     RenderLayer* rootLayer = view().layer();
1161     if (!rootLayer || !rootLayer-&gt;isComposited())
1162         return false;
1163 
1164     return rootLayer-&gt;backing()-&gt;backgroundLayerPaintsFixedRootBackground();
1165 }
1166 
1167 static inline LayoutUnit getSpace(LayoutUnit areaSize, LayoutUnit tileSize)
1168 {
1169     int numberOfTiles = areaSize / tileSize;
1170     LayoutUnit space = -1;
1171 
1172     if (numberOfTiles &gt; 1)
1173         space = (areaSize - numberOfTiles * tileSize) / (numberOfTiles - 1);
1174 
1175     return space;
1176 }
1177 
1178 static LayoutUnit resolveEdgeRelativeLength(const Length&amp; length, Edge edge, LayoutUnit availableSpace, const LayoutSize&amp; areaSize, const LayoutSize&amp; tileSize)
1179 {
1180     LayoutUnit result = minimumValueForLength(length, availableSpace);
1181 
1182     if (edge == Edge::Right)
1183         return areaSize.width() - tileSize.width() - result;
1184 
1185     if (edge == Edge::Bottom)
1186         return areaSize.height() - tileSize.height() - result;
1187 
1188     return result;
1189 }
1190 
1191 BackgroundImageGeometry RenderBoxModelObject::calculateBackgroundImageGeometry(const RenderLayerModelObject* paintContainer, const FillLayer&amp; fillLayer, const LayoutPoint&amp; paintOffset,
1192     const LayoutRect&amp; borderBoxRect, RenderElement* backgroundObject) const
1193 {
1194     LayoutUnit left;
1195     LayoutUnit top;
1196     LayoutSize positioningAreaSize;
1197     // Determine the background positioning area and set destination rect to the background painting area.
1198     // Destination rect will be adjusted later if the background is non-repeating.
1199     // FIXME: transforms spec says that fixed backgrounds behave like scroll inside transforms. https://bugs.webkit.org/show_bug.cgi?id=15679
1200     LayoutRect destinationRect(borderBoxRect);
1201     bool fixedAttachment = fillLayer.attachment() == FillAttachment::FixedBackground;
1202     float deviceScaleFactor = document().deviceScaleFactor();
1203     if (!fixedAttachment) {
1204         LayoutUnit right;
1205         LayoutUnit bottom;
1206         // Scroll and Local.
1207         if (fillLayer.origin() != FillBox::Border) {
1208             left = borderLeft();
1209             right = borderRight();
1210             top = borderTop();
1211             bottom = borderBottom();
1212             if (fillLayer.origin() == FillBox::Content) {
1213                 left += paddingLeft();
1214                 right += paddingRight();
1215                 top += paddingTop();
1216                 bottom += paddingBottom();
1217             }
1218         }
1219 
1220         // The background of the box generated by the root element covers the entire canvas including
1221         // its margins. Since those were added in already, we have to factor them out when computing
1222         // the background positioning area.
1223         if (isDocumentElementRenderer()) {
1224             positioningAreaSize = downcast&lt;RenderBox&gt;(*this).size() - LayoutSize(left + right, top + bottom);
1225             positioningAreaSize = LayoutSize(snapSizeToDevicePixel(positioningAreaSize, LayoutPoint(), deviceScaleFactor));
1226             if (view().frameView().hasExtendedBackgroundRectForPainting()) {
1227                 LayoutRect extendedBackgroundRect = view().frameView().extendedBackgroundRectForPainting();
1228                 left += (marginLeft() - extendedBackgroundRect.x());
1229                 top += (marginTop() - extendedBackgroundRect.y());
1230             }
1231         } else {
1232             positioningAreaSize = borderBoxRect.size() - LayoutSize(left + right, top + bottom);
1233             positioningAreaSize = LayoutSize(snapRectToDevicePixels(LayoutRect(paintOffset, positioningAreaSize), deviceScaleFactor).size());
1234         }
1235     } else {
1236         LayoutRect viewportRect;
1237         float topContentInset = 0;
1238         if (settings().fixedBackgroundsPaintRelativeToDocument())
1239             viewportRect = view().unscaledDocumentRect();
1240         else {
1241             FrameView&amp; frameView = view().frameView();
1242             bool useFixedLayout = frameView.useFixedLayout() &amp;&amp; !frameView.fixedLayoutSize().isEmpty();
1243 
1244             if (useFixedLayout) {
1245                 // Use the fixedLayoutSize() when useFixedLayout() because the rendering will scale
1246                 // down the frameView to to fit in the current viewport.
1247                 viewportRect.setSize(frameView.fixedLayoutSize());
1248             } else
1249                 viewportRect.setSize(frameView.sizeForVisibleContent());
1250 
1251             if (fixedBackgroundPaintsInLocalCoordinates()) {
1252                 if (!useFixedLayout) {
1253                     // Shifting location up by topContentInset is needed for layout tests which expect
1254                     // layout to be shifted down when calling window.internals.setTopContentInset().
1255                     topContentInset = frameView.topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset);
1256                     viewportRect.setLocation(LayoutPoint(0, -topContentInset));
1257                 }
1258             } else if (useFixedLayout || frameView.frameScaleFactor() != 1) {
1259                 // scrollPositionForFixedPosition() is adjusted for page scale and it does not include
1260                 // topContentInset so do not add it to the calculation below.
1261                 viewportRect.setLocation(frameView.scrollPositionForFixedPosition());
1262             } else {
1263                 // documentScrollPositionRelativeToViewOrigin() includes -topContentInset in its height
1264                 // so we need to account for that in calculating the phase size
1265                 topContentInset = frameView.topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset);
1266                 viewportRect.setLocation(frameView.documentScrollPositionRelativeToViewOrigin());
1267             }
1268 
1269             top += topContentInset;
1270         }
1271 
1272         if (paintContainer)
1273             viewportRect.moveBy(LayoutPoint(-paintContainer-&gt;localToAbsolute(FloatPoint())));
1274 
1275         destinationRect = viewportRect;
1276         positioningAreaSize = destinationRect.size();
1277         positioningAreaSize.setHeight(positioningAreaSize.height() - topContentInset);
1278         positioningAreaSize = LayoutSize(snapRectToDevicePixels(LayoutRect(destinationRect.location(), positioningAreaSize), deviceScaleFactor).size());
1279     }
1280 
1281     auto clientForBackgroundImage = backgroundObject ? backgroundObject : this;
1282     LayoutSize tileSize = calculateFillTileSize(fillLayer, positioningAreaSize);
1283     if (StyleImage* layerImage = fillLayer.image())
1284         layerImage-&gt;setContainerContextForRenderer(*clientForBackgroundImage, tileSize, style().effectiveZoom());
1285 
1286     FillRepeat backgroundRepeatX = fillLayer.repeatX();
1287     FillRepeat backgroundRepeatY = fillLayer.repeatY();
1288     LayoutUnit availableWidth = positioningAreaSize.width() - tileSize.width();
1289     LayoutUnit availableHeight = positioningAreaSize.height() - tileSize.height();
1290 
1291     LayoutSize spaceSize;
1292     LayoutSize phase;
1293     LayoutSize noRepeat;
1294     LayoutUnit computedXPosition = resolveEdgeRelativeLength(fillLayer.xPosition(), fillLayer.backgroundXOrigin(), availableWidth, positioningAreaSize, tileSize);
1295     if (backgroundRepeatX == FillRepeat::Round &amp;&amp; positioningAreaSize.width() &gt; 0 &amp;&amp; tileSize.width() &gt; 0) {
1296         int numTiles = std::max(1, roundToInt(positioningAreaSize.width() / tileSize.width()));
1297         if (fillLayer.size().size.height.isAuto() &amp;&amp; backgroundRepeatY != FillRepeat::Round)
1298             tileSize.setHeight(tileSize.height() * positioningAreaSize.width() / (numTiles * tileSize.width()));
1299 
1300         tileSize.setWidth(positioningAreaSize.width() / numTiles);
1301         phase.setWidth(tileSize.width() ? tileSize.width() - fmodf((computedXPosition + left), tileSize.width()) : 0);
1302     }
1303 
1304     LayoutUnit computedYPosition = resolveEdgeRelativeLength(fillLayer.yPosition(), fillLayer.backgroundYOrigin(), availableHeight, positioningAreaSize, tileSize);
1305     if (backgroundRepeatY == FillRepeat::Round &amp;&amp; positioningAreaSize.height() &gt; 0 &amp;&amp; tileSize.height() &gt; 0) {
1306         int numTiles = std::max(1, roundToInt(positioningAreaSize.height() / tileSize.height()));
1307         if (fillLayer.size().size.width.isAuto() &amp;&amp; backgroundRepeatX != FillRepeat::Round)
1308             tileSize.setWidth(tileSize.width() * positioningAreaSize.height() / (numTiles * tileSize.height()));
1309 
1310         tileSize.setHeight(positioningAreaSize.height() / numTiles);
1311         phase.setHeight(tileSize.height() ? tileSize.height() - fmodf((computedYPosition + top), tileSize.height()) : 0);
1312     }
1313 
1314     if (backgroundRepeatX == FillRepeat::Repeat) {
1315         phase.setWidth(tileSize.width() ? tileSize.width() - fmodf(computedXPosition + left, tileSize.width()) : 0);
1316         spaceSize.setWidth(0);
1317     } else if (backgroundRepeatX == FillRepeat::Space &amp;&amp; tileSize.width() &gt; 0) {
1318         LayoutUnit space = getSpace(positioningAreaSize.width(), tileSize.width());
1319         if (space &gt;= 0) {
1320             LayoutUnit actualWidth = tileSize.width() + space;
1321             computedXPosition = minimumValueForLength(Length(), availableWidth);
1322             spaceSize.setWidth(space);
1323             spaceSize.setHeight(0);
1324             phase.setWidth(actualWidth ? actualWidth - fmodf((computedXPosition + left), actualWidth) : 0);
1325         } else
1326             backgroundRepeatX = FillRepeat::NoRepeat;
1327     }
1328 
1329     if (backgroundRepeatX == FillRepeat::NoRepeat) {
1330         LayoutUnit xOffset = left + computedXPosition;
1331         if (xOffset &gt; 0)
1332             destinationRect.move(xOffset, 0_lu);
1333         xOffset = std::min&lt;LayoutUnit&gt;(xOffset, 0);
1334         phase.setWidth(-xOffset);
1335         destinationRect.setWidth(tileSize.width() + xOffset);
1336         spaceSize.setWidth(0);
1337     }
1338 
1339     if (backgroundRepeatY == FillRepeat::Repeat) {
1340         phase.setHeight(tileSize.height() ? tileSize.height() - fmodf(computedYPosition + top, tileSize.height()) : 0);
1341         spaceSize.setHeight(0);
1342     } else if (backgroundRepeatY == FillRepeat::Space &amp;&amp; tileSize.height() &gt; 0) {
1343         LayoutUnit space = getSpace(positioningAreaSize.height(), tileSize.height());
1344 
1345         if (space &gt;= 0) {
1346             LayoutUnit actualHeight = tileSize.height() + space;
1347             computedYPosition = minimumValueForLength(Length(), availableHeight);
1348             spaceSize.setHeight(space);
1349             phase.setHeight(actualHeight ? actualHeight - fmodf((computedYPosition + top), actualHeight) : 0);
1350         } else
1351             backgroundRepeatY = FillRepeat::NoRepeat;
1352     }
1353     if (backgroundRepeatY == FillRepeat::NoRepeat) {
1354         LayoutUnit yOffset = top + computedYPosition;
1355         if (yOffset &gt; 0)
1356             destinationRect.move(0_lu, yOffset);
1357         yOffset = std::min&lt;LayoutUnit&gt;(yOffset, 0);
1358         phase.setHeight(-yOffset);
1359         destinationRect.setHeight(tileSize.height() + yOffset);
1360         spaceSize.setHeight(0);
1361     }
1362 
1363     if (fixedAttachment) {
1364         LayoutPoint attachmentPoint = borderBoxRect.location();
1365         phase.expand(std::max&lt;LayoutUnit&gt;(attachmentPoint.x() - destinationRect.x(), 0), std::max&lt;LayoutUnit&gt;(attachmentPoint.y() - destinationRect.y(), 0));
1366     }
1367 
1368     destinationRect.intersect(borderBoxRect);
1369     pixelSnapBackgroundImageGeometryForPainting(destinationRect, tileSize, phase, spaceSize, deviceScaleFactor);
1370     return BackgroundImageGeometry(destinationRect, tileSize, phase, spaceSize, fixedAttachment);
1371 }
1372 
1373 void RenderBoxModelObject::getGeometryForBackgroundImage(const RenderLayerModelObject* paintContainer, const LayoutPoint&amp; paintOffset, FloatRect&amp; destRect, FloatSize&amp; phase, FloatSize&amp; tileSize) const
1374 {
1375     LayoutRect paintRect(destRect);
1376     auto geometry = calculateBackgroundImageGeometry(paintContainer, style().backgroundLayers(), paintOffset, paintRect);
1377     phase = geometry.phase();
1378     tileSize = geometry.tileSize();
1379     destRect = geometry.destRect();
1380 }
1381 
1382 bool RenderBoxModelObject::paintNinePieceImage(GraphicsContext&amp; graphicsContext, const LayoutRect&amp; rect, const RenderStyle&amp; style,
1383                                                const NinePieceImage&amp; ninePieceImage, CompositeOperator op)
1384 {
1385     StyleImage* styleImage = ninePieceImage.image();
1386     if (!styleImage)
1387         return false;
1388 
1389     if (!styleImage-&gt;isLoaded())
1390         return true; // Never paint a nine-piece image incrementally, but don&#39;t paint the fallback borders either.
1391 
1392     if (!styleImage-&gt;canRender(this, style.effectiveZoom()))
1393         return false;
1394 
1395     // FIXME: border-image is broken with full page zooming when tiling has to happen, since the tiling function
1396     // doesn&#39;t have any understanding of the zoom that is in effect on the tile.
1397     float deviceScaleFactor = document().deviceScaleFactor();
1398 
1399     LayoutRect rectWithOutsets = rect;
1400     rectWithOutsets.expand(style.imageOutsets(ninePieceImage));
1401     LayoutRect destination = LayoutRect(snapRectToDevicePixels(rectWithOutsets, deviceScaleFactor));
1402 
1403     LayoutSize source = calculateImageIntrinsicDimensions(styleImage, destination.size(), DoNotScaleByEffectiveZoom);
1404 
1405     // If both values are ‘auto’ then the intrinsic width and/or height of the image should be used, if any.
1406     styleImage-&gt;setContainerContextForRenderer(*this, source, style.effectiveZoom());
1407 
1408     ninePieceImage.paint(graphicsContext, this, style, destination, source, deviceScaleFactor, op);
1409     return true;
1410 }
1411 
1412 static bool allCornersClippedOut(const RoundedRect&amp; border, const LayoutRect&amp; clipRect)
1413 {
1414     LayoutRect boundingRect = border.rect();
1415     if (clipRect.contains(boundingRect))
1416         return false;
1417 
1418     RoundedRect::Radii radii = border.radii();
1419 
1420     LayoutRect topLeftRect(boundingRect.location(), radii.topLeft());
1421     if (clipRect.intersects(topLeftRect))
1422         return false;
1423 
1424     LayoutRect topRightRect(boundingRect.location(), radii.topRight());
1425     topRightRect.setX(boundingRect.maxX() - topRightRect.width());
1426     if (clipRect.intersects(topRightRect))
1427         return false;
1428 
1429     LayoutRect bottomLeftRect(boundingRect.location(), radii.bottomLeft());
1430     bottomLeftRect.setY(boundingRect.maxY() - bottomLeftRect.height());
1431     if (clipRect.intersects(bottomLeftRect))
1432         return false;
1433 
1434     LayoutRect bottomRightRect(boundingRect.location(), radii.bottomRight());
1435     bottomRightRect.setX(boundingRect.maxX() - bottomRightRect.width());
1436     bottomRightRect.setY(boundingRect.maxY() - bottomRightRect.height());
1437     if (clipRect.intersects(bottomRightRect))
1438         return false;
1439 
1440     return true;
1441 }
1442 
1443 static bool borderWillArcInnerEdge(const LayoutSize&amp; firstRadius, const FloatSize&amp; secondRadius)
1444 {
1445     return !firstRadius.isZero() || !secondRadius.isZero();
1446 }
1447 
1448 inline bool styleRequiresClipPolygon(BorderStyle style)
1449 {
1450     return style == BorderStyle::Dotted || style == BorderStyle::Dashed; // These are drawn with a stroke, so we have to clip to get corner miters.
1451 }
1452 
1453 static bool borderStyleFillsBorderArea(BorderStyle style)
1454 {
1455     return !(style == BorderStyle::Dotted || style == BorderStyle::Dashed || style == BorderStyle::Double);
1456 }
1457 
1458 static bool borderStyleHasInnerDetail(BorderStyle style)
1459 {
1460     return style == BorderStyle::Groove || style == BorderStyle::Ridge || style == BorderStyle::Double;
1461 }
1462 
1463 static bool borderStyleIsDottedOrDashed(BorderStyle style)
1464 {
1465     return style == BorderStyle::Dotted || style == BorderStyle::Dashed;
1466 }
1467 
1468 // BorderStyle::Outset darkens the bottom and right (and maybe lightens the top and left)
1469 // BorderStyle::Inset darkens the top and left (and maybe lightens the bottom and right)
1470 static inline bool borderStyleHasUnmatchedColorsAtCorner(BorderStyle style, BoxSide side, BoxSide adjacentSide)
1471 {
1472     // These styles match at the top/left and bottom/right.
1473     if (style == BorderStyle::Inset || style == BorderStyle::Groove || style == BorderStyle::Ridge || style == BorderStyle::Outset) {
1474         const BorderEdgeFlags topRightFlags = edgeFlagForSide(BSTop) | edgeFlagForSide(BSRight);
1475         const BorderEdgeFlags bottomLeftFlags = edgeFlagForSide(BSBottom) | edgeFlagForSide(BSLeft);
1476 
1477         BorderEdgeFlags flags = edgeFlagForSide(side) | edgeFlagForSide(adjacentSide);
1478         return flags == topRightFlags || flags == bottomLeftFlags;
1479     }
1480     return false;
1481 }
1482 
1483 static inline bool colorsMatchAtCorner(BoxSide side, BoxSide adjacentSide, const BorderEdge edges[])
1484 {
1485     if (edges[side].shouldRender() != edges[adjacentSide].shouldRender())
1486         return false;
1487 
1488     if (!edgesShareColor(edges[side], edges[adjacentSide]))
1489         return false;
1490 
1491     return !borderStyleHasUnmatchedColorsAtCorner(edges[side].style(), side, adjacentSide);
1492 }
1493 
1494 
1495 static inline bool colorNeedsAntiAliasAtCorner(BoxSide side, BoxSide adjacentSide, const BorderEdge edges[])
1496 {
1497     if (edges[side].color().isOpaque())
1498         return false;
1499 
1500     if (edges[side].shouldRender() != edges[adjacentSide].shouldRender())
1501         return false;
1502 
1503     if (!edgesShareColor(edges[side], edges[adjacentSide]))
1504         return true;
1505 
1506     return borderStyleHasUnmatchedColorsAtCorner(edges[side].style(), side, adjacentSide);
1507 }
1508 
1509 // This assumes that we draw in order: top, bottom, left, right.
1510 static inline bool willBeOverdrawn(BoxSide side, BoxSide adjacentSide, const BorderEdge edges[])
1511 {
1512     switch (side) {
1513     case BSTop:
1514     case BSBottom:
1515         if (edges[adjacentSide].presentButInvisible())
1516             return false;
1517 
1518         if (!edgesShareColor(edges[side], edges[adjacentSide]) &amp;&amp; !edges[adjacentSide].color().isOpaque())
1519             return false;
1520 
1521         if (!borderStyleFillsBorderArea(edges[adjacentSide].style()))
1522             return false;
1523 
1524         return true;
1525 
1526     case BSLeft:
1527     case BSRight:
1528         // These draw last, so are never overdrawn.
1529         return false;
1530     }
1531     return false;
1532 }
1533 
1534 static inline bool borderStylesRequireMitre(BoxSide side, BoxSide adjacentSide, BorderStyle style, BorderStyle adjacentStyle)
1535 {
1536     if (style == BorderStyle::Double || adjacentStyle == BorderStyle::Double || adjacentStyle == BorderStyle::Groove || adjacentStyle == BorderStyle::Ridge)
1537         return true;
1538 
1539     if (borderStyleIsDottedOrDashed(style) != borderStyleIsDottedOrDashed(adjacentStyle))
1540         return true;
1541 
1542     if (style != adjacentStyle)
1543         return true;
1544 
1545     return borderStyleHasUnmatchedColorsAtCorner(style, side, adjacentSide);
1546 }
1547 
1548 static bool joinRequiresMitre(BoxSide side, BoxSide adjacentSide, const BorderEdge edges[], bool allowOverdraw)
1549 {
1550     if ((edges[side].isTransparent() &amp;&amp; edges[adjacentSide].isTransparent()) || !edges[adjacentSide].isPresent())
1551         return false;
1552 
1553     if (allowOverdraw &amp;&amp; willBeOverdrawn(side, adjacentSide, edges))
1554         return false;
1555 
1556     if (!edgesShareColor(edges[side], edges[adjacentSide]))
1557         return true;
1558 
1559     if (borderStylesRequireMitre(side, adjacentSide, edges[side].style(), edges[adjacentSide].style()))
1560         return true;
1561 
1562     return false;
1563 }
1564 
1565 static RoundedRect calculateAdjustedInnerBorder(const RoundedRect&amp;innerBorder, BoxSide side)
1566 {
1567     // Expand the inner border as necessary to make it a rounded rect (i.e. radii contained within each edge).
1568     // This function relies on the fact we only get radii not contained within each edge if one of the radii
1569     // for an edge is zero, so we can shift the arc towards the zero radius corner.
1570     RoundedRect::Radii newRadii = innerBorder.radii();
1571     LayoutRect newRect = innerBorder.rect();
1572 
1573     float overshoot;
1574     float maxRadii;
1575 
1576     switch (side) {
1577     case BSTop:
1578         overshoot = newRadii.topLeft().width() + newRadii.topRight().width() - newRect.width();
1579         if (overshoot &gt; 0) {
1580             ASSERT(!(newRadii.topLeft().width() &amp;&amp; newRadii.topRight().width()));
1581             newRect.setWidth(newRect.width() + overshoot);
1582             if (!newRadii.topLeft().width())
1583                 newRect.move(-overshoot, 0);
1584         }
1585         newRadii.setBottomLeft(IntSize(0, 0));
1586         newRadii.setBottomRight(IntSize(0, 0));
1587         maxRadii = std::max(newRadii.topLeft().height(), newRadii.topRight().height());
1588         if (maxRadii &gt; newRect.height())
1589             newRect.setHeight(maxRadii);
1590         break;
1591 
1592     case BSBottom:
1593         overshoot = newRadii.bottomLeft().width() + newRadii.bottomRight().width() - newRect.width();
1594         if (overshoot &gt; 0) {
1595             ASSERT(!(newRadii.bottomLeft().width() &amp;&amp; newRadii.bottomRight().width()));
1596             newRect.setWidth(newRect.width() + overshoot);
1597             if (!newRadii.bottomLeft().width())
1598                 newRect.move(-overshoot, 0);
1599         }
1600         newRadii.setTopLeft(IntSize(0, 0));
1601         newRadii.setTopRight(IntSize(0, 0));
1602         maxRadii = std::max(newRadii.bottomLeft().height(), newRadii.bottomRight().height());
1603         if (maxRadii &gt; newRect.height()) {
1604             newRect.move(0, newRect.height() - maxRadii);
1605             newRect.setHeight(maxRadii);
1606         }
1607         break;
1608 
1609     case BSLeft:
1610         overshoot = newRadii.topLeft().height() + newRadii.bottomLeft().height() - newRect.height();
1611         if (overshoot &gt; 0) {
1612             ASSERT(!(newRadii.topLeft().height() &amp;&amp; newRadii.bottomLeft().height()));
1613             newRect.setHeight(newRect.height() + overshoot);
1614             if (!newRadii.topLeft().height())
1615                 newRect.move(0, -overshoot);
1616         }
1617         newRadii.setTopRight(IntSize(0, 0));
1618         newRadii.setBottomRight(IntSize(0, 0));
1619         maxRadii = std::max(newRadii.topLeft().width(), newRadii.bottomLeft().width());
1620         if (maxRadii &gt; newRect.width())
1621             newRect.setWidth(maxRadii);
1622         break;
1623 
1624     case BSRight:
1625         overshoot = newRadii.topRight().height() + newRadii.bottomRight().height() - newRect.height();
1626         if (overshoot &gt; 0) {
1627             ASSERT(!(newRadii.topRight().height() &amp;&amp; newRadii.bottomRight().height()));
1628             newRect.setHeight(newRect.height() + overshoot);
1629             if (!newRadii.topRight().height())
1630                 newRect.move(0, -overshoot);
1631         }
1632         newRadii.setTopLeft(IntSize(0, 0));
1633         newRadii.setBottomLeft(IntSize(0, 0));
1634         maxRadii = std::max(newRadii.topRight().width(), newRadii.bottomRight().width());
1635         if (maxRadii &gt; newRect.width()) {
1636             newRect.move(newRect.width() - maxRadii, 0);
1637             newRect.setWidth(maxRadii);
1638         }
1639         break;
1640     }
1641 
1642     return RoundedRect(newRect, newRadii);
1643 }
1644 
1645 void RenderBoxModelObject::paintOneBorderSide(GraphicsContext&amp; graphicsContext, const RenderStyle&amp; style, const RoundedRect&amp; outerBorder, const RoundedRect&amp; innerBorder,
1646     const LayoutRect&amp; sideRect, BoxSide side, BoxSide adjacentSide1, BoxSide adjacentSide2, const BorderEdge edges[], const Path* path,
1647     BackgroundBleedAvoidance bleedAvoidance, bool includeLogicalLeftEdge, bool includeLogicalRightEdge, bool antialias, const Color* overrideColor)
1648 {
1649     const BorderEdge&amp; edgeToRender = edges[side];
1650     ASSERT(edgeToRender.widthForPainting());
1651     const BorderEdge&amp; adjacentEdge1 = edges[adjacentSide1];
1652     const BorderEdge&amp; adjacentEdge2 = edges[adjacentSide2];
1653 
1654     bool mitreAdjacentSide1 = joinRequiresMitre(side, adjacentSide1, edges, !antialias);
1655     bool mitreAdjacentSide2 = joinRequiresMitre(side, adjacentSide2, edges, !antialias);
1656 
1657     bool adjacentSide1StylesMatch = colorsMatchAtCorner(side, adjacentSide1, edges);
1658     bool adjacentSide2StylesMatch = colorsMatchAtCorner(side, adjacentSide2, edges);
1659 
1660     const Color&amp; colorToPaint = overrideColor ? *overrideColor : edgeToRender.color();
1661 
1662     if (path) {
1663         GraphicsContextStateSaver stateSaver(graphicsContext);
1664 
1665         clipBorderSidePolygon(graphicsContext, outerBorder, innerBorder, side, adjacentSide1StylesMatch, adjacentSide2StylesMatch);
1666 
1667         if (!innerBorder.isRenderable())
1668             graphicsContext.clipOutRoundedRect(FloatRoundedRect(calculateAdjustedInnerBorder(innerBorder, side)));
1669 
1670         float thickness = std::max(std::max(edgeToRender.widthForPainting(), adjacentEdge1.widthForPainting()), adjacentEdge2.widthForPainting());
1671         drawBoxSideFromPath(graphicsContext, outerBorder.rect(), *path, edges, edgeToRender.widthForPainting(), thickness, side, style,
1672             colorToPaint, edgeToRender.style(), bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge);
1673     } else {
1674         bool clipForStyle = styleRequiresClipPolygon(edgeToRender.style()) &amp;&amp; (mitreAdjacentSide1 || mitreAdjacentSide2);
1675         bool clipAdjacentSide1 = colorNeedsAntiAliasAtCorner(side, adjacentSide1, edges) &amp;&amp; mitreAdjacentSide1;
1676         bool clipAdjacentSide2 = colorNeedsAntiAliasAtCorner(side, adjacentSide2, edges) &amp;&amp; mitreAdjacentSide2;
1677         bool shouldClip = clipForStyle || clipAdjacentSide1 || clipAdjacentSide2;
1678 
1679         GraphicsContextStateSaver clipStateSaver(graphicsContext, shouldClip);
1680         if (shouldClip) {
1681             bool aliasAdjacentSide1 = clipAdjacentSide1 || (clipForStyle &amp;&amp; mitreAdjacentSide1);
1682             bool aliasAdjacentSide2 = clipAdjacentSide2 || (clipForStyle &amp;&amp; mitreAdjacentSide2);
1683             clipBorderSidePolygon(graphicsContext, outerBorder, innerBorder, side, !aliasAdjacentSide1, !aliasAdjacentSide2);
1684             // Since we clipped, no need to draw with a mitre.
1685             mitreAdjacentSide1 = false;
1686             mitreAdjacentSide2 = false;
1687         }
1688         drawLineForBoxSide(graphicsContext, sideRect, side, colorToPaint, edgeToRender.style(), mitreAdjacentSide1 ? adjacentEdge1.widthForPainting() : 0, mitreAdjacentSide2 ? adjacentEdge2.widthForPainting() : 0, antialias);
1689     }
1690 }
1691 
1692 static LayoutRect calculateSideRect(const RoundedRect&amp; outerBorder, const BorderEdge edges[], int side)
1693 {
1694     LayoutRect sideRect = outerBorder.rect();
1695     float width = edges[side].widthForPainting();
1696 
1697     if (side == BSTop)
1698         sideRect.setHeight(width);
1699     else if (side == BSBottom)
1700         sideRect.shiftYEdgeTo(sideRect.maxY() - width);
1701     else if (side == BSLeft)
1702         sideRect.setWidth(width);
1703     else
1704         sideRect.shiftXEdgeTo(sideRect.maxX() - width);
1705 
1706     return sideRect;
1707 }
1708 
1709 void RenderBoxModelObject::paintBorderSides(GraphicsContext&amp; graphicsContext, const RenderStyle&amp; style, const RoundedRect&amp; outerBorder, const RoundedRect&amp; innerBorder,
1710     const IntPoint&amp; innerBorderAdjustment, const BorderEdge edges[], BorderEdgeFlags edgeSet, BackgroundBleedAvoidance bleedAvoidance,
1711     bool includeLogicalLeftEdge, bool includeLogicalRightEdge, bool antialias, const Color* overrideColor)
1712 {
1713     bool renderRadii = outerBorder.isRounded();
1714 
1715     Path roundedPath;
1716     if (renderRadii)
1717         roundedPath.addRoundedRect(outerBorder);
1718 
1719     // The inner border adjustment for bleed avoidance mode BackgroundBleedBackgroundOverBorder
1720     // is only applied to sideRect, which is okay since BackgroundBleedBackgroundOverBorder
1721     // is only to be used for solid borders and the shape of the border painted by drawBoxSideFromPath
1722     // only depends on sideRect when painting solid borders.
1723 
1724     if (edges[BSTop].shouldRender() &amp;&amp; includesEdge(edgeSet, BSTop)) {
1725         LayoutRect sideRect = outerBorder.rect();
1726         sideRect.setHeight(edges[BSTop].widthForPainting() + innerBorderAdjustment.y());
1727 
1728         bool usePath = renderRadii &amp;&amp; (borderStyleHasInnerDetail(edges[BSTop].style()) || borderWillArcInnerEdge(innerBorder.radii().topLeft(), innerBorder.radii().topRight()));
1729         paintOneBorderSide(graphicsContext, style, outerBorder, innerBorder, sideRect, BSTop, BSLeft, BSRight, edges, usePath ? &amp;roundedPath : nullptr, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias, overrideColor);
1730     }
1731 
1732     if (edges[BSBottom].shouldRender() &amp;&amp; includesEdge(edgeSet, BSBottom)) {
1733         LayoutRect sideRect = outerBorder.rect();
1734         sideRect.shiftYEdgeTo(sideRect.maxY() - edges[BSBottom].widthForPainting() - innerBorderAdjustment.y());
1735 
1736         bool usePath = renderRadii &amp;&amp; (borderStyleHasInnerDetail(edges[BSBottom].style()) || borderWillArcInnerEdge(innerBorder.radii().bottomLeft(), innerBorder.radii().bottomRight()));
1737         paintOneBorderSide(graphicsContext, style, outerBorder, innerBorder, sideRect, BSBottom, BSLeft, BSRight, edges, usePath ? &amp;roundedPath : nullptr, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias, overrideColor);
1738     }
1739 
1740     if (edges[BSLeft].shouldRender() &amp;&amp; includesEdge(edgeSet, BSLeft)) {
1741         LayoutRect sideRect = outerBorder.rect();
1742         sideRect.setWidth(edges[BSLeft].widthForPainting() + innerBorderAdjustment.x());
1743 
1744         bool usePath = renderRadii &amp;&amp; (borderStyleHasInnerDetail(edges[BSLeft].style()) || borderWillArcInnerEdge(innerBorder.radii().bottomLeft(), innerBorder.radii().topLeft()));
1745         paintOneBorderSide(graphicsContext, style, outerBorder, innerBorder, sideRect, BSLeft, BSTop, BSBottom, edges, usePath ? &amp;roundedPath : nullptr, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias, overrideColor);
1746     }
1747 
1748     if (edges[BSRight].shouldRender() &amp;&amp; includesEdge(edgeSet, BSRight)) {
1749         LayoutRect sideRect = outerBorder.rect();
1750         sideRect.shiftXEdgeTo(sideRect.maxX() - edges[BSRight].widthForPainting() - innerBorderAdjustment.x());
1751 
1752         bool usePath = renderRadii &amp;&amp; (borderStyleHasInnerDetail(edges[BSRight].style()) || borderWillArcInnerEdge(innerBorder.radii().bottomRight(), innerBorder.radii().topRight()));
1753         paintOneBorderSide(graphicsContext, style, outerBorder, innerBorder, sideRect, BSRight, BSTop, BSBottom, edges, usePath ? &amp;roundedPath : nullptr, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias, overrideColor);
1754     }
1755 }
1756 
1757 void RenderBoxModelObject::paintTranslucentBorderSides(GraphicsContext&amp; graphicsContext, const RenderStyle&amp; style, const RoundedRect&amp; outerBorder, const RoundedRect&amp; innerBorder, const IntPoint&amp; innerBorderAdjustment,
1758     const BorderEdge edges[], BorderEdgeFlags edgesToDraw, BackgroundBleedAvoidance bleedAvoidance, bool includeLogicalLeftEdge, bool includeLogicalRightEdge, bool antialias)
1759 {
1760     // willBeOverdrawn assumes that we draw in order: top, bottom, left, right.
1761     // This is different from BoxSide enum order.
1762     static const BoxSide paintOrder[] = { BSTop, BSBottom, BSLeft, BSRight };
1763 
1764     while (edgesToDraw) {
1765         // Find undrawn edges sharing a color.
1766         Color commonColor;
1767 
1768         BorderEdgeFlags commonColorEdgeSet = 0;
1769         for (size_t i = 0; i &lt; sizeof(paintOrder) / sizeof(paintOrder[0]); ++i) {
1770             BoxSide currSide = paintOrder[i];
1771             if (!includesEdge(edgesToDraw, currSide))
1772                 continue;
1773 
1774             bool includeEdge;
1775             if (!commonColorEdgeSet) {
1776                 commonColor = edges[currSide].color();
1777                 includeEdge = true;
1778             } else
1779                 includeEdge = edges[currSide].color() == commonColor;
1780 
1781             if (includeEdge)
1782                 commonColorEdgeSet |= edgeFlagForSide(currSide);
1783         }
1784 
1785         bool useTransparencyLayer = includesAdjacentEdges(commonColorEdgeSet) &amp;&amp; !commonColor.isOpaque();
1786         if (useTransparencyLayer) {
1787             graphicsContext.beginTransparencyLayer(commonColor.alphaAsFloat());
1788             commonColor = commonColor.opaqueColor();
1789         }
1790 
1791         paintBorderSides(graphicsContext, style, outerBorder, innerBorder, innerBorderAdjustment, edges, commonColorEdgeSet, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias, &amp;commonColor);
1792 
1793         if (useTransparencyLayer)
1794             graphicsContext.endTransparencyLayer();
1795 
1796         edgesToDraw &amp;= ~commonColorEdgeSet;
1797     }
1798 }
1799 
1800 void RenderBoxModelObject::paintBorder(const PaintInfo&amp; info, const LayoutRect&amp; rect, const RenderStyle&amp; style,
1801                                        BackgroundBleedAvoidance bleedAvoidance, bool includeLogicalLeftEdge, bool includeLogicalRightEdge)
1802 {
1803     GraphicsContext&amp; graphicsContext = info.context();
1804 
1805     if (graphicsContext.paintingDisabled())
1806         return;
1807 
1808     if (rect.isEmpty())
1809         return;
1810 
1811     auto rectToClipOut = paintRectToClipOutFromBorder(rect);
1812     bool appliedClipAlready = !rectToClipOut.isEmpty();
1813     GraphicsContextStateSaver stateSave(graphicsContext, appliedClipAlready);
1814     if (!rectToClipOut.isEmpty())
1815         graphicsContext.clipOut(snapRectToDevicePixels(rectToClipOut, document().deviceScaleFactor()));
1816 
1817     // border-image is not affected by border-radius.
1818     if (paintNinePieceImage(graphicsContext, rect, style, style.borderImage()))
1819         return;
1820 
1821     BorderEdge edges[4];
1822     BorderEdge::getBorderEdgeInfo(edges, style, document().deviceScaleFactor(), includeLogicalLeftEdge, includeLogicalRightEdge);
1823     RoundedRect outerBorder = style.getRoundedBorderFor(rect, includeLogicalLeftEdge, includeLogicalRightEdge);
1824     RoundedRect innerBorder = style.getRoundedInnerBorderFor(borderInnerRectAdjustedForBleedAvoidance(graphicsContext, rect, bleedAvoidance), includeLogicalLeftEdge, includeLogicalRightEdge);
1825 
1826     // If no borders intersects with the dirty area, we can skip the border painting.
1827     if (innerBorder.contains(info.rect))
1828         return;
1829 
1830     bool haveAlphaColor = false;
1831     bool haveAllSolidEdges = true;
1832     bool haveAllDoubleEdges = true;
1833     int numEdgesVisible = 4;
1834     bool allEdgesShareColor = true;
1835     int firstVisibleEdge = -1;
1836     BorderEdgeFlags edgesToDraw = 0;
1837 
1838     for (int i = BSTop; i &lt;= BSLeft; ++i) {
1839         const BorderEdge&amp; currEdge = edges[i];
1840 
1841         if (edges[i].shouldRender())
1842             edgesToDraw |= edgeFlagForSide(static_cast&lt;BoxSide&gt;(i));
1843 
1844         if (currEdge.presentButInvisible()) {
1845             --numEdgesVisible;
1846             allEdgesShareColor = false;
1847             continue;
1848         }
1849 
1850         if (!currEdge.widthForPainting()) {
1851             --numEdgesVisible;
1852             continue;
1853         }
1854 
1855         if (firstVisibleEdge == -1)
1856             firstVisibleEdge = i;
1857         else if (currEdge.color() != edges[firstVisibleEdge].color())
1858             allEdgesShareColor = false;
1859 
1860         if (!currEdge.color().isOpaque())
1861             haveAlphaColor = true;
1862 
1863         if (currEdge.style() != BorderStyle::Solid)
1864             haveAllSolidEdges = false;
1865 
1866         if (currEdge.style() != BorderStyle::Double)
1867             haveAllDoubleEdges = false;
1868     }
1869 
1870     // If no corner intersects the clip region, we can pretend outerBorder is
1871     // rectangular to improve performance.
1872     if (haveAllSolidEdges &amp;&amp; outerBorder.isRounded() &amp;&amp; allCornersClippedOut(outerBorder, info.rect))
1873         outerBorder.setRadii(RoundedRect::Radii());
1874 
1875     float deviceScaleFactor = document().deviceScaleFactor();
1876     // isRenderable() check avoids issue described in https://bugs.webkit.org/show_bug.cgi?id=38787
1877     if ((haveAllSolidEdges || haveAllDoubleEdges) &amp;&amp; allEdgesShareColor &amp;&amp; innerBorder.isRenderable()) {
1878         // Fast path for drawing all solid edges and all unrounded double edges
1879         if (numEdgesVisible == 4 &amp;&amp; (outerBorder.isRounded() || haveAlphaColor)
1880             &amp;&amp; (haveAllSolidEdges || (!outerBorder.isRounded() &amp;&amp; !innerBorder.isRounded()))) {
1881             Path path;
1882 
1883             FloatRoundedRect pixelSnappedOuterBorder = outerBorder.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
1884             if (pixelSnappedOuterBorder.isRounded() &amp;&amp; bleedAvoidance != BackgroundBleedUseTransparencyLayer)
1885                 path.addRoundedRect(pixelSnappedOuterBorder);
1886             else
1887                 path.addRect(pixelSnappedOuterBorder.rect());
1888 
1889             if (haveAllDoubleEdges) {
1890                 LayoutRect innerThirdRect = outerBorder.rect();
1891                 LayoutRect outerThirdRect = outerBorder.rect();
1892                 for (int side = BSTop; side &lt;= BSLeft; ++side) {
1893                     LayoutUnit outerWidth;
1894                     LayoutUnit innerWidth;
1895                     edges[side].getDoubleBorderStripeWidths(outerWidth, innerWidth);
1896 
1897                     if (side == BSTop) {
1898                         innerThirdRect.shiftYEdgeTo(innerThirdRect.y() + innerWidth);
1899                         outerThirdRect.shiftYEdgeTo(outerThirdRect.y() + outerWidth);
1900                     } else if (side == BSBottom) {
1901                         innerThirdRect.setHeight(innerThirdRect.height() - innerWidth);
1902                         outerThirdRect.setHeight(outerThirdRect.height() - outerWidth);
1903                     } else if (side == BSLeft) {
1904                         innerThirdRect.shiftXEdgeTo(innerThirdRect.x() + innerWidth);
1905                         outerThirdRect.shiftXEdgeTo(outerThirdRect.x() + outerWidth);
1906                     } else {
1907                         innerThirdRect.setWidth(innerThirdRect.width() - innerWidth);
1908                         outerThirdRect.setWidth(outerThirdRect.width() - outerWidth);
1909                     }
1910                 }
1911 
1912                 FloatRoundedRect pixelSnappedOuterThird = outerBorder.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
1913                 pixelSnappedOuterThird.setRect(snapRectToDevicePixels(outerThirdRect, deviceScaleFactor));
1914 
1915                 if (pixelSnappedOuterThird.isRounded() &amp;&amp; bleedAvoidance != BackgroundBleedUseTransparencyLayer)
1916                     path.addRoundedRect(pixelSnappedOuterThird);
1917                 else
1918                     path.addRect(pixelSnappedOuterThird.rect());
1919 
1920                 FloatRoundedRect pixelSnappedInnerThird = innerBorder.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
1921                 pixelSnappedInnerThird.setRect(snapRectToDevicePixels(innerThirdRect, deviceScaleFactor));
1922                 if (pixelSnappedInnerThird.isRounded() &amp;&amp; bleedAvoidance != BackgroundBleedUseTransparencyLayer)
1923                     path.addRoundedRect(pixelSnappedInnerThird);
1924                 else
1925                     path.addRect(pixelSnappedInnerThird.rect());
1926             }
1927 
1928             FloatRoundedRect pixelSnappedInnerBorder = innerBorder.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
1929             if (pixelSnappedInnerBorder.isRounded())
1930                 path.addRoundedRect(pixelSnappedInnerBorder);
1931             else
1932                 path.addRect(pixelSnappedInnerBorder.rect());
1933 
1934             graphicsContext.setFillRule(WindRule::EvenOdd);
1935             graphicsContext.setFillColor(edges[firstVisibleEdge].color());
1936             graphicsContext.fillPath(path);
1937             return;
1938         }
1939         // Avoid creating transparent layers
1940         if (haveAllSolidEdges &amp;&amp; numEdgesVisible != 4 &amp;&amp; !outerBorder.isRounded() &amp;&amp; haveAlphaColor) {
1941             Path path;
1942 
1943             for (int i = BSTop; i &lt;= BSLeft; ++i) {
1944                 const BorderEdge&amp; currEdge = edges[i];
1945                 if (currEdge.shouldRender()) {
1946                     LayoutRect sideRect = calculateSideRect(outerBorder, edges, i);
1947                     path.addRect(sideRect);
1948                 }
1949             }
1950 
1951             graphicsContext.setFillRule(WindRule::NonZero);
1952             graphicsContext.setFillColor(edges[firstVisibleEdge].color());
1953             graphicsContext.fillPath(path);
1954             return;
1955         }
1956     }
1957 
1958     bool clipToOuterBorder = outerBorder.isRounded();
1959     GraphicsContextStateSaver stateSaver(graphicsContext, clipToOuterBorder &amp;&amp; !appliedClipAlready);
1960     if (clipToOuterBorder) {
1961         // Clip to the inner and outer radii rects.
1962         if (bleedAvoidance != BackgroundBleedUseTransparencyLayer)
1963             graphicsContext.clipRoundedRect(outerBorder.pixelSnappedRoundedRectForPainting(deviceScaleFactor));
1964         // isRenderable() check avoids issue described in https://bugs.webkit.org/show_bug.cgi?id=38787
1965         // The inside will be clipped out later (in clipBorderSideForComplexInnerPath)
1966         if (innerBorder.isRenderable())
1967             graphicsContext.clipOutRoundedRect(innerBorder.pixelSnappedRoundedRectForPainting(deviceScaleFactor));
1968     }
1969 
1970     // If only one edge visible antialiasing doesn&#39;t create seams
1971     bool antialias = shouldAntialiasLines(graphicsContext) || numEdgesVisible == 1;
1972     RoundedRect unadjustedInnerBorder = (bleedAvoidance == BackgroundBleedBackgroundOverBorder) ? style.getRoundedInnerBorderFor(rect, includeLogicalLeftEdge, includeLogicalRightEdge) : innerBorder;
1973     IntPoint innerBorderAdjustment(innerBorder.rect().x() - unadjustedInnerBorder.rect().x(), innerBorder.rect().y() - unadjustedInnerBorder.rect().y());
1974     if (haveAlphaColor)
1975         paintTranslucentBorderSides(graphicsContext, style, outerBorder, unadjustedInnerBorder, innerBorderAdjustment, edges, edgesToDraw, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias);
1976     else
1977         paintBorderSides(graphicsContext, style, outerBorder, unadjustedInnerBorder, innerBorderAdjustment, edges, edgesToDraw, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias);
1978 }
1979 
1980 void RenderBoxModelObject::drawBoxSideFromPath(GraphicsContext&amp; graphicsContext, const LayoutRect&amp; borderRect, const Path&amp; borderPath, const BorderEdge edges[],
1981     float thickness, float drawThickness, BoxSide side, const RenderStyle&amp; style, Color color, BorderStyle borderStyle, BackgroundBleedAvoidance bleedAvoidance,
1982     bool includeLogicalLeftEdge, bool includeLogicalRightEdge)
1983 {
1984     if (thickness &lt;= 0)
1985         return;
1986 
1987     if (borderStyle == BorderStyle::Double &amp;&amp; thickness &lt; 3)
1988         borderStyle = BorderStyle::Solid;
1989 
1990     switch (borderStyle) {
1991     case BorderStyle::None:
1992     case BorderStyle::Hidden:
1993         return;
1994     case BorderStyle::Dotted:
1995     case BorderStyle::Dashed: {
1996         graphicsContext.setStrokeColor(color);
1997 
1998         // The stroke is doubled here because the provided path is the
1999         // outside edge of the border so half the stroke is clipped off.
2000         // The extra multiplier is so that the clipping mask can antialias
2001         // the edges to prevent jaggies.
2002         graphicsContext.setStrokeThickness(drawThickness * 2 * 1.1f);
2003         graphicsContext.setStrokeStyle(borderStyle == BorderStyle::Dashed ? DashedStroke : DottedStroke);
2004 
2005         // If the number of dashes that fit in the path is odd and non-integral then we
2006         // will have an awkwardly-sized dash at the end of the path. To try to avoid that
2007         // here, we simply make the whitespace dashes ever so slightly bigger.
2008         // FIXME: This could be even better if we tried to manipulate the dash offset
2009         // and possibly the gapLength to get the corners dash-symmetrical.
2010         float dashLength = thickness * ((borderStyle == BorderStyle::Dashed) ? 3.0f : 1.0f);
2011         float gapLength = dashLength;
2012         float numberOfDashes = borderPath.length() / dashLength;
2013         // Don&#39;t try to show dashes if we have less than 2 dashes + 2 gaps.
2014         // FIXME: should do this test per side.
2015         if (numberOfDashes &gt;= 4) {
2016             bool evenNumberOfFullDashes = !((int)numberOfDashes % 2);
2017             bool integralNumberOfDashes = !(numberOfDashes - (int)numberOfDashes);
2018             if (!evenNumberOfFullDashes &amp;&amp; !integralNumberOfDashes) {
2019                 float numberOfGaps = numberOfDashes / 2;
2020                 gapLength += (dashLength  / numberOfGaps);
2021             }
2022 
2023             DashArray lineDash;
2024             lineDash.append(dashLength);
2025             lineDash.append(gapLength);
2026             graphicsContext.setLineDash(lineDash, dashLength);
2027         }
2028 
2029         // FIXME: stroking the border path causes issues with tight corners:
2030         // https://bugs.webkit.org/show_bug.cgi?id=58711
2031         // Also, to get the best appearance we should stroke a path between the two borders.
2032         graphicsContext.strokePath(borderPath);
2033         return;
2034     }
2035     case BorderStyle::Double: {
2036         // Get the inner border rects for both the outer border line and the inner border line
2037         LayoutUnit outerBorderTopWidth;
2038         LayoutUnit innerBorderTopWidth;
2039         edges[BSTop].getDoubleBorderStripeWidths(outerBorderTopWidth, innerBorderTopWidth);
2040 
2041         LayoutUnit outerBorderRightWidth;
2042         LayoutUnit innerBorderRightWidth;
2043         edges[BSRight].getDoubleBorderStripeWidths(outerBorderRightWidth, innerBorderRightWidth);
2044 
2045         LayoutUnit outerBorderBottomWidth;
2046         LayoutUnit innerBorderBottomWidth;
2047         edges[BSBottom].getDoubleBorderStripeWidths(outerBorderBottomWidth, innerBorderBottomWidth);
2048 
2049         LayoutUnit outerBorderLeftWidth;
2050         LayoutUnit innerBorderLeftWidth;
2051         edges[BSLeft].getDoubleBorderStripeWidths(outerBorderLeftWidth, innerBorderLeftWidth);
2052 
2053         // Draw inner border line
2054         {
2055             GraphicsContextStateSaver stateSaver(graphicsContext);
2056             RoundedRect innerClip = style.getRoundedInnerBorderFor(borderRect,
2057                 innerBorderTopWidth, innerBorderBottomWidth, innerBorderLeftWidth, innerBorderRightWidth,
2058                 includeLogicalLeftEdge, includeLogicalRightEdge);
2059 
2060             graphicsContext.clipRoundedRect(FloatRoundedRect(innerClip));
2061             drawBoxSideFromPath(graphicsContext, borderRect, borderPath, edges, thickness, drawThickness, side, style, color, BorderStyle::Solid, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge);
2062         }
2063 
2064         // Draw outer border line
2065         {
2066             GraphicsContextStateSaver stateSaver(graphicsContext);
2067             LayoutRect outerRect = borderRect;
2068             if (bleedAvoidance == BackgroundBleedUseTransparencyLayer) {
2069                 outerRect.inflate(1);
2070                 ++outerBorderTopWidth;
2071                 ++outerBorderBottomWidth;
2072                 ++outerBorderLeftWidth;
2073                 ++outerBorderRightWidth;
2074             }
2075 
2076             RoundedRect outerClip = style.getRoundedInnerBorderFor(outerRect,
2077                 outerBorderTopWidth, outerBorderBottomWidth, outerBorderLeftWidth, outerBorderRightWidth,
2078                 includeLogicalLeftEdge, includeLogicalRightEdge);
2079             graphicsContext.clipOutRoundedRect(FloatRoundedRect(outerClip));
2080             drawBoxSideFromPath(graphicsContext, borderRect, borderPath, edges, thickness, drawThickness, side, style, color, BorderStyle::Solid, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge);
2081         }
2082         return;
2083     }
2084     case BorderStyle::Ridge:
2085     case BorderStyle::Groove:
2086     {
2087         BorderStyle s1;
2088         BorderStyle s2;
2089         if (borderStyle == BorderStyle::Groove) {
2090             s1 = BorderStyle::Inset;
2091             s2 = BorderStyle::Outset;
2092         } else {
2093             s1 = BorderStyle::Outset;
2094             s2 = BorderStyle::Inset;
2095         }
2096 
2097         // Paint full border
2098         drawBoxSideFromPath(graphicsContext, borderRect, borderPath, edges, thickness, drawThickness, side, style, color, s1, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge);
2099 
2100         // Paint inner only
2101         GraphicsContextStateSaver stateSaver(graphicsContext);
2102         LayoutUnit topWidth { edges[BSTop].widthForPainting() / 2 };
2103         LayoutUnit bottomWidth { edges[BSBottom].widthForPainting() / 2 };
2104         LayoutUnit leftWidth { edges[BSLeft].widthForPainting() / 2 };
2105         LayoutUnit rightWidth { edges[BSRight].widthForPainting() / 2 };
2106 
2107         RoundedRect clipRect = style.getRoundedInnerBorderFor(borderRect,
2108             topWidth, bottomWidth, leftWidth, rightWidth,
2109             includeLogicalLeftEdge, includeLogicalRightEdge);
2110 
2111         graphicsContext.clipRoundedRect(FloatRoundedRect(clipRect));
2112         drawBoxSideFromPath(graphicsContext, borderRect, borderPath, edges, thickness, drawThickness, side, style, color, s2, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge);
2113         return;
2114     }
2115     case BorderStyle::Inset:
2116     case BorderStyle::Outset:
2117         calculateBorderStyleColor(borderStyle, side, color);
2118         break;
2119     default:
2120         break;
2121     }
2122 
2123     graphicsContext.setStrokeStyle(NoStroke);
2124     graphicsContext.setFillColor(color);
2125     graphicsContext.drawRect(snapRectToDevicePixels(borderRect, document().deviceScaleFactor()));
2126 }
2127 
2128 void RenderBoxModelObject::clipBorderSidePolygon(GraphicsContext&amp; graphicsContext, const RoundedRect&amp; outerBorder, const RoundedRect&amp; innerBorder,
2129                                                  BoxSide side, bool firstEdgeMatches, bool secondEdgeMatches)
2130 {
2131     float deviceScaleFactor = document().deviceScaleFactor();
2132     const FloatRect&amp; outerRect = snapRectToDevicePixels(outerBorder.rect(), deviceScaleFactor);
2133     const FloatRect&amp; innerRect = snapRectToDevicePixels(innerBorder.rect(), deviceScaleFactor);
2134 
2135     // For each side, create a quad that encompasses all parts of that side that may draw,
2136     // including areas inside the innerBorder.
2137     //
2138     //         0----------------3
2139     //       0  \              /  0
2140     //       |\  1----------- 2  /|
2141     //       | 1                1 |
2142     //       | |                | |
2143     //       | |                | |
2144     //       | 2                2 |
2145     //       |/  1------------2  \|
2146     //       3  /              \  3
2147     //         0----------------3
2148     //
2149     Vector&lt;FloatPoint&gt; quad;
2150     quad.reserveInitialCapacity(4);
2151     switch (side) {
2152     case BSTop:
2153         quad.uncheckedAppend(outerRect.minXMinYCorner());
2154         quad.uncheckedAppend(innerRect.minXMinYCorner());
2155         quad.uncheckedAppend(innerRect.maxXMinYCorner());
2156         quad.uncheckedAppend(outerRect.maxXMinYCorner());
2157 
2158         if (!innerBorder.radii().topLeft().isZero())
2159             findIntersection(outerRect.minXMinYCorner(), innerRect.minXMinYCorner(), innerRect.minXMaxYCorner(), innerRect.maxXMinYCorner(), quad[1]);
2160 
2161         if (!innerBorder.radii().topRight().isZero())
2162             findIntersection(outerRect.maxXMinYCorner(), innerRect.maxXMinYCorner(), innerRect.minXMinYCorner(), innerRect.maxXMaxYCorner(), quad[2]);
2163         break;
2164 
2165     case BSLeft:
2166         quad.uncheckedAppend(outerRect.minXMinYCorner());
2167         quad.uncheckedAppend(innerRect.minXMinYCorner());
2168         quad.uncheckedAppend(innerRect.minXMaxYCorner());
2169         quad.uncheckedAppend(outerRect.minXMaxYCorner());
2170 
2171         if (!innerBorder.radii().topLeft().isZero())
2172             findIntersection(outerRect.minXMinYCorner(), innerRect.minXMinYCorner(), innerRect.minXMaxYCorner(), innerRect.maxXMinYCorner(), quad[1]);
2173 
2174         if (!innerBorder.radii().bottomLeft().isZero())
2175             findIntersection(outerRect.minXMaxYCorner(), innerRect.minXMaxYCorner(), innerRect.minXMinYCorner(), innerRect.maxXMaxYCorner(), quad[2]);
2176         break;
2177 
2178     case BSBottom:
2179         quad.uncheckedAppend(outerRect.minXMaxYCorner());
2180         quad.uncheckedAppend(innerRect.minXMaxYCorner());
2181         quad.uncheckedAppend(innerRect.maxXMaxYCorner());
2182         quad.uncheckedAppend(outerRect.maxXMaxYCorner());
2183 
2184         if (!innerBorder.radii().bottomLeft().isZero())
2185             findIntersection(outerRect.minXMaxYCorner(), innerRect.minXMaxYCorner(), innerRect.minXMinYCorner(), innerRect.maxXMaxYCorner(), quad[1]);
2186 
2187         if (!innerBorder.radii().bottomRight().isZero())
2188             findIntersection(outerRect.maxXMaxYCorner(), innerRect.maxXMaxYCorner(), innerRect.maxXMinYCorner(), innerRect.minXMaxYCorner(), quad[2]);
2189         break;
2190 
2191     case BSRight:
2192         quad.uncheckedAppend(outerRect.maxXMinYCorner());
2193         quad.uncheckedAppend(innerRect.maxXMinYCorner());
2194         quad.uncheckedAppend(innerRect.maxXMaxYCorner());
2195         quad.uncheckedAppend(outerRect.maxXMaxYCorner());
2196 
2197         if (!innerBorder.radii().topRight().isZero())
2198             findIntersection(outerRect.maxXMinYCorner(), innerRect.maxXMinYCorner(), innerRect.minXMinYCorner(), innerRect.maxXMaxYCorner(), quad[1]);
2199 
2200         if (!innerBorder.radii().bottomRight().isZero())
2201             findIntersection(outerRect.maxXMaxYCorner(), innerRect.maxXMaxYCorner(), innerRect.maxXMinYCorner(), innerRect.minXMaxYCorner(), quad[2]);
2202         break;
2203     }
2204 
2205     // If the border matches both of its adjacent sides, don&#39;t anti-alias the clip, and
2206     // if neither side matches, anti-alias the clip.
2207     if (firstEdgeMatches == secondEdgeMatches) {
2208         bool wasAntialiased = graphicsContext.shouldAntialias();
2209         graphicsContext.setShouldAntialias(!firstEdgeMatches);
2210         graphicsContext.clipPath(Path::polygonPathFromPoints(quad), WindRule::NonZero);
2211         graphicsContext.setShouldAntialias(wasAntialiased);
2212         return;
2213     }
2214 
2215     // Square off the end which shouldn&#39;t be affected by antialiasing, and clip.
2216     Vector&lt;FloatPoint&gt; firstQuad = {
2217         quad[0],
2218         quad[1],
2219         quad[2],
2220         side == BSTop || side == BSBottom ? FloatPoint(quad[3].x(), quad[2].y()) : FloatPoint(quad[2].x(), quad[3].y()),
2221         quad[3]
2222     };
2223     bool wasAntialiased = graphicsContext.shouldAntialias();
2224     graphicsContext.setShouldAntialias(!firstEdgeMatches);
2225     graphicsContext.clipPath(Path::polygonPathFromPoints(firstQuad), WindRule::NonZero);
2226 
2227     Vector&lt;FloatPoint&gt; secondQuad = {
2228         quad[0],
2229         side == BSTop || side == BSBottom ? FloatPoint(quad[0].x(), quad[1].y()) : FloatPoint(quad[1].x(), quad[0].y()),
2230         quad[1],
2231         quad[2],
2232         quad[3]
2233     };
2234     // Antialiasing affects the second side.
2235     graphicsContext.setShouldAntialias(!secondEdgeMatches);
2236     graphicsContext.clipPath(Path::polygonPathFromPoints(secondQuad), WindRule::NonZero);
2237 
2238     graphicsContext.setShouldAntialias(wasAntialiased);
2239 }
2240 
2241 bool RenderBoxModelObject::borderObscuresBackgroundEdge(const FloatSize&amp; contextScale) const
2242 {
2243     BorderEdge edges[4];
2244     BorderEdge::getBorderEdgeInfo(edges, style(), document().deviceScaleFactor());
2245 
2246     for (int i = BSTop; i &lt;= BSLeft; ++i) {
2247         const BorderEdge&amp; currEdge = edges[i];
2248         // FIXME: for vertical text
2249         float axisScale = (i == BSTop || i == BSBottom) ? contextScale.height() : contextScale.width();
2250         if (!currEdge.obscuresBackgroundEdge(axisScale))
2251             return false;
2252     }
2253 
2254     return true;
2255 }
2256 
2257 bool RenderBoxModelObject::borderObscuresBackground() const
2258 {
2259     if (!style().hasBorder())
2260         return false;
2261 
2262     // Bail if we have any border-image for now. We could look at the image alpha to improve this.
2263     if (style().borderImage().image())
2264         return false;
2265 
2266     BorderEdge edges[4];
2267     BorderEdge::getBorderEdgeInfo(edges, style(), document().deviceScaleFactor());
2268 
2269     for (int i = BSTop; i &lt;= BSLeft; ++i) {
2270         const BorderEdge&amp; currEdge = edges[i];
2271         if (!currEdge.obscuresBackground())
2272             return false;
2273     }
2274 
2275     return true;
2276 }
2277 
2278 bool RenderBoxModelObject::boxShadowShouldBeAppliedToBackground(const LayoutPoint&amp;, BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox* inlineFlowBox) const
2279 {
2280     if (bleedAvoidance != BackgroundBleedNone)
2281         return false;
2282 
2283     if (style().hasAppearance())
2284         return false;
2285 
2286     bool hasOneNormalBoxShadow = false;
2287     for (const ShadowData* currentShadow = style().boxShadow(); currentShadow; currentShadow = currentShadow-&gt;next()) {
<a name="14" id="anc14"></a><span class="line-modified">2288         if (currentShadow-&gt;style() != ShadowStyle::Normal)</span>
2289             continue;
2290 
2291         if (hasOneNormalBoxShadow)
2292             return false;
2293         hasOneNormalBoxShadow = true;
2294 
2295         if (currentShadow-&gt;spread())
2296             return false;
2297     }
2298 
2299     if (!hasOneNormalBoxShadow)
2300         return false;
2301 
2302     Color backgroundColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
2303     if (!backgroundColor.isOpaque())
2304         return false;
2305 
2306     auto* lastBackgroundLayer = &amp;style().backgroundLayers();
2307     while (auto* next = lastBackgroundLayer-&gt;next())
2308         lastBackgroundLayer = next;
2309 
2310     if (lastBackgroundLayer-&gt;clip() != FillBox::Border)
2311         return false;
2312 
2313     if (lastBackgroundLayer-&gt;image() &amp;&amp; style().hasBorderRadius())
2314         return false;
2315 
2316     if (inlineFlowBox &amp;&amp; !inlineFlowBox-&gt;boxShadowCanBeAppliedToBackground(*lastBackgroundLayer))
2317         return false;
2318 
2319     if (hasOverflowClip() &amp;&amp; lastBackgroundLayer-&gt;attachment() == FillAttachment::LocalBackground)
2320         return false;
2321 
2322     return true;
2323 }
2324 
<a name="15" id="anc15"></a><span class="line-modified">2325 static inline LayoutRect areaCastingShadowInHole(const LayoutRect&amp; holeRect, LayoutUnit shadowExtent, LayoutUnit shadowSpread, const LayoutSize&amp; shadowOffset)</span>
2326 {
2327     LayoutRect bounds(holeRect);
2328 
2329     bounds.inflate(shadowExtent);
2330 
2331     if (shadowSpread &lt; 0)
2332         bounds.inflate(-shadowSpread);
2333 
2334     LayoutRect offsetBounds = bounds;
2335     offsetBounds.move(-shadowOffset);
2336     return unionRect(bounds, offsetBounds);
2337 }
2338 
2339 void RenderBoxModelObject::paintBoxShadow(const PaintInfo&amp; info, const LayoutRect&amp; paintRect, const RenderStyle&amp; style, ShadowStyle shadowStyle, bool includeLogicalLeftEdge, bool includeLogicalRightEdge)
2340 {
2341     // FIXME: Deal with border-image.  Would be great to use border-image as a mask.
2342     GraphicsContext&amp; context = info.context();
2343     if (context.paintingDisabled() || !style.boxShadow())
2344         return;
2345 
<a name="16" id="anc16"></a><span class="line-modified">2346     RoundedRect border = (shadowStyle == ShadowStyle::Inset) ? style.getRoundedInnerBorderFor(paintRect, includeLogicalLeftEdge, includeLogicalRightEdge)</span>
2347         : style.getRoundedBorderFor(paintRect, includeLogicalLeftEdge, includeLogicalRightEdge);
2348 
2349     bool hasBorderRadius = style.hasBorderRadius();
2350     bool isHorizontal = style.isHorizontalWritingMode();
2351     float deviceScaleFactor = document().deviceScaleFactor();
2352 
2353     bool hasOpaqueBackground = style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isOpaque();
2354     for (const ShadowData* shadow = style.boxShadow(); shadow; shadow = shadow-&gt;next()) {
2355         if (shadow-&gt;style() != shadowStyle)
2356             continue;
2357 
<a name="17" id="anc17"></a><span class="line-modified">2358         LayoutSize shadowOffset(shadow-&gt;x(), shadow-&gt;y());</span>
<span class="line-modified">2359         LayoutUnit shadowPaintingExtent = shadow-&gt;paintingExtent();</span>
<span class="line-modified">2360         LayoutUnit shadowSpread = shadow-&gt;spread();</span>
2361         int shadowRadius = shadow-&gt;radius();
<a name="18" id="anc18"></a>

2362 
2363         if (shadowOffset.isZero() &amp;&amp; !shadowRadius &amp;&amp; !shadowSpread)
2364             continue;
2365 
2366         Color shadowColor = style.colorByApplyingColorFilter(shadow-&gt;color());
2367 
<a name="19" id="anc19"></a><span class="line-modified">2368         if (shadow-&gt;style() == ShadowStyle::Normal) {</span>
2369             RoundedRect fillRect = border;
2370             fillRect.inflate(shadowSpread);
2371             if (fillRect.isEmpty())
2372                 continue;
2373 
<a name="20" id="anc20"></a><span class="line-modified">2374             LayoutRect shadowRect = border.rect();</span>
<span class="line-modified">2375             shadowRect.inflate(shadowPaintingExtent + shadowSpread);</span>
<span class="line-modified">2376             shadowRect.move(shadowOffset);</span>
<span class="line-added">2377             FloatRect pixelSnappedShadowRect = snapRectToDevicePixels(shadowRect, deviceScaleFactor);</span>
2378 
2379             GraphicsContextStateSaver stateSaver(context);
2380             context.clip(pixelSnappedShadowRect);
2381 
<a name="21" id="anc21"></a><span class="line-modified">2382             // Move the fill just outside the clip, adding at least 1 pixel of separation so that the fill does not</span>
2383             // bleed in (due to antialiasing) if the context is transformed.
<a name="22" id="anc22"></a><span class="line-modified">2384             LayoutUnit xOffset = paintRect.width() + std::max&lt;LayoutUnit&gt;(0, shadowOffset.width()) + shadowPaintingExtent + 2 * shadowSpread + LayoutUnit(1);</span>
<span class="line-added">2385             LayoutSize extraOffset(xOffset.ceil(), 0);</span>
2386             shadowOffset -= extraOffset;
2387             fillRect.move(extraOffset);
2388 
<a name="23" id="anc23"></a><span class="line-added">2389             FloatRoundedRect pixelSnappedRectToClipOut = border.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
<span class="line-added">2390             FloatRoundedRect pixelSnappedFillRect = fillRect.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
<span class="line-added">2391 </span>
<span class="line-added">2392             LayoutPoint shadowRectOrigin = fillRect.rect().location() + shadowOffset;</span>
<span class="line-added">2393             FloatPoint snappedShadowOrigin = FloatPoint(roundToDevicePixel(shadowRectOrigin.x(), deviceScaleFactor), roundToDevicePixel(shadowRectOrigin.y(), deviceScaleFactor));</span>
<span class="line-added">2394             FloatSize snappedShadowOffset = snappedShadowOrigin - pixelSnappedFillRect.rect().location();</span>
<span class="line-added">2395 </span>
2396             if (shadow-&gt;isWebkitBoxShadow())
<a name="24" id="anc24"></a><span class="line-modified">2397                 context.setLegacyShadow(snappedShadowOffset, shadowRadius, shadowColor);</span>
2398             else
<a name="25" id="anc25"></a><span class="line-modified">2399                 context.setShadow(snappedShadowOffset, shadowRadius, shadowColor);</span>
2400 
<a name="26" id="anc26"></a>

2401             if (hasBorderRadius) {
2402                 // If the box is opaque, it is unnecessary to clip it out. However, doing so saves time
2403                 // when painting the shadow. On the other hand, it introduces subpixel gaps along the
2404                 // corners. Those are avoided by insetting the clipping path by one pixel.
2405                 if (hasOpaqueBackground)
<a name="27" id="anc27"></a><span class="line-modified">2406                     pixelSnappedRectToClipOut.inflateWithRadii(-1.0f);</span>
2407 
<a name="28" id="anc28"></a><span class="line-modified">2408                 if (!pixelSnappedRectToClipOut.isEmpty())</span>
<span class="line-modified">2409                     context.clipOutRoundedRect(pixelSnappedRectToClipOut);</span>
2410 
2411                 RoundedRect influenceRect(LayoutRect(pixelSnappedShadowRect), border.radii());
2412                 influenceRect.expandRadii(2 * shadowPaintingExtent + shadowSpread);
2413 
2414                 if (allCornersClippedOut(influenceRect, info.rect))
2415                     context.fillRect(pixelSnappedFillRect.rect(), Color::black);
2416                 else {
2417                     pixelSnappedFillRect.expandRadii(shadowSpread);
2418                     if (!pixelSnappedFillRect.isRenderable())
2419                         pixelSnappedFillRect.adjustRadii();
2420                     context.fillRoundedRect(pixelSnappedFillRect, Color::black);
2421                 }
2422             } else {
2423                 // If the box is opaque, it is unnecessary to clip it out. However, doing so saves time
2424                 // when painting the shadow. On the other hand, it introduces subpixel gaps along the
2425                 // edges if they are not pixel-aligned. Those are avoided by insetting the clipping path
2426                 // by one pixel.
2427                 if (hasOpaqueBackground) {
2428                     // FIXME: The function to decide on the policy based on the transform should be a named function.
2429                     // FIXME: It&#39;s not clear if this check is right. What about integral scale factors?
2430                     AffineTransform transform = context.getCTM();
2431                     if (transform.a() != 1 || (transform.d() != 1 &amp;&amp; transform.d() != -1) || transform.b() || transform.c())
<a name="29" id="anc29"></a><span class="line-modified">2432                         pixelSnappedRectToClipOut.inflate(-1.0f);</span>
2433                 }
2434 
<a name="30" id="anc30"></a><span class="line-modified">2435                 if (!pixelSnappedRectToClipOut.isEmpty())</span>
<span class="line-modified">2436                     context.clipOut(pixelSnappedRectToClipOut.rect());</span>
<span class="line-added">2437 </span>
2438                 context.fillRect(pixelSnappedFillRect.rect(), Color::black);
2439             }
2440         } else {
2441             // Inset shadow.
<a name="31" id="anc31"></a><span class="line-added">2442             LayoutRect holeRect = border.rect();</span>
<span class="line-added">2443             holeRect.inflate(-shadowSpread);</span>
<span class="line-added">2444             FloatRect pixelSnappedHoleRect = snapRectToDevicePixels(holeRect, deviceScaleFactor);</span>
2445             FloatRoundedRect pixelSnappedBorderRect = border.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
<a name="32" id="anc32"></a>

2446 
2447             if (pixelSnappedHoleRect.isEmpty()) {
2448                 if (hasBorderRadius)
2449                     context.fillRoundedRect(pixelSnappedBorderRect, shadowColor);
2450                 else
2451                     context.fillRect(pixelSnappedBorderRect.rect(), shadowColor);
2452                 continue;
2453             }
2454 
2455             if (!includeLogicalLeftEdge) {
2456                 if (isHorizontal) {
<a name="33" id="anc33"></a><span class="line-modified">2457                     holeRect.move(-std::max&lt;LayoutUnit&gt;(shadowOffset.width(), 0) - shadowPaintingExtent, 0);</span>
<span class="line-modified">2458                     holeRect.setWidth(holeRect.width() + std::max&lt;LayoutUnit&gt;(shadowOffset.width(), 0) + shadowPaintingExtent);</span>
2459                 } else {
<a name="34" id="anc34"></a><span class="line-modified">2460                     holeRect.move(0, -std::max&lt;LayoutUnit&gt;(shadowOffset.height(), 0) - shadowPaintingExtent);</span>
<span class="line-modified">2461                     holeRect.setHeight(holeRect.height() + std::max&lt;LayoutUnit&gt;(shadowOffset.height(), 0) + shadowPaintingExtent);</span>
2462                 }
2463             }
<a name="35" id="anc35"></a><span class="line-added">2464 </span>
2465             if (!includeLogicalRightEdge) {
2466                 if (isHorizontal)
<a name="36" id="anc36"></a><span class="line-modified">2467                     holeRect.setWidth(holeRect.width() - std::min&lt;LayoutUnit&gt;(shadowOffset.width(), 0) + shadowPaintingExtent);</span>
2468                 else
<a name="37" id="anc37"></a><span class="line-modified">2469                     holeRect.setHeight(holeRect.height() - std::min&lt;LayoutUnit&gt;(shadowOffset.height(), 0) + shadowPaintingExtent);</span>
2470             }
2471 
<a name="38" id="anc38"></a><span class="line-added">2472             if (!includeLogicalLeftEdge || !includeLogicalRightEdge)</span>
<span class="line-added">2473                 pixelSnappedHoleRect = snapRectToDevicePixels(holeRect, deviceScaleFactor);</span>
<span class="line-added">2474 </span>
2475             Color fillColor(shadowColor.red(), shadowColor.green(), shadowColor.blue(), 255);
2476 
<a name="39" id="anc39"></a><span class="line-modified">2477             LayoutRect shadowCastingRect = areaCastingShadowInHole(border.rect(), shadowPaintingExtent, shadowSpread, shadowOffset);</span>
<span class="line-modified">2478             RoundedRect roundedHoleRect(holeRect, border.radii());</span>
<span class="line-added">2479 </span>
<span class="line-added">2480             FloatRect pixelSnappedOuterRect = snapRectToDevicePixels(shadowCastingRect, deviceScaleFactor);</span>
<span class="line-added">2481             FloatRoundedRect pixelSnappedRoundedHole = roundedHoleRect.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
2482 
2483             GraphicsContextStateSaver stateSaver(context);
2484             if (hasBorderRadius) {
2485                 context.clipRoundedRect(pixelSnappedBorderRect);
2486                 pixelSnappedRoundedHole.shrinkRadii(shadowSpread);
2487             } else
2488                 context.clip(pixelSnappedBorderRect.rect());
2489 
<a name="40" id="anc40"></a><span class="line-modified">2490             LayoutUnit xOffset = 2 * paintRect.width() + std::max&lt;LayoutUnit&gt;(0, shadowOffset.width()) + shadowPaintingExtent + 2 * shadowSpread + LayoutUnit(1);</span>
<span class="line-added">2491             LayoutSize extraOffset(xOffset.ceil(), 0);</span>
<span class="line-added">2492 </span>
2493             context.translate(extraOffset);
2494             shadowOffset -= extraOffset;
2495 
2496             if (shadow-&gt;isWebkitBoxShadow())
2497                 context.setLegacyShadow(shadowOffset, shadowRadius, shadowColor);
2498             else
2499                 context.setShadow(shadowOffset, shadowRadius, shadowColor);
2500 
<a name="41" id="anc41"></a><span class="line-modified">2501             context.fillRectWithRoundedHole(enclosingIntRect(pixelSnappedOuterRect), pixelSnappedRoundedHole, fillColor); // todo tav IntRect is required as first param</span>
2502         }
2503     }
2504 }
2505 
2506 LayoutUnit RenderBoxModelObject::containingBlockLogicalWidthForContent() const
2507 {
2508     if (auto* containingBlock = this-&gt;containingBlock())
2509         return containingBlock-&gt;availableLogicalWidth();
2510     return { };
2511 }
2512 
2513 RenderBoxModelObject* RenderBoxModelObject::continuation() const
2514 {
2515     if (!hasContinuationChainNode())
2516         return nullptr;
2517 
2518     auto&amp; continuationChainNode = *continuationChainNodeMap().get(this);
2519     if (!continuationChainNode.next)
2520         return nullptr;
2521     return continuationChainNode.next-&gt;renderer.get();
2522 }
2523 
2524 RenderInline* RenderBoxModelObject::inlineContinuation() const
2525 {
2526     if (!hasContinuationChainNode())
2527         return nullptr;
2528 
2529     for (auto* next = continuationChainNodeMap().get(this)-&gt;next; next; next = next-&gt;next) {
2530         if (is&lt;RenderInline&gt;(*next-&gt;renderer))
2531             return downcast&lt;RenderInline&gt;(next-&gt;renderer.get());
2532     }
2533     return nullptr;
2534 }
2535 
2536 RenderBoxModelObject::ContinuationChainNode* RenderBoxModelObject::continuationChainNode() const
2537 {
2538     return continuationChainNodeMap().get(this);
2539 }
2540 
2541 void RenderBoxModelObject::insertIntoContinuationChainAfter(RenderBoxModelObject&amp; afterRenderer)
2542 {
2543     ASSERT(isContinuation());
2544     ASSERT(!continuationChainNodeMap().contains(this));
2545 
2546     auto&amp; after = afterRenderer.ensureContinuationChainNode();
2547     ensureContinuationChainNode().insertAfter(after);
2548 }
2549 
2550 void RenderBoxModelObject::removeFromContinuationChain()
2551 {
2552     ASSERT(hasContinuationChainNode());
2553     ASSERT(continuationChainNodeMap().contains(this));
2554     setHasContinuationChainNode(false);
2555     continuationChainNodeMap().remove(this);
2556 }
2557 
2558 auto RenderBoxModelObject::ensureContinuationChainNode() -&gt; ContinuationChainNode&amp;
2559 {
2560     setHasContinuationChainNode(true);
2561     return *continuationChainNodeMap().ensure(this, [&amp;] {
2562         return makeUnique&lt;ContinuationChainNode&gt;(*this);
2563     }).iterator-&gt;value;
2564 }
2565 
2566 RenderTextFragment* RenderBoxModelObject::firstLetterRemainingText() const
2567 {
2568     if (!isFirstLetter())
2569         return nullptr;
2570     return firstLetterRemainingTextMap().get(this).get();
2571 }
2572 
2573 void RenderBoxModelObject::setFirstLetterRemainingText(RenderTextFragment&amp; remainingText)
2574 {
2575     ASSERT(isFirstLetter());
2576     firstLetterRemainingTextMap().set(this, makeWeakPtr(remainingText));
2577 }
2578 
2579 void RenderBoxModelObject::clearFirstLetterRemainingText()
2580 {
2581     ASSERT(isFirstLetter());
2582     firstLetterRemainingTextMap().remove(this);
2583 }
2584 
2585 LayoutRect RenderBoxModelObject::localCaretRectForEmptyElement(LayoutUnit width, LayoutUnit textIndentOffset)
2586 {
2587     ASSERT(!firstChild());
2588 
2589     // FIXME: This does not take into account either :first-line or :first-letter
2590     // However, as soon as some content is entered, the line boxes will be
2591     // constructed and this kludge is not called any more. So only the caret size
2592     // of an empty :first-line&#39;d block is wrong. I think we can live with that.
2593     const RenderStyle&amp; currentStyle = firstLineStyle();
2594     LayoutUnit height = lineHeight(true, currentStyle.isHorizontalWritingMode() ? HorizontalLine : VerticalLine);
2595 
2596     enum CaretAlignment { alignLeft, alignRight, alignCenter };
2597 
2598     CaretAlignment alignment = alignLeft;
2599 
2600     switch (currentStyle.textAlign()) {
2601     case TextAlignMode::Left:
2602     case TextAlignMode::WebKitLeft:
2603         break;
2604     case TextAlignMode::Center:
2605     case TextAlignMode::WebKitCenter:
2606         alignment = alignCenter;
2607         break;
2608     case TextAlignMode::Right:
2609     case TextAlignMode::WebKitRight:
2610         alignment = alignRight;
2611         break;
2612     case TextAlignMode::Justify:
2613     case TextAlignMode::Start:
2614         if (!currentStyle.isLeftToRightDirection())
2615             alignment = alignRight;
2616         break;
2617     case TextAlignMode::End:
2618         if (currentStyle.isLeftToRightDirection())
2619             alignment = alignRight;
2620         break;
2621     }
2622 
2623     LayoutUnit x = borderLeft() + paddingLeft();
2624     LayoutUnit maxX = width - borderRight() - paddingRight();
2625 
2626     switch (alignment) {
2627     case alignLeft:
2628         if (currentStyle.isLeftToRightDirection())
2629             x += textIndentOffset;
2630         break;
2631     case alignCenter:
2632         x = (x + maxX) / 2;
2633         if (currentStyle.isLeftToRightDirection())
2634             x += textIndentOffset / 2;
2635         else
2636             x -= textIndentOffset / 2;
2637         break;
2638     case alignRight:
2639         x = maxX - caretWidth;
2640         if (!currentStyle.isLeftToRightDirection())
2641             x -= textIndentOffset;
2642         break;
2643     }
2644     x = std::min(x, std::max&lt;LayoutUnit&gt;(maxX - caretWidth, 0));
2645 
2646     LayoutUnit y = paddingTop() + borderTop();
2647 
2648     return currentStyle.isHorizontalWritingMode() ? LayoutRect(x, y, caretWidth, height) : LayoutRect(y, x, height, caretWidth);
2649 }
2650 
2651 bool RenderBoxModelObject::shouldAntialiasLines(GraphicsContext&amp; context)
2652 {
2653     // FIXME: We may want to not antialias when scaled by an integral value,
2654     // and we may want to antialias when translated by a non-integral value.
2655     return !context.getCTM().isIdentityOrTranslationOrFlipped();
2656 }
2657 
2658 void RenderBoxModelObject::mapAbsoluteToLocalPoint(MapCoordinatesFlags mode, TransformState&amp; transformState) const
2659 {
2660     RenderElement* container = this-&gt;container();
2661     if (!container)
2662         return;
2663 
2664     // FIXME: This code is wrong for named flow threads since it only works for content in the first region.
2665     // We also don&#39;t want to run it for multicolumn flow threads, since we can use our knowledge of column
2666     // geometry to actually get a better result.
2667     // The point inside a box that&#39;s inside a region has its coordinates relative to the region,
2668     // not the FragmentedFlow that is its container in the RenderObject tree.
2669     if (is&lt;RenderBox&gt;(*this) &amp;&amp; container-&gt;isOutOfFlowRenderFragmentedFlow()) {
2670         RenderFragmentContainer* startFragment = nullptr;
2671         RenderFragmentContainer* endFragment = nullptr;
2672         if (downcast&lt;RenderFragmentedFlow&gt;(*container).getFragmentRangeForBox(downcast&lt;RenderBox&gt;(this), startFragment, endFragment))
2673             container = startFragment;
2674     }
2675 
2676     container-&gt;mapAbsoluteToLocalPoint(mode, transformState);
2677 
2678     LayoutSize containerOffset = offsetFromContainer(*container, LayoutPoint());
2679 
2680     bool preserve3D = mode &amp; UseTransforms &amp;&amp; (container-&gt;style().preserves3D() || style().preserves3D());
2681     if (mode &amp; UseTransforms &amp;&amp; shouldUseTransformFromContainer(container)) {
2682         TransformationMatrix t;
2683         getTransformFromContainer(container, containerOffset, t);
2684         transformState.applyTransform(t, preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2685     } else
2686         transformState.move(containerOffset.width(), containerOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2687 }
2688 
2689 bool RenderBoxModelObject::hasRunningAcceleratedAnimations() const
2690 {
2691     if (auto* node = element()) {
2692         if (auto* timeline = node-&gt;document().existingTimeline())
2693             return timeline-&gt;runningAnimationsForElementAreAllAccelerated(*node);
2694     }
2695     return false;
2696 }
2697 
<a name="42" id="anc42"></a><span class="line-added">2698 void RenderBoxModelObject::collectAbsoluteQuadsForContinuation(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const</span>
<span class="line-added">2699 {</span>
<span class="line-added">2700     ASSERT(continuation());</span>
<span class="line-added">2701     for (auto* nextInContinuation = this-&gt;continuation(); nextInContinuation; nextInContinuation = nextInContinuation-&gt;continuation()) {</span>
<span class="line-added">2702         if (is&lt;RenderBlock&gt;(*nextInContinuation)) {</span>
<span class="line-added">2703             auto&amp; blockBox = downcast&lt;RenderBlock&gt;(*nextInContinuation);</span>
<span class="line-added">2704             // For blocks inside inlines, we include margins so that we run right up to the inline boxes</span>
<span class="line-added">2705             // above and below us (thus getting merged with them to form a single irregular shape).</span>
<span class="line-added">2706             auto logicalRect = FloatRect { 0, -blockBox.collapsedMarginBefore(), blockBox.width(),</span>
<span class="line-added">2707                 blockBox.height() + blockBox.collapsedMarginBefore() + blockBox.collapsedMarginAfter() };</span>
<span class="line-added">2708             nextInContinuation-&gt;absoluteQuadsIgnoringContinuation(logicalRect, quads, wasFixed);</span>
<span class="line-added">2709             continue;</span>
<span class="line-added">2710         }</span>
<span class="line-added">2711         nextInContinuation-&gt;absoluteQuadsIgnoringContinuation({ }, quads, wasFixed);</span>
<span class="line-added">2712     }</span>
<span class="line-added">2713 }</span>
<span class="line-added">2714 </span>
2715 } // namespace WebCore
<a name="43" id="anc43"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="43" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/MessagePort.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  *
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;MessagePort.h&quot;
 29 
 30 #include &quot;Document.h&quot;
 31 #include &quot;EventNames.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;MessageEvent.h&quot;
 34 #include &quot;MessagePortChannelProvider.h&quot;
 35 #include &quot;MessageWithMessagePorts.h&quot;
 36 #include &quot;WorkerGlobalScope.h&quot;
 37 #include &quot;WorkerThread.h&quot;
 38 #include &lt;wtf/CompletionHandler.h&gt;
 39 #include &lt;wtf/IsoMallocInlines.h&gt;
<a name="1" id="anc1"></a><span class="line-added"> 40 #include &lt;wtf/Scope.h&gt;</span>
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(MessagePort);
 45 
 46 static Lock allMessagePortsLock;
 47 static HashMap&lt;MessagePortIdentifier, MessagePort*&gt;&amp; allMessagePorts()
 48 {
 49     static NeverDestroyed&lt;HashMap&lt;MessagePortIdentifier, MessagePort*&gt;&gt; map;
 50     return map;
 51 }
 52 
 53 void MessagePort::ref() const
 54 {
 55     ++m_refCount;
 56 }
 57 
 58 void MessagePort::deref() const
 59 {
 60     // This custom deref() function ensures that as long as the lock to allMessagePortsLock is taken, no MessagePort will be destroyed.
 61     // This allows isExistingMessagePortLocallyReachable and notifyMessageAvailable to easily query the map and manipulate MessagePort instances.
 62 
 63     if (!--m_refCount) {
 64         Locker&lt;Lock&gt; locker(allMessagePortsLock);
 65 
 66         if (m_refCount)
 67             return;
 68 
 69         auto iterator = allMessagePorts().find(m_identifier);
 70         if (iterator != allMessagePorts().end() &amp;&amp; iterator-&gt;value == this)
 71             allMessagePorts().remove(iterator);
 72 
 73         delete this;
 74     }
 75 }
 76 
 77 bool MessagePort::isExistingMessagePortLocallyReachable(const MessagePortIdentifier&amp; identifier)
 78 {
 79     Locker&lt;Lock&gt; locker(allMessagePortsLock);
 80     auto* port = allMessagePorts().get(identifier);
 81     return port &amp;&amp; port-&gt;isLocallyReachable();
 82 }
 83 
 84 void MessagePort::notifyMessageAvailable(const MessagePortIdentifier&amp; identifier)
 85 {
 86     Locker&lt;Lock&gt; locker(allMessagePortsLock);
 87     if (auto* port = allMessagePorts().get(identifier))
 88         port-&gt;messageAvailable();
 89 
 90 }
 91 
 92 Ref&lt;MessagePort&gt; MessagePort::create(ScriptExecutionContext&amp; scriptExecutionContext, const MessagePortIdentifier&amp; local, const MessagePortIdentifier&amp; remote)
 93 {
 94     return adoptRef(*new MessagePort(scriptExecutionContext, local, remote));
 95 }
 96 
 97 MessagePort::MessagePort(ScriptExecutionContext&amp; scriptExecutionContext, const MessagePortIdentifier&amp; local, const MessagePortIdentifier&amp; remote)
 98     : ActiveDOMObject(&amp;scriptExecutionContext)
 99     , m_identifier(local)
100     , m_remoteIdentifier(remote)
101 {
102     LOG(MessagePorts, &quot;Created MessagePort %s (%p) in process %&quot; PRIu64, m_identifier.logString().utf8().data(), this, Process::identifier().toUInt64());
103 
104     Locker&lt;Lock&gt; locker(allMessagePortsLock);
105     allMessagePorts().set(m_identifier, this);
106 
107     m_scriptExecutionContext-&gt;createdMessagePort(*this);
108     suspendIfNeeded();
109 
110     // Don&#39;t need to call processMessageWithMessagePortsSoon() here, because the port will not be opened until start() is invoked.
111 }
112 
113 MessagePort::~MessagePort()
114 {
115     LOG(MessagePorts, &quot;Destroyed MessagePort %s (%p) in process %&quot; PRIu64, m_identifier.logString().utf8().data(), this, Process::identifier().toUInt64());
116 
117     ASSERT(allMessagePortsLock.isLocked());
118 
119     if (m_entangled)
120         close();
121 
122     if (m_scriptExecutionContext)
123         m_scriptExecutionContext-&gt;destroyedMessagePort(*this);
124 }
125 
126 void MessagePort::entangle()
127 {
<a name="2" id="anc2"></a><span class="line-modified">128     MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).entangleLocalPortInThisProcessToRemote(m_identifier, m_remoteIdentifier);</span>
129 }
130 
<a name="3" id="anc3"></a><span class="line-modified">131 ExceptionOr&lt;void&gt; MessagePort::postMessage(JSC::JSGlobalObject&amp; state, JSC::JSValue messageValue, PostMessageOptions&amp;&amp; options)</span>
132 {
133     LOG(MessagePorts, &quot;Attempting to post message to port %s (to be received by port %s)&quot;, m_identifier.logString().utf8().data(), m_remoteIdentifier.logString().utf8().data());
134 
135     registerLocalActivity();
136 
137     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<a name="4" id="anc4"></a><span class="line-modified">138     auto messageData = SerializedScriptValue::create(state, messageValue, WTFMove(options.transfer), ports);</span>
139     if (messageData.hasException())
140         return messageData.releaseException();
141 
142     if (!isEntangled())
143         return { };
144     ASSERT(m_scriptExecutionContext);
145 
146     TransferredMessagePortArray transferredPorts;
147     // Make sure we aren&#39;t connected to any of the passed-in ports.
148     if (!ports.isEmpty()) {
149         for (auto&amp; port : ports) {
150             if (port-&gt;identifier() == m_identifier || port-&gt;identifier() == m_remoteIdentifier)
151                 return Exception { DataCloneError };
152         }
153 
154         auto disentangleResult = MessagePort::disentanglePorts(WTFMove(ports));
155         if (disentangleResult.hasException())
156             return disentangleResult.releaseException();
157         transferredPorts = disentangleResult.releaseReturnValue();
158     }
159 
160     MessageWithMessagePorts message { messageData.releaseReturnValue(), WTFMove(transferredPorts) };
161 
162     LOG(MessagePorts, &quot;Actually posting message to port %s (to be received by port %s)&quot;, m_identifier.logString().utf8().data(), m_remoteIdentifier.logString().utf8().data());
163 
<a name="5" id="anc5"></a><span class="line-modified">164     MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).postMessageToRemote(WTFMove(message), m_remoteIdentifier);</span>
165     return { };
166 }
167 
168 void MessagePort::disentangle()
169 {
170     ASSERT(m_entangled);
171     m_entangled = false;
172 
173     registerLocalActivity();
174 
<a name="6" id="anc6"></a><span class="line-modified">175     MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).messagePortDisentangled(m_identifier);</span>
176 
177     // We can&#39;t receive any messages or generate any events after this, so remove ourselves from the list of active ports.
<a name="7" id="anc7"></a>
178     m_scriptExecutionContext-&gt;destroyedMessagePort(*this);
179     m_scriptExecutionContext-&gt;willDestroyActiveDOMObject(*this);
180     m_scriptExecutionContext-&gt;willDestroyDestructionObserver(*this);
181 
182     m_scriptExecutionContext = nullptr;
183 }
184 
185 void MessagePort::registerLocalActivity()
186 {
187     // Any time certain local operations happen, we dirty our own state to delay GC.
188     m_hasHadLocalActivitySinceLastCheck = true;
189     m_mightBeEligibleForGC = false;
190 }
191 
192 // Invoked to notify us that there are messages available for this port.
193 // This code may be called from another thread, and so should not call any non-threadsafe APIs (i.e. should not call into the entangled channel or access mutable variables).
194 void MessagePort::messageAvailable()
195 {
196     // This MessagePort object might be disentangled because the port is being transferred,
197     // in which case we&#39;ll notify it that messages are available once a new end point is created.
198     if (!m_scriptExecutionContext || m_scriptExecutionContext-&gt;activeDOMObjectsAreSuspended())
199         return;
200 
201     m_scriptExecutionContext-&gt;processMessageWithMessagePortsSoon();
202 }
203 
204 void MessagePort::start()
205 {
206     // Do nothing if we&#39;ve been cloned or closed.
207     if (!isEntangled())
208         return;
209 
210     registerLocalActivity();
211 
212     ASSERT(m_scriptExecutionContext);
213     if (m_started)
214         return;
215 
216     m_started = true;
217     m_scriptExecutionContext-&gt;processMessageWithMessagePortsSoon();
218 }
219 
220 void MessagePort::close()
221 {
222     m_mightBeEligibleForGC = true;
223 
224     if (m_closed)
225         return;
226     m_closed = true;
227 
<a name="8" id="anc8"></a><span class="line-modified">228     if (isMainThread())</span>
<span class="line-added">229         MessagePortChannelProvider::singleton().messagePortClosed(m_identifier);</span>
<span class="line-added">230     else {</span>
<span class="line-added">231         callOnMainThread([identifier = m_identifier] {</span>
<span class="line-added">232             MessagePortChannelProvider::singleton().messagePortClosed(identifier);</span>
<span class="line-added">233         });</span>
<span class="line-added">234     }</span>
<span class="line-added">235 </span>
236     removeAllEventListeners();
237 }
238 
239 void MessagePort::contextDestroyed()
240 {
241     ASSERT(m_scriptExecutionContext);
242 
243     close();
244     m_scriptExecutionContext = nullptr;
245 }
246 
247 void MessagePort::dispatchMessages()
248 {
249     // Messages for contexts that are not fully active get dispatched too, but JSAbstractEventListener::handleEvent() doesn&#39;t call handlers for these.
250     // The HTML5 spec specifies that any messages sent to a document that is not fully active should be dropped, so this behavior is OK.
251     ASSERT(started());
252 
253     if (!m_scriptExecutionContext || m_scriptExecutionContext-&gt;activeDOMObjectsAreSuspended() || !isEntangled())
254         return;
255 
<a name="9" id="anc9"></a><span class="line-modified">256     auto messagesTakenHandler = [this, weakThis = makeWeakPtr(this)](Vector&lt;MessageWithMessagePorts&gt;&amp;&amp; messages, Function&lt;void()&gt;&amp;&amp; completionCallback) mutable {</span>
<span class="line-modified">257         auto scopeExit = makeScopeExit(WTFMove(completionCallback));</span>

258 
<a name="10" id="anc10"></a><span class="line-modified">259         if (!weakThis)</span>
<span class="line-modified">260             return;</span>



261 
<a name="11" id="anc11"></a><span class="line-modified">262         LOG(MessagePorts, &quot;MessagePort %s (%p) dispatching %zu messages&quot;, m_identifier.logString().utf8().data(), this, messages.size());</span>
263 
<a name="12" id="anc12"></a><span class="line-modified">264         if (!m_scriptExecutionContext)</span>
<span class="line-modified">265             return;</span>
266 
<a name="13" id="anc13"></a><span class="line-modified">267         if (!messages.isEmpty())</span>
<span class="line-modified">268             registerLocalActivity();</span>
269 
<a name="14" id="anc14"></a><span class="line-modified">270         ASSERT(m_scriptExecutionContext-&gt;isContextThread());</span>
271 
<a name="15" id="anc15"></a><span class="line-modified">272         bool contextIsWorker = is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext);</span>
<span class="line-modified">273         for (auto&amp; message : messages) {</span>
<span class="line-modified">274             // close() in Worker onmessage handler should prevent next message from dispatching.</span>
<span class="line-modified">275             if (contextIsWorker &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).isClosing())</span>
<span class="line-modified">276                 return;</span>
<span class="line-modified">277             auto ports = MessagePort::entanglePorts(*m_scriptExecutionContext, WTFMove(message.transferredPorts));</span>
<span class="line-modified">278             // Per specification, each MessagePort object has a task source called the port message queue.</span>
<span class="line-modified">279             queueTaskToDispatchEvent(*this, TaskSource::PostedMessageQueue, MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));</span>






280         }
<a name="16" id="anc16"></a>





281     };
282 
<a name="17" id="anc17"></a><span class="line-modified">283     MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).takeAllMessagesForPort(m_identifier, WTFMove(messagesTakenHandler));</span>
<span class="line-added">284 }</span>
<span class="line-added">285 </span>
<span class="line-added">286 void MessagePort::dispatchEvent(Event&amp; event)</span>
<span class="line-added">287 {</span>
<span class="line-added">288     if (m_closed)</span>
<span class="line-added">289         return;</span>
<span class="line-added">290 </span>
<span class="line-added">291     if (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).isClosing())</span>
<span class="line-added">292         return;</span>
<span class="line-added">293 </span>
<span class="line-added">294     EventTarget::dispatchEvent(event);</span>
295 }
296 
297 void MessagePort::updateActivity(MessagePortChannelProvider::HasActivity hasActivity)
298 {
299     bool hasHadLocalActivity = m_hasHadLocalActivitySinceLastCheck;
300     m_hasHadLocalActivitySinceLastCheck = false;
301 
302     if (hasActivity == MessagePortChannelProvider::HasActivity::No &amp;&amp; !hasHadLocalActivity)
303         m_isRemoteEligibleForGC = true;
304 
305     if (hasActivity == MessagePortChannelProvider::HasActivity::Yes)
306         m_isRemoteEligibleForGC = false;
307 
308     m_isAskingRemoteAboutGC = false;
309 }
310 
311 bool MessagePort::hasPendingActivity() const
312 {
313     m_mightBeEligibleForGC = true;
314 
315     // If the ScriptExecutionContext has been shut down on this object close()&#39;ed, we can GC.
316     if (!m_scriptExecutionContext || m_closed)
317         return false;
318 
319     // If this object has been idle since the remote port declared itself elgibile for GC, we can GC.
320     if (!m_hasHadLocalActivitySinceLastCheck &amp;&amp; m_isRemoteEligibleForGC)
321         return false;
322 
323     // If this MessagePort has no message event handler then the existence of remote activity cannot keep it alive.
324     if (!m_hasMessageEventListener)
325         return false;
326 
327     // If we&#39;re not in the middle of asking the remote port about collectability, do so now.
328     if (!m_isAskingRemoteAboutGC) {
329         RefPtr&lt;WorkerThread&gt; workerThread;
330         if (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext))
331             workerThread = &amp;downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread();
332 
<a name="18" id="anc18"></a><span class="line-modified">333         callOnMainThread([remoteIdentifier = m_remoteIdentifier, weakThis = makeWeakPtr(const_cast&lt;MessagePort*&gt;(this)), workerThread = WTFMove(workerThread)]() mutable {</span>
<span class="line-modified">334             MessagePortChannelProvider::singleton().checkRemotePortForActivity(remoteIdentifier, [weakThis = WTFMove(weakThis), workerThread = WTFMove(workerThread)](auto hasActivity) mutable {</span>
<span class="line-modified">335                 if (!workerThread) {</span>
<span class="line-modified">336                     if (weakThis)</span>
<span class="line-modified">337                         weakThis-&gt;updateActivity(hasActivity);</span>
<span class="line-modified">338                     return;</span>
<span class="line-modified">339                 }</span>

340 
<a name="19" id="anc19"></a><span class="line-modified">341                 workerThread-&gt;runLoop().postTaskForMode([weakThis = WTFMove(weakThis), hasActivity](auto&amp;) mutable {</span>
<span class="line-modified">342                     if (weakThis)</span>
<span class="line-modified">343                         weakThis-&gt;updateActivity(hasActivity);</span>
<span class="line-modified">344                 }, WorkerRunLoop::defaultMode());</span>
<span class="line-added">345             });</span>
346         });
347         m_isAskingRemoteAboutGC = true;
348     }
349 
350     // Since we need an answer from the remote object, we have to pretend we have pending activity for now.
351     return true;
352 }
353 
354 bool MessagePort::isLocallyReachable() const
355 {
356     return !m_mightBeEligibleForGC;
357 }
358 
359 MessagePort* MessagePort::locallyEntangledPort() const
360 {
361     // FIXME: As the header describes, this is an optional optimization.
362     // Even in the new async model we should be able to get it right.
363     return nullptr;
364 }
365 
366 ExceptionOr&lt;TransferredMessagePortArray&gt; MessagePort::disentanglePorts(Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp;&amp; ports)
367 {
368     if (ports.isEmpty())
369         return TransferredMessagePortArray { };
370 
371     // Walk the incoming array - if there are any duplicate ports, or null ports or cloned ports, throw an error (per section 8.3.3 of the HTML5 spec).
372     HashSet&lt;MessagePort*&gt; portSet;
373     for (auto&amp; port : ports) {
374         if (!port || !port-&gt;m_entangled || !portSet.add(port.get()).isNewEntry)
375             return Exception { DataCloneError };
376     }
377 
378     // Passed-in ports passed validity checks, so we can disentangle them.
379     TransferredMessagePortArray portArray;
380     portArray.reserveInitialCapacity(ports.size());
381     for (auto&amp; port : ports) {
382         portArray.uncheckedAppend({ port-&gt;identifier(), port-&gt;remoteIdentifier() });
383         port-&gt;disentangle();
384     }
385 
386     return portArray;
387 }
388 
389 Vector&lt;RefPtr&lt;MessagePort&gt;&gt; MessagePort::entanglePorts(ScriptExecutionContext&amp; context, TransferredMessagePortArray&amp;&amp; transferredPorts)
390 {
391     LOG(MessagePorts, &quot;Entangling %zu transferred ports to ScriptExecutionContext %s (%p)&quot;, transferredPorts.size(), context.url().string().utf8().data(), &amp;context);
392 
393     if (transferredPorts.isEmpty())
394         return { };
395 
396     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
397     ports.reserveInitialCapacity(transferredPorts.size());
398     for (auto&amp; transferredPort : transferredPorts) {
399         auto port = MessagePort::create(context, transferredPort.first, transferredPort.second);
400         port-&gt;entangle();
401         ports.uncheckedAppend(WTFMove(port));
402     }
403     return ports;
404 }
405 
406 bool MessagePort::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
407 {
408     if (eventType == eventNames().messageEvent) {
409         if (listener-&gt;isAttribute())
410             start();
411         m_hasMessageEventListener = true;
412         registerLocalActivity();
413     }
414 
415     return EventTargetWithInlineData::addEventListener(eventType, WTFMove(listener), options);
416 }
417 
418 bool MessagePort::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
419 {
420     auto result = EventTargetWithInlineData::removeEventListener(eventType, listener, options);
421 
422     if (!hasEventListeners(eventNames().messageEvent))
423         m_hasMessageEventListener = false;
424 
425     return result;
426 }
427 
428 const char* MessagePort::activeDOMObjectName() const
429 {
430     return &quot;MessagePort&quot;;
431 }
432 
<a name="20" id="anc20"></a>




433 } // namespace WebCore
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
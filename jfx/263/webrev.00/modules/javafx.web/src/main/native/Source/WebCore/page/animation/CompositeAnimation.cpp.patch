diff a/modules/javafx.web/src/main/native/Source/WebCore/page/animation/CompositeAnimation.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/animation/CompositeAnimation.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/animation/CompositeAnimation.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/animation/CompositeAnimation.cpp
@@ -35,10 +35,11 @@
 #include "ImplicitAnimation.h"
 #include "KeyframeAnimation.h"
 #include "Logging.h"
 #include "RenderElement.h"
 #include "RenderStyle.h"
+#include "StyleAdjuster.h"
 #include <wtf/NeverDestroyed.h>
 #include <wtf/text/CString.h>
 
 namespace WebCore {
 
@@ -284,12 +285,11 @@
     // We don't do any transitions if we don't have a currentStyle (on startup).
     updateTransitions(element, currentStyle, targetStyle);
     updateKeyframeAnimations(element, currentStyle, targetStyle);
     m_keyframeAnimations.checkConsistency();
 
-    bool animationChangeRequiresRecomposite = false;
-    bool forceStackingContext = false;
+    OptionSet<AnimationImpact> imapct;
 
     std::unique_ptr<RenderStyle> animatedStyle;
 
     if (currentStyle) {
         // Now that we have transition objects ready, let them know about the new goal state.  We want them
@@ -298,15 +298,16 @@
         for (auto& transition : m_transitions.values()) {
             auto changes = transition->animate(*this, targetStyle, animatedStyle);
             if (changes.contains(AnimateChange::StyleBlended))
                 checkForStackingContext |= WillChangeData::propertyCreatesStackingContext(transition->animatingProperty());
 
-            animationChangeRequiresRecomposite = changes.contains(AnimateChange::RunningStateChange) && transition->affectsAcceleratedProperty();
+            if (changes.contains(AnimateChange::RunningStateChange) && transition->affectsAcceleratedProperty())
+                imapct.add(AnimationImpact::RequiresRecomposite);
         }
 
         if (animatedStyle && checkForStackingContext) {
-            // Note that this is similar to code in StyleResolver::adjustRenderStyle() but only needs to consult
+            // Note that this is similar to code in Style::Adjuster::adjust() but only needs to consult
             // animatable properties that can trigger stacking context.
             if (animatedStyle->opacity() < 1.0f
                 || animatedStyle->hasTransformRelatedProperty()
                 || animatedStyle->hasMask()
                 || animatedStyle->clipPath()
@@ -314,36 +315,31 @@
                 || animatedStyle->hasFilter()
 #if ENABLE(FILTERS_LEVEL_2)
                 || animatedStyle->hasBackdropFilter()
 #endif
                 )
-            forceStackingContext = true;
+            imapct.add(AnimationImpact::ForcesStackingContext);
         }
     }
 
     // Now that we have animation objects ready, let them know about the new goal state.  We want them
     // to fill in a RenderStyle*& only if needed.
     for (auto& name : m_keyframeAnimationOrderMap) {
         RefPtr<KeyframeAnimation> keyframeAnim = m_keyframeAnimations.get(name);
         if (keyframeAnim) {
             auto changes = keyframeAnim->animate(*this, targetStyle, animatedStyle);
-            animationChangeRequiresRecomposite = changes.contains(AnimateChange::RunningStateChange) && keyframeAnim->affectsAcceleratedProperty();
-            forceStackingContext |= changes.contains(AnimateChange::StyleBlended) && keyframeAnim->triggersStackingContext();
+            if (changes.contains(AnimateChange::RunningStateChange) && keyframeAnim->affectsAcceleratedProperty())
+                imapct.add(AnimationImpact::RequiresRecomposite);
+
+            if (changes.contains(AnimateChange::StyleBlended) && keyframeAnim->triggersStackingContext())
+                imapct.add(AnimationImpact::ForcesStackingContext);
+
             m_hasAnimationThatDependsOnLayout |= keyframeAnim->dependsOnLayout();
         }
     }
 
-    // https://drafts.csswg.org/css-animations-1/
-    // While an animation is applied but has not finished, or has finished but has an animation-fill-mode of forwards or both,
-    // the user agent must act as if the will-change property ([css-will-change-1]) on the element additionally
-    // includes all the properties animated by the animation.
-    if (forceStackingContext && animatedStyle) {
-        if (animatedStyle->hasAutoZIndex())
-            animatedStyle->setZIndex(0);
-    }
-
-    return { WTFMove(animatedStyle), animationChangeRequiresRecomposite };
+    return { WTFMove(animatedStyle), imapct };
 }
 
 std::unique_ptr<RenderStyle> CompositeAnimation::getAnimatedStyle() const
 {
     std::unique_ptr<RenderStyle> resultStyle;

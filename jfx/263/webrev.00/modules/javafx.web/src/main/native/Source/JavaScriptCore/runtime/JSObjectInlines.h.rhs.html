<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObjectInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<a name="1" id="anc1"></a><span class="line-modified">  4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
  5  *  Copyright (C) 2007 Eric Seidel (eric@webkit.org)
  6  *
  7  *  This library is free software; you can redistribute it and/or
  8  *  modify it under the terms of the GNU Library General Public
  9  *  License as published by the Free Software Foundation; either
 10  *  version 2 of the License, or (at your option) any later version.
 11  *
 12  *  This library is distributed in the hope that it will be useful,
 13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  *  Library General Public License for more details.
 16  *
 17  *  You should have received a copy of the GNU Library General Public License
 18  *  along with this library; see the file COPYING.LIB.  If not, write to
 19  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  *  Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #pragma once
 25 
 26 #include &quot;AuxiliaryBarrierInlines.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 27 #include &quot;ButterflyInlines.h&quot;</span>
 28 #include &quot;Error.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 29 #include &quot;JSFunction.h&quot;</span>
 30 #include &quot;JSObject.h&quot;
 31 #include &quot;JSTypedArrays.h&quot;
 32 #include &quot;Lookup.h&quot;
 33 #include &quot;StructureInlines.h&quot;
 34 #include &quot;TypedArrayType.h&quot;
 35 
 36 namespace JSC {
 37 
<a name="4" id="anc4"></a><span class="line-added"> 38 template&lt;typename CellType, SubspaceAccess&gt;</span>
<span class="line-added"> 39 CompleteSubspace* JSObject::subspaceFor(VM&amp; vm)</span>
<span class="line-added"> 40 {</span>
<span class="line-added"> 41     static_assert(!CellType::needsDestruction);</span>
<span class="line-added"> 42     return &amp;vm.cellSpace;</span>
<span class="line-added"> 43 }</span>
<span class="line-added"> 44 </span>
 45 // Section 7.3.17 of the spec.
 46 template &lt;typename AddFunction&gt; // Add function should have a type like: (JSValue, RuntimeType) -&gt; bool
<a name="5" id="anc5"></a><span class="line-modified"> 47 void createListFromArrayLike(JSGlobalObject* globalObject, JSValue arrayLikeValue, RuntimeTypeMask legalTypesFilter, const String&amp; notAnObjectErroMessage, const String&amp; illegalTypeErrorMessage, AddFunction addFunction)</span>
 48 {
<a name="6" id="anc6"></a><span class="line-modified"> 49     VM&amp; vm = getVM(globalObject);</span>
 50     auto scope = DECLARE_THROW_SCOPE(vm);
 51 
 52     if (!arrayLikeValue.isObject()) {
<a name="7" id="anc7"></a><span class="line-modified"> 53         throwTypeError(globalObject, scope, notAnObjectErroMessage);</span>
 54         return;
 55     }
 56 
 57     Vector&lt;JSValue&gt; result;
<a name="8" id="anc8"></a><span class="line-modified"> 58     JSValue lengthProperty = arrayLikeValue.get(globalObject, vm.propertyNames-&gt;length);</span>
 59     RETURN_IF_EXCEPTION(scope, void());
<a name="9" id="anc9"></a><span class="line-modified"> 60     double lengthAsDouble = lengthProperty.toLength(globalObject);</span>
 61     RETURN_IF_EXCEPTION(scope, void());
 62     RELEASE_ASSERT(lengthAsDouble &gt;= 0.0 &amp;&amp; lengthAsDouble == std::trunc(lengthAsDouble));
 63     uint64_t length = static_cast&lt;uint64_t&gt;(lengthAsDouble);
 64     for (uint64_t index = 0; index &lt; length; index++) {
<a name="10" id="anc10"></a><span class="line-modified"> 65         JSValue next = arrayLikeValue.get(globalObject, index);</span>
 66         RETURN_IF_EXCEPTION(scope, void());
 67 
 68         RuntimeType type = runtimeTypeForValue(vm, next);
 69         if (!(type &amp; legalTypesFilter)) {
<a name="11" id="anc11"></a><span class="line-modified"> 70             throwTypeError(globalObject, scope, illegalTypeErrorMessage);</span>
 71             return;
 72         }
 73 
 74         bool exitEarly = addFunction(next, type);
 75         if (exitEarly)
 76             return;
 77     }
 78 }
 79 
 80 ALWAYS_INLINE bool JSObject::canPerformFastPutInlineExcludingProto(VM&amp; vm)
 81 {
 82     // Check if there are any setters or getters in the prototype chain
 83     JSValue prototype;
 84     JSObject* obj = this;
 85     while (true) {
 86         MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
 87         if (obj-&gt;structure(vm)-&gt;hasReadOnlyOrGetterSetterPropertiesExcludingProto() || obj-&gt;methodTable(vm)-&gt;getPrototype != defaultGetPrototype)
 88             return false;
 89 
 90         prototype = obj-&gt;getPrototypeDirect(vm);
 91         if (prototype.isNull())
 92             return true;
 93 
 94         obj = asObject(prototype);
 95     }
 96 
 97     ASSERT_NOT_REACHED();
 98 }
 99 
100 ALWAYS_INLINE bool JSObject::canPerformFastPutInline(VM&amp; vm, PropertyName propertyName)
101 {
102     if (UNLIKELY(propertyName == vm.propertyNames-&gt;underscoreProto))
103         return false;
104     return canPerformFastPutInlineExcludingProto(vm);
105 }
106 
107 template&lt;typename CallbackWhenNoException&gt;
<a name="12" id="anc12"></a><span class="line-modified">108 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSObject::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, CallbackWhenNoException callback) const</span>
109 {
110     PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<a name="13" id="anc13"></a><span class="line-modified">111     return getPropertySlot(globalObject, propertyName, slot, callback);</span>
112 }
113 
114 template&lt;typename CallbackWhenNoException&gt;
<a name="14" id="anc14"></a><span class="line-modified">115 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSObject::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot, CallbackWhenNoException callback) const</span>
116 {
<a name="15" id="anc15"></a><span class="line-modified">117     VM&amp; vm = getVM(globalObject);</span>
118     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="16" id="anc16"></a><span class="line-modified">119     bool found = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
120     RETURN_IF_EXCEPTION(scope, { });
121     RELEASE_AND_RETURN(scope, callback(found, slot));
122 }
123 
<a name="17" id="anc17"></a><span class="line-modified">124 ALWAYS_INLINE bool JSObject::getPropertySlot(JSGlobalObject* globalObject, unsigned propertyName, PropertySlot&amp; slot)</span>
125 {
<a name="18" id="anc18"></a><span class="line-modified">126     VM&amp; vm = getVM(globalObject);</span>
127     auto scope = DECLARE_THROW_SCOPE(vm);
128     auto&amp; structureIDTable = vm.heap.structureIDTable();
129     JSObject* object = this;
130     MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
131     while (true) {
132         Structure* structure = structureIDTable.get(object-&gt;structureID());
<a name="19" id="anc19"></a><span class="line-modified">133         bool hasSlot = structure-&gt;classInfo()-&gt;methodTable.getOwnPropertySlotByIndex(object, globalObject, propertyName, slot);</span>
134         RETURN_IF_EXCEPTION(scope, false);
135         if (hasSlot)
136             return true;
<a name="20" id="anc20"></a><span class="line-added">137         if (object-&gt;type() == ProxyObjectType &amp;&amp; slot.internalMethodType() == PropertySlot::InternalMethodType::HasProperty)</span>
<span class="line-added">138             return false;</span>
139         JSValue prototype;
140         if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype || slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry))
141             prototype = object-&gt;getPrototypeDirect(vm);
142         else {
<a name="21" id="anc21"></a><span class="line-modified">143             prototype = object-&gt;getPrototype(vm, globalObject);</span>
144             RETURN_IF_EXCEPTION(scope, false);
145         }
146         if (!prototype.isObject())
147             return false;
148         object = asObject(prototype);
149     }
150 }
151 
<a name="22" id="anc22"></a><span class="line-modified">152 ALWAYS_INLINE bool JSObject::getNonIndexPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
153 {
154     // This method only supports non-index PropertyNames.
155     ASSERT(!parseIndex(propertyName));
156 
<a name="23" id="anc23"></a><span class="line-modified">157     VM&amp; vm = getVM(globalObject);</span>
158     auto scope = DECLARE_THROW_SCOPE(vm);
159     auto&amp; structureIDTable = vm.heap.structureIDTable();
160     JSObject* object = this;
161     MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
162     while (true) {
163         Structure* structure = structureIDTable.get(object-&gt;structureID());
164         if (LIKELY(!TypeInfo::overridesGetOwnPropertySlot(object-&gt;inlineTypeFlags()))) {
165             if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
166                 return true;
167         } else {
<a name="24" id="anc24"></a><span class="line-modified">168             bool hasSlot = structure-&gt;classInfo()-&gt;methodTable.getOwnPropertySlot(object, globalObject, propertyName, slot);</span>
169             RETURN_IF_EXCEPTION(scope, false);
170             if (hasSlot)
171                 return true;
<a name="25" id="anc25"></a><span class="line-added">172             if (object-&gt;type() == ProxyObjectType &amp;&amp; slot.internalMethodType() == PropertySlot::InternalMethodType::HasProperty)</span>
<span class="line-added">173                 return false;</span>
174         }
175         JSValue prototype;
176         if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype || slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry))
177             prototype = object-&gt;getPrototypeDirect(vm);
178         else {
<a name="26" id="anc26"></a><span class="line-modified">179             prototype = object-&gt;getPrototype(vm, globalObject);</span>
180             RETURN_IF_EXCEPTION(scope, false);
181         }
182         if (!prototype.isObject())
183             return false;
184         object = asObject(prototype);
185     }
186 }
187 
<a name="27" id="anc27"></a><span class="line-modified">188 inline bool JSObject::getOwnPropertySlotInline(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
189 {
<a name="28" id="anc28"></a><span class="line-modified">190     VM&amp; vm = getVM(globalObject);</span>
191     if (UNLIKELY(TypeInfo::overridesGetOwnPropertySlot(inlineTypeFlags())))
<a name="29" id="anc29"></a><span class="line-modified">192         return methodTable(vm)-&gt;getOwnPropertySlot(this, globalObject, propertyName, slot);</span>
<span class="line-modified">193     return JSObject::getOwnPropertySlot(this, globalObject, propertyName, slot);</span>
194 }
195 
196 inline bool JSObject::mayInterceptIndexedAccesses(VM&amp; vm)
197 {
198     return structure(vm)-&gt;mayInterceptIndexedAccesses();
199 }
200 
201 inline void JSObject::putDirectWithoutTransition(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes)
202 {
203     ASSERT(!value.isGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::Accessor));
204     ASSERT(!value.isCustomGetterSetter());
205     StructureID structureID = this-&gt;structureID();
206     Structure* structure = vm.heap.structureIDTable().get(structureID);
207     PropertyOffset offset = prepareToPutDirectWithoutTransition(vm, propertyName, attributes, structureID, structure);
208     putDirect(vm, offset, value);
209     if (attributes &amp; PropertyAttribute::ReadOnly)
210         structure-&gt;setContainsReadOnlyProperties();
211 }
212 
213 ALWAYS_INLINE PropertyOffset JSObject::prepareToPutDirectWithoutTransition(VM&amp; vm, PropertyName propertyName, unsigned attributes, StructureID structureID, Structure* structure)
214 {
215     unsigned oldOutOfLineCapacity = structure-&gt;outOfLineCapacity();
216     PropertyOffset result;
217     structure-&gt;addPropertyWithoutTransition(
218         vm, propertyName, attributes,
<a name="30" id="anc30"></a><span class="line-modified">219         [&amp;] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset offset, PropertyOffset newMaxOffset) {</span>
<span class="line-modified">220             unsigned newOutOfLineCapacity = Structure::outOfLineCapacity(newMaxOffset);</span>
221             if (newOutOfLineCapacity != oldOutOfLineCapacity) {
222                 Butterfly* butterfly = allocateMoreOutOfLineStorage(vm, oldOutOfLineCapacity, newOutOfLineCapacity);
223                 nukeStructureAndSetButterfly(vm, structureID, butterfly);
<a name="31" id="anc31"></a><span class="line-modified">224                 structure-&gt;setMaxOffset(vm, newMaxOffset);</span>
225                 WTF::storeStoreFence();
226                 setStructureIDDirectly(structureID);
227             } else
<a name="32" id="anc32"></a><span class="line-modified">228                 structure-&gt;setMaxOffset(vm, newMaxOffset);</span>
229 
230             // This assertion verifies that the concurrent GC won&#39;t read garbage if the concurrentGC
231             // is running at the same time we put without transitioning.
232             ASSERT(!getDirect(offset) || !JSValue::encode(getDirect(offset)));
233             result = offset;
234         });
235     return result;
236 }
237 
238 // ECMA 8.6.2.2
<a name="33" id="anc33"></a><span class="line-modified">239 ALWAYS_INLINE bool JSObject::putInlineForJSObject(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
240 {
<a name="34" id="anc34"></a><span class="line-modified">241     VM&amp; vm = getVM(globalObject);</span>
242     auto scope = DECLARE_THROW_SCOPE(vm);
243 
244     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
245     ASSERT(value);
246     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(thisObject));
247 
248     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<a name="35" id="anc35"></a><span class="line-modified">249         RELEASE_AND_RETURN(scope, ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
250 
251     // Try indexed put first. This is required for correctness, since loads on property names that appear like
252     // valid indices will never look in the named property storage.
253     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<a name="36" id="anc36"></a><span class="line-modified">254         RELEASE_AND_RETURN(scope, putByIndex(thisObject, globalObject, index.value(), value, slot.isStrictMode()));</span>
255 
256     if (thisObject-&gt;canPerformFastPutInline(vm, propertyName)) {
257         ASSERT(!thisObject-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName));
258         if (!thisObject-&gt;putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot))
<a name="37" id="anc37"></a><span class="line-modified">259             return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
260         return true;
261     }
262 
<a name="38" id="anc38"></a><span class="line-modified">263     RELEASE_AND_RETURN(scope, thisObject-&gt;putInlineSlow(globalObject, propertyName, value, slot));</span>
264 }
265 
266 // HasOwnProperty(O, P) from section 7.3.11 in the spec.
267 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasownproperty
<a name="39" id="anc39"></a><span class="line-modified">268 ALWAYS_INLINE bool JSObject::hasOwnProperty(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot) const</span>
269 {
<a name="40" id="anc40"></a><span class="line-modified">270     VM&amp; vm = getVM(globalObject);</span>
271     ASSERT(slot.internalMethodType() == PropertySlot::InternalMethodType::GetOwnProperty);
272     if (LIKELY(const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(vm)-&gt;getOwnPropertySlot == JSObject::getOwnPropertySlot))
<a name="41" id="anc41"></a><span class="line-modified">273         return JSObject::getOwnPropertySlot(const_cast&lt;JSObject*&gt;(this), globalObject, propertyName, slot);</span>
<span class="line-modified">274     return const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(vm)-&gt;getOwnPropertySlot(const_cast&lt;JSObject*&gt;(this), globalObject, propertyName, slot);</span>
275 }
276 
<a name="42" id="anc42"></a><span class="line-modified">277 ALWAYS_INLINE bool JSObject::hasOwnProperty(JSGlobalObject* globalObject, PropertyName propertyName) const</span>
278 {
279     PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<a name="43" id="anc43"></a><span class="line-modified">280     return hasOwnProperty(globalObject, propertyName, slot);</span>
281 }
282 
<a name="44" id="anc44"></a><span class="line-modified">283 ALWAYS_INLINE bool JSObject::hasOwnProperty(JSGlobalObject* globalObject, unsigned propertyName) const</span>
284 {
285     PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<a name="45" id="anc45"></a><span class="line-modified">286     return const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(getVM(globalObject))-&gt;getOwnPropertySlotByIndex(const_cast&lt;JSObject*&gt;(this), globalObject, propertyName, slot);</span>
287 }
288 
289 template&lt;JSObject::PutMode mode&gt;
290 ALWAYS_INLINE bool JSObject::putDirectInternal(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes, PutPropertySlot&amp; slot)
291 {
292     ASSERT(value);
293     ASSERT(value.isGetterSetter() == !!(attributes &amp; PropertyAttribute::Accessor));
294     ASSERT(value.isCustomGetterSetter() == !!(attributes &amp; PropertyAttribute::CustomAccessorOrValue));
295     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));
296     ASSERT(!parseIndex(propertyName));
297 
298     StructureID structureID = this-&gt;structureID();
299     Structure* structure = vm.heap.structureIDTable().get(structureID);
300     if (structure-&gt;isDictionary()) {
301         ASSERT(!isCopyOnWrite(indexingMode()));
302 
303         unsigned currentAttributes;
304         PropertyOffset offset = structure-&gt;get(vm, propertyName, currentAttributes);
305         if (offset != invalidOffset) {
306             if ((mode == PutModePut) &amp;&amp; currentAttributes &amp; PropertyAttribute::ReadOnly)
307                 return false;
308 
309             putDirect(vm, offset, value);
310             structure-&gt;didReplaceProperty(offset);
311 
312             if ((attributes &amp; PropertyAttribute::Accessor) != (currentAttributes &amp; PropertyAttribute::Accessor) || (attributes &amp; PropertyAttribute::CustomAccessorOrValue) != (currentAttributes &amp; PropertyAttribute::CustomAccessorOrValue)) {
313                 ASSERT(!(attributes &amp; PropertyAttribute::ReadOnly));
314                 setStructure(vm, Structure::attributeChangeTransition(vm, structure, propertyName, attributes));
315             } else
316                 slot.setExistingProperty(this, offset);
317 
318             return true;
319         }
320 
321         if ((mode == PutModePut) &amp;&amp; !isStructureExtensible(vm))
322             return false;
323 
324         offset = prepareToPutDirectWithoutTransition(vm, propertyName, attributes, structureID, structure);
325         validateOffset(offset);
326         putDirect(vm, offset, value);
327         slot.setNewProperty(this, offset);
328         if (attributes &amp; PropertyAttribute::ReadOnly)
329             this-&gt;structure(vm)-&gt;setContainsReadOnlyProperties();
330         return true;
331     }
332 
333     PropertyOffset offset;
334     size_t currentCapacity = this-&gt;structure(vm)-&gt;outOfLineCapacity();
335     Structure* newStructure = Structure::addPropertyTransitionToExistingStructure(
336         structure, propertyName, attributes, offset);
337     if (newStructure) {
338         Butterfly* newButterfly = butterfly();
339         if (currentCapacity != newStructure-&gt;outOfLineCapacity()) {
340             ASSERT(newStructure != this-&gt;structure(vm));
341             newButterfly = allocateMoreOutOfLineStorage(vm, currentCapacity, newStructure-&gt;outOfLineCapacity());
342             nukeStructureAndSetButterfly(vm, structureID, newButterfly);
343         }
344 
345         validateOffset(offset);
346         ASSERT(newStructure-&gt;isValidOffset(offset));
347 
348         // This assertion verifies that the concurrent GC won&#39;t read garbage if the concurrentGC
349         // is running at the same time we put without transitioning.
350         ASSERT(!getDirect(offset) || !JSValue::encode(getDirect(offset)));
351         putDirect(vm, offset, value);
352         setStructure(vm, newStructure);
353         slot.setNewProperty(this, offset);
354         return true;
355     }
356 
357     unsigned currentAttributes;
358     offset = structure-&gt;get(vm, propertyName, currentAttributes);
359     if (offset != invalidOffset) {
360         if ((mode == PutModePut) &amp;&amp; currentAttributes &amp; PropertyAttribute::ReadOnly)
361             return false;
362 
363         structure-&gt;didReplaceProperty(offset);
364         putDirect(vm, offset, value);
365 
366         if ((attributes &amp; PropertyAttribute::Accessor) != (currentAttributes &amp; PropertyAttribute::Accessor) || (attributes &amp; PropertyAttribute::CustomAccessorOrValue) != (currentAttributes &amp; PropertyAttribute::CustomAccessorOrValue)) {
367             ASSERT(!(attributes &amp; PropertyAttribute::ReadOnly));
368             setStructure(vm, Structure::attributeChangeTransition(vm, structure, propertyName, attributes));
369         } else
370             slot.setExistingProperty(this, offset);
371 
372         return true;
373     }
374 
375     if ((mode == PutModePut) &amp;&amp; !isStructureExtensible(vm))
376         return false;
377 
378     // We want the structure transition watchpoint to fire after this object has switched
379     // structure. This allows adaptive watchpoints to observe if the new structure is the one
380     // we want.
381     DeferredStructureTransitionWatchpointFire deferredWatchpointFire(vm, structure);
382 
383     newStructure = Structure::addNewPropertyTransition(
384         vm, structure, propertyName, attributes, offset, slot.context(), &amp;deferredWatchpointFire);
385 
386     validateOffset(offset);
387     ASSERT(newStructure-&gt;isValidOffset(offset));
388     size_t oldCapacity = structure-&gt;outOfLineCapacity();
389     size_t newCapacity = newStructure-&gt;outOfLineCapacity();
390     ASSERT(oldCapacity &lt;= newCapacity);
391     if (oldCapacity != newCapacity) {
392         Butterfly* newButterfly = allocateMoreOutOfLineStorage(vm, oldCapacity, newCapacity);
393         nukeStructureAndSetButterfly(vm, structureID, newButterfly);
394     }
395 
396     // This assertion verifies that the concurrent GC won&#39;t read garbage if the concurrentGC
397     // is running at the same time we put without transitioning.
398     ASSERT(!getDirect(offset) || !JSValue::encode(getDirect(offset)));
399     putDirect(vm, offset, value);
400     setStructure(vm, newStructure);
401     slot.setNewProperty(this, offset);
402     if (attributes &amp; PropertyAttribute::ReadOnly)
403         newStructure-&gt;setContainsReadOnlyProperties();
404     return true;
405 }
406 
407 inline bool JSObject::mayBePrototype() const
408 {
409     return perCellBit();
410 }
411 
412 inline void JSObject::didBecomePrototype()
413 {
414     setPerCellBit(true);
415 }
416 
417 inline bool JSObject::canGetIndexQuicklyForTypedArray(unsigned i) const
418 {
419     switch (type()) {
420 #define CASE_TYPED_ARRAY_TYPE(name) \
421     case name ## ArrayType :\
422         return jsCast&lt;const JS ## name ## Array *&gt;(this)-&gt;canGetIndexQuickly(i);
423         FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(CASE_TYPED_ARRAY_TYPE)
424 #undef CASE_TYPED_ARRAY_TYPE
425     default:
426         return false;
427     }
428 }
429 
430 inline bool JSObject::canSetIndexQuicklyForTypedArray(unsigned i, JSValue value) const
431 {
432     switch (type()) {
433 #define CASE_TYPED_ARRAY_TYPE(name) \
434     case name ## ArrayType :\
435         return jsCast&lt;const JS ## name ## Array *&gt;(this)-&gt;canSetIndexQuickly(i, value);
436         FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(CASE_TYPED_ARRAY_TYPE)
437 #undef CASE_TYPED_ARRAY_TYPE
438     default:
439         return false;
440     }
441 }
442 
443 inline JSValue JSObject::getIndexQuicklyForTypedArray(unsigned i) const
444 {
445     switch (type()) {
446 #define CASE_TYPED_ARRAY_TYPE(name) \
447     case name ## ArrayType : {\
448         auto* typedArray = jsCast&lt;const JS ## name ## Array *&gt;(this);\
449         RELEASE_ASSERT(typedArray-&gt;canGetIndexQuickly(i));\
450         return typedArray-&gt;getIndexQuickly(i);\
451     }
452         FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(CASE_TYPED_ARRAY_TYPE)
453 #undef CASE_TYPED_ARRAY_TYPE
454     default:
455         RELEASE_ASSERT_NOT_REACHED();
456         return JSValue();
457     }
458 }
459 
460 inline void JSObject::setIndexQuicklyForTypedArray(unsigned i, JSValue value)
461 {
462     switch (type()) {
463 #define CASE_TYPED_ARRAY_TYPE(name) \
464     case name ## ArrayType : {\
465         auto* typedArray = jsCast&lt;JS ## name ## Array *&gt;(this);\
466         RELEASE_ASSERT(typedArray-&gt;canSetIndexQuickly(i, value));\
467         typedArray-&gt;setIndexQuickly(i, value);\
468         break;\
469     }
470         FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(CASE_TYPED_ARRAY_TYPE)
471 #undef CASE_TYPED_ARRAY_TYPE
472     default:
473         RELEASE_ASSERT_NOT_REACHED();
474         return;
475     }
476 }
477 
<a name="46" id="anc46"></a><span class="line-added">478 inline void JSObject::validatePutOwnDataProperty(VM&amp; vm, PropertyName propertyName, JSValue value)</span>
<span class="line-added">479 {</span>
<span class="line-added">480 #if ASSERT_ENABLED</span>
<span class="line-added">481     ASSERT(value);</span>
<span class="line-added">482     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));</span>
<span class="line-added">483     unsigned attributes;</span>
<span class="line-added">484     PropertyOffset offset = structure(vm)-&gt;get(vm, propertyName, attributes);</span>
<span class="line-added">485     if (isValidOffset(offset))</span>
<span class="line-added">486         ASSERT(!(attributes &amp; (PropertyAttribute::Accessor | PropertyAttribute::CustomAccessor | PropertyAttribute::ReadOnly)));</span>
<span class="line-added">487     else if (TypeInfo::hasStaticPropertyTable(inlineTypeFlags())) {</span>
<span class="line-added">488         if (auto entry = findPropertyHashEntry(vm, propertyName))</span>
<span class="line-added">489             ASSERT(!(entry-&gt;value-&gt;attributes() &amp; (PropertyAttribute::Accessor | PropertyAttribute::CustomAccessor | PropertyAttribute::ReadOnly)));</span>
<span class="line-added">490     }</span>
<span class="line-added">491 #else // not ASSERT_ENABLED</span>
<span class="line-added">492     UNUSED_PARAM(vm);</span>
<span class="line-added">493     UNUSED_PARAM(propertyName);</span>
<span class="line-added">494     UNUSED_PARAM(value);</span>
<span class="line-added">495 #endif // not ASSERT_ENABLED</span>
<span class="line-added">496 }</span>
<span class="line-added">497 </span>
<span class="line-added">498 inline bool JSObject::putOwnDataProperty(VM&amp; vm, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="line-added">499 {</span>
<span class="line-added">500     validatePutOwnDataProperty(vm, propertyName, value);</span>
<span class="line-added">501     return putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot);</span>
<span class="line-added">502 }</span>
<span class="line-added">503 </span>
<span class="line-added">504 inline bool JSObject::putOwnDataPropertyMayBeIndex(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="line-added">505 {</span>
<span class="line-added">506     VM&amp; vm = getVM(globalObject);</span>
<span class="line-added">507     validatePutOwnDataProperty(vm, propertyName, value);</span>
<span class="line-added">508     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))</span>
<span class="line-added">509         return putDirectIndex(globalObject, index.value(), value, 0, PutDirectIndexLikePutDirect);</span>
<span class="line-added">510 </span>
<span class="line-added">511     return putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot);</span>
<span class="line-added">512 }</span>
<span class="line-added">513 </span>
<span class="line-added">514 inline CallType getCallData(VM&amp; vm, JSValue value, CallData&amp; callData)</span>
<span class="line-added">515 {</span>
<span class="line-added">516     if (!value.isCell())</span>
<span class="line-added">517         return CallType::None;</span>
<span class="line-added">518     JSCell* cell = value.asCell();</span>
<span class="line-added">519     if (cell-&gt;type() == JSFunctionType)</span>
<span class="line-added">520         return JSFunction::getCallData(cell, callData);</span>
<span class="line-added">521     CallType result = cell-&gt;methodTable(vm)-&gt;getCallData(cell, callData);</span>
<span class="line-added">522     ASSERT(result == CallType::None || value.isValidCallee());</span>
<span class="line-added">523     return result;</span>
<span class="line-added">524 }</span>
<span class="line-added">525 </span>
<span class="line-added">526 inline ConstructType getConstructData(VM&amp; vm, JSValue value, ConstructData&amp; constructData)</span>
<span class="line-added">527 {</span>
<span class="line-added">528     if (!value.isCell())</span>
<span class="line-added">529         return ConstructType::None;</span>
<span class="line-added">530     JSCell* cell = value.asCell();</span>
<span class="line-added">531     if (cell-&gt;type() == JSFunctionType)</span>
<span class="line-added">532         return JSFunction::getConstructData(cell, constructData);</span>
<span class="line-added">533     ConstructType result = cell-&gt;methodTable(vm)-&gt;getConstructData(cell, constructData);</span>
<span class="line-added">534     ASSERT(result == ConstructType::None || value.isValidCallee());</span>
<span class="line-added">535     return result;</span>
<span class="line-added">536 }</span>
537 
538 } // namespace JSC
<a name="47" id="anc47"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="47" type="hidden" />
</body>
</html>
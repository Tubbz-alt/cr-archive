<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableFormattingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../layouttree/LayoutTreeBuilder.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TableFormattingContext.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableFormattingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,90 ***</span>
  #include &quot;config.h&quot;
  #include &quot;TableFormattingContext.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
  #include &quot;LayoutBox.h&quot;
  #include &quot;TableFormattingState.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  
  namespace WebCore {
  namespace Layout {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(TableFormattingContext);
  
  // https://www.w3.org/TR/css-tables-3/#table-layout-algorithm
<span class="line-modified">! TableFormattingContext::TableFormattingContext(const Box&amp; formattingContextRoot, TableFormattingState&amp; formattingState)</span>
      : FormattingContext(formattingContextRoot, formattingState)
  {
  }
  
<span class="line-modified">! void TableFormattingContext::layout() const</span>
  {
      auto&amp; grid = formattingState().tableGrid();
      auto&amp; cellList = grid.cells();
      ASSERT(!cellList.isEmpty());
<span class="line-removed">-     // Layout and position each table cell (and compute row height as well).</span>
<span class="line-removed">-     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-removed">-     auto&amp; columnList = grid.columnsContext().columns();</span>
<span class="line-removed">-     auto&amp; rowList = grid.rows();</span>
      for (auto&amp; cell : cellList) {
          auto&amp; cellLayoutBox = cell-&gt;tableCellBox;
<span class="line-modified">!         ASSERT(cellLayoutBox.establishesBlockFormattingContext());</span>
<span class="line-modified">! </span>
<span class="line-modified">!         auto&amp; cellDisplayBox = layoutState.displayBoxForLayoutBox(cellLayoutBox);</span>
<span class="line-modified">!         // FIXME: Add support for column and row spanning.</span>
<span class="line-modified">!         auto cellPosition = cell-&gt;position;</span>
<span class="line-modified">!         auto&amp; row = rowList.at(cellPosition.y());</span>
<span class="line-modified">!         auto&amp; column = columnList.at(cellPosition.x());</span>
<span class="line-modified">!         cellDisplayBox.setContentBoxWidth(column.logicalWidth());</span>
<span class="line-modified">!         // FIXME: Do not use blanks.</span>
<span class="line-modified">!         cellDisplayBox.setBorder({ });</span>
<span class="line-modified">!         cellDisplayBox.setPadding({ });</span>
<span class="line-modified">!         cellDisplayBox.setHorizontalMargin({ });</span>
<span class="line-modified">!         cellDisplayBox.setHorizontalComputedMargin({ });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         cellDisplayBox.setTopLeft({ column.logicalLeft(), row.logicalTop() });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         layoutState.createFormattingContext(cellLayoutBox)-&gt;layout();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // FIXME: This requires a 2 pass layout.</span>
<span class="line-modified">!         auto heightAndMargin = Geometry::tableCellHeightAndMargin(layoutState, cellLayoutBox);</span>
<span class="line-modified">!         cellDisplayBox.setContentBoxHeight(heightAndMargin.height);</span>
<span class="line-modified">!         cellDisplayBox.setVerticalMargin({ heightAndMargin.nonCollapsedMargin, { } });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         row.setLogicalHeight(std::max(row.logicalHeight(), heightAndMargin.height));</span>
<span class="line-modified">!         // FIXME: This also requires spanning support/check.</span>
<span class="line-modified">!         if (!cellPosition.x() &amp;&amp; cellPosition.y()) {</span>
<span class="line-modified">!             auto&amp; previousRow = rowList.at(cellPosition.y() - 1);</span>
<span class="line-modified">!             row.setLogicalTop(previousRow.logicalBottom());</span>
<span class="line-modified">!         }</span>
      }
  }
  
<span class="line-modified">! FormattingContext::IntrinsicWidthConstraints TableFormattingContext::computedIntrinsicWidthConstraints() const</span>
  {
      // Tables have a slighty different concept of shrink to fit. It&#39;s really only different with non-auto &quot;width&quot; values, where
      // a generic shrink-to fit block level box like a float box would be just sized to the computed value of &quot;width&quot;, tables
      // can actually be streched way over.
<span class="line-modified">! </span>
<span class="line-modified">!     // 1. Ensure each cell slot is occupied by at least one cell.</span>
<span class="line-modified">!     ensureTableGrid();</span>
<span class="line-modified">!     // 2. Compute the minimum width of each column.</span>
<span class="line-modified">!     computePreferredWidthForColumns();</span>
<span class="line-modified">!     // 3. Compute the width of the table.</span>
<span class="line-modified">!     auto width = computedTableWidth();</span>
<span class="line-modified">!     // This is the actual computed table width that we want to present as min/max width.</span>
<span class="line-removed">-     return { width, width };</span>
  }
  
<span class="line-modified">! void TableFormattingContext::ensureTableGrid() const</span>
  {
<span class="line-modified">!     auto&amp; tableWrapperBox = downcast&lt;Container&gt;(root());</span>
      auto&amp; tableGrid = formattingState().tableGrid();
  
<span class="line-modified">!     for (auto* section = tableWrapperBox.firstChild(); section; section = section-&gt;nextSibling()) {</span>
          ASSERT(section-&gt;isTableHeader() || section-&gt;isTableBody() || section-&gt;isTableFooter());
          for (auto* row = downcast&lt;Container&gt;(*section).firstChild(); row; row = row-&gt;nextSibling()) {
              ASSERT(row-&gt;isTableRow());
              for (auto* cell = downcast&lt;Container&gt;(*row).firstChild(); cell; cell = cell-&gt;nextSibling()) {
                  ASSERT(cell-&gt;isTableCell());
<span class="line-new-header">--- 26,189 ---</span>
  #include &quot;config.h&quot;
  #include &quot;TableFormattingContext.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
<span class="line-added">+ #include &quot;DisplayBox.h&quot;</span>
<span class="line-added">+ #include &quot;InvalidationState.h&quot;</span>
  #include &quot;LayoutBox.h&quot;
<span class="line-added">+ #include &quot;LayoutChildIterator.h&quot;</span>
<span class="line-added">+ #include &quot;LayoutContext.h&quot;</span>
  #include &quot;TableFormattingState.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  
  namespace WebCore {
  namespace Layout {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(TableFormattingContext);
  
<span class="line-added">+ // FIXME: This is temporary. Remove this function when table formatting is complete.</span>
<span class="line-added">+ void TableFormattingContext::initializeDisplayBoxToBlank(Display::Box&amp; displayBox) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     displayBox.setBorder({ });</span>
<span class="line-added">+     displayBox.setPadding({ });</span>
<span class="line-added">+     displayBox.setHorizontalMargin({ });</span>
<span class="line-added">+     displayBox.setHorizontalComputedMargin({ });</span>
<span class="line-added">+     displayBox.setVerticalMargin({ { }, { } });</span>
<span class="line-added">+     displayBox.setTopLeft({ });</span>
<span class="line-added">+     displayBox.setContentBoxWidth({ });</span>
<span class="line-added">+     displayBox.setContentBoxHeight({ });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // https://www.w3.org/TR/css-tables-3/#table-layout-algorithm
<span class="line-modified">! TableFormattingContext::TableFormattingContext(const Container&amp; formattingContextRoot, TableFormattingState&amp; formattingState)</span>
      : FormattingContext(formattingContextRoot, formattingState)
  {
  }
  
<span class="line-modified">! void TableFormattingContext::layoutInFlowContent(InvalidationState&amp; invalidationState, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp;)</span>
  {
      auto&amp; grid = formattingState().tableGrid();
<span class="line-added">+     auto&amp; columnsContext = grid.columnsContext();</span>
<span class="line-added">+ </span>
<span class="line-added">+     computeAndDistributeExtraHorizontalSpace();</span>
<span class="line-added">+     // 1. Position each column.</span>
<span class="line-added">+     // FIXME: This should also deal with collapsing borders etc.</span>
<span class="line-added">+     auto horizontalSpacing = grid.horizontalSpacing();</span>
<span class="line-added">+     auto columnLogicalLeft = horizontalSpacing;</span>
<span class="line-added">+     for (auto&amp; column : columnsContext.columns()) {</span>
<span class="line-added">+         column.setLogicalLeft(columnLogicalLeft);</span>
<span class="line-added">+         columnLogicalLeft += (column.logicalWidth() + horizontalSpacing);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // 2. Layout each table cell (and compute row height as well).</span>
<span class="line-added">+     auto&amp; columnList = columnsContext.columns();</span>
      auto&amp; cellList = grid.cells();
      ASSERT(!cellList.isEmpty());
      for (auto&amp; cell : cellList) {
          auto&amp; cellLayoutBox = cell-&gt;tableCellBox;
<span class="line-modified">!         layoutTableCellBox(cellLayoutBox, columnList.at(cell-&gt;position.x()), invalidationState, horizontalConstraints);</span>
<span class="line-modified">!         // FIXME: Add support for column and row spanning and this requires a 2 pass layout.</span>
<span class="line-modified">!         auto&amp; row = grid.rows().at(cell-&gt;position.y());</span>
<span class="line-modified">!         row.setLogicalHeight(std::max(row.logicalHeight(), geometryForBox(cellLayoutBox).marginBoxHeight()));</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     // This is after the second pass when cell heights are fully computed.</span>
<span class="line-modified">!     auto rowLogicalTop = grid.verticalSpacing();</span>
<span class="line-modified">!     for (auto&amp; row : grid.rows()) {</span>
<span class="line-modified">!         row.setLogicalTop(rowLogicalTop);</span>
<span class="line-modified">!         rowLogicalTop += (row.logicalHeight() + grid.verticalSpacing());</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // 3. Finalize size and position.</span>
<span class="line-modified">!     positionTableCells();</span>
<span class="line-modified">!     setComputedGeometryForSections();</span>
<span class="line-modified">!     setComputedGeometryForRows();</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void TableFormattingContext::layoutTableCellBox(const Box&amp; cellLayoutBox, const TableGrid::Column&amp; column, InvalidationState&amp; invalidationState, const HorizontalConstraints&amp; horizontalConstraints)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     computeBorderAndPadding(cellLayoutBox, horizontalConstraints);</span>
<span class="line-modified">!     // Margins do not apply to internal table elements.</span>
<span class="line-modified">!     auto&amp; cellDisplayBox = formattingState().displayBox(cellLayoutBox);</span>
<span class="line-modified">!     cellDisplayBox.setHorizontalMargin({ });</span>
<span class="line-modified">!     cellDisplayBox.setHorizontalComputedMargin({ });</span>
<span class="line-modified">!     // Don&#39;t know the actual position yet.</span>
<span class="line-modified">!     cellDisplayBox.setTopLeft({ });</span>
<span class="line-modified">!     cellDisplayBox.setContentBoxWidth(column.logicalWidth() - cellDisplayBox.horizontalMarginBorderAndPadding());</span>
<span class="line-modified">! </span>
<span class="line-added">+     ASSERT(cellLayoutBox.establishesBlockFormattingContext());</span>
<span class="line-added">+     if (is&lt;Container&gt;(cellLayoutBox) &amp;&amp; downcast&lt;Container&gt;(cellLayoutBox).hasInFlowOrFloatingChild())</span>
<span class="line-added">+         LayoutContext::createFormattingContext(downcast&lt;Container&gt;(cellLayoutBox), layoutState())-&gt;layoutInFlowContent(invalidationState, Geometry::horizontalConstraintsForInFlow(cellDisplayBox), Geometry::verticalConstraintsForInFlow(cellDisplayBox));</span>
<span class="line-added">+     cellDisplayBox.setVerticalMargin({ { }, { } });</span>
<span class="line-added">+     cellDisplayBox.setContentBoxHeight(geometry().tableCellHeightAndMargin(cellLayoutBox).contentHeight);</span>
<span class="line-added">+     // FIXME: Check what to do with out-of-flow content.</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void TableFormattingContext::positionTableCells()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-added">+     auto&amp; rowList = grid.rows();</span>
<span class="line-added">+     auto&amp; columnList = grid.columnsContext().columns();</span>
<span class="line-added">+     for (auto&amp; cell : grid.cells()) {</span>
<span class="line-added">+         auto&amp; cellDisplayBox = formattingState().displayBox(cell-&gt;tableCellBox);</span>
<span class="line-added">+         cellDisplayBox.setTop(rowList.at(cell-&gt;position.y()).logicalTop());</span>
<span class="line-added">+         cellDisplayBox.setLeft(columnList.at(cell-&gt;position.x()).logicalLeft());</span>
      }
  }
  
<span class="line-modified">! void TableFormattingContext::setComputedGeometryForRows()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-added">+     auto rowWidth = grid.columnsContext().logicalWidth() + 2 * grid.horizontalSpacing();</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; rowList = grid.rows();</span>
<span class="line-added">+     for (auto&amp; row : rowList) {</span>
<span class="line-added">+         auto&amp; rowDisplayBox = formattingState().displayBox(row.box());</span>
<span class="line-added">+         initializeDisplayBoxToBlank(rowDisplayBox);</span>
<span class="line-added">+         rowDisplayBox.setContentBoxHeight(row.logicalHeight());</span>
<span class="line-added">+         rowDisplayBox.setContentBoxWidth(rowWidth);</span>
<span class="line-added">+         rowDisplayBox.setTop(row.logicalTop());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void TableFormattingContext::setComputedGeometryForSections()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-added">+     auto sectionWidth = grid.columnsContext().logicalWidth() + 2 * grid.horizontalSpacing();</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; section : childrenOfType&lt;Box&gt;(root())) {</span>
<span class="line-added">+         auto&amp; sectionDisplayBox = formattingState().displayBox(section);</span>
<span class="line-added">+         initializeDisplayBoxToBlank(sectionDisplayBox);</span>
<span class="line-added">+         // FIXME: Size table sections properly.</span>
<span class="line-added">+         sectionDisplayBox.setContentBoxWidth(sectionWidth);</span>
<span class="line-added">+         sectionDisplayBox.setContentBoxHeight(grid.rows().last().logicalBottom() + grid.verticalSpacing());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ FormattingContext::IntrinsicWidthConstraints TableFormattingContext::computedIntrinsicWidthConstraints()</span>
  {
      // Tables have a slighty different concept of shrink to fit. It&#39;s really only different with non-auto &quot;width&quot; values, where
      // a generic shrink-to fit block level box like a float box would be just sized to the computed value of &quot;width&quot;, tables
      // can actually be streched way over.
<span class="line-modified">!     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-modified">!     if (!grid.hasComputedWidthConstraints()) {</span>
<span class="line-modified">!         // 1. Ensure each cell slot is occupied by at least one cell.</span>
<span class="line-modified">!         ensureTableGrid();</span>
<span class="line-modified">!         // 2. Compute the minimum/maximum width of each column.</span>
<span class="line-modified">!         computePreferredWidthForColumns();</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     return grid.widthConstraints();</span>
  }
  
<span class="line-modified">! void TableFormattingContext::ensureTableGrid()</span>
  {
<span class="line-modified">!     auto&amp; tableBox = root();</span>
      auto&amp; tableGrid = formattingState().tableGrid();
<span class="line-added">+     tableGrid.setHorizontalSpacing(LayoutUnit { tableBox.style().horizontalBorderSpacing() });</span>
<span class="line-added">+     tableGrid.setVerticalSpacing(LayoutUnit { tableBox.style().verticalBorderSpacing() });</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* firstChild = tableBox.firstChild();</span>
<span class="line-added">+     const Box* tableCaption = nullptr;</span>
<span class="line-added">+     const Box* colgroup = nullptr;</span>
<span class="line-added">+     // Table caption is an optional element; if used, it is always the first child of a &lt;table&gt;.</span>
<span class="line-added">+     if (firstChild-&gt;isTableCaption())</span>
<span class="line-added">+         tableCaption = firstChild;</span>
<span class="line-added">+     // The &lt;colgroup&gt; must appear after any optional &lt;caption&gt; element but before any &lt;thead&gt;, &lt;th&gt;, &lt;tbody&gt;, &lt;tfoot&gt; and &lt;tr&gt; element.</span>
<span class="line-added">+     auto* colgroupCandidate = firstChild;</span>
<span class="line-added">+     if (tableCaption)</span>
<span class="line-added">+         colgroupCandidate = tableCaption-&gt;nextSibling();</span>
<span class="line-added">+     if (colgroupCandidate-&gt;isTableColumnGroup())</span>
<span class="line-added">+         colgroup = colgroupCandidate;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (colgroup) {</span>
<span class="line-added">+         auto&amp; columnsContext = tableGrid.columnsContext();</span>
<span class="line-added">+         for (auto* column = downcast&lt;Container&gt;(*colgroup).firstChild(); column; column = column-&gt;nextSibling()) {</span>
<span class="line-added">+             ASSERT(column-&gt;isTableColumn());</span>
<span class="line-added">+             auto columnSpanCount = column-&gt;columnSpan();</span>
<span class="line-added">+             ASSERT(columnSpanCount &gt; 0);</span>
<span class="line-added">+             while (columnSpanCount--)</span>
<span class="line-added">+                 columnsContext.addColumn(column);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     auto* firstSection = colgroup ? colgroup-&gt;nextSibling() : tableCaption ? tableCaption-&gt;nextSibling() : firstChild;</span>
<span class="line-added">+     for (auto* section = firstSection; section; section = section-&gt;nextSibling()) {</span>
          ASSERT(section-&gt;isTableHeader() || section-&gt;isTableBody() || section-&gt;isTableFooter());
          for (auto* row = downcast&lt;Container&gt;(*section).firstChild(); row; row = row-&gt;nextSibling()) {
              ASSERT(row-&gt;isTableRow());
              for (auto* cell = downcast&lt;Container&gt;(*row).firstChild(); cell; cell = cell-&gt;nextSibling()) {
                  ASSERT(cell-&gt;isTableCell());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,27 ***</span>
              }
          }
      }
  }
  
<span class="line-modified">! void TableFormattingContext::computePreferredWidthForColumns() const</span>
  {
      auto&amp; formattingState = this-&gt;formattingState();
      auto&amp; grid = formattingState.tableGrid();
  
      // 1. Calculate the minimum content width (MCW) of each cell: the formatted content may span any number of lines but may not overflow the cell box.
      //    If the specified &#39;width&#39; (W) of the cell is greater than MCW, W is the minimum cell width. A value of &#39;auto&#39; means that MCW is the minimum cell width.
      //    Also, calculate the &quot;maximum&quot; cell width of each cell: formatting the content without breaking lines other than where explicit line breaks occur.
      for (auto&amp; cell : grid.cells()) {
<span class="line-modified">!         ASSERT(cell-&gt;tableCellBox.establishesFormattingContext());</span>
  
<span class="line-modified">!         auto intrinsicWidth = layoutState().createFormattingContext(cell-&gt;tableCellBox)-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-modified">!         intrinsicWidth = Geometry::constrainByMinMaxWidth(cell-&gt;tableCellBox, intrinsicWidth);</span>
<span class="line-modified">!         formattingState.setIntrinsicWidthConstraints(intrinsicWidth);</span>
  
          auto columnSpan = cell-&gt;size.width();
<span class="line-modified">!         auto slotIntrinsicWidth = FormattingContext::IntrinsicWidthConstraints { intrinsicWidth.minimum / columnSpan, intrinsicWidth.maximum / columnSpan };</span>
          auto initialPosition = cell-&gt;position;
          for (auto i = 0; i &lt; columnSpan; ++i)
              grid.slot({ initialPosition.x() + i, initialPosition.y() })-&gt;widthConstraints = slotIntrinsicWidth;
      }
      // 2. For each column, determine a maximum and minimum column width from the cells that span only that column.
<span class="line-new-header">--- 216,38 ---</span>
              }
          }
      }
  }
  
<span class="line-modified">! void TableFormattingContext::computePreferredWidthForColumns()</span>
  {
      auto&amp; formattingState = this-&gt;formattingState();
      auto&amp; grid = formattingState.tableGrid();
<span class="line-added">+     ASSERT(!grid.hasComputedWidthConstraints());</span>
  
      // 1. Calculate the minimum content width (MCW) of each cell: the formatted content may span any number of lines but may not overflow the cell box.
      //    If the specified &#39;width&#39; (W) of the cell is greater than MCW, W is the minimum cell width. A value of &#39;auto&#39; means that MCW is the minimum cell width.
      //    Also, calculate the &quot;maximum&quot; cell width of each cell: formatting the content without breaking lines other than where explicit line breaks occur.
      for (auto&amp; cell : grid.cells()) {
<span class="line-modified">!         auto&amp; tableCellBox = cell-&gt;tableCellBox;</span>
<span class="line-added">+         ASSERT(tableCellBox.establishesFormattingContext());</span>
  
<span class="line-modified">!         auto intrinsicWidth = formattingState.intrinsicWidthConstraintsForBox(tableCellBox);</span>
<span class="line-modified">!         if (!intrinsicWidth) {</span>
<span class="line-modified">!             intrinsicWidth = IntrinsicWidthConstraints { };</span>
<span class="line-added">+             if (is&lt;Container&gt;(tableCellBox))</span>
<span class="line-added">+                 intrinsicWidth = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(tableCellBox), layoutState())-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-added">+             intrinsicWidth = geometry().constrainByMinMaxWidth(tableCellBox, *intrinsicWidth);</span>
<span class="line-added">+             auto border = geometry().computedBorder(tableCellBox);</span>
<span class="line-added">+             auto padding = *geometry().computedPadding(tableCellBox, { });</span>
<span class="line-added">+ </span>
<span class="line-added">+             intrinsicWidth-&gt;expand(border.horizontal.width() + padding.horizontal.width());</span>
<span class="line-added">+             formattingState.setIntrinsicWidthConstraintsForBox(tableCellBox, *intrinsicWidth);</span>
<span class="line-added">+         }</span>
  
          auto columnSpan = cell-&gt;size.width();
<span class="line-modified">!         auto slotIntrinsicWidth = FormattingContext::IntrinsicWidthConstraints { intrinsicWidth-&gt;minimum / columnSpan, intrinsicWidth-&gt;maximum / columnSpan };</span>
          auto initialPosition = cell-&gt;position;
          for (auto i = 0; i &lt; columnSpan; ++i)
              grid.slot({ initialPosition.x() + i, initialPosition.y() })-&gt;widthConstraints = slotIntrinsicWidth;
      }
      // 2. For each column, determine a maximum and minimum column width from the cells that span only that column.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,77 ***</span>
          for (int rowIndex = 0; rowIndex &lt; numberOfRows; ++rowIndex) {
              auto* slot = grid.slot({ columnIndex, rowIndex });
              columnIntrinsicWidths.minimum = std::max(slot-&gt;widthConstraints.minimum, columnIntrinsicWidths.minimum);
              columnIntrinsicWidths.maximum = std::max(slot-&gt;widthConstraints.maximum, columnIntrinsicWidths.maximum);
          }
          columns[columnIndex].setWidthConstraints(columnIntrinsicWidths);
      }
<span class="line-removed">-     // FIXME: Take column group elements into account.</span>
  }
  
<span class="line-modified">! LayoutUnit TableFormattingContext::computedTableWidth() const</span>
  {
      // Column and caption widths influence the final table width as follows:
      // If the &#39;table&#39; or &#39;inline-table&#39; element&#39;s &#39;width&#39; property has a computed value (W) other than &#39;auto&#39;, the used width is the greater of
      // W, CAPMIN, and the minimum width required by all the columns plus cell spacing or borders (MIN).
      // If the used width is greater than MIN, the extra width should be distributed over the columns.
      // If the &#39;table&#39; or &#39;inline-table&#39; element has &#39;width: auto&#39;, the used width is the greater of the table&#39;s containing block width,
      // CAPMIN, and MIN. However, if either CAPMIN or the maximum width required by the columns plus cell spacing or borders (MAX) is
      // less than that of the containing block, use max(MAX, CAPMIN).
  
<span class="line-modified">!     // FIXME: This kind of code usually lives in *FormattingContextGeometry class.</span>
<span class="line-modified">!     auto&amp; tableWrapperBox = root();</span>
<span class="line-modified">!     auto&amp; style = tableWrapperBox.style();</span>
<span class="line-modified">!     auto&amp; containingBlock = *tableWrapperBox.containingBlock();</span>
<span class="line-modified">!     auto&amp; containingBlockDisplayBox = layoutState().displayBoxForLayoutBox(containingBlock);</span>
<span class="line-modified">!     auto containingBlockWidth = containingBlockDisplayBox.contentBoxWidth();</span>
  
<span class="line-modified">!     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-modified">!     auto&amp; columnsContext = grid.columnsContext();</span>
<span class="line-removed">-     auto tableWidthConstraints = grid.widthConstraints();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto width = Geometry::computedValueIfNotAuto(style.width(), containingBlockWidth);</span>
<span class="line-removed">-     LayoutUnit usedWidth;</span>
<span class="line-removed">-     if (width) {</span>
<span class="line-removed">-         if (*width &gt; tableWidthConstraints.minimum) {</span>
<span class="line-removed">-             distributeAvailableWidth(*width - tableWidthConstraints.minimum);</span>
<span class="line-removed">-             usedWidth = *width;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             usedWidth = tableWidthConstraints.minimum;</span>
<span class="line-removed">-             columnsContext.useAsLogicalWidth(TableGrid::ColumnsContext::WidthConstraintsType::Minimum);</span>
          }
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         if (tableWidthConstraints.minimum &gt; containingBlockWidth) {</span>
<span class="line-modified">!             usedWidth = tableWidthConstraints.minimum;</span>
<span class="line-modified">!             columnsContext.useAsLogicalWidth(TableGrid::ColumnsContext::WidthConstraintsType::Minimum);</span>
<span class="line-modified">!         } else if (tableWidthConstraints.maximum &lt; containingBlockWidth) {</span>
<span class="line-modified">!             usedWidth = tableWidthConstraints.maximum;</span>
<span class="line-modified">!             columnsContext.useAsLogicalWidth(TableGrid::ColumnsContext::WidthConstraintsType::Maximum);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             usedWidth = containingBlockWidth;</span>
<span class="line-removed">-             distributeAvailableWidth(*width - tableWidthConstraints.minimum);</span>
          }
      }
<span class="line-removed">-     // FIXME: This should also deal with collapsing borders etc.</span>
<span class="line-removed">-     LayoutUnit columnLogicalLeft;</span>
<span class="line-removed">-     auto&amp; columns = columnsContext.columns();</span>
<span class="line-removed">-     for (auto&amp; column : columns) {</span>
<span class="line-removed">-         column.setLogicalLeft(columnLogicalLeft);</span>
<span class="line-removed">-         columnLogicalLeft += column.logicalWidth();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return usedWidth;</span>
  }
  
<span class="line-modified">! void TableFormattingContext::distributeAvailableWidth(LayoutUnit extraHorizontalSpace) const</span>
  {
<span class="line-removed">-     // FIXME: Right now just distribute the extra space equaly among the columns.</span>
      auto&amp; columns = formattingState().tableGrid().columnsContext().columns();
      ASSERT(!columns.isEmpty());
  
<span class="line-removed">-     auto columnExtraSpace = extraHorizontalSpace / columns.size();</span>
      for (auto&amp; column : columns)
<span class="line-modified">!         column.setLogicalWidth(column.widthConstraints().minimum + columnExtraSpace);</span>
  }
  
  }
  }
  
<span class="line-new-header">--- 261,88 ---</span>
          for (int rowIndex = 0; rowIndex &lt; numberOfRows; ++rowIndex) {
              auto* slot = grid.slot({ columnIndex, rowIndex });
              columnIntrinsicWidths.minimum = std::max(slot-&gt;widthConstraints.minimum, columnIntrinsicWidths.minimum);
              columnIntrinsicWidths.maximum = std::max(slot-&gt;widthConstraints.maximum, columnIntrinsicWidths.maximum);
          }
<span class="line-added">+         // Now that we have the content driven min/max widths, check if &lt;col&gt; sets a preferred width on this column.</span>
<span class="line-added">+         if (auto* columnBox = columns[columnIndex].columnBox()) {</span>
<span class="line-added">+             if (auto columnPreferredWidth = geometry().computedColumnWidth(*columnBox)) {</span>
<span class="line-added">+                 // Let&#39;s stay at least as wide as the preferred width.</span>
<span class="line-added">+                 columnIntrinsicWidths.minimum = std::max(columnIntrinsicWidths.minimum, *columnPreferredWidth);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
          columns[columnIndex].setWidthConstraints(columnIntrinsicWidths);
      }
  }
  
<span class="line-modified">! void TableFormattingContext::computeAndDistributeExtraHorizontalSpace()</span>
  {
<span class="line-added">+     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-added">+     ASSERT(grid.hasComputedWidthConstraints());</span>
<span class="line-added">+     auto tableWidthConstraints = grid.widthConstraints();</span>
<span class="line-added">+ </span>
      // Column and caption widths influence the final table width as follows:
      // If the &#39;table&#39; or &#39;inline-table&#39; element&#39;s &#39;width&#39; property has a computed value (W) other than &#39;auto&#39;, the used width is the greater of
      // W, CAPMIN, and the minimum width required by all the columns plus cell spacing or borders (MIN).
      // If the used width is greater than MIN, the extra width should be distributed over the columns.
      // If the &#39;table&#39; or &#39;inline-table&#39; element has &#39;width: auto&#39;, the used width is the greater of the table&#39;s containing block width,
      // CAPMIN, and MIN. However, if either CAPMIN or the maximum width required by the columns plus cell spacing or borders (MAX) is
      // less than that of the containing block, use max(MAX, CAPMIN).
<span class="line-added">+     auto distributeExtraHorizontalSpace = [&amp;](auto extraHorizontalSpace) {</span>
<span class="line-added">+         auto&amp; columns = grid.columnsContext().columns();</span>
<span class="line-added">+         ASSERT(!columns.isEmpty());</span>
  
<span class="line-modified">!         auto tableMinimumContentWidth = tableWidthConstraints.minimum - grid.totalHorizontalSpacing();</span>
<span class="line-modified">!         auto adjustabledHorizontalSpace = tableMinimumContentWidth;</span>
<span class="line-modified">!         auto numberOfColumns = columns.size();</span>
<span class="line-modified">!         // Fixed width columns don&#39;t participate in available space distribution.</span>
<span class="line-modified">!         for (auto&amp; column : columns) {</span>
<span class="line-modified">!             if (!column.hasFixedWidth())</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             auto columnFixedWidth = *column.columnBox()-&gt;columnWidth();</span>
<span class="line-added">+             column.setLogicalWidth(columnFixedWidth);</span>
  
<span class="line-modified">!             --numberOfColumns;</span>
<span class="line-modified">!             adjustabledHorizontalSpace -= columnFixedWidth;</span>
          }
<span class="line-modified">!         if (!numberOfColumns || !adjustabledHorizontalSpace)</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         // FIXME: Right now just distribute the extra space equaly among the columns using the minimum width.</span>
<span class="line-modified">!         ASSERT(adjustabledHorizontalSpace &gt; 0);</span>
<span class="line-modified">!         for (auto&amp; column : columns) {</span>
<span class="line-modified">!             if (column.hasFixedWidth())</span>
<span class="line-modified">!                 continue;</span>
<span class="line-modified">!             auto columnExtraSpace = extraHorizontalSpace / adjustabledHorizontalSpace * column.widthConstraints().minimum;</span>
<span class="line-modified">!             column.setLogicalWidth(column.widthConstraints().minimum + columnExtraSpace);</span>
          }
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; tableBox = root();</span>
<span class="line-added">+     auto containingBlockWidth = geometryForBox(*tableBox.containingBlock(), EscapeReason::TableNeedsAccessToTableWrapper).contentBoxWidth();</span>
<span class="line-added">+     auto contentWidth = geometry().computedContentWidth(tableBox, containingBlockWidth);</span>
<span class="line-added">+     if (contentWidth) {</span>
<span class="line-added">+         if (*contentWidth &gt; tableWidthConstraints.minimum)</span>
<span class="line-added">+             distributeExtraHorizontalSpace(*contentWidth - tableWidthConstraints.minimum);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             useAsContentLogicalWidth(WidthConstraintsType::Minimum);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         if (tableWidthConstraints.minimum &gt; containingBlockWidth)</span>
<span class="line-added">+             useAsContentLogicalWidth(WidthConstraintsType::Minimum);</span>
<span class="line-added">+         else if (tableWidthConstraints.maximum &lt; containingBlockWidth)</span>
<span class="line-added">+             useAsContentLogicalWidth(WidthConstraintsType::Maximum);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             distributeExtraHorizontalSpace(containingBlockWidth - tableWidthConstraints.minimum);</span>
      }
  }
  
<span class="line-modified">! void TableFormattingContext::useAsContentLogicalWidth(WidthConstraintsType type)</span>
  {
      auto&amp; columns = formattingState().tableGrid().columnsContext().columns();
      ASSERT(!columns.isEmpty());
  
      for (auto&amp; column : columns)
<span class="line-modified">!         column.setLogicalWidth(type == WidthConstraintsType::Minimum ? column.widthConstraints().minimum : column.widthConstraints().maximum);</span>
  }
  
  }
  }
  
</pre>
<center><a href="../layouttree/LayoutTreeBuilder.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TableFormattingContext.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/x86.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 # Copyright (C) 2012-2018 Apple Inc. All rights reserved.
   2 # Copyright (C) 2013 Digia Plc. and/or its subsidiary(-ies)
   3 #
   4 # Redistribution and use in source and binary forms, with or without
   5 # modification, are permitted provided that the following conditions
   6 # are met:
   7 # 1. Redistributions of source code must retain the above copyright
   8 #    notice, this list of conditions and the following disclaimer.
   9 # 2. Redistributions in binary form must reproduce the above copyright
  10 #    notice, this list of conditions and the following disclaimer in the
  11 #    documentation and/or other materials provided with the distribution.
  12 #
  13 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23 # THE POSSIBILITY OF SUCH DAMAGE.
  24 
  25 require &quot;config&quot;
  26 
  27 # GPR conventions, to match the baseline JIT:
  28 #
  29 #
  30 # On x86-32 bits (windows and non-windows)
  31 # a0, a1, a2, a3 are only there for ease-of-use of offlineasm; they are not
  32 # actually considered as such by the ABI and we need to push/pop our arguments
  33 # on the stack. a0 and a1 are ecx and edx to follow fastcall.
  34 #
  35 # eax =&gt; t0, a2, r0
  36 # edx =&gt; t1, a1, r1
  37 # ecx =&gt; t2, a0
  38 # ebx =&gt; t3, a3     (callee-save)
  39 # esi =&gt; t4         (callee-save)
  40 # edi =&gt; t5         (callee-save)
  41 # ebp =&gt; cfr
  42 # esp =&gt; sp
  43 #
  44 # On x86-64 non-windows
  45 #
  46 # rax =&gt; t0,     r0
  47 # rdi =&gt;     a0
  48 # rsi =&gt; t1, a1
  49 # rdx =&gt; t2, a2, r1
  50 # rcx =&gt; t3, a3
  51 #  r8 =&gt; t4
  52 #  r9 =&gt; t5
  53 # r10 =&gt; t6
  54 # rbx =&gt;             csr0 (callee-save, wasmInstance)
  55 # r12 =&gt;             csr1 (callee-save, metadataTable)
  56 # r13 =&gt;             csr2 (callee-save, PB)
  57 # r14 =&gt;             csr3 (callee-save, tagTypeNumber)
  58 # r15 =&gt;             csr4 (callee-save, tagMask)
  59 # rsp =&gt; sp
  60 # rbp =&gt; cfr
  61 # r11 =&gt;                  (scratch)
  62 #
  63 # On x86-64 windows
  64 # Arguments need to be push/pop&#39;d on the stack in addition to being stored in
  65 # the registers. Also, &gt;8 return types are returned in a weird way.
  66 #
  67 # rax =&gt; t0,     r0
  68 # rcx =&gt; t5, a0
  69 # rdx =&gt; t1, a1, r1
  70 #  r8 =&gt; t2, a2
  71 #  r9 =&gt; t3, a3
  72 # r10 =&gt; t4
  73 # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)
  74 # rsi =&gt;             csr1 (callee-save)
  75 # rdi =&gt;             csr2 (callee-save)
  76 # r12 =&gt;             csr3 (callee-save)
  77 # r13 =&gt;             csr4 (callee-save)
  78 # r14 =&gt;             csr5 (callee-save, numberTag)
  79 # r15 =&gt;             csr6 (callee-save, notCellMask)
  80 # rsp =&gt; sp
  81 # rbp =&gt; cfr
  82 # r11 =&gt;                  (scratch)
  83 
  84 def isX64
  85     case $activeBackend
  86     when &quot;X86&quot;
  87         false
  88     when &quot;X86_WIN&quot;
  89         false
  90     when &quot;X86_64&quot;
  91         true
  92     when &quot;X86_64_WIN&quot;
  93         true
  94     else
  95         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
  96     end
  97 end
  98 
  99 def isWin
 100     case $activeBackend
 101     when &quot;X86&quot;
 102         false
 103     when &quot;X86_WIN&quot;
 104         true
 105     when &quot;X86_64&quot;
 106         false
 107     when &quot;X86_64_WIN&quot;
 108         true
 109     else
 110         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
 111     end
 112 end
 113 
 114 def isMSVC
 115     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 116 end
 117 
 118 def isIntelSyntax
 119     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 120 end
 121 
 122 def register(name)
 123     isIntelSyntax ? name : &quot;%&quot; + name
 124 end
 125 
 126 def offsetRegister(off, register)
 127     isIntelSyntax ? &quot;[#{off} + #{register}]&quot; : &quot;#{off}(#{register})&quot;
 128 end
 129 
 130 def callPrefix
 131     isIntelSyntax ? &quot;&quot; : &quot;*&quot;
 132 end
 133 
 134 def orderOperands(*operands)
 135     (isIntelSyntax ? operands.reverse : operands).join(&quot;, &quot;)
 136 end
 137 
 138 def const(c)
 139     isIntelSyntax ? &quot;#{c}&quot; : &quot;$#{c}&quot;
 140 end
 141 
 142 def getSizeString(kind)
 143     if !isIntelSyntax
 144         return &quot;&quot;
 145     end
 146 
 147     size = &quot;&quot;
 148     case kind
 149     when :byte
 150         size = &quot;byte&quot;
 151     when :half
 152         size = &quot;word&quot;
 153     when :int
 154         size = &quot;dword&quot;
 155     when :ptr
 156         size =  isX64 ? &quot;qword&quot; : &quot;dword&quot;
 157     when :float
 158         size = &quot;dword&quot;
 159     when :double
 160         size = &quot;qword&quot;
 161     when :quad
 162         size = &quot;qword&quot;
 163     else
 164         raise &quot;Invalid kind #{kind}&quot;
 165     end
 166 
 167     return size + &quot; &quot; + &quot;ptr&quot; + &quot; &quot;;
 168 end
 169 
 170 class SpecialRegister &lt; NoChildren
 171     def x86Operand(kind)
 172         raise unless @name =~ /^r/
 173         raise unless isX64
 174         case kind
 175         when :half
 176             register(@name + &quot;w&quot;)
 177         when :int
 178             register(@name + &quot;d&quot;)
 179         when :ptr
 180             register(@name)
 181         when :quad
 182             register(@name)
 183         else
 184             raise codeOriginString
 185         end
 186     end
 187     def x86CallOperand(kind)
 188         # Call operands are not allowed to be partial registers.
 189         &quot;#{callPrefix}#{x86Operand(:quad)}&quot;
 190     end
 191 end
 192 
 193 X64_SCRATCH_REGISTER = SpecialRegister.new(&quot;r11&quot;)
 194 
 195 def x86GPRName(name, kind)
 196     case name
 197     when &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;
 198         name8 = name[1] + &#39;l&#39;
 199         name16 = name[1..2]
 200     when &quot;esi&quot;, &quot;edi&quot;, &quot;ebp&quot;, &quot;esp&quot;
 201         name16 = name[1..2]
 202         name8 = name16 + &#39;l&#39;
 203     when &quot;rax&quot;, &quot;rbx&quot;, &quot;rcx&quot;, &quot;rdx&quot;
 204         raise &quot;bad GPR name #{name} in 32-bit X86&quot; unless isX64
 205         name8 = name[1] + &#39;l&#39;
 206         name16 = name[1..2]
 207     when &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r12&quot;, &quot;r13&quot;, &quot;r14&quot;, &quot;r15&quot;
 208         raise &quot;bad GPR name #{name} in 32-bit X86&quot; unless isX64
 209         case kind
 210         when :half
 211             return register(name + &quot;w&quot;)
 212         when :int
 213             return register(name + &quot;d&quot;)
 214         when :ptr
 215             return register(name)
 216         when :quad
 217             return register(name)
 218         end
 219     else
 220         raise &quot;bad GPR name #{name}&quot;
 221     end
 222     case kind
 223     when :byte
 224         register(name8)
 225     when :half
 226         register(name16)
 227     when :int
 228         register(&quot;e&quot; + name16)
 229     when :ptr
 230         register((isX64 ? &quot;r&quot; : &quot;e&quot;) + name16)
 231     when :quad
 232         isX64 ? register(&quot;r&quot; + name16) : raise
 233     else
 234         raise &quot;invalid kind #{kind} for GPR #{name} in X86&quot;
 235     end
 236 end
 237 
 238 class Node
 239     def x86LoadOperand(type, dst)
 240         x86Operand(type)
 241     end
 242 end
 243 
 244 class RegisterID
 245     def supports8BitOnX86
 246         case x86GPR
 247         when &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;, &quot;edi&quot;, &quot;esi&quot;, &quot;ebp&quot;, &quot;esp&quot;
 248             true
 249         when &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r12&quot;, &quot;r13&quot;, &quot;r14&quot;, &quot;r15&quot;
 250             false
 251         else
 252             raise
 253         end
 254     end
 255 
 256     def x86GPR
 257         if isX64
 258             case name
 259             when &quot;t0&quot;, &quot;r0&quot;, &quot;ws0&quot;
 260                 &quot;eax&quot;
 261             when &quot;r1&quot;
 262                 &quot;edx&quot; # t1 = a1 when isWin, t2 = a2 otherwise
 263             when &quot;a0&quot;, &quot;wa0&quot;
 264                 isWin ? &quot;ecx&quot; : &quot;edi&quot;
 265             when &quot;t1&quot;, &quot;a1&quot;, &quot;wa1&quot;
 266                 isWin ? &quot;edx&quot; : &quot;esi&quot;
 267             when &quot;t2&quot;, &quot;a2&quot;, &quot;wa2&quot;
 268                 isWin ? &quot;r8&quot; : &quot;edx&quot;
 269             when &quot;t3&quot;, &quot;a3&quot;, &quot;wa3&quot;
 270                 isWin ? &quot;r9&quot; : &quot;ecx&quot;
 271             when &quot;t4&quot;, &quot;wa4&quot;
 272                 isWin ? &quot;r10&quot; : &quot;r8&quot;
 273             when &quot;t5&quot;, &quot;wa5&quot;
 274                 isWin ? &quot;ecx&quot; : &quot;r9&quot;
 275             when &quot;t6&quot;, &quot;ws1&quot;
 276                 raise &quot;cannot use register #{name} on X86-64 Windows&quot; if isWin
 277                 &quot;r10&quot;
 278             when &quot;csr0&quot;
 279                 &quot;ebx&quot;
 280             when &quot;csr1&quot;
 281                 isWin ? &quot;esi&quot; : &quot;r12&quot;
 282             when &quot;csr2&quot;
 283                 isWin ? &quot;edi&quot; : &quot;r13&quot;
 284             when &quot;csr3&quot;
 285                 isWin ? &quot;r12&quot; : &quot;r14&quot;
 286             when &quot;csr4&quot;
 287                 isWin ? &quot;r13&quot; : &quot;r15&quot;
 288             when &quot;csr5&quot;
 289                 raise &quot;cannot use register #{name} on X86-64&quot; unless isWin
 290                 &quot;r14&quot;
 291             when &quot;csr6&quot;
 292                 raise &quot;cannot use register #{name} on X86-64&quot; unless isWin
 293                 &quot;r15&quot;
 294             when &quot;cfr&quot;
 295                 &quot;ebp&quot;
 296             when &quot;sp&quot;
 297                 &quot;esp&quot;
 298             else
 299                 raise &quot;cannot use register #{name} on X86&quot;
 300             end
 301         else
 302             case name
 303             when &quot;t0&quot;, &quot;r0&quot;, &quot;a2&quot;
 304                 &quot;eax&quot;
 305             when &quot;t1&quot;, &quot;r1&quot;, &quot;a1&quot;
 306                 &quot;edx&quot;
 307             when &quot;t2&quot;, &quot;a0&quot;
 308                 &quot;ecx&quot;
 309             when &quot;t3&quot;, &quot;a3&quot;
 310                 &quot;ebx&quot;
 311             when &quot;t4&quot;
 312                 &quot;esi&quot;
 313             when &quot;t5&quot;
 314                 &quot;edi&quot;
 315             when &quot;cfr&quot;
 316                 &quot;ebp&quot;
 317             when &quot;sp&quot;
 318                 &quot;esp&quot;
 319             end
 320         end
 321     end
 322 
 323     def x86Operand(kind)
 324         x86GPRName(x86GPR, kind)
 325     end
 326 
 327     def x86CallOperand(kind)
 328         &quot;#{callPrefix}#{x86Operand(:ptr)}&quot;
 329     end
 330 end
 331 
 332 class FPRegisterID
 333     def x86Operand(kind)
 334         raise unless [:float, :double].include? kind
 335         case name
 336         when &quot;ft0&quot;, &quot;fa0&quot;, &quot;fr&quot;, &quot;wfa0&quot;
 337             register(&quot;xmm0&quot;)
 338         when &quot;ft1&quot;, &quot;fa1&quot;, &quot;wfa1&quot;
 339             register(&quot;xmm1&quot;)
 340         when &quot;ft2&quot;, &quot;fa2&quot;, &quot;wfa2&quot;
 341             register(&quot;xmm2&quot;)
 342         when &quot;ft3&quot;, &quot;fa3&quot;, &quot;wfa3&quot;
 343             register(&quot;xmm3&quot;)
 344         when &quot;ft4&quot;, &quot;wfa4&quot;
 345             register(&quot;xmm4&quot;)
 346         when &quot;ft5&quot;, &quot;wfa5&quot;
 347             register(&quot;xmm5&quot;)
 348         when &quot;wfa6&quot;
 349             register(&quot;xmm6&quot;)
 350         when &quot;wfa7&quot;
 351             register(&quot;xmm7&quot;)
 352         else
 353             raise &quot;Bad register #{name} for X86 at #{codeOriginString}&quot;
 354         end
 355     end
 356     def x86CallOperand(kind)
 357         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 358     end
 359 end
 360 
 361 class Immediate
 362     def validX86Immediate?
 363         if isX64
 364             value &gt;= -0x80000000 and value &lt;= 0x7fffffff
 365         else
 366             true
 367         end
 368     end
 369     def x86Operand(kind)
 370         &quot;#{const(value)}&quot;
 371     end
 372     def x86CallOperand(kind)
 373         &quot;#{value}&quot;
 374     end
 375 end
 376 
 377 class Address
 378     def supports8BitOnX86
 379         true
 380     end
 381     
 382     def x86AddressOperand(addressKind)
 383         &quot;#{offsetRegister(offset.value, base.x86Operand(addressKind))}&quot;
 384     end
 385     def x86Operand(kind)
 386         &quot;#{getSizeString(kind)}#{x86AddressOperand(:ptr)}&quot;
 387     end
 388     def x86CallOperand(kind)
 389         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 390     end
 391 end
 392 
 393 class BaseIndex
 394     def supports8BitOnX86
 395         true
 396     end
 397     
 398     def x86AddressOperand(addressKind)
 399         if !isIntelSyntax
 400             &quot;#{offset.value}(#{base.x86Operand(addressKind)}, #{index.x86Operand(addressKind)}, #{scaleValue})&quot;
 401         else
 402             &quot;#{getSizeString(addressKind)}[#{offset.value} + #{base.x86Operand(addressKind)} + #{index.x86Operand(addressKind)} * #{scaleValue}]&quot;
 403         end
 404     end
 405     
 406     def x86Operand(kind)
 407         if !isIntelSyntax
 408             x86AddressOperand(:ptr)
 409         else
 410             &quot;#{getSizeString(kind)}[#{offset.value} + #{base.x86Operand(:ptr)} + #{index.x86Operand(:ptr)} * #{scaleValue}]&quot;
 411         end
 412     end
 413 
 414     def x86CallOperand(kind)
 415         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 416     end
 417 end
 418 
 419 class AbsoluteAddress
 420     def supports8BitOnX86
 421         true
 422     end
 423     
 424     def x86AddressOperand(addressKind)
 425         &quot;#{address.value}&quot;
 426     end
 427     
 428     def x86Operand(kind)
 429         &quot;#{address.value}&quot;
 430     end
 431 
 432     def x86CallOperand(kind)
 433         &quot;#{callPrefix}#{address.value}&quot;
 434     end
 435 end
 436 
 437 class LabelReference
 438     def x86CallOperand(kind)
 439         asmLabel
 440     end
 441     def x86LoadOperand(kind, dst)
 442         # FIXME: Implement this on platforms that aren&#39;t Mach-O.
 443         # https://bugs.webkit.org/show_bug.cgi?id=175104
 444         used
 445         if !isIntelSyntax
 446             $asm.puts &quot;movq #{asmLabel}@GOTPCREL(%rip), #{dst.x86Operand(:ptr)}&quot;
 447         else
 448             $asm.puts &quot;lea #{dst.x86Operand(:ptr)}, #{asmLabel}&quot;
 449         end
 450         &quot;#{offset}(#{dst.x86Operand(kind)})&quot;
 451     end
 452 end
 453 
 454 class LocalLabelReference
 455     def x86Operand(kind)
 456         asmLabel
 457     end
 458     def x86CallOperand(kind)
 459         asmLabel
 460     end
 461 end
 462 
 463 class Sequence
 464     def getModifiedListX86_64
 465         newList = []
 466         
 467         @list.each {
 468             | node |
 469             newNode = node
 470             if node.is_a? Instruction
 471                 unless node.opcode == &quot;move&quot;
 472                     usedScratch = false
 473                     newOperands = node.operands.map {
 474                         | operand |
 475                         if operand.immediate? and not operand.validX86Immediate?
 476                             if usedScratch
 477                                 raise &quot;Attempt to use scratch register twice at #{operand.codeOriginString}&quot;
 478                             end
 479                             newList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;move&quot;, [operand, X64_SCRATCH_REGISTER])
 480                             usedScratch = true
 481                             X64_SCRATCH_REGISTER
 482                         else
 483                             operand
 484                         end
 485                     }
 486                     newNode = Instruction.new(node.codeOrigin, node.opcode, newOperands, node.annotation)
 487                 end
 488             else
 489                 unless node.is_a? Label or
 490                         node.is_a? LocalLabel or
 491                         node.is_a? Skip
 492                     raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
 493                 end
 494             end
 495             if newNode
 496                 newList &lt;&lt; newNode
 497             end
 498         }
 499         
 500         return newList
 501     end
 502     def getModifiedListX86_64_WIN
 503         getModifiedListX86_64
 504     end
 505 end
 506 
 507 class Instruction
 508     
 509     def x86Operands(*kinds)
 510         raise &quot;Expected size of kinds to be #{operands.size}, but it was #{kinds.size}&quot; unless kinds.size == operands.size
 511         result = []
 512         kinds.size.times {
 513             | idx |
 514             i = isIntelSyntax ? (kinds.size - idx - 1) : idx
 515             result &lt;&lt; operands[i].x86Operand(kinds[i])
 516         }
 517         result.join(&quot;, &quot;)
 518     end
 519     
 520     def x86LoadOperands(srcKind, dstKind)
 521         orderOperands(operands[0].x86LoadOperand(srcKind, operands[1]), operands[1].x86Operand(dstKind))
 522     end
 523 
 524     def x86Suffix(kind)
 525         if isIntelSyntax and not [:float, :double].include? kind
 526             return &quot;&quot;
 527         end
 528 
 529         case kind
 530         when :byte
 531             &quot;b&quot;
 532         when :half
 533             &quot;w&quot;
 534         when :int
 535             &quot;l&quot;
 536         when :ptr
 537             isX64 ? &quot;q&quot; : &quot;l&quot;
 538         when :quad
 539             isX64 ? &quot;q&quot; : raise
 540         when :float
 541             &quot;ss&quot;
 542         when :double
 543             &quot;sd&quot;
 544         else
 545             raise
 546         end
 547     end
 548     
 549     def x86Bytes(kind)
 550         case kind
 551         when :byte
 552             1
 553         when :half
 554             2
 555         when :int
 556             4
 557         when :ptr
 558             isX64 ? 8 : 4
 559         when :quad
 560             isX64 ? 8 : raise
 561         when :float
 562             4
 563         when :double
 564             8
 565         else
 566             raise
 567         end
 568     end
 569 
 570     def emitX86Lea(src, dst, kind)
 571         if src.is_a? LabelReference
 572             src.used
 573             if !isIntelSyntax
 574                 $asm.puts &quot;movq #{src.asmLabel}@GOTPCREL(%rip), #{dst.x86Operand(:ptr)}&quot;
 575             else
 576                 $asm.puts &quot;lea #{dst.x86Operand(:ptr)}, #{src.asmLabel}&quot;
 577             end
 578         else
 579             $asm.puts &quot;lea#{x86Suffix(kind)} #{orderOperands(src.x86AddressOperand(kind), dst.x86Operand(kind))}&quot;
 580         end
 581     end
 582 
 583     def getImplicitOperandString
 584         isIntelSyntax ? &quot;st(0), &quot; : &quot;&quot;
 585     end
 586     
 587     def handleX86OpWithNumOperands(opcode, kind, numOperands)
 588         if numOperands == 3
 589             if operands[0] == operands[2]
 590                 $asm.puts &quot;#{opcode} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 591             elsif operands[1] == operands[2]
 592                 $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 593             else
 594                 $asm.puts &quot;mov#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 595                 $asm.puts &quot;#{opcode} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 596             end
 597         else
 598             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 599         end
 600     end
 601     
 602     def handleX86Op(opcode, kind)
 603         handleX86OpWithNumOperands(opcode, kind, operands.size)
 604     end
 605     
 606     def handleX86Shift(opcode, kind)
 607         if operands[0].is_a? Immediate or operands[0].x86GPR == &quot;ecx&quot;
 608             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(:byte), operands[1].x86Operand(kind))}&quot;
 609         else
 610             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 611             $asm.puts &quot;#{opcode} #{orderOperands(register(&quot;cl&quot;), operands[1].x86Operand(kind))}&quot;
 612             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 613         end
 614     end
 615     
 616     def handleX86FPBranch(kind, branchOpcode, mode)
 617         case mode
 618         when :normal
 619             $asm.puts &quot;ucomi#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(:double), operands[0].x86Operand(:double))}&quot;
 620         when :reverse
 621             $asm.puts &quot;ucomi#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
 622         else
 623             raise mode.inspect
 624         end
 625         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 626     end
 627     
 628     def handleX86IntCompare(opcodeSuffix, kind)
 629         if operands[0].is_a? Immediate and operands[0].value == 0 and operands[1].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 630             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 631         elsif operands[1].is_a? Immediate and operands[1].value == 0 and operands[0].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 632             $asm.puts &quot;test#{x86Suffix(kind)}  #{orderOperands(operands[0].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 633         else
 634             $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 635         end
 636     end
 637     
 638     def handleX86IntCompare(opcodeSuffix, kind)
 639         if operands[0].is_a? Immediate and operands[0].value == 0 and operands[1].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 640             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 641         elsif operands[1].is_a? Immediate and operands[1].value == 0 and operands[0].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 642             $asm.puts &quot;test#{x86Suffix(kind)}  #{orderOperands(operands[0].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 643         else
 644             $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 645         end
 646     end
 647 
 648     def handleX86IntBranch(branchOpcode, kind)
 649         handleX86IntCompare(branchOpcode[1..-1], kind)
 650         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 651     end
 652     
 653     def handleX86Set(setOpcode, operand)
 654         if operand.supports8BitOnX86
 655             $asm.puts &quot;#{setOpcode} #{operand.x86Operand(:byte)}&quot;
 656             if !isIntelSyntax
 657                 $asm.puts &quot;movzbl #{orderOperands(operand.x86Operand(:byte), operand.x86Operand(:int))}&quot;
 658             else
 659                 $asm.puts &quot;movzx #{orderOperands(operand.x86Operand(:byte), operand.x86Operand(:int))}&quot;
 660             end
 661         else
 662             ax = RegisterID.new(nil, &quot;r0&quot;)
 663             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operand.x86Operand(:ptr)}, #{ax.x86Operand(:ptr)}&quot;
 664             $asm.puts &quot;#{setOpcode} #{ax.x86Operand(:byte)}&quot;
 665             if !isIntelSyntax
 666                 $asm.puts &quot;movzbl #{ax.x86Operand(:byte)}, #{ax.x86Operand(:int)}&quot;
 667             else
 668                 $asm.puts &quot;movzx #{ax.x86Operand(:int)}, #{ax.x86Operand(:byte)}&quot;
 669             end
 670             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operand.x86Operand(:ptr)}, #{ax.x86Operand(:ptr)}&quot;
 671         end
 672     end
 673     
 674     def handleX86IntCompareSet(setOpcode, kind)
 675         handleX86IntCompare(setOpcode[3..-1], kind)
 676         handleX86Set(setOpcode, operands[2])
 677     end
 678 
 679     def handleX86FPCompareSet(kind, setOpcode, order = :normal)
 680         is_special = setOpcode.is_a? Symbol
 681         left = operands[0]
 682         right = operands[1]
 683         target = operands[2]
 684 
 685         compare = lambda do |lhs, rhs|
 686             $asm.puts &quot;ucomi#{x86Suffix(kind)} #{orderOperands(lhs.x86Operand(:double), rhs.x86Operand(:double))}&quot;
 687         end
 688 
 689         if is_special
 690             case setOpcode
 691             when :eq
 692                 if left == right
 693                     compare.call(right, left)
 694                     handleX86Set(&quot;setnp&quot;, operands[2])
 695                     return
 696                 end
 697 
 698                 isUnordered = LocalLabel.unique(&quot;isUnordered&quot;)
 699                 $asm.puts &quot;movq $0, #{target.x86Operand(:quad)}&quot;
 700                 compare.call(right, left)
 701                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
 702                 handleX86Set(&quot;sete&quot;, target)
 703                 isUnordered.lower($activeBackend)
 704                 return
 705             when :nequn
 706                 if left == right
 707                     compare.call(right, left)
 708                     handleX86Set(&quot;setp&quot;, target)
 709                     return
 710                 end
 711 
 712                 isUnordered = LocalLabel.unique(&quot;isUnordered&quot;)
 713                 $asm.puts &quot;movq $1, #{target.x86Operand(:quad)}&quot;
 714                 compare.call(right, left);
 715                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
 716                 handleX86Set(&quot;setne&quot;, target)
 717                 isUnordered.lower($activeBackend)
 718                 return
 719             else
 720                 raise &quot;Uhandled special opcode: #{setOpcode}&quot;
 721             end
 722         end
 723 
 724         if order == :normal
 725             compare.call(right, left)
 726         else
 727             compare.call(left, right)
 728         end
 729         handleX86Set(setOpcode, target)
 730     end
 731     
 732     def handleX86Test(kind)
 733         value = operands[0]
 734         case operands.size
 735         when 2
 736             mask = Immediate.new(codeOrigin, -1)
 737         when 3
 738             mask = operands[1]
 739         else
 740             raise &quot;Expected 2 or 3 operands, but got #{operands.size} at #{codeOriginString}&quot;
 741         end
 742         
 743         if mask.is_a? Immediate and mask.value == -1
 744             if value.is_a? RegisterID
 745                 $asm.puts &quot;test#{x86Suffix(kind)} #{value.x86Operand(kind)}, #{value.x86Operand(kind)}&quot;
 746             else
 747                 $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(const(0), value.x86Operand(kind))}&quot;
 748             end
 749         else
 750             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(mask.x86Operand(kind), value.x86Operand(kind))}&quot;
 751         end
 752     end
 753     
 754     def handleX86BranchTest(branchOpcode, kind)
 755         handleX86Test(kind)
 756         $asm.puts &quot;#{branchOpcode} #{operands.last.asmLabel}&quot;
 757     end
 758     
 759     def handleX86SetTest(setOpcode, kind)
 760         handleX86Test(kind)
 761         handleX86Set(setOpcode, operands.last)
 762     end
 763     
 764     def handleX86OpBranch(opcode, branchOpcode, kind)
 765         handleX86OpWithNumOperands(opcode, kind, operands.size - 1)
 766         case operands.size
 767         when 4
 768             jumpTarget = operands[3]
 769         when 3
 770             jumpTarget = operands[2]
 771         else
 772             raise self.inspect
 773         end
 774         $asm.puts &quot;#{branchOpcode} #{jumpTarget.asmLabel}&quot;
 775     end
 776     
 777     def handleX86SubBranch(branchOpcode, kind)
 778         if operands.size == 4 and operands[1] == operands[2]
 779             $asm.puts &quot;neg#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}&quot;
 780             $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 781         else
 782             handleX86OpWithNumOperands(&quot;sub#{x86Suffix(kind)}&quot;, kind, operands.size - 1)
 783         end
 784         case operands.size
 785         when 4
 786             jumpTarget = operands[3]
 787         when 3
 788             jumpTarget = operands[2]
 789         else
 790             raise self.inspect
 791         end
 792         $asm.puts &quot;#{branchOpcode} #{jumpTarget.asmLabel}&quot;
 793     end
 794 
 795     def handleX86Add(kind)
 796         if operands.size == 3 and operands[1] == operands[2]
 797             unless Immediate.new(nil, 0) == operands[0]
 798                 $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 799             end
 800         elsif operands.size == 3 and operands[0].is_a? Immediate
 801             raise unless operands[1].is_a? RegisterID
 802             raise unless operands[2].is_a? RegisterID
 803             if operands[0].value == 0
 804                 if operands[1] != operands[2]
 805                     $asm.puts &quot;mov#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 806                 end
 807             else
 808                 $asm.puts &quot;lea#{x86Suffix(kind)} #{orderOperands(offsetRegister(operands[0].value, operands[1].x86Operand(kind)), operands[2].x86Operand(kind))}&quot;
 809             end
 810         elsif operands.size == 3 and operands[0].is_a? RegisterID
 811             raise unless operands[1].is_a? RegisterID
 812             raise unless operands[2].is_a? RegisterID
 813             if operands[0] == operands[2]
 814                 $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 815             else
 816                 if !isIntelSyntax
 817                     $asm.puts &quot;lea#{x86Suffix(kind)} (#{operands[0].x86Operand(kind)}, #{operands[1].x86Operand(kind)}), #{operands[2].x86Operand(kind)}&quot;
 818                 else
 819                     $asm.puts &quot;lea#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}, [#{operands[0].x86Operand(kind)} + #{operands[1].x86Operand(kind)}]&quot;
 820                 end
 821             end
 822         else
 823             unless Immediate.new(nil, 0) == operands[0]
 824                 $asm.puts &quot;add#{x86Suffix(kind)} #{x86Operands(kind, kind)}&quot;
 825             end
 826         end
 827     end
 828 
 829     def handleX86Sub(kind)
 830         if operands.size == 3
 831             if Immediate.new(nil, 0) == operands[1]
 832                 raise unless operands[0].is_a? RegisterID
 833                 raise unless operands[2].is_a? RegisterID
 834                 if operands[0] != operands[2]
 835                     $asm.puts &quot;mov#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 836                 end
 837                 return
 838             end
 839             if operands[1] == operands[2]
 840                 $asm.puts &quot;neg#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}&quot;
 841                 if Immediate.new(nil, 0) != operands[0]
 842                     $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 843                 end
 844                 return
 845             end
 846         end
 847 
 848         if operands.size == 2
 849             if Immediate.new(nil, 0) == operands[0]
 850                 return
 851             end
 852         end
 853 
 854         handleX86Op(&quot;sub#{x86Suffix(kind)}&quot;, kind)
 855     end
 856     
 857     def handleX86Mul(kind)
 858         if operands.size == 3 and operands[0].is_a? Immediate
 859             $asm.puts &quot;imul#{x86Suffix(kind)} #{x86Operands(kind, kind, kind)}&quot;
 860             return
 861         end
 862 
 863         if operands.size == 2 and operands[0].is_a? Immediate
 864             imm = operands[0].value
 865             if imm &gt; 0 and isPowerOfTwo(imm)
 866                 $asm.puts &quot;sal#{x86Suffix(kind)} #{orderOperands(Immediate.new(nil, Math.log2(imm).to_i).x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 867                 return
 868             end
 869         end
 870 
 871         handleX86Op(&quot;imul#{x86Suffix(kind)}&quot;, kind)
 872     end
 873     
 874     def handleX86AddFP(kind)
 875         if operands.size == 2
 876             $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 877         elsif operands.size == 3
 878             $asm.puts &quot;vadd#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 879         else
 880             raise &quot;Unexpected number of operands for floating point addition: #{operands.size}&quot;
 881         end
 882     end
 883 
 884     def handleX86SubFP(kind)
 885         if operands.size == 2
 886             $asm.puts &quot;sub#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 887         elsif operands.size == 3
 888             $asm.puts &quot;vsub#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 889         else
 890             raise &quot;Unexpected number of operands for floating point addition: #{operands.size}&quot;
 891         end
 892     end
 893 
 894     def handleX86MulFP(kind)
 895         if operands.size == 2
 896             $asm.puts &quot;mul#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 897         elsif operands.size == 3
 898             $asm.puts &quot;vmul#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 899         else
 900             raise &quot;Unexpected number of operands for floating point addition: #{operands.size}&quot;
 901         end
 902     end
 903 
 904     def handleX86DivFP(kind)
 905         if operands.size == 2
 906             $asm.puts &quot;div#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 907         elsif operands.size == 3
 908             $asm.puts &quot;vdiv#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 909         else
 910             raise &quot;Unexpected number of operands for floating point addition: #{operands.size}&quot;
 911         end
 912     end
 913 
 914     def handleX86Peek()
 915         sp = RegisterID.new(nil, &quot;sp&quot;)
 916         opA = offsetRegister(operands[0].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
 917         opB = operands[1].x86Operand(:ptr)
 918         $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
 919     end
 920 
 921     def handleX86Poke()
 922         sp = RegisterID.new(nil, &quot;sp&quot;)
 923         opA = operands[0].x86Operand(:ptr)
 924         opB = offsetRegister(operands[1].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
 925         $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
 926     end
 927 
 928     def handleMove
 929         if Immediate.new(nil, 0) == operands[0] and operands[1].is_a? RegisterID
 930             if isX64
 931                 $asm.puts &quot;xor#{x86Suffix(:quad)} #{operands[1].x86Operand(:quad)}, #{operands[1].x86Operand(:quad)}&quot;
 932             else
 933                 $asm.puts &quot;xor#{x86Suffix(:ptr)} #{operands[1].x86Operand(:ptr)}, #{operands[1].x86Operand(:ptr)}&quot;
 934             end
 935         elsif operands[0] != operands[1]
 936             if isX64
 937                 $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
 938             else
 939                 $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
 940             end
 941         end
 942     end
 943 
 944     def countLeadingZeros(kind)
 945         target = operands[1]
 946         srcIsNonZero = LocalLabel.unique(&quot;srcIsNonZero&quot;)
 947         skipNonZeroCase = LocalLabel.unique(&quot;skipNonZeroCase&quot;)
 948         zeroValue = Immediate.new(codeOrigin, x86Bytes(kind) * 8)
 949         xorValue = Immediate.new(codeOrigin, kind == :quad ? 0x3f : 0x1f)
 950         xor = kind == :quad ? &quot;xorq&quot; : &quot;xori&quot;
 951 
 952         $asm.puts &quot;bsr#{x86Suffix(kind)} #{x86Operands(kind, kind)}&quot;
 953 
 954         Sequence.new(codeOrigin, [
 955             Instruction.new(codeOrigin, &quot;bnz&quot;, [LocalLabelReference.new(codeOrigin, srcIsNonZero)]),
 956             Instruction.new(codeOrigin, &quot;move&quot;, [zeroValue, target]),
 957             Instruction.new(codeOrigin, &quot;jmp&quot;, [LocalLabelReference.new(codeOrigin, skipNonZeroCase)]),
 958 
 959             srcIsNonZero,
 960             Instruction.new(codeOrigin, xor, [xorValue, target]),
 961 
 962             skipNonZeroCase,
 963         ]).lower($activeBackend)
 964     end
 965 
 966     def countTrailingZeros(kind)
 967         target = operands[1]
 968         srcIsNonZero = LocalLabel.unique(&quot;srcIsNonZero&quot;)
 969         zeroValue = Immediate.new(codeOrigin, x86Bytes(kind) * 8)
 970 
 971         $asm.puts &quot;bsf#{x86Suffix(kind)} #{x86Operands(kind, kind)}&quot;
 972 
 973         Sequence.new(codeOrigin, [
 974             Instruction.new(codeOrigin, &quot;bnz&quot;, [LocalLabelReference.new(codeOrigin, srcIsNonZero)]),
 975             Instruction.new(codeOrigin, &quot;move&quot;, [zeroValue, target]),
 976             srcIsNonZero,
 977         ]).lower($activeBackend)
 978     end
 979 
 980     def truncateFloatingPointToQuad(kind)
 981         src = operands[0]
 982         dst = operands[1]
 983         slow = LocalLabel.unique(&quot;slow&quot;)
 984         done = LocalLabel.unique(&quot;done&quot;)
 985         gprScratch = X64_SCRATCH_REGISTER
 986         fprScratch = FPRegisterID.forName(codeOrigin, &quot;wfa7&quot;)
 987         int64SignBit = Immediate.new(codeOrigin, 0x8000000000000000)
 988         case kind
 989         when :float
 990             int64Min = Immediate.new(codeOrigin, 0xdf000000)
 991             negInt64Min = Immediate.new(codeOrigin, 0x5f000000)
 992             integerSuffix = &quot;i&quot;
 993             floatingSuffix = &quot;f&quot;
 994         when :double
 995             int64Min = Immediate.new(codeOrigin, 0xc3e0000000000000)
 996             negInt64Min = Immediate.new(codeOrigin, 0x43e0000000000000)
 997             integerSuffix = &quot;q&quot;
 998             floatingSuffix = &quot;d&quot;
 999         else
1000             raise
1001         end
1002 
1003         Sequence.new(codeOrigin, [
1004             Instruction.new(codeOrigin, &quot;move&quot;, [negInt64Min, gprScratch]),
1005             Instruction.new(codeOrigin, &quot;f#{integerSuffix}2#{floatingSuffix}&quot;, [gprScratch, fprScratch]),
1006             Instruction.new(codeOrigin, &quot;b#{floatingSuffix}gteq&quot;, [src, fprScratch, LocalLabelReference.new(codeOrigin, slow)]),
1007             Instruction.new(codeOrigin, &quot;truncate#{floatingSuffix}2qs&quot;, [src, dst]),
1008             Instruction.new(codeOrigin, &quot;jmp&quot;, [LocalLabelReference.new(codeOrigin, done)]),
1009 
1010             slow,
1011             Instruction.new(codeOrigin, &quot;move&quot;, [int64Min, gprScratch]),
1012             Instruction.new(codeOrigin, &quot;f#{integerSuffix}2#{floatingSuffix}&quot;, [gprScratch, fprScratch]),
1013             Instruction.new(codeOrigin, &quot;add#{floatingSuffix}&quot;, [src, fprScratch]),
1014             Instruction.new(codeOrigin, &quot;truncate#{floatingSuffix}2qs&quot;, [fprScratch, dst]),
1015             Instruction.new(codeOrigin, &quot;move&quot;, [int64SignBit, gprScratch]),
1016             Instruction.new(codeOrigin, &quot;orq&quot;, [gprScratch, dst]),
1017 
1018             done,
1019         ]).lower($activeBackend)
1020     end
1021 
1022     def convertQuadToFloatingPoint(kind)
1023         src = operands[0]
1024         scratch1 = operands[1]
1025         dst = operands[2]
1026         slow = LocalLabel.unique(&quot;slow&quot;)
1027         done = LocalLabel.unique(&quot;done&quot;)
1028         scratch2 = X64_SCRATCH_REGISTER
1029         one = Immediate.new(codeOrigin, 0x1)
1030 
1031         case kind
1032         when :float
1033             floatingSuffix = &quot;f&quot;
1034         when :double
1035             floatingSuffix = &quot;d&quot;
1036         else
1037             raise
1038         end
1039 
1040         Sequence.new(codeOrigin, [
1041             Instruction.new(codeOrigin, &quot;btqs&quot;, [src, LocalLabelReference.new(codeOrigin, slow)]),
1042             Instruction.new(codeOrigin, &quot;cq2#{floatingSuffix}s&quot;, [src, dst]),
1043             Instruction.new(codeOrigin, &quot;jmp&quot;, [LocalLabelReference.new(codeOrigin, done)]),
1044 
1045             slow,
1046             Instruction.new(codeOrigin, &quot;move&quot;, [src, scratch1]),
1047             Instruction.new(codeOrigin, &quot;move&quot;, [src, scratch2]),
1048             Instruction.new(codeOrigin, &quot;urshiftq&quot;, [one, scratch1]),
1049             Instruction.new(codeOrigin, &quot;andq&quot;, [one, scratch2]),
1050             Instruction.new(codeOrigin, &quot;orq&quot;, [scratch1, scratch2]),
1051             Instruction.new(codeOrigin, &quot;cq2#{floatingSuffix}s&quot;, [scratch2, dst]),
1052             Instruction.new(codeOrigin, &quot;add#{floatingSuffix}&quot;, [dst, dst]),
1053 
1054             done,
1055         ]).lower($activeBackend)
1056     end
1057 
1058     def lowerX86
1059         raise unless $activeBackend == &quot;X86&quot;
1060         lowerX86Common
1061     end
1062 
1063     def lowerX86_WIN
1064         raise unless $activeBackend == &quot;X86_WIN&quot; 
1065         lowerX86Common
1066     end
1067     
1068     def lowerX86_64
1069         raise unless $activeBackend == &quot;X86_64&quot;
1070         lowerX86Common
1071     end
1072 
1073     def lowerX86_64_WIN
1074         raise unless $activeBackend == &quot;X86_64_WIN&quot;
1075         lowerX86Common
1076     end
1077 
1078     def lowerX86Common
1079         case opcode
1080         when &quot;addi&quot;
1081             handleX86Add(:int)
1082         when &quot;addp&quot;
1083             handleX86Add(:ptr)
1084         when &quot;addq&quot;
1085             handleX86Add(:quad)
1086         when &quot;andi&quot;
1087             handleX86Op(&quot;and#{x86Suffix(:int)}&quot;, :int)
1088         when &quot;andp&quot;
1089             handleX86Op(&quot;and#{x86Suffix(:ptr)}&quot;, :ptr)
1090         when &quot;andq&quot;
1091             handleX86Op(&quot;and#{x86Suffix(:quad)}&quot;, :quad)
1092         when &quot;andf&quot;
1093             handleX86Op(&quot;andps&quot;, :float)
1094         when &quot;andd&quot;
1095             handleX86Op(&quot;andpd&quot;, :double)
1096         when &quot;lshifti&quot;
1097             handleX86Shift(&quot;sal#{x86Suffix(:int)}&quot;, :int)
1098         when &quot;lshiftp&quot;
1099             handleX86Shift(&quot;sal#{x86Suffix(:ptr)}&quot;, :ptr)
1100         when &quot;lshiftq&quot;
1101             handleX86Shift(&quot;sal#{x86Suffix(:quad)}&quot;, :quad)
1102         when &quot;muli&quot;
1103             handleX86Mul(:int)
1104         when &quot;mulp&quot;
1105             handleX86Mul(:ptr)
1106         when &quot;mulq&quot;
1107             handleX86Mul(:quad)
1108         when &quot;negi&quot;
1109             $asm.puts &quot;neg#{x86Suffix(:int)} #{x86Operands(:int)}&quot;
1110         when &quot;negp&quot;
1111             $asm.puts &quot;neg#{x86Suffix(:ptr)} #{x86Operands(:ptr)}&quot;
1112         when &quot;negq&quot;
1113             $asm.puts &quot;neg#{x86Suffix(:quad)} #{x86Operands(:quad)}&quot;
1114         when &quot;noti&quot;
1115             $asm.puts &quot;not#{x86Suffix(:int)} #{x86Operands(:int)}&quot;
1116         when &quot;ori&quot;
1117             handleX86Op(&quot;or#{x86Suffix(:int)}&quot;, :int)
1118         when &quot;orp&quot;
1119             handleX86Op(&quot;or#{x86Suffix(:ptr)}&quot;, :ptr)
1120         when &quot;orq&quot;
1121             handleX86Op(&quot;or#{x86Suffix(:quad)}&quot;, :quad)
1122         when &quot;orf&quot;
1123             handleX86Op(&quot;orps&quot;, :float)
1124         when &quot;ord&quot;
1125             handleX86Op(&quot;orpd&quot;, :double)
1126         when &quot;orh&quot;
1127             handleX86Op(&quot;or#{x86Suffix(:half)}&quot;, :half)
1128         when &quot;rshifti&quot;
1129             handleX86Shift(&quot;sar#{x86Suffix(:int)}&quot;, :int)
1130         when &quot;rshiftp&quot;
1131             handleX86Shift(&quot;sar#{x86Suffix(:ptr)}&quot;, :ptr)
1132         when &quot;rshiftq&quot;
1133             handleX86Shift(&quot;sar#{x86Suffix(:quad)}&quot;, :quad)
1134         when &quot;urshifti&quot;
1135             handleX86Shift(&quot;shr#{x86Suffix(:int)}&quot;, :int)
1136         when &quot;urshiftp&quot;
1137             handleX86Shift(&quot;shr#{x86Suffix(:ptr)}&quot;, :ptr)
1138         when &quot;urshiftq&quot;
1139             handleX86Shift(&quot;shr#{x86Suffix(:quad)}&quot;, :quad)
1140         when &quot;rrotatei&quot;
1141             handleX86Shift(&quot;ror#{x86Suffix(:int)}&quot;, :int)
1142         when &quot;rrotateq&quot;
1143             handleX86Shift(&quot;ror#{x86Suffix(:quad)}&quot;, :quad)
1144         when &quot;lrotatei&quot;
1145             handleX86Shift(&quot;rol#{x86Suffix(:int)}&quot;, :int)
1146         when &quot;lrotateq&quot;
1147             handleX86Shift(&quot;rol#{x86Suffix(:quad)}&quot;, :quad)
1148         when &quot;subi&quot;
1149             handleX86Sub(:int)
1150         when &quot;subp&quot;
1151             handleX86Sub(:ptr)
1152         when &quot;subq&quot;
1153             handleX86Sub(:quad)
1154         when &quot;xori&quot;
1155             handleX86Op(&quot;xor#{x86Suffix(:int)}&quot;, :int)
1156         when &quot;xorp&quot;
1157             handleX86Op(&quot;xor#{x86Suffix(:ptr)}&quot;, :ptr)
1158         when &quot;xorq&quot;
1159             handleX86Op(&quot;xor#{x86Suffix(:quad)}&quot;, :quad)
1160         when &quot;leap&quot;
1161             emitX86Lea(operands[0], operands[1], :ptr)
1162         when &quot;loadi&quot;
1163             $asm.puts &quot;mov#{x86Suffix(:int)} #{x86LoadOperands(:int, :int)}&quot;
1164         when &quot;storei&quot;
1165             $asm.puts &quot;mov#{x86Suffix(:int)} #{x86Operands(:int, :int)}&quot;
1166         when &quot;loadis&quot;
1167             if isX64
1168                 if !isIntelSyntax
1169                     $asm.puts &quot;movslq #{x86LoadOperands(:int, :quad)}&quot;
1170                 else
1171                     $asm.puts &quot;movsxd #{x86LoadOperands(:int, :quad)}&quot;
1172                 end
1173             else
1174                 $asm.puts &quot;mov#{x86Suffix(:int)} #{x86LoadOperands(:int, :int)}&quot;
1175             end
1176         when &quot;loadp&quot;
1177             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86LoadOperands(:ptr, :ptr)}&quot;
1178         when &quot;storep&quot;
1179             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
1180         when &quot;loadq&quot;
1181             $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86LoadOperands(:quad, :quad)}&quot;
1182         when &quot;storeq&quot;
1183             $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
1184         when &quot;loadb&quot;
1185             if !isIntelSyntax
1186                 $asm.puts &quot;movzbl #{x86LoadOperands(:byte, :int)}&quot;
1187             else
1188                 $asm.puts &quot;movzx #{x86LoadOperands(:byte, :int)}&quot;
1189             end
1190         when &quot;loadbsi&quot;
1191             if !isIntelSyntax
1192                 $asm.puts &quot;movsbl #{x86LoadOperands(:byte, :int)}&quot;
1193             else
1194                 $asm.puts &quot;movsx #{x86LoadOperands(:byte, :int)}&quot;
1195             end
1196         when &quot;loadbsq&quot;
1197             if !isIntelSyntax
1198                 $asm.puts &quot;movsbq #{x86LoadOperands(:byte, :quad)}&quot;
1199             else
1200                 $asm.puts &quot;movsx #{x86LoadOperands(:byte, :quad)}&quot;
1201             end
1202         when &quot;loadh&quot;
1203             if !isIntelSyntax
1204                 $asm.puts &quot;movzwl #{x86LoadOperands(:half, :int)}&quot;
1205             else
1206                 $asm.puts &quot;movzx #{x86LoadOperands(:half, :int)}&quot;
1207             end
1208         when &quot;loadhsi&quot;
1209             if !isIntelSyntax
1210                 $asm.puts &quot;movswl #{x86LoadOperands(:half, :int)}&quot;
1211             else
1212                 $asm.puts &quot;movsx #{x86LoadOperands(:half, :int)}&quot;
1213             end
1214         when &quot;loadhsq&quot;
1215             if !isIntelSyntax
1216                 $asm.puts &quot;movswq #{x86LoadOperands(:half, :quad)}&quot;
1217             else
1218                 $asm.puts &quot;movsx #{x86LoadOperands(:half, :quad)}&quot;
1219             end
1220         when &quot;storeb&quot;
1221             $asm.puts &quot;mov#{x86Suffix(:byte)} #{x86Operands(:byte, :byte)}&quot;
1222         when &quot;storeh&quot;
1223             $asm.puts &quot;mov#{x86Suffix(:half)} #{x86Operands(:half, :half)}&quot;
1224         when &quot;loadf&quot;
1225             $asm.puts &quot;movss #{x86Operands(:float, :float)}&quot;
1226         when &quot;loadd&quot;
1227             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
1228         when &quot;moved&quot;
1229             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
1230         when &quot;storef&quot;
1231             $asm.puts &quot;movss #{x86Operands(:float, :float)}&quot;
1232         when &quot;stored&quot;
1233             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
1234         when &quot;addf&quot;
1235             handleX86AddFP(:float)
1236         when &quot;addd&quot;
1237             handleX86AddFP(:double)
1238         when &quot;mulf&quot;
1239             handleX86MulFP(:float)
1240         when &quot;muld&quot;
1241             handleX86MulFP(:double)
1242         when &quot;subf&quot;
1243             handleX86SubFP(:float)
1244         when &quot;subd&quot;
1245             handleX86SubFP(:double)
1246         when &quot;divf&quot;
1247             handleX86DivFP(:float)
1248         when &quot;divd&quot;
1249             handleX86DivFP(:double)
1250         when &quot;sqrtf&quot;
1251             $asm.puts &quot;sqrtss #{operands[0].x86Operand(:float)}, #{operands[1].x86Operand(:float)}&quot;
1252         when &quot;sqrtd&quot;
1253             $asm.puts &quot;sqrtsd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
1254         when &quot;roundf&quot;
1255             $asm.puts &quot;roundss $0, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
1256         when &quot;roundd&quot;
1257             $asm.puts &quot;roundsd $0, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
1258         when &quot;floorf&quot;
1259             $asm.puts &quot;roundss $1, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
1260         when &quot;floord&quot;
1261             $asm.puts &quot;roundsd $1, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
1262         when &quot;ceilf&quot;
1263             $asm.puts &quot;roundss $2, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
1264         when &quot;ceild&quot;
1265             $asm.puts &quot;roundsd $2, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
1266         when &quot;truncatef&quot;
1267             $asm.puts &quot;roundss $3, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
1268         when &quot;truncated&quot;
1269             $asm.puts &quot;roundsd $3, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
1270         when &quot;truncatef2i&quot;
1271             $asm.puts &quot;cvttss2si #{operands[0].x86Operand(:float)}, #{operands[1].x86Operand(:quad)}&quot;
1272         when &quot;truncated2i&quot;
1273             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;
1274         when &quot;truncatef2q&quot;
1275             truncateFloatingPointToQuad(:float)
1276         when &quot;truncated2q&quot;
1277             truncateFloatingPointToQuad(:double)
1278         when &quot;truncatef2is&quot;
1279             $asm.puts &quot;cvttss2si #{operands[0].x86Operand(:float)}, #{operands[1].x86Operand(:int)}&quot;
1280         when &quot;truncatef2qs&quot;
1281             $asm.puts &quot;cvttss2si #{operands[0].x86Operand(:float)}, #{operands[1].x86Operand(:quad)}&quot;
1282         when &quot;truncated2is&quot;
1283             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1284         when &quot;truncated2qs&quot;
1285             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;
1286         when &quot;ci2d&quot;
1287             $asm.puts &quot;cvtsi2sd #{orderOperands(operands[0].x86Operand(:quad), operands[1].x86Operand(:double))}&quot;
1288         when &quot;ci2ds&quot;
1289             $asm.puts &quot;cvtsi2sd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:double))}&quot;
1290         when &quot;ci2fs&quot;
1291             $asm.puts &quot;cvtsi2ss #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:float))}&quot;
1292         when &quot;ci2f&quot;
1293             $asm.puts &quot;cvtsi2ss #{orderOperands(operands[0].x86Operand(:quad), operands[1].x86Operand(:float))}&quot;
1294         when &quot;cq2f&quot;
1295             convertQuadToFloatingPoint(:float)
1296         when &quot;cq2d&quot;
1297             convertQuadToFloatingPoint(:double)
1298         when &quot;cq2fs&quot;
1299             $asm.puts &quot;cvtsi2ssq #{orderOperands(operands[0].x86Operand(:quad), operands[1].x86Operand(:float))}&quot;
1300         when &quot;cq2ds&quot;
1301             $asm.puts &quot;cvtsi2sdq #{orderOperands(operands[0].x86Operand(:quad), operands[1].x86Operand(:double))}&quot;
1302         when &quot;cd2f&quot;
1303             $asm.puts &quot;cvtsd2ss #{x86Operands(:double, :float)}&quot;
1304         when &quot;cf2d&quot;
1305             $asm.puts &quot;cvtss2sd #{x86Operands(:float, :double)}&quot;
1306         when &quot;bdeq&quot;
1307             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
1308             if operands[0] == operands[1]
1309                 # This is just a jump ordered, which is a jnp.
1310                 $asm.puts &quot;jnp #{operands[2].asmLabel}&quot;
1311             else
1312                 isUnordered = LocalLabel.unique(&quot;bdeq&quot;)
1313                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1314                 $asm.puts &quot;je #{LocalLabelReference.new(codeOrigin, operands[2]).asmLabel}&quot;
1315                 isUnordered.lower($activeBackend)
1316             end
1317         when &quot;bdneq&quot;
1318             handleX86FPBranch(:double, &quot;jne&quot;, :normal)
1319         when &quot;bdgt&quot;
1320             handleX86FPBranch(:double, &quot;ja&quot;, :normal)
1321         when &quot;bdgteq&quot;
1322             handleX86FPBranch(:double, &quot;jae&quot;, :normal)
1323         when &quot;bdlt&quot;
1324             handleX86FPBranch(:double, &quot;ja&quot;, :reverse)
1325         when &quot;bdlteq&quot;
1326             handleX86FPBranch(:double, &quot;jae&quot;, :reverse)
1327         when &quot;bdequn&quot;
1328             handleX86FPBranch(:double, &quot;je&quot;, :normal)
1329         when &quot;bdnequn&quot;
1330             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
1331             if operands[0] == operands[1]
1332                 # This is just a jump unordered, which is a jp.
1333                 $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1334             else
1335                 isUnordered = LocalLabel.unique(&quot;bdnequn&quot;)
1336                 isEqual = LocalLabel.unique(&quot;bdnequn&quot;)
1337                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1338                 $asm.puts &quot;je #{LocalLabelReference.new(codeOrigin, isEqual).asmLabel}&quot;
1339                 isUnordered.lower($activeBackend)
1340                 $asm.puts &quot;jmp #{operands[2].asmLabel}&quot;
1341                 isEqual.lower($activeBackend)
1342             end
1343         when &quot;bdgtun&quot;
1344             handleX86FPBranch(:double, &quot;jb&quot;, :reverse)
1345         when &quot;bdgtequn&quot;
1346             handleX86FPBranch(:double, &quot;jbe&quot;, :reverse)
1347         when &quot;bdltun&quot;
1348             handleX86FPBranch(:double, &quot;jb&quot;, :normal)
1349         when &quot;bdltequn&quot;
1350             handleX86FPBranch(:double, &quot;jbe&quot;, :normal)
1351         when &quot;bfeq&quot;
1352             $asm.puts &quot;ucomiss #{orderOperands(operands[0].x86Operand(:float), operands[1].x86Operand(:float))}&quot;
1353             if operands[0] == operands[1]
1354                 # This is just a jump ordered, which is a jnp.
1355                 $asm.puts &quot;jnp #{operands[2].asmLabel}&quot;
1356             else
1357                 isUnordered = LocalLabel.unique(&quot;bfeq&quot;)
1358                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1359                 $asm.puts &quot;je #{LocalLabelReference.new(codeOrigin, operands[2]).asmLabel}&quot;
1360                 isUnordered.lower($activeBackend)
1361             end
1362         when &quot;bfgt&quot;
1363             handleX86FPBranch(:float, &quot;ja&quot;, :normal)
1364         when &quot;bfgteq&quot;
1365             handleX86FPBranch(:float, &quot;jae&quot;, :normal)
1366         when &quot;bflt&quot;
1367             handleX86FPBranch(:float, &quot;ja&quot;, :reverse)
1368         when &quot;bfgtun&quot;
1369             handleX86FPBranch(:float, &quot;jb&quot;, :reverse)
1370         when &quot;bfgtequn&quot;
1371             handleX86FPBranch(:float, &quot;jbe&quot;, :reverse)
1372         when &quot;bfltun&quot;
1373             handleX86FPBranch(:float, &quot;jb&quot;, :normal)
1374         when &quot;bfltequn&quot;
1375             handleX86FPBranch(:float, &quot;jbe&quot;, :normal)
1376         when &quot;btd2i&quot;
1377             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1378             $asm.puts &quot;cmpl $0x80000000 #{operands[1].x86Operand(:int)}&quot;
1379             $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1380         when &quot;td2i&quot;
1381             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1382         when &quot;bcd2i&quot;
1383             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1384             $asm.puts &quot;test#{x86Suffix(:int)} #{operands[1].x86Operand(:int)}, #{operands[1].x86Operand(:int)}&quot;
1385             $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1386             $asm.puts &quot;cvtsi2sd #{operands[1].x86Operand(:int)}, %xmm7&quot;
1387             $asm.puts &quot;ucomisd #{operands[0].x86Operand(:double)}, %xmm7&quot;
1388             $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1389             $asm.puts &quot;jne #{operands[2].asmLabel}&quot;
1390         when &quot;movdz&quot;
1391             $asm.puts &quot;xorpd #{operands[0].x86Operand(:double)}, #{operands[0].x86Operand(:double)}&quot;
1392         when &quot;pop&quot;
1393             operands.each {
1394                 | op |
1395                 $asm.puts &quot;pop #{op.x86Operand(:ptr)}&quot;
1396             }
1397         when &quot;push&quot;
1398             operands.each {
1399                 | op |
1400                 $asm.puts &quot;push #{op.x86Operand(:ptr)}&quot;
1401             }
1402         when &quot;move&quot;
1403             handleMove
1404         when &quot;sxi2q&quot;
1405             if !isIntelSyntax
1406                 $asm.puts &quot;movslq #{operands[0].x86Operand(:int)}, #{operands[1].x86Operand(:quad)}&quot;
1407             else
1408                 $asm.puts &quot;movsxd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:quad))}&quot;
1409             end
1410         when &quot;zxi2q&quot;
1411             $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:int))}&quot;
1412         when &quot;nop&quot;
1413             $asm.puts &quot;nop&quot;
1414         when &quot;bieq&quot;
1415             handleX86IntBranch(&quot;je&quot;, :int)
1416         when &quot;bpeq&quot;
1417             handleX86IntBranch(&quot;je&quot;, :ptr)
1418         when &quot;bqeq&quot;
1419             handleX86IntBranch(&quot;je&quot;, :quad)
1420         when &quot;bineq&quot;
1421             handleX86IntBranch(&quot;jne&quot;, :int)
1422         when &quot;bpneq&quot;
1423             handleX86IntBranch(&quot;jne&quot;, :ptr)
1424         when &quot;bqneq&quot;
1425             handleX86IntBranch(&quot;jne&quot;, :quad)
1426         when &quot;bia&quot;
1427             handleX86IntBranch(&quot;ja&quot;, :int)
1428         when &quot;bpa&quot;
1429             handleX86IntBranch(&quot;ja&quot;, :ptr)
1430         when &quot;bqa&quot;
1431             handleX86IntBranch(&quot;ja&quot;, :quad)
1432         when &quot;biaeq&quot;
1433             handleX86IntBranch(&quot;jae&quot;, :int)
1434         when &quot;bpaeq&quot;
1435             handleX86IntBranch(&quot;jae&quot;, :ptr)
1436         when &quot;bqaeq&quot;
1437             handleX86IntBranch(&quot;jae&quot;, :quad)
1438         when &quot;bib&quot;
1439             handleX86IntBranch(&quot;jb&quot;, :int)
1440         when &quot;bpb&quot;
1441             handleX86IntBranch(&quot;jb&quot;, :ptr)
1442         when &quot;bqb&quot;
1443             handleX86IntBranch(&quot;jb&quot;, :quad)
1444         when &quot;bibeq&quot;
1445             handleX86IntBranch(&quot;jbe&quot;, :int)
1446         when &quot;bpbeq&quot;
1447             handleX86IntBranch(&quot;jbe&quot;, :ptr)
1448         when &quot;bqbeq&quot;
1449             handleX86IntBranch(&quot;jbe&quot;, :quad)
1450         when &quot;bigt&quot;
1451             handleX86IntBranch(&quot;jg&quot;, :int)
1452         when &quot;bpgt&quot;
1453             handleX86IntBranch(&quot;jg&quot;, :ptr)
1454         when &quot;bqgt&quot;
1455             handleX86IntBranch(&quot;jg&quot;, :quad)
1456         when &quot;bigteq&quot;
1457             handleX86IntBranch(&quot;jge&quot;, :int)
1458         when &quot;bpgteq&quot;
1459             handleX86IntBranch(&quot;jge&quot;, :ptr)
1460         when &quot;bqgteq&quot;
1461             handleX86IntBranch(&quot;jge&quot;, :quad)
1462         when &quot;bilt&quot;
1463             handleX86IntBranch(&quot;jl&quot;, :int)
1464         when &quot;bplt&quot;
1465             handleX86IntBranch(&quot;jl&quot;, :ptr)
1466         when &quot;bqlt&quot;
1467             handleX86IntBranch(&quot;jl&quot;, :quad)
1468         when &quot;bilteq&quot;
1469             handleX86IntBranch(&quot;jle&quot;, :int)
1470         when &quot;bplteq&quot;
1471             handleX86IntBranch(&quot;jle&quot;, :ptr)
1472         when &quot;bqlteq&quot;
1473             handleX86IntBranch(&quot;jle&quot;, :quad)
1474         when &quot;bbeq&quot;
1475             handleX86IntBranch(&quot;je&quot;, :byte)
1476         when &quot;bbneq&quot;
1477             handleX86IntBranch(&quot;jne&quot;, :byte)
1478         when &quot;bba&quot;
1479             handleX86IntBranch(&quot;ja&quot;, :byte)
1480         when &quot;bbaeq&quot;
1481             handleX86IntBranch(&quot;jae&quot;, :byte)
1482         when &quot;bbb&quot;
1483             handleX86IntBranch(&quot;jb&quot;, :byte)
1484         when &quot;bbbeq&quot;
1485             handleX86IntBranch(&quot;jbe&quot;, :byte)
1486         when &quot;bbgt&quot;
1487             handleX86IntBranch(&quot;jg&quot;, :byte)
1488         when &quot;bbgteq&quot;
1489             handleX86IntBranch(&quot;jge&quot;, :byte)
1490         when &quot;bblt&quot;
1491             handleX86IntBranch(&quot;jl&quot;, :byte)
1492         when &quot;bblteq&quot;
1493             handleX86IntBranch(&quot;jlteq&quot;, :byte)
1494         when &quot;btis&quot;
1495             handleX86BranchTest(&quot;js&quot;, :int)
1496         when &quot;btps&quot;
1497             handleX86BranchTest(&quot;js&quot;, :ptr)
1498         when &quot;btqs&quot;
1499             handleX86BranchTest(&quot;js&quot;, :quad)
1500         when &quot;btiz&quot;
1501             handleX86BranchTest(&quot;jz&quot;, :int)
1502         when &quot;btpz&quot;
1503             handleX86BranchTest(&quot;jz&quot;, :ptr)
1504         when &quot;btqz&quot;
1505             handleX86BranchTest(&quot;jz&quot;, :quad)
1506         when &quot;btinz&quot;
1507             handleX86BranchTest(&quot;jnz&quot;, :int)
1508         when &quot;btpnz&quot;
1509             handleX86BranchTest(&quot;jnz&quot;, :ptr)
1510         when &quot;btqnz&quot;
1511             handleX86BranchTest(&quot;jnz&quot;, :quad)
1512         when &quot;btbs&quot;
1513             handleX86BranchTest(&quot;js&quot;, :byte)
1514         when &quot;btbz&quot;
1515             handleX86BranchTest(&quot;jz&quot;, :byte)
1516         when &quot;btbnz&quot;
1517             handleX86BranchTest(&quot;jnz&quot;, :byte)
1518         when &quot;jmp&quot;
1519             $asm.puts &quot;jmp #{operands[0].x86CallOperand(:ptr)}&quot;
1520         when &quot;baddio&quot;
1521             handleX86OpBranch(&quot;add#{x86Suffix(:int)}&quot;, &quot;jo&quot;, :int)
1522         when &quot;baddpo&quot;
1523             handleX86OpBranch(&quot;add#{x86Suffix(:ptr)}&quot;, &quot;jo&quot;, :ptr)
1524         when &quot;baddqo&quot;
1525             handleX86OpBranch(&quot;add#{x86Suffix(:quad)}&quot;, &quot;jo&quot;, :quad)
1526         when &quot;baddis&quot;
1527             handleX86OpBranch(&quot;add#{x86Suffix(:int)}&quot;, &quot;js&quot;, :int)
1528         when &quot;baddps&quot;
1529             handleX86OpBranch(&quot;add#{x86Suffix(:ptr)}&quot;, &quot;js&quot;, :ptr)
1530         when &quot;baddqs&quot;
1531             handleX86OpBranch(&quot;add#{x86Suffix(:quad)}&quot;, &quot;js&quot;, :quad)
1532         when &quot;baddiz&quot;
1533             handleX86OpBranch(&quot;add#{x86Suffix(:int)}&quot;, &quot;jz&quot;, :int)
1534         when &quot;baddpz&quot;
1535             handleX86OpBranch(&quot;add#{x86Suffix(:ptr)}&quot;, &quot;jz&quot;, :ptr)
1536         when &quot;baddqz&quot;
1537             handleX86OpBranch(&quot;add#{x86Suffix(:quad)}&quot;, &quot;jz&quot;, :quad)
1538         when &quot;baddinz&quot;
1539             handleX86OpBranch(&quot;add#{x86Suffix(:int)}&quot;, &quot;jnz&quot;, :int)
1540         when &quot;baddpnz&quot;
1541             handleX86OpBranch(&quot;add#{x86Suffix(:ptr)}&quot;, &quot;jnz&quot;, :ptr)
1542         when &quot;baddqnz&quot;
1543             handleX86OpBranch(&quot;add#{x86Suffix(:quad)}&quot;, &quot;jnz&quot;, :quad)
1544         when &quot;bsubio&quot;
1545             handleX86SubBranch(&quot;jo&quot;, :int)
1546         when &quot;bsubis&quot;
1547             handleX86SubBranch(&quot;js&quot;, :int)
1548         when &quot;bsubiz&quot;
1549             handleX86SubBranch(&quot;jz&quot;, :int)
1550         when &quot;bsubinz&quot;
1551             handleX86SubBranch(&quot;jnz&quot;, :int)
1552         when &quot;bmulio&quot;
1553             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jo&quot;, :int)
1554         when &quot;bmulis&quot;
1555             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;js&quot;, :int)
1556         when &quot;bmuliz&quot;
1557             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jz&quot;, :int)
1558         when &quot;bmulinz&quot;
1559             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jnz&quot;, :int)
1560         when &quot;borio&quot;
1561             handleX86OpBranch(&quot;orl&quot;, &quot;jo&quot;, :int)
1562         when &quot;boris&quot;
1563             handleX86OpBranch(&quot;orl&quot;, &quot;js&quot;, :int)
1564         when &quot;boriz&quot;
1565             handleX86OpBranch(&quot;orl&quot;, &quot;jz&quot;, :int)
1566         when &quot;borinz&quot;
1567             handleX86OpBranch(&quot;orl&quot;, &quot;jnz&quot;, :int)
1568         when &quot;break&quot;
1569             $asm.puts &quot;int #{const(3)}&quot;
1570         when &quot;call&quot;
1571             op = operands[0].x86CallOperand(:ptr)
1572             if operands[0].is_a? LabelReference
1573                 operands[0].used
1574             end
1575             $asm.puts &quot;call #{op}&quot;
1576         when &quot;ret&quot;
1577             $asm.puts &quot;ret&quot;
1578         when &quot;cieq&quot;
1579             handleX86IntCompareSet(&quot;sete&quot;, :int)
1580         when &quot;cbeq&quot;
1581             handleX86IntCompareSet(&quot;sete&quot;, :byte)
1582         when &quot;cpeq&quot;
1583             handleX86IntCompareSet(&quot;sete&quot;, :ptr)
1584         when &quot;cqeq&quot;
1585             handleX86IntCompareSet(&quot;sete&quot;, :quad)
1586         when &quot;cineq&quot;
1587             handleX86IntCompareSet(&quot;setne&quot;, :int)
1588         when &quot;cbneq&quot;
1589             handleX86IntCompareSet(&quot;setne&quot;, :byte)
1590         when &quot;cpneq&quot;
1591             handleX86IntCompareSet(&quot;setne&quot;, :ptr)
1592         when &quot;cqneq&quot;
1593             handleX86IntCompareSet(&quot;setne&quot;, :quad)
1594         when &quot;cia&quot;
1595             handleX86IntCompareSet(&quot;seta&quot;, :int)
1596         when &quot;cba&quot;
1597             handleX86IntCompareSet(&quot;seta&quot;, :byte)
1598         when &quot;cpa&quot;
1599             handleX86IntCompareSet(&quot;seta&quot;, :ptr)
1600         when &quot;cqa&quot;
1601             handleX86IntCompareSet(&quot;seta&quot;, :quad)
1602         when &quot;ciaeq&quot;
1603             handleX86IntCompareSet(&quot;setae&quot;, :int)
1604         when &quot;cbaeq&quot;
1605             handleX86IntCompareSet(&quot;setae&quot;, :byte)
1606         when &quot;cpaeq&quot;
1607             handleX86IntCompareSet(&quot;setae&quot;, :ptr)
1608         when &quot;cqaeq&quot;
1609             handleX86IntCompareSet(&quot;setae&quot;, :quad)
1610         when &quot;cib&quot;
1611             handleX86IntCompareSet(&quot;setb&quot;, :int)
1612         when &quot;cbb&quot;
1613             handleX86IntCompareSet(&quot;setb&quot;, :byte)
1614         when &quot;cpb&quot;
1615             handleX86IntCompareSet(&quot;setb&quot;, :ptr)
1616         when &quot;cqb&quot;
1617             handleX86IntCompareSet(&quot;setb&quot;, :quad)
1618         when &quot;cibeq&quot;
1619             handleX86IntCompareSet(&quot;setbe&quot;, :int)
1620         when &quot;cbbeq&quot;
1621             handleX86IntCompareSet(&quot;setbe&quot;, :byte)
1622         when &quot;cpbeq&quot;
1623             handleX86IntCompareSet(&quot;setbe&quot;, :ptr)
1624         when &quot;cqbeq&quot;
1625             handleX86IntCompareSet(&quot;setbe&quot;, :quad)
1626         when &quot;cigt&quot;
1627             handleX86IntCompareSet(&quot;setg&quot;, :int)
1628         when &quot;cbgt&quot;
1629             handleX86IntCompareSet(&quot;setg&quot;, :byte)
1630         when &quot;cpgt&quot;
1631             handleX86IntCompareSet(&quot;setg&quot;, :ptr)
1632         when &quot;cqgt&quot;
1633             handleX86IntCompareSet(&quot;setg&quot;, :quad)
1634         when &quot;cigteq&quot;
1635             handleX86IntCompareSet(&quot;setge&quot;, :int)
1636         when &quot;cbgteq&quot;
1637             handleX86IntCompareSet(&quot;setge&quot;, :byte)
1638         when &quot;cpgteq&quot;
1639             handleX86IntCompareSet(&quot;setge&quot;, :ptr)
1640         when &quot;cqgteq&quot;
1641             handleX86IntCompareSet(&quot;setge&quot;, :quad)
1642         when &quot;cilt&quot;
1643             handleX86IntCompareSet(&quot;setl&quot;, :int)
1644         when &quot;cblt&quot;
1645             handleX86IntCompareSet(&quot;setl&quot;, :byte)
1646         when &quot;cplt&quot;
1647             handleX86IntCompareSet(&quot;setl&quot;, :ptr)
1648         when &quot;cqlt&quot;
1649             handleX86IntCompareSet(&quot;setl&quot;, :quad)
1650         when &quot;cilteq&quot;
1651             handleX86IntCompareSet(&quot;setle&quot;, :int)
1652         when &quot;cblteq&quot;
1653             handleX86IntCompareSet(&quot;setle&quot;, :byte)
1654         when &quot;cplteq&quot;
1655             handleX86IntCompareSet(&quot;setle&quot;, :ptr)
1656         when &quot;cqlteq&quot;
1657             handleX86IntCompareSet(&quot;setle&quot;, :quad)
1658         when &quot;cfeq&quot;
1659             handleX86FPCompareSet(:float, :eq)
1660         when &quot;cdeq&quot;
1661             handleX86FPCompareSet(:double, :eq)
1662         when &quot;cfneq&quot;
1663             handleX86FPCompareSet(:float, &quot;setne&quot;)
1664         when &quot;cdneq&quot;
1665             handleX86FPCompareSet(:double, &quot;setne&quot;)
1666         when &quot;cfnequn&quot;
1667             handleX86FPCompareSet(:float, :nequn)
1668         when &quot;cdnequn&quot;
1669             handleX86FPCompareSet(:double, :nequn)
1670         when &quot;cfgt&quot;
1671             handleX86FPCompareSet(:float, &quot;seta&quot;)
1672         when &quot;cdgt&quot;
1673             handleX86FPCompareSet(:double, &quot;seta&quot;)
1674         when &quot;cfgteq&quot;
1675             handleX86FPCompareSet(:float, &quot;setae&quot;)
1676         when &quot;cdgteq&quot;
1677             handleX86FPCompareSet(:double, &quot;setae&quot;)
1678         when &quot;cflt&quot;
1679             handleX86FPCompareSet(:float, &quot;seta&quot;, :reverse)
1680         when &quot;cdlt&quot;
1681             handleX86FPCompareSet(:double, &quot;seta&quot;, :reverse)
1682         when &quot;cflteq&quot;
1683             handleX86FPCompareSet(:float, &quot;setae&quot;, :reverse)
1684         when &quot;cdlteq&quot;
1685             handleX86FPCompareSet(:double, &quot;setae&quot;, :reverse)
1686         when &quot;tis&quot;
1687             handleX86SetTest(&quot;sets&quot;, :int)
1688         when &quot;tiz&quot;
1689             handleX86SetTest(&quot;setz&quot;, :int)
1690         when &quot;tinz&quot;
1691             handleX86SetTest(&quot;setnz&quot;, :int)
1692         when &quot;tps&quot;
1693             handleX86SetTest(&quot;sets&quot;, :ptr)
1694         when &quot;tpz&quot;
1695             handleX86SetTest(&quot;setz&quot;, :ptr)
1696         when &quot;tpnz&quot;
1697             handleX86SetTest(&quot;setnz&quot;, :ptr)
1698         when &quot;tqs&quot;
1699             handleX86SetTest(&quot;sets&quot;, :quad)
1700         when &quot;tqz&quot;
1701             handleX86SetTest(&quot;setz&quot;, :quad)
1702         when &quot;tqnz&quot;
1703             handleX86SetTest(&quot;setnz&quot;, :quad)
1704         when &quot;tbs&quot;
1705             handleX86SetTest(&quot;sets&quot;, :byte)
1706         when &quot;tbz&quot;
1707             handleX86SetTest(&quot;setz&quot;, :byte)
1708         when &quot;tbnz&quot;
1709             handleX86SetTest(&quot;setnz&quot;, :byte)
1710         when &quot;peek&quot;
1711             handleX86Peek()
1712         when &quot;poke&quot;
1713             handleX86Poke()
1714         when &quot;cdqi&quot;
1715             $asm.puts &quot;cdq&quot;
1716         when &quot;cqoq&quot;
1717             $asm.puts &quot;cqo&quot;
1718         when &quot;idivi&quot;
1719             $asm.puts &quot;idiv#{x86Suffix(:int)} #{operands[0].x86Operand(:int)}&quot;
1720         when &quot;udivi&quot;
1721             $asm.puts &quot;div#{x86Suffix(:int)} #{operands[0].x86Operand(:int)}&quot;
1722         when &quot;idivq&quot;
1723             $asm.puts &quot;idiv#{x86Suffix(:quad)} #{operands[0].x86Operand(:quad)}&quot;
1724         when &quot;udivq&quot;
1725             $asm.puts &quot;div#{x86Suffix(:quad)} #{operands[0].x86Operand(:quad)}&quot;
1726         when &quot;popcnti&quot;
1727             $asm.puts &quot;popcnt#{x86Suffix(:int)} #{x86Operands(:int, :int)}&quot;
1728         when &quot;popcntq&quot;
1729             $asm.puts &quot;popcnt#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
1730         when &quot;tzcnti&quot;
1731             countTrailingZeros(:int)
1732         when &quot;tzcntq&quot;
1733             countTrailingZeros(:quad)
1734         when &quot;lzcnti&quot;
1735             countLeadingZeros(:int)
1736         when &quot;lzcntq&quot;
1737             countLeadingZeros(:quad)
1738         when &quot;fii2d&quot;
1739             $asm.puts &quot;movd #{operands[0].x86Operand(:int)}, #{operands[2].x86Operand(:double)}&quot;
1740             $asm.puts &quot;movd #{operands[1].x86Operand(:int)}, %xmm7&quot;
1741             $asm.puts &quot;psllq $32, %xmm7&quot;
1742             $asm.puts &quot;por %xmm7, #{operands[2].x86Operand(:double)}&quot;
1743         when &quot;fd2ii&quot;
1744             $asm.puts &quot;movd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1745             $asm.puts &quot;movsd #{operands[0].x86Operand(:double)}, %xmm7&quot;
1746             $asm.puts &quot;psrlq $32, %xmm7&quot;
1747             $asm.puts &quot;movd %xmm7, #{operands[2].x86Operand(:int)}&quot;
1748         when &quot;fq2d&quot;
1749             if !isIntelSyntax
1750                 $asm.puts &quot;movq #{operands[0].x86Operand(:quad)}, #{operands[1].x86Operand(:double)}&quot;
1751             else
1752                 # MASM does not accept register operands with movq.
1753                 # Debugging shows that movd actually moves a qword when using MASM.
1754                 $asm.puts &quot;movd #{operands[1].x86Operand(:double)}, #{operands[0].x86Operand(:quad)}&quot;
1755             end
1756         when &quot;fd2q&quot;
1757             if !isIntelSyntax
1758                 $asm.puts &quot;movq #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;
1759             else
1760                 # MASM does not accept register operands with movq.
1761                 # Debugging shows that movd actually moves a qword when using MASM.
1762                 $asm.puts &quot;movd #{operands[1].x86Operand(:quad)}, #{operands[0].x86Operand(:double)}&quot;
1763             end
1764         when &quot;fi2f&quot;
1765             $asm.puts &quot;movd #{x86Operands(:int, :float)}&quot;
1766         when &quot;ff2i&quot;
1767             $asm.puts &quot;movd #{x86Operands(:float, :int)}&quot;
1768         when &quot;bo&quot;
1769             $asm.puts &quot;jo #{operands[0].asmLabel}&quot;
1770         when &quot;bs&quot;
1771             $asm.puts &quot;js #{operands[0].asmLabel}&quot;
1772         when &quot;bz&quot;
1773             $asm.puts &quot;jz #{operands[0].asmLabel}&quot;
1774         when &quot;bnz&quot;
1775             $asm.puts &quot;jnz #{operands[0].asmLabel}&quot;
1776         when &quot;leai&quot;
1777             $asm.puts &quot;lea#{x86Suffix(:int)} #{orderOperands(operands[0].x86AddressOperand(:int), operands[1].x86Operand(:int))}&quot;
1778         when &quot;leap&quot;
1779             $asm.puts &quot;lea#{x86Suffix(:ptr)} #{orderOperands(operands[0].x86AddressOperand(:ptr), operands[1].x86Operand(:ptr))}&quot;
1780         when &quot;memfence&quot;
1781             sp = RegisterID.new(nil, &quot;sp&quot;)
1782             if isIntelSyntax
1783                 $asm.puts &quot;mfence&quot;
1784             else
1785                 $asm.puts &quot;lock; orl $0, (#{sp.x86Operand(:ptr)})&quot;
1786             end
1787         when &quot;absf&quot;
1788             $asm.puts &quot;movl #{orderOperands(&quot;$0x80000000&quot;, X64_SCRATCH_REGISTER.x86Operand(:int))}&quot;
1789             $asm.puts &quot;movd #{orderOperands(X64_SCRATCH_REGISTER.x86Operand(:int), operands[1].x86Operand(:float))}&quot;
1790             $asm.puts &quot;andnps #{orderOperands(operands[0].x86Operand(:float), operands[1].x86Operand(:float))}&quot;
1791         when &quot;absd&quot;
1792             $asm.puts &quot;movq #{orderOperands(&quot;$0x8000000000000000&quot;, X64_SCRATCH_REGISTER.x86Operand(:quad))}&quot;
1793             $asm.puts &quot;movd #{orderOperands(X64_SCRATCH_REGISTER.x86Operand(:quad), operands[1].x86Operand(:double))}&quot;
1794             $asm.puts &quot;andnps #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
1795         when &quot;negf&quot;
1796             $asm.puts &quot;movl #{orderOperands(&quot;$0x80000000&quot;, X64_SCRATCH_REGISTER.x86Operand(:int))}&quot;
1797             $asm.puts &quot;movd #{orderOperands(X64_SCRATCH_REGISTER.x86Operand(:int), operands[1].x86Operand(:float))}&quot;
1798             $asm.puts &quot;xorps #{orderOperands(operands[0].x86Operand(:float), operands[1].x86Operand(:float))}&quot;
1799         when &quot;negd&quot;
1800             $asm.puts &quot;movq #{orderOperands(&quot;$0x8000000000000000&quot;, X64_SCRATCH_REGISTER.x86Operand(:quad))}&quot;
1801             $asm.puts &quot;movd #{orderOperands(X64_SCRATCH_REGISTER.x86Operand(:quad), operands[1].x86Operand(:double))}&quot;
1802             $asm.puts &quot;xorpd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
1803         when &quot;tls_loadp&quot;
1804             raise &quot;tls_loadp is only supported on x64&quot; unless isX64
1805             if operands[0].immediate?
1806                 mem = &quot;%gs:#{operands[0].value * 8}&quot;
1807             else
1808                 mem = BaseIndex.new(codeOrigin, nil, operands[0], 8, &quot;%gs:&quot;).x86AddressOperand(:quad)
1809             end
1810             $asm.puts &quot;movq #{orderOperands(mem, operands[1].x86Operand(:quad))}&quot;
1811         when &quot;tls_loadp&quot;
1812             raise &quot;tls_loadp is only supported on x64&quot; unless isX64
1813             if operands[0].immediate?
1814                 mem = &quot;%gs:#{operands[0].value * x86Bytes(:ptr)}&quot;
1815             else
1816                 mem = BaseIndex.new(codeOrigin, nil, operands[0], x86Bytes(:ptr), &quot;%gs:&quot;).x86AddressOperand(:quad)
1817             end
1818             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(mem, operands[1].x86Operand(:quad))}&quot;
1819         when &quot;tls_storep&quot;
1820             raise &quot;tls_loadp is only supported on x64&quot; unless isX64
1821             if operands[1].immediate?
1822                 mem = &quot;%gs:#{operands[1].value * x86Bytes(:ptr)}&quot;
1823             else
1824                 mem = BaseIndex.new(codeOrigin, nil, operands[1], x86Bytes(:ptr), &quot;%gs:&quot;).x86AddressOperand(:ptr)
1825             end
1826             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(operands[0].x86Operand(:ptr), mem)}&quot;
1827         else
1828             lowerDefault
1829         end
1830     end
1831 end
1832 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLRenderingContextBase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContextBase.idl.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,12 ***</span>
  #if ENABLE(WEBGL)
  
  #include &quot;ActivityStateChangeObserver.h&quot;
  #include &quot;ExceptionOr.h&quot;
  #include &quot;GPUBasedCanvasRenderingContext.h&quot;
<span class="line-modified">! #include &quot;GraphicsContext3D.h&quot;</span>
  #include &quot;ImageBuffer.h&quot;
  #include &quot;Timer.h&quot;
  #include &quot;WebGLAny.h&quot;
  #include &quot;WebGLBuffer.h&quot;
  #include &quot;WebGLContextAttributes.h&quot;
  #include &quot;WebGLFramebuffer.h&quot;
<span class="line-new-header">--- 28,13 ---</span>
  #if ENABLE(WEBGL)
  
  #include &quot;ActivityStateChangeObserver.h&quot;
  #include &quot;ExceptionOr.h&quot;
  #include &quot;GPUBasedCanvasRenderingContext.h&quot;
<span class="line-modified">! #include &quot;GraphicsContextGLOpenGL.h&quot;</span>
  #include &quot;ImageBuffer.h&quot;
<span class="line-added">+ #include &quot;SuspendableTimer.h&quot;</span>
  #include &quot;Timer.h&quot;
  #include &quot;WebGLAny.h&quot;
  #include &quot;WebGLBuffer.h&quot;
  #include &quot;WebGLContextAttributes.h&quot;
  #include &quot;WebGLFramebuffer.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,16 ***</span>
<span class="line-new-header">--- 67,20 ---</span>
  class OESTextureFloatLinear;
  class OESTextureHalfFloat;
  class OESTextureHalfFloatLinear;
  class OESVertexArrayObject;
  class OESElementIndexUint;
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
  class OffscreenCanvas;
<span class="line-added">+ #endif</span>
  class WebGLActiveInfo;
  class WebGLContextGroup;
  class WebGLContextObject;
  class WebGLCompressedTextureASTC;
  class WebGLCompressedTextureATC;
<span class="line-added">+ class WebGLCompressedTextureETC;</span>
<span class="line-added">+ class WebGLCompressedTextureETC1;</span>
  class WebGLCompressedTexturePVRTC;
  class WebGLCompressedTextureS3TC;
  class WebGLDebugRendererInfo;
  class WebGLDebugShaders;
  class WebGLDepthTexture;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,164 ***</span>
  
  #if ENABLE(VIDEO)
  class HTMLVideoElement;
  #endif
  
  using WebGLCanvas = WTF::Variant&lt;RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;OffscreenCanvas&gt;&gt;;
  
<span class="line-modified">! class WebGLRenderingContextBase : public GraphicsContext3D::Client, public GPUBasedCanvasRenderingContext, private ActivityStateChangeObserver {</span>
      WTF_MAKE_ISO_ALLOCATED(WebGLRenderingContextBase);
  public:
      static std::unique_ptr&lt;WebGLRenderingContextBase&gt; create(CanvasBase&amp;, WebGLContextAttributes&amp;, const String&amp;);
      virtual ~WebGLRenderingContextBase();
  
      WebGLCanvas canvas();
  
      int drawingBufferWidth() const;
      int drawingBufferHeight() const;
  
<span class="line-modified">!     void activeTexture(GC3Denum texture);</span>
      void attachShader(WebGLProgram*, WebGLShader*);
<span class="line-modified">!     void bindAttribLocation(WebGLProgram*, GC3Duint index, const String&amp; name);</span>
<span class="line-modified">!     void bindBuffer(GC3Denum target, WebGLBuffer*);</span>
<span class="line-modified">!     void bindFramebuffer(GC3Denum target, WebGLFramebuffer*);</span>
<span class="line-modified">!     void bindRenderbuffer(GC3Denum target, WebGLRenderbuffer*);</span>
<span class="line-modified">!     void bindTexture(GC3Denum target, WebGLTexture*);</span>
<span class="line-modified">!     void blendColor(GC3Dfloat red, GC3Dfloat green, GC3Dfloat blue, GC3Dfloat alpha);</span>
<span class="line-modified">!     void blendEquation(GC3Denum mode);</span>
<span class="line-modified">!     void blendEquationSeparate(GC3Denum modeRGB, GC3Denum modeAlpha);</span>
<span class="line-modified">!     void blendFunc(GC3Denum sfactor, GC3Denum dfactor);</span>
<span class="line-modified">!     void blendFuncSeparate(GC3Denum srcRGB, GC3Denum dstRGB, GC3Denum srcAlpha, GC3Denum dstAlpha);</span>
  
      using BufferDataSource = WTF::Variant&lt;RefPtr&lt;ArrayBuffer&gt;, RefPtr&lt;ArrayBufferView&gt;&gt;;
<span class="line-modified">!     void bufferData(GC3Denum target, long long size, GC3Denum usage);</span>
<span class="line-modified">!     void bufferData(GC3Denum target, Optional&lt;BufferDataSource&gt;&amp;&amp;, GC3Denum usage);</span>
<span class="line-modified">!     void bufferSubData(GC3Denum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     GC3Denum checkFramebufferStatus(GC3Denum target);</span>
<span class="line-modified">!     virtual void clear(GC3Dbitfield mask) = 0;</span>
<span class="line-modified">!     void clearColor(GC3Dfloat red, GC3Dfloat green, GC3Dfloat blue, GC3Dfloat alpha);</span>
<span class="line-modified">!     void clearDepth(GC3Dfloat);</span>
<span class="line-modified">!     void clearStencil(GC3Dint);</span>
<span class="line-modified">!     void colorMask(GC3Dboolean red, GC3Dboolean green, GC3Dboolean blue, GC3Dboolean alpha);</span>
      void compileShader(WebGLShader*);
  
<span class="line-modified">!     void compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, ArrayBufferView&amp; data);</span>
<span class="line-modified">!     void compressedTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; data);</span>
  
<span class="line-modified">!     void copyTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Dint border);</span>
<span class="line-modified">!     void copyTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);</span>
  
      RefPtr&lt;WebGLBuffer&gt; createBuffer();
      RefPtr&lt;WebGLFramebuffer&gt; createFramebuffer();
      RefPtr&lt;WebGLProgram&gt; createProgram();
      RefPtr&lt;WebGLRenderbuffer&gt; createRenderbuffer();
<span class="line-modified">!     RefPtr&lt;WebGLShader&gt; createShader(GC3Denum type);</span>
      RefPtr&lt;WebGLTexture&gt; createTexture();
  
<span class="line-modified">!     void cullFace(GC3Denum mode);</span>
  
      void deleteBuffer(WebGLBuffer*);
      void deleteFramebuffer(WebGLFramebuffer*);
      void deleteProgram(WebGLProgram*);
      void deleteRenderbuffer(WebGLRenderbuffer*);
      void deleteShader(WebGLShader*);
      void deleteTexture(WebGLTexture*);
  
<span class="line-modified">!     void depthFunc(GC3Denum);</span>
<span class="line-modified">!     void depthMask(GC3Dboolean);</span>
<span class="line-modified">!     void depthRange(GC3Dfloat zNear, GC3Dfloat zFar);</span>
      void detachShader(WebGLProgram*, WebGLShader*);
<span class="line-modified">!     void disable(GC3Denum cap);</span>
<span class="line-modified">!     void disableVertexAttribArray(GC3Duint index);</span>
<span class="line-modified">!     void drawArrays(GC3Denum mode, GC3Dint first, GC3Dsizei count);</span>
<span class="line-modified">!     void drawElements(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset);</span>
  
<span class="line-modified">!     void enable(GC3Denum cap);</span>
<span class="line-modified">!     void enableVertexAttribArray(GC3Duint index);</span>
      void finish();
      void flush();
<span class="line-modified">!     void framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, WebGLRenderbuffer*);</span>
<span class="line-modified">!     void framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, WebGLTexture*, GC3Dint level);</span>
<span class="line-modified">!     void frontFace(GC3Denum mode);</span>
<span class="line-modified">!     void generateMipmap(GC3Denum target);</span>
  
<span class="line-modified">!     RefPtr&lt;WebGLActiveInfo&gt; getActiveAttrib(WebGLProgram*, GC3Duint index);</span>
<span class="line-modified">!     RefPtr&lt;WebGLActiveInfo&gt; getActiveUniform(WebGLProgram*, GC3Duint index);</span>
      Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; getAttachedShaders(WebGLProgram*);
<span class="line-modified">!     GC3Dint getAttribLocation(WebGLProgram*, const String&amp; name);</span>
<span class="line-modified">!     WebGLAny getBufferParameter(GC3Denum target, GC3Denum pname);</span>
      Optional&lt;WebGLContextAttributes&gt; getContextAttributes();
<span class="line-modified">!     GC3Denum getError();</span>
      virtual WebGLExtension* getExtension(const String&amp; name) = 0;
<span class="line-modified">!     virtual WebGLAny getFramebufferAttachmentParameter(GC3Denum target, GC3Denum attachment, GC3Denum pname) = 0;</span>
<span class="line-modified">!     virtual WebGLAny getParameter(GC3Denum pname) = 0;</span>
<span class="line-modified">!     WebGLAny getProgramParameter(WebGLProgram*, GC3Denum pname);</span>
      String getProgramInfoLog(WebGLProgram*);
<span class="line-modified">!     WebGLAny getRenderbufferParameter(GC3Denum target, GC3Denum pname);</span>
<span class="line-modified">!     WebGLAny getShaderParameter(WebGLShader*, GC3Denum pname);</span>
      String getShaderInfoLog(WebGLShader*);
<span class="line-modified">!     RefPtr&lt;WebGLShaderPrecisionFormat&gt; getShaderPrecisionFormat(GC3Denum shaderType, GC3Denum precisionType);</span>
      String getShaderSource(WebGLShader*);
      virtual Optional&lt;Vector&lt;String&gt;&gt; getSupportedExtensions() = 0;
<span class="line-modified">!     WebGLAny getTexParameter(GC3Denum target, GC3Denum pname);</span>
      WebGLAny getUniform(WebGLProgram*, const WebGLUniformLocation*);
      RefPtr&lt;WebGLUniformLocation&gt; getUniformLocation(WebGLProgram*, const String&amp;);
<span class="line-modified">!     WebGLAny getVertexAttrib(GC3Duint index, GC3Denum pname);</span>
<span class="line-modified">!     long long getVertexAttribOffset(GC3Duint index, GC3Denum pname);</span>
  
      bool extensionIsEnabled(const String&amp;);
  
      bool isPreservingDrawingBuffer() const { return m_attributes.preserveDrawingBuffer; }
      void setPreserveDrawingBuffer(bool value) { m_attributes.preserveDrawingBuffer = value; }
  
      bool preventBufferClearForInspector() const { return m_preventBufferClearForInspector; }
      void setPreventBufferClearForInspector(bool value) { m_preventBufferClearForInspector = value; }
  
<span class="line-modified">!     virtual void hint(GC3Denum target, GC3Denum mode) = 0;</span>
<span class="line-modified">!     GC3Dboolean isBuffer(WebGLBuffer*);</span>
      bool isContextLost() const;
<span class="line-modified">!     GC3Dboolean isEnabled(GC3Denum cap);</span>
<span class="line-modified">!     GC3Dboolean isFramebuffer(WebGLFramebuffer*);</span>
<span class="line-modified">!     GC3Dboolean isProgram(WebGLProgram*);</span>
<span class="line-modified">!     GC3Dboolean isRenderbuffer(WebGLRenderbuffer*);</span>
<span class="line-modified">!     GC3Dboolean isShader(WebGLShader*);</span>
<span class="line-modified">!     GC3Dboolean isTexture(WebGLTexture*);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     void lineWidth(GC3Dfloat);</span>
      void linkProgram(WebGLProgram*);
      bool linkProgramWithoutInvalidatingAttribLocations(WebGLProgram*);
<span class="line-modified">!     void pixelStorei(GC3Denum pname, GC3Dint param);</span>
<span class="line-modified">!     void polygonOffset(GC3Dfloat factor, GC3Dfloat units);</span>
<span class="line-modified">!     void readPixels(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, ArrayBufferView&amp; pixels);</span>
      void releaseShaderCompiler();
<span class="line-modified">!     virtual void renderbufferStorage(GC3Denum target, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height) = 0;</span>
<span class="line-modified">!     void sampleCoverage(GC3Dfloat value, GC3Dboolean invert);</span>
<span class="line-modified">!     void scissor(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);</span>
      void shaderSource(WebGLShader*, const String&amp;);
<span class="line-modified">!     void stencilFunc(GC3Denum func, GC3Dint ref, GC3Duint mask);</span>
<span class="line-modified">!     void stencilFuncSeparate(GC3Denum face, GC3Denum func, GC3Dint ref, GC3Duint mask);</span>
<span class="line-modified">!     void stencilMask(GC3Duint);</span>
<span class="line-modified">!     void stencilMaskSeparate(GC3Denum face, GC3Duint mask);</span>
<span class="line-modified">!     void stencilOp(GC3Denum fail, GC3Denum zfail, GC3Denum zpass);</span>
<span class="line-modified">!     void stencilOpSeparate(GC3Denum face, GC3Denum fail, GC3Denum zfail, GC3Denum zpass);</span>
  
<span class="line-modified">!     void texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);</span>
  
  #if ENABLE(VIDEO)
      using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;HTMLVideoElement&gt;&gt;;
  #else
      using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;&gt;;
  #endif
  
<span class="line-modified">!     ExceptionOr&lt;void&gt; texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt;);</span>
  
<span class="line-modified">!     void texParameterf(GC3Denum target, GC3Denum pname, GC3Dfloat param);</span>
<span class="line-modified">!     void texParameteri(GC3Denum target, GC3Denum pname, GC3Dint param);</span>
  
<span class="line-modified">!     void texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);</span>
<span class="line-modified">!     ExceptionOr&lt;void&gt; texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt;&amp;&amp;);</span>
  
      template &lt;class TypedArray, class DataType&gt;
      class TypedList {
      public:
          using VariantType = Variant&lt;RefPtr&lt;TypedArray&gt;, Vector&lt;DataType&gt;&gt;;
<span class="line-new-header">--- 95,168 ---</span>
  
  #if ENABLE(VIDEO)
  class HTMLVideoElement;
  #endif
  
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
  using WebGLCanvas = WTF::Variant&lt;RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;OffscreenCanvas&gt;&gt;;
<span class="line-added">+ #else</span>
<span class="line-added">+ using WebGLCanvas = WTF::Variant&lt;RefPtr&lt;HTMLCanvasElement&gt;&gt;;</span>
<span class="line-added">+ #endif</span>
  
<span class="line-modified">! class WebGLRenderingContextBase : public GraphicsContextGLOpenGL::Client, public GPUBasedCanvasRenderingContext, private ActivityStateChangeObserver {</span>
      WTF_MAKE_ISO_ALLOCATED(WebGLRenderingContextBase);
  public:
      static std::unique_ptr&lt;WebGLRenderingContextBase&gt; create(CanvasBase&amp;, WebGLContextAttributes&amp;, const String&amp;);
      virtual ~WebGLRenderingContextBase();
  
      WebGLCanvas canvas();
  
      int drawingBufferWidth() const;
      int drawingBufferHeight() const;
  
<span class="line-modified">!     void activeTexture(GCGLenum texture);</span>
      void attachShader(WebGLProgram*, WebGLShader*);
<span class="line-modified">!     void bindAttribLocation(WebGLProgram*, GCGLuint index, const String&amp; name);</span>
<span class="line-modified">!     void bindBuffer(GCGLenum target, WebGLBuffer*);</span>
<span class="line-modified">!     void bindFramebuffer(GCGLenum target, WebGLFramebuffer*);</span>
<span class="line-modified">!     void bindRenderbuffer(GCGLenum target, WebGLRenderbuffer*);</span>
<span class="line-modified">!     void bindTexture(GCGLenum target, WebGLTexture*);</span>
<span class="line-modified">!     void blendColor(GCGLfloat red, GCGLfloat green, GCGLfloat blue, GCGLfloat alpha);</span>
<span class="line-modified">!     void blendEquation(GCGLenum mode);</span>
<span class="line-modified">!     void blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha);</span>
<span class="line-modified">!     void blendFunc(GCGLenum sfactor, GCGLenum dfactor);</span>
<span class="line-modified">!     void blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha);</span>
  
      using BufferDataSource = WTF::Variant&lt;RefPtr&lt;ArrayBuffer&gt;, RefPtr&lt;ArrayBufferView&gt;&gt;;
<span class="line-modified">!     void bufferData(GCGLenum target, long long size, GCGLenum usage);</span>
<span class="line-modified">!     void bufferData(GCGLenum target, Optional&lt;BufferDataSource&gt;&amp;&amp;, GCGLenum usage);</span>
<span class="line-modified">!     void bufferSubData(GCGLenum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     GCGLenum checkFramebufferStatus(GCGLenum target);</span>
<span class="line-modified">!     virtual void clear(GCGLbitfield mask) = 0;</span>
<span class="line-modified">!     void clearColor(GCGLfloat red, GCGLfloat green, GCGLfloat blue, GCGLfloat alpha);</span>
<span class="line-modified">!     void clearDepth(GCGLfloat);</span>
<span class="line-modified">!     void clearStencil(GCGLint);</span>
<span class="line-modified">!     void colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha);</span>
      void compileShader(WebGLShader*);
  
<span class="line-modified">!     void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, ArrayBufferView&amp; data);</span>
<span class="line-modified">!     void compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; data);</span>
  
<span class="line-modified">!     void copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border);</span>
<span class="line-modified">!     void copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);</span>
  
      RefPtr&lt;WebGLBuffer&gt; createBuffer();
      RefPtr&lt;WebGLFramebuffer&gt; createFramebuffer();
      RefPtr&lt;WebGLProgram&gt; createProgram();
      RefPtr&lt;WebGLRenderbuffer&gt; createRenderbuffer();
<span class="line-modified">!     RefPtr&lt;WebGLShader&gt; createShader(GCGLenum type);</span>
      RefPtr&lt;WebGLTexture&gt; createTexture();
  
<span class="line-modified">!     void cullFace(GCGLenum mode);</span>
  
      void deleteBuffer(WebGLBuffer*);
      void deleteFramebuffer(WebGLFramebuffer*);
      void deleteProgram(WebGLProgram*);
      void deleteRenderbuffer(WebGLRenderbuffer*);
      void deleteShader(WebGLShader*);
      void deleteTexture(WebGLTexture*);
  
<span class="line-modified">!     void depthFunc(GCGLenum);</span>
<span class="line-modified">!     void depthMask(GCGLboolean);</span>
<span class="line-modified">!     void depthRange(GCGLfloat zNear, GCGLfloat zFar);</span>
      void detachShader(WebGLProgram*, WebGLShader*);
<span class="line-modified">!     void disable(GCGLenum cap);</span>
<span class="line-modified">!     void disableVertexAttribArray(GCGLuint index);</span>
<span class="line-modified">!     void drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count);</span>
<span class="line-modified">!     void drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset);</span>
  
<span class="line-modified">!     void enable(GCGLenum cap);</span>
<span class="line-modified">!     void enableVertexAttribArray(GCGLuint index);</span>
      void finish();
      void flush();
<span class="line-modified">!     void framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, WebGLRenderbuffer*);</span>
<span class="line-modified">!     void framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, WebGLTexture*, GCGLint level);</span>
<span class="line-modified">!     void frontFace(GCGLenum mode);</span>
<span class="line-modified">!     void generateMipmap(GCGLenum target);</span>
  
<span class="line-modified">!     RefPtr&lt;WebGLActiveInfo&gt; getActiveAttrib(WebGLProgram*, GCGLuint index);</span>
<span class="line-modified">!     RefPtr&lt;WebGLActiveInfo&gt; getActiveUniform(WebGLProgram*, GCGLuint index);</span>
      Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; getAttachedShaders(WebGLProgram*);
<span class="line-modified">!     GCGLint getAttribLocation(WebGLProgram*, const String&amp; name);</span>
<span class="line-modified">!     WebGLAny getBufferParameter(GCGLenum target, GCGLenum pname);</span>
      Optional&lt;WebGLContextAttributes&gt; getContextAttributes();
<span class="line-modified">!     GCGLenum getError();</span>
      virtual WebGLExtension* getExtension(const String&amp; name) = 0;
<span class="line-modified">!     virtual WebGLAny getFramebufferAttachmentParameter(GCGLenum target, GCGLenum attachment, GCGLenum pname) = 0;</span>
<span class="line-modified">!     virtual WebGLAny getParameter(GCGLenum pname) = 0;</span>
<span class="line-modified">!     WebGLAny getProgramParameter(WebGLProgram*, GCGLenum pname);</span>
      String getProgramInfoLog(WebGLProgram*);
<span class="line-modified">!     WebGLAny getRenderbufferParameter(GCGLenum target, GCGLenum pname);</span>
<span class="line-modified">!     WebGLAny getShaderParameter(WebGLShader*, GCGLenum pname);</span>
      String getShaderInfoLog(WebGLShader*);
<span class="line-modified">!     RefPtr&lt;WebGLShaderPrecisionFormat&gt; getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType);</span>
      String getShaderSource(WebGLShader*);
      virtual Optional&lt;Vector&lt;String&gt;&gt; getSupportedExtensions() = 0;
<span class="line-modified">!     WebGLAny getTexParameter(GCGLenum target, GCGLenum pname);</span>
      WebGLAny getUniform(WebGLProgram*, const WebGLUniformLocation*);
      RefPtr&lt;WebGLUniformLocation&gt; getUniformLocation(WebGLProgram*, const String&amp;);
<span class="line-modified">!     WebGLAny getVertexAttrib(GCGLuint index, GCGLenum pname);</span>
<span class="line-modified">!     long long getVertexAttribOffset(GCGLuint index, GCGLenum pname);</span>
  
      bool extensionIsEnabled(const String&amp;);
  
      bool isPreservingDrawingBuffer() const { return m_attributes.preserveDrawingBuffer; }
      void setPreserveDrawingBuffer(bool value) { m_attributes.preserveDrawingBuffer = value; }
  
      bool preventBufferClearForInspector() const { return m_preventBufferClearForInspector; }
      void setPreventBufferClearForInspector(bool value) { m_preventBufferClearForInspector = value; }
  
<span class="line-modified">!     virtual void hint(GCGLenum target, GCGLenum mode) = 0;</span>
<span class="line-modified">!     GCGLboolean isBuffer(WebGLBuffer*);</span>
      bool isContextLost() const;
<span class="line-modified">!     GCGLboolean isEnabled(GCGLenum cap);</span>
<span class="line-modified">!     GCGLboolean isFramebuffer(WebGLFramebuffer*);</span>
<span class="line-modified">!     GCGLboolean isProgram(WebGLProgram*);</span>
<span class="line-modified">!     GCGLboolean isRenderbuffer(WebGLRenderbuffer*);</span>
<span class="line-modified">!     GCGLboolean isShader(WebGLShader*);</span>
<span class="line-modified">!     GCGLboolean isTexture(WebGLTexture*);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     void lineWidth(GCGLfloat);</span>
      void linkProgram(WebGLProgram*);
      bool linkProgramWithoutInvalidatingAttribLocations(WebGLProgram*);
<span class="line-modified">!     void pixelStorei(GCGLenum pname, GCGLint param);</span>
<span class="line-modified">!     void polygonOffset(GCGLfloat factor, GCGLfloat units);</span>
<span class="line-modified">!     void readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, ArrayBufferView&amp; pixels);</span>
      void releaseShaderCompiler();
<span class="line-modified">!     virtual void renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height) = 0;</span>
<span class="line-modified">!     void sampleCoverage(GCGLfloat value, GCGLboolean invert);</span>
<span class="line-modified">!     void scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);</span>
      void shaderSource(WebGLShader*, const String&amp;);
<span class="line-modified">!     void stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask);</span>
<span class="line-modified">!     void stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask);</span>
<span class="line-modified">!     void stencilMask(GCGLuint);</span>
<span class="line-modified">!     void stencilMaskSeparate(GCGLenum face, GCGLuint mask);</span>
<span class="line-modified">!     void stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass);</span>
<span class="line-modified">!     void stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass);</span>
  
<span class="line-modified">!     void texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);</span>
  
  #if ENABLE(VIDEO)
      using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;HTMLVideoElement&gt;&gt;;
  #else
      using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;&gt;;
  #endif
  
<span class="line-modified">!     ExceptionOr&lt;void&gt; texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt;);</span>
  
<span class="line-modified">!     void texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat param);</span>
<span class="line-modified">!     void texParameteri(GCGLenum target, GCGLenum pname, GCGLint param);</span>
  
<span class="line-modified">!     void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);</span>
<span class="line-modified">!     ExceptionOr&lt;void&gt; texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt;&amp;&amp;);</span>
  
      template &lt;class TypedArray, class DataType&gt;
      class TypedList {
      public:
          using VariantType = Variant&lt;RefPtr&lt;TypedArray&gt;, Vector&lt;DataType&gt;&gt;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,34 ***</span>
                  [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; const DataType* { return typedArray-&gt;data(); },
                  [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; const DataType* { return vector.data(); }
              );
          }
  
<span class="line-modified">!         GC3Dsizei length() const</span>
          {
              return WTF::switchOn(m_variant,
<span class="line-modified">!                 [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; GC3Dsizei { return typedArray-&gt;length(); },</span>
<span class="line-modified">!                 [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; GC3Dsizei { return vector.size(); }</span>
              );
          }
  
      private:
          VariantType m_variant;
      };
  
      using Float32List = TypedList&lt;Float32Array, float&gt;;
      using Int32List = TypedList&lt;Int32Array, int&gt;;
  
<span class="line-modified">!     void uniform1f(const WebGLUniformLocation*, GC3Dfloat x);</span>
<span class="line-modified">!     void uniform2f(const WebGLUniformLocation*, GC3Dfloat x, GC3Dfloat y);</span>
<span class="line-modified">!     void uniform3f(const WebGLUniformLocation*, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);</span>
<span class="line-modified">!     void uniform4f(const WebGLUniformLocation*, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);</span>
  
<span class="line-modified">!     void uniform1i(const WebGLUniformLocation*, GC3Dint x);</span>
<span class="line-modified">!     void uniform2i(const WebGLUniformLocation*, GC3Dint x, GC3Dint y);</span>
<span class="line-modified">!     void uniform3i(const WebGLUniformLocation*, GC3Dint x, GC3Dint y, GC3Dint z);</span>
<span class="line-modified">!     void uniform4i(const WebGLUniformLocation*, GC3Dint x, GC3Dint y, GC3Dint z, GC3Dint w);</span>
  
      void uniform1fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
      void uniform2fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
      void uniform3fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
      void uniform4fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
<span class="line-new-header">--- 272,34 ---</span>
                  [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; const DataType* { return typedArray-&gt;data(); },
                  [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; const DataType* { return vector.data(); }
              );
          }
  
<span class="line-modified">!         GCGLsizei length() const</span>
          {
              return WTF::switchOn(m_variant,
<span class="line-modified">!                 [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; GCGLsizei { return typedArray-&gt;length(); },</span>
<span class="line-modified">!                 [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; GCGLsizei { return vector.size(); }</span>
              );
          }
  
      private:
          VariantType m_variant;
      };
  
      using Float32List = TypedList&lt;Float32Array, float&gt;;
      using Int32List = TypedList&lt;Int32Array, int&gt;;
  
<span class="line-modified">!     void uniform1f(const WebGLUniformLocation*, GCGLfloat x);</span>
<span class="line-modified">!     void uniform2f(const WebGLUniformLocation*, GCGLfloat x, GCGLfloat y);</span>
<span class="line-modified">!     void uniform3f(const WebGLUniformLocation*, GCGLfloat x, GCGLfloat y, GCGLfloat z);</span>
<span class="line-modified">!     void uniform4f(const WebGLUniformLocation*, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w);</span>
  
<span class="line-modified">!     void uniform1i(const WebGLUniformLocation*, GCGLint x);</span>
<span class="line-modified">!     void uniform2i(const WebGLUniformLocation*, GCGLint x, GCGLint y);</span>
<span class="line-modified">!     void uniform3i(const WebGLUniformLocation*, GCGLint x, GCGLint y, GCGLint z);</span>
<span class="line-modified">!     void uniform4i(const WebGLUniformLocation*, GCGLint x, GCGLint y, GCGLint z, GCGLint w);</span>
  
      void uniform1fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
      void uniform2fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
      void uniform3fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
      void uniform4fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 298,31 ***</span>
      void uniform1iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
      void uniform2iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
      void uniform3iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
      void uniform4iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
  
<span class="line-modified">!     void uniformMatrix2fv(const WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp;);</span>
<span class="line-modified">!     void uniformMatrix3fv(const WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp;);</span>
<span class="line-modified">!     void uniformMatrix4fv(const WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp;);</span>
  
      void useProgram(WebGLProgram*);
      void validateProgram(WebGLProgram*);
  
<span class="line-modified">!     void vertexAttrib1f(GC3Duint index, GC3Dfloat x);</span>
<span class="line-modified">!     void vertexAttrib2f(GC3Duint index, GC3Dfloat x, GC3Dfloat y);</span>
<span class="line-modified">!     void vertexAttrib3f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);</span>
<span class="line-modified">!     void vertexAttrib4f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);</span>
  
<span class="line-modified">!     void vertexAttrib1fv(GC3Duint index, Float32List&amp;&amp;);</span>
<span class="line-modified">!     void vertexAttrib2fv(GC3Duint index, Float32List&amp;&amp;);</span>
<span class="line-modified">!     void vertexAttrib3fv(GC3Duint index, Float32List&amp;&amp;);</span>
<span class="line-modified">!     void vertexAttrib4fv(GC3Duint index, Float32List&amp;&amp;);</span>
  
<span class="line-modified">!     void vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized,</span>
<span class="line-modified">!         GC3Dsizei stride, long long offset);</span>
  
<span class="line-modified">!     void viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);</span>
  
      // WEBKIT_lose_context support
      enum LostContextMode {
          // Lost context occurred at the graphics system level.
          RealLostContext,
<span class="line-new-header">--- 307,31 ---</span>
      void uniform1iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
      void uniform2iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
      void uniform3iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
      void uniform4iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
  
<span class="line-modified">!     void uniformMatrix2fv(const WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp;);</span>
<span class="line-modified">!     void uniformMatrix3fv(const WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp;);</span>
<span class="line-modified">!     void uniformMatrix4fv(const WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp;);</span>
  
      void useProgram(WebGLProgram*);
      void validateProgram(WebGLProgram*);
  
<span class="line-modified">!     void vertexAttrib1f(GCGLuint index, GCGLfloat x);</span>
<span class="line-modified">!     void vertexAttrib2f(GCGLuint index, GCGLfloat x, GCGLfloat y);</span>
<span class="line-modified">!     void vertexAttrib3f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z);</span>
<span class="line-modified">!     void vertexAttrib4f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w);</span>
  
<span class="line-modified">!     void vertexAttrib1fv(GCGLuint index, Float32List&amp;&amp;);</span>
<span class="line-modified">!     void vertexAttrib2fv(GCGLuint index, Float32List&amp;&amp;);</span>
<span class="line-modified">!     void vertexAttrib3fv(GCGLuint index, Float32List&amp;&amp;);</span>
<span class="line-modified">!     void vertexAttrib4fv(GCGLuint index, Float32List&amp;&amp;);</span>
  
<span class="line-modified">!     void vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized,</span>
<span class="line-modified">!         GCGLsizei stride, long long offset);</span>
  
<span class="line-modified">!     void viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);</span>
  
      // WEBKIT_lose_context support
      enum LostContextMode {
          // Lost context occurred at the graphics system level.
          RealLostContext,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 333,11 ***</span>
      void forceLostContext(LostContextMode);
      void forceRestoreContext();
      void loseContextImpl(LostContextMode);
      WEBCORE_EXPORT void simulateContextChanged();
  
<span class="line-modified">!     GraphicsContext3D* graphicsContext3D() const { return m_context.get(); }</span>
      WebGLContextGroup* contextGroup() const { return m_contextGroup.get(); }
      PlatformLayer* platformLayer() const override;
  
      void reshape(int width, int height) override;
  
<span class="line-new-header">--- 342,11 ---</span>
      void forceLostContext(LostContextMode);
      void forceRestoreContext();
      void loseContextImpl(LostContextMode);
      WEBCORE_EXPORT void simulateContextChanged();
  
<span class="line-modified">!     GraphicsContextGLOpenGL* graphicsContextGL() const { return m_context.get(); }</span>
      WebGLContextGroup* contextGroup() const { return m_contextGroup.get(); }
      PlatformLayer* platformLayer() const override;
  
      void reshape(int width, int height) override;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,34 ***</span>
      void removeContextObject(WebGLContextObject&amp;);
  
      unsigned getMaxVertexAttribs() const { return m_maxVertexAttribs; }
  
      // Instanced Array helper functions.
<span class="line-modified">!     void drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount);</span>
<span class="line-modified">!     void drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, GC3Dsizei primcount);</span>
<span class="line-modified">!     void vertexAttribDivisor(GC3Duint index, GC3Duint divisor);</span>
  
      // Used for testing only, from Internals.
      WEBCORE_EXPORT void setFailNextGPUStatusCheck();
  
<span class="line-modified">!     // GraphicsContext3D::Client</span>
      void didComposite() override;
      void forceContextLost() override;
      void recycleContext() override;
      void dispatchContextChangedNotification() override;
  
  protected:
      WebGLRenderingContextBase(CanvasBase&amp;, WebGLContextAttributes);
<span class="line-modified">!     WebGLRenderingContextBase(CanvasBase&amp;, Ref&lt;GraphicsContext3D&gt;&amp;&amp;, WebGLContextAttributes);</span>
  
      friend class WebGLDrawBuffers;
      friend class WebGLFramebuffer;
      friend class WebGLObject;
      friend class OESVertexArrayObject;
      friend class WebGLDebugShaders;
      friend class WebGLCompressedTextureASTC;
      friend class WebGLCompressedTextureATC;
      friend class WebGLCompressedTexturePVRTC;
      friend class WebGLCompressedTextureS3TC;
      friend class WebGLRenderingContextErrorMessageCallback;
      friend class WebGLVertexArrayObjectOES;
      friend class WebGLVertexArrayObject;
<span class="line-new-header">--- 358,39 ---</span>
      void removeContextObject(WebGLContextObject&amp;);
  
      unsigned getMaxVertexAttribs() const { return m_maxVertexAttribs; }
  
      // Instanced Array helper functions.
<span class="line-modified">!     void drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount);</span>
<span class="line-modified">!     void drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, GCGLsizei primcount);</span>
<span class="line-modified">!     void vertexAttribDivisor(GCGLuint index, GCGLuint divisor);</span>
  
      // Used for testing only, from Internals.
      WEBCORE_EXPORT void setFailNextGPUStatusCheck();
  
<span class="line-modified">!     // GraphicsContextGL::Client</span>
      void didComposite() override;
      void forceContextLost() override;
      void recycleContext() override;
      void dispatchContextChangedNotification() override;
  
<span class="line-added">+     // ActiveDOMObject</span>
<span class="line-added">+     bool hasPendingActivity() const final;</span>
<span class="line-added">+ </span>
  protected:
      WebGLRenderingContextBase(CanvasBase&amp;, WebGLContextAttributes);
<span class="line-modified">!     WebGLRenderingContextBase(CanvasBase&amp;, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp;, WebGLContextAttributes);</span>
  
      friend class WebGLDrawBuffers;
      friend class WebGLFramebuffer;
      friend class WebGLObject;
      friend class OESVertexArrayObject;
      friend class WebGLDebugShaders;
      friend class WebGLCompressedTextureASTC;
      friend class WebGLCompressedTextureATC;
<span class="line-added">+     friend class WebGLCompressedTextureETC;</span>
<span class="line-added">+     friend class WebGLCompressedTextureETC1;</span>
      friend class WebGLCompressedTexturePVRTC;
      friend class WebGLCompressedTextureS3TC;
      friend class WebGLRenderingContextErrorMessageCallback;
      friend class WebGLVertexArrayObjectOES;
      friend class WebGLVertexArrayObject;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 385,20 ***</span>
      virtual void initializeNewContext();
      virtual void initializeVertexArrayObjects() = 0;
      void setupFlags();
  
      // ActiveDOMObject
<span class="line-removed">-     bool hasPendingActivity() const override;</span>
      void stop() override;
      const char* activeDOMObjectName() const override;
<span class="line-modified">!     bool canSuspendForDocumentSuspension() const override;</span>
  
      void addSharedObject(WebGLSharedObject&amp;);
      void addContextObject(WebGLContextObject&amp;);
      void detachAndRemoveAllObjects();
  
<span class="line-modified">!     void destroyGraphicsContext3D();</span>
      void markContextChanged();
      void markContextChangedAndNotifyCanvasObserver();
  
      void addActivityStateChangeObserverIfNecessary();
      void removeActivityStateChangeObserver();
<span class="line-new-header">--- 399,20 ---</span>
      virtual void initializeNewContext();
      virtual void initializeVertexArrayObjects() = 0;
      void setupFlags();
  
      // ActiveDOMObject
      void stop() override;
      const char* activeDOMObjectName() const override;
<span class="line-modified">!     void suspend(ReasonForSuspension) override;</span>
<span class="line-added">+     void resume() override;</span>
  
      void addSharedObject(WebGLSharedObject&amp;);
      void addContextObject(WebGLContextObject&amp;);
      void detachAndRemoveAllObjects();
  
<span class="line-modified">!     void destroyGraphicsContextGL();</span>
      void markContextChanged();
      void markContextChangedAndNotifyCanvasObserver();
  
      void addActivityStateChangeObserverIfNecessary();
      void removeActivityStateChangeObserver();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,30 ***</span>
      // Query if depth_stencil buffer is supported.
      bool isDepthStencilSupported() { return m_isDepthStencilSupported; }
  
      // Helper to return the size in bytes of OpenGL data types
      // like GL_FLOAT, GL_INT, etc.
<span class="line-modified">!     unsigned int sizeInBytes(GC3Denum type);</span>
  
      // Basic validation of count and offset against number of elements in element array buffer
<span class="line-modified">!     bool validateElementArraySize(GC3Dsizei count, GC3Denum type, GC3Dintptr offset);</span>
  
      // Conservative but quick index validation
<span class="line-modified">!     virtual bool validateIndexArrayConservative(GC3Denum type, unsigned&amp; numElementsRequired) = 0;</span>
  
      // Precise but slow index validation -- only done if conservative checks fail
<span class="line-modified">!     bool validateIndexArrayPrecise(GC3Dsizei count, GC3Denum type, GC3Dintptr offset, unsigned&amp; numElementsRequired);</span>
      bool validateVertexAttributes(unsigned elementCount, unsigned primitiveCount = 0);
  
      bool validateWebGLObject(const char*, WebGLObject*);
  
<span class="line-modified">!     bool validateDrawArrays(const char* functionName, GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount);</span>
<span class="line-modified">!     bool validateDrawElements(const char* functionName, GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, unsigned&amp; numElements, GC3Dsizei primcount);</span>
<span class="line-modified">!     bool validateNPOTTextureLevel(GC3Dsizei width, GC3Dsizei height, GC3Dint level, const char* functionName);</span>
  
      // Adds a compressed texture format.
<span class="line-modified">!     void addCompressedTextureFormat(GC3Denum);</span>
  
      RefPtr&lt;Image&gt; drawImageIntoBuffer(Image&amp;, int width, int height, int deviceScaleFactor);
  
  #if ENABLE(VIDEO)
      RefPtr&lt;Image&gt; videoFrameToImage(HTMLVideoElement*, BackingStoreCopy);
<span class="line-new-header">--- 424,30 ---</span>
      // Query if depth_stencil buffer is supported.
      bool isDepthStencilSupported() { return m_isDepthStencilSupported; }
  
      // Helper to return the size in bytes of OpenGL data types
      // like GL_FLOAT, GL_INT, etc.
<span class="line-modified">!     unsigned sizeInBytes(GCGLenum type);</span>
  
      // Basic validation of count and offset against number of elements in element array buffer
<span class="line-modified">!     bool validateElementArraySize(GCGLsizei count, GCGLenum type, GCGLintptr offset);</span>
  
      // Conservative but quick index validation
<span class="line-modified">!     virtual bool validateIndexArrayConservative(GCGLenum type, unsigned&amp; numElementsRequired) = 0;</span>
  
      // Precise but slow index validation -- only done if conservative checks fail
<span class="line-modified">!     bool validateIndexArrayPrecise(GCGLsizei count, GCGLenum type, GCGLintptr offset, unsigned&amp; numElementsRequired);</span>
      bool validateVertexAttributes(unsigned elementCount, unsigned primitiveCount = 0);
  
      bool validateWebGLObject(const char*, WebGLObject*);
  
<span class="line-modified">!     bool validateDrawArrays(const char* functionName, GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount);</span>
<span class="line-modified">!     bool validateDrawElements(const char* functionName, GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, unsigned&amp; numElements, GCGLsizei primcount);</span>
<span class="line-modified">!     bool validateNPOTTextureLevel(GCGLsizei width, GCGLsizei height, GCGLint level, const char* functionName);</span>
  
      // Adds a compressed texture format.
<span class="line-modified">!     void addCompressedTextureFormat(GCGLenum);</span>
  
      RefPtr&lt;Image&gt; drawImageIntoBuffer(Image&amp;, int width, int height, int deviceScaleFactor);
  
  #if ENABLE(VIDEO)
      RefPtr&lt;Image&gt; videoFrameToImage(HTMLVideoElement*, BackingStoreCopy);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 441,21 ***</span>
  
      WebGLTexture::TextureExtensionFlag textureExtensionFlags() const;
  
      bool enableSupportedExtension(ASCIILiteral extensionNameLiteral);
  
<span class="line-modified">!     RefPtr&lt;GraphicsContext3D&gt; m_context;</span>
      RefPtr&lt;WebGLContextGroup&gt; m_contextGroup;
  
      // Dispatches a context lost event once it is determined that one is needed.
      // This is used both for synthetic and real context losses. For real ones, it&#39;s
      // likely that there&#39;s no JavaScript on the stack, but that might be dependent
      // on how exactly the platform discovers that the context was lost. For better
      // portability we always defer the dispatch of the event.
<span class="line-modified">!     Timer m_dispatchContextLostEventTimer;</span>
      bool m_restoreAllowed { false };
<span class="line-modified">!     Timer m_restoreTimer;</span>
  
      bool m_needsUpdate;
      bool m_markedCanvasDirty;
      HashSet&lt;WebGLContextObject*&gt; m_contextObjects;
  
<span class="line-new-header">--- 455,24 ---</span>
  
      WebGLTexture::TextureExtensionFlag textureExtensionFlags() const;
  
      bool enableSupportedExtension(ASCIILiteral extensionNameLiteral);
  
<span class="line-modified">!     virtual void uncacheDeletedBuffer(WebGLBuffer*);</span>
<span class="line-added">+ </span>
<span class="line-added">+     RefPtr&lt;GraphicsContextGLOpenGL&gt; m_context;</span>
      RefPtr&lt;WebGLContextGroup&gt; m_contextGroup;
  
      // Dispatches a context lost event once it is determined that one is needed.
      // This is used both for synthetic and real context losses. For real ones, it&#39;s
      // likely that there&#39;s no JavaScript on the stack, but that might be dependent
      // on how exactly the platform discovers that the context was lost. For better
      // portability we always defer the dispatch of the event.
<span class="line-modified">!     SuspendableTimer m_dispatchContextLostEventTimer;</span>
<span class="line-added">+     SuspendableTimer m_dispatchContextChangedEventTimer;</span>
      bool m_restoreAllowed { false };
<span class="line-modified">!     SuspendableTimer m_restoreTimer;</span>
  
      bool m_needsUpdate;
      bool m_markedCanvasDirty;
      HashSet&lt;WebGLContextObject*&gt; m_contextObjects;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 489,17 ***</span>
              value[1] = 0.0f;
              value[2] = 0.0f;
              value[3] = 1.0f;
          }
  
<span class="line-modified">!         GC3Dfloat value[4];</span>
      };
      Vector&lt;VertexAttribValue&gt; m_vertexAttribValue;
      unsigned m_maxVertexAttribs;
      RefPtr&lt;WebGLBuffer&gt; m_vertexAttrib0Buffer;
      long m_vertexAttrib0BufferSize { 0 };
<span class="line-modified">!     GC3Dfloat m_vertexAttrib0BufferValue[4];</span>
      bool m_forceAttrib0BufferRefill { true };
      bool m_vertexAttrib0UsedBefore { false };
  
      RefPtr&lt;WebGLProgram&gt; m_currentProgram;
      RefPtr&lt;WebGLFramebuffer&gt; m_framebufferBinding;
<span class="line-new-header">--- 506,17 ---</span>
              value[1] = 0.0f;
              value[2] = 0.0f;
              value[3] = 1.0f;
          }
  
<span class="line-modified">!         GCGLfloat value[4];</span>
      };
      Vector&lt;VertexAttribValue&gt; m_vertexAttribValue;
      unsigned m_maxVertexAttribs;
      RefPtr&lt;WebGLBuffer&gt; m_vertexAttrib0Buffer;
      long m_vertexAttrib0BufferSize { 0 };
<span class="line-modified">!     GCGLfloat m_vertexAttrib0BufferValue[4];</span>
      bool m_forceAttrib0BufferRefill { true };
      bool m_vertexAttrib0UsedBefore { false };
  
      RefPtr&lt;WebGLProgram&gt; m_currentProgram;
      RefPtr&lt;WebGLFramebuffer&gt; m_framebufferBinding;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 515,11 ***</span>
      unsigned long m_activeTextureUnit;
  
      RefPtr&lt;WebGLTexture&gt; m_blackTexture2D;
      RefPtr&lt;WebGLTexture&gt; m_blackTextureCubeMap;
  
<span class="line-modified">!     Vector&lt;GC3Denum&gt; m_compressedTextureFormats;</span>
  
      // Fixed-size cache of reusable image buffers for video texImage2D calls.
      class LRUImageBufferCache {
      public:
          LRUImageBufferCache(int capacity);
<span class="line-new-header">--- 532,11 ---</span>
      unsigned long m_activeTextureUnit;
  
      RefPtr&lt;WebGLTexture&gt; m_blackTexture2D;
      RefPtr&lt;WebGLTexture&gt; m_blackTextureCubeMap;
  
<span class="line-modified">!     Vector&lt;GCGLenum&gt; m_compressedTextureFormats;</span>
  
      // Fixed-size cache of reusable image buffers for video texImage2D calls.
      class LRUImageBufferCache {
      public:
          LRUImageBufferCache(int capacity);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,44 ***</span>
          void bubbleToFront(size_t idx);
          Vector&lt;std::unique_ptr&lt;ImageBuffer&gt;&gt; m_buffers;
      };
      LRUImageBufferCache m_generatedImageCache { 0 };
  
<span class="line-modified">!     GC3Dint m_maxTextureSize;</span>
<span class="line-modified">!     GC3Dint m_maxCubeMapTextureSize;</span>
<span class="line-modified">!     GC3Dint m_maxRenderbufferSize;</span>
<span class="line-modified">!     GC3Dint m_maxViewportDims[2] { 0, 0 };</span>
<span class="line-modified">!     GC3Dint m_maxTextureLevel;</span>
<span class="line-modified">!     GC3Dint m_maxCubeMapTextureLevel;</span>
  
<span class="line-modified">!     GC3Dint m_maxDrawBuffers;</span>
<span class="line-modified">!     GC3Dint m_maxColorAttachments;</span>
<span class="line-modified">!     GC3Denum m_backDrawBuffer;</span>
      bool m_drawBuffersWebGLRequirementsChecked;
      bool m_drawBuffersSupported;
  
<span class="line-modified">!     GC3Dint m_packAlignment;</span>
<span class="line-modified">!     GC3Dint m_unpackAlignment;</span>
      bool m_unpackFlipY;
      bool m_unpackPremultiplyAlpha;
<span class="line-modified">!     GC3Denum m_unpackColorspaceConversion;</span>
      bool m_contextLost { false };
      LostContextMode m_contextLostMode { SyntheticLostContext };
      WebGLContextAttributes m_attributes;
  
      bool m_layerCleared;
<span class="line-modified">!     GC3Dfloat m_clearColor[4];</span>
      bool m_scissorEnabled;
<span class="line-modified">!     GC3Dfloat m_clearDepth;</span>
<span class="line-modified">!     GC3Dint m_clearStencil;</span>
<span class="line-modified">!     GC3Dboolean m_colorMask[4];</span>
<span class="line-modified">!     GC3Dboolean m_depthMask;</span>
  
      bool m_stencilEnabled;
<span class="line-modified">!     GC3Duint m_stencilMask, m_stencilMaskBack;</span>
<span class="line-modified">!     GC3Dint m_stencilFuncRef, m_stencilFuncRefBack; // Note that these are the user specified values, not the internal clamped value.</span>
<span class="line-modified">!     GC3Duint m_stencilFuncMask, m_stencilFuncMaskBack;</span>
  
      bool m_isGLES2Compliant;
      bool m_isGLES2NPOTStrict;
      bool m_isDepthStencilSupported;
      bool m_isRobustnessEXTSupported;
<span class="line-new-header">--- 546,44 ---</span>
          void bubbleToFront(size_t idx);
          Vector&lt;std::unique_ptr&lt;ImageBuffer&gt;&gt; m_buffers;
      };
      LRUImageBufferCache m_generatedImageCache { 0 };
  
<span class="line-modified">!     GCGLint m_maxTextureSize;</span>
<span class="line-modified">!     GCGLint m_maxCubeMapTextureSize;</span>
<span class="line-modified">!     GCGLint m_maxRenderbufferSize;</span>
<span class="line-modified">!     GCGLint m_maxViewportDims[2] { 0, 0 };</span>
<span class="line-modified">!     GCGLint m_maxTextureLevel;</span>
<span class="line-modified">!     GCGLint m_maxCubeMapTextureLevel;</span>
  
<span class="line-modified">!     GCGLint m_maxDrawBuffers;</span>
<span class="line-modified">!     GCGLint m_maxColorAttachments;</span>
<span class="line-modified">!     GCGLenum m_backDrawBuffer;</span>
      bool m_drawBuffersWebGLRequirementsChecked;
      bool m_drawBuffersSupported;
  
<span class="line-modified">!     GCGLint m_packAlignment;</span>
<span class="line-modified">!     GCGLint m_unpackAlignment;</span>
      bool m_unpackFlipY;
      bool m_unpackPremultiplyAlpha;
<span class="line-modified">!     GCGLenum m_unpackColorspaceConversion;</span>
      bool m_contextLost { false };
      LostContextMode m_contextLostMode { SyntheticLostContext };
      WebGLContextAttributes m_attributes;
  
      bool m_layerCleared;
<span class="line-modified">!     GCGLfloat m_clearColor[4];</span>
      bool m_scissorEnabled;
<span class="line-modified">!     GCGLfloat m_clearDepth;</span>
<span class="line-modified">!     GCGLint m_clearStencil;</span>
<span class="line-modified">!     GCGLboolean m_colorMask[4];</span>
<span class="line-modified">!     GCGLboolean m_depthMask;</span>
  
      bool m_stencilEnabled;
<span class="line-modified">!     GCGLuint m_stencilMask, m_stencilMaskBack;</span>
<span class="line-modified">!     GCGLint m_stencilFuncRef, m_stencilFuncRefBack; // Note that these are the user specified values, not the internal clamped value.</span>
<span class="line-modified">!     GCGLuint m_stencilFuncMask, m_stencilFuncMaskBack;</span>
  
      bool m_isGLES2Compliant;
      bool m_isGLES2NPOTStrict;
      bool m_isDepthStencilSupported;
      bool m_isRobustnessEXTSupported;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 600,51 ***</span>
      std::unique_ptr&lt;WebGLLoseContext&gt; m_webglLoseContext;
      std::unique_ptr&lt;WebGLDebugRendererInfo&gt; m_webglDebugRendererInfo;
      std::unique_ptr&lt;WebGLDebugShaders&gt; m_webglDebugShaders;
      std::unique_ptr&lt;WebGLCompressedTextureASTC&gt; m_webglCompressedTextureASTC;
      std::unique_ptr&lt;WebGLCompressedTextureATC&gt; m_webglCompressedTextureATC;
      std::unique_ptr&lt;WebGLCompressedTexturePVRTC&gt; m_webglCompressedTexturePVRTC;
      std::unique_ptr&lt;WebGLCompressedTextureS3TC&gt; m_webglCompressedTextureS3TC;
      std::unique_ptr&lt;WebGLDepthTexture&gt; m_webglDepthTexture;
      std::unique_ptr&lt;WebGLDrawBuffers&gt; m_webglDrawBuffers;
      std::unique_ptr&lt;ANGLEInstancedArrays&gt; m_angleInstancedArrays;
  
      // Helpers for getParameter and other similar functions.
<span class="line-modified">!     bool getBooleanParameter(GC3Denum);</span>
<span class="line-modified">!     Vector&lt;bool&gt; getBooleanArrayParameter(GC3Denum);</span>
<span class="line-modified">!     float getFloatParameter(GC3Denum);</span>
<span class="line-modified">!     int getIntParameter(GC3Denum);</span>
<span class="line-modified">!     unsigned getUnsignedIntParameter(GC3Denum);</span>
<span class="line-modified">!     long long getInt64Parameter(GC3Denum);</span>
<span class="line-modified">!     RefPtr&lt;Float32Array&gt; getWebGLFloatArrayParameter(GC3Denum);</span>
<span class="line-modified">!     RefPtr&lt;Int32Array&gt; getWebGLIntArrayParameter(GC3Denum);</span>
  
      // Clear the backbuffer if it was composited since the last operation.
      // clearMask is set to the bitfield of any clear that would happen anyway at this time
      // and the function returns true if that clear is now unnecessary.
<span class="line-modified">!     bool clearIfComposited(GC3Dbitfield clearMask = 0);</span>
  
      // Helper to restore state that clearing the framebuffer may destroy.
      void restoreStateAfterClear();
  
<span class="line-modified">!     void texImage2DBase(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels);</span>
<span class="line-modified">!     void texImage2DImpl(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Image*, GraphicsContext3D::ImageHtmlDomSource, bool flipY, bool premultiplyAlpha);</span>
<span class="line-modified">!     void texSubImage2DBase(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum internalformat, GC3Denum format, GC3Denum type, const void* pixels);</span>
<span class="line-modified">!     void texSubImage2DImpl(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Image*, GraphicsContext3D::ImageHtmlDomSource, bool flipY, bool premultiplyAlpha);</span>
  
      bool checkTextureCompleteness(const char*, bool);
  
      void createFallbackBlackTextures1x1();
  
      // Helper function for copyTex{Sub}Image, check whether the internalformat
      // and the color buffer format of the current bound framebuffer combination
      // is valid.
<span class="line-modified">!     bool isTexInternalFormatColorBufferCombinationValid(GC3Denum texInternalFormat,</span>
<span class="line-removed">-                                                         GC3Denum colorBufferFormat);</span>
  
      // Helper function to get the bound framebuffer&#39;s color buffer format.
<span class="line-modified">!     GC3Denum getBoundFramebufferColorFormat();</span>
  
      // Helper function to get the bound framebuffer&#39;s width.
      int getBoundFramebufferWidth();
  
      // Helper function to get the bound framebuffer&#39;s height.
<span class="line-new-header">--- 617,52 ---</span>
      std::unique_ptr&lt;WebGLLoseContext&gt; m_webglLoseContext;
      std::unique_ptr&lt;WebGLDebugRendererInfo&gt; m_webglDebugRendererInfo;
      std::unique_ptr&lt;WebGLDebugShaders&gt; m_webglDebugShaders;
      std::unique_ptr&lt;WebGLCompressedTextureASTC&gt; m_webglCompressedTextureASTC;
      std::unique_ptr&lt;WebGLCompressedTextureATC&gt; m_webglCompressedTextureATC;
<span class="line-added">+     std::unique_ptr&lt;WebGLCompressedTextureETC&gt; m_webglCompressedTextureETC;</span>
<span class="line-added">+     std::unique_ptr&lt;WebGLCompressedTextureETC1&gt; m_webglCompressedTextureETC1;</span>
      std::unique_ptr&lt;WebGLCompressedTexturePVRTC&gt; m_webglCompressedTexturePVRTC;
      std::unique_ptr&lt;WebGLCompressedTextureS3TC&gt; m_webglCompressedTextureS3TC;
      std::unique_ptr&lt;WebGLDepthTexture&gt; m_webglDepthTexture;
      std::unique_ptr&lt;WebGLDrawBuffers&gt; m_webglDrawBuffers;
      std::unique_ptr&lt;ANGLEInstancedArrays&gt; m_angleInstancedArrays;
  
      // Helpers for getParameter and other similar functions.
<span class="line-modified">!     bool getBooleanParameter(GCGLenum);</span>
<span class="line-modified">!     Vector&lt;bool&gt; getBooleanArrayParameter(GCGLenum);</span>
<span class="line-modified">!     float getFloatParameter(GCGLenum);</span>
<span class="line-modified">!     int getIntParameter(GCGLenum);</span>
<span class="line-modified">!     unsigned getUnsignedIntParameter(GCGLenum);</span>
<span class="line-modified">!     long long getInt64Parameter(GCGLenum);</span>
<span class="line-modified">!     RefPtr&lt;Float32Array&gt; getWebGLFloatArrayParameter(GCGLenum);</span>
<span class="line-modified">!     RefPtr&lt;Int32Array&gt; getWebGLIntArrayParameter(GCGLenum);</span>
  
      // Clear the backbuffer if it was composited since the last operation.
      // clearMask is set to the bitfield of any clear that would happen anyway at this time
      // and the function returns true if that clear is now unnecessary.
<span class="line-modified">!     bool clearIfComposited(GCGLbitfield clearMask = 0);</span>
  
      // Helper to restore state that clearing the framebuffer may destroy.
      void restoreStateAfterClear();
  
<span class="line-modified">!     void texImage2DBase(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels);</span>
<span class="line-modified">!     void texImage2DImpl(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Image*, GraphicsContextGL::DOMSource, bool flipY, bool premultiplyAlpha);</span>
<span class="line-modified">!     void texSubImage2DBase(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum internalformat, GCGLenum format, GCGLenum type, const void* pixels);</span>
<span class="line-modified">!     void texSubImage2DImpl(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Image*, GraphicsContextGL::DOMSource, bool flipY, bool premultiplyAlpha);</span>
  
      bool checkTextureCompleteness(const char*, bool);
  
      void createFallbackBlackTextures1x1();
  
      // Helper function for copyTex{Sub}Image, check whether the internalformat
      // and the color buffer format of the current bound framebuffer combination
      // is valid.
<span class="line-modified">!     bool isTexInternalFormatColorBufferCombinationValid(GCGLenum texInternalFormat, GCGLenum colorBufferFormat);</span>
  
      // Helper function to get the bound framebuffer&#39;s color buffer format.
<span class="line-modified">!     GCGLenum getBoundFramebufferColorFormat();</span>
  
      // Helper function to get the bound framebuffer&#39;s width.
      int getBoundFramebufferWidth();
  
      // Helper function to get the bound framebuffer&#39;s height.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 653,28 ***</span>
      // Helper function to verify limits on the length of uniform and attribute locations.
      bool validateLocationLength(const char* functionName, const String&amp;);
  
      // Helper function to check if size is non-negative.
      // Generate GL error and return false for negative inputs; otherwise, return true.
<span class="line-modified">!     bool validateSize(const char* functionName, GC3Dint x, GC3Dint y);</span>
  
      // Helper function to check if all characters in the string belong to the
      // ASCII subset as defined in GLSL ES 1.0 spec section 3.1.
      bool validateString(const char* functionName, const String&amp;);
  
      // Helper function to check target and texture bound to the target.
      // Generate GL errors and return 0 if target is invalid or texture bound is
      // null.  Otherwise, return the texture bound to the target.
<span class="line-modified">!     RefPtr&lt;WebGLTexture&gt; validateTextureBinding(const char* functionName, GC3Denum target, bool useSixEnumsForCubeMap);</span>
  
      // Helper function to check input format/type for functions {copy}Tex{Sub}Image.
      // Generates GL error and returns false if parameters are invalid.
<span class="line-modified">!     bool validateTexFuncFormatAndType(const char* functionName, GC3Denum internalformat, GC3Denum format, GC3Denum type, GC3Dint level);</span>
  
      // Helper function to check input level for functions {copy}Tex{Sub}Image.
      // Generates GL error and returns false if level is invalid.
<span class="line-modified">!     bool validateTexFuncLevel(const char* functionName, GC3Denum target, GC3Dint level);</span>
  
      enum TexFuncValidationFunctionType {
          TexImage,
          TexSubImage,
          CopyTexImage
<span class="line-new-header">--- 671,28 ---</span>
      // Helper function to verify limits on the length of uniform and attribute locations.
      bool validateLocationLength(const char* functionName, const String&amp;);
  
      // Helper function to check if size is non-negative.
      // Generate GL error and return false for negative inputs; otherwise, return true.
<span class="line-modified">!     bool validateSize(const char* functionName, GCGLint x, GCGLint y);</span>
  
      // Helper function to check if all characters in the string belong to the
      // ASCII subset as defined in GLSL ES 1.0 spec section 3.1.
      bool validateString(const char* functionName, const String&amp;);
  
      // Helper function to check target and texture bound to the target.
      // Generate GL errors and return 0 if target is invalid or texture bound is
      // null.  Otherwise, return the texture bound to the target.
<span class="line-modified">!     RefPtr&lt;WebGLTexture&gt; validateTextureBinding(const char* functionName, GCGLenum target, bool useSixEnumsForCubeMap);</span>
  
      // Helper function to check input format/type for functions {copy}Tex{Sub}Image.
      // Generates GL error and returns false if parameters are invalid.
<span class="line-modified">!     bool validateTexFuncFormatAndType(const char* functionName, GCGLenum internalformat, GCGLenum format, GCGLenum type, GCGLint level);</span>
  
      // Helper function to check input level for functions {copy}Tex{Sub}Image.
      // Generates GL error and returns false if level is invalid.
<span class="line-modified">!     bool validateTexFuncLevel(const char* functionName, GCGLenum target, GCGLint level);</span>
  
      enum TexFuncValidationFunctionType {
          TexImage,
          TexSubImage,
          CopyTexImage
</pre>
<hr />
<pre>
<span class="line-old-header">*** 691,167 ***</span>
  #endif
      };
  
      // Helper function for tex{Sub}Image2D to check if the input format/type/level/target/width/height/border/xoffset/yoffset are valid.
      // Otherwise, it would return quickly without doing other work.
<span class="line-modified">!     bool validateTexFunc(const char* functionName, TexFuncValidationFunctionType, TexFuncValidationSourceType, GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width,</span>
<span class="line-modified">!         GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint xoffset, GC3Dint yoffset);</span>
  
      // Helper function to check input parameters for functions {copy}Tex{Sub}Image.
      // Generates GL error and returns false if parameters are invalid.
      bool validateTexFuncParameters(const char* functionName,
          TexFuncValidationFunctionType,
<span class="line-modified">!         GC3Denum target, GC3Dint level,</span>
<span class="line-modified">!         GC3Denum internalformat,</span>
<span class="line-modified">!         GC3Dsizei width, GC3Dsizei height, GC3Dint border,</span>
<span class="line-modified">!         GC3Denum format, GC3Denum type);</span>
  
      enum NullDisposition {
          NullAllowed,
          NullNotAllowed
      };
  
      // Helper function to validate that the given ArrayBufferView
      // is of the correct type and contains enough data for the texImage call.
      // Generates GL error and returns false if parameters are invalid.
<span class="line-modified">!     bool validateTexFuncData(const char* functionName, GC3Dint level,</span>
<span class="line-modified">!         GC3Dsizei width, GC3Dsizei height,</span>
<span class="line-modified">!         GC3Denum internalformat, GC3Denum format, GC3Denum type,</span>
          ArrayBufferView* pixels,
          NullDisposition);
  
      // Helper function to validate a given texture format is settable as in
      // you can supply data to texImage2D, or call texImage2D, copyTexImage2D and
      // copyTexSubImage2D.
      // Generates GL error and returns false if the format is not settable.
<span class="line-modified">!     bool validateSettableTexInternalFormat(const char* functionName, GC3Denum format);</span>
  
      // Helper function to validate compressed texture data is correct size
      // for the given format and dimensions.
<span class="line-modified">!     bool validateCompressedTexFuncData(const char* functionName, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; pixels);</span>
  
      // Helper function for validating compressed texture formats.
<span class="line-modified">!     bool validateCompressedTexFormat(GC3Denum format);</span>
  
      // Helper function to validate compressed texture dimensions are valid for
      // the given format.
<span class="line-modified">!     bool validateCompressedTexDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dsizei width, GC3Dsizei height, GC3Denum format);</span>
  
      // Helper function to validate compressed texture dimensions are valid for
      // the given format.
<span class="line-modified">!     bool validateCompressedTexSubDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset,</span>
<span class="line-modified">!                                             GC3Dsizei width, GC3Dsizei height, GC3Denum format, WebGLTexture*);</span>
  
      // Helper function to validate mode for draw{Arrays/Elements}.
<span class="line-modified">!     bool validateDrawMode(const char* functionName, GC3Denum);</span>
  
      // Helper function to validate if front/back stencilMask and stencilFunc settings are the same.
      bool validateStencilSettings(const char* functionName);
  
      // Helper function to validate stencil func.
<span class="line-modified">!     bool validateStencilFunc(const char* functionName, GC3Denum);</span>
  
      // Helper function for texParameterf and texParameteri.
<span class="line-modified">!     void texParameter(GC3Denum target, GC3Denum pname, GC3Dfloat parami, GC3Dint paramf, bool isFloat);</span>
  
      // Helper function to print errors and warnings to console.
      void printToConsole(MessageLevel, const String&amp;);
  
      // Helper function to validate input parameters for framebuffer functions.
      // Generate GL error if parameters are illegal.
<span class="line-modified">!     virtual bool validateFramebufferFuncParameters(const char* functionName, GC3Denum target, GC3Denum attachment) = 0;</span>
  
      // Helper function to validate blend equation mode.
<span class="line-modified">!     virtual bool validateBlendEquation(const char* functionName, GC3Denum) = 0;</span>
  
      // Helper function to validate blend func factors.
<span class="line-modified">!     bool validateBlendFuncFactors(const char* functionName, GC3Denum src, GC3Denum dst);</span>
  
      // Helper function to validate a GL capability.
<span class="line-modified">!     virtual bool validateCapability(const char* functionName, GC3Denum) = 0;</span>
  
      // Helper function to validate input parameters for uniform functions.
<span class="line-modified">!     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Float32List&amp;, GC3Dsizei mod);</span>
<span class="line-modified">!     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Int32List&amp;, GC3Dsizei mod);</span>
<span class="line-modified">!     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, void*, GC3Dsizei, GC3Dsizei mod);</span>
<span class="line-modified">!     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GC3Dboolean transpose, const Float32List&amp;, GC3Dsizei mod);</span>
<span class="line-modified">!     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GC3Dboolean transpose, const void*, GC3Dsizei, GC3Dsizei mod);</span>
  
      // Helper function to validate parameters for bufferData.
      // Return the current bound buffer to target, or 0 if parameters are invalid.
<span class="line-modified">!     WebGLBuffer* validateBufferDataParameters(const char* functionName, GC3Denum target, GC3Denum usage);</span>
  
      // Helper function for tex{Sub}Image2D to make sure image is ready.
      ExceptionOr&lt;bool&gt; validateHTMLImageElement(const char* functionName, HTMLImageElement*);
      ExceptionOr&lt;bool&gt; validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement*);
  #if ENABLE(VIDEO)
      ExceptionOr&lt;bool&gt; validateHTMLVideoElement(const char* functionName, HTMLVideoElement*);
  #endif
  
      // Helper functions for vertexAttribNf{v}.
<span class="line-modified">!     void vertexAttribfImpl(const char* functionName, GC3Duint index, GC3Dsizei expectedSize, GC3Dfloat, GC3Dfloat, GC3Dfloat, GC3Dfloat);</span>
<span class="line-modified">!     void vertexAttribfvImpl(const char* functionName, GC3Duint index, Float32List&amp;&amp;, GC3Dsizei expectedSize);</span>
  
      // Helper function for delete* (deleteBuffer, deleteProgram, etc) functions.
      // Return false if caller should return without further processing.
      bool deleteObject(WebGLObject*);
  
      // Helper function for bind* (bindBuffer, bindTexture, etc) and useProgram.
      // If the object has already been deleted, set deleted to true upon return.
      // Return false if caller should return without further processing.
      bool checkObjectToBeBound(const char* functionName, WebGLObject*, bool&amp; deleted);
  
      // Helpers for simulating vertexAttrib0.
      void initVertexAttrib0();
<span class="line-modified">!     Optional&lt;bool&gt; simulateVertexAttrib0(GC3Duint numVertex);</span>
<span class="line-modified">!     bool validateSimulatedVertexAttrib0(GC3Duint numVertex);</span>
      void restoreStatesAfterVertexAttrib0Simulation();
  
<span class="line-modified">!     void dispatchContextLostEvent();</span>
<span class="line-removed">-     // Helper for restoration after context lost.</span>
<span class="line-removed">-     void maybeRestoreContext();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Wrapper for GraphicsContext3D::synthesizeGLError that sends a message to the JavaScript console.</span>
      enum ConsoleDisplayPreference { DisplayInConsole, DontDisplayInConsole };
<span class="line-modified">!     void synthesizeGLError(GC3Denum, const char* functionName, const char* description, ConsoleDisplayPreference = DisplayInConsole);</span>
  
      String ensureNotNull(const String&amp;) const;
  
      // Enable or disable stencil test based on user setting and whether the current FBO has a stencil buffer.
      void applyStencilTest();
  
      // Helper for enabling or disabling a capability.
<span class="line-modified">!     void enableOrDisable(GC3Denum capability, bool enable);</span>
  
      // Clamp the width and height to GL_MAX_VIEWPORT_DIMS.
      IntSize clampedCanvasSize();
  
<span class="line-modified">!     virtual GC3Dint getMaxDrawBuffers() = 0;</span>
<span class="line-modified">!     virtual GC3Dint getMaxColorAttachments() = 0;</span>
  
<span class="line-modified">!     void setBackDrawBuffer(GC3Denum);</span>
  
      void restoreCurrentFramebuffer();
      void restoreCurrentTexture2D();
  
      // Check if EXT_draw_buffers extension is supported and if it satisfies the WebGL requirements.
      bool supportsDrawBuffers();
  
      OffscreenCanvas* offscreenCanvas();
  
      template &lt;typename T&gt; inline Optional&lt;T&gt; checkedAddAndMultiply(T value, T add, T multiply);
<span class="line-modified">!     template &lt;typename T&gt; unsigned getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GC3Dintptr uoffset, GC3Dsizei n);</span>
  
  private:
<span class="line-modified">!     bool validateArrayBufferType(const char* functionName, GC3Denum type, Optional&lt;JSC::TypedArrayType&gt;);</span>
      void registerWithWebGLStateTracker();
      void checkForContextLossHandling();
  
      void activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState) override;
  
      WebGLStateTracker::Token m_trackerToken;
      Timer m_checkForContextLossHandlingTimer;
  };
  
  template &lt;typename T&gt;
  inline Optional&lt;T&gt; WebGLRenderingContextBase::checkedAddAndMultiply(T value, T add, T multiply)
  {
<span class="line-new-header">--- 709,173 ---</span>
  #endif
      };
  
      // Helper function for tex{Sub}Image2D to check if the input format/type/level/target/width/height/border/xoffset/yoffset are valid.
      // Otherwise, it would return quickly without doing other work.
<span class="line-modified">!     bool validateTexFunc(const char* functionName, TexFuncValidationFunctionType, TexFuncValidationSourceType, GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width,</span>
<span class="line-modified">!         GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLint xoffset, GCGLint yoffset);</span>
  
      // Helper function to check input parameters for functions {copy}Tex{Sub}Image.
      // Generates GL error and returns false if parameters are invalid.
      bool validateTexFuncParameters(const char* functionName,
          TexFuncValidationFunctionType,
<span class="line-modified">!         GCGLenum target, GCGLint level,</span>
<span class="line-modified">!         GCGLenum internalformat,</span>
<span class="line-modified">!         GCGLsizei width, GCGLsizei height, GCGLint border,</span>
<span class="line-modified">!         GCGLenum format, GCGLenum type);</span>
  
      enum NullDisposition {
          NullAllowed,
          NullNotAllowed
      };
  
      // Helper function to validate that the given ArrayBufferView
      // is of the correct type and contains enough data for the texImage call.
      // Generates GL error and returns false if parameters are invalid.
<span class="line-modified">!     bool validateTexFuncData(const char* functionName, GCGLint level,</span>
<span class="line-modified">!         GCGLsizei width, GCGLsizei height,</span>
<span class="line-modified">!         GCGLenum internalformat, GCGLenum format, GCGLenum type,</span>
          ArrayBufferView* pixels,
          NullDisposition);
  
      // Helper function to validate a given texture format is settable as in
      // you can supply data to texImage2D, or call texImage2D, copyTexImage2D and
      // copyTexSubImage2D.
      // Generates GL error and returns false if the format is not settable.
<span class="line-modified">!     bool validateSettableTexInternalFormat(const char* functionName, GCGLenum format);</span>
  
      // Helper function to validate compressed texture data is correct size
      // for the given format and dimensions.
<span class="line-modified">!     bool validateCompressedTexFuncData(const char* functionName, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; pixels);</span>
  
      // Helper function for validating compressed texture formats.
<span class="line-modified">!     bool validateCompressedTexFormat(GCGLenum format);</span>
  
      // Helper function to validate compressed texture dimensions are valid for
      // the given format.
<span class="line-modified">!     bool validateCompressedTexDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLsizei width, GCGLsizei height, GCGLenum format);</span>
  
      // Helper function to validate compressed texture dimensions are valid for
      // the given format.
<span class="line-modified">!     bool validateCompressedTexSubDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset,</span>
<span class="line-modified">!         GCGLsizei width, GCGLsizei height, GCGLenum format, WebGLTexture*);</span>
  
      // Helper function to validate mode for draw{Arrays/Elements}.
<span class="line-modified">!     bool validateDrawMode(const char* functionName, GCGLenum);</span>
  
      // Helper function to validate if front/back stencilMask and stencilFunc settings are the same.
      bool validateStencilSettings(const char* functionName);
  
      // Helper function to validate stencil func.
<span class="line-modified">!     bool validateStencilFunc(const char* functionName, GCGLenum);</span>
  
      // Helper function for texParameterf and texParameteri.
<span class="line-modified">!     void texParameter(GCGLenum target, GCGLenum pname, GCGLfloat parami, GCGLint paramf, bool isFloat);</span>
  
      // Helper function to print errors and warnings to console.
      void printToConsole(MessageLevel, const String&amp;);
  
      // Helper function to validate input parameters for framebuffer functions.
      // Generate GL error if parameters are illegal.
<span class="line-modified">!     virtual bool validateFramebufferFuncParameters(const char* functionName, GCGLenum target, GCGLenum attachment) = 0;</span>
  
      // Helper function to validate blend equation mode.
<span class="line-modified">!     virtual bool validateBlendEquation(const char* functionName, GCGLenum) = 0;</span>
  
      // Helper function to validate blend func factors.
<span class="line-modified">!     bool validateBlendFuncFactors(const char* functionName, GCGLenum src, GCGLenum dst);</span>
  
      // Helper function to validate a GL capability.
<span class="line-modified">!     virtual bool validateCapability(const char* functionName, GCGLenum) = 0;</span>
  
      // Helper function to validate input parameters for uniform functions.
<span class="line-modified">!     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Float32List&amp;, GCGLsizei mod);</span>
<span class="line-modified">!     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Int32List&amp;, GCGLsizei mod);</span>
<span class="line-modified">!     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, void*, GCGLsizei, GCGLsizei mod);</span>
<span class="line-modified">!     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GCGLboolean transpose, const Float32List&amp;, GCGLsizei mod);</span>
<span class="line-modified">!     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GCGLboolean transpose, const void*, GCGLsizei, GCGLsizei mod);</span>
  
      // Helper function to validate parameters for bufferData.
      // Return the current bound buffer to target, or 0 if parameters are invalid.
<span class="line-modified">!     WebGLBuffer* validateBufferDataParameters(const char* functionName, GCGLenum target, GCGLenum usage);</span>
  
      // Helper function for tex{Sub}Image2D to make sure image is ready.
      ExceptionOr&lt;bool&gt; validateHTMLImageElement(const char* functionName, HTMLImageElement*);
      ExceptionOr&lt;bool&gt; validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement*);
  #if ENABLE(VIDEO)
      ExceptionOr&lt;bool&gt; validateHTMLVideoElement(const char* functionName, HTMLVideoElement*);
  #endif
  
      // Helper functions for vertexAttribNf{v}.
<span class="line-modified">!     void vertexAttribfImpl(const char* functionName, GCGLuint index, GCGLsizei expectedSize, GCGLfloat, GCGLfloat, GCGLfloat, GCGLfloat);</span>
<span class="line-modified">!     void vertexAttribfvImpl(const char* functionName, GCGLuint index, Float32List&amp;&amp;, GCGLsizei expectedSize);</span>
  
      // Helper function for delete* (deleteBuffer, deleteProgram, etc) functions.
      // Return false if caller should return without further processing.
      bool deleteObject(WebGLObject*);
  
      // Helper function for bind* (bindBuffer, bindTexture, etc) and useProgram.
      // If the object has already been deleted, set deleted to true upon return.
      // Return false if caller should return without further processing.
      bool checkObjectToBeBound(const char* functionName, WebGLObject*, bool&amp; deleted);
  
<span class="line-added">+     bool validateAndCacheBufferBinding(const char* functionName, GCGLenum target, WebGLBuffer*);</span>
<span class="line-added">+ </span>
      // Helpers for simulating vertexAttrib0.
      void initVertexAttrib0();
<span class="line-modified">!     Optional&lt;bool&gt; simulateVertexAttrib0(GCGLuint numVertex);</span>
<span class="line-modified">!     bool validateSimulatedVertexAttrib0(GCGLuint numVertex);</span>
      void restoreStatesAfterVertexAttrib0Simulation();
  
<span class="line-modified">!     // Wrapper for GraphicsContextGLOpenGL::synthesizeGLError that sends a message to the JavaScript console.</span>
      enum ConsoleDisplayPreference { DisplayInConsole, DontDisplayInConsole };
<span class="line-modified">!     void synthesizeGLError(GCGLenum, const char* functionName, const char* description, ConsoleDisplayPreference = DisplayInConsole);</span>
  
      String ensureNotNull(const String&amp;) const;
  
      // Enable or disable stencil test based on user setting and whether the current FBO has a stencil buffer.
      void applyStencilTest();
  
      // Helper for enabling or disabling a capability.
<span class="line-modified">!     void enableOrDisable(GCGLenum capability, bool enable);</span>
  
      // Clamp the width and height to GL_MAX_VIEWPORT_DIMS.
      IntSize clampedCanvasSize();
  
<span class="line-modified">!     virtual GCGLint getMaxDrawBuffers() = 0;</span>
<span class="line-modified">!     virtual GCGLint getMaxColorAttachments() = 0;</span>
  
<span class="line-modified">!     void setBackDrawBuffer(GCGLenum);</span>
  
      void restoreCurrentFramebuffer();
      void restoreCurrentTexture2D();
  
      // Check if EXT_draw_buffers extension is supported and if it satisfies the WebGL requirements.
      bool supportsDrawBuffers();
  
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
      OffscreenCanvas* offscreenCanvas();
<span class="line-added">+ #endif</span>
  
      template &lt;typename T&gt; inline Optional&lt;T&gt; checkedAddAndMultiply(T value, T add, T multiply);
<span class="line-modified">!     template &lt;typename T&gt; unsigned getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GCGLintptr uoffset, GCGLsizei n);</span>
  
  private:
<span class="line-modified">!     void dispatchContextLostEvent();</span>
<span class="line-added">+     void dispatchContextChangedEvent();</span>
<span class="line-added">+     // Helper for restoration after context lost.</span>
<span class="line-added">+     void maybeRestoreContext();</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool validateArrayBufferType(const char* functionName, GCGLenum type, Optional&lt;JSC::TypedArrayType&gt;);</span>
      void registerWithWebGLStateTracker();
      void checkForContextLossHandling();
  
      void activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState) override;
  
      WebGLStateTracker::Token m_trackerToken;
      Timer m_checkForContextLossHandlingTimer;
<span class="line-added">+     bool m_isSuspended { false };</span>
  };
  
  template &lt;typename T&gt;
  inline Optional&lt;T&gt; WebGLRenderingContextBase::checkedAddAndMultiply(T value, T add, T multiply)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 863,11 ***</span>
  
      return checkedResult.unsafeGet();
  }
  
  template&lt;typename T&gt;
<span class="line-modified">! inline unsigned WebGLRenderingContextBase::getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GC3Dintptr uoffset, GC3Dsizei n)</span>
  {
      unsigned maxIndex = 0;
      T restartIndex = 0;
  
  #if ENABLE(WEBGL2)
<span class="line-new-header">--- 887,11 ---</span>
  
      return checkedResult.unsafeGet();
  }
  
  template&lt;typename T&gt;
<span class="line-modified">! inline unsigned WebGLRenderingContextBase::getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GCGLintptr uoffset, GCGLsizei n)</span>
  {
      unsigned maxIndex = 0;
      T restartIndex = 0;
  
  #if ENABLE(WEBGL2)
</pre>
<center><a href="WebGLRenderingContextBase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContextBase.idl.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/history/HistoryItem.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2005, 2006, 2008, 2011, 2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;HistoryItem.h&quot;
 28 
<a name="1" id="anc1"></a>
 29 #include &quot;CachedPage.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;KeyedCoding.h&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 32 #include &quot;PageCache.h&quot;</span>
 33 #include &quot;ResourceRequest.h&quot;
 34 #include &quot;SerializedScriptValue.h&quot;
 35 #include &quot;SharedBuffer.h&quot;
 36 #include &lt;stdio.h&gt;
 37 #include &lt;wtf/DateMath.h&gt;
 38 #include &lt;wtf/DebugUtilities.h&gt;
 39 #include &lt;wtf/WallTime.h&gt;
 40 #include &lt;wtf/text/CString.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 int64_t HistoryItem::generateSequenceNumber()
 45 {
 46     // Initialize to the current time to reduce the likelihood of generating
 47     // identifiers that overlap with those from past/future browser sessions.
 48     static long long next = static_cast&lt;long long&gt;(WallTime::now().secondsSinceEpoch().microseconds());
 49     return ++next;
 50 }
 51 
 52 static void defaultNotifyHistoryItemChanged(HistoryItem&amp;)
 53 {
 54 }
 55 
 56 void (*notifyHistoryItemChanged)(HistoryItem&amp;) = defaultNotifyHistoryItemChanged;
 57 
 58 #if PLATFORM(JAVA)
 59 extern &quot;C&quot; {
 60 extern void notifyHistoryItemDestroyed(const JLObject&amp;);
 61 }
 62 #endif
 63 
 64 HistoryItem::HistoryItem()
 65     : HistoryItem({ }, { })
 66 {
 67 }
 68 
 69 HistoryItem::HistoryItem(const String&amp; urlString, const String&amp; title)
 70     : HistoryItem(urlString, title, { })
 71 {
 72 }
 73 
 74 HistoryItem::HistoryItem(const String&amp; urlString, const String&amp; title, const String&amp; alternateTitle)
 75     : HistoryItem(urlString, title, alternateTitle, { Process::identifier(), ObjectIdentifier&lt;BackForwardItemIdentifier::ItemIdentifierType&gt;::generate() })
 76 {
 77 }
 78 
 79 HistoryItem::HistoryItem(const String&amp; urlString, const String&amp; title, const String&amp; alternateTitle, BackForwardItemIdentifier BackForwardItemIdentifier)
 80     : m_urlString(urlString)
 81     , m_originalURLString(urlString)
 82     , m_title(title)
 83     , m_displayTitle(alternateTitle)
 84     , m_pruningReason(PruningReason::None)
 85     , m_identifier(BackForwardItemIdentifier)
 86 {
 87 }
 88 
 89 HistoryItem::~HistoryItem()
 90 {
 91     ASSERT(!m_cachedPage);
 92 #if PLATFORM(JAVA)
 93     if (m_hostObject) {
 94         notifyHistoryItemDestroyed(m_hostObject);
 95     }
 96 #endif
 97 }
 98 
 99 inline HistoryItem::HistoryItem(const HistoryItem&amp; item)
100     : RefCounted&lt;HistoryItem&gt;()
101     , m_urlString(item.m_urlString)
102     , m_originalURLString(item.m_originalURLString)
103     , m_referrer(item.m_referrer)
104     , m_target(item.m_target)
105     , m_title(item.m_title)
106     , m_displayTitle(item.m_displayTitle)
107     , m_scrollPosition(item.m_scrollPosition)
108     , m_pageScaleFactor(item.m_pageScaleFactor)
109     , m_lastVisitWasFailure(item.m_lastVisitWasFailure)
110     , m_isTargetItem(item.m_isTargetItem)
111     , m_itemSequenceNumber(item.m_itemSequenceNumber)
112     , m_documentSequenceNumber(item.m_documentSequenceNumber)
113     , m_formContentType(item.m_formContentType)
114     , m_pruningReason(PruningReason::None)
115 #if PLATFORM(IOS_FAMILY)
116     , m_obscuredInsets(item.m_obscuredInsets)
117     , m_scale(item.m_scale)
118     , m_scaleIsInitial(item.m_scaleIsInitial)
119 #endif
120 #if PLATFORM(JAVA)
121     , m_hostObject(item.m_hostObject)
122 #endif
123     , m_identifier(item.m_identifier)
124 {
125     if (item.m_formData)
126         m_formData = item.m_formData-&gt;copy();
127 
128     unsigned size = item.m_children.size();
129     m_children.reserveInitialCapacity(size);
130     for (unsigned i = 0; i &lt; size; ++i)
131         m_children.uncheckedAppend(item.m_children[i]-&gt;copy());
132 }
133 
134 Ref&lt;HistoryItem&gt; HistoryItem::copy() const
135 {
136     return adoptRef(*new HistoryItem(*this));
137 }
138 
139 void HistoryItem::reset()
140 {
141     m_urlString = String();
142     m_originalURLString = String();
143     m_referrer = String();
144     m_target = String();
145     m_title = String();
146     m_displayTitle = String();
147 
148     m_lastVisitWasFailure = false;
149     m_isTargetItem = false;
150 
151     m_itemSequenceNumber = generateSequenceNumber();
152 
153     m_stateObject = nullptr;
154     m_documentSequenceNumber = generateSequenceNumber();
155 
156     m_formData = nullptr;
157     m_formContentType = String();
158 
159     clearChildren();
160 }
161 
162 const String&amp; HistoryItem::urlString() const
163 {
164     return m_urlString;
165 }
166 
167 // The first URL we loaded to get to where this history item points.  Includes both client
168 // and server redirects.
169 const String&amp; HistoryItem::originalURLString() const
170 {
171     return m_originalURLString;
172 }
173 
174 const String&amp; HistoryItem::title() const
175 {
176     return m_title;
177 }
178 
179 const String&amp; HistoryItem::alternateTitle() const
180 {
181     return m_displayTitle;
182 }
183 
184 bool HistoryItem::hasCachedPageExpired() const
185 {
186     return m_cachedPage ? m_cachedPage-&gt;hasExpired() : false;
187 }
188 
<a name="3" id="anc3"></a>















189 URL HistoryItem::url() const
190 {
191     return URL({ }, m_urlString);
192 }
193 
194 URL HistoryItem::originalURL() const
195 {
196     return URL({ }, m_originalURLString);
197 }
198 
199 const String&amp; HistoryItem::referrer() const
200 {
201     return m_referrer;
202 }
203 
204 const String&amp; HistoryItem::target() const
205 {
206     return m_target;
207 }
208 
209 void HistoryItem::setAlternateTitle(const String&amp; alternateTitle)
210 {
211     m_displayTitle = alternateTitle;
212     notifyChanged();
213 }
214 
215 void HistoryItem::setURLString(const String&amp; urlString)
216 {
217     m_urlString = urlString;
218     notifyChanged();
219 }
220 
221 void HistoryItem::setURL(const URL&amp; url)
222 {
<a name="4" id="anc4"></a><span class="line-modified">223     PageCache::singleton().remove(*this);</span>
224     setURLString(url.string());
225     clearDocumentState();
226 }
227 
228 void HistoryItem::setOriginalURLString(const String&amp; urlString)
229 {
230     m_originalURLString = urlString;
231     notifyChanged();
232 }
233 
234 void HistoryItem::setReferrer(const String&amp; referrer)
235 {
236     m_referrer = referrer;
237     notifyChanged();
238 }
239 
240 void HistoryItem::setTitle(const String&amp; title)
241 {
242     m_title = title;
243     notifyChanged();
244 }
245 
246 void HistoryItem::setTarget(const String&amp; target)
247 {
248     m_target = target;
249     notifyChanged();
250 }
251 
252 const IntPoint&amp; HistoryItem::scrollPosition() const
253 {
254     return m_scrollPosition;
255 }
256 
257 void HistoryItem::setScrollPosition(const IntPoint&amp; position)
258 {
259     m_scrollPosition = position;
260 }
261 
262 void HistoryItem::clearScrollPosition()
263 {
264     m_scrollPosition = IntPoint();
265 }
266 
267 bool HistoryItem::shouldRestoreScrollPosition() const
268 {
269     return m_shouldRestoreScrollPosition;
270 }
271 
272 void HistoryItem::setShouldRestoreScrollPosition(bool shouldRestore)
273 {
274     m_shouldRestoreScrollPosition = shouldRestore;
275     notifyChanged();
276 }
277 
278 float HistoryItem::pageScaleFactor() const
279 {
280     return m_pageScaleFactor;
281 }
282 
283 void HistoryItem::setPageScaleFactor(float scaleFactor)
284 {
285     m_pageScaleFactor = scaleFactor;
286 }
287 
288 void HistoryItem::setDocumentState(const Vector&lt;String&gt;&amp; state)
289 {
290     m_documentState = state;
291 }
292 
293 const Vector&lt;String&gt;&amp; HistoryItem::documentState() const
294 {
295     return m_documentState;
296 }
297 
298 void HistoryItem::clearDocumentState()
299 {
300     m_documentState.clear();
301 }
302 
303 void HistoryItem::setShouldOpenExternalURLsPolicy(ShouldOpenExternalURLsPolicy policy)
304 {
305     m_shouldOpenExternalURLsPolicy = policy;
306 }
307 
308 ShouldOpenExternalURLsPolicy HistoryItem::shouldOpenExternalURLsPolicy() const
309 {
310     return m_shouldOpenExternalURLsPolicy;
311 }
312 
313 bool HistoryItem::isTargetItem() const
314 {
315     return m_isTargetItem;
316 }
317 
318 void HistoryItem::setIsTargetItem(bool flag)
319 {
320     m_isTargetItem = flag;
321 }
322 
323 void HistoryItem::setStateObject(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; object)
324 {
325     m_stateObject = WTFMove(object);
326     notifyChanged();
327 }
328 
329 void HistoryItem::addChildItem(Ref&lt;HistoryItem&gt;&amp;&amp; child)
330 {
331     ASSERT(!childItemWithTarget(child-&gt;target()));
332     m_children.append(WTFMove(child));
333 }
334 
335 void HistoryItem::setChildItem(Ref&lt;HistoryItem&gt;&amp;&amp; child)
336 {
337     ASSERT(!child-&gt;isTargetItem());
338     unsigned size = m_children.size();
339     for (unsigned i = 0; i &lt; size; ++i)  {
340         if (m_children[i]-&gt;target() == child-&gt;target()) {
341             child-&gt;setIsTargetItem(m_children[i]-&gt;isTargetItem());
342             m_children[i] = WTFMove(child);
343             return;
344         }
345     }
346     m_children.append(WTFMove(child));
347 }
348 
349 HistoryItem* HistoryItem::childItemWithTarget(const String&amp; target)
350 {
351     unsigned size = m_children.size();
352     for (unsigned i = 0; i &lt; size; ++i) {
353         if (m_children[i]-&gt;target() == target)
354             return m_children[i].ptr();
355     }
356     return nullptr;
357 }
358 
359 HistoryItem* HistoryItem::childItemWithDocumentSequenceNumber(long long number)
360 {
361     unsigned size = m_children.size();
362     for (unsigned i = 0; i &lt; size; ++i) {
363         if (m_children[i]-&gt;documentSequenceNumber() == number)
364             return m_children[i].ptr();
365     }
366     return nullptr;
367 }
368 
369 const Vector&lt;Ref&lt;HistoryItem&gt;&gt;&amp; HistoryItem::children() const
370 {
371     return m_children;
372 }
373 
374 bool HistoryItem::hasChildren() const
375 {
376     return !m_children.isEmpty();
377 }
378 
379 void HistoryItem::clearChildren()
380 {
381     m_children.clear();
382 }
383 
384 // We do same-document navigation if going to a different item and if either of the following is true:
385 // - The other item corresponds to the same document (for history entries created via pushState or fragment changes).
386 // - The other item corresponds to the same set of documents, including frames (for history entries created via regular navigation)
387 bool HistoryItem::shouldDoSameDocumentNavigationTo(HistoryItem&amp; otherItem) const
388 {
389     // The following logic must be kept in sync with WebKit::WebBackForwardListItem::itemIsInSameDocument().
390     if (this == &amp;otherItem)
391         return false;
392 
393     if (stateObject() || otherItem.stateObject())
394         return documentSequenceNumber() == otherItem.documentSequenceNumber();
395 
396     if ((url().hasFragmentIdentifier() || otherItem.url().hasFragmentIdentifier()) &amp;&amp; equalIgnoringFragmentIdentifier(url(), otherItem.url()))
397         return documentSequenceNumber() == otherItem.documentSequenceNumber();
398 
399     return hasSameDocumentTree(otherItem);
400 }
401 
402 // Does a recursive check that this item and its descendants have the same
403 // document sequence numbers as the other item.
404 bool HistoryItem::hasSameDocumentTree(HistoryItem&amp; otherItem) const
405 {
406     if (documentSequenceNumber() != otherItem.documentSequenceNumber())
407         return false;
408 
409     if (children().size() != otherItem.children().size())
410         return false;
411 
412     for (size_t i = 0; i &lt; children().size(); i++) {
413         auto&amp; child = children()[i].get();
414         auto* otherChild = otherItem.childItemWithDocumentSequenceNumber(child.documentSequenceNumber());
415         if (!otherChild || !child.hasSameDocumentTree(*otherChild))
416             return false;
417     }
418 
419     return true;
420 }
421 
422 // Does a non-recursive check that this item and its immediate children have the
423 // same frames as the other item.
424 bool HistoryItem::hasSameFrames(HistoryItem&amp; otherItem) const
425 {
426     if (target() != otherItem.target())
427         return false;
428 
429     if (children().size() != otherItem.children().size())
430         return false;
431 
432     for (size_t i = 0; i &lt; children().size(); i++) {
433         if (!otherItem.childItemWithTarget(children()[i]-&gt;target()))
434             return false;
435     }
436 
437     return true;
438 }
439 
440 String HistoryItem::formContentType() const
441 {
442     return m_formContentType;
443 }
444 
445 void HistoryItem::setFormInfoFromRequest(const ResourceRequest&amp; request)
446 {
447     m_referrer = request.httpReferrer();
448 
449     if (equalLettersIgnoringASCIICase(request.httpMethod(), &quot;post&quot;)) {
450         // FIXME: Eventually we have to make this smart enough to handle the case where
451         // we have a stream for the body to handle the &quot;data interspersed with files&quot; feature.
452         m_formData = request.httpBody();
453         m_formContentType = request.httpContentType();
454     } else {
455         m_formData = nullptr;
456         m_formContentType = String();
457     }
458 }
459 
460 void HistoryItem::setFormData(RefPtr&lt;FormData&gt;&amp;&amp; formData)
461 {
462     m_formData = WTFMove(formData);
463 }
464 
465 void HistoryItem::setFormContentType(const String&amp; formContentType)
466 {
467     m_formContentType = formContentType;
468 }
469 
470 FormData* HistoryItem::formData()
471 {
472     return m_formData.get();
473 }
474 
475 bool HistoryItem::isCurrentDocument(Document&amp; document) const
476 {
477     // FIXME: We should find a better way to check if this is the current document.
478     return equalIgnoringFragmentIdentifier(url(), document.url());
479 }
480 
481 void HistoryItem::notifyChanged()
482 {
483     notifyHistoryItemChanged(*this);
484 }
485 
486 #if PLATFORM(JAVA)
487 JLObject HistoryItem::hostObject()
488 {
489     return m_hostObject;
490 }
491 
492 void HistoryItem::setHostObject(const JLObject&amp; host)
493 {
494     m_hostObject = host;
495 }
496 #endif
497 
498 #ifndef NDEBUG
499 
500 int HistoryItem::showTree() const
501 {
502     return showTreeWithIndent(0);
503 }
504 
505 int HistoryItem::showTreeWithIndent(unsigned indentLevel) const
506 {
507     Vector&lt;char&gt; prefix;
508     for (unsigned i = 0; i &lt; indentLevel; ++i)
509         prefix.append(&quot;  &quot;, 2);
510     prefix.append(&quot;\0&quot;, 1);
511 
512     fprintf(stderr, &quot;%s+-%s (%p)\n&quot;, prefix.data(), m_urlString.utf8().data(), this);
513 
514     int totalSubItems = 0;
515     for (unsigned i = 0; i &lt; m_children.size(); ++i)
516         totalSubItems += m_children[i]-&gt;showTreeWithIndent(indentLevel + 1);
517     return totalSubItems + 1;
518 }
519 
520 #endif
521 
522 #if !LOG_DISABLED
523 const char* HistoryItem::logString() const
524 {
525     return debugString(&quot;HistoryItem current URL &quot;, urlString(), &quot;, identifier &quot;, m_identifier.logString());
526 }
527 #endif
528 
529 } // namespace WebCore
530 
531 #ifndef NDEBUG
532 
533 int showTree(const WebCore::HistoryItem* item)
534 {
535     return item-&gt;showTree();
536 }
537 
538 #endif
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
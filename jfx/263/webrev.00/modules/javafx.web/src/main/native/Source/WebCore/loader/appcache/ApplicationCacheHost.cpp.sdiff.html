<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/appcache/ApplicationCacheHost.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ApplicationCacheGroup.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ApplicationCacheHost.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/appcache/ApplicationCacheHost.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 46 #include &quot;SubresourceLoader.h&quot;
 47 #include &lt;wtf/FileSystem.h&gt;
 48 #include &lt;wtf/UUID.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 ApplicationCacheHost::ApplicationCacheHost(DocumentLoader&amp; documentLoader)
 53     : m_documentLoader(documentLoader)
 54 {
 55 }
 56 
 57 ApplicationCacheHost::~ApplicationCacheHost()
 58 {
 59     ASSERT(!m_applicationCache || !m_candidateApplicationCacheGroup || m_applicationCache-&gt;group() == m_candidateApplicationCacheGroup);
 60     if (m_applicationCache)
 61         m_applicationCache-&gt;group()-&gt;disassociateDocumentLoader(m_documentLoader);
 62     else if (m_candidateApplicationCacheGroup)
 63         m_candidateApplicationCacheGroup-&gt;disassociateDocumentLoader(m_documentLoader);
 64 }
 65 





 66 void ApplicationCacheHost::selectCacheWithoutManifest()
 67 {
 68     ASSERT(m_documentLoader.frame());
 69     ApplicationCacheGroup::selectCacheWithoutManifestURL(*m_documentLoader.frame());
 70 }
 71 
 72 void ApplicationCacheHost::selectCacheWithManifest(const URL&amp; manifestURL)
 73 {
 74     ASSERT(m_documentLoader.frame());
 75     ApplicationCacheGroup::selectCache(*m_documentLoader.frame(), manifestURL);
 76 }
 77 







 78 void ApplicationCacheHost::maybeLoadMainResource(const ResourceRequest&amp; request, SubstituteData&amp; substituteData)
 79 {
 80     // Check if this request should be loaded from the application cache
 81     if (!substituteData.isValid() &amp;&amp; isApplicationCacheEnabled() &amp;&amp; !isApplicationCacheBlockedForRequest(request)) {
 82         ASSERT(!m_mainResourceApplicationCache);
 83 
 84         m_mainResourceApplicationCache = ApplicationCacheGroup::cacheForMainRequest(request, &amp;m_documentLoader);
 85 
 86         if (m_mainResourceApplicationCache) {
 87             // Get the resource from the application cache. By definition, cacheForMainRequest() returns a cache that contains the resource.
 88             ApplicationCacheResource* resource = m_mainResourceApplicationCache-&gt;resourceForRequest(request);
 89 
 90             // ApplicationCache resources have fragment identifiers stripped off of their URLs,
 91             // but we&#39;ll need to restore that for the SubstituteData.
 92             ResourceResponse responseToUse = resource-&gt;response();
 93             if (request.url().hasFragmentIdentifier()) {
 94                 URL url = responseToUse.url();
 95                 url.setFragmentIdentifier(request.url().fragmentIdentifier());
 96                 responseToUse.setURL(url);
 97             }
</pre>
<hr />
<pre>
127 bool ApplicationCacheHost::maybeLoadFallbackForMainError(const ResourceRequest&amp; request, const ResourceError&amp; error)
128 {
129     if (!error.isCancellation()) {
130         ASSERT(!m_mainResourceApplicationCache);
131         if (isApplicationCacheEnabled() &amp;&amp; !isApplicationCacheBlockedForRequest(request)) {
132             m_mainResourceApplicationCache = ApplicationCacheGroup::fallbackCacheForMainRequest(request, &amp;m_documentLoader);
133 
134             if (scheduleLoadFallbackResourceFromApplicationCache(m_documentLoader.mainResourceLoader(), m_mainResourceApplicationCache.get()))
135                 return true;
136         }
137     }
138     return false;
139 }
140 
141 void ApplicationCacheHost::mainResourceDataReceived(const char*, int, long long, bool)
142 {
143 }
144 
145 void ApplicationCacheHost::failedLoadingMainResource()
146 {
<span class="line-modified">147     auto* group = m_candidateApplicationCacheGroup;</span>
148     if (!group &amp;&amp; m_applicationCache) {
149         if (mainResourceApplicationCache()) {
150             // Even when the main resource is being loaded from an application cache, loading can fail if aborted.
151             return;
152         }
153         group = m_applicationCache-&gt;group();
154     }
155 
156     if (group)
157         group-&gt;failedLoadingMainResource(m_documentLoader);
158 }
159 
160 void ApplicationCacheHost::finishedLoadingMainResource()
161 {
162     auto* group = candidateApplicationCacheGroup();
163     if (!group &amp;&amp; applicationCache() &amp;&amp; !mainResourceApplicationCache())
164         group = applicationCache()-&gt;group();
165 
166     if (group)
167         group-&gt;finishedLoadingMainResource(m_documentLoader);
</pre>
<hr />
<pre>
272 }
273 
274 void ApplicationCacheHost::maybeLoadFallbackSynchronously(const ResourceRequest&amp; request, ResourceError&amp; error, ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt;&amp; data)
275 {
276     // If normal loading results in a redirect to a resource with another origin (indicative of a captive portal), or a 4xx or 5xx status code or equivalent,
277     // or if there were network errors (but not if the user canceled the download), then instead get, from the cache, the resource of the fallback entry
278     // corresponding to the matched namespace.
279     if ((!error.isNull() &amp;&amp; !error.isCancellation())
280          || response.httpStatusCode() / 100 == 4 || response.httpStatusCode() / 100 == 5
281          || !protocolHostAndPortAreEqual(request.url(), response.url())) {
282         ApplicationCacheResource* resource;
283         if (getApplicationCacheFallbackResource(request, resource)) {
284             response = resource-&gt;response();
285             // FIXME: Clients proably do not need a copy of the SharedBuffer.
286             // Remove the call to copy() once we ensure SharedBuffer will not be modified.
287             data = resource-&gt;data().copy();
288         }
289     }
290 }
291 
<span class="line-modified">292 bool ApplicationCacheHost::canCacheInPageCache()</span>
293 {
294     return !applicationCache() &amp;&amp; !candidateApplicationCacheGroup();
295 }
296 
297 void ApplicationCacheHost::setDOMApplicationCache(DOMApplicationCache* domApplicationCache)
298 {
299     ASSERT(!m_domApplicationCache || !domApplicationCache);
300     m_domApplicationCache = makeWeakPtr(domApplicationCache);
301 }
302 
303 void ApplicationCacheHost::notifyDOMApplicationCache(const AtomString&amp; eventType, int total, int done)
304 {
305     if (eventType != eventNames().progressEvent)
306         InspectorInstrumentation::updateApplicationCacheStatus(m_documentLoader.frame());
307 
308     if (m_defersEvents) {
309         // Event dispatching is deferred until document.onload has fired.
310         m_deferredEvents.append({ eventType, total, done });
311         return;
312     }
</pre>
<hr />
<pre>
372 }
373 
374 static Ref&lt;Event&gt; createApplicationCacheEvent(const AtomString&amp; eventType, int total, int done)
375 {
376     if (eventType == eventNames().progressEvent)
377         return ProgressEvent::create(eventType, true, done, total);
378     return Event::create(eventType, Event::CanBubble::No, Event::IsCancelable::No);
379 }
380 
381 void ApplicationCacheHost::dispatchDOMEvent(const AtomString&amp; eventType, int total, int done)
382 {
383     if (!m_domApplicationCache || !m_domApplicationCache-&gt;frame())
384         return;
385 
386     m_domApplicationCache-&gt;dispatchEvent(createApplicationCacheEvent(eventType, total, done));
387 }
388 
389 void ApplicationCacheHost::setCandidateApplicationCacheGroup(ApplicationCacheGroup* group)
390 {
391     ASSERT(!m_applicationCache);
<span class="line-modified">392     m_candidateApplicationCacheGroup = group;</span>
393 }
394 
395 void ApplicationCacheHost::setApplicationCache(RefPtr&lt;ApplicationCache&gt;&amp;&amp; applicationCache)
396 {
397     if (m_candidateApplicationCacheGroup) {
398         ASSERT(!m_applicationCache);
399         m_candidateApplicationCacheGroup = nullptr;
400     }
401     m_applicationCache = WTFMove(applicationCache);
402 }
403 
404 bool ApplicationCacheHost::shouldLoadResourceFromApplicationCache(const ResourceRequest&amp; originalRequest, ApplicationCacheResource*&amp; resource)
405 {
406     auto* cache = applicationCache();
407     if (!cache || !cache-&gt;isComplete())
408         return false;
409 
410     ResourceRequest request(originalRequest);
411     if (auto* loaderFrame = m_documentLoader.frame()) {
412         if (auto* document = loaderFrame-&gt;document())
</pre>
<hr />
<pre>
503 }
504 
505 bool ApplicationCacheHost::update()
506 {
507     auto* cache = applicationCache();
508     if (!cache)
509         return false;
510     auto* frame = m_documentLoader.frame();
511     if (!frame)
512         return false;
513     cache-&gt;group()-&gt;update(*frame, ApplicationCacheUpdateWithoutBrowsingContext);
514     return true;
515 }
516 
517 bool ApplicationCacheHost::swapCache()
518 {
519     auto* cache = applicationCache();
520     if (!cache)
521         return false;
522 




523     // If the group of application caches to which cache belongs has the lifecycle status obsolete, unassociate document from cache.
<span class="line-modified">524     if (cache-&gt;group()-&gt;isObsolete()) {</span>
<span class="line-modified">525         cache-&gt;group()-&gt;disassociateDocumentLoader(m_documentLoader);</span>
526         return true;
527     }
528 
529     // If there is no newer cache, raise an InvalidStateError exception.
<span class="line-modified">530     auto* newestCache = cache-&gt;group()-&gt;newestCache();</span>
<span class="line-modified">531     if (cache == newestCache)</span>
532         return false;
533 
<span class="line-modified">534     ASSERT(cache-&gt;group() == newestCache-&gt;group());</span>
535     setApplicationCache(newestCache);
536     InspectorInstrumentation::updateApplicationCacheStatus(m_documentLoader.frame());
537     return true;
538 }
539 
540 void ApplicationCacheHost::abort()
541 {
542     auto* frame = m_documentLoader.frame();
543     if (!frame)
544         return;
545     if (auto* cacheGroup = candidateApplicationCacheGroup())
546         cacheGroup-&gt;abort(*frame);
547     else if (auto* cache = applicationCache())
548         cache-&gt;group()-&gt;abort(*frame);
549 }
550 
551 bool ApplicationCacheHost::isApplicationCacheEnabled()
552 {
553     return m_documentLoader.frame() &amp;&amp; m_documentLoader.frame()-&gt;settings().offlineWebApplicationCacheEnabled() &amp;&amp; !m_documentLoader.frame()-&gt;page()-&gt;usesEphemeralSession();
554 }
</pre>
</td>
<td>
<hr />
<pre>
 46 #include &quot;SubresourceLoader.h&quot;
 47 #include &lt;wtf/FileSystem.h&gt;
 48 #include &lt;wtf/UUID.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 ApplicationCacheHost::ApplicationCacheHost(DocumentLoader&amp; documentLoader)
 53     : m_documentLoader(documentLoader)
 54 {
 55 }
 56 
 57 ApplicationCacheHost::~ApplicationCacheHost()
 58 {
 59     ASSERT(!m_applicationCache || !m_candidateApplicationCacheGroup || m_applicationCache-&gt;group() == m_candidateApplicationCacheGroup);
 60     if (m_applicationCache)
 61         m_applicationCache-&gt;group()-&gt;disassociateDocumentLoader(m_documentLoader);
 62     else if (m_candidateApplicationCacheGroup)
 63         m_candidateApplicationCacheGroup-&gt;disassociateDocumentLoader(m_documentLoader);
 64 }
 65 
<span class="line-added"> 66 ApplicationCacheGroup* ApplicationCacheHost::candidateApplicationCacheGroup() const</span>
<span class="line-added"> 67 {</span>
<span class="line-added"> 68     return m_candidateApplicationCacheGroup.get();</span>
<span class="line-added"> 69 }</span>
<span class="line-added"> 70 </span>
 71 void ApplicationCacheHost::selectCacheWithoutManifest()
 72 {
 73     ASSERT(m_documentLoader.frame());
 74     ApplicationCacheGroup::selectCacheWithoutManifestURL(*m_documentLoader.frame());
 75 }
 76 
 77 void ApplicationCacheHost::selectCacheWithManifest(const URL&amp; manifestURL)
 78 {
 79     ASSERT(m_documentLoader.frame());
 80     ApplicationCacheGroup::selectCache(*m_documentLoader.frame(), manifestURL);
 81 }
 82 
<span class="line-added"> 83 bool ApplicationCacheHost::canLoadMainResource(const ResourceRequest&amp; request)</span>
<span class="line-added"> 84 {</span>
<span class="line-added"> 85     if (!isApplicationCacheEnabled() || isApplicationCacheBlockedForRequest(request))</span>
<span class="line-added"> 86         return false;</span>
<span class="line-added"> 87     return !!ApplicationCacheGroup::cacheForMainRequest(request, &amp;m_documentLoader);</span>
<span class="line-added"> 88 }</span>
<span class="line-added"> 89 </span>
 90 void ApplicationCacheHost::maybeLoadMainResource(const ResourceRequest&amp; request, SubstituteData&amp; substituteData)
 91 {
 92     // Check if this request should be loaded from the application cache
 93     if (!substituteData.isValid() &amp;&amp; isApplicationCacheEnabled() &amp;&amp; !isApplicationCacheBlockedForRequest(request)) {
 94         ASSERT(!m_mainResourceApplicationCache);
 95 
 96         m_mainResourceApplicationCache = ApplicationCacheGroup::cacheForMainRequest(request, &amp;m_documentLoader);
 97 
 98         if (m_mainResourceApplicationCache) {
 99             // Get the resource from the application cache. By definition, cacheForMainRequest() returns a cache that contains the resource.
100             ApplicationCacheResource* resource = m_mainResourceApplicationCache-&gt;resourceForRequest(request);
101 
102             // ApplicationCache resources have fragment identifiers stripped off of their URLs,
103             // but we&#39;ll need to restore that for the SubstituteData.
104             ResourceResponse responseToUse = resource-&gt;response();
105             if (request.url().hasFragmentIdentifier()) {
106                 URL url = responseToUse.url();
107                 url.setFragmentIdentifier(request.url().fragmentIdentifier());
108                 responseToUse.setURL(url);
109             }
</pre>
<hr />
<pre>
139 bool ApplicationCacheHost::maybeLoadFallbackForMainError(const ResourceRequest&amp; request, const ResourceError&amp; error)
140 {
141     if (!error.isCancellation()) {
142         ASSERT(!m_mainResourceApplicationCache);
143         if (isApplicationCacheEnabled() &amp;&amp; !isApplicationCacheBlockedForRequest(request)) {
144             m_mainResourceApplicationCache = ApplicationCacheGroup::fallbackCacheForMainRequest(request, &amp;m_documentLoader);
145 
146             if (scheduleLoadFallbackResourceFromApplicationCache(m_documentLoader.mainResourceLoader(), m_mainResourceApplicationCache.get()))
147                 return true;
148         }
149     }
150     return false;
151 }
152 
153 void ApplicationCacheHost::mainResourceDataReceived(const char*, int, long long, bool)
154 {
155 }
156 
157 void ApplicationCacheHost::failedLoadingMainResource()
158 {
<span class="line-modified">159     auto* group = m_candidateApplicationCacheGroup.get();</span>
160     if (!group &amp;&amp; m_applicationCache) {
161         if (mainResourceApplicationCache()) {
162             // Even when the main resource is being loaded from an application cache, loading can fail if aborted.
163             return;
164         }
165         group = m_applicationCache-&gt;group();
166     }
167 
168     if (group)
169         group-&gt;failedLoadingMainResource(m_documentLoader);
170 }
171 
172 void ApplicationCacheHost::finishedLoadingMainResource()
173 {
174     auto* group = candidateApplicationCacheGroup();
175     if (!group &amp;&amp; applicationCache() &amp;&amp; !mainResourceApplicationCache())
176         group = applicationCache()-&gt;group();
177 
178     if (group)
179         group-&gt;finishedLoadingMainResource(m_documentLoader);
</pre>
<hr />
<pre>
284 }
285 
286 void ApplicationCacheHost::maybeLoadFallbackSynchronously(const ResourceRequest&amp; request, ResourceError&amp; error, ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt;&amp; data)
287 {
288     // If normal loading results in a redirect to a resource with another origin (indicative of a captive portal), or a 4xx or 5xx status code or equivalent,
289     // or if there were network errors (but not if the user canceled the download), then instead get, from the cache, the resource of the fallback entry
290     // corresponding to the matched namespace.
291     if ((!error.isNull() &amp;&amp; !error.isCancellation())
292          || response.httpStatusCode() / 100 == 4 || response.httpStatusCode() / 100 == 5
293          || !protocolHostAndPortAreEqual(request.url(), response.url())) {
294         ApplicationCacheResource* resource;
295         if (getApplicationCacheFallbackResource(request, resource)) {
296             response = resource-&gt;response();
297             // FIXME: Clients proably do not need a copy of the SharedBuffer.
298             // Remove the call to copy() once we ensure SharedBuffer will not be modified.
299             data = resource-&gt;data().copy();
300         }
301     }
302 }
303 
<span class="line-modified">304 bool ApplicationCacheHost::canCacheInBackForwardCache()</span>
305 {
306     return !applicationCache() &amp;&amp; !candidateApplicationCacheGroup();
307 }
308 
309 void ApplicationCacheHost::setDOMApplicationCache(DOMApplicationCache* domApplicationCache)
310 {
311     ASSERT(!m_domApplicationCache || !domApplicationCache);
312     m_domApplicationCache = makeWeakPtr(domApplicationCache);
313 }
314 
315 void ApplicationCacheHost::notifyDOMApplicationCache(const AtomString&amp; eventType, int total, int done)
316 {
317     if (eventType != eventNames().progressEvent)
318         InspectorInstrumentation::updateApplicationCacheStatus(m_documentLoader.frame());
319 
320     if (m_defersEvents) {
321         // Event dispatching is deferred until document.onload has fired.
322         m_deferredEvents.append({ eventType, total, done });
323         return;
324     }
</pre>
<hr />
<pre>
384 }
385 
386 static Ref&lt;Event&gt; createApplicationCacheEvent(const AtomString&amp; eventType, int total, int done)
387 {
388     if (eventType == eventNames().progressEvent)
389         return ProgressEvent::create(eventType, true, done, total);
390     return Event::create(eventType, Event::CanBubble::No, Event::IsCancelable::No);
391 }
392 
393 void ApplicationCacheHost::dispatchDOMEvent(const AtomString&amp; eventType, int total, int done)
394 {
395     if (!m_domApplicationCache || !m_domApplicationCache-&gt;frame())
396         return;
397 
398     m_domApplicationCache-&gt;dispatchEvent(createApplicationCacheEvent(eventType, total, done));
399 }
400 
401 void ApplicationCacheHost::setCandidateApplicationCacheGroup(ApplicationCacheGroup* group)
402 {
403     ASSERT(!m_applicationCache);
<span class="line-modified">404     m_candidateApplicationCacheGroup = makeWeakPtr(group);</span>
405 }
406 
407 void ApplicationCacheHost::setApplicationCache(RefPtr&lt;ApplicationCache&gt;&amp;&amp; applicationCache)
408 {
409     if (m_candidateApplicationCacheGroup) {
410         ASSERT(!m_applicationCache);
411         m_candidateApplicationCacheGroup = nullptr;
412     }
413     m_applicationCache = WTFMove(applicationCache);
414 }
415 
416 bool ApplicationCacheHost::shouldLoadResourceFromApplicationCache(const ResourceRequest&amp; originalRequest, ApplicationCacheResource*&amp; resource)
417 {
418     auto* cache = applicationCache();
419     if (!cache || !cache-&gt;isComplete())
420         return false;
421 
422     ResourceRequest request(originalRequest);
423     if (auto* loaderFrame = m_documentLoader.frame()) {
424         if (auto* document = loaderFrame-&gt;document())
</pre>
<hr />
<pre>
515 }
516 
517 bool ApplicationCacheHost::update()
518 {
519     auto* cache = applicationCache();
520     if (!cache)
521         return false;
522     auto* frame = m_documentLoader.frame();
523     if (!frame)
524         return false;
525     cache-&gt;group()-&gt;update(*frame, ApplicationCacheUpdateWithoutBrowsingContext);
526     return true;
527 }
528 
529 bool ApplicationCacheHost::swapCache()
530 {
531     auto* cache = applicationCache();
532     if (!cache)
533         return false;
534 
<span class="line-added">535     auto* group = cache-&gt;group();</span>
<span class="line-added">536     if (!group)</span>
<span class="line-added">537         return false;</span>
<span class="line-added">538 </span>
539     // If the group of application caches to which cache belongs has the lifecycle status obsolete, unassociate document from cache.
<span class="line-modified">540     if (group-&gt;isObsolete()) {</span>
<span class="line-modified">541         group-&gt;disassociateDocumentLoader(m_documentLoader);</span>
542         return true;
543     }
544 
545     // If there is no newer cache, raise an InvalidStateError exception.
<span class="line-modified">546     auto* newestCache = group-&gt;newestCache();</span>
<span class="line-modified">547     if (!newestCache || cache == newestCache)</span>
548         return false;
549 
<span class="line-modified">550     ASSERT(group == newestCache-&gt;group());</span>
551     setApplicationCache(newestCache);
552     InspectorInstrumentation::updateApplicationCacheStatus(m_documentLoader.frame());
553     return true;
554 }
555 
556 void ApplicationCacheHost::abort()
557 {
558     auto* frame = m_documentLoader.frame();
559     if (!frame)
560         return;
561     if (auto* cacheGroup = candidateApplicationCacheGroup())
562         cacheGroup-&gt;abort(*frame);
563     else if (auto* cache = applicationCache())
564         cache-&gt;group()-&gt;abort(*frame);
565 }
566 
567 bool ApplicationCacheHost::isApplicationCacheEnabled()
568 {
569     return m_documentLoader.frame() &amp;&amp; m_documentLoader.frame()-&gt;settings().offlineWebApplicationCacheEnabled() &amp;&amp; !m_documentLoader.frame()-&gt;page()-&gt;usesEphemeralSession();
570 }
</pre>
</td>
</tr>
</table>
<center><a href="ApplicationCacheGroup.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ApplicationCacheHost.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ObjectConstructor.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ObjectConstructor.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ObjectConstructor.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ObjectConstructor.cpp
@@ -38,25 +38,25 @@
 #include "StackVisitor.h"
 #include "Symbol.h"
 
 namespace JSC {
 
-EncodedJSValue JSC_HOST_CALL objectConstructorAssign(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorValues(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorGetPrototypeOf(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorSetPrototypeOf(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyNames(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperty(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperties(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorCreate(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorSeal(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorFreeze(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorPreventExtensions(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorIsSealed(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorIsFrozen(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorIsExtensible(ExecState*);
-EncodedJSValue JSC_HOST_CALL objectConstructorIs(ExecState*);
+EncodedJSValue JSC_HOST_CALL objectConstructorAssign(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorValues(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorGetPrototypeOf(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorSetPrototypeOf(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyNames(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperty(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperties(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorCreate(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorSeal(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorFreeze(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorPreventExtensions(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorIsSealed(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorIsFrozen(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorIsExtensible(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL objectConstructorIs(JSGlobalObject*, CallFrame*);
 
 }
 
 #include "ObjectConstructor.lut.h"
 
@@ -91,21 +91,21 @@
   fromEntries               JSBuiltin                                   DontEnum|Function 1
 @end
 */
 
 
-static EncodedJSValue JSC_HOST_CALL callObjectConstructor(ExecState*);
-static EncodedJSValue JSC_HOST_CALL constructWithObjectConstructor(ExecState*);
+static EncodedJSValue JSC_HOST_CALL callObjectConstructor(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL constructWithObjectConstructor(JSGlobalObject*, CallFrame*);
 
 ObjectConstructor::ObjectConstructor(VM& vm, Structure* structure)
     : InternalFunction(vm, structure, callObjectConstructor, constructWithObjectConstructor)
 {
 }
 
 void ObjectConstructor::finishCreation(VM& vm, JSGlobalObject* globalObject, ObjectPrototype* objectPrototype)
 {
-    Base::finishCreation(vm, vm.propertyNames->Object.string(), NameVisibility::Visible, NameAdditionMode::WithoutStructureTransition);
+    Base::finishCreation(vm, vm.propertyNames->Object.string(), NameAdditionMode::WithoutStructureTransition);
 
     putDirectWithoutTransition(vm, vm.propertyNames->prototype, objectPrototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
     putDirectWithoutTransition(vm, vm.propertyNames->length, jsNumber(1), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames->builtinNames().createPrivateName(), objectConstructorCreate, static_cast<unsigned>(PropertyAttribute::DontEnum), 2);
@@ -113,204 +113,202 @@
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames->builtinNames().getPrototypeOfPrivateName(), objectConstructorGetPrototypeOf, static_cast<unsigned>(PropertyAttribute::DontEnum), 1);
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames->builtinNames().getOwnPropertyNamesPrivateName(), objectConstructorGetOwnPropertyNames, static_cast<unsigned>(PropertyAttribute::DontEnum), 1);
 }
 
 // ES 19.1.1.1 Object([value])
-static ALWAYS_INLINE JSObject* constructObject(ExecState* exec, JSValue newTarget)
+static ALWAYS_INLINE JSObject* constructObjectWithNewTarget(JSGlobalObject* globalObject, CallFrame* callFrame, JSValue newTarget)
 {
-    VM& vm = exec->vm();
-    ObjectConstructor* objectConstructor = jsCast<ObjectConstructor*>(exec->jsCallee());
-    JSGlobalObject* globalObject = objectConstructor->globalObject(vm);
+    VM& vm = globalObject->vm();
+    ObjectConstructor* objectConstructor = jsCast<ObjectConstructor*>(callFrame->jsCallee());
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // We need to check newTarget condition in this caller side instead of InternalFunction::createSubclassStructure side.
     // Since if we found this condition is met, we should not fall into the type conversion in the step 3.
 
     // 1. If NewTarget is neither undefined nor the active function, then
     if (newTarget && newTarget != objectConstructor) {
         // a. Return ? OrdinaryCreateFromConstructor(NewTarget, "%ObjectPrototype%").
-        Structure* objectStructure = InternalFunction::createSubclassStructure(exec, newTarget, globalObject->objectStructureForObjectConstructor());
+        Structure* objectStructure = InternalFunction::createSubclassStructure(globalObject, objectConstructor, newTarget, globalObject->objectStructureForObjectConstructor());
         RETURN_IF_EXCEPTION(scope, nullptr);
-        return constructEmptyObject(exec, objectStructure);
+        return constructEmptyObject(vm, objectStructure);
     }
 
     // 2. If value is null, undefined or not supplied, return ObjectCreate(%ObjectPrototype%).
-    ArgList args(exec);
-    JSValue arg = args.at(0);
-    if (arg.isUndefinedOrNull())
-        return constructEmptyObject(exec, globalObject->objectStructureForObjectConstructor());
+    JSValue argument = callFrame->argument(0);
+    if (argument.isUndefinedOrNull())
+        return constructEmptyObject(vm, globalObject->objectStructureForObjectConstructor());
 
     // 3. Return ToObject(value).
-    RELEASE_AND_RETURN(scope, arg.toObject(exec, globalObject));
+    RELEASE_AND_RETURN(scope, argument.toObject(globalObject));
 }
 
-static EncodedJSValue JSC_HOST_CALL constructWithObjectConstructor(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL constructWithObjectConstructor(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    return JSValue::encode(constructObject(exec, exec->newTarget()));
+    return JSValue::encode(constructObjectWithNewTarget(globalObject, callFrame, callFrame->newTarget()));
 }
 
-static EncodedJSValue JSC_HOST_CALL callObjectConstructor(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL callObjectConstructor(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    return JSValue::encode(constructObject(exec, JSValue()));
+    return JSValue::encode(constructObjectWithNewTarget(globalObject, callFrame, JSValue()));
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorGetPrototypeOf(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorGetPrototypeOf(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    JSObject* object = exec->argument(0).toObject(exec);
+    JSObject* object = callFrame->argument(0).toObject(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    RELEASE_AND_RETURN(scope, JSValue::encode(object->getPrototype(vm, exec)));
+    RELEASE_AND_RETURN(scope, JSValue::encode(object->getPrototype(vm, globalObject)));
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorSetPrototypeOf(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorSetPrototypeOf(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue objectValue = exec->argument(0);
+    JSValue objectValue = callFrame->argument(0);
     if (objectValue.isUndefinedOrNull())
-        return throwVMTypeError(exec, scope, "Cannot set prototype of undefined or null"_s);
+        return throwVMTypeError(globalObject, scope, "Cannot set prototype of undefined or null"_s);
 
-    JSValue protoValue = exec->argument(1);
+    JSValue protoValue = callFrame->argument(1);
     if (!protoValue.isObject() && !protoValue.isNull())
-        return throwVMTypeError(exec, scope, "Prototype value can only be an object or null"_s);
+        return throwVMTypeError(globalObject, scope, "Prototype value can only be an object or null"_s);
 
-    JSObject* object = objectValue.toObject(exec);
+    JSObject* object = objectValue.toObject(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     bool shouldThrowIfCantSet = true;
-    bool didSetPrototype = object->setPrototype(vm, exec, protoValue, shouldThrowIfCantSet);
+    bool didSetPrototype = object->setPrototype(vm, globalObject, protoValue, shouldThrowIfCantSet);
     EXCEPTION_ASSERT_UNUSED(didSetPrototype, scope.exception() || didSetPrototype);
     return JSValue::encode(objectValue);
 }
 
-JSValue objectConstructorGetOwnPropertyDescriptor(ExecState* exec, JSObject* object, const Identifier& propertyName)
+JSValue objectConstructorGetOwnPropertyDescriptor(JSGlobalObject* globalObject, JSObject* object, const Identifier& propertyName)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     PropertyDescriptor descriptor;
-    if (!object->getOwnPropertyDescriptor(exec, propertyName, descriptor))
+    if (!object->getOwnPropertyDescriptor(globalObject, propertyName, descriptor))
         RELEASE_AND_RETURN(scope, jsUndefined());
     RETURN_IF_EXCEPTION(scope, { });
 
-    JSObject* result = constructObjectFromPropertyDescriptor(exec, descriptor);
+    JSObject* result = constructObjectFromPropertyDescriptor(globalObject, descriptor);
     EXCEPTION_ASSERT(!!scope.exception() == !result);
     if (!result)
         return jsUndefined();
     return result;
 }
 
-JSValue objectConstructorGetOwnPropertyDescriptors(ExecState* exec, JSObject* object)
+JSValue objectConstructorGetOwnPropertyDescriptors(JSGlobalObject* globalObject, JSObject* object)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     PropertyNameArray properties(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
-    object->methodTable(vm)->getOwnPropertyNames(object, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));
+    object->methodTable(vm)->getOwnPropertyNames(object, globalObject, properties, EnumerationMode(DontEnumPropertiesMode::Include));
     RETURN_IF_EXCEPTION(scope, { });
 
-    JSObject* descriptors = constructEmptyObject(exec);
+    JSObject* descriptors = constructEmptyObject(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
     for (auto& propertyName : properties) {
         PropertyDescriptor descriptor;
-        bool didGetDescriptor = object->getOwnPropertyDescriptor(exec, propertyName, descriptor);
+        bool didGetDescriptor = object->getOwnPropertyDescriptor(globalObject, propertyName, descriptor);
         RETURN_IF_EXCEPTION(scope, { });
 
         if (!didGetDescriptor)
             continue;
 
-        JSObject* fromDescriptor = constructObjectFromPropertyDescriptor(exec, descriptor);
+        JSObject* fromDescriptor = constructObjectFromPropertyDescriptor(globalObject, descriptor);
         EXCEPTION_ASSERT(!!scope.exception() == !fromDescriptor);
         if (!fromDescriptor)
             return jsUndefined();
 
         PutPropertySlot slot(descriptors);
-        descriptors->putOwnDataPropertyMayBeIndex(exec, propertyName, fromDescriptor, slot);
+        descriptors->putOwnDataPropertyMayBeIndex(globalObject, propertyName, fromDescriptor, slot);
         scope.assertNoException();
     }
 
     return descriptors;
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyDescriptor(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyDescriptor(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    JSObject* object = exec->argument(0).toObject(exec);
+    JSObject* object = callFrame->argument(0).toObject(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    auto propertyName = exec->argument(1).toPropertyKey(exec);
+    auto propertyName = callFrame->argument(1).toPropertyKey(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorGetOwnPropertyDescriptor(exec, object, propertyName)));
+    RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorGetOwnPropertyDescriptor(globalObject, object, propertyName)));
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyDescriptors(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyDescriptors(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    JSObject* object = exec->argument(0).toObject(exec);
+    JSObject* object = callFrame->argument(0).toObject(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorGetOwnPropertyDescriptors(exec, object)));
+    RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorGetOwnPropertyDescriptors(globalObject, object)));
 }
 
 // FIXME: Use the enumeration cache.
-EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyNames(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyNames(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    JSObject* object = exec->argument(0).toObject(exec);
+    JSObject* object = callFrame->argument(0).toObject(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Include)));
+    RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(globalObject, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Include)));
 }
 
 // FIXME: Use the enumeration cache.
-EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertySymbols(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertySymbols(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    JSObject* object = exec->argument(0).toObject(exec);
+    JSObject* object = callFrame->argument(0).toObject(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(exec, object, PropertyNameMode::Symbols, DontEnumPropertiesMode::Include)));
+    RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(globalObject, object, PropertyNameMode::Symbols, DontEnumPropertiesMode::Include)));
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorKeys(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorKeys(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    JSObject* object = exec->argument(0).toObject(exec);
+    JSObject* object = callFrame->argument(0).toObject(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude)));
+    RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(globalObject, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude)));
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorAssign(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorAssign(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue targetValue = exec->argument(0);
+    JSValue targetValue = callFrame->argument(0);
     if (targetValue.isUndefinedOrNull())
-        return throwVMTypeError(exec, scope, "Object.assign requires that input parameter not be null or undefined"_s);
-    JSObject* target = targetValue.toObject(exec);
+        return throwVMTypeError(globalObject, scope, "Object.assign requires that input parameter not be null or undefined"_s);
+    JSObject* target = targetValue.toObject(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
     // FIXME: Extend this for non JSFinalObject. For example, we would like to use this fast path for function objects too.
     // https://bugs.webkit.org/show_bug.cgi?id=185358
     bool targetCanPerformFastPut = jsDynamicCast<JSFinalObject*>(vm, target) && target->canPerformFastPutInlineExcludingProto(vm);
 
     Vector<RefPtr<UniquedStringImpl>, 8> properties;
     MarkedArgumentBuffer values;
-    unsigned argsCount = exec->argumentCount();
+    unsigned argsCount = callFrame->argumentCount();
     for (unsigned i = 1; i < argsCount; ++i) {
-        JSValue sourceValue = exec->uncheckedArgument(i);
+        JSValue sourceValue = callFrame->uncheckedArgument(i);
         if (sourceValue.isUndefinedOrNull())
             continue;
-        JSObject* source = sourceValue.toObject(exec);
+        JSObject* source = sourceValue.toObject(globalObject);
         RETURN_IF_EXCEPTION(scope, { });
 
         if (targetCanPerformFastPut) {
             if (!source->staticPropertiesReified(vm)) {
-                source->reifyAllStaticProperties(exec);
+                source->reifyAllStaticProperties(globalObject);
                 RETURN_IF_EXCEPTION(scope, { });
             }
 
             auto canPerformFastPropertyEnumerationForObjectAssign = [] (Structure* structure) {
                 if (structure->typeInfo().overridesGetOwnPropertySlot())
@@ -372,31 +370,31 @@
         // [[GetOwnPropertyNames]], [[Get]] etc. could modify target object and invalidate this assumption.
         // For example, [[Get]] of source object could configure setter to target object. So disable the fast path.
         targetCanPerformFastPut = false;
 
         PropertyNameArray properties(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
-        source->methodTable(vm)->getOwnPropertyNames(source, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));
+        source->methodTable(vm)->getOwnPropertyNames(source, globalObject, properties, EnumerationMode(DontEnumPropertiesMode::Include));
         RETURN_IF_EXCEPTION(scope, { });
 
         auto assign = [&] (PropertyName propertyName) {
             PropertySlot slot(source, PropertySlot::InternalMethodType::GetOwnProperty);
-            bool hasProperty = source->methodTable(vm)->getOwnPropertySlot(source, exec, propertyName, slot);
+            bool hasProperty = source->methodTable(vm)->getOwnPropertySlot(source, globalObject, propertyName, slot);
             RETURN_IF_EXCEPTION(scope, void());
             if (!hasProperty)
                 return;
             if (slot.attributes() & PropertyAttribute::DontEnum)
                 return;
 
             JSValue value;
             if (LIKELY(!slot.isTaintedByOpaqueObject()))
-                value = slot.getValue(exec, propertyName);
+                value = slot.getValue(globalObject, propertyName);
             else
-                value = source->get(exec, propertyName);
+                value = source->get(globalObject, propertyName);
             RETURN_IF_EXCEPTION(scope, void());
 
             PutPropertySlot putPropertySlot(target, true);
-            target->putInline(exec, propertyName, value, putPropertySlot);
+            target->putInline(globalObject, propertyName, value, putPropertySlot);
         };
 
         // First loop is for strings. Second loop is for symbols to keep standardized order requirement in the spec.
         // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys
         bool foundSymbol = false;
@@ -424,46 +422,46 @@
         }
     }
     return JSValue::encode(target);
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorValues(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorValues(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue targetValue = exec->argument(0);
+    JSValue targetValue = callFrame->argument(0);
     if (targetValue.isUndefinedOrNull())
-        return throwVMTypeError(exec, scope, "Object.values requires that input parameter not be null or undefined"_s);
-    JSObject* target = targetValue.toObject(exec);
+        return throwVMTypeError(globalObject, scope, "Object.values requires that input parameter not be null or undefined"_s);
+    JSObject* target = targetValue.toObject(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
-    JSArray* values = constructEmptyArray(exec, nullptr);
+    JSArray* values = constructEmptyArray(globalObject, nullptr);
     RETURN_IF_EXCEPTION(scope, { });
 
     PropertyNameArray properties(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
-    target->methodTable(vm)->getOwnPropertyNames(target, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));
+    target->methodTable(vm)->getOwnPropertyNames(target, globalObject, properties, EnumerationMode(DontEnumPropertiesMode::Include));
     RETURN_IF_EXCEPTION(scope, { });
 
     unsigned index = 0;
     auto addValue = [&] (PropertyName propertyName) {
         PropertySlot slot(target, PropertySlot::InternalMethodType::GetOwnProperty);
-        bool hasProperty = target->methodTable(vm)->getOwnPropertySlot(target, exec, propertyName, slot);
+        bool hasProperty = target->methodTable(vm)->getOwnPropertySlot(target, globalObject, propertyName, slot);
         RETURN_IF_EXCEPTION(scope, void());
         if (!hasProperty)
             return;
         if (slot.attributes() & PropertyAttribute::DontEnum)
             return;
 
         JSValue value;
         if (LIKELY(!slot.isTaintedByOpaqueObject()))
-            value = slot.getValue(exec, propertyName);
+            value = slot.getValue(globalObject, propertyName);
         else
-            value = target->get(exec, propertyName);
+            value = target->get(globalObject, propertyName);
         RETURN_IF_EXCEPTION(scope, void());
 
-        values->putDirectIndex(exec, index++, value);
+        values->putDirectIndex(globalObject, index++, value);
     };
 
     for (unsigned i = 0, numProperties = properties.size(); i < numProperties; i++) {
         const auto& propertyName = properties[i];
         if (propertyName.isSymbol())
@@ -477,83 +475,83 @@
 }
 
 
 // ES6 6.2.4.5 ToPropertyDescriptor
 // https://tc39.github.io/ecma262/#sec-topropertydescriptor
-bool toPropertyDescriptor(ExecState* exec, JSValue in, PropertyDescriptor& desc)
+bool toPropertyDescriptor(JSGlobalObject* globalObject, JSValue in, PropertyDescriptor& desc)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!in.isObject()) {
-        throwTypeError(exec, scope, "Property description must be an object."_s);
+        throwTypeError(globalObject, scope, "Property description must be an object."_s);
         return false;
     }
     JSObject* description = asObject(in);
 
-    bool hasProperty = description->hasProperty(exec, vm.propertyNames->enumerable);
+    bool hasProperty = description->hasProperty(globalObject, vm.propertyNames->enumerable);
     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
     if (hasProperty) {
-        JSValue value = description->get(exec, vm.propertyNames->enumerable);
+        JSValue value = description->get(globalObject, vm.propertyNames->enumerable);
         RETURN_IF_EXCEPTION(scope, false);
-        desc.setEnumerable(value.toBoolean(exec));
+        desc.setEnumerable(value.toBoolean(globalObject));
     } else
         RETURN_IF_EXCEPTION(scope, false);
 
-    hasProperty = description->hasProperty(exec, vm.propertyNames->configurable);
+    hasProperty = description->hasProperty(globalObject, vm.propertyNames->configurable);
     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
     if (hasProperty) {
-        JSValue value = description->get(exec, vm.propertyNames->configurable);
+        JSValue value = description->get(globalObject, vm.propertyNames->configurable);
         RETURN_IF_EXCEPTION(scope, false);
-        desc.setConfigurable(value.toBoolean(exec));
+        desc.setConfigurable(value.toBoolean(globalObject));
     } else
         RETURN_IF_EXCEPTION(scope, false);
 
     JSValue value;
-    hasProperty = description->hasProperty(exec, vm.propertyNames->value);
+    hasProperty = description->hasProperty(globalObject, vm.propertyNames->value);
     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
     if (hasProperty) {
-        JSValue value = description->get(exec, vm.propertyNames->value);
+        JSValue value = description->get(globalObject, vm.propertyNames->value);
         RETURN_IF_EXCEPTION(scope, false);
         desc.setValue(value);
     } else
         RETURN_IF_EXCEPTION(scope, false);
 
-    hasProperty = description->hasProperty(exec, vm.propertyNames->writable);
+    hasProperty = description->hasProperty(globalObject, vm.propertyNames->writable);
     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
     if (hasProperty) {
-        JSValue value = description->get(exec, vm.propertyNames->writable);
+        JSValue value = description->get(globalObject, vm.propertyNames->writable);
         RETURN_IF_EXCEPTION(scope, false);
-        desc.setWritable(value.toBoolean(exec));
+        desc.setWritable(value.toBoolean(globalObject));
     } else
         RETURN_IF_EXCEPTION(scope, false);
 
-    hasProperty = description->hasProperty(exec, vm.propertyNames->get);
+    hasProperty = description->hasProperty(globalObject, vm.propertyNames->get);
     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
     if (hasProperty) {
-        JSValue get = description->get(exec, vm.propertyNames->get);
+        JSValue get = description->get(globalObject, vm.propertyNames->get);
         RETURN_IF_EXCEPTION(scope, false);
         if (!get.isUndefined()) {
             CallData callData;
             if (getCallData(vm, get, callData) == CallType::None) {
-                throwTypeError(exec, scope, "Getter must be a function."_s);
+                throwTypeError(globalObject, scope, "Getter must be a function."_s);
                 return false;
             }
         }
         desc.setGetter(get);
     } else
         RETURN_IF_EXCEPTION(scope, false);
 
-    hasProperty = description->hasProperty(exec, vm.propertyNames->set);
+    hasProperty = description->hasProperty(globalObject, vm.propertyNames->set);
     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
     if (hasProperty) {
-        JSValue set = description->get(exec, vm.propertyNames->set);
+        JSValue set = description->get(globalObject, vm.propertyNames->set);
         RETURN_IF_EXCEPTION(scope, false);
         if (!set.isUndefined()) {
             CallData callData;
             if (getCallData(vm, set, callData) == CallType::None) {
-                throwTypeError(exec, scope, "Setter must be a function."_s);
+                throwTypeError(globalObject, scope, "Setter must be a function."_s);
                 return false;
             }
         }
         desc.setSetter(set);
     } else
@@ -561,49 +559,49 @@
 
     if (!desc.isAccessorDescriptor())
         return true;
 
     if (desc.value()) {
-        throwTypeError(exec, scope, "Invalid property.  'value' present on property with getter or setter."_s);
+        throwTypeError(globalObject, scope, "Invalid property.  'value' present on property with getter or setter."_s);
         return false;
     }
 
     if (desc.writablePresent()) {
-        throwTypeError(exec, scope, "Invalid property.  'writable' present on property with getter or setter."_s);
+        throwTypeError(globalObject, scope, "Invalid property.  'writable' present on property with getter or setter."_s);
         return false;
     }
     return true;
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperty(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperty(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    if (!exec->argument(0).isObject())
-        return throwVMTypeError(exec, scope, "Properties can only be defined on Objects."_s);
-    JSObject* obj = asObject(exec->argument(0));
-    auto propertyName = exec->argument(1).toPropertyKey(exec);
+    if (!callFrame->argument(0).isObject())
+        return throwVMTypeError(globalObject, scope, "Properties can only be defined on Objects."_s);
+    JSObject* obj = asObject(callFrame->argument(0));
+    auto propertyName = callFrame->argument(1).toPropertyKey(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     PropertyDescriptor descriptor;
-    auto success = toPropertyDescriptor(exec, exec->argument(2), descriptor);
+    auto success = toPropertyDescriptor(globalObject, callFrame->argument(2), descriptor);
     EXCEPTION_ASSERT(!scope.exception() == success);
     if (!success)
         return JSValue::encode(jsNull());
     ASSERT((descriptor.attributes() & PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
     scope.assertNoException();
-    obj->methodTable(vm)->defineOwnProperty(obj, exec, propertyName, descriptor, true);
+    obj->methodTable(vm)->defineOwnProperty(obj, globalObject, propertyName, descriptor, true);
     RELEASE_AND_RETURN(scope, JSValue::encode(obj));
 }
 
-static JSValue defineProperties(ExecState* exec, JSObject* object, JSObject* properties)
+static JSValue defineProperties(JSGlobalObject* globalObject, JSObject* object, JSObject* properties)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     PropertyNameArray propertyNames(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
-    asObject(properties)->methodTable(vm)->getOwnPropertyNames(asObject(properties), exec, propertyNames, EnumerationMode(DontEnumPropertiesMode::Exclude));
+    asObject(properties)->methodTable(vm)->getOwnPropertyNames(asObject(properties), globalObject, propertyNames, EnumerationMode(DontEnumPropertiesMode::Exclude));
     RETURN_IF_EXCEPTION(scope, { });
     size_t numProperties = propertyNames.size();
     Vector<PropertyDescriptor> descriptors;
     MarkedArgumentBuffer markBuffer;
 #define RETURN_IF_EXCEPTION_CLEARING_OVERFLOW(value) do { \
@@ -611,14 +609,14 @@
         markBuffer.overflowCheckNotNeeded(); \
         return value; \
     } \
 } while (false)
     for (size_t i = 0; i < numProperties; i++) {
-        JSValue prop = properties->get(exec, propertyNames[i]);
+        JSValue prop = properties->get(globalObject, propertyNames[i]);
         RETURN_IF_EXCEPTION_CLEARING_OVERFLOW({ });
         PropertyDescriptor descriptor;
-        toPropertyDescriptor(exec, prop, descriptor);
+        toPropertyDescriptor(globalObject, prop, descriptor);
         RETURN_IF_EXCEPTION_CLEARING_OVERFLOW({ });
         descriptors.append(descriptor);
         // Ensure we mark all the values that we're accumulating
         if (descriptor.isDataDescriptor() && descriptor.value())
             markBuffer.append(descriptor.value());
@@ -633,68 +631,68 @@
 #undef RETURN_IF_EXCEPTION_CLEARING_OVERFLOW
     for (size_t i = 0; i < numProperties; i++) {
         auto& propertyName = propertyNames[i];
         ASSERT(!propertyName.isPrivateName());
 
-        object->methodTable(vm)->defineOwnProperty(object, exec, propertyName, descriptors[i], true);
+        object->methodTable(vm)->defineOwnProperty(object, globalObject, propertyName, descriptors[i], true);
         RETURN_IF_EXCEPTION(scope, { });
     }
     return object;
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperties(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperties(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    if (!exec->argument(0).isObject())
-        return throwVMTypeError(exec, scope, "Properties can only be defined on Objects."_s);
-    JSObject* targetObj = asObject(exec->argument(0));
-    JSObject* props = exec->argument(1).toObject(exec);
+    if (!callFrame->argument(0).isObject())
+        return throwVMTypeError(globalObject, scope, "Properties can only be defined on Objects."_s);
+    JSObject* targetObj = asObject(callFrame->argument(0));
+    JSObject* props = callFrame->argument(1).toObject(globalObject);
     EXCEPTION_ASSERT(!!scope.exception() == !props);
     if (UNLIKELY(!props))
         return encodedJSValue();
-    RELEASE_AND_RETURN(scope, JSValue::encode(defineProperties(exec, targetObj, props)));
+    RELEASE_AND_RETURN(scope, JSValue::encode(defineProperties(globalObject, targetObj, props)));
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorCreate(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorCreate(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue proto = exec->argument(0);
+    JSValue proto = callFrame->argument(0);
     if (!proto.isObject() && !proto.isNull())
-        return throwVMTypeError(exec, scope, "Object prototype may only be an Object or null."_s);
+        return throwVMTypeError(globalObject, scope, "Object prototype may only be an Object or null."_s);
     JSObject* newObject = proto.isObject()
-        ? constructEmptyObject(exec, asObject(proto))
-        : constructEmptyObject(exec, exec->lexicalGlobalObject()->nullPrototypeObjectStructure());
-    if (exec->argument(1).isUndefined())
+        ? constructEmptyObject(globalObject, asObject(proto))
+        : constructEmptyObject(vm, globalObject->nullPrototypeObjectStructure());
+    if (callFrame->argument(1).isUndefined())
         return JSValue::encode(newObject);
-    JSObject* properties = exec->uncheckedArgument(1).toObject(exec);
+    JSObject* properties = callFrame->uncheckedArgument(1).toObject(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
-    RELEASE_AND_RETURN(scope, JSValue::encode(defineProperties(exec, newObject, properties)));
+    RELEASE_AND_RETURN(scope, JSValue::encode(defineProperties(globalObject, newObject, properties)));
 }
 
 enum class IntegrityLevel {
     Sealed,
     Frozen
 };
 
 template<IntegrityLevel level>
-bool setIntegrityLevel(ExecState* exec, VM& vm, JSObject* object)
+bool setIntegrityLevel(JSGlobalObject* globalObject, VM& vm, JSObject* object)
 {
     // See https://tc39.github.io/ecma262/#sec-setintegritylevel.
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    bool success = object->methodTable(vm)->preventExtensions(object, exec);
+    bool success = object->methodTable(vm)->preventExtensions(object, globalObject);
     RETURN_IF_EXCEPTION(scope, false);
     if (UNLIKELY(!success))
         return false;
 
     PropertyNameArray properties(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
-    object->methodTable(vm)->getOwnPropertyNames(object, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));
+    object->methodTable(vm)->getOwnPropertyNames(object, globalObject, properties, EnumerationMode(DontEnumPropertiesMode::Include));
     RETURN_IF_EXCEPTION(scope, false);
 
     PropertyNameArray::const_iterator end = properties.end();
     for (PropertyNameArray::const_iterator iter = properties.begin(); iter != end; ++iter) {
         auto& propertyName = *iter;
@@ -702,57 +700,57 @@
 
         PropertyDescriptor desc;
         if (level == IntegrityLevel::Sealed)
             desc.setConfigurable(false);
         else {
-            bool hasPropertyDescriptor = object->getOwnPropertyDescriptor(exec, propertyName, desc);
+            bool hasPropertyDescriptor = object->getOwnPropertyDescriptor(globalObject, propertyName, desc);
             RETURN_IF_EXCEPTION(scope, false);
             if (!hasPropertyDescriptor)
                 continue;
 
             if (desc.isDataDescriptor())
                 desc.setWritable(false);
 
             desc.setConfigurable(false);
         }
 
-        object->methodTable(vm)->defineOwnProperty(object, exec, propertyName, desc, true);
+        object->methodTable(vm)->defineOwnProperty(object, globalObject, propertyName, desc, true);
         RETURN_IF_EXCEPTION(scope, false);
     }
     return true;
 }
 
 template<IntegrityLevel level>
-bool testIntegrityLevel(ExecState* exec, VM& vm, JSObject* object)
+bool testIntegrityLevel(JSGlobalObject* globalObject, VM& vm, JSObject* object)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // 1. Assert: Type(O) is Object.
     // 2. Assert: level is either "sealed" or "frozen".
 
     // 3. Let status be ?IsExtensible(O).
-    bool status = object->isExtensible(exec);
+    bool status = object->isExtensible(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
     // 4. If status is true, return false.
     if (status)
         return false;
 
     // 6. Let keys be ? O.[[OwnPropertyKeys]]().
     PropertyNameArray keys(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
-    object->methodTable(vm)->getOwnPropertyNames(object, exec, keys, EnumerationMode(DontEnumPropertiesMode::Include));
+    object->methodTable(vm)->getOwnPropertyNames(object, globalObject, keys, EnumerationMode(DontEnumPropertiesMode::Include));
     RETURN_IF_EXCEPTION(scope, { });
 
     // 7. For each element k of keys, do
     PropertyNameArray::const_iterator end = keys.end();
     for (PropertyNameArray::const_iterator iter = keys.begin(); iter != end; ++iter) {
         auto& propertyName = *iter;
         ASSERT(!propertyName.isPrivateName());
 
         // a. Let currentDesc be ? O.[[GetOwnProperty]](k)
         PropertyDescriptor desc;
-        bool didGetDescriptor = object->getOwnPropertyDescriptor(exec, propertyName, desc);
+        bool didGetDescriptor = object->getOwnPropertyDescriptor(globalObject, propertyName, desc);
         RETURN_IF_EXCEPTION(scope, { });
 
         // b. If currentDesc is not undefined, then
         if (!didGetDescriptor)
             continue;
@@ -768,146 +766,150 @@
     }
 
     return true;
 }
 
-JSObject* objectConstructorSeal(ExecState* exec, JSObject* object)
+JSObject* objectConstructorSeal(JSGlobalObject* globalObject, JSObject* object)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (jsDynamicCast<JSFinalObject*>(vm, object) && !hasIndexedProperties(object->indexingType())) {
         object->seal(vm);
         return object;
     }
 
-    bool success = setIntegrityLevel<IntegrityLevel::Sealed>(exec, vm, object);
+    bool success = setIntegrityLevel<IntegrityLevel::Sealed>(globalObject, vm, object);
     RETURN_IF_EXCEPTION(scope, nullptr);
     if (UNLIKELY(!success)) {
-        throwTypeError(exec, scope, "Unable to prevent extension in Object.seal"_s);
+        throwTypeError(globalObject, scope, "Unable to prevent extension in Object.seal"_s);
         return nullptr;
     }
 
     return object;
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorSeal(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorSeal(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // 1. If Type(O) is not Object, return O.
-    JSValue obj = exec->argument(0);
+    JSValue obj = callFrame->argument(0);
     if (!obj.isObject())
         return JSValue::encode(obj);
 
-    RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorSeal(exec, asObject(obj))));
+    RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorSeal(globalObject, asObject(obj))));
 }
 
-JSObject* objectConstructorFreeze(ExecState* exec, JSObject* object)
+JSObject* objectConstructorFreeze(JSGlobalObject* globalObject, JSObject* object)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (jsDynamicCast<JSFinalObject*>(vm, object) && !hasIndexedProperties(object->indexingType())) {
         object->freeze(vm);
         return object;
     }
 
-    bool success = setIntegrityLevel<IntegrityLevel::Frozen>(exec, vm, object);
+    bool success = setIntegrityLevel<IntegrityLevel::Frozen>(globalObject, vm, object);
     RETURN_IF_EXCEPTION(scope, nullptr);
     if (UNLIKELY(!success)) {
-        throwTypeError(exec, scope, "Unable to prevent extension in Object.freeze"_s);
+        throwTypeError(globalObject, scope, "Unable to prevent extension in Object.freeze"_s);
         return nullptr;
     }
     return object;
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorFreeze(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorFreeze(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     // 1. If Type(O) is not Object, return O.
-    JSValue obj = exec->argument(0);
+    JSValue obj = callFrame->argument(0);
     if (!obj.isObject())
         return JSValue::encode(obj);
-    JSObject* result = objectConstructorFreeze(exec, asObject(obj));
+    JSObject* result = objectConstructorFreeze(globalObject, asObject(obj));
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     return JSValue::encode(result);
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorPreventExtensions(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorPreventExtensions(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
-    JSValue argument = exec->argument(0);
+    VM& vm = globalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
+
+    JSValue argument = callFrame->argument(0);
     if (!argument.isObject())
         return JSValue::encode(argument);
     JSObject* object = asObject(argument);
-    object->methodTable(vm)->preventExtensions(object, exec);
+    bool status = object->methodTable(vm)->preventExtensions(object, globalObject);
+    RETURN_IF_EXCEPTION(scope, { });
+    if (UNLIKELY(!status))
+        return throwVMTypeError(globalObject, scope, "Unable to prevent extension in Object.preventExtensions"_s);
     return JSValue::encode(object);
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorIsSealed(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorIsSealed(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
 
     // 1. If Type(O) is not Object, return true.
-    JSValue obj = exec->argument(0);
+    JSValue obj = callFrame->argument(0);
     if (!obj.isObject())
         return JSValue::encode(jsBoolean(true));
     JSObject* object = asObject(obj);
 
     // Quick check for final objects.
     if (jsDynamicCast<JSFinalObject*>(vm, object) && !hasIndexedProperties(object->indexingType()))
         return JSValue::encode(jsBoolean(object->isSealed(vm)));
 
     // 2. Return ? TestIntegrityLevel(O, "sealed").
-    return JSValue::encode(jsBoolean(testIntegrityLevel<IntegrityLevel::Sealed>(exec, vm, object)));
+    return JSValue::encode(jsBoolean(testIntegrityLevel<IntegrityLevel::Sealed>(globalObject, vm, object)));
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorIsFrozen(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorIsFrozen(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
 
     // 1. If Type(O) is not Object, return true.
-    JSValue obj = exec->argument(0);
+    JSValue obj = callFrame->argument(0);
     if (!obj.isObject())
         return JSValue::encode(jsBoolean(true));
     JSObject* object = asObject(obj);
 
     // Quick check for final objects.
     if (jsDynamicCast<JSFinalObject*>(vm, object) && !hasIndexedProperties(object->indexingType()))
         return JSValue::encode(jsBoolean(object->isFrozen(vm)));
 
     // 2. Return ? TestIntegrityLevel(O, "frozen").
-    return JSValue::encode(jsBoolean(testIntegrityLevel<IntegrityLevel::Frozen>(exec, vm, object)));
+    return JSValue::encode(jsBoolean(testIntegrityLevel<IntegrityLevel::Frozen>(globalObject, vm, object)));
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorIsExtensible(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorIsExtensible(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    JSValue obj = exec->argument(0);
+    JSValue obj = callFrame->argument(0);
     if (!obj.isObject())
         return JSValue::encode(jsBoolean(false));
     JSObject* object = asObject(obj);
-    bool isExtensible = object->isExtensible(exec);
+    bool isExtensible = object->isExtensible(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     return JSValue::encode(jsBoolean(isExtensible));
 }
 
-EncodedJSValue JSC_HOST_CALL objectConstructorIs(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL objectConstructorIs(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    return JSValue::encode(jsBoolean(sameValue(exec, exec->argument(0), exec->argument(1))));
+    return JSValue::encode(jsBoolean(sameValue(globalObject, callFrame->argument(0), callFrame->argument(1))));
 }
 
-JSArray* ownPropertyKeys(ExecState* exec, JSObject* object, PropertyNameMode propertyNameMode, DontEnumPropertiesMode dontEnumPropertiesMode)
+JSArray* ownPropertyKeys(JSGlobalObject* globalObject, JSObject* object, PropertyNameMode propertyNameMode, DontEnumPropertiesMode dontEnumPropertiesMode)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    auto* globalObject = exec->lexicalGlobalObject();
     bool isObjectKeys = propertyNameMode == PropertyNameMode::Strings && dontEnumPropertiesMode == DontEnumPropertiesMode::Exclude;
     // We attempt to look up own property keys cache in Object.keys case.
     if (isObjectKeys) {
         if (LIKELY(!globalObject->isHavingABadTime())) {
             if (auto* immutableButterfly = object->structure(vm)->cachedOwnKeys()) {
@@ -916,11 +918,11 @@
             }
         }
     }
 
     PropertyNameArray properties(vm, propertyNameMode, PrivateSymbolMode::Exclude);
-    object->methodTable(vm)->getOwnPropertyNames(object, exec, properties, EnumerationMode(dontEnumPropertiesMode));
+    object->methodTable(vm)->getOwnPropertyNames(object, globalObject, properties, EnumerationMode(dontEnumPropertiesMode));
     RETURN_IF_EXCEPTION(scope, nullptr);
 
     if (propertyNameMode != PropertyNameMode::StringsAndSymbols) {
         ASSERT(propertyNameMode == PropertyNameMode::Strings || propertyNameMode == PropertyNameMode::Symbols);
         if (properties.size() < MIN_SPARSE_ARRAY_INDEX) {
@@ -964,25 +966,25 @@
                 return keys;
             }
         }
     }
 
-    JSArray* keys = constructEmptyArray(exec, nullptr);
+    JSArray* keys = constructEmptyArray(globalObject, nullptr);
     RETURN_IF_EXCEPTION(scope, nullptr);
 
     unsigned index = 0;
-    auto pushDirect = [&] (ExecState* exec, JSArray* array, JSValue value) {
-        array->putDirectIndex(exec, index++, value);
+    auto pushDirect = [&] (JSGlobalObject* globalObject, JSArray* array, JSValue value) {
+        array->putDirectIndex(globalObject, index++, value);
     };
 
     switch (propertyNameMode) {
     case PropertyNameMode::Strings: {
         size_t numProperties = properties.size();
         for (size_t i = 0; i < numProperties; i++) {
             const auto& identifier = properties[i];
             ASSERT(!identifier.isSymbol());
-            pushDirect(exec, keys, jsOwnedString(vm, identifier.string()));
+            pushDirect(globalObject, keys, jsOwnedString(vm, identifier.string()));
             RETURN_IF_EXCEPTION(scope, nullptr);
         }
         break;
     }
 
@@ -990,11 +992,11 @@
         size_t numProperties = properties.size();
         for (size_t i = 0; i < numProperties; i++) {
             const auto& identifier = properties[i];
             ASSERT(identifier.isSymbol());
             ASSERT(!identifier.isPrivateName());
-            pushDirect(exec, keys, Symbol::create(vm, static_cast<SymbolImpl&>(*identifier.impl())));
+            pushDirect(globalObject, keys, Symbol::create(vm, static_cast<SymbolImpl&>(*identifier.impl())));
             RETURN_IF_EXCEPTION(scope, nullptr);
         }
         break;
     }
 
@@ -1007,17 +1009,17 @@
                 ASSERT(!identifier.isPrivateName());
                 propertySymbols.append(identifier);
                 continue;
             }
 
-            pushDirect(exec, keys, jsOwnedString(vm, identifier.string()));
+            pushDirect(globalObject, keys, jsOwnedString(vm, identifier.string()));
             RETURN_IF_EXCEPTION(scope, nullptr);
         }
 
         // To ensure the order defined in the spec (9.1.12), we append symbols at the last elements of keys.
         for (const auto& identifier : propertySymbols) {
-            pushDirect(exec, keys, Symbol::create(vm, static_cast<SymbolImpl&>(*identifier.impl())));
+            pushDirect(globalObject, keys, Symbol::create(vm, static_cast<SymbolImpl&>(*identifier.impl())));
             RETURN_IF_EXCEPTION(scope, nullptr);
         }
 
         break;
     }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorNetworkAgent.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
  3  * Copyright (C) 2015 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #pragma once
 33 
 34 #include &quot;InspectorInstrumentation.h&quot;
 35 #include &quot;InspectorPageAgent.h&quot;
 36 #include &quot;InspectorWebAgentBase.h&quot;
 37 #include &lt;JavaScriptCore/InspectorBackendDispatchers.h&gt;
 38 #include &lt;JavaScriptCore/InspectorFrontendDispatchers.h&gt;
 39 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 40 #include &lt;wtf/Forward.h&gt;
 41 #include &lt;wtf/JSONValues.h&gt;
 42 
 43 namespace Inspector {
 44 class InjectedScriptManager;
 45 }
 46 
 47 namespace WebCore {
 48 
 49 class CachedResource;
 50 class Document;
 51 class DocumentLoader;
 52 class DocumentThreadableLoader;
 53 class NetworkLoadMetrics;
 54 class NetworkResourcesData;
 55 class ResourceError;
 56 class ResourceLoader;
 57 class ResourceRequest;
 58 class ResourceResponse;
 59 class TextResourceDecoder;
 60 class WebSocket;
 61 
 62 struct WebSocketFrame;
 63 
 64 typedef String ErrorString;
 65 
 66 class InspectorNetworkAgent : public InspectorAgentBase, public Inspector::NetworkBackendDispatcherHandler {
 67     WTF_MAKE_NONCOPYABLE(InspectorNetworkAgent);
 68     WTF_MAKE_FAST_ALLOCATED;
 69 public:
 70     ~InspectorNetworkAgent() override;
 71 
 72     static bool shouldTreatAsText(const String&amp; mimeType);
 73     static Ref&lt;TextResourceDecoder&gt; createTextDecoder(const String&amp; mimeType, const String&amp; textEncodingName);
 74     static Optional&lt;String&gt; textContentForCachedResource(CachedResource&amp;);
 75     static bool cachedResourceContent(CachedResource&amp;, String* result, bool* base64Encoded);
 76 
 77     // InspectorAgentBase
 78     void didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*) final;
 79     void willDestroyFrontendAndBackend(Inspector::DisconnectReason) final;
 80 
 81     // NetworkBackendDispatcherHandler
 82     void enable(ErrorString&amp;) final;
 83     void disable(ErrorString&amp;) final;
 84     void setExtraHTTPHeaders(ErrorString&amp;, const JSON::Object&amp; headers) final;
 85     void getResponseBody(ErrorString&amp;, const String&amp; requestId, String* content, bool* base64Encoded) final;
 86     void setResourceCachingDisabled(ErrorString&amp;, bool disabled) final;
 87     void loadResource(const String&amp; frameId, const String&amp; url, Ref&lt;LoadResourceCallback&gt;&amp;&amp;) final;
 88     void getSerializedCertificate(ErrorString&amp;, const String&amp; requestId, String* serializedCertificate) final;
 89     void resolveWebSocket(ErrorString&amp;, const String&amp; requestId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp;) final;
 90     void setInterceptionEnabled(ErrorString&amp;, bool enabled) final;
 91     void addInterception(ErrorString&amp;, const String&amp; url, const bool* caseSensitive, const bool* isRegex, const String* networkStageString) final;
 92     void removeInterception(ErrorString&amp;, const String&amp; url, const bool* caseSensitive, const bool* isRegex, const String* networkStageString) final;
 93     void interceptContinue(ErrorString&amp;, const String&amp; requestId) final;
 94     void interceptWithResponse(ErrorString&amp;, const String&amp; requestId, const String&amp; content, bool base64Encoded, const String* mimeType, const int* status, const String* statusText, const JSON::Object* headers) final;
 95 
 96     // InspectorInstrumentation
 97     void willRecalculateStyle();
 98     void didRecalculateStyle();
 99     void willSendRequest(unsigned long identifier, DocumentLoader*, ResourceRequest&amp;, const ResourceResponse&amp; redirectResponse);
100     void willSendRequestOfType(unsigned long identifier, DocumentLoader*, ResourceRequest&amp;, InspectorInstrumentation::LoadType);
101     void didReceiveResponse(unsigned long identifier, DocumentLoader*, const ResourceResponse&amp;, ResourceLoader*);
102     void didReceiveData(unsigned long identifier, const char* data, int dataLength, int encodedDataLength);
103     void didFinishLoading(unsigned long identifier, DocumentLoader*, const NetworkLoadMetrics&amp;, ResourceLoader*);
104     void didFailLoading(unsigned long identifier, DocumentLoader*, const ResourceError&amp;);
105     void didLoadResourceFromMemoryCache(DocumentLoader*, CachedResource&amp;);
106     void didReceiveThreadableLoaderResponse(unsigned long identifier, DocumentThreadableLoader&amp;);
107     void willLoadXHRSynchronously();
108     void didLoadXHRSynchronously();
109     void didReceiveScriptResponse(unsigned long identifier);
110     void willDestroyCachedResource(CachedResource&amp;);
111     void didCreateWebSocket(unsigned long identifier, const URL&amp; requestURL);
112     void willSendWebSocketHandshakeRequest(unsigned long identifier, const ResourceRequest&amp;);
113     void didReceiveWebSocketHandshakeResponse(unsigned long identifier, const ResourceResponse&amp;);
114     void didCloseWebSocket(unsigned long identifier);
115     void didReceiveWebSocketFrame(unsigned long identifier, const WebSocketFrame&amp;);
116     void didSendWebSocketFrame(unsigned long identifier, const WebSocketFrame&amp;);
117     void didReceiveWebSocketFrameError(unsigned long identifier, const String&amp;);
118     void mainFrameNavigated(DocumentLoader&amp;);
119     void setInitialScriptContent(unsigned long identifier, const String&amp; sourceString);
120     void didScheduleStyleRecalculation(Document&amp;);
121     bool willInterceptRequest(const ResourceRequest&amp;);
122     bool shouldInterceptResponse(const ResourceResponse&amp;);
123     void interceptResponse(const ResourceResponse&amp;, unsigned long identifier, CompletionHandler&lt;void(const ResourceResponse&amp;, RefPtr&lt;SharedBuffer&gt;)&gt;&amp;&amp;);
124 
125     void searchOtherRequests(const JSC::Yarr::RegularExpression&amp;, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;&gt;&amp;);
126     void searchInRequest(ErrorString&amp;, const String&amp; requestId, const String&amp; query, bool caseSensitive, bool isRegex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;&gt;&amp;);
127 
128 protected:
129     InspectorNetworkAgent(WebAgentContext&amp;);
130 
131     virtual String loaderIdentifier(DocumentLoader*) = 0;
132     virtual String frameIdentifier(DocumentLoader*) = 0;
133     virtual Vector&lt;WebSocket*&gt; activeWebSockets(const LockHolder&amp;) = 0;
134     virtual void setResourceCachingDisabled(bool) = 0;
135     virtual ScriptExecutionContext* scriptExecutionContext(ErrorString&amp;, const String&amp; frameId) = 0;
136     virtual bool shouldForceBufferingNetworkResourceData() const = 0;
137 
138 private:
139     void enable();
140 
141     void willSendRequest(unsigned long identifier, DocumentLoader*, ResourceRequest&amp;, const ResourceResponse&amp; redirectResponse, InspectorPageAgent::ResourceType);
142 
143     bool shouldIntercept(URL);
144     void continuePendingResponses();
145 
146     WebSocket* webSocketForRequestId(const String&amp; requestId);
147 
148     RefPtr&lt;Inspector::Protocol::Network::Initiator&gt; buildInitiatorObject(Document*, Optional&lt;const ResourceRequest&amp;&gt; = WTF::nullopt);
149     Ref&lt;Inspector::Protocol::Network::ResourceTiming&gt; buildObjectForTiming(const NetworkLoadMetrics&amp;, ResourceLoader&amp;);
150     Ref&lt;Inspector::Protocol::Network::Metrics&gt; buildObjectForMetrics(const NetworkLoadMetrics&amp;);
151     RefPtr&lt;Inspector::Protocol::Network::Response&gt; buildObjectForResourceResponse(const ResourceResponse&amp;, ResourceLoader*);
152     Ref&lt;Inspector::Protocol::Network::CachedResource&gt; buildObjectForCachedResource(CachedResource*);
153 
154     double timestamp();
155 
156     class PendingInterceptResponse {
157         WTF_MAKE_NONCOPYABLE(PendingInterceptResponse);
158         WTF_MAKE_FAST_ALLOCATED;
159     public:
160         PendingInterceptResponse(const ResourceResponse&amp; originalResponse, CompletionHandler&lt;void(const ResourceResponse&amp;, RefPtr&lt;SharedBuffer&gt;)&gt;&amp;&amp; completionHandler)
161             : m_originalResponse(originalResponse)
162             , m_completionHandler(WTFMove(completionHandler))
163         { }
164 
165         ~PendingInterceptResponse()
166         {
167             ASSERT(m_responded);
168         }
169 
170         ResourceResponse originalResponse() { return m_originalResponse; }
171 
172         void respondWithOriginalResponse()
173         {
174             respond(m_originalResponse, nullptr);
175         }
176 
177         void respond(const ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt; data)
178         {
179             ASSERT(!m_responded);
180             if (m_responded)
181                 return;
182 
183             m_responded = true;
184 
185             m_completionHandler(response, data);
186         }
187 
188     private:
189         ResourceResponse m_originalResponse;
190         CompletionHandler&lt;void(const ResourceResponse&amp;, RefPtr&lt;SharedBuffer&gt;)&gt; m_completionHandler;
191         bool m_responded { false };
192     };
193 
194     std::unique_ptr&lt;Inspector::NetworkFrontendDispatcher&gt; m_frontendDispatcher;
195     RefPtr&lt;Inspector::NetworkBackendDispatcher&gt; m_backendDispatcher;
196     Inspector::InjectedScriptManager&amp; m_injectedScriptManager;
197 
198     std::unique_ptr&lt;NetworkResourcesData&gt; m_resourcesData;
199 
200     HashMap&lt;String, String&gt; m_extraRequestHeaders;
201     HashSet&lt;unsigned long&gt; m_hiddenRequestIdentifiers;
202 
203     struct Intercept {
204         String url;
205         bool caseSensitive { true };
206         bool isRegex { false };
207 
208         inline bool operator==(const Intercept&amp; other) const
209         {
210             return url == other.url
211                 &amp;&amp; caseSensitive == other.caseSensitive
212                 &amp;&amp; isRegex == other.isRegex;
213         }
214     };
215     Vector&lt;Intercept&gt; m_intercepts;
216     HashMap&lt;String, std::unique_ptr&lt;PendingInterceptResponse&gt;&gt; m_pendingInterceptResponses;
217 
218     // FIXME: InspectorNetworkAgent should not be aware of style recalculation.
219     RefPtr&lt;Inspector::Protocol::Network::Initiator&gt; m_styleRecalculationInitiator;
220     bool m_isRecalculatingStyle { false };
221 
222     bool m_enabled { false };
223     bool m_loadingXHRSynchronously { false };
224     bool m_interceptionEnabled { false };
225 };
226 
227 } // namespace WebCore
    </pre>
  </body>
</html>
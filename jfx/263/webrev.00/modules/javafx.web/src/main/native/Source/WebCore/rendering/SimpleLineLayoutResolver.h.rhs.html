<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;LayoutRect.h&quot;
 29 #include &quot;RenderBlockFlow.h&quot;
 30 #include &quot;SimpleLineLayout.h&quot;
 31 #include &quot;SimpleLineLayoutFlowContents.h&quot;
 32 #include &lt;wtf/IteratorRange.h&gt;
 33 #include &lt;wtf/text/WTFString.h&gt;
 34 
 35 namespace WebCore {
 36 namespace SimpleLineLayout {
 37 
 38 class RunResolver {
 39     WTF_MAKE_FAST_ALLOCATED;
 40 public:
 41     class Iterator;
 42 
 43     class Run {
 44     public:
 45         explicit Run(const Iterator&amp;);
 46 
 47         // Position relative to the enclosing flow block.
 48         unsigned start() const;
 49         unsigned end() const;
 50         // Position relative to the actual renderer.
 51         unsigned localStart() const;
 52         unsigned localEnd() const;
 53 
 54         float logicalLeft() const;
 55         float logicalRight() const;
 56 
 57         FloatRect rect() const;
 58         float expansion() const;
 59         ExpansionBehavior expansionBehavior() const;
 60         int baselinePosition() const;
<a name="1" id="anc1"></a><span class="line-added"> 61         int baselineOffset() const { return m_iterator.resolver().m_baseline; }</span>
 62         StringView text() const;
 63         String textWithHyphen() const;
 64         const RenderObject&amp; renderer() const;
 65         bool isEndOfLine() const;
 66         bool hasHyphen() const { return m_iterator.simpleRun().hasHyphen; }
<a name="2" id="anc2"></a><span class="line-added"> 67         bool isLineBreak() const { return m_iterator.simpleRun().isLineBreak; }</span>
 68         const SimpleLineLayout::Run&amp; simpleRun() const { return m_iterator.simpleRun(); }
 69 
 70         unsigned lineIndex() const;
 71 
 72     private:
 73         float computeBaselinePosition() const;
 74         void constructStringForHyphenIfNeeded();
 75 
 76         const Iterator&amp; m_iterator;
 77     };
 78 
 79     class Iterator {
 80     friend class Run;
 81     friend class RunResolver;
 82     friend class LineResolver;
 83     public:
 84         Iterator(const RunResolver&amp;, unsigned runIndex, unsigned lineIndex);
 85 
 86         Iterator&amp; operator++();
 87         Iterator&amp; operator--();
 88 
 89         bool operator==(const Iterator&amp;) const;
 90         bool operator!=(const Iterator&amp;) const;
 91 
 92         Run operator*() const;
 93 
<a name="3" id="anc3"></a><span class="line-added"> 94         bool atBegin() const;</span>
<span class="line-added"> 95 </span>
 96     private:
 97         const SimpleLineLayout::Run&amp; simpleRun() const;
 98         unsigned lineIndex() const { return m_lineIndex; }
 99         Iterator&amp; advance();
100         Iterator&amp; advanceLines(unsigned);
<a name="4" id="anc4"></a><span class="line-modified">101         const RunResolver&amp; resolver() const { return *m_resolver; }</span>
<span class="line-modified">102         const Layout&amp; layout() const { return *m_layout; }</span>
103 
<a name="5" id="anc5"></a><span class="line-modified">104         RefPtr&lt;const Layout&gt; m_layout;</span>
<span class="line-added">105         const RunResolver* m_resolver;</span>
106         unsigned m_runIndex;
107         unsigned m_lineIndex;
108     };
109 
110     RunResolver(const RenderBlockFlow&amp;, const Layout&amp;);
111 
112     const RenderBlockFlow&amp; flow() const { return m_flowRenderer; }
113     const FlowContents&amp; flowContents() const { return m_flowContents; }
114     Iterator begin() const;
115     Iterator end() const;
116 
117     WTF::IteratorRange&lt;Iterator&gt; rangeForRect(const LayoutRect&amp;) const;
118     WTF::IteratorRange&lt;Iterator&gt; rangeForRenderer(const RenderObject&amp;) const;
119     WTF::IteratorRange&lt;Iterator&gt; rangeForLine(unsigned lineIndex) const;
120     Iterator runForPoint(const LayoutPoint&amp;) const;
121     WTF::IteratorRange&lt;Iterator&gt; rangeForRendererWithOffsets(const RenderObject&amp;, unsigned start, unsigned end) const;
122 
123 private:
124     enum class IndexType { First, Last };
125     unsigned lineIndexForHeight(LayoutUnit, IndexType) const;
126     unsigned adjustLineIndexForStruts(LayoutUnit, IndexType, unsigned lineIndexCandidate) const;
127 
128     const RenderBlockFlow&amp; m_flowRenderer;
129     const Layout&amp; m_layout;
130     const FlowContents m_flowContents;
131     const LayoutUnit m_lineHeight;
132     const LayoutUnit m_baseline;
133     const LayoutUnit m_borderAndPaddingBefore;
134     const float m_ascent;
135     const float m_descent;
136     const float m_visualOverflowOffset;
<a name="6" id="anc6"></a>
137 };
138 
139 class LineResolver {
140 public:
141     class Iterator {
142     public:
143         explicit Iterator(RunResolver::Iterator);
144 
145         Iterator&amp; operator++();
146         bool operator==(const Iterator&amp;) const;
147         bool operator!=(const Iterator&amp;) const;
148 
149         FloatRect operator*() const;
150         // FIXME: Use a list to support multiple renderers per line.
151         const RenderObject&amp; renderer() const;
152 
153     private:
154         RunResolver::Iterator m_runIterator;
155     };
156 
157     LineResolver(const RunResolver&amp;);
158 
159     Iterator begin() const;
160     Iterator end() const;
161 
162     WTF::IteratorRange&lt;Iterator&gt; rangeForRect(const LayoutRect&amp;) const;
163 
164 private:
165     const RunResolver&amp; m_runResolver;
166 };
167 
168 RunResolver runResolver(const RenderBlockFlow&amp;, const Layout&amp;);
169 LineResolver lineResolver(const RunResolver&amp;);
170 
171 inline unsigned RunResolver::Run::start() const
172 {
173     return m_iterator.simpleRun().start;
174 }
175 
176 inline unsigned RunResolver::Run::end() const
177 {
178     return m_iterator.simpleRun().end;
179 }
180 
181 inline float RunResolver::Run::logicalLeft() const
182 {
183     return m_iterator.simpleRun().logicalLeft;
184 }
185 
186 inline float RunResolver::Run::logicalRight() const
187 {
188     return m_iterator.simpleRun().logicalRight;
189 }
190 
191 inline float RunResolver::Run::expansion() const
192 {
193     return m_iterator.simpleRun().expansion;
194 }
195 
196 inline ExpansionBehavior RunResolver::Run::expansionBehavior() const
197 {
198     return m_iterator.simpleRun().expansionBehavior;
199 }
200 
201 inline int RunResolver::Run::baselinePosition() const
202 {
203     return roundToInt(computeBaselinePosition());
204 }
205 
206 inline bool RunResolver::Run::isEndOfLine() const
207 {
208     return m_iterator.simpleRun().isEndOfLine;
209 }
210 
211 inline unsigned RunResolver::Run::lineIndex() const
212 {
213     return m_iterator.lineIndex();
214 }
215 
216 inline RunResolver::Iterator&amp; RunResolver::Iterator::operator++()
217 {
218     return advance();
219 }
220 
221 inline float RunResolver::Run::computeBaselinePosition() const
222 {
223     auto&amp; resolver = m_iterator.resolver();
224     auto offset = resolver.m_borderAndPaddingBefore + resolver.m_lineHeight * lineIndex();
<a name="7" id="anc7"></a><span class="line-modified">225     if (!m_iterator.layout().hasLineStruts())</span>
226         return offset + resolver.m_baseline;
227     for (auto&amp; strutEntry : resolver.m_layout.struts()) {
228         if (strutEntry.lineBreak &gt; lineIndex())
229             break;
230         offset += strutEntry.offset;
231     }
232     return offset + resolver.m_baseline;
233 }
234 
235 inline RunResolver::Iterator&amp; RunResolver::Iterator::operator--()
236 {
237     --m_runIndex;
238     if (simpleRun().isEndOfLine)
239         --m_lineIndex;
240     return *this;
241 }
242 
243 inline bool RunResolver::Iterator::operator==(const Iterator&amp; other) const
244 {
<a name="8" id="anc8"></a><span class="line-modified">245     ASSERT(m_resolver == other.m_resolver);</span>
246     return m_runIndex == other.m_runIndex;
247 }
248 
249 inline bool RunResolver::Iterator::operator!=(const Iterator&amp; other) const
250 {
251     return !(*this == other);
252 }
253 
254 inline RunResolver::Run RunResolver::Iterator::operator*() const
255 {
256     return Run(*this);
257 }
258 
<a name="9" id="anc9"></a><span class="line-added">259 inline bool RunResolver::Iterator::atBegin() const</span>
<span class="line-added">260 {</span>
<span class="line-added">261     return *this == resolver().begin();</span>
<span class="line-added">262 }</span>
<span class="line-added">263 </span>
264 inline const SimpleLineLayout::Run&amp; RunResolver::Iterator::simpleRun() const
265 {
<a name="10" id="anc10"></a><span class="line-modified">266     return layout().runAt(m_runIndex);</span>
267 }
268 
269 inline RunResolver::Iterator RunResolver::begin() const
270 {
271     return Iterator(*this, 0, 0);
272 }
273 
274 inline RunResolver::Iterator RunResolver::end() const
275 {
276     return Iterator(*this, m_layout.runCount(), m_layout.lineCount());
277 }
278 
279 inline LineResolver::Iterator&amp; LineResolver::Iterator::operator++()
280 {
281     m_runIterator.advanceLines(1);
282     return *this;
283 }
284 
285 inline bool LineResolver::Iterator::operator==(const Iterator&amp; other) const
286 {
287     return m_runIterator == other.m_runIterator;
288 }
289 
290 inline bool LineResolver::Iterator::operator!=(const Iterator&amp; other) const
291 {
292     return m_runIterator != other.m_runIterator;
293 }
294 
295 inline LineResolver::Iterator LineResolver::begin() const
296 {
297     return Iterator(m_runResolver.begin());
298 }
299 
300 inline LineResolver::Iterator LineResolver::end() const
301 {
302     return Iterator(m_runResolver.end());
303 }
304 
305 inline WTF::IteratorRange&lt;LineResolver::Iterator&gt; LineResolver::rangeForRect(const LayoutRect&amp; rect) const
306 {
307     auto runRange = m_runResolver.rangeForRect(rect);
308     return { Iterator(runRange.begin()), Iterator(runRange.end()) };
309 }
310 
<a name="11" id="anc11"></a>




311 inline LineResolver lineResolver(const RunResolver&amp; runResolver)
312 {
313     return LineResolver(runResolver);
314 }
315 
316 }
317 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
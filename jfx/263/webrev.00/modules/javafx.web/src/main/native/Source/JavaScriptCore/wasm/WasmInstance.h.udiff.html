<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmInstance.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmInstance.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmMemory.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmInstance.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,30 +26,32 @@</span>
  #pragma once
  
  #if ENABLE(WEBASSEMBLY)
  
  #include &quot;WasmFormat.h&quot;
<span class="udiff-line-added">+ #include &quot;WasmGlobal.h&quot;</span>
  #include &quot;WasmMemory.h&quot;
  #include &quot;WasmModule.h&quot;
  #include &quot;WasmTable.h&quot;
  #include &quot;WriteBarrier.h&quot;
  #include &lt;wtf/BitVector.h&gt;
  #include &lt;wtf/RefPtr.h&gt;
  #include &lt;wtf/ThreadSafeRefCounted.h&gt;
  
<span class="udiff-line-modified-removed">- namespace JSC { namespace Wasm {</span>
<span class="udiff-line-modified-added">+ namespace JSC {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ class LLIntOffsetsExtractor;</span>
<span class="udiff-line-added">+ class JSWebAssemblyInstance;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ namespace Wasm {</span>
  
  struct Context;
  class Instance;
  
<span class="udiff-line-removed">- EncodedJSValue getWasmTableElement(Instance*, unsigned, int32_t);</span>
<span class="udiff-line-removed">- bool setWasmTableElement(Instance*, unsigned, int32_t, EncodedJSValue encValue);</span>
<span class="udiff-line-removed">- EncodedJSValue doWasmRefFunc(Instance*, uint32_t);</span>
<span class="udiff-line-removed">- int32_t doWasmTableGrow(Instance*, unsigned, EncodedJSValue fill, int32_t delta);</span>
<span class="udiff-line-removed">- bool doWasmTableFill(Instance*, unsigned, int32_t offset, EncodedJSValue fill, int32_t count);</span>
<span class="udiff-line-removed">- </span>
  class Instance : public ThreadSafeRefCounted&lt;Instance&gt;, public CanMakeWeakPtr&lt;Instance&gt; {
<span class="udiff-line-added">+     friend LLIntOffsetsExtractor;</span>
<span class="udiff-line-added">+ </span>
  public:
      using StoreTopCallFrameCallback = WTF::Function&lt;void(void*)&gt;;
      using FunctionWrapperMap = HashMap&lt;uint32_t, WriteBarrier&lt;Unknown&gt;, IntHash&lt;uint32_t&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;uint32_t&gt;&gt;;
  
      static Ref&lt;Instance&gt; create(Context*, Ref&lt;Module&gt;&amp;&amp;, EntryFrame** pointerToTopEntryFrame, void** pointerToActualStackLimit, StoreTopCallFrameCallback&amp;&amp;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -90,21 +92,59 @@</span>
              m_cachedMemory = CagedPtr&lt;Gigacage::Primitive, void, tagCagedPtr&gt;(memory()-&gt;memory(), memory()-&gt;size());
              m_cachedMemorySize = memory()-&gt;size();
          }
      }
  
<span class="udiff-line-modified-removed">-     int32_t loadI32Global(unsigned i) const { return m_globals.get()[i].primitive; }</span>
<span class="udiff-line-modified-removed">-     int64_t loadI64Global(unsigned i) const { return m_globals.get()[i].primitive; }</span>
<span class="udiff-line-modified-added">+     int32_t loadI32Global(unsigned i) const</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-added">+         Global::Value* slot = m_globals.get() + i;</span>
<span class="udiff-line-added">+         if (m_globalsToBinding.get(i)) {</span>
<span class="udiff-line-added">+             slot = slot-&gt;m_pointer;</span>
<span class="udiff-line-added">+             if (!slot)</span>
<span class="udiff-line-added">+                 return 0;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return slot-&gt;m_primitive;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     int64_t loadI64Global(unsigned i) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         Global::Value* slot = m_globals.get() + i;</span>
<span class="udiff-line-added">+         if (m_globalsToBinding.get(i)) {</span>
<span class="udiff-line-added">+             slot = slot-&gt;m_pointer;</span>
<span class="udiff-line-added">+             if (!slot)</span>
<span class="udiff-line-added">+                 return 0;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return slot-&gt;m_primitive;</span>
<span class="udiff-line-added">+     }</span>
      float loadF32Global(unsigned i) const { return bitwise_cast&lt;float&gt;(loadI32Global(i)); }
      double loadF64Global(unsigned i) const { return bitwise_cast&lt;double&gt;(loadI64Global(i)); }
<span class="udiff-line-modified-removed">-     void setGlobal(unsigned i, int64_t bits) { m_globals.get()[i].primitive = bits; }</span>
<span class="udiff-line-modified-added">+     void setGlobal(unsigned i, int64_t bits)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         Global::Value* slot = m_globals.get() + i;</span>
<span class="udiff-line-added">+         if (m_globalsToBinding.get(i)) {</span>
<span class="udiff-line-added">+             slot = slot-&gt;m_pointer;</span>
<span class="udiff-line-added">+             if (!slot)</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         slot-&gt;m_primitive = bits;</span>
<span class="udiff-line-added">+     }</span>
      void setGlobal(unsigned, JSValue);
<span class="udiff-line-added">+     void linkGlobal(unsigned, Ref&lt;Global&gt;&amp;&amp;);</span>
      const BitVector&amp; globalsToMark() { return m_globalsToMark; }
<span class="udiff-line-added">+     const BitVector&amp; globalsToBinding() { return m_globalsToBinding; }</span>
      JSValue getFunctionWrapper(unsigned) const;
      typename FunctionWrapperMap::ValuesConstIteratorRange functionWrappers() const { return m_functionWrappers.values(); }
      void setFunctionWrapper(unsigned, JSValue);
  
<span class="udiff-line-added">+     Wasm::Global* getGlobalBinding(unsigned i)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         ASSERT(m_globalsToBinding.get(i));</span>
<span class="udiff-line-added">+         Wasm::Global::Value* pointer = m_globals.get()[i].m_pointer;</span>
<span class="udiff-line-added">+         if (!pointer)</span>
<span class="udiff-line-added">+             return nullptr;</span>
<span class="udiff-line-added">+         return &amp;Wasm::Global::fromBinding(*pointer);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      static ptrdiff_t offsetOfMemory() { return OBJECT_OFFSETOF(Instance, m_memory); }
      static ptrdiff_t offsetOfGlobals() { return OBJECT_OFFSETOF(Instance, m_globals); }
      static ptrdiff_t offsetOfCachedMemory() { return OBJECT_OFFSETOF(Instance, m_cachedMemory); }
      static ptrdiff_t offsetOfCachedMemorySize() { return OBJECT_OFFSETOF(Instance, m_cachedMemorySize); }
      static ptrdiff_t offsetOfPointerToTopEntryFrame() { return OBJECT_OFFSETOF(Instance, m_pointerToTopEntryFrame); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -164,22 +204,20 @@</span>
      size_t m_cachedMemorySize { 0 };
      Ref&lt;Module&gt; m_module;
      RefPtr&lt;CodeBlock&gt; m_codeBlock;
      RefPtr&lt;Memory&gt; m_memory;
  
<span class="udiff-line-modified-removed">-     union GlobalValue {</span>
<span class="udiff-line-removed">-         WriteBarrier&lt;Unknown&gt; anyref;</span>
<span class="udiff-line-removed">-         uint64_t primitive;</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">-     MallocPtr&lt;GlobalValue&gt; m_globals;</span>
<span class="udiff-line-modified-added">+     MallocPtr&lt;Global::Value, VMMalloc&gt; m_globals;</span>
      FunctionWrapperMap m_functionWrappers;
      BitVector m_globalsToMark;
<span class="udiff-line-added">+     BitVector m_globalsToBinding;</span>
      EntryFrame** m_pointerToTopEntryFrame { nullptr };
      void** m_pointerToActualStackLimit { nullptr };
      void* m_cachedStackLimit { bitwise_cast&lt;void*&gt;(std::numeric_limits&lt;uintptr_t&gt;::max()) };
      StoreTopCallFrameCallback m_storeTopCallFrame;
      unsigned m_numImportFunctions { 0 };
<span class="udiff-line-added">+     HashMap&lt;uint32_t, Ref&lt;Global&gt;, IntHash&lt;uint32_t&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;uint32_t&gt;&gt; m_linkedGlobals;</span>
  };
  
  } } // namespace JSC::Wasm
  
  #endif // ENABLE(WEBASSEMBLY)
</pre>
<center><a href="WasmInstance.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmMemory.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
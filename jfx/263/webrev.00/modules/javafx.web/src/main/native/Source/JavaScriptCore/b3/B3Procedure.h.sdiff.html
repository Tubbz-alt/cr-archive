<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3Procedure.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="B3Procedure.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3ReduceDoubleToFloat.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3Procedure.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;B3OpaqueByproducts.h&quot;
 31 #include &quot;B3Origin.h&quot;
 32 #include &quot;B3PCToOriginMap.h&quot;
 33 #include &quot;B3SparseCollection.h&quot;
 34 #include &quot;B3Type.h&quot;
 35 #include &quot;B3ValueKey.h&quot;
<span class="line-removed"> 36 #include &quot;CCallHelpers.h&quot;</span>
 37 #include &quot;PureNaN.h&quot;
 38 #include &quot;RegisterAtOffsetList.h&quot;
 39 #include &lt;wtf/Bag.h&gt;
 40 #include &lt;wtf/FastMalloc.h&gt;
 41 #include &lt;wtf/HashSet.h&gt;
 42 #include &lt;wtf/IndexedContainerIterator.h&gt;
 43 #include &lt;wtf/Noncopyable.h&gt;
 44 #include &lt;wtf/PrintStream.h&gt;
 45 #include &lt;wtf/SharedTask.h&gt;
 46 #include &lt;wtf/TriState.h&gt;
 47 #include &lt;wtf/Vector.h&gt;
 48 
<span class="line-modified"> 49 namespace JSC { namespace B3 {</span>




 50 
 51 class BackwardsCFG;
 52 class BackwardsDominators;
 53 class BasicBlock;
 54 class BlockInsertionSet;
 55 class CFG;
 56 class Dominators;
 57 class NaturalLoops;
 58 class StackSlot;
 59 class Value;
 60 class Variable;
 61 
 62 namespace Air { class Code; }
 63 
 64 typedef void WasmBoundsCheckGeneratorFunction(CCallHelpers&amp;, GPRReg);
 65 typedef SharedTask&lt;WasmBoundsCheckGeneratorFunction&gt; WasmBoundsCheckGenerator;
 66 
 67 // This represents B3&#39;s view of a piece of code. Note that this object must exist in a 1:1
 68 // relationship with Air::Code. B3::Procedure and Air::Code are just different facades of the B3
 69 // compiler&#39;s knowledge about a piece of code. Some kinds of state aren&#39;t perfect fits for either
</pre>
<hr />
<pre>
101     // need to mention every block in the procedure. Blocks not mentioned will be placed after
102     // these blocks in the same order as they were in originally.
103     template&lt;typename BlockIterable&gt;
104     void setBlockOrder(const BlockIterable&amp; iterable)
105     {
106         Vector&lt;BasicBlock*&gt; blocks;
107         for (BasicBlock* block : iterable)
108             blocks.append(block);
109         setBlockOrderImpl(blocks);
110     }
111 
112     JS_EXPORT_PRIVATE StackSlot* addStackSlot(unsigned byteSize);
113     JS_EXPORT_PRIVATE Variable* addVariable(Type);
114 
115     JS_EXPORT_PRIVATE Type addTuple(Vector&lt;Type&gt;&amp;&amp; types);
116     const Vector&lt;Vector&lt;Type&gt;&gt;&amp; tuples() const { return m_tuples; };
117     bool isValidTuple(Type tuple) const;
118     Type extractFromTuple(Type tuple, unsigned index) const;
119     const Vector&lt;Type&gt;&amp; tupleForType(Type tuple) const;
120 
<span class="line-modified">121     unsigned returnCount(Type type) const { return type.isTuple() ? tupleForType(type).size() : type.isNumeric(); }</span>

122 
123     template&lt;typename ValueType, typename... Arguments&gt;
124     ValueType* add(Arguments...);
125 
126     Value* clone(Value*);
127 
128     Value* addIntConstant(Origin, Type, int64_t value);
129     Value* addIntConstant(Value*, int64_t value);
130 
131     // bits is a bitwise_cast of the constant you want.
132     Value* addConstant(Origin, Type, uint64_t bits);
133 
134     // You&#39;re guaranteed that bottom is zero.
135     Value* addBottom(Origin, Type);
136     Value* addBottom(Value*);
137 
138     // Returns null for MixedTriState.
139     Value* addBoolConstant(Origin, TriState);
140 
141     void resetValueOwners();
</pre>
<hr />
<pre>
179 
180     // A valid procedure cannot contain any orphan values. An orphan is a value that is not in
181     // any basic block. It is possible to create an orphan value during code generation or during
182     // transformation. If you know that you may have created some, you can call this method to
183     // delete them, making the procedure valid again.
184     void deleteOrphans();
185 
186     CFG&amp; cfg() const { return *m_cfg; }
187 
188     Dominators&amp; dominators();
189     NaturalLoops&amp; naturalLoops();
190     BackwardsCFG&amp; backwardsCFG();
191     BackwardsDominators&amp; backwardsDominators();
192 
193     void addFastConstant(const ValueKey&amp;);
194     bool isFastConstant(const ValueKey&amp;);
195 
196     unsigned numEntrypoints() const { return m_numEntrypoints; }
197     JS_EXPORT_PRIVATE void setNumEntrypoints(unsigned);
198 
<span class="line-removed">199     // Only call this after code generation is complete. Note that the label for the 0th entrypoint</span>
<span class="line-removed">200     // should point to exactly where the code generation cursor was before you started generating</span>
<span class="line-removed">201     // code.</span>
<span class="line-removed">202     JS_EXPORT_PRIVATE CCallHelpers::Label entrypointLabel(unsigned entrypointIndex) const;</span>
<span class="line-removed">203 </span>
204     // The name has to be a string literal, since we don&#39;t do any memory management for the string.
205     void setLastPhaseName(const char* name)
206     {
207         m_lastPhaseName = name;
208     }
209 
210     const char* lastPhaseName() const { return m_lastPhaseName; }
211 
212     // Allocates a slab of memory that will be kept alive by anyone who keeps the resulting code
213     // alive. Great for compiler-generated data sections, like switch jump tables and constant pools.
214     // This returns memory that has been zero-initialized.
215     JS_EXPORT_PRIVATE void* addDataSection(size_t);
216 
217     // Some operations are specified in B3 IR to behave one way but on this given CPU they behave a
218     // different way. When true, those B3 IR ops switch to behaving the CPU way, and the optimizer may
219     // start taking advantage of it.
220     //
221     // One way to think of it is like this. Imagine that you find that the cleanest way of lowering
222     // something in lowerMacros is to unconditionally replace one opcode with another. This is a shortcut
223     // where you instead keep the same opcode, but rely on the opcode&#39;s meaning changes once lowerMacros
</pre>
</td>
<td>
<hr />
<pre>
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;B3OpaqueByproducts.h&quot;
 31 #include &quot;B3Origin.h&quot;
 32 #include &quot;B3PCToOriginMap.h&quot;
 33 #include &quot;B3SparseCollection.h&quot;
 34 #include &quot;B3Type.h&quot;
 35 #include &quot;B3ValueKey.h&quot;

 36 #include &quot;PureNaN.h&quot;
 37 #include &quot;RegisterAtOffsetList.h&quot;
 38 #include &lt;wtf/Bag.h&gt;
 39 #include &lt;wtf/FastMalloc.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 #include &lt;wtf/IndexedContainerIterator.h&gt;
 42 #include &lt;wtf/Noncopyable.h&gt;
 43 #include &lt;wtf/PrintStream.h&gt;
 44 #include &lt;wtf/SharedTask.h&gt;
 45 #include &lt;wtf/TriState.h&gt;
 46 #include &lt;wtf/Vector.h&gt;
 47 
<span class="line-modified"> 48 namespace JSC {</span>
<span class="line-added"> 49 </span>
<span class="line-added"> 50 class CCallHelpers;</span>
<span class="line-added"> 51 </span>
<span class="line-added"> 52 namespace B3 {</span>
 53 
 54 class BackwardsCFG;
 55 class BackwardsDominators;
 56 class BasicBlock;
 57 class BlockInsertionSet;
 58 class CFG;
 59 class Dominators;
 60 class NaturalLoops;
 61 class StackSlot;
 62 class Value;
 63 class Variable;
 64 
 65 namespace Air { class Code; }
 66 
 67 typedef void WasmBoundsCheckGeneratorFunction(CCallHelpers&amp;, GPRReg);
 68 typedef SharedTask&lt;WasmBoundsCheckGeneratorFunction&gt; WasmBoundsCheckGenerator;
 69 
 70 // This represents B3&#39;s view of a piece of code. Note that this object must exist in a 1:1
 71 // relationship with Air::Code. B3::Procedure and Air::Code are just different facades of the B3
 72 // compiler&#39;s knowledge about a piece of code. Some kinds of state aren&#39;t perfect fits for either
</pre>
<hr />
<pre>
104     // need to mention every block in the procedure. Blocks not mentioned will be placed after
105     // these blocks in the same order as they were in originally.
106     template&lt;typename BlockIterable&gt;
107     void setBlockOrder(const BlockIterable&amp; iterable)
108     {
109         Vector&lt;BasicBlock*&gt; blocks;
110         for (BasicBlock* block : iterable)
111             blocks.append(block);
112         setBlockOrderImpl(blocks);
113     }
114 
115     JS_EXPORT_PRIVATE StackSlot* addStackSlot(unsigned byteSize);
116     JS_EXPORT_PRIVATE Variable* addVariable(Type);
117 
118     JS_EXPORT_PRIVATE Type addTuple(Vector&lt;Type&gt;&amp;&amp; types);
119     const Vector&lt;Vector&lt;Type&gt;&gt;&amp; tuples() const { return m_tuples; };
120     bool isValidTuple(Type tuple) const;
121     Type extractFromTuple(Type tuple, unsigned index) const;
122     const Vector&lt;Type&gt;&amp; tupleForType(Type tuple) const;
123 
<span class="line-modified">124     unsigned resultCount(Type type) const { return type.isTuple() ? tupleForType(type).size() : type.isNumeric(); }</span>
<span class="line-added">125     Type typeAtOffset(Type type, unsigned index) const { ASSERT(index &lt; resultCount(type)); return type.isTuple() ? extractFromTuple(type, index) : type; }</span>
126 
127     template&lt;typename ValueType, typename... Arguments&gt;
128     ValueType* add(Arguments...);
129 
130     Value* clone(Value*);
131 
132     Value* addIntConstant(Origin, Type, int64_t value);
133     Value* addIntConstant(Value*, int64_t value);
134 
135     // bits is a bitwise_cast of the constant you want.
136     Value* addConstant(Origin, Type, uint64_t bits);
137 
138     // You&#39;re guaranteed that bottom is zero.
139     Value* addBottom(Origin, Type);
140     Value* addBottom(Value*);
141 
142     // Returns null for MixedTriState.
143     Value* addBoolConstant(Origin, TriState);
144 
145     void resetValueOwners();
</pre>
<hr />
<pre>
183 
184     // A valid procedure cannot contain any orphan values. An orphan is a value that is not in
185     // any basic block. It is possible to create an orphan value during code generation or during
186     // transformation. If you know that you may have created some, you can call this method to
187     // delete them, making the procedure valid again.
188     void deleteOrphans();
189 
190     CFG&amp; cfg() const { return *m_cfg; }
191 
192     Dominators&amp; dominators();
193     NaturalLoops&amp; naturalLoops();
194     BackwardsCFG&amp; backwardsCFG();
195     BackwardsDominators&amp; backwardsDominators();
196 
197     void addFastConstant(const ValueKey&amp;);
198     bool isFastConstant(const ValueKey&amp;);
199 
200     unsigned numEntrypoints() const { return m_numEntrypoints; }
201     JS_EXPORT_PRIVATE void setNumEntrypoints(unsigned);
202 





203     // The name has to be a string literal, since we don&#39;t do any memory management for the string.
204     void setLastPhaseName(const char* name)
205     {
206         m_lastPhaseName = name;
207     }
208 
209     const char* lastPhaseName() const { return m_lastPhaseName; }
210 
211     // Allocates a slab of memory that will be kept alive by anyone who keeps the resulting code
212     // alive. Great for compiler-generated data sections, like switch jump tables and constant pools.
213     // This returns memory that has been zero-initialized.
214     JS_EXPORT_PRIVATE void* addDataSection(size_t);
215 
216     // Some operations are specified in B3 IR to behave one way but on this given CPU they behave a
217     // different way. When true, those B3 IR ops switch to behaving the CPU way, and the optimizer may
218     // start taking advantage of it.
219     //
220     // One way to think of it is like this. Imagine that you find that the cleanest way of lowering
221     // something in lowerMacros is to unconditionally replace one opcode with another. This is a shortcut
222     // where you instead keep the same opcode, but rely on the opcode&#39;s meaning changes once lowerMacros
</pre>
</td>
</tr>
</table>
<center><a href="B3Procedure.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3ReduceDoubleToFloat.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
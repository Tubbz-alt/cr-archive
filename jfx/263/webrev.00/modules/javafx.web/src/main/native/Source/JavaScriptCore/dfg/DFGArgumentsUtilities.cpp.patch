diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsUtilities.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsUtilities.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsUtilities.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsUtilities.cpp
@@ -30,52 +30,59 @@
 
 #include "JSCInlines.h"
 
 namespace JSC { namespace DFG {
 
-bool argumentsInvolveStackSlot(InlineCallFrame* inlineCallFrame, VirtualRegister reg)
+bool argumentsInvolveStackSlot(InlineCallFrame* inlineCallFrame, Operand operand)
 {
+    if (operand.isTmp())
+        return false;
+
+    VirtualRegister reg = operand.virtualRegister();
     if (!inlineCallFrame)
         return (reg.isArgument() && reg.toArgument()) || reg.isHeader();
 
     if (inlineCallFrame->isClosureCall
         && reg == VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::callee))
         return true;
 
     if (inlineCallFrame->isVarargs()
-        && reg == VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCount))
+        && reg == VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCountIncludingThis))
         return true;
 
     // We do not include fixups here since it is not related to |arguments|, rest parameters, and varargs.
-    unsigned numArguments = inlineCallFrame->argumentCountIncludingThis - 1;
+    unsigned numArguments = static_cast<unsigned>(inlineCallFrame->argumentCountIncludingThis - 1);
     VirtualRegister argumentStart =
         VirtualRegister(inlineCallFrame->stackOffset) + CallFrame::argumentOffset(0);
     return reg >= argumentStart && reg < argumentStart + numArguments;
 }
 
-bool argumentsInvolveStackSlot(Node* candidate, VirtualRegister reg)
+bool argumentsInvolveStackSlot(Node* candidate, Operand operand)
 {
-    return argumentsInvolveStackSlot(candidate->origin.semantic.inlineCallFrame(), reg);
+    return argumentsInvolveStackSlot(candidate->origin.semantic.inlineCallFrame(), operand);
 }
 
 Node* emitCodeToGetArgumentsArrayLength(
-    InsertionSet& insertionSet, Node* arguments, unsigned nodeIndex, NodeOrigin origin)
+    InsertionSet& insertionSet, Node* arguments, unsigned nodeIndex, NodeOrigin origin, bool addThis)
 {
     Graph& graph = insertionSet.graph();
 
     DFG_ASSERT(
         graph, arguments,
         arguments->op() == CreateDirectArguments || arguments->op() == CreateScopedArguments
         || arguments->op() == CreateClonedArguments || arguments->op() == CreateRest
         || arguments->op() == NewArrayBuffer
         || arguments->op() == PhantomDirectArguments || arguments->op() == PhantomClonedArguments
         || arguments->op() == PhantomCreateRest || arguments->op() == PhantomNewArrayBuffer
-        || arguments->op() == PhantomNewArrayWithSpread,
+        || arguments->op() == PhantomNewArrayWithSpread || arguments->op() == PhantomSpread,
         arguments->op());
 
+    if (arguments->op() == PhantomSpread)
+        return emitCodeToGetArgumentsArrayLength(insertionSet, arguments->child1().node(), nodeIndex, origin, addThis);
+
     if (arguments->op() == PhantomNewArrayWithSpread) {
-        unsigned numberOfNonSpreadArguments = 0;
+        unsigned numberOfNonSpreadArguments = addThis;
         BitVector* bitVector = arguments->bitVector();
         Node* currentSum = nullptr;
         for (unsigned i = 0; i < arguments->numChildren(); i++) {
             if (bitVector->get(i)) {
                 Node* child = graph.varArgChild(arguments, i).node();
@@ -101,21 +108,21 @@
         return insertionSet.insertConstant(nodeIndex, origin, jsNumber(numberOfNonSpreadArguments));
     }
 
     if (arguments->op() == NewArrayBuffer || arguments->op() == PhantomNewArrayBuffer) {
         return insertionSet.insertConstant(
-            nodeIndex, origin, jsNumber(arguments->castOperand<JSImmutableButterfly*>()->length()));
+            nodeIndex, origin, jsNumber(arguments->castOperand<JSImmutableButterfly*>()->length() + addThis));
     }
 
     InlineCallFrame* inlineCallFrame = arguments->origin.semantic.inlineCallFrame();
 
     unsigned numberOfArgumentsToSkip = 0;
     if (arguments->op() == CreateRest || arguments->op() == PhantomCreateRest)
         numberOfArgumentsToSkip = arguments->numberOfArgumentsToSkip();
 
     if (inlineCallFrame && !inlineCallFrame->isVarargs()) {
-        unsigned argumentsSize = inlineCallFrame->argumentCountIncludingThis - 1;
+        unsigned argumentsSize = inlineCallFrame->argumentCountIncludingThis - !addThis;
         if (argumentsSize >= numberOfArgumentsToSkip)
             argumentsSize -= numberOfArgumentsToSkip;
         else
             argumentsSize = 0;
         return insertionSet.insertConstant(
@@ -127,18 +134,18 @@
 
     Node* result = insertionSet.insertNode(
         nodeIndex, SpecInt32Only, ArithSub, origin, OpInfo(Arith::Unchecked),
         Edge(argumentCount, Int32Use),
         insertionSet.insertConstantForUse(
-            nodeIndex, origin, jsNumber(1 + numberOfArgumentsToSkip), Int32Use));
+            nodeIndex, origin, jsNumber(numberOfArgumentsToSkip + !addThis), Int32Use));
 
     if (numberOfArgumentsToSkip) {
         // The above subtraction may produce a negative number if this number is non-zero. We correct that here.
         result = insertionSet.insertNode(
             nodeIndex, SpecInt32Only, ArithMax, origin,
             Edge(result, Int32Use),
-            insertionSet.insertConstantForUse(nodeIndex, origin, jsNumber(0), Int32Use));
+            insertionSet.insertConstantForUse(nodeIndex, origin, jsNumber(static_cast<unsigned>(addThis)), Int32Use));
         result->setResult(NodeResultInt32);
     }
 
     return result;
 }

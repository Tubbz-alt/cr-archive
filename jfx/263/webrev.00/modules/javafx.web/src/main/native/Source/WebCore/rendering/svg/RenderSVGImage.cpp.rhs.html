<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006 Alexander Kellett &lt;lypanov@kde.org&gt;
  3  * Copyright (C) 2006 Apple Inc.
  4  * Copyright (C) 2007 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  5  * Copyright (C) 2007, 2008, 2009 Rob Buis &lt;buis@kde.org&gt;
  6  * Copyright (C) 2009 Google, Inc.
  7  * Copyright (C) 2009 Dirk Schulze &lt;krit@webkit.org&gt;
  8  * Copyright (C) 2010 Patrick Gansterer &lt;paroga@paroga.com&gt;
  9  *
 10  * This library is free software; you can redistribute it and/or
 11  * modify it under the terms of the GNU Library General Public
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderSVGImage.h&quot;
 28 
 29 #include &quot;FloatQuad.h&quot;
 30 #include &quot;GraphicsContext.h&quot;
 31 #include &quot;HitTestResult.h&quot;
 32 #include &quot;LayoutRepainter.h&quot;
 33 #include &quot;PointerEventsHitRules.h&quot;
 34 #include &quot;RenderImageResource.h&quot;
 35 #include &quot;RenderLayer.h&quot;
 36 #include &quot;RenderSVGResource.h&quot;
 37 #include &quot;RenderSVGResourceFilter.h&quot;
 38 #include &quot;SVGImageElement.h&quot;
 39 #include &quot;SVGRenderingContext.h&quot;
 40 #include &quot;SVGResources.h&quot;
 41 #include &quot;SVGResourcesCache.h&quot;
 42 #include &lt;wtf/IsoMallocInlines.h&gt;
 43 #include &lt;wtf/StackStats.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderSVGImage);
 48 
 49 RenderSVGImage::RenderSVGImage(SVGImageElement&amp; element, RenderStyle&amp;&amp; style)
 50     : RenderSVGModelObject(element, WTFMove(style))
 51     , m_needsBoundariesUpdate(true)
 52     , m_needsTransformUpdate(true)
 53     , m_imageResource(makeUnique&lt;RenderImageResource&gt;())
 54 {
 55     imageResource().initialize(*this);
 56 }
 57 
 58 RenderSVGImage::~RenderSVGImage() = default;
 59 
 60 void RenderSVGImage::willBeDestroyed()
 61 {
 62     imageResource().shutdown();
 63     RenderSVGModelObject::willBeDestroyed();
 64 }
 65 
 66 SVGImageElement&amp; RenderSVGImage::imageElement() const
 67 {
 68     return downcast&lt;SVGImageElement&gt;(RenderSVGModelObject::element());
 69 }
 70 
<a name="1" id="anc1"></a><span class="line-modified"> 71 FloatRect RenderSVGImage::calculateObjectBoundingBox() const</span>
 72 {
<a name="2" id="anc2"></a><span class="line-modified"> 73     LayoutSize intrinsicSize;</span>
<span class="line-modified"> 74     if (CachedImage* cachedImage = imageResource().cachedImage())</span>
<span class="line-added"> 75         intrinsicSize = cachedImage-&gt;imageSizeForRenderer(nullptr, style().effectiveZoom());</span>
 76 
 77     SVGLengthContext lengthContext(&amp;imageElement());
<a name="3" id="anc3"></a>
 78 
<a name="4" id="anc4"></a><span class="line-added"> 79     Length width = style().width();</span>
<span class="line-added"> 80     Length height = style().height();</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82     float concreteWidth;</span>
<span class="line-added"> 83     if (!width.isAuto())</span>
<span class="line-added"> 84         concreteWidth = lengthContext.valueForLength(width, SVGLengthMode::Width);</span>
<span class="line-added"> 85     else if (!height.isAuto() &amp;&amp; !intrinsicSize.isEmpty())</span>
<span class="line-added"> 86         concreteWidth = lengthContext.valueForLength(height, SVGLengthMode::Height) * intrinsicSize.width() / intrinsicSize.height();</span>
<span class="line-added"> 87     else</span>
<span class="line-added"> 88         concreteWidth = intrinsicSize.width();</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90     float concreteHeight;</span>
<span class="line-added"> 91     if (!height.isAuto())</span>
<span class="line-added"> 92         concreteHeight = lengthContext.valueForLength(height, SVGLengthMode::Height);</span>
<span class="line-added"> 93     else if (!width.isAuto() &amp;&amp; !intrinsicSize.isEmpty())</span>
<span class="line-added"> 94         concreteHeight = lengthContext.valueForLength(width, SVGLengthMode::Width) * intrinsicSize.height() / intrinsicSize.width();</span>
<span class="line-added"> 95     else</span>
<span class="line-added"> 96         concreteHeight = intrinsicSize.height();</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98     return { imageElement().x().value(lengthContext), imageElement().y().value(lengthContext), concreteWidth, concreteHeight };</span>
<span class="line-added"> 99 }</span>
<span class="line-added">100 </span>
<span class="line-added">101 bool RenderSVGImage::updateImageViewport()</span>
<span class="line-added">102 {</span>
<span class="line-added">103     FloatRect oldBoundaries = m_objectBoundingBox;</span>
<span class="line-added">104     m_objectBoundingBox = calculateObjectBoundingBox();</span>
<span class="line-added">105 </span>
<span class="line-added">106     bool updatedViewport = false;</span>
107     URL imageSourceURL = document().completeURL(imageElement().imageSourceURL());
108 
109     // Images with preserveAspectRatio=none should force non-uniform scaling. This can be achieved
110     // by setting the image&#39;s container size to its intrinsic size.
111     // See: http://www.w3.org/TR/SVG/single-page.html, 7.8 The ‘preserveAspectRatio’ attribute.
112     if (imageElement().preserveAspectRatio().align() == SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_NONE) {
113         if (CachedImage* cachedImage = imageResource().cachedImage()) {
114             LayoutSize intrinsicSize = cachedImage-&gt;imageSizeForRenderer(nullptr, style().effectiveZoom());
115             if (intrinsicSize != imageResource().imageSize(style().effectiveZoom())) {
116                 imageResource().setContainerContext(roundedIntSize(intrinsicSize), imageSourceURL);
117                 updatedViewport = true;
118             }
119         }
120     }
121 
122     if (oldBoundaries != m_objectBoundingBox) {
123         if (!updatedViewport)
124             imageResource().setContainerContext(enclosingIntRect(m_objectBoundingBox).size(), imageSourceURL);
125         updatedViewport = true;
126         m_needsBoundariesUpdate = true;
127     }
128 
129     return updatedViewport;
130 }
131 
132 void RenderSVGImage::layout()
133 {
134     StackStats::LayoutCheckPoint layoutCheckPoint;
135     ASSERT(needsLayout());
136 
137     LayoutRepainter repainter(*this, SVGRenderSupport::checkForSVGRepaintDuringLayout(*this) &amp;&amp; selfNeedsLayout());
138     updateImageViewport();
139 
140     bool transformOrBoundariesUpdate = m_needsTransformUpdate || m_needsBoundariesUpdate;
141     if (m_needsTransformUpdate) {
142         m_localTransform = imageElement().animatedLocalTransform();
143         m_needsTransformUpdate = false;
144     }
145 
146     if (m_needsBoundariesUpdate) {
147         m_repaintBoundingBoxExcludingShadow = m_objectBoundingBox;
148         SVGRenderSupport::intersectRepaintRectWithResources(*this, m_repaintBoundingBoxExcludingShadow);
149 
150         m_repaintBoundingBox = m_repaintBoundingBoxExcludingShadow;
151 
152         m_needsBoundariesUpdate = false;
153     }
154 
155     // Invalidate all resources of this client if our layout changed.
156     if (everHadLayout() &amp;&amp; selfNeedsLayout())
157         SVGResourcesCache::clientLayoutChanged(*this);
158 
159     // If our bounds changed, notify the parents.
160     if (transformOrBoundariesUpdate)
161         RenderSVGModelObject::setNeedsBoundariesUpdate();
162 
163     repainter.repaintAfterLayout();
164     clearNeedsLayout();
165 }
166 
167 void RenderSVGImage::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp;)
168 {
169     if (paintInfo.context().paintingDisabled() || paintInfo.phase != PaintPhase::Foreground
170         || style().visibility() == Visibility::Hidden || !imageResource().cachedImage())
171         return;
172 
173     FloatRect boundingBox = repaintRectInLocalCoordinates();
174     if (!SVGRenderSupport::paintInfoIntersectsRepaintRect(boundingBox, m_localTransform, paintInfo))
175         return;
176 
177     PaintInfo childPaintInfo(paintInfo);
178     GraphicsContextStateSaver stateSaver(childPaintInfo.context());
179     childPaintInfo.applyTransform(m_localTransform);
180 
181     if (childPaintInfo.phase == PaintPhase::Foreground) {
182         SVGRenderingContext renderingContext(*this, childPaintInfo);
183 
184         if (renderingContext.isRenderingPrepared()) {
185             if (style().svgStyle().bufferedRendering() == BufferedRendering::Static &amp;&amp; renderingContext.bufferForeground(m_bufferedForeground))
186                 return;
187 
188             paintForeground(childPaintInfo);
189         }
190     }
191 
192     if (style().outlineWidth())
193         paintOutline(childPaintInfo, IntRect(boundingBox));
194 }
195 
196 void RenderSVGImage::paintForeground(PaintInfo&amp; paintInfo)
197 {
198     RefPtr&lt;Image&gt; image = imageResource().image();
199     if (!image)
200         return;
201 
202     FloatRect destRect = m_objectBoundingBox;
203     FloatRect srcRect(0, 0, image-&gt;width(), image-&gt;height());
204 
205     imageElement().preserveAspectRatio().transformRect(destRect, srcRect);
206 
207     paintInfo.context().drawImage(*image, destRect, srcRect);
208 }
209 
210 void RenderSVGImage::invalidateBufferedForeground()
211 {
212     m_bufferedForeground.reset();
213 }
214 
215 bool RenderSVGImage::nodeAtFloatPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const FloatPoint&amp; pointInParent, HitTestAction hitTestAction)
216 {
217     // We only draw in the forground phase, so we only hit-test then.
218     if (hitTestAction != HitTestForeground)
219         return false;
220 
221     PointerEventsHitRules hitRules(PointerEventsHitRules::SVG_IMAGE_HITTESTING, request, style().pointerEvents());
222     bool isVisible = (style().visibility() == Visibility::Visible);
223     if (isVisible || !hitRules.requireVisible) {
224         FloatPoint localPoint = localToParentTransform().inverse().valueOr(AffineTransform()).mapPoint(pointInParent);
225 
226         if (!SVGRenderSupport::pointInClippingArea(*this, localPoint))
227             return false;
228 
229         if (hitRules.canHitFill) {
230             if (m_objectBoundingBox.contains(localPoint)) {
231                 updateHitTestResult(result, LayoutPoint(localPoint));
232                 if (result.addNodeToListBasedTestResult(&amp;imageElement(), request, localPoint) == HitTestProgress::Stop)
233                     return true;
234             }
235         }
236     }
237 
238     return false;
239 }
240 
241 void RenderSVGImage::imageChanged(WrappedImagePtr, const IntRect*)
242 {
243     // The image resource defaults to nullImage until the resource arrives.
244     // This empty image may be cached by SVG resources which must be invalidated.
245     if (auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this))
246         resources-&gt;removeClientFromCache(*this);
247 
248     // Eventually notify parent resources, that we&#39;ve changed.
249     RenderSVGResource::markForLayoutAndParentResourceInvalidation(*this, false);
250 
251     // Update the SVGImageCache sizeAndScales entry in case image loading finished after layout.
252     // (https://bugs.webkit.org/show_bug.cgi?id=99489)
253     m_objectBoundingBox = FloatRect();
<a name="5" id="anc5"></a><span class="line-modified">254     if (updateImageViewport())</span>
<span class="line-added">255         setNeedsLayout();</span>
256 
257     invalidateBufferedForeground();
258 
259     repaint();
260 }
261 
262 void RenderSVGImage::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp;, const RenderLayerModelObject*)
263 {
264     // this is called from paint() after the localTransform has already been applied
265     LayoutRect contentRect = LayoutRect(repaintRectInLocalCoordinates());
266     if (!contentRect.isEmpty())
267         rects.append(contentRect);
268 }
269 
270 } // namespace WebCore
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
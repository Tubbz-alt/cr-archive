<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/encryptedmedia/legacy/WebKitMediaKeySession.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebKitMediaKeySession.h&quot;
 28 
 29 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 30 
 31 #include &quot;Document.h&quot;
 32 #include &quot;EventLoop.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;Page.h&quot;
 35 #include &quot;SecurityOriginData.h&quot;
 36 #include &quot;Settings.h&quot;
 37 #include &quot;WebKitMediaKeyError.h&quot;
 38 #include &quot;WebKitMediaKeyMessageEvent.h&quot;
 39 #include &quot;WebKitMediaKeys.h&quot;
 40 #include &lt;wtf/FileSystem.h&gt;
 41 #include &lt;wtf/IsoMallocInlines.h&gt;
 42 
 43 namespace WebCore {
 44 
 45 WTF_MAKE_ISO_ALLOCATED_IMPL(WebKitMediaKeySession);
 46 
 47 Ref&lt;WebKitMediaKeySession&gt; WebKitMediaKeySession::create(ScriptExecutionContext&amp; context, WebKitMediaKeys&amp; keys, const String&amp; keySystem)
 48 {
 49     auto session = adoptRef(*new WebKitMediaKeySession(context, keys, keySystem));
 50     session-&gt;suspendIfNeeded();
 51     return session;
 52 }
 53 
 54 WebKitMediaKeySession::WebKitMediaKeySession(ScriptExecutionContext&amp; context, WebKitMediaKeys&amp; keys, const String&amp; keySystem)
 55     : ActiveDOMObject(&amp;context)
 56     , m_keys(&amp;keys)
 57     , m_keySystem(keySystem)
 58     , m_session(keys.cdm().createSession(*this))
 59     , m_keyRequestTimer(*this, &amp;WebKitMediaKeySession::keyRequestTimerFired)
 60     , m_addKeyTimer(*this, &amp;WebKitMediaKeySession::addKeyTimerFired)
 61 {
 62     if (m_session)
 63         m_sessionId = m_session-&gt;sessionId();
 64 }
 65 
 66 WebKitMediaKeySession::~WebKitMediaKeySession()
 67 {
 68     if (m_session)
 69         m_session-&gt;setClient(nullptr);
 70 }
 71 
 72 void WebKitMediaKeySession::close()
 73 {
 74     if (m_session) {
 75         m_session-&gt;releaseKeys();
 76         m_session = nullptr;
 77     }
 78 }
 79 
 80 RefPtr&lt;ArrayBuffer&gt; WebKitMediaKeySession::cachedKeyForKeyId(const String&amp; keyId) const
 81 {
 82     return m_session ? m_session-&gt;cachedKeyForKeyID(keyId) : nullptr;
 83 }
 84 
 85 void WebKitMediaKeySession::generateKeyRequest(const String&amp; mimeType, Ref&lt;Uint8Array&gt;&amp;&amp; initData)
 86 {
 87     m_pendingKeyRequests.append({ mimeType, WTFMove(initData) });
 88     m_keyRequestTimer.startOneShot(0_s);
 89 }
 90 
 91 void WebKitMediaKeySession::keyRequestTimerFired()
 92 {
 93     ASSERT(m_pendingKeyRequests.size());
 94     if (!m_session)
 95         return;
 96 
 97     while (!m_pendingKeyRequests.isEmpty()) {
 98         auto request = m_pendingKeyRequests.takeFirst();
 99 
100         // NOTE: Continued from step 5 in MediaKeys::createSession().
101         // The user agent will asynchronously execute the following steps in the task:
102 
103         // 1. Let cdm be the cdm loaded in the MediaKeys constructor.
104         // 2. Let destinationURL be null.
105         String destinationURL;
106         WebKitMediaKeyError::Code errorCode = 0;
107         uint32_t systemCode = 0;
108 
109         // 3. Use cdm to generate a key request and follow the steps for the first matching condition from the following list:
110 
111         auto keyRequest = m_session-&gt;generateKeyRequest(request.mimeType, request.initData.ptr(), destinationURL, errorCode, systemCode);
112 
113         // Otherwise [if a request is not successfully generated]:
114         if (errorCode) {
115             // 3.1. Create a new MediaKeyError object with the following attributes:
116             //      code = the appropriate MediaKeyError code
117             //      systemCode = a Key System-specific value, if provided, and 0 otherwise
118             // 3.2. Set the MediaKeySession object&#39;s error attribute to the error object created in the previous step.
119             // 3.3. queue a task to fire a simple event named keyerror at the MediaKeySession object.
120             sendError(errorCode, systemCode);
121             // 3.4. Abort the task.
122             continue;
123         }
124 
125         // 4. queue a task to fire a simple event named keymessage at the new object
126         //    The event is of type MediaKeyMessageEvent and has:
127         //    message = key request
128         //    destinationURL = destinationURL
129         if (keyRequest)
130             sendMessage(keyRequest.get(), destinationURL);
131     }
132 }
133 
134 ExceptionOr&lt;void&gt; WebKitMediaKeySession::update(Ref&lt;Uint8Array&gt;&amp;&amp; key)
135 {
136     // From &lt;http://dvcs.w3.org/hg/html-media/raw-file/tip/encrypted-media/encrypted-media.html#dom-addkey&gt;:
137     // The addKey(key) method must run the following steps:
138     // 1. If the first or second argument [sic] is an empty array, throw an InvalidAccessError.
139     // NOTE: the reference to a &quot;second argument&quot; is a spec bug.
140     if (!key-&gt;length())
141         return Exception { InvalidAccessError };
142 
143     // 2. Schedule a task to handle the call, providing key.
144     m_pendingKeys.append(WTFMove(key));
145     m_addKeyTimer.startOneShot(0_s);
146 
147     return { };
148 }
149 
150 void WebKitMediaKeySession::addKeyTimerFired()
151 {
152     ASSERT(m_pendingKeys.size());
153     if (!m_session)
154         return;
155 
156     while (!m_pendingKeys.isEmpty()) {
157         auto pendingKey = m_pendingKeys.takeFirst();
158         unsigned short errorCode = 0;
159         uint32_t systemCode = 0;
160 
161         // NOTE: Continued from step 2. of MediaKeySession::update()
162         // 2.1. Let cdm be the cdm loaded in the MediaKeys constructor.
163         // NOTE: This is m_session.
164         // 2.2. Let &#39;did store key&#39; be false.
165         bool didStoreKey = false;
166         // 2.3. Let &#39;next message&#39; be null.
167         RefPtr&lt;Uint8Array&gt; nextMessage;
168         // 2.4. Use cdm to handle key.
169         didStoreKey = m_session-&gt;update(pendingKey.ptr(), nextMessage, errorCode, systemCode);
170         // 2.5. If did store key is true and the media element is waiting for a key, queue a task to attempt to resume playback.
171         // TODO: Find and restart the media element
172 
173         // 2.6. If next message is not null, queue a task to fire a simple event named keymessage at the MediaKeySession object.
174         //      The event is of type MediaKeyMessageEvent and has:
175         //      message = next message
176         //      destinationURL = null
177         if (nextMessage)
178             sendMessage(nextMessage.get(), emptyString());
179 
180         // 2.7. If did store key is true, queue a task to fire a simple event named keyadded at the MediaKeySession object.
181         if (didStoreKey) {
182             auto keyaddedEvent = Event::create(eventNames().webkitkeyaddedEvent, Event::CanBubble::No, Event::IsCancelable::No);
183             keyaddedEvent-&gt;setTarget(this);
184             queueTaskToDispatchEvent(*this, TaskSource::Networking, WTFMove(keyaddedEvent));
185 
186             ASSERT(m_keys);
187             m_keys-&gt;keyAdded();
188         }
189 
190         // 2.8. If any of the preceding steps in the task failed
191         if (errorCode) {
192             // 2.8.1. Create a new MediaKeyError object with the following attributes:
193             //        code = the appropriate MediaKeyError code
194             //        systemCode = a Key System-specific value, if provided, and 0 otherwise
195             // 2.8.2. Set the MediaKeySession object&#39;s error attribute to the error object created in the previous step.
196             // 2.8.3. queue a task to fire a simple event named keyerror at the MediaKeySession object.
197             sendError(errorCode, systemCode);
198             // 2.8.4. Abort the task.
199             // NOTE: no-op
200         }
201     }
202 }
203 
204 void WebKitMediaKeySession::sendMessage(Uint8Array* message, String destinationURL)
205 {
206     auto event = WebKitMediaKeyMessageEvent::create(eventNames().webkitkeymessageEvent, message, destinationURL);
207     event-&gt;setTarget(this);
208     queueTaskToDispatchEvent(*this, TaskSource::Networking, WTFMove(event));
209 }
210 
211 void WebKitMediaKeySession::sendError(MediaKeyErrorCode errorCode, uint32_t systemCode)
212 {
213     m_error = WebKitMediaKeyError::create(errorCode, systemCode);
214 
215     auto keyerrorEvent = Event::create(eventNames().webkitkeyerrorEvent, Event::CanBubble::No, Event::IsCancelable::No);
216     keyerrorEvent-&gt;setTarget(this);
217     queueTaskToDispatchEvent(*this, TaskSource::Networking, WTFMove(keyerrorEvent));
218 }
219 
220 String WebKitMediaKeySession::mediaKeysStorageDirectory() const
221 {
222     auto* document = downcast&lt;Document&gt;(scriptExecutionContext());
223     if (!document)
224         return emptyString();
225 
226     auto* page = document-&gt;page();
227     if (!page || page-&gt;usesEphemeralSession())
228         return emptyString();
229 
230     auto storageDirectory = document-&gt;settings().mediaKeysStorageDirectory();
231     if (storageDirectory.isEmpty())
232         return emptyString();
233 
234     return FileSystem::pathByAppendingComponent(storageDirectory, document-&gt;securityOrigin().data().databaseIdentifier());
235 }
236 
237 bool WebKitMediaKeySession::hasPendingActivity() const
238 {
239     return (m_keys &amp;&amp; m_session) || ActiveDOMObject::hasPendingActivity();
240 }
241 
242 void WebKitMediaKeySession::stop()
243 {
244     close();
245 }
246 
247 const char* WebKitMediaKeySession::activeDOMObjectName() const
248 {
249     return &quot;WebKitMediaKeySession&quot;;
250 }
251 
252 }
253 
254 #endif
    </pre>
  </body>
</html>
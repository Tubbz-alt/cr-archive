<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2007, 2008 Rob Buis &lt;buis@kde.org&gt;
  3  * Copyright (C) 2007 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  4  * Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  5  * Copyright (C) 2009 Google, Inc.  All rights reserved.
  6  * Copyright (C) 2009 Dirk Schulze &lt;krit@webkit.org&gt;
  7  * Copyright (C) Research In Motion Limited 2009-2010. All rights reserved.
  8  * Copyright (C) 2018 Adobe Systems Incorporated. All rights reserved.
  9  *
 10  * This library is free software; you can redistribute it and/or
 11  * modify it under the terms of the GNU Library General Public
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SVGRenderingContext.h&quot;
 28 
 29 #include &quot;BasicShapes.h&quot;
 30 #include &quot;Frame.h&quot;
 31 #include &quot;FrameView.h&quot;
 32 #include &quot;RenderLayer.h&quot;
 33 #include &quot;RenderSVGImage.h&quot;
 34 #include &quot;RenderSVGResourceClipper.h&quot;
 35 #include &quot;RenderSVGResourceFilter.h&quot;
 36 #include &quot;RenderSVGResourceMasker.h&quot;
 37 #include &quot;RenderView.h&quot;
 38 #include &quot;SVGLengthContext.h&quot;
 39 #include &quot;SVGResources.h&quot;
 40 #include &quot;SVGResourcesCache.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 41 #include &lt;wtf/MathExtras.h&gt;</span>
 42 
 43 namespace WebCore {
 44 
 45 static inline bool isRenderingMaskImage(const RenderObject&amp; object)
 46 {
 47     return object.view().frameView().paintBehavior().contains(PaintBehavior::RenderingSVGMask);
 48 }
 49 
 50 SVGRenderingContext::~SVGRenderingContext()
 51 {
 52     // Fast path if we don&#39;t need to restore anything.
 53     if (!(m_renderingFlags &amp; ActionsNeeded))
 54         return;
 55 
 56     ASSERT(m_renderer &amp;&amp; m_paintInfo);
 57 
 58     if (m_renderingFlags &amp; EndFilterLayer) {
 59         ASSERT(m_filter);
 60         GraphicsContext* contextPtr = &amp;m_paintInfo-&gt;context();
 61         m_filter-&gt;postApplyResource(*m_renderer, contextPtr, { }, nullptr, nullptr);
 62         m_paintInfo-&gt;setContext(*m_savedContext);
 63         m_paintInfo-&gt;rect = m_savedPaintRect;
 64     }
 65 
 66     if (m_renderingFlags &amp; EndOpacityLayer)
 67         m_paintInfo-&gt;context().endTransparencyLayer();
 68 
 69     if (m_renderingFlags &amp; EndShadowLayer)
 70         m_paintInfo-&gt;context().endTransparencyLayer();
 71 
 72     if (m_renderingFlags &amp; RestoreGraphicsContext)
 73         m_paintInfo-&gt;context().restore();
 74 }
 75 
 76 void SVGRenderingContext::prepareToRenderSVGContent(RenderElement&amp; renderer, PaintInfo&amp; paintInfo, NeedsGraphicsContextSave needsGraphicsContextSave)
 77 {
 78 #ifndef NDEBUG
 79     // This function must not be called twice!
 80     ASSERT(!(m_renderingFlags &amp; PrepareToRenderSVGContentWasCalled));
 81     m_renderingFlags |= PrepareToRenderSVGContentWasCalled;
 82 #endif
 83 
 84     m_renderer = &amp;renderer;
 85     m_paintInfo = &amp;paintInfo;
 86     m_filter = nullptr;
 87 
 88     // We need to save / restore the context even if the initialization failed.
 89     if (needsGraphicsContextSave == SaveGraphicsContext) {
 90         m_paintInfo-&gt;context().save();
 91         m_renderingFlags |= RestoreGraphicsContext;
 92     }
 93 
 94     auto&amp; style = m_renderer-&gt;style();
 95 
 96     const SVGRenderStyle&amp; svgStyle = style.svgStyle();
 97 
 98     // Setup transparency layers before setting up SVG resources!
 99     bool isRenderingMask = isRenderingMaskImage(*m_renderer);
100     // RenderLayer takes care of root opacity.
101     float opacity = (renderer.isSVGRoot() || isRenderingMask) ? 1 : style.opacity();
102     const ShadowData* shadow = svgStyle.shadow();
103     bool hasBlendMode = style.hasBlendMode();
104     bool hasIsolation = style.hasIsolation();
105     bool isolateMaskForBlending = false;
106 
107 #if ENABLE(CSS_COMPOSITING)
108     if (svgStyle.hasMasker() &amp;&amp; is&lt;SVGGraphicsElement&gt;(downcast&lt;SVGElement&gt;(*renderer.element()))) {
109         SVGGraphicsElement&amp; graphicsElement = downcast&lt;SVGGraphicsElement&gt;(*renderer.element());
110         isolateMaskForBlending = graphicsElement.shouldIsolateBlending();
111     }
112 #endif
113 
114     if (opacity &lt; 1 || shadow || hasBlendMode || isolateMaskForBlending || hasIsolation) {
115         FloatRect repaintRect = m_renderer-&gt;repaintRectInLocalCoordinates();
116         m_paintInfo-&gt;context().clip(repaintRect);
117 
118         if (opacity &lt; 1 || hasBlendMode || isolateMaskForBlending || hasIsolation) {
119 
120             if (hasBlendMode)
121                 m_paintInfo-&gt;context().setCompositeOperation(m_paintInfo-&gt;context().compositeOperation(), style.blendMode());
122 
123             m_paintInfo-&gt;context().beginTransparencyLayer(opacity);
124 
125             if (hasBlendMode)
126                 m_paintInfo-&gt;context().setCompositeOperation(m_paintInfo-&gt;context().compositeOperation(), BlendMode::Normal);
127 
128             m_renderingFlags |= EndOpacityLayer;
129         }
130 
131         if (shadow) {
132             m_paintInfo-&gt;context().setShadow(IntSize(roundToInt(shadow-&gt;x()), roundToInt(shadow-&gt;y())), shadow-&gt;radius(), shadow-&gt;color());
133             m_paintInfo-&gt;context().beginTransparencyLayer(1);
134             m_renderingFlags |= EndShadowLayer;
135         }
136     }
137 
138     ClipPathOperation* clipPathOperation = style.clipPath();
139     bool hasCSSClipping = is&lt;ShapeClipPathOperation&gt;(clipPathOperation) || is&lt;BoxClipPathOperation&gt;(clipPathOperation);
140     if (hasCSSClipping)
141         SVGRenderSupport::clipContextToCSSClippingArea(m_paintInfo-&gt;context(), renderer);
142 
143     auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*m_renderer);
144     if (!resources) {
145         if (style.hasReferenceFilterOnly())
146             return;
147 
148         m_renderingFlags |= RenderingPrepared;
149         return;
150     }
151 
152     if (!isRenderingMask) {
153         if (RenderSVGResourceMasker* masker = resources-&gt;masker()) {
154             GraphicsContext* contextPtr = &amp;m_paintInfo-&gt;context();
155             bool result = masker-&gt;applyResource(*m_renderer, style, contextPtr, { });
156             m_paintInfo-&gt;setContext(*contextPtr);
157             if (!result)
158                 return;
159         }
160     }
161 
162     RenderSVGResourceClipper* clipper = resources-&gt;clipper();
163     if (!hasCSSClipping &amp;&amp; clipper) {
164         GraphicsContext* contextPtr = &amp;m_paintInfo-&gt;context();
165         bool result = clipper-&gt;applyResource(*m_renderer, style, contextPtr, { });
166         m_paintInfo-&gt;setContext(*contextPtr);
167         if (!result)
168             return;
169     }
170 
171     if (!isRenderingMask) {
172         m_filter = resources-&gt;filter();
173         if (m_filter) {
174             m_savedContext = &amp;m_paintInfo-&gt;context();
175             m_savedPaintRect = m_paintInfo-&gt;rect;
176             // Return with false here may mean that we don&#39;t need to draw the content
177             // (because it was either drawn before or empty) but we still need to apply the filter.
178             m_renderingFlags |= EndFilterLayer;
179             GraphicsContext* contextPtr = &amp;m_paintInfo-&gt;context();
180             bool result = m_filter-&gt;applyResource(*m_renderer, style, contextPtr, { });
181             m_paintInfo-&gt;setContext(*contextPtr);
182             if (!result)
183                 return;
184 
185             // Since we&#39;re caching the resulting bitmap and do not invalidate it on repaint rect
186             // changes, we need to paint the whole filter region. Otherwise, elements not visible
187             // at the time of the initial paint (due to scrolling, window size, etc.) will never
188             // be drawn.
189             m_paintInfo-&gt;rect = IntRect(m_filter-&gt;drawingRegion(m_renderer));
190         }
191     }
192 
193     m_renderingFlags |= RenderingPrepared;
194 }
195 
196 static AffineTransform&amp; currentContentTransformation()
197 {
198     static NeverDestroyed&lt;AffineTransform&gt; s_currentContentTransformation;
199     return s_currentContentTransformation;
200 }
201 
202 float SVGRenderingContext::calculateScreenFontSizeScalingFactor(const RenderObject&amp; renderer)
203 {
204     AffineTransform ctm = calculateTransformationToOutermostCoordinateSystem(renderer);
<a name="2" id="anc2"></a><span class="line-modified">205     return narrowPrecisionToFloat(std::hypot(ctm.xScale(), ctm.yScale()) / sqrtOfTwoDouble);</span>
206 }
207 
208 AffineTransform SVGRenderingContext::calculateTransformationToOutermostCoordinateSystem(const RenderObject&amp; renderer)
209 {
210     AffineTransform absoluteTransform = currentContentTransformation();
211 
212     float deviceScaleFactor = renderer.document().deviceScaleFactor();
213     // Walk up the render tree, accumulating SVG transforms.
214     const RenderObject* ancestor = &amp;renderer;
215     while (ancestor) {
216         absoluteTransform = ancestor-&gt;localToParentTransform() * absoluteTransform;
217         if (ancestor-&gt;isSVGRoot())
218             break;
219         ancestor = ancestor-&gt;parent();
220     }
221 
222     // Continue walking up the layer tree, accumulating CSS transforms.
223     RenderLayer* layer = ancestor ? ancestor-&gt;enclosingLayer() : nullptr;
224     while (layer) {
225         if (TransformationMatrix* layerTransform = layer-&gt;transform())
226             absoluteTransform = layerTransform-&gt;toAffineTransform() * absoluteTransform;
227 
228         // We can stop at compositing layers, to match the backing resolution.
229         if (layer-&gt;isComposited())
230             break;
231 
232         layer = layer-&gt;parent();
233     }
234 
235     absoluteTransform.scale(deviceScaleFactor);
236     return absoluteTransform;
237 }
238 
239 std::unique_ptr&lt;ImageBuffer&gt; SVGRenderingContext::createImageBuffer(const FloatRect&amp; targetRect, const AffineTransform&amp; absoluteTransform, ColorSpace colorSpace, RenderingMode renderingMode, const GraphicsContext* context)
240 {
241     IntRect paintRect = calculateImageBufferRect(targetRect, absoluteTransform);
242     // Don&#39;t create empty ImageBuffers.
243     if (paintRect.isEmpty())
244         return nullptr;
245 
246     FloatSize scale;
247     FloatSize clampedSize = ImageBuffer::clampedSize(paintRect.size(), scale);
248 
249 #if USE(DIRECT2D)
250     auto imageBuffer = ImageBuffer::create(clampedSize, renderingMode, context, 1, colorSpace);
251 #else
252     UNUSED_PARAM(context);
253     auto imageBuffer = ImageBuffer::create(clampedSize, renderingMode, 1, colorSpace);
254 #endif
255     if (!imageBuffer)
256         return nullptr;
257 
258     AffineTransform transform;
259     transform.scale(scale).translate(-paintRect.location()).multiply(absoluteTransform);
260 
261     GraphicsContext&amp; imageContext = imageBuffer-&gt;context();
262     imageContext.concatCTM(transform);
263 
264     return imageBuffer;
265 }
266 
267 std::unique_ptr&lt;ImageBuffer&gt; SVGRenderingContext::createImageBuffer(const FloatRect&amp; targetRect, const FloatRect&amp; clampedRect, ColorSpace colorSpace, RenderingMode renderingMode, const GraphicsContext* context)
268 {
269     IntSize clampedSize = roundedIntSize(clampedRect.size());
270     FloatSize unclampedSize = roundedIntSize(targetRect.size());
271 
272     // Don&#39;t create empty ImageBuffers.
273     if (clampedSize.isEmpty())
274         return nullptr;
275 
276 #if USE(DIRECT2D)
277     auto imageBuffer = ImageBuffer::create(clampedSize, renderingMode, context, 1, colorSpace);
278 #else
279     UNUSED_PARAM(context);
280     auto imageBuffer = ImageBuffer::create(clampedSize, renderingMode, 1, colorSpace);
281 #endif
282     if (!imageBuffer)
283         return nullptr;
284 
285     GraphicsContext&amp; imageContext = imageBuffer-&gt;context();
286 
287     // Compensate rounding effects, as the absolute target rect is using floating-point numbers and the image buffer size is integer.
288     imageContext.scale(unclampedSize / targetRect.size());
289 
290     return imageBuffer;
291 }
292 
293 void SVGRenderingContext::renderSubtreeToImageBuffer(ImageBuffer* image, RenderElement&amp; item, const AffineTransform&amp; subtreeContentTransformation)
294 {
295     ASSERT(image);
296 
297     // Rendering into a buffer implies we&#39;re being used for masking, clipping, patterns or filters. In each of these
298     // cases we don&#39;t want to paint the selection.
299     PaintInfo info(image-&gt;context(), LayoutRect::infiniteRect(), PaintPhase::Foreground, PaintBehavior::SkipSelectionHighlight);
300 
301     AffineTransform&amp; contentTransformation = currentContentTransformation();
302     AffineTransform savedContentTransformation = contentTransformation;
303     contentTransformation = subtreeContentTransformation * contentTransformation;
304 
305     ASSERT(!item.needsLayout());
306     item.paint(info, { });
307 
308     contentTransformation = savedContentTransformation;
309 }
310 
311 void SVGRenderingContext::clipToImageBuffer(GraphicsContext&amp; context, const AffineTransform&amp; absoluteTransform, const FloatRect&amp; targetRect, std::unique_ptr&lt;ImageBuffer&gt;&amp; imageBuffer, bool safeToClear)
312 {
313     if (!imageBuffer)
314         return;
315 
316     FloatRect absoluteTargetRect = calculateImageBufferRect(targetRect, absoluteTransform);
317 
318     // The mask image has been created in the absolute coordinate space, as the image should not be scaled.
319     // So the actual masking process has to be done in the absolute coordinate space as well.
320     context.concatCTM(absoluteTransform.inverse().valueOr(AffineTransform()));
321     context.clipToImageBuffer(*imageBuffer, absoluteTargetRect);
322     context.concatCTM(absoluteTransform);
323 
324     // When nesting resources, with objectBoundingBox as content unit types, there&#39;s no use in caching the
325     // resulting image buffer as the parent resource already caches the result.
326     if (safeToClear &amp;&amp; !currentContentTransformation().isIdentity())
327         imageBuffer.reset();
328 }
329 
330 void SVGRenderingContext::clear2DRotation(AffineTransform&amp; transform)
331 {
332     AffineTransform::DecomposedType decomposition;
333     transform.decompose(decomposition);
334     decomposition.angle = 0;
335     transform.recompose(decomposition);
336 }
337 
338 bool SVGRenderingContext::bufferForeground(std::unique_ptr&lt;ImageBuffer&gt;&amp; imageBuffer)
339 {
340     ASSERT(m_paintInfo);
341     ASSERT(is&lt;RenderSVGImage&gt;(*m_renderer));
342     FloatRect boundingBox = m_renderer-&gt;objectBoundingBox();
343 
344     // Invalidate an existing buffer if the scale is not correct.
345     if (imageBuffer) {
346         AffineTransform transform = m_paintInfo-&gt;context().getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
347         IntSize expandedBoundingBox = expandedIntSize(boundingBox.size());
348         IntSize bufferSize(static_cast&lt;int&gt;(ceil(expandedBoundingBox.width() * transform.xScale())), static_cast&lt;int&gt;(ceil(expandedBoundingBox.height() * transform.yScale())));
349         if (bufferSize != imageBuffer-&gt;internalSize())
350             imageBuffer.reset();
351     }
352 
353     // Create a new buffer and paint the foreground into it.
354     if (!imageBuffer) {
<a name="3" id="anc3"></a><span class="line-modified">355         if ((imageBuffer = ImageBuffer::createCompatibleBuffer(expandedIntSize(boundingBox.size()), ColorSpace::SRGB, m_paintInfo-&gt;context()))) {</span>
356             GraphicsContext&amp; bufferedRenderingContext = imageBuffer-&gt;context();
357             bufferedRenderingContext.translate(-boundingBox.location());
358             PaintInfo bufferedInfo(*m_paintInfo);
359             bufferedInfo.setContext(bufferedRenderingContext);
360             downcast&lt;RenderSVGImage&gt;(*m_renderer).paintForeground(bufferedInfo);
361         } else
362             return false;
363     }
364 
365     m_paintInfo-&gt;context().drawImageBuffer(*imageBuffer, boundingBox);
366     return true;
367 }
368 
369 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
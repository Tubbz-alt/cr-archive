<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CommonSlowPaths.h&quot;
  28 
  29 #include &quot;ArithProfile.h&quot;
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeStructs.h&quot;
  33 #include &quot;CallFrame.h&quot;
  34 #include &quot;ClonedArguments.h&quot;
  35 #include &quot;CodeProfiling.h&quot;
  36 #include &quot;DefinePropertyAttributes.h&quot;
  37 #include &quot;DirectArguments.h&quot;
  38 #include &quot;Error.h&quot;
  39 #include &quot;ErrorHandlingScope.h&quot;
  40 #include &quot;ExceptionFuzz.h&quot;
  41 #include &quot;FrameTracers.h&quot;
  42 #include &quot;GetterSetter.h&quot;
  43 #include &quot;HostCallReturnValue.h&quot;
  44 #include &quot;ICStats.h&quot;
  45 #include &quot;Interpreter.h&quot;
  46 #include &quot;IteratorOperations.h&quot;
  47 #include &quot;JIT.h&quot;
  48 #include &quot;JSArrayInlines.h&quot;
<a name="1" id="anc1"></a>
  49 #include &quot;JSCInlines.h&quot;
  50 #include &quot;JSCJSValue.h&quot;
<a name="2" id="anc2"></a><span class="line-removed">  51 #include &quot;JSFixedArray.h&quot;</span>
  52 #include &quot;JSGlobalObjectFunctions.h&quot;
  53 #include &quot;JSImmutableButterfly.h&quot;
<a name="3" id="anc3"></a>

  54 #include &quot;JSLexicalEnvironment.h&quot;
<a name="4" id="anc4"></a>
  55 #include &quot;JSPropertyNameEnumerator.h&quot;
  56 #include &quot;JSString.h&quot;
  57 #include &quot;JSWithScope.h&quot;
  58 #include &quot;LLIntCommon.h&quot;
  59 #include &quot;LLIntExceptions.h&quot;
  60 #include &quot;LowLevelInterpreter.h&quot;
  61 #include &quot;MathCommon.h&quot;
  62 #include &quot;ObjectConstructor.h&quot;
  63 #include &quot;OpcodeInlines.h&quot;
  64 #include &quot;ScopedArguments.h&quot;
  65 #include &quot;StructureRareDataInlines.h&quot;
  66 #include &quot;ThunkGenerators.h&quot;
  67 #include &quot;TypeProfilerLog.h&quot;
  68 #include &lt;wtf/StringPrintStream.h&gt;
  69 #include &lt;wtf/Variant.h&gt;
  70 
  71 namespace JSC {
  72 
  73 #define BEGIN_NO_SET_PC() \
<a name="5" id="anc5"></a><span class="line-modified">  74     VM&amp; vm = exec-&gt;vm();      \</span>
<span class="line-modified">  75     NativeCallFrameTracer tracer(vm, exec); \</span>


  76     auto throwScope = DECLARE_THROW_SCOPE(vm); \
  77     UNUSED_PARAM(throwScope)
  78 
  79 #ifndef NDEBUG
  80 #define SET_PC_FOR_STUBS() do { \
<a name="6" id="anc6"></a><span class="line-modified">  81         exec-&gt;codeBlock()-&gt;bytecodeOffset(pc); \</span>
<span class="line-modified">  82         exec-&gt;setCurrentVPC(pc); \</span>
  83     } while (false)
  84 #else
  85 #define SET_PC_FOR_STUBS() do { \
<a name="7" id="anc7"></a><span class="line-modified">  86         exec-&gt;setCurrentVPC(pc); \</span>
  87     } while (false)
  88 #endif
  89 
<a name="8" id="anc8"></a><span class="line-modified">  90 #define RETURN_TO_THROW(exec, pc)   pc = LLInt::returnToThrow(exec)</span>
  91 
  92 #define BEGIN()                           \
  93     BEGIN_NO_SET_PC();                    \
  94     SET_PC_FOR_STUBS()
  95 
<a name="9" id="anc9"></a><span class="line-modified">  96 #define GET(operand) (exec-&gt;uncheckedR(operand.offset()))</span>
<span class="line-modified">  97 #define GET_C(operand) (exec-&gt;r(operand.offset()))</span>
  98 
  99 #define RETURN_TWO(first, second) do {       \
 100         return encodeResult(first, second);        \
 101     } while (false)
 102 
<a name="10" id="anc10"></a><span class="line-modified"> 103 #define END_IMPL() RETURN_TWO(pc, exec)</span>
 104 
 105 #define THROW(exceptionToThrow) do {                        \
<a name="11" id="anc11"></a><span class="line-modified"> 106         throwException(exec, throwScope, exceptionToThrow); \</span>
<span class="line-modified"> 107         RETURN_TO_THROW(exec, pc);                          \</span>
 108         END_IMPL();                                         \
 109     } while (false)
 110 
 111 #define CHECK_EXCEPTION() do {                    \
<a name="12" id="anc12"></a><span class="line-modified"> 112         doExceptionFuzzingIfEnabled(exec, throwScope, &quot;CommonSlowPaths&quot;, pc);   \</span>
 113         if (UNLIKELY(throwScope.exception())) {   \
<a name="13" id="anc13"></a><span class="line-modified"> 114             RETURN_TO_THROW(exec, pc);            \</span>
 115             END_IMPL();                           \
 116         }                                         \
 117     } while (false)
 118 
 119 #define END() do {                        \
 120         CHECK_EXCEPTION();                \
 121         END_IMPL();                       \
 122     } while (false)
 123 
 124 #define BRANCH(condition) do {                      \
 125         bool bCondition = (condition);                         \
 126         CHECK_EXCEPTION();                                  \
 127         if (bCondition)                                        \
 128             pc = bytecode.m_targetLabel \
 129                 ? reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + bytecode.m_targetLabel) \
<a name="14" id="anc14"></a><span class="line-modified"> 130                 : exec-&gt;codeBlock()-&gt;outOfLineJumpTarget(pc);                              \</span>
 131         else                                                      \
 132             pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + pc-&gt;size()); \
 133         END_IMPL();                                         \
 134     } while (false)
 135 
 136 #define RETURN_WITH_PROFILING_CUSTOM(result__, value__, profilingAction__) do { \
 137         JSValue returnValue__ = (value__);  \
 138         CHECK_EXCEPTION();                  \
 139         GET(result__) = returnValue__;              \
 140         profilingAction__;                  \
 141         END_IMPL();                         \
 142     } while (false)
 143 
 144 #define RETURN_WITH_PROFILING(value__, profilingAction__) RETURN_WITH_PROFILING_CUSTOM(bytecode.m_dst, value__, profilingAction__)
 145 
 146 #define RETURN(value) \
 147     RETURN_WITH_PROFILING(value, { })
 148 
 149 #define RETURN_PROFILED(value__) \
 150     RETURN_WITH_PROFILING(value__, PROFILE_VALUE(returnValue__))
 151 
 152 #define PROFILE_VALUE(value) do { \
<a name="15" id="anc15"></a><span class="line-modified"> 153         bytecode.metadata(exec).m_profile.m_buckets[0] = JSValue::encode(value); \</span>
 154     } while (false)
 155 
<a name="16" id="anc16"></a><span class="line-modified"> 156 #define CALL_END_IMPL(exec, callTarget, callTargetTag) \</span>
<span class="line-removed"> 157     RETURN_TWO(retagCodePtr((callTarget), callTargetTag, SlowPathPtrTag), (exec))</span>
<span class="line-removed"> 158 </span>
<span class="line-removed"> 159 #define CALL_CHECK_EXCEPTION(exec, pc) do {                          \</span>
<span class="line-removed"> 160         ExecState* cceExec = (exec);                                 \</span>
<span class="line-removed"> 161         Instruction* ccePC = (pc);                                   \</span>
<span class="line-removed"> 162         if (UNLIKELY(throwScope.exception()))                        \</span>
<span class="line-removed"> 163             CALL_END_IMPL(cceExec, LLInt::callToThrow(cceExec), ExceptionHandlerPtrTag); \</span>
<span class="line-removed"> 164     } while (false)</span>
<span class="line-removed"> 165 </span>
<span class="line-removed"> 166 static void throwArityCheckStackOverflowError(ExecState* exec, ThrowScope&amp; scope)</span>
 167 {
<a name="17" id="anc17"></a><span class="line-modified"> 168     JSObject* error = createStackOverflowError(exec);</span>
<span class="line-modified"> 169     throwException(exec, scope, error);</span>
 170 #if LLINT_TRACING
 171     if (UNLIKELY(Options::traceLLIntSlowPath()))
 172         dataLog(&quot;Throwing exception &quot;, JSValue(scope.exception()), &quot;.\n&quot;);
 173 #endif
 174 }
 175 
 176 SLOW_PATH_DECL(slow_path_call_arityCheck)
 177 {
 178     BEGIN();
<a name="18" id="anc18"></a><span class="line-modified"> 179     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForCall);</span>
 180     if (UNLIKELY(slotsToAdd &lt; 0)) {
<a name="19" id="anc19"></a><span class="line-modified"> 181         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForCall);</span>
<span class="line-modified"> 182         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 183         NativeCallFrameTracer tracer(vm, exec);</span>
 184         ErrorHandlingScope errorScope(vm);
 185         throwScope.release();
<a name="20" id="anc20"></a><span class="line-modified"> 186         throwArityCheckStackOverflowError(exec, throwScope);</span>
<span class="line-modified"> 187         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);</span>
 188     }
 189     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 190 }
 191 
 192 SLOW_PATH_DECL(slow_path_construct_arityCheck)
 193 {
 194     BEGIN();
<a name="21" id="anc21"></a><span class="line-modified"> 195     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForConstruct);</span>
 196     if (UNLIKELY(slotsToAdd &lt; 0)) {
<a name="22" id="anc22"></a><span class="line-modified"> 197         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForConstruct);</span>
<span class="line-modified"> 198         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 199         NativeCallFrameTracer tracer(vm, exec);</span>
 200         ErrorHandlingScope errorScope(vm);
<a name="23" id="anc23"></a><span class="line-modified"> 201         throwArityCheckStackOverflowError(exec, throwScope);</span>
<span class="line-modified"> 202         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);</span>
 203     }
 204     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 205 }
 206 
 207 SLOW_PATH_DECL(slow_path_create_direct_arguments)
 208 {
 209     BEGIN();
 210     auto bytecode = pc-&gt;as&lt;OpCreateDirectArguments&gt;();
<a name="24" id="anc24"></a><span class="line-modified"> 211     RETURN(DirectArguments::createByCopying(exec));</span>
 212 }
 213 
 214 SLOW_PATH_DECL(slow_path_create_scoped_arguments)
 215 {
 216     BEGIN();
 217     auto bytecode = pc-&gt;as&lt;OpCreateScopedArguments&gt;();
 218     JSLexicalEnvironment* scope = jsCast&lt;JSLexicalEnvironment*&gt;(GET(bytecode.m_scope).jsValue());
 219     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
<a name="25" id="anc25"></a><span class="line-modified"> 220     RETURN(ScopedArguments::createByCopying(exec, table, scope));</span>
 221 }
 222 
 223 SLOW_PATH_DECL(slow_path_create_cloned_arguments)
 224 {
 225     BEGIN();
 226     auto bytecode = pc-&gt;as&lt;OpCreateClonedArguments&gt;();
<a name="26" id="anc26"></a><span class="line-modified"> 227     RETURN(ClonedArguments::createWithMachineFrame(exec, exec, ArgumentsMode::Cloned));</span>













 228 }
 229 
 230 SLOW_PATH_DECL(slow_path_create_this)
 231 {
 232     BEGIN();
 233     auto bytecode = pc-&gt;as&lt;OpCreateThis&gt;();
 234     JSObject* result;
 235     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());
<a name="27" id="anc27"></a><span class="line-modified"> 236     if (constructorAsObject-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructorAsObject)-&gt;canUseAllocationProfile()) {</span>
<span class="line-modified"> 237         JSFunction* constructor = jsCast&lt;JSFunction*&gt;(constructorAsObject);</span>
<span class="line-modified"> 238         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(exec).m_cachedCallee;</span>
 239         if (!cachedCallee)
<a name="28" id="anc28"></a><span class="line-modified"> 240             cachedCallee.set(vm, exec-&gt;codeBlock(), constructor);</span>
 241         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
 242             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
 243 
 244         size_t inlineCapacity = bytecode.m_inlineCapacity;
<a name="29" id="anc29"></a><span class="line-modified"> 245         ObjectAllocationProfileWithPrototype* allocationProfile = constructor-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity)-&gt;objectAllocationProfile();</span>
 246         throwScope.releaseAssertNoException();
 247         Structure* structure = allocationProfile-&gt;structure();
<a name="30" id="anc30"></a><span class="line-modified"> 248         result = constructEmptyObject(exec, structure);</span>
 249         if (structure-&gt;hasPolyProto()) {
 250             JSObject* prototype = allocationProfile-&gt;prototype();
<a name="31" id="anc31"></a><span class="line-modified"> 251             ASSERT(prototype == constructor-&gt;prototypeForConstruction(vm, exec));</span>
 252             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 253             prototype-&gt;didBecomePrototype();
 254             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 255         }
 256     } else {
 257         // http://ecma-international.org/ecma-262/6.0/#sec-ordinarycreatefromconstructor
<a name="32" id="anc32"></a><span class="line-modified"> 258         JSValue proto = constructorAsObject-&gt;get(exec, vm.propertyNames-&gt;prototype);</span>
 259         CHECK_EXCEPTION();
 260         if (proto.isObject())
<a name="33" id="anc33"></a><span class="line-modified"> 261             result = constructEmptyObject(exec, asObject(proto));</span>
 262         else
<a name="34" id="anc34"></a><span class="line-modified"> 263             result = constructEmptyObject(exec);</span>
 264     }
 265     RETURN(result);
 266 }
 267 
<a name="35" id="anc35"></a>

















































































 268 SLOW_PATH_DECL(slow_path_to_this)
 269 {
 270     BEGIN();
 271     auto bytecode = pc-&gt;as&lt;OpToThis&gt;();
<a name="36" id="anc36"></a><span class="line-modified"> 272     auto&amp; metadata = bytecode.metadata(exec);</span>
 273     JSValue v1 = GET(bytecode.m_srcDst).jsValue();
 274     if (v1.isCell()) {
 275         StructureID myStructureID = v1.asCell()-&gt;structureID();
 276         StructureID otherStructureID = metadata.m_cachedStructureID;
 277         if (myStructureID != otherStructureID) {
 278             if (otherStructureID)
 279                 metadata.m_toThisStatus = ToThisConflicted;
 280             metadata.m_cachedStructureID = myStructureID;
<a name="37" id="anc37"></a><span class="line-modified"> 281             vm.heap.writeBarrier(exec-&gt;codeBlock(), vm.getStructure(myStructureID));</span>
 282         }
 283     } else {
 284         metadata.m_toThisStatus = ToThisConflicted;
 285         metadata.m_cachedStructureID = 0;
 286     }
 287     // Note: We only need to do this value profiling here on the slow path. The fast path
 288     // just returns the input to to_this if the structure check succeeds. If the structure
 289     // check succeeds, doing value profiling here is equivalent to doing it with a potentially
 290     // different object that still has the same structure on the fast path since it&#39;ll produce
 291     // the same SpeculatedType. Therefore, we don&#39;t need to worry about value profiling on the
 292     // fast path.
<a name="38" id="anc38"></a><span class="line-modified"> 293     auto value = v1.toThis(exec, exec-&gt;codeBlock()-&gt;isStrictMode() ? StrictMode : NotStrictMode);</span>
 294     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, value, PROFILE_VALUE(value));
 295 }
 296 
 297 SLOW_PATH_DECL(slow_path_throw_tdz_error)
 298 {
 299     BEGIN();
<a name="39" id="anc39"></a><span class="line-modified"> 300     THROW(createTDZError(exec));</span>
 301 }
 302 
 303 SLOW_PATH_DECL(slow_path_check_tdz)
 304 {
 305     BEGIN();
<a name="40" id="anc40"></a><span class="line-modified"> 306     THROW(createTDZError(exec));</span>
 307 }
 308 
 309 SLOW_PATH_DECL(slow_path_throw_strict_mode_readonly_property_write_error)
 310 {
 311     BEGIN();
<a name="41" id="anc41"></a><span class="line-modified"> 312     THROW(createTypeError(exec, ReadonlyPropertyWriteError));</span>
 313 }
 314 
 315 SLOW_PATH_DECL(slow_path_not)
 316 {
 317     BEGIN();
 318     auto bytecode = pc-&gt;as&lt;OpNot&gt;();
<a name="42" id="anc42"></a><span class="line-modified"> 319     RETURN(jsBoolean(!GET_C(bytecode.m_operand).jsValue().toBoolean(exec)));</span>
 320 }
 321 
 322 SLOW_PATH_DECL(slow_path_eq)
 323 {
 324     BEGIN();
 325     auto bytecode = pc-&gt;as&lt;OpEq&gt;();
<a name="43" id="anc43"></a><span class="line-modified"> 326     RETURN(jsBoolean(JSValue::equal(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 327 }
 328 
 329 SLOW_PATH_DECL(slow_path_neq)
 330 {
 331     BEGIN();
 332     auto bytecode = pc-&gt;as&lt;OpNeq&gt;();
<a name="44" id="anc44"></a><span class="line-modified"> 333     RETURN(jsBoolean(!JSValue::equal(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 334 }
 335 
 336 SLOW_PATH_DECL(slow_path_stricteq)
 337 {
 338     BEGIN();
 339     auto bytecode = pc-&gt;as&lt;OpStricteq&gt;();
<a name="45" id="anc45"></a><span class="line-modified"> 340     RETURN(jsBoolean(JSValue::strictEqual(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 341 }
 342 
 343 SLOW_PATH_DECL(slow_path_nstricteq)
 344 {
 345     BEGIN();
 346     auto bytecode = pc-&gt;as&lt;OpNstricteq&gt;();
<a name="46" id="anc46"></a><span class="line-modified"> 347     RETURN(jsBoolean(!JSValue::strictEqual(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 348 }
 349 
 350 SLOW_PATH_DECL(slow_path_less)
 351 {
 352     BEGIN();
 353     auto bytecode = pc-&gt;as&lt;OpLess&gt;();
<a name="47" id="anc47"></a><span class="line-modified"> 354     RETURN(jsBoolean(jsLess&lt;true&gt;(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 355 }
 356 
 357 SLOW_PATH_DECL(slow_path_lesseq)
 358 {
 359     BEGIN();
 360     auto bytecode = pc-&gt;as&lt;OpLesseq&gt;();
<a name="48" id="anc48"></a><span class="line-modified"> 361     RETURN(jsBoolean(jsLessEq&lt;true&gt;(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 362 }
 363 
 364 SLOW_PATH_DECL(slow_path_greater)
 365 {
 366     BEGIN();
 367     auto bytecode = pc-&gt;as&lt;OpGreater&gt;();
<a name="49" id="anc49"></a><span class="line-modified"> 368     RETURN(jsBoolean(jsLess&lt;false&gt;(exec, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));</span>
 369 }
 370 
 371 SLOW_PATH_DECL(slow_path_greatereq)
 372 {
 373     BEGIN();
 374     auto bytecode = pc-&gt;as&lt;OpGreatereq&gt;();
<a name="50" id="anc50"></a><span class="line-modified"> 375     RETURN(jsBoolean(jsLessEq&lt;false&gt;(exec, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));</span>
 376 }
 377 
 378 SLOW_PATH_DECL(slow_path_inc)
 379 {
 380     BEGIN();
 381     auto bytecode = pc-&gt;as&lt;OpInc&gt;();
<a name="51" id="anc51"></a><span class="line-modified"> 382     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, jsNumber(GET(bytecode.m_srcDst).jsValue().toNumber(exec) + 1), { });</span>








 383 }
 384 
 385 SLOW_PATH_DECL(slow_path_dec)
 386 {
 387     BEGIN();
 388     auto bytecode = pc-&gt;as&lt;OpDec&gt;();
<a name="52" id="anc52"></a><span class="line-modified"> 389     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, jsNumber(GET(bytecode.m_srcDst).jsValue().toNumber(exec) - 1), { });</span>








 390 }
 391 
 392 SLOW_PATH_DECL(slow_path_to_string)
 393 {
 394     BEGIN();
 395     auto bytecode = pc-&gt;as&lt;OpToString&gt;();
<a name="53" id="anc53"></a><span class="line-modified"> 396     RETURN(GET_C(bytecode.m_operand).jsValue().toString(exec));</span>
 397 }
 398 
 399 #if ENABLE(JIT)
 400 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp; metadata, JSValue result, JSValue operand)
 401 {
<a name="54" id="anc54"></a><span class="line-modified"> 402     ArithProfile&amp; profile = metadata.m_arithProfile;</span>
<span class="line-modified"> 403     profile.observeLHS(operand);</span>
 404     ASSERT(result.isNumber() || result.isBigInt());
 405     if (result.isNumber()) {
 406         if (!result.isInt32()) {
 407             if (operand.isInt32())
 408                 profile.setObservedInt32Overflow();
 409 
 410             double doubleVal = result.asNumber();
 411             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 412                 profile.setObservedNegZeroDouble();
 413             else {
 414                 profile.setObservedNonNegZeroDouble();
 415 
 416                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 417                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 418                 // done to simplify the checking algorithm.
 419                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 420                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 421                 if (int64Val &gt;= int52OverflowPoint)
 422                     profile.setObservedInt52Overflow();
 423             }
 424         }
 425     } else if (result.isBigInt())
 426         profile.setObservedBigInt();
 427     else
 428         profile.setObservedNonNumeric();
 429 }
 430 #else
 431 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp;, JSValue, JSValue) { }
 432 #endif
 433 
 434 SLOW_PATH_DECL(slow_path_negate)
 435 {
 436     BEGIN();
 437     auto bytecode = pc-&gt;as&lt;OpNegate&gt;();
<a name="55" id="anc55"></a><span class="line-modified"> 438     auto&amp; metadata = bytecode.metadata(exec);</span>
 439     JSValue operand = GET_C(bytecode.m_operand).jsValue();
<a name="56" id="anc56"></a><span class="line-modified"> 440     JSValue primValue = operand.toPrimitive(exec, PreferNumber);</span>
 441     CHECK_EXCEPTION();
 442 
 443     if (primValue.isBigInt()) {
 444         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
 445         RETURN_WITH_PROFILING(result, {
 446             updateArithProfileForUnaryArithOp(metadata, result, operand);
 447         });
 448     }
 449 
<a name="57" id="anc57"></a><span class="line-modified"> 450     JSValue result = jsNumber(-primValue.toNumber(exec));</span>
 451     CHECK_EXCEPTION();
 452     RETURN_WITH_PROFILING(result, {
 453         updateArithProfileForUnaryArithOp(metadata, result, operand);
 454     });
 455 }
 456 
 457 #if ENABLE(DFG_JIT)
<a name="58" id="anc58"></a><span class="line-modified"> 458 static void updateArithProfileForBinaryArithOp(ExecState* exec, const Instruction* pc, JSValue result, JSValue left, JSValue right)</span>
 459 {
<a name="59" id="anc59"></a><span class="line-modified"> 460     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed"> 461     ArithProfile&amp; profile = *codeBlock-&gt;arithProfileForPC(pc);</span>
 462 
 463     if (result.isNumber()) {
 464         if (!result.isInt32()) {
 465             if (left.isInt32() &amp;&amp; right.isInt32())
 466                 profile.setObservedInt32Overflow();
 467 
 468             double doubleVal = result.asNumber();
 469             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 470                 profile.setObservedNegZeroDouble();
 471             else {
 472                 profile.setObservedNonNegZeroDouble();
 473 
 474                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 475                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 476                 // done to simplify the checking algorithm.
 477                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 478                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 479                 if (int64Val &gt;= int52OverflowPoint)
 480                     profile.setObservedInt52Overflow();
 481             }
 482         }
 483     } else if (result.isBigInt())
 484         profile.setObservedBigInt();
 485     else
 486         profile.setObservedNonNumeric();
 487 }
 488 #else
<a name="60" id="anc60"></a><span class="line-modified"> 489 static void updateArithProfileForBinaryArithOp(ExecState*, const Instruction*, JSValue, JSValue, JSValue) { }</span>
 490 #endif
 491 
 492 SLOW_PATH_DECL(slow_path_to_number)
 493 {
 494     BEGIN();
 495     auto bytecode = pc-&gt;as&lt;OpToNumber&gt;();
 496     JSValue argument = GET_C(bytecode.m_operand).jsValue();
<a name="61" id="anc61"></a><span class="line-modified"> 497     JSValue result = jsNumber(argument.toNumber(exec));</span>















 498     RETURN_PROFILED(result);
 499 }
 500 
 501 SLOW_PATH_DECL(slow_path_to_object)
 502 {
 503     BEGIN();
 504     auto bytecode = pc-&gt;as&lt;OpToObject&gt;();
 505     JSValue argument = GET_C(bytecode.m_operand).jsValue();
 506     if (UNLIKELY(argument.isUndefinedOrNull())) {
<a name="62" id="anc62"></a><span class="line-modified"> 507         const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_message);</span>
 508         if (!ident.isEmpty())
<a name="63" id="anc63"></a><span class="line-modified"> 509             THROW(createTypeError(exec, ident.impl()));</span>
 510     }
<a name="64" id="anc64"></a><span class="line-modified"> 511     JSObject* result = argument.toObject(exec);</span>
 512     RETURN_PROFILED(result);
 513 }
 514 
 515 SLOW_PATH_DECL(slow_path_add)
 516 {
 517     BEGIN();
 518     auto bytecode = pc-&gt;as&lt;OpAdd&gt;();
 519     JSValue v1 = GET_C(bytecode.m_lhs).jsValue();
 520     JSValue v2 = GET_C(bytecode.m_rhs).jsValue();
 521 
<a name="65" id="anc65"></a><span class="line-modified"> 522     ArithProfile&amp; arithProfile = *exec-&gt;codeBlock()-&gt;arithProfileForPC(pc);</span>
 523     arithProfile.observeLHSAndRHS(v1, v2);
 524 
<a name="66" id="anc66"></a><span class="line-modified"> 525     JSValue result = jsAdd(exec, v1, v2);</span>
 526 
 527     RETURN_WITH_PROFILING(result, {
<a name="67" id="anc67"></a><span class="line-modified"> 528         updateArithProfileForBinaryArithOp(exec, pc, result, v1, v2);</span>
 529     });
 530 }
 531 
 532 // The following arithmetic and bitwise operations need to be sure to run
 533 // toNumber() on their operands in order.  (A call to toNumber() is idempotent
<a name="68" id="anc68"></a><span class="line-modified"> 534 // if an exception is already set on the ExecState.)</span>
 535 
 536 SLOW_PATH_DECL(slow_path_mul)
 537 {
 538     BEGIN();
 539     auto bytecode = pc-&gt;as&lt;OpMul&gt;();
 540     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 541     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="69" id="anc69"></a><span class="line-modified"> 542     JSValue result = jsMul(exec, left, right);</span>
 543     CHECK_EXCEPTION();
 544     RETURN_WITH_PROFILING(result, {
<a name="70" id="anc70"></a><span class="line-modified"> 545         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
 546     });
 547 }
 548 
 549 SLOW_PATH_DECL(slow_path_sub)
 550 {
 551     BEGIN();
 552     auto bytecode = pc-&gt;as&lt;OpSub&gt;();
 553     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 554     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="71" id="anc71"></a><span class="line-modified"> 555     auto leftNumeric = left.toNumeric(exec);</span>
 556     CHECK_EXCEPTION();
<a name="72" id="anc72"></a><span class="line-modified"> 557     auto rightNumeric = right.toNumeric(exec);</span>
 558     CHECK_EXCEPTION();
 559 
 560     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 561         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="73" id="anc73"></a><span class="line-modified"> 562             JSBigInt* result = JSBigInt::sub(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 563             CHECK_EXCEPTION();
 564             RETURN_WITH_PROFILING(result, {
<a name="74" id="anc74"></a><span class="line-modified"> 565                 updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
 566             });
 567         }
 568 
<a name="75" id="anc75"></a><span class="line-modified"> 569         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in subtraction.&quot;));</span>
 570     }
 571 
 572     JSValue result = jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
 573     RETURN_WITH_PROFILING(result, {
<a name="76" id="anc76"></a><span class="line-modified"> 574         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
 575     });
 576 }
 577 
 578 SLOW_PATH_DECL(slow_path_div)
 579 {
 580     BEGIN();
 581     auto bytecode = pc-&gt;as&lt;OpDiv&gt;();
 582     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 583     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="77" id="anc77"></a><span class="line-modified"> 584     auto leftNumeric = left.toNumeric(exec);</span>
 585     CHECK_EXCEPTION();
<a name="78" id="anc78"></a><span class="line-modified"> 586     auto rightNumeric = right.toNumeric(exec);</span>
 587     CHECK_EXCEPTION();
 588 
 589     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 590         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="79" id="anc79"></a><span class="line-modified"> 591             JSBigInt* result = JSBigInt::divide(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 592             CHECK_EXCEPTION();
 593             RETURN_WITH_PROFILING(result, {
<a name="80" id="anc80"></a><span class="line-modified"> 594                 updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
 595             });
 596         }
 597 
<a name="81" id="anc81"></a><span class="line-modified"> 598         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in division.&quot;));</span>
 599     }
 600 
 601     double a = WTF::get&lt;double&gt;(leftNumeric);
 602     double b = WTF::get&lt;double&gt;(rightNumeric);
 603     JSValue result = jsNumber(a / b);
 604     RETURN_WITH_PROFILING(result, {
<a name="82" id="anc82"></a><span class="line-modified"> 605         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
 606     });
 607 }
 608 
 609 SLOW_PATH_DECL(slow_path_mod)
 610 {
 611     BEGIN();
 612     auto bytecode = pc-&gt;as&lt;OpMod&gt;();
 613     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 614     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="83" id="anc83"></a><span class="line-modified"> 615     auto leftNumeric = left.toNumeric(exec);</span>
 616     CHECK_EXCEPTION();
<a name="84" id="anc84"></a><span class="line-modified"> 617     auto rightNumeric = right.toNumeric(exec);</span>
 618     CHECK_EXCEPTION();
 619 
 620     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 621         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="85" id="anc85"></a><span class="line-modified"> 622             JSBigInt* result = JSBigInt::remainder(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 623             CHECK_EXCEPTION();
 624             RETURN(result);
 625         }
 626 
<a name="86" id="anc86"></a><span class="line-modified"> 627         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;));</span>
 628     }
 629 
 630     double a = WTF::get&lt;double&gt;(leftNumeric);
 631     double b = WTF::get&lt;double&gt;(rightNumeric);
 632     RETURN(jsNumber(jsMod(a, b)));
 633 }
 634 
 635 SLOW_PATH_DECL(slow_path_pow)
 636 {
 637     BEGIN();
 638     auto bytecode = pc-&gt;as&lt;OpPow&gt;();
 639     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 640     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="87" id="anc87"></a><span class="line-modified"> 641     auto leftNumeric = left.toNumeric(exec);</span>
 642     CHECK_EXCEPTION();
<a name="88" id="anc88"></a><span class="line-modified"> 643     auto rightNumeric = right.toNumeric(exec);</span>
 644     CHECK_EXCEPTION();
 645 
 646     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 647         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="89" id="anc89"></a><span class="line-modified"> 648             JSBigInt* result = JSBigInt::exponentiate(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 649             CHECK_EXCEPTION();
 650             RETURN(result);
 651         }
 652 
<a name="90" id="anc90"></a><span class="line-modified"> 653         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;));</span>
 654     }
 655 
 656     double a = WTF::get&lt;double&gt;(leftNumeric);
 657     double b = WTF::get&lt;double&gt;(rightNumeric);
 658 
 659     RETURN(jsNumber(operationMathPow(a, b)));
 660 }
 661 
 662 SLOW_PATH_DECL(slow_path_lshift)
 663 {
 664     BEGIN();
 665     auto bytecode = pc-&gt;as&lt;OpLshift&gt;();
 666     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 667     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="91" id="anc91"></a><span class="line-modified"> 668     auto leftNumeric = left.toBigIntOrInt32(exec);</span>
 669     CHECK_EXCEPTION();
<a name="92" id="anc92"></a><span class="line-modified"> 670     auto rightNumeric = right.toBigIntOrInt32(exec);</span>
 671     CHECK_EXCEPTION();
 672 
 673     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 674         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="93" id="anc93"></a><span class="line-modified"> 675             JSBigInt* result = JSBigInt::leftShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 676             CHECK_EXCEPTION();
 677             RETURN_PROFILED(result);
 678         }
 679 
<a name="94" id="anc94"></a><span class="line-modified"> 680         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;));</span>
 681     }
 682 
 683     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &lt;&lt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));
 684 }
 685 
 686 SLOW_PATH_DECL(slow_path_rshift)
 687 {
 688     BEGIN();
 689     auto bytecode = pc-&gt;as&lt;OpRshift&gt;();
 690     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 691     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="95" id="anc95"></a><span class="line-modified"> 692     auto leftNumeric = left.toBigIntOrInt32(exec);</span>
 693     CHECK_EXCEPTION();
<a name="96" id="anc96"></a><span class="line-modified"> 694     auto rightNumeric = right.toBigIntOrInt32(exec);</span>
 695     CHECK_EXCEPTION();
 696 
 697     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 698         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="97" id="anc97"></a><span class="line-modified"> 699             JSBigInt* result = JSBigInt::signedRightShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 700             CHECK_EXCEPTION();
<a name="98" id="anc98"></a><span class="line-modified"> 701             RETURN(result);</span>
 702         }
 703 
<a name="99" id="anc99"></a><span class="line-modified"> 704         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in signed right shift operation.&quot;));</span>
 705     }
 706 
<a name="100" id="anc100"></a><span class="line-modified"> 707     RETURN(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &gt;&gt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));</span>
 708 }
 709 
 710 SLOW_PATH_DECL(slow_path_urshift)
 711 {
 712     BEGIN();
 713     auto bytecode = pc-&gt;as&lt;OpUrshift&gt;();
<a name="101" id="anc101"></a><span class="line-modified"> 714     uint32_t a = GET_C(bytecode.m_lhs).jsValue().toUInt32(exec);</span>
 715     if (UNLIKELY(throwScope.exception()))
 716         RETURN(JSValue());
<a name="102" id="anc102"></a><span class="line-modified"> 717     uint32_t b = GET_C(bytecode.m_rhs).jsValue().toUInt32(exec);</span>
 718     RETURN(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 31))));
 719 }
 720 
 721 SLOW_PATH_DECL(slow_path_unsigned)
 722 {
 723     BEGIN();
 724     auto bytecode = pc-&gt;as&lt;OpUnsigned&gt;();
<a name="103" id="anc103"></a><span class="line-modified"> 725     uint32_t a = GET_C(bytecode.m_operand).jsValue().toUInt32(exec);</span>
 726     RETURN(jsNumber(a));
 727 }
 728 
 729 SLOW_PATH_DECL(slow_path_bitnot)
 730 {
 731     BEGIN();
 732     auto bytecode = pc-&gt;as&lt;OpBitnot&gt;();
<a name="104" id="anc104"></a><span class="line-modified"> 733     auto operandNumeric = GET_C(bytecode.m_operand).jsValue().toBigIntOrInt32(exec);</span>
 734     CHECK_EXCEPTION();
 735 
 736     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric)) {
<a name="105" id="anc105"></a><span class="line-modified"> 737         JSBigInt* result = JSBigInt::bitwiseNot(exec, WTF::get&lt;JSBigInt*&gt;(operandNumeric));</span>
 738         CHECK_EXCEPTION();
 739         RETURN_PROFILED(result);
 740     }
 741 
 742     RETURN_PROFILED(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
 743 }
 744 
 745 SLOW_PATH_DECL(slow_path_bitand)
 746 {
 747     BEGIN();
 748     auto bytecode = pc-&gt;as&lt;OpBitand&gt;();
<a name="106" id="anc106"></a><span class="line-modified"> 749     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);</span>
 750     CHECK_EXCEPTION();
<a name="107" id="anc107"></a><span class="line-modified"> 751     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);</span>
 752     CHECK_EXCEPTION();
 753     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 754         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="108" id="anc108"></a><span class="line-modified"> 755             JSBigInt* result = JSBigInt::bitwiseAnd(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 756             CHECK_EXCEPTION();
 757             RETURN_PROFILED(result);
 758         }
 759 
<a name="109" id="anc109"></a><span class="line-modified"> 760         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;));</span>
 761     }
 762 
 763     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &amp; WTF::get&lt;int32_t&gt;(rightNumeric)));
 764 }
 765 
 766 SLOW_PATH_DECL(slow_path_bitor)
 767 {
 768     BEGIN();
 769     auto bytecode = pc-&gt;as&lt;OpBitor&gt;();
<a name="110" id="anc110"></a><span class="line-modified"> 770     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);</span>
 771     CHECK_EXCEPTION();
<a name="111" id="anc111"></a><span class="line-modified"> 772     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);</span>
 773     CHECK_EXCEPTION();
 774     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 775         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="112" id="anc112"></a><span class="line-modified"> 776             JSBigInt* result = JSBigInt::bitwiseOr(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 777             CHECK_EXCEPTION();
 778             RETURN_PROFILED(result);
 779         }
 780 
<a name="113" id="anc113"></a><span class="line-modified"> 781         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;));</span>
 782     }
 783 
 784     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) | WTF::get&lt;int32_t&gt;(rightNumeric)));
 785 }
 786 
 787 SLOW_PATH_DECL(slow_path_bitxor)
 788 {
 789     BEGIN();
 790     auto bytecode = pc-&gt;as&lt;OpBitxor&gt;();
<a name="114" id="anc114"></a><span class="line-modified"> 791     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);</span>
 792     CHECK_EXCEPTION();
<a name="115" id="anc115"></a><span class="line-modified"> 793     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);</span>
 794     CHECK_EXCEPTION();
 795     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 796         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="116" id="anc116"></a><span class="line-modified"> 797             JSBigInt* result = JSBigInt::bitwiseXor(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 798             CHECK_EXCEPTION();
 799             RETURN_PROFILED(result);
 800         }
 801 
<a name="117" id="anc117"></a><span class="line-modified"> 802         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;));</span>
 803     }
 804 
 805     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) ^ WTF::get&lt;int32_t&gt;(rightNumeric)));
 806 }
 807 
 808 SLOW_PATH_DECL(slow_path_typeof)
 809 {
 810     BEGIN();
 811     auto bytecode = pc-&gt;as&lt;OpTypeof&gt;();
<a name="118" id="anc118"></a><span class="line-modified"> 812     RETURN(jsTypeStringForValue(exec, GET_C(bytecode.m_value).jsValue()));</span>
 813 }
 814 
 815 SLOW_PATH_DECL(slow_path_is_object_or_null)
 816 {
 817     BEGIN();
 818     auto bytecode = pc-&gt;as&lt;OpIsObjectOrNull&gt;();
<a name="119" id="anc119"></a><span class="line-modified"> 819     RETURN(jsBoolean(jsIsObjectTypeOrNull(exec, GET_C(bytecode.m_operand).jsValue())));</span>
 820 }
 821 
 822 SLOW_PATH_DECL(slow_path_is_function)
 823 {
 824     BEGIN();
 825     auto bytecode = pc-&gt;as&lt;OpIsFunction&gt;();
 826     RETURN(jsBoolean(GET_C(bytecode.m_operand).jsValue().isFunction(vm)));
 827 }
 828 
 829 SLOW_PATH_DECL(slow_path_in_by_val)
 830 {
 831     BEGIN();
 832     auto bytecode = pc-&gt;as&lt;OpInByVal&gt;();
<a name="120" id="anc120"></a><span class="line-modified"> 833     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified"> 834     RETURN(jsBoolean(CommonSlowPaths::opInByVal(exec, GET_C(bytecode.m_base).jsValue(), GET_C(bytecode.m_property).jsValue(), &amp;metadata.m_arrayProfile)));</span>
 835 }
 836 
 837 SLOW_PATH_DECL(slow_path_in_by_id)
 838 {
 839     BEGIN();
 840 
 841     auto bytecode = pc-&gt;as&lt;OpInById&gt;();
 842     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 843     if (!baseValue.isObject())
<a name="121" id="anc121"></a><span class="line-modified"> 844         THROW(createInvalidInParameterError(exec, baseValue));</span>
 845 
<a name="122" id="anc122"></a><span class="line-modified"> 846     RETURN(jsBoolean(asObject(baseValue)-&gt;hasProperty(exec, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property))));</span>
 847 }
 848 
 849 SLOW_PATH_DECL(slow_path_del_by_val)
 850 {
 851     BEGIN();
 852     auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
 853     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
<a name="123" id="anc123"></a><span class="line-modified"> 854     JSObject* baseObject = baseValue.toObject(exec);</span>
 855     CHECK_EXCEPTION();
 856 
 857     JSValue subscript = GET_C(bytecode.m_property).jsValue();
 858 
 859     bool couldDelete;
 860 
 861     uint32_t i;
 862     if (subscript.getUInt32(i))
<a name="124" id="anc124"></a><span class="line-modified"> 863         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, exec, i);</span>
 864     else {
 865         CHECK_EXCEPTION();
<a name="125" id="anc125"></a><span class="line-modified"> 866         auto property = subscript.toPropertyKey(exec);</span>
 867         CHECK_EXCEPTION();
<a name="126" id="anc126"></a><span class="line-modified"> 868         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, property);</span>
 869     }
<a name="127" id="anc127"></a>
 870 
<a name="128" id="anc128"></a><span class="line-modified"> 871     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())</span>
<span class="line-modified"> 872         THROW(createTypeError(exec, UnableToDeletePropertyError));</span>
 873 
 874     RETURN(jsBoolean(couldDelete));
 875 }
 876 
 877 SLOW_PATH_DECL(slow_path_strcat)
 878 {
 879     BEGIN();
 880     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
<a name="129" id="anc129"></a><span class="line-modified"> 881     RETURN(jsStringFromRegisterArray(exec, &amp;GET(bytecode.m_src), bytecode.m_count));</span>
 882 }
 883 
 884 SLOW_PATH_DECL(slow_path_to_primitive)
 885 {
 886     BEGIN();
 887     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
<a name="130" id="anc130"></a><span class="line-modified"> 888     RETURN(GET_C(bytecode.m_src).jsValue().toPrimitive(exec));</span>














 889 }
 890 
 891 SLOW_PATH_DECL(slow_path_get_enumerable_length)
 892 {
 893     BEGIN();
 894     auto bytecode = pc-&gt;as&lt;OpGetEnumerableLength&gt;();
 895     JSValue enumeratorValue = GET(bytecode.m_base).jsValue();
 896     if (enumeratorValue.isUndefinedOrNull())
 897         RETURN(jsNumber(0));
 898 
 899     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(enumeratorValue.asCell());
 900 
 901     RETURN(jsNumber(enumerator-&gt;indexedLength()));
 902 }
 903 
 904 SLOW_PATH_DECL(slow_path_has_indexed_property)
 905 {
 906     BEGIN();
 907     auto bytecode = pc-&gt;as&lt;OpHasIndexedProperty&gt;();
<a name="131" id="anc131"></a><span class="line-modified"> 908     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified"> 909     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);</span>
 910     CHECK_EXCEPTION();
 911     JSValue property = GET(bytecode.m_property).jsValue();
 912     metadata.m_arrayProfile.observeStructure(base-&gt;structure(vm));
 913     ASSERT(property.isUInt32AsAnyInt());
<a name="132" id="anc132"></a><span class="line-modified"> 914     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, property.asUInt32AsAnyInt(), PropertySlot::InternalMethodType::GetOwnProperty)));</span>
 915 }
 916 
 917 SLOW_PATH_DECL(slow_path_has_structure_property)
 918 {
 919     BEGIN();
 920     auto bytecode = pc-&gt;as&lt;OpHasStructureProperty&gt;();
<a name="133" id="anc133"></a><span class="line-modified"> 921     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);</span>
 922     CHECK_EXCEPTION();
 923     JSValue property = GET(bytecode.m_property).jsValue();
 924     ASSERT(property.isString());
 925     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 926     if (base-&gt;structure(vm)-&gt;id() == enumerator-&gt;cachedStructureID())
 927         RETURN(jsBoolean(true));
 928     JSString* string = asString(property);
<a name="134" id="anc134"></a><span class="line-modified"> 929     auto propertyName = string-&gt;toIdentifier(exec);</span>
 930     CHECK_EXCEPTION();
<a name="135" id="anc135"></a><span class="line-modified"> 931     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
 932 }
 933 
 934 SLOW_PATH_DECL(slow_path_has_generic_property)
 935 {
 936     BEGIN();
 937     auto bytecode = pc-&gt;as&lt;OpHasGenericProperty&gt;();
<a name="136" id="anc136"></a><span class="line-modified"> 938     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);</span>
 939     CHECK_EXCEPTION();
 940     JSValue property = GET(bytecode.m_property).jsValue();
 941     ASSERT(property.isString());
 942     JSString* string = asString(property);
<a name="137" id="anc137"></a><span class="line-modified"> 943     auto propertyName = string-&gt;toIdentifier(exec);</span>
 944     CHECK_EXCEPTION();
<a name="138" id="anc138"></a><span class="line-modified"> 945     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
 946 }
 947 
 948 SLOW_PATH_DECL(slow_path_get_direct_pname)
 949 {
 950     BEGIN();
 951     auto bytecode = pc-&gt;as&lt;OpGetDirectPname&gt;();
 952     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 953     JSValue property = GET(bytecode.m_property).jsValue();
 954     ASSERT(property.isString());
 955     JSString* string = asString(property);
<a name="139" id="anc139"></a><span class="line-modified"> 956     auto propertyName = string-&gt;toIdentifier(exec);</span>
 957     CHECK_EXCEPTION();
<a name="140" id="anc140"></a><span class="line-modified"> 958     RETURN(baseValue.get(exec, propertyName));</span>
 959 }
 960 
 961 SLOW_PATH_DECL(slow_path_get_property_enumerator)
 962 {
 963     BEGIN();
 964     auto bytecode = pc-&gt;as&lt;OpGetPropertyEnumerator&gt;();
 965     JSValue baseValue = GET(bytecode.m_base).jsValue();
 966     if (baseValue.isUndefinedOrNull())
 967         RETURN(vm.emptyPropertyNameEnumerator());
 968 
<a name="141" id="anc141"></a><span class="line-modified"> 969     JSObject* base = baseValue.toObject(exec);</span>
 970     CHECK_EXCEPTION();
 971 
<a name="142" id="anc142"></a><span class="line-modified"> 972     RETURN(propertyNameEnumerator(exec, base));</span>
 973 }
 974 
 975 SLOW_PATH_DECL(slow_path_enumerator_structure_pname)
 976 {
 977     BEGIN();
 978     auto bytecode = pc-&gt;as&lt;OpEnumeratorStructurePname&gt;();
 979     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 980     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
 981 
 982     JSString* propertyName = nullptr;
 983     if (index &lt; enumerator-&gt;endStructurePropertyIndex())
 984         propertyName = enumerator-&gt;propertyNameAtIndex(index);
 985     RETURN(propertyName ? propertyName : jsNull());
 986 }
 987 
 988 SLOW_PATH_DECL(slow_path_enumerator_generic_pname)
 989 {
 990     BEGIN();
 991     auto bytecode = pc-&gt;as&lt;OpEnumeratorGenericPname&gt;();
 992     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 993     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
 994 
 995     JSString* propertyName = nullptr;
 996     if (enumerator-&gt;endStructurePropertyIndex() &lt;= index &amp;&amp; index &lt; enumerator-&gt;endGenericPropertyIndex())
 997         propertyName = enumerator-&gt;propertyNameAtIndex(index);
 998     RETURN(propertyName ? propertyName : jsNull());
 999 }
1000 
1001 SLOW_PATH_DECL(slow_path_to_index_string)
1002 {
1003     BEGIN();
1004     auto bytecode = pc-&gt;as&lt;OpToIndexString&gt;();
1005     JSValue indexValue = GET(bytecode.m_index).jsValue();
1006     ASSERT(indexValue.isUInt32AsAnyInt());
1007     RETURN(jsString(vm, Identifier::from(vm, indexValue.asUInt32AsAnyInt()).string()));
1008 }
1009 
1010 SLOW_PATH_DECL(slow_path_profile_type_clear_log)
1011 {
1012     BEGIN();
1013     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;LLInt log full.&quot;_s);
1014     END();
1015 }
1016 
1017 SLOW_PATH_DECL(slow_path_unreachable)
1018 {
1019     BEGIN();
1020     UNREACHABLE_FOR_PLATFORM();
1021     END();
1022 }
1023 
1024 SLOW_PATH_DECL(slow_path_create_lexical_environment)
1025 {
1026     BEGIN();
1027     auto bytecode = pc-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
<a name="143" id="anc143"></a><span class="line-modified">1028     int scopeReg = bytecode.m_scope.offset();</span>
<span class="line-removed">1029     JSScope* currentScope = exec-&gt;uncheckedR(scopeReg).Register::scope();</span>
1030     SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(GET_C(bytecode.m_symbolTable).jsValue());
1031     JSValue initialValue = GET_C(bytecode.m_initialValue).jsValue();
1032     ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
<a name="144" id="anc144"></a><span class="line-modified">1033     JSScope* newScope = JSLexicalEnvironment::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, symbolTable, initialValue);</span>
1034     RETURN(newScope);
1035 }
1036 
1037 SLOW_PATH_DECL(slow_path_push_with_scope)
1038 {
1039     BEGIN();
1040     auto bytecode = pc-&gt;as&lt;OpPushWithScope&gt;();
<a name="145" id="anc145"></a><span class="line-modified">1041     JSObject* newScope = GET_C(bytecode.m_newScope).jsValue().toObject(exec);</span>
1042     CHECK_EXCEPTION();
1043 
<a name="146" id="anc146"></a><span class="line-modified">1044     int scopeReg = bytecode.m_currentScope.offset();</span>
<span class="line-modified">1045     JSScope* currentScope = exec-&gt;uncheckedR(scopeReg).Register::scope();</span>
<span class="line-removed">1046     RETURN(JSWithScope::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, newScope));</span>
1047 }
1048 
1049 SLOW_PATH_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval)
1050 {
1051     BEGIN();
1052     auto bytecode = pc-&gt;as&lt;OpResolveScopeForHoistingFuncDeclInEval&gt;();
<a name="147" id="anc147"></a><span class="line-modified">1053     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);</span>
<span class="line-modified">1054     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();</span>
<span class="line-modified">1055     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, ident);</span>
1056 
1057     CHECK_EXCEPTION();
1058 
1059     RETURN(resolvedScope);
1060 }
1061 
1062 SLOW_PATH_DECL(slow_path_resolve_scope)
1063 {
1064     BEGIN();
1065     auto bytecode = pc-&gt;as&lt;OpResolveScope&gt;();
<a name="148" id="anc148"></a><span class="line-modified">1066     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">1067     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
1068     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<a name="149" id="anc149"></a><span class="line-modified">1069     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();</span>
<span class="line-modified">1070     JSObject* resolvedScope = JSScope::resolve(exec, scope, ident);</span>
1071     // Proxy can throw an error here, e.g. Proxy in with statement&#39;s @unscopables.
1072     CHECK_EXCEPTION();
1073 
1074     ResolveType resolveType = metadata.m_resolveType;
1075 
1076     // ModuleVar does not keep the scope register value alive in DFG.
1077     ASSERT(resolveType != ModuleVar);
1078 
1079     switch (resolveType) {
1080     case GlobalProperty:
1081     case GlobalPropertyWithVarInjectionChecks:
1082     case UnresolvedProperty:
1083     case UnresolvedPropertyWithVarInjectionChecks: {
1084         if (resolvedScope-&gt;isGlobalObject()) {
1085             JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(resolvedScope);
<a name="150" id="anc150"></a><span class="line-modified">1086             bool hasProperty = globalObject-&gt;hasProperty(exec, ident);</span>
1087             CHECK_EXCEPTION();
1088             if (hasProperty) {
1089                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1090                 metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
1091                 metadata.m_globalObject.set(vm, codeBlock, globalObject);
1092                 metadata.m_globalLexicalBindingEpoch = globalObject-&gt;globalLexicalBindingEpoch();
1093             }
1094         } else if (resolvedScope-&gt;isGlobalLexicalEnvironment()) {
1095             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(resolvedScope);
1096             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1097             metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;
1098             metadata.m_globalLexicalEnvironment.set(vm, codeBlock, globalLexicalEnvironment);
1099         }
1100         break;
1101     }
1102     default:
1103         break;
1104     }
1105 
1106     RETURN(resolvedScope);
1107 }
1108 
1109 SLOW_PATH_DECL(slow_path_create_rest)
1110 {
1111     BEGIN();
1112     auto bytecode = pc-&gt;as&lt;OpCreateRest&gt;();
1113     unsigned arraySize = GET_C(bytecode.m_arraySize).jsValue().asUInt32();
<a name="151" id="anc151"></a><span class="line-removed">1114     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
1115     Structure* structure = globalObject-&gt;restParameterStructure();
1116     unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
<a name="152" id="anc152"></a><span class="line-modified">1117     JSValue* argumentsToCopyRegion = exec-&gt;addressOfArgumentsStart() + numParamsToSkip;</span>
<span class="line-modified">1118     RETURN(constructArray(exec, structure, argumentsToCopyRegion, arraySize));</span>
1119 }
1120 
1121 SLOW_PATH_DECL(slow_path_get_by_id_with_this)
1122 {
1123     BEGIN();
1124     auto bytecode = pc-&gt;as&lt;OpGetByIdWithThis&gt;();
<a name="153" id="anc153"></a><span class="line-modified">1125     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);</span>
1126     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1127     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1128     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
<a name="154" id="anc154"></a><span class="line-modified">1129     JSValue result = baseValue.get(exec, ident, slot);</span>
1130     RETURN_PROFILED(result);
1131 }
1132 
1133 SLOW_PATH_DECL(slow_path_get_by_val_with_this)
1134 {
1135     BEGIN();
1136 
1137     auto bytecode = pc-&gt;as&lt;OpGetByValWithThis&gt;();
1138     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1139     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1140     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1141 
1142     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1143         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1144         if (JSCell::canUseFastGetOwnProperty(structure)) {
<a name="155" id="anc155"></a><span class="line-modified">1145             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
1146             CHECK_EXCEPTION();
1147             if (existingAtomString) {
1148                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
1149                     RETURN_PROFILED(result);
1150             }
1151         }
1152     }
1153 
1154     PropertySlot slot(thisValue, PropertySlot::PropertySlot::InternalMethodType::Get);
1155     if (subscript.isUInt32()) {
1156         uint32_t i = subscript.asUInt32();
1157         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
<a name="156" id="anc156"></a><span class="line-modified">1158             RETURN_PROFILED(asString(baseValue)-&gt;getIndex(exec, i));</span>
1159 
<a name="157" id="anc157"></a><span class="line-modified">1160         RETURN_PROFILED(baseValue.get(exec, i, slot));</span>
1161     }
1162 
<a name="158" id="anc158"></a><span class="line-modified">1163     baseValue.requireObjectCoercible(exec);</span>
1164     CHECK_EXCEPTION();
<a name="159" id="anc159"></a><span class="line-modified">1165     auto property = subscript.toPropertyKey(exec);</span>
1166     CHECK_EXCEPTION();
<a name="160" id="anc160"></a><span class="line-modified">1167     RETURN_PROFILED(baseValue.get(exec, property, slot));</span>
1168 }
1169 
1170 SLOW_PATH_DECL(slow_path_put_by_id_with_this)
1171 {
1172     BEGIN();
1173     auto bytecode = pc-&gt;as&lt;OpPutByIdWithThis&gt;();
<a name="161" id="anc161"></a><span class="line-removed">1174     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
1175     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
1176     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1177     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1178     JSValue putValue = GET_C(bytecode.m_value).jsValue();
1179     PutPropertySlot slot(thisVal, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
<a name="162" id="anc162"></a><span class="line-modified">1180     baseValue.putInline(exec, ident, putValue, slot);</span>
1181     END();
1182 }
1183 
1184 SLOW_PATH_DECL(slow_path_put_by_val_with_this)
1185 {
1186     BEGIN();
1187     auto bytecode = pc-&gt;as&lt;OpPutByValWithThis&gt;();
1188     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1189     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1190     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1191     JSValue value = GET_C(bytecode.m_value).jsValue();
1192 
<a name="163" id="anc163"></a><span class="line-modified">1193     auto property = subscript.toPropertyKey(exec);</span>
1194     CHECK_EXCEPTION();
<a name="164" id="anc164"></a><span class="line-modified">1195     PutPropertySlot slot(thisValue, exec-&gt;codeBlock()-&gt;isStrictMode());</span>
<span class="line-modified">1196     baseValue.put(exec, property, value, slot);</span>
1197     END();
1198 }
1199 
1200 SLOW_PATH_DECL(slow_path_define_data_property)
1201 {
1202     BEGIN();
1203     auto bytecode = pc-&gt;as&lt;OpDefineDataProperty&gt;();
1204     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1205     JSValue property = GET_C(bytecode.m_property).jsValue();
1206     JSValue value = GET_C(bytecode.m_value).jsValue();
1207     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1208     ASSERT(attributes.isInt32());
1209 
<a name="165" id="anc165"></a><span class="line-modified">1210     auto propertyName = property.toPropertyKey(exec);</span>
1211     CHECK_EXCEPTION();
1212     PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes.asInt32()));
1213     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
<a name="166" id="anc166"></a><span class="line-modified">1214     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
1215     END();
1216 }
1217 
1218 SLOW_PATH_DECL(slow_path_define_accessor_property)
1219 {
1220     BEGIN();
1221     auto bytecode = pc-&gt;as&lt;OpDefineAccessorProperty&gt;();
1222     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1223     JSValue property = GET_C(bytecode.m_property).jsValue();
1224     JSValue getter = GET_C(bytecode.m_getter).jsValue();
1225     JSValue setter = GET_C(bytecode.m_setter).jsValue();
1226     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1227     ASSERT(attributes.isInt32());
1228 
<a name="167" id="anc167"></a><span class="line-modified">1229     auto propertyName = property.toPropertyKey(exec);</span>
1230     CHECK_EXCEPTION();
1231     PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes.asInt32()));
1232     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
<a name="168" id="anc168"></a><span class="line-modified">1233     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
1234     END();
1235 }
1236 
1237 SLOW_PATH_DECL(slow_path_throw_static_error)
1238 {
1239     BEGIN();
1240     auto bytecode = pc-&gt;as&lt;OpThrowStaticError&gt;();
1241     JSValue errorMessageValue = GET_C(bytecode.m_message).jsValue();
1242     RELEASE_ASSERT(errorMessageValue.isString());
<a name="169" id="anc169"></a><span class="line-modified">1243     String errorMessage = asString(errorMessageValue)-&gt;value(exec);</span>
1244     ErrorType errorType = bytecode.m_errorType;
<a name="170" id="anc170"></a><span class="line-modified">1245     THROW(createError(exec, errorType, errorMessage));</span>
1246 }
1247 
1248 SLOW_PATH_DECL(slow_path_new_array_with_spread)
1249 {
1250     BEGIN();
1251     auto bytecode = pc-&gt;as&lt;OpNewArrayWithSpread&gt;();
1252     int numItems = bytecode.m_argc;
1253     ASSERT(numItems &gt;= 0);
<a name="171" id="anc171"></a><span class="line-modified">1254     const BitVector&amp; bitVector = exec-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;bitVector(bytecode.m_bitVector);</span>
1255 
1256     JSValue* values = bitwise_cast&lt;JSValue*&gt;(&amp;GET(bytecode.m_argv));
1257 
<a name="172" id="anc172"></a>







1258     Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
1259     for (int i = 0; i &lt; numItems; i++) {
1260         if (bitVector.get(i)) {
1261             JSValue value = values[-i];
<a name="173" id="anc173"></a><span class="line-modified">1262             JSFixedArray* array = jsCast&lt;JSFixedArray*&gt;(value);</span>
<span class="line-modified">1263             checkedArraySize += array-&gt;size();</span>
1264         } else
1265             checkedArraySize += 1;
1266     }
1267     if (UNLIKELY(checkedArraySize.hasOverflowed()))
<a name="174" id="anc174"></a><span class="line-modified">1268         THROW(createOutOfMemoryError(exec));</span>
1269 
1270     unsigned arraySize = checkedArraySize.unsafeGet();
1271     if (UNLIKELY(arraySize &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH))
<a name="175" id="anc175"></a><span class="line-modified">1272         THROW(createOutOfMemoryError(exec));</span>
1273 
<a name="176" id="anc176"></a><span class="line-removed">1274     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
1275     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
1276 
1277     JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
1278     if (UNLIKELY(!result))
<a name="177" id="anc177"></a><span class="line-modified">1279         THROW(createOutOfMemoryError(exec));</span>
1280     CHECK_EXCEPTION();
1281 
1282     unsigned index = 0;
1283     for (int i = 0; i &lt; numItems; i++) {
1284         JSValue value = values[-i];
1285         if (bitVector.get(i)) {
1286             // We are spreading.
<a name="178" id="anc178"></a><span class="line-modified">1287             JSFixedArray* array = jsCast&lt;JSFixedArray*&gt;(value);</span>
<span class="line-modified">1288             for (unsigned i = 0; i &lt; array-&gt;size(); i++) {</span>
1289                 RELEASE_ASSERT(array-&gt;get(i));
<a name="179" id="anc179"></a><span class="line-modified">1290                 result-&gt;putDirectIndex(exec, index, array-&gt;get(i));</span>
1291                 CHECK_EXCEPTION();
1292                 ++index;
1293             }
1294         } else {
1295             // We are not spreading.
<a name="180" id="anc180"></a><span class="line-modified">1296             result-&gt;putDirectIndex(exec, index, value);</span>
1297             CHECK_EXCEPTION();
1298             ++index;
1299         }
1300     }
1301 
1302     RETURN(result);
1303 }
1304 
1305 SLOW_PATH_DECL(slow_path_new_array_buffer)
1306 {
1307     BEGIN();
1308     auto bytecode = pc-&gt;as&lt;OpNewArrayBuffer&gt;();
<a name="181" id="anc181"></a><span class="line-modified">1309     ASSERT(exec-&gt;codeBlock()-&gt;isConstantRegisterIndex(bytecode.m_immutableButterfly.offset()));</span>
1310     JSImmutableButterfly* immutableButterfly = bitwise_cast&lt;JSImmutableButterfly*&gt;(GET_C(bytecode.m_immutableButterfly).jsValue().asCell());
<a name="182" id="anc182"></a><span class="line-modified">1311     auto&amp; profile = bytecode.metadata(exec).m_arrayAllocationProfile;</span>
1312 
1313     IndexingType indexingMode = profile.selectIndexingType();
<a name="183" id="anc183"></a><span class="line-modified">1314     Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);</span>
1315     ASSERT(isCopyOnWrite(indexingMode));
1316     ASSERT(!structure-&gt;outOfLineCapacity());
1317 
1318     if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
1319         auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
1320         for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); ++i)
1321             newButterfly-&gt;setIndex(vm, i, immutableButterfly-&gt;get(i));
1322         immutableButterfly = newButterfly;
<a name="184" id="anc184"></a><span class="line-removed">1323         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
1324 
1325         // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
1326         // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
1327         // a compilation thread.
1328         WTF::storeStoreFence();
<a name="185" id="anc185"></a><span class="line-modified">1329         codeBlock-&gt;constantRegister(bytecode.m_immutableButterfly.offset()).set(vm, codeBlock, immutableButterfly);</span>
1330         WTF::storeStoreFence();
1331     }
1332 
1333     JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
<a name="186" id="anc186"></a><span class="line-modified">1334     ASSERT(isCopyOnWrite(result-&gt;indexingMode()) || exec-&gt;lexicalGlobalObject()-&gt;isHavingABadTime());</span>
1335     ArrayAllocationProfile::updateLastAllocationFor(&amp;profile, result);
1336     RETURN(result);
1337 }
1338 
1339 SLOW_PATH_DECL(slow_path_spread)
1340 {
1341     BEGIN();
1342 
1343     auto bytecode = pc-&gt;as&lt;OpSpread&gt;();
1344     JSValue iterable = GET_C(bytecode.m_argument).jsValue();
1345 
1346     if (iterable.isCell() &amp;&amp; isJSArray(iterable.asCell())) {
1347         JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
1348         if (array-&gt;isIteratorProtocolFastAndNonObservable()) {
<a name="187" id="anc187"></a><span class="line-modified">1349             // JSFixedArray::createFromArray does not consult the prototype chain,</span>
1350             // so we must be sure that not consulting the prototype chain would
1351             // produce the same value during iteration.
<a name="188" id="anc188"></a><span class="line-modified">1352             RETURN(JSFixedArray::createFromArray(exec, vm, array));</span>
1353         }
1354     }
1355 
<a name="189" id="anc189"></a><span class="line-removed">1356     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">1357 </span>
1358     JSArray* array;
1359     {
1360         JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
1361         CallData callData;
1362         CallType callType = JSC::getCallData(vm, iterationFunction, callData);
1363         ASSERT(callType != CallType::None);
1364 
1365         MarkedArgumentBuffer arguments;
1366         arguments.append(iterable);
1367         ASSERT(!arguments.hasOverflowed());
<a name="190" id="anc190"></a><span class="line-modified">1368         JSValue arrayResult = call(exec, iterationFunction, callType, callData, jsNull(), arguments);</span>
1369         CHECK_EXCEPTION();
1370         array = jsCast&lt;JSArray*&gt;(arrayResult);
1371     }
1372 
<a name="191" id="anc191"></a><span class="line-modified">1373     RETURN(JSFixedArray::createFromArray(exec, vm, array));</span>
1374 }
1375 
1376 } // namespace JSC
<a name="192" id="anc192"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="192" type="hidden" />
</body>
</html>
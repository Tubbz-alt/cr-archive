<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/Database.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2007, 2008, 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;Database.h&quot;
 31 
 32 #include &quot;ChangeVersionData.h&quot;
 33 #include &quot;ChangeVersionWrapper.h&quot;
 34 #include &quot;DOMWindow.h&quot;
 35 #include &quot;DatabaseAuthorizer.h&quot;
 36 #include &quot;DatabaseCallback.h&quot;
 37 #include &quot;DatabaseContext.h&quot;
 38 #include &quot;DatabaseManager.h&quot;
 39 #include &quot;DatabaseTask.h&quot;
 40 #include &quot;DatabaseThread.h&quot;
 41 #include &quot;DatabaseTracker.h&quot;
 42 #include &quot;Document.h&quot;
 43 #include &quot;JSDOMWindow.h&quot;
 44 #include &quot;Logging.h&quot;
 45 #include &quot;SQLError.h&quot;
 46 #include &quot;SQLTransaction.h&quot;
 47 #include &quot;SQLTransactionCallback.h&quot;
 48 #include &quot;SQLTransactionErrorCallback.h&quot;
 49 #include &quot;SQLiteDatabaseTracker.h&quot;
 50 #include &quot;SQLiteStatement.h&quot;
 51 #include &quot;SQLiteTransaction.h&quot;
 52 #include &quot;ScriptExecutionContext.h&quot;
 53 #include &quot;SecurityOrigin.h&quot;
 54 #include &quot;VoidCallback.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 55 #include &quot;WindowEventLoop.h&quot;</span>
 56 #include &lt;wtf/NeverDestroyed.h&gt;
 57 #include &lt;wtf/RefPtr.h&gt;
 58 #include &lt;wtf/StdLibExtras.h&gt;
 59 #include &lt;wtf/text/CString.h&gt;
 60 
 61 namespace WebCore {
 62 
 63 // Registering &quot;opened&quot; databases with the DatabaseTracker
 64 // =======================================================
 65 // The DatabaseTracker maintains a list of databases that have been
 66 // &quot;opened&quot; so that the client can call interrupt or delete on every database
 67 // associated with a DatabaseContext.
 68 //
 69 // We will only call DatabaseTracker::addOpenDatabase() to add the database
 70 // to the tracker as opened when we&#39;ve succeeded in opening the database,
 71 // and will set m_opened to true. Similarly, we only call
 72 // DatabaseTracker::removeOpenDatabase() to remove the database from the
 73 // tracker when we set m_opened to false in closeDatabase(). This sets up
 74 // a simple symmetry between open and close operations, and a direct
 75 // correlation to adding and removing databases from the tracker&#39;s list,
 76 // thus ensuring that we have a correct list for the interrupt and
 77 // delete operations to work on.
 78 //
 79 // The only databases instances not tracked by the tracker&#39;s open database
 80 // list are the ones that have not been added yet, or the ones that we
 81 // attempted an open on but failed to. Such instances only exist in the
 82 // factory functions for creating database backends.
 83 //
 84 // The factory functions will either call openAndVerifyVersion() or
 85 // performOpenAndVerify(). These methods will add the newly instantiated
 86 // database backend if they succeed in opening the requested database.
 87 // In the case of failure to open the database, the factory methods will
 88 // simply discard the newly instantiated database backend when they return.
 89 // The ref counting mechanims will automatically destruct the un-added
 90 // (and un-returned) databases instances.
 91 
 92 static const char versionKey[] = &quot;WebKitDatabaseVersionKey&quot;;
 93 static const char unqualifiedInfoTableName[] = &quot;__WebKitDatabaseInfoTable__&quot;;
 94 const unsigned long long quotaIncreaseSize = 5 * 1024 * 1024;
 95 
 96 static const char* fullyQualifiedInfoTableName()
 97 {
 98     static const char qualifier[] = &quot;main.&quot;;
 99     static char qualifiedName[sizeof(qualifier) + sizeof(unqualifiedInfoTableName) - 1];
100 
101     static std::once_flag onceFlag;
102     std::call_once(onceFlag, [] {
103         snprintf(qualifiedName, sizeof(qualifiedName), &quot;%s%s&quot;, qualifier, unqualifiedInfoTableName);
104     });
105 
106     return qualifiedName;
107 }
108 
109 static String formatErrorMessage(const char* message, int sqliteErrorCode, const char* sqliteErrorMessage)
110 {
111     return makeString(message, &quot; (&quot;, sqliteErrorCode, &#39; &#39;, sqliteErrorMessage, &#39;)&#39;);
112 }
113 
114 static bool setTextValueInDatabase(SQLiteDatabase&amp; db, const String&amp; query, const String&amp; value)
115 {
116     SQLiteStatement statement(db, query);
117     int result = statement.prepare();
118 
119     if (result != SQLITE_OK) {
120         LOG_ERROR(&quot;Failed to prepare statement to set value in database (%s)&quot;, query.ascii().data());
121         return false;
122     }
123 
124     statement.bindText(1, value);
125 
126     result = statement.step();
127     if (result != SQLITE_DONE) {
128         LOG_ERROR(&quot;Failed to step statement to set value in database (%s)&quot;, query.ascii().data());
129         return false;
130     }
131 
132     return true;
133 }
134 
135 static bool retrieveTextResultFromDatabase(SQLiteDatabase&amp; db, const String&amp; query, String&amp; resultString)
136 {
137     SQLiteStatement statement(db, query);
138     int result = statement.prepare();
139 
140     if (result != SQLITE_OK) {
141         LOG_ERROR(&quot;Error (%i) preparing statement to read text result from database (%s)&quot;, result, query.ascii().data());
142         return false;
143     }
144 
145     result = statement.step();
146     if (result == SQLITE_ROW) {
147         resultString = statement.getColumnText(0);
148         return true;
149     }
150     if (result == SQLITE_DONE) {
151         resultString = String();
152         return true;
153     }
154 
155     LOG_ERROR(&quot;Error (%i) reading text result from database (%s)&quot;, result, query.ascii().data());
156     return false;
157 }
158 
159 // FIXME: move all guid-related functions to a DatabaseVersionTracker class.
160 static Lock guidMutex;
161 
162 static HashMap&lt;DatabaseGUID, String&gt;&amp; guidToVersionMap()
163 {
164     static NeverDestroyed&lt;HashMap&lt;DatabaseGUID, String&gt;&gt; map;
165     return map;
166 }
167 
168 // NOTE: Caller must lock guidMutex().
169 static inline void updateGUIDVersionMap(DatabaseGUID guid, const String&amp; newVersion)
170 {
171     // Note: It is not safe to put an empty string into the guidToVersionMap() map.
172     // That&#39;s because the map is cross-thread, but empty strings are per-thread.
173     // The copy() function makes a version of the string you can use on the current
174     // thread, but we need a string we can keep in a cross-thread data structure.
175     // FIXME: This is a quite-awkward restriction to have to program with.
176 
177     // Map empty string to null string (see comment above).
178     guidToVersionMap().set(guid, newVersion.isEmpty() ? String() : newVersion.isolatedCopy());
179 }
180 
181 static HashMap&lt;DatabaseGUID, HashSet&lt;Database*&gt;&gt;&amp; guidToDatabaseMap()
182 {
183     static NeverDestroyed&lt;HashMap&lt;DatabaseGUID, HashSet&lt;Database*&gt;&gt;&gt; map;
184     return map;
185 }
186 
187 static inline DatabaseGUID guidForOriginAndName(const String&amp; origin, const String&amp; name)
188 {
189     static NeverDestroyed&lt;HashMap&lt;String, DatabaseGUID&gt;&gt; map;
190     return map.get().ensure(makeString(origin, &#39;/&#39;, name), [] {
191         static DatabaseGUID lastUsedGUID;
192         return ++lastUsedGUID;
193     }).iterator-&gt;value;
194 }
195 
196 Database::Database(DatabaseContext&amp; context, const String&amp; name, const String&amp; expectedVersion, const String&amp; displayName, unsigned long long estimatedSize)
197     : m_document(*context.document())
198     , m_contextThreadSecurityOrigin(m_document-&gt;securityOrigin().isolatedCopy())
199     , m_databaseThreadSecurityOrigin(m_document-&gt;securityOrigin().isolatedCopy())
200     , m_databaseContext(context)
201     , m_name((name.isNull() ? emptyString() : name).isolatedCopy())
202     , m_expectedVersion(expectedVersion.isolatedCopy())
203     , m_displayName(displayName.isolatedCopy())
204     , m_estimatedSize(estimatedSize)
205     , m_filename(DatabaseManager::singleton().fullPathForDatabase(m_document-&gt;securityOrigin(), m_name))
206     , m_databaseAuthorizer(DatabaseAuthorizer::create(unqualifiedInfoTableName))
207 {
208     {
209         std::lock_guard&lt;Lock&gt; locker(guidMutex);
210 
211         m_guid = guidForOriginAndName(securityOrigin().securityOrigin()-&gt;toString(), name);
212         guidToDatabaseMap().ensure(m_guid, [] {
213             return HashSet&lt;Database*&gt;();
214         }).iterator-&gt;value.add(this);
215     }
216 
217     m_databaseContext-&gt;databaseThread();
218 
219     ASSERT(m_databaseContext-&gt;existingDatabaseThread());
220 }
221 
222 DatabaseThread&amp; Database::databaseThread()
223 {
224     ASSERT(m_databaseContext-&gt;existingDatabaseThread());
225     return *m_databaseContext-&gt;existingDatabaseThread();
226 }
227 
228 Database::~Database()
229 {
230     // The reference to the Document needs to be cleared on the JavaScript thread. If we&#39;re on that thread already, we can just let the RefPtr&#39;s destruction do the dereffing.
231     if (!isMainThread())
232         callOnMainThread([document = WTFMove(m_document), databaseContext = WTFMove(m_databaseContext)] { });
233 
234     // SQLite is &quot;multi-thread safe&quot;, but each database handle can only be used
235     // on a single thread at a time.
236     //
237     // For DatabaseBackend, we open the SQLite database on the DatabaseThread,
238     // and hence we should also close it on that same thread. This means that the
239     // SQLite database need to be closed by another mechanism (see
240     // DatabaseContext::stopDatabases()). By the time we get here, the SQLite
241     // database should have already been closed.
242 
243     ASSERT(!m_opened);
244 }
245 
246 ExceptionOr&lt;void&gt; Database::openAndVerifyVersion(bool setVersionInNewDatabase)
247 {
248     DatabaseTaskSynchronizer synchronizer;
249     auto&amp; thread = databaseThread();
250     if (thread.terminationRequested(&amp;synchronizer))
251         return Exception { InvalidStateError };
252 
253     ExceptionOr&lt;void&gt; result;
254     auto task = makeUnique&lt;DatabaseOpenTask&gt;(*this, setVersionInNewDatabase, synchronizer, result);
255     thread.scheduleImmediateTask(WTFMove(task));
256     synchronizer.waitForTaskCompletion();
257 
258     return result;
259 }
260 
261 void Database::interrupt()
262 {
263     // It is safe to call this from any thread for an opened or closed database.
264     m_sqliteDatabase.interrupt();
265 }
266 
267 void Database::close()
268 {
269     auto&amp; thread = databaseThread();
270 
271     DatabaseTaskSynchronizer synchronizer;
272     if (thread.terminationRequested(&amp;synchronizer)) {
273         LOG(StorageAPI, &quot;Database handle %p is on a terminated DatabaseThread, cannot be marked for normal closure\n&quot;, this);
274         return;
275     }
276 
277     thread.scheduleImmediateTask(makeUnique&lt;DatabaseCloseTask&gt;(*this, synchronizer));
278 
279     // FIXME: iOS depends on this function blocking until the database is closed as part
280     // of closing all open databases from a process assertion expiration handler.
281     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=157184&gt;.
282     synchronizer.waitForTaskCompletion();
283 }
284 
285 void Database::performClose()
286 {
287     ASSERT(databaseThread().getThread() == &amp;Thread::current());
288 
289     {
290         LockHolder locker(m_transactionInProgressMutex);
291 
292         // Clean up transactions that have not been scheduled yet:
293         // Transaction phase 1 cleanup. See comment on &quot;What happens if a
294         // transaction is interrupted?&quot; at the top of SQLTransactionBackend.cpp.
295         while (!m_transactionQueue.isEmpty())
296             m_transactionQueue.takeFirst()-&gt;notifyDatabaseThreadIsShuttingDown();
297 
298         m_isTransactionQueueEnabled = false;
299         m_transactionInProgress = false;
300     }
301 
302     closeDatabase();
303 
304     // DatabaseThread keeps databases alive by referencing them in its
305     // m_openDatabaseSet. DatabaseThread::recordDatabaseClose() will remove
306     // this database from that set (which effectively deref&#39;s it). We hold on
307     // to it with a local pointer here for a liitle longer, so that we can
308     // unschedule any DatabaseTasks that refer to it before the database gets
309     // deleted.
310     Ref&lt;Database&gt; protectedThis(*this);
311     auto&amp; thread = databaseThread();
312     thread.recordDatabaseClosed(*this);
313     thread.unscheduleDatabaseTasks(*this);
314 }
315 
316 class DoneCreatingDatabaseOnExitCaller {
317 public:
318     DoneCreatingDatabaseOnExitCaller(Database&amp; database)
319         : m_database(database)
320     {
321     }
322 
323     ~DoneCreatingDatabaseOnExitCaller()
324     {
325         DatabaseTracker::singleton().doneCreatingDatabase(m_database);
326     }
327 
328 private:
329     Database&amp; m_database;
330 };
331 
332 ExceptionOr&lt;void&gt; Database::performOpenAndVerify(bool shouldSetVersionInNewDatabase)
333 {
334     DoneCreatingDatabaseOnExitCaller onExitCaller(*this);
335 
336     const int maxSqliteBusyWaitTime = 30000;
337 
338 #if PLATFORM(IOS_FAMILY)
339     {
340         // Make sure we wait till the background removal of the empty database files finished before trying to open any database.
341         auto locker = holdLock(DatabaseTracker::openDatabaseMutex());
342     }
343 #endif
344 
345     SQLiteTransactionInProgressAutoCounter transactionCounter;
346 
347     if (!m_sqliteDatabase.open(m_filename))
348         return Exception { InvalidStateError, formatErrorMessage(&quot;unable to open database&quot;, m_sqliteDatabase.lastError(), m_sqliteDatabase.lastErrorMsg()) };
349     if (!m_sqliteDatabase.turnOnIncrementalAutoVacuum())
350         LOG_ERROR(&quot;Unable to turn on incremental auto-vacuum (%d %s)&quot;, m_sqliteDatabase.lastError(), m_sqliteDatabase.lastErrorMsg());
351 
352     m_sqliteDatabase.setBusyTimeout(maxSqliteBusyWaitTime);
353 
354     String currentVersion;
355     {
356         std::lock_guard&lt;Lock&gt; locker(guidMutex);
357 
358         auto entry = guidToVersionMap().find(m_guid);
359         if (entry != guidToVersionMap().end()) {
360             // Map null string to empty string (see updateGUIDVersionMap()).
361             currentVersion = entry-&gt;value.isNull() ? emptyString() : entry-&gt;value.isolatedCopy();
362             LOG(StorageAPI, &quot;Current cached version for guid %i is %s&quot;, m_guid, currentVersion.ascii().data());
363         } else {
364             LOG(StorageAPI, &quot;No cached version for guid %i&quot;, m_guid);
365 
366             SQLiteTransaction transaction(m_sqliteDatabase);
367             transaction.begin();
368             if (!transaction.inProgress()) {
369                 String message = formatErrorMessage(&quot;unable to open database, failed to start transaction&quot;, m_sqliteDatabase.lastError(), m_sqliteDatabase.lastErrorMsg());
370                 m_sqliteDatabase.close();
371                 return Exception { InvalidStateError, WTFMove(message) };
372             }
373 
374             String tableName(unqualifiedInfoTableName);
375             if (!m_sqliteDatabase.tableExists(tableName)) {
376                 m_new = true;
377 
378                 if (!m_sqliteDatabase.executeCommand(&quot;CREATE TABLE &quot; + tableName + &quot; (key TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE,value TEXT NOT NULL ON CONFLICT FAIL);&quot;)) {
379                     String message = formatErrorMessage(&quot;unable to open database, failed to create &#39;info&#39; table&quot;, m_sqliteDatabase.lastError(), m_sqliteDatabase.lastErrorMsg());
380                     transaction.rollback();
381                     m_sqliteDatabase.close();
382                 return Exception { InvalidStateError, WTFMove(message) };
383                 }
384             } else if (!getVersionFromDatabase(currentVersion, false)) {
385                 String message = formatErrorMessage(&quot;unable to open database, failed to read current version&quot;, m_sqliteDatabase.lastError(), m_sqliteDatabase.lastErrorMsg());
386                 transaction.rollback();
387                 m_sqliteDatabase.close();
388                 return Exception { InvalidStateError, WTFMove(message) };
389             }
390 
391             if (currentVersion.length()) {
392                 LOG(StorageAPI, &quot;Retrieved current version %s from database %s&quot;, currentVersion.ascii().data(), databaseDebugName().ascii().data());
393             } else if (!m_new || shouldSetVersionInNewDatabase) {
394                 LOG(StorageAPI, &quot;Setting version %s in database %s that was just created&quot;, m_expectedVersion.ascii().data(), databaseDebugName().ascii().data());
395                 if (!setVersionInDatabase(m_expectedVersion, false)) {
396                     String message = formatErrorMessage(&quot;unable to open database, failed to write current version&quot;, m_sqliteDatabase.lastError(), m_sqliteDatabase.lastErrorMsg());
397                     transaction.rollback();
398                     m_sqliteDatabase.close();
399                     return Exception { InvalidStateError, WTFMove(message) };
400                 }
401                 currentVersion = m_expectedVersion;
402             }
403             updateGUIDVersionMap(m_guid, currentVersion);
404             transaction.commit();
405         }
406     }
407 
408     if (currentVersion.isNull()) {
409         LOG(StorageAPI, &quot;Database %s does not have its version set&quot;, databaseDebugName().ascii().data());
410         currentVersion = emptyString();
411     }
412 
413     // If the expected version isn&#39;t the empty string, ensure that the current database version we have matches that version. Otherwise, set an exception.
414     // If the expected version is the empty string, then we always return with whatever version of the database we have.
415     if ((!m_new || shouldSetVersionInNewDatabase) &amp;&amp; m_expectedVersion.length() &amp;&amp; m_expectedVersion != currentVersion) {
416         m_sqliteDatabase.close();
417         return Exception { InvalidStateError, &quot;unable to open database, version mismatch, &#39;&quot; + m_expectedVersion + &quot;&#39; does not match the currentVersion of &#39;&quot; + currentVersion + &quot;&#39;&quot; };
418     }
419 
420     m_sqliteDatabase.setAuthorizer(m_databaseAuthorizer.get());
421 
422     DatabaseTracker::singleton().addOpenDatabase(*this);
423     m_opened = true;
424 
425     if (m_new &amp;&amp; !shouldSetVersionInNewDatabase)
426         m_expectedVersion = emptyString(); // The caller provided a creationCallback which will set the expected version.
427 
428     databaseThread().recordDatabaseOpen(*this);
429 
430     return { };
431 }
432 
433 void Database::closeDatabase()
434 {
435     if (!m_opened)
436         return;
437 
438     m_sqliteDatabase.close();
439     m_opened = false;
440 
441     // See comment at the top this file regarding calling removeOpenDatabase().
442     DatabaseTracker::singleton().removeOpenDatabase(*this);
443 
444     {
445         std::lock_guard&lt;Lock&gt; locker(guidMutex);
446 
447         auto it = guidToDatabaseMap().find(m_guid);
448         ASSERT(it != guidToDatabaseMap().end());
449         ASSERT(it-&gt;value.contains(this));
450         it-&gt;value.remove(this);
451         if (it-&gt;value.isEmpty()) {
452             guidToDatabaseMap().remove(it);
453             guidToVersionMap().remove(m_guid);
454         }
455     }
456 }
457 
458 bool Database::getVersionFromDatabase(String&amp; version, bool shouldCacheVersion)
459 {
460     String query(String(&quot;SELECT value FROM &quot;) + fullyQualifiedInfoTableName() +  &quot; WHERE key = &#39;&quot; + versionKey + &quot;&#39;;&quot;);
461 
462     m_databaseAuthorizer-&gt;disable();
463 
464     bool result = retrieveTextResultFromDatabase(m_sqliteDatabase, query, version);
465     if (result) {
466         if (shouldCacheVersion)
467             setCachedVersion(version);
468     } else
469         LOG_ERROR(&quot;Failed to retrieve version from database %s&quot;, databaseDebugName().ascii().data());
470 
471     m_databaseAuthorizer-&gt;enable();
472 
473     return result;
474 }
475 
476 bool Database::setVersionInDatabase(const String&amp; version, bool shouldCacheVersion)
477 {
478     // The INSERT will replace an existing entry for the database with the new version number, due to the UNIQUE ON CONFLICT REPLACE
479     // clause in the CREATE statement (see Database::performOpenAndVerify()).
480     String query(String(&quot;INSERT INTO &quot;) + fullyQualifiedInfoTableName() +  &quot; (key, value) VALUES (&#39;&quot; + versionKey + &quot;&#39;, ?);&quot;);
481 
482     m_databaseAuthorizer-&gt;disable();
483 
484     bool result = setTextValueInDatabase(m_sqliteDatabase, query, version);
485     if (result) {
486         if (shouldCacheVersion)
487             setCachedVersion(version);
488     } else
489         LOG_ERROR(&quot;Failed to set version %s in database (%s)&quot;, version.ascii().data(), query.ascii().data());
490 
491     m_databaseAuthorizer-&gt;enable();
492 
493     return result;
494 }
495 
496 void Database::setExpectedVersion(const String&amp; version)
497 {
498     m_expectedVersion = version.isolatedCopy();
499 }
500 
501 String Database::getCachedVersion() const
502 {
503     std::lock_guard&lt;Lock&gt; locker(guidMutex);
504 
505     return guidToVersionMap().get(m_guid).isolatedCopy();
506 }
507 
508 void Database::setCachedVersion(const String&amp; actualVersion)
509 {
510     std::lock_guard&lt;Lock&gt; locker(guidMutex);
511 
512     updateGUIDVersionMap(m_guid, actualVersion);
513 }
514 
515 bool Database::getActualVersionForTransaction(String &amp;actualVersion)
516 {
517     ASSERT(m_sqliteDatabase.transactionInProgress());
518 
519     // Note: In multi-process browsers the cached value may be inaccurate.
520     // So we retrieve the value from the database and update the cached value here.
521     return getVersionFromDatabase(actualVersion, true);
522 }
523 
524 void Database::scheduleTransaction()
525 {
526     ASSERT(!m_transactionInProgressMutex.tryLock()); // Locked by caller.
527 
528     if (!m_isTransactionQueueEnabled || m_transactionQueue.isEmpty()) {
529         m_transactionInProgress = false;
530         return;
531     }
532 
533     m_transactionInProgress = true;
534 
535     auto transaction = m_transactionQueue.takeFirst();
536     auto task = makeUnique&lt;DatabaseTransactionTask&gt;(WTFMove(transaction));
537     LOG(StorageAPI, &quot;Scheduling DatabaseTransactionTask %p for transaction %p\n&quot;, task.get(), task-&gt;transaction());
538     databaseThread().scheduleTask(WTFMove(task));
539 }
540 
541 void Database::scheduleTransactionStep(SQLTransaction&amp; transaction)
542 {
543     auto&amp; thread = databaseThread();
544 
545     auto task = makeUnique&lt;DatabaseTransactionTask&gt;(&amp;transaction);
546     LOG(StorageAPI, &quot;Scheduling DatabaseTransactionTask %p for the transaction step\n&quot;, task.get());
547     thread.scheduleTask(WTFMove(task));
548 }
549 
550 void Database::inProgressTransactionCompleted()
551 {
552     LockHolder locker(m_transactionInProgressMutex);
553     m_transactionInProgress = false;
554     scheduleTransaction();
555 }
556 
557 bool Database::hasPendingTransaction()
558 {
559     LockHolder locker(m_transactionInProgressMutex);
560     return m_transactionInProgress || !m_transactionQueue.isEmpty();
561 }
562 
563 SQLTransactionCoordinator* Database::transactionCoordinator()
564 {
565     return databaseThread().transactionCoordinator();
566 }
567 
568 String Database::version() const
569 {
570     if (m_deleted)
571         return String();
572 
573     // Note: In multi-process browsers the cached value may be accurate, but we cannot read the
574     // actual version from the database without potentially inducing a deadlock.
575     // FIXME: Add an async version getter to the DatabaseAPI.
576     return getCachedVersion();
577 }
578 
579 void Database::markAsDeletedAndClose()
580 {
581     if (m_deleted)
582         return;
583 
584     LOG(StorageAPI, &quot;Marking %s (%p) as deleted&quot;, stringIdentifierIsolatedCopy().ascii().data(), this);
585     m_deleted = true;
586 
587     close();
588 }
589 
590 void Database::changeVersion(const String&amp; oldVersion, const String&amp; newVersion, RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback)
591 {
592     runTransaction(WTFMove(callback), WTFMove(errorCallback), WTFMove(successCallback), ChangeVersionWrapper::create(oldVersion, newVersion), false);
593 }
594 
595 void Database::transaction(RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback)
596 {
597     runTransaction(WTFMove(callback), WTFMove(errorCallback), WTFMove(successCallback), nullptr, false);
598 }
599 
600 void Database::readTransaction(RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback)
601 {
602     runTransaction(WTFMove(callback), WTFMove(errorCallback), WTFMove(successCallback), nullptr, true);
603 }
604 
605 String Database::stringIdentifierIsolatedCopy() const
606 {
607     // Return a deep copy for ref counting thread safety
608     return m_name.isolatedCopy();
609 }
610 
611 String Database::displayNameIsolatedCopy() const
612 {
613     // Return a deep copy for ref counting thread safety
614     return m_displayName.isolatedCopy();
615 }
616 
617 String Database::expectedVersionIsolatedCopy() const
618 {
619     // Return a deep copy for ref counting thread safety
620     return m_expectedVersion.isolatedCopy();
621 }
622 
623 unsigned long long Database::estimatedSize() const
624 {
625     return m_estimatedSize;
626 }
627 
628 void Database::setEstimatedSize(unsigned long long estimatedSize)
629 {
630     m_estimatedSize = estimatedSize;
631     DatabaseTracker::singleton().setDatabaseDetails(securityOrigin(), m_name, m_displayName, m_estimatedSize);
632 }
633 
634 String Database::fileNameIsolatedCopy() const
635 {
636     // Return a deep copy for ref counting thread safety
637     return m_filename.isolatedCopy();
638 }
639 
640 DatabaseDetails Database::details() const
641 {
642     // This code path is only used for database quota delegate calls, so file dates are irrelevant and left uninitialized.
643     return DatabaseDetails(stringIdentifierIsolatedCopy(), displayNameIsolatedCopy(), estimatedSize(), 0, WTF::nullopt, WTF::nullopt);
644 }
645 
646 void Database::disableAuthorizer()
647 {
648     m_databaseAuthorizer-&gt;disable();
649 }
650 
651 void Database::enableAuthorizer()
652 {
653     m_databaseAuthorizer-&gt;enable();
654 }
655 
656 void Database::setAuthorizerPermissions(int permissions)
657 {
658     m_databaseAuthorizer-&gt;setPermissions(permissions);
659 }
660 
661 bool Database::lastActionChangedDatabase()
662 {
663     return m_databaseAuthorizer-&gt;lastActionChangedDatabase();
664 }
665 
666 bool Database::lastActionWasInsert()
667 {
668     return m_databaseAuthorizer-&gt;lastActionWasInsert();
669 }
670 
671 void Database::resetDeletes()
672 {
673     m_databaseAuthorizer-&gt;resetDeletes();
674 }
675 
676 bool Database::hadDeletes()
677 {
678     return m_databaseAuthorizer-&gt;hadDeletes();
679 }
680 
681 void Database::resetAuthorizer()
682 {
683     m_databaseAuthorizer-&gt;reset();
684 }
685 
686 void Database::runTransaction(RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback, RefPtr&lt;SQLTransactionWrapper&gt;&amp;&amp; wrapper, bool readOnly)
687 {
<a name="2" id="anc2"></a><span class="line-added">688     ASSERT(isMainThread());</span>
689     LockHolder locker(m_transactionInProgressMutex);
690     if (!m_isTransactionQueueEnabled) {
691         if (errorCallback) {
<a name="3" id="anc3"></a><span class="line-modified">692             m_document-&gt;eventLoop().queueTask(TaskSource::Networking, [errorCallback = makeRef(*errorCallback)]() {</span>
693                 errorCallback-&gt;handleEvent(SQLError::create(SQLError::UNKNOWN_ERR, &quot;database has been closed&quot;));
694             });
695         }
696         return;
697     }
698 
699     m_transactionQueue.append(SQLTransaction::create(*this, WTFMove(callback), WTFMove(successCallback), errorCallback.copyRef(), WTFMove(wrapper), readOnly));
700     if (!m_transactionInProgress)
701         scheduleTransaction();
702 }
703 
704 void Database::scheduleTransactionCallback(SQLTransaction* transaction)
705 {
<a name="4" id="anc4"></a><span class="line-modified">706     callOnMainThread([this, protectedThis = makeRef(*this), transaction = makeRefPtr(transaction)] {</span>
<span class="line-modified">707         m_document-&gt;eventLoop().queueTask(TaskSource::Networking, [transaction = transaction.copyRef()] {</span>
<span class="line-added">708             transaction-&gt;performPendingCallback();</span>
<span class="line-added">709         });</span>
710     });
711 }
712 
713 Vector&lt;String&gt; Database::performGetTableNames()
714 {
715     disableAuthorizer();
716 
717     SQLiteStatement statement(sqliteDatabase(), &quot;SELECT name FROM sqlite_master WHERE type=&#39;table&#39;;&quot;);
718     if (statement.prepare() != SQLITE_OK) {
719         LOG_ERROR(&quot;Unable to retrieve list of tables for database %s&quot;, databaseDebugName().ascii().data());
720         enableAuthorizer();
721         return Vector&lt;String&gt;();
722     }
723 
724     Vector&lt;String&gt; tableNames;
725     int result;
726     while ((result = statement.step()) == SQLITE_ROW) {
727         String name = statement.getColumnText(0);
728         if (name != unqualifiedInfoTableName)
729             tableNames.append(name);
730     }
731 
732     enableAuthorizer();
733 
734     if (result != SQLITE_DONE) {
735         LOG_ERROR(&quot;Error getting tables for database %s&quot;, databaseDebugName().ascii().data());
736         return Vector&lt;String&gt;();
737     }
738 
739     return tableNames;
740 }
741 
742 void Database::incrementalVacuumIfNeeded()
743 {
744     SQLiteTransactionInProgressAutoCounter transactionCounter;
745 
746     int64_t freeSpaceSize = m_sqliteDatabase.freeSpaceSize();
747     int64_t totalSize = m_sqliteDatabase.totalSize();
748     if (totalSize &lt;= 10 * freeSpaceSize) {
749         int result = m_sqliteDatabase.runIncrementalVacuumCommand();
750         if (result != SQLITE_OK)
751             logErrorMessage(formatErrorMessage(&quot;error vacuuming database&quot;, result, m_sqliteDatabase.lastErrorMsg()));
752     }
753 }
754 
755 void Database::logErrorMessage(const String&amp; message)
756 {
757     m_document-&gt;addConsoleMessage(MessageSource::Storage, MessageLevel::Error, message);
758 }
759 
760 Vector&lt;String&gt; Database::tableNames()
761 {
762     // FIXME: Not using isolatedCopy on these strings looks ok since threads take strict turns
763     // in dealing with them. However, if the code changes, this may not be true anymore.
764     Vector&lt;String&gt; result;
765     DatabaseTaskSynchronizer synchronizer;
766     auto&amp; thread = databaseThread();
767     if (thread.terminationRequested(&amp;synchronizer))
768         return result;
769 
770     auto task = makeUnique&lt;DatabaseTableNamesTask&gt;(*this, synchronizer, result);
771     thread.scheduleImmediateTask(WTFMove(task));
772     synchronizer.waitForTaskCompletion();
773 
774     return result;
775 }
776 
777 SecurityOriginData Database::securityOrigin()
778 {
779     if (isMainThread())
780         return m_contextThreadSecurityOrigin-&gt;data();
781     if (databaseThread().getThread() == &amp;Thread::current())
782         return m_databaseThreadSecurityOrigin-&gt;data();
783     RELEASE_ASSERT_NOT_REACHED();
784 }
785 
786 unsigned long long Database::maximumSize()
787 {
788     return DatabaseTracker::singleton().maximumSize(*this);
789 }
790 
791 void Database::didCommitWriteTransaction()
792 {
793     DatabaseTracker::singleton().scheduleNotifyDatabaseChanged(securityOrigin(), stringIdentifierIsolatedCopy());
794 }
795 
796 bool Database::didExceedQuota()
797 {
798     ASSERT(isMainThread());
799     auto&amp; tracker = DatabaseTracker::singleton();
800     auto oldQuota = tracker.quota(securityOrigin());
801     if (estimatedSize() &lt;= oldQuota) {
802         // The expected usage provided by the page is now smaller than the actual database size so we bump the expected usage to
803         // oldQuota + 5MB so that the client actually increases the quota.
804         setEstimatedSize(oldQuota + quotaIncreaseSize);
805     }
806     databaseContext().databaseExceededQuota(stringIdentifierIsolatedCopy(), details());
807     return tracker.quota(securityOrigin()) &gt; oldQuota;
808 }
809 
810 #if !LOG_DISABLED || !ERROR_DISABLED
811 
812 String Database::databaseDebugName() const
813 {
814     return m_contextThreadSecurityOrigin-&gt;toString() + &quot;::&quot; + m_name;
815 }
816 
817 #endif
818 
819 } // namespace WebCore
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCJSValue.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCJSValue.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCJSValueInlines.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCJSValue.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -39,11 +39,11 @@</span>
  
  namespace JSC {
  
  class AssemblyHelpers;
  class JSBigInt;
<span class="udiff-line-modified-removed">- class ExecState;</span>
<span class="udiff-line-modified-added">+ class CallFrame;</span>
  class JSCell;
  class JSValueSource;
  class VM;
  class JSGlobalObject;
  class JSObject;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127,11 +127,12 @@</span>
  bool isInt52(double);
  
  enum class SourceCodeRepresentation : uint8_t {
      Other,
      Integer,
<span class="udiff-line-modified-removed">-     Double</span>
<span class="udiff-line-modified-added">+     Double,</span>
<span class="udiff-line-added">+     LinkTimeConstant,</span>
  };
  
  class JSValue {
      friend struct EncodedJSValueHashTraits;
      friend struct EncodedJSValueWithRepresentationHashTraits;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -243,80 +244,80 @@</span>
      bool inherits(VM&amp;, const ClassInfo*) const;
      template&lt;typename Target&gt; bool inherits(VM&amp;) const;
      const ClassInfo* classInfoOrNull(VM&amp;) const;
  
      // Extracting the value.
<span class="udiff-line-modified-removed">-     bool getString(ExecState*, WTF::String&amp;) const;</span>
<span class="udiff-line-modified-removed">-     WTF::String getString(ExecState*) const; // null string if not a string</span>
<span class="udiff-line-modified-added">+     bool getString(JSGlobalObject*, WTF::String&amp;) const;</span>
<span class="udiff-line-modified-added">+     WTF::String getString(JSGlobalObject*) const; // null string if not a string</span>
      JSObject* getObject() const; // 0 if not an object
  
      // Extracting integer values.
      bool getUInt32(uint32_t&amp;) const;
  
      // Basic conversions.
<span class="udiff-line-modified-removed">-     JSValue toPrimitive(ExecState*, PreferredPrimitiveType = NoPreference) const;</span>
<span class="udiff-line-modified-removed">-     bool getPrimitiveNumber(ExecState*, double&amp; number, JSValue&amp;);</span>
<span class="udiff-line-modified-added">+     JSValue toPrimitive(JSGlobalObject*, PreferredPrimitiveType = NoPreference) const;</span>
<span class="udiff-line-modified-added">+     bool getPrimitiveNumber(JSGlobalObject*, double&amp; number, JSValue&amp;);</span>
  
<span class="udiff-line-modified-removed">-     bool toBoolean(ExecState*) const;</span>
<span class="udiff-line-modified-added">+     bool toBoolean(JSGlobalObject*) const;</span>
      TriState pureToBoolean() const;
  
      // toNumber conversion is expected to be side effect free if an exception has
<span class="udiff-line-modified-removed">-     // been set in the ExecState already.</span>
<span class="udiff-line-modified-removed">-     double toNumber(ExecState*) const;</span>
<span class="udiff-line-modified-added">+     // been set in the CallFrame already.</span>
<span class="udiff-line-modified-added">+     double toNumber(JSGlobalObject*) const;</span>
  
<span class="udiff-line-modified-removed">-     Variant&lt;JSBigInt*, double&gt; toNumeric(ExecState*) const;</span>
<span class="udiff-line-modified-removed">-     Variant&lt;JSBigInt*, int32_t&gt; toBigIntOrInt32(ExecState*) const;</span>
<span class="udiff-line-modified-added">+     Variant&lt;JSBigInt*, double&gt; toNumeric(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     Variant&lt;JSBigInt*, int32_t&gt; toBigIntOrInt32(JSGlobalObject*) const;</span>
  
      // toNumber conversion if it can be done without side effects.
      Optional&lt;double&gt; toNumberFromPrimitive() const;
  
<span class="udiff-line-modified-removed">-     JSString* toString(ExecState*) const; // On exception, this returns the empty string.</span>
<span class="udiff-line-modified-removed">-     JSString* toStringOrNull(ExecState*) const; // On exception, this returns null, to make exception checks faster.</span>
<span class="udiff-line-modified-removed">-     Identifier toPropertyKey(ExecState*) const;</span>
<span class="udiff-line-modified-removed">-     WTF::String toWTFString(ExecState*) const;</span>
<span class="udiff-line-modified-removed">-     JSObject* toObject(ExecState*) const;</span>
<span class="udiff-line-modified-removed">-     JSObject* toObject(ExecState*, JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     JSString* toString(JSGlobalObject*) const; // On exception, this returns the empty string.</span>
<span class="udiff-line-modified-added">+     JSString* toStringOrNull(JSGlobalObject*) const; // On exception, this returns null, to make exception checks faster.</span>
<span class="udiff-line-modified-added">+     Identifier toPropertyKey(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     JSValue toPropertyKeyValue(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     WTF::String toWTFString(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     JSObject* toObject(JSGlobalObject*) const;</span>
  
      // Integer conversions.
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE double toInteger(ExecState*) const;</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE double toIntegerPreserveNaN(ExecState*) const;</span>
<span class="udiff-line-modified-removed">-     int32_t toInt32(ExecState*) const;</span>
<span class="udiff-line-modified-removed">-     uint32_t toUInt32(ExecState*) const;</span>
<span class="udiff-line-modified-removed">-     uint32_t toIndex(ExecState*, const char* errorName) const;</span>
<span class="udiff-line-modified-removed">-     double toLength(ExecState*) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE double toInteger(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE double toIntegerPreserveNaN(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     int32_t toInt32(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     uint32_t toUInt32(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     uint32_t toIndex(JSGlobalObject*, const char* errorName) const;</span>
<span class="udiff-line-modified-added">+     double toLength(JSGlobalObject*) const;</span>
  
      // Floating point conversions (this is a convenience function for WebCore;
      // single precision float is not a representation used in JS or JSC).
<span class="udiff-line-modified-removed">-     float toFloat(ExecState* exec) const { return static_cast&lt;float&gt;(toNumber(exec)); }</span>
<span class="udiff-line-modified-added">+     float toFloat(JSGlobalObject* globalObject) const { return static_cast&lt;float&gt;(toNumber(globalObject)); }</span>
  
      // Object operations, with the toObject operation included.
<span class="udiff-line-modified-removed">-     JSValue get(ExecState*, PropertyName) const;</span>
<span class="udiff-line-modified-removed">-     JSValue get(ExecState*, PropertyName, PropertySlot&amp;) const;</span>
<span class="udiff-line-modified-removed">-     JSValue get(ExecState*, unsigned propertyName) const;</span>
<span class="udiff-line-modified-removed">-     JSValue get(ExecState*, unsigned propertyName, PropertySlot&amp;) const;</span>
<span class="udiff-line-modified-removed">-     JSValue get(ExecState*, uint64_t propertyName) const;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     bool getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;) const;</span>
<span class="udiff-line-modified-removed">-     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, CallbackWhenNoException) const;</span>
<span class="udiff-line-modified-removed">-     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;, CallbackWhenNoException) const;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     bool getOwnPropertySlot(ExecState*, PropertyName, PropertySlot&amp;) const;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     bool put(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="udiff-line-modified-removed">-     bool putInline(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE bool putToPrimitive(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE bool putToPrimitiveByIndex(ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="udiff-line-modified-removed">-     bool putByIndex(ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     JSValue toThis(ExecState*, ECMAMode) const;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     static bool equal(ExecState*, JSValue v1, JSValue v2);</span>
<span class="udiff-line-modified-removed">-     static bool equalSlowCase(ExecState*, JSValue v1, JSValue v2);</span>
<span class="udiff-line-modified-removed">-     static bool equalSlowCaseInline(ExecState*, JSValue v1, JSValue v2);</span>
<span class="udiff-line-modified-removed">-     static bool strictEqual(ExecState*, JSValue v1, JSValue v2);</span>
<span class="udiff-line-modified-removed">-     static bool strictEqualSlowCase(ExecState*, JSValue v1, JSValue v2);</span>
<span class="udiff-line-modified-removed">-     static bool strictEqualSlowCaseInline(ExecState*, JSValue v1, JSValue v2);</span>
<span class="udiff-line-modified-added">+     JSValue get(JSGlobalObject*, PropertyName) const;</span>
<span class="udiff-line-modified-added">+     JSValue get(JSGlobalObject*, PropertyName, PropertySlot&amp;) const;</span>
<span class="udiff-line-modified-added">+     JSValue get(JSGlobalObject*, unsigned propertyName) const;</span>
<span class="udiff-line-modified-added">+     JSValue get(JSGlobalObject*, unsigned propertyName, PropertySlot&amp;) const;</span>
<span class="udiff-line-modified-added">+     JSValue get(JSGlobalObject*, uint64_t propertyName) const;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     bool getPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;) const;</span>
<span class="udiff-line-modified-added">+     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(JSGlobalObject*, PropertyName, CallbackWhenNoException) const;</span>
<span class="udiff-line-modified-added">+     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;, CallbackWhenNoException) const;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     bool getOwnPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;) const;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     bool put(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     bool putInline(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE bool putToPrimitive(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE bool putToPrimitiveByIndex(JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="udiff-line-modified-added">+     bool putByIndex(JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     JSValue toThis(JSGlobalObject*, ECMAMode) const;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     static bool equal(JSGlobalObject*, JSValue v1, JSValue v2);</span>
<span class="udiff-line-modified-added">+     static bool equalSlowCase(JSGlobalObject*, JSValue v1, JSValue v2);</span>
<span class="udiff-line-modified-added">+     static bool equalSlowCaseInline(JSGlobalObject*, JSValue v1, JSValue v2);</span>
<span class="udiff-line-modified-added">+     static bool strictEqual(JSGlobalObject*, JSValue v1, JSValue v2);</span>
<span class="udiff-line-modified-added">+     static bool strictEqualSlowCase(JSGlobalObject*, JSValue v1, JSValue v2);</span>
<span class="udiff-line-modified-added">+     static bool strictEqualSlowCaseInline(JSGlobalObject*, JSValue v1, JSValue v2);</span>
      static TriState pureStrictEqual(JSValue v1, JSValue v2);
  
      bool isCell() const;
      JSCell* asCell() const;
      JS_EXPORT_PRIVATE bool isValidCallee();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -327,12 +328,12 @@</span>
      JS_EXPORT_PRIVATE void dump(PrintStream&amp;) const;
      void dumpInContext(PrintStream&amp;, DumpContext*) const;
      void dumpInContextAssumingStructure(PrintStream&amp;, DumpContext*, Structure*) const;
      void dumpForBacktrace(PrintStream&amp;) const;
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE JSObject* synthesizePrototype(ExecState*) const;</span>
<span class="udiff-line-modified-removed">-     bool requireObjectCoercible(ExecState*) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE JSObject* synthesizePrototype(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     bool requireObjectCoercible(JSGlobalObject*) const;</span>
  
      // Constants used for Int52. Int52 isn&#39;t part of JSValue right now, but JSValues may be
      // converted to Int52s and back again.
      static constexpr const unsigned numberOfInt52Bits = 52;
      static constexpr const int64_t notInt52 = static_cast&lt;int64_t&gt;(1) &lt;&lt; numberOfInt52Bits;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -379,83 +380,84 @@</span>
       * pointer and integer values.  Since any 64-bit bit pattern where the top 15 bits are
       * all set represents a NaN with a non-zero payload, we can use this space in the NaN
       * ranges to encode other values (however there are also other ranges of NaN space that
       * could have been selected).
       *
<span class="udiff-line-modified-removed">-      * This range of NaN space is represented by 64-bit numbers begining with the 16-bit</span>
<span class="udiff-line-modified-removed">-      * hex patterns 0xFFFE and 0xFFFF - we rely on the fact that no valid double-precision</span>
<span class="udiff-line-modified-added">+      * This range of NaN space is represented by 64-bit numbers begining with the 15-bit</span>
<span class="udiff-line-modified-added">+      * hex patterns 0xFFFC and 0xFFFE - we rely on the fact that no valid double-precision</span>
       * numbers will fall in these ranges.
       *
<span class="udiff-line-modified-removed">-      * The top 16-bits denote the type of the encoded JSValue:</span>
<span class="udiff-line-modified-added">+      * The top 15-bits denote the type of the encoded JSValue:</span>
       *
       *     Pointer {  0000:PPPP:PPPP:PPPP
<span class="udiff-line-modified-removed">-      *              / 0001:****:****:****</span>
<span class="udiff-line-modified-added">+      *              / 0002:****:****:****</span>
       *     Double  {         ...
<span class="udiff-line-modified-removed">-      *              \ FFFE:****:****:****</span>
<span class="udiff-line-modified-removed">-      *     Integer {  FFFF:0000:IIII:IIII</span>
<span class="udiff-line-modified-added">+      *              \ FFFC:****:****:****</span>
<span class="udiff-line-modified-added">+      *     Integer {  FFFE:0000:IIII:IIII</span>
       *
       * The scheme we have implemented encodes double precision values by performing a
<span class="udiff-line-modified-removed">-      * 64-bit integer addition of the value 2^48 to the number. After this manipulation</span>
<span class="udiff-line-modified-removed">-      * no encoded double-precision value will begin with the pattern 0x0000 or 0xFFFF.</span>
<span class="udiff-line-modified-added">+      * 64-bit integer addition of the value 2^49 to the number. After this manipulation</span>
<span class="udiff-line-modified-added">+      * no encoded double-precision value will begin with the pattern 0x0000 or 0xFFFE.</span>
       * Values must be decoded by reversing this operation before subsequent floating point
       * operations may be peformed.
       *
<span class="udiff-line-modified-removed">-      * 32-bit signed integers are marked with the 16-bit tag 0xFFFF.</span>
<span class="udiff-line-modified-added">+      * 32-bit signed integers are marked with the 16-bit tag 0xFFFE.</span>
       *
       * The tag 0x0000 denotes a pointer, or another form of tagged immediate. Boolean,
       * null and undefined values are represented by specific, invalid pointer values:
       *
       *     False:     0x06
       *     True:      0x07
       *     Undefined: 0x0a
       *     Null:      0x02
       *
       * These values have the following properties:
<span class="udiff-line-modified-removed">-      * - Bit 1 (TagBitTypeOther) is set for all four values, allowing real pointers to be</span>
<span class="udiff-line-modified-added">+      * - Bit 1 (OtherTag) is set for all four values, allowing real pointers to be</span>
       *   quickly distinguished from all immediate values, including these invalid pointers.
<span class="udiff-line-modified-removed">-      * - With bit 3 is masked out (TagBitUndefined) Undefined and Null share the</span>
<span class="udiff-line-modified-added">+      * - With bit 3 is masked out (UndefinedTag) Undefined and Null share the</span>
       *   same value, allowing null &amp; undefined to be quickly detected.
       *
       * No valid JSValue will have the bit pattern 0x0, this is used to represent array
       * holes, and as a C++ &#39;no value&#39; result (e.g. JSValue() has an internal value of 0).
       */
  
<span class="udiff-line-modified-removed">-     // These values are #defines since using static const integers here is a ~1% regression!</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // This value is 2^48, used to encode doubles such that the encoded value will begin</span>
<span class="udiff-line-modified-removed">-     // with a 16-bit pattern within the range 0x0001..0xFFFE.</span>
<span class="udiff-line-removed">-     #define DoubleEncodeOffset 0x1000000000000ll</span>
<span class="udiff-line-modified-added">+     // This value is 2^49, used to encode doubles such that the encoded value will begin</span>
<span class="udiff-line-modified-added">+     // with a 15-bit pattern within the range 0x0002..0xFFFC.</span>
<span class="udiff-line-modified-added">+     static constexpr size_t DoubleEncodeOffsetBit = 49;</span>
<span class="udiff-line-modified-added">+     static constexpr int64_t DoubleEncodeOffset = 1ll &lt;&lt; DoubleEncodeOffsetBit;</span>
      // If all bits in the mask are set, this indicates an integer number,
      // if any but not all are set this value is a double precision number.
<span class="udiff-line-modified-removed">-     #define TagTypeNumber 0xffff000000000000ll</span>
<span class="udiff-line-modified-added">+     static constexpr int64_t NumberTag = 0xfffe000000000000ll;</span>
  
      // All non-numeric (bool, null, undefined) immediates have bit 2 set.
<span class="udiff-line-modified-removed">-     #define TagBitTypeOther 0x2ll</span>
<span class="udiff-line-modified-removed">-     #define TagBitBool      0x4ll</span>
<span class="udiff-line-modified-removed">-     #define TagBitUndefined 0x8ll</span>
<span class="udiff-line-modified-added">+     static constexpr int32_t OtherTag       = 0x2;</span>
<span class="udiff-line-modified-added">+     static constexpr int32_t BoolTag        = 0x4;</span>
<span class="udiff-line-modified-added">+     static constexpr int32_t UndefinedTag   = 0x8;</span>
      // Combined integer value for non-numeric immediates.
<span class="udiff-line-modified-removed">-     #define ValueFalse     (TagBitTypeOther | TagBitBool | false)</span>
<span class="udiff-line-modified-removed">-     #define ValueTrue      (TagBitTypeOther | TagBitBool | true)</span>
<span class="udiff-line-modified-removed">-     #define ValueUndefined (TagBitTypeOther | TagBitUndefined)</span>
<span class="udiff-line-modified-removed">-     #define ValueNull      (TagBitTypeOther)</span>
<span class="udiff-line-modified-added">+     static constexpr int32_t ValueFalse     = OtherTag | BoolTag | false;</span>
<span class="udiff-line-modified-added">+     static constexpr int32_t ValueTrue      = OtherTag | BoolTag | true;</span>
<span class="udiff-line-modified-added">+     static constexpr int32_t ValueUndefined = OtherTag | UndefinedTag;</span>
<span class="udiff-line-modified-added">+     static constexpr int32_t ValueNull      = OtherTag;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static constexpr int64_t MiscTag = OtherTag | BoolTag | UndefinedTag;</span>
  
<span class="udiff-line-modified-removed">-     // TagMask is used to check for all types of immediate values (either number or &#39;other&#39;).</span>
<span class="udiff-line-modified-removed">-     #define TagMask (TagTypeNumber | TagBitTypeOther)</span>
<span class="udiff-line-modified-added">+     // NotCellMask is used to check for all types of immediate values (either number or &#39;other&#39;).</span>
<span class="udiff-line-modified-added">+     static constexpr int64_t NotCellMask = NumberTag | OtherTag;</span>
  
      // These special values are never visible to JavaScript code; Empty is used to represent
      // Array holes, and for uninitialized JSValues. Deleted is used in hash table code.
      // These values would map to cell types in the JSValue encoding, but not valid GC cell
      // pointer should have either of these values (Empty is null, deleted is at an invalid
      // alignment for a GC cell, and in the zero page).
<span class="udiff-line-modified-removed">-     #define ValueEmpty   0x0ll</span>
<span class="udiff-line-modified-removed">-     #define ValueDeleted 0x4ll</span>
<span class="udiff-line-modified-added">+     static constexpr int32_t ValueEmpty   = 0x0;</span>
<span class="udiff-line-modified-added">+     static constexpr int32_t ValueDeleted = 0x4;</span>
  
<span class="udiff-line-modified-removed">-     #define TagBitsWasm (TagBitTypeOther | 0x1)</span>
<span class="udiff-line-modified-removed">-     #define TagWasmMask (TagTypeNumber | 0x7)</span>
<span class="udiff-line-modified-added">+     static constexpr int64_t WasmTag = OtherTag | 0x1;</span>
<span class="udiff-line-modified-added">+     static constexpr int64_t WasmMask = NumberTag | 0x7;</span>
      // We tag Wasm non-JSCell pointers with a 3 at the bottom. We can test if a 64-bit JSValue pattern
      // is a Wasm callee by masking the upper 16 bits and the lower 3 bits, and seeing if
<span class="udiff-line-modified-removed">-     // the resulting value is 3. The full test is: x &amp; TagWasmMask == TagBitsWasm</span>
<span class="udiff-line-modified-added">+     // the resulting value is 3. The full test is: x &amp; WasmMask == WasmTag</span>
      // This works because the lower 3 bits of the non-number immediate values are as follows:
      // undefined: 0b010
      // null:      0b010
      // true:      0b111
      // false:     0b110
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -463,36 +465,36 @@</span>
      // The test rejects all numbers because they have non-zero upper 16 bits.
      // The test also rejects normal cells because they won&#39;t have the number 3 as
      // their lower 3 bits. Note, this bit pattern also allows the normal JSValue isCell(), etc,
      // predicates to work on a Wasm::Callee because the various tests will fail if you
      // bit casted a boxed Wasm::Callee* to a JSValue. isCell() would fail since it sees
<span class="udiff-line-modified-removed">-     // TagBitTypeOther. The other tests also trivially fail, since it won&#39;t be a number,</span>
<span class="udiff-line-modified-added">+     // OtherTag. The other tests also trivially fail, since it won&#39;t be a number,</span>
      // and it won&#39;t be equal to null, undefined, true, or false. The isBoolean() predicate
<span class="udiff-line-modified-removed">-     // will fail because we won&#39;t have TagBitBool set.</span>
<span class="udiff-line-modified-added">+     // will fail because we won&#39;t have BoolTag set.</span>
  #endif
  
  private:
      template &lt;class T&gt; JSValue(WriteBarrierBase&lt;T, WriteBarrierTraitsSelect&lt;T&gt;&gt;);
  
      enum HashTableDeletedValueTag { HashTableDeletedValue };
      JSValue(HashTableDeletedValueTag);
  
      inline const JSValue asValue() const { return *this; }
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE double toNumberSlowCase(ExecState*) const;</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE JSString* toStringSlowCase(ExecState*, bool returnEmptyStringOnError) const;</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE WTF::String toWTFStringSlowCase(ExecState*) const;</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE JSObject* toObjectSlowCase(ExecState*, JSGlobalObject*) const;</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE JSValue toThisSlowCase(ExecState*, ECMAMode) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE double toNumberSlowCase(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE JSString* toStringSlowCase(JSGlobalObject*, bool returnEmptyStringOnError) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE WTF::String toWTFStringSlowCase(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE JSObject* toObjectSlowCase(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE JSValue toThisSlowCase(JSGlobalObject*, ECMAMode) const;</span>
  
      EncodedValueDescriptor u;
  };
  
  typedef IntHash&lt;EncodedJSValue&gt; EncodedJSValueHash;
  
  #if USE(JSVALUE32_64)
  struct EncodedJSValueHashTraits : HashTraits&lt;EncodedJSValue&gt; {
<span class="udiff-line-modified-removed">-     static const bool emptyValueIsZero = false;</span>
<span class="udiff-line-modified-added">+     static constexpr bool emptyValueIsZero = false;</span>
      static EncodedJSValue emptyValue() { return JSValue::encode(JSValue()); }
      static void constructDeletedValue(EncodedJSValue&amp; slot) { slot = JSValue::encode(JSValue(JSValue::HashTableDeletedValue)); }
      static bool isDeletedValue(EncodedJSValue value) { return value == JSValue::encode(JSValue(JSValue::HashTableDeletedValue)); }
  };
  #else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -503,11 +505,11 @@</span>
  #endif
  
  typedef std::pair&lt;EncodedJSValue, SourceCodeRepresentation&gt; EncodedJSValueWithRepresentation;
  
  struct EncodedJSValueWithRepresentationHashTraits : HashTraits&lt;EncodedJSValueWithRepresentation&gt; {
<span class="udiff-line-modified-removed">-     static const bool emptyValueIsZero = false;</span>
<span class="udiff-line-modified-added">+     static constexpr bool emptyValueIsZero = false;</span>
      static EncodedJSValueWithRepresentation emptyValue() { return std::make_pair(JSValue::encode(JSValue()), SourceCodeRepresentation::Other); }
      static void constructDeletedValue(EncodedJSValueWithRepresentation&amp; slot) { slot = std::make_pair(JSValue::encode(JSValue(JSValue::HashTableDeletedValue)), SourceCodeRepresentation::Other); }
      static bool isDeletedValue(EncodedJSValueWithRepresentation value) { return value == std::make_pair(JSValue::encode(JSValue(JSValue::HashTableDeletedValue)), SourceCodeRepresentation::Other); }
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -518,11 +520,11 @@</span>
      }
      static bool equal(const EncodedJSValueWithRepresentation&amp; a, const EncodedJSValueWithRepresentation&amp; b)
      {
          return a == b;
      }
<span class="udiff-line-modified-removed">-     static const bool safeToCompareToEmptyOrDeleted = true;</span>
<span class="udiff-line-modified-added">+     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
  };
  
  // Stand-alone helper functions.
  inline JSValue jsNull()
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -630,8 +632,8 @@</span>
  
  
  bool isThisValueAltered(const PutPropertySlot&amp;, JSObject* baseObject);
  
  // See section 7.2.9: https://tc39.github.io/ecma262/#sec-samevalue
<span class="udiff-line-modified-removed">- bool sameValue(ExecState*, JSValue a, JSValue b);</span>
<span class="udiff-line-modified-added">+ bool sameValue(JSGlobalObject*, JSValue a, JSValue b);</span>
  
  } // namespace JSC
</pre>
<center><a href="JSCJSValue.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCJSValueInlines.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDocumentCustom.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDocumentCustom.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDocumentCustom.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDocumentCustom.cpp
@@ -30,69 +30,69 @@
 
 
 namespace WebCore {
 using namespace JSC;
 
-static inline JSValue createNewDocumentWrapper(ExecState& state, JSDOMGlobalObject& globalObject, Ref<Document>&& passedDocument)
+static inline JSValue createNewDocumentWrapper(JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, Ref<Document>&& passedDocument)
 {
     auto& document = passedDocument.get();
     JSObject* wrapper;
     if (document.isHTMLDocument())
         wrapper = createWrapper<HTMLDocument>(&globalObject, WTFMove(passedDocument));
     else if (document.isXMLDocument())
         wrapper = createWrapper<XMLDocument>(&globalObject, WTFMove(passedDocument));
     else
         wrapper = createWrapper<Document>(&globalObject, WTFMove(passedDocument));
 
-    reportMemoryForDocumentIfFrameless(state, document);
+    reportMemoryForDocumentIfFrameless(lexicalGlobalObject, document);
 
     return wrapper;
 }
 
-JSObject* cachedDocumentWrapper(ExecState& state, JSDOMGlobalObject& globalObject, Document& document)
+JSObject* cachedDocumentWrapper(JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, Document& document)
 {
     if (auto* wrapper = getCachedWrapper(globalObject.world(), document))
         return wrapper;
 
     auto* window = document.domWindow();
     if (!window)
         return nullptr;
 
-    auto* documentGlobalObject = toJSDOMWindow(state.vm(), toJS(&state, *window));
+    auto* documentGlobalObject = toJSDOMWindow(lexicalGlobalObject.vm(), toJS(&lexicalGlobalObject, *window));
     if (!documentGlobalObject)
         return nullptr;
 
     // Creating a wrapper for domWindow might have created a wrapper for document as well.
     return getCachedWrapper(documentGlobalObject->world(), document);
 }
 
-void reportMemoryForDocumentIfFrameless(ExecState& state, Document& document)
+void reportMemoryForDocumentIfFrameless(JSGlobalObject& lexicalGlobalObject, Document& document)
 {
     // Make sure the document is kept around by the window object, and works right with the back/forward cache.
     if (document.frame())
         return;
 
-    VM& vm = state.vm();
+    VM& vm = lexicalGlobalObject.vm();
     size_t memoryCost = 0;
     for (Node* node = &document; node; node = NodeTraversal::next(*node))
         memoryCost += node->approximateMemoryCost();
 
     // FIXME: Adopt reportExtraMemoryVisited, and switch to reportExtraMemoryAllocated.
     // https://bugs.webkit.org/show_bug.cgi?id=142595
     vm.heap.deprecatedReportExtraMemory(memoryCost);
 }
 
-JSValue toJSNewlyCreated(ExecState* state, JSDOMGlobalObject* globalObject, Ref<Document>&& document)
+JSValue toJSNewlyCreated(JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, Ref<Document>&& document)
 {
-    return createNewDocumentWrapper(*state, *globalObject, WTFMove(document));
+    return createNewDocumentWrapper(*lexicalGlobalObject, *globalObject, WTFMove(document));
 }
 
-JSValue toJS(ExecState* state, JSDOMGlobalObject* globalObject, Document& document)
+JSValue toJS(JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, Document& document)
 {
-    if (auto* wrapper = cachedDocumentWrapper(*state, *globalObject, document))
+    if (auto* wrapper = cachedDocumentWrapper(*lexicalGlobalObject, *globalObject, document))
         return wrapper;
-    return toJSNewlyCreated(state, globalObject, Ref<Document>(document));
+    return toJSNewlyCreated(lexicalGlobalObject, globalObject, Ref<Document>(document));
 }
 
 void JSDocument::visitAdditionalChildren(SlotVisitor& visitor)
 {
     visitor.addOpaqueRoot(static_cast<ScriptExecutionContext*>(&wrapped()));

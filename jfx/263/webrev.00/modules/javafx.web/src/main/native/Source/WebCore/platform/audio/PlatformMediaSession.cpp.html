<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/audio/PlatformMediaSession.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;PlatformMediaSession.h&quot;
 28 
 29 #if ENABLE(VIDEO) || ENABLE(WEB_AUDIO)
 30 #include &quot;HTMLMediaElement.h&quot;
 31 #include &quot;Logging.h&quot;
 32 #include &quot;MediaPlayer.h&quot;
 33 #include &quot;PlatformMediaSessionManager.h&quot;
 34 
 35 namespace WebCore {
 36 
 37 static const Seconds clientDataBufferingTimerThrottleDelay { 100_ms };
 38 
 39 #if !RELEASE_LOG_DISABLED
 40 String convertEnumerationToString(PlatformMediaSession::State state)
 41 {
 42     static const NeverDestroyed&lt;String&gt; values[] = {
 43         MAKE_STATIC_STRING_IMPL(&quot;Idle&quot;),
 44         MAKE_STATIC_STRING_IMPL(&quot;Autoplaying&quot;),
 45         MAKE_STATIC_STRING_IMPL(&quot;Playing&quot;),
 46         MAKE_STATIC_STRING_IMPL(&quot;Paused&quot;),
 47         MAKE_STATIC_STRING_IMPL(&quot;Interrupted&quot;),
 48     };
 49     static_assert(!static_cast&lt;size_t&gt;(PlatformMediaSession::Idle), &quot;PlatformMediaSession::Idle is not 0 as expected&quot;);
 50     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::Autoplaying) == 1, &quot;PlatformMediaSession::Autoplaying is not 1 as expected&quot;);
 51     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::Playing) == 2, &quot;PlatformMediaSession::Playing is not 2 as expected&quot;);
 52     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::Paused) == 3, &quot;PlatformMediaSession::Paused is not 3 as expected&quot;);
 53     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::Interrupted) == 4, &quot;PlatformMediaSession::Interrupted is not 4 as expected&quot;);
 54     ASSERT(static_cast&lt;size_t&gt;(state) &lt; WTF_ARRAY_LENGTH(values));
 55     return values[static_cast&lt;size_t&gt;(state)];
 56 }
 57 
 58 String convertEnumerationToString(PlatformMediaSession::InterruptionType type)
 59 {
 60     static const NeverDestroyed&lt;String&gt; values[] = {
 61         MAKE_STATIC_STRING_IMPL(&quot;NoInterruption&quot;),
 62         MAKE_STATIC_STRING_IMPL(&quot;SystemSleep&quot;),
 63         MAKE_STATIC_STRING_IMPL(&quot;EnteringBackground&quot;),
 64         MAKE_STATIC_STRING_IMPL(&quot;SystemInterruption&quot;),
 65         MAKE_STATIC_STRING_IMPL(&quot;SuspendedUnderLock&quot;),
 66         MAKE_STATIC_STRING_IMPL(&quot;InvisibleAutoplay&quot;),
 67         MAKE_STATIC_STRING_IMPL(&quot;ProcessInactive&quot;),
 68     };
 69     static_assert(!static_cast&lt;size_t&gt;(PlatformMediaSession::NoInterruption), &quot;PlatformMediaSession::NoInterruption is not 0 as expected&quot;);
 70     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::SystemSleep) == 1, &quot;PlatformMediaSession::SystemSleep is not 1 as expected&quot;);
 71     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::EnteringBackground) == 2, &quot;PlatformMediaSession::EnteringBackground is not 2 as expected&quot;);
 72     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::SystemInterruption) == 3, &quot;PlatformMediaSession::SystemInterruption is not 3 as expected&quot;);
 73     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::SuspendedUnderLock) == 4, &quot;PlatformMediaSession::SuspendedUnderLock is not 4 as expected&quot;);
 74     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::InvisibleAutoplay) == 5, &quot;PlatformMediaSession::InvisibleAutoplay is not 5 as expected&quot;);
 75     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::ProcessInactive) == 6, &quot;PlatformMediaSession::ProcessInactive is not 6 as expected&quot;);
 76     ASSERT(static_cast&lt;size_t&gt;(type) &lt; WTF_ARRAY_LENGTH(values));
 77     return values[static_cast&lt;size_t&gt;(type)];
 78 }
 79 
 80 String convertEnumerationToString(PlatformMediaSession::RemoteControlCommandType command)
 81 {
 82     static const NeverDestroyed&lt;String&gt; values[] = {
 83         MAKE_STATIC_STRING_IMPL(&quot;NoCommand&quot;),
 84         MAKE_STATIC_STRING_IMPL(&quot;PlayCommand&quot;),
 85         MAKE_STATIC_STRING_IMPL(&quot;PauseCommand&quot;),
 86         MAKE_STATIC_STRING_IMPL(&quot;StopCommand&quot;),
 87         MAKE_STATIC_STRING_IMPL(&quot;TogglePlayPauseCommand&quot;),
 88         MAKE_STATIC_STRING_IMPL(&quot;BeginSeekingBackwardCommand&quot;),
 89         MAKE_STATIC_STRING_IMPL(&quot;EndSeekingBackwardCommand&quot;),
 90         MAKE_STATIC_STRING_IMPL(&quot;BeginSeekingForwardCommand&quot;),
 91         MAKE_STATIC_STRING_IMPL(&quot;EndSeekingForwardCommand&quot;),
 92         MAKE_STATIC_STRING_IMPL(&quot;SeekToPlaybackPositionCommand&quot;),
 93     };
 94     static_assert(!static_cast&lt;size_t&gt;(PlatformMediaSession::NoCommand), &quot;PlatformMediaSession::NoCommand is not 0 as expected&quot;);
 95     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::PlayCommand) == 1, &quot;PlatformMediaSession::PlayCommand is not 1 as expected&quot;);
 96     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::PauseCommand) == 2, &quot;PlatformMediaSession::PauseCommand is not 2 as expected&quot;);
 97     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::StopCommand) == 3, &quot;PlatformMediaSession::StopCommand is not 3 as expected&quot;);
 98     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::TogglePlayPauseCommand) == 4, &quot;PlatformMediaSession::TogglePlayPauseCommand is not 4 as expected&quot;);
 99     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::BeginSeekingBackwardCommand) == 5, &quot;PlatformMediaSession::BeginSeekingBackwardCommand is not 5 as expected&quot;);
100     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::EndSeekingBackwardCommand) == 6, &quot;PlatformMediaSession::EndSeekingBackwardCommand is not 6 as expected&quot;);
101     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::BeginSeekingForwardCommand) == 7, &quot;PlatformMediaSession::BeginSeekingForwardCommand is not 7 as expected&quot;);
102     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::EndSeekingForwardCommand) == 8, &quot;PlatformMediaSession::EndSeekingForwardCommand is not 8 as expected&quot;);
103     static_assert(static_cast&lt;size_t&gt;(PlatformMediaSession::SeekToPlaybackPositionCommand) == 9, &quot;PlatformMediaSession::SeekToPlaybackPositionCommand is not 9 as expected&quot;);
104     ASSERT(static_cast&lt;size_t&gt;(command) &lt; WTF_ARRAY_LENGTH(values));
105     return values[static_cast&lt;size_t&gt;(command)];
106 }
107 
108 #endif
109 
110 std::unique_ptr&lt;PlatformMediaSession&gt; PlatformMediaSession::create(PlatformMediaSessionClient&amp; client)
111 {
112     return makeUnique&lt;PlatformMediaSession&gt;(client);
113 }
114 
115 PlatformMediaSession::PlatformMediaSession(PlatformMediaSessionClient&amp; client)
116     : m_client(client)
117     , m_state(Idle)
118     , m_stateToRestore(Idle)
119     , m_notifyingClient(false)
120 #if !RELEASE_LOG_DISABLED
121     , m_logger(client.hostingDocument()-&gt;logger())
122     , m_logIdentifier(uniqueLogIdentifier())
123 #endif
124 {
125     ASSERT(m_client.mediaType() &gt;= None &amp;&amp; m_client.mediaType() &lt;= MediaStreamCapturingAudio);
126     PlatformMediaSessionManager::sharedManager().addSession(*this);
127 }
128 
129 PlatformMediaSession::~PlatformMediaSession()
130 {
131     PlatformMediaSessionManager::sharedManager().removeSession(*this);
132 }
133 
134 void PlatformMediaSession::setState(State state)
135 {
136     if (state == m_state)
137         return;
138 
139     INFO_LOG(LOGIDENTIFIER, state);
140     m_state = state;
141     if (m_state == State::Playing)
142         m_hasPlayedSinceLastInterruption = true;
143     PlatformMediaSessionManager::sharedManager().sessionStateChanged(*this);
144 }
145 
146 void PlatformMediaSession::beginInterruption(InterruptionType type)
147 {
148     INFO_LOG(LOGIDENTIFIER, &quot;state = &quot;, m_state, &quot;, interruption type = &quot;, type, &quot;, interruption count = &quot;, m_interruptionCount);
149 
150     // When interruptions are overridden, m_interruptionType doesn&#39;t get set.
151     // Give nested interruptions a chance when the previous interruptions were overridden.
152     if (++m_interruptionCount &gt; 1 &amp;&amp; m_interruptionType != NoInterruption)
153         return;
154 
155     if (client().shouldOverrideBackgroundPlaybackRestriction(type)) {
156         INFO_LOG(LOGIDENTIFIER, &quot;returning early because client says to override interruption&quot;);
157         return;
158     }
159 
160     m_stateToRestore = state();
161     m_notifyingClient = true;
162     setState(Interrupted);
163     m_interruptionType = type;
164     client().suspendPlayback();
165     m_notifyingClient = false;
166 }
167 
168 void PlatformMediaSession::endInterruption(EndInterruptionFlags flags)
169 {
170     INFO_LOG(LOGIDENTIFIER, &quot;flags = &quot;, (int)flags, &quot;, stateToRestore = &quot;, m_stateToRestore, &quot;, interruption count = &quot;, m_interruptionCount);
171 
172     if (!m_interruptionCount) {
173         INFO_LOG(LOGIDENTIFIER, &quot;!! ignoring spurious interruption end !!&quot;);
174         return;
175     }
176 
177     if (--m_interruptionCount)
178         return;
179 
180     if (m_interruptionType == NoInterruption)
181         return;
182 
183     State stateToRestore = m_stateToRestore;
184     m_stateToRestore = Idle;
185     m_interruptionType = NoInterruption;
186     setState(stateToRestore);
187 
188     if (stateToRestore == Autoplaying)
189         client().resumeAutoplaying();
190 
191     bool shouldResume = flags &amp; MayResumePlaying &amp;&amp; stateToRestore == Playing;
192     client().mayResumePlayback(shouldResume);
193 }
194 
195 void PlatformMediaSession::clientWillBeginAutoplaying()
196 {
197     if (m_notifyingClient)
198         return;
199 
200     INFO_LOG(LOGIDENTIFIER, &quot;state = &quot;, m_state);
201     if (state() == Interrupted) {
202         m_stateToRestore = Autoplaying;
203         INFO_LOG(LOGIDENTIFIER, &quot;      setting stateToRestore to \&quot;Autoplaying\&quot;&quot;);
204         return;
205     }
206 
207     setState(Autoplaying);
208 }
209 
210 bool PlatformMediaSession::clientWillBeginPlayback()
211 {
212     if (m_notifyingClient)
213         return true;
214 
215     INFO_LOG(LOGIDENTIFIER, &quot;state = &quot;, m_state);
216 
217     if (!PlatformMediaSessionManager::sharedManager().sessionWillBeginPlayback(*this)) {
218         if (state() == Interrupted)
219             m_stateToRestore = Playing;
220         return false;
221     }
222 
223     setState(Playing);
224     return true;
225 }
226 
227 bool PlatformMediaSession::processClientWillPausePlayback(DelayCallingUpdateNowPlaying shouldDelayCallingUpdateNowPlaying)
228 {
229     if (m_notifyingClient)
230         return true;
231 
232     INFO_LOG(LOGIDENTIFIER, &quot;state = &quot;, m_state);
233     if (state() == Interrupted) {
234         m_stateToRestore = Paused;
235         INFO_LOG(LOGIDENTIFIER, &quot;      setting stateToRestore to \&quot;Paused\&quot;&quot;);
236         return false;
237     }
238 
239     setState(Paused);
240     PlatformMediaSessionManager::sharedManager().sessionWillEndPlayback(*this, shouldDelayCallingUpdateNowPlaying);
241     return true;
242 }
243 
244 bool PlatformMediaSession::clientWillPausePlayback()
245 {
246     return processClientWillPausePlayback(DelayCallingUpdateNowPlaying::No);
247 }
248 
249 void PlatformMediaSession::clientWillBeDOMSuspended()
250 {
251     processClientWillPausePlayback(DelayCallingUpdateNowPlaying::Yes);
252 }
253 
254 void PlatformMediaSession::pauseSession()
255 {
256     INFO_LOG(LOGIDENTIFIER);
257     m_client.suspendPlayback();
258 }
259 
260 void PlatformMediaSession::stopSession()
261 {
262     INFO_LOG(LOGIDENTIFIER);
263     m_client.suspendPlayback();
264     PlatformMediaSessionManager::sharedManager().removeSession(*this);
265 }
266 
267 PlatformMediaSession::MediaType PlatformMediaSession::mediaType() const
268 {
269     return m_client.mediaType();
270 }
271 
272 PlatformMediaSession::MediaType PlatformMediaSession::presentationType() const
273 {
274     return m_client.presentationType();
275 }
276 
277 PlatformMediaSession::CharacteristicsFlags PlatformMediaSession::characteristics() const
278 {
279     return m_client.characteristics();
280 }
281 
282 #if ENABLE(VIDEO)
283 uint64_t PlatformMediaSession::uniqueIdentifier() const
284 {
285     return m_client.mediaSessionUniqueIdentifier();
286 }
287 
288 String PlatformMediaSession::title() const
289 {
290     return m_client.mediaSessionTitle();
291 }
292 
293 double PlatformMediaSession::duration() const
294 {
295     return m_client.mediaSessionDuration();
296 }
297 
298 double PlatformMediaSession::currentTime() const
299 {
300     return m_client.mediaSessionCurrentTime();
301 }
302 #endif
303 
304 bool PlatformMediaSession::canReceiveRemoteControlCommands() const
305 {
306     return m_client.canReceiveRemoteControlCommands();
307 }
308 
309 void PlatformMediaSession::didReceiveRemoteControlCommand(RemoteControlCommandType command, const PlatformMediaSession::RemoteCommandArgument* argument)
310 {
311     INFO_LOG(LOGIDENTIFIER, command);
312 
313     m_client.didReceiveRemoteControlCommand(command, argument);
314 }
315 
316 bool PlatformMediaSession::supportsSeeking() const
317 {
318     return m_client.supportsSeeking();
319 }
320 
321 String PlatformMediaSession::sourceApplicationIdentifier() const
322 {
323     return m_client.sourceApplicationIdentifier();
324 }
325 
326 bool PlatformMediaSession::isSuspended() const
327 {
328     return m_client.isSuspended();
329 }
330 
331 bool PlatformMediaSession::shouldOverrideBackgroundLoadingRestriction() const
332 {
333     return m_client.shouldOverrideBackgroundLoadingRestriction();
334 }
335 
336 void PlatformMediaSession::isPlayingToWirelessPlaybackTargetChanged(bool isWireless)
337 {
338     if (isWireless == m_isPlayingToWirelessPlaybackTarget)
339         return;
340 
341     m_isPlayingToWirelessPlaybackTarget = isWireless;
342 
343     // Save and restore the interruption count so it doesn&#39;t get out of sync if beginInterruption is called because
344     // if we in the background.
345     int interruptionCount = m_interruptionCount;
346     PlatformMediaSessionManager::sharedManager().sessionIsPlayingToWirelessPlaybackTargetChanged(*this);
347     m_interruptionCount = interruptionCount;
348 }
349 
350 PlatformMediaSession::DisplayType PlatformMediaSession::displayType() const
351 {
352     return m_client.displayType();
353 }
354 
355 bool PlatformMediaSession::activeAudioSessionRequired() const
356 {
357     if (mediaType() == PlatformMediaSession::None)
358         return false;
359     if (state() != PlatformMediaSession::State::Playing)
360         return false;
361     return canProduceAudio();
362 }
363 
364 bool PlatformMediaSession::canProduceAudio() const
365 {
366     return m_client.canProduceAudio();
367 }
368 
369 void PlatformMediaSession::canProduceAudioChanged()
370 {
371     PlatformMediaSessionManager::sharedManager().sessionCanProduceAudioChanged();
372 }
373 
374 #if ENABLE(VIDEO)
375 uint64_t PlatformMediaSessionClient::mediaSessionUniqueIdentifier() const
376 {
377     return 0;
378 }
379 
380 String PlatformMediaSessionClient::mediaSessionTitle() const
381 {
382     return String();
383 }
384 
385 double PlatformMediaSessionClient::mediaSessionDuration() const
386 {
387     return MediaPlayer::invalidTime();
388 }
389 
390 double PlatformMediaSessionClient::mediaSessionCurrentTime() const
391 {
392     return MediaPlayer::invalidTime();
393 }
394 #endif
395 
396 void PlatformMediaSession::clientCharacteristicsChanged()
397 {
398     PlatformMediaSessionManager::sharedManager().clientCharacteristicsChanged(*this);
399 }
400 
401 bool PlatformMediaSession::canPlayConcurrently(const PlatformMediaSession&amp; otherSession) const
402 {
403     return m_client.hasMediaStreamSource() &amp;&amp; otherSession.m_client.hasMediaStreamSource();
404 }
405 
406 bool PlatformMediaSession::shouldOverridePauseDuringRouteChange() const
407 {
408     return m_client.shouldOverridePauseDuringRouteChange();
409 }
410 
411 #if !RELEASE_LOG_DISABLED
412 WTFLogChannel&amp; PlatformMediaSession::logChannel() const
413 {
414     return LogMedia;
415 }
416 #endif
417 
418 }
419 
420 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/AssemblyHelpers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../interpreter/VMEntryRecord.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AssemblyHelpers.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/AssemblyHelpers.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 98,11 ***</span>
      ASSERT(flag &lt;= 32);
      and32(TrustedImm32(~(1u &lt;&lt; (flag - 1))), AbsoluteAddress(SamplingFlags::addressOfFlags()));
  }
  #endif
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  #if USE(JSVALUE64)
  void AssemblyHelpers::jitAssertIsInt32(GPRReg gpr)
  {
  #if CPU(X86_64) || CPU(ARM64)
      Jump checkInt32 = branch64(BelowOrEqual, gpr, TrustedImm64(static_cast&lt;uintptr_t&gt;(0xFFFFFFFFu)));
<span class="line-new-header">--- 98,11 ---</span>
      ASSERT(flag &lt;= 32);
      and32(TrustedImm32(~(1u &lt;&lt; (flag - 1))), AbsoluteAddress(SamplingFlags::addressOfFlags()));
  }
  #endif
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  #if USE(JSVALUE64)
  void AssemblyHelpers::jitAssertIsInt32(GPRReg gpr)
  {
  #if CPU(X86_64) || CPU(ARM64)
      Jump checkInt32 = branch64(BelowOrEqual, gpr, TrustedImm64(static_cast&lt;uintptr_t&gt;(0xFFFFFFFFu)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,47 ***</span>
  #endif
  }
  
  void AssemblyHelpers::jitAssertIsJSInt32(GPRReg gpr)
  {
<span class="line-modified">!     Jump checkJSInt32 = branch64(AboveOrEqual, gpr, GPRInfo::tagTypeNumberRegister);</span>
      abortWithReason(AHIsNotJSInt32);
      checkJSInt32.link(this);
  }
  
  void AssemblyHelpers::jitAssertIsJSNumber(GPRReg gpr)
  {
<span class="line-modified">!     Jump checkJSNumber = branchTest64(MacroAssembler::NonZero, gpr, GPRInfo::tagTypeNumberRegister);</span>
      abortWithReason(AHIsNotJSNumber);
      checkJSNumber.link(this);
  }
  
  void AssemblyHelpers::jitAssertIsJSDouble(GPRReg gpr)
  {
<span class="line-modified">!     Jump checkJSInt32 = branch64(AboveOrEqual, gpr, GPRInfo::tagTypeNumberRegister);</span>
<span class="line-modified">!     Jump checkJSNumber = branchTest64(MacroAssembler::NonZero, gpr, GPRInfo::tagTypeNumberRegister);</span>
      checkJSInt32.link(this);
      abortWithReason(AHIsNotJSDouble);
      checkJSNumber.link(this);
  }
  
  void AssemblyHelpers::jitAssertIsCell(GPRReg gpr)
  {
<span class="line-modified">!     Jump checkCell = branchTest64(MacroAssembler::Zero, gpr, GPRInfo::tagMaskRegister);</span>
      abortWithReason(AHIsNotCell);
      checkCell.link(this);
  }
  
  void AssemblyHelpers::jitAssertTagsInPlace()
  {
<span class="line-modified">!     Jump ok = branch64(Equal, GPRInfo::tagTypeNumberRegister, TrustedImm64(TagTypeNumber));</span>
<span class="line-modified">!     abortWithReason(AHTagTypeNumberNotInPlace);</span>
      breakpoint();
      ok.link(this);
  
<span class="line-modified">!     ok = branch64(Equal, GPRInfo::tagMaskRegister, TrustedImm64(TagMask));</span>
<span class="line-modified">!     abortWithReason(AHTagMaskNotInPlace);</span>
      ok.link(this);
  }
  #elif USE(JSVALUE32_64)
  void AssemblyHelpers::jitAssertIsInt32(GPRReg gpr)
  {
<span class="line-new-header">--- 113,47 ---</span>
  #endif
  }
  
  void AssemblyHelpers::jitAssertIsJSInt32(GPRReg gpr)
  {
<span class="line-modified">!     Jump checkJSInt32 = branch64(AboveOrEqual, gpr, GPRInfo::numberTagRegister);</span>
      abortWithReason(AHIsNotJSInt32);
      checkJSInt32.link(this);
  }
  
  void AssemblyHelpers::jitAssertIsJSNumber(GPRReg gpr)
  {
<span class="line-modified">!     Jump checkJSNumber = branchTest64(MacroAssembler::NonZero, gpr, GPRInfo::numberTagRegister);</span>
      abortWithReason(AHIsNotJSNumber);
      checkJSNumber.link(this);
  }
  
  void AssemblyHelpers::jitAssertIsJSDouble(GPRReg gpr)
  {
<span class="line-modified">!     Jump checkJSInt32 = branch64(AboveOrEqual, gpr, GPRInfo::numberTagRegister);</span>
<span class="line-modified">!     Jump checkJSNumber = branchTest64(MacroAssembler::NonZero, gpr, GPRInfo::numberTagRegister);</span>
      checkJSInt32.link(this);
      abortWithReason(AHIsNotJSDouble);
      checkJSNumber.link(this);
  }
  
  void AssemblyHelpers::jitAssertIsCell(GPRReg gpr)
  {
<span class="line-modified">!     Jump checkCell = branchTest64(MacroAssembler::Zero, gpr, GPRInfo::notCellMaskRegister);</span>
      abortWithReason(AHIsNotCell);
      checkCell.link(this);
  }
  
  void AssemblyHelpers::jitAssertTagsInPlace()
  {
<span class="line-modified">!     Jump ok = branch64(Equal, GPRInfo::numberTagRegister, TrustedImm64(JSValue::NumberTag));</span>
<span class="line-modified">!     abortWithReason(AHNumberTagNotInPlace);</span>
      breakpoint();
      ok.link(this);
  
<span class="line-modified">!     ok = branch64(Equal, GPRInfo::notCellMaskRegister, TrustedImm64(JSValue::NotCellMask));</span>
<span class="line-modified">!     abortWithReason(AHNotCellMaskNotInPlace);</span>
      ok.link(this);
  }
  #elif USE(JSVALUE32_64)
  void AssemblyHelpers::jitAssertIsInt32(GPRReg gpr)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,16 ***</span>
      checkNull.link(this);
  }
  
  void AssemblyHelpers::jitAssertArgumentCountSane()
  {
<span class="line-modified">!     Jump ok = branch32(Below, payloadFor(CallFrameSlot::argumentCount), TrustedImm32(10000000));</span>
      abortWithReason(AHInsaneArgumentCount);
      ok.link(this);
  }
  
<span class="line-modified">! #endif // !ASSERT_DISABLED</span>
  
  void AssemblyHelpers::jitReleaseAssertNoException(VM&amp; vm)
  {
      Jump noException;
  #if USE(JSVALUE64)
<span class="line-new-header">--- 209,16 ---</span>
      checkNull.link(this);
  }
  
  void AssemblyHelpers::jitAssertArgumentCountSane()
  {
<span class="line-modified">!     Jump ok = branch32(Below, payloadFor(CallFrameSlot::argumentCountIncludingThis), TrustedImm32(10000000));</span>
      abortWithReason(AHInsaneArgumentCount);
      ok.link(this);
  }
  
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
  void AssemblyHelpers::jitReleaseAssertNoException(VM&amp; vm)
  {
      Jump noException;
  #if USE(JSVALUE64)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 248,16 ***</span>
          move(TrustedImmPtr(buffer + GPRInfo::numberOfRegisters + i), GPRInfo::regT0);
          storeDouble(FPRInfo::toRegister(i), Address(GPRInfo::regT0));
      }
  
      // Set up one argument.
<span class="line-removed">- #if CPU(X86)</span>
<span class="line-removed">-     poke(GPRInfo::callFrameRegister, 0);</span>
<span class="line-removed">- #else</span>
      move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
<span class="line-removed">- #endif</span>
      move(TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationExceptionFuzz)), GPRInfo::nonPreservedNonReturnGPR);
      call(GPRInfo::nonPreservedNonReturnGPR, OperationPtrTag);
  
      for (unsigned i = 0; i &lt; FPRInfo::numberOfRegisters; ++i) {
          move(TrustedImmPtr(buffer + GPRInfo::numberOfRegisters + i), GPRInfo::regT0);
          loadDouble(Address(GPRInfo::regT0), FPRInfo::toRegister(i));
<span class="line-new-header">--- 248,13 ---</span>
          move(TrustedImmPtr(buffer + GPRInfo::numberOfRegisters + i), GPRInfo::regT0);
          storeDouble(FPRInfo::toRegister(i), Address(GPRInfo::regT0));
      }
  
      // Set up one argument.
      move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
      move(TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationExceptionFuzz)), GPRInfo::nonPreservedNonReturnGPR);
<span class="line-added">+     prepareCallOperation(vm);</span>
      call(GPRInfo::nonPreservedNonReturnGPR, OperationPtrTag);
  
      for (unsigned i = 0; i &lt; FPRInfo::numberOfRegisters; ++i) {
          move(TrustedImmPtr(buffer + GPRInfo::numberOfRegisters + i), GPRInfo::regT0);
          loadDouble(Address(GPRInfo::regT0), FPRInfo::toRegister(i));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,11 ***</span>
  void AssemblyHelpers::emitStoreStructureWithTypeInfo(AssemblyHelpers&amp; jit, TrustedImmPtr structure, RegisterID dest)
  {
      const Structure* structurePtr = reinterpret_cast&lt;const Structure*&gt;(structure.m_value);
  #if USE(JSVALUE64)
      jit.store64(TrustedImm64(structurePtr-&gt;idBlob()), MacroAssembler::Address(dest, JSCell::structureIDOffset()));
<span class="line-modified">!     if (!ASSERT_DISABLED) {</span>
          Jump correctStructure = jit.branch32(Equal, MacroAssembler::Address(dest, JSCell::structureIDOffset()), TrustedImm32(structurePtr-&gt;id()));
          jit.abortWithReason(AHStructureIDIsValid);
          correctStructure.link(&amp;jit);
  
          Jump correctIndexingType = jit.branch8(Equal, MacroAssembler::Address(dest, JSCell::indexingTypeAndMiscOffset()), TrustedImm32(structurePtr-&gt;indexingModeIncludingHistory()));
<span class="line-new-header">--- 313,11 ---</span>
  void AssemblyHelpers::emitStoreStructureWithTypeInfo(AssemblyHelpers&amp; jit, TrustedImmPtr structure, RegisterID dest)
  {
      const Structure* structurePtr = reinterpret_cast&lt;const Structure*&gt;(structure.m_value);
  #if USE(JSVALUE64)
      jit.store64(TrustedImm64(structurePtr-&gt;idBlob()), MacroAssembler::Address(dest, JSCell::structureIDOffset()));
<span class="line-modified">!     if (ASSERT_ENABLED) {</span>
          Jump correctStructure = jit.branch32(Equal, MacroAssembler::Address(dest, JSCell::structureIDOffset()), TrustedImm32(structurePtr-&gt;id()));
          jit.abortWithReason(AHStructureIDIsValid);
          correctStructure.link(&amp;jit);
  
          Jump correctIndexingType = jit.branch8(Equal, MacroAssembler::Address(dest, JSCell::indexingTypeAndMiscOffset()), TrustedImm32(structurePtr-&gt;indexingModeIncludingHistory()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 448,11 ***</span>
      // Now, scratch0 is always in range of int64_t. Safe to convert it to double with cvtsi2sdq.
      jit.convertInt64ToDouble(scratch0, result);
  
      // Convert `(53bit double integer value) / (1 &lt;&lt; 53)` to `(53bit double integer value) * (1.0 / (1 &lt;&lt; 53))`.
      // In latter case, `1.0 / (1 &lt;&lt; 53)` will become a double value represented as (mantissa = 0 &amp; exp = 970, it means 1e-(2**54)).
<span class="line-modified">!     static const double scale = 1.0 / (1ULL &lt;&lt; 53);</span>
  
      // Multiplying 1e-(2**54) with the double integer does not change anything of the mantissa part of the double integer.
      // It just reduces the exp part of the given 53bit double integer.
      // (Except for 0.0. This is specially handled and in this case, exp just becomes 0.)
      // Now we get 53bit precision random double value in [0, 1).
<span class="line-new-header">--- 445,11 ---</span>
      // Now, scratch0 is always in range of int64_t. Safe to convert it to double with cvtsi2sdq.
      jit.convertInt64ToDouble(scratch0, result);
  
      // Convert `(53bit double integer value) / (1 &lt;&lt; 53)` to `(53bit double integer value) * (1.0 / (1 &lt;&lt; 53))`.
      // In latter case, `1.0 / (1 &lt;&lt; 53)` will become a double value represented as (mantissa = 0 &amp; exp = 970, it means 1e-(2**54)).
<span class="line-modified">!     static constexpr double scale = 1.0 / (1ULL &lt;&lt; 53);</span>
  
      // Multiplying 1e-(2**54) with the double integer does not change anything of the mantissa part of the double integer.
      // It just reduces the exp part of the given 53bit double integer.
      // (Except for 0.0. This is specially handled and in this case, exp just becomes 0.)
      // Now we get 53bit precision random double value in [0, 1).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 626,18 ***</span>
  #else
      UNUSED_PARAM(topEntryFrame);
  #endif
  }
  
<span class="line-modified">! void AssemblyHelpers::emitDumbVirtualCall(VM&amp; vm, CallLinkInfo* info)</span>
  {
      move(TrustedImmPtr(info), GPRInfo::regT2);
      Call call = nearCall();
      addLinkTask(
          [=, &amp;vm] (LinkBuffer&amp; linkBuffer) {
              MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; virtualThunk = virtualThunkFor(vm, *info);
<span class="line-modified">!             info-&gt;setSlowStub(createJITStubRoutine(virtualThunk, vm, nullptr, true));</span>
              linkBuffer.link(call, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(virtualThunk.code()));
          });
  }
  
  #if USE(JSVALUE64)
<span class="line-new-header">--- 623,19 ---</span>
  #else
      UNUSED_PARAM(topEntryFrame);
  #endif
  }
  
<span class="line-modified">! void AssemblyHelpers::emitDumbVirtualCall(VM&amp; vm, JSGlobalObject* globalObject, CallLinkInfo* info)</span>
  {
      move(TrustedImmPtr(info), GPRInfo::regT2);
<span class="line-added">+     move(TrustedImmPtr(globalObject), GPRInfo::regT3);</span>
      Call call = nearCall();
      addLinkTask(
          [=, &amp;vm] (LinkBuffer&amp; linkBuffer) {
              MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; virtualThunk = virtualThunkFor(vm, *info);
<span class="line-modified">!             info-&gt;setSlowStub(GCAwareJITStubRoutine::create(virtualThunk, vm));</span>
              linkBuffer.link(call, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(virtualThunk.code()));
          });
  }
  
  #if USE(JSVALUE64)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 753,12 ***</span>
      move(invert ? TrustedImm32(0) : TrustedImm32(1), result);
      done.append(jump());
  
      notDouble.link(this);
  #if USE(JSVALUE64)
<span class="line-modified">!     static_assert(static_cast&lt;int32_t&gt;(ValueTrue) == ValueTrue, &quot;&quot;);</span>
<span class="line-removed">-     compare64(invert ? NotEqual : Equal, value.gpr(), TrustedImm32(ValueTrue), result);</span>
  #else
      move(invert ? TrustedImm32(1) : TrustedImm32(0), result);
      done.append(branchIfNotBoolean(value, InvalidGPRReg));
      compare32(invert ? Equal : NotEqual, value.payloadGPR(), TrustedImm32(0), result);
  #endif
<span class="line-new-header">--- 751,11 ---</span>
      move(invert ? TrustedImm32(0) : TrustedImm32(1), result);
      done.append(jump());
  
      notDouble.link(this);
  #if USE(JSVALUE64)
<span class="line-modified">!     compare64(invert ? NotEqual : Equal, value.gpr(), TrustedImm32(JSValue::ValueTrue), result);</span>
  #else
      move(invert ? TrustedImm32(1) : TrustedImm32(0), result);
      done.append(branchIfNotBoolean(value, InvalidGPRReg));
      compare32(invert ? Equal : NotEqual, value.payloadGPR(), TrustedImm32(0), result);
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 930,18 ***</span>
  #if CPU(X86_64) || CPU(ARM_THUMB2) || CPU(ARM64) || CPU(MIPS)
      move(TrustedImmPtr(buffer), GPRInfo::argumentGPR2);
      move(TrustedImmPtr(argument), GPRInfo::argumentGPR1);
      move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
      GPRReg scratch = selectScratchGPR(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::argumentGPR2);
<span class="line-removed">- #elif CPU(X86)</span>
<span class="line-removed">-     poke(GPRInfo::callFrameRegister, 0);</span>
<span class="line-removed">-     poke(TrustedImmPtr(argument), 1);</span>
<span class="line-removed">-     poke(TrustedImmPtr(buffer), 2);</span>
<span class="line-removed">-     GPRReg scratch = GPRInfo::regT0;</span>
  #else
  #error &quot;JIT not supported on this platform.&quot;
  #endif
      move(TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(function)), scratch);
      call(scratch, OperationPtrTag);
  
      move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::regT0);
      storePtr(TrustedImmPtr(nullptr), GPRInfo::regT0);
<span class="line-new-header">--- 927,14 ---</span>
  #if CPU(X86_64) || CPU(ARM_THUMB2) || CPU(ARM64) || CPU(MIPS)
      move(TrustedImmPtr(buffer), GPRInfo::argumentGPR2);
      move(TrustedImmPtr(argument), GPRInfo::argumentGPR1);
      move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
      GPRReg scratch = selectScratchGPR(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::argumentGPR2);
  #else
  #error &quot;JIT not supported on this platform.&quot;
  #endif
<span class="line-added">+     prepareCallOperation(vm);</span>
      move(TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(function)), scratch);
      call(scratch, OperationPtrTag);
  
      move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::regT0);
      storePtr(TrustedImmPtr(nullptr), GPRInfo::regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 993,21 ***</span>
      done.link(this);
      move(stackPointerRegister, scratch);
      storePtr(scratch, vm.addressOfLastStackTop());
  }
  
<span class="line-removed">- void AssemblyHelpers::emitPreparePreciseIndexMask32(GPRReg index, GPRReg length, GPRReg result)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (length == result) {</span>
<span class="line-removed">-         negPtr(length);</span>
<span class="line-removed">-         addPtr(index, length);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         move(index, result);</span>
<span class="line-removed">-         subPtr(length, result);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     rshiftPtr(TrustedImm32(preciseIndexMaskShift&lt;void*&gt;()), result);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  } // namespace JSC
  
  #endif // ENABLE(JIT)
  
<span class="line-new-header">--- 986,9 ---</span>
</pre>
<center><a href="../interpreter/VMEntryRecord.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AssemblyHelpers.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
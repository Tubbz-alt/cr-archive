<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/QualifiedName.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2005-2017 Apple Inc. All rights reserved.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &lt;wtf/HashTraits.h&gt;
 24 #include &lt;wtf/NeverDestroyed.h&gt;
 25 #include &lt;wtf/text/AtomString.h&gt;
 26 
 27 namespace WebCore {
 28 
 29 struct QualifiedNameComponents {
 30     StringImpl* m_prefix;
 31     StringImpl* m_localName;
 32     StringImpl* m_namespace;
 33 };
 34 
<a name="1" id="anc1"></a><span class="line-added"> 35 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(QualifiedName);</span>
<span class="line-added"> 36 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(QualifiedNameQualifiedNameImpl);</span>
<span class="line-added"> 37 </span>
 38 class QualifiedName {
<a name="2" id="anc2"></a><span class="line-modified"> 39     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(QualifiedName);</span>
 40 public:
 41     class QualifiedNameImpl : public RefCounted&lt;QualifiedNameImpl&gt; {
<a name="3" id="anc3"></a><span class="line-added"> 42         WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(QualifiedNameQualifiedNameImpl);</span>
 43     public:
 44         static Ref&lt;QualifiedNameImpl&gt; create(const AtomString&amp; prefix, const AtomString&amp; localName, const AtomString&amp; namespaceURI)
 45         {
 46             return adoptRef(*new QualifiedNameImpl(prefix, localName, namespaceURI));
 47         }
 48 
 49         WEBCORE_EXPORT ~QualifiedNameImpl();
 50 
 51         unsigned computeHash() const;
 52 
 53         mutable unsigned m_existingHash { 0 };
 54         const AtomString m_prefix;
 55         const AtomString m_localName;
 56         const AtomString m_namespace;
 57         mutable AtomString m_localNameUpper;
 58 
 59 #if ENABLE(JIT)
 60         static ptrdiff_t localNameMemoryOffset() { return OBJECT_OFFSETOF(QualifiedNameImpl, m_localName); }
 61         static ptrdiff_t namespaceMemoryOffset() { return OBJECT_OFFSETOF(QualifiedNameImpl, m_namespace); }
 62 #endif
 63 
 64     private:
 65         QualifiedNameImpl(const AtomString&amp; prefix, const AtomString&amp; localName, const AtomString&amp; namespaceURI)
 66             : m_prefix(prefix)
 67             , m_localName(localName)
 68             , m_namespace(namespaceURI)
 69         {
 70             ASSERT(!namespaceURI.isEmpty() || namespaceURI.isNull());
 71         }
 72     };
 73 
 74     WEBCORE_EXPORT QualifiedName(const AtomString&amp; prefix, const AtomString&amp; localName, const AtomString&amp; namespaceURI);
 75     explicit QualifiedName(WTF::HashTableDeletedValueType) : m_impl(WTF::HashTableDeletedValue) { }
 76     bool isHashTableDeletedValue() const { return m_impl.isHashTableDeletedValue(); }
 77 #ifdef QNAME_DEFAULT_CONSTRUCTOR
 78     QualifiedName() { }
 79 #endif
 80 
 81     bool operator==(const QualifiedName&amp; other) const { return m_impl == other.m_impl; }
 82     bool operator!=(const QualifiedName&amp; other) const { return !(*this == other); }
 83 
 84     bool matches(const QualifiedName&amp; other) const { return m_impl == other.m_impl || (localName() == other.localName() &amp;&amp; namespaceURI() == other.namespaceURI()); }
 85 
 86     bool hasPrefix() const { return !m_impl-&gt;m_prefix.isNull(); }
 87     void setPrefix(const AtomString&amp; prefix) { *this = QualifiedName(prefix, localName(), namespaceURI()); }
 88 
 89     const AtomString&amp; prefix() const { return m_impl-&gt;m_prefix; }
 90     const AtomString&amp; localName() const { return m_impl-&gt;m_localName; }
 91     const AtomString&amp; namespaceURI() const { return m_impl-&gt;m_namespace; }
 92 
 93     // Uppercased localName, cached for efficiency
 94     const AtomString&amp; localNameUpper() const;
 95 
 96     String toString() const;
 97 
 98     QualifiedNameImpl* impl() const { return m_impl.get(); }
 99 #if ENABLE(JIT)
100     static ptrdiff_t implMemoryOffset() { return OBJECT_OFFSETOF(QualifiedName, m_impl); }
101 #endif
102 
103     // Init routine for globals
104     WEBCORE_EXPORT static void init();
105 
106 private:
<a name="4" id="anc4"></a><span class="line-modified">107     static QualifiedNameImpl* hashTableDeletedValue() { return RefPtr&lt;QualifiedNameImpl&gt;::PtrTraits::hashTableDeletedValue(); }</span>
108 
109     RefPtr&lt;QualifiedNameImpl&gt; m_impl;
110 };
111 
112 extern LazyNeverDestroyed&lt;const QualifiedName&gt; anyName;
113 inline const QualifiedName&amp; anyQName() { return anyName; }
114 
115 const QualifiedName&amp; nullQName();
116 
117 inline bool operator==(const AtomString&amp; a, const QualifiedName&amp; q) { return a == q.localName(); }
118 inline bool operator!=(const AtomString&amp; a, const QualifiedName&amp; q) { return a != q.localName(); }
119 inline bool operator==(const QualifiedName&amp; q, const AtomString&amp; a) { return a == q.localName(); }
120 inline bool operator!=(const QualifiedName&amp; q, const AtomString&amp; a) { return a != q.localName(); }
121 
122 inline unsigned hashComponents(const QualifiedNameComponents&amp; buf)
123 {
124     return StringHasher::hashMemory&lt;sizeof(QualifiedNameComponents)&gt;(&amp;buf);
125 }
126 
127 struct QualifiedNameHash {
128     static unsigned hash(const QualifiedName&amp; name) { return hash(name.impl()); }
129 
130     static unsigned hash(const QualifiedName::QualifiedNameImpl* name)
131     {
132         if (!name-&gt;m_existingHash)
133             name-&gt;m_existingHash = name-&gt;computeHash();
134         return name-&gt;m_existingHash;
135     }
136 
137     static bool equal(const QualifiedName&amp; a, const QualifiedName&amp; b) { return a == b; }
138     static bool equal(const QualifiedName::QualifiedNameImpl* a, const QualifiedName::QualifiedNameImpl* b) { return a == b; }
139 
140     static const bool safeToCompareToEmptyOrDeleted = false;
141 };
142 
143 inline String QualifiedName::toString() const
144 {
145     if (!hasPrefix())
146         return localName();
147 
148     return prefix().string() + &#39;:&#39; + localName().string();
149 }
150 
151 } // namespace WebCore
152 
153 namespace WTF {
154 
155     template&lt;typename T&gt; struct DefaultHash;
156 
157     template&lt;&gt; struct DefaultHash&lt;WebCore::QualifiedName&gt; {
158         typedef WebCore::QualifiedNameHash Hash;
159     };
160 
161     template&lt;&gt; struct HashTraits&lt;WebCore::QualifiedName&gt; : SimpleClassHashTraits&lt;WebCore::QualifiedName&gt; {
162         static const bool emptyValueIsZero = false;
163         static WebCore::QualifiedName emptyValue() { return WebCore::nullQName(); }
164     };
165 
166 } // namespace WTF
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
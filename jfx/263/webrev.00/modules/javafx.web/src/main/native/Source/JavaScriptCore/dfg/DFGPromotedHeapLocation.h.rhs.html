<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPromotedHeapLocation.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGEdge.h&quot;
 31 #include &quot;DFGNodeOrigin.h&quot;
 32 #include &lt;wtf/HashTable.h&gt;
 33 #include &lt;wtf/PrintStream.h&gt;
 34 
 35 namespace JSC { namespace DFG {
 36 
 37 struct Node;
 38 
 39 // Promoted locations are like heap locations but are meant to be more precise. A heap location is
 40 // applicable to CSE scenarios, where it makes sense to speak of a location very abstractly. A
 41 // promoted heap location is for cases where we speak of a specific object and the compiler knows
 42 // this object&#39;s identity - for example, the object allocation has been eliminated and we turned the
 43 // fields into local variables. Because these two cases have subtly different needs, we use subtly
 44 // different structures. One of the really significant differences is that promoted locations can be
 45 // spoken of using either a descriptor which does not refer to any Node*&#39;s or with a heap location,
 46 // which is a descriptor with a Node* base.
 47 
 48 enum PromotedLocationKind {
 49     InvalidPromotedLocationKind,
 50 
 51     ActivationScopePLoc,
 52     ActivationSymbolTablePLoc,
 53     ArgumentCountPLoc,
 54     ArgumentPLoc,
 55     ArgumentsCalleePLoc,
 56     ClosureVarPLoc,
<a name="2" id="anc2"></a><span class="line-added"> 57     InternalFieldObjectPLoc,</span>
 58     FunctionActivationPLoc,
 59     FunctionExecutablePLoc,
 60     IndexedPropertyPLoc,
 61     NamedPropertyPLoc,
 62     PublicLengthPLoc,
 63     StructurePLoc,
 64     VectorLengthPLoc,
 65     SpreadPLoc,
 66     NewArrayWithSpreadArgumentPLoc,
 67     NewArrayBufferPLoc,
 68     RegExpObjectRegExpPLoc,
 69     RegExpObjectLastIndexPLoc,
 70 };
 71 
 72 class PromotedLocationDescriptor {
 73 public:
 74     PromotedLocationDescriptor(
 75         PromotedLocationKind kind = InvalidPromotedLocationKind, unsigned info = 0)
 76         : m_kind(kind)
 77         , m_info(info)
 78     {
 79     }
 80 
 81     PromotedLocationDescriptor(WTF::HashTableDeletedValueType)
 82         : m_kind(InvalidPromotedLocationKind)
 83         , m_info(1)
 84     {
 85     }
 86 
 87     bool operator!() const { return m_kind == InvalidPromotedLocationKind; }
 88 
 89     explicit operator bool() const { return !!*this; }
 90 
 91     PromotedLocationKind kind() const { return m_kind; }
 92     unsigned info() const { return m_info; }
 93 
 94     unsigned imm1() const { return static_cast&lt;uint32_t&gt;(m_kind); }
 95     unsigned imm2() const { return static_cast&lt;uint32_t&gt;(m_info); }
 96 
 97     unsigned hash() const
 98     {
 99         return m_kind + m_info;
100     }
101 
102     bool operator==(const PromotedLocationDescriptor&amp; other) const
103     {
104         return m_kind == other.m_kind
105             &amp;&amp; m_info == other.m_info;
106     }
107 
108     bool operator!=(const PromotedLocationDescriptor&amp; other) const
109     {
110         return !(*this == other);
111     }
112 
113     bool isHashTableDeletedValue() const
114     {
115         return m_kind == InvalidPromotedLocationKind &amp;&amp; m_info;
116     }
117 
118     bool neededForMaterialization() const
119     {
120         switch (kind()) {
121         case NamedPropertyPLoc:
122         case ClosureVarPLoc:
123         case RegExpObjectLastIndexPLoc:
<a name="3" id="anc3"></a><span class="line-added">124         case InternalFieldObjectPLoc:</span>
125             return false;
126 
127         default:
128             return true;
129         }
130     }
131 
132     void dump(PrintStream&amp; out) const;
133 
134 private:
135     PromotedLocationKind m_kind;
136     unsigned m_info;
137 };
138 
139 struct PromotedLocationDescriptorHash {
140     static unsigned hash(const PromotedLocationDescriptor&amp; key) { return key.hash(); }
141     static bool equal(const PromotedLocationDescriptor&amp; a, const PromotedLocationDescriptor&amp; b) { return a == b; }
<a name="4" id="anc4"></a><span class="line-modified">142     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
143 };
144 
145 class PromotedHeapLocation {
146 public:
147     PromotedHeapLocation(
148         PromotedLocationKind kind = InvalidPromotedLocationKind,
149         Node* base = nullptr, unsigned info = 0)
150         : m_base(base)
151         , m_meta(kind, info)
152     {
153     }
154 
155     PromotedHeapLocation(
156         PromotedLocationKind kind, Edge base, unsigned info = 0)
157         : PromotedHeapLocation(kind, base.node(), info)
158     {
159     }
160 
161     PromotedHeapLocation(Node* base, PromotedLocationDescriptor meta)
162         : m_base(base)
163         , m_meta(meta)
164     {
165     }
166 
167     PromotedHeapLocation(WTF::HashTableDeletedValueType)
168         : m_base(nullptr)
169         , m_meta(InvalidPromotedLocationKind, 1)
170     {
171     }
172 
173     Node* createHint(Graph&amp;, NodeOrigin, Node* value);
174 
175     bool operator!() const { return kind() == InvalidPromotedLocationKind; }
176 
177     PromotedLocationKind kind() const { return m_meta.kind(); }
178     Node* base() const { return m_base; }
179     unsigned info() const { return m_meta.info(); }
180     PromotedLocationDescriptor descriptor() const { return m_meta; }
181 
182     unsigned hash() const
183     {
184         return m_meta.hash() + WTF::PtrHash&lt;Node*&gt;::hash(m_base);
185     }
186 
187     bool operator==(const PromotedHeapLocation&amp; other) const
188     {
189         return m_base == other.m_base
190             &amp;&amp; m_meta == other.m_meta;
191     }
192 
193     bool isHashTableDeletedValue() const
194     {
195         return m_meta.isHashTableDeletedValue();
196     }
197 
198     void dump(PrintStream&amp; out) const;
199 
200 private:
201     Node* m_base;
202     PromotedLocationDescriptor m_meta;
203 };
204 
205 struct PromotedHeapLocationHash {
206     static unsigned hash(const PromotedHeapLocation&amp; key) { return key.hash(); }
207     static bool equal(const PromotedHeapLocation&amp; a, const PromotedHeapLocation&amp; b) { return a == b; }
<a name="5" id="anc5"></a><span class="line-modified">208     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
209 };
210 
211 } } // namespace JSC::DFG
212 
213 namespace WTF {
214 
215 void printInternal(PrintStream&amp;, JSC::DFG::PromotedLocationKind);
216 
217 template&lt;typename T&gt; struct DefaultHash;
218 template&lt;&gt; struct DefaultHash&lt;JSC::DFG::PromotedHeapLocation&gt; {
219     typedef JSC::DFG::PromotedHeapLocationHash Hash;
220 };
221 
222 template&lt;typename T&gt; struct HashTraits;
223 template&lt;&gt; struct HashTraits&lt;JSC::DFG::PromotedHeapLocation&gt; : SimpleClassHashTraits&lt;JSC::DFG::PromotedHeapLocation&gt; {
<a name="6" id="anc6"></a><span class="line-modified">224     static constexpr bool emptyValueIsZero = false;</span>
225 };
226 
227 template&lt;typename T&gt; struct DefaultHash;
228 template&lt;&gt; struct DefaultHash&lt;JSC::DFG::PromotedLocationDescriptor&gt; {
229     typedef JSC::DFG::PromotedLocationDescriptorHash Hash;
230 };
231 
232 template&lt;typename T&gt; struct HashTraits;
233 template&lt;&gt; struct HashTraits&lt;JSC::DFG::PromotedLocationDescriptor&gt; : SimpleClassHashTraits&lt;JSC::DFG::PromotedLocationDescriptor&gt; {
<a name="7" id="anc7"></a><span class="line-modified">234     static constexpr bool emptyValueIsZero = false;</span>
235 };
236 
237 } // namespace WTF
238 
239 #endif // ENABLE(DFG_JIT)
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
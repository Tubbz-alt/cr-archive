<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasession/WebMediaSessionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2015 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebMediaSessionManager.h&quot;
 28 
 29 #if ENABLE(WIRELESS_PLAYBACK_TARGET) &amp;&amp; !PLATFORM(IOS_FAMILY)
 30 
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;MediaPlaybackTargetPickerMock.h&quot;
 34 #include &quot;WebMediaSessionManagerClient.h&quot;
<a name="2" id="anc2"></a>

 35 #include &lt;wtf/text/StringBuilder.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 static const Seconds taskDelayInterval { 100_ms };
 40 
<a name="3" id="anc3"></a>





 41 struct ClientState {
 42     WTF_MAKE_STRUCT_FAST_ALLOCATED;
 43 
 44     explicit ClientState(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
 45         : client(client)
 46         , contextId(contextId)
 47     {
 48     }
 49 
 50     bool operator == (ClientState const&amp; other) const
 51     {
 52         return contextId == other.contextId &amp;&amp; &amp;client == &amp;other.client;
 53     }
 54 
 55     WebMediaSessionManagerClient&amp; client;
 56     uint64_t contextId { 0 };
 57     WebCore::MediaProducer::MediaStateFlags flags { WebCore::MediaProducer::IsNotPlaying };
 58     bool requestedPicker { false };
 59     bool previouslyRequestedPicker { false };
 60     bool configurationRequired { true };
 61     bool playedToEnd { false };
 62 };
 63 
 64 static bool flagsAreSet(MediaProducer::MediaStateFlags value, unsigned flags)
 65 {
 66     return value &amp; flags;
 67 }
 68 
<a name="4" id="anc4"></a><span class="line-modified"> 69 #if !LOG_DISABLED</span>
<span class="line-removed"> 70 static String mediaProducerStateString(MediaProducer::MediaStateFlags flags)</span>
 71 {
 72     StringBuilder string;
 73     if (flags &amp; MediaProducer::IsPlayingAudio)
<a name="5" id="anc5"></a><span class="line-modified"> 74         string.append(&quot;IsPlayingAudio + &quot;);</span>
 75     if (flags &amp; MediaProducer::IsPlayingVideo)
<a name="6" id="anc6"></a><span class="line-modified"> 76         string.append(&quot;IsPlayingVideo + &quot;);</span>
 77     if (flags &amp; MediaProducer::IsPlayingToExternalDevice)
<a name="7" id="anc7"></a><span class="line-modified"> 78         string.append(&quot;IsPlayingToExternalDevice + &quot;);</span>
 79     if (flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
<a name="8" id="anc8"></a><span class="line-modified"> 80         string.append(&quot;HasPlaybackTargetAvailabilityListener + &quot;);</span>
 81     if (flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring)
<a name="9" id="anc9"></a><span class="line-modified"> 82         string.append(&quot;RequiresPlaybackTargetMonitoring + &quot;);</span>
 83     if (flags &amp; MediaProducer::ExternalDeviceAutoPlayCandidate)
<a name="10" id="anc10"></a><span class="line-modified"> 84         string.append(&quot;ExternalDeviceAutoPlayCandidate + &quot;);</span>
 85     if (flags &amp; MediaProducer::DidPlayToEnd)
<a name="11" id="anc11"></a><span class="line-modified"> 86         string.append(&quot;DidPlayToEnd + &quot;);</span>
 87     if (flags &amp; MediaProducer::HasAudioOrVideo)
<a name="12" id="anc12"></a><span class="line-modified"> 88         string.append(&quot;HasAudioOrVideo + &quot;);</span>
 89     if (string.isEmpty())
 90         string.append(&quot;IsNotPlaying&quot;);
 91     else
<a name="13" id="anc13"></a><span class="line-modified"> 92         string.resize(string.length() - 2);</span>
 93 
<a name="14" id="anc14"></a><span class="line-modified"> 94     return string.toString();</span>
 95 }
<a name="15" id="anc15"></a><span class="line-removed"> 96 #endif</span>
 97 
<a name="16" id="anc16"></a><span class="line-modified"> 98 void WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled(bool enabled)</span>








































 99 {
<a name="17" id="anc17"></a><span class="line-modified">100     LOG(Media, &quot;WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled - enabled = %i&quot;, (int)enabled);</span>

101 
<a name="18" id="anc18"></a>











102     if (m_mockPickerEnabled == enabled)
103         return;
104 
<a name="19" id="anc19"></a>
105     m_mockPickerEnabled = enabled;
106 }
107 
108 void WebMediaSessionManager::setMockMediaPlaybackTargetPickerState(const String&amp; name, MediaPlaybackTargetContext::State state)
109 {
<a name="20" id="anc20"></a><span class="line-modified">110     LOG(Media, &quot;WebMediaSessionManager::setMockMediaPlaybackTargetPickerState - name = %s, state = %i&quot;, name.utf8().data(), (int)state);</span>
<span class="line-removed">111 </span>
112     mockPicker().setState(name, state);
113 }
114 
<a name="21" id="anc21"></a>





115 MediaPlaybackTargetPickerMock&amp; WebMediaSessionManager::mockPicker()
116 {
117     if (!m_pickerOverride)
118         m_pickerOverride = makeUnique&lt;MediaPlaybackTargetPickerMock&gt;(*this);
119 
120     return *m_pickerOverride.get();
121 }
122 
123 WebCore::MediaPlaybackTargetPicker&amp; WebMediaSessionManager::targetPicker()
124 {
125     if (m_mockPickerEnabled)
126         return mockPicker();
127 
128     return platformPicker();
129 }
130 
131 WebMediaSessionManager::WebMediaSessionManager()
132     : m_taskTimer(RunLoop::current(), this, &amp;WebMediaSessionManager::taskTimerFired)
133     , m_watchdogTimer(RunLoop::current(), this, &amp;WebMediaSessionManager::watchdogTimerFired)
134 {
135 }
136 
137 WebMediaSessionManager::~WebMediaSessionManager() = default;
138 
139 uint64_t WebMediaSessionManager::addPlaybackTargetPickerClient(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
140 {
141     size_t index = find(&amp;client, contextId);
142     ASSERT(index == notFound);
143     if (index != notFound)
144         return 0;
145 
<a name="22" id="anc22"></a><span class="line-modified">146     LOG(Media, &quot;WebMediaSessionManager::addPlaybackTargetPickerClient(%p + %llu)&quot;, &amp;client, contextId);</span>
<span class="line-removed">147 </span>
148     m_clientState.append(makeUnique&lt;ClientState&gt;(client, contextId));
149 
150     if (m_externalOutputDeviceAvailable || m_playbackTarget)
151         scheduleDelayedTask(InitialConfigurationTask | TargetClientsConfigurationTask);
152 
153     return contextId;
154 }
155 
156 void WebMediaSessionManager::removePlaybackTargetPickerClient(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
157 {
158     size_t index = find(&amp;client, contextId);
159     ASSERT(index != notFound);
160     if (index == notFound)
161         return;
162 
<a name="23" id="anc23"></a><span class="line-modified">163     LOG(Media, &quot;WebMediaSessionManager::removePlaybackTargetPickerClient(%p + %llu)&quot;, &amp;client, contextId);</span>
164 
165     m_clientState.remove(index);
166     scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
167 }
168 
169 void WebMediaSessionManager::removeAllPlaybackTargetPickerClients(WebMediaSessionManagerClient&amp; client)
170 {
171     if (m_clientState.isEmpty())
172         return;
173 
<a name="24" id="anc24"></a><span class="line-removed">174     LOG(Media, &quot;WebMediaSessionManager::removeAllPlaybackTargetPickerClients(%p)&quot;, &amp;client);</span>
<span class="line-removed">175 </span>
176     for (size_t i = m_clientState.size(); i &gt; 0; --i) {
<a name="25" id="anc25"></a><span class="line-modified">177         if (&amp;m_clientState[i - 1]-&gt;client == &amp;client)</span>

178             m_clientState.remove(i - 1);
<a name="26" id="anc26"></a>
179     }
180     scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
181 }
182 
183 void WebMediaSessionManager::showPlaybackTargetPicker(WebMediaSessionManagerClient&amp; client, uint64_t contextId, const IntRect&amp; rect, bool, bool useDarkAppearance)
184 {
185     size_t index = find(&amp;client, contextId);
186     ASSERT(index != notFound);
187     if (index == notFound)
188         return;
189 
190     auto&amp; clientRequestingPicker = m_clientState[index];
191     for (auto&amp; state : m_clientState) {
192         state-&gt;requestedPicker = state == clientRequestingPicker;
193         state-&gt;previouslyRequestedPicker = state == clientRequestingPicker;
194     }
195 
<a name="27" id="anc27"></a>

196     bool hasActiveRoute = flagsAreSet(m_clientState[index]-&gt;flags, MediaProducer::IsPlayingToExternalDevice);
<a name="28" id="anc28"></a><span class="line-removed">197     LOG(Media, &quot;WebMediaSessionManager::showPlaybackTargetPicker(%p + %llu) - hasActiveRoute = %i&quot;, &amp;client, contextId, (int)hasActiveRoute);</span>
198     targetPicker().showPlaybackTargetPicker(FloatRect(rect), hasActiveRoute, useDarkAppearance);
199 }
200 
201 void WebMediaSessionManager::clientStateDidChange(WebMediaSessionManagerClient&amp; client, uint64_t contextId, MediaProducer::MediaStateFlags newFlags)
202 {
203     size_t index = find(&amp;client, contextId);
204     ASSERT(index != notFound);
205     if (index == notFound)
206         return;
207 
208     auto&amp; changedClientState = m_clientState[index];
209     MediaProducer::MediaStateFlags oldFlags = changedClientState-&gt;flags;
210     if (newFlags == oldFlags)
211         return;
212 
<a name="29" id="anc29"></a><span class="line-modified">213     LOG(Media, &quot;WebMediaSessionManager::clientStateDidChange(%p + %llu) - new flags = %s, old flags = %s&quot;, &amp;client, contextId, mediaProducerStateString(newFlags).utf8().data(), mediaProducerStateString(oldFlags).utf8().data());</span>
214 
215     changedClientState-&gt;flags = newFlags;
216 
217     MediaProducer::MediaStateFlags updateConfigurationFlags = MediaProducer::RequiresPlaybackTargetMonitoring | MediaProducer::HasPlaybackTargetAvailabilityListener | MediaProducer::HasAudioOrVideo;
218     if ((oldFlags &amp; updateConfigurationFlags) != (newFlags &amp; updateConfigurationFlags))
219         scheduleDelayedTask(TargetMonitoringConfigurationTask);
220 
221     MediaProducer::MediaStateFlags playingToTargetFlags = MediaProducer::IsPlayingToExternalDevice | MediaProducer::IsPlayingVideo;
222     if ((oldFlags &amp; playingToTargetFlags) != (newFlags &amp; playingToTargetFlags)) {
223         if (flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo) &amp;&amp; !flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) &amp;&amp; flagsAreSet(newFlags, MediaProducer::DidPlayToEnd))
224             changedClientState-&gt;playedToEnd = true;
225         scheduleDelayedTask(WatchdogTimerConfigurationTask);
226     }
227 
228     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute() || !flagsAreSet(newFlags, MediaProducer::ExternalDeviceAutoPlayCandidate))
229         return;
230 
231     // Do not interrupt another element already playing to a device.
232     for (auto&amp; state : m_clientState) {
233         if (state == changedClientState)
234             continue;
235 
<a name="30" id="anc30"></a><span class="line-modified">236         if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo))</span>

237             return;
<a name="31" id="anc31"></a>
238     }
239 
240     // Do not begin playing to the device unless playback has just started.
<a name="32" id="anc32"></a><span class="line-modified">241     if (!flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) || flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo))</span>

242         return;
<a name="33" id="anc33"></a>
243 
244     for (auto&amp; state : m_clientState) {
245         if (state == changedClientState)
246             continue;
<a name="34" id="anc34"></a>
247         state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
248     }
249 
<a name="35" id="anc35"></a>
250     changedClientState-&gt;client.setShouldPlayToPlaybackTarget(changedClientState-&gt;contextId, true);
251 
252     if (index &amp;&amp; m_clientState.size() &gt; 1)
253         std::swap(m_clientState.at(index), m_clientState.at(0));
254 }
255 
256 void WebMediaSessionManager::setPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
257 {
<a name="36" id="anc36"></a>
258     m_playbackTarget = WTFMove(target);
259     m_targetChanged = true;
260     scheduleDelayedTask(TargetClientsConfigurationTask);
261 }
262 
263 void WebMediaSessionManager::externalOutputDeviceAvailableDidChange(bool available)
264 {
<a name="37" id="anc37"></a><span class="line-modified">265     LOG(Media, &quot;WebMediaSessionManager::externalOutputDeviceAvailableDidChange - clients = %zu, available = %i&quot;, m_clientState.size(), (int)available);</span>
<span class="line-removed">266 </span>
267     m_externalOutputDeviceAvailable = available;
268     for (auto&amp; state : m_clientState)
269         state-&gt;client.externalOutputDeviceAvailableDidChange(state-&gt;contextId, available);
270 }
271 
<a name="38" id="anc38"></a>






272 void WebMediaSessionManager::configureNewClients()
273 {
274     for (auto&amp; state : m_clientState) {
275         if (!state-&gt;configurationRequired)
276             continue;
277 
278         state-&gt;configurationRequired = false;
279         if (m_externalOutputDeviceAvailable)
280             state-&gt;client.externalOutputDeviceAvailableDidChange(state-&gt;contextId, true);
281 
282         if (m_playbackTarget)
283             state-&gt;client.setPlaybackTarget(state-&gt;contextId, *m_playbackTarget.copyRef());
284     }
285 }
286 
287 void WebMediaSessionManager::configurePlaybackTargetClients()
288 {
289     if (m_clientState.isEmpty())
290         return;
291 
292     size_t indexOfClientThatRequestedPicker = notFound;
293     size_t indexOfLastClientToRequestPicker = notFound;
294     size_t indexOfClientWillPlayToTarget = notFound;
295     bool haveActiveRoute = m_playbackTarget &amp;&amp; m_playbackTarget-&gt;hasActiveRoute();
296 
297     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
298         auto&amp; state = m_clientState[i];
299 
<a name="39" id="anc39"></a><span class="line-modified">300         LOG(Media, &quot;WebMediaSessionManager::configurePlaybackTargetClients %zu - client (%p + %llu) requestedPicker = %i, flags = %s&quot;, i, &amp;state-&gt;client, state-&gt;contextId, state-&gt;requestedPicker, mediaProducerStateString(state-&gt;flags).utf8().data());</span>
301 
<a name="40" id="anc40"></a><span class="line-modified">302         if (m_targetChanged &amp;&amp; state-&gt;requestedPicker)</span>
303             indexOfClientThatRequestedPicker = i;
304 
305         if (indexOfClientWillPlayToTarget == notFound &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice))
306             indexOfClientWillPlayToTarget = i;
307 
308         if (indexOfClientWillPlayToTarget == notFound &amp;&amp; haveActiveRoute &amp;&amp; state-&gt;previouslyRequestedPicker)
309             indexOfLastClientToRequestPicker = i;
310     }
311 
312     if (indexOfClientThatRequestedPicker != notFound)
313         indexOfClientWillPlayToTarget = indexOfClientThatRequestedPicker;
314     if (indexOfClientWillPlayToTarget == notFound &amp;&amp; indexOfLastClientToRequestPicker != notFound)
315         indexOfClientWillPlayToTarget = indexOfLastClientToRequestPicker;
316     if (indexOfClientWillPlayToTarget == notFound &amp;&amp; haveActiveRoute &amp;&amp; flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::ExternalDeviceAutoPlayCandidate) &amp;&amp; !flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::IsPlayingVideo))
317         indexOfClientWillPlayToTarget = 0;
318 
<a name="41" id="anc41"></a><span class="line-removed">319     LOG(Media, &quot;WebMediaSessionManager::configurePlaybackTargetClients - indexOfClientWillPlayToTarget = %zu&quot;, indexOfClientWillPlayToTarget);</span>
<span class="line-removed">320 </span>
321     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
322         auto&amp; state = m_clientState[i];
323 
324         if (m_playbackTarget)
325             state-&gt;client.setPlaybackTarget(state-&gt;contextId, *m_playbackTarget.copyRef());
326 
<a name="42" id="anc42"></a><span class="line-modified">327         if (i != indexOfClientWillPlayToTarget || !haveActiveRoute)</span>

328             state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
<a name="43" id="anc43"></a>





329 
330         state-&gt;configurationRequired = false;
<a name="44" id="anc44"></a><span class="line-modified">331         if (m_targetChanged)</span>
332             state-&gt;requestedPicker = false;
333     }
334 
335     if (haveActiveRoute &amp;&amp; indexOfClientWillPlayToTarget != notFound) {
336         auto&amp; state = m_clientState[indexOfClientWillPlayToTarget];
<a name="45" id="anc45"></a><span class="line-modified">337         if (!flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice))</span>

338             state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, true);
<a name="46" id="anc46"></a>
339     }
340 
341     m_targetChanged = false;
342     configureWatchdogTimer();
343 }
344 
345 void WebMediaSessionManager::configurePlaybackTargetMonitoring()
346 {
347     bool monitoringRequired = false;
348     bool hasAvailabilityListener = false;
349     bool haveClientWithMedia = false;
350     for (auto&amp; state : m_clientState) {
<a name="47" id="anc47"></a>
351         if (state-&gt;flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring) {
352             monitoringRequired = true;
353             break;
354         }
355         if (state-&gt;flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
356             hasAvailabilityListener = true;
357         if (state-&gt;flags &amp; MediaProducer::HasAudioOrVideo)
358             haveClientWithMedia = true;
359     }
360 
<a name="48" id="anc48"></a><span class="line-modified">361     LOG(Media, &quot;WebMediaSessionManager::configurePlaybackTargetMonitoring - monitoringRequired = %i&quot;, static_cast&lt;int&gt;(monitoringRequired || (hasAvailabilityListener &amp;&amp; haveClientWithMedia)));</span>
<span class="line-modified">362 </span>
<span class="line-removed">363     if (monitoringRequired || (hasAvailabilityListener &amp;&amp; haveClientWithMedia))</span>
364         targetPicker().startingMonitoringPlaybackTargets();
<a name="49" id="anc49"></a><span class="line-modified">365     else</span>

366         targetPicker().stopMonitoringPlaybackTargets();
<a name="50" id="anc50"></a>
367 }
368 
<a name="51" id="anc51"></a><span class="line-removed">369 #if !LOG_DISABLED</span>
<span class="line-removed">370 String WebMediaSessionManager::toString(ConfigurationTasks tasks)</span>
<span class="line-removed">371 {</span>
<span class="line-removed">372     StringBuilder string;</span>
<span class="line-removed">373     if (tasks &amp; InitialConfigurationTask)</span>
<span class="line-removed">374         string.append(&quot;InitialConfigurationTask + &quot;);</span>
<span class="line-removed">375     if (tasks &amp; TargetClientsConfigurationTask)</span>
<span class="line-removed">376         string.append(&quot;TargetClientsConfigurationTask + &quot;);</span>
<span class="line-removed">377     if (tasks &amp; TargetMonitoringConfigurationTask)</span>
<span class="line-removed">378         string.append(&quot;TargetMonitoringConfigurationTask + &quot;);</span>
<span class="line-removed">379     if (tasks &amp; WatchdogTimerConfigurationTask)</span>
<span class="line-removed">380         string.append(&quot;WatchdogTimerConfigurationTask + &quot;);</span>
<span class="line-removed">381     if (string.isEmpty())</span>
<span class="line-removed">382         string.append(&quot;NoTask&quot;);</span>
<span class="line-removed">383     else</span>
<span class="line-removed">384         string.resize(string.length() - 2);</span>
<span class="line-removed">385 </span>
<span class="line-removed">386     return string.toString();</span>
<span class="line-removed">387 }</span>
<span class="line-removed">388 #endif</span>
<span class="line-removed">389 </span>
390 void WebMediaSessionManager::scheduleDelayedTask(ConfigurationTasks tasks)
391 {
<a name="52" id="anc52"></a><span class="line-removed">392     LOG(Media, &quot;WebMediaSessionManager::scheduleDelayedTask - %s&quot;, toString(tasks).utf8().data());</span>
<span class="line-removed">393 </span>
394     m_taskFlags |= tasks;
395     m_taskTimer.startOneShot(taskDelayInterval);
396 }
397 
398 void WebMediaSessionManager::taskTimerFired()
399 {
<a name="53" id="anc53"></a><span class="line-removed">400     LOG(Media, &quot;WebMediaSessionManager::taskTimerFired - tasks = %s&quot;, toString(m_taskFlags).utf8().data());</span>
<span class="line-removed">401 </span>
402     if (m_taskFlags &amp; InitialConfigurationTask)
403         configureNewClients();
404     if (m_taskFlags &amp; TargetClientsConfigurationTask)
405         configurePlaybackTargetClients();
406     if (m_taskFlags &amp; TargetMonitoringConfigurationTask)
407         configurePlaybackTargetMonitoring();
408     if (m_taskFlags &amp; WatchdogTimerConfigurationTask)
409         configureWatchdogTimer();
410 
411     m_taskFlags = NoTask;
412 }
413 
414 size_t WebMediaSessionManager::find(WebMediaSessionManagerClient* client, uint64_t contextId)
415 {
416     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
417         if (m_clientState[i]-&gt;contextId == contextId &amp;&amp; &amp;m_clientState[i]-&gt;client == client)
418             return i;
419     }
420 
421     return notFound;
422 }
423 
424 void WebMediaSessionManager::configureWatchdogTimer()
425 {
426     static const Seconds watchdogTimerIntervalAfterPausing { 1_h };
427     static const Seconds watchdogTimerIntervalAfterPlayingToEnd { 8_min };
428 
429     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute()) {
<a name="54" id="anc54"></a><span class="line-modified">430         m_watchdogTimer.stop();</span>





431         return;
432     }
433 
434     bool stopTimer = false;
435     bool didPlayToEnd = false;
436     for (auto&amp; state : m_clientState) {
<a name="55" id="anc55"></a>


437         if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo))
438             stopTimer = true;
439         if (state-&gt;playedToEnd)
440             didPlayToEnd = true;
441         state-&gt;playedToEnd = false;
442     }
443 
444     if (stopTimer) {
<a name="56" id="anc56"></a>
445         m_currentWatchdogInterval = { };
446         m_watchdogTimer.stop();
<a name="57" id="anc57"></a><span class="line-removed">447         LOG(Media, &quot;WebMediaSessionManager::configureWatchdogTimer - timer stopped&quot;);</span>
448     } else {
449         Seconds interval = didPlayToEnd ? watchdogTimerIntervalAfterPlayingToEnd : watchdogTimerIntervalAfterPausing;
450         if (interval != m_currentWatchdogInterval || !m_watchdogTimer.isActive()) {
451             m_watchdogTimer.startOneShot(interval);
<a name="58" id="anc58"></a><span class="line-removed">452             LOG(Media, &quot;WebMediaSessionManager::configureWatchdogTimer - timer scheduled for %.0f seconds&quot;, interval.value());</span>
453         }
<a name="59" id="anc59"></a>
454         m_currentWatchdogInterval = interval;
455     }
456 }
457 
458 void WebMediaSessionManager::watchdogTimerFired()
459 {
<a name="60" id="anc60"></a><span class="line-removed">460     LOG(Media, &quot;WebMediaSessionManager::watchdogTimerFired&quot;);</span>
461     if (!m_playbackTarget)
462         return;
463 
<a name="61" id="anc61"></a>
464     targetPicker().invalidatePlaybackTargets();
465 }
466 
467 } // namespace WebCore
468 
469 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET) &amp;&amp; !PLATFORM(IOS_FAMILY)
<a name="62" id="anc62"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="62" type="hidden" />
</body>
</html>
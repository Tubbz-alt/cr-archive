<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/GetByStatus.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012-2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CacheableIdentifier.h&quot;
 29 #include &quot;CallLinkStatus.h&quot;
 30 #include &quot;CodeOrigin.h&quot;
 31 #include &quot;ConcurrentJSLock.h&quot;
 32 #include &quot;ExitFlag.h&quot;
 33 #include &quot;GetByIdVariant.h&quot;
 34 #include &quot;ICStatusMap.h&quot;
 35 #include &quot;ScopeOffset.h&quot;
 36 #include &quot;StubInfoSummary.h&quot;
 37 
 38 namespace JSC {
 39 
 40 class AccessCase;
 41 class CodeBlock;
 42 class JSModuleEnvironment;
 43 class JSModuleNamespaceObject;
 44 class ModuleNamespaceAccessCase;
 45 class StructureStubInfo;
 46 
 47 class GetByStatus final {
 48     WTF_MAKE_FAST_ALLOCATED;
 49 public:
 50     enum State : uint8_t {
 51         // It&#39;s uncached so we have no information.
 52         NoInformation,
 53         // It&#39;s cached for a simple access to a known object property with
 54         // a possible structure chain and a possible specific value.
 55         Simple,
 56         // It&#39;s cached for a custom accessor with a possible structure chain.
 57         Custom,
 58         // It&#39;s cached for an access to a module namespace object&#39;s binding.
 59         ModuleNamespace,
 60         // It will likely take the slow path.
 61         LikelyTakesSlowPath,
 62         // It&#39;s known to take slow path. We also observed that the slow path was taken on StructureStubInfo.
 63         ObservedTakesSlowPath,
 64         // It will likely take the slow path and will make calls.
 65         MakesCalls,
 66         // It known to take paths that make calls. We also observed that the slow path was taken on StructureStubInfo.
 67         ObservedSlowPathAndMakesCalls ,
 68     };
 69 
 70     GetByStatus()
 71         : m_state(NoInformation)
 72     {
 73     }
 74 
 75     explicit GetByStatus(State state)
 76         : m_state(state)
 77     {
 78         ASSERT(state == NoInformation || state == LikelyTakesSlowPath || state == ObservedTakesSlowPath || state == MakesCalls || state == ObservedSlowPathAndMakesCalls);
 79     }
 80 
 81     explicit GetByStatus(StubInfoSummary, StructureStubInfo&amp;);
 82 
 83     GetByStatus(
 84         State state, bool wasSeenInJIT)
 85         : m_state(state)
 86         , m_wasSeenInJIT(wasSeenInJIT)
 87     {
 88     }
 89 
 90     static GetByStatus computeFor(CodeBlock* baselineBlock, ICStatusMap&amp; baselineMap, ICStatusContextStack&amp; dfgContextStack, CodeOrigin);
 91     static GetByStatus computeFor(const StructureSet&amp;, UniquedStringImpl*);
 92 
 93     State state() const { return m_state; }
 94 
 95     bool isSet() const { return m_state != NoInformation; }
 96     explicit operator bool() const { return isSet(); }
 97     bool isSimple() const { return m_state == Simple; }
 98     bool isCustom() const { return m_state == Custom; }
 99     bool isModuleNamespace() const { return m_state == ModuleNamespace; }
100 
101     size_t numVariants() const { return m_variants.size(); }
102     const Vector&lt;GetByIdVariant, 1&gt;&amp; variants() const { return m_variants; }
103     const GetByIdVariant&amp; at(size_t index) const { return m_variants[index]; }
104     const GetByIdVariant&amp; operator[](size_t index) const { return at(index); }
105 
106     bool takesSlowPath() const { return m_state == LikelyTakesSlowPath || m_state == ObservedTakesSlowPath || m_state == MakesCalls || m_state == ObservedSlowPathAndMakesCalls || m_state == Custom || m_state == ModuleNamespace; }
107     bool observedStructureStubInfoSlowPath() const { return m_state == ObservedTakesSlowPath || m_state == ObservedSlowPathAndMakesCalls; }
108     bool makesCalls() const;
109 
110     GetByStatus slowVersion() const;
111 
112     bool wasSeenInJIT() const { return m_wasSeenInJIT; }
113 
114     // Attempts to reduce the set of variants to fit the given structure set. This may be approximate.
115     void filter(const StructureSet&amp;);
116 
117     JSModuleNamespaceObject* moduleNamespaceObject() const { return m_moduleNamespaceData-&gt;m_moduleNamespaceObject; }
118     JSModuleEnvironment* moduleEnvironment() const { return m_moduleNamespaceData-&gt;m_moduleEnvironment; }
119     ScopeOffset scopeOffset() const { return m_moduleNamespaceData-&gt;m_scopeOffset; }
120 
121     void visitAggregate(SlotVisitor&amp;);
122     void markIfCheap(SlotVisitor&amp;);
123     bool finalize(VM&amp;); // Return true if this gets to live.
124 
125     bool appendVariant(const GetByIdVariant&amp;);
126 
127     void dump(PrintStream&amp;) const;
128 
129     CacheableIdentifier singleIdentifier() const;
130 
131 private:
132     void merge(const GetByStatus&amp;);
133 
134 #if ENABLE(JIT)
135     GetByStatus(const ModuleNamespaceAccessCase&amp;);
136     static GetByStatus computeForStubInfoWithoutExitSiteFeedback(
137         const ConcurrentJSLocker&amp;, CodeBlock* profiledBlock, StructureStubInfo*, CallLinkStatus::ExitSiteData);
138 #endif
139     static GetByStatus computeFromLLInt(CodeBlock*, BytecodeIndex);
140     static GetByStatus computeFor(CodeBlock*, ICStatusMap&amp;, BytecodeIndex, ExitFlag, CallLinkStatus::ExitSiteData);
141 
142     struct ModuleNamespaceData {
143         JSModuleNamespaceObject* m_moduleNamespaceObject { nullptr };
144         JSModuleEnvironment* m_moduleEnvironment { nullptr };
145         ScopeOffset m_scopeOffset { };
146         CacheableIdentifier m_identifier;
147     };
148 
149     Vector&lt;GetByIdVariant, 1&gt; m_variants;
150     Box&lt;ModuleNamespaceData&gt; m_moduleNamespaceData;
151     State m_state;
152     bool m_wasSeenInJIT { false };
153 };
154 
155 } // namespace JSC
    </pre>
  </body>
</html>
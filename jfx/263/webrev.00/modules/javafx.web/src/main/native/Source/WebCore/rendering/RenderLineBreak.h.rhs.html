<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLineBreak.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2013 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;RenderBoxModelObject.h&quot;
 25 
 26 namespace WebCore {
 27 
 28 class InlineElementBox;
 29 class HTMLElement;
 30 class Position;
 31 
 32 class RenderLineBreak final : public RenderBoxModelObject {
 33     WTF_MAKE_ISO_ALLOCATED(RenderLineBreak);
 34 public:
 35     RenderLineBreak(HTMLElement&amp;, RenderStyle&amp;&amp;);
 36     virtual ~RenderLineBreak();
 37 
 38     // FIXME: The lies here keep render tree dump based test results unchanged.
 39     const char* renderName() const override { return m_isWBR ? &quot;RenderWordBreak&quot; : &quot;RenderBR&quot;; }
 40 
 41     bool isWBR() const override { return m_isWBR; }
 42 
 43     std::unique_ptr&lt;InlineElementBox&gt; createInlineBox();
 44     InlineElementBox* inlineBoxWrapper() const { return m_inlineBoxWrapper; }
 45     void setInlineBoxWrapper(InlineElementBox*);
 46     void deleteInlineBoxWrapper();
 47     void replaceInlineBoxWrapper(InlineElementBox&amp;);
 48     void dirtyLineBoxes(bool fullLayout);
<a name="1" id="anc1"></a>
 49 
 50     IntRect linesBoundingBox() const;
<a name="2" id="anc2"></a><span class="line-added"> 51     IntRect boundingBoxForRenderTreeDump() const;</span>
 52 
 53     void absoluteRects(Vector&lt;IntRect&gt;&amp;, const LayoutPoint&amp; accumulatedOffset) const override;
 54     void absoluteQuads(Vector&lt;FloatQuad&gt;&amp;, bool* wasFixed) const override;
 55 #if PLATFORM(IOS_FAMILY)
 56 void collectSelectionRects(Vector&lt;SelectionRect&gt;&amp;, unsigned startOffset = 0, unsigned endOffset = std::numeric_limits&lt;unsigned&gt;::max()) override;
 57 #endif
 58     void ensureLineBoxes();
 59 
 60 private:
 61     void node() const = delete;
 62 
 63     bool canHaveChildren() const override { return false; }
 64     void paint(PaintInfo&amp;, const LayoutPoint&amp;) override { }
 65 
 66     VisiblePosition positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*) override;
 67     int caretMinOffset() const override;
 68     int caretMaxOffset() const override;
 69     bool canBeSelectionLeaf() const override;
 70     LayoutRect localCaretRect(InlineBox*, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine) override;
 71     void setSelectionState(SelectionState) override;
 72 
 73     LayoutUnit lineHeight(bool firstLine, LineDirectionMode, LinePositionMode) const override;
 74     int baselinePosition(FontBaseline, bool firstLine, LineDirectionMode, LinePositionMode) const override;
 75 
 76     LayoutUnit marginTop() const override { return 0; }
 77     LayoutUnit marginBottom() const override { return 0; }
 78     LayoutUnit marginLeft() const override { return 0; }
 79     LayoutUnit marginRight() const override { return 0; }
 80     LayoutUnit marginBefore(const RenderStyle*) const override { return 0; }
 81     LayoutUnit marginAfter(const RenderStyle*) const override { return 0; }
 82     LayoutUnit marginStart(const RenderStyle*) const override { return 0; }
 83     LayoutUnit marginEnd(const RenderStyle*) const override { return 0; }
 84     LayoutUnit offsetWidth() const override { return linesBoundingBox().width(); }
 85     LayoutUnit offsetHeight() const override { return linesBoundingBox().height(); }
 86     LayoutRect borderBoundingBox() const override { return LayoutRect(LayoutPoint(), linesBoundingBox().size()); }
 87     LayoutRect frameRectForStickyPositioning() const override { ASSERT_NOT_REACHED(); return LayoutRect(); }
 88     LayoutRect clippedOverflowRectForRepaint(const RenderLayerModelObject*) const override { return LayoutRect(); }
 89 
 90     void updateFromStyle() override;
 91     bool requiresLayer() const override { return false; }
 92 
 93     InlineElementBox* m_inlineBoxWrapper;
 94     mutable int m_cachedLineHeight;
 95     bool m_isWBR;
 96 };
 97 
 98 } // namespace WebCore
 99 
100 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderLineBreak, isLineBreak())
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
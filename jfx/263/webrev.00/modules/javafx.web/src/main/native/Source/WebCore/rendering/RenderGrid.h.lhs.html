<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGrid.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Apple Inc. All rights reserved.
  3  * Copyright (C) 2013-2017 Igalia S.L.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;Grid.h&quot;
 30 #include &quot;GridTrackSizingAlgorithm.h&quot;
 31 #include &quot;RenderBlock.h&quot;
 32 
 33 namespace WebCore {
 34 
 35 class GridArea;
 36 class GridSpan;
 37 
 38 struct ContentAlignmentData {
 39     WTF_MAKE_NONCOPYABLE(ContentAlignmentData); WTF_MAKE_FAST_ALLOCATED;
 40 public:
 41     ContentAlignmentData() = default;
 42     bool isValid() const { return positionOffset &gt;= 0 &amp;&amp; distributionOffset &gt;= 0; }
 43 
 44     LayoutUnit positionOffset;
 45     LayoutUnit distributionOffset;
 46 };
 47 
 48 enum GridAxisPosition {GridAxisStart, GridAxisEnd, GridAxisCenter};
 49 
 50 class RenderGrid final : public RenderBlock {
 51     WTF_MAKE_ISO_ALLOCATED(RenderGrid);
 52 public:
 53     RenderGrid(Element&amp;, RenderStyle&amp;&amp;);
 54     virtual ~RenderGrid();
 55 
 56     Element&amp; element() const { return downcast&lt;Element&gt;(nodeForNonAnonymous()); }
 57 
 58     void styleDidChange(StyleDifference, const RenderStyle* oldStyle) override;
 59     void layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight = 0_lu) override;
 60 
 61     bool avoidsFloats() const override { return true; }
 62     bool canDropAnonymousBlockChild() const override { return false; }
 63 
 64     void dirtyGrid();
 65     Vector&lt;LayoutUnit&gt; trackSizesForComputedStyle(GridTrackSizingDirection) const;
 66 
 67     const Vector&lt;LayoutUnit&gt;&amp; columnPositions() const { return m_columnPositions; }
 68     const Vector&lt;LayoutUnit&gt;&amp; rowPositions() const { return m_rowPositions; }
 69 
 70     unsigned autoRepeatCountForDirection(GridTrackSizingDirection direction) const { return m_grid.autoRepeatTracks(direction); }
 71 
 72     // Required by GridTrackSizingAlgorithm. Keep them under control.
 73     LayoutUnit guttersSize(const Grid&amp;, GridTrackSizingDirection, unsigned startLine, unsigned span, Optional&lt;LayoutUnit&gt; availableSize) const;
 74     LayoutUnit gridItemOffset(GridTrackSizingDirection) const;
 75 
 76     void updateGridAreaLogicalSize(RenderBox&amp;, LayoutSize) const;
 77     bool isBaselineAlignmentForChild(const RenderBox&amp;) const;
 78     bool isBaselineAlignmentForChild(const RenderBox&amp;, GridAxis) const;
 79 
 80     StyleSelfAlignmentData selfAlignmentForChild(GridAxis, const RenderBox&amp;, const RenderStyle* = nullptr) const;
 81 
 82     StyleContentAlignmentData contentAlignment(GridTrackSizingDirection) const;
 83 
 84 protected:
 85     ItemPosition selfAlignmentNormalBehavior(const RenderBox* child = nullptr) const override
 86     {
 87         ASSERT(child);
 88         return child-&gt;isRenderReplaced() ? ItemPosition::Start : ItemPosition::Stretch;
 89     }
 90 
 91 private:
 92     const char* renderName() const override;
 93     bool isRenderGrid() const override { return true; }
 94     void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const override;
 95 
 96     bool selfAlignmentChangedToStretch(GridAxis, const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle, const RenderBox&amp;) const;
 97     bool selfAlignmentChangedFromStretch(GridAxis, const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle, const RenderBox&amp;) const;
 98 
 99     Optional&lt;LayoutUnit&gt; availableSpaceForGutters(GridTrackSizingDirection) const;
100 
101     bool explicitGridDidResize(const RenderStyle&amp;) const;
102     bool namedGridLinesDefinitionDidChange(const RenderStyle&amp;) const;
103 
104     unsigned computeAutoRepeatTracksCount(GridTrackSizingDirection, Optional&lt;LayoutUnit&gt; availableSize) const;
105 
106     unsigned clampAutoRepeatTracks(GridTrackSizingDirection, unsigned autoRepeatTracks) const;
107 
108     std::unique_ptr&lt;OrderedTrackIndexSet&gt; computeEmptyTracksForAutoRepeat(Grid&amp;, GridTrackSizingDirection) const;
109 
110     void performGridItemsPreLayout(const GridTrackSizingAlgorithm&amp;) const;
111 
112     void placeItemsOnGrid(GridTrackSizingAlgorithm&amp;, Optional&lt;LayoutUnit&gt; availableLogicalWidth) const;
113     void populateExplicitGridAndOrderIterator(Grid&amp;) const;
114     std::unique_ptr&lt;GridArea&gt; createEmptyGridAreaAtSpecifiedPositionsOutsideGrid(Grid&amp;, const RenderBox&amp;, GridTrackSizingDirection, const GridSpan&amp;) const;
115     void placeSpecifiedMajorAxisItemsOnGrid(Grid&amp;, const Vector&lt;RenderBox*&gt;&amp;) const;
116     void placeAutoMajorAxisItemsOnGrid(Grid&amp;, const Vector&lt;RenderBox*&gt;&amp;) const;
117     typedef std::pair&lt;unsigned, unsigned&gt; AutoPlacementCursor;
118     void placeAutoMajorAxisItemOnGrid(Grid&amp;, RenderBox&amp;, AutoPlacementCursor&amp;) const;
119     GridTrackSizingDirection autoPlacementMajorAxisDirection() const;
120     GridTrackSizingDirection autoPlacementMinorAxisDirection() const;
121 
122     bool canPerformSimplifiedLayout() const final;
123     void prepareChildForPositionedLayout(RenderBox&amp;);
124     bool hasStaticPositionForChild(const RenderBox&amp;, GridTrackSizingDirection) const;
125     void layoutPositionedObject(RenderBox&amp;, bool relayoutChildren, bool fixedPositionObjectsOnly) override;
126 
127     void computeTrackSizesForDefiniteSize(GridTrackSizingDirection, LayoutUnit availableSpace);
128     void computeTrackSizesForIndefiniteSize(GridTrackSizingAlgorithm&amp;, GridTrackSizingDirection, LayoutUnit* minIntrinsicSize = nullptr, LayoutUnit* maxIntrinsicSize = nullptr) const;
129     LayoutUnit computeTrackBasedLogicalHeight() const;
130 
131     void repeatTracksSizingIfNeeded(LayoutUnit availableSpaceForColumns, LayoutUnit availableSpaceForRows);
132 
133     void layoutGridItems();
134     void populateGridPositionsForDirection(GridTrackSizingDirection);
135 
136     LayoutUnit resolveAutoStartGridPosition(GridTrackSizingDirection) const;
137     LayoutUnit resolveAutoEndGridPosition(GridTrackSizingDirection) const;
138     LayoutUnit gridAreaBreadthForOutOfFlowChild(const RenderBox&amp;, GridTrackSizingDirection);
139     LayoutUnit logicalOffsetForOutOfFlowChild(const RenderBox&amp;, GridTrackSizingDirection, LayoutUnit) const;
140     void gridAreaPositionForOutOfFlowChild(const RenderBox&amp;, GridTrackSizingDirection, LayoutUnit&amp; start, LayoutUnit&amp; end) const;
141     void gridAreaPositionForInFlowChild(const RenderBox&amp;, GridTrackSizingDirection, LayoutUnit&amp; start, LayoutUnit&amp; end) const;
142     void gridAreaPositionForChild(const RenderBox&amp;, GridTrackSizingDirection, LayoutUnit&amp; start, LayoutUnit&amp; end) const;
143 
144     GridAxisPosition columnAxisPositionForChild(const RenderBox&amp;) const;
145     GridAxisPosition rowAxisPositionForChild(const RenderBox&amp;) const;
146     LayoutUnit columnAxisOffsetForChild(const RenderBox&amp;) const;
147     LayoutUnit rowAxisOffsetForChild(const RenderBox&amp;) const;
148     void computeContentPositionAndDistributionOffset(GridTrackSizingDirection, const LayoutUnit&amp; availableFreeSpace, unsigned numberOfGridTracks);
149     void setLogicalPositionForChild(RenderBox&amp;) const;
150     void setLogicalOffsetForChild(RenderBox&amp;, GridTrackSizingDirection) const;
151     LayoutUnit logicalOffsetForChild(const RenderBox&amp;, GridTrackSizingDirection) const;
152     GridArea cachedGridArea(const RenderBox&amp;) const;
153     GridSpan cachedGridSpan(const RenderBox&amp;, GridTrackSizingDirection) const;
154 
155     LayoutUnit gridAreaBreadthForChildIncludingAlignmentOffsets(const RenderBox&amp;, GridTrackSizingDirection) const;
156 
157     void paintChildren(PaintInfo&amp; forSelf, const LayoutPoint&amp; paintOffset, PaintInfo&amp; forChild, bool usePrintRect) override;
158     LayoutUnit availableAlignmentSpaceForChildBeforeStretching(LayoutUnit gridAreaBreadthForChild, const RenderBox&amp;) const;
159     StyleSelfAlignmentData justifySelfForChild(const RenderBox&amp;, const RenderStyle* = nullptr) const;
160     StyleSelfAlignmentData alignSelfForChild(const RenderBox&amp;, const RenderStyle* = nullptr) const;
161     void applyStretchAlignmentToChildIfNeeded(RenderBox&amp;);
162     bool hasAutoSizeInColumnAxis(const RenderBox&amp; child) const { return isHorizontalWritingMode() ? child.style().height().isAuto() : child.style().width().isAuto(); }
163     bool hasAutoSizeInRowAxis(const RenderBox&amp; child) const { return isHorizontalWritingMode() ? child.style().width().isAuto() : child.style().height().isAuto(); }
164     bool allowedToStretchChildAlongColumnAxis(const RenderBox&amp; child) const { return alignSelfForChild(child).position() == ItemPosition::Stretch &amp;&amp; hasAutoSizeInColumnAxis(child) &amp;&amp; !hasAutoMarginsInColumnAxis(child); }
165     bool allowedToStretchChildAlongRowAxis(const RenderBox&amp; child) const { return justifySelfForChild(child).position() == ItemPosition::Stretch &amp;&amp; hasAutoSizeInRowAxis(child) &amp;&amp; !hasAutoMarginsInRowAxis(child); }
166     bool hasAutoMarginsInColumnAxis(const RenderBox&amp;) const;
167     bool hasAutoMarginsInRowAxis(const RenderBox&amp;) const;
168     void resetAutoMarginsAndLogicalTopInColumnAxis(RenderBox&amp; child);
169     void updateAutoMarginsInColumnAxisIfNeeded(RenderBox&amp;);
170     void updateAutoMarginsInRowAxisIfNeeded(RenderBox&amp;);
171 
172     int baselinePosition(FontBaseline, bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const final;
173     Optional&lt;int&gt; firstLineBaseline() const final;
174     Optional&lt;int&gt; inlineBlockBaseline(LineDirectionMode) const final;
175     bool isInlineBaselineAlignedChild(const RenderBox&amp;) const;
176 
177     LayoutUnit columnAxisBaselineOffsetForChild(const RenderBox&amp;) const;
178     LayoutUnit rowAxisBaselineOffsetForChild(const RenderBox&amp;) const;
179 
180     LayoutUnit gridGap(GridTrackSizingDirection) const;
181     LayoutUnit gridGap(GridTrackSizingDirection, Optional&lt;LayoutUnit&gt; availableSize) const;
182 
183     unsigned nonCollapsedTracks(GridTrackSizingDirection) const;
184     unsigned numTracks(GridTrackSizingDirection, const Grid&amp;) const;
185 
186     LayoutUnit translateOutOfFlowRTLCoordinate(const RenderBox&amp;, LayoutUnit) const;
187     LayoutUnit translateRTLCoordinate(LayoutUnit) const;
188 
<a name="1" id="anc1"></a>

189     Grid m_grid;
190 
191     GridTrackSizingAlgorithm m_trackSizingAlgorithm;
192 
193     Vector&lt;LayoutUnit&gt; m_columnPositions;
194     Vector&lt;LayoutUnit&gt; m_rowPositions;
195     ContentAlignmentData m_offsetBetweenColumns;
196     ContentAlignmentData m_offsetBetweenRows;
197 
198     typedef HashMap&lt;const RenderBox*, Optional&lt;size_t&gt;&gt; OutOfFlowPositionsMap;
199     OutOfFlowPositionsMap m_outOfFlowItemColumn;
200     OutOfFlowPositionsMap m_outOfFlowItemRow;
201 
202     bool m_hasAnyOrthogonalItem {false};
203     bool m_baselineItemsCached {false};
204 };
205 
206 } // namespace WebCore
207 
208 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderGrid, isRenderGrid())
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
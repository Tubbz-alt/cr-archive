<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2015, 2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;UniqueIDBDatabase.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
<a name="1" id="anc1"></a><span class="line-removed">  31 #include &quot;IDBBindingUtilities.h&quot;</span>
  32 #include &quot;IDBCursorInfo.h&quot;
  33 #include &quot;IDBGetAllRecordsData.h&quot;
  34 #include &quot;IDBGetAllResult.h&quot;
  35 #include &quot;IDBGetRecordData.h&quot;
  36 #include &quot;IDBIterateCursorData.h&quot;
  37 #include &quot;IDBKeyRangeData.h&quot;
  38 #include &quot;IDBResultData.h&quot;
  39 #include &quot;IDBServer.h&quot;
  40 #include &quot;IDBTransactionInfo.h&quot;
  41 #include &quot;IDBValue.h&quot;
  42 #include &quot;Logging.h&quot;
<a name="2" id="anc2"></a><span class="line-removed">  43 #include &quot;SerializedScriptValue.h&quot;</span>
  44 #include &quot;StorageQuotaManager.h&quot;
  45 #include &quot;UniqueIDBDatabaseConnection.h&quot;
<a name="3" id="anc3"></a><span class="line-removed">  46 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;</span>
<span class="line-removed">  47 #include &lt;JavaScriptCore/JSCInlines.h&gt;</span>
<span class="line-removed">  48 #include &lt;JavaScriptCore/StrongInlines.h&gt;</span>
<span class="line-removed">  49 #include &lt;wtf/MainThread.h&gt;</span>
<span class="line-removed">  50 #include &lt;wtf/NeverDestroyed.h&gt;</span>
  51 #include &lt;wtf/Scope.h&gt;
  52 
  53 namespace WebCore {
  54 using namespace JSC;
  55 namespace IDBServer {
  56 
  57 static const uint64_t defaultWriteOperationCost = 4;
  58 
  59 static inline uint64_t estimateSize(const IDBKeyData&amp; keyData)
  60 {
  61     uint64_t size = 4;
  62     switch (keyData.type()) {
  63     case IndexedDB::KeyType::String:
  64         size += keyData.string().sizeInBytes();
  65         break;
  66     case IndexedDB::KeyType::Binary: {
  67         size += keyData.binary().size();
  68         break;
  69     }
  70     case IndexedDB::KeyType::Array:
  71         for (auto&amp; data : keyData.array())
  72             size += estimateSize(data);
  73         break;
  74     default:
  75         break;
  76     }
  77     return size;
  78 }
  79 
  80 static inline uint64_t estimateSize(const IDBValue&amp; value)
  81 {
  82     uint64_t size = 4;
  83     size += value.data().size();
  84     for (auto&amp; url : value.blobURLs())
  85         size += url.sizeInBytes();
  86     for (auto&amp; path : value.blobFilePaths())
  87         size += path.sizeInBytes();
  88     return size;
  89 }
  90 
<a name="4" id="anc4"></a>











  91 static inline uint64_t estimateSize(const IDBIndexInfo&amp; info)
  92 {
  93     uint64_t size = 4;
  94     size += info.name().sizeInBytes();
<a name="5" id="anc5"></a>
  95     return size;
  96 }
  97 
  98 static inline uint64_t estimateSize(const IDBObjectStoreInfo&amp; info)
  99 {
 100     uint64_t size = 4;
 101     size += info.name().sizeInBytes();
<a name="6" id="anc6"></a><span class="line-modified"> 102     // FIXME: estimate keyPath.</span>
<span class="line-modified"> 103     for (auto&amp; indexInfo : info.indexMap().values())</span>
<span class="line-removed"> 104         size += estimateSize(indexInfo);</span>
 105     return size;
 106 }
 107 
 108 UniqueIDBDatabase::UniqueIDBDatabase(IDBServer&amp; server, const IDBDatabaseIdentifier&amp; identifier)
 109     : m_server(server)
 110     , m_identifier(identifier)
<a name="7" id="anc7"></a><span class="line-removed"> 111     , m_operationAndTransactionTimer(*this, &amp;UniqueIDBDatabase::operationAndTransactionTimerFired)</span>
 112 {
<a name="8" id="anc8"></a><span class="line-modified"> 113     LOG(IndexedDB, &quot;UniqueIDBDatabase::UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());</span>



 114 }
 115 
 116 UniqueIDBDatabase::~UniqueIDBDatabase()
 117 {
<a name="9" id="anc9"></a><span class="line-modified"> 118     LOG(IndexedDB, &quot;UniqueIDBDatabase::~UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());</span>
<span class="line-modified"> 119     ASSERT(isMainThread());</span>
<span class="line-modified"> 120     ASSERT(!hasAnyPendingCallbacks());</span>
<span class="line-modified"> 121     ASSERT(!hasUnfinishedTransactions());</span>

 122     ASSERT(m_pendingTransactions.isEmpty());
<a name="10" id="anc10"></a><span class="line-modified"> 123     ASSERT(m_openDatabaseConnections.isEmpty());</span>
<span class="line-modified"> 124     ASSERT(m_clientClosePendingDatabaseConnections.isEmpty());</span>
<span class="line-modified"> 125     ASSERT(m_serverClosePendingDatabaseConnections.isEmpty());</span>
<span class="line-removed"> 126 </span>
<span class="line-removed"> 127     RELEASE_ASSERT(m_databaseQueue.isKilled());</span>
<span class="line-removed"> 128     RELEASE_ASSERT(m_databaseReplyQueue.isKilled());</span>
 129     RELEASE_ASSERT(!m_backingStore);
<a name="11" id="anc11"></a>

 130 }
 131 
 132 const IDBDatabaseInfo&amp; UniqueIDBDatabase::info() const
 133 {
 134     RELEASE_ASSERT(m_databaseInfo);
 135     return *m_databaseInfo;
 136 }
 137 
 138 void UniqueIDBDatabase::openDatabaseConnection(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 139 {
 140     LOG(IndexedDB, &quot;UniqueIDBDatabase::openDatabaseConnection&quot;);
<a name="12" id="anc12"></a><span class="line-modified"> 141     ASSERT(!m_hardClosedForUserDelete);</span>
<span class="line-removed"> 142     ASSERT(isMainThread());</span>
 143 
 144     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 145 
<a name="13" id="anc13"></a><span class="line-removed"> 146     // An open operation is already in progress, so we can&#39;t possibly handle this one yet.</span>
<span class="line-removed"> 147     if (m_isOpeningBackingStore)</span>
<span class="line-removed"> 148         return;</span>
<span class="line-removed"> 149 </span>
 150     handleDatabaseOperations();
 151 }
 152 
<a name="14" id="anc14"></a><span class="line-removed"> 153 bool UniqueIDBDatabase::hasAnyPendingCallbacks() const</span>
<span class="line-removed"> 154 {</span>
<span class="line-removed"> 155     return !m_errorCallbacks.isEmpty()</span>
<span class="line-removed"> 156         || !m_keyDataCallbacks.isEmpty()</span>
<span class="line-removed"> 157         || !m_getResultCallbacks.isEmpty()</span>
<span class="line-removed"> 158         || !m_getAllResultsCallbacks.isEmpty()</span>
<span class="line-removed"> 159         || !m_countCallbacks.isEmpty();</span>
<span class="line-removed"> 160 }</span>
<span class="line-removed"> 161 </span>
<span class="line-removed"> 162 bool UniqueIDBDatabase::isVersionChangeInProgress()</span>
<span class="line-removed"> 163 {</span>
<span class="line-removed"> 164 #if !LOG_DISABLED</span>
<span class="line-removed"> 165     if (m_versionChangeTransaction)</span>
<span class="line-removed"> 166         ASSERT(m_versionChangeDatabaseConnection);</span>
<span class="line-removed"> 167 #endif</span>
<span class="line-removed"> 168 </span>
<span class="line-removed"> 169     return m_versionChangeDatabaseConnection;</span>
<span class="line-removed"> 170 }</span>
<span class="line-removed"> 171 </span>
 172 static inline String quotaErrorMessageName(const char* taskName)
 173 {
 174     return makeString(&quot;Failed to &quot;, taskName, &quot; in database because not enough space for domain&quot;);
 175 }
 176 
<a name="15" id="anc15"></a><span class="line-removed"> 177 void UniqueIDBDatabase::requestSpace(uint64_t taskSize, const char* taskName, CompletionHandler&lt;void(Optional&lt;IDBError&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
<span class="line-removed"> 178 {</span>
<span class="line-removed"> 179     m_server-&gt;requestSpace(m_identifier.origin(), taskSize, [weakThis = makeWeakPtr(this), this, taskName, callback = WTFMove(callback)](auto decision) mutable {</span>
<span class="line-removed"> 180         if (!weakThis) {</span>
<span class="line-removed"> 181             callback(IDBError { UnknownError });</span>
<span class="line-removed"> 182             return;</span>
<span class="line-removed"> 183         }</span>
<span class="line-removed"> 184 </span>
<span class="line-removed"> 185         if (m_owningPointerForClose) {</span>
<span class="line-removed"> 186             // We are closing the database, there is no point in trying to modify the database at that point.</span>
<span class="line-removed"> 187             callback(IDBError { UnknownError });</span>
<span class="line-removed"> 188             return;</span>
<span class="line-removed"> 189         }</span>
<span class="line-removed"> 190 </span>
<span class="line-removed"> 191         switch (decision) {</span>
<span class="line-removed"> 192         case StorageQuotaManager::Decision::Deny:</span>
<span class="line-removed"> 193             callback(IDBError { QuotaExceededError, quotaErrorMessageName(taskName) });</span>
<span class="line-removed"> 194             return;</span>
<span class="line-removed"> 195         case StorageQuotaManager::Decision::Grant:</span>
<span class="line-removed"> 196             callback({ });</span>
<span class="line-removed"> 197         };</span>
<span class="line-removed"> 198     });</span>
<span class="line-removed"> 199 }</span>
<span class="line-removed"> 200 </span>
<span class="line-removed"> 201 void UniqueIDBDatabase::waitForRequestSpaceCompletion(CompletionHandler&lt;void(Optional&lt;IDBError&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
<span class="line-removed"> 202 {</span>
<span class="line-removed"> 203     requestSpace(0, &quot;&quot;, WTFMove(callback));</span>
<span class="line-removed"> 204 }</span>
<span class="line-removed"> 205 </span>
 206 void UniqueIDBDatabase::performCurrentOpenOperation()
 207 {
<a name="16" id="anc16"></a><span class="line-modified"> 208     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentOpenOperation (%p)&quot;, this);</span>
 209 
 210     ASSERT(m_currentOpenDBRequest);
 211     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 212 
<a name="17" id="anc17"></a><span class="line-modified"> 213     if (!m_databaseInfo) {</span>
<span class="line-modified"> 214         if (!m_isOpeningBackingStore) {</span>
<span class="line-modified"> 215             m_isOpeningBackingStore = true;</span>
<span class="line-modified"> 216             // We do not know whether this is an existing or a new database.</span>
<span class="line-modified"> 217             // We set a small cost so that it is not possible to open an infinite number of database.</span>
<span class="line-modified"> 218             m_server-&gt;requestSpace(m_identifier.origin(), defaultWriteOperationCost, [this, weakThis = makeWeakPtr(this)](auto decision) mutable {</span>
<span class="line-modified"> 219                 if (!weakThis)</span>
<span class="line-modified"> 220                     return;</span>
<span class="line-modified"> 221 </span>
<span class="line-modified"> 222                 if (m_owningPointerForClose)</span>
<span class="line-modified"> 223                     return;</span>
<span class="line-modified"> 224 </span>
<span class="line-modified"> 225                 switch (decision) {</span>
<span class="line-modified"> 226                 case StorageQuotaManager::Decision::Deny: {</span>
<span class="line-removed"> 227                     auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), IDBError { QuotaExceededError, quotaErrorMessageName(&quot;openDatabase&quot;) });</span>
<span class="line-removed"> 228                     m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);</span>
<span class="line-removed"> 229                     m_currentOpenDBRequest = nullptr;</span>
<span class="line-removed"> 230                     m_isOpeningBackingStore = false;</span>
<span class="line-removed"> 231                     break;</span>
<span class="line-removed"> 232                 }</span>
<span class="line-removed"> 233                 case StorageQuotaManager::Decision::Grant:</span>
<span class="line-removed"> 234                     this-&gt;postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::openBackingStore, m_identifier));</span>
<span class="line-removed"> 235                 };</span>
<span class="line-removed"> 236             });</span>
 237         }
<a name="18" id="anc18"></a>






 238         return;
 239     }
 240 
 241     // If we previously started a version change operation but were blocked by having open connections,
 242     // we might now be unblocked.
 243     if (m_versionChangeDatabaseConnection) {
 244         if (!m_versionChangeTransaction &amp;&amp; !hasAnyOpenConnections())
 245             startVersionChangeTransaction();
 246         return;
 247     }
 248 
 249     // 3.3.1 Opening a database
 250     // If requested version is undefined, then let requested version be 1 if db was created in the previous step,
 251     // or the current version of db otherwise.
 252     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
 253     if (!requestedVersion)
 254         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 255 
 256     // 3.3.1 Opening a database
 257     // If the database version higher than the requested version, abort these steps and return a VersionError.
 258     if (requestedVersion &lt; m_databaseInfo-&gt;version()) {
 259         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), IDBError(VersionError));
 260         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 261         m_currentOpenDBRequest = nullptr;
 262 
 263         return;
 264     }
 265 
<a name="19" id="anc19"></a><span class="line-removed"> 266     if (!m_backingStoreOpenError.isNull()) {</span>
<span class="line-removed"> 267         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), m_backingStoreOpenError);</span>
<span class="line-removed"> 268         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);</span>
<span class="line-removed"> 269         m_currentOpenDBRequest = nullptr;</span>
<span class="line-removed"> 270 </span>
<span class="line-removed"> 271         return;</span>
<span class="line-removed"> 272     }</span>
<span class="line-removed"> 273 </span>
 274     Ref&lt;UniqueIDBDatabaseConnection&gt; connection = UniqueIDBDatabaseConnection::create(*this, *m_currentOpenDBRequest);
 275 
 276     if (requestedVersion == m_databaseInfo-&gt;version()) {
 277         auto* rawConnection = &amp;connection.get();
 278         addOpenDatabaseConnection(WTFMove(connection));
 279 
 280         auto result = IDBResultData::openDatabaseSuccess(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), *rawConnection);
 281         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 282         m_currentOpenDBRequest = nullptr;
 283 
 284         return;
 285     }
 286 
 287     ASSERT(!m_versionChangeDatabaseConnection);
 288     m_versionChangeDatabaseConnection = WTFMove(connection);
 289 
 290     // 3.3.7 &quot;versionchange&quot; transaction steps
 291     // If there&#39;s no other open connections to this database, the version change process can begin immediately.
 292     if (!hasAnyOpenConnections()) {
 293         startVersionChangeTransaction();
 294         return;
 295     }
 296 
 297     // Otherwise we have to notify all those open connections and wait for them to close.
 298     maybeNotifyConnectionsOfVersionChange();
 299 }
 300 
 301 void UniqueIDBDatabase::performCurrentDeleteOperation()
 302 {
<a name="20" id="anc20"></a><span class="line-modified"> 303     ASSERT(isMainThread());</span>
<span class="line-removed"> 304     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentDeleteOperation - %s&quot;, m_identifier.debugString().utf8().data());</span>
 305 
 306     ASSERT(m_currentOpenDBRequest);
 307     ASSERT(m_currentOpenDBRequest-&gt;isDeleteRequest());
 308 
<a name="21" id="anc21"></a><span class="line-removed"> 309     if (m_deleteBackingStoreInProgress)</span>
<span class="line-removed"> 310         return;</span>
<span class="line-removed"> 311 </span>
 312     if (hasAnyOpenConnections()) {
 313         maybeNotifyConnectionsOfVersionChange();
 314         return;
 315     }
 316 
<a name="22" id="anc22"></a><span class="line-removed"> 317     if (hasUnfinishedTransactions())</span>
<span class="line-removed"> 318         return;</span>
<span class="line-removed"> 319 </span>
<span class="line-removed"> 320     ASSERT(!hasAnyPendingCallbacks());</span>
 321     ASSERT(m_pendingTransactions.isEmpty());
 322     ASSERT(m_openDatabaseConnections.isEmpty());
 323 
 324     // It&#39;s possible to have multiple delete requests queued up in a row.
 325     // In that scenario only the first request will actually have to delete the database.
 326     // Subsequent requests can immediately notify their completion.
 327 
<a name="23" id="anc23"></a><span class="line-modified"> 328     if (!m_deleteBackingStoreInProgress) {</span>
<span class="line-modified"> 329         if (!m_databaseInfo &amp;&amp; m_mostRecentDeletedDatabaseInfo)</span>
<span class="line-modified"> 330             didDeleteBackingStore(0);</span>
<span class="line-modified"> 331         else {</span>
<span class="line-removed"> 332             m_deleteBackingStoreInProgress = true;</span>
<span class="line-removed"> 333             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::deleteBackingStore, m_identifier));</span>
<span class="line-removed"> 334         }</span>
<span class="line-removed"> 335     }</span>
 336 }
 337 
<a name="24" id="anc24"></a><span class="line-modified"> 338 void UniqueIDBDatabase::deleteBackingStore(const IDBDatabaseIdentifier&amp; identifier)</span>
 339 {
 340     ASSERT(!isMainThread());
<a name="25" id="anc25"></a><span class="line-modified"> 341     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::deleteBackingStore&quot;);</span>
 342 
 343     uint64_t deletedVersion = 0;
 344 
 345     if (m_backingStore) {
 346         m_backingStore-&gt;deleteBackingStore();
<a name="26" id="anc26"></a><span class="line-removed"> 347         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-removed"> 348 </span>
 349         m_backingStore = nullptr;
<a name="27" id="anc27"></a><span class="line-removed"> 350         m_backingStoreSupportsSimultaneousTransactions = false;</span>
<span class="line-removed"> 351         m_backingStoreIsEphemeral = false;</span>
 352     } else {
<a name="28" id="anc28"></a><span class="line-modified"> 353         auto backingStore = m_server-&gt;createBackingStore(identifier);</span>
<span class="line-removed"> 354         m_currentDatabaseSize = backingStore-&gt;databaseSize();</span>
 355 
 356         IDBDatabaseInfo databaseInfo;
 357         auto error = backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 358         if (!error.isNull())
<a name="29" id="anc29"></a><span class="line-modified"> 359             LOG_ERROR(&quot;Error getting database info from database %s that we are trying to delete&quot;, identifier.debugString().utf8().data());</span>
 360 
 361         deletedVersion = databaseInfo.version();
 362         backingStore-&gt;deleteBackingStore();
<a name="30" id="anc30"></a><span class="line-removed"> 363         m_newDatabaseSize = backingStore-&gt;databaseSize();</span>
<span class="line-removed"> 364     }</span>
<span class="line-removed"> 365 </span>
<span class="line-removed"> 366     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didDeleteBackingStore, deletedVersion));</span>
<span class="line-removed"> 367 }</span>
<span class="line-removed"> 368 </span>
<span class="line-removed"> 369 void UniqueIDBDatabase::performUnconditionalDeleteBackingStore()</span>
<span class="line-removed"> 370 {</span>
<span class="line-removed"> 371     ASSERT(!isMainThread());</span>
<span class="line-removed"> 372     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performUnconditionalDeleteBackingStore&quot;);</span>
<span class="line-removed"> 373 </span>
<span class="line-removed"> 374     if (m_backingStore)</span>
<span class="line-removed"> 375         m_backingStore-&gt;deleteBackingStore();</span>
<span class="line-removed"> 376 </span>
<span class="line-removed"> 377     shutdownForClose();</span>
<span class="line-removed"> 378 }</span>
<span class="line-removed"> 379 </span>
<span class="line-removed"> 380 void UniqueIDBDatabase::scheduleShutdownForClose()</span>
<span class="line-removed"> 381 {</span>
<span class="line-removed"> 382     ASSERT(isMainThread());</span>
<span class="line-removed"> 383 </span>
<span class="line-removed"> 384     m_operationAndTransactionTimer.stop();</span>
<span class="line-removed"> 385 </span>
<span class="line-removed"> 386     RELEASE_ASSERT(!m_owningPointerForClose);</span>
<span class="line-removed"> 387     m_owningPointerForClose = m_server-&gt;closeAndTakeUniqueIDBDatabase(*this);</span>
<span class="line-removed"> 388 </span>
<span class="line-removed"> 389     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));</span>
<span class="line-removed"> 390 }</span>
<span class="line-removed"> 391 </span>
<span class="line-removed"> 392 void UniqueIDBDatabase::shutdownForClose()</span>
<span class="line-removed"> 393 {</span>
<span class="line-removed"> 394     ASSERT(!isMainThread());</span>
<span class="line-removed"> 395     ASSERT(m_owningPointerForClose.get() == this);</span>
<span class="line-removed"> 396 </span>
<span class="line-removed"> 397     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::shutdownForClose&quot;);</span>
<span class="line-removed"> 398 </span>
<span class="line-removed"> 399     if (m_backingStore) {</span>
<span class="line-removed"> 400         m_backingStore-&gt;close();</span>
<span class="line-removed"> 401         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-removed"> 402     }</span>
<span class="line-removed"> 403 </span>
<span class="line-removed"> 404     m_backingStore = nullptr;</span>
<span class="line-removed"> 405     m_backingStoreSupportsSimultaneousTransactions = false;</span>
<span class="line-removed"> 406     m_backingStoreIsEphemeral = false;</span>
<span class="line-removed"> 407 </span>
<span class="line-removed"> 408     if (!m_databaseQueue.isEmpty()) {</span>
<span class="line-removed"> 409         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));</span>
<span class="line-removed"> 410         return;</span>
 411     }
<a name="31" id="anc31"></a><span class="line-removed"> 412     m_databaseQueue.kill();</span>
<span class="line-removed"> 413 </span>
<span class="line-removed"> 414     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didShutdownForClose));</span>
<span class="line-removed"> 415 }</span>
 416 
<a name="32" id="anc32"></a><span class="line-modified"> 417 void UniqueIDBDatabase::didShutdownForClose()</span>
<span class="line-removed"> 418 {</span>
<span class="line-removed"> 419     ASSERT(m_databaseReplyQueue.isEmpty());</span>
<span class="line-removed"> 420     m_databaseReplyQueue.kill();</span>
<span class="line-removed"> 421 </span>
<span class="line-removed"> 422     updateSpaceUsedIfNeeded();</span>
 423 }
 424 
 425 void UniqueIDBDatabase::didDeleteBackingStore(uint64_t deletedVersion)
 426 {
<a name="33" id="anc33"></a><span class="line-modified"> 427     ASSERT(isMainThread());</span>
<span class="line-removed"> 428     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didDeleteBackingStore&quot;);</span>
 429 
<a name="34" id="anc34"></a><span class="line-modified"> 430     ASSERT(!hasAnyPendingCallbacks());</span>
<span class="line-removed"> 431     ASSERT(!hasUnfinishedTransactions());</span>
 432     ASSERT(m_pendingTransactions.isEmpty());
 433     ASSERT(m_openDatabaseConnections.isEmpty());
 434     ASSERT(!m_backingStore);
 435 
<a name="35" id="anc35"></a><span class="line-modified"> 436     // It&#39;s possible that the openDBRequest was cancelled from client-side after the delete was already dispatched to the backingstore.</span>
<span class="line-removed"> 437     // So it&#39;s okay if we don&#39;t have a currentOpenDBRequest, but if we do it has to be a deleteRequest.</span>
<span class="line-removed"> 438     ASSERT(!m_currentOpenDBRequest || m_currentOpenDBRequest-&gt;isDeleteRequest());</span>
 439 
 440     if (m_databaseInfo)
 441         m_mostRecentDeletedDatabaseInfo = WTFMove(m_databaseInfo);
 442 
 443     // If this UniqueIDBDatabase was brought into existence for the purpose of deleting the file on disk,
 444     // we won&#39;t have a m_mostRecentDeletedDatabaseInfo. In that case, we&#39;ll manufacture one using the
 445     // passed in deletedVersion argument.
 446     if (!m_mostRecentDeletedDatabaseInfo)
<a name="36" id="anc36"></a><span class="line-modified"> 447         m_mostRecentDeletedDatabaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), deletedVersion);</span>
 448 
 449     if (m_currentOpenDBRequest) {
 450         m_currentOpenDBRequest-&gt;notifyDidDeleteDatabase(*m_mostRecentDeletedDatabaseInfo);
 451         m_currentOpenDBRequest = nullptr;
 452     }
<a name="37" id="anc37"></a><span class="line-removed"> 453 </span>
<span class="line-removed"> 454     updateSpaceUsedIfNeeded();</span>
<span class="line-removed"> 455 </span>
<span class="line-removed"> 456     m_deleteBackingStoreInProgress = false;</span>
<span class="line-removed"> 457 </span>
<span class="line-removed"> 458     if (m_hardClosedForUserDelete)</span>
<span class="line-removed"> 459         return;</span>
<span class="line-removed"> 460 </span>
<span class="line-removed"> 461     invokeOperationAndTransactionTimer();</span>
 462 }
 463 
 464 void UniqueIDBDatabase::clearStalePendingOpenDBRequests()
 465 {
 466     while (!m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;connection().isClosed())
 467         m_pendingOpenDBRequests.removeFirst();
 468 }
 469 
 470 void UniqueIDBDatabase::handleDatabaseOperations()
 471 {
<a name="38" id="anc38"></a><span class="line-modified"> 472     ASSERT(isMainThread());</span>
<span class="line-modified"> 473     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDatabaseOperations - There are %u pending&quot;, m_pendingOpenDBRequests.size());</span>
<span class="line-removed"> 474     ASSERT(!m_hardClosedForUserDelete);</span>
<span class="line-removed"> 475 </span>
<span class="line-removed"> 476     if (m_deleteBackingStoreInProgress || m_isOpeningBackingStore)</span>
<span class="line-removed"> 477         return;</span>
<span class="line-removed"> 478 </span>
<span class="line-removed"> 479     clearStalePendingOpenDBRequests();</span>
 480 
<a name="39" id="anc39"></a><span class="line-modified"> 481     if (m_versionChangeDatabaseConnection || m_versionChangeTransaction || (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())) {</span>
 482         // We can&#39;t start any new open-database operations right now, but we might be able to start handling a delete operation.
<a name="40" id="anc40"></a><span class="line-modified"> 483         if (!m_currentOpenDBRequest &amp;&amp; !m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;isDeleteRequest())</span>
<span class="line-modified"> 484             m_currentOpenDBRequest = m_pendingOpenDBRequests.takeFirst();</span>
<span class="line-modified"> 485 </span>
<span class="line-modified"> 486         // Some operations (such as the first open operation after a delete) require multiple passes to completely handle</span>
<span class="line-removed"> 487         if (m_currentOpenDBRequest)</span>
<span class="line-removed"> 488             handleCurrentOperation();</span>
<span class="line-removed"> 489 </span>
<span class="line-removed"> 490         return;</span>
<span class="line-removed"> 491     }</span>
 492 
<a name="41" id="anc41"></a><span class="line-modified"> 493     if (m_pendingOpenDBRequests.isEmpty()) {</span>
<span class="line-modified"> 494         m_currentOpenDBRequest = nullptr;</span>
<span class="line-modified"> 495         return;</span>






 496     }
<a name="42" id="anc42"></a><span class="line-modified"> 497 </span>
<span class="line-removed"> 498     m_currentOpenDBRequest = m_pendingOpenDBRequests.takeFirst();</span>
<span class="line-removed"> 499     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDatabaseOperations - Popped an operation, now there are %u pending&quot;, m_pendingOpenDBRequests.size());</span>
<span class="line-removed"> 500 </span>
<span class="line-removed"> 501     handleCurrentOperation();</span>
 502 }
 503 
 504 void UniqueIDBDatabase::handleCurrentOperation()
 505 {
<a name="43" id="anc43"></a><span class="line-modified"> 506     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleCurrentOperation&quot;);</span>
<span class="line-removed"> 507     ASSERT(!m_hardClosedForUserDelete);</span>
 508     ASSERT(m_currentOpenDBRequest);
 509 
 510     if (m_currentOpenDBRequest-&gt;isOpenRequest())
 511         performCurrentOpenOperation();
 512     else if (m_currentOpenDBRequest-&gt;isDeleteRequest())
 513         performCurrentDeleteOperation();
 514     else
 515         ASSERT_NOT_REACHED();
<a name="44" id="anc44"></a><span class="line-removed"> 516 </span>
<span class="line-removed"> 517     if (!m_currentOpenDBRequest)</span>
<span class="line-removed"> 518         invokeOperationAndTransactionTimer();</span>
 519 }
 520 
 521 bool UniqueIDBDatabase::hasAnyOpenConnections() const
 522 {
 523     return !m_openDatabaseConnections.isEmpty();
 524 }
 525 
 526 bool UniqueIDBDatabase::allConnectionsAreClosedOrClosing() const
 527 {
 528     for (auto&amp; connection : m_openDatabaseConnections) {
 529         if (!connection-&gt;connectionIsClosing())
 530             return false;
 531     }
 532 
 533     return true;
 534 }
 535 
<a name="45" id="anc45"></a><span class="line-removed"> 536 static uint64_t generateUniqueCallbackIdentifier()</span>
<span class="line-removed"> 537 {</span>
<span class="line-removed"> 538     ASSERT(isMainThread());</span>
<span class="line-removed"> 539     static uint64_t currentID = 0;</span>
<span class="line-removed"> 540     return ++currentID;</span>
<span class="line-removed"> 541 }</span>
<span class="line-removed"> 542 </span>
<span class="line-removed"> 543 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(ErrorCallback&amp;&amp; callback, uint64_t taskSize)</span>
<span class="line-removed"> 544 {</span>
<span class="line-removed"> 545     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed"> 546         callback(IDBError::userDeleteError());</span>
<span class="line-removed"> 547         return 0;</span>
<span class="line-removed"> 548     }</span>
<span class="line-removed"> 549 </span>
<span class="line-removed"> 550     uint64_t identifier = generateUniqueCallbackIdentifier();</span>
<span class="line-removed"> 551     ASSERT(!m_errorCallbacks.contains(identifier));</span>
<span class="line-removed"> 552     m_errorCallbacks.add(identifier, WTFMove(callback));</span>
<span class="line-removed"> 553 </span>
<span class="line-removed"> 554     if (taskSize) {</span>
<span class="line-removed"> 555         m_server-&gt;increasePotentialSpaceUsed(m_identifier.origin(), taskSize);</span>
<span class="line-removed"> 556         m_pendingSpaceIncreasingTasks.add(identifier, taskSize);</span>
<span class="line-removed"> 557     }</span>
<span class="line-removed"> 558 </span>
<span class="line-removed"> 559     m_callbackQueue.append(identifier);</span>
<span class="line-removed"> 560     return identifier;</span>
<span class="line-removed"> 561 }</span>
<span class="line-removed"> 562 </span>
<span class="line-removed"> 563 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(KeyDataCallback&amp;&amp; callback, uint64_t taskSize)</span>
<span class="line-removed"> 564 {</span>
<span class="line-removed"> 565     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed"> 566         callback(IDBError::userDeleteError(), { });</span>
<span class="line-removed"> 567         return 0;</span>
<span class="line-removed"> 568     }</span>
<span class="line-removed"> 569 </span>
<span class="line-removed"> 570     uint64_t identifier = generateUniqueCallbackIdentifier();</span>
<span class="line-removed"> 571     ASSERT(!m_keyDataCallbacks.contains(identifier));</span>
<span class="line-removed"> 572     m_keyDataCallbacks.add(identifier, WTFMove(callback));</span>
<span class="line-removed"> 573 </span>
<span class="line-removed"> 574     if (taskSize) {</span>
<span class="line-removed"> 575         m_server-&gt;increasePotentialSpaceUsed(m_identifier.origin(), taskSize);</span>
<span class="line-removed"> 576         m_pendingSpaceIncreasingTasks.add(identifier, taskSize);</span>
<span class="line-removed"> 577     }</span>
<span class="line-removed"> 578 </span>
<span class="line-removed"> 579     m_callbackQueue.append(identifier);</span>
<span class="line-removed"> 580     return identifier;</span>
<span class="line-removed"> 581 }</span>
<span class="line-removed"> 582 </span>
<span class="line-removed"> 583 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetResultCallback&amp;&amp; callback)</span>
<span class="line-removed"> 584 {</span>
<span class="line-removed"> 585     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed"> 586         callback(IDBError::userDeleteError(), { });</span>
<span class="line-removed"> 587         return 0;</span>
<span class="line-removed"> 588     }</span>
<span class="line-removed"> 589 </span>
<span class="line-removed"> 590     uint64_t identifier = generateUniqueCallbackIdentifier();</span>
<span class="line-removed"> 591     ASSERT(!m_getResultCallbacks.contains(identifier));</span>
<span class="line-removed"> 592     m_getResultCallbacks.add(identifier, WTFMove(callback));</span>
<span class="line-removed"> 593     m_callbackQueue.append(identifier);</span>
<span class="line-removed"> 594     return identifier;</span>
<span class="line-removed"> 595 }</span>
<span class="line-removed"> 596 </span>
<span class="line-removed"> 597 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetAllResultsCallback&amp;&amp; callback)</span>
<span class="line-removed"> 598 {</span>
<span class="line-removed"> 599     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed"> 600         callback(IDBError::userDeleteError(), { });</span>
<span class="line-removed"> 601         return 0;</span>
<span class="line-removed"> 602     }</span>
<span class="line-removed"> 603 </span>
<span class="line-removed"> 604     uint64_t identifier = generateUniqueCallbackIdentifier();</span>
<span class="line-removed"> 605     ASSERT(!m_getAllResultsCallbacks.contains(identifier));</span>
<span class="line-removed"> 606     m_getAllResultsCallbacks.add(identifier, WTFMove(callback));</span>
<span class="line-removed"> 607     m_callbackQueue.append(identifier);</span>
<span class="line-removed"> 608     return identifier;</span>
<span class="line-removed"> 609 }</span>
<span class="line-removed"> 610 </span>
<span class="line-removed"> 611 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(CountCallback&amp;&amp; callback)</span>
<span class="line-removed"> 612 {</span>
<span class="line-removed"> 613     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed"> 614         callback(IDBError::userDeleteError(), 0);</span>
<span class="line-removed"> 615         return 0;</span>
<span class="line-removed"> 616     }</span>
<span class="line-removed"> 617 </span>
<span class="line-removed"> 618     uint64_t identifier = generateUniqueCallbackIdentifier();</span>
<span class="line-removed"> 619     ASSERT(!m_countCallbacks.contains(identifier));</span>
<span class="line-removed"> 620     m_countCallbacks.add(identifier, WTFMove(callback));</span>
<span class="line-removed"> 621     m_callbackQueue.append(identifier);</span>
<span class="line-removed"> 622     return identifier;</span>
<span class="line-removed"> 623 }</span>
<span class="line-removed"> 624 </span>
 625 void UniqueIDBDatabase::handleDelete(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 626 {
<a name="46" id="anc46"></a><span class="line-modified"> 627     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDelete&quot;);</span>
<span class="line-removed"> 628     ASSERT(!m_hardClosedForUserDelete);</span>
 629 
 630     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 631     handleDatabaseOperations();
 632 }
 633 
 634 void UniqueIDBDatabase::startVersionChangeTransaction()
 635 {
<a name="47" id="anc47"></a><span class="line-modified"> 636     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::startVersionChangeTransaction&quot;);</span>
 637 
 638     ASSERT(!m_versionChangeTransaction);
 639     ASSERT(m_currentOpenDBRequest);
 640     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 641     ASSERT(m_versionChangeDatabaseConnection);
 642 
 643     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
 644     if (!requestedVersion)
 645         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 646 
 647     m_versionChangeTransaction = &amp;m_versionChangeDatabaseConnection-&gt;createVersionChangeTransaction(requestedVersion);
<a name="48" id="anc48"></a><span class="line-modified"> 648     m_inProgressTransactions.set(m_versionChangeTransaction-&gt;info().identifier(), m_versionChangeTransaction);</span>
<span class="line-modified"> 649 </span>
<span class="line-removed"> 650     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performStartVersionChangeTransaction, m_versionChangeTransaction-&gt;info()));</span>
<span class="line-removed"> 651 }</span>
<span class="line-removed"> 652 </span>
<span class="line-removed"> 653 void UniqueIDBDatabase::performStartVersionChangeTransaction(const IDBTransactionInfo&amp; info)</span>
<span class="line-removed"> 654 {</span>
<span class="line-removed"> 655     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performStartVersionChangeTransaction&quot;);</span>
<span class="line-removed"> 656 </span>
<span class="line-removed"> 657     IDBError error = m_backingStore-&gt;beginTransaction(info);</span>
<span class="line-removed"> 658     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformStartVersionChangeTransaction, error));</span>
<span class="line-removed"> 659 }</span>
<span class="line-removed"> 660 </span>
<span class="line-removed"> 661 void UniqueIDBDatabase::didPerformStartVersionChangeTransaction(const IDBError&amp; error)</span>
<span class="line-removed"> 662 {</span>
<span class="line-removed"> 663     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformStartVersionChangeTransaction&quot;);</span>
<span class="line-removed"> 664 </span>
<span class="line-removed"> 665     // Open request may already be canceled by client or user, or connection to client is lost.</span>
<span class="line-removed"> 666     if (!m_versionChangeDatabaseConnection)</span>
<span class="line-removed"> 667         return;</span>
 668 
<a name="49" id="anc49"></a><span class="line-modified"> 669     ASSERT(m_currentOpenDBRequest);</span>
<span class="line-removed"> 670     ASSERT(m_versionChangeTransaction);</span>
 671     auto operation = WTFMove(m_currentOpenDBRequest);
 672     IDBResultData result;
 673     if (error.isNull()) {
 674         addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);
<a name="50" id="anc50"></a><span class="line-modified"> 675         m_databaseInfo-&gt;setVersion(m_versionChangeTransaction-&gt;info().newVersion());</span>
 676         result = IDBResultData::openDatabaseUpgradeNeeded(operation-&gt;requestData().requestIdentifier(), *m_versionChangeTransaction);
 677         operation-&gt;connection().didOpenDatabase(result);
 678     } else {
 679         m_versionChangeDatabaseConnection-&gt;abortTransactionWithoutCallback(*m_versionChangeTransaction);
 680         m_versionChangeDatabaseConnection = nullptr;
 681         result = IDBResultData::error(operation-&gt;requestData().requestIdentifier(), error);
 682         operation-&gt;connection().didOpenDatabase(result);
 683     }
<a name="51" id="anc51"></a><span class="line-removed"> 684 </span>
<span class="line-removed"> 685     invokeOperationAndTransactionTimer();</span>
 686 }
 687 
 688 void UniqueIDBDatabase::maybeNotifyConnectionsOfVersionChange()
 689 {
 690     ASSERT(m_currentOpenDBRequest);
 691 
 692     if (m_currentOpenDBRequest-&gt;hasNotifiedConnectionsOfVersionChange())
 693         return;
 694 
 695     uint64_t newVersion = m_currentOpenDBRequest-&gt;isOpenRequest() ? m_currentOpenDBRequest-&gt;requestData().requestedVersion() : 0;
 696     auto requestIdentifier = m_currentOpenDBRequest-&gt;requestData().requestIdentifier();
 697 
<a name="52" id="anc52"></a><span class="line-modified"> 698     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::notifyConnectionsOfVersionChange - %&quot; PRIu64, newVersion);</span>
 699 
 700     // 3.3.7 &quot;versionchange&quot; transaction steps
 701     // Fire a versionchange event at each connection in m_openDatabaseConnections that is open.
 702     // The event must not be fired on connections which has the closePending flag set.
 703     HashSet&lt;uint64_t&gt; connectionIdentifiers;
 704     for (const auto&amp; connection : m_openDatabaseConnections) {
 705         if (connection-&gt;closePending())
 706             continue;
 707 
 708         connection-&gt;fireVersionChangeEvent(requestIdentifier, newVersion);
 709         connectionIdentifiers.add(connection-&gt;identifier());
 710     }
 711 
 712     if (!connectionIdentifiers.isEmpty())
 713         m_currentOpenDBRequest-&gt;notifiedConnectionsOfVersionChange(WTFMove(connectionIdentifiers));
 714     else
 715         m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
 716 }
 717 
 718 void UniqueIDBDatabase::notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(uint64_t connectionIdentifier)
 719 {
 720     LOG(IndexedDB, &quot;UniqueIDBDatabase::notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent - %&quot; PRIu64, connectionIdentifier);
 721 
 722     ASSERT(m_currentOpenDBRequest);
 723 
 724     m_currentOpenDBRequest-&gt;connectionClosedOrFiredVersionChangeEvent(connectionIdentifier);
 725 
 726     if (m_currentOpenDBRequest-&gt;hasConnectionsPendingVersionChangeEvent())
 727         return;
 728 
 729     if (!hasAnyOpenConnections() || allConnectionsAreClosedOrClosing()) {
<a name="53" id="anc53"></a><span class="line-modified"> 730         invokeOperationAndTransactionTimer();</span>
 731         return;
 732     }
 733 
 734     // Since all open connections have fired their version change events but not all of them have closed,
 735     // this request is officially blocked.
 736     m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
 737 }
 738 
<a name="54" id="anc54"></a><span class="line-modified"> 739 void UniqueIDBDatabase::didFireVersionChangeEvent(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; requestIdentifier)</span>






















 740 {
 741     LOG(IndexedDB, &quot;UniqueIDBDatabase::didFireVersionChangeEvent&quot;);
 742 
 743     if (!m_currentOpenDBRequest)
 744         return;
 745 
 746     ASSERT_UNUSED(requestIdentifier, m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier);
 747 
<a name="55" id="anc55"></a>






 748     notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
 749 }
 750 
 751 void UniqueIDBDatabase::openDBRequestCancelled(const IDBResourceIdentifier&amp; requestIdentifier)
 752 {
 753     LOG(IndexedDB, &quot;UniqueIDBDatabase::openDBRequestCancelled - %s&quot;, requestIdentifier.loggingString().utf8().data());
 754 
 755     if (m_currentOpenDBRequest &amp;&amp; m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier)
 756         m_currentOpenDBRequest = nullptr;
 757 
 758     if (m_versionChangeDatabaseConnection &amp;&amp; m_versionChangeDatabaseConnection-&gt;openRequestIdentifier() == requestIdentifier) {
 759         ASSERT(!m_versionChangeTransaction || m_versionChangeTransaction-&gt;databaseConnection().openRequestIdentifier() == requestIdentifier);
 760         ASSERT(!m_versionChangeTransaction || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
 761 
 762         connectionClosedFromClient(*m_versionChangeDatabaseConnection);
 763     }
 764 
 765     for (auto&amp; request : m_pendingOpenDBRequests) {
 766         if (request-&gt;requestData().requestIdentifier() == requestIdentifier) {
 767             m_pendingOpenDBRequests.remove(request);
 768             return;
 769         }
 770     }
 771 }
 772 
 773 void UniqueIDBDatabase::addOpenDatabaseConnection(Ref&lt;UniqueIDBDatabaseConnection&gt;&amp;&amp; connection)
 774 {
 775     ASSERT(!m_openDatabaseConnections.contains(&amp;connection.get()));
 776     m_openDatabaseConnections.add(adoptRef(connection.leakRef()));
 777 }
 778 
<a name="56" id="anc56"></a><span class="line-modified"> 779 void UniqueIDBDatabase::openBackingStore(const IDBDatabaseIdentifier&amp; identifier)</span>
 780 {
 781     ASSERT(!isMainThread());
<a name="57" id="anc57"></a><span class="line-modified"> 782     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::openBackingStore (%p)&quot;, this);</span>
 783 
<a name="58" id="anc58"></a><span class="line-modified"> 784     ASSERT(!m_backingStore);</span>
<span class="line-removed"> 785     m_backingStore = m_server-&gt;createBackingStore(identifier);</span>
<span class="line-removed"> 786     m_backingStoreSupportsSimultaneousTransactions = m_backingStore-&gt;supportsSimultaneousTransactions();</span>
<span class="line-removed"> 787     m_backingStoreIsEphemeral = m_backingStore-&gt;isEphemeral();</span>
 788 
<a name="59" id="anc59"></a><span class="line-modified"> 789     // QuotaUser should have initiliazed storage usage, which contains the</span>
<span class="line-modified"> 790     // size of this database.</span>
<span class="line-modified"> 791     m_currentDatabaseSize = m_backingStore-&gt;databaseSize();</span>



 792 
<a name="60" id="anc60"></a><span class="line-modified"> 793     IDBDatabaseInfo databaseInfo;</span>
<span class="line-modified"> 794     auto error = m_backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);</span>

 795 
<a name="61" id="anc61"></a><span class="line-modified"> 796     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didOpenBackingStore, databaseInfo, error));</span>
 797 }
 798 
<a name="62" id="anc62"></a><span class="line-modified"> 799 void UniqueIDBDatabase::didOpenBackingStore(const IDBDatabaseInfo&amp; info, const IDBError&amp; error)</span>
 800 {
<a name="63" id="anc63"></a><span class="line-modified"> 801     ASSERT(isMainThread());</span>
<span class="line-modified"> 802     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didOpenBackingStore&quot;);</span>
<span class="line-removed"> 803 </span>
<span class="line-removed"> 804     m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(info);</span>
<span class="line-removed"> 805     m_backingStoreOpenError = error;</span>
<span class="line-removed"> 806 </span>
<span class="line-removed"> 807     ASSERT(m_isOpeningBackingStore);</span>
<span class="line-removed"> 808     m_isOpeningBackingStore = false;</span>
<span class="line-removed"> 809 </span>
<span class="line-removed"> 810     updateSpaceUsedIfNeeded();</span>
 811 
<a name="64" id="anc64"></a><span class="line-modified"> 812     if (m_hardClosedForUserDelete)</span>


 813         return;
<a name="65" id="anc65"></a>
 814 
<a name="66" id="anc66"></a><span class="line-modified"> 815     handleDatabaseOperations();</span>





 816 }
 817 
<a name="67" id="anc67"></a><span class="line-modified"> 818 void UniqueIDBDatabase::createObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)</span>
 819 {
<a name="68" id="anc68"></a><span class="line-modified"> 820     ASSERT(isMainThread());</span>
<span class="line-modified"> 821     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createObjectStore&quot;);</span>
 822 
<a name="69" id="anc69"></a><span class="line-modified"> 823     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="line-modified"> 824     requestSpace(taskSize, &quot;createObjectStore&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-modified"> 825         if (error) {</span>
<span class="line-modified"> 826             callback(WTFMove(*error));</span>
<span class="line-modified"> 827             return;</span>
<span class="line-modified"> 828         }</span>
<span class="line-removed"> 829         if (!transaction) {</span>
<span class="line-removed"> 830             callback(IDBError { UnknownError });</span>
<span class="line-removed"> 831             return;</span>
<span class="line-removed"> 832         }</span>
<span class="line-removed"> 833         this-&gt;createObjectStoreAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));</span>
<span class="line-removed"> 834     });</span>
<span class="line-removed"> 835 }</span>
 836 
<a name="70" id="anc70"></a><span class="line-modified"> 837 void UniqueIDBDatabase::createObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)</span>
<span class="line-modified"> 838 {</span>
<span class="line-modified"> 839     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="line-removed"> 840     if (!callbackID)</span>
 841         return;
<a name="71" id="anc71"></a>





 842 
<a name="72" id="anc72"></a><span class="line-modified"> 843     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateObjectStore, callbackID, transaction.info().identifier(), info));</span>
 844 }
 845 
<a name="73" id="anc73"></a><span class="line-modified"> 846 void UniqueIDBDatabase::performCreateObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)</span>
 847 {
 848     ASSERT(!isMainThread());
<a name="74" id="anc74"></a><span class="line-modified"> 849     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateObjectStore&quot;);</span>
 850 
 851     ASSERT(m_backingStore);
<a name="75" id="anc75"></a><span class="line-modified"> 852     m_backingStore-&gt;createObjectStore(transactionIdentifier, info);</span>
 853 
<a name="76" id="anc76"></a><span class="line-modified"> 854     IDBError error;</span>
<span class="line-removed"> 855     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateObjectStore, callbackIdentifier, error, info));</span>
 856 }
 857 
<a name="77" id="anc77"></a><span class="line-modified"> 858 void UniqueIDBDatabase::didPerformCreateObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBObjectStoreInfo&amp; info)</span>
 859 {
<a name="78" id="anc78"></a><span class="line-modified"> 860     ASSERT(isMainThread());</span>
<span class="line-modified"> 861     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateObjectStore&quot;);</span>
 862 
<a name="79" id="anc79"></a><span class="line-modified"> 863     if (error.isNull())</span>
<span class="line-modified"> 864         m_databaseInfo-&gt;addExistingObjectStore(info);</span>














 865 
<a name="80" id="anc80"></a><span class="line-modified"> 866     performErrorCallback(callbackIdentifier, error);</span>
 867 }
 868 
<a name="81" id="anc81"></a><span class="line-modified"> 869 void UniqueIDBDatabase::deleteObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)</span>
 870 {
<a name="82" id="anc82"></a><span class="line-modified"> 871     ASSERT(isMainThread());</span>
<span class="line-modified"> 872     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteObjectStore&quot;);</span>
<span class="line-removed"> 873 </span>
<span class="line-removed"> 874     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed"> 875         if (error) {</span>
<span class="line-removed"> 876             callback(WTFMove(*error));</span>
<span class="line-removed"> 877             return;</span>
<span class="line-removed"> 878         }</span>
<span class="line-removed"> 879         if (!transaction) {</span>
<span class="line-removed"> 880             callback(IDBError { UnknownError });</span>
<span class="line-removed"> 881             return;</span>
<span class="line-removed"> 882         }</span>
<span class="line-removed"> 883         this-&gt;deleteObjectStoreAfterQuotaCheck(*transaction, objectStoreName, WTFMove(callback));</span>
<span class="line-removed"> 884     });</span>
<span class="line-removed"> 885 }</span>
<span class="line-removed"> 886 </span>
<span class="line-removed"> 887 void UniqueIDBDatabase::deleteObjectStoreAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)</span>
<span class="line-removed"> 888 {</span>
<span class="line-removed"> 889     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed"> 890     if (!callbackID)</span>
<span class="line-removed"> 891         return;</span>
<span class="line-removed"> 892 </span>
<span class="line-removed"> 893     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreName);</span>
<span class="line-removed"> 894     if (!info) {</span>
<span class="line-removed"> 895         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant object store&quot;_s });</span>
<span class="line-removed"> 896         return;</span>
<span class="line-removed"> 897     }</span>
<span class="line-removed"> 898 </span>
<span class="line-removed"> 899     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteObjectStore, callbackID, transaction.info().identifier(), info-&gt;identifier()));</span>
<span class="line-removed"> 900 }</span>
<span class="line-removed"> 901 </span>
<span class="line-removed"> 902 void UniqueIDBDatabase::performDeleteObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)</span>
<span class="line-removed"> 903 {</span>
<span class="line-removed"> 904     ASSERT(!isMainThread());</span>
<span class="line-removed"> 905     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteObjectStore&quot;);</span>
<span class="line-removed"> 906 </span>
<span class="line-removed"> 907     ASSERT(m_backingStore);</span>
<span class="line-removed"> 908     m_backingStore-&gt;deleteObjectStore(transactionIdentifier, objectStoreIdentifier);</span>
<span class="line-removed"> 909 </span>
<span class="line-removed"> 910     IDBError error;</span>
<span class="line-removed"> 911     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteObjectStore, callbackIdentifier, error, objectStoreIdentifier));</span>
<span class="line-removed"> 912 }</span>
<span class="line-removed"> 913 </span>
<span class="line-removed"> 914 void UniqueIDBDatabase::didPerformDeleteObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier)</span>
<span class="line-removed"> 915 {</span>
<span class="line-removed"> 916     ASSERT(isMainThread());</span>
<span class="line-removed"> 917     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteObjectStore&quot;);</span>
<span class="line-removed"> 918 </span>
<span class="line-removed"> 919     if (error.isNull())</span>
<span class="line-removed"> 920         m_databaseInfo-&gt;deleteObjectStore(objectStoreIdentifier);</span>
<span class="line-removed"> 921 </span>
<span class="line-removed"> 922     performErrorCallback(callbackIdentifier, error);</span>
<span class="line-removed"> 923 }</span>
<span class="line-removed"> 924 </span>
<span class="line-removed"> 925 void UniqueIDBDatabase::renameObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)</span>
<span class="line-removed"> 926 {</span>
<span class="line-removed"> 927     ASSERT(isMainThread());</span>
<span class="line-removed"> 928     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameObjectStore&quot;);</span>
<span class="line-removed"> 929 </span>
<span class="line-removed"> 930     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();</span>
<span class="line-removed"> 931     requestSpace(taskSize, &quot;renameObjectStore&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed"> 932         if (error) {</span>
<span class="line-removed"> 933             callback(WTFMove(*error));</span>
<span class="line-removed"> 934             return;</span>
<span class="line-removed"> 935         }</span>
<span class="line-removed"> 936         if (!transaction) {</span>
<span class="line-removed"> 937             callback(IDBError { UnknownError });</span>
<span class="line-removed"> 938             return;</span>
<span class="line-removed"> 939         }</span>
<span class="line-removed"> 940         this-&gt;renameObjectStoreAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, newName, WTFMove(callback));</span>
<span class="line-removed"> 941     });</span>
<span class="line-removed"> 942 }</span>
<span class="line-removed"> 943 </span>
<span class="line-removed"> 944 void UniqueIDBDatabase::renameObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)</span>
<span class="line-removed"> 945 {</span>
<span class="line-removed"> 946     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="line-removed"> 947     if (!callbackID)</span>
<span class="line-removed"> 948         return;</span>
<span class="line-removed"> 949 </span>
<span class="line-removed"> 950     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);</span>
<span class="line-removed"> 951     if (!info) {</span>
<span class="line-removed"> 952         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant object store&quot;_s });</span>
<span class="line-removed"> 953         return;</span>
<span class="line-removed"> 954     }</span>
<span class="line-removed"> 955 </span>
<span class="line-removed"> 956     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier, newName));</span>
<span class="line-removed"> 957 }</span>
<span class="line-removed"> 958 </span>
<span class="line-removed"> 959 void UniqueIDBDatabase::performRenameObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)</span>
<span class="line-removed"> 960 {</span>
<span class="line-removed"> 961     ASSERT(!isMainThread());</span>
<span class="line-removed"> 962     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performRenameObjectStore&quot;);</span>
<span class="line-removed"> 963 </span>
<span class="line-removed"> 964     ASSERT(m_backingStore);</span>
<span class="line-removed"> 965     m_backingStore-&gt;renameObjectStore(transactionIdentifier, objectStoreIdentifier, newName);</span>
<span class="line-removed"> 966 </span>
<span class="line-removed"> 967     IDBError error;</span>
<span class="line-removed"> 968     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformRenameObjectStore, callbackIdentifier, error, objectStoreIdentifier, newName));</span>
<span class="line-removed"> 969 }</span>
<span class="line-removed"> 970 </span>
<span class="line-removed"> 971 void UniqueIDBDatabase::didPerformRenameObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, const String&amp; newName)</span>
<span class="line-removed"> 972 {</span>
<span class="line-removed"> 973     ASSERT(isMainThread());</span>
<span class="line-removed"> 974     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameObjectStore&quot;);</span>
<span class="line-removed"> 975 </span>
<span class="line-removed"> 976     if (error.isNull())</span>
<span class="line-removed"> 977         m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);</span>
<span class="line-removed"> 978 </span>
<span class="line-removed"> 979     performErrorCallback(callbackIdentifier, error);</span>
<span class="line-removed"> 980 }</span>
<span class="line-removed"> 981 </span>
<span class="line-removed"> 982 void UniqueIDBDatabase::clearObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)</span>
<span class="line-removed"> 983 {</span>
<span class="line-removed"> 984     ASSERT(isMainThread());</span>
<span class="line-removed"> 985     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::clearObjectStore&quot;);</span>
<span class="line-removed"> 986 </span>
<span class="line-removed"> 987     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed"> 988         if (error) {</span>
<span class="line-removed"> 989             callback(WTFMove(*error));</span>
<span class="line-removed"> 990             return;</span>
<span class="line-removed"> 991         }</span>
<span class="line-removed"> 992         if (!transaction) {</span>
<span class="line-removed"> 993             callback(IDBError { UnknownError });</span>
<span class="line-removed"> 994             return;</span>
<span class="line-removed"> 995         }</span>
<span class="line-removed"> 996         this-&gt;clearObjectStoreAfetQuotaCheck(*transaction, objectStoreIdentifier, WTFMove(callback));</span>
<span class="line-removed"> 997     });</span>
<span class="line-removed"> 998 }</span>
<span class="line-removed"> 999 </span>
<span class="line-removed">1000 void UniqueIDBDatabase::clearObjectStoreAfetQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)</span>
<span class="line-removed">1001 {</span>
<span class="line-removed">1002     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">1003     if (!callbackID)</span>
<span class="line-removed">1004         return;</span>
<span class="line-removed">1005     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performClearObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier));</span>
<span class="line-removed">1006 }</span>
<span class="line-removed">1007 </span>
<span class="line-removed">1008 void UniqueIDBDatabase::performClearObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)</span>
<span class="line-removed">1009 {</span>
<span class="line-removed">1010     ASSERT(!isMainThread());</span>
<span class="line-removed">1011     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performClearObjectStore&quot;);</span>
<span class="line-removed">1012 </span>
<span class="line-removed">1013     ASSERT(m_backingStore);</span>
<span class="line-removed">1014     m_backingStore-&gt;clearObjectStore(transactionIdentifier, objectStoreIdentifier);</span>
<span class="line-removed">1015 </span>
<span class="line-removed">1016     IDBError error;</span>
<span class="line-removed">1017     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformClearObjectStore, callbackIdentifier, error));</span>
<span class="line-removed">1018 }</span>
<span class="line-removed">1019 </span>
<span class="line-removed">1020 void UniqueIDBDatabase::didPerformClearObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error)</span>
<span class="line-removed">1021 {</span>
<span class="line-removed">1022     ASSERT(isMainThread());</span>
<span class="line-removed">1023     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformClearObjectStore&quot;);</span>
<span class="line-removed">1024 </span>
<span class="line-removed">1025     performErrorCallback(callbackIdentifier, error);</span>
<span class="line-removed">1026 }</span>
<span class="line-removed">1027 </span>
<span class="line-removed">1028 void UniqueIDBDatabase::createIndex(UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)</span>
<span class="line-removed">1029 {</span>
<span class="line-removed">1030     ASSERT(isMainThread());</span>
<span class="line-removed">1031     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createIndex&quot;);</span>
<span class="line-removed">1032 </span>
<span class="line-removed">1033     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="line-removed">1034     requestSpace(taskSize, &quot;createIndex&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">1035         if (error) {</span>
<span class="line-removed">1036             callback(WTFMove(*error));</span>
<span class="line-removed">1037             return;</span>
<span class="line-removed">1038         }</span>
<span class="line-removed">1039         if (!transaction) {</span>
<span class="line-removed">1040             callback(IDBError { UnknownError });</span>
<span class="line-removed">1041             return;</span>
<span class="line-removed">1042         }</span>
<span class="line-removed">1043         this-&gt;createIndexAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));</span>
<span class="line-removed">1044     });</span>
<span class="line-removed">1045 }</span>
<span class="line-removed">1046 </span>
<span class="line-removed">1047 void UniqueIDBDatabase::createIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)</span>
<span class="line-removed">1048 {</span>
<span class="line-removed">1049     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="line-removed">1050     if (!callbackID)</span>
<span class="line-removed">1051         return;</span>
<span class="line-removed">1052     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateIndex, callbackID, transaction.info().identifier(), info));</span>
<span class="line-removed">1053 }</span>
<span class="line-removed">1054 </span>
<span class="line-removed">1055 void UniqueIDBDatabase::performCreateIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)</span>
<span class="line-removed">1056 {</span>
<span class="line-removed">1057     ASSERT(!isMainThread());</span>
<span class="line-removed">1058     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateIndex&quot;);</span>
<span class="line-removed">1059 </span>
<span class="line-removed">1060     IDBError error;</span>
<span class="line-removed">1061     ASSERT(m_backingStore);</span>
<span class="line-removed">1062     if (!m_backingStore) {</span>
<span class="line-removed">1063         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - UniqueIDBDatabase::performCreateIndex: m_backingStore is null&quot;, this);</span>
<span class="line-removed">1064         error = IDBError(InvalidStateError, &quot;Backing store is invalid for call to create index&quot;_s);</span>
<span class="line-removed">1065         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));</span>
<span class="line-removed">1066         return;</span>
<span class="line-removed">1067     }</span>
<span class="line-removed">1068 </span>
<span class="line-removed">1069     error = m_backingStore-&gt;createIndex(transactionIdentifier, info);</span>
<span class="line-removed">1070     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));</span>
<span class="line-removed">1071 }</span>
<span class="line-removed">1072 </span>
<span class="line-removed">1073 void UniqueIDBDatabase::didPerformCreateIndex(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBIndexInfo&amp; info)</span>
<span class="line-removed">1074 {</span>
<span class="line-removed">1075     ASSERT(isMainThread());</span>
<span class="line-removed">1076     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateIndex&quot;);</span>
<span class="line-removed">1077 </span>
<span class="line-removed">1078     if (error.isNull()) {</span>
<span class="line-removed">1079         ASSERT(m_databaseInfo);</span>
<span class="line-removed">1080         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());</span>
<span class="line-removed">1081         ASSERT(objectStoreInfo);</span>
<span class="line-removed">1082         objectStoreInfo-&gt;addExistingIndex(info);</span>
<span class="line-removed">1083     }</span>
<span class="line-removed">1084 </span>
<span class="line-removed">1085     performErrorCallback(callbackIdentifier, error);</span>
<span class="line-removed">1086 }</span>
<span class="line-removed">1087 </span>
<span class="line-removed">1088 void UniqueIDBDatabase::deleteIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)</span>
<span class="line-removed">1089 {</span>
<span class="line-removed">1090     ASSERT(isMainThread());</span>
<span class="line-removed">1091     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteIndex&quot;);</span>
<span class="line-removed">1092 </span>
<span class="line-removed">1093     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">1094         if (error) {</span>
<span class="line-removed">1095             callback(WTFMove(*error));</span>
<span class="line-removed">1096             return;</span>
<span class="line-removed">1097         }</span>
<span class="line-removed">1098         if (!transaction) {</span>
<span class="line-removed">1099             callback(IDBError { UnknownError });</span>
<span class="line-removed">1100             return;</span>
<span class="line-removed">1101         }</span>
<span class="line-removed">1102         this-&gt;deleteIndexAfterQuotaCheck(*transaction, objectStoreIdentifier, indexName, WTFMove(callback));</span>
<span class="line-removed">1103     });</span>
<span class="line-removed">1104 }</span>
<span class="line-removed">1105 </span>
<span class="line-removed">1106 void UniqueIDBDatabase::deleteIndexAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)</span>
<span class="line-removed">1107 {</span>
<span class="line-removed">1108     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">1109     if (!callbackID)</span>
<span class="line-removed">1110         return;</span>
1111 
1112     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1113     if (!objectStoreInfo) {
<a name="83" id="anc83"></a><span class="line-modified">1114         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete index from non-existant object store&quot;_s });</span>
1115         return;
1116     }
1117 
1118     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexName);
1119     if (!indexInfo) {
<a name="84" id="anc84"></a><span class="line-modified">1120         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant index&quot;_s });</span>
1121         return;
1122     }
<a name="85" id="anc85"></a><span class="line-modified">1123 </span>
<span class="line-removed">1124     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexInfo-&gt;identifier()));</span>
<span class="line-removed">1125 }</span>
<span class="line-removed">1126 </span>
<span class="line-removed">1127 void UniqueIDBDatabase::performDeleteIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const uint64_t indexIdentifier)</span>
<span class="line-removed">1128 {</span>
<span class="line-removed">1129     ASSERT(!isMainThread());</span>
<span class="line-removed">1130     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteIndex&quot;);</span>
1131 
1132     ASSERT(m_backingStore);
<a name="86" id="anc86"></a><span class="line-modified">1133     m_backingStore-&gt;deleteIndex(transactionIdentifier, objectStoreIdentifier, indexIdentifier);</span>
<span class="line-modified">1134 </span>
<span class="line-modified">1135     IDBError error;</span>
<span class="line-removed">1136     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteIndex, callbackIdentifier, error, objectStoreIdentifier, indexIdentifier));</span>
<span class="line-removed">1137 }</span>
<span class="line-removed">1138 </span>
<span class="line-removed">1139 void UniqueIDBDatabase::didPerformDeleteIndex(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)</span>
<span class="line-removed">1140 {</span>
<span class="line-removed">1141     ASSERT(isMainThread());</span>
<span class="line-removed">1142     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteIndex&quot;);</span>
<span class="line-removed">1143 </span>
<span class="line-removed">1144     if (error.isNull()) {</span>
<span class="line-removed">1145         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);</span>
<span class="line-removed">1146         if (objectStoreInfo)</span>
<span class="line-removed">1147             objectStoreInfo-&gt;deleteIndex(indexIdentifier);</span>
<span class="line-removed">1148     }</span>
1149 
<a name="87" id="anc87"></a><span class="line-modified">1150     performErrorCallback(callbackIdentifier, error);</span>
1151 }
1152 
1153 void UniqueIDBDatabase::renameIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)
1154 {
<a name="88" id="anc88"></a><span class="line-modified">1155     ASSERT(isMainThread());</span>
<span class="line-modified">1156     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameIndex&quot;);</span>
1157 
<a name="89" id="anc89"></a>
1158     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();
<a name="90" id="anc90"></a><span class="line-modified">1159     requestSpace(taskSize, &quot;renameIndex&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-modified">1160         if (error) {</span>
<span class="line-removed">1161             callback(WTFMove(*error));</span>
<span class="line-removed">1162             return;</span>
<span class="line-removed">1163         }</span>
<span class="line-removed">1164         if (!transaction) {</span>
<span class="line-removed">1165             callback(IDBError { UnknownError });</span>
<span class="line-removed">1166             return;</span>
<span class="line-removed">1167         }</span>
<span class="line-removed">1168         this-&gt;renameIndexAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, indexIdentifier, newName, WTFMove(callback));</span>
<span class="line-removed">1169     });</span>
<span class="line-removed">1170 }</span>
<span class="line-removed">1171 </span>
<span class="line-removed">1172 void UniqueIDBDatabase::renameIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)</span>
<span class="line-removed">1173 {</span>
<span class="line-removed">1174     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="line-removed">1175     if (!callbackID)</span>
1176         return;
<a name="91" id="anc91"></a>
1177 
1178     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1179     if (!objectStoreInfo) {
<a name="92" id="anc92"></a><span class="line-modified">1180         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename index in non-existant object store&quot;_s });</span>
1181         return;
1182     }
1183 
1184     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
1185     if (!indexInfo) {
<a name="93" id="anc93"></a><span class="line-modified">1186         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant index&quot;_s });</span>
1187         return;
1188     }
1189 
<a name="94" id="anc94"></a><span class="line-removed">1190     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexIdentifier, newName));</span>
<span class="line-removed">1191 }</span>
<span class="line-removed">1192 </span>
<span class="line-removed">1193 void UniqueIDBDatabase::performRenameIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)</span>
<span class="line-removed">1194 {</span>
<span class="line-removed">1195     ASSERT(!isMainThread());</span>
<span class="line-removed">1196     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performRenameIndex&quot;);</span>
<span class="line-removed">1197 </span>
1198     ASSERT(m_backingStore);
<a name="95" id="anc95"></a><span class="line-modified">1199     m_backingStore-&gt;renameIndex(transactionIdentifier, objectStoreIdentifier, indexIdentifier, newName);</span>
<span class="line-modified">1200 </span>
<span class="line-modified">1201     IDBError error;</span>
<span class="line-removed">1202     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformRenameIndex, callbackIdentifier, error, objectStoreIdentifier, indexIdentifier, newName));</span>
<span class="line-removed">1203 }</span>
<span class="line-removed">1204 </span>
<span class="line-removed">1205 void UniqueIDBDatabase::didPerformRenameIndex(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)</span>
<span class="line-removed">1206 {</span>
<span class="line-removed">1207     ASSERT(isMainThread());</span>
<span class="line-removed">1208     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameIndex&quot;);</span>
<span class="line-removed">1209 </span>
<span class="line-removed">1210     if (error.isNull()) {</span>
<span class="line-removed">1211         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);</span>
<span class="line-removed">1212         ASSERT(objectStoreInfo);</span>
<span class="line-removed">1213         if (objectStoreInfo) {</span>
<span class="line-removed">1214             auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);</span>
<span class="line-removed">1215             ASSERT(indexInfo);</span>
<span class="line-removed">1216             indexInfo-&gt;rename(newName);</span>
<span class="line-removed">1217         }</span>
<span class="line-removed">1218     }</span>
1219 
<a name="96" id="anc96"></a><span class="line-modified">1220     performErrorCallback(callbackIdentifier, error);</span>
1221 }
1222 
1223 void UniqueIDBDatabase::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
<a name="97" id="anc97"></a><span class="line-removed">1224 {</span>
<span class="line-removed">1225     ASSERT(isMainThread());</span>
<span class="line-removed">1226     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::putOrAdd&quot;);</span>
<span class="line-removed">1227 </span>
<span class="line-removed">1228     auto taskSize = defaultWriteOperationCost + estimateSize(keyData) + estimateSize(value);</span>
<span class="line-removed">1229     requestSpace(taskSize, &quot;putOrAdd&quot;, [this, taskSize, requestData, keyData, value, callback = WTFMove(callback), overwriteMode](auto error) mutable {</span>
<span class="line-removed">1230         if (error) {</span>
<span class="line-removed">1231             callback(WTFMove(*error), { });</span>
<span class="line-removed">1232             return;</span>
<span class="line-removed">1233         }</span>
<span class="line-removed">1234         this-&gt;putOrAddAfterQuotaCheck(taskSize, requestData, keyData, value, overwriteMode, WTFMove(callback));</span>
<span class="line-removed">1235     });</span>
<span class="line-removed">1236 }</span>
<span class="line-removed">1237 </span>
<span class="line-removed">1238 void UniqueIDBDatabase::putOrAddAfterQuotaCheck(uint64_t taskSize, const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)</span>
<span class="line-removed">1239 {</span>
<span class="line-removed">1240     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="line-removed">1241     if (!callbackID)</span>
<span class="line-removed">1242         return;</span>
<span class="line-removed">1243     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPutOrAdd, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyData, value, overwriteMode));</span>
<span class="line-removed">1244 }</span>
<span class="line-removed">1245 </span>
<span class="line-removed">1246 void UniqueIDBDatabase::performPutOrAdd(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyData&amp; keyData, const IDBValue&amp; originalRecordValue, IndexedDB::ObjectStoreOverwriteMode overwriteMode)</span>
1247 {
1248     ASSERT(!isMainThread());
<a name="98" id="anc98"></a><span class="line-modified">1249     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPutOrAdd&quot;);</span>
1250 
<a name="99" id="anc99"></a><span class="line-modified">1251     ASSERT(m_backingStore);</span>
<span class="line-removed">1252     ASSERT(objectStoreIdentifier);</span>
1253 
1254     IDBKeyData usedKey;
1255     IDBError error;
1256 
<a name="100" id="anc100"></a><span class="line-modified">1257     if (!m_backingStore) {</span>
<span class="line-modified">1258         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - UniqueIDBDatabase::performPutOrAdd: m_backingStore is null&quot;, this);</span>
<span class="line-modified">1259         error = IDBError(InvalidStateError, &quot;Backing store is invalid for call to put or add&quot;_s);</span>
<span class="line-modified">1260         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>

1261         return;
1262     }
1263 
<a name="101" id="anc101"></a><span class="line-modified">1264     auto* objectStoreInfo = m_backingStore-&gt;infoForObjectStore(objectStoreIdentifier);</span>
<span class="line-modified">1265     if (!objectStoreInfo) {</span>
<span class="line-modified">1266         error = IDBError(InvalidStateError, &quot;Object store cannot be found in the backing store&quot;_s);</span>
<span class="line-modified">1267         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>



1268         return;
1269     }
1270 
1271     bool usedKeyIsGenerated = false;
1272     uint64_t keyNumber;
<a name="102" id="anc102"></a>
1273     auto generatedKeyResetter = WTF::makeScopeExit([this, transactionIdentifier, objectStoreIdentifier, &amp;keyNumber, &amp;usedKeyIsGenerated]() {
1274         if (usedKeyIsGenerated)
1275             m_backingStore-&gt;revertGeneratedKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
1276     });
<a name="103" id="anc103"></a>
1277     if (objectStoreInfo-&gt;autoIncrement() &amp;&amp; !keyData.isValid()) {
1278         error = m_backingStore-&gt;generateKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
1279         if (!error.isNull()) {
<a name="104" id="anc104"></a><span class="line-modified">1280             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
1281             return;
1282         }
<a name="105" id="anc105"></a><span class="line-removed">1283 </span>
1284         usedKey.setNumberValue(keyNumber);
1285         usedKeyIsGenerated = true;
1286     } else
1287         usedKey = keyData;
1288 
1289     if (overwriteMode == IndexedDB::ObjectStoreOverwriteMode::NoOverwrite) {
1290         bool keyExists;
1291         error = m_backingStore-&gt;keyExistsInObjectStore(transactionIdentifier, objectStoreIdentifier, usedKey, keyExists);
1292         if (error.isNull() &amp;&amp; keyExists)
<a name="106" id="anc106"></a><span class="line-modified">1293             error = IDBError(ConstraintError, &quot;Key already exists in the object store&quot;_s);</span>
1294 
1295         if (!error.isNull()) {
<a name="107" id="anc107"></a><span class="line-modified">1296             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
1297             return;
1298         }
1299     }
<a name="108" id="anc108"></a><span class="line-modified">1300 </span>
<span class="line-removed">1301     // 3.4.1 Object Store Storage Operation</span>
<span class="line-removed">1302     // ...If a record already exists in store ...</span>
<span class="line-removed">1303     // then remove the record from store using the steps for deleting records from an object store...</span>
1304     // This is important because formally deleting it from from the object store also removes it from the appropriate indexes.
1305     error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, usedKey);
1306     if (!error.isNull()) {
<a name="109" id="anc109"></a><span class="line-modified">1307         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
1308         return;
1309     }
1310 
<a name="110" id="anc110"></a><span class="line-modified">1311     error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, originalRecordValue);</span>
<span class="line-removed">1312 </span>
1313     if (!error.isNull()) {
<a name="111" id="anc111"></a><span class="line-modified">1314         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
1315         return;
1316     }
1317 
1318     if (overwriteMode != IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor &amp;&amp; objectStoreInfo-&gt;autoIncrement() &amp;&amp; keyData.type() == IndexedDB::KeyType::Number)
1319         error = m_backingStore-&gt;maybeUpdateKeyGeneratorNumber(transactionIdentifier, objectStoreIdentifier, keyData.number());
1320 
1321     generatedKeyResetter.release();
<a name="112" id="anc112"></a><span class="line-modified">1322     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
<span class="line-removed">1323 }</span>
<span class="line-removed">1324 </span>
<span class="line-removed">1325 void UniqueIDBDatabase::didPerformPutOrAdd(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)</span>
<span class="line-removed">1326 {</span>
<span class="line-removed">1327     ASSERT(isMainThread());</span>
<span class="line-removed">1328     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformPutOrAdd&quot;);</span>
<span class="line-removed">1329 </span>
<span class="line-removed">1330     performKeyDataCallback(callbackIdentifier, error, resultKey);</span>
1331 }
1332 
1333 void UniqueIDBDatabase::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)
<a name="113" id="anc113"></a><span class="line-removed">1334 {</span>
<span class="line-removed">1335     ASSERT(isMainThread());</span>
<span class="line-removed">1336     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getRecord&quot;);</span>
<span class="line-removed">1337 </span>
<span class="line-removed">1338     waitForRequestSpaceCompletion([this, requestData, getRecordData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">1339         if (error) {</span>
<span class="line-removed">1340             callback(WTFMove(*error), { });</span>
<span class="line-removed">1341             return;</span>
<span class="line-removed">1342         }</span>
<span class="line-removed">1343         this-&gt;getRecordAfterQuotaCheck(requestData, getRecordData, WTFMove(callback));</span>
<span class="line-removed">1344     });</span>
<span class="line-removed">1345 }</span>
<span class="line-removed">1346 </span>
<span class="line-removed">1347 void UniqueIDBDatabase::getRecordAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)</span>
<span class="line-removed">1348 {</span>
<span class="line-removed">1349     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">1350     if (!callbackID)</span>
<span class="line-removed">1351         return;</span>
<span class="line-removed">1352 </span>
<span class="line-removed">1353     if (uint64_t indexIdentifier = requestData.indexIdentifier())</span>
<span class="line-removed">1354         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetIndexRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), indexIdentifier, requestData.indexRecordType(), getRecordData.keyRangeData));</span>
<span class="line-removed">1355     else</span>
<span class="line-removed">1356         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), getRecordData.keyRangeData, getRecordData.type));</span>
<span class="line-removed">1357 }</span>
<span class="line-removed">1358 </span>
<span class="line-removed">1359 void UniqueIDBDatabase::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)</span>
<span class="line-removed">1360 {</span>
<span class="line-removed">1361     ASSERT(isMainThread());</span>
<span class="line-removed">1362     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getAllRecords&quot;);</span>
<span class="line-removed">1363 </span>
<span class="line-removed">1364     waitForRequestSpaceCompletion([this, requestData, getAllRecordsData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">1365         if (error) {</span>
<span class="line-removed">1366             callback(WTFMove(*error), { });</span>
<span class="line-removed">1367             return;</span>
<span class="line-removed">1368         }</span>
<span class="line-removed">1369         this-&gt;getAllRecordsAfterQuotaCheck(requestData, getAllRecordsData, WTFMove(callback));</span>
<span class="line-removed">1370     });</span>
<span class="line-removed">1371 }</span>
<span class="line-removed">1372 </span>
<span class="line-removed">1373 void UniqueIDBDatabase::getAllRecordsAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)</span>
<span class="line-removed">1374 {</span>
<span class="line-removed">1375     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">1376     if (!callbackID)</span>
<span class="line-removed">1377         return;</span>
<span class="line-removed">1378 </span>
<span class="line-removed">1379     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetAllRecords, callbackID, requestData.transactionIdentifier(), getAllRecordsData));</span>
<span class="line-removed">1380 }</span>
<span class="line-removed">1381 </span>
<span class="line-removed">1382 void UniqueIDBDatabase::performGetRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; keyRangeData, IDBGetRecordDataType type)</span>
1383 {
1384     ASSERT(!isMainThread());
<a name="114" id="anc114"></a><span class="line-modified">1385     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetRecord&quot;);</span>
<span class="line-removed">1386 </span>
<span class="line-removed">1387     ASSERT(m_backingStore);</span>
1388 
1389     IDBGetResult result;
<a name="115" id="anc115"></a><span class="line-modified">1390     IDBError error = m_backingStore-&gt;getRecord(transactionIdentifier, objectStoreIdentifier, keyRangeData, type, result);</span>
<span class="line-removed">1391 </span>
<span class="line-removed">1392     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetRecord, callbackIdentifier, error, result));</span>
<span class="line-removed">1393 }</span>
<span class="line-removed">1394 </span>
<span class="line-removed">1395 void UniqueIDBDatabase::performGetIndexRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, IndexedDB::IndexRecordType recordType, const IDBKeyRangeData&amp; range)</span>
<span class="line-removed">1396 {</span>
<span class="line-removed">1397     ASSERT(!isMainThread());</span>
<span class="line-removed">1398     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetIndexRecord&quot;);</span>
1399 
1400     ASSERT(m_backingStore);
<a name="116" id="anc116"></a>



1401 
<a name="117" id="anc117"></a><span class="line-modified">1402     IDBGetResult result;</span>
<span class="line-removed">1403     IDBError error = m_backingStore-&gt;getIndexRecord(transactionIdentifier, objectStoreIdentifier, indexIdentifier, recordType, range, result);</span>
<span class="line-removed">1404 </span>
<span class="line-removed">1405     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetRecord, callbackIdentifier, error, result));</span>
<span class="line-removed">1406 }</span>
<span class="line-removed">1407 </span>
<span class="line-removed">1408 void UniqueIDBDatabase::didPerformGetRecord(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)</span>
<span class="line-removed">1409 {</span>
<span class="line-removed">1410     ASSERT(isMainThread());</span>
<span class="line-removed">1411     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetRecord&quot;);</span>
<span class="line-removed">1412 </span>
<span class="line-removed">1413     performGetResultCallback(callbackIdentifier, error, result);</span>
1414 }
1415 
<a name="118" id="anc118"></a><span class="line-modified">1416 void UniqueIDBDatabase::performGetAllRecords(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData)</span>
1417 {
1418     ASSERT(!isMainThread());
<a name="119" id="anc119"></a><span class="line-modified">1419     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetAllRecords&quot;);</span>
1420 
1421     ASSERT(m_backingStore);
<a name="120" id="anc120"></a><span class="line-removed">1422 </span>
1423     IDBGetAllResult result;
<a name="121" id="anc121"></a><span class="line-modified">1424     IDBError error = m_backingStore-&gt;getAllRecords(transactionIdentifier, getAllRecordsData, result);</span>
<span class="line-removed">1425 </span>
<span class="line-removed">1426     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetAllRecords, callbackIdentifier, error, WTFMove(result)));</span>
<span class="line-removed">1427 }</span>
<span class="line-removed">1428 </span>
<span class="line-removed">1429 void UniqueIDBDatabase::didPerformGetAllRecords(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetAllResult&amp; result)</span>
<span class="line-removed">1430 {</span>
<span class="line-removed">1431     ASSERT(isMainThread());</span>
<span class="line-removed">1432     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetAllRecords&quot;);</span>
<span class="line-removed">1433 </span>
<span class="line-removed">1434     performGetAllResultsCallback(callbackIdentifier, error, result);</span>
<span class="line-removed">1435 }</span>
<span class="line-removed">1436 </span>
<span class="line-removed">1437 void UniqueIDBDatabase::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)</span>
<span class="line-removed">1438 {</span>
<span class="line-removed">1439     ASSERT(isMainThread());</span>
<span class="line-removed">1440     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getCount&quot;);</span>
<span class="line-removed">1441 </span>
<span class="line-removed">1442     waitForRequestSpaceCompletion([this, requestData, range, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">1443         if (error) {</span>
<span class="line-removed">1444             callback(WTFMove(*error), { });</span>
<span class="line-removed">1445             return;</span>
<span class="line-removed">1446         }</span>
<span class="line-removed">1447         this-&gt;getCountAfterQuotaCheck(requestData, range, WTFMove(callback));</span>
<span class="line-removed">1448     });</span>
<span class="line-removed">1449 }</span>
<span class="line-removed">1450 </span>
<span class="line-removed">1451 void UniqueIDBDatabase::getCountAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)</span>
<span class="line-removed">1452 {</span>
<span class="line-removed">1453     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">1454     if (!callbackID)</span>
<span class="line-removed">1455         return;</span>
<span class="line-removed">1456     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetCount, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), requestData.indexIdentifier(), range));</span>
<span class="line-removed">1457 }</span>
<span class="line-removed">1458 </span>
<span class="line-removed">1459 void UniqueIDBDatabase::performGetCount(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; keyRangeData)</span>
<span class="line-removed">1460 {</span>
<span class="line-removed">1461     ASSERT(!isMainThread());</span>
<span class="line-removed">1462     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetCount&quot;);</span>
<span class="line-removed">1463 </span>
<span class="line-removed">1464     ASSERT(m_backingStore);</span>
<span class="line-removed">1465     ASSERT(objectStoreIdentifier);</span>
<span class="line-removed">1466 </span>
<span class="line-removed">1467     uint64_t count;</span>
<span class="line-removed">1468     IDBError error = m_backingStore-&gt;getCount(transactionIdentifier, objectStoreIdentifier, indexIdentifier, keyRangeData, count);</span>
<span class="line-removed">1469 </span>
<span class="line-removed">1470     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetCount, callbackIdentifier, error, count));</span>
<span class="line-removed">1471 }</span>
<span class="line-removed">1472 </span>
<span class="line-removed">1473 void UniqueIDBDatabase::didPerformGetCount(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)</span>
<span class="line-removed">1474 {</span>
<span class="line-removed">1475     ASSERT(isMainThread());</span>
<span class="line-removed">1476     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetCount&quot;);</span>
<span class="line-removed">1477 </span>
<span class="line-removed">1478     performCountCallback(callbackIdentifier, error, count);</span>
<span class="line-removed">1479 }</span>
1480 
<a name="122" id="anc122"></a><span class="line-modified">1481 void UniqueIDBDatabase::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)</span>
<span class="line-removed">1482 {</span>
<span class="line-removed">1483     ASSERT(isMainThread());</span>
<span class="line-removed">1484     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteRecord&quot;);</span>
<span class="line-removed">1485 </span>
<span class="line-removed">1486     waitForRequestSpaceCompletion([this, requestData, keyRangeData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">1487         if (error) {</span>
<span class="line-removed">1488             callback(WTFMove(*error));</span>
<span class="line-removed">1489             return;</span>
<span class="line-removed">1490         }</span>
<span class="line-removed">1491         this-&gt;deleteRecordAfterQuotaCheck(requestData, keyRangeData, WTFMove(callback));</span>
<span class="line-removed">1492     });</span>
<span class="line-removed">1493 }</span>
<span class="line-removed">1494 </span>
<span class="line-removed">1495 void UniqueIDBDatabase::deleteRecordAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)</span>
<span class="line-removed">1496 {</span>
<span class="line-removed">1497     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">1498     if (!callbackID)</span>
<span class="line-removed">1499         return;</span>
<span class="line-removed">1500     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyRangeData));</span>
<span class="line-removed">1501 }</span>
<span class="line-removed">1502 </span>
<span class="line-removed">1503 void UniqueIDBDatabase::performDeleteRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; range)</span>
<span class="line-removed">1504 {</span>
<span class="line-removed">1505     ASSERT(!isMainThread());</span>
<span class="line-removed">1506     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteRecord&quot;);</span>
<span class="line-removed">1507 </span>
<span class="line-removed">1508     IDBError error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, range);</span>
<span class="line-removed">1509 </span>
<span class="line-removed">1510     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteRecord, callbackIdentifier, error));</span>
<span class="line-removed">1511 }</span>
<span class="line-removed">1512 </span>
<span class="line-removed">1513 void UniqueIDBDatabase::didPerformDeleteRecord(uint64_t callbackIdentifier, const IDBError&amp; error)</span>
<span class="line-removed">1514 {</span>
<span class="line-removed">1515     ASSERT(isMainThread());</span>
<span class="line-removed">1516     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteRecord&quot;);</span>
<span class="line-removed">1517 </span>
<span class="line-removed">1518     performErrorCallback(callbackIdentifier, error);</span>
<span class="line-removed">1519 }</span>
<span class="line-removed">1520 </span>
<span class="line-removed">1521 void UniqueIDBDatabase::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)</span>
<span class="line-removed">1522 {</span>
<span class="line-removed">1523     ASSERT(isMainThread());</span>
<span class="line-removed">1524     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::openCursor&quot;);</span>
<span class="line-removed">1525 </span>
<span class="line-removed">1526     waitForRequestSpaceCompletion([this, requestData, info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">1527         if (error) {</span>
<span class="line-removed">1528             callback(WTFMove(*error), { });</span>
<span class="line-removed">1529             return;</span>
<span class="line-removed">1530         }</span>
<span class="line-removed">1531         this-&gt;openCursorAfterQuotaCheck(requestData, info, WTFMove(callback));</span>
<span class="line-removed">1532     });</span>
<span class="line-removed">1533 }</span>
<span class="line-removed">1534 </span>
<span class="line-removed">1535 void UniqueIDBDatabase::openCursorAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)</span>
<span class="line-removed">1536 {</span>
<span class="line-removed">1537     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">1538     if (!callbackID)</span>
<span class="line-removed">1539         return;</span>
<span class="line-removed">1540     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performOpenCursor, callbackID, requestData.transactionIdentifier(), info));</span>
<span class="line-removed">1541 }</span>
<span class="line-removed">1542 </span>
<span class="line-removed">1543 void UniqueIDBDatabase::performOpenCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info)</span>
<span class="line-removed">1544 {</span>
<span class="line-removed">1545     ASSERT(!isMainThread());</span>
<span class="line-removed">1546     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performOpenCursor&quot;);</span>
<span class="line-removed">1547 </span>
<span class="line-removed">1548     IDBGetResult result;</span>
<span class="line-removed">1549     IDBError error = m_backingStore-&gt;openCursor(transactionIdentifier, info, result);</span>
<span class="line-removed">1550 </span>
<span class="line-removed">1551     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformOpenCursor, callbackIdentifier, error, result));</span>
<span class="line-removed">1552 }</span>
<span class="line-removed">1553 </span>
<span class="line-removed">1554 void UniqueIDBDatabase::didPerformOpenCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)</span>
<span class="line-removed">1555 {</span>
<span class="line-removed">1556     ASSERT(isMainThread());</span>
<span class="line-removed">1557     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformOpenCursor&quot;);</span>
<span class="line-removed">1558 </span>
<span class="line-removed">1559     performGetResultCallback(callbackIdentifier, error, result);</span>
<span class="line-removed">1560 }</span>
<span class="line-removed">1561 </span>
<span class="line-removed">1562 void UniqueIDBDatabase::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)</span>
<span class="line-removed">1563 {</span>
<span class="line-removed">1564     ASSERT(isMainThread());</span>
<span class="line-removed">1565     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::iterateCursor&quot;);</span>
<span class="line-removed">1566 </span>
<span class="line-removed">1567     waitForRequestSpaceCompletion([this, requestData, data, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">1568         if (error) {</span>
<span class="line-removed">1569             callback(WTFMove(*error), { });</span>
<span class="line-removed">1570             return;</span>
<span class="line-removed">1571         }</span>
<span class="line-removed">1572         this-&gt;iterateCursorAfterQuotaCheck(requestData, data, WTFMove(callback));</span>
<span class="line-removed">1573     });</span>
<span class="line-removed">1574 }</span>
<span class="line-removed">1575 </span>
<span class="line-removed">1576 void UniqueIDBDatabase::iterateCursorAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)</span>
<span class="line-removed">1577 {</span>
<span class="line-removed">1578     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">1579     if (!callbackID)</span>
<span class="line-removed">1580         return;</span>
<span class="line-removed">1581     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performIterateCursor, callbackID, requestData.transactionIdentifier(), requestData.cursorIdentifier(), data));</span>
<span class="line-removed">1582 }</span>
<span class="line-removed">1583 </span>
<span class="line-removed">1584 void UniqueIDBDatabase::performIterateCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data)</span>
<span class="line-removed">1585 {</span>
<span class="line-removed">1586     ASSERT(!isMainThread());</span>
<span class="line-removed">1587     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performIterateCursor&quot;);</span>
<span class="line-removed">1588 </span>
<span class="line-removed">1589     IDBGetResult result;</span>
<span class="line-removed">1590     IDBError error = m_backingStore-&gt;iterateCursor(transactionIdentifier, cursorIdentifier, data, result);</span>
<span class="line-removed">1591 </span>
<span class="line-removed">1592     if (error.isNull()) {</span>
<span class="line-removed">1593         auto addResult = m_cursorPrefetches.add(cursorIdentifier);</span>
<span class="line-removed">1594         if (addResult.isNewEntry)</span>
<span class="line-removed">1595             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));</span>
<span class="line-removed">1596     }</span>
<span class="line-removed">1597 </span>
<span class="line-removed">1598     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformIterateCursor, callbackIdentifier, error, result));</span>
<span class="line-removed">1599 }</span>
<span class="line-removed">1600 </span>
<span class="line-removed">1601 void UniqueIDBDatabase::performPrefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)</span>
<span class="line-removed">1602 {</span>
<span class="line-removed">1603     ASSERT(!isMainThread());</span>
<span class="line-removed">1604     ASSERT(m_cursorPrefetches.contains(cursorIdentifier));</span>
<span class="line-removed">1605     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPrefetchCursor&quot;);</span>
<span class="line-removed">1606 </span>
<span class="line-removed">1607     if (m_hardClosedForUserDelete || !m_backingStore-&gt;prefetchCursor(transactionIdentifier, cursorIdentifier))</span>
<span class="line-removed">1608         m_cursorPrefetches.remove(cursorIdentifier);</span>
<span class="line-removed">1609     else</span>
<span class="line-removed">1610         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));</span>
<span class="line-removed">1611 }</span>
<span class="line-removed">1612 </span>
<span class="line-removed">1613 void UniqueIDBDatabase::didPerformIterateCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)</span>
<span class="line-removed">1614 {</span>
<span class="line-removed">1615     ASSERT(isMainThread());</span>
<span class="line-removed">1616     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformIterateCursor&quot;);</span>
<span class="line-removed">1617 </span>
<span class="line-removed">1618     performGetResultCallback(callbackIdentifier, error, result);</span>
<span class="line-removed">1619 }</span>
<span class="line-removed">1620 </span>
<span class="line-removed">1621 bool UniqueIDBDatabase::prepareToFinishTransaction(UniqueIDBDatabaseTransaction&amp; transaction, UniqueIDBDatabaseTransaction::State state)</span>
<span class="line-removed">1622 {</span>
<span class="line-removed">1623     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());</span>
<span class="line-removed">1624     if (!takenTransaction)</span>
<span class="line-removed">1625         return false;</span>
<span class="line-removed">1626 </span>
<span class="line-removed">1627     ASSERT(!m_finishingTransactions.contains(transaction.info().identifier()));</span>
<span class="line-removed">1628     takenTransaction-&gt;setState(state);</span>
<span class="line-removed">1629     m_finishingTransactions.set(transaction.info().identifier(), WTFMove(takenTransaction));</span>
<span class="line-removed">1630 </span>
<span class="line-removed">1631     return true;</span>
<span class="line-removed">1632 }</span>
<span class="line-removed">1633 </span>
<span class="line-removed">1634 void UniqueIDBDatabase::commitTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
<span class="line-removed">1635 {</span>
<span class="line-removed">1636     ASSERT(isMainThread());</span>
<span class="line-removed">1637     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::commitTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());</span>
<span class="line-removed">1638 </span>
<span class="line-removed">1639     ASSERT(transaction.databaseConnection().database() == this);</span>
<span class="line-removed">1640 </span>
<span class="line-removed">1641     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">1642         if (error) {</span>
<span class="line-removed">1643             callback(WTFMove(*error));</span>
<span class="line-removed">1644             return;</span>
<span class="line-removed">1645         }</span>
<span class="line-removed">1646         if (!transaction) {</span>
<span class="line-removed">1647             callback(IDBError { UnknownError });</span>
<span class="line-removed">1648             return;</span>
<span class="line-removed">1649         }</span>
<span class="line-removed">1650         this-&gt;commitTransactionAfterQuotaCheck(*transaction, WTFMove(callback));</span>
<span class="line-removed">1651     });</span>
1652 }
1653 
<a name="123" id="anc123"></a><span class="line-modified">1654 void UniqueIDBDatabase::commitTransactionAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
1655 {
<a name="124" id="anc124"></a><span class="line-modified">1656     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-modified">1657     if (!callbackID)</span>
<span class="line-removed">1658         return;</span>
<span class="line-removed">1659 </span>
<span class="line-removed">1660     if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Committing)) {</span>
<span class="line-removed">1661         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {</span>
<span class="line-removed">1662             // This database connection is closing or has already closed, so there is no point in messaging back to it about the commit failing.</span>
<span class="line-removed">1663             forgetErrorCallback(callbackID);</span>
<span class="line-removed">1664             return;</span>
<span class="line-removed">1665         }</span>
1666 
<a name="125" id="anc125"></a><span class="line-modified">1667         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to commit transaction that is already finishing&quot;_s });</span>
<span class="line-modified">1668         return;</span>
<span class="line-modified">1669     }</span>
1670 
<a name="126" id="anc126"></a><span class="line-modified">1671     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCommitTransaction, callbackID, transaction.info().identifier()));</span>
1672 }
1673 
<a name="127" id="anc127"></a><span class="line-modified">1674 void UniqueIDBDatabase::performCommitTransaction(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)</span>
1675 {
1676     ASSERT(!isMainThread());
<a name="128" id="anc128"></a><span class="line-modified">1677     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());</span>



1678 
<a name="129" id="anc129"></a><span class="line-modified">1679     IDBError error = m_backingStore-&gt;commitTransaction(transactionIdentifier);</span>
<span class="line-removed">1680     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCommitTransaction, callbackIdentifier, error, transactionIdentifier));</span>
1681 }
1682 
<a name="130" id="anc130"></a><span class="line-modified">1683 void UniqueIDBDatabase::didPerformCommitTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)</span>
1684 {
<a name="131" id="anc131"></a><span class="line-modified">1685     ASSERT(isMainThread());</span>
<span class="line-modified">1686     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());</span>
1687 
<a name="132" id="anc132"></a><span class="line-modified">1688     IDBError result = error;</span>
<span class="line-removed">1689     auto transaction = m_finishingTransactions.get(transactionIdentifier);</span>
<span class="line-removed">1690     switch (transaction-&gt;state()) {</span>
<span class="line-removed">1691     case UniqueIDBDatabaseTransaction::State::Aborted:</span>
<span class="line-removed">1692         result = IDBError { UnknownError, &quot;Transaction is already aborted&quot;_s };</span>
<span class="line-removed">1693         break;</span>
<span class="line-removed">1694     case UniqueIDBDatabaseTransaction::State::Committed:</span>
<span class="line-removed">1695         result = transaction-&gt;result();</span>
<span class="line-removed">1696         break;</span>
<span class="line-removed">1697     case UniqueIDBDatabaseTransaction::State::Committing:</span>
<span class="line-removed">1698         break;</span>
<span class="line-removed">1699     case UniqueIDBDatabaseTransaction::State::Running:</span>
<span class="line-removed">1700     case UniqueIDBDatabaseTransaction::State::Aborting:</span>
<span class="line-removed">1701         ASSERT_NOT_REACHED();</span>
<span class="line-removed">1702     }</span>
1703 
<a name="133" id="anc133"></a><span class="line-modified">1704     performErrorCallback(callbackIdentifier, result);</span>

1705 
<a name="134" id="anc134"></a><span class="line-modified">1706     transactionCompleted(m_finishingTransactions.take(transactionIdentifier));</span>
1707 }
1708 
<a name="135" id="anc135"></a><span class="line-modified">1709 void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction&amp; transaction, WaitForPendingTasks waitForPendingTasks, ErrorCallback callback)</span>
1710 {
<a name="136" id="anc136"></a><span class="line-modified">1711     ASSERT(isMainThread());</span>
<span class="line-modified">1712     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::abortTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());</span>
<span class="line-removed">1713 </span>
<span class="line-removed">1714     ASSERT(transaction.databaseConnection().database() == this);</span>
<span class="line-removed">1715 </span>
<span class="line-removed">1716     if (waitForPendingTasks == WaitForPendingTasks::Yes) {</span>
<span class="line-removed">1717         waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto&amp;&amp; error) mutable {</span>
<span class="line-removed">1718             if (error) {</span>
<span class="line-removed">1719                 callback(WTFMove(*error));</span>
<span class="line-removed">1720                 return;</span>
<span class="line-removed">1721             }</span>
<span class="line-removed">1722             if (!transaction) {</span>
<span class="line-removed">1723                 callback(IDBError { UnknownError });</span>
<span class="line-removed">1724                 return;</span>
<span class="line-removed">1725             }</span>
<span class="line-removed">1726             this-&gt;abortTransaction(*transaction, WaitForPendingTasks::No, WTFMove(callback));</span>
<span class="line-removed">1727         });</span>
<span class="line-removed">1728         return;</span>
<span class="line-removed">1729     }</span>
<span class="line-removed">1730 </span>
<span class="line-removed">1731     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">1732     if (!callbackID)</span>
<span class="line-removed">1733         return;</span>
1734 
<a name="137" id="anc137"></a><span class="line-modified">1735     if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Aborting)) {</span>
<span class="line-removed">1736         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {</span>
<span class="line-removed">1737             // This database connection is closing or has already closed, so there is no point in messaging back to it about the abort failing.</span>
<span class="line-removed">1738             forgetErrorCallback(callbackID);</span>
<span class="line-removed">1739             return;</span>
<span class="line-removed">1740         }</span>
1741 
<a name="138" id="anc138"></a><span class="line-modified">1742         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to abort transaction that is already finishing&quot;_s });</span>
<span class="line-modified">1743         return;</span>
<span class="line-modified">1744     }</span>

1745 
<a name="139" id="anc139"></a><span class="line-modified">1746     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performAbortTransaction, callbackID, transaction.info().identifier()));</span>
1747 }
1748 
<a name="140" id="anc140"></a><span class="line-modified">1749 void UniqueIDBDatabase::didFinishHandlingVersionChange(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; transactionIdentifier)</span>
1750 {
<a name="141" id="anc141"></a><span class="line-modified">1751     ASSERT(isMainThread());</span>
<span class="line-modified">1752     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didFinishHandlingVersionChange&quot;);</span>
<span class="line-removed">1753 </span>
<span class="line-removed">1754     ASSERT_UNUSED(transactionIdentifier, !m_versionChangeTransaction || m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier);</span>
<span class="line-removed">1755     ASSERT_UNUSED(connection, !m_versionChangeDatabaseConnection || m_versionChangeDatabaseConnection.get() == &amp;connection);</span>
1756 
<a name="142" id="anc142"></a><span class="line-modified">1757     m_versionChangeTransaction = nullptr;</span>
<span class="line-modified">1758     m_versionChangeDatabaseConnection = nullptr;</span>




1759 
<a name="143" id="anc143"></a><span class="line-modified">1760     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed">1761         maybeFinishHardClose();</span>
1762         return;
1763     }
1764 
<a name="144" id="anc144"></a><span class="line-modified">1765     invokeOperationAndTransactionTimer();</span>



1766 }
1767 
<a name="145" id="anc145"></a><span class="line-modified">1768 void UniqueIDBDatabase::performAbortTransaction(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)</span>
1769 {
1770     ASSERT(!isMainThread());
<a name="146" id="anc146"></a><span class="line-modified">1771     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());</span>
1772 
<a name="147" id="anc147"></a><span class="line-modified">1773     IDBError error = m_backingStore-&gt;abortTransaction(transactionIdentifier);</span>
<span class="line-removed">1774     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformAbortTransaction, callbackIdentifier, error, transactionIdentifier));</span>
<span class="line-removed">1775 }</span>
1776 
<a name="148" id="anc148"></a><span class="line-modified">1777 void UniqueIDBDatabase::didPerformAbortTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)</span>
<span class="line-modified">1778 {</span>
<span class="line-modified">1779     ASSERT(isMainThread());</span>
<span class="line-modified">1780     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());</span>
1781 
<a name="149" id="anc149"></a><span class="line-modified">1782     auto transaction = m_finishingTransactions.take(transactionIdentifier);</span>
<span class="line-modified">1783     ASSERT(transaction);</span>









1784 
<a name="150" id="anc150"></a>
1785     if (m_versionChangeTransaction &amp;&amp; m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier) {
<a name="151" id="anc151"></a><span class="line-modified">1786         ASSERT(m_versionChangeTransaction == transaction);</span>
1787         ASSERT(!m_versionChangeDatabaseConnection || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
1788         ASSERT(m_versionChangeTransaction-&gt;originalDatabaseInfo());
1789         m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(*m_versionChangeTransaction-&gt;originalDatabaseInfo());
1790     }
1791 
<a name="152" id="anc152"></a><span class="line-modified">1792     IDBError result = transaction-&gt;state() == UniqueIDBDatabaseTransaction::State::Aborted ? transaction-&gt;result() : error;</span>
<span class="line-removed">1793     performErrorCallback(callbackIdentifier, result);</span>
1794 
<a name="153" id="anc153"></a><span class="line-modified">1795     transactionCompleted(WTFMove(transaction));</span>

1796 }
1797 
<a name="154" id="anc154"></a><span class="line-modified">1798 void UniqueIDBDatabase::transactionDestroyed(UniqueIDBDatabaseTransaction&amp; transaction)</span>
1799 {
<a name="155" id="anc155"></a><span class="line-modified">1800     if (m_versionChangeTransaction == &amp;transaction)</span>
<span class="line-modified">1801         m_versionChangeTransaction = nullptr;</span>









1802 }
1803 
1804 void UniqueIDBDatabase::connectionClosedFromClient(UniqueIDBDatabaseConnection&amp; connection)
1805 {
<a name="156" id="anc156"></a><span class="line-modified">1806     ASSERT(isMainThread());</span>
<span class="line-modified">1807     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::connectionClosedFromClient - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());</span>
<span class="line-removed">1808 </span>
<span class="line-removed">1809     if (m_serverClosePendingDatabaseConnections.contains(&amp;connection)) {</span>
<span class="line-removed">1810         m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
<span class="line-removed">1811         if (m_hardClosedForUserDelete)</span>
<span class="line-removed">1812             maybeFinishHardClose();</span>
<span class="line-removed">1813         return;</span>
<span class="line-removed">1814     }</span>
1815 
1816     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
1817     m_openDatabaseConnections.remove(&amp;connection);
1818 
1819     if (m_versionChangeDatabaseConnection == &amp;connection) {
<a name="157" id="anc157"></a>
1820         if (m_versionChangeTransaction) {
<a name="158" id="anc158"></a><span class="line-modified">1821             m_clientClosePendingDatabaseConnections.add(WTFMove(m_versionChangeDatabaseConnection));</span>

1822 
<a name="159" id="anc159"></a><span class="line-modified">1823             auto transactionIdentifier = m_versionChangeTransaction-&gt;info().identifier();</span>
<span class="line-modified">1824             if (m_inProgressTransactions.contains(transactionIdentifier)) {</span>
<span class="line-modified">1825                 ASSERT(!m_finishingTransactions.contains(transactionIdentifier));</span>
<span class="line-removed">1826                 connection.abortTransactionWithoutCallback(*m_versionChangeTransaction);</span>
<span class="line-removed">1827             }</span>
1828 
1829             return;
1830         }
<a name="160" id="anc160"></a><span class="line-removed">1831 </span>
<span class="line-removed">1832         m_versionChangeDatabaseConnection = nullptr;</span>
<span class="line-removed">1833     }</span>
<span class="line-removed">1834 </span>
<span class="line-removed">1835     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; pendingTransactions;</span>
<span class="line-removed">1836     while (!m_pendingTransactions.isEmpty()) {</span>
<span class="line-removed">1837         auto transaction = m_pendingTransactions.takeFirst();</span>
<span class="line-removed">1838         if (&amp;transaction-&gt;databaseConnection() != &amp;connection)</span>
<span class="line-removed">1839             pendingTransactions.append(WTFMove(transaction));</span>
<span class="line-removed">1840     }</span>
<span class="line-removed">1841 </span>
<span class="line-removed">1842     if (!pendingTransactions.isEmpty())</span>
<span class="line-removed">1843         m_pendingTransactions.swap(pendingTransactions);</span>
<span class="line-removed">1844 </span>
<span class="line-removed">1845     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; transactionsToAbort;</span>
<span class="line-removed">1846     for (auto&amp; transaction : m_inProgressTransactions.values()) {</span>
<span class="line-removed">1847         if (&amp;transaction-&gt;databaseConnection() == &amp;connection)</span>
<span class="line-removed">1848             transactionsToAbort.append(transaction);</span>
1849     }
1850 
<a name="161" id="anc161"></a><span class="line-modified">1851     for (auto&amp; transaction : transactionsToAbort)</span>
<span class="line-modified">1852         transaction-&gt;abortWithoutCallback();</span>
1853 
1854     if (m_currentOpenDBRequest)
1855         notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
1856 
<a name="162" id="anc162"></a><span class="line-modified">1857     if (connection.hasNonFinishedTransactions()) {</span>
<span class="line-removed">1858         m_clientClosePendingDatabaseConnections.add(WTFMove(protectedConnection));</span>
<span class="line-removed">1859         return;</span>
<span class="line-removed">1860     }</span>
<span class="line-removed">1861 </span>
<span class="line-removed">1862     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed">1863         maybeFinishHardClose();</span>
<span class="line-removed">1864         return;</span>
<span class="line-removed">1865     }</span>
1866 
1867     // Now that a database connection has closed, previously blocked operations might be runnable.
<a name="163" id="anc163"></a><span class="line-modified">1868     invokeOperationAndTransactionTimer();</span>

1869 }
1870 
1871 void UniqueIDBDatabase::connectionClosedFromServer(UniqueIDBDatabaseConnection&amp; connection)
1872 {
<a name="164" id="anc164"></a><span class="line-modified">1873     ASSERT(isMainThread());</span>
1874     LOG(IndexedDB, &quot;UniqueIDBDatabase::connectionClosedFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1875 
<a name="165" id="anc165"></a><span class="line-removed">1876     if (m_clientClosePendingDatabaseConnections.contains(&amp;connection)) {</span>
<span class="line-removed">1877         ASSERT(!m_openDatabaseConnections.contains(&amp;connection));</span>
<span class="line-removed">1878         ASSERT(!m_serverClosePendingDatabaseConnections.contains(&amp;connection));</span>
<span class="line-removed">1879         return;</span>
<span class="line-removed">1880     }</span>
<span class="line-removed">1881 </span>
<span class="line-removed">1882     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);</span>
<span class="line-removed">1883     m_openDatabaseConnections.remove(&amp;connection);</span>
<span class="line-removed">1884 </span>
1885     connection.connectionToClient().didCloseFromServer(connection, IDBError::userDeleteError());
1886 
<a name="166" id="anc166"></a><span class="line-modified">1887     m_serverClosePendingDatabaseConnections.add(WTFMove(protectedConnection));</span>
<span class="line-removed">1888 }</span>
<span class="line-removed">1889 </span>
<span class="line-removed">1890 void UniqueIDBDatabase::confirmDidCloseFromServer(UniqueIDBDatabaseConnection&amp; connection)</span>
<span class="line-removed">1891 {</span>
<span class="line-removed">1892     ASSERT(isMainThread());</span>
<span class="line-removed">1893     LOG(IndexedDB, &quot;UniqueIDBDatabase::confirmDidCloseFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());</span>
<span class="line-removed">1894 </span>
<span class="line-removed">1895     if (!m_serverClosePendingDatabaseConnections.contains(&amp;connection))</span>
<span class="line-removed">1896         return;</span>
<span class="line-removed">1897     m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
<span class="line-removed">1898 </span>
<span class="line-removed">1899     if (m_hardClosedForUserDelete)</span>
<span class="line-removed">1900         maybeFinishHardClose();</span>
1901 }
1902 
1903 void UniqueIDBDatabase::enqueueTransaction(Ref&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
1904 {
1905     LOG(IndexedDB, &quot;UniqueIDBDatabase::enqueueTransaction - %s&quot;, transaction-&gt;info().loggingString().utf8().data());
<a name="167" id="anc167"></a><span class="line-removed">1906     ASSERT(!m_hardClosedForUserDelete);</span>
1907 
1908     ASSERT(transaction-&gt;info().mode() != IDBTransactionMode::Versionchange);
1909 
1910     m_pendingTransactions.append(WTFMove(transaction));
1911 
<a name="168" id="anc168"></a><span class="line-modified">1912     invokeOperationAndTransactionTimer();</span>
<span class="line-removed">1913 }</span>
<span class="line-removed">1914 </span>
<span class="line-removed">1915 bool UniqueIDBDatabase::isCurrentlyInUse() const</span>
<span class="line-removed">1916 {</span>
<span class="line-removed">1917     return !m_openDatabaseConnections.isEmpty() || !m_clientClosePendingDatabaseConnections.isEmpty() || !m_pendingOpenDBRequests.isEmpty() || m_currentOpenDBRequest || m_versionChangeDatabaseConnection || m_versionChangeTransaction || m_isOpeningBackingStore || m_deleteBackingStoreInProgress;</span>
<span class="line-removed">1918 }</span>
<span class="line-removed">1919 </span>
<span class="line-removed">1920 bool UniqueIDBDatabase::hasUnfinishedTransactions() const</span>
<span class="line-removed">1921 {</span>
<span class="line-removed">1922     return !m_inProgressTransactions.isEmpty() || !m_finishingTransactions.isEmpty();</span>
<span class="line-removed">1923 }</span>
<span class="line-removed">1924 </span>
<span class="line-removed">1925 void UniqueIDBDatabase::invokeOperationAndTransactionTimer()</span>
<span class="line-removed">1926 {</span>
<span class="line-removed">1927     LOG(IndexedDB, &quot;UniqueIDBDatabase::invokeOperationAndTransactionTimer()&quot;);</span>
<span class="line-removed">1928     RELEASE_ASSERT(!m_hardClosedForUserDelete);</span>
<span class="line-removed">1929     RELEASE_ASSERT(!m_owningPointerForClose);</span>
<span class="line-removed">1930 </span>
<span class="line-removed">1931     if (!m_operationAndTransactionTimer.isActive())</span>
<span class="line-removed">1932         m_operationAndTransactionTimer.startOneShot(0_s);</span>
1933 }
1934 
<a name="169" id="anc169"></a><span class="line-modified">1935 void UniqueIDBDatabase::operationAndTransactionTimerFired()</span>
1936 {
<a name="170" id="anc170"></a><span class="line-modified">1937     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::operationAndTransactionTimerFired&quot;);</span>
<span class="line-removed">1938     ASSERT(!m_hardClosedForUserDelete);</span>
<span class="line-removed">1939     ASSERT(isMainThread());</span>
<span class="line-removed">1940 </span>
<span class="line-removed">1941     // This UniqueIDBDatabase might be no longer in use by any web page.</span>
<span class="line-removed">1942     // Assuming it is not ephemeral, the server should now close it to free up resources.</span>
<span class="line-removed">1943     if (!m_backingStoreIsEphemeral &amp;&amp; !isCurrentlyInUse()) {</span>
<span class="line-removed">1944         ASSERT(m_pendingTransactions.isEmpty());</span>
<span class="line-removed">1945         ASSERT(!hasUnfinishedTransactions());</span>
<span class="line-removed">1946 </span>
<span class="line-removed">1947         scheduleShutdownForClose();</span>
<span class="line-removed">1948         return;</span>
<span class="line-removed">1949     }</span>
<span class="line-removed">1950 </span>
<span class="line-removed">1951     // The current operation might require multiple attempts to handle, so try to</span>
<span class="line-removed">1952     // make further progress on it now.</span>
<span class="line-removed">1953     if (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())</span>
<span class="line-removed">1954         handleCurrentOperation();</span>
<span class="line-removed">1955     else</span>
<span class="line-removed">1956         handleDatabaseOperations();</span>
1957 
1958     bool hadDeferredTransactions = false;
1959     auto transaction = takeNextRunnableTransaction(hadDeferredTransactions);
1960 
<a name="171" id="anc171"></a><span class="line-modified">1961     if (transaction) {</span>
1962         m_inProgressTransactions.set(transaction-&gt;info().identifier(), transaction);
1963         for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
1964             m_objectStoreTransactionCounts.add(objectStore);
1965             if (!transaction-&gt;isReadOnly()) {
1966                 m_objectStoreWriteTransactions.add(objectStore);
<a name="172" id="anc172"></a><span class="line-modified">1967                 ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1 || m_hardClosedForUserDelete);</span>
1968             }
1969         }
1970 
1971         activateTransactionInBackingStore(*transaction);
<a name="173" id="anc173"></a><span class="line-modified">1972 </span>
<span class="line-modified">1973         // If no transactions were deferred, it&#39;s possible we can start another transaction right now.</span>
<span class="line-modified">1974         if (!hadDeferredTransactions)</span>
<span class="line-removed">1975             invokeOperationAndTransactionTimer();</span>
1976     }
<a name="174" id="anc174"></a>
1977 }
1978 
1979 void UniqueIDBDatabase::activateTransactionInBackingStore(UniqueIDBDatabaseTransaction&amp; transaction)
1980 {
<a name="175" id="anc175"></a><span class="line-modified">1981     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::activateTransactionInBackingStore&quot;);</span>
<span class="line-removed">1982     ASSERT(isMainThread());</span>
<span class="line-removed">1983 </span>
<span class="line-removed">1984     RefPtr&lt;UniqueIDBDatabaseTransaction&gt; refTransaction(&amp;transaction);</span>
<span class="line-removed">1985 </span>
<span class="line-removed">1986     ErrorCallback callback = [refTransaction](const IDBError&amp; error) {</span>
<span class="line-removed">1987         refTransaction-&gt;didActivateInBackingStore(error);</span>
<span class="line-removed">1988     };</span>
<span class="line-removed">1989 </span>
<span class="line-removed">1990     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">1991     if (!callbackID)</span>
<span class="line-removed">1992         return;</span>
<span class="line-removed">1993     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performActivateTransactionInBackingStore, callbackID, transaction.info()));</span>
<span class="line-removed">1994 }</span>
<span class="line-removed">1995 </span>
<span class="line-removed">1996 void UniqueIDBDatabase::performActivateTransactionInBackingStore(uint64_t callbackIdentifier, const IDBTransactionInfo&amp; info)</span>
<span class="line-removed">1997 {</span>
<span class="line-removed">1998     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performActivateTransactionInBackingStore&quot;);</span>
<span class="line-removed">1999 </span>
<span class="line-removed">2000     IDBError error = m_backingStore-&gt;beginTransaction(info);</span>
<span class="line-removed">2001     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformActivateTransactionInBackingStore, callbackIdentifier, error));</span>
<span class="line-removed">2002 }</span>
<span class="line-removed">2003 </span>
<span class="line-removed">2004 void UniqueIDBDatabase::didPerformActivateTransactionInBackingStore(uint64_t callbackIdentifier, const IDBError&amp; error)</span>
<span class="line-removed">2005 {</span>
<span class="line-removed">2006     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformActivateTransactionInBackingStore&quot;);</span>
2007 
<a name="176" id="anc176"></a><span class="line-modified">2008     if (m_hardClosedForUserDelete)</span>
<span class="line-removed">2009         return;</span>
2010 
<a name="177" id="anc177"></a><span class="line-modified">2011     invokeOperationAndTransactionTimer();</span>
2012 
<a name="178" id="anc178"></a><span class="line-modified">2013     performErrorCallback(callbackIdentifier, error);</span>
2014 }
2015 
2016 template&lt;typename T&gt; bool scopesOverlap(const T&amp; aScopes, const Vector&lt;uint64_t&gt;&amp; bScopes)
2017 {
2018     for (auto scope : bScopes) {
2019         if (aScopes.contains(scope))
2020             return true;
2021     }
2022 
2023     return false;
2024 }
2025 
2026 RefPtr&lt;UniqueIDBDatabaseTransaction&gt; UniqueIDBDatabase::takeNextRunnableTransaction(bool&amp; hadDeferredTransactions)
2027 {
2028     hadDeferredTransactions = false;
2029 
2030     if (m_pendingTransactions.isEmpty())
2031         return nullptr;
2032 
<a name="179" id="anc179"></a><span class="line-modified">2033     if (!m_backingStoreSupportsSimultaneousTransactions &amp;&amp; hasUnfinishedTransactions()) {</span>
2034         LOG(IndexedDB, &quot;UniqueIDBDatabase::takeNextRunnableTransaction - Backing store only supports 1 transaction, and we already have 1&quot;);
2035         return nullptr;
2036     }
2037 
2038     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; deferredTransactions;
2039     RefPtr&lt;UniqueIDBDatabaseTransaction&gt; currentTransaction;
2040 
2041     HashSet&lt;uint64_t&gt; deferredReadWriteScopes;
2042 
2043     while (!m_pendingTransactions.isEmpty()) {
2044         currentTransaction = m_pendingTransactions.takeFirst();
2045 
2046         switch (currentTransaction-&gt;info().mode()) {
2047         case IDBTransactionMode::Readonly: {
2048             bool hasOverlappingScopes = scopesOverlap(deferredReadWriteScopes, currentTransaction-&gt;objectStoreIdentifiers());
2049             hasOverlappingScopes |= scopesOverlap(m_objectStoreWriteTransactions, currentTransaction-&gt;objectStoreIdentifiers());
2050 
2051             if (hasOverlappingScopes)
2052                 deferredTransactions.append(WTFMove(currentTransaction));
2053 
2054             break;
2055         }
2056         case IDBTransactionMode::Readwrite: {
2057             bool hasOverlappingScopes = scopesOverlap(m_objectStoreTransactionCounts, currentTransaction-&gt;objectStoreIdentifiers());
2058             hasOverlappingScopes |= scopesOverlap(deferredReadWriteScopes, currentTransaction-&gt;objectStoreIdentifiers());
2059 
2060             if (hasOverlappingScopes) {
2061                 for (auto objectStore : currentTransaction-&gt;objectStoreIdentifiers())
2062                     deferredReadWriteScopes.add(objectStore);
2063                 deferredTransactions.append(WTFMove(currentTransaction));
2064             }
2065 
2066             break;
2067         }
2068         case IDBTransactionMode::Versionchange:
2069             // Version change transactions should never be scheduled in the traditional manner.
2070             RELEASE_ASSERT_NOT_REACHED();
2071         }
2072 
2073         // If we didn&#39;t defer the currentTransaction above, it can be run now.
2074         if (currentTransaction)
2075             break;
2076     }
2077 
2078     hadDeferredTransactions = !deferredTransactions.isEmpty();
2079     if (!hadDeferredTransactions)
2080         return currentTransaction;
2081 
2082     // Prepend the deferred transactions back on the beginning of the deque for future scheduling passes.
2083     while (!deferredTransactions.isEmpty())
2084         m_pendingTransactions.prepend(deferredTransactions.takeLast());
2085 
2086     return currentTransaction;
2087 }
2088 
2089 void UniqueIDBDatabase::transactionCompleted(RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
2090 {
2091     ASSERT(transaction);
2092     ASSERT(!m_inProgressTransactions.contains(transaction-&gt;info().identifier()));
<a name="180" id="anc180"></a><span class="line-modified">2093     ASSERT(!m_finishingTransactions.contains(transaction-&gt;info().identifier()));</span>
<span class="line-removed">2094     ASSERT(isMainThread());</span>
2095 
2096     for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
2097         if (!transaction-&gt;isReadOnly()) {
2098             m_objectStoreWriteTransactions.remove(objectStore);
<a name="181" id="anc181"></a><span class="line-modified">2099             ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1 || m_hardClosedForUserDelete);</span>
2100         }
2101         m_objectStoreTransactionCounts.remove(objectStore);
2102     }
2103 
<a name="182" id="anc182"></a><span class="line-removed">2104     if (!transaction-&gt;databaseConnection().hasNonFinishedTransactions())</span>
<span class="line-removed">2105         m_clientClosePendingDatabaseConnections.remove(&amp;transaction-&gt;databaseConnection());</span>
<span class="line-removed">2106 </span>
2107     if (m_versionChangeTransaction == transaction)
2108         m_versionChangeTransaction = nullptr;
2109 
<a name="183" id="anc183"></a><span class="line-removed">2110     // It&#39;s possible that this database had its backing store deleted but there were a few outstanding asynchronous operations.</span>
<span class="line-removed">2111     // If this transaction completing was the last of those operations, we can finally delete this UniqueIDBDatabase.</span>
<span class="line-removed">2112     if (m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_pendingOpenDBRequests.isEmpty() &amp;&amp; !m_databaseInfo) {</span>
<span class="line-removed">2113         scheduleShutdownForClose();</span>
<span class="line-removed">2114         return;</span>
<span class="line-removed">2115     }</span>
<span class="line-removed">2116 </span>
2117     // Previously blocked operations might be runnable.
<a name="184" id="anc184"></a><span class="line-modified">2118     if (!m_hardClosedForUserDelete)</span>
<span class="line-modified">2119         invokeOperationAndTransactionTimer();</span>
<span class="line-removed">2120     else</span>
<span class="line-removed">2121         maybeFinishHardClose();</span>
<span class="line-removed">2122 }</span>
<span class="line-removed">2123 </span>
<span class="line-removed">2124 void UniqueIDBDatabase::postDatabaseTask(CrossThreadTask&amp;&amp; task)</span>
<span class="line-removed">2125 {</span>
<span class="line-removed">2126     m_databaseQueue.append(WTFMove(task));</span>
<span class="line-removed">2127     m_server-&gt;postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTask));</span>
<span class="line-removed">2128 }</span>
<span class="line-removed">2129 </span>
<span class="line-removed">2130 void UniqueIDBDatabase::postDatabaseTaskReply(CrossThreadTask&amp;&amp; task)</span>
<span class="line-removed">2131 {</span>
<span class="line-removed">2132     if (m_backingStore)</span>
<span class="line-removed">2133         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-removed">2134 </span>
<span class="line-removed">2135     m_databaseReplyQueue.append(WTFMove(task));</span>
<span class="line-removed">2136     m_server-&gt;postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTaskReply));</span>
<span class="line-removed">2137 }</span>
<span class="line-removed">2138 </span>
<span class="line-removed">2139 void UniqueIDBDatabase::executeNextDatabaseTask()</span>
<span class="line-removed">2140 {</span>
<span class="line-removed">2141     ASSERT(!isMainThread());</span>
<span class="line-removed">2142     ASSERT(!m_databaseQueue.isKilled());</span>
<span class="line-removed">2143 </span>
<span class="line-removed">2144     auto task = m_databaseQueue.tryGetMessage();</span>
<span class="line-removed">2145     ASSERT(task);</span>
<span class="line-removed">2146 </span>
<span class="line-removed">2147     task-&gt;performTask();</span>
<span class="line-removed">2148 }</span>
<span class="line-removed">2149 </span>
<span class="line-removed">2150 void UniqueIDBDatabase::executeNextDatabaseTaskReply()</span>
<span class="line-removed">2151 {</span>
<span class="line-removed">2152     ASSERT(isMainThread());</span>
<span class="line-removed">2153     ASSERT(!m_databaseReplyQueue.isKilled());</span>
<span class="line-removed">2154 </span>
<span class="line-removed">2155     auto task = m_databaseReplyQueue.tryGetMessage();</span>
<span class="line-removed">2156     ASSERT(task);</span>
<span class="line-removed">2157 </span>
<span class="line-removed">2158     task-&gt;performTask();</span>
<span class="line-removed">2159 </span>
<span class="line-removed">2160     // If this database was force closed (e.g. for a user delete) and there are no more</span>
<span class="line-removed">2161     // cleanup tasks left, delete this.</span>
<span class="line-removed">2162     maybeFinishHardClose();</span>
<span class="line-removed">2163 }</span>
<span class="line-removed">2164 </span>
<span class="line-removed">2165 void UniqueIDBDatabase::maybeFinishHardClose()</span>
<span class="line-removed">2166 {</span>
<span class="line-removed">2167     if (m_owningPointerForClose &amp;&amp; isDoneWithHardClose()) {</span>
<span class="line-removed">2168         if (m_owningPointerReleaseScheduled)</span>
<span class="line-removed">2169             return;</span>
<span class="line-removed">2170         m_owningPointerReleaseScheduled = true;</span>
<span class="line-removed">2171 </span>
<span class="line-removed">2172         callOnMainThread([this] {</span>
<span class="line-removed">2173             ASSERT(isDoneWithHardClose());</span>
<span class="line-removed">2174             m_owningPointerForClose = nullptr;</span>
<span class="line-removed">2175         });</span>
<span class="line-removed">2176     }</span>
<span class="line-removed">2177 }</span>
<span class="line-removed">2178 </span>
<span class="line-removed">2179 bool UniqueIDBDatabase::isDoneWithHardClose()</span>
<span class="line-removed">2180 {</span>
<span class="line-removed">2181     return m_databaseReplyQueue.isKilled() &amp;&amp; m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_serverClosePendingDatabaseConnections.isEmpty();</span>
2182 }
2183 
2184 static void errorOpenDBRequestForUserDelete(ServerOpenDBRequest&amp; request)
2185 {
2186     auto result = IDBResultData::error(request.requestData().requestIdentifier(), IDBError::userDeleteError());
2187     if (request.isOpenRequest())
2188         request.connection().didOpenDatabase(result);
2189     else
2190         request.connection().didDeleteDatabase(result);
2191 }
2192 
2193 void UniqueIDBDatabase::immediateCloseForUserDelete()
2194 {
<a name="185" id="anc185"></a><span class="line-modified">2195     LOG(IndexedDB, &quot;UniqueIDBDatabase::immediateCloseForUserDelete - Cancelling (%i, %i, %i, %i) callbacks&quot;, m_errorCallbacks.size(), m_keyDataCallbacks.size(), m_getResultCallbacks.size(), m_countCallbacks.size());</span>
<span class="line-removed">2196 </span>
<span class="line-removed">2197     ASSERT(isMainThread());</span>
2198 
<a name="186" id="anc186"></a><span class="line-modified">2199     m_pendingSpaceIncreasingTasks.clear();</span>
<span class="line-modified">2200     m_server-&gt;resetSpaceUsed(m_identifier.origin());</span>




2201 
<a name="187" id="anc187"></a><span class="line-removed">2202     // Error out all transactions</span>
2203     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys()))
2204         m_inProgressTransactions.get(identifier)-&gt;abortWithoutCallback();
2205 
2206     ASSERT(m_inProgressTransactions.isEmpty());
2207 
<a name="188" id="anc188"></a><span class="line-removed">2208     for (auto&amp; transaction : m_pendingTransactions)</span>
<span class="line-removed">2209         transaction-&gt;databaseConnection().deleteTransaction(*transaction);</span>
<span class="line-removed">2210     m_pendingTransactions.clear();</span>
2211     m_objectStoreTransactionCounts.clear();
2212     m_objectStoreWriteTransactions.clear();
2213 
<a name="189" id="anc189"></a><span class="line-removed">2214     // Error out all pending callbacks</span>
<span class="line-removed">2215     IDBError error = IDBError::userDeleteError();</span>
<span class="line-removed">2216     IDBKeyData keyData;</span>
<span class="line-removed">2217     IDBGetResult getResult;</span>
<span class="line-removed">2218     IDBGetAllResult getAllResult;</span>
<span class="line-removed">2219 </span>
<span class="line-removed">2220     while (!m_callbackQueue.isEmpty()) {</span>
<span class="line-removed">2221         auto identifier = m_callbackQueue.first();</span>
<span class="line-removed">2222         if (m_errorCallbacks.contains(identifier))</span>
<span class="line-removed">2223             performErrorCallback(identifier, error);</span>
<span class="line-removed">2224         else if (m_keyDataCallbacks.contains(identifier))</span>
<span class="line-removed">2225             performKeyDataCallback(identifier, error, keyData);</span>
<span class="line-removed">2226         else if (m_getResultCallbacks.contains(identifier))</span>
<span class="line-removed">2227             performGetResultCallback(identifier, error, getResult);</span>
<span class="line-removed">2228         else if (m_countCallbacks.contains(identifier))</span>
<span class="line-removed">2229             performCountCallback(identifier, error, 0);</span>
<span class="line-removed">2230         else if (m_getAllResultsCallbacks.contains(identifier))</span>
<span class="line-removed">2231             performGetAllResultsCallback(identifier, error, getAllResult);</span>
<span class="line-removed">2232         else</span>
<span class="line-removed">2233             ASSERT_NOT_REACHED();</span>
<span class="line-removed">2234     }</span>
<span class="line-removed">2235 </span>
2236     // Error out all IDBOpenDBRequests
2237     if (m_currentOpenDBRequest) {
2238         errorOpenDBRequestForUserDelete(*m_currentOpenDBRequest);
2239         m_currentOpenDBRequest = nullptr;
2240     }
2241 
2242     for (auto&amp; request : m_pendingOpenDBRequests)
2243         errorOpenDBRequestForUserDelete(*request);
2244 
2245     m_pendingOpenDBRequests.clear();
2246 
2247     // Close all open connections
2248     auto openDatabaseConnections = m_openDatabaseConnections;
2249     for (auto&amp; connection : openDatabaseConnections)
2250         connectionClosedFromServer(*connection);
2251 
2252     if (m_versionChangeDatabaseConnection) {
2253         connectionClosedFromServer(*m_versionChangeDatabaseConnection);
2254         m_versionChangeDatabaseConnection = nullptr;
2255     }
2256 
<a name="190" id="anc190"></a><span class="line-modified">2257     // Cancel the operation timer</span>
<span class="line-removed">2258     m_operationAndTransactionTimer.stop();</span>
<span class="line-removed">2259 </span>
<span class="line-removed">2260     // Set up the database to remain alive-but-inert until all of its background activity finishes and all</span>
<span class="line-removed">2261     // database connections confirm that they have closed.</span>
<span class="line-removed">2262     m_hardClosedForUserDelete = true;</span>
<span class="line-removed">2263 </span>
<span class="line-removed">2264     // If this database already owns itself, it is already closing on the background thread.</span>
<span class="line-removed">2265     // After that close completes, the next database thread task will be &quot;delete all currently closed databases&quot;</span>
<span class="line-removed">2266     // which will also cover this database.</span>
<span class="line-removed">2267     if (m_owningPointerForClose)</span>
<span class="line-removed">2268         return;</span>
2269 
<a name="191" id="anc191"></a><span class="line-modified">2270     // Otherwise, this database is still potentially active.</span>
<span class="line-removed">2271     // So we&#39;ll have it own itself and then perform a clean unconditional delete on the background thread.</span>
<span class="line-removed">2272     m_owningPointerForClose = m_server-&gt;closeAndTakeUniqueIDBDatabase(*this);</span>
<span class="line-removed">2273     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performUnconditionalDeleteBackingStore));</span>
2274 }
2275 
<a name="192" id="anc192"></a><span class="line-modified">2276 void UniqueIDBDatabase::updateSpaceUsedIfNeeded(Optional&lt;uint64_t&gt; optionalCallbackIdentifier)</span>
2277 {
2278     ASSERT(isMainThread());
<a name="193" id="anc193"></a>
2279 
<a name="194" id="anc194"></a><span class="line-modified">2280     if (optionalCallbackIdentifier) {</span>
<span class="line-modified">2281         uint64_t callbackIdentifier = optionalCallbackIdentifier.value();</span>
<span class="line-modified">2282         auto iterator = m_pendingSpaceIncreasingTasks.find(callbackIdentifier);</span>
<span class="line-removed">2283         if (iterator != m_pendingSpaceIncreasingTasks.end()) {</span>
<span class="line-removed">2284             m_server-&gt;decreasePotentialSpaceUsed(m_identifier.origin(), iterator-&gt;value);</span>
<span class="line-removed">2285             m_pendingSpaceIncreasingTasks.remove(iterator);</span>
<span class="line-removed">2286         }</span>
<span class="line-removed">2287     }</span>
<span class="line-removed">2288 </span>
<span class="line-removed">2289     uint64_t databaseSize = m_newDatabaseSize;</span>
<span class="line-removed">2290     if (databaseSize != m_currentDatabaseSize) {</span>
<span class="line-removed">2291         if (databaseSize &gt; m_currentDatabaseSize)</span>
<span class="line-removed">2292             m_server-&gt;increaseSpaceUsed(m_identifier.origin(), databaseSize - m_currentDatabaseSize);</span>
<span class="line-removed">2293         else</span>
<span class="line-removed">2294             m_server-&gt;decreaseSpaceUsed(m_identifier.origin(), m_currentDatabaseSize - databaseSize);</span>
<span class="line-removed">2295         m_currentDatabaseSize = databaseSize;</span>
<span class="line-removed">2296     }</span>
<span class="line-removed">2297 }</span>
<span class="line-removed">2298 </span>
<span class="line-removed">2299 void UniqueIDBDatabase::performErrorCallback(uint64_t callbackIdentifier, const IDBError&amp; error)</span>
<span class="line-removed">2300 {</span>
<span class="line-removed">2301     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="line-removed">2302 </span>
<span class="line-removed">2303     auto callback = m_errorCallbacks.take(callbackIdentifier);</span>
<span class="line-removed">2304     ASSERT(callback || m_hardClosedForUserDelete);</span>
<span class="line-removed">2305     if (callback) {</span>
<span class="line-removed">2306         callback(error);</span>
<span class="line-removed">2307         ASSERT(m_callbackQueue.first() == callbackIdentifier);</span>
<span class="line-removed">2308         m_callbackQueue.removeFirst();</span>
<span class="line-removed">2309     }</span>
<span class="line-removed">2310 }</span>
<span class="line-removed">2311 </span>
<span class="line-removed">2312 void UniqueIDBDatabase::performKeyDataCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)</span>
<span class="line-removed">2313 {</span>
<span class="line-removed">2314     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="line-removed">2315 </span>
<span class="line-removed">2316     auto callback = m_keyDataCallbacks.take(callbackIdentifier);</span>
<span class="line-removed">2317     ASSERT(callback || m_hardClosedForUserDelete);</span>
<span class="line-removed">2318     if (callback) {</span>
<span class="line-removed">2319         callback(error, resultKey);</span>
<span class="line-removed">2320         ASSERT(m_callbackQueue.first() == callbackIdentifier);</span>
<span class="line-removed">2321         m_callbackQueue.removeFirst();</span>
<span class="line-removed">2322     }</span>
<span class="line-removed">2323 }</span>
<span class="line-removed">2324 </span>
<span class="line-removed">2325 void UniqueIDBDatabase::performGetResultCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; resultData)</span>
<span class="line-removed">2326 {</span>
<span class="line-removed">2327     auto callback = m_getResultCallbacks.take(callbackIdentifier);</span>
<span class="line-removed">2328     ASSERT(callback || m_hardClosedForUserDelete);</span>
<span class="line-removed">2329     if (callback) {</span>
<span class="line-removed">2330         callback(error, resultData);</span>
<span class="line-removed">2331         ASSERT(m_callbackQueue.first() == callbackIdentifier);</span>
<span class="line-removed">2332         m_callbackQueue.removeFirst();</span>
2333     }
2334 }
2335 
<a name="195" id="anc195"></a><span class="line-modified">2336 void UniqueIDBDatabase::performGetAllResultsCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetAllResult&amp; resultData)</span>
2337 {
<a name="196" id="anc196"></a><span class="line-modified">2338     auto callback = m_getAllResultsCallbacks.take(callbackIdentifier);</span>
<span class="line-removed">2339     ASSERT(callback || m_hardClosedForUserDelete);</span>
<span class="line-removed">2340     if (callback) {</span>
<span class="line-removed">2341         callback(error, resultData);</span>
<span class="line-removed">2342         ASSERT(m_callbackQueue.first() == callbackIdentifier);</span>
<span class="line-removed">2343         m_callbackQueue.removeFirst();</span>
<span class="line-removed">2344     }</span>
<span class="line-removed">2345 }</span>
2346 
<a name="197" id="anc197"></a><span class="line-modified">2347 void UniqueIDBDatabase::performCountCallback(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)</span>
<span class="line-modified">2348 {</span>
<span class="line-modified">2349     auto callback = m_countCallbacks.take(callbackIdentifier);</span>
<span class="line-removed">2350     ASSERT(callback || m_hardClosedForUserDelete);</span>
<span class="line-removed">2351     if (callback) {</span>
<span class="line-removed">2352         callback(error, count);</span>
<span class="line-removed">2353         ASSERT(m_callbackQueue.first() == callbackIdentifier);</span>
<span class="line-removed">2354         m_callbackQueue.removeFirst();</span>
2355     }
2356 }
2357 
<a name="198" id="anc198"></a><span class="line-modified">2358 void UniqueIDBDatabase::forgetErrorCallback(uint64_t callbackIdentifier)</span>
<span class="line-removed">2359 {</span>
<span class="line-removed">2360     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="line-removed">2361 </span>
<span class="line-removed">2362     ASSERT(m_errorCallbacks.contains(callbackIdentifier));</span>
<span class="line-removed">2363     ASSERT(m_callbackQueue.last() == callbackIdentifier);</span>
<span class="line-removed">2364     m_callbackQueue.removeLast();</span>
<span class="line-removed">2365     m_errorCallbacks.remove(callbackIdentifier);</span>
<span class="line-removed">2366 }</span>
<span class="line-removed">2367 </span>
<span class="line-removed">2368 void UniqueIDBDatabase::abortTransactionOnMainThread(UniqueIDBDatabaseTransaction&amp; transaction)</span>
2369 {
<a name="199" id="anc199"></a><span class="line-modified">2370     transaction.setResult(m_backingStore-&gt;abortTransaction(transaction.info().identifier()));</span>
<span class="line-modified">2371     transaction.setState(UniqueIDBDatabaseTransaction::State::Aborted);</span>
<span class="line-removed">2372 }</span>
<span class="line-removed">2373 </span>
<span class="line-removed">2374 void UniqueIDBDatabase::commitTransactionOnMainThread(UniqueIDBDatabaseTransaction&amp; transaction)</span>
<span class="line-removed">2375 {</span>
<span class="line-removed">2376     transaction.setResult(m_backingStore-&gt;commitTransaction(transaction.info().identifier()));</span>
<span class="line-removed">2377     transaction.setState(UniqueIDBDatabaseTransaction::State::Committed);</span>
<span class="line-removed">2378 }</span>
<span class="line-removed">2379 </span>
<span class="line-removed">2380 void UniqueIDBDatabase::finishActiveTransactions()</span>
<span class="line-removed">2381 {</span>
<span class="line-removed">2382     ASSERT(isMainThread());</span>
2383 
<a name="200" id="anc200"></a><span class="line-modified">2384     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys())) {</span>
<span class="line-modified">2385         auto transaction = m_inProgressTransactions.get(identifier);</span>
<span class="line-modified">2386         abortTransactionOnMainThread(*transaction);</span>

2387     }
2388 
<a name="201" id="anc201"></a><span class="line-modified">2389     for (auto&amp; identifier : copyToVector(m_finishingTransactions.keys())) {</span>
<span class="line-removed">2390         if (!m_backingStore-&gt;hasTransaction(identifier))</span>
<span class="line-removed">2391             continue;</span>
<span class="line-removed">2392 </span>
<span class="line-removed">2393         auto transaction = m_finishingTransactions.get(identifier);</span>
<span class="line-removed">2394         switch (transaction-&gt;state()) {</span>
<span class="line-removed">2395         case UniqueIDBDatabaseTransaction::State::Aborting:</span>
<span class="line-removed">2396             abortTransactionOnMainThread(*transaction);</span>
<span class="line-removed">2397             break;</span>
<span class="line-removed">2398         case UniqueIDBDatabaseTransaction::State::Committing:</span>
<span class="line-removed">2399             commitTransactionOnMainThread(*transaction);</span>
<span class="line-removed">2400             break;</span>
<span class="line-removed">2401         case UniqueIDBDatabaseTransaction::State::Running:</span>
<span class="line-removed">2402         case UniqueIDBDatabaseTransaction::State::Aborted:</span>
<span class="line-removed">2403         case UniqueIDBDatabaseTransaction::State::Committed:</span>
<span class="line-removed">2404             ASSERT_NOT_REACHED();</span>
<span class="line-removed">2405         }</span>
<span class="line-removed">2406     }</span>
2407 }
2408 
2409 } // namespace IDBServer
2410 } // namespace WebCore
2411 
2412 #endif // ENABLE(INDEXED_DATABASE)
<a name="202" id="anc202"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="202" type="hidden" />
</body>
</html>
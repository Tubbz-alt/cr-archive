<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ExceptionHelpers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ExceptionFuzz.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ExceptionHelpers.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ExceptionHelpers.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   *
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2008-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,14 ***</span>
  
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(TerminatedExecutionError);
  
  const ClassInfo TerminatedExecutionError::s_info = { &quot;TerminatedExecutionError&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(TerminatedExecutionError) };
  
<span class="line-modified">! JSValue TerminatedExecutionError::defaultValue(const JSObject*, ExecState* exec, PreferredPrimitiveType hint)</span>
  {
      if (hint == PreferString)
<span class="line-modified">!         return jsNontrivialString(exec-&gt;vm(), String(&quot;JavaScript execution terminated.&quot;_s));</span>
      return JSValue(PNaN);
  }
  
  JSObject* createTerminatedExecutionException(VM* vm)
  {
<span class="line-new-header">--- 45,14 ---</span>
  
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(TerminatedExecutionError);
  
  const ClassInfo TerminatedExecutionError::s_info = { &quot;TerminatedExecutionError&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(TerminatedExecutionError) };
  
<span class="line-modified">! JSValue TerminatedExecutionError::defaultValue(const JSObject*, JSGlobalObject* globalObject, PreferredPrimitiveType hint)</span>
  {
      if (hint == PreferString)
<span class="line-modified">!         return jsNontrivialString(globalObject-&gt;vm(), String(&quot;JavaScript execution terminated.&quot;_s));</span>
      return JSValue(PNaN);
  }
  
  JSObject* createTerminatedExecutionException(VM* vm)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,49 ***</span>
          return false;
  
      return exception-&gt;value().inherits&lt;TerminatedExecutionError&gt;(vm);
  }
  
<span class="line-modified">! JSObject* createStackOverflowError(ExecState* exec)</span>
  {
<span class="line-modified">!     return createStackOverflowError(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JSObject* createStackOverflowError(ExecState* exec, JSGlobalObject* globalObject)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto* error = createRangeError(exec, globalObject, &quot;Maximum call stack size exceeded.&quot;_s);</span>
      jsCast&lt;ErrorInstance*&gt;(error)-&gt;setStackOverflowError();
      return error;
  }
  
<span class="line-modified">! JSObject* createUndefinedVariableError(ExecState* exec, const Identifier&amp; ident)</span>
  {
      if (ident.isPrivateName())
<span class="line-modified">!         return createReferenceError(exec, makeString(&quot;Can&#39;t find private variable: PrivateSymbol.&quot;, ident.string()));</span>
<span class="line-modified">!     return createReferenceError(exec, makeString(&quot;Can&#39;t find variable: &quot;, ident.string()));</span>
  }
  
<span class="line-modified">! String errorDescriptionForValue(ExecState* exec, JSValue v)</span>
  {
      if (v.isString()) {
<span class="line-modified">!         String string = asString(v)-&gt;value(exec);</span>
          if (!string)
              return string;
          return tryMakeString(&#39;&quot;&#39;, string, &#39;&quot;&#39;);
      }
  
      if (v.isSymbol())
          return asSymbol(v)-&gt;descriptiveString();
      if (v.isObject()) {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          CallData callData;
          JSObject* object = asObject(v);
          if (object-&gt;methodTable(vm)-&gt;getCallData(object, callData) != CallType::None)
<span class="line-modified">!             return vm.smallStrings.functionString()-&gt;value(exec);</span>
          return JSObject::calculatedClassName(object);
      }
<span class="line-modified">!     return v.toString(exec)-&gt;value(exec);</span>
  }
  
  static String defaultApproximateSourceError(const String&amp; originalMessage, const String&amp; sourceText)
  {
      return makeString(originalMessage, &quot; (near &#39;...&quot;, sourceText, &quot;...&#39;)&quot;);
<span class="line-new-header">--- 65,44 ---</span>
          return false;
  
      return exception-&gt;value().inherits&lt;TerminatedExecutionError&gt;(vm);
  }
  
<span class="line-modified">! JSObject* createStackOverflowError(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     auto* error = createRangeError(globalObject, &quot;Maximum call stack size exceeded.&quot;_s);</span>
      jsCast&lt;ErrorInstance*&gt;(error)-&gt;setStackOverflowError();
      return error;
  }
  
<span class="line-modified">! JSObject* createUndefinedVariableError(JSGlobalObject* globalObject, const Identifier&amp; ident)</span>
  {
      if (ident.isPrivateName())
<span class="line-modified">!         return createReferenceError(globalObject, makeString(&quot;Can&#39;t find private variable: PrivateSymbol.&quot;, ident.string()));</span>
<span class="line-modified">!     return createReferenceError(globalObject, makeString(&quot;Can&#39;t find variable: &quot;, ident.string()));</span>
  }
  
<span class="line-modified">! String errorDescriptionForValue(JSGlobalObject* globalObject, JSValue v)</span>
  {
      if (v.isString()) {
<span class="line-modified">!         String string = asString(v)-&gt;value(globalObject);</span>
          if (!string)
              return string;
          return tryMakeString(&#39;&quot;&#39;, string, &#39;&quot;&#39;);
      }
  
      if (v.isSymbol())
          return asSymbol(v)-&gt;descriptiveString();
      if (v.isObject()) {
<span class="line-modified">!         VM&amp; vm = globalObject-&gt;vm();</span>
          CallData callData;
          JSObject* object = asObject(v);
          if (object-&gt;methodTable(vm)-&gt;getCallData(object, callData) != CallType::None)
<span class="line-modified">!             return vm.smallStrings.functionString()-&gt;value(globalObject);</span>
          return JSObject::calculatedClassName(object);
      }
<span class="line-modified">!     return v.toString(globalObject)-&gt;value(globalObject);</span>
  }
  
  static String defaultApproximateSourceError(const String&amp; originalMessage, const String&amp; sourceText)
  {
      return makeString(originalMessage, &quot; (near &#39;...&quot;, sourceText, &quot;...&#39;)&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,11 ***</span>
      unsigned sourceLength = sourceText.length();
      unsigned idx = sourceLength - 1;
      if (sourceLength &lt; 2 || sourceText[idx] != &#39;)&#39;) {
          // For function calls that have many new lines in between their open parenthesis
          // and their closing parenthesis, the text range passed into the message appender
<span class="line-modified">!         // will not inlcude the text in between these parentheses, it will just be the desired</span>
          // text that precedes the parentheses.
          return String();
      }
  
      unsigned parenStack = 1;
<span class="line-new-header">--- 128,11 ---</span>
      unsigned sourceLength = sourceText.length();
      unsigned idx = sourceLength - 1;
      if (sourceLength &lt; 2 || sourceText[idx] != &#39;)&#39;) {
          // For function calls that have many new lines in between their open parenthesis
          // and their closing parenthesis, the text range passed into the message appender
<span class="line-modified">!         // will not include the text in between these parentheses, it will just be the desired</span>
          // text that precedes the parentheses.
          return String();
      }
  
      unsigned parenStack = 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,11 ***</span>
          return originalMessage;
      }
      if (sourceText.find(&quot;in&quot;) != inIndex)
          return makeString(originalMessage, &quot; (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
  
<span class="line-modified">!     static const unsigned inLength = 2;</span>
      String rightHandSide = sourceText.substring(inIndex + inLength).simplifyWhiteSpace();
      return makeString(rightHandSide, &quot; is not an Object. (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
  }
  
  inline String invalidParameterInstanceofSourceAppender(const String&amp; content, const String&amp; originalMessage, const String&amp; sourceText, RuntimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
<span class="line-new-header">--- 227,11 ---</span>
          return originalMessage;
      }
      if (sourceText.find(&quot;in&quot;) != inIndex)
          return makeString(originalMessage, &quot; (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
  
<span class="line-modified">!     static constexpr unsigned inLength = 2;</span>
      String rightHandSide = sourceText.substring(inIndex + inLength).simplifyWhiteSpace();
      return makeString(rightHandSide, &quot; is not an Object. (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
  }
  
  inline String invalidParameterInstanceofSourceAppender(const String&amp; content, const String&amp; originalMessage, const String&amp; sourceText, RuntimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 248,11 ***</span>
      auto instanceofIndex = sourceText.reverseFind(&quot;instanceof&quot;);
      RELEASE_ASSERT(instanceofIndex != notFound);
      if (sourceText.find(&quot;instanceof&quot;) != instanceofIndex)
          return makeString(originalMessage, &quot; (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
  
<span class="line-modified">!     static const unsigned instanceofLength = 10;</span>
      String rightHandSide = sourceText.substring(instanceofIndex + instanceofLength).simplifyWhiteSpace();
      return makeString(rightHandSide, content, &quot;. (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
  }
  
  static String invalidParameterInstanceofNotFunctionSourceAppender(const String&amp; originalMessage, const String&amp; sourceText, RuntimeType runtimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
<span class="line-new-header">--- 243,11 ---</span>
      auto instanceofIndex = sourceText.reverseFind(&quot;instanceof&quot;);
      RELEASE_ASSERT(instanceofIndex != notFound);
      if (sourceText.find(&quot;instanceof&quot;) != instanceofIndex)
          return makeString(originalMessage, &quot; (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
  
<span class="line-modified">!     static constexpr unsigned instanceofLength = 10;</span>
      String rightHandSide = sourceText.substring(instanceofIndex + instanceofLength).simplifyWhiteSpace();
      return makeString(rightHandSide, content, &quot;. (evaluating &#39;&quot;, sourceText, &quot;&#39;)&quot;);
  }
  
  static String invalidParameterInstanceofNotFunctionSourceAppender(const String&amp; originalMessage, const String&amp; sourceText, RuntimeType runtimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,91 ***</span>
  static String invalidParameterInstanceofhasInstanceValueNotFunctionSourceAppender(const String&amp; originalMessage, const String&amp; sourceText, RuntimeType runtimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
  {
      return invalidParameterInstanceofSourceAppender(&quot;[Symbol.hasInstance] is not a function, undefined, or null&quot;_s, originalMessage, sourceText, runtimeType, occurrence);
  }
  
<span class="line-modified">! JSObject* createError(ExecState* exec, JSValue value, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     String valueDescription = errorDescriptionForValue(exec, value);</span>
<span class="line-modified">!     ASSERT(scope.exception() || !!valueDescription);</span>
<span class="line-modified">!     if (!valueDescription) {</span>
          scope.clearException();
<span class="line-modified">!         return createOutOfMemoryError(exec);</span>
      }
      String errorMessage = tryMakeString(valueDescription, &#39; &#39;, message);
      if (!errorMessage)
<span class="line-modified">!         return createOutOfMemoryError(exec);</span>
      scope.assertNoException();
<span class="line-modified">!     JSObject* exception = createTypeError(exec, errorMessage, appender, runtimeTypeForValue(vm, value));</span>
      ASSERT(exception-&gt;isErrorInstance());
  
      return exception;
  }
  
<span class="line-modified">! JSObject* createInvalidFunctionApplyParameterError(ExecState* exec, JSValue value)</span>
  {
<span class="line-modified">!     return createTypeError(exec, &quot;second argument to Function.prototype.apply must be an Array-like object&quot;_s, defaultSourceAppender, runtimeTypeForValue(exec-&gt;vm(), value));</span>
  }
  
<span class="line-modified">! JSObject* createInvalidInParameterError(ExecState* exec, JSValue value)</span>
  {
<span class="line-modified">!     return createError(exec, value, &quot;is not an Object.&quot;_s, invalidParameterInSourceAppender);</span>
  }
  
<span class="line-modified">! JSObject* createInvalidInstanceofParameterErrorNotFunction(ExecState* exec, JSValue value)</span>
  {
<span class="line-modified">!     return createError(exec, value, &quot; is not a function&quot;_s, invalidParameterInstanceofNotFunctionSourceAppender);</span>
  }
  
<span class="line-modified">! JSObject* createInvalidInstanceofParameterErrorHasInstanceValueNotFunction(ExecState* exec, JSValue value)</span>
  {
<span class="line-modified">!     return createError(exec, value, &quot;[Symbol.hasInstance] is not a function, undefined, or null&quot;_s, invalidParameterInstanceofhasInstanceValueNotFunctionSourceAppender);</span>
  }
  
<span class="line-modified">! JSObject* createNotAConstructorError(ExecState* exec, JSValue value)</span>
  {
<span class="line-modified">!     return createError(exec, value, &quot;is not a constructor&quot;_s, defaultSourceAppender);</span>
  }
  
<span class="line-modified">! JSObject* createNotAFunctionError(ExecState* exec, JSValue value)</span>
  {
<span class="line-modified">!     return createError(exec, value, &quot;is not a function&quot;_s, notAFunctionSourceAppender);</span>
  }
  
<span class="line-modified">! JSObject* createNotAnObjectError(ExecState* exec, JSValue value)</span>
  {
<span class="line-modified">!     return createError(exec, value, &quot;is not an object&quot;_s, defaultSourceAppender);</span>
  }
  
<span class="line-modified">! JSObject* createErrorForInvalidGlobalAssignment(ExecState* exec, const String&amp; propertyName)</span>
  {
<span class="line-modified">!     return createReferenceError(exec, makeString(&quot;Strict mode forbids implicit creation of global property &#39;&quot;, propertyName, &#39;\&#39;&#39;));</span>
  }
  
<span class="line-modified">! JSObject* createTDZError(ExecState* exec)</span>
  {
<span class="line-modified">!     return createReferenceError(exec, &quot;Cannot access uninitialized variable.&quot;);</span>
  }
  
<span class="line-modified">! Exception* throwOutOfMemoryError(ExecState* exec, ThrowScope&amp; scope)</span>
  {
<span class="line-modified">!     return throwException(exec, scope, createOutOfMemoryError(exec));</span>
  }
  
<span class="line-modified">! Exception* throwStackOverflowError(ExecState* exec, ThrowScope&amp; scope)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      ErrorHandlingScope errorScope(vm);
<span class="line-modified">!     return throwException(exec, scope, createStackOverflowError(exec));</span>
  }
  
<span class="line-modified">! Exception* throwTerminatedExecutionException(ExecState* exec, ThrowScope&amp; scope)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      ErrorHandlingScope errorScope(vm);
<span class="line-modified">!     return throwException(exec, scope, createTerminatedExecutionException(&amp;vm));</span>
  }
  
  } // namespace JSC
<span class="line-new-header">--- 258,94 ---</span>
  static String invalidParameterInstanceofhasInstanceValueNotFunctionSourceAppender(const String&amp; originalMessage, const String&amp; sourceText, RuntimeType runtimeType, ErrorInstance::SourceTextWhereErrorOccurred occurrence)
  {
      return invalidParameterInstanceofSourceAppender(&quot;[Symbol.hasInstance] is not a function, undefined, or null&quot;_s, originalMessage, sourceText, runtimeType, occurrence);
  }
  
<span class="line-modified">! JSObject* createError(JSGlobalObject* globalObject, JSValue value, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     String valueDescription = errorDescriptionForValue(globalObject, value);</span>
<span class="line-modified">!     if (scope.exception() || !valueDescription) {</span>
<span class="line-modified">!         // When we see an exception, we&#39;re not returning immediately because</span>
<span class="line-added">+         // we&#39;re in a CatchScope, i.e. no exceptions are thrown past this scope.</span>
<span class="line-added">+         // We&#39;re using a CatchScope because the contract for createError() is</span>
<span class="line-added">+         // that it only creates an error object; it doesn&#39;t throw it.</span>
          scope.clearException();
<span class="line-modified">!         return createOutOfMemoryError(globalObject);</span>
      }
      String errorMessage = tryMakeString(valueDescription, &#39; &#39;, message);
      if (!errorMessage)
<span class="line-modified">!         return createOutOfMemoryError(globalObject);</span>
      scope.assertNoException();
<span class="line-modified">!     JSObject* exception = createTypeError(globalObject, errorMessage, appender, runtimeTypeForValue(vm, value));</span>
      ASSERT(exception-&gt;isErrorInstance());
  
      return exception;
  }
  
<span class="line-modified">! JSObject* createInvalidFunctionApplyParameterError(JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     return createTypeError(globalObject, &quot;second argument to Function.prototype.apply must be an Array-like object&quot;_s, defaultSourceAppender, runtimeTypeForValue(globalObject-&gt;vm(), value));</span>
  }
  
<span class="line-modified">! JSObject* createInvalidInParameterError(JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     return createError(globalObject, value, &quot;is not an Object.&quot;_s, invalidParameterInSourceAppender);</span>
  }
  
<span class="line-modified">! JSObject* createInvalidInstanceofParameterErrorNotFunction(JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     return createError(globalObject, value, &quot; is not a function&quot;_s, invalidParameterInstanceofNotFunctionSourceAppender);</span>
  }
  
<span class="line-modified">! JSObject* createInvalidInstanceofParameterErrorHasInstanceValueNotFunction(JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     return createError(globalObject, value, &quot;[Symbol.hasInstance] is not a function, undefined, or null&quot;_s, invalidParameterInstanceofhasInstanceValueNotFunctionSourceAppender);</span>
  }
  
<span class="line-modified">! JSObject* createNotAConstructorError(JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     return createError(globalObject, value, &quot;is not a constructor&quot;_s, defaultSourceAppender);</span>
  }
  
<span class="line-modified">! JSObject* createNotAFunctionError(JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     return createError(globalObject, value, &quot;is not a function&quot;_s, notAFunctionSourceAppender);</span>
  }
  
<span class="line-modified">! JSObject* createNotAnObjectError(JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     return createError(globalObject, value, &quot;is not an object&quot;_s, defaultSourceAppender);</span>
  }
  
<span class="line-modified">! JSObject* createErrorForInvalidGlobalAssignment(JSGlobalObject* globalObject, const String&amp; propertyName)</span>
  {
<span class="line-modified">!     return createReferenceError(globalObject, makeString(&quot;Strict mode forbids implicit creation of global property &#39;&quot;, propertyName, &#39;\&#39;&#39;));</span>
  }
  
<span class="line-modified">! JSObject* createTDZError(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     return createReferenceError(globalObject, &quot;Cannot access uninitialized variable.&quot;);</span>
  }
  
<span class="line-modified">! Exception* throwOutOfMemoryError(JSGlobalObject* globalObject, ThrowScope&amp; scope)</span>
  {
<span class="line-modified">!     return throwException(globalObject, scope, createOutOfMemoryError(globalObject));</span>
  }
  
<span class="line-modified">! Exception* throwStackOverflowError(JSGlobalObject* globalObject, ThrowScope&amp; scope)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      ErrorHandlingScope errorScope(vm);
<span class="line-modified">!     return throwException(globalObject, scope, createStackOverflowError(globalObject));</span>
  }
  
<span class="line-modified">! Exception* throwTerminatedExecutionException(JSGlobalObject* globalObject, ThrowScope&amp; scope)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      ErrorHandlingScope errorScope(vm);
<span class="line-modified">!     return throwException(globalObject, scope, createTerminatedExecutionException(&amp;vm));</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="ExceptionFuzz.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ExceptionHelpers.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScriptWrappable.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SerializedScriptValue.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 87,19 ***</span>
<span class="line-new-header">--- 87,26 ---</span>
  #include &lt;wtf/CompletionHandler.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/RunLoop.h&gt;
  #include &lt;wtf/Vector.h&gt;
  
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+ #include &quot;JSOffscreenCanvas.h&quot;</span>
<span class="line-added">+ #include &quot;OffscreenCanvas.h&quot;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  #if CPU(BIG_ENDIAN) || CPU(MIDDLE_ENDIAN) || CPU(NEEDS_ALIGNED_ACCESS)
  #define ASSUME_LITTLE_ENDIAN 0
  #else
  #define ASSUME_LITTLE_ENDIAN 1
  #endif
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SerializedScriptValue);</span>
<span class="line-added">+ </span>
  static const unsigned maximumFilterRecursion = 40000;
  
  enum class SerializationReturnCode {
      SuccessfullyCompleted,
      StackOverflowError,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,10 ***</span>
<span class="line-new-header">--- 172,14 ---</span>
      DOMMatrixTag = 41,
      DOMQuadTag = 42,
      ImageBitmapTransferTag = 43,
  #if ENABLE(WEB_RTC)
      RTCCertificateTag = 44,
<span class="line-added">+ #endif</span>
<span class="line-added">+     ImageBitmapTag = 45,</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+     OffscreenCanvasTransferTag = 46,</span>
  #endif
      ErrorTag = 255
  };
  
  enum ArrayBufferViewSubtag {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 348,10 ***</span>
<span class="line-new-header">--- 359,12 ---</span>
   *    | DOMRect
   *    | DOMMatrix
   *    | DOMQuad
   *    | ImageBitmapTransferTag &lt;value:uint32_t&gt;
   *    | RTCCertificateTag
<span class="line-added">+  *    | ImageBitmapTag &lt;originClean:uint8_t&gt; &lt;logicalWidth:int32_t&gt; &lt;logicalHeight:int32_t&gt; &lt;resolutionScale:double&gt; &lt;byteLength:uint32_t&gt;(&lt;imageByteData:uint8_t&gt;)</span>
<span class="line-added">+  *    | OffscreenCanvasTransferTag &lt;value:uint32_t&gt;</span>
   *
   * Inside certificate, data is serialized in this format as per spec:
   *
   * &lt;expires:double&gt; &lt;certificate:StringData&gt; &lt;origin:StringData&gt; &lt;keyingMaterial:StringData&gt;
   * We also add fingerprints to make sure we expose to JavaScript the same information.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 456,45 ***</span>
  
  using DeserializationResult = std::pair&lt;JSC::JSValue, SerializationReturnCode&gt;;
  
  class CloneBase {
  protected:
<span class="line-modified">!     CloneBase(ExecState* exec)</span>
<span class="line-modified">!         : m_exec(exec)</span>
          , m_failed(false)
      {
      }
  
      bool shouldTerminate()
      {
<span class="line-modified">!         VM&amp; vm = m_exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
          return scope.exception();
      }
  
      void fail()
      {
          m_failed = true;
      }
  
<span class="line-modified">!     ExecState* m_exec;</span>
      bool m_failed;
      MarkedArgumentBuffer m_gcBuffer;
  };
  
  #if ENABLE(WEB_CRYPTO)
<span class="line-modified">! static bool wrapCryptoKey(ExecState* exec, const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)</span>
  {
<span class="line-modified">!     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(exec);</span>
      if (!scriptExecutionContext)
          return false;
      return scriptExecutionContext-&gt;wrapCryptoKey(key, wrappedKey);
  }
  
<span class="line-modified">! static bool unwrapCryptoKey(ExecState* exec, const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)</span>
  {
<span class="line-modified">!     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(exec);</span>
      if (!scriptExecutionContext)
          return false;
      return scriptExecutionContext-&gt;unwrapCryptoKey(wrappedKey, key);
  }
  #endif
<span class="line-new-header">--- 469,45 ---</span>
  
  using DeserializationResult = std::pair&lt;JSC::JSValue, SerializationReturnCode&gt;;
  
  class CloneBase {
  protected:
<span class="line-modified">!     CloneBase(JSGlobalObject* lexicalGlobalObject)</span>
<span class="line-modified">!         : m_lexicalGlobalObject(lexicalGlobalObject)</span>
          , m_failed(false)
      {
      }
  
      bool shouldTerminate()
      {
<span class="line-modified">!         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
          return scope.exception();
      }
  
      void fail()
      {
          m_failed = true;
      }
  
<span class="line-modified">!     JSGlobalObject* m_lexicalGlobalObject;</span>
      bool m_failed;
      MarkedArgumentBuffer m_gcBuffer;
  };
  
  #if ENABLE(WEB_CRYPTO)
<span class="line-modified">! static bool wrapCryptoKey(JSGlobalObject* lexicalGlobalObject, const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)</span>
  {
<span class="line-modified">!     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(lexicalGlobalObject);</span>
      if (!scriptExecutionContext)
          return false;
      return scriptExecutionContext-&gt;wrapCryptoKey(key, wrappedKey);
  }
  
<span class="line-modified">! static bool unwrapCryptoKey(JSGlobalObject* lexicalGlobalObject, const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)</span>
  {
<span class="line-modified">!     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(lexicalGlobalObject);</span>
      if (!scriptExecutionContext)
          return false;
      return scriptExecutionContext-&gt;unwrapCryptoKey(wrappedKey, key);
  }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 544,17 ***</span>
      return true;
  }
  
  class CloneSerializer : CloneBase {
  public:
<span class="line-modified">!     static SerializationReturnCode serialize(ExecState* exec, JSValue value, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,</span>
  #if ENABLE(WEBASSEMBLY)
              WasmModuleArray&amp; wasmModules,
  #endif
          Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)
      {
<span class="line-modified">!         CloneSerializer serializer(exec, messagePorts, arrayBuffers, imageBitmaps,</span>
  #if ENABLE(WEBASSEMBLY)
              wasmModules,
  #endif
              blobURLs, out, context, sharedBuffers);
          return serializer.serialize(value);
<span class="line-new-header">--- 557,23 ---</span>
      return true;
  }
  
  class CloneSerializer : CloneBase {
  public:
<span class="line-modified">!     static SerializationReturnCode serialize(JSGlobalObject* lexicalGlobalObject, JSValue value, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+             const Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt;&amp; offscreenCanvases,</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
              WasmModuleArray&amp; wasmModules,
  #endif
          Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)
      {
<span class="line-modified">!         CloneSerializer serializer(lexicalGlobalObject, messagePorts, arrayBuffers, imageBitmaps,</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+             offscreenCanvases,</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
              wasmModules,
  #endif
              blobURLs, out, context, sharedBuffers);
          return serializer.serialize(value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 577,39 ***</span>
      }
  
  private:
      typedef HashMap&lt;JSObject*, uint32_t&gt; ObjectPool;
  
<span class="line-modified">!     CloneSerializer(ExecState* exec, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,</span>
  #if ENABLE(WEBASSEMBLY)
              WasmModuleArray&amp; wasmModules,
  #endif
          Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)
<span class="line-modified">!         : CloneBase(exec)</span>
          , m_buffer(out)
          , m_blobURLs(blobURLs)
<span class="line-modified">!         , m_emptyIdentifier(Identifier::fromString(exec-&gt;vm(), emptyString()))</span>
          , m_context(context)
          , m_sharedBuffers(sharedBuffers)
  #if ENABLE(WEBASSEMBLY)
          , m_wasmModules(wasmModules)
  #endif
      {
          write(CurrentVersion);
          fillTransferMap(messagePorts, m_transferredMessagePorts);
          fillTransferMap(arrayBuffers, m_transferredArrayBuffers);
          fillTransferMap(imageBitmaps, m_transferredImageBitmaps);
      }
  
      template &lt;class T&gt;
      void fillTransferMap(const Vector&lt;RefPtr&lt;T&gt;&gt;&amp; input, ObjectPool&amp; result)
      {
          if (input.isEmpty())
              return;
<span class="line-modified">!         JSDOMGlobalObject* globalObject = jsCast&lt;JSDOMGlobalObject*&gt;(m_exec-&gt;lexicalGlobalObject());</span>
          for (size_t i = 0; i &lt; input.size(); i++) {
<span class="line-modified">!             JSC::JSValue value = toJS(m_exec, globalObject, input[i].get());</span>
              JSC::JSObject* obj = value.getObject();
              if (obj &amp;&amp; !result.contains(obj))
                  result.add(obj, i);
          }
      }
<span class="line-new-header">--- 596,45 ---</span>
      }
  
  private:
      typedef HashMap&lt;JSObject*, uint32_t&gt; ObjectPool;
  
<span class="line-modified">!     CloneSerializer(JSGlobalObject* lexicalGlobalObject, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+             const Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt;&amp; offscreenCanvases,</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
              WasmModuleArray&amp; wasmModules,
  #endif
          Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)
<span class="line-modified">!         : CloneBase(lexicalGlobalObject)</span>
          , m_buffer(out)
          , m_blobURLs(blobURLs)
<span class="line-modified">!         , m_emptyIdentifier(Identifier::fromString(lexicalGlobalObject-&gt;vm(), emptyString()))</span>
          , m_context(context)
          , m_sharedBuffers(sharedBuffers)
  #if ENABLE(WEBASSEMBLY)
          , m_wasmModules(wasmModules)
  #endif
      {
          write(CurrentVersion);
          fillTransferMap(messagePorts, m_transferredMessagePorts);
          fillTransferMap(arrayBuffers, m_transferredArrayBuffers);
          fillTransferMap(imageBitmaps, m_transferredImageBitmaps);
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+         fillTransferMap(offscreenCanvases, m_transferredOffscreenCanvases);</span>
<span class="line-added">+ #endif</span>
      }
  
      template &lt;class T&gt;
      void fillTransferMap(const Vector&lt;RefPtr&lt;T&gt;&gt;&amp; input, ObjectPool&amp; result)
      {
          if (input.isEmpty())
              return;
<span class="line-modified">!         JSDOMGlobalObject* globalObject = jsCast&lt;JSDOMGlobalObject*&gt;(m_lexicalGlobalObject);</span>
          for (size_t i = 0; i &lt; input.size(); i++) {
<span class="line-modified">!             JSC::JSValue value = toJS(m_lexicalGlobalObject, globalObject, input[i].get());</span>
              JSC::JSObject* obj = value.getObject();
              if (obj &amp;&amp; !result.contains(obj))
                  result.add(obj, i);
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 712,12 ***</span>
      }
  
      JSValue getProperty(VM&amp; vm, JSObject* object, const Identifier&amp; propertyName)
      {
          PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!         if (object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, m_exec, propertyName, slot))</span>
<span class="line-modified">!             return slot.getValue(m_exec, propertyName);</span>
          return JSValue();
      }
  
      void dumpImmediate(JSValue value)
      {
<span class="line-new-header">--- 737,12 ---</span>
      }
  
      JSValue getProperty(VM&amp; vm, JSObject* object, const Identifier&amp; propertyName)
      {
          PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!         if (object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, m_lexicalGlobalObject, propertyName, slot))</span>
<span class="line-modified">!             return slot.getValue(m_lexicalGlobalObject, propertyName);</span>
          return JSValue();
      }
  
      void dumpImmediate(JSValue value)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 767,24 ***</span>
          }
      }
  
      JSC::JSValue toJSArrayBuffer(ArrayBuffer&amp; arrayBuffer)
      {
<span class="line-modified">!         auto&amp; vm = m_exec-&gt;vm();</span>
<span class="line-modified">!         auto* globalObject = m_exec-&gt;lexicalGlobalObject();</span>
          if (globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(vm))
<span class="line-modified">!             return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(globalObject), &amp;arrayBuffer);</span>
  
          if (auto* buffer = arrayBuffer.m_wrapper.get())
              return buffer;
  
          return JSC::JSArrayBuffer::create(vm, globalObject-&gt;arrayBufferStructure(arrayBuffer.sharingMode()), &amp;arrayBuffer);
      }
  
      bool dumpArrayBufferView(JSObject* obj, SerializationReturnCode&amp; code)
      {
<span class="line-modified">!         VM&amp; vm = m_exec-&gt;vm();</span>
          write(ArrayBufferViewTag);
          if (obj-&gt;inherits&lt;JSDataView&gt;(vm))
              write(DataViewTag);
          else if (obj-&gt;inherits&lt;JSUint8ClampedArray&gt;(vm))
              write(Uint8ClampedArrayTag);
<span class="line-new-header">--- 792,24 ---</span>
          }
      }
  
      JSC::JSValue toJSArrayBuffer(ArrayBuffer&amp; arrayBuffer)
      {
<span class="line-modified">!         auto&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
<span class="line-modified">!         auto* globalObject = m_lexicalGlobalObject;</span>
          if (globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(vm))
<span class="line-modified">!             return toJS(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(globalObject), &amp;arrayBuffer);</span>
  
          if (auto* buffer = arrayBuffer.m_wrapper.get())
              return buffer;
  
          return JSC::JSArrayBuffer::create(vm, globalObject-&gt;arrayBufferStructure(arrayBuffer.sharingMode()), &amp;arrayBuffer);
      }
  
      bool dumpArrayBufferView(JSObject* obj, SerializationReturnCode&amp; code)
      {
<span class="line-modified">!         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
          write(ArrayBufferViewTag);
          if (obj-&gt;inherits&lt;JSDataView&gt;(vm))
              write(DataViewTag);
          else if (obj-&gt;inherits&lt;JSUint8ClampedArray&gt;(vm))
              write(Uint8ClampedArrayTag);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 827,22 ***</span>
          write(point.w());
      }
  
      void dumpDOMPoint(JSObject* obj)
      {
<span class="line-modified">!         VM&amp; vm = m_exec-&gt;vm();</span>
          if (obj-&gt;inherits&lt;JSDOMPoint&gt;(vm))
              write(DOMPointTag);
          else
              write(DOMPointReadOnlyTag);
  
          dumpDOMPoint(jsCast&lt;JSDOMPointReadOnly*&gt;(obj)-&gt;wrapped());
      }
  
      void dumpDOMRect(JSObject* obj)
      {
<span class="line-modified">!         VM&amp; vm = m_exec-&gt;vm();</span>
          if (obj-&gt;inherits&lt;JSDOMRect&gt;(vm))
              write(DOMRectTag);
          else
              write(DOMRectReadOnlyTag);
  
<span class="line-new-header">--- 852,22 ---</span>
          write(point.w());
      }
  
      void dumpDOMPoint(JSObject* obj)
      {
<span class="line-modified">!         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
          if (obj-&gt;inherits&lt;JSDOMPoint&gt;(vm))
              write(DOMPointTag);
          else
              write(DOMPointReadOnlyTag);
  
          dumpDOMPoint(jsCast&lt;JSDOMPointReadOnly*&gt;(obj)-&gt;wrapped());
      }
  
      void dumpDOMRect(JSObject* obj)
      {
<span class="line-modified">!         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
          if (obj-&gt;inherits&lt;JSDOMRect&gt;(vm))
              write(DOMRectTag);
          else
              write(DOMRectReadOnlyTag);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 853,11 ***</span>
          write(rect.height());
      }
  
      void dumpDOMMatrix(JSObject* obj)
      {
<span class="line-modified">!         VM&amp; vm = m_exec-&gt;vm();</span>
          if (obj-&gt;inherits&lt;JSDOMMatrix&gt;(vm))
              write(DOMMatrixTag);
          else
              write(DOMMatrixReadOnlyTag);
  
<span class="line-new-header">--- 878,11 ---</span>
          write(rect.height());
      }
  
      void dumpDOMMatrix(JSObject* obj)
      {
<span class="line-modified">!         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
          if (obj-&gt;inherits&lt;JSDOMMatrix&gt;(vm))
              write(DOMMatrixTag);
          else
              write(DOMMatrixReadOnlyTag);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 909,33 ***</span>
              write(ImageBitmapTransferTag);
              write(index-&gt;value);
              return;
          }
  
<span class="line-modified">!         // Copying ImageBitmaps is not yet supported.</span>
<span class="line-modified">!         code = SerializationReturnCode::ValidationError;</span>
      }
  
      bool dumpIfTerminal(JSValue value, SerializationReturnCode&amp; code)
      {
          if (!value.isCell()) {
              dumpImmediate(value);
              return true;
          }
          ASSERT(value.isCell());
  
          if (value.isString()) {
<span class="line-modified">!             dumpString(asString(value)-&gt;value(m_exec));</span>
              return true;
          }
  
          if (value.isSymbol()) {
              code = SerializationReturnCode::DataCloneError;
              return true;
          }
  
<span class="line-modified">!         VM&amp; vm = m_exec-&gt;vm();</span>
          if (isArray(vm, value))
              return false;
  
          if (value.isObject()) {
              auto* obj = asObject(value);
<span class="line-new-header">--- 934,74 ---</span>
              write(ImageBitmapTransferTag);
              write(index-&gt;value);
              return;
          }
  
<span class="line-modified">!         auto&amp; imageBitmap = jsCast&lt;JSImageBitmap*&gt;(obj)-&gt;wrapped();</span>
<span class="line-modified">!         auto* buffer = imageBitmap.buffer();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!buffer) {</span>
<span class="line-added">+             code = SerializationReturnCode::ValidationError;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         const IntSize&amp; logicalSize = buffer-&gt;logicalSize();</span>
<span class="line-added">+         auto imageData = buffer-&gt;getPremultipliedImageData(IntRect(0, 0, logicalSize.width(), logicalSize.height()));</span>
<span class="line-added">+         if (!imageData) {</span>
<span class="line-added">+             code = SerializationReturnCode::ValidationError;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = imageData-&gt;possiblySharedBuffer();</span>
<span class="line-added">+         if (!arrayBuffer) {</span>
<span class="line-added">+             code = SerializationReturnCode::ValidationError;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         write(ImageBitmapTag);</span>
<span class="line-added">+         write(static_cast&lt;uint8_t&gt;(imageBitmap.originClean()));</span>
<span class="line-added">+         write(static_cast&lt;int32_t&gt;(logicalSize.width()));</span>
<span class="line-added">+         write(static_cast&lt;int32_t&gt;(logicalSize.height()));</span>
<span class="line-added">+         write(static_cast&lt;double&gt;(buffer-&gt;resolutionScale()));</span>
<span class="line-added">+ </span>
<span class="line-added">+         write(static_cast&lt;uint32_t&gt;(arrayBuffer-&gt;byteLength()));</span>
<span class="line-added">+         write(static_cast&lt;const uint8_t*&gt;(arrayBuffer-&gt;data()), arrayBuffer-&gt;byteLength());</span>
      }
  
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+     void dumpOffscreenCanvas(JSObject* obj, SerializationReturnCode&amp; code)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         auto index = m_transferredOffscreenCanvases.find(obj);</span>
<span class="line-added">+         if (index != m_transferredOffscreenCanvases.end()) {</span>
<span class="line-added">+             write(OffscreenCanvasTransferTag);</span>
<span class="line-added">+             write(index-&gt;value);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         code = SerializationReturnCode::DataCloneError;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      bool dumpIfTerminal(JSValue value, SerializationReturnCode&amp; code)
      {
          if (!value.isCell()) {
              dumpImmediate(value);
              return true;
          }
          ASSERT(value.isCell());
  
          if (value.isString()) {
<span class="line-modified">!             dumpString(asString(value)-&gt;value(m_lexicalGlobalObject));</span>
              return true;
          }
  
          if (value.isSymbol()) {
              code = SerializationReturnCode::DataCloneError;
              return true;
          }
  
<span class="line-modified">!         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
          if (isArray(vm, value))
              return false;
  
          if (value.isObject()) {
              auto* obj = asObject(value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 945,17 ***</span>
                  return true;
              }
              if (auto* booleanObject = jsDynamicCast&lt;BooleanObject*&gt;(vm, obj)) {
                  if (!startObjectInternal(booleanObject)) // handle duplicates
                      return true;
<span class="line-modified">!                 write(booleanObject-&gt;internalValue().toBoolean(m_exec) ? TrueObjectTag : FalseObjectTag);</span>
                  return true;
              }
              if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, obj)) {
                  if (!startObjectInternal(stringObject)) // handle duplicates
                      return true;
<span class="line-modified">!                 String str = asString(stringObject-&gt;internalValue())-&gt;value(m_exec);</span>
                  dumpStringObject(str);
                  return true;
              }
              if (auto* numberObject = jsDynamicCast&lt;NumberObject*&gt;(vm, obj)) {
                  if (!startObjectInternal(numberObject)) // handle duplicates
<span class="line-new-header">--- 1011,17 ---</span>
                  return true;
              }
              if (auto* booleanObject = jsDynamicCast&lt;BooleanObject*&gt;(vm, obj)) {
                  if (!startObjectInternal(booleanObject)) // handle duplicates
                      return true;
<span class="line-modified">!                 write(booleanObject-&gt;internalValue().toBoolean(m_lexicalGlobalObject) ? TrueObjectTag : FalseObjectTag);</span>
                  return true;
              }
              if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, obj)) {
                  if (!startObjectInternal(stringObject)) // handle duplicates
                      return true;
<span class="line-modified">!                 String str = asString(stringObject-&gt;internalValue())-&gt;value(m_lexicalGlobalObject);</span>
                  dumpStringObject(str);
                  return true;
              }
              if (auto* numberObject = jsDynamicCast&lt;NumberObject*&gt;(vm, obj)) {
                  if (!startObjectInternal(numberObject)) // handle duplicates
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1063,18 ***</span>
                  Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
  #if ENABLE(WEBASSEMBLY)
                  WasmModuleArray dummyModules;
  #endif
                  ArrayBufferContentsArray dummySharedBuffers;
<span class="line-modified">!                 CloneSerializer rawKeySerializer(m_exec, dummyMessagePorts, dummyArrayBuffers, { },</span>
  #if ENABLE(WEBASSEMBLY)
                      dummyModules,
  #endif
                      dummyBlobURLs, serializedKey, SerializationContext::Default, dummySharedBuffers);
                  rawKeySerializer.write(key);
                  Vector&lt;uint8_t&gt; wrappedKey;
<span class="line-modified">!                 if (!wrapCryptoKey(m_exec, serializedKey, wrappedKey))</span>
                      return false;
                  write(wrappedKey);
                  return true;
              }
  #endif
<span class="line-new-header">--- 1129,21 ---</span>
                  Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
  #if ENABLE(WEBASSEMBLY)
                  WasmModuleArray dummyModules;
  #endif
                  ArrayBufferContentsArray dummySharedBuffers;
<span class="line-modified">!                 CloneSerializer rawKeySerializer(m_lexicalGlobalObject, dummyMessagePorts, dummyArrayBuffers, { },</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+                     { },</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
                      dummyModules,
  #endif
                      dummyBlobURLs, serializedKey, SerializationContext::Default, dummySharedBuffers);
                  rawKeySerializer.write(key);
                  Vector&lt;uint8_t&gt; wrappedKey;
<span class="line-modified">!                 if (!wrapCryptoKey(m_lexicalGlobalObject, serializedKey, wrappedKey))</span>
                      return false;
                  write(wrappedKey);
                  return true;
              }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1123,10 ***</span>
<span class="line-new-header">--- 1192,16 ---</span>
              }
              if (obj-&gt;inherits(vm, JSImageBitmap::info())) {
                  dumpImageBitmap(obj, code);
                  return true;
              }
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+             if (obj-&gt;inherits(vm, JSOffscreenCanvas::info())) {</span>
<span class="line-added">+                 dumpOffscreenCanvas(obj, code);</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ #endif</span>
              return false;
          }
          // Any other types are expected to serialize as null.
          write(NullTag);
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1257,11 ***</span>
      void write(const String&amp; str)
      {
          if (str.isNull())
              write(m_emptyIdentifier);
          else
<span class="line-modified">!             write(Identifier::fromString(m_exec-&gt;vm(), str));</span>
      }
  
      void write(const Vector&lt;uint8_t&gt;&amp; vector)
      {
          uint32_t size = vector.size();
<span class="line-new-header">--- 1332,11 ---</span>
      void write(const String&amp; str)
      {
          if (str.isNull())
              write(m_emptyIdentifier);
          else
<span class="line-modified">!             write(Identifier::fromString(m_lexicalGlobalObject-&gt;vm(), str));</span>
      }
  
      void write(const Vector&lt;uint8_t&gt;&amp; vector)
      {
          uint32_t size = vector.size();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1470,10 ***</span>
<span class="line-new-header">--- 1545,13 ---</span>
      Vector&lt;String&gt;&amp; m_blobURLs;
      ObjectPool m_objectPool;
      ObjectPool m_transferredMessagePorts;
      ObjectPool m_transferredArrayBuffers;
      ObjectPool m_transferredImageBitmaps;
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+     ObjectPool m_transferredOffscreenCanvases;</span>
<span class="line-added">+ #endif</span>
      typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, uint32_t, IdentifierRepHash&gt; StringConstantPool;
      StringConstantPool m_constantPool;
      Identifier m_emptyIdentifier;
      SerializationContext m_context;
      ArrayBufferContentsArray&amp; m_sharedBuffers;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1482,23 ***</span>
  #endif
  };
  
  SerializationReturnCode CloneSerializer::serialize(JSValue in)
  {
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      Vector&lt;uint32_t, 16&gt; indexStack;
      Vector&lt;uint32_t, 16&gt; lengthStack;
      Vector&lt;PropertyNameArray, 16&gt; propertyStack;
      Vector&lt;JSObject*, 32&gt; inputObjectStack;
      Vector&lt;JSMapIterator*, 4&gt; mapIteratorStack;
      Vector&lt;JSSetIterator*, 4&gt; setIteratorStack;
      Vector&lt;JSValue, 4&gt; mapIteratorValueStack;
      Vector&lt;WalkerState, 16&gt; stateStack;
<span class="line-modified">!     WalkerState state = StateUnknown;</span>
      JSValue inValue = in;
      while (1) {
<span class="line-modified">!         switch (state) {</span>
              arrayStartState:
              case ArrayStartState: {
                  ASSERT(isArray(vm, inValue));
                  if (inputObjectStack.size() &gt; maximumFilterRecursion)
                      return SerializationReturnCode::StackOverflowError;
<span class="line-new-header">--- 1560,23 ---</span>
  #endif
  };
  
  SerializationReturnCode CloneSerializer::serialize(JSValue in)
  {
<span class="line-modified">!     VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
      Vector&lt;uint32_t, 16&gt; indexStack;
      Vector&lt;uint32_t, 16&gt; lengthStack;
      Vector&lt;PropertyNameArray, 16&gt; propertyStack;
      Vector&lt;JSObject*, 32&gt; inputObjectStack;
      Vector&lt;JSMapIterator*, 4&gt; mapIteratorStack;
      Vector&lt;JSSetIterator*, 4&gt; setIteratorStack;
      Vector&lt;JSValue, 4&gt; mapIteratorValueStack;
      Vector&lt;WalkerState, 16&gt; stateStack;
<span class="line-modified">!     WalkerState lexicalGlobalObject = StateUnknown;</span>
      JSValue inValue = in;
      while (1) {
<span class="line-modified">!         switch (lexicalGlobalObject) {</span>
              arrayStartState:
              case ArrayStartState: {
                  ASSERT(isArray(vm, inValue));
                  if (inputObjectStack.size() &gt; maximumFilterRecursion)
                      return SerializationReturnCode::StackOverflowError;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1519,11 ***</span>
                  if (index == lengthStack.last()) {
                      indexStack.removeLast();
                      lengthStack.removeLast();
  
                      propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">!                     array-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(array, m_exec, propertyStack.last(), EnumerationMode());</span>
                      if (propertyStack.last().size()) {
                          write(NonIndexPropertiesTag);
                          indexStack.append(0);
                          goto objectStartVisitMember;
                      }
<span class="line-new-header">--- 1597,11 ---</span>
                  if (index == lengthStack.last()) {
                      indexStack.removeLast();
                      lengthStack.removeLast();
  
                      propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">!                     array-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(array, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());</span>
                      if (propertyStack.last().size()) {
                          write(NonIndexPropertiesTag);
                          indexStack.append(0);
                          goto objectStartVisitMember;
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1531,11 ***</span>
  
                      endObject();
                      inputObjectStack.removeLast();
                      break;
                  }
<span class="line-modified">!                 inValue = array-&gt;getDirectIndex(m_exec, index);</span>
                  if (!inValue) {
                      indexStack.last()++;
                      goto arrayStartVisitMember;
                  }
  
<span class="line-new-header">--- 1609,11 ---</span>
  
                      endObject();
                      inputObjectStack.removeLast();
                      break;
                  }
<span class="line-modified">!                 inValue = array-&gt;getDirectIndex(m_lexicalGlobalObject, index);</span>
                  if (!inValue) {
                      indexStack.last()++;
                      goto arrayStartVisitMember;
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1569,11 ***</span>
                  if (inObject-&gt;classInfo(vm) != JSFinalObject::info())
                      return SerializationReturnCode::DataCloneError;
                  inputObjectStack.append(inObject);
                  indexStack.append(0);
                  propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">!                 inObject-&gt;methodTable(vm)-&gt;getOwnPropertyNames(inObject, m_exec, propertyStack.last(), EnumerationMode());</span>
              }
              objectStartVisitMember:
              FALLTHROUGH;
              case ObjectStartVisitMember: {
                  JSObject* object = inputObjectStack.last();
<span class="line-new-header">--- 1647,11 ---</span>
                  if (inObject-&gt;classInfo(vm) != JSFinalObject::info())
                      return SerializationReturnCode::DataCloneError;
                  inputObjectStack.append(inObject);
                  indexStack.append(0);
                  propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">!                 inObject-&gt;methodTable(vm)-&gt;getOwnPropertyNames(inObject, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());</span>
              }
              objectStartVisitMember:
              FALLTHROUGH;
              case ObjectStartVisitMember: {
                  JSObject* object = inputObjectStack.last();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1621,27 ***</span>
                  if (inputObjectStack.size() &gt; maximumFilterRecursion)
                      return SerializationReturnCode::StackOverflowError;
                  JSMap* inMap = jsCast&lt;JSMap*&gt;(inValue);
                  if (!startMap(inMap))
                      break;
<span class="line-modified">!                 JSMapIterator* iterator = JSMapIterator::create(vm, vm.mapIteratorStructure(), inMap, IterateKeyValue);</span>
                  m_gcBuffer.appendWithCrashOnOverflow(inMap);
                  m_gcBuffer.appendWithCrashOnOverflow(iterator);
                  mapIteratorStack.append(iterator);
                  inputObjectStack.append(inMap);
                  goto mapDataStartVisitEntry;
              }
              mapDataStartVisitEntry:
              case MapDataStartVisitEntry: {
                  JSMapIterator* iterator = mapIteratorStack.last();
                  JSValue key, value;
<span class="line-modified">!                 if (!iterator-&gt;nextKeyValue(m_exec, key, value)) {</span>
                      mapIteratorStack.removeLast();
                      JSObject* object = inputObjectStack.last();
                      ASSERT(jsDynamicCast&lt;JSMap*&gt;(vm, object));
                      propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">!                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());</span>
                      write(NonMapPropertiesTag);
                      indexStack.append(0);
                      goto objectStartVisitMember;
                  }
                  inValue = key;
<span class="line-new-header">--- 1699,27 ---</span>
                  if (inputObjectStack.size() &gt; maximumFilterRecursion)
                      return SerializationReturnCode::StackOverflowError;
                  JSMap* inMap = jsCast&lt;JSMap*&gt;(inValue);
                  if (!startMap(inMap))
                      break;
<span class="line-modified">!                 JSMapIterator* iterator = JSMapIterator::create(vm, vm.mapIteratorStructure(), inMap, IterationKind::Entries);</span>
                  m_gcBuffer.appendWithCrashOnOverflow(inMap);
                  m_gcBuffer.appendWithCrashOnOverflow(iterator);
                  mapIteratorStack.append(iterator);
                  inputObjectStack.append(inMap);
                  goto mapDataStartVisitEntry;
              }
              mapDataStartVisitEntry:
              case MapDataStartVisitEntry: {
                  JSMapIterator* iterator = mapIteratorStack.last();
                  JSValue key, value;
<span class="line-modified">!                 if (!iterator-&gt;nextKeyValue(m_lexicalGlobalObject, key, value)) {</span>
                      mapIteratorStack.removeLast();
                      JSObject* object = inputObjectStack.last();
                      ASSERT(jsDynamicCast&lt;JSMap*&gt;(vm, object));
                      propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">!                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());</span>
                      write(NonMapPropertiesTag);
                      indexStack.append(0);
                      goto objectStartVisitMember;
                  }
                  inValue = key;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1665,27 ***</span>
                  if (inputObjectStack.size() &gt; maximumFilterRecursion)
                      return SerializationReturnCode::StackOverflowError;
                  JSSet* inSet = jsCast&lt;JSSet*&gt;(inValue);
                  if (!startSet(inSet))
                      break;
<span class="line-modified">!                 JSSetIterator* iterator = JSSetIterator::create(vm, vm.setIteratorStructure(), inSet, IterateKey);</span>
                  m_gcBuffer.appendWithCrashOnOverflow(inSet);
                  m_gcBuffer.appendWithCrashOnOverflow(iterator);
                  setIteratorStack.append(iterator);
                  inputObjectStack.append(inSet);
                  goto setDataStartVisitEntry;
              }
              setDataStartVisitEntry:
              case SetDataStartVisitEntry: {
                  JSSetIterator* iterator = setIteratorStack.last();
                  JSValue key;
<span class="line-modified">!                 if (!iterator-&gt;next(m_exec, key)) {</span>
                      setIteratorStack.removeLast();
                      JSObject* object = inputObjectStack.last();
                      ASSERT(jsDynamicCast&lt;JSSet*&gt;(vm, object));
                      propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">!                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());</span>
                      write(NonSetPropertiesTag);
                      indexStack.append(0);
                      goto objectStartVisitMember;
                  }
                  inValue = key;
<span class="line-new-header">--- 1743,27 ---</span>
                  if (inputObjectStack.size() &gt; maximumFilterRecursion)
                      return SerializationReturnCode::StackOverflowError;
                  JSSet* inSet = jsCast&lt;JSSet*&gt;(inValue);
                  if (!startSet(inSet))
                      break;
<span class="line-modified">!                 JSSetIterator* iterator = JSSetIterator::create(vm, vm.setIteratorStructure(), inSet, IterationKind::Keys);</span>
                  m_gcBuffer.appendWithCrashOnOverflow(inSet);
                  m_gcBuffer.appendWithCrashOnOverflow(iterator);
                  setIteratorStack.append(iterator);
                  inputObjectStack.append(inSet);
                  goto setDataStartVisitEntry;
              }
              setDataStartVisitEntry:
              case SetDataStartVisitEntry: {
                  JSSetIterator* iterator = setIteratorStack.last();
                  JSValue key;
<span class="line-modified">!                 if (!iterator-&gt;next(m_lexicalGlobalObject, key)) {</span>
                      setIteratorStack.removeLast();
                      JSObject* object = inputObjectStack.last();
                      ASSERT(jsDynamicCast&lt;JSSet*&gt;(vm, object));
                      propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">!                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());</span>
                      write(NonSetPropertiesTag);
                      indexStack.append(0);
                      goto objectStartVisitMember;
                  }
                  inValue = key;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1715,11 ***</span>
              }
          }
          if (stateStack.isEmpty())
              break;
  
<span class="line-modified">!         state = stateStack.last();</span>
          stateStack.removeLast();
      }
      if (m_failed)
          return SerializationReturnCode::UnspecifiedError;
  
<span class="line-new-header">--- 1793,11 ---</span>
              }
          }
          if (stateStack.isEmpty())
              break;
  
<span class="line-modified">!         lexicalGlobalObject = stateStack.last();</span>
          stateStack.removeLast();
      }
      if (m_failed)
          return SerializationReturnCode::UnspecifiedError;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1749,19 ***</span>
          if (!readString(ptr, end, str, length, is8Bit))
              return String();
          return str;
      }
  
<span class="line-modified">!     static DeserializationResult deserialize(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers, ArrayBufferContentsArray* arrayBufferContentsArray, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers</span>
  #if ENABLE(WEBASSEMBLY)
          , WasmModuleArray* wasmModules
  #endif
          )
      {
          if (!buffer.size())
              return std::make_pair(jsNull(), SerializationReturnCode::UnspecifiedError);
<span class="line-modified">!         CloneDeserializer deserializer(exec, globalObject, messagePorts, arrayBufferContentsArray, buffer, blobURLs, blobFilePaths, sharedBuffers, WTFMove(imageBuffers)</span>
  #if ENABLE(WEBASSEMBLY)
              , wasmModules
  #endif
              );
          if (!deserializer.isValid())
<span class="line-new-header">--- 1827,26 ---</span>
          if (!readString(ptr, end, str, length, is8Bit))
              return String();
          return str;
      }
  
<span class="line-modified">!     static DeserializationResult deserialize(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+         , Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt;&amp;&amp; detachedOffscreenCanvases</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         , ArrayBufferContentsArray* arrayBufferContentsArray, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers</span>
  #if ENABLE(WEBASSEMBLY)
          , WasmModuleArray* wasmModules
  #endif
          )
      {
          if (!buffer.size())
              return std::make_pair(jsNull(), SerializationReturnCode::UnspecifiedError);
<span class="line-modified">!         CloneDeserializer deserializer(lexicalGlobalObject, globalObject, messagePorts, arrayBufferContentsArray, buffer, blobURLs, blobFilePaths, sharedBuffers, WTFMove(imageBuffers)</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+             , WTFMove(detachedOffscreenCanvases)</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
              , wasmModules
  #endif
              );
          if (!deserializer.isValid())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1774,14 ***</span>
          CachedString(const String&amp; string)
              : m_string(string)
          {
          }
  
<span class="line-modified">!         JSValue jsString(ExecState* exec)</span>
          {
              if (!m_jsString)
<span class="line-modified">!                 m_jsString = JSC::jsString(exec-&gt;vm(), m_string);</span>
              return m_jsString;
          }
          const String&amp; string() { return m_string; }
          String takeString() { return WTFMove(m_string); }
  
<span class="line-new-header">--- 1859,14 ---</span>
          CachedString(const String&amp; string)
              : m_string(string)
          {
          }
  
<span class="line-modified">!         JSValue jsString(JSGlobalObject* lexicalGlobalObject)</span>
          {
              if (!m_jsString)
<span class="line-modified">!                 m_jsString = JSC::jsString(lexicalGlobalObject-&gt;vm(), m_string);</span>
              return m_jsString;
          }
          const String&amp; string() { return m_string; }
          String takeString() { return WTFMove(m_string); }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1807,40 ***</span>
      private:
          Vector&lt;CachedString&gt;* m_base;
          size_t m_index;
      };
  
<span class="line-modified">!     CloneDeserializer(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers,</span>
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">!         WasmModuleArray* wasmModules,</span>
  #endif
<span class="line-modified">!         const Vector&lt;uint8_t&gt;&amp; buffer)</span>
<span class="line-modified">!         : CloneBase(exec)</span>
          , m_globalObject(globalObject)
          , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
          , m_ptr(buffer.data())
          , m_end(buffer.data() + buffer.size())
          , m_version(0xFFFFFFFF)
          , m_messagePorts(messagePorts)
          , m_arrayBufferContents(arrayBufferContents)
          , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
          , m_imageBuffers(WTFMove(imageBuffers))
          , m_imageBitmaps(m_imageBuffers.size())
  #if ENABLE(WEBASSEMBLY)
          , m_wasmModules(wasmModules)
  #endif
      {
          if (!read(m_version))
              m_version = 0xFFFFFFFF;
      }
  
<span class="line-modified">!     CloneDeserializer(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers</span>
  #if ENABLE(WEBASSEMBLY)
          , WasmModuleArray* wasmModules
  #endif
          )
<span class="line-modified">!         : CloneBase(exec)</span>
          , m_globalObject(globalObject)
          , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
          , m_ptr(buffer.data())
          , m_end(buffer.data() + buffer.size())
          , m_version(0xFFFFFFFF)
<span class="line-new-header">--- 1892,50 ---</span>
      private:
          Vector&lt;CachedString&gt;* m_base;
          size_t m_index;
      };
  
<span class="line-modified">!     CloneDeserializer(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers, const Vector&lt;uint8_t&gt;&amp; buffer</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+         , Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt;&amp;&amp; detachedOffscreenCanvases = { }</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">!         , WasmModuleArray* wasmModules = nullptr</span>
  #endif
<span class="line-modified">!         )</span>
<span class="line-modified">!         : CloneBase(lexicalGlobalObject)</span>
          , m_globalObject(globalObject)
          , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
          , m_ptr(buffer.data())
          , m_end(buffer.data() + buffer.size())
          , m_version(0xFFFFFFFF)
          , m_messagePorts(messagePorts)
          , m_arrayBufferContents(arrayBufferContents)
          , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
          , m_imageBuffers(WTFMove(imageBuffers))
          , m_imageBitmaps(m_imageBuffers.size())
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+         , m_detachedOffscreenCanvases(WTFMove(detachedOffscreenCanvases))</span>
<span class="line-added">+         , m_offscreenCanvases(m_detachedOffscreenCanvases.size())</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
          , m_wasmModules(wasmModules)
  #endif
      {
          if (!read(m_version))
              m_version = 0xFFFFFFFF;
      }
  
<span class="line-modified">!     CloneDeserializer(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+         , Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt;&amp;&amp; detachedOffscreenCanvases</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
          , WasmModuleArray* wasmModules
  #endif
          )
<span class="line-modified">!         : CloneBase(lexicalGlobalObject)</span>
          , m_globalObject(globalObject)
          , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
          , m_ptr(buffer.data())
          , m_end(buffer.data() + buffer.size())
          , m_version(0xFFFFFFFF)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1850,10 ***</span>
<span class="line-new-header">--- 1945,14 ---</span>
          , m_blobURLs(blobURLs)
          , m_blobFilePaths(blobFilePaths)
          , m_sharedBuffers(sharedBuffers)
          , m_imageBuffers(WTFMove(imageBuffers))
          , m_imageBitmaps(m_imageBuffers.size())
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+         , m_detachedOffscreenCanvases(WTFMove(detachedOffscreenCanvases))</span>
<span class="line-added">+         , m_offscreenCanvases(m_detachedOffscreenCanvases.size())</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
          , m_wasmModules(wasmModules)
  #endif
      {
          if (!read(m_version))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2054,16 ***</span>
          return true;
      }
  
      void putProperty(JSObject* object, unsigned index, JSValue value)
      {
<span class="line-modified">!         object-&gt;putDirectIndex(m_exec, index, value);</span>
      }
  
      void putProperty(JSObject* object, const Identifier&amp; property, JSValue value)
      {
<span class="line-modified">!         object-&gt;putDirectMayBeIndex(m_exec, property, value);</span>
      }
  
      bool readFile(RefPtr&lt;File&gt;&amp; file)
      {
          CachedStringRef path;
<span class="line-new-header">--- 2153,16 ---</span>
          return true;
      }
  
      void putProperty(JSObject* object, unsigned index, JSValue value)
      {
<span class="line-modified">!         object-&gt;putDirectIndex(m_lexicalGlobalObject, index, value);</span>
      }
  
      void putProperty(JSObject* object, const Identifier&amp; property, JSValue value)
      {
<span class="line-modified">!         object-&gt;putDirectMayBeIndex(m_lexicalGlobalObject, property, value);</span>
      }
  
      bool readFile(RefPtr&lt;File&gt;&amp; file)
      {
          CachedStringRef path;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2091,11 ***</span>
          String filePath = blobFilePathForBlobURL(url-&gt;string());
          if (filePath.isEmpty())
              filePath = path-&gt;string();
  
          if (m_isDOMGlobalObject)
<span class="line-modified">!             file = File::deserialize(jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject)-&gt;scriptExecutionContext()-&gt;sessionID(), filePath, URL(URL(), url-&gt;string()), type-&gt;string(), name-&gt;string(), optionalLastModified);</span>
          return true;
      }
  
      bool readArrayBuffer(RefPtr&lt;ArrayBuffer&gt;&amp; arrayBuffer)
      {
<span class="line-new-header">--- 2190,11 ---</span>
          String filePath = blobFilePathForBlobURL(url-&gt;string());
          if (filePath.isEmpty())
              filePath = path-&gt;string();
  
          if (m_isDOMGlobalObject)
<span class="line-modified">!             file = File::deserialize(filePath, URL(URL(), url-&gt;string()), type-&gt;string(), name-&gt;string(), optionalLastModified);</span>
          return true;
      }
  
      bool readArrayBuffer(RefPtr&lt;ArrayBuffer&gt;&amp; arrayBuffer)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2132,38 ***</span>
              return false;
  
          RefPtr&lt;ArrayBuffer&gt; arrayBuffer = toPossiblySharedArrayBuffer(vm, arrayBufferObj);
          switch (arrayBufferViewSubtag) {
          case DataViewTag:
<span class="line-modified">!             arrayBufferView = toJS(m_exec, m_globalObject, DataView::create(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Int8ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_exec, m_globalObject, Int8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Uint8ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_exec, m_globalObject, Uint8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Uint8ClampedArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_exec, m_globalObject, Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Int16ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_exec, m_globalObject, Int16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Uint16ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_exec, m_globalObject, Uint16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Int32ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_exec, m_globalObject, Int32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Uint32ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_exec, m_globalObject, Uint32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Float32ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_exec, m_globalObject, Float32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Float64ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_exec, m_globalObject, Float64Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          default:
              return false;
          }
      }
<span class="line-new-header">--- 2231,38 ---</span>
              return false;
  
          RefPtr&lt;ArrayBuffer&gt; arrayBuffer = toPossiblySharedArrayBuffer(vm, arrayBufferObj);
          switch (arrayBufferViewSubtag) {
          case DataViewTag:
<span class="line-modified">!             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, DataView::create(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Int8ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Int8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Uint8ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Uint8ClampedArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Int16ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Int16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Uint16ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Int32ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Int32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Uint32ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Float32ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Float32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          case Float64ArrayTag:
<span class="line-modified">!             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Float64Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
              return true;
          default:
              return false;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2315,11 ***</span>
          CryptoAlgorithmIdentifier algorithm;
          if (!read(algorithm))
              return false;
  
          int32_t isRestrictedToHash;
<span class="line-modified">!         CryptoAlgorithmIdentifier hash;</span>
          if (!read(isRestrictedToHash))
              return false;
          if (isRestrictedToHash &amp;&amp; !read(hash))
              return false;
  
<span class="line-new-header">--- 2414,11 ---</span>
          CryptoAlgorithmIdentifier algorithm;
          if (!read(algorithm))
              return false;
  
          int32_t isRestrictedToHash;
<span class="line-modified">!         CryptoAlgorithmIdentifier hash = CryptoAlgorithmIdentifier::SHA_1;</span>
          if (!read(isRestrictedToHash))
              return false;
          if (isRestrictedToHash &amp;&amp; !read(hash))
              return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2508,17 ***</span>
  #endif
  
      template&lt;class T&gt;
      JSValue getJSValue(T* nativeObj)
      {
<span class="line-modified">!         return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);</span>
      }
  
      template&lt;class T&gt;
      JSValue getJSValue(T&amp; nativeObj)
      {
<span class="line-modified">!         return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);</span>
      }
  
      template&lt;class T&gt;
      JSValue readDOMPoint()
      {
<span class="line-new-header">--- 2607,17 ---</span>
  #endif
  
      template&lt;class T&gt;
      JSValue getJSValue(T* nativeObj)
      {
<span class="line-modified">!         return toJS(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);</span>
      }
  
      template&lt;class T&gt;
      JSValue getJSValue(T&amp; nativeObj)
      {
<span class="line-modified">!         return toJS(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);</span>
      }
  
      template&lt;class T&gt;
      JSValue readDOMPoint()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2533,11 ***</span>
              return { };
          double w;
          if (!read(w))
              return { };
  
<span class="line-modified">!         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, z, w));</span>
      }
  
      template&lt;class T&gt;
      JSValue readDOMMatrix()
      {
<span class="line-new-header">--- 2632,11 ---</span>
              return { };
          double w;
          if (!read(w))
              return { };
  
<span class="line-modified">!         return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, z, w));</span>
      }
  
      template&lt;class T&gt;
      JSValue readDOMMatrix()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2564,11 ***</span>
              double m42;
              if (!read(m42))
                  return { };
  
              TransformationMatrix matrix(m11, m12, m21, m22, m41, m42);
<span class="line-modified">!             return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::Yes));</span>
          } else {
              double m11;
              if (!read(m11))
                  return { };
              double m12;
<span class="line-new-header">--- 2663,11 ---</span>
              double m42;
              if (!read(m42))
                  return { };
  
              TransformationMatrix matrix(m11, m12, m21, m22, m41, m42);
<span class="line-modified">!             return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::Yes));</span>
          } else {
              double m11;
              if (!read(m11))
                  return { };
              double m12;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2616,11 ***</span>
              double m44;
              if (!read(m44))
                  return { };
  
              TransformationMatrix matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
<span class="line-modified">!             return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::No));</span>
          }
      }
  
      template&lt;class T&gt;
      JSValue readDOMRect()
<span class="line-new-header">--- 2715,11 ---</span>
              double m44;
              if (!read(m44))
                  return { };
  
              TransformationMatrix matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
<span class="line-modified">!             return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::No));</span>
          }
      }
  
      template&lt;class T&gt;
      JSValue readDOMRect()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2636,11 ***</span>
              return { };
          double height;
          if (!read(height))
              return { };
  
<span class="line-modified">!         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, width, height));</span>
      }
  
      Optional&lt;DOMPointInit&gt; readDOMPointInit()
      {
          DOMPointInit point;
<span class="line-new-header">--- 2735,11 ---</span>
              return { };
          double height;
          if (!read(height))
              return { };
  
<span class="line-modified">!         return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, width, height));</span>
      }
  
      Optional&lt;DOMPointInit&gt; readDOMPointInit()
      {
          DOMPointInit point;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2669,14 ***</span>
              return JSValue();
          auto p4 = readDOMPointInit();
          if (!p4)
              return JSValue();
  
<span class="line-modified">!         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), DOMQuad::create(p1.value(), p2.value(), p3.value(), p4.value()));</span>
      }
  
<span class="line-modified">!     JSValue readImageBitmap()</span>
      {
          uint32_t index;
          bool indexSuccessfullyRead = read(index);
          if (!indexSuccessfullyRead || index &gt;= m_imageBuffers.size()) {
              fail();
<span class="line-new-header">--- 2768,14 ---</span>
              return JSValue();
          auto p4 = readDOMPointInit();
          if (!p4)
              return JSValue();
  
<span class="line-modified">!         return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), DOMQuad::create(p1.value(), p2.value(), p3.value(), p4.value()));</span>
      }
  
<span class="line-modified">!     JSValue readTransferredImageBitmap()</span>
      {
          uint32_t index;
          bool indexSuccessfullyRead = read(index);
          if (!indexSuccessfullyRead || index &gt;= m_imageBuffers.size()) {
              fail();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2688,10 ***</span>
<span class="line-new-header">--- 2787,28 ---</span>
  
          auto bitmap = m_imageBitmaps[index].get();
          return getJSValue(bitmap);
      }
  
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+     JSValue readOffscreenCanvas()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         uint32_t index;</span>
<span class="line-added">+         bool indexSuccessfullyRead = read(index);</span>
<span class="line-added">+         if (!indexSuccessfullyRead || index &gt;= m_detachedOffscreenCanvases.size()) {</span>
<span class="line-added">+             fail();</span>
<span class="line-added">+             return JSValue();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!m_offscreenCanvases[index])</span>
<span class="line-added">+             m_offscreenCanvases[index] = OffscreenCanvas::create(*scriptExecutionContextFromExecState(m_lexicalGlobalObject), WTFMove(m_detachedOffscreenCanvases.at(index)));</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto offscreenCanvas = m_offscreenCanvases[index].get();</span>
<span class="line-added">+         return getJSValue(offscreenCanvas);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  #if ENABLE(WEB_RTC)
      JSValue readRTCCertificate()
      {
          double expires;
          if (!read(expires)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2728,17 ***</span>
                  return JSValue();
              fingerprints.uncheckedAppend(RTCCertificate::DtlsFingerprint { algorithm-&gt;string(), value-&gt;string() });
          }
  
          if (!m_isDOMGlobalObject)
<span class="line-modified">!             return constructEmptyObject(m_exec, m_globalObject-&gt;objectPrototype());</span>
  
          auto rtcCertificate = RTCCertificate::create(SecurityOrigin::createFromString(origin-&gt;string()), expires, WTFMove(fingerprints), certificate-&gt;takeString(), keyedMaterial-&gt;takeString());
<span class="line-modified">!         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), WTFMove(rtcCertificate));</span>
      }
  #endif
  
      JSValue readTerminal()
      {
          SerializationTag tag = readTag();
          switch (tag) {
          case UndefinedTag:
<span class="line-new-header">--- 2845,48 ---</span>
                  return JSValue();
              fingerprints.uncheckedAppend(RTCCertificate::DtlsFingerprint { algorithm-&gt;string(), value-&gt;string() });
          }
  
          if (!m_isDOMGlobalObject)
<span class="line-modified">!             return constructEmptyObject(m_lexicalGlobalObject, m_globalObject-&gt;objectPrototype());</span>
  
          auto rtcCertificate = RTCCertificate::create(SecurityOrigin::createFromString(origin-&gt;string()), expires, WTFMove(fingerprints), certificate-&gt;takeString(), keyedMaterial-&gt;takeString());
<span class="line-modified">!         return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), WTFMove(rtcCertificate));</span>
      }
  #endif
  
<span class="line-added">+     JSValue readImageBitmap()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         uint8_t originClean;</span>
<span class="line-added">+         int32_t logicalWidth;</span>
<span class="line-added">+         int32_t logicalHeight;</span>
<span class="line-added">+         double resolutionScale;</span>
<span class="line-added">+         RefPtr&lt;ArrayBuffer&gt; arrayBuffer;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!read(originClean) || !read(logicalWidth) || !read(logicalHeight) || !read(resolutionScale) || !readArrayBuffer(arrayBuffer)) {</span>
<span class="line-added">+             fail();</span>
<span class="line-added">+             return JSValue();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto imageData = Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), 0, arrayBuffer-&gt;byteLength());</span>
<span class="line-added">+         if (!imageData) {</span>
<span class="line-added">+             fail();</span>
<span class="line-added">+             return JSValue();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto buffer = ImageBuffer::create(FloatSize(logicalWidth, logicalHeight), RenderingMode::Unaccelerated, resolutionScale);</span>
<span class="line-added">+         if (!buffer) {</span>
<span class="line-added">+             fail();</span>
<span class="line-added">+             return JSValue();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         buffer-&gt;putByteArray(*imageData, AlphaPremultiplication::Premultiplied, IntSize(logicalWidth, logicalHeight), IntRect(0, 0, logicalWidth, logicalHeight), IntPoint());</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto bitmap = ImageBitmap::create({ WTFMove(buffer), static_cast&lt;bool&gt;(originClean) });</span>
<span class="line-added">+         return getJSValue(bitmap);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      JSValue readTerminal()
      {
          SerializationTag tag = readTag();
          switch (tag) {
          case UndefinedTag:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2758,18 ***</span>
          case FalseTag:
              return jsBoolean(false);
          case TrueTag:
              return jsBoolean(true);
          case FalseObjectTag: {
<span class="line-modified">!             BooleanObject* obj = BooleanObject::create(m_exec-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());</span>
<span class="line-modified">!             obj-&gt;setInternalValue(m_exec-&gt;vm(), jsBoolean(false));</span>
              m_gcBuffer.appendWithCrashOnOverflow(obj);
              return obj;
          }
          case TrueObjectTag: {
<span class="line-modified">!             BooleanObject* obj = BooleanObject::create(m_exec-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());</span>
<span class="line-modified">!             obj-&gt;setInternalValue(m_exec-&gt;vm(), jsBoolean(true));</span>
              m_gcBuffer.appendWithCrashOnOverflow(obj);
              return obj;
          }
          case DoubleTag: {
              double d;
<span class="line-new-header">--- 2906,18 ---</span>
          case FalseTag:
              return jsBoolean(false);
          case TrueTag:
              return jsBoolean(true);
          case FalseObjectTag: {
<span class="line-modified">!             BooleanObject* obj = BooleanObject::create(m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());</span>
<span class="line-modified">!             obj-&gt;setInternalValue(m_lexicalGlobalObject-&gt;vm(), jsBoolean(false));</span>
              m_gcBuffer.appendWithCrashOnOverflow(obj);
              return obj;
          }
          case TrueObjectTag: {
<span class="line-modified">!             BooleanObject* obj = BooleanObject::create(m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());</span>
<span class="line-modified">!             obj-&gt;setInternalValue(m_lexicalGlobalObject-&gt;vm(), jsBoolean(true));</span>
              m_gcBuffer.appendWithCrashOnOverflow(obj);
              return obj;
          }
          case DoubleTag: {
              double d;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2779,27 ***</span>
          }
          case NumberObjectTag: {
              double d;
              if (!read(d))
                  return JSValue();
<span class="line-modified">!             NumberObject* obj = constructNumber(m_exec, m_globalObject, jsNumber(d));</span>
              m_gcBuffer.appendWithCrashOnOverflow(obj);
              return obj;
          }
          case DateTag: {
              double d;
              if (!read(d))
                  return JSValue();
<span class="line-modified">!             return DateInstance::create(m_exec-&gt;vm(), m_globalObject-&gt;dateStructure(), d);</span>
          }
          case FileTag: {
              RefPtr&lt;File&gt; file;
              if (!readFile(file))
                  return JSValue();
              if (!m_isDOMGlobalObject)
                  return jsNull();
<span class="line-modified">!             return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), file.get());</span>
          }
          case FileListTag: {
              unsigned length = 0;
              if (!read(length))
                  return JSValue();
<span class="line-new-header">--- 2927,27 ---</span>
          }
          case NumberObjectTag: {
              double d;
              if (!read(d))
                  return JSValue();
<span class="line-modified">!             NumberObject* obj = constructNumber(m_globalObject, jsNumber(d));</span>
              m_gcBuffer.appendWithCrashOnOverflow(obj);
              return obj;
          }
          case DateTag: {
              double d;
              if (!read(d))
                  return JSValue();
<span class="line-modified">!             return DateInstance::create(m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;dateStructure(), d);</span>
          }
          case FileTag: {
              RefPtr&lt;File&gt; file;
              if (!readFile(file))
                  return JSValue();
              if (!m_isDOMGlobalObject)
                  return jsNull();
<span class="line-modified">!             return toJS(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), file.get());</span>
          }
          case FileListTag: {
              unsigned length = 0;
              if (!read(length))
                  return JSValue();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2857,30 ***</span>
              unsigned long long size = 0;
              if (!read(size))
                  return JSValue();
              if (!m_isDOMGlobalObject)
                  return jsNull();
<span class="line-modified">!             return getJSValue(Blob::deserialize(jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject)-&gt;scriptExecutionContext()-&gt;sessionID(), URL(URL(), url-&gt;string()), type-&gt;string(), size, blobFilePathForBlobURL(url-&gt;string())).get());</span>
          }
          case StringTag: {
              CachedStringRef cachedString;
              if (!readStringData(cachedString))
                  return JSValue();
<span class="line-modified">!             return cachedString-&gt;jsString(m_exec);</span>
          }
          case EmptyStringTag:
<span class="line-modified">!             return jsEmptyString(m_exec-&gt;vm());</span>
          case StringObjectTag: {
              CachedStringRef cachedString;
              if (!readStringData(cachedString))
                  return JSValue();
<span class="line-modified">!             StringObject* obj = constructString(m_exec-&gt;vm(), m_globalObject, cachedString-&gt;jsString(m_exec));</span>
              m_gcBuffer.appendWithCrashOnOverflow(obj);
              return obj;
          }
          case EmptyStringObjectTag: {
<span class="line-modified">!             VM&amp; vm = m_exec-&gt;vm();</span>
              StringObject* obj = constructString(vm, m_globalObject, jsEmptyString(vm));
              m_gcBuffer.appendWithCrashOnOverflow(obj);
              return obj;
          }
          case RegExpTag: {
<span class="line-new-header">--- 3005,30 ---</span>
              unsigned long long size = 0;
              if (!read(size))
                  return JSValue();
              if (!m_isDOMGlobalObject)
                  return jsNull();
<span class="line-modified">!             return getJSValue(Blob::deserialize(URL(URL(), url-&gt;string()), type-&gt;string(), size, blobFilePathForBlobURL(url-&gt;string())).get());</span>
          }
          case StringTag: {
              CachedStringRef cachedString;
              if (!readStringData(cachedString))
                  return JSValue();
<span class="line-modified">!             return cachedString-&gt;jsString(m_lexicalGlobalObject);</span>
          }
          case EmptyStringTag:
<span class="line-modified">!             return jsEmptyString(m_lexicalGlobalObject-&gt;vm());</span>
          case StringObjectTag: {
              CachedStringRef cachedString;
              if (!readStringData(cachedString))
                  return JSValue();
<span class="line-modified">!             StringObject* obj = constructString(m_lexicalGlobalObject-&gt;vm(), m_globalObject, cachedString-&gt;jsString(m_lexicalGlobalObject));</span>
              m_gcBuffer.appendWithCrashOnOverflow(obj);
              return obj;
          }
          case EmptyStringObjectTag: {
<span class="line-modified">!             VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
              StringObject* obj = constructString(vm, m_globalObject, jsEmptyString(vm));
              m_gcBuffer.appendWithCrashOnOverflow(obj);
              return obj;
          }
          case RegExpTag: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2890,11 ***</span>
              CachedStringRef flags;
              if (!readStringData(flags))
                  return JSValue();
              auto reFlags = Yarr::parseFlags(flags-&gt;string());
              ASSERT(reFlags.hasValue());
<span class="line-modified">!             VM&amp; vm = m_exec-&gt;vm();</span>
              RegExp* regExp = RegExp::create(vm, pattern-&gt;string(), reFlags.value());
              return RegExpObject::create(vm, m_globalObject-&gt;regExpStructure(), regExp);
          }
          case ObjectReferenceTag: {
              unsigned index = 0;
<span class="line-new-header">--- 3038,11 ---</span>
              CachedStringRef flags;
              if (!readStringData(flags))
                  return JSValue();
              auto reFlags = Yarr::parseFlags(flags-&gt;string());
              ASSERT(reFlags.hasValue());
<span class="line-modified">!             VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
              RegExp* regExp = RegExp::create(vm, pattern-&gt;string(), reFlags.value());
              return RegExpObject::create(vm, m_globalObject-&gt;regExpStructure(), regExp);
          }
          case ObjectReferenceTag: {
              unsigned index = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2919,12 ***</span>
              bool indexSuccessfullyRead = read(index);
              if (!indexSuccessfullyRead || !m_wasmModules || index &gt;= m_wasmModules-&gt;size()) {
                  fail();
                  return JSValue();
              }
<span class="line-modified">!             auto scope = DECLARE_THROW_SCOPE(m_exec-&gt;vm());</span>
<span class="line-modified">!             JSValue result = JSC::JSWebAssemblyModule::createStub(m_exec-&gt;vm(), m_exec, m_globalObject-&gt;webAssemblyModuleStructure(), m_wasmModules-&gt;at(index));</span>
              // Since we are cloning a JSWebAssemblyModule, it&#39;s impossible for that
              // module to not have been a valid module. Therefore, createStub should
              // not trow.
              scope.releaseAssertNoException();
              m_gcBuffer.appendWithCrashOnOverflow(result);
<span class="line-new-header">--- 3067,12 ---</span>
              bool indexSuccessfullyRead = read(index);
              if (!indexSuccessfullyRead || !m_wasmModules || index &gt;= m_wasmModules-&gt;size()) {
                  fail();
                  return JSValue();
              }
<span class="line-modified">!             auto scope = DECLARE_THROW_SCOPE(m_lexicalGlobalObject-&gt;vm());</span>
<span class="line-modified">!             JSValue result = JSC::JSWebAssemblyModule::createStub(m_lexicalGlobalObject-&gt;vm(), m_lexicalGlobalObject, m_globalObject-&gt;webAssemblyModuleStructure(), m_wasmModules-&gt;at(index));</span>
              // Since we are cloning a JSWebAssemblyModule, it&#39;s impossible for that
              // module to not have been a valid module. Therefore, createStub should
              // not trow.
              scope.releaseAssertNoException();
              m_gcBuffer.appendWithCrashOnOverflow(result);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2942,11 ***</span>
              // array buffers while the sender is. In that case, we would see a null structure here.
              if (!structure) {
                  fail();
                  return JSValue();
              }
<span class="line-modified">!             JSValue result = JSArrayBuffer::create(m_exec-&gt;vm(), structure, WTFMove(arrayBuffer));</span>
              m_gcBuffer.appendWithCrashOnOverflow(result);
              return result;
          }
          case ArrayBufferTransferTag: {
              uint32_t index;
<span class="line-new-header">--- 3090,11 ---</span>
              // array buffers while the sender is. In that case, we would see a null structure here.
              if (!structure) {
                  fail();
                  return JSValue();
              }
<span class="line-modified">!             JSValue result = JSArrayBuffer::create(m_lexicalGlobalObject-&gt;vm(), structure, WTFMove(arrayBuffer));</span>
              m_gcBuffer.appendWithCrashOnOverflow(result);
              return result;
          }
          case ArrayBufferTransferTag: {
              uint32_t index;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2975,11 ***</span>
              m_gcBuffer.appendWithCrashOnOverflow(result);
              return result;
          }
          case ArrayBufferViewTag: {
              JSValue arrayBufferView;
<span class="line-modified">!             if (!readArrayBufferView(m_exec-&gt;vm(), arrayBufferView)) {</span>
                  fail();
                  return JSValue();
              }
              m_gcBuffer.appendWithCrashOnOverflow(arrayBufferView);
              return arrayBufferView;
<span class="line-new-header">--- 3123,11 ---</span>
              m_gcBuffer.appendWithCrashOnOverflow(result);
              return result;
          }
          case ArrayBufferViewTag: {
              JSValue arrayBufferView;
<span class="line-modified">!             if (!readArrayBufferView(m_lexicalGlobalObject-&gt;vm(), arrayBufferView)) {</span>
                  fail();
                  return JSValue();
              }
              m_gcBuffer.appendWithCrashOnOverflow(arrayBufferView);
              return arrayBufferView;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2990,21 ***</span>
              if (!read(wrappedKey)) {
                  fail();
                  return JSValue();
              }
              Vector&lt;uint8_t&gt; serializedKey;
<span class="line-modified">!             if (!unwrapCryptoKey(m_exec, wrappedKey, serializedKey)) {</span>
                  fail();
                  return JSValue();
              }
              JSValue cryptoKey;
              Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
<span class="line-modified">!             CloneDeserializer rawKeyDeserializer(m_exec, m_globalObject, dummyMessagePorts, nullptr, { },</span>
<span class="line-removed">- #if ENABLE(WEBASSEMBLY)</span>
<span class="line-removed">-                 nullptr,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-                 serializedKey);</span>
              if (!rawKeyDeserializer.readCryptoKey(cryptoKey)) {
                  fail();
                  return JSValue();
              }
              m_gcBuffer.appendWithCrashOnOverflow(cryptoKey);
<span class="line-new-header">--- 3138,17 ---</span>
              if (!read(wrappedKey)) {
                  fail();
                  return JSValue();
              }
              Vector&lt;uint8_t&gt; serializedKey;
<span class="line-modified">!             if (!unwrapCryptoKey(m_lexicalGlobalObject, wrappedKey, serializedKey)) {</span>
                  fail();
                  return JSValue();
              }
              JSValue cryptoKey;
              Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
<span class="line-modified">!             CloneDeserializer rawKeyDeserializer(m_lexicalGlobalObject, m_globalObject, dummyMessagePorts, nullptr, { }, serializedKey);</span>
              if (!rawKeyDeserializer.readCryptoKey(cryptoKey)) {
                  fail();
                  return JSValue();
              }
              m_gcBuffer.appendWithCrashOnOverflow(cryptoKey);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3024,15 ***</span>
          case DOMMatrixTag:
              return readDOMMatrix&lt;DOMMatrix&gt;();
          case DOMQuadTag:
              return readDOMQuad();
          case ImageBitmapTransferTag:
<span class="line-modified">!             return readImageBitmap();</span>
  #if ENABLE(WEB_RTC)
          case RTCCertificateTag:
              return readRTCCertificate();
  
  #endif
          default:
              m_ptr--; // Push the tag back
              return JSValue();
          }
<span class="line-new-header">--- 3168,21 ---</span>
          case DOMMatrixTag:
              return readDOMMatrix&lt;DOMMatrix&gt;();
          case DOMQuadTag:
              return readDOMQuad();
          case ImageBitmapTransferTag:
<span class="line-modified">!             return readTransferredImageBitmap();</span>
  #if ENABLE(WEB_RTC)
          case RTCCertificateTag:
              return readRTCCertificate();
  
<span class="line-added">+ #endif</span>
<span class="line-added">+         case ImageBitmapTag:</span>
<span class="line-added">+             return readImageBitmap();</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+         case OffscreenCanvasTransferTag:</span>
<span class="line-added">+             return readOffscreenCanvas();</span>
  #endif
          default:
              m_ptr--; // Push the tag back
              return JSValue();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3059,10 ***</span>
<span class="line-new-header">--- 3209,14 ---</span>
      Vector&lt;String&gt; m_blobURLs;
      Vector&lt;String&gt; m_blobFilePaths;
      ArrayBufferContentsArray* m_sharedBuffers;
      Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt; m_imageBuffers;
      Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; m_imageBitmaps;
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+     Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt; m_detachedOffscreenCanvases;</span>
<span class="line-added">+     Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt; m_offscreenCanvases;</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
      WasmModuleArray* m_wasmModules;
  #endif
  
      String blobFilePathForBlobURL(const String&amp; blobURL)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3077,33 ***</span>
      }
  };
  
  DeserializationResult CloneDeserializer::deserialize()
  {
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Vector&lt;uint32_t, 16&gt; indexStack;
      Vector&lt;Identifier, 16&gt; propertyNameStack;
      Vector&lt;JSObject*, 32&gt; outputObjectStack;
      Vector&lt;JSValue, 4&gt; mapKeyStack;
      Vector&lt;JSMap*, 4&gt; mapStack;
      Vector&lt;JSSet*, 4&gt; setStack;
      Vector&lt;WalkerState, 16&gt; stateStack;
<span class="line-modified">!     WalkerState state = StateUnknown;</span>
      JSValue outValue;
  
      while (1) {
<span class="line-modified">!         switch (state) {</span>
          arrayStartState:
          case ArrayStartState: {
              uint32_t length;
              if (!read(length)) {
                  fail();
                  goto error;
              }
<span class="line-modified">!             JSArray* outArray = constructEmptyArray(m_exec, 0, m_globalObject, length);</span>
              if (UNLIKELY(scope.exception()))
                  goto error;
              m_gcBuffer.appendWithCrashOnOverflow(outArray);
              outputObjectStack.append(outArray);
          }
<span class="line-new-header">--- 3231,33 ---</span>
      }
  };
  
  DeserializationResult CloneDeserializer::deserialize()
  {
<span class="line-modified">!     VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Vector&lt;uint32_t, 16&gt; indexStack;
      Vector&lt;Identifier, 16&gt; propertyNameStack;
      Vector&lt;JSObject*, 32&gt; outputObjectStack;
      Vector&lt;JSValue, 4&gt; mapKeyStack;
      Vector&lt;JSMap*, 4&gt; mapStack;
      Vector&lt;JSSet*, 4&gt; setStack;
      Vector&lt;WalkerState, 16&gt; stateStack;
<span class="line-modified">!     WalkerState lexicalGlobalObject = StateUnknown;</span>
      JSValue outValue;
  
      while (1) {
<span class="line-modified">!         switch (lexicalGlobalObject) {</span>
          arrayStartState:
          case ArrayStartState: {
              uint32_t length;
              if (!read(length)) {
                  fail();
                  goto error;
              }
<span class="line-modified">!             JSArray* outArray = constructEmptyArray(m_globalObject, static_cast&lt;JSC::ArrayAllocationProfile*&gt;(nullptr), length);</span>
              if (UNLIKELY(scope.exception()))
                  goto error;
              m_gcBuffer.appendWithCrashOnOverflow(outArray);
              outputObjectStack.append(outArray);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3142,11 ***</span>
          }
          objectStartState:
          case ObjectStartState: {
              if (outputObjectStack.size() &gt; maximumFilterRecursion)
                  return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
<span class="line-modified">!             JSObject* outObject = constructEmptyObject(m_exec, m_globalObject-&gt;objectPrototype());</span>
              m_gcBuffer.appendWithCrashOnOverflow(outObject);
              outputObjectStack.append(outObject);
          }
          objectStartVisitMember:
          FALLTHROUGH;
<span class="line-new-header">--- 3296,11 ---</span>
          }
          objectStartState:
          case ObjectStartState: {
              if (outputObjectStack.size() &gt; maximumFilterRecursion)
                  return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
<span class="line-modified">!             JSObject* outObject = constructEmptyObject(m_lexicalGlobalObject, m_globalObject-&gt;objectPrototype());</span>
              m_gcBuffer.appendWithCrashOnOverflow(outObject);
              outputObjectStack.append(outObject);
          }
          objectStartVisitMember:
          FALLTHROUGH;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3177,11 ***</span>
              goto objectStartVisitMember;
          }
          mapObjectStartState: {
              if (outputObjectStack.size() &gt; maximumFilterRecursion)
                  return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
<span class="line-modified">!             JSMap* map = JSMap::create(m_exec, m_exec-&gt;vm(), m_globalObject-&gt;mapStructure());</span>
              if (UNLIKELY(scope.exception()))
                  goto error;
              m_gcBuffer.appendWithCrashOnOverflow(map);
              outputObjectStack.append(map);
              mapStack.append(map);
<span class="line-new-header">--- 3331,11 ---</span>
              goto objectStartVisitMember;
          }
          mapObjectStartState: {
              if (outputObjectStack.size() &gt; maximumFilterRecursion)
                  return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
<span class="line-modified">!             JSMap* map = JSMap::create(m_lexicalGlobalObject, m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;mapStructure());</span>
              if (UNLIKELY(scope.exception()))
                  goto error;
              m_gcBuffer.appendWithCrashOnOverflow(map);
              outputObjectStack.append(map);
              mapStack.append(map);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3200,19 ***</span>
              mapKeyStack.append(outValue);
              stateStack.append(MapDataEndVisitValue);
              goto stateUnknown;
          }
          case MapDataEndVisitValue: {
<span class="line-modified">!             mapStack.last()-&gt;set(m_exec, mapKeyStack.last(), outValue);</span>
              mapKeyStack.removeLast();
              goto mapDataStartVisitEntry;
          }
  
          setObjectStartState: {
              if (outputObjectStack.size() &gt; maximumFilterRecursion)
                  return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
<span class="line-modified">!             JSSet* set = JSSet::create(m_exec, m_exec-&gt;vm(), m_globalObject-&gt;setStructure());</span>
              if (UNLIKELY(scope.exception()))
                  goto error;
              m_gcBuffer.appendWithCrashOnOverflow(set);
              outputObjectStack.append(set);
              setStack.append(set);
<span class="line-new-header">--- 3354,19 ---</span>
              mapKeyStack.append(outValue);
              stateStack.append(MapDataEndVisitValue);
              goto stateUnknown;
          }
          case MapDataEndVisitValue: {
<span class="line-modified">!             mapStack.last()-&gt;set(m_lexicalGlobalObject, mapKeyStack.last(), outValue);</span>
              mapKeyStack.removeLast();
              goto mapDataStartVisitEntry;
          }
  
          setObjectStartState: {
              if (outputObjectStack.size() &gt; maximumFilterRecursion)
                  return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
<span class="line-modified">!             JSSet* set = JSSet::create(m_lexicalGlobalObject, m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;setStructure());</span>
              if (UNLIKELY(scope.exception()))
                  goto error;
              m_gcBuffer.appendWithCrashOnOverflow(set);
              outputObjectStack.append(set);
              setStack.append(set);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3227,11 ***</span>
              stateStack.append(SetDataEndVisitKey);
              goto stateUnknown;
          }
          case SetDataEndVisitKey: {
              JSSet* set = setStack.last();
<span class="line-modified">!             set-&gt;add(m_exec, outValue);</span>
              goto setDataStartVisitEntry;
          }
  
          stateUnknown:
          case StateUnknown:
<span class="line-new-header">--- 3381,11 ---</span>
              stateStack.append(SetDataEndVisitKey);
              goto stateUnknown;
          }
          case SetDataEndVisitKey: {
              JSSet* set = setStack.last();
<span class="line-modified">!             set-&gt;add(m_lexicalGlobalObject, outValue);</span>
              goto setDataStartVisitEntry;
          }
  
          stateUnknown:
          case StateUnknown:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3251,11 ***</span>
              goto error;
          }
          if (stateStack.isEmpty())
              break;
  
<span class="line-modified">!         state = stateStack.last();</span>
          stateStack.removeLast();
      }
      ASSERT(outValue);
      ASSERT(!m_failed);
      return std::make_pair(outValue, SerializationReturnCode::SuccessfullyCompleted);
<span class="line-new-header">--- 3405,11 ---</span>
              goto error;
          }
          if (stateStack.isEmpty())
              break;
  
<span class="line-modified">!         lexicalGlobalObject = stateStack.last();</span>
          stateStack.removeLast();
      }
      ASSERT(outValue);
      ASSERT(!m_failed);
      return std::make_pair(outValue, SerializationReturnCode::SuccessfullyCompleted);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3276,18 ***</span>
<span class="line-new-header">--- 3430,24 ---</span>
      , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
  {
  }
  
  SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray, std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBufferContentsArray, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+         , Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt;&amp;&amp; detachedOffscreenCanvases</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
          , std::unique_ptr&lt;WasmModuleArray&gt; wasmModulesArray
  #endif
          )
      : m_data(WTFMove(buffer))
      , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
      , m_sharedBufferContentsArray(WTFMove(sharedBufferContentsArray))
      , m_imageBuffers(WTFMove(imageBuffers))
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+     , m_detachedOffscreenCanvases(WTFMove(detachedOffscreenCanvases))</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
      , m_wasmModulesArray(WTFMove(wasmModulesArray))
  #endif
  {
      // Since this SerializedScriptValue is meant to be passed between threads, its String data members
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3316,26 ***</span>
      }
  
      return contents;
  }
  
<span class="line-modified">! static void maybeThrowExceptionIfSerializationFailed(ExecState&amp; state, SerializationReturnCode code)</span>
  {
<span class="line-modified">!     auto&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      switch (code) {
      case SerializationReturnCode::SuccessfullyCompleted:
          break;
      case SerializationReturnCode::StackOverflowError:
<span class="line-modified">!         throwException(&amp;state, scope, createStackOverflowError(&amp;state));</span>
          break;
      case SerializationReturnCode::ValidationError:
<span class="line-modified">!         throwTypeError(&amp;state, scope, &quot;Unable to deserialize data.&quot;_s);</span>
          break;
      case SerializationReturnCode::DataCloneError:
<span class="line-modified">!         throwDataCloneError(state, scope);</span>
          break;
      case SerializationReturnCode::ExistingExceptionError:
      case SerializationReturnCode::UnspecifiedError:
          break;
      case SerializationReturnCode::InterruptedExecutionError:
<span class="line-new-header">--- 3476,26 ---</span>
      }
  
      return contents;
  }
  
<span class="line-modified">! static void maybeThrowExceptionIfSerializationFailed(JSGlobalObject&amp; lexicalGlobalObject, SerializationReturnCode code)</span>
  {
<span class="line-modified">!     auto&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      switch (code) {
      case SerializationReturnCode::SuccessfullyCompleted:
          break;
      case SerializationReturnCode::StackOverflowError:
<span class="line-modified">!         throwException(&amp;lexicalGlobalObject, scope, createStackOverflowError(&amp;lexicalGlobalObject));</span>
          break;
      case SerializationReturnCode::ValidationError:
<span class="line-modified">!         throwTypeError(&amp;lexicalGlobalObject, scope, &quot;Unable to deserialize data.&quot;_s);</span>
          break;
      case SerializationReturnCode::DataCloneError:
<span class="line-modified">!         throwDataCloneError(lexicalGlobalObject, scope);</span>
          break;
      case SerializationReturnCode::ExistingExceptionError:
      case SerializationReturnCode::UnspecifiedError:
          break;
      case SerializationReturnCode::InterruptedExecutionError:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3365,42 ***</span>
      }
      ASSERT_NOT_REACHED();
      return Exception { TypeError };
  }
  
<span class="line-modified">! RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(ExecState&amp; exec, JSValue value, SerializationErrorMode throwExceptions)</span>
  {
      Vector&lt;uint8_t&gt; buffer;
      Vector&lt;String&gt; blobURLs;
      Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
      Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; dummyImageBitmaps;
      Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
  #if ENABLE(WEBASSEMBLY)
      WasmModuleArray dummyModules;
  #endif
      ArrayBufferContentsArray dummySharedBuffers;
<span class="line-modified">!     auto code = CloneSerializer::serialize(&amp;exec, value, dummyMessagePorts, dummyArrayBuffers, dummyImageBitmaps,</span>
  #if ENABLE(WEBASSEMBLY)
          dummyModules,
  #endif
          blobURLs, buffer, SerializationContext::Default, dummySharedBuffers);
  
  #if ENABLE(WEBASSEMBLY)
      ASSERT_WITH_MESSAGE(dummyModules.isEmpty(), &quot;Wasm::Module serialization is only allowed in the postMessage context&quot;);
  #endif
  
      if (throwExceptions == SerializationErrorMode::Throwing)
<span class="line-modified">!         maybeThrowExceptionIfSerializationFailed(exec, code);</span>
  
      if (code != SerializationReturnCode::SuccessfullyCompleted)
          return nullptr;
  
<span class="line-modified">!     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, nullptr, nullptr, { }</span>
<span class="line-removed">- #if ENABLE(WEBASSEMBLY)</span>
<span class="line-removed">-         , nullptr</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-             ));</span>
  }
  
  static bool containsDuplicates(const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps)
  {
      HashSet&lt;ImageBitmap*&gt; visited;
<span class="line-new-header">--- 3525,44 ---</span>
      }
      ASSERT_NOT_REACHED();
      return Exception { TypeError };
  }
  
<span class="line-modified">! RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(JSGlobalObject&amp; lexicalGlobalObject, JSValue value, SerializationErrorMode throwExceptions)</span>
  {
      Vector&lt;uint8_t&gt; buffer;
      Vector&lt;String&gt; blobURLs;
      Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
      Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; dummyImageBitmaps;
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+     Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt; dummyOffscreenCanvases;</span>
<span class="line-added">+ #endif</span>
      Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
  #if ENABLE(WEBASSEMBLY)
      WasmModuleArray dummyModules;
  #endif
      ArrayBufferContentsArray dummySharedBuffers;
<span class="line-modified">!     auto code = CloneSerializer::serialize(&amp;lexicalGlobalObject, value, dummyMessagePorts, dummyArrayBuffers, dummyImageBitmaps,</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+         dummyOffscreenCanvases,</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
          dummyModules,
  #endif
          blobURLs, buffer, SerializationContext::Default, dummySharedBuffers);
  
  #if ENABLE(WEBASSEMBLY)
      ASSERT_WITH_MESSAGE(dummyModules.isEmpty(), &quot;Wasm::Module serialization is only allowed in the postMessage context&quot;);
  #endif
  
      if (throwExceptions == SerializationErrorMode::Throwing)
<span class="line-modified">!         maybeThrowExceptionIfSerializationFailed(lexicalGlobalObject, code);</span>
  
      if (code != SerializationReturnCode::SuccessfullyCompleted)
          return nullptr;
  
<span class="line-modified">!     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, nullptr, nullptr, { }));</span>
  }
  
  static bool containsDuplicates(const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps)
  {
      HashSet&lt;ImageBitmap*&gt; visited;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3409,22 ***</span>
              return true;
      }
      return false;
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;SerializedScriptValue&gt;&gt; SerializedScriptValue::create(ExecState&amp; state, JSValue value, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transferList, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationContext context)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; arrayBuffers;
      Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; imageBitmaps;
      for (auto&amp; transferable : transferList) {
          if (auto arrayBuffer = toPossiblySharedArrayBuffer(vm, transferable.get())) {
              if (arrayBuffer-&gt;isNeutered())
                  return Exception { DataCloneError };
              if (arrayBuffer-&gt;isLocked()) {
                  auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!                 throwVMTypeError(&amp;state, scope, errorMesasgeForTransfer(arrayBuffer));</span>
                  return Exception { ExistingExceptionError };
              }
              arrayBuffers.append(WTFMove(arrayBuffer));
              continue;
          }
<span class="line-new-header">--- 3571,40 ---</span>
              return true;
      }
      return false;
  }
  
<span class="line-modified">! #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+ static bool canOffscreenCanvasesDetach(const Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt;&amp; offscreenCanvases)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     HashSet&lt;OffscreenCanvas*&gt; visited;</span>
<span class="line-added">+     for (auto&amp; offscreenCanvas : offscreenCanvases) {</span>
<span class="line-added">+         if (!offscreenCanvas-&gt;canDetach())</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         // Check the return value of add, we should not encounter duplicates.</span>
<span class="line-added">+         if (!visited.add(offscreenCanvas.get()))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ ExceptionOr&lt;Ref&lt;SerializedScriptValue&gt;&gt; SerializedScriptValue::create(JSGlobalObject&amp; lexicalGlobalObject, JSValue value, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transferList, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationContext context)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; arrayBuffers;
      Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; imageBitmaps;
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+     Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt; offscreenCanvases;</span>
<span class="line-added">+ #endif</span>
      for (auto&amp; transferable : transferList) {
          if (auto arrayBuffer = toPossiblySharedArrayBuffer(vm, transferable.get())) {
              if (arrayBuffer-&gt;isNeutered())
                  return Exception { DataCloneError };
              if (arrayBuffer-&gt;isLocked()) {
                  auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!                 throwVMTypeError(&amp;lexicalGlobalObject, scope, errorMesasgeForTransfer(arrayBuffer));</span>
                  return Exception { ExistingExceptionError };
              }
              arrayBuffers.append(WTFMove(arrayBuffer));
              continue;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3440,23 ***</span>
  
              imageBitmaps.append(WTFMove(imageBitmap));
              continue;
          }
  
          return Exception { DataCloneError };
      }
  
      if (containsDuplicates(imageBitmaps))
          return Exception { DataCloneError };
  
      Vector&lt;uint8_t&gt; buffer;
      Vector&lt;String&gt; blobURLs;
  #if ENABLE(WEBASSEMBLY)
      WasmModuleArray wasmModules;
  #endif
      std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBuffers = makeUnique&lt;ArrayBufferContentsArray&gt;();
<span class="line-modified">!     auto code = CloneSerializer::serialize(&amp;state, value, messagePorts, arrayBuffers, imageBitmaps,</span>
  #if ENABLE(WEBASSEMBLY)
          wasmModules,
  #endif
          blobURLs, buffer, context, *sharedBuffers);
  
<span class="line-new-header">--- 3620,37 ---</span>
  
              imageBitmaps.append(WTFMove(imageBitmap));
              continue;
          }
  
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+         if (auto offscreenCanvas = JSOffscreenCanvas::toWrapped(vm, transferable.get())) {</span>
<span class="line-added">+             offscreenCanvases.append(WTFMove(offscreenCanvas));</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
          return Exception { DataCloneError };
      }
  
      if (containsDuplicates(imageBitmaps))
          return Exception { DataCloneError };
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+     if (!canOffscreenCanvasesDetach(offscreenCanvases))</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ #endif</span>
  
      Vector&lt;uint8_t&gt; buffer;
      Vector&lt;String&gt; blobURLs;
  #if ENABLE(WEBASSEMBLY)
      WasmModuleArray wasmModules;
  #endif
      std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBuffers = makeUnique&lt;ArrayBufferContentsArray&gt;();
<span class="line-modified">!     auto code = CloneSerializer::serialize(&amp;lexicalGlobalObject, value, messagePorts, arrayBuffers, imageBitmaps,</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+         offscreenCanvases,</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
          wasmModules,
  #endif
          blobURLs, buffer, context, *sharedBuffers);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3467,11 ***</span>
<span class="line-new-header">--- 3661,20 ---</span>
      if (arrayBufferContentsArray.hasException())
          return arrayBufferContentsArray.releaseException();
  
      auto imageBuffers = ImageBitmap::detachBitmaps(WTFMove(imageBitmaps));
  
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+     Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt; detachedCanvases;</span>
<span class="line-added">+     for (auto offscreenCanvas : offscreenCanvases)</span>
<span class="line-added">+         detachedCanvases.append(offscreenCanvas-&gt;detach());</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, arrayBufferContentsArray.releaseReturnValue(), context == SerializationContext::WorkerPostMessage ? WTFMove(sharedBuffers) : nullptr, WTFMove(imageBuffers)
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+                 , WTFMove(detachedCanvases)</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBASSEMBLY)
                  , makeUnique&lt;WasmModuleArray&gt;(wasmModules)
  #endif
                  ));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3484,20 ***</span>
      return adoptRef(*new SerializedScriptValue(WTFMove(buffer)));
  }
  
  RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(JSContextRef originContext, JSValueRef apiValue, JSValueRef* exception)
  {
<span class="line-modified">!     ExecState* exec = toJS(originContext);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     JSValue value = toJS(exec, apiValue);</span>
<span class="line-modified">!     auto serializedValue = SerializedScriptValue::create(*exec, value);</span>
      if (UNLIKELY(scope.exception())) {
          if (exception)
<span class="line-modified">!             *exception = toRef(exec, scope.exception()-&gt;value());</span>
          scope.clearException();
          return nullptr;
      }
      ASSERT(serializedValue);
      return serializedValue;
<span class="line-new-header">--- 3687,20 ---</span>
      return adoptRef(*new SerializedScriptValue(WTFMove(buffer)));
  }
  
  RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(JSContextRef originContext, JSValueRef apiValue, JSValueRef* exception)
  {
<span class="line-modified">!     JSGlobalObject* lexicalGlobalObject = toJS(originContext);</span>
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     JSValue value = toJS(lexicalGlobalObject, apiValue);</span>
<span class="line-modified">!     auto serializedValue = SerializedScriptValue::create(*lexicalGlobalObject, value);</span>
      if (UNLIKELY(scope.exception())) {
          if (exception)
<span class="line-modified">!             *exception = toRef(lexicalGlobalObject, scope.exception()-&gt;value());</span>
          scope.clearException();
          return nullptr;
      }
      ASSERT(serializedValue);
      return serializedValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3506,50 ***</span>
  String SerializedScriptValue::toString()
  {
      return CloneDeserializer::deserializeString(m_data);
  }
  
<span class="line-modified">! JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, SerializationErrorMode throwExceptions)</span>
  {
<span class="line-modified">!     return deserialize(exec, globalObject, { }, throwExceptions);</span>
  }
  
<span class="line-modified">! JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationErrorMode throwExceptions)</span>
  {
      Vector&lt;String&gt; dummyBlobs;
      Vector&lt;String&gt; dummyPaths;
<span class="line-modified">!     return deserialize(exec, globalObject, messagePorts, dummyBlobs, dummyPaths, throwExceptions);</span>
  }
  
<span class="line-modified">! JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt;&amp; blobFilePaths, SerializationErrorMode throwExceptions)</span>
  {
<span class="line-modified">!     DeserializationResult result = CloneDeserializer::deserialize(&amp;exec, globalObject, messagePorts, WTFMove(m_imageBuffers), m_arrayBufferContentsArray.get(), m_data, blobURLs, blobFilePaths, m_sharedBufferContentsArray.get()</span>
  #if ENABLE(WEBASSEMBLY)
          , m_wasmModulesArray.get()
  #endif
          );
      if (throwExceptions == SerializationErrorMode::Throwing)
<span class="line-modified">!         maybeThrowExceptionIfSerializationFailed(exec, result.second);</span>
      return result.first ? result.first : jsNull();
  }
  
  JSValueRef SerializedScriptValue::deserialize(JSContextRef destinationContext, JSValueRef* exception)
  {
<span class="line-modified">!     ExecState* exec = toJS(destinationContext);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     JSValue value = deserialize(*exec, exec-&gt;lexicalGlobalObject());</span>
      if (UNLIKELY(scope.exception())) {
          if (exception)
<span class="line-modified">!             *exception = toRef(exec, scope.exception()-&gt;value());</span>
          scope.clearException();
          return nullptr;
      }
      ASSERT(value);
<span class="line-modified">!     return toRef(exec, value);</span>
  }
  
  Ref&lt;SerializedScriptValue&gt; SerializedScriptValue::nullValue()
  {
      return adoptRef(*new SerializedScriptValue(Vector&lt;uint8_t&gt;()));
<span class="line-new-header">--- 3709,54 ---</span>
  String SerializedScriptValue::toString()
  {
      return CloneDeserializer::deserializeString(m_data);
  }
  
<span class="line-modified">! JSValue SerializedScriptValue::deserialize(JSGlobalObject&amp; lexicalGlobalObject, JSGlobalObject* globalObject, SerializationErrorMode throwExceptions)</span>
  {
<span class="line-modified">!     return deserialize(lexicalGlobalObject, globalObject, { }, throwExceptions);</span>
  }
  
<span class="line-modified">! JSValue SerializedScriptValue::deserialize(JSGlobalObject&amp; lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationErrorMode throwExceptions)</span>
  {
      Vector&lt;String&gt; dummyBlobs;
      Vector&lt;String&gt; dummyPaths;
<span class="line-modified">!     return deserialize(lexicalGlobalObject, globalObject, messagePorts, dummyBlobs, dummyPaths, throwExceptions);</span>
  }
  
<span class="line-modified">! JSValue SerializedScriptValue::deserialize(JSGlobalObject&amp; lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt;&amp; blobFilePaths, SerializationErrorMode throwExceptions)</span>
  {
<span class="line-modified">!     DeserializationResult result = CloneDeserializer::deserialize(&amp;lexicalGlobalObject, globalObject, messagePorts, WTFMove(m_imageBuffers)</span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+         , WTFMove(m_detachedOffscreenCanvases)</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         , m_arrayBufferContentsArray.get(), m_data, blobURLs, blobFilePaths, m_sharedBufferContentsArray.get()</span>
  #if ENABLE(WEBASSEMBLY)
          , m_wasmModulesArray.get()
  #endif
          );
      if (throwExceptions == SerializationErrorMode::Throwing)
<span class="line-modified">!         maybeThrowExceptionIfSerializationFailed(lexicalGlobalObject, result.second);</span>
      return result.first ? result.first : jsNull();
  }
  
  JSValueRef SerializedScriptValue::deserialize(JSContextRef destinationContext, JSValueRef* exception)
  {
<span class="line-modified">!     JSGlobalObject* lexicalGlobalObject = toJS(destinationContext);</span>
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     JSValue value = deserialize(*lexicalGlobalObject, lexicalGlobalObject);</span>
      if (UNLIKELY(scope.exception())) {
          if (exception)
<span class="line-modified">!             *exception = toRef(lexicalGlobalObject, scope.exception()-&gt;value());</span>
          scope.clearException();
          return nullptr;
      }
      ASSERT(value);
<span class="line-modified">!     return toRef(lexicalGlobalObject, value);</span>
  }
  
  Ref&lt;SerializedScriptValue&gt; SerializedScriptValue::nullValue()
  {
      return adoptRef(*new SerializedScriptValue(Vector&lt;uint8_t&gt;()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3569,16 ***</span>
          result.uncheckedAppend(url.isolatedCopy());
  
      return result;
  }
  
<span class="line-modified">! void SerializedScriptValue::writeBlobsToDiskForIndexedDB(PAL::SessionID sessionID, CompletionHandler&lt;void(IDBValue&amp;&amp;)&gt;&amp;&amp; completionHandler)</span>
  {
      ASSERT(isMainThread());
      ASSERT(hasBlobURLs());
  
<span class="line-modified">!     blobRegistry().writeBlobsToTemporaryFiles(sessionID, m_blobURLs, [completionHandler = WTFMove(completionHandler), this, protectedThis = makeRef(*this)] (auto&amp;&amp; blobFilePaths) mutable {</span>
          ASSERT(isMainThread());
  
          if (blobFilePaths.isEmpty()) {
              // We should have successfully written blobs to temporary files.
              // If we failed, then we can&#39;t successfully store this record.
<span class="line-new-header">--- 3776,16 ---</span>
          result.uncheckedAppend(url.isolatedCopy());
  
      return result;
  }
  
<span class="line-modified">! void SerializedScriptValue::writeBlobsToDiskForIndexedDB(CompletionHandler&lt;void(IDBValue&amp;&amp;)&gt;&amp;&amp; completionHandler)</span>
  {
      ASSERT(isMainThread());
      ASSERT(hasBlobURLs());
  
<span class="line-modified">!     blobRegistry().writeBlobsToTemporaryFiles(m_blobURLs, [completionHandler = WTFMove(completionHandler), this, protectedThis = makeRef(*this)] (auto&amp;&amp; blobFilePaths) mutable {</span>
          ASSERT(isMainThread());
  
          if (blobFilePaths.isEmpty()) {
              // We should have successfully written blobs to temporary files.
              // If we failed, then we can&#39;t successfully store this record.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3590,21 ***</span>
  
          completionHandler({ *this, m_blobURLs, blobFilePaths });
      });
  }
  
<span class="line-modified">! IDBValue SerializedScriptValue::writeBlobsToDiskForIndexedDBSynchronously(PAL::SessionID sessionID)</span>
  {
      ASSERT(!isMainThread());
  
      IDBValue value;
      Lock lock;
      Condition condition;
      lock.lock();
  
<span class="line-modified">!     RunLoop::main().dispatch([this, sessionID, conditionPtr = &amp;condition, valuePtr = &amp;value] {</span>
<span class="line-modified">!         writeBlobsToDiskForIndexedDB(sessionID, [conditionPtr, valuePtr](IDBValue&amp;&amp; result) {</span>
              ASSERT(isMainThread());
              valuePtr-&gt;setAsIsolatedCopy(result);
  
              conditionPtr-&gt;notifyAll();
          });
<span class="line-new-header">--- 3797,21 ---</span>
  
          completionHandler({ *this, m_blobURLs, blobFilePaths });
      });
  }
  
<span class="line-modified">! IDBValue SerializedScriptValue::writeBlobsToDiskForIndexedDBSynchronously()</span>
  {
      ASSERT(!isMainThread());
  
      IDBValue value;
      Lock lock;
      Condition condition;
      lock.lock();
  
<span class="line-modified">!     RunLoop::main().dispatch([this, conditionPtr = &amp;condition, valuePtr = &amp;value] {</span>
<span class="line-modified">!         writeBlobsToDiskForIndexedDB([conditionPtr, valuePtr](IDBValue&amp;&amp; result) {</span>
              ASSERT(isMainThread());
              valuePtr-&gt;setAsIsolatedCopy(result);
  
              conditionPtr-&gt;notifyAll();
          });
</pre>
<center><a href="ScriptWrappable.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SerializedScriptValue.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
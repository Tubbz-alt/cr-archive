<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  4  *  Copyright (C) 2008, 2009, 2013, 2014 Apple Inc. All rights reserved.
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Lesser General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;Breakpoint.h&quot;
 25 #include &quot;CallData.h&quot;
 26 #include &quot;DebuggerCallFrame.h&quot;
 27 #include &quot;DebuggerParseData.h&quot;
 28 #include &quot;DebuggerPrimitives.h&quot;
 29 #include &quot;JSCJSValue.h&quot;
 30 #include &lt;wtf/HashMap.h&gt;
 31 #include &lt;wtf/HashSet.h&gt;
 32 #include &lt;wtf/RefPtr.h&gt;
 33 #include &lt;wtf/text/TextPosition.h&gt;
 34 
 35 namespace JSC {
 36 
 37 class CallFrame;
 38 class CodeBlock;
 39 class Exception;
 40 class JSGlobalObject;
 41 class SourceProvider;
 42 class VM;
 43 
 44 class JS_EXPORT_PRIVATE Debugger {
 45     WTF_MAKE_FAST_ALLOCATED;
 46 public:
 47     Debugger(VM&amp;);
 48     virtual ~Debugger();
 49 
 50     VM&amp; vm() { return m_vm; }
 51 
 52     JSC::DebuggerCallFrame&amp; currentDebuggerCallFrame();
 53     bool hasHandlerForExceptionCallback() const
 54     {
 55         ASSERT(m_reasonForPause == PausedForException);
 56         return m_hasHandlerForExceptionCallback;
 57     }
 58     JSValue currentException()
 59     {
 60         ASSERT(m_reasonForPause == PausedForException);
 61         return m_currentException;
 62     }
 63 
 64     bool needsExceptionCallbacks() const { return m_breakpointsActivated &amp;&amp; m_pauseOnExceptionsState != DontPauseOnExceptions; }
 65     bool isInteractivelyDebugging() const { return m_breakpointsActivated; }
 66 
 67     enum ReasonForDetach {
 68         TerminatingDebuggingSession,
 69         GlobalObjectIsDestructing
 70     };
 71     void attach(JSGlobalObject*);
 72     void detach(JSGlobalObject*, ReasonForDetach);
 73     bool isAttached(JSGlobalObject*);
 74 
 75     void resolveBreakpoint(Breakpoint&amp;, SourceProvider*);
 76     BreakpointID setBreakpoint(Breakpoint&amp;, bool&amp; existing);
 77     void removeBreakpoint(BreakpointID);
 78     void clearBreakpoints();
 79 
 80     void activateBreakpoints() { setBreakpointsActivated(true); }
 81     void deactivateBreakpoints() { setBreakpointsActivated(false); }
 82     bool breakpointsActive() const { return m_breakpointsActivated; }
 83 
 84     enum PauseOnExceptionsState {
 85         DontPauseOnExceptions,
 86         PauseOnAllExceptions,
 87         PauseOnUncaughtExceptions
 88     };
 89     PauseOnExceptionsState pauseOnExceptionsState() const { return m_pauseOnExceptionsState; }
 90     void setPauseOnExceptionsState(PauseOnExceptionsState);
 91 
 92     void setPauseOnDebuggerStatements(bool enabled) { m_pauseOnDebuggerStatements = enabled; }
 93 
 94     enum ReasonForPause {
 95         NotPaused,
 96         PausedForException,
 97         PausedAtStatement,
 98         PausedAtExpression,
 99         PausedBeforeReturn,
100         PausedAtEndOfProgram,
101         PausedForBreakpoint,
102         PausedForDebuggerStatement,
103         PausedAfterBlackboxedScript,
104     };
105     ReasonForPause reasonForPause() const { return m_reasonForPause; }
106     BreakpointID pausingBreakpointID() const { return m_pausingBreakpointID; }
107 
108     void setPauseOnNextStatement(bool);
109     void breakProgram();
110     void continueProgram();
111     void stepIntoStatement();
112     void stepOverStatement();
113     void stepOutOfFunction();
114 
115     enum class BlackboxType { Deferred, Ignored };
116     void setBlackboxType(SourceID, Optional&lt;BlackboxType&gt;);
117     void clearBlackbox();
118 
119     bool isPaused() const { return m_isPaused; }
120     bool isStepping() const { return m_steppingMode == SteppingModeEnabled; }
121 
122     bool suppressAllPauses() const { return m_suppressAllPauses; }
123     void setSuppressAllPauses(bool suppress) { m_suppressAllPauses = suppress; }
124 
125     virtual void sourceParsed(JSGlobalObject*, SourceProvider*, int errorLineNumber, const WTF::String&amp; errorMessage) = 0;
126     virtual void willRunMicrotask() { }
127     virtual void didRunMicrotask() { }
128 
129     void exception(JSGlobalObject*, CallFrame*, JSValue exceptionValue, bool hasCatchHandler);
130     void atStatement(CallFrame*);
131     void atExpression(CallFrame*);
132     void callEvent(CallFrame*);
133     void returnEvent(CallFrame*);
134     void unwindEvent(CallFrame*);
135     void willExecuteProgram(CallFrame*);
136     void didExecuteProgram(CallFrame*);
137     void didReachDebuggerStatement(CallFrame*);
138 
139     virtual void recompileAllJSFunctions();
140 
141     void registerCodeBlock(CodeBlock*);
142 
143     class ProfilingClient {
144     public:
145         virtual ~ProfilingClient();
146         virtual bool isAlreadyProfiling() const = 0;
147         virtual Seconds willEvaluateScript() = 0;
148         virtual void didEvaluateScript(Seconds startTime, ProfilingReason) = 0;
149     };
150 
151     void setProfilingClient(ProfilingClient*);
152     bool hasProfilingClient() const { return m_profilingClient != nullptr; }
153     bool isAlreadyProfiling() const { return m_profilingClient &amp;&amp; m_profilingClient-&gt;isAlreadyProfiling(); }
154     Seconds willEvaluateScript();
155     void didEvaluateScript(Seconds startTime, ProfilingReason);
156 
157 protected:
158     virtual void handleBreakpointHit(JSGlobalObject*, const Breakpoint&amp;) { }
159     virtual void handleExceptionInBreakpointCondition(JSGlobalObject*, Exception*) const { }
160     virtual void handlePause(JSGlobalObject*, ReasonForPause) { }
161     virtual void notifyDoneProcessingDebuggerEvents() { }
162 
163 private:
164     typedef HashMap&lt;BreakpointID, Breakpoint*&gt; BreakpointIDToBreakpointMap;
165 
166     typedef HashMap&lt;unsigned, RefPtr&lt;BreakpointsList&gt;, WTF::IntHash&lt;int&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;int&gt;&gt; LineToBreakpointsMap;
167     typedef HashMap&lt;SourceID, LineToBreakpointsMap, WTF::IntHash&lt;SourceID&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;SourceID&gt;&gt; SourceIDToBreakpointsMap;
168 
169     class ClearCodeBlockDebuggerRequestsFunctor;
170     class ClearDebuggerRequestsFunctor;
171     class SetSteppingModeFunctor;
172     class ToggleBreakpointFunctor;
173 
174     class PauseReasonDeclaration {
175     public:
176         PauseReasonDeclaration(Debugger&amp; debugger, ReasonForPause reason)
177             : m_debugger(debugger)
178         {
179             m_debugger.m_reasonForPause = reason;
180         }
181 
182         ~PauseReasonDeclaration()
183         {
184             m_debugger.m_reasonForPause = NotPaused;
185         }
186     private:
187         Debugger&amp; m_debugger;
188     };
189 
190     bool hasBreakpoint(SourceID, const TextPosition&amp;, Breakpoint* hitBreakpoint);
191 
192     DebuggerParseData&amp; debuggerParseData(SourceID, SourceProvider*);
193 
194     void updateNeedForOpDebugCallbacks();
195 
196     // These update functions are only needed because our current breakpoints are
197     // key&#39;ed off the source position instead of the bytecode PC. This ensures
198     // that we don&#39;t break on the same line more than once. Once we switch to a
199     // bytecode PC key&#39;ed breakpoint, we will not need these anymore and should
200     // be able to remove them.
201     enum CallFrameUpdateAction { AttemptPause, NoPause };
202     void updateCallFrame(JSC::JSGlobalObject*, JSC::CallFrame*, CallFrameUpdateAction);
203     void updateCallFrameInternal(JSC::CallFrame*);
204     void pauseIfNeeded(JSC::JSGlobalObject*);
205     void clearNextPauseState();
206 
207     enum SteppingMode {
208         SteppingModeDisabled,
209         SteppingModeEnabled
210     };
211     void setSteppingMode(SteppingMode);
212 
213     enum BreakpointState {
214         BreakpointDisabled,
215         BreakpointEnabled
216     };
217     void setBreakpointsActivated(bool);
218     void toggleBreakpoint(CodeBlock*, Breakpoint&amp;, BreakpointState);
219     void applyBreakpoints(CodeBlock*);
220     void toggleBreakpoint(Breakpoint&amp;, BreakpointState);
221 
222     void clearDebuggerRequests(JSGlobalObject*);
223     void clearParsedData();
224 
225     VM&amp; m_vm;
226     HashSet&lt;JSGlobalObject*&gt; m_globalObjects;
227     HashMap&lt;SourceID, DebuggerParseData, WTF::IntHash&lt;SourceID&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;SourceID&gt;&gt; m_parseDataMap;
228     HashMap&lt;SourceID, BlackboxType, WTF::IntHash&lt;SourceID&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;SourceID&gt;&gt; m_blackboxedScripts;
229 
230     PauseOnExceptionsState m_pauseOnExceptionsState;
231     bool m_pauseOnDebuggerStatements : 1;
232     bool m_pauseAtNextOpportunity : 1;
233     bool m_pauseOnStepOut : 1;
234     bool m_pastFirstExpressionInStatement : 1;
235     bool m_isPaused : 1;
236     bool m_breakpointsActivated : 1;
237     bool m_hasHandlerForExceptionCallback : 1;
238     bool m_suppressAllPauses : 1;
239     unsigned m_steppingMode : 1; // SteppingMode
240 
241     ReasonForPause m_reasonForPause;
242     JSValue m_currentException;
243     CallFrame* m_pauseOnCallFrame { nullptr };
244     CallFrame* m_currentCallFrame { nullptr };
245     unsigned m_lastExecutedLine;
246     SourceID m_lastExecutedSourceID;
247     bool m_afterBlackboxedScript { false };
248 
249     BreakpointID m_topBreakpointID;
250     BreakpointID m_pausingBreakpointID;
251     BreakpointIDToBreakpointMap m_breakpointIDToBreakpoint;
252     SourceIDToBreakpointsMap m_sourceIDToBreakpoints;
253 
254     RefPtr&lt;JSC::DebuggerCallFrame&gt; m_currentDebuggerCallFrame;
255 
256     ProfilingClient* m_profilingClient { nullptr };
257 
258     friend class DebuggerPausedScope;
259     friend class TemporaryPausedState;
260     friend class LLIntOffsetsExtractor;
261 };
262 
263 } // namespace JSC
    </pre>
  </body>
</html>
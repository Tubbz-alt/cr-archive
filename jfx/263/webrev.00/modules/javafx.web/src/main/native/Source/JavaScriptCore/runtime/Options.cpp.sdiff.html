<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Options.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Operations.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Options.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Options.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Options.h&quot;
  28 
  29 #include &quot;AssemblerCommon.h&quot;
  30 #include &quot;CPU.h&quot;
  31 #include &quot;LLIntCommon.h&quot;
  32 #include &quot;MinimumReservedZoneSize.h&quot;
  33 #include &quot;SigillCrashAnalyzer.h&quot;
  34 #include &lt;algorithm&gt;
  35 #include &lt;limits&gt;
  36 #include &lt;math.h&gt;
  37 #include &lt;mutex&gt;
  38 #include &lt;stdlib.h&gt;
  39 #include &lt;string.h&gt;
  40 #include &lt;wtf/ASCIICType.h&gt;
  41 #include &lt;wtf/Compiler.h&gt;
  42 #include &lt;wtf/DataLog.h&gt;
  43 #include &lt;wtf/NumberOfCores.h&gt;

  44 #include &lt;wtf/PointerPreparations.h&gt;
  45 #include &lt;wtf/StdLibExtras.h&gt;
  46 #include &lt;wtf/text/StringBuilder.h&gt;
  47 #include &lt;wtf/threads/Signals.h&gt;
  48 
  49 #if PLATFORM(COCOA)
  50 #include &lt;crt_externs.h&gt;
  51 #endif
  52 
  53 #if ENABLE(JIT)
  54 #include &quot;MacroAssembler.h&quot;
  55 #endif
  56 
  57 namespace JSC {
  58 
<span class="line-modified">  59 namespace {</span>
<span class="line-modified">  60 #ifdef NDEBUG</span>
<span class="line-removed">  61 bool restrictedOptionsEnabled = false;</span>
<span class="line-removed">  62 #else</span>
<span class="line-removed">  63 bool restrictedOptionsEnabled = true;</span>
<span class="line-removed">  64 #endif</span>
<span class="line-removed">  65 }</span>
<span class="line-removed">  66 </span>
<span class="line-removed">  67 void Options::enableRestrictedOptions(bool enableOrNot)</span>
<span class="line-removed">  68 {</span>
<span class="line-removed">  69     restrictedOptionsEnabled = enableOrNot;</span>
<span class="line-removed">  70 }</span>
  71 
<span class="line-modified">  72 static bool parse(const char* string, bool&amp; value)</span>

  73 {
<span class="line-modified">  74     if (equalLettersIgnoringASCIICase(string, &quot;true&quot;) || equalLettersIgnoringASCIICase(string, &quot;yes&quot;) || !strcmp(string, &quot;1&quot;)) {</span>
<span class="line-removed">  75         value = true;</span>
  76         return true;
<span class="line-modified">  77     }</span>
<span class="line-modified">  78     if (equalLettersIgnoringASCIICase(string, &quot;false&quot;) || equalLettersIgnoringASCIICase(string, &quot;no&quot;) || !strcmp(string, &quot;0&quot;)) {</span>
<span class="line-modified">  79         value = false;</span>
<span class="line-removed">  80         return true;</span>
<span class="line-removed">  81     }</span>
<span class="line-removed">  82     return false;</span>
<span class="line-removed">  83 }</span>
<span class="line-removed">  84 </span>
<span class="line-removed">  85 static bool parse(const char* string, int32_t&amp; value)</span>
<span class="line-removed">  86 {</span>
<span class="line-removed">  87     return sscanf(string, &quot;%d&quot;, &amp;value) == 1;</span>
  88 }
  89 
<span class="line-modified">  90 static bool parse(const char* string, unsigned&amp; value)</span>

  91 {
<span class="line-modified">  92     return sscanf(string, &quot;%u&quot;, &amp;value) == 1;</span>



  93 }
  94 
<span class="line-modified">  95 static bool UNUSED_FUNCTION parse(const char* string, unsigned long&amp; value)</span>

  96 {
<span class="line-modified">  97     return sscanf(string, &quot;%lu&quot;, &amp;value);</span>



  98 }
  99 
<span class="line-modified"> 100 static bool UNUSED_FUNCTION parse(const char* string, unsigned long long&amp; value)</span>


 101 {
<span class="line-modified"> 102     return sscanf(string, &quot;%llu&quot;, &amp;value);</span>



 103 }

 104 
<span class="line-modified"> 105 static bool parse(const char* string, double&amp; value)</span>

 106 {
<span class="line-modified"> 107     return sscanf(string, &quot;%lf&quot;, &amp;value) == 1;</span>



 108 }
 109 
<span class="line-modified"> 110 static bool parse(const char* string, OptionRange&amp; value)</span>

 111 {
<span class="line-modified"> 112     return value.init(string);</span>



 113 }
 114 
<span class="line-modified"> 115 static bool parse(const char* string, const char*&amp; value)</span>

 116 {
<span class="line-modified"> 117     if (!strlen(string)) {</span>
<span class="line-modified"> 118         value = nullptr;</span>
<span class="line-modified"> 119         return true;</span>
<span class="line-removed"> 120     }</span>
 121 
 122     // FIXME &lt;https://webkit.org/b/169057&gt;: This could leak if this option is set more than once.
 123     // Given that Options are typically used for testing, this isn&#39;t considered to be a problem.
 124     value = WTF::fastStrDup(string);
<span class="line-modified"> 125     return true;</span>
 126 }
 127 
<span class="line-modified"> 128 static bool parse(const char* string, GCLogging::Level&amp; value)</span>

 129 {
<span class="line-modified"> 130     if (equalLettersIgnoringASCIICase(string, &quot;none&quot;) || equalLettersIgnoringASCIICase(string, &quot;no&quot;) || equalLettersIgnoringASCIICase(string, &quot;false&quot;) || !strcmp(string, &quot;0&quot;)) {</span>
<span class="line-modified"> 131         value = GCLogging::None;</span>
<span class="line-removed"> 132         return true;</span>
<span class="line-removed"> 133     }</span>
 134 
<span class="line-modified"> 135     if (equalLettersIgnoringASCIICase(string, &quot;basic&quot;) || equalLettersIgnoringASCIICase(string, &quot;yes&quot;) || equalLettersIgnoringASCIICase(string, &quot;true&quot;) || !strcmp(string, &quot;1&quot;)) {</span>
<span class="line-modified"> 136         value = GCLogging::Basic;</span>
<span class="line-removed"> 137         return true;</span>
<span class="line-removed"> 138     }</span>
 139 
<span class="line-modified"> 140     if (equalLettersIgnoringASCIICase(string, &quot;verbose&quot;) || !strcmp(string, &quot;2&quot;)) {</span>
<span class="line-modified"> 141         value = GCLogging::Verbose;</span>
<span class="line-removed"> 142         return true;</span>
<span class="line-removed"> 143     }</span>
 144 
<span class="line-modified"> 145     return false;</span>
 146 }
 147 
 148 bool Options::isAvailable(Options::ID id, Options::Availability availability)
 149 {
 150     if (availability == Availability::Restricted)
<span class="line-modified"> 151         return restrictedOptionsEnabled;</span>
 152     ASSERT(availability == Availability::Configurable);
 153 
 154     UNUSED_PARAM(id);
 155 #if !defined(NDEBUG)
 156     if (id == maxSingleAllocationSizeID)
 157         return true;
 158 #endif
 159 #if OS(DARWIN)
 160     if (id == useSigillCrashAnalyzerID)
 161         return true;
 162 #endif
 163 #if ENABLE(ASSEMBLER) &amp;&amp; OS(LINUX)
 164     if (id == logJITCodeForPerfID)
 165         return true;
 166 #endif
 167     if (id == traceLLIntExecutionID)
 168         return !!LLINT_TRACING;
 169     if (id == traceLLIntSlowPathID)
 170         return !!LLINT_TRACING;
 171     return false;
 172 }
 173 
 174 template&lt;typename T&gt;
 175 bool overrideOptionWithHeuristic(T&amp; variable, Options::ID id, const char* name, Options::Availability availability)
 176 {
 177     bool available = (availability == Options::Availability::Normal)
 178         || Options::isAvailable(id, availability);
 179 
 180     const char* stringValue = getenv(name);
 181     if (!stringValue)
 182         return false;
 183 
<span class="line-modified"> 184     if (available &amp;&amp; parse(stringValue, variable))</span>
<span class="line-modified"> 185         return true;</span>





 186 
 187     fprintf(stderr, &quot;WARNING: failed to parse %s=%s\n&quot;, name, stringValue);
 188     return false;
 189 }
 190 
 191 bool Options::overrideAliasedOptionWithHeuristic(const char* name)
 192 {
 193     const char* stringValue = getenv(name);
 194     if (!stringValue)
 195         return false;
 196 
 197     String aliasedOption;
 198     aliasedOption = String(&amp;name[4]) + &quot;=&quot; + stringValue;
 199     if (Options::setOption(aliasedOption.utf8().data()))
 200         return true;
 201 
 202     fprintf(stderr, &quot;WARNING: failed to parse %s=%s\n&quot;, name, stringValue);
 203     return false;
 204 }
 205 
</pre>
<hr />
<pre>
 278 
 279     return true;
 280 }
 281 
 282 bool OptionRange::isInRange(unsigned count)
 283 {
 284     if (m_state &lt; Normal)
 285         return true;
 286 
 287     if ((m_lowLimit &lt;= count) &amp;&amp; (count &lt;= m_highLimit))
 288         return m_state == Normal ? true : false;
 289 
 290     return m_state == Normal ? false : true;
 291 }
 292 
 293 void OptionRange::dump(PrintStream&amp; out) const
 294 {
 295     out.print(m_rangeString);
 296 }
 297 
<span class="line-removed"> 298 Options::Entry Options::s_options[Options::numberOfOptions];</span>
<span class="line-removed"> 299 Options::Entry Options::s_defaultOptions[Options::numberOfOptions];</span>
<span class="line-removed"> 300 </span>
 301 // Realize the names for each of the options:
<span class="line-modified"> 302 const Options::EntryInfo Options::s_optionsInfo[Options::numberOfOptions] = {</span>
<span class="line-modified"> 303 #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
<span class="line-modified"> 304     { #name_, description_, Options::Type::type_##Type, Availability::availability_ },</span>
<span class="line-modified"> 305     JSC_OPTIONS(FOR_EACH_OPTION)</span>
<span class="line-modified"> 306 #undef FOR_EACH_OPTION</span>
 307 };
 308 
 309 static void scaleJITPolicy()
 310 {
 311     auto&amp; scaleFactor = Options::jitPolicyScale();
 312     if (scaleFactor &gt; 1.0)
 313         scaleFactor = 1.0;
 314     else if (scaleFactor &lt; 0.0)
 315         scaleFactor = 0.0;
 316 
<span class="line-modified"> 317     struct OptionToScale {</span>
<span class="line-modified"> 318         Options::ID id;</span>
<span class="line-modified"> 319         int32_t minVal;</span>
 320     };
 321 
<span class="line-modified"> 322     static const OptionToScale optionsToScale[] = {</span>
<span class="line-modified"> 323         { Options::thresholdForJITAfterWarmUpID, 0 },</span>
<span class="line-modified"> 324         { Options::thresholdForJITSoonID, 0 },</span>
<span class="line-modified"> 325         { Options::thresholdForOptimizeAfterWarmUpID, 1 },</span>
<span class="line-modified"> 326         { Options::thresholdForOptimizeAfterLongWarmUpID, 1 },</span>
<span class="line-modified"> 327         { Options::thresholdForOptimizeSoonID, 1 },</span>
<span class="line-modified"> 328         { Options::thresholdForFTLOptimizeSoonID, 2 },</span>
<span class="line-removed"> 329         { Options::thresholdForFTLOptimizeAfterWarmUpID, 2 }</span>
<span class="line-removed"> 330     };</span>
<span class="line-removed"> 331 </span>
<span class="line-removed"> 332     const int numberOfOptionsToScale = sizeof(optionsToScale) / sizeof(OptionToScale);</span>
<span class="line-removed"> 333     for (int i = 0; i &lt; numberOfOptionsToScale; i++) {</span>
<span class="line-removed"> 334         Option option(optionsToScale[i].id);</span>
<span class="line-removed"> 335         ASSERT(option.type() == Options::Type::int32Type);</span>
<span class="line-removed"> 336         option.int32Val() *= scaleFactor;</span>
<span class="line-removed"> 337         option.int32Val() = std::max(option.int32Val(), optionsToScale[i].minVal);</span>
<span class="line-removed"> 338     }</span>
 339 }
 340 
 341 static void overrideDefaults()
 342 {
 343 #if !PLATFORM(IOS_FAMILY)
 344     if (WTF::numberOfProcessorCores() &lt; 4)
 345 #endif
 346     {
 347         Options::maximumMutatorUtilization() = 0.6;
 348         Options::concurrentGCMaxHeadroom() = 1.4;
 349         Options::minimumGCPauseMS() = 1;
 350         Options::useStochasticMutatorScheduler() = false;
 351         if (WTF::numberOfProcessorCores() &lt;= 1)
 352             Options::gcIncrementScale() = 1;
 353         else
 354             Options::gcIncrementScale() = 0;
 355     }
 356 
<span class="line-modified"> 357 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified"> 358     // On iOS, we control heap growth using process memory footprint. Therefore these values can be agressive.</span>
 359     Options::smallHeapRAMFraction() = 0.8;
 360     Options::mediumHeapRAMFraction() = 0.9;

 361 
<span class="line-modified"> 362 #if !PLATFORM(WATCHOS) &amp;&amp; defined(__LP64__)</span>
 363     Options::useSigillCrashAnalyzer() = true;
 364 #endif
<span class="line-removed"> 365 #endif</span>
 366 
 367 #if !ENABLE(SIGNAL_BASED_VM_TRAPS)
 368     Options::usePollingTraps() = true;
 369 #endif
 370 
 371 #if !ENABLE(WEBASSEMBLY_FAST_MEMORY)
 372     Options::useWebAssemblyFastMemory() = false;
 373 #endif
 374 
 375 #if !HAVE(MACH_EXCEPTIONS)
 376     Options::useMachForExceptions() = false;
 377 #endif





 378 }
 379 
 380 static void correctOptions()
 381 {
 382     unsigned thresholdForGlobalLexicalBindingEpoch = Options::thresholdForGlobalLexicalBindingEpoch();
 383     if (thresholdForGlobalLexicalBindingEpoch == 0 || thresholdForGlobalLexicalBindingEpoch == 1)
 384         Options::thresholdForGlobalLexicalBindingEpoch() = UINT_MAX;
 385 }
 386 
 387 static void recomputeDependentOptions()
 388 {
 389 #if !defined(NDEBUG)
 390     Options::validateDFGExceptionHandling() = true;
 391 #endif
 392 #if !ENABLE(JIT)
 393     Options::useLLInt() = true;
 394     Options::useJIT() = false;
 395     Options::useBaselineJIT() = false;
 396     Options::useDFGJIT() = false;
 397     Options::useFTLJIT() = false;
</pre>
<hr />
<pre>
 434         || Options::dumpGraphAtEachPhase()
 435         || Options::dumpDFGGraphAtEachPhase()
 436         || Options::dumpDFGFTLGraphAtEachPhase()
 437         || Options::dumpB3GraphAtEachPhase()
 438         || Options::dumpAirGraphAtEachPhase()
 439         || Options::verboseCompilation()
 440         || Options::verboseFTLCompilation()
 441         || Options::logCompilationChanges()
 442         || Options::validateGraph()
 443         || Options::validateGraphAtEachPhase()
 444         || Options::verboseOSR()
 445         || Options::verboseCompilationQueue()
 446         || Options::reportCompileTimes()
 447         || Options::reportBaselineCompileTimes()
 448         || Options::reportDFGCompileTimes()
 449         || Options::reportFTLCompileTimes()
 450         || Options::logPhaseTimes()
 451         || Options::verboseCFA()
 452         || Options::verboseDFGFailure()
 453         || Options::verboseFTLFailure()
<span class="line-modified"> 454         || Options::dumpRandomizingFuzzerAgentPredictions())</span>
 455         Options::alwaysComputeHash() = true;
 456 
 457     if (!Options::useConcurrentGC())
 458         Options::collectContinuously() = false;
 459 
<span class="line-modified"> 460     if (Option(Options::jitPolicyScaleID).isOverridden())</span>
 461         scaleJITPolicy();
 462 
 463     if (Options::forceEagerCompilation()) {
 464         Options::thresholdForJITAfterWarmUp() = 10;
 465         Options::thresholdForJITSoon() = 10;
 466         Options::thresholdForOptimizeAfterWarmUp() = 20;
 467         Options::thresholdForOptimizeAfterLongWarmUp() = 20;
 468         Options::thresholdForOptimizeSoon() = 20;
 469         Options::thresholdForFTLOptimizeAfterWarmUp() = 20;
 470         Options::thresholdForFTLOptimizeSoon() = 20;
 471         Options::maximumEvalCacheableSourceLength() = 150000;
 472         Options::useConcurrentJIT() = false;
 473     }
 474 #if ENABLE(SEPARATED_WX_HEAP)
 475     // Override globally for now. Longer term we&#39;ll just make the default
 476     // be to have this option enabled, and have platforms that don&#39;t support
 477     // it just silently use a single mapping.
 478     Options::useSeparatedWXHeap() = true;
 479 #else
 480     Options::useSeparatedWXHeap() = false;
</pre>
<hr />
<pre>
 495     ASSERT((static_cast&lt;int64_t&gt;(Options::thresholdForOptimizeAfterLongWarmUp()) &lt;&lt; Options::reoptimizationRetryCounterMax()) &gt; 0);
 496     ASSERT((static_cast&lt;int64_t&gt;(Options::thresholdForOptimizeAfterLongWarmUp()) &lt;&lt; Options::reoptimizationRetryCounterMax()) &lt;= static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()));
 497 
 498 #if !defined(NDEBUG)
 499     if (Options::maxSingleAllocationSize())
 500         fastSetMaxSingleAllocationSize(Options::maxSingleAllocationSize());
 501     else
 502         fastSetMaxSingleAllocationSize(std::numeric_limits&lt;size_t&gt;::max());
 503 #endif
 504 
 505     if (Options::useZombieMode()) {
 506         Options::sweepSynchronously() = true;
 507         Options::scribbleFreeCells() = true;
 508     }
 509 
 510     if (Options::reservedZoneSize() &lt; minimumReservedZoneSize)
 511         Options::reservedZoneSize() = minimumReservedZoneSize;
 512     if (Options::softReservedZoneSize() &lt; Options::reservedZoneSize() + minimumReservedZoneSize)
 513         Options::softReservedZoneSize() = Options::reservedZoneSize() + minimumReservedZoneSize;
 514 
<span class="line-removed"> 515 #if USE(JSVALUE32_64)</span>
 516     // FIXME: Make probe OSR exit work on 32-bit:
 517     // https://bugs.webkit.org/show_bug.cgi?id=177956
 518     Options::useProbeOSRExit() = false;
<span class="line-removed"> 519 #endif</span>
 520 
 521     if (!Options::useCodeCache())
 522         Options::diskCachePath() = nullptr;

















 523 }
 524 
 525 void Options::initialize()
 526 {
 527     static std::once_flag initializeOptionsOnceFlag;
 528 
 529     std::call_once(
 530         initializeOptionsOnceFlag,
 531         [] {











 532             // Initialize each of the options with their default values:
<span class="line-modified"> 533 #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
<span class="line-modified"> 534             name_() = defaultValue_;                                    \</span>
<span class="line-modified"> 535             name_##Default() = defaultValue_;</span>
<span class="line-modified"> 536             JSC_OPTIONS(FOR_EACH_OPTION)</span>
<span class="line-modified"> 537 #undef FOR_EACH_OPTION</span>


 538 
 539             overrideDefaults();
 540 
 541             // Allow environment vars to override options if applicable.
 542             // The evn var should be the name of the option prefixed with
 543             // &quot;JSC_&quot;.
 544 #if PLATFORM(COCOA)
 545             bool hasBadOptions = false;
 546             for (char** envp = *_NSGetEnviron(); *envp; envp++) {
 547                 const char* env = *envp;
 548                 if (!strncmp(&quot;JSC_&quot;, env, 4)) {
 549                     if (!Options::setOption(&amp;env[4])) {
 550                         dataLog(&quot;ERROR: invalid option: &quot;, *envp, &quot;\n&quot;);
 551                         hasBadOptions = true;
 552                     }
 553                 }
 554             }
 555             if (hasBadOptions &amp;&amp; Options::validateOptions())
 556                 CRASH();
 557 #else // PLATFORM(COCOA)
<span class="line-modified"> 558 #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
 559             overrideOptionWithHeuristic(name_(), name_##ID, &quot;JSC_&quot; #name_, Availability::availability_);
<span class="line-modified"> 560             JSC_OPTIONS(FOR_EACH_OPTION)</span>
<span class="line-modified"> 561 #undef FOR_EACH_OPTION</span>
 562 #endif // PLATFORM(COCOA)
 563 
<span class="line-modified"> 564 #define FOR_EACH_OPTION(aliasedName_, unaliasedName_, equivalence_) \</span>
 565             overrideAliasedOptionWithHeuristic(&quot;JSC_&quot; #aliasedName_);
<span class="line-modified"> 566             JSC_ALIASED_OPTIONS(FOR_EACH_OPTION)</span>
<span class="line-modified"> 567 #undef FOR_EACH_OPTION</span>
 568 
 569 #if 0
 570                 ; // Deconfuse editors that do auto indentation
 571 #endif
 572 
 573             correctOptions();
 574 
 575             recomputeDependentOptions();
 576 
 577             // Do range checks where needed and make corrections to the options:
 578             ASSERT(Options::thresholdForOptimizeAfterLongWarmUp() &gt;= Options::thresholdForOptimizeAfterWarmUp());
 579             ASSERT(Options::thresholdForOptimizeAfterWarmUp() &gt;= Options::thresholdForOptimizeSoon());
 580             ASSERT(Options::thresholdForOptimizeAfterWarmUp() &gt;= 0);
 581             ASSERT(Options::criticalGCMemoryThreshold() &gt; 0.0 &amp;&amp; Options::criticalGCMemoryThreshold() &lt; 1.0);
 582 
 583             dumpOptionsIfNeeded();
 584             ensureOptionsAreCoherent();
 585 
 586 #if HAVE(MACH_EXCEPTIONS)
 587             if (Options::useMachForExceptions())
</pre>
<hr />
<pre>
 625             title = &quot;All JSC options:&quot;;
 626             break;
 627         case DumpLevel::Verbose:
 628             title = &quot;All JSC options with descriptions:&quot;;
 629             break;
 630         }
 631 
 632         StringBuilder builder;
 633         dumpAllOptions(builder, level, title, nullptr, &quot;   &quot;, &quot;\n&quot;, DumpDefaults);
 634         dataLog(builder.toString());
 635     }
 636 }
 637 
 638 static bool isSeparator(char c)
 639 {
 640     return isASCIISpace(c) || (c == &#39;,&#39;);
 641 }
 642 
 643 bool Options::setOptions(const char* optionsStr)
 644 {

 645     Vector&lt;char*&gt; options;
 646 
 647     size_t length = strlen(optionsStr);
 648     char* optionsStrCopy = WTF::fastStrDup(optionsStr);
 649     char* end = optionsStrCopy + length;
 650     char* p = optionsStrCopy;
 651 
 652     while (p &lt; end) {
 653         // Skip separators (white space or commas).
 654         while (p &lt; end &amp;&amp; isSeparator(*p))
 655             p++;
 656         if (p == end)
 657             break;
 658 
 659         char* optionStart = p;
 660         p = strstr(p, &quot;=&quot;);
 661         if (!p) {
 662             dataLogF(&quot;&#39;=&#39; not found in option string: %p\n&quot;, optionStart);
 663             WTF::fastFree(optionsStrCopy);
 664             return false;
</pre>
<hr />
<pre>
 717 
 718     ensureOptionsAreCoherent();
 719 
 720     WTF::fastFree(optionsStrCopy);
 721 
 722     return success;
 723 }
 724 
 725 // Parses a single command line option in the format &quot;&lt;optionName&gt;=&lt;value&gt;&quot;
 726 // (no spaces allowed) and set the specified option if appropriate.
 727 bool Options::setOptionWithoutAlias(const char* arg)
 728 {
 729     // arg should look like this:
 730     //   &lt;jscOptionName&gt;=&lt;appropriate value&gt;
 731     const char* equalStr = strchr(arg, &#39;=&#39;);
 732     if (!equalStr)
 733         return false;
 734 
 735     const char* valueStr = equalStr + 1;
 736 
<span class="line-modified"> 737     // For each option, check if the specify arg is a match. If so, set the arg</span>
 738     // if the value makes sense. Otherwise, move on to checking the next option.
<span class="line-modified"> 739 #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
 740     if (strlen(#name_) == static_cast&lt;size_t&gt;(equalStr - arg)      \
 741         &amp;&amp; !strncmp(arg, #name_, equalStr - arg)) {                \
 742         if (Availability::availability_ != Availability::Normal     \
 743             &amp;&amp; !isAvailable(name_##ID, Availability::availability_)) \
 744             return false;                                          \
<span class="line-modified"> 745         type_ value;                                               \</span>
<span class="line-modified"> 746         value = (defaultValue_);                                   \</span>
<span class="line-modified"> 747         bool success = parse(valueStr, value);                     \</span>
<span class="line-modified"> 748         if (success) {                                             \</span>
<span class="line-removed"> 749             name_() = value;                                       \</span>
 750             correctOptions();                                      \
 751             recomputeDependentOptions();                           \
 752             return true;                                           \
 753         }                                                          \
 754         return false;                                              \
 755     }
 756 
<span class="line-modified"> 757     JSC_OPTIONS(FOR_EACH_OPTION)</span>
<span class="line-modified"> 758 #undef FOR_EACH_OPTION</span>
 759 
 760     return false; // No option matched.
 761 }
 762 
<span class="line-modified"> 763 static bool invertBoolOptionValue(const char* valueStr, const char*&amp; invertedValueStr)</span>
 764 {
<span class="line-modified"> 765     bool boolValue;</span>
<span class="line-modified"> 766     if (!parse(valueStr, boolValue))</span>
<span class="line-modified"> 767         return false;</span>
<span class="line-modified"> 768     invertedValueStr = boolValue ? &quot;false&quot; : &quot;true&quot;;</span>
<span class="line-removed"> 769     return true;</span>
 770 }
 771 
 772 
 773 bool Options::setAliasedOption(const char* arg)
 774 {
 775     // arg should look like this:
 776     //   &lt;jscOptionName&gt;=&lt;appropriate value&gt;
 777     const char* equalStr = strchr(arg, &#39;=&#39;);
 778     if (!equalStr)
 779         return false;
 780 
 781     IGNORE_WARNINGS_BEGIN(&quot;tautological-compare&quot;)
 782 
 783     // For each option, check if the specify arg is a match. If so, set the arg
 784     // if the value makes sense. Otherwise, move on to checking the next option.
 785 #define FOR_EACH_OPTION(aliasedName_, unaliasedName_, equivalence) \
 786     if (strlen(#aliasedName_) == static_cast&lt;size_t&gt;(equalStr - arg)    \
 787         &amp;&amp; !strncmp(arg, #aliasedName_, equalStr - arg)) {              \
 788         String unaliasedOption(#unaliasedName_);                        \
 789         if (equivalence == SameOption)                                  \
 790             unaliasedOption = unaliasedOption + equalStr;               \
 791         else {                                                          \
 792             ASSERT(equivalence == InvertedOption);                      \
<span class="line-modified"> 793             const char* invertedValueStr = nullptr;                     \</span>
<span class="line-modified"> 794             if (!invertBoolOptionValue(equalStr + 1, invertedValueStr)) \</span>
 795                 return false;                                           \
 796             unaliasedOption = unaliasedOption + &quot;=&quot; + invertedValueStr; \
 797         }                                                               \
 798         return setOptionWithoutAlias(unaliasedOption.utf8().data());   \
 799     }
 800 
<span class="line-modified"> 801     JSC_ALIASED_OPTIONS(FOR_EACH_OPTION)</span>
 802 #undef FOR_EACH_OPTION
 803 
 804     IGNORE_WARNINGS_END
 805 
 806     return false; // No option matched.
 807 }
 808 
 809 bool Options::setOption(const char* arg)
 810 {
 811     bool success = setOptionWithoutAlias(arg);
 812     if (success)
 813         return true;
 814     return setAliasedOption(arg);
 815 }
 816 
 817 
 818 void Options::dumpAllOptions(StringBuilder&amp; builder, DumpLevel level, const char* title,
 819     const char* separator, const char* optionHeader, const char* optionFooter, DumpDefaultsOption dumpDefaultsOption)
 820 {
 821     if (title) {
 822         builder.append(title);
 823         builder.append(&#39;\n&#39;);
 824     }
 825 
<span class="line-modified"> 826     for (int id = 0; id &lt; numberOfOptions; id++) {</span>
 827         if (separator &amp;&amp; id)
 828             builder.append(separator);
 829         dumpOption(builder, level, static_cast&lt;ID&gt;(id), optionHeader, optionFooter, dumpDefaultsOption);
 830     }
 831 }
 832 
 833 void Options::dumpAllOptionsInALine(StringBuilder&amp; builder)
 834 {
 835     dumpAllOptions(builder, DumpLevel::All, nullptr, &quot; &quot;, nullptr, nullptr, DontDumpDefaults);
 836 }
 837 
 838 void Options::dumpAllOptions(FILE* stream, DumpLevel level, const char* title)
 839 {
 840     StringBuilder builder;
 841     dumpAllOptions(builder, level, title, nullptr, &quot;   &quot;, &quot;\n&quot;, DumpDefaults);
 842     fprintf(stream, &quot;%s&quot;, builder.toString().utf8().data());
 843 }
 844 










































 845 void Options::dumpOption(StringBuilder&amp; builder, DumpLevel level, Options::ID id,
 846     const char* header, const char* footer, DumpDefaultsOption dumpDefaultsOption)
 847 {
<span class="line-modified"> 848     if (id &gt;= numberOfOptions)</span>
<span class="line-removed"> 849         return; // Illegal option.</span>
 850 
<span class="line-modified"> 851     Option option(id);</span>
 852     Availability availability = option.availability();
 853     if (availability != Availability::Normal &amp;&amp; !isAvailable(id, availability))
 854         return;
 855 
 856     bool wasOverridden = option.isOverridden();
 857     bool needsDescription = (level == DumpLevel::Verbose &amp;&amp; option.description());
 858 
 859     if (level == DumpLevel::Overridden &amp;&amp; !wasOverridden)
 860         return;
 861 
 862     if (header)
 863         builder.append(header);
 864     builder.append(option.name(), &#39;=&#39;);
 865     option.dump(builder);
 866 
 867     if (wasOverridden &amp;&amp; (dumpDefaultsOption == DumpDefaults)) {

 868         builder.appendLiteral(&quot; (default: &quot;);
<span class="line-modified"> 869         option.defaultOption().dump(builder);</span>
 870         builder.appendLiteral(&quot;)&quot;);
 871     }
 872 
 873     if (needsDescription)
 874         builder.append(&quot;   ... &quot;, option.description());
 875 
 876     builder.append(footer);
 877 }
 878 
 879 void Options::ensureOptionsAreCoherent()
 880 {
 881     bool coherent = true;
 882     if (!(useLLInt() || useJIT())) {
 883         coherent = false;
 884         dataLog(&quot;INCOHERENT OPTIONS: at least one of useLLInt or useJIT must be true\n&quot;);
 885     }
 886     if (!coherent)
 887         CRASH();
 888 }
 889 
<span class="line-modified"> 890 void Option::dump(StringBuilder&amp; builder) const</span>









































 891 {
 892     switch (type()) {
<span class="line-modified"> 893     case Options::Type::boolType:</span>
<span class="line-modified"> 894         builder.append(m_entry.boolVal ? &quot;true&quot; : &quot;false&quot;);</span>
 895         break;
<span class="line-modified"> 896     case Options::Type::unsignedType:</span>
<span class="line-modified"> 897         builder.appendNumber(m_entry.unsignedVal);</span>
 898         break;
<span class="line-modified"> 899     case Options::Type::sizeType:</span>
<span class="line-modified"> 900         builder.appendNumber(m_entry.sizeVal);</span>
 901         break;
<span class="line-modified"> 902     case Options::Type::doubleType:</span>
<span class="line-modified"> 903         builder.appendFixedPrecisionNumber(m_entry.doubleVal);</span>
 904         break;
<span class="line-modified"> 905     case Options::Type::int32Type:</span>
<span class="line-modified"> 906         builder.appendNumber(m_entry.int32Val);</span>
 907         break;
<span class="line-modified"> 908     case Options::Type::optionRangeType:</span>
<span class="line-modified"> 909         builder.append(m_entry.optionRangeVal.rangeString());</span>
 910         break;
<span class="line-modified"> 911     case Options::Type::optionStringType: {</span>
<span class="line-modified"> 912         const char* option = m_entry.optionStringVal;</span>
 913         if (!option)
 914             option = &quot;&quot;;
 915         builder.append(&#39;&quot;&#39;);
 916         builder.append(option);
 917         builder.append(&#39;&quot;&#39;);
 918         break;
 919     }
<span class="line-modified"> 920     case Options::Type::gcLogLevelType: {</span>
<span class="line-modified"> 921         builder.append(GCLogging::levelAsString(m_entry.gcLogLevelVal));</span>
 922         break;
 923     }
 924     }
 925 }
 926 
<span class="line-modified"> 927 bool Option::operator==(const Option&amp; other) const</span>
 928 {

 929     switch (type()) {
<span class="line-modified"> 930     case Options::Type::boolType:</span>
<span class="line-modified"> 931         return m_entry.boolVal == other.m_entry.boolVal;</span>
<span class="line-modified"> 932     case Options::Type::unsignedType:</span>
<span class="line-modified"> 933         return m_entry.unsignedVal == other.m_entry.unsignedVal;</span>
<span class="line-modified"> 934     case Options::Type::sizeType:</span>
<span class="line-modified"> 935         return m_entry.sizeVal == other.m_entry.sizeVal;</span>
<span class="line-modified"> 936     case Options::Type::doubleType:</span>
<span class="line-modified"> 937         return (m_entry.doubleVal == other.m_entry.doubleVal) || (std::isnan(m_entry.doubleVal) &amp;&amp; std::isnan(other.m_entry.doubleVal));</span>
<span class="line-modified"> 938     case Options::Type::int32Type:</span>
<span class="line-modified"> 939         return m_entry.int32Val == other.m_entry.int32Val;</span>
<span class="line-modified"> 940     case Options::Type::optionRangeType:</span>
<span class="line-modified"> 941         return m_entry.optionRangeVal.rangeString() == other.m_entry.optionRangeVal.rangeString();</span>
<span class="line-modified"> 942     case Options::Type::optionStringType:</span>
<span class="line-modified"> 943         return (m_entry.optionStringVal == other.m_entry.optionStringVal)</span>
<span class="line-modified"> 944             || (m_entry.optionStringVal &amp;&amp; other.m_entry.optionStringVal &amp;&amp; !strcmp(m_entry.optionStringVal, other.m_entry.optionStringVal));</span>
<span class="line-modified"> 945     case Options::Type::gcLogLevelType:</span>
<span class="line-modified"> 946         return m_entry.gcLogLevelVal == other.m_entry.gcLogLevelVal;</span>
 947     }
 948     return false;
 949 }
 950 
 951 } // namespace JSC
<span class="line-removed"> 952 </span>
</pre>
</td>
<td>
<hr />
<pre>
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Options.h&quot;
  28 
  29 #include &quot;AssemblerCommon.h&quot;
  30 #include &quot;CPU.h&quot;
  31 #include &quot;LLIntCommon.h&quot;
  32 #include &quot;MinimumReservedZoneSize.h&quot;
  33 #include &quot;SigillCrashAnalyzer.h&quot;
  34 #include &lt;algorithm&gt;
  35 #include &lt;limits&gt;
  36 #include &lt;math.h&gt;
  37 #include &lt;mutex&gt;
  38 #include &lt;stdlib.h&gt;
  39 #include &lt;string.h&gt;
  40 #include &lt;wtf/ASCIICType.h&gt;
  41 #include &lt;wtf/Compiler.h&gt;
  42 #include &lt;wtf/DataLog.h&gt;
  43 #include &lt;wtf/NumberOfCores.h&gt;
<span class="line-added">  44 #include &lt;wtf/Optional.h&gt;</span>
  45 #include &lt;wtf/PointerPreparations.h&gt;
  46 #include &lt;wtf/StdLibExtras.h&gt;
  47 #include &lt;wtf/text/StringBuilder.h&gt;
  48 #include &lt;wtf/threads/Signals.h&gt;
  49 
  50 #if PLATFORM(COCOA)
  51 #include &lt;crt_externs.h&gt;
  52 #endif
  53 
  54 #if ENABLE(JIT)
  55 #include &quot;MacroAssembler.h&quot;
  56 #endif
  57 
  58 namespace JSC {
  59 
<span class="line-modified">  60 template&lt;typename T&gt;</span>
<span class="line-modified">  61 Optional&lt;T&gt; parse(const char* string);</span>










  62 
<span class="line-modified">  63 template&lt;&gt;</span>
<span class="line-added">  64 Optional&lt;OptionsStorage::Bool&gt; parse(const char* string)</span>
  65 {
<span class="line-modified">  66     if (equalLettersIgnoringASCIICase(string, &quot;true&quot;) || equalLettersIgnoringASCIICase(string, &quot;yes&quot;) || !strcmp(string, &quot;1&quot;))</span>

  67         return true;
<span class="line-modified">  68     if (equalLettersIgnoringASCIICase(string, &quot;false&quot;) || equalLettersIgnoringASCIICase(string, &quot;no&quot;) || !strcmp(string, &quot;0&quot;))</span>
<span class="line-modified">  69         return false;</span>
<span class="line-modified">  70     return WTF::nullopt;</span>








  71 }
  72 
<span class="line-modified">  73 template&lt;&gt;</span>
<span class="line-added">  74 Optional&lt;OptionsStorage::Int32&gt; parse(const char* string)</span>
  75 {
<span class="line-modified">  76     int32_t value;</span>
<span class="line-added">  77     if (sscanf(string, &quot;%d&quot;, &amp;value) == 1)</span>
<span class="line-added">  78         return value;</span>
<span class="line-added">  79     return WTF::nullopt;</span>
  80 }
  81 
<span class="line-modified">  82 template&lt;&gt;</span>
<span class="line-added">  83 Optional&lt;OptionsStorage::Unsigned&gt; parse(const char* string)</span>
  84 {
<span class="line-modified">  85     unsigned value;</span>
<span class="line-added">  86     if (sscanf(string, &quot;%u&quot;, &amp;value) == 1)</span>
<span class="line-added">  87         return value;</span>
<span class="line-added">  88     return WTF::nullopt;</span>
  89 }
  90 
<span class="line-modified">  91 #if CPU(ADDRESS64) || OS(DARWIN)</span>
<span class="line-added">  92 template&lt;&gt;</span>
<span class="line-added">  93 Optional&lt;OptionsStorage::Size&gt; parse(const char* string)</span>
  94 {
<span class="line-modified">  95     size_t value;</span>
<span class="line-added">  96     if (sscanf(string, &quot;%zu&quot;, &amp;value) == 1)</span>
<span class="line-added">  97         return value;</span>
<span class="line-added">  98     return WTF::nullopt;</span>
  99 }
<span class="line-added"> 100 #endif // CPU(ADDRESS64) || OS(DARWIN)</span>
 101 
<span class="line-modified"> 102 template&lt;&gt;</span>
<span class="line-added"> 103 Optional&lt;OptionsStorage::Double&gt; parse(const char* string)</span>
 104 {
<span class="line-modified"> 105     double value;</span>
<span class="line-added"> 106     if (sscanf(string, &quot;%lf&quot;, &amp;value) == 1)</span>
<span class="line-added"> 107         return value;</span>
<span class="line-added"> 108     return WTF::nullopt;</span>
 109 }
 110 
<span class="line-modified"> 111 template&lt;&gt;</span>
<span class="line-added"> 112 Optional&lt;OptionsStorage::OptionRange&gt; parse(const char* string)</span>
 113 {
<span class="line-modified"> 114     OptionRange range;</span>
<span class="line-added"> 115     if (range.init(string))</span>
<span class="line-added"> 116         return range;</span>
<span class="line-added"> 117     return WTF::nullopt;</span>
 118 }
 119 
<span class="line-modified"> 120 template&lt;&gt;</span>
<span class="line-added"> 121 Optional&lt;OptionsStorage::OptionString&gt; parse(const char* string)</span>
 122 {
<span class="line-modified"> 123     const char* value = nullptr;</span>
<span class="line-modified"> 124     if (!strlen(string))</span>
<span class="line-modified"> 125         return value;</span>

 126 
 127     // FIXME &lt;https://webkit.org/b/169057&gt;: This could leak if this option is set more than once.
 128     // Given that Options are typically used for testing, this isn&#39;t considered to be a problem.
 129     value = WTF::fastStrDup(string);
<span class="line-modified"> 130     return value;</span>
 131 }
 132 
<span class="line-modified"> 133 template&lt;&gt;</span>
<span class="line-added"> 134 Optional&lt;OptionsStorage::GCLogLevel&gt; parse(const char* string)</span>
 135 {
<span class="line-modified"> 136     if (equalLettersIgnoringASCIICase(string, &quot;none&quot;) || equalLettersIgnoringASCIICase(string, &quot;no&quot;) || equalLettersIgnoringASCIICase(string, &quot;false&quot;) || !strcmp(string, &quot;0&quot;))</span>
<span class="line-modified"> 137         return GCLogging::None;</span>


 138 
<span class="line-modified"> 139     if (equalLettersIgnoringASCIICase(string, &quot;basic&quot;) || equalLettersIgnoringASCIICase(string, &quot;yes&quot;) || equalLettersIgnoringASCIICase(string, &quot;true&quot;) || !strcmp(string, &quot;1&quot;))</span>
<span class="line-modified"> 140         return GCLogging::Basic;</span>


 141 
<span class="line-modified"> 142     if (equalLettersIgnoringASCIICase(string, &quot;verbose&quot;) || !strcmp(string, &quot;2&quot;))</span>
<span class="line-modified"> 143         return GCLogging::Verbose;</span>


 144 
<span class="line-modified"> 145     return WTF::nullopt;</span>
 146 }
 147 
 148 bool Options::isAvailable(Options::ID id, Options::Availability availability)
 149 {
 150     if (availability == Availability::Restricted)
<span class="line-modified"> 151         return g_jscConfig.restrictedOptionsEnabled;</span>
 152     ASSERT(availability == Availability::Configurable);
 153 
 154     UNUSED_PARAM(id);
 155 #if !defined(NDEBUG)
 156     if (id == maxSingleAllocationSizeID)
 157         return true;
 158 #endif
 159 #if OS(DARWIN)
 160     if (id == useSigillCrashAnalyzerID)
 161         return true;
 162 #endif
 163 #if ENABLE(ASSEMBLER) &amp;&amp; OS(LINUX)
 164     if (id == logJITCodeForPerfID)
 165         return true;
 166 #endif
 167     if (id == traceLLIntExecutionID)
 168         return !!LLINT_TRACING;
 169     if (id == traceLLIntSlowPathID)
 170         return !!LLINT_TRACING;
 171     return false;
 172 }
 173 
 174 template&lt;typename T&gt;
 175 bool overrideOptionWithHeuristic(T&amp; variable, Options::ID id, const char* name, Options::Availability availability)
 176 {
 177     bool available = (availability == Options::Availability::Normal)
 178         || Options::isAvailable(id, availability);
 179 
 180     const char* stringValue = getenv(name);
 181     if (!stringValue)
 182         return false;
 183 
<span class="line-modified"> 184     if (available) {</span>
<span class="line-modified"> 185         Optional&lt;T&gt; value = parse&lt;T&gt;(stringValue);</span>
<span class="line-added"> 186         if (value) {</span>
<span class="line-added"> 187             variable = value.value();</span>
<span class="line-added"> 188             return true;</span>
<span class="line-added"> 189         }</span>
<span class="line-added"> 190     }</span>
 191 
 192     fprintf(stderr, &quot;WARNING: failed to parse %s=%s\n&quot;, name, stringValue);
 193     return false;
 194 }
 195 
 196 bool Options::overrideAliasedOptionWithHeuristic(const char* name)
 197 {
 198     const char* stringValue = getenv(name);
 199     if (!stringValue)
 200         return false;
 201 
 202     String aliasedOption;
 203     aliasedOption = String(&amp;name[4]) + &quot;=&quot; + stringValue;
 204     if (Options::setOption(aliasedOption.utf8().data()))
 205         return true;
 206 
 207     fprintf(stderr, &quot;WARNING: failed to parse %s=%s\n&quot;, name, stringValue);
 208     return false;
 209 }
 210 
</pre>
<hr />
<pre>
 283 
 284     return true;
 285 }
 286 
 287 bool OptionRange::isInRange(unsigned count)
 288 {
 289     if (m_state &lt; Normal)
 290         return true;
 291 
 292     if ((m_lowLimit &lt;= count) &amp;&amp; (count &lt;= m_highLimit))
 293         return m_state == Normal ? true : false;
 294 
 295     return m_state == Normal ? false : true;
 296 }
 297 
 298 void OptionRange::dump(PrintStream&amp; out) const
 299 {
 300     out.print(m_rangeString);
 301 }
 302 



 303 // Realize the names for each of the options:
<span class="line-modified"> 304 const Options::ConstMetaData Options::s_constMetaData[NumberOfOptions] = {</span>
<span class="line-modified"> 305 #define FILL_OPTION_INFO(type_, name_, defaultValue_, availability_, description_) \</span>
<span class="line-modified"> 306     { #name_, description_, Options::Type::type_, Availability::availability_, offsetof(OptionsStorage, name_), offsetof(OptionsStorage, name_##Default) },</span>
<span class="line-modified"> 307     FOR_EACH_JSC_OPTION(FILL_OPTION_INFO)</span>
<span class="line-modified"> 308 #undef FILL_OPTION_INFO</span>
 309 };
 310 
 311 static void scaleJITPolicy()
 312 {
 313     auto&amp; scaleFactor = Options::jitPolicyScale();
 314     if (scaleFactor &gt; 1.0)
 315         scaleFactor = 1.0;
 316     else if (scaleFactor &lt; 0.0)
 317         scaleFactor = 0.0;
 318 
<span class="line-modified"> 319     auto scaleOption = [&amp;] (int32_t&amp; optionValue, int32_t minValue) {</span>
<span class="line-modified"> 320         optionValue *= scaleFactor;</span>
<span class="line-modified"> 321         optionValue = std::max(optionValue, minValue);</span>
 322     };
 323 
<span class="line-modified"> 324     scaleOption(Options::thresholdForJITAfterWarmUp(), 0);</span>
<span class="line-modified"> 325     scaleOption(Options::thresholdForJITSoon(), 0);</span>
<span class="line-modified"> 326     scaleOption(Options::thresholdForOptimizeAfterWarmUp(), 1);</span>
<span class="line-modified"> 327     scaleOption(Options::thresholdForOptimizeAfterLongWarmUp(), 1);</span>
<span class="line-modified"> 328     scaleOption(Options::thresholdForOptimizeSoon(), 1);</span>
<span class="line-modified"> 329     scaleOption(Options::thresholdForFTLOptimizeSoon(), 2);</span>
<span class="line-modified"> 330     scaleOption(Options::thresholdForFTLOptimizeAfterWarmUp(), 2);</span>










 331 }
 332 
 333 static void overrideDefaults()
 334 {
 335 #if !PLATFORM(IOS_FAMILY)
 336     if (WTF::numberOfProcessorCores() &lt; 4)
 337 #endif
 338     {
 339         Options::maximumMutatorUtilization() = 0.6;
 340         Options::concurrentGCMaxHeadroom() = 1.4;
 341         Options::minimumGCPauseMS() = 1;
 342         Options::useStochasticMutatorScheduler() = false;
 343         if (WTF::numberOfProcessorCores() &lt;= 1)
 344             Options::gcIncrementScale() = 1;
 345         else
 346             Options::gcIncrementScale() = 0;
 347     }
 348 
<span class="line-modified"> 349 #if USE(BMALLOC_MEMORY_FOOTPRINT_API)</span>
<span class="line-modified"> 350     // On iOS and conditionally Linux, we control heap growth using process memory footprint. Therefore these values can be agressive.</span>
 351     Options::smallHeapRAMFraction() = 0.8;
 352     Options::mediumHeapRAMFraction() = 0.9;
<span class="line-added"> 353 #endif</span>
 354 
<span class="line-modified"> 355 #if PLATFORM(IOS_FAMILY) &amp;&amp; !PLATFORM(WATCHOS) &amp;&amp; defined(__LP64__)</span>
 356     Options::useSigillCrashAnalyzer() = true;
 357 #endif

 358 
 359 #if !ENABLE(SIGNAL_BASED_VM_TRAPS)
 360     Options::usePollingTraps() = true;
 361 #endif
 362 
 363 #if !ENABLE(WEBASSEMBLY_FAST_MEMORY)
 364     Options::useWebAssemblyFastMemory() = false;
 365 #endif
 366 
 367 #if !HAVE(MACH_EXCEPTIONS)
 368     Options::useMachForExceptions() = false;
 369 #endif
<span class="line-added"> 370 </span>
<span class="line-added"> 371     if (Options::useWasmLLInt() &amp;&amp; !Options::wasmLLIntTiersUpToBBQ()) {</span>
<span class="line-added"> 372         Options::thresholdForOMGOptimizeAfterWarmUp() = 1500;</span>
<span class="line-added"> 373         Options::thresholdForOMGOptimizeSoon() = 100;</span>
<span class="line-added"> 374     }</span>
 375 }
 376 
 377 static void correctOptions()
 378 {
 379     unsigned thresholdForGlobalLexicalBindingEpoch = Options::thresholdForGlobalLexicalBindingEpoch();
 380     if (thresholdForGlobalLexicalBindingEpoch == 0 || thresholdForGlobalLexicalBindingEpoch == 1)
 381         Options::thresholdForGlobalLexicalBindingEpoch() = UINT_MAX;
 382 }
 383 
 384 static void recomputeDependentOptions()
 385 {
 386 #if !defined(NDEBUG)
 387     Options::validateDFGExceptionHandling() = true;
 388 #endif
 389 #if !ENABLE(JIT)
 390     Options::useLLInt() = true;
 391     Options::useJIT() = false;
 392     Options::useBaselineJIT() = false;
 393     Options::useDFGJIT() = false;
 394     Options::useFTLJIT() = false;
</pre>
<hr />
<pre>
 431         || Options::dumpGraphAtEachPhase()
 432         || Options::dumpDFGGraphAtEachPhase()
 433         || Options::dumpDFGFTLGraphAtEachPhase()
 434         || Options::dumpB3GraphAtEachPhase()
 435         || Options::dumpAirGraphAtEachPhase()
 436         || Options::verboseCompilation()
 437         || Options::verboseFTLCompilation()
 438         || Options::logCompilationChanges()
 439         || Options::validateGraph()
 440         || Options::validateGraphAtEachPhase()
 441         || Options::verboseOSR()
 442         || Options::verboseCompilationQueue()
 443         || Options::reportCompileTimes()
 444         || Options::reportBaselineCompileTimes()
 445         || Options::reportDFGCompileTimes()
 446         || Options::reportFTLCompileTimes()
 447         || Options::logPhaseTimes()
 448         || Options::verboseCFA()
 449         || Options::verboseDFGFailure()
 450         || Options::verboseFTLFailure()
<span class="line-modified"> 451         || Options::dumpFuzzerAgentPredictions())</span>
 452         Options::alwaysComputeHash() = true;
 453 
 454     if (!Options::useConcurrentGC())
 455         Options::collectContinuously() = false;
 456 
<span class="line-modified"> 457     if (Options::jitPolicyScale() != Options::jitPolicyScaleDefault())</span>
 458         scaleJITPolicy();
 459 
 460     if (Options::forceEagerCompilation()) {
 461         Options::thresholdForJITAfterWarmUp() = 10;
 462         Options::thresholdForJITSoon() = 10;
 463         Options::thresholdForOptimizeAfterWarmUp() = 20;
 464         Options::thresholdForOptimizeAfterLongWarmUp() = 20;
 465         Options::thresholdForOptimizeSoon() = 20;
 466         Options::thresholdForFTLOptimizeAfterWarmUp() = 20;
 467         Options::thresholdForFTLOptimizeSoon() = 20;
 468         Options::maximumEvalCacheableSourceLength() = 150000;
 469         Options::useConcurrentJIT() = false;
 470     }
 471 #if ENABLE(SEPARATED_WX_HEAP)
 472     // Override globally for now. Longer term we&#39;ll just make the default
 473     // be to have this option enabled, and have platforms that don&#39;t support
 474     // it just silently use a single mapping.
 475     Options::useSeparatedWXHeap() = true;
 476 #else
 477     Options::useSeparatedWXHeap() = false;
</pre>
<hr />
<pre>
 492     ASSERT((static_cast&lt;int64_t&gt;(Options::thresholdForOptimizeAfterLongWarmUp()) &lt;&lt; Options::reoptimizationRetryCounterMax()) &gt; 0);
 493     ASSERT((static_cast&lt;int64_t&gt;(Options::thresholdForOptimizeAfterLongWarmUp()) &lt;&lt; Options::reoptimizationRetryCounterMax()) &lt;= static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()));
 494 
 495 #if !defined(NDEBUG)
 496     if (Options::maxSingleAllocationSize())
 497         fastSetMaxSingleAllocationSize(Options::maxSingleAllocationSize());
 498     else
 499         fastSetMaxSingleAllocationSize(std::numeric_limits&lt;size_t&gt;::max());
 500 #endif
 501 
 502     if (Options::useZombieMode()) {
 503         Options::sweepSynchronously() = true;
 504         Options::scribbleFreeCells() = true;
 505     }
 506 
 507     if (Options::reservedZoneSize() &lt; minimumReservedZoneSize)
 508         Options::reservedZoneSize() = minimumReservedZoneSize;
 509     if (Options::softReservedZoneSize() &lt; Options::reservedZoneSize() + minimumReservedZoneSize)
 510         Options::softReservedZoneSize() = Options::reservedZoneSize() + minimumReservedZoneSize;
 511 

 512     // FIXME: Make probe OSR exit work on 32-bit:
 513     // https://bugs.webkit.org/show_bug.cgi?id=177956
 514     Options::useProbeOSRExit() = false;

 515 
 516     if (!Options::useCodeCache())
 517         Options::diskCachePath() = nullptr;
<span class="line-added"> 518 </span>
<span class="line-added"> 519     if (Options::randomIntegrityAuditRate() &lt; 0)</span>
<span class="line-added"> 520         Options::randomIntegrityAuditRate() = 0;</span>
<span class="line-added"> 521     else if (Options::randomIntegrityAuditRate() &gt; 1.0)</span>
<span class="line-added"> 522         Options::randomIntegrityAuditRate() = 1.0;</span>
<span class="line-added"> 523 }</span>
<span class="line-added"> 524 </span>
<span class="line-added"> 525 inline void* Options::addressOfOption(Options::ID id)</span>
<span class="line-added"> 526 {</span>
<span class="line-added"> 527     auto offset = Options::s_constMetaData[id].offsetOfOption;</span>
<span class="line-added"> 528     return reinterpret_cast&lt;uint8_t*&gt;(&amp;g_jscConfig.options) + offset;</span>
<span class="line-added"> 529 }</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531 inline void* Options::addressOfOptionDefault(Options::ID id)</span>
<span class="line-added"> 532 {</span>
<span class="line-added"> 533     auto offset = Options::s_constMetaData[id].offsetOfOptionDefault;</span>
<span class="line-added"> 534     return reinterpret_cast&lt;uint8_t*&gt;(&amp;g_jscConfig.options) + offset;</span>
 535 }
 536 
 537 void Options::initialize()
 538 {
 539     static std::once_flag initializeOptionsOnceFlag;
 540 
 541     std::call_once(
 542         initializeOptionsOnceFlag,
 543         [] {
<span class="line-added"> 544             // Sanity check that options address computation is working.</span>
<span class="line-added"> 545             RELEASE_ASSERT(Options::addressOfOption(useKernTCSMID) ==  &amp;Options::useKernTCSM());</span>
<span class="line-added"> 546             RELEASE_ASSERT(Options::addressOfOptionDefault(useKernTCSMID) ==  &amp;Options::useKernTCSMDefault());</span>
<span class="line-added"> 547             RELEASE_ASSERT(Options::addressOfOption(gcMaxHeapSizeID) ==  &amp;Options::gcMaxHeapSize());</span>
<span class="line-added"> 548             RELEASE_ASSERT(Options::addressOfOptionDefault(gcMaxHeapSizeID) ==  &amp;Options::gcMaxHeapSizeDefault());</span>
<span class="line-added"> 549             RELEASE_ASSERT(Options::addressOfOption(forceOSRExitToLLIntID) ==  &amp;Options::forceOSRExitToLLInt());</span>
<span class="line-added"> 550             RELEASE_ASSERT(Options::addressOfOptionDefault(forceOSRExitToLLIntID) ==  &amp;Options::forceOSRExitToLLIntDefault());</span>
<span class="line-added"> 551 </span>
<span class="line-added"> 552 #ifndef NDEBUG</span>
<span class="line-added"> 553             Config::enableRestrictedOptions();</span>
<span class="line-added"> 554 #endif</span>
 555             // Initialize each of the options with their default values:
<span class="line-modified"> 556 #define INIT_OPTION(type_, name_, defaultValue_, availability_, description_) { \</span>
<span class="line-modified"> 557                 auto value = defaultValue_; \</span>
<span class="line-modified"> 558                 name_() = value; \</span>
<span class="line-modified"> 559                 name_##Default() = value; \</span>
<span class="line-modified"> 560             }</span>
<span class="line-added"> 561             FOR_EACH_JSC_OPTION(INIT_OPTION)</span>
<span class="line-added"> 562 #undef INIT_OPTION</span>
 563 
 564             overrideDefaults();
 565 
 566             // Allow environment vars to override options if applicable.
 567             // The evn var should be the name of the option prefixed with
 568             // &quot;JSC_&quot;.
 569 #if PLATFORM(COCOA)
 570             bool hasBadOptions = false;
 571             for (char** envp = *_NSGetEnviron(); *envp; envp++) {
 572                 const char* env = *envp;
 573                 if (!strncmp(&quot;JSC_&quot;, env, 4)) {
 574                     if (!Options::setOption(&amp;env[4])) {
 575                         dataLog(&quot;ERROR: invalid option: &quot;, *envp, &quot;\n&quot;);
 576                         hasBadOptions = true;
 577                     }
 578                 }
 579             }
 580             if (hasBadOptions &amp;&amp; Options::validateOptions())
 581                 CRASH();
 582 #else // PLATFORM(COCOA)
<span class="line-modified"> 583 #define OVERRIDE_OPTION_WITH_HEURISTICS(type_, name_, defaultValue_, availability_, description_) \</span>
 584             overrideOptionWithHeuristic(name_(), name_##ID, &quot;JSC_&quot; #name_, Availability::availability_);
<span class="line-modified"> 585             FOR_EACH_JSC_OPTION(OVERRIDE_OPTION_WITH_HEURISTICS)</span>
<span class="line-modified"> 586 #undef OVERRIDE_OPTION_WITH_HEURISTICS</span>
 587 #endif // PLATFORM(COCOA)
 588 
<span class="line-modified"> 589 #define OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS(aliasedName_, unaliasedName_, equivalence_) \</span>
 590             overrideAliasedOptionWithHeuristic(&quot;JSC_&quot; #aliasedName_);
<span class="line-modified"> 591             FOR_EACH_JSC_ALIASED_OPTION(OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS)</span>
<span class="line-modified"> 592 #undef OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS</span>
 593 
 594 #if 0
 595                 ; // Deconfuse editors that do auto indentation
 596 #endif
 597 
 598             correctOptions();
 599 
 600             recomputeDependentOptions();
 601 
 602             // Do range checks where needed and make corrections to the options:
 603             ASSERT(Options::thresholdForOptimizeAfterLongWarmUp() &gt;= Options::thresholdForOptimizeAfterWarmUp());
 604             ASSERT(Options::thresholdForOptimizeAfterWarmUp() &gt;= Options::thresholdForOptimizeSoon());
 605             ASSERT(Options::thresholdForOptimizeAfterWarmUp() &gt;= 0);
 606             ASSERT(Options::criticalGCMemoryThreshold() &gt; 0.0 &amp;&amp; Options::criticalGCMemoryThreshold() &lt; 1.0);
 607 
 608             dumpOptionsIfNeeded();
 609             ensureOptionsAreCoherent();
 610 
 611 #if HAVE(MACH_EXCEPTIONS)
 612             if (Options::useMachForExceptions())
</pre>
<hr />
<pre>
 650             title = &quot;All JSC options:&quot;;
 651             break;
 652         case DumpLevel::Verbose:
 653             title = &quot;All JSC options with descriptions:&quot;;
 654             break;
 655         }
 656 
 657         StringBuilder builder;
 658         dumpAllOptions(builder, level, title, nullptr, &quot;   &quot;, &quot;\n&quot;, DumpDefaults);
 659         dataLog(builder.toString());
 660     }
 661 }
 662 
 663 static bool isSeparator(char c)
 664 {
 665     return isASCIISpace(c) || (c == &#39;,&#39;);
 666 }
 667 
 668 bool Options::setOptions(const char* optionsStr)
 669 {
<span class="line-added"> 670     RELEASE_ASSERT(!g_jscConfig.isPermanentlyFrozen);</span>
 671     Vector&lt;char*&gt; options;
 672 
 673     size_t length = strlen(optionsStr);
 674     char* optionsStrCopy = WTF::fastStrDup(optionsStr);
 675     char* end = optionsStrCopy + length;
 676     char* p = optionsStrCopy;
 677 
 678     while (p &lt; end) {
 679         // Skip separators (white space or commas).
 680         while (p &lt; end &amp;&amp; isSeparator(*p))
 681             p++;
 682         if (p == end)
 683             break;
 684 
 685         char* optionStart = p;
 686         p = strstr(p, &quot;=&quot;);
 687         if (!p) {
 688             dataLogF(&quot;&#39;=&#39; not found in option string: %p\n&quot;, optionStart);
 689             WTF::fastFree(optionsStrCopy);
 690             return false;
</pre>
<hr />
<pre>
 743 
 744     ensureOptionsAreCoherent();
 745 
 746     WTF::fastFree(optionsStrCopy);
 747 
 748     return success;
 749 }
 750 
 751 // Parses a single command line option in the format &quot;&lt;optionName&gt;=&lt;value&gt;&quot;
 752 // (no spaces allowed) and set the specified option if appropriate.
 753 bool Options::setOptionWithoutAlias(const char* arg)
 754 {
 755     // arg should look like this:
 756     //   &lt;jscOptionName&gt;=&lt;appropriate value&gt;
 757     const char* equalStr = strchr(arg, &#39;=&#39;);
 758     if (!equalStr)
 759         return false;
 760 
 761     const char* valueStr = equalStr + 1;
 762 
<span class="line-modified"> 763     // For each option, check if the specified arg is a match. If so, set the arg</span>
 764     // if the value makes sense. Otherwise, move on to checking the next option.
<span class="line-modified"> 765 #define SET_OPTION_IF_MATCH(type_, name_, defaultValue_, availability_, description_) \</span>
 766     if (strlen(#name_) == static_cast&lt;size_t&gt;(equalStr - arg)      \
 767         &amp;&amp; !strncmp(arg, #name_, equalStr - arg)) {                \
 768         if (Availability::availability_ != Availability::Normal     \
 769             &amp;&amp; !isAvailable(name_##ID, Availability::availability_)) \
 770             return false;                                          \
<span class="line-modified"> 771         Optional&lt;OptionsStorage::type_&gt; value;                     \</span>
<span class="line-modified"> 772         value = parse&lt;OptionsStorage::type_&gt;(valueStr);            \</span>
<span class="line-modified"> 773         if (value) {                                               \</span>
<span class="line-modified"> 774             name_() = value.value();                               \</span>

 775             correctOptions();                                      \
 776             recomputeDependentOptions();                           \
 777             return true;                                           \
 778         }                                                          \
 779         return false;                                              \
 780     }
 781 
<span class="line-modified"> 782     FOR_EACH_JSC_OPTION(SET_OPTION_IF_MATCH)</span>
<span class="line-modified"> 783 #undef SET_OPTION_IF_MATCH</span>
 784 
 785     return false; // No option matched.
 786 }
 787 
<span class="line-modified"> 788 static const char* invertBoolOptionValue(const char* valueStr)</span>
 789 {
<span class="line-modified"> 790     Optional&lt;OptionsStorage::Bool&gt; value = parse&lt;OptionsStorage::Bool&gt;(valueStr);</span>
<span class="line-modified"> 791     if (!value)</span>
<span class="line-modified"> 792         return nullptr;</span>
<span class="line-modified"> 793     return value.value() ? &quot;false&quot; : &quot;true&quot;;</span>

 794 }
 795 
 796 
 797 bool Options::setAliasedOption(const char* arg)
 798 {
 799     // arg should look like this:
 800     //   &lt;jscOptionName&gt;=&lt;appropriate value&gt;
 801     const char* equalStr = strchr(arg, &#39;=&#39;);
 802     if (!equalStr)
 803         return false;
 804 
 805     IGNORE_WARNINGS_BEGIN(&quot;tautological-compare&quot;)
 806 
 807     // For each option, check if the specify arg is a match. If so, set the arg
 808     // if the value makes sense. Otherwise, move on to checking the next option.
 809 #define FOR_EACH_OPTION(aliasedName_, unaliasedName_, equivalence) \
 810     if (strlen(#aliasedName_) == static_cast&lt;size_t&gt;(equalStr - arg)    \
 811         &amp;&amp; !strncmp(arg, #aliasedName_, equalStr - arg)) {              \
 812         String unaliasedOption(#unaliasedName_);                        \
 813         if (equivalence == SameOption)                                  \
 814             unaliasedOption = unaliasedOption + equalStr;               \
 815         else {                                                          \
 816             ASSERT(equivalence == InvertedOption);                      \
<span class="line-modified"> 817             auto* invertedValueStr = invertBoolOptionValue(equalStr + 1); \</span>
<span class="line-modified"> 818             if (!invertedValueStr)                                      \</span>
 819                 return false;                                           \
 820             unaliasedOption = unaliasedOption + &quot;=&quot; + invertedValueStr; \
 821         }                                                               \
 822         return setOptionWithoutAlias(unaliasedOption.utf8().data());   \
 823     }
 824 
<span class="line-modified"> 825     FOR_EACH_JSC_ALIASED_OPTION(FOR_EACH_OPTION)</span>
 826 #undef FOR_EACH_OPTION
 827 
 828     IGNORE_WARNINGS_END
 829 
 830     return false; // No option matched.
 831 }
 832 
 833 bool Options::setOption(const char* arg)
 834 {
 835     bool success = setOptionWithoutAlias(arg);
 836     if (success)
 837         return true;
 838     return setAliasedOption(arg);
 839 }
 840 
 841 
 842 void Options::dumpAllOptions(StringBuilder&amp; builder, DumpLevel level, const char* title,
 843     const char* separator, const char* optionHeader, const char* optionFooter, DumpDefaultsOption dumpDefaultsOption)
 844 {
 845     if (title) {
 846         builder.append(title);
 847         builder.append(&#39;\n&#39;);
 848     }
 849 
<span class="line-modified"> 850     for (size_t id = 0; id &lt; NumberOfOptions; id++) {</span>
 851         if (separator &amp;&amp; id)
 852             builder.append(separator);
 853         dumpOption(builder, level, static_cast&lt;ID&gt;(id), optionHeader, optionFooter, dumpDefaultsOption);
 854     }
 855 }
 856 
 857 void Options::dumpAllOptionsInALine(StringBuilder&amp; builder)
 858 {
 859     dumpAllOptions(builder, DumpLevel::All, nullptr, &quot; &quot;, nullptr, nullptr, DontDumpDefaults);
 860 }
 861 
 862 void Options::dumpAllOptions(FILE* stream, DumpLevel level, const char* title)
 863 {
 864     StringBuilder builder;
 865     dumpAllOptions(builder, level, title, nullptr, &quot;   &quot;, &quot;\n&quot;, DumpDefaults);
 866     fprintf(stream, &quot;%s&quot;, builder.toString().utf8().data());
 867 }
 868 
<span class="line-added"> 869 struct OptionReader {</span>
<span class="line-added"> 870     class Option {</span>
<span class="line-added"> 871     public:</span>
<span class="line-added"> 872         void dump(StringBuilder&amp;) const;</span>
<span class="line-added"> 873 </span>
<span class="line-added"> 874         bool operator==(const Option&amp; other) const;</span>
<span class="line-added"> 875         bool operator!=(const Option&amp; other) const { return !(*this == other); }</span>
<span class="line-added"> 876 </span>
<span class="line-added"> 877         const char* name() const { return Options::s_constMetaData[m_id].name; }</span>
<span class="line-added"> 878         const char* description() const { return Options::s_constMetaData[m_id].description; }</span>
<span class="line-added"> 879         Options::Type type() const { return Options::s_constMetaData[m_id].type; }</span>
<span class="line-added"> 880         Options::Availability availability() const { return Options::s_constMetaData[m_id].availability; }</span>
<span class="line-added"> 881         bool isOverridden() const { return *this != OptionReader::defaultFor(m_id); }</span>
<span class="line-added"> 882 </span>
<span class="line-added"> 883     private:</span>
<span class="line-added"> 884         Option(Options::ID id, void* addressOfValue)</span>
<span class="line-added"> 885             : m_id(id)</span>
<span class="line-added"> 886         {</span>
<span class="line-added"> 887             initValue(addressOfValue);</span>
<span class="line-added"> 888         }</span>
<span class="line-added"> 889 </span>
<span class="line-added"> 890         void initValue(void* addressOfValue);</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892         Options::ID m_id;</span>
<span class="line-added"> 893         union {</span>
<span class="line-added"> 894             bool m_bool;</span>
<span class="line-added"> 895             unsigned m_unsigned;</span>
<span class="line-added"> 896             double m_double;</span>
<span class="line-added"> 897             int32_t m_int32;</span>
<span class="line-added"> 898             size_t m_size;</span>
<span class="line-added"> 899             OptionRange m_optionRange;</span>
<span class="line-added"> 900             const char* m_optionString;</span>
<span class="line-added"> 901             GCLogging::Level m_gcLogLevel;</span>
<span class="line-added"> 902         };</span>
<span class="line-added"> 903 </span>
<span class="line-added"> 904         friend struct OptionReader;</span>
<span class="line-added"> 905     };</span>
<span class="line-added"> 906 </span>
<span class="line-added"> 907     static const Option optionFor(Options::ID);</span>
<span class="line-added"> 908     static const Option defaultFor(Options::ID);</span>
<span class="line-added"> 909 };</span>
<span class="line-added"> 910 </span>
 911 void Options::dumpOption(StringBuilder&amp; builder, DumpLevel level, Options::ID id,
 912     const char* header, const char* footer, DumpDefaultsOption dumpDefaultsOption)
 913 {
<span class="line-modified"> 914     RELEASE_ASSERT(static_cast&lt;size_t&gt;(id) &lt; NumberOfOptions);</span>

 915 
<span class="line-modified"> 916     auto option = OptionReader::optionFor(id);</span>
 917     Availability availability = option.availability();
 918     if (availability != Availability::Normal &amp;&amp; !isAvailable(id, availability))
 919         return;
 920 
 921     bool wasOverridden = option.isOverridden();
 922     bool needsDescription = (level == DumpLevel::Verbose &amp;&amp; option.description());
 923 
 924     if (level == DumpLevel::Overridden &amp;&amp; !wasOverridden)
 925         return;
 926 
 927     if (header)
 928         builder.append(header);
 929     builder.append(option.name(), &#39;=&#39;);
 930     option.dump(builder);
 931 
 932     if (wasOverridden &amp;&amp; (dumpDefaultsOption == DumpDefaults)) {
<span class="line-added"> 933         auto defaultOption = OptionReader::defaultFor(id);</span>
 934         builder.appendLiteral(&quot; (default: &quot;);
<span class="line-modified"> 935         defaultOption.dump(builder);</span>
 936         builder.appendLiteral(&quot;)&quot;);
 937     }
 938 
 939     if (needsDescription)
 940         builder.append(&quot;   ... &quot;, option.description());
 941 
 942     builder.append(footer);
 943 }
 944 
 945 void Options::ensureOptionsAreCoherent()
 946 {
 947     bool coherent = true;
 948     if (!(useLLInt() || useJIT())) {
 949         coherent = false;
 950         dataLog(&quot;INCOHERENT OPTIONS: at least one of useLLInt or useJIT must be true\n&quot;);
 951     }
 952     if (!coherent)
 953         CRASH();
 954 }
 955 
<span class="line-modified"> 956 const OptionReader::Option OptionReader::optionFor(Options::ID id)</span>
<span class="line-added"> 957 {</span>
<span class="line-added"> 958     return Option(id, Options::addressOfOption(id));</span>
<span class="line-added"> 959 }</span>
<span class="line-added"> 960 </span>
<span class="line-added"> 961 const OptionReader::Option OptionReader::defaultFor(Options::ID id)</span>
<span class="line-added"> 962 {</span>
<span class="line-added"> 963     return Option(id, Options::addressOfOptionDefault(id));</span>
<span class="line-added"> 964 }</span>
<span class="line-added"> 965 </span>
<span class="line-added"> 966 void OptionReader::Option::initValue(void* addressOfValue)</span>
<span class="line-added"> 967 {</span>
<span class="line-added"> 968     Options::Type type = Options::s_constMetaData[m_id].type;</span>
<span class="line-added"> 969     switch (type) {</span>
<span class="line-added"> 970     case Options::Type::Bool:</span>
<span class="line-added"> 971         memcpy(&amp;m_bool, addressOfValue, sizeof(OptionsStorage::Bool));</span>
<span class="line-added"> 972         break;</span>
<span class="line-added"> 973     case Options::Type::Unsigned:</span>
<span class="line-added"> 974         memcpy(&amp;m_unsigned, addressOfValue, sizeof(OptionsStorage::Unsigned));</span>
<span class="line-added"> 975         break;</span>
<span class="line-added"> 976     case Options::Type::Double:</span>
<span class="line-added"> 977         memcpy(&amp;m_double, addressOfValue, sizeof(OptionsStorage::Double));</span>
<span class="line-added"> 978         break;</span>
<span class="line-added"> 979     case Options::Type::Int32:</span>
<span class="line-added"> 980         memcpy(&amp;m_int32, addressOfValue, sizeof(OptionsStorage::Int32));</span>
<span class="line-added"> 981         break;</span>
<span class="line-added"> 982     case Options::Type::Size:</span>
<span class="line-added"> 983         memcpy(&amp;m_size, addressOfValue, sizeof(OptionsStorage::Size));</span>
<span class="line-added"> 984         break;</span>
<span class="line-added"> 985     case Options::Type::OptionRange:</span>
<span class="line-added"> 986         memcpy(&amp;m_optionRange, addressOfValue, sizeof(OptionsStorage::OptionRange));</span>
<span class="line-added"> 987         break;</span>
<span class="line-added"> 988     case Options::Type::OptionString:</span>
<span class="line-added"> 989         memcpy(&amp;m_optionString, addressOfValue, sizeof(OptionsStorage::OptionString));</span>
<span class="line-added"> 990         break;</span>
<span class="line-added"> 991     case Options::Type::GCLogLevel:</span>
<span class="line-added"> 992         memcpy(&amp;m_gcLogLevel, addressOfValue, sizeof(OptionsStorage::GCLogLevel));</span>
<span class="line-added"> 993         break;</span>
<span class="line-added"> 994     }</span>
<span class="line-added"> 995 }</span>
<span class="line-added"> 996 </span>
<span class="line-added"> 997 void OptionReader::Option::dump(StringBuilder&amp; builder) const</span>
 998 {
 999     switch (type()) {
<span class="line-modified">1000     case Options::Type::Bool:</span>
<span class="line-modified">1001         builder.append(m_bool ? &quot;true&quot; : &quot;false&quot;);</span>
1002         break;
<span class="line-modified">1003     case Options::Type::Unsigned:</span>
<span class="line-modified">1004         builder.appendNumber(m_unsigned);</span>
1005         break;
<span class="line-modified">1006     case Options::Type::Size:</span>
<span class="line-modified">1007         builder.appendNumber(m_size);</span>
1008         break;
<span class="line-modified">1009     case Options::Type::Double:</span>
<span class="line-modified">1010         builder.append(m_double);</span>
1011         break;
<span class="line-modified">1012     case Options::Type::Int32:</span>
<span class="line-modified">1013         builder.appendNumber(m_int32);</span>
1014         break;
<span class="line-modified">1015     case Options::Type::OptionRange:</span>
<span class="line-modified">1016         builder.append(m_optionRange.rangeString());</span>
1017         break;
<span class="line-modified">1018     case Options::Type::OptionString: {</span>
<span class="line-modified">1019         const char* option = m_optionString;</span>
1020         if (!option)
1021             option = &quot;&quot;;
1022         builder.append(&#39;&quot;&#39;);
1023         builder.append(option);
1024         builder.append(&#39;&quot;&#39;);
1025         break;
1026     }
<span class="line-modified">1027     case Options::Type::GCLogLevel: {</span>
<span class="line-modified">1028         builder.append(GCLogging::levelAsString(m_gcLogLevel));</span>
1029         break;
1030     }
1031     }
1032 }
1033 
<span class="line-modified">1034 bool OptionReader::Option::operator==(const Option&amp; other) const</span>
1035 {
<span class="line-added">1036     ASSERT(type() == other.type());</span>
1037     switch (type()) {
<span class="line-modified">1038     case Options::Type::Bool:</span>
<span class="line-modified">1039         return m_bool == other.m_bool;</span>
<span class="line-modified">1040     case Options::Type::Unsigned:</span>
<span class="line-modified">1041         return m_unsigned == other.m_unsigned;</span>
<span class="line-modified">1042     case Options::Type::Size:</span>
<span class="line-modified">1043         return m_size == other.m_size;</span>
<span class="line-modified">1044     case Options::Type::Double:</span>
<span class="line-modified">1045         return (m_double == other.m_double) || (std::isnan(m_double) &amp;&amp; std::isnan(other.m_double));</span>
<span class="line-modified">1046     case Options::Type::Int32:</span>
<span class="line-modified">1047         return m_int32 == other.m_int32;</span>
<span class="line-modified">1048     case Options::Type::OptionRange:</span>
<span class="line-modified">1049         return m_optionRange.rangeString() == other.m_optionRange.rangeString();</span>
<span class="line-modified">1050     case Options::Type::OptionString:</span>
<span class="line-modified">1051         return (m_optionString == other.m_optionString)</span>
<span class="line-modified">1052             || (m_optionString &amp;&amp; other.m_optionString &amp;&amp; !strcmp(m_optionString, other.m_optionString));</span>
<span class="line-modified">1053     case Options::Type::GCLogLevel:</span>
<span class="line-modified">1054         return m_gcLogLevel == other.m_gcLogLevel;</span>
1055     }
1056     return false;
1057 }
1058 
1059 } // namespace JSC

</pre>
</td>
</tr>
</table>
<center><a href="Operations.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Options.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
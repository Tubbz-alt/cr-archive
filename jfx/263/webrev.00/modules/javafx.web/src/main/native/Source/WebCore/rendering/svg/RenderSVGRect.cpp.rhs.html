<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGRect.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 University of Szeged
  3  * Copyright (C) 2011 Renata Hodovan &lt;reni@webkit.org&gt;
  4  * All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF SZEGED ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL UNIVERSITY OF SZEGED OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;RenderSVGRect.h&quot;
 30 
 31 #include &lt;wtf/IsoMallocInlines.h&gt;
 32 
 33 namespace WebCore {
 34 
 35 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderSVGRect);
 36 
 37 RenderSVGRect::RenderSVGRect(SVGRectElement&amp; element, RenderStyle&amp;&amp; style)
 38     : RenderSVGShape(element, WTFMove(style))
 39     , m_usePathFallback(false)
 40 {
 41 }
 42 
 43 RenderSVGRect::~RenderSVGRect() = default;
 44 
 45 SVGRectElement&amp; RenderSVGRect::rectElement() const
 46 {
 47     return downcast&lt;SVGRectElement&gt;(RenderSVGShape::graphicsElement());
 48 }
 49 
 50 void RenderSVGRect::updateShapeFromElement()
 51 {
 52     // Before creating a new object we need to clear the cached bounding box
 53     // to avoid using garbage.
 54     m_fillBoundingBox = FloatRect();
 55     m_innerStrokeRect = FloatRect();
 56     m_outerStrokeRect = FloatRect();
 57     clearPath();
 58     m_usePathFallback = false;
 59 
 60     SVGLengthContext lengthContext(&amp;rectElement());
<a name="1" id="anc1"></a><span class="line-modified"> 61     FloatSize boundingBoxSize(lengthContext.valueForLength(style().width(), SVGLengthMode::Width), lengthContext.valueForLength(style().height(), SVGLengthMode::Height));</span>
 62 
<a name="2" id="anc2"></a><span class="line-modified"> 63     // Spec: &quot;A negative value is illegal. A value of zero disables rendering of the element.&quot;</span>
<span class="line-modified"> 64     if (boundingBoxSize.isEmpty())</span>
 65         return;
 66 
<a name="3" id="anc3"></a><span class="line-modified"> 67     if (rectElement().rx().value(lengthContext) &gt; 0 || rectElement().ry().value(lengthContext) &gt; 0 || hasNonScalingStroke()) {</span>
<span class="line-modified"> 68         // Fall back to RenderSVGShape</span>
<span class="line-modified"> 69         RenderSVGShape::updateShapeFromElement();</span>
<span class="line-modified"> 70         m_usePathFallback = true;</span>
<span class="line-modified"> 71         return;</span>



 72     }
 73 
<a name="4" id="anc4"></a><span class="line-modified"> 74     m_fillBoundingBox = FloatRect(FloatPoint(lengthContext.valueForLength(style().svgStyle().x(), SVGLengthMode::Width),</span>
<span class="line-modified"> 75         lengthContext.valueForLength(style().svgStyle().y(), SVGLengthMode::Height)),</span>
 76         boundingBoxSize);
 77 
 78     // To decide if the stroke contains a point we create two rects which represent the inner and
 79     // the outer stroke borders. A stroke contains the point, if the point is between them.
 80     m_innerStrokeRect = m_fillBoundingBox;
 81     m_outerStrokeRect = m_fillBoundingBox;
 82 
 83     if (style().svgStyle().hasStroke()) {
 84         float strokeWidth = this-&gt;strokeWidth();
 85         m_innerStrokeRect.inflate(-strokeWidth / 2);
 86         m_outerStrokeRect.inflate(strokeWidth / 2);
 87     }
 88 
 89     m_strokeBoundingBox = m_outerStrokeRect;
 90 
 91 #if USE(CG)
 92     // CoreGraphics can inflate the stroke by 1px when drawing a rectangle with antialiasing disabled at non-integer coordinates, we need to compensate.
 93     if (style().svgStyle().shapeRendering() == ShapeRendering::CrispEdges)
 94         m_strokeBoundingBox.inflate(1);
 95 #endif
 96 }
 97 
 98 void RenderSVGRect::fillShape(GraphicsContext&amp; context) const
 99 {
100     if (m_usePathFallback) {
101         RenderSVGShape::fillShape(context);
102         return;
103     }
104 
105 #if USE(CG)
106     // FIXME: CG implementation of GraphicsContextCG::fillRect has an own
107     // shadow drawing method, which draws an extra shadow.
108     // This is a workaround for switching off the extra shadow.
109     // https://bugs.webkit.org/show_bug.cgi?id=68899
110     if (context.hasShadow()) {
111         GraphicsContextStateSaver stateSaver(context);
112         context.clearShadow();
113         context.fillRect(m_fillBoundingBox);
114         return;
115     }
116 #endif
117 
118     context.fillRect(m_fillBoundingBox);
119 }
120 
121 void RenderSVGRect::strokeShape(GraphicsContext&amp; context) const
122 {
123     if (!style().hasVisibleStroke())
124         return;
125 
126     if (m_usePathFallback) {
127         RenderSVGShape::strokeShape(context);
128         return;
129     }
130 
131     context.strokeRect(m_fillBoundingBox, strokeWidth());
132 }
133 
134 bool RenderSVGRect::shapeDependentStrokeContains(const FloatPoint&amp; point, PointCoordinateSpace pointCoordinateSpace)
135 {
136     // The optimized contains code below does not support non-smooth strokes so we need
137     // to fall back to RenderSVGShape::shapeDependentStrokeContains in these cases.
138     if (m_usePathFallback || !hasSmoothStroke()) {
139         if (!hasPath())
140             RenderSVGShape::updateShapeFromElement();
141         return RenderSVGShape::shapeDependentStrokeContains(point, pointCoordinateSpace);
142     }
143 
144     return m_outerStrokeRect.contains(point, FloatRect::InsideOrOnStroke) &amp;&amp; !m_innerStrokeRect.contains(point, FloatRect::InsideButNotOnStroke);
145 }
146 
147 bool RenderSVGRect::shapeDependentFillContains(const FloatPoint&amp; point, const WindRule fillRule) const
148 {
149     if (m_usePathFallback)
150         return RenderSVGShape::shapeDependentFillContains(point, fillRule);
151     return m_fillBoundingBox.contains(point.x(), point.y());
152 }
153 
154 bool RenderSVGRect::isRenderingDisabled() const
155 {
156     // A width or height of zero disables rendering for the element, and results in an empty bounding box.
157     return m_fillBoundingBox.isEmpty();
158 }
159 
160 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
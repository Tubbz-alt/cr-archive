diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGeometryMap.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGeometryMap.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGeometryMap.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGeometryMap.cpp
@@ -53,20 +53,20 @@
         transformState.flatten();
         return;
     }
 
     bool inFixed = false;
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     bool foundContainer = !container || (m_mapping.size() && m_mapping[0].m_renderer == container);
 #endif
 
     for (int i = m_mapping.size() - 1; i >= 0; --i) {
         const RenderGeometryMapStep& currentStep = m_mapping[i];
 
         // If container is the RenderView (step 0) we want to apply its scroll offset.
         if (i > 0 && currentStep.m_renderer == container) {
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
             foundContainer = true;
 #endif
             break;
         }
 
@@ -100,18 +100,18 @@
 }
 
 FloatPoint RenderGeometryMap::mapToContainer(const FloatPoint& p, const RenderLayerModelObject* container) const
 {
     FloatPoint result;
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     FloatPoint rendererMappedResult = m_mapping.last().m_renderer->localToAbsolute(p, m_mapCoordinatesFlags);
 #endif
 
     if (!hasFixedPositionStep() && !hasTransformStep() && !hasNonUniformStep() && (!container || (m_mapping.size() && container == m_mapping[0].m_renderer))) {
         result = p + roundedIntSize(m_accumulatedOffset);
         // Should convert to a LayoutPoint because of the uniqueness of LayoutUnit::round
-        ASSERT(roundedIntPoint(LayoutPoint(rendererMappedResult)) == result);
+        ASSERT(m_accumulatedOffsetMightBeSaturated || roundedIntPoint(LayoutPoint(rendererMappedResult)) == result);
     } else {
         TransformState transformState(TransformState::ApplyTransformDirection, p);
         mapToContainer(transformState, container);
         result = transformState.lastPlanarPoint();
         ASSERT(areEssentiallyEqual(rendererMappedResult, result));
@@ -263,12 +263,16 @@
 }
 
 void RenderGeometryMap::stepInserted(const RenderGeometryMapStep& step)
 {
     // RenderView's offset, is only applied when we have fixed-positions.
-    if (!step.m_renderer->isRenderView())
+    if (!step.m_renderer->isRenderView()) {
         m_accumulatedOffset += step.m_offset;
+#if ASSERT_ENABLED
+        m_accumulatedOffsetMightBeSaturated |= m_accumulatedOffset.mightBeSaturated();
+#endif
+    }
 
     if (step.m_isNonUniform)
         ++m_nonUniformStepsCount;
 
     if (step.m_transform)
@@ -279,12 +283,16 @@
 }
 
 void RenderGeometryMap::stepRemoved(const RenderGeometryMapStep& step)
 {
     // RenderView's offset, is only applied when we have fixed-positions.
-    if (!step.m_renderer->isRenderView())
+    if (!step.m_renderer->isRenderView()) {
         m_accumulatedOffset -= step.m_offset;
+#if ASSERT_ENABLED
+        m_accumulatedOffsetMightBeSaturated |= m_accumulatedOffset.mightBeSaturated();
+#endif
+    }
 
     if (step.m_isNonUniform) {
         ASSERT(m_nonUniformStepsCount);
         --m_nonUniformStepsCount;
     }

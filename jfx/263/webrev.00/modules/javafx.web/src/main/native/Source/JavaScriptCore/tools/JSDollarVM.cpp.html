<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/JSDollarVM.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;JSDollarVM.h&quot;
  28 
  29 #include &quot;BuiltinExecutableCreator.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;DOMAttributeGetterSetter.h&quot;
  32 #include &quot;DOMJITGetterSetter.h&quot;
  33 #include &quot;Debugger.h&quot;
  34 #include &quot;Error.h&quot;
  35 #include &quot;FrameTracers.h&quot;
  36 #include &quot;FunctionCodeBlock.h&quot;
  37 #include &quot;GetterSetter.h&quot;
  38 #include &quot;JSArray.h&quot;
  39 #include &quot;JSArrayBuffer.h&quot;
  40 #include &quot;JSCInlines.h&quot;
  41 #include &quot;JSFunction.h&quot;
  42 #include &quot;JSONObject.h&quot;
  43 #include &quot;JSProxy.h&quot;
  44 #include &quot;JSString.h&quot;
  45 #include &quot;Options.h&quot;
  46 #include &quot;Parser.h&quot;
  47 #include &quot;ProbeContext.h&quot;
  48 #include &quot;ShadowChicken.h&quot;
  49 #include &quot;Snippet.h&quot;
  50 #include &quot;SnippetParams.h&quot;
  51 #include &quot;TypeProfiler.h&quot;
  52 #include &quot;TypeProfilerLog.h&quot;
  53 #include &quot;VMInspector.h&quot;
  54 #include &quot;WasmCapabilities.h&quot;
  55 #include &lt;wtf/Atomics.h&gt;
  56 #include &lt;wtf/CPUTime.h&gt;
  57 #include &lt;wtf/DataLog.h&gt;
  58 #include &lt;wtf/ProcessID.h&gt;
  59 #include &lt;wtf/StringPrintStream.h&gt;
  60 
  61 #if ENABLE(WEBASSEMBLY)
  62 #include &quot;JSWebAssemblyHelpers.h&quot;
  63 #include &quot;WasmStreamingParser.h&quot;
  64 #endif
  65 
  66 using namespace JSC;
  67 
  68 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)
  69 
  70 extern &quot;C&quot; void ctiMasmProbeTrampoline();
  71 
  72 namespace JSC {
  73 
  74 // This class is only here as a simple way to grant JSDollarVM friend privileges
  75 // to all the classes that it needs special access to.
  76 class JSDollarVMHelper {
  77 public:
  78     JSDollarVMHelper(VM&amp; vm)
  79         : m_vm(vm)
  80     { }
  81 
  82     void updateVMStackLimits() { return m_vm.updateStackLimits(); };
  83 
  84     static EncodedJSValue JSC_HOST_CALL functionGetStructureTransitionList(JSGlobalObject*, CallFrame*);
  85 
  86 private:
  87     VM&amp; m_vm;
  88 };
  89 
  90 } // namespace JSC
  91 
  92 namespace {
  93 
  94 // We must RELEASE_ASSERT(Options::useDollarVM()) in all JSDollarVM functions
  95 // that are non-trivial at an eye&#39;s glance. This includes (but is not limited to):
  96 //      constructors
  97 //      create() factory
  98 //      createStructure() factory
  99 //      finishCreation()
 100 //      HOST_CALL or operation functions
 101 //      Constructors and methods of utility and test classes
 102 //      lambda functions
 103 //
 104 // The way to do this RELEASE_ASSERT is with the DollarVMAssertScope below.
 105 //
 106 // The only exception are some constexpr constructors used for instantiating
 107 // globals (since these must have trivial constructors) e.g. DOMJITAttribute.
 108 // Instead, these constructors should always be ALWAYS_INLINE.
 109 
 110 class JSDollarVMCallFrame : public JSNonFinalObject {
 111     using Base = JSNonFinalObject;
 112 public:
 113     JSDollarVMCallFrame(VM&amp; vm, Structure* structure)
 114         : Base(vm, structure)
 115     {
 116         DollarVMAssertScope assertScope;
 117     }
 118 
 119     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 120     {
 121         DollarVMAssertScope assertScope;
 122         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 123     }
 124 
 125     static JSDollarVMCallFrame* create(JSGlobalObject* globalObject, CallFrame* callFrame, unsigned requestedFrameIndex)
 126     {
 127         DollarVMAssertScope assertScope;
 128         VM&amp; vm = globalObject-&gt;vm();
 129         Structure* structure = createStructure(vm, globalObject, jsNull());
 130         JSDollarVMCallFrame* frame = new (NotNull, allocateCell&lt;JSDollarVMCallFrame&gt;(vm.heap)) JSDollarVMCallFrame(vm, structure);
 131         frame-&gt;finishCreation(vm, callFrame, requestedFrameIndex);
 132         return frame;
 133     }
 134 
 135     void finishCreation(VM&amp; vm, CallFrame* callFrame, unsigned requestedFrameIndex)
 136     {
 137         DollarVMAssertScope assertScope;
 138         Base::finishCreation(vm);
 139 
 140         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
 141             DollarVMAssertScope assertScope;
 142             JSDollarVMCallFrame::addProperty(vm, name, value);
 143         };
 144 
 145         unsigned frameIndex = 0;
 146         bool isValid = false;
 147         callFrame-&gt;iterate(vm, [&amp;] (StackVisitor&amp; visitor) {
 148             DollarVMAssertScope assertScope;
 149 
 150             if (frameIndex++ != requestedFrameIndex)
 151                 return StackVisitor::Continue;
 152 
 153             addProperty(vm, &quot;name&quot;, jsString(vm, visitor-&gt;functionName()));
 154 
 155             if (visitor-&gt;callee().isCell())
 156                 addProperty(vm, &quot;callee&quot;, visitor-&gt;callee().asCell());
 157 
 158             CodeBlock* codeBlock = visitor-&gt;codeBlock();
 159             if (codeBlock) {
 160                 addProperty(vm, &quot;codeBlock&quot;, codeBlock);
 161                 addProperty(vm, &quot;unlinkedCodeBlock&quot;, codeBlock-&gt;unlinkedCodeBlock());
 162                 addProperty(vm, &quot;executable&quot;, codeBlock-&gt;ownerExecutable());
 163             }
 164             isValid = true;
 165 
 166             return StackVisitor::Done;
 167         });
 168 
 169         addProperty(vm, &quot;valid&quot;, jsBoolean(isValid));
 170     }
 171 
 172     DECLARE_INFO;
 173 
 174 private:
 175     void addProperty(VM&amp; vm, const char* name, JSValue value)
 176     {
 177         DollarVMAssertScope assertScope;
 178         Identifier identifier = Identifier::fromString(vm, name);
 179         putDirect(vm, identifier, value);
 180     }
 181 };
 182 
 183 const ClassInfo JSDollarVMCallFrame::s_info = { &quot;CallFrame&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVMCallFrame) };
 184 
 185 class ElementHandleOwner;
 186 class Root;
 187 
 188 class Element : public JSNonFinalObject {
 189 public:
 190     Element(VM&amp; vm, Structure* structure)
 191         : Base(vm, structure)
 192     {
 193         DollarVMAssertScope assertScope;
 194     }
 195 
 196     typedef JSNonFinalObject Base;
 197 
 198     Root* root() const { return m_root.get(); }
 199     void setRoot(VM&amp; vm, Root* root) { m_root.set(vm, this, root); }
 200 
 201     static Element* create(VM&amp; vm, JSGlobalObject* globalObject, Root* root)
 202     {
 203         DollarVMAssertScope assertScope;
 204         Structure* structure = createStructure(vm, globalObject, jsNull());
 205         Element* element = new (NotNull, allocateCell&lt;Element&gt;(vm.heap)) Element(vm, structure);
 206         element-&gt;finishCreation(vm, root);
 207         return element;
 208     }
 209 
 210     void finishCreation(VM&amp;, Root*);
 211 
 212     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 213     {
 214         DollarVMAssertScope assertScope;
 215         Element* thisObject = jsCast&lt;Element*&gt;(cell);
 216         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 217         Base::visitChildren(thisObject, visitor);
 218         visitor.append(thisObject-&gt;m_root);
 219     }
 220 
 221     static ElementHandleOwner* handleOwner();
 222 
 223     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 224     {
 225         DollarVMAssertScope assertScope;
 226         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 227     }
 228 
 229     DECLARE_INFO;
 230 
 231 private:
 232     WriteBarrier&lt;Root&gt; m_root;
 233 };
 234 
 235 class ElementHandleOwner : public WeakHandleOwner {
 236     WTF_MAKE_FAST_ALLOCATED;
 237 public:
 238     bool isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason) override
 239     {
 240         DollarVMAssertScope assertScope;
 241         if (UNLIKELY(reason))
 242             *reason = &quot;JSC::Element is opaque root&quot;;
 243         Element* element = jsCast&lt;Element*&gt;(handle.slot()-&gt;asCell());
 244         return visitor.containsOpaqueRoot(element-&gt;root());
 245     }
 246 };
 247 
 248 class Root : public JSDestructibleObject {
 249 public:
 250     Root(VM&amp; vm, Structure* structure)
 251         : Base(vm, structure)
 252     {
 253         DollarVMAssertScope assertScope;
 254     }
 255 
 256     Element* element()
 257     {
 258         return m_element.get();
 259     }
 260 
 261     void setElement(Element* element)
 262     {
 263         DollarVMAssertScope assertScope;
 264         Weak&lt;Element&gt; newElement(element, Element::handleOwner());
 265         m_element.swap(newElement);
 266     }
 267 
 268     static Root* create(VM&amp; vm, JSGlobalObject* globalObject)
 269     {
 270         DollarVMAssertScope assertScope;
 271         Structure* structure = createStructure(vm, globalObject, jsNull());
 272         Root* root = new (NotNull, allocateCell&lt;Root&gt;(vm.heap)) Root(vm, structure);
 273         root-&gt;finishCreation(vm);
 274         return root;
 275     }
 276 
 277     typedef JSDestructibleObject Base;
 278 
 279     DECLARE_INFO;
 280 
 281     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 282     {
 283         DollarVMAssertScope assertScope;
 284         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 285     }
 286 
 287     static void visitChildren(JSCell* thisObject, SlotVisitor&amp; visitor)
 288     {
 289         DollarVMAssertScope assertScope;
 290         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 291         Base::visitChildren(thisObject, visitor);
 292         visitor.addOpaqueRoot(thisObject);
 293     }
 294 
 295 private:
 296     Weak&lt;Element&gt; m_element;
 297 };
 298 
 299 class SimpleObject : public JSNonFinalObject {
 300 public:
 301     SimpleObject(VM&amp; vm, Structure* structure)
 302         : Base(vm, structure)
 303     {
 304         DollarVMAssertScope assertScope;
 305     }
 306 
 307     typedef JSNonFinalObject Base;
 308     static constexpr bool needsDestruction = false;
 309 
 310     static SimpleObject* create(VM&amp; vm, JSGlobalObject* globalObject)
 311     {
 312         DollarVMAssertScope assertScope;
 313         Structure* structure = createStructure(vm, globalObject, jsNull());
 314         SimpleObject* simpleObject = new (NotNull, allocateCell&lt;SimpleObject&gt;(vm.heap)) SimpleObject(vm, structure);
 315         simpleObject-&gt;finishCreation(vm);
 316         return simpleObject;
 317     }
 318 
 319     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 320     {
 321         DollarVMAssertScope assertScope;
 322         SimpleObject* thisObject = jsCast&lt;SimpleObject*&gt;(cell);
 323         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 324         Base::visitChildren(thisObject, visitor);
 325         visitor.append(thisObject-&gt;m_hiddenValue);
 326     }
 327 
 328     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 329     {
 330         DollarVMAssertScope assertScope;
 331         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 332     }
 333 
 334     JSValue hiddenValue()
 335     {
 336         return m_hiddenValue.get();
 337     }
 338 
 339     void setHiddenValue(VM&amp; vm, JSValue value)
 340     {
 341         ASSERT(value.isCell());
 342         m_hiddenValue.set(vm, this, value);
 343     }
 344 
 345     DECLARE_INFO;
 346 
 347 private:
 348     WriteBarrier&lt;JSC::Unknown&gt; m_hiddenValue;
 349 };
 350 
 351 class ImpureGetter : public JSNonFinalObject {
 352 public:
 353     ImpureGetter(VM&amp; vm, Structure* structure)
 354         : Base(vm, structure)
 355     {
 356         DollarVMAssertScope assertScope;
 357     }
 358 
 359     DECLARE_INFO;
 360     typedef JSNonFinalObject Base;
 361     static constexpr unsigned StructureFlags = Base::StructureFlags | JSC::GetOwnPropertySlotIsImpure | JSC::OverridesGetOwnPropertySlot;
 362 
 363     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 364     {
 365         DollarVMAssertScope assertScope;
 366         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 367     }
 368 
 369     static ImpureGetter* create(VM&amp; vm, Structure* structure, JSObject* delegate)
 370     {
 371         DollarVMAssertScope assertScope;
 372         ImpureGetter* getter = new (NotNull, allocateCell&lt;ImpureGetter&gt;(vm.heap)) ImpureGetter(vm, structure);
 373         getter-&gt;finishCreation(vm, delegate);
 374         return getter;
 375     }
 376 
 377     void finishCreation(VM&amp; vm, JSObject* delegate)
 378     {
 379         DollarVMAssertScope assertScope;
 380         Base::finishCreation(vm);
 381         if (delegate)
 382             m_delegate.set(vm, this, delegate);
 383     }
 384 
 385     static bool getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName name, PropertySlot&amp; slot)
 386     {
 387         DollarVMAssertScope assertScope;
 388         VM&amp; vm = globalObject-&gt;vm();
 389         auto scope = DECLARE_THROW_SCOPE(vm);
 390         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(object);
 391 
 392         if (thisObject-&gt;m_delegate) {
 393             if (thisObject-&gt;m_delegate-&gt;getPropertySlot(globalObject, name, slot))
 394                 return true;
 395             RETURN_IF_EXCEPTION(scope, false);
 396         }
 397 
 398         return Base::getOwnPropertySlot(object, globalObject, name, slot);
 399     }
 400 
 401     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 402     {
 403         DollarVMAssertScope assertScope;
 404         ASSERT_GC_OBJECT_INHERITS(cell, info());
 405         Base::visitChildren(cell, visitor);
 406         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(cell);
 407         visitor.append(thisObject-&gt;m_delegate);
 408     }
 409 
 410     void setDelegate(VM&amp; vm, JSObject* delegate)
 411     {
 412         m_delegate.set(vm, this, delegate);
 413     }
 414 
 415 private:
 416     WriteBarrier&lt;JSObject&gt; m_delegate;
 417 };
 418 
 419 class CustomGetter : public JSNonFinalObject {
 420 public:
 421     CustomGetter(VM&amp; vm, Structure* structure)
 422         : Base(vm, structure)
 423     {
 424         DollarVMAssertScope assertScope;
 425     }
 426 
 427     DECLARE_INFO;
 428     typedef JSNonFinalObject Base;
 429     static constexpr unsigned StructureFlags = Base::StructureFlags | JSC::OverridesGetOwnPropertySlot;
 430 
 431     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 432     {
 433         DollarVMAssertScope assertScope;
 434         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 435     }
 436 
 437     static CustomGetter* create(VM&amp; vm, Structure* structure)
 438     {
 439         DollarVMAssertScope assertScope;
 440         CustomGetter* getter = new (NotNull, allocateCell&lt;CustomGetter&gt;(vm.heap)) CustomGetter(vm, structure);
 441         getter-&gt;finishCreation(vm);
 442         return getter;
 443     }
 444 
 445     static bool getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)
 446     {
 447         DollarVMAssertScope assertScope;
 448         VM&amp; vm = globalObject-&gt;vm();
 449         CustomGetter* thisObject = jsCast&lt;CustomGetter*&gt;(object);
 450         if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetter&quot;))) {
 451             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;customGetter);
 452             return true;
 453         }
 454 
 455         if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetterAccessor&quot;))) {
 456             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, thisObject-&gt;customGetterAcessor);
 457             return true;
 458         }
 459 
 460         return JSObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);
 461     }
 462 
 463 private:
 464     static EncodedJSValue customGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)
 465     {
 466         DollarVMAssertScope assertScope;
 467         VM&amp; vm = globalObject-&gt;vm();
 468         auto scope = DECLARE_THROW_SCOPE(vm);
 469 
 470         CustomGetter* thisObject = jsDynamicCast&lt;CustomGetter*&gt;(vm, JSValue::decode(thisValue));
 471         if (!thisObject)
 472             return throwVMTypeError(globalObject, scope);
 473         bool shouldThrow = thisObject-&gt;get(globalObject, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(globalObject);
 474         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 475         if (shouldThrow)
 476             return throwVMTypeError(globalObject, scope);
 477         return JSValue::encode(jsNumber(100));
 478     }
 479 
 480     static EncodedJSValue customGetterAcessor(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)
 481     {
 482         DollarVMAssertScope assertScope;
 483         VM&amp; vm = globalObject-&gt;vm();
 484         auto scope = DECLARE_THROW_SCOPE(vm);
 485 
 486         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 487         if (!thisObject)
 488             return throwVMTypeError(globalObject, scope);
 489         bool shouldThrow = thisObject-&gt;get(globalObject, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(globalObject);
 490         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 491         if (shouldThrow)
 492             return throwVMTypeError(globalObject, scope);
 493         return JSValue::encode(jsNumber(100));
 494     }
 495 };
 496 
 497 class RuntimeArray : public JSArray {
 498 public:
 499     typedef JSArray Base;
 500     static constexpr unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesGetPropertyNames;
 501 
 502     static RuntimeArray* create(JSGlobalObject* globalObject, CallFrame* callFrame)
 503     {
 504         DollarVMAssertScope assertScope;
 505         VM&amp; vm = globalObject-&gt;vm();
 506         Structure* structure = createStructure(vm, globalObject, createPrototype(vm, globalObject));
 507         RuntimeArray* runtimeArray = new (NotNull, allocateCell&lt;RuntimeArray&gt;(vm.heap)) RuntimeArray(globalObject, structure);
 508         runtimeArray-&gt;finishCreation(globalObject, callFrame);
 509         vm.heap.addFinalizer(runtimeArray, destroy);
 510         return runtimeArray;
 511     }
 512 
 513     ~RuntimeArray() { }
 514 
 515     static void destroy(JSCell* cell)
 516     {
 517         DollarVMAssertScope assertScope;
 518         static_cast&lt;RuntimeArray*&gt;(cell)-&gt;RuntimeArray::~RuntimeArray();
 519     }
 520 
 521     static constexpr bool needsDestruction = false;
 522 
 523     static bool getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)
 524     {
 525         DollarVMAssertScope assertScope;
 526         VM&amp; vm = globalObject-&gt;vm();
 527         RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
 528         if (propertyName == vm.propertyNames-&gt;length) {
 529             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;lengthGetter);
 530             return true;
 531         }
 532 
 533         Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
 534         if (index &amp;&amp; index.value() &lt; thisObject-&gt;getLength()) {
 535             slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index.value()]));
 536             return true;
 537         }
 538 
 539         return JSObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);
 540     }
 541 
 542     static bool getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* globalObject, unsigned index, PropertySlot&amp; slot)
 543     {
 544         DollarVMAssertScope assertScope;
 545         RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
 546         if (index &lt; thisObject-&gt;getLength()) {
 547             slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index]));
 548             return true;
 549         }
 550 
 551         return JSObject::getOwnPropertySlotByIndex(thisObject, globalObject, index, slot);
 552     }
 553 
 554     static NO_RETURN_DUE_TO_CRASH bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;)
 555     {
 556         RELEASE_ASSERT_NOT_REACHED();
 557     }
 558 
 559     static NO_RETURN_DUE_TO_CRASH bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName)
 560     {
 561         RELEASE_ASSERT_NOT_REACHED();
 562     }
 563 
 564     unsigned getLength() const { return m_vector.size(); }
 565 
 566     DECLARE_INFO;
 567 
 568     static ArrayPrototype* createPrototype(VM&amp;, JSGlobalObject* globalObject)
 569     {
 570         DollarVMAssertScope assertScope;
 571         return globalObject-&gt;arrayPrototype();
 572     }
 573 
 574     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 575     {
 576         DollarVMAssertScope assertScope;
 577         return Structure::create(vm, globalObject, prototype, TypeInfo(DerivedArrayType, StructureFlags), info(), ArrayClass);
 578     }
 579 
 580 protected:
 581     void finishCreation(JSGlobalObject* globalObject, CallFrame* callFrame)
 582     {
 583         DollarVMAssertScope assertScope;
 584         VM&amp; vm = globalObject-&gt;vm();
 585         Base::finishCreation(vm);
 586         ASSERT(inherits(vm, info()));
 587 
 588         for (size_t i = 0; i &lt; callFrame-&gt;argumentCount(); i++)
 589             m_vector.append(callFrame-&gt;argument(i).toInt32(globalObject));
 590     }
 591 
 592 private:
 593     RuntimeArray(JSGlobalObject* globalObject, Structure* structure)
 594         : JSArray(globalObject-&gt;vm(), structure, 0)
 595     {
 596         DollarVMAssertScope assertScope;
 597     }
 598 
 599     static EncodedJSValue lengthGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)
 600     {
 601         DollarVMAssertScope assertScope;
 602         VM&amp; vm = globalObject-&gt;vm();
 603         auto scope = DECLARE_THROW_SCOPE(vm);
 604 
 605         RuntimeArray* thisObject = jsDynamicCast&lt;RuntimeArray*&gt;(vm, JSValue::decode(thisValue));
 606         if (!thisObject)
 607             return throwVMTypeError(globalObject, scope);
 608         return JSValue::encode(jsNumber(thisObject-&gt;getLength()));
 609     }
 610 
 611     Vector&lt;int&gt; m_vector;
 612 };
 613 
 614 static const struct CompactHashIndex staticCustomAccessorTableIndex[2] = {
 615     { 0, -1 },
 616     { -1, -1 },
 617 };
 618 
 619 static EncodedJSValue testStaticAccessorGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)
 620 {
 621     DollarVMAssertScope assertScope;
 622     VM&amp; vm = globalObject-&gt;vm();
 623 
 624     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 625     RELEASE_ASSERT(thisObject);
 626 
 627     if (JSValue result = thisObject-&gt;getDirect(vm, PropertyName(Identifier::fromString(vm, &quot;testField&quot;))))
 628         return JSValue::encode(result);
 629     return JSValue::encode(jsUndefined());
 630 }
 631 
 632 static bool testStaticAccessorPutter(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue value)
 633 {
 634     DollarVMAssertScope assertScope;
 635     VM&amp; vm = globalObject-&gt;vm();
 636 
 637     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 638     RELEASE_ASSERT(thisObject);
 639 
 640     return thisObject-&gt;putDirect(vm, PropertyName(Identifier::fromString(vm, &quot;testField&quot;)), JSValue::decode(value));
 641 }
 642 
 643 static const struct HashTableValue staticCustomAccessorTableValues[1] = {
 644     { &quot;testStaticAccessor&quot;, static_cast&lt;unsigned&gt;(PropertyAttribute::CustomAccessor), NoIntrinsic, { (intptr_t)static_cast&lt;PropertySlot::GetValueFunc&gt;(testStaticAccessorGetter), (intptr_t)static_cast&lt;PutPropertySlot::PutValueFunc&gt;(testStaticAccessorPutter) } },
 645 };
 646 
 647 static const struct HashTable staticCustomAccessorTable =
 648     { 1, 1, true, nullptr, staticCustomAccessorTableValues, staticCustomAccessorTableIndex };
 649 
 650 class StaticCustomAccessor : public JSNonFinalObject {
 651     using Base = JSNonFinalObject;
 652 public:
 653     StaticCustomAccessor(VM&amp; vm, Structure* structure)
 654         : Base(vm, structure)
 655     {
 656         DollarVMAssertScope assertScope;
 657     }
 658 
 659     DECLARE_INFO;
 660 
 661     static constexpr unsigned StructureFlags = Base::StructureFlags | HasStaticPropertyTable | OverridesGetOwnPropertySlot;
 662 
 663     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 664     {
 665         DollarVMAssertScope assertScope;
 666         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 667     }
 668 
 669     static StaticCustomAccessor* create(VM&amp; vm, Structure* structure)
 670     {
 671         DollarVMAssertScope assertScope;
 672         StaticCustomAccessor* accessor = new (NotNull, allocateCell&lt;StaticCustomAccessor&gt;(vm.heap)) StaticCustomAccessor(vm, structure);
 673         accessor-&gt;finishCreation(vm);
 674         return accessor;
 675     }
 676 
 677     static bool getOwnPropertySlot(JSObject* thisObject, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)
 678     {
 679         if (String(propertyName.uid()) == &quot;thinAirCustomGetter&quot;) {
 680             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, testStaticAccessorGetter);
 681             return true;
 682         }
 683         return JSNonFinalObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);
 684     }
 685 };
 686 
 687 class ObjectDoingSideEffectPutWithoutCorrectSlotStatus : public JSNonFinalObject {
 688     using Base = JSNonFinalObject;
 689 public:
 690     ObjectDoingSideEffectPutWithoutCorrectSlotStatus(VM&amp; vm, Structure* structure)
 691         : Base(vm, structure)
 692     {
 693         DollarVMAssertScope assertScope;
 694     }
 695 
 696     DECLARE_INFO;
 697 
 698     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 699     {
 700         DollarVMAssertScope assertScope;
 701         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 702     }
 703 
 704     static ObjectDoingSideEffectPutWithoutCorrectSlotStatus* create(VM&amp; vm, Structure* structure)
 705     {
 706         DollarVMAssertScope assertScope;
 707         ObjectDoingSideEffectPutWithoutCorrectSlotStatus* accessor = new (NotNull, allocateCell&lt;ObjectDoingSideEffectPutWithoutCorrectSlotStatus&gt;(vm.heap)) ObjectDoingSideEffectPutWithoutCorrectSlotStatus(vm, structure);
 708         accessor-&gt;finishCreation(vm);
 709         return accessor;
 710     }
 711 
 712     static bool put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 713     {
 714         DollarVMAssertScope assertScope;
 715         auto* thisObject = jsCast&lt;ObjectDoingSideEffectPutWithoutCorrectSlotStatus*&gt;(cell);
 716         auto throwScope = DECLARE_THROW_SCOPE(globalObject-&gt;vm());
 717         auto* string = value.toString(globalObject);
 718         RETURN_IF_EXCEPTION(throwScope, false);
 719         RELEASE_AND_RETURN(throwScope, Base::put(thisObject, globalObject, propertyName, string, slot));
 720     }
 721 };
 722 
 723 class DOMJITNode : public JSNonFinalObject {
 724 public:
 725     DOMJITNode(VM&amp; vm, Structure* structure)
 726         : Base(vm, structure)
 727     {
 728         DollarVMAssertScope assertScope;
 729     }
 730 
 731     DECLARE_INFO;
 732     typedef JSNonFinalObject Base;
 733     static constexpr unsigned StructureFlags = Base::StructureFlags;
 734 
 735     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 736     {
 737         DollarVMAssertScope assertScope;
 738         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 739     }
 740 
 741 #if ENABLE(JIT)
 742     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 743     {
 744         DollarVMAssertScope assertScope;
 745         Ref&lt;Snippet&gt; snippet = Snippet::create();
 746         snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {
 747             DollarVMAssertScope assertScope;
 748             CCallHelpers::JumpList failureCases;
 749             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 750             return failureCases;
 751         });
 752         return snippet;
 753     }
 754 #endif
 755 
 756     static DOMJITNode* create(VM&amp; vm, Structure* structure)
 757     {
 758         DollarVMAssertScope assertScope;
 759         DOMJITNode* getter = new (NotNull, allocateCell&lt;DOMJITNode&gt;(vm.heap)) DOMJITNode(vm, structure);
 760         getter-&gt;finishCreation(vm);
 761         return getter;
 762     }
 763 
 764     int32_t value() const
 765     {
 766         return m_value;
 767     }
 768 
 769     static ptrdiff_t offsetOfValue() { return OBJECT_OFFSETOF(DOMJITNode, m_value); }
 770 
 771 private:
 772     int32_t m_value { 42 };
 773 };
 774 
 775 class DOMJITGetter : public DOMJITNode {
 776 public:
 777     DOMJITGetter(VM&amp; vm, Structure* structure)
 778         : Base(vm, structure)
 779     {
 780         DollarVMAssertScope assertScope;
 781     }
 782 
 783     DECLARE_INFO;
 784     typedef DOMJITNode Base;
 785     static constexpr unsigned StructureFlags = Base::StructureFlags;
 786 
 787     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 788     {
 789         DollarVMAssertScope assertScope;
 790         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 791     }
 792 
 793     static DOMJITGetter* create(VM&amp; vm, Structure* structure)
 794     {
 795         DollarVMAssertScope assertScope;
 796         DOMJITGetter* getter = new (NotNull, allocateCell&lt;DOMJITGetter&gt;(vm.heap)) DOMJITGetter(vm, structure);
 797         getter-&gt;finishCreation(vm);
 798         return getter;
 799     }
 800 
 801     class DOMJITAttribute : public DOMJIT::GetterSetter {
 802     public:
 803         ALWAYS_INLINE constexpr DOMJITAttribute()
 804             : DOMJIT::GetterSetter(
 805                 DOMJITGetter::customGetter,
 806 #if ENABLE(JIT)
 807                 &amp;callDOMGetter,
 808 #else
 809                 nullptr,
 810 #endif
 811                 SpecInt32Only)
 812         {
 813         }
 814 
 815 #if ENABLE(JIT)
 816         static EncodedJSValue JIT_OPERATION slowCall(JSGlobalObject* globalObject, void* pointer)
 817         {
 818             DollarVMAssertScope assertScope;
 819             VM&amp; vm = globalObject-&gt;vm();
 820             CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 821             JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 822             return JSValue::encode(jsNumber(static_cast&lt;DOMJITGetter*&gt;(pointer)-&gt;value()));
 823         }
 824 
 825         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 826         {
 827             DollarVMAssertScope assertScope;
 828             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 829             snippet-&gt;requireGlobalObject = true;
 830             snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {
 831                 DollarVMAssertScope assertScope;
 832                 JSValueRegs results = params[0].jsValueRegs();
 833                 GPRReg domGPR = params[1].gpr();
 834                 GPRReg globalObjectGPR = params[2].gpr();
 835                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, globalObjectGPR, domGPR);
 836                 return CCallHelpers::JumpList();
 837 
 838             });
 839             return snippet;
 840         }
 841 #endif
 842     };
 843 
 844 private:
 845     void finishCreation(VM&amp;);
 846 
 847     static EncodedJSValue customGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)
 848     {
 849         DollarVMAssertScope assertScope;
 850         VM&amp; vm = globalObject-&gt;vm();
 851         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, JSValue::decode(thisValue));
 852         ASSERT(thisObject);
 853         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 854     }
 855 };
 856 
 857 static const DOMJITGetter::DOMJITAttribute DOMJITGetterDOMJIT;
 858 
 859 void DOMJITGetter::finishCreation(VM&amp; vm)
 860 {
 861     DollarVMAssertScope assertScope;
 862     Base::finishCreation(vm);
 863     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterDOMJIT;
 864     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITNode::info(), domJIT });
 865     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 866 }
 867 
 868 
 869 class DOMJITGetterComplex : public DOMJITNode {
 870 public:
 871     DOMJITGetterComplex(VM&amp; vm, Structure* structure)
 872         : Base(vm, structure)
 873     {
 874         DollarVMAssertScope assertScope;
 875     }
 876 
 877     DECLARE_INFO;
 878     typedef DOMJITNode Base;
 879     static constexpr unsigned StructureFlags = Base::StructureFlags;
 880 
 881     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 882     {
 883         DollarVMAssertScope assertScope;
 884         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 885     }
 886 
 887     static DOMJITGetterComplex* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 888     {
 889         DollarVMAssertScope assertScope;
 890         DOMJITGetterComplex* getter = new (NotNull, allocateCell&lt;DOMJITGetterComplex&gt;(vm.heap)) DOMJITGetterComplex(vm, structure);
 891         getter-&gt;finishCreation(vm, globalObject);
 892         return getter;
 893     }
 894 
 895     class DOMJITAttribute : public DOMJIT::GetterSetter {
 896     public:
 897         ALWAYS_INLINE constexpr DOMJITAttribute()
 898             : DOMJIT::GetterSetter(
 899                 DOMJITGetterComplex::customGetter,
 900 #if ENABLE(JIT)
 901                 &amp;callDOMGetter,
 902 #else
 903                 nullptr,
 904 #endif
 905                 SpecInt32Only)
 906         {
 907         }
 908 
 909 #if ENABLE(JIT)
 910         static EncodedJSValue JIT_OPERATION slowCall(JSGlobalObject* globalObject, void* pointer)
 911         {
 912             DollarVMAssertScope assertScope;
 913             VM&amp; vm = globalObject-&gt;vm();
 914             CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 915             JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 916             auto scope = DECLARE_THROW_SCOPE(vm);
 917             auto* object = static_cast&lt;DOMJITNode*&gt;(pointer);
 918             auto* domjitGetterComplex = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, object);
 919             if (domjitGetterComplex) {
 920                 if (domjitGetterComplex-&gt;m_enableException)
 921                     return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;DOMJITGetterComplex slow call exception&quot;_s)));
 922             }
 923             return JSValue::encode(jsNumber(object-&gt;value()));
 924         }
 925 
 926         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 927         {
 928             DollarVMAssertScope assertScope;
 929             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 930             static_assert(GPRInfo::numberOfRegisters &gt;= 4, &quot;Number of registers should be larger or equal to 4.&quot;);
 931             unsigned numGPScratchRegisters = GPRInfo::numberOfRegisters - 4;
 932             snippet-&gt;numGPScratchRegisters = numGPScratchRegisters;
 933             snippet-&gt;numFPScratchRegisters = 3;
 934             snippet-&gt;requireGlobalObject = true;
 935             snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {
 936                 DollarVMAssertScope assertScope;
 937                 JSValueRegs results = params[0].jsValueRegs();
 938                 GPRReg domGPR = params[1].gpr();
 939                 GPRReg globalObjectGPR = params[2].gpr();
 940                 for (unsigned i = 0; i &lt; numGPScratchRegisters; ++i)
 941                     jit.move(CCallHelpers::TrustedImm32(42), params.gpScratch(i));
 942 
 943                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, globalObjectGPR, domGPR);
 944                 return CCallHelpers::JumpList();
 945             });
 946             return snippet;
 947         }
 948 #endif
 949     };
 950 
 951 private:
 952     void finishCreation(VM&amp;, JSGlobalObject*);
 953 
 954     static EncodedJSValue JSC_HOST_CALL functionEnableException(JSGlobalObject* globalObject, CallFrame* callFrame)
 955     {
 956         DollarVMAssertScope assertScope;
 957         VM&amp; vm = globalObject-&gt;vm();
 958         auto* object = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, callFrame-&gt;thisValue());
 959         if (object)
 960             object-&gt;m_enableException = true;
 961         return JSValue::encode(jsUndefined());
 962     }
 963 
 964     static EncodedJSValue customGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)
 965     {
 966         DollarVMAssertScope assertScope;
 967         VM&amp; vm = globalObject-&gt;vm();
 968         auto scope = DECLARE_THROW_SCOPE(vm);
 969 
 970         auto* thisObject = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, JSValue::decode(thisValue));
 971         ASSERT(thisObject);
 972         if (thisObject-&gt;m_enableException)
 973             return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;DOMJITGetterComplex slow call exception&quot;_s)));
 974         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 975     }
 976 
 977     bool m_enableException { false };
 978 };
 979 
 980 static const DOMJITGetterComplex::DOMJITAttribute DOMJITGetterComplexDOMJIT;
 981 
 982 void DOMJITGetterComplex::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 983 {
 984     DollarVMAssertScope assertScope;
 985     Base::finishCreation(vm);
 986     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterComplexDOMJIT;
 987     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITGetterComplex::info(), domJIT });
 988     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 989     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;enableException&quot;), 0, functionEnableException, NoIntrinsic, 0);
 990 }
 991 
 992 class DOMJITFunctionObject : public DOMJITNode {
 993 public:
 994     DOMJITFunctionObject(VM&amp; vm, Structure* structure)
 995         : Base(vm, structure)
 996     {
 997         DollarVMAssertScope assertScope;
 998     }
 999 
1000     DECLARE_INFO;
1001     typedef DOMJITNode Base;
1002     static constexpr unsigned StructureFlags = Base::StructureFlags;
1003 
1004     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1005     {
1006         DollarVMAssertScope assertScope;
1007         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
1008     }
1009 
1010     static DOMJITFunctionObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
1011     {
1012         DollarVMAssertScope assertScope;
1013         DOMJITFunctionObject* object = new (NotNull, allocateCell&lt;DOMJITFunctionObject&gt;(vm.heap)) DOMJITFunctionObject(vm, structure);
1014         object-&gt;finishCreation(vm, globalObject);
1015         return object;
1016     }
1017 
1018     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(JSGlobalObject* globalObject, CallFrame* callFrame)
1019     {
1020         DollarVMAssertScope assertScope;
1021         VM&amp; vm = globalObject-&gt;vm();
1022         auto scope = DECLARE_THROW_SCOPE(vm);
1023 
1024         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, callFrame-&gt;thisValue());
1025         if (!thisObject)
1026             return throwVMTypeError(globalObject, scope);
1027         return JSValue::encode(jsNumber(thisObject-&gt;value()));
1028     }
1029 
1030     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(JSGlobalObject* globalObject, DOMJITNode* node)
1031     {
1032         DollarVMAssertScope assertScope;
1033         VM&amp; vm = globalObject-&gt;vm();
1034         CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1035         JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1036         return JSValue::encode(jsNumber(node-&gt;value()));
1037     }
1038 
1039 #if ENABLE(JIT)
1040     static Ref&lt;Snippet&gt; checkSubClassSnippet()
1041     {
1042         DollarVMAssertScope assertScope;
1043         Ref&lt;Snippet&gt; snippet = Snippet::create();
1044         snippet-&gt;numFPScratchRegisters = 1;
1045         snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {
1046             DollarVMAssertScope assertScope;
1047             static const double value = 42.0;
1048             CCallHelpers::JumpList failureCases;
1049             // May use scratch registers.
1050             jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;value), params.fpScratch(0));
1051             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
1052             return failureCases;
1053         });
1054         return snippet;
1055     }
1056 #endif
1057 
1058 private:
1059     void finishCreation(VM&amp;, JSGlobalObject*);
1060 };
1061 
1062 static const DOMJIT::Signature DOMJITFunctionObjectSignature(DOMJITFunctionObject::functionWithoutTypeCheck, DOMJITFunctionObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
1063 
1064 void DOMJITFunctionObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
1065 {
1066     DollarVMAssertScope assertScope;
1067     Base::finishCreation(vm);
1068     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITFunctionObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
1069 }
1070 
1071 class DOMJITCheckSubClassObject : public DOMJITNode {
1072 public:
1073     DOMJITCheckSubClassObject(VM&amp; vm, Structure* structure)
1074         : Base(vm, structure)
1075     {
1076         DollarVMAssertScope assertScope;
1077     }
1078 
1079     DECLARE_INFO;
1080     typedef DOMJITNode Base;
1081     static constexpr unsigned StructureFlags = Base::StructureFlags;
1082 
1083     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1084     {
1085         DollarVMAssertScope assertScope;
1086         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
1087     }
1088 
1089     static DOMJITCheckSubClassObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
1090     {
1091         DollarVMAssertScope assertScope;
1092         DOMJITCheckSubClassObject* object = new (NotNull, allocateCell&lt;DOMJITCheckSubClassObject&gt;(vm.heap)) DOMJITCheckSubClassObject(vm, structure);
1093         object-&gt;finishCreation(vm, globalObject);
1094         return object;
1095     }
1096 
1097     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(JSGlobalObject* globalObject, CallFrame* callFrame)
1098     {
1099         DollarVMAssertScope assertScope;
1100         VM&amp; vm = globalObject-&gt;vm();
1101         auto scope = DECLARE_THROW_SCOPE(vm);
1102 
1103         auto* thisObject = jsDynamicCast&lt;DOMJITCheckSubClassObject*&gt;(vm, callFrame-&gt;thisValue());
1104         if (!thisObject)
1105             return throwVMTypeError(globalObject, scope);
1106         return JSValue::encode(jsNumber(thisObject-&gt;value()));
1107     }
1108 
1109     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(JSGlobalObject* globalObject, DOMJITNode* node)
1110     {
1111         DollarVMAssertScope assertScope;
1112         VM&amp; vm = globalObject-&gt;vm();
1113         CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1114         JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1115         return JSValue::encode(jsNumber(node-&gt;value()));
1116     }
1117 
1118 private:
1119     void finishCreation(VM&amp;, JSGlobalObject*);
1120 };
1121 
1122 static const DOMJIT::Signature DOMJITCheckSubClassObjectSignature(DOMJITCheckSubClassObject::functionWithoutTypeCheck, DOMJITCheckSubClassObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
1123 
1124 void DOMJITCheckSubClassObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
1125 {
1126     DollarVMAssertScope assertScope;
1127     Base::finishCreation(vm);
1128     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITCheckSubClassObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
1129 }
1130 
1131 class DOMJITGetterBaseJSObject : public DOMJITNode {
1132 public:
1133     DOMJITGetterBaseJSObject(VM&amp; vm, Structure* structure)
1134         : Base(vm, structure)
1135     {
1136         DollarVMAssertScope assertScope;
1137     }
1138 
1139     DECLARE_INFO;
1140     using Base = DOMJITNode;
1141     static constexpr unsigned StructureFlags = Base::StructureFlags;
1142 
1143     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1144     {
1145         DollarVMAssertScope assertScope;
1146         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
1147     }
1148 
1149     static DOMJITGetterBaseJSObject* create(VM&amp; vm, Structure* structure)
1150     {
1151         DollarVMAssertScope assertScope;
1152         DOMJITGetterBaseJSObject* getter = new (NotNull, allocateCell&lt;DOMJITGetterBaseJSObject&gt;(vm.heap)) DOMJITGetterBaseJSObject(vm, structure);
1153         getter-&gt;finishCreation(vm);
1154         return getter;
1155     }
1156 
1157     class DOMJITAttribute : public DOMJIT::GetterSetter {
1158     public:
1159         ALWAYS_INLINE constexpr DOMJITAttribute()
1160             : DOMJIT::GetterSetter(
1161                 DOMJITGetterBaseJSObject::customGetter,
1162 #if ENABLE(JIT)
1163                 &amp;callDOMGetter,
1164 #else
1165                 nullptr,
1166 #endif
1167                 SpecBytecodeTop)
1168         {
1169         }
1170 
1171 #if ENABLE(JIT)
1172         static EncodedJSValue JIT_OPERATION slowCall(JSGlobalObject* globalObject, void* pointer)
1173         {
1174             DollarVMAssertScope assertScope;
1175             VM&amp; vm = globalObject-&gt;vm();
1176             CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
1177             JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
1178             JSObject* object = static_cast&lt;JSObject*&gt;(pointer);
1179             return JSValue::encode(object-&gt;getPrototypeDirect(vm));
1180         }
1181 
1182         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
1183         {
1184             DollarVMAssertScope assertScope;
1185             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
1186             snippet-&gt;requireGlobalObject = true;
1187             snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {
1188                 DollarVMAssertScope assertScope;
1189                 JSValueRegs results = params[0].jsValueRegs();
1190                 GPRReg domGPR = params[1].gpr();
1191                 GPRReg globalObjectGPR = params[2].gpr();
1192                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, globalObjectGPR, domGPR);
1193                 return CCallHelpers::JumpList();
1194 
1195             });
1196             return snippet;
1197         }
1198 #endif
1199     };
1200 
1201 private:
1202     void finishCreation(VM&amp;);
1203 
1204     static EncodedJSValue customGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)
1205     {
1206         DollarVMAssertScope assertScope;
1207         VM&amp; vm = globalObject-&gt;vm();
1208         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
1209         RELEASE_ASSERT(thisObject);
1210         return JSValue::encode(thisObject-&gt;getPrototypeDirect(vm));
1211     }
1212 };
1213 
1214 static const DOMJITGetterBaseJSObject::DOMJITAttribute DOMJITGetterBaseJSObjectDOMJIT;
1215 
1216 void DOMJITGetterBaseJSObject::finishCreation(VM&amp; vm)
1217 {
1218     DollarVMAssertScope assertScope;
1219     Base::finishCreation(vm);
1220     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterBaseJSObjectDOMJIT;
1221     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { JSObject::info(), domJIT });
1222     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
1223 }
1224 
1225 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
1226 public:
1227     Message(ArrayBufferContents&amp;&amp;, int32_t);
1228     ~Message();
1229 
1230     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
1231     int32_t index() const { return m_index; }
1232 
1233 private:
1234     ArrayBufferContents m_contents;
1235     int32_t m_index { 0 };
1236 };
1237 
1238 class JSTestCustomGetterSetter : public JSNonFinalObject {
1239 public:
1240     using Base = JSNonFinalObject;
1241     static constexpr unsigned StructureFlags = Base::StructureFlags;
1242 
1243     JSTestCustomGetterSetter(VM&amp; vm, Structure* structure)
1244         : Base(vm, structure)
1245     {
1246         DollarVMAssertScope assertScope;
1247     }
1248 
1249     static JSTestCustomGetterSetter* create(VM&amp; vm, JSGlobalObject*, Structure* structure)
1250     {
1251         DollarVMAssertScope assertScope;
1252         JSTestCustomGetterSetter* result = new (NotNull, allocateCell&lt;JSTestCustomGetterSetter&gt;(vm.heap)) JSTestCustomGetterSetter(vm, structure);
1253         result-&gt;finishCreation(vm);
1254         return result;
1255     }
1256 
1257     void finishCreation(VM&amp;);
1258 
1259     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject)
1260     {
1261         DollarVMAssertScope assertScope;
1262         return Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(ObjectType, StructureFlags), info());
1263     }
1264 
1265     DECLARE_INFO;
1266 };
1267 
1268 
1269 static EncodedJSValue customGetAccessor(JSGlobalObject*, EncodedJSValue thisValue, PropertyName)
1270 {
1271     // Passed |this|
1272     return thisValue;
1273 }
1274 
1275 static EncodedJSValue customGetValue(JSGlobalObject* globalObject, EncodedJSValue slotValue, PropertyName)
1276 {
1277     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(globalObject-&gt;vm()));
1278     // Passed property holder.
1279     return slotValue;
1280 }
1281 
1282 static bool customSetAccessor(JSGlobalObject* globalObject, EncodedJSValue thisObject, EncodedJSValue encodedValue)
1283 {
1284     DollarVMAssertScope assertScope;
1285     VM&amp; vm = globalObject-&gt;vm();
1286 
1287     JSValue value = JSValue::decode(encodedValue);
1288     RELEASE_ASSERT(value.isObject());
1289     JSObject* object = asObject(value);
1290     PutPropertySlot slot(object);
1291     object-&gt;put(object, globalObject, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(thisObject), slot);
1292 
1293     return true;
1294 }
1295 
1296 static bool customSetValue(JSGlobalObject* globalObject, EncodedJSValue slotValue, EncodedJSValue encodedValue)
1297 {
1298     DollarVMAssertScope assertScope;
1299     VM&amp; vm = globalObject-&gt;vm();
1300 
1301     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(globalObject-&gt;vm()));
1302 
1303     JSValue value = JSValue::decode(encodedValue);
1304     RELEASE_ASSERT(value.isObject());
1305     JSObject* object = asObject(value);
1306     PutPropertySlot slot(object);
1307     object-&gt;put(object, globalObject, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(slotValue), slot);
1308 
1309     return true;
1310 }
1311 
1312 void JSTestCustomGetterSetter::finishCreation(VM&amp; vm)
1313 {
1314     DollarVMAssertScope assertScope;
1315     Base::finishCreation(vm);
1316 
1317     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customValue&quot;),
1318         CustomGetterSetter::create(vm, customGetValue, customSetValue), 0);
1319     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customAccessor&quot;),
1320         CustomGetterSetter::create(vm, customGetAccessor, customSetAccessor), static_cast&lt;unsigned&gt;(PropertyAttribute::CustomAccessor));
1321 }
1322 
1323 const ClassInfo Element::s_info = { &quot;Element&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Element) };
1324 const ClassInfo Root::s_info = { &quot;Root&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Root) };
1325 const ClassInfo SimpleObject::s_info = { &quot;SimpleObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(SimpleObject) };
1326 const ClassInfo ImpureGetter::s_info = { &quot;ImpureGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ImpureGetter) };
1327 const ClassInfo CustomGetter::s_info = { &quot;CustomGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(CustomGetter) };
1328 const ClassInfo RuntimeArray::s_info = { &quot;RuntimeArray&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RuntimeArray) };
1329 #if ENABLE(JIT)
1330 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITNode::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITNode) };
1331 #else
1332 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITNode) };
1333 #endif
1334 const ClassInfo DOMJITGetter::s_info = { &quot;DOMJITGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetter) };
1335 const ClassInfo DOMJITGetterComplex::s_info = { &quot;DOMJITGetterComplex&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterComplex) };
1336 const ClassInfo DOMJITGetterBaseJSObject::s_info = { &quot;DOMJITGetterBaseJSObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterBaseJSObject) };
1337 #if ENABLE(JIT)
1338 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITFunctionObject::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1339 #else
1340 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1341 #endif
1342 const ClassInfo DOMJITCheckSubClassObject::s_info = { &quot;DOMJITCheckSubClassObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITCheckSubClassObject) };
1343 const ClassInfo JSTestCustomGetterSetter::s_info = { &quot;JSTestCustomGetterSetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTestCustomGetterSetter) };
1344 
1345 const ClassInfo StaticCustomAccessor::s_info = { &quot;StaticCustomAccessor&quot;, &amp;Base::s_info, &amp;staticCustomAccessorTable, nullptr, CREATE_METHOD_TABLE(StaticCustomAccessor) };
1346 const ClassInfo ObjectDoingSideEffectPutWithoutCorrectSlotStatus::s_info = { &quot;ObjectDoingSideEffectPutWithoutCorrectSlotStatus&quot;, &amp;Base::s_info, &amp;staticCustomAccessorTable, nullptr, CREATE_METHOD_TABLE(ObjectDoingSideEffectPutWithoutCorrectSlotStatus) };
1347 
1348 ElementHandleOwner* Element::handleOwner()
1349 {
1350     DollarVMAssertScope assertScope;
1351     static ElementHandleOwner* owner = 0;
1352     if (!owner)
1353         owner = new ElementHandleOwner();
1354     return owner;
1355 }
1356 
1357 void Element::finishCreation(VM&amp; vm, Root* root)
1358 {
1359     DollarVMAssertScope assertScope;
1360     Base::finishCreation(vm);
1361     setRoot(vm, root);
1362     m_root-&gt;setElement(this);
1363 }
1364 
1365 #if ENABLE(WEBASSEMBLY)
1366 
1367 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(JSGlobalObject*, CallFrame*);
1368 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(JSGlobalObject*, CallFrame*);
1369 
1370 class WasmStreamingParser : public JSDestructibleObject {
1371 public:
1372     class Client final : public Wasm::StreamingParserClient {
1373     public:
1374         explicit Client(WasmStreamingParser* parser)
1375             : m_parser(parser)
1376         {
1377         }
1378 
1379         bool didReceiveSectionData(Wasm::Section) override { return true; }
1380         bool didReceiveFunctionData(unsigned, const Wasm::FunctionData&amp;) override { return true; }
1381         void didFinishParsing() override { }
1382 
1383         WasmStreamingParser* m_parser;
1384     };
1385 
1386     WasmStreamingParser(VM&amp; vm, Structure* structure)
1387         : Base(vm, structure)
1388         , m_info(Wasm::ModuleInformation::create())
1389         , m_client(this)
1390         , m_streamingParser(m_info.get(), m_client)
1391     {
1392         DollarVMAssertScope assertScope;
1393     }
1394 
1395     using Base = JSDestructibleObject;
1396 
1397     static WasmStreamingParser* create(VM&amp; vm, JSGlobalObject* globalObject)
1398     {
1399         DollarVMAssertScope assertScope;
1400         Structure* structure = createStructure(vm, globalObject, jsNull());
1401         WasmStreamingParser* result = new (NotNull, allocateCell&lt;WasmStreamingParser&gt;(vm.heap)) WasmStreamingParser(vm, structure);
1402         result-&gt;finishCreation(vm);
1403         return result;
1404     }
1405 
1406     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1407     {
1408         DollarVMAssertScope assertScope;
1409         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1410     }
1411 
1412     Wasm::StreamingParser&amp; streamingParser() { return m_streamingParser; }
1413 
1414     void finishCreation(VM&amp; vm)
1415     {
1416         DollarVMAssertScope assertScope;
1417         Base::finishCreation(vm);
1418 
1419         JSGlobalObject* globalObject = this-&gt;globalObject(vm);
1420         putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;addBytes&quot;), 0, functionWasmStreamingParserAddBytes, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
1421         putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;finalize&quot;), 0, functionWasmStreamingParserFinalize, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
1422     }
1423 
1424     DECLARE_INFO;
1425 
1426     Ref&lt;Wasm::ModuleInformation&gt; m_info;
1427     Client m_client;
1428     Wasm::StreamingParser m_streamingParser;
1429 };
1430 
1431 const ClassInfo WasmStreamingParser::s_info = { &quot;WasmStreamingParser&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WasmStreamingParser) };
1432 
1433 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(JSGlobalObject* globalObject, CallFrame* callFrame)
1434 {
1435     DollarVMAssertScope assertScope;
1436     VM&amp; vm = globalObject-&gt;vm();
1437     auto scope = DECLARE_THROW_SCOPE(globalObject-&gt;vm());
1438 
1439     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, callFrame-&gt;thisValue());
1440     if (!thisObject)
1441         RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(false)));
1442 
1443     auto data = getWasmBufferFromValue(globalObject, callFrame-&gt;argument(0));
1444     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1445     RELEASE_AND_RETURN(scope, JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().addBytes(bitwise_cast&lt;const uint8_t*&gt;(data.first), data.second)))));
1446 }
1447 
1448 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(JSGlobalObject* globalObject, CallFrame* callFrame)
1449 {
1450     DollarVMAssertScope assertScope;
1451     VM&amp; vm = globalObject-&gt;vm();
1452     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, callFrame-&gt;thisValue());
1453     if (!thisObject)
1454         return JSValue::encode(jsBoolean(false));
1455     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().finalize())));
1456 }
1457 
1458 #endif
1459 
1460 } // namespace
1461 
1462 namespace JSC {
1463 
1464 const ClassInfo JSDollarVM::s_info = { &quot;DollarVM&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVM) };
1465 
1466 // Triggers a crash immediately.
1467 // Usage: $vm.crash()
1468 static NO_RETURN_DUE_TO_CRASH EncodedJSValue JSC_HOST_CALL functionCrash(JSGlobalObject*, CallFrame*)
1469 {
1470     DollarVMAssertScope assertScope;
1471     CRASH();
1472 }
1473 
1474 // Executes a breakpoint instruction if the first argument is truthy or is unset.
1475 // Usage: $vm.breakpoint(&lt;condition&gt;)
1476 static EncodedJSValue JSC_HOST_CALL functionBreakpoint(JSGlobalObject* globalObject, CallFrame* callFrame)
1477 {
1478     DollarVMAssertScope assertScope;
1479     // Nothing should throw here but we might as well double check...
1480     VM&amp; vm = globalObject-&gt;vm();
1481     auto scope = DECLARE_CATCH_SCOPE(vm);
1482     UNUSED_PARAM(scope);
1483     if (!callFrame-&gt;argumentCount() || callFrame-&gt;argument(0).toBoolean(globalObject))
1484         WTFBreakpointTrap();
1485 
1486     return encodedJSUndefined();
1487 }
1488 
1489 // Returns true if the current frame is a DFG frame.
1490 // Usage: isDFG = $vm.dfgTrue()
1491 static EncodedJSValue JSC_HOST_CALL functionDFGTrue(JSGlobalObject*, CallFrame*)
1492 {
1493     DollarVMAssertScope assertScope;
1494     return JSValue::encode(jsBoolean(false));
1495 }
1496 
1497 // Returns true if the current frame is a FTL frame.
1498 // Usage: isFTL = $vm.ftlTrue()
1499 static EncodedJSValue JSC_HOST_CALL functionFTLTrue(JSGlobalObject*, CallFrame*)
1500 {
1501     DollarVMAssertScope assertScope;
1502     return JSValue::encode(jsBoolean(false));
1503 }
1504 
1505 static EncodedJSValue JSC_HOST_CALL functionCpuMfence(JSGlobalObject*, CallFrame*)
1506 {
1507     DollarVMAssertScope assertScope;
1508 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1509     asm volatile(&quot;mfence&quot; ::: &quot;memory&quot;);
1510 #endif
1511     return JSValue::encode(jsUndefined());
1512 }
1513 
1514 static EncodedJSValue JSC_HOST_CALL functionCpuRdtsc(JSGlobalObject*, CallFrame*)
1515 {
1516     DollarVMAssertScope assertScope;
1517 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1518     unsigned high;
1519     unsigned low;
1520     asm volatile (&quot;rdtsc&quot; : &quot;=a&quot;(low), &quot;=d&quot;(high));
1521     return JSValue::encode(jsNumber(low));
1522 #else
1523     return JSValue::encode(jsNumber(0));
1524 #endif
1525 }
1526 
1527 static EncodedJSValue JSC_HOST_CALL functionCpuCpuid(JSGlobalObject*, CallFrame*)
1528 {
1529     DollarVMAssertScope assertScope;
1530 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1531     WTF::x86_cpuid();
1532 #endif
1533     return JSValue::encode(jsUndefined());
1534 }
1535 
1536 static EncodedJSValue JSC_HOST_CALL functionCpuPause(JSGlobalObject*, CallFrame*)
1537 {
1538     DollarVMAssertScope assertScope;
1539 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1540     asm volatile (&quot;pause&quot; ::: &quot;memory&quot;);
1541 #endif
1542     return JSValue::encode(jsUndefined());
1543 }
1544 
1545 // This takes either a JSArrayBuffer, JSArrayBufferView*, or any other object as its first
1546 // argument. The second argument is expected to be an integer.
1547 //
1548 // If the first argument is a JSArrayBuffer, it&#39;ll clflush on that buffer
1549 // plus the second argument as a byte offset. It&#39;ll also flush on the object
1550 // itself so its length, etc, aren&#39;t in the cache.
1551 //
1552 // If the first argument is not a JSArrayBuffer, we load the butterfly
1553 // and clflush at the address of the butterfly.
1554 static EncodedJSValue JSC_HOST_CALL functionCpuClflush(JSGlobalObject* globalObject, CallFrame* callFrame)
1555 {
1556     DollarVMAssertScope assertScope;
1557 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1558     VM&amp; vm = globalObject-&gt;vm();
1559 
1560     if (!callFrame-&gt;argument(1).isInt32())
1561         return JSValue::encode(jsBoolean(false));
1562 
1563     auto clflush = [] (void* ptr) {
1564         DollarVMAssertScope assertScope;
1565         char* ptrToFlush = static_cast&lt;char*&gt;(ptr);
1566         asm volatile (&quot;clflush %0&quot; :: &quot;m&quot;(*ptrToFlush) : &quot;memory&quot;);
1567     };
1568 
1569     Vector&lt;void*&gt; toFlush;
1570 
1571     uint32_t offset = callFrame-&gt;argument(1).asUInt32();
1572 
1573     if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, callFrame-&gt;argument(0)))
1574         toFlush.append(bitwise_cast&lt;char*&gt;(view-&gt;vector()) + offset);
1575     else if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(0))) {
1576         switch (object-&gt;indexingType()) {
1577         case ALL_INT32_INDEXING_TYPES:
1578         case ALL_CONTIGUOUS_INDEXING_TYPES:
1579         case ALL_DOUBLE_INDEXING_TYPES:
1580             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfVectorLength());
1581             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfPublicLength());
1582         }
1583     }
1584 
1585     if (!toFlush.size())
1586         return JSValue::encode(jsBoolean(false));
1587 
1588     for (void* ptr : toFlush)
1589         clflush(ptr);
1590     return JSValue::encode(jsBoolean(true));
1591 #else
1592     UNUSED_PARAM(globalObject);
1593     UNUSED_PARAM(callFrame);
1594     return JSValue::encode(jsBoolean(false));
1595 #endif
1596 }
1597 
1598 class CallerFrameJITTypeFunctor {
1599 public:
1600     CallerFrameJITTypeFunctor()
1601         : m_currentFrame(0)
1602         , m_jitType(JITType::None)
1603     {
1604         DollarVMAssertScope assertScope;
1605     }
1606 
1607     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1608     {
1609         if (m_currentFrame++ &gt; 1) {
1610             m_jitType = visitor-&gt;codeBlock()-&gt;jitType();
1611             return StackVisitor::Done;
1612         }
1613         return StackVisitor::Continue;
1614     }
1615 
1616     JITType jitType() { return m_jitType; }
1617 
1618 private:
1619     mutable unsigned m_currentFrame;
1620     mutable JITType m_jitType;
1621 };
1622 
1623 static FunctionExecutable* getExecutableForFunction(JSValue theFunctionValue)
1624 {
1625     DollarVMAssertScope assertScope;
1626     if (!theFunctionValue.isCell())
1627         return nullptr;
1628 
1629     VM&amp; vm = theFunctionValue.asCell()-&gt;vm();
1630     JSFunction* theFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, theFunctionValue);
1631     if (!theFunction)
1632         return nullptr;
1633 
1634     FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm,
1635         theFunction-&gt;executable());
1636 
1637     return executable;
1638 }
1639 
1640 // Returns true if the current frame is a LLInt frame.
1641 // Usage: isLLInt = $vm.llintTrue()
1642 static EncodedJSValue JSC_HOST_CALL functionLLintTrue(JSGlobalObject* globalObject, CallFrame* callFrame)
1643 {
1644     DollarVMAssertScope assertScope;
1645     VM&amp; vm = globalObject-&gt;vm();
1646     if (!callFrame)
1647         return JSValue::encode(jsUndefined());
1648     CallerFrameJITTypeFunctor functor;
1649     callFrame-&gt;iterate(vm, functor);
1650     return JSValue::encode(jsBoolean(functor.jitType() == JITType::InterpreterThunk));
1651 }
1652 
1653 // Returns true if the current frame is a baseline JIT frame.
1654 // Usage: isBaselineJIT = $vm.jitTrue()
1655 static EncodedJSValue JSC_HOST_CALL functionJITTrue(JSGlobalObject* globalObject, CallFrame* callFrame)
1656 {
1657     DollarVMAssertScope assertScope;
1658     VM&amp; vm = globalObject-&gt;vm();
1659     if (!callFrame)
1660         return JSValue::encode(jsUndefined());
1661     CallerFrameJITTypeFunctor functor;
1662     callFrame-&gt;iterate(vm, functor);
1663     return JSValue::encode(jsBoolean(functor.jitType() == JITType::BaselineJIT));
1664 }
1665 
1666 // Set that the argument function should not be inlined.
1667 // Usage:
1668 // function f() { };
1669 // $vm.noInline(f);
1670 static EncodedJSValue JSC_HOST_CALL functionNoInline(JSGlobalObject*, CallFrame* callFrame)
1671 {
1672     DollarVMAssertScope assertScope;
1673     if (callFrame-&gt;argumentCount() &lt; 1)
1674         return JSValue::encode(jsUndefined());
1675 
1676     JSValue theFunctionValue = callFrame-&gt;uncheckedArgument(0);
1677 
1678     if (FunctionExecutable* executable = getExecutableForFunction(theFunctionValue))
1679         executable-&gt;setNeverInline(true);
1680 
1681     return JSValue::encode(jsUndefined());
1682 }
1683 
1684 // Runs a full GC synchronously.
1685 // Usage: $vm.gc()
1686 static EncodedJSValue JSC_HOST_CALL functionGC(JSGlobalObject* globalObject, CallFrame*)
1687 {
1688     DollarVMAssertScope assertScope;
1689     VMInspector::gc(globalObject);
1690     return JSValue::encode(jsUndefined());
1691 }
1692 
1693 // Runs the edenGC synchronously.
1694 // Usage: $vm.edenGC()
1695 static EncodedJSValue JSC_HOST_CALL functionEdenGC(JSGlobalObject* globalObject, CallFrame*)
1696 {
1697     DollarVMAssertScope assertScope;
1698     VMInspector::edenGC(globalObject);
1699     return JSValue::encode(jsUndefined());
1700 }
1701 
1702 // Dumps the hashes of all subspaces currently registered with the VM.
1703 // Usage: $vm.dumpSubspaceHashes()
1704 static EncodedJSValue JSC_HOST_CALL functionDumpSubspaceHashes(JSGlobalObject* globalObject, CallFrame*)
1705 {
1706     DollarVMAssertScope assertScope;
1707     VM&amp; vm = globalObject-&gt;vm();
1708     VMInspector::dumpSubspaceHashes(&amp;vm);
1709     return JSValue::encode(jsUndefined());
1710 }
1711 
1712 // Gets a JSDollarVMCallFrame for a specified frame index.
1713 // Usage: var callFrame = $vm.callFrame(0) // frame 0 is the top frame.
1714 // Usage: var callFrame = $vm.callFrame() // implies frame 0 i.e. current frame.
1715 //
1716 // This gives you the ability to query the following:
1717 //    callFrame.valid; // false if we asked for a frame beyond the end of the stack, else true.
1718 //    callFrame.callee;
1719 //    callFrame.codeBlock;
1720 //    callFrame.unlinkedCodeBlock;
1721 //    callFrame.executable;
1722 //
1723 // Note: you cannot toString() a codeBlock, unlinkedCodeBlock, or executable because
1724 // there are internal objects and not a JS object. Hence, you cannot do string
1725 // concatenation with them.
1726 static EncodedJSValue JSC_HOST_CALL functionCallFrame(JSGlobalObject* globalObject, CallFrame* callFrame)
1727 {
1728     DollarVMAssertScope assertScope;
1729     unsigned frameNumber = 1;
1730     if (callFrame-&gt;argumentCount() &gt;= 1) {
1731         JSValue value = callFrame-&gt;uncheckedArgument(0);
1732         if (!value.isUInt32())
1733             return JSValue::encode(jsUndefined());
1734 
1735         // We need to inc the frame number because the caller would consider
1736         // its own frame as frame 0. Hence, we need discount the frame for this
1737         // function.
1738         frameNumber = value.asUInt32() + 1;
1739     }
1740 
1741     return JSValue::encode(JSDollarVMCallFrame::create(globalObject, callFrame, frameNumber));
1742 }
1743 
1744 // Gets a token for the CodeBlock for a specified frame index.
1745 // Usage: codeBlockToken = $vm.codeBlockForFrame(0) // frame 0 is the top frame.
1746 // Usage: codeBlockToken = $vm.codeBlockForFrame() // implies frame 0 i.e. current frame.
1747 static EncodedJSValue JSC_HOST_CALL functionCodeBlockForFrame(JSGlobalObject* globalObject, CallFrame* callFrame)
1748 {
1749     DollarVMAssertScope assertScope;
1750     unsigned frameNumber = 1;
1751     if (callFrame-&gt;argumentCount() &gt;= 1) {
1752         JSValue value = callFrame-&gt;uncheckedArgument(0);
1753         if (!value.isUInt32())
1754             return JSValue::encode(jsUndefined());
1755 
1756         // We need to inc the frame number because the caller would consider
1757         // its own frame as frame 0. Hence, we need discount the frame for this
1758         // function.
1759         frameNumber = value.asUInt32() + 1;
1760     }
1761 
1762     CodeBlock* codeBlock = VMInspector::codeBlockForFrame(globalObject, callFrame, frameNumber);
1763     if (codeBlock)
1764         return JSValue::encode(codeBlock);
1765     return JSValue::encode(jsUndefined());
1766 }
1767 
1768 static CodeBlock* codeBlockFromArg(JSGlobalObject* globalObject, CallFrame* callFrame)
1769 {
1770     DollarVMAssertScope assertScope;
1771     VM&amp; vm = globalObject-&gt;vm();
1772     if (callFrame-&gt;argumentCount() &lt; 1)
1773         return nullptr;
1774 
1775     JSValue value = callFrame-&gt;uncheckedArgument(0);
1776     CodeBlock* candidateCodeBlock = nullptr;
1777     if (value.isCell()) {
1778         JSFunction* func = jsDynamicCast&lt;JSFunction*&gt;(vm, value.asCell());
1779         if (func) {
1780             if (func-&gt;isHostFunction())
1781                 candidateCodeBlock = nullptr;
1782             else
1783                 candidateCodeBlock = func-&gt;jsExecutable()-&gt;eitherCodeBlock();
1784         } else
1785             candidateCodeBlock = static_cast&lt;CodeBlock*&gt;(value.asCell());
1786     }
1787 
1788     if (candidateCodeBlock &amp;&amp; VMInspector::isValidCodeBlock(globalObject, candidateCodeBlock))
1789         return candidateCodeBlock;
1790 
1791     if (candidateCodeBlock)
1792         dataLog(&quot;Invalid codeBlock: &quot;, RawPointer(candidateCodeBlock), &quot; &quot;, value, &quot;\n&quot;);
1793     else
1794         dataLog(&quot;Invalid codeBlock: &quot;, value, &quot;\n&quot;);
1795     return nullptr;
1796 }
1797 
1798 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(functionObj))
1799 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(codeBlockToken))
1800 // Note: you cannot toString() a codeBlock because it&#39;s an internal object and not
1801 // a JS object. Hence, you cannot do string concatenation with it.
1802 static EncodedJSValue JSC_HOST_CALL functionCodeBlockFor(JSGlobalObject* globalObject, CallFrame* callFrame)
1803 {
1804     DollarVMAssertScope assertScope;
1805     CodeBlock* codeBlock = codeBlockFromArg(globalObject, callFrame);
1806     WTF::StringPrintStream stream;
1807     if (codeBlock) {
1808         stream.print(*codeBlock);
1809         return JSValue::encode(jsString(globalObject-&gt;vm(), stream.toString()));
1810     }
1811     return JSValue::encode(jsUndefined());
1812 }
1813 
1814 // Usage: $vm.dumpSourceFor(functionObj)
1815 // Usage: $vm.dumpSourceFor(codeBlockToken)
1816 static EncodedJSValue JSC_HOST_CALL functionDumpSourceFor(JSGlobalObject* globalObject, CallFrame* callFrame)
1817 {
1818     DollarVMAssertScope assertScope;
1819     CodeBlock* codeBlock = codeBlockFromArg(globalObject, callFrame);
1820     if (codeBlock)
1821         codeBlock-&gt;dumpSource();
1822     return JSValue::encode(jsUndefined());
1823 }
1824 
1825 // Usage: $vm.dumpBytecodeFor(functionObj)
1826 // Usage: $vm.dumpBytecodeFor(codeBlock)
1827 static EncodedJSValue JSC_HOST_CALL functionDumpBytecodeFor(JSGlobalObject* globalObject, CallFrame* callFrame)
1828 {
1829     DollarVMAssertScope assertScope;
1830     CodeBlock* codeBlock = codeBlockFromArg(globalObject, callFrame);
1831     if (codeBlock)
1832         codeBlock-&gt;dumpBytecode();
1833     return JSValue::encode(jsUndefined());
1834 }
1835 
1836 static EncodedJSValue doPrint(JSGlobalObject* globalObject, CallFrame* callFrame, bool addLineFeed)
1837 {
1838     DollarVMAssertScope assertScope;
1839     auto scope = DECLARE_THROW_SCOPE(globalObject-&gt;vm());
1840     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {
1841         JSValue arg = callFrame-&gt;uncheckedArgument(i);
1842         if (arg.isCell()
1843             &amp;&amp; !arg.isObject()
1844             &amp;&amp; !arg.isString()
1845             &amp;&amp; !arg.isBigInt()) {
1846             dataLog(arg);
1847             continue;
1848         }
1849         String argStr = callFrame-&gt;uncheckedArgument(i).toWTFString(globalObject);
1850         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1851         dataLog(argStr);
1852     }
1853     if (addLineFeed)
1854         dataLog(&quot;\n&quot;);
1855     return JSValue::encode(jsUndefined());
1856 }
1857 
1858 // Prints a series of comma separate strings without appending a newline.
1859 // Usage: $vm.dataLog(str1, str2, str3)
1860 static EncodedJSValue JSC_HOST_CALL functionDataLog(JSGlobalObject* globalObject, CallFrame* callFrame)
1861 {
1862     DollarVMAssertScope assertScope;
1863     const bool addLineFeed = false;
1864     return doPrint(globalObject, callFrame, addLineFeed);
1865 }
1866 
1867 // Prints a series of comma separate strings and appends a newline.
1868 // Usage: $vm.print(str1, str2, str3)
1869 static EncodedJSValue JSC_HOST_CALL functionPrint(JSGlobalObject* globalObject, CallFrame* callFrame)
1870 {
1871     DollarVMAssertScope assertScope;
1872     const bool addLineFeed = true;
1873     return doPrint(globalObject, callFrame, addLineFeed);
1874 }
1875 
1876 // Dumps the current CallFrame.
1877 // Usage: $vm.dumpCallFrame()
1878 static EncodedJSValue JSC_HOST_CALL functionDumpCallFrame(JSGlobalObject* globalObject, CallFrame* callFrame)
1879 {
1880     DollarVMAssertScope assertScope;
1881     // When the callers call this function, they are expecting to dump their
1882     // own frame. So skip 1 for this frame.
1883     VMInspector::dumpCallFrame(globalObject, callFrame, 1);
1884     return JSValue::encode(jsUndefined());
1885 }
1886 
1887 // Dumps the JS stack.
1888 // Usage: $vm.printStack()
1889 static EncodedJSValue JSC_HOST_CALL functionDumpStack(JSGlobalObject* globalObject, CallFrame* callFrame)
1890 {
1891     DollarVMAssertScope assertScope;
1892     // When the callers call this function, they are expecting to dump the
1893     // stack starting their own frame. So skip 1 for this frame.
1894     VMInspector::dumpStack(globalObject, callFrame, 1);
1895     return JSValue::encode(jsUndefined());
1896 }
1897 
1898 // Dumps the current CallFrame.
1899 // Usage: $vm.dumpRegisters(N) // dump the registers of the Nth CallFrame.
1900 // Usage: $vm.dumpRegisters() // dump the registers of the current CallFrame.
1901 // FIXME: Currently, this function dumps the physical frame. We should make
1902 // it dump the logical frame (i.e. be able to dump inlined frames as well).
1903 static EncodedJSValue JSC_HOST_CALL functionDumpRegisters(JSGlobalObject* globalObject, CallFrame* callFrame)
1904 {
1905     DollarVMAssertScope assertScope;
1906     VM&amp; vm = globalObject-&gt;vm();
1907     unsigned requestedFrameIndex = 1;
1908     if (callFrame-&gt;argumentCount() &gt;= 1) {
1909         JSValue value = callFrame-&gt;uncheckedArgument(0);
1910         if (!value.isUInt32())
1911             return JSValue::encode(jsUndefined());
1912 
1913         // We need to inc the frame number because the caller would consider
1914         // its own frame as frame 0. Hence, we need discount the frame for this
1915         // function.
1916         requestedFrameIndex = value.asUInt32() + 1;
1917     }
1918 
1919     unsigned frameIndex = 0;
1920     callFrame-&gt;iterate(vm, [&amp;] (StackVisitor&amp; visitor) {
1921         DollarVMAssertScope assertScope;
1922         if (frameIndex++ != requestedFrameIndex)
1923             return StackVisitor::Continue;
1924         VMInspector::dumpRegisters(visitor-&gt;callFrame());
1925         return StackVisitor::Done;
1926     });
1927 
1928     return encodedJSUndefined();
1929 }
1930 
1931 // Dumps the internal memory layout of a JSCell.
1932 // Usage: $vm.dumpCell(cell)
1933 static EncodedJSValue JSC_HOST_CALL functionDumpCell(JSGlobalObject*, CallFrame* callFrame)
1934 {
1935     DollarVMAssertScope assertScope;
1936     JSValue value = callFrame-&gt;argument(0);
1937     if (!value.isCell())
1938         return encodedJSUndefined();
1939 
1940     VMInspector::dumpCellMemory(value.asCell());
1941     return encodedJSUndefined();
1942 }
1943 
1944 // Gets the dataLog dump of the indexingMode of the passed value.
1945 // Usage: $vm.print(&quot;indexingMode = &quot; + $vm.indexingMode(jsValue))
1946 static EncodedJSValue JSC_HOST_CALL functionIndexingMode(JSGlobalObject* globalObject, CallFrame* callFrame)
1947 {
1948     DollarVMAssertScope assertScope;
1949     if (!callFrame-&gt;argument(0).isObject())
1950         return encodedJSUndefined();
1951 
1952     WTF::StringPrintStream stream;
1953     stream.print(IndexingTypeDump(callFrame-&gt;uncheckedArgument(0).getObject()-&gt;indexingMode()));
1954     return JSValue::encode(jsString(globalObject-&gt;vm(), stream.toString()));
1955 }
1956 
1957 static EncodedJSValue JSC_HOST_CALL functionInlineCapacity(JSGlobalObject* globalObject, CallFrame* callFrame)
1958 {
1959     DollarVMAssertScope assertScope;
1960     VM&amp; vm = globalObject-&gt;vm();
1961     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(0)))
1962         return JSValue::encode(jsNumber(object-&gt;structure(vm)-&gt;inlineCapacity()));
1963 
1964     return encodedJSUndefined();
1965 }
1966 
1967 // Gets the dataLog dump of a given JS value as a string.
1968 // Usage: $vm.print(&quot;value = &quot; + $vm.value(jsValue))
1969 static EncodedJSValue JSC_HOST_CALL functionValue(JSGlobalObject* globalObject, CallFrame* callFrame)
1970 {
1971     DollarVMAssertScope assertScope;
1972     WTF::StringPrintStream stream;
1973     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {
1974         if (i)
1975             stream.print(&quot;, &quot;);
1976         stream.print(callFrame-&gt;uncheckedArgument(i));
1977     }
1978 
1979     return JSValue::encode(jsString(globalObject-&gt;vm(), stream.toString()));
1980 }
1981 
1982 // Gets the pid of the current process.
1983 // Usage: $vm.print(&quot;pid = &quot; + $vm.getpid())
1984 static EncodedJSValue JSC_HOST_CALL functionGetPID(JSGlobalObject*, CallFrame*)
1985 {
1986     DollarVMAssertScope assertScope;
1987     return JSValue::encode(jsNumber(getCurrentProcessID()));
1988 }
1989 
1990 // Make the globalObject have a bad time. Does nothing if the object is not a JSGlobalObject.
1991 // Usage: $vm.haveABadTime(globalObject)
1992 static EncodedJSValue JSC_HOST_CALL functionHaveABadTime(JSGlobalObject* globalObject, CallFrame* callFrame)
1993 {
1994     DollarVMAssertScope assertScope;
1995     VM&amp; vm = globalObject-&gt;vm();
1996     JSLockHolder lock(vm);
1997     JSValue objValue = callFrame-&gt;argument(0);
1998     if (!objValue.isObject())
1999         return JSValue::encode(jsBoolean(false));
2000 
2001     JSObject* obj = asObject(objValue.asCell());
2002     JSGlobalObject* target = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);
2003     if (!target)
2004         JSValue::encode(jsBoolean(false));
2005 
2006     target-&gt;haveABadTime(vm);
2007     return JSValue::encode(jsBoolean(true));
2008 }
2009 
2010 // Checks if the object (or its global if the object is not a global) is having a bad time.
2011 // Usage: $vm.isHavingABadTime(obj)
2012 static EncodedJSValue JSC_HOST_CALL functionIsHavingABadTime(JSGlobalObject* globalObject, CallFrame* callFrame)
2013 {
2014     DollarVMAssertScope assertScope;
2015     VM&amp; vm = globalObject-&gt;vm();
2016     JSLockHolder lock(vm);
2017     JSValue objValue = callFrame-&gt;argument(0);
2018     if (!objValue.isObject())
2019         return JSValue::encode(jsUndefined());
2020 
2021     JSObject* obj = asObject(objValue.asCell());
2022     JSGlobalObject* target = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);
2023     if (target)
2024         JSValue::encode(jsBoolean(target-&gt;isHavingABadTime()));
2025 
2026     target= obj-&gt;globalObject();
2027     if (!target)
2028         return JSValue::encode(jsUndefined());
2029 
2030     return JSValue::encode(jsBoolean(target-&gt;isHavingABadTime()));
2031 }
2032 
2033 // Calls the specified test function after adjusting the stack to have the specified
2034 // remaining size from the end of the physical stack.
2035 // Usage: $vm.callWithStackSize(funcToCall, desiredStackSize)
2036 //
2037 // This function will only work in test configurations, specifically, only if JSC
2038 // options are not frozen. For the jsc shell, the --disableOptionsFreezingForTesting
2039 // argument needs to be passed in on the command line.
2040 
2041 #if ENABLE(MASM_PROBE)
2042 static void callWithStackSizeProbeFunction(Probe::State* state)
2043 {
2044     JSGlobalObject* globalObject = bitwise_cast&lt;JSGlobalObject*&gt;(state-&gt;arg);
2045     JSFunction* function = bitwise_cast&lt;JSFunction*&gt;(state-&gt;probeFunction);
2046     state-&gt;initializeStackFunction = nullptr;
2047     state-&gt;initializeStackArg = nullptr;
2048 
2049     DollarVMAssertScope assertScope;
2050     VM&amp; vm = globalObject-&gt;vm();
2051 
2052     CallData callData;
2053     CallType callType = getCallData(vm, function, callData);
2054     MarkedArgumentBuffer args;
2055     call(globalObject, function, callType, callData, jsUndefined(), args);
2056 }
2057 #endif // ENABLE(MASM_PROBE)
2058 
2059 SUPPRESS_ASAN
2060 static EncodedJSValue JSC_HOST_CALL functionCallWithStackSize(JSGlobalObject* globalObject, CallFrame* callFrame)
2061 {
2062     DollarVMAssertScope assertScope;
2063     VM&amp; vm = globalObject-&gt;vm();
2064     JSLockHolder lock(vm);
2065     auto throwScope = DECLARE_THROW_SCOPE(vm);
2066 
2067 #if OS(DARWIN) &amp;&amp; CPU(X86_64)
2068     constexpr bool isSupportedByPlatform = true;
2069 #else
2070     constexpr bool isSupportedByPlatform = false;
2071 #endif
2072 
2073     if (!isSupportedByPlatform)
2074         return throwVMError(globalObject, throwScope, &quot;Not supported for this platform&quot;);
2075 
2076 #if ENABLE(MASM_PROBE)
2077     if (g_jscConfig.isPermanentlyFrozen || !g_jscConfig.disabledFreezingForTesting)
2078         return throwVMError(globalObject, throwScope, &quot;Options are frozen&quot;);
2079 
2080     if (callFrame-&gt;argumentCount() &lt; 2)
2081         return throwVMError(globalObject, throwScope, &quot;Invalid number of arguments&quot;);
2082     JSValue arg0 = callFrame-&gt;argument(0);
2083     JSValue arg1 = callFrame-&gt;argument(1);
2084     if (!arg0.isFunction(vm))
2085         return throwVMError(globalObject, throwScope, &quot;arg0 should be a function&quot;);
2086     if (!arg1.isNumber())
2087         return throwVMError(globalObject, throwScope, &quot;arg1 should be a number&quot;);
2088 
2089     JSFunction* function = jsCast&lt;JSFunction*&gt;(arg0);
2090     size_t desiredStackSize = arg1.asNumber();
2091 
2092     const StackBounds&amp; bounds = Thread::current().stack();
2093     uint8_t* currentStackPosition = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());
2094     uint8_t* end = bitwise_cast&lt;uint8_t*&gt;(bounds.end());
2095     uint8_t* desiredStart = end + desiredStackSize;
2096     if (desiredStart &gt;= currentStackPosition)
2097         return throwVMError(globalObject, throwScope, &quot;Unable to setup desired stack size&quot;);
2098 
2099     JSDollarVMHelper helper(vm);
2100 
2101     unsigned originalMaxPerThreadStackUsage = Options::maxPerThreadStackUsage();
2102     void* originalVMSoftStackLimit = vm.softStackLimit();
2103     void* originalVMStackLimit = vm.stackLimit();
2104 
2105     // This is a hack to make the VM think it&#39;s stack limits are near the end
2106     // of the physical stack.
2107     uint8_t* vmStackStart = bitwise_cast&lt;uint8_t*&gt;(vm.stackPointerAtVMEntry());
2108     uint8_t* vmStackEnd = vmStackStart - originalMaxPerThreadStackUsage;
2109     ptrdiff_t sizeDiff = vmStackEnd - end;
2110     RELEASE_ASSERT(sizeDiff &gt;= 0);
2111     RELEASE_ASSERT(sizeDiff &lt; UINT_MAX);
2112 
2113     Options::maxPerThreadStackUsage() = originalMaxPerThreadStackUsage + sizeDiff;
2114     helper.updateVMStackLimits();
2115 
2116 #if OS(DARWIN) &amp;&amp; CPU(X86_64)
2117     __asm__ volatile (
2118         &quot;subq %[sizeDiff], %%rsp&quot; &quot;\n&quot;
2119         &quot;pushq %%rax&quot; &quot;\n&quot;
2120         &quot;pushq %%rcx&quot; &quot;\n&quot;
2121         &quot;pushq %%rdx&quot; &quot;\n&quot;
2122         &quot;pushq %%rbx&quot; &quot;\n&quot;
2123         &quot;callq *%%rax&quot; &quot;\n&quot;
2124         &quot;addq %[sizeDiff], %%rsp&quot; &quot;\n&quot;
2125         :
2126         : &quot;a&quot; (ctiMasmProbeTrampoline)
2127         , &quot;c&quot; (callWithStackSizeProbeFunction)
2128         , &quot;d&quot; (function)
2129         , &quot;b&quot; (globalObject)
2130         , [sizeDiff] &quot;rm&quot; (sizeDiff)
2131         : &quot;memory&quot;
2132     );
2133 #else
2134     UNUSED_PARAM(function);
2135 #if !COMPILER(MSVC)
2136     UNUSED_PARAM(callWithStackSizeProbeFunction);
2137 #endif
2138 #endif // OS(DARWIN) &amp;&amp; CPU(X86_64)
2139 
2140     Options::maxPerThreadStackUsage() = originalMaxPerThreadStackUsage;
2141     helper.updateVMStackLimits();
2142     RELEASE_ASSERT(vm.softStackLimit() == originalVMSoftStackLimit);
2143     RELEASE_ASSERT(vm.stackLimit() == originalVMStackLimit);
2144 
2145     throwScope.release();
2146     return encodedJSUndefined();
2147 
2148 #else // not ENABLE(MASM_PROBE)
2149     UNUSED_PARAM(callFrame);
2150     return throwVMError(globalObject, throwScope, &quot;Not supported for this platform&quot;);
2151 #endif // ENABLE(MASM_PROBE)
2152 }
2153 
2154 // Creates a new global object.
2155 // Usage: $vm.createGlobalObject()
2156 static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(JSGlobalObject* globalObject, CallFrame*)
2157 {
2158     DollarVMAssertScope assertScope;
2159     VM&amp; vm = globalObject-&gt;vm();
2160     JSLockHolder lock(vm);
2161     return JSValue::encode(JSGlobalObject::create(vm, JSGlobalObject::createStructure(vm, jsNull())));
2162 }
2163 
2164 static EncodedJSValue JSC_HOST_CALL functionCreateProxy(JSGlobalObject* globalObject, CallFrame* callFrame)
2165 {
2166     DollarVMAssertScope assertScope;
2167     VM&amp; vm = globalObject-&gt;vm();
2168     JSLockHolder lock(vm);
2169     JSValue target = callFrame-&gt;argument(0);
2170     if (!target.isObject())
2171         return JSValue::encode(jsUndefined());
2172     JSObject* jsTarget = asObject(target.asCell());
2173     Structure* structure = JSProxy::createStructure(vm, globalObject, jsTarget-&gt;getPrototypeDirect(vm), ImpureProxyType);
2174     JSProxy* proxy = JSProxy::create(vm, structure, jsTarget);
2175     return JSValue::encode(proxy);
2176 }
2177 
2178 static EncodedJSValue JSC_HOST_CALL functionCreateRuntimeArray(JSGlobalObject* globalObject, CallFrame* callFrame)
2179 {
2180     DollarVMAssertScope assertScope;
2181     JSLockHolder lock(globalObject);
2182     RuntimeArray* array = RuntimeArray::create(globalObject, callFrame);
2183     return JSValue::encode(array);
2184 }
2185 
2186 static EncodedJSValue JSC_HOST_CALL functionCreateNullRopeString(JSGlobalObject* globalObject, CallFrame*)
2187 {
2188     DollarVMAssertScope assertScope;
2189     VM&amp; vm = globalObject-&gt;vm();
2190     JSLockHolder lock(vm);
2191     return JSValue::encode(JSRopeString::createNullForTesting(vm));
2192 }
2193 
2194 static EncodedJSValue JSC_HOST_CALL functionCreateImpureGetter(JSGlobalObject* globalObject, CallFrame* callFrame)
2195 {
2196     DollarVMAssertScope assertScope;
2197     VM&amp; vm = globalObject-&gt;vm();
2198     JSLockHolder lock(vm);
2199     JSValue target = callFrame-&gt;argument(0);
2200     JSObject* delegate = nullptr;
2201     if (target.isObject())
2202         delegate = asObject(target.asCell());
2203     Structure* structure = ImpureGetter::createStructure(vm, globalObject, jsNull());
2204     ImpureGetter* result = ImpureGetter::create(vm, structure, delegate);
2205     return JSValue::encode(result);
2206 }
2207 
2208 static EncodedJSValue JSC_HOST_CALL functionCreateCustomGetterObject(JSGlobalObject* globalObject, CallFrame*)
2209 {
2210     DollarVMAssertScope assertScope;
2211     VM&amp; vm = globalObject-&gt;vm();
2212     JSLockHolder lock(vm);
2213     Structure* structure = CustomGetter::createStructure(vm, globalObject, jsNull());
2214     CustomGetter* result = CustomGetter::create(vm, structure);
2215     return JSValue::encode(result);
2216 }
2217 
2218 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITNodeObject(JSGlobalObject* globalObject, CallFrame*)
2219 {
2220     DollarVMAssertScope assertScope;
2221     VM&amp; vm = globalObject-&gt;vm();
2222     JSLockHolder lock(vm);
2223     Structure* structure = DOMJITNode::createStructure(vm, globalObject, DOMJITGetter::create(vm, DOMJITGetter::createStructure(vm, globalObject, jsNull())));
2224     DOMJITNode* result = DOMJITNode::create(vm, structure);
2225     return JSValue::encode(result);
2226 }
2227 
2228 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterObject(JSGlobalObject* globalObject, CallFrame*)
2229 {
2230     DollarVMAssertScope assertScope;
2231     VM&amp; vm = globalObject-&gt;vm();
2232     JSLockHolder lock(vm);
2233     Structure* structure = DOMJITGetter::createStructure(vm, globalObject, jsNull());
2234     DOMJITGetter* result = DOMJITGetter::create(vm, structure);
2235     return JSValue::encode(result);
2236 }
2237 
2238 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterComplexObject(JSGlobalObject* globalObject, CallFrame*)
2239 {
2240     DollarVMAssertScope assertScope;
2241     VM&amp; vm = globalObject-&gt;vm();
2242     JSLockHolder lock(vm);
2243     Structure* structure = DOMJITGetterComplex::createStructure(vm, globalObject, jsNull());
2244     DOMJITGetterComplex* result = DOMJITGetterComplex::create(vm, globalObject, structure);
2245     return JSValue::encode(result);
2246 }
2247 
2248 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITFunctionObject(JSGlobalObject* globalObject, CallFrame*)
2249 {
2250     DollarVMAssertScope assertScope;
2251     VM&amp; vm = globalObject-&gt;vm();
2252     JSLockHolder lock(vm);
2253     Structure* structure = DOMJITFunctionObject::createStructure(vm, globalObject, jsNull());
2254     DOMJITFunctionObject* result = DOMJITFunctionObject::create(vm, globalObject, structure);
2255     return JSValue::encode(result);
2256 }
2257 
2258 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITCheckSubClassObject(JSGlobalObject* globalObject, CallFrame*)
2259 {
2260     DollarVMAssertScope assertScope;
2261     VM&amp; vm = globalObject-&gt;vm();
2262     JSLockHolder lock(vm);
2263     Structure* structure = DOMJITCheckSubClassObject::createStructure(vm, globalObject, jsNull());
2264     DOMJITCheckSubClassObject* result = DOMJITCheckSubClassObject::create(vm, globalObject, structure);
2265     return JSValue::encode(result);
2266 }
2267 
2268 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterBaseJSObject(JSGlobalObject* globalObject, CallFrame*)
2269 {
2270     DollarVMAssertScope assertScope;
2271     VM&amp; vm = globalObject-&gt;vm();
2272     JSLockHolder lock(vm);
2273     Structure* structure = DOMJITGetterBaseJSObject::createStructure(vm, globalObject, jsNull());
2274     DOMJITGetterBaseJSObject* result = DOMJITGetterBaseJSObject::create(vm, structure);
2275     return JSValue::encode(result);
2276 }
2277 
2278 #if ENABLE(WEBASSEMBLY)
2279 static EncodedJSValue JSC_HOST_CALL functionCreateWasmStreamingParser(JSGlobalObject* globalObject, CallFrame*)
2280 {
2281     DollarVMAssertScope assertScope;
2282     VM&amp; vm = globalObject-&gt;vm();
2283     JSLockHolder lock(vm);
2284     return JSValue::encode(WasmStreamingParser::create(vm, globalObject));
2285 }
2286 #endif
2287 
2288 static EncodedJSValue JSC_HOST_CALL functionCreateStaticCustomAccessor(JSGlobalObject* globalObject, CallFrame*)
2289 {
2290     DollarVMAssertScope assertScope;
2291     VM&amp; vm = globalObject-&gt;vm();
2292     JSLockHolder lock(vm);
2293     Structure* structure = StaticCustomAccessor::createStructure(vm, globalObject, jsNull());
2294     auto* result = StaticCustomAccessor::create(vm, structure);
2295     return JSValue::encode(result);
2296 }
2297 
2298 static EncodedJSValue JSC_HOST_CALL functionCreateObjectDoingSideEffectPutWithoutCorrectSlotStatus(JSGlobalObject* globalObject, CallFrame* callFrame)
2299 {
2300     DollarVMAssertScope assertScope;
2301     VM&amp; vm = globalObject-&gt;vm();
2302     JSLockHolder lock(vm);
2303 
2304     auto* dollarVM = jsDynamicCast&lt;JSDollarVM*&gt;(vm, callFrame-&gt;thisValue());
2305     RELEASE_ASSERT(dollarVM);
2306     auto* result = ObjectDoingSideEffectPutWithoutCorrectSlotStatus::create(vm, dollarVM-&gt;objectDoingSideEffectPutWithoutCorrectSlotStatusStructure());
2307     return JSValue::encode(result);
2308 }
2309 
2310 static EncodedJSValue JSC_HOST_CALL functionSetImpureGetterDelegate(JSGlobalObject* globalObject, CallFrame* callFrame)
2311 {
2312     DollarVMAssertScope assertScope;
2313     VM&amp; vm = globalObject-&gt;vm();
2314     JSLockHolder lock(vm);
2315     auto scope = DECLARE_THROW_SCOPE(vm);
2316 
2317     JSValue base = callFrame-&gt;argument(0);
2318     if (!base.isObject())
2319         return JSValue::encode(jsUndefined());
2320     JSValue delegate = callFrame-&gt;argument(1);
2321     if (!delegate.isObject())
2322         return JSValue::encode(jsUndefined());
2323     ImpureGetter* impureGetter = jsDynamicCast&lt;ImpureGetter*&gt;(vm, asObject(base.asCell()));
2324     if (UNLIKELY(!impureGetter)) {
2325         throwTypeError(globalObject, scope, &quot;argument is not an ImpureGetter&quot;_s);
2326         return encodedJSValue();
2327     }
2328     impureGetter-&gt;setDelegate(vm, asObject(delegate.asCell()));
2329     return JSValue::encode(jsUndefined());
2330 }
2331 
2332 static EncodedJSValue JSC_HOST_CALL functionCreateBuiltin(JSGlobalObject* globalObject, CallFrame* callFrame)
2333 {
2334     DollarVMAssertScope assertScope;
2335     VM&amp; vm = globalObject-&gt;vm();
2336     auto scope = DECLARE_THROW_SCOPE(vm);
2337 
2338     if (callFrame-&gt;argumentCount() &lt; 1 || !callFrame-&gt;argument(0).isString())
2339         return JSValue::encode(jsUndefined());
2340 
2341     String functionText = asString(callFrame-&gt;argument(0))-&gt;value(globalObject);
2342     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2343 
2344     SourceCode source = makeSource(functionText, { });
2345     JSFunction* func = JSFunction::create(vm, createBuiltinExecutable(vm, source, Identifier::fromString(vm, &quot;foo&quot;), ConstructorKind::None, ConstructAbility::CannotConstruct)-&gt;link(vm, nullptr, source), globalObject);
2346 
2347     return JSValue::encode(func);
2348 }
2349 
2350 static EncodedJSValue JSC_HOST_CALL functionGetPrivateProperty(JSGlobalObject* globalObject, CallFrame* callFrame)
2351 {
2352     DollarVMAssertScope assertScope;
2353     VM&amp; vm = globalObject-&gt;vm();
2354     auto scope = DECLARE_THROW_SCOPE(vm);
2355 
2356     if (callFrame-&gt;argumentCount() &lt; 2 || !callFrame-&gt;argument(1).isString())
2357         return encodedJSUndefined();
2358 
2359     String str = asString(callFrame-&gt;argument(1))-&gt;value(globalObject);
2360 
2361     SymbolImpl* symbol = vm.propertyNames-&gt;lookUpPrivateName(Identifier::fromString(vm, str));
2362     if (!symbol)
2363         return throwVMError(globalObject, scope, &quot;Unknown private name.&quot;);
2364 
2365     RELEASE_AND_RETURN(scope, JSValue::encode(callFrame-&gt;argument(0).get(globalObject, symbol)));
2366 }
2367 
2368 static EncodedJSValue JSC_HOST_CALL functionCreateRoot(JSGlobalObject* globalObject, CallFrame*)
2369 {
2370     DollarVMAssertScope assertScope;
2371     VM&amp; vm = globalObject-&gt;vm();
2372     JSLockHolder lock(vm);
2373     return JSValue::encode(Root::create(vm, globalObject));
2374 }
2375 
2376 static EncodedJSValue JSC_HOST_CALL functionCreateElement(JSGlobalObject* globalObject, CallFrame* callFrame)
2377 {
2378     DollarVMAssertScope assertScope;
2379     VM&amp; vm = globalObject-&gt;vm();
2380     JSLockHolder lock(vm);
2381     auto scope = DECLARE_THROW_SCOPE(vm);
2382 
2383     Root* root = jsDynamicCast&lt;Root*&gt;(vm, callFrame-&gt;argument(0));
2384     if (!root)
2385         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Cannot create Element without a Root.&quot;_s)));
2386     return JSValue::encode(Element::create(vm, globalObject, root));
2387 }
2388 
2389 static EncodedJSValue JSC_HOST_CALL functionGetElement(JSGlobalObject* globalObject, CallFrame* callFrame)
2390 {
2391     DollarVMAssertScope assertScope;
2392     VM&amp; vm = globalObject-&gt;vm();
2393     JSLockHolder lock(vm);
2394     Root* root = jsDynamicCast&lt;Root*&gt;(vm, callFrame-&gt;argument(0));
2395     if (!root)
2396         return JSValue::encode(jsUndefined());
2397     Element* result = root-&gt;element();
2398     return JSValue::encode(result ? result : jsUndefined());
2399 }
2400 
2401 static EncodedJSValue JSC_HOST_CALL functionCreateSimpleObject(JSGlobalObject* globalObject, CallFrame*)
2402 {
2403     DollarVMAssertScope assertScope;
2404     VM&amp; vm = globalObject-&gt;vm();
2405     JSLockHolder lock(vm);
2406     return JSValue::encode(SimpleObject::create(vm, globalObject));
2407 }
2408 
2409 static EncodedJSValue JSC_HOST_CALL functionGetHiddenValue(JSGlobalObject* globalObject, CallFrame* callFrame)
2410 {
2411     DollarVMAssertScope assertScope;
2412     VM&amp; vm = globalObject-&gt;vm();
2413     JSLockHolder lock(vm);
2414     auto scope = DECLARE_THROW_SCOPE(vm);
2415 
2416     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, callFrame-&gt;argument(0));
2417     if (UNLIKELY(!simpleObject)) {
2418         throwTypeError(globalObject, scope, &quot;Invalid use of getHiddenValue test function&quot;_s);
2419         return encodedJSValue();
2420     }
2421     return JSValue::encode(simpleObject-&gt;hiddenValue());
2422 }
2423 
2424 static EncodedJSValue JSC_HOST_CALL functionSetHiddenValue(JSGlobalObject* globalObject, CallFrame* callFrame)
2425 {
2426     DollarVMAssertScope assertScope;
2427     VM&amp; vm = globalObject-&gt;vm();
2428     JSLockHolder lock(vm);
2429     auto scope = DECLARE_THROW_SCOPE(vm);
2430 
2431     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, callFrame-&gt;argument(0));
2432     if (UNLIKELY(!simpleObject)) {
2433         throwTypeError(globalObject, scope, &quot;Invalid use of setHiddenValue test function&quot;_s);
2434         return encodedJSValue();
2435     }
2436     JSValue value = callFrame-&gt;argument(1);
2437     simpleObject-&gt;setHiddenValue(vm, value);
2438     return JSValue::encode(jsUndefined());
2439 }
2440 
2441 static EncodedJSValue JSC_HOST_CALL functionShadowChickenFunctionsOnStack(JSGlobalObject* globalObject, CallFrame* callFrame)
2442 {
2443     DollarVMAssertScope assertScope;
2444     VM&amp; vm = globalObject-&gt;vm();
2445     auto scope = DECLARE_THROW_SCOPE(vm);
2446     if (auto* shadowChicken = vm.shadowChicken()) {
2447         scope.release();
2448         return JSValue::encode(shadowChicken-&gt;functionsOnStack(globalObject, callFrame));
2449     }
2450 
2451     JSArray* result = constructEmptyArray(globalObject, 0);
2452     RETURN_IF_EXCEPTION(scope, { });
2453     StackVisitor::visit(callFrame, vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {
2454         DollarVMAssertScope assertScope;
2455         if (visitor-&gt;isInlinedFrame())
2456             return StackVisitor::Continue;
2457         if (visitor-&gt;isWasmFrame())
2458             return StackVisitor::Continue;
2459         result-&gt;push(globalObject, jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()));
2460         scope.releaseAssertNoException(); // This function is only called from tests.
2461         return StackVisitor::Continue;
2462     });
2463     RETURN_IF_EXCEPTION(scope, { });
2464     return JSValue::encode(result);
2465 }
2466 
2467 static EncodedJSValue JSC_HOST_CALL functionSetGlobalConstRedeclarationShouldNotThrow(JSGlobalObject* globalObject, CallFrame*)
2468 {
2469     DollarVMAssertScope assertScope;
2470     VM&amp; vm = globalObject-&gt;vm();
2471     vm.setGlobalConstRedeclarationShouldThrow(false);
2472     return JSValue::encode(jsUndefined());
2473 }
2474 
2475 static EncodedJSValue JSC_HOST_CALL functionFindTypeForExpression(JSGlobalObject* globalObject, CallFrame* callFrame)
2476 {
2477     DollarVMAssertScope assertScope;
2478     VM&amp; vm = globalObject-&gt;vm();
2479     RELEASE_ASSERT(vm.typeProfiler());
2480     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionFindTypeForExpression&quot;_s);
2481 
2482     JSValue functionValue = callFrame-&gt;argument(0);
2483     RELEASE_ASSERT(functionValue.isFunction(vm));
2484     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2485 
2486     RELEASE_ASSERT(callFrame-&gt;argument(1).isString());
2487     String substring = asString(callFrame-&gt;argument(1))-&gt;value(globalObject);
2488     String sourceCodeText = executable-&gt;source().view().toString();
2489     unsigned offset = static_cast&lt;unsigned&gt;(sourceCodeText.find(substring) + executable-&gt;source().startOffset());
2490 
2491     String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorNormal, offset, executable-&gt;sourceID(), vm);
2492     return JSValue::encode(JSONParse(globalObject, jsonString));
2493 }
2494 
2495 static EncodedJSValue JSC_HOST_CALL functionReturnTypeFor(JSGlobalObject* globalObject, CallFrame* callFrame)
2496 {
2497     DollarVMAssertScope assertScope;
2498     VM&amp; vm = globalObject-&gt;vm();
2499     RELEASE_ASSERT(vm.typeProfiler());
2500     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionReturnTypeFor&quot;_s);
2501 
2502     JSValue functionValue = callFrame-&gt;argument(0);
2503     RELEASE_ASSERT(functionValue.isFunction(vm));
2504     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2505 
2506     unsigned offset = executable-&gt;typeProfilingStartOffset(vm);
2507     String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorFunctionReturn, offset, executable-&gt;sourceID(), vm);
2508     return JSValue::encode(JSONParse(globalObject, jsonString));
2509 }
2510 
2511 static EncodedJSValue JSC_HOST_CALL functionFlattenDictionaryObject(JSGlobalObject* globalObject, CallFrame* callFrame)
2512 {
2513     DollarVMAssertScope assertScope;
2514     VM&amp; vm = globalObject-&gt;vm();
2515     JSValue value = callFrame-&gt;argument(0);
2516     RELEASE_ASSERT(value.isObject() &amp;&amp; value.getObject()-&gt;structure()-&gt;isDictionary());
2517     value.getObject()-&gt;flattenDictionaryObject(vm);
2518     return encodedJSUndefined();
2519 }
2520 
2521 static EncodedJSValue JSC_HOST_CALL functionDumpBasicBlockExecutionRanges(JSGlobalObject* globalObject, CallFrame*)
2522 {
2523     DollarVMAssertScope assertScope;
2524     VM&amp; vm = globalObject-&gt;vm();
2525     RELEASE_ASSERT(vm.controlFlowProfiler());
2526     vm.controlFlowProfiler()-&gt;dumpData();
2527     return JSValue::encode(jsUndefined());
2528 }
2529 
2530 static EncodedJSValue JSC_HOST_CALL functionHasBasicBlockExecuted(JSGlobalObject* globalObject, CallFrame* callFrame)
2531 {
2532     DollarVMAssertScope assertScope;
2533     VM&amp; vm = globalObject-&gt;vm();
2534     RELEASE_ASSERT(vm.controlFlowProfiler());
2535 
2536     JSValue functionValue = callFrame-&gt;argument(0);
2537     RELEASE_ASSERT(functionValue.isFunction(vm));
2538     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2539 
2540     RELEASE_ASSERT(callFrame-&gt;argument(1).isString());
2541     String substring = asString(callFrame-&gt;argument(1))-&gt;value(globalObject);
2542     String sourceCodeText = executable-&gt;source().view().toString();
2543     RELEASE_ASSERT(sourceCodeText.contains(substring));
2544     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2545 
2546     bool hasExecuted = vm.controlFlowProfiler()-&gt;hasBasicBlockAtTextOffsetBeenExecuted(offset, executable-&gt;sourceID(), vm);
2547     return JSValue::encode(jsBoolean(hasExecuted));
2548 }
2549 
2550 static EncodedJSValue JSC_HOST_CALL functionBasicBlockExecutionCount(JSGlobalObject* globalObject, CallFrame* callFrame)
2551 {
2552     DollarVMAssertScope assertScope;
2553     VM&amp; vm = globalObject-&gt;vm();
2554     RELEASE_ASSERT(vm.controlFlowProfiler());
2555 
2556     JSValue functionValue = callFrame-&gt;argument(0);
2557     RELEASE_ASSERT(functionValue.isFunction(vm));
2558     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2559 
2560     RELEASE_ASSERT(callFrame-&gt;argument(1).isString());
2561     String substring = asString(callFrame-&gt;argument(1))-&gt;value(globalObject);
2562     String sourceCodeText = executable-&gt;source().view().toString();
2563     RELEASE_ASSERT(sourceCodeText.contains(substring));
2564     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2565 
2566     size_t executionCount = vm.controlFlowProfiler()-&gt;basicBlockExecutionCountAtTextOffset(offset, executable-&gt;sourceID(), vm);
2567     return JSValue::encode(JSValue(executionCount));
2568 }
2569 
2570 static EncodedJSValue JSC_HOST_CALL functionEnableExceptionFuzz(JSGlobalObject*, CallFrame*)
2571 {
2572     DollarVMAssertScope assertScope;
2573     Options::useExceptionFuzz() = true;
2574     return JSValue::encode(jsUndefined());
2575 }
2576 
2577 class DoNothingDebugger final : public Debugger {
2578     WTF_MAKE_NONCOPYABLE(DoNothingDebugger);
2579     WTF_MAKE_FAST_ALLOCATED;
2580 public:
2581     DoNothingDebugger(VM&amp; vm)
2582         : Debugger(vm)
2583     {
2584         DollarVMAssertScope assertScope;
2585         setSuppressAllPauses(true);
2586     }
2587 
2588 private:
2589     void sourceParsed(JSGlobalObject*, SourceProvider*, int, const WTF::String&amp;) override
2590     {
2591         DollarVMAssertScope assertScope;
2592     }
2593 };
2594 
2595 static EncodedJSValue changeDebuggerModeWhenIdle(JSGlobalObject* globalObject, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)
2596 {
2597     DollarVMAssertScope assertScope;
2598 
2599     bool debuggerRequested = codeGenerationMode.contains(CodeGenerationMode::Debugger);
2600     if (debuggerRequested == globalObject-&gt;hasDebugger())
2601         return JSValue::encode(jsUndefined());
2602 
2603     VM* vm = &amp;globalObject-&gt;vm();
2604     vm-&gt;whenIdle([=] () {
2605         DollarVMAssertScope assertScope;
2606         if (debuggerRequested) {
2607             Debugger* debugger = new DoNothingDebugger(globalObject-&gt;vm());
2608             globalObject-&gt;setDebugger(debugger);
2609             debugger-&gt;activateBreakpoints(); // Also deletes all code.
2610         } else {
2611             Debugger* debugger = globalObject-&gt;debugger();
2612             debugger-&gt;deactivateBreakpoints(); // Also deletes all code.
2613             globalObject-&gt;setDebugger(nullptr);
2614             delete debugger;
2615         }
2616     });
2617     return JSValue::encode(jsUndefined());
2618 }
2619 
2620 static EncodedJSValue JSC_HOST_CALL functionEnableDebuggerModeWhenIdle(JSGlobalObject* globalObject, CallFrame*)
2621 {
2622     DollarVMAssertScope assertScope;
2623     return changeDebuggerModeWhenIdle(globalObject, { CodeGenerationMode::Debugger });
2624 }
2625 
2626 static EncodedJSValue JSC_HOST_CALL functionDisableDebuggerModeWhenIdle(JSGlobalObject* globalObject, CallFrame*)
2627 {
2628     DollarVMAssertScope assertScope;
2629     return changeDebuggerModeWhenIdle(globalObject, { });
2630 }
2631 
2632 static EncodedJSValue JSC_HOST_CALL functionDeleteAllCodeWhenIdle(JSGlobalObject* globalObject, CallFrame*)
2633 {
2634     DollarVMAssertScope assertScope;
2635     VM* vm = &amp;globalObject-&gt;vm();
2636     vm-&gt;whenIdle([=] () {
2637         DollarVMAssertScope assertScope;
2638         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);
2639     });
2640     return JSValue::encode(jsUndefined());
2641 }
2642 
2643 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectCount(JSGlobalObject* globalObject, CallFrame*)
2644 {
2645     DollarVMAssertScope assertScope;
2646     return JSValue::encode(jsNumber(globalObject-&gt;vm().heap.globalObjectCount()));
2647 }
2648 
2649 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectForObject(JSGlobalObject* globalObject, CallFrame* callFrame)
2650 {
2651     DollarVMAssertScope assertScope;
2652     JSValue value = callFrame-&gt;argument(0);
2653     RELEASE_ASSERT(value.isObject());
2654     JSGlobalObject* result = jsCast&lt;JSObject*&gt;(value)-&gt;globalObject(globalObject-&gt;vm());
2655     RELEASE_ASSERT(result);
2656     return JSValue::encode(result);
2657 }
2658 
2659 static EncodedJSValue JSC_HOST_CALL functionGetGetterSetter(JSGlobalObject* globalObject, CallFrame* callFrame)
2660 {
2661     DollarVMAssertScope assertScope;
2662     VM&amp; vm = globalObject-&gt;vm();
2663     auto scope = DECLARE_THROW_SCOPE(vm);
2664 
2665     JSValue value = callFrame-&gt;argument(0);
2666     if (!value.isObject())
2667         return JSValue::encode(jsUndefined());
2668 
2669     JSValue property = callFrame-&gt;argument(1);
2670     if (!property.isString())
2671         return JSValue::encode(jsUndefined());
2672 
2673     auto propertyName = asString(property)-&gt;toIdentifier(globalObject);
2674     RETURN_IF_EXCEPTION(scope, { });
2675 
2676     PropertySlot slot(value, PropertySlot::InternalMethodType::VMInquiry);
2677     value.getPropertySlot(globalObject, propertyName, slot);
2678     RETURN_IF_EXCEPTION(scope, { });
2679 
2680     JSValue result;
2681     if (slot.isCacheableGetter())
2682         result = slot.getterSetter();
2683     else
2684         result = jsNull();
2685 
2686     return JSValue::encode(result);
2687 }
2688 
2689 static EncodedJSValue JSC_HOST_CALL functionLoadGetterFromGetterSetter(JSGlobalObject* globalObject, CallFrame* callFrame)
2690 {
2691     DollarVMAssertScope assertScope;
2692     VM&amp; vm = globalObject-&gt;vm();
2693     auto scope = DECLARE_THROW_SCOPE(vm);
2694 
2695     GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(vm, callFrame-&gt;argument(0));
2696     if (UNLIKELY(!getterSetter)) {
2697         throwTypeError(globalObject, scope, &quot;Invalid use of loadGetterFromGetterSetter test function: argument is not a GetterSetter&quot;_s);
2698         return encodedJSValue();
2699     }
2700 
2701     JSObject* getter = getterSetter-&gt;getter();
2702     RELEASE_ASSERT(getter);
2703     return JSValue::encode(getter);
2704 }
2705 
2706 static EncodedJSValue JSC_HOST_CALL functionCreateCustomTestGetterSetter(JSGlobalObject* globalObject, CallFrame*)
2707 {
2708     DollarVMAssertScope assertScope;
2709     VM&amp; vm = globalObject-&gt;vm();
2710     return JSValue::encode(JSTestCustomGetterSetter::create(vm, globalObject, JSTestCustomGetterSetter::createStructure(vm, globalObject)));
2711 }
2712 
2713 static EncodedJSValue JSC_HOST_CALL functionDeltaBetweenButterflies(JSGlobalObject* globalObject, CallFrame* callFrame)
2714 {
2715     DollarVMAssertScope assertScope;
2716     VM&amp; vm = globalObject-&gt;vm();
2717     JSObject* a = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(0));
2718     JSObject* b = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(1));
2719     if (!a || !b)
2720         return JSValue::encode(jsNumber(PNaN));
2721 
2722     ptrdiff_t delta = bitwise_cast&lt;char*&gt;(a-&gt;butterfly()) - bitwise_cast&lt;char*&gt;(b-&gt;butterfly());
2723     if (delta &lt; 0)
2724         return JSValue::encode(jsNumber(PNaN));
2725     if (delta &gt; std::numeric_limits&lt;int32_t&gt;::max())
2726         return JSValue::encode(jsNumber(PNaN));
2727     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(delta)));
2728 }
2729 
2730 static EncodedJSValue JSC_HOST_CALL functionCurrentCPUTime(JSGlobalObject*, CallFrame*)
2731 {
2732     DollarVMAssertScope assertScope;
2733     return JSValue::encode(jsNumber(CPUTime::forCurrentThread().value()));
2734 }
2735 
2736 static EncodedJSValue JSC_HOST_CALL functionTotalGCTime(JSGlobalObject* globalObject, CallFrame*)
2737 {
2738     DollarVMAssertScope assertScope;
2739     VM&amp; vm = globalObject-&gt;vm();
2740     return JSValue::encode(jsNumber(vm.heap.totalGCTime().seconds()));
2741 }
2742 
2743 static EncodedJSValue JSC_HOST_CALL functionParseCount(JSGlobalObject*, CallFrame*)
2744 {
2745     DollarVMAssertScope assertScope;
2746     return JSValue::encode(jsNumber(globalParseCount.load()));
2747 }
2748 
2749 static EncodedJSValue JSC_HOST_CALL functionIsWasmSupported(JSGlobalObject*, CallFrame*)
2750 {
2751     DollarVMAssertScope assertScope;
2752 #if ENABLE(WEBASSEMBLY)
2753     return JSValue::encode(jsBoolean(Wasm::isSupported()));
2754 #else
2755     return JSValue::encode(jsBoolean(false));
2756 #endif
2757 }
2758 
2759 static EncodedJSValue JSC_HOST_CALL functionMake16BitStringIfPossible(JSGlobalObject* globalObject, CallFrame* callFrame)
2760 {
2761     DollarVMAssertScope assertScope;
2762     VM&amp; vm = globalObject-&gt;vm();
2763     auto scope = DECLARE_THROW_SCOPE(vm);
2764     String string = callFrame-&gt;argument(0).toWTFString(globalObject);
2765     RETURN_IF_EXCEPTION(scope, { });
2766     if (!string.is8Bit())
2767         return JSValue::encode(jsString(vm, WTFMove(string)));
2768     Vector&lt;UChar&gt; buffer;
2769     buffer.resize(string.length());
2770     StringImpl::copyCharacters(buffer.data(), string.characters8(), string.length());
2771     return JSValue::encode(jsString(vm, String::adopt(WTFMove(buffer))));
2772 }
2773 
2774 EncodedJSValue JSC_HOST_CALL JSDollarVMHelper::functionGetStructureTransitionList(JSGlobalObject* globalObject, CallFrame* callFrame)
2775 {
2776     DollarVMAssertScope assertScope;
2777     VM&amp; vm = globalObject-&gt;vm();
2778     auto scope = DECLARE_THROW_SCOPE(vm);
2779     JSObject* obj = callFrame-&gt;argument(0).toObject(globalObject);
2780     RETURN_IF_EXCEPTION(scope, { });
2781     if (!obj)
2782         return JSValue::encode(jsNull());
2783     Vector&lt;Structure*, 8&gt; structures;
2784 
2785     for (auto* structure = obj-&gt;structure(); structure; structure = structure-&gt;previousID())
2786         structures.append(structure);
2787 
2788     JSArray* result = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);
2789     RETURN_IF_EXCEPTION(scope, { });
2790 
2791     for (size_t i = 0; i &lt; structures.size(); ++i) {
2792         auto* structure = structures[structures.size() - i - 1];
2793         result-&gt;push(globalObject, JSValue(structure-&gt;id()));
2794         RETURN_IF_EXCEPTION(scope, { });
2795         result-&gt;push(globalObject, JSValue(structure-&gt;transitionOffset()));
2796         RETURN_IF_EXCEPTION(scope, { });
2797         result-&gt;push(globalObject, JSValue(structure-&gt;maxOffset()));
2798         RETURN_IF_EXCEPTION(scope, { });
2799         if (structure-&gt;m_transitionPropertyName)
2800             result-&gt;push(globalObject, jsString(vm, String(*structure-&gt;m_transitionPropertyName)));
2801         else
2802             result-&gt;push(globalObject, jsNull());
2803         RETURN_IF_EXCEPTION(scope, { });
2804         result-&gt;push(globalObject, JSValue(structure-&gt;isPropertyDeletionTransition()));
2805         RETURN_IF_EXCEPTION(scope, { });
2806     }
2807 
2808     return JSValue::encode(result);
2809 }
2810 
2811 static EncodedJSValue JSC_HOST_CALL functionGetConcurrently(JSGlobalObject* globalObject, CallFrame* callFrame)
2812 {
2813     DollarVMAssertScope assertScope;
2814     VM&amp; vm = globalObject-&gt;vm();
2815     auto scope = DECLARE_THROW_SCOPE(vm);
2816     JSObject* obj = callFrame-&gt;argument(0).toObject(globalObject);
2817     RETURN_IF_EXCEPTION(scope, { });
2818     if (!obj)
2819         return JSValue::encode(jsNull());
2820     String property = callFrame-&gt;argument(1).toWTFString(globalObject);
2821     RETURN_IF_EXCEPTION(scope, { });
2822     auto name = PropertyName(Identifier::fromString(vm, property));
2823     auto offset = obj-&gt;structure()-&gt;getConcurrently(name.uid());
2824     if (offset != invalidOffset)
2825         ASSERT(JSValue::encode(obj-&gt;getDirect(offset)));
2826     JSValue result = JSValue(offset != invalidOffset);
2827     RETURN_IF_EXCEPTION(scope, { });
2828     return JSValue::encode(result);
2829 }
2830 
2831 void JSDollarVM::finishCreation(VM&amp; vm)
2832 {
2833     DollarVMAssertScope assertScope;
2834     Base::finishCreation(vm);
2835 
2836     JSGlobalObject* globalObject = this-&gt;globalObject(vm);
2837 
2838     auto addFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
2839         DollarVMAssertScope assertScope;
2840         JSDollarVM::addFunction(vm, globalObject, name, function, arguments);
2841     };
2842     auto addConstructibleFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
2843         DollarVMAssertScope assertScope;
2844         JSDollarVM::addConstructibleFunction(vm, globalObject, name, function, arguments);
2845     };
2846 
2847     addFunction(vm, &quot;abort&quot;, functionCrash, 0);
2848     addFunction(vm, &quot;crash&quot;, functionCrash, 0);
2849     addFunction(vm, &quot;breakpoint&quot;, functionBreakpoint, 0);
2850 
2851     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;dfgTrue&quot;), 0, functionDFGTrue, DFGTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
2852     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;ftlTrue&quot;), 0, functionFTLTrue, FTLTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
2853 
2854     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuMfence&quot;), 0, functionCpuMfence, CPUMfenceIntrinsic, 0);
2855     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuRdtsc&quot;), 0, functionCpuRdtsc, CPURdtscIntrinsic, 0);
2856     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuCpuid&quot;), 0, functionCpuCpuid, CPUCpuidIntrinsic, 0);
2857     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuPause&quot;), 0, functionCpuPause, CPUPauseIntrinsic, 0);
2858     addFunction(vm, &quot;cpuClflush&quot;, functionCpuClflush, 2);
2859 
2860     addFunction(vm, &quot;llintTrue&quot;, functionLLintTrue, 0);
2861     addFunction(vm, &quot;jitTrue&quot;, functionJITTrue, 0);
2862 
2863     addFunction(vm, &quot;noInline&quot;, functionNoInline, 1);
2864 
2865     addFunction(vm, &quot;gc&quot;, functionGC, 0);
2866     addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);
2867     addFunction(vm, &quot;dumpSubspaceHashes&quot;, functionDumpSubspaceHashes, 0);
2868 
2869     addFunction(vm, &quot;callFrame&quot;, functionCallFrame, 1);
2870     addFunction(vm, &quot;codeBlockFor&quot;, functionCodeBlockFor, 1);
2871     addFunction(vm, &quot;codeBlockForFrame&quot;, functionCodeBlockForFrame, 1);
2872     addFunction(vm, &quot;dumpSourceFor&quot;, functionDumpSourceFor, 1);
2873     addFunction(vm, &quot;dumpBytecodeFor&quot;, functionDumpBytecodeFor, 1);
2874 
2875     addFunction(vm, &quot;dataLog&quot;, functionDataLog, 1);
2876     addFunction(vm, &quot;print&quot;, functionPrint, 1);
2877     addFunction(vm, &quot;dumpCallFrame&quot;, functionDumpCallFrame, 0);
2878     addFunction(vm, &quot;dumpStack&quot;, functionDumpStack, 0);
2879     addFunction(vm, &quot;dumpRegisters&quot;, functionDumpRegisters, 1);
2880 
2881     addFunction(vm, &quot;dumpCell&quot;, functionDumpCell, 1);
2882 
2883     addFunction(vm, &quot;indexingMode&quot;, functionIndexingMode, 1);
2884     addFunction(vm, &quot;inlineCapacity&quot;, functionInlineCapacity, 1);
2885     addFunction(vm, &quot;value&quot;, functionValue, 1);
2886     addFunction(vm, &quot;getpid&quot;, functionGetPID, 0);
2887 
2888     addFunction(vm, &quot;haveABadTime&quot;, functionHaveABadTime, 1);
2889     addFunction(vm, &quot;isHavingABadTime&quot;, functionIsHavingABadTime, 1);
2890 
2891     addFunction(vm, &quot;callWithStackSize&quot;, functionCallWithStackSize, 2);
2892 
2893     addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
2894     addFunction(vm, &quot;createProxy&quot;, functionCreateProxy, 1);
2895     addFunction(vm, &quot;createRuntimeArray&quot;, functionCreateRuntimeArray, 0);
2896     addFunction(vm, &quot;createNullRopeString&quot;, functionCreateNullRopeString, 0);
2897 
2898     addFunction(vm, &quot;createImpureGetter&quot;, functionCreateImpureGetter, 1);
2899     addFunction(vm, &quot;createCustomGetterObject&quot;, functionCreateCustomGetterObject, 0);
2900     addFunction(vm, &quot;createDOMJITNodeObject&quot;, functionCreateDOMJITNodeObject, 0);
2901     addFunction(vm, &quot;createDOMJITGetterObject&quot;, functionCreateDOMJITGetterObject, 0);
2902     addFunction(vm, &quot;createDOMJITGetterComplexObject&quot;, functionCreateDOMJITGetterComplexObject, 0);
2903     addFunction(vm, &quot;createDOMJITFunctionObject&quot;, functionCreateDOMJITFunctionObject, 0);
2904     addFunction(vm, &quot;createDOMJITCheckSubClassObject&quot;, functionCreateDOMJITCheckSubClassObject, 0);
2905     addFunction(vm, &quot;createDOMJITGetterBaseJSObject&quot;, functionCreateDOMJITGetterBaseJSObject, 0);
2906     addFunction(vm, &quot;createBuiltin&quot;, functionCreateBuiltin, 2);
2907 #if ENABLE(WEBASSEMBLY)
2908     addFunction(vm, &quot;createWasmStreamingParser&quot;, functionCreateWasmStreamingParser, 0);
2909 #endif
2910     addFunction(vm, &quot;createStaticCustomAccessor&quot;, functionCreateStaticCustomAccessor, 0);
2911     addFunction(vm, &quot;createObjectDoingSideEffectPutWithoutCorrectSlotStatus&quot;, functionCreateObjectDoingSideEffectPutWithoutCorrectSlotStatus, 0);
2912     addFunction(vm, &quot;getPrivateProperty&quot;, functionGetPrivateProperty, 2);
2913     addFunction(vm, &quot;setImpureGetterDelegate&quot;, functionSetImpureGetterDelegate, 2);
2914 
2915     addConstructibleFunction(vm, &quot;Root&quot;, functionCreateRoot, 0);
2916     addConstructibleFunction(vm, &quot;Element&quot;, functionCreateElement, 1);
2917     addFunction(vm, &quot;getElement&quot;, functionGetElement, 1);
2918 
2919     addConstructibleFunction(vm, &quot;SimpleObject&quot;, functionCreateSimpleObject, 0);
2920     addFunction(vm, &quot;getHiddenValue&quot;, functionGetHiddenValue, 1);
2921     addFunction(vm, &quot;setHiddenValue&quot;, functionSetHiddenValue, 2);
2922 
2923     addFunction(vm, &quot;shadowChickenFunctionsOnStack&quot;, functionShadowChickenFunctionsOnStack, 0);
2924     addFunction(vm, &quot;setGlobalConstRedeclarationShouldNotThrow&quot;, functionSetGlobalConstRedeclarationShouldNotThrow, 0);
2925 
2926     addFunction(vm, &quot;findTypeForExpression&quot;, functionFindTypeForExpression, 2);
2927     addFunction(vm, &quot;returnTypeFor&quot;, functionReturnTypeFor, 1);
2928 
2929     addFunction(vm, &quot;flattenDictionaryObject&quot;, functionFlattenDictionaryObject, 1);
2930 
2931     addFunction(vm, &quot;dumpBasicBlockExecutionRanges&quot;, functionDumpBasicBlockExecutionRanges , 0);
2932     addFunction(vm, &quot;hasBasicBlockExecuted&quot;, functionHasBasicBlockExecuted, 2);
2933     addFunction(vm, &quot;basicBlockExecutionCount&quot;, functionBasicBlockExecutionCount, 2);
2934 
2935     addFunction(vm, &quot;enableExceptionFuzz&quot;, functionEnableExceptionFuzz, 0);
2936 
2937     addFunction(vm, &quot;enableDebuggerModeWhenIdle&quot;, functionEnableDebuggerModeWhenIdle, 0);
2938     addFunction(vm, &quot;disableDebuggerModeWhenIdle&quot;, functionDisableDebuggerModeWhenIdle, 0);
2939 
2940     addFunction(vm, &quot;deleteAllCodeWhenIdle&quot;, functionDeleteAllCodeWhenIdle, 0);
2941 
2942     addFunction(vm, &quot;globalObjectCount&quot;, functionGlobalObjectCount, 0);
2943     addFunction(vm, &quot;globalObjectForObject&quot;, functionGlobalObjectForObject, 1);
2944 
2945     addFunction(vm, &quot;getGetterSetter&quot;, functionGetGetterSetter, 2);
2946     addFunction(vm, &quot;loadGetterFromGetterSetter&quot;, functionLoadGetterFromGetterSetter, 1);
2947     addFunction(vm, &quot;createCustomTestGetterSetter&quot;, functionCreateCustomTestGetterSetter, 1);
2948 
2949     addFunction(vm, &quot;deltaBetweenButterflies&quot;, functionDeltaBetweenButterflies, 2);
2950 
2951     addFunction(vm, &quot;currentCPUTime&quot;, functionCurrentCPUTime, 0);
2952     addFunction(vm, &quot;totalGCTime&quot;, functionTotalGCTime, 0);
2953 
2954     addFunction(vm, &quot;parseCount&quot;, functionParseCount, 0);
2955 
2956     addFunction(vm, &quot;isWasmSupported&quot;, functionIsWasmSupported, 0);
2957     addFunction(vm, &quot;make16BitStringIfPossible&quot;, functionMake16BitStringIfPossible, 1);
2958 
2959     addFunction(vm, &quot;getStructureTransitionList&quot;, JSDollarVMHelper::functionGetStructureTransitionList, 1);
2960     addFunction(vm, &quot;getConcurrently&quot;, functionGetConcurrently, 2);
2961 
2962     m_objectDoingSideEffectPutWithoutCorrectSlotStatusStructure.set(vm, this, ObjectDoingSideEffectPutWithoutCorrectSlotStatus::createStructure(vm, globalObject, jsNull()));
2963 }
2964 
2965 void JSDollarVM::addFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2966 {
2967     DollarVMAssertScope assertScope;
2968     Identifier identifier = Identifier::fromString(vm, name);
2969     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function));
2970 }
2971 
2972 void JSDollarVM::addConstructibleFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2973 {
2974     DollarVMAssertScope assertScope;
2975     Identifier identifier = Identifier::fromString(vm, name);
2976     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function, NoIntrinsic, function));
2977 }
2978 
2979 void JSDollarVM::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
2980 {
2981     JSDollarVM* thisObject = jsCast&lt;JSDollarVM*&gt;(cell);
2982     Base::visitChildren(thisObject, visitor);
2983     visitor.append(thisObject-&gt;m_objectDoingSideEffectPutWithoutCorrectSlotStatusStructure);
2984 }
2985 
2986 } // namespace JSC
2987 
2988 IGNORE_WARNINGS_END
    </pre>
  </body>
</html>
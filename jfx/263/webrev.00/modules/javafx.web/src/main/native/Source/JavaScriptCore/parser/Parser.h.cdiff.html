<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Parser.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ParserArena.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 179,10 ***</span>
<span class="line-new-header">--- 179,11 ---</span>
          , m_isFunctionBoundary(false)
          , m_isValidStrictMode(true)
          , m_hasArguments(false)
          , m_isEvalContext(false)
          , m_hasNonSimpleParameterList(false)
<span class="line-added">+         , m_isClassScope(false)</span>
          , m_evalContextType(EvalContextType::None)
          , m_constructorKind(static_cast&lt;unsigned&gt;(ConstructorKind::None))
          , m_expectedSuperBinding(static_cast&lt;unsigned&gt;(SuperBinding::NotNeeded))
          , m_loopDepth(0)
          , m_switchDepth(0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,10 ***</span>
<span class="line-new-header">--- 257,11 ---</span>
  
          case SourceParseMode::NormalFunctionMode:
          case SourceParseMode::GetterMode:
          case SourceParseMode::SetterMode:
          case SourceParseMode::MethodMode:
<span class="line-added">+         case SourceParseMode::InstanceFieldInitializerMode:</span>
              setIsFunction();
              break;
  
          case SourceParseMode::ArrowFunctionMode:
              setIsArrowFunction();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 285,10 ***</span>
<span class="line-new-header">--- 287,11 ---</span>
      bool isFunctionBoundary() const { return m_isFunctionBoundary; }
      bool isGenerator() const { return m_isGenerator; }
      bool isGeneratorBoundary() const { return m_isGeneratorBoundary; }
      bool isAsyncFunction() const { return m_isAsyncFunction; }
      bool isAsyncFunctionBoundary() const { return m_isAsyncFunctionBoundary; }
<span class="line-added">+     bool isClassScope() const { return m_isClassScope; }</span>
  
      bool hasArguments() const { return m_hasArguments; }
  
      void setIsGlobalCodeScope() { m_isGlobalCodeScope = true; }
      bool isGlobalCodeScope() const { return m_isGlobalCodeScope; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,10 ***</span>
<span class="line-new-header">--- 302,16 ---</span>
      void setIsLexicalScope()
      {
          m_isLexicalScope = true;
          m_allowsLexicalDeclarations = true;
      }
<span class="line-added">+ </span>
<span class="line-added">+     void setIsClassScope()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         m_isClassScope = true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      bool isLexicalScope() { return m_isLexicalScope; }
      bool usesEval() { return m_usesEval; }
  
      const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates() const { return m_closedVariableCandidates; }
      VariableEnvironment&amp; declaredVariables() { return m_declaredVariables; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,11 ***</span>
                  m_lexicalVariables.markVariableAsCapturedIfDefined(impl);
          }
  
          // We can now purge values from the captured candidates because they&#39;re captured in this scope.
          {
<span class="line-modified">!             for (auto entry : m_lexicalVariables) {</span>
                  if (entry.value.isCaptured())
                      m_closedVariableCandidates.remove(entry.key.get());
              }
          }
      }
<span class="line-new-header">--- 337,11 ---</span>
                  m_lexicalVariables.markVariableAsCapturedIfDefined(impl);
          }
  
          // We can now purge values from the captured candidates because they&#39;re captured in this scope.
          {
<span class="line-modified">!             for (const auto&amp; entry : m_lexicalVariables) {</span>
                  if (entry.value.isCaptured())
                      m_closedVariableCandidates.remove(entry.key.get());
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 580,10 ***</span>
<span class="line-new-header">--- 589,16 ---</span>
      void addClosedVariableCandidateUnconditionally(UniquedStringImpl* impl)
      {
          m_closedVariableCandidates.add(impl);
      }
  
<span class="line-added">+     void markLastUsedVariablesSetAsCaptured()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         for (UniquedStringImpl* impl : m_usedVariables.last())</span>
<span class="line-added">+             m_closedVariableCandidates.add(impl);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void collectFreeVariables(Scope* nestedScope, bool shouldTrackClosedVariables)
      {
          if (nestedScope-&gt;m_usesEval)
              m_usesEval = true;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,11 ***</span>
          m_innerArrowFunctionFeatures = info-&gt;innerArrowFunctionFeatures;
          m_needsFullActivation = info-&gt;needsFullActivation;
          m_needsSuperBinding = info-&gt;needsSuperBinding;
          UniquedStringImplPtrSet&amp; destSet = m_usedVariables.last();
          for (unsigned i = 0; i &lt; info-&gt;usedVariablesCount; ++i)
<span class="line-modified">!             destSet.add(info-&gt;usedVariables()[i]);</span>
      }
  
      class MaybeParseAsGeneratorForScope;
  
  private:
<span class="line-new-header">--- 722,11 ---</span>
          m_innerArrowFunctionFeatures = info-&gt;innerArrowFunctionFeatures;
          m_needsFullActivation = info-&gt;needsFullActivation;
          m_needsSuperBinding = info-&gt;needsSuperBinding;
          UniquedStringImplPtrSet&amp; destSet = m_usedVariables.last();
          for (unsigned i = 0; i &lt; info-&gt;usedVariablesCount; ++i)
<span class="line-modified">!             destSet.add(info-&gt;usedVariables()[i].get());</span>
      }
  
      class MaybeParseAsGeneratorForScope;
  
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 817,10 ***</span>
<span class="line-new-header">--- 832,11 ---</span>
      bool m_isFunctionBoundary;
      bool m_isValidStrictMode;
      bool m_hasArguments;
      bool m_isEvalContext;
      bool m_hasNonSimpleParameterList;
<span class="line-added">+     bool m_isClassScope;</span>
      EvalContextType m_evalContextType;
      unsigned m_constructorKind;
      unsigned m_expectedSuperBinding;
      int m_loopDepth;
      int m_switchDepth;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 883,15 ***</span>
  class Parser {
      WTF_MAKE_NONCOPYABLE(Parser);
      WTF_MAKE_FAST_ALLOCATED;
  
  public:
<span class="line-modified">!     Parser(VM&amp;, const SourceCode&amp;, JSParserBuiltinMode, JSParserStrictMode, JSParserScriptMode, SourceParseMode, SuperBinding, ConstructorKind defaultConstructorKind = ConstructorKind::None, DerivedContextType = DerivedContextType::None, bool isEvalContext = false, EvalContextType = EvalContextType::None, DebuggerParseData* = nullptr);</span>
      ~Parser();
  
      template &lt;class ParsedNode&gt;
<span class="line-modified">!     std::unique_ptr&lt;ParsedNode&gt; parse(ParserError&amp;, const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);</span>
  
      JSTextPosition positionBeforeLastNewline() const { return m_lexer-&gt;positionBeforeLastNewline(); }
      JSTokenLocation locationBeforeLastToken() const { return m_lexer-&gt;lastTokenLocation(); }
  
      struct CallOrApplyDepthScope {
<span class="line-new-header">--- 899,15 ---</span>
  class Parser {
      WTF_MAKE_NONCOPYABLE(Parser);
      WTF_MAKE_FAST_ALLOCATED;
  
  public:
<span class="line-modified">!     Parser(VM&amp;, const SourceCode&amp;, JSParserBuiltinMode, JSParserStrictMode, JSParserScriptMode, SourceParseMode, SuperBinding, ConstructorKind defaultConstructorKindForTopLevelFunction = ConstructorKind::None, DerivedContextType = DerivedContextType::None, bool isEvalContext = false, EvalContextType = EvalContextType::None, DebuggerParseData* = nullptr);</span>
      ~Parser();
  
      template &lt;class ParsedNode&gt;
<span class="line-modified">!     std::unique_ptr&lt;ParsedNode&gt; parse(ParserError&amp;, const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt, const Vector&lt;JSTextPosition&gt;* = nullptr);</span>
  
      JSTextPosition positionBeforeLastNewline() const { return m_lexer-&gt;positionBeforeLastNewline(); }
      JSTokenLocation locationBeforeLastToken() const { return m_lexer-&gt;lastTokenLocation(); }
  
      struct CallOrApplyDepthScope {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1170,10 ***</span>
<span class="line-new-header">--- 1186,19 ---</span>
              i--;
          // When reaching the top level scope (it can be non ordinary function scope), we return it.
          return ScopeRef(&amp;m_scopeStack, i);
      }
  
<span class="line-added">+     ScopeRef closestClassScopeOrTopLevelScope()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         unsigned i = m_scopeStack.size() - 1;</span>
<span class="line-added">+         ASSERT(i &lt; m_scopeStack.size());</span>
<span class="line-added">+         while (i &amp;&amp; !m_scopeStack[i].isClassScope())</span>
<span class="line-added">+             i--;</span>
<span class="line-added">+         return ScopeRef(&amp;m_scopeStack, i);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      ScopeRef pushScope()
      {
          bool isFunction = false;
          bool isStrict = false;
          bool isGenerator = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1345,60 ***</span>
          return m_functionCache ? m_functionCache-&gt;get(openBracePos) : 0;
      }
  
      Parser();
  
<span class="line-modified">!     String parseInner(const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     void didFinishParsing(SourceElements*, DeclarationStacks::FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, CodeFeatures, int);</span>
  
      // Used to determine type of error to report.
      bool isFunctionMetadataNode(ScopeNode*) { return false; }
      bool isFunctionMetadataNode(FunctionMetadataNode*) { return true; }
  
<span class="line-modified">!     ALWAYS_INLINE void next(unsigned lexerFlags = 0)</span>
      {
          int lastLine = m_token.m_location.line;
          int lastTokenEnd = m_token.m_location.endOffset;
          int lastTokenLineStart = m_token.m_location.lineStartOffset;
          m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
          m_lexer-&gt;setLastLineNumber(lastLine);
          m_token.m_type = m_lexer-&gt;lex(&amp;m_token, lexerFlags, strictMode());
      }
  
<span class="line-modified">!     ALWAYS_INLINE void nextWithoutClearingLineTerminator(unsigned lexerFlags = 0)</span>
      {
          int lastLine = m_token.m_location.line;
          int lastTokenEnd = m_token.m_location.endOffset;
          int lastTokenLineStart = m_token.m_location.lineStartOffset;
          m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
          m_lexer-&gt;setLastLineNumber(lastLine);
          m_token.m_type = m_lexer-&gt;lexWithoutClearingLineTerminator(&amp;m_token, lexerFlags, strictMode());
      }
  
<span class="line-modified">!     ALWAYS_INLINE void nextExpectIdentifier(unsigned lexerFlags = 0)</span>
      {
          int lastLine = m_token.m_location.line;
          int lastTokenEnd = m_token.m_location.endOffset;
          int lastTokenLineStart = m_token.m_location.lineStartOffset;
          m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
          m_lexer-&gt;setLastLineNumber(lastLine);
          m_token.m_type = m_lexer-&gt;lexExpectIdentifier(&amp;m_token, lexerFlags, strictMode());
      }
  
<span class="line-modified">!     ALWAYS_INLINE void lexCurrentTokenAgainUnderCurrentContext()</span>
      {
<span class="line-modified">!         auto savePoint = createSavePoint();</span>
<span class="line-modified">!         restoreSavePoint(savePoint);</span>
      }
  
      ALWAYS_INLINE bool nextTokenIsColon()
      {
          return m_lexer-&gt;nextTokenIsColon();
      }
  
<span class="line-modified">!     ALWAYS_INLINE bool consume(JSTokenType expected, unsigned flags = 0)</span>
      {
          bool result = m_token.m_type == expected;
          if (result)
              next(flags);
          return result;
<span class="line-new-header">--- 1370,68 ---</span>
          return m_functionCache ? m_functionCache-&gt;get(openBracePos) : 0;
      }
  
      Parser();
  
<span class="line-modified">!     struct ParseInnerResult {</span>
<span class="line-modified">!         FunctionParameters* parameters;</span>
<span class="line-modified">!         SourceElements* sourceElements;</span>
<span class="line-added">+         DeclarationStacks::FunctionStack functionDeclarations;</span>
<span class="line-added">+         VariableEnvironment varDeclarations;</span>
<span class="line-added">+         UniquedStringImplPtrSet sloppyModeHoistedFunctions;</span>
<span class="line-added">+         CodeFeatures features;</span>
<span class="line-added">+         int numConstants;</span>
<span class="line-added">+     };</span>
<span class="line-added">+     Expected&lt;ParseInnerResult, String&gt; parseInner(const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt, const Vector&lt;JSTextPosition&gt;* = nullptr);</span>
  
      // Used to determine type of error to report.
      bool isFunctionMetadataNode(ScopeNode*) { return false; }
      bool isFunctionMetadataNode(FunctionMetadataNode*) { return true; }
  
<span class="line-modified">!     ALWAYS_INLINE void next(OptionSet&lt;LexerFlags&gt; lexerFlags = { })</span>
      {
          int lastLine = m_token.m_location.line;
          int lastTokenEnd = m_token.m_location.endOffset;
          int lastTokenLineStart = m_token.m_location.lineStartOffset;
          m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
          m_lexer-&gt;setLastLineNumber(lastLine);
          m_token.m_type = m_lexer-&gt;lex(&amp;m_token, lexerFlags, strictMode());
      }
  
<span class="line-modified">!     ALWAYS_INLINE void nextWithoutClearingLineTerminator(OptionSet&lt;LexerFlags&gt; lexerFlags = { })</span>
      {
          int lastLine = m_token.m_location.line;
          int lastTokenEnd = m_token.m_location.endOffset;
          int lastTokenLineStart = m_token.m_location.lineStartOffset;
          m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
          m_lexer-&gt;setLastLineNumber(lastLine);
          m_token.m_type = m_lexer-&gt;lexWithoutClearingLineTerminator(&amp;m_token, lexerFlags, strictMode());
      }
  
<span class="line-modified">!     ALWAYS_INLINE void nextExpectIdentifier(OptionSet&lt;LexerFlags&gt; lexerFlags = { })</span>
      {
          int lastLine = m_token.m_location.line;
          int lastTokenEnd = m_token.m_location.endOffset;
          int lastTokenLineStart = m_token.m_location.lineStartOffset;
          m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
          m_lexer-&gt;setLastLineNumber(lastLine);
          m_token.m_type = m_lexer-&gt;lexExpectIdentifier(&amp;m_token, lexerFlags, strictMode());
      }
  
<span class="line-modified">!     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">+     ALWAYS_INLINE void lexCurrentTokenAgainUnderCurrentContext(TreeBuilder&amp; context)</span>
      {
<span class="line-modified">!         auto savePoint = createSavePoint(context);</span>
<span class="line-modified">!         restoreSavePoint(context, savePoint);</span>
      }
  
      ALWAYS_INLINE bool nextTokenIsColon()
      {
          return m_lexer-&gt;nextTokenIsColon();
      }
  
<span class="line-modified">!     ALWAYS_INLINE bool consume(JSTokenType expected, OptionSet&lt;LexerFlags&gt; flags = { })</span>
      {
          bool result = m_token.m_type == expected;
          if (result)
              next(flags);
          return result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1574,10 ***</span>
<span class="line-new-header">--- 1607,11 ---</span>
      template &lt;class TreeBuilder&gt; TreeSourceElements parseSourceElements(TreeBuilder&amp;, SourceElementsMode);
      template &lt;class TreeBuilder&gt; TreeSourceElements parseGeneratorFunctionSourceElements(TreeBuilder&amp;, const Identifier&amp; name, SourceElementsMode);
      template &lt;class TreeBuilder&gt; TreeSourceElements parseAsyncFunctionSourceElements(TreeBuilder&amp;, SourceParseMode, bool isArrowFunctionBodyExpression, SourceElementsMode);
      template &lt;class TreeBuilder&gt; TreeSourceElements parseAsyncGeneratorFunctionSourceElements(TreeBuilder&amp;, SourceParseMode, bool isArrowFunctionBodyExpression, SourceElementsMode);
      template &lt;class TreeBuilder&gt; TreeSourceElements parseSingleFunction(TreeBuilder&amp;, Optional&lt;int&gt; functionConstructorParametersEndPosition);
<span class="line-added">+     template &lt;class TreeBuilder&gt; TreeSourceElements parseInstanceFieldInitializerSourceElements(TreeBuilder&amp;, const Vector&lt;JSTextPosition&gt;&amp;);</span>
      template &lt;class TreeBuilder&gt; TreeStatement parseStatementListItem(TreeBuilder&amp;, const Identifier*&amp; directive, unsigned* directiveLiteralLength);
      template &lt;class TreeBuilder&gt; TreeStatement parseStatement(TreeBuilder&amp;, const Identifier*&amp; directive, unsigned* directiveLiteralLength = 0);
      enum class ExportType { Exported, NotExported };
      template &lt;class TreeBuilder&gt; TreeStatement parseClassDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard);
      template &lt;class TreeBuilder&gt; TreeStatement parseFunctionDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1613,11 ***</span>
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeExpression parseAwaitExpression(TreeBuilder&amp;);
      template &lt;class TreeBuilder&gt; TreeExpression parseMemberExpression(TreeBuilder&amp;);
      template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parsePrimaryExpression(TreeBuilder&amp;);
      template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseArrayLiteral(TreeBuilder&amp;);
      template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseObjectLiteral(TreeBuilder&amp;);
<span class="line-removed">-     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeExpression parseStrictObjectLiteral(TreeBuilder&amp;);</span>
      template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeClassExpression parseClassExpression(TreeBuilder&amp;);
      template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseFunctionExpression(TreeBuilder&amp;);
      template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseAsyncFunctionExpression(TreeBuilder&amp;);
      template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeArguments parseArguments(TreeBuilder&amp;);
      template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseArgument(TreeBuilder&amp;, ArgumentType&amp;);
<span class="line-new-header">--- 1647,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1628,11 ***</span>
      template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool parseFormalParameters(TreeBuilder&amp;, TreeFormalParameterList, bool isArrowFunction, bool isMethod, unsigned&amp;);
      enum VarDeclarationListContext { ForLoopContext, VarDeclarationContext };
      template &lt;class TreeBuilder&gt; TreeExpression parseVariableDeclarationList(TreeBuilder&amp;, int&amp; declarations, TreeDestructuringPattern&amp; lastPattern, TreeExpression&amp; lastInitializer, JSTextPosition&amp; identStart, JSTextPosition&amp; initStart, JSTextPosition&amp; initEnd, VarDeclarationListContext, DeclarationType, ExportType, bool&amp; forLoopConstDoesNotHaveInitializer);
      template &lt;class TreeBuilder&gt; TreeSourceElements parseArrowFunctionSingleExpressionBodySourceElements(TreeBuilder&amp;);
      template &lt;class TreeBuilder&gt; TreeExpression parseArrowFunctionExpression(TreeBuilder&amp;, bool isAsync);
<span class="line-modified">!     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern createBindingPattern(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier&amp;, JSToken, AssignmentContext, const Identifier** duplicateIdentifier);</span>
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern createAssignmentElement(TreeBuilder&amp;, TreeExpression&amp;, const JSTextPosition&amp;, const JSTextPosition&amp;);
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, AssignmentContext bindingContext);
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth);
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestAssignmentElement(TreeBuilder&amp; context);
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth);
<span class="line-new-header">--- 1661,11 ---</span>
      template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool parseFormalParameters(TreeBuilder&amp;, TreeFormalParameterList, bool isArrowFunction, bool isMethod, unsigned&amp;);
      enum VarDeclarationListContext { ForLoopContext, VarDeclarationContext };
      template &lt;class TreeBuilder&gt; TreeExpression parseVariableDeclarationList(TreeBuilder&amp;, int&amp; declarations, TreeDestructuringPattern&amp; lastPattern, TreeExpression&amp; lastInitializer, JSTextPosition&amp; identStart, JSTextPosition&amp; initStart, JSTextPosition&amp; initEnd, VarDeclarationListContext, DeclarationType, ExportType, bool&amp; forLoopConstDoesNotHaveInitializer);
      template &lt;class TreeBuilder&gt; TreeSourceElements parseArrowFunctionSingleExpressionBodySourceElements(TreeBuilder&amp;);
      template &lt;class TreeBuilder&gt; TreeExpression parseArrowFunctionExpression(TreeBuilder&amp;, bool isAsync);
<span class="line-modified">!     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern createBindingPattern(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier&amp;, const JSToken&amp;, AssignmentContext, const Identifier** duplicateIdentifier);</span>
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern createAssignmentElement(TreeBuilder&amp;, TreeExpression&amp;, const JSTextPosition&amp;, const JSTextPosition&amp;);
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, AssignmentContext bindingContext);
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth);
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestAssignmentElement(TreeBuilder&amp; context);
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1651,11 ***</span>
      template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression createResolveAndUseVariable(TreeBuilder&amp;, const Identifier*, bool isEval, const JSTextPosition&amp;, const JSTokenLocation&amp;);
  
      enum class FunctionDefinitionType { Expression, Declaration, Method };
      template &lt;class TreeBuilder&gt; NEVER_INLINE bool parseFunctionInfo(TreeBuilder&amp;, FunctionNameRequirements, SourceParseMode, bool nameIsInContainingScope, ConstructorKind, SuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp;, FunctionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
  
<span class="line-modified">!     ALWAYS_INLINE bool isArrowFunctionParameters();</span>
  
      template &lt;class TreeBuilder, class FunctionInfoType&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList parseFunctionParameters(TreeBuilder&amp;, SourceParseMode, FunctionInfoType&amp;);
      template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList createGeneratorParameters(TreeBuilder&amp;, unsigned&amp; parameterCount);
  
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeClassExpression parseClass(TreeBuilder&amp;, FunctionNameRequirements, ParserClassInfo&lt;TreeBuilder&gt;&amp;);
<span class="line-new-header">--- 1684,11 ---</span>
      template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression createResolveAndUseVariable(TreeBuilder&amp;, const Identifier*, bool isEval, const JSTextPosition&amp;, const JSTokenLocation&amp;);
  
      enum class FunctionDefinitionType { Expression, Declaration, Method };
      template &lt;class TreeBuilder&gt; NEVER_INLINE bool parseFunctionInfo(TreeBuilder&amp;, FunctionNameRequirements, SourceParseMode, bool nameIsInContainingScope, ConstructorKind, SuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp;, FunctionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
  
<span class="line-modified">!     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool isArrowFunctionParameters(TreeBuilder&amp;);</span>
  
      template &lt;class TreeBuilder, class FunctionInfoType&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList parseFunctionParameters(TreeBuilder&amp;, SourceParseMode, FunctionInfoType&amp;);
      template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList createGeneratorParameters(TreeBuilder&amp;, unsigned&amp; parameterCount);
  
      template &lt;class TreeBuilder&gt; NEVER_INLINE TreeClassExpression parseClass(TreeBuilder&amp;, FunctionNameRequirements, ParserClassInfo&lt;TreeBuilder&gt;&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1757,26 ***</span>
      enum class FunctionParsePhase { Parameters, Body };
      struct ParserState {
          int assignmentCount { 0 };
          int nonLHSCount { 0 };
          int nonTrivialExpressionCount { 0 };
          FunctionParsePhase functionParsePhase { FunctionParsePhase::Body };
          const Identifier* lastIdentifier { nullptr };
          const Identifier* lastFunctionName { nullptr };
          bool allowAwait { true };
      };
  
      // If you&#39;re using this directly, you probably should be using
      // createSavePoint() instead.
<span class="line-modified">!     ALWAYS_INLINE ParserState internalSaveParserState()</span>
      {
<span class="line-modified">!         return m_parserState;</span>
      }
  
<span class="line-modified">!     ALWAYS_INLINE void restoreParserState(const ParserState&amp; state)</span>
      {
          m_parserState = state;
      }
  
      struct LexerState {
          int startOffset;
          unsigned oldLineStartOffset;
<span class="line-new-header">--- 1790,33 ---</span>
      enum class FunctionParsePhase { Parameters, Body };
      struct ParserState {
          int assignmentCount { 0 };
          int nonLHSCount { 0 };
          int nonTrivialExpressionCount { 0 };
<span class="line-added">+         int unaryTokenStackDepth { 0 };</span>
          FunctionParsePhase functionParsePhase { FunctionParsePhase::Body };
          const Identifier* lastIdentifier { nullptr };
          const Identifier* lastFunctionName { nullptr };
          bool allowAwait { true };
<span class="line-added">+         bool isParsingClassFieldInitializer { false };</span>
      };
  
      // If you&#39;re using this directly, you probably should be using
      // createSavePoint() instead.
<span class="line-modified">!     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">+     ALWAYS_INLINE ParserState internalSaveParserState(TreeBuilder&amp; context)</span>
      {
<span class="line-modified">!         auto parserState = m_parserState;</span>
<span class="line-added">+         parserState.unaryTokenStackDepth = context.unaryTokenStackDepth();</span>
<span class="line-added">+         return parserState;</span>
      }
  
<span class="line-modified">!     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">+     ALWAYS_INLINE void restoreParserState(TreeBuilder&amp; context, const ParserState&amp; state)</span>
      {
          m_parserState = state;
<span class="line-added">+         context.setUnaryTokenStackDepth(m_parserState.unaryTokenStackDepth);</span>
      }
  
      struct LexerState {
          int startOffset;
          unsigned oldLineStartOffset;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1820,79 ***</span>
          bool lexerError;
          String lexerErrorMessage;
          String parserErrorMessage;
      };
  
<span class="line-modified">!     ALWAYS_INLINE void internalSaveState(SavePoint&amp; savePoint)</span>
      {
<span class="line-modified">!         savePoint.parserState = internalSaveParserState();</span>
          savePoint.lexerState = internalSaveLexerState();
      }
  
<span class="line-modified">!     ALWAYS_INLINE SavePointWithError createSavePointForError()</span>
      {
          SavePointWithError savePoint;
<span class="line-modified">!         internalSaveState(savePoint);</span>
          savePoint.lexerError = m_lexer-&gt;sawError();
          savePoint.lexerErrorMessage = m_lexer-&gt;getErrorMessage();
          savePoint.parserErrorMessage = m_errorMessage;
          return savePoint;
      }
  
<span class="line-modified">!     ALWAYS_INLINE SavePoint createSavePoint()</span>
      {
          ASSERT(!hasError());
          SavePoint savePoint;
<span class="line-modified">!         internalSaveState(savePoint);</span>
          return savePoint;
      }
  
<span class="line-modified">!     ALWAYS_INLINE void internalRestoreState(const SavePoint&amp; savePoint)</span>
      {
          restoreLexerState(savePoint.lexerState);
<span class="line-modified">!         restoreParserState(savePoint.parserState);</span>
      }
  
<span class="line-modified">!     ALWAYS_INLINE void restoreSavePointWithError(const SavePointWithError&amp; savePoint)</span>
      {
<span class="line-modified">!         internalRestoreState(savePoint);</span>
          m_lexer-&gt;setSawError(savePoint.lexerError);
          m_lexer-&gt;setErrorMessage(savePoint.lexerErrorMessage);
          m_errorMessage = savePoint.parserErrorMessage;
      }
  
<span class="line-modified">!     ALWAYS_INLINE void restoreSavePoint(const SavePoint&amp; savePoint)</span>
      {
<span class="line-modified">!         internalRestoreState(savePoint);</span>
          m_errorMessage = String();
      }
  
      VM&amp; m_vm;
      const SourceCode* m_source;
      ParserArena m_parserArena;
      std::unique_ptr&lt;LexerType&gt; m_lexer;
<span class="line-removed">-     FunctionParameters* m_parameters { nullptr };</span>
  
      ParserState m_parserState;
  
      bool m_hasStackOverflow;
      String m_errorMessage;
      JSToken m_token;
      bool m_allowsIn;
      JSTextPosition m_lastTokenEndPosition;
      int m_statementDepth;
      RefPtr&lt;SourceProviderCache&gt; m_functionCache;
<span class="line-removed">-     SourceElements* m_sourceElements;</span>
      bool m_parsingBuiltin;
      JSParserScriptMode m_scriptMode;
      SuperBinding m_superBinding;
<span class="line-modified">!     ConstructorKind m_defaultConstructorKind;</span>
<span class="line-removed">-     VariableEnvironment m_varDeclarations;</span>
<span class="line-removed">-     DeclarationStacks::FunctionStack m_funcDeclarations;</span>
<span class="line-removed">-     UniquedStringImplPtrSet m_sloppyModeHoistedFunctions;</span>
<span class="line-removed">-     CodeFeatures m_features;</span>
<span class="line-removed">-     int m_numConstants;</span>
      ExpressionErrorClassifier* m_expressionErrorClassifier;
      bool m_isEvalContext;
      bool m_immediateParentAllowsFunctionDeclarationInStatement;
      RefPtr&lt;ModuleScopeData&gt; m_moduleScopeData;
      DebuggerParseData* m_debuggerParseData;
<span class="line-new-header">--- 1860,81 ---</span>
          bool lexerError;
          String lexerErrorMessage;
          String parserErrorMessage;
      };
  
<span class="line-modified">!     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">+     ALWAYS_INLINE void internalSaveState(TreeBuilder&amp; context, SavePoint&amp; savePoint)</span>
      {
<span class="line-modified">!         savePoint.parserState = internalSaveParserState(context);</span>
          savePoint.lexerState = internalSaveLexerState();
      }
  
<span class="line-modified">!     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">+     ALWAYS_INLINE SavePointWithError swapSavePointForError(TreeBuilder&amp; context, SavePoint&amp; oldSavePoint)</span>
      {
          SavePointWithError savePoint;
<span class="line-modified">!         internalSaveState(context, savePoint);</span>
          savePoint.lexerError = m_lexer-&gt;sawError();
          savePoint.lexerErrorMessage = m_lexer-&gt;getErrorMessage();
          savePoint.parserErrorMessage = m_errorMessage;
<span class="line-added">+         // Make sure we set our new savepoints unary stack to what oldSavePoint had as it currently may contain stale info.</span>
<span class="line-added">+         savePoint.parserState.unaryTokenStackDepth = oldSavePoint.parserState.unaryTokenStackDepth;</span>
<span class="line-added">+         restoreSavePoint(context, oldSavePoint);</span>
          return savePoint;
      }
  
<span class="line-modified">!     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">+     ALWAYS_INLINE SavePoint createSavePoint(TreeBuilder&amp; context)</span>
      {
          ASSERT(!hasError());
          SavePoint savePoint;
<span class="line-modified">!         internalSaveState(context, savePoint);</span>
          return savePoint;
      }
  
<span class="line-modified">!     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">+     ALWAYS_INLINE void internalRestoreState(TreeBuilder&amp; context, const SavePoint&amp; savePoint)</span>
      {
          restoreLexerState(savePoint.lexerState);
<span class="line-modified">!         restoreParserState(context, savePoint.parserState);</span>
      }
  
<span class="line-modified">!     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">+     ALWAYS_INLINE void restoreSavePointWithError(TreeBuilder&amp; context, const SavePointWithError&amp; savePoint)</span>
      {
<span class="line-modified">!         internalRestoreState(context, savePoint);</span>
          m_lexer-&gt;setSawError(savePoint.lexerError);
          m_lexer-&gt;setErrorMessage(savePoint.lexerErrorMessage);
          m_errorMessage = savePoint.parserErrorMessage;
      }
  
<span class="line-modified">!     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">+     ALWAYS_INLINE void restoreSavePoint(TreeBuilder&amp; context, const SavePoint&amp; savePoint)</span>
      {
<span class="line-modified">!         internalRestoreState(context, savePoint);</span>
          m_errorMessage = String();
      }
  
      VM&amp; m_vm;
      const SourceCode* m_source;
      ParserArena m_parserArena;
      std::unique_ptr&lt;LexerType&gt; m_lexer;
  
      ParserState m_parserState;
  
      bool m_hasStackOverflow;
      String m_errorMessage;
      JSToken m_token;
      bool m_allowsIn;
      JSTextPosition m_lastTokenEndPosition;
      int m_statementDepth;
      RefPtr&lt;SourceProviderCache&gt; m_functionCache;
      bool m_parsingBuiltin;
      JSParserScriptMode m_scriptMode;
      SuperBinding m_superBinding;
<span class="line-modified">!     ConstructorKind m_defaultConstructorKindForTopLevelFunction;</span>
      ExpressionErrorClassifier* m_expressionErrorClassifier;
      bool m_isEvalContext;
      bool m_immediateParentAllowsFunctionDeclarationInStatement;
      RefPtr&lt;ModuleScopeData&gt; m_moduleScopeData;
      DebuggerParseData* m_debuggerParseData;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1901,63 ***</span>
  };
  
  
  template &lt;typename LexerType&gt;
  template &lt;class ParsedNode&gt;
<span class="line-modified">! std::unique_ptr&lt;ParsedNode&gt; Parser&lt;LexerType&gt;::parse(ParserError&amp; error, const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)</span>
  {
      int errLine;
      String errMsg;
  
      if (ParsedNode::scopeIsFunction)
          m_lexer-&gt;setIsReparsingFunction();
  
<span class="line-removed">-     m_sourceElements = 0;</span>
<span class="line-removed">- </span>
      errLine = -1;
      errMsg = String();
  
      JSTokenLocation startLocation(tokenLocation());
      ASSERT(m_source-&gt;startColumn() &gt; OrdinalNumber::beforeFirst());
      unsigned startColumn = m_source-&gt;startColumn().zeroBasedInt();
  
<span class="line-modified">!     String parseError = parseInner(calleeName, parseMode, parsingContext, functionConstructorParametersEndPosition);</span>
  
      int lineNumber = m_lexer-&gt;lineNumber();
      bool lexError = m_lexer-&gt;sawError();
      String lexErrorMessage = lexError ? m_lexer-&gt;getErrorMessage() : String();
      ASSERT(lexErrorMessage.isNull() != lexError);
      m_lexer-&gt;clear();
  
<span class="line-modified">!     if (!parseError.isNull() || lexError) {</span>
          errLine = lineNumber;
<span class="line-modified">!         errMsg = !lexErrorMessage.isNull() ? lexErrorMessage : parseError;</span>
<span class="line-removed">-         m_sourceElements = 0;</span>
      }
  
      std::unique_ptr&lt;ParsedNode&gt; result;
<span class="line-modified">!     if (m_sourceElements) {</span>
          JSTokenLocation endLocation;
          endLocation.line = m_lexer-&gt;lineNumber();
          endLocation.lineStartOffset = m_lexer-&gt;currentLineStartOffset();
          endLocation.startOffset = m_lexer-&gt;currentOffset();
          unsigned endColumn = endLocation.startOffset - endLocation.lineStartOffset;
          result = makeUnique&lt;ParsedNode&gt;(m_parserArena,
                                      startLocation,
                                      endLocation,
                                      startColumn,
                                      endColumn,
<span class="line-modified">!                                     m_sourceElements,</span>
<span class="line-modified">!                                     m_varDeclarations,</span>
<span class="line-modified">!                                     WTFMove(m_funcDeclarations),</span>
                                      currentScope()-&gt;finalizeLexicalEnvironment(),
<span class="line-modified">!                                     WTFMove(m_sloppyModeHoistedFunctions),</span>
<span class="line-modified">!                                     m_parameters,</span>
                                      *m_source,
<span class="line-modified">!                                     m_features,</span>
                                      currentScope()-&gt;innerArrowFunctionFeatures(),
<span class="line-modified">!                                     m_numConstants,</span>
                                      WTFMove(m_moduleScopeData));
          result-&gt;setLoc(m_source-&gt;firstLine().oneBasedInt(), m_lexer-&gt;lineNumber(), m_lexer-&gt;currentOffset(), m_lexer-&gt;currentLineStartOffset());
          result-&gt;setEndOffset(m_lexer-&gt;currentOffset());
  
          if (!isFunctionParseMode(parseMode)) {
<span class="line-new-header">--- 1943,60 ---</span>
  };
  
  
  template &lt;typename LexerType&gt;
  template &lt;class ParsedNode&gt;
<span class="line-modified">! std::unique_ptr&lt;ParsedNode&gt; Parser&lt;LexerType&gt;::parse(ParserError&amp; error, const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition, const Vector&lt;JSTextPosition&gt;* instanceFieldLocations)</span>
  {
      int errLine;
      String errMsg;
  
      if (ParsedNode::scopeIsFunction)
          m_lexer-&gt;setIsReparsingFunction();
  
      errLine = -1;
      errMsg = String();
  
      JSTokenLocation startLocation(tokenLocation());
      ASSERT(m_source-&gt;startColumn() &gt; OrdinalNumber::beforeFirst());
      unsigned startColumn = m_source-&gt;startColumn().zeroBasedInt();
  
<span class="line-modified">!     auto parseResult = parseInner(calleeName, parseMode, parsingContext, functionConstructorParametersEndPosition, instanceFieldLocations);</span>
  
      int lineNumber = m_lexer-&gt;lineNumber();
      bool lexError = m_lexer-&gt;sawError();
      String lexErrorMessage = lexError ? m_lexer-&gt;getErrorMessage() : String();
      ASSERT(lexErrorMessage.isNull() != lexError);
      m_lexer-&gt;clear();
  
<span class="line-modified">!     if (!parseResult || lexError) {</span>
          errLine = lineNumber;
<span class="line-modified">!         errMsg = !lexErrorMessage.isNull() ? lexErrorMessage : parseResult.error();</span>
      }
  
      std::unique_ptr&lt;ParsedNode&gt; result;
<span class="line-modified">!     if (parseResult) {</span>
          JSTokenLocation endLocation;
          endLocation.line = m_lexer-&gt;lineNumber();
          endLocation.lineStartOffset = m_lexer-&gt;currentLineStartOffset();
          endLocation.startOffset = m_lexer-&gt;currentOffset();
          unsigned endColumn = endLocation.startOffset - endLocation.lineStartOffset;
          result = makeUnique&lt;ParsedNode&gt;(m_parserArena,
                                      startLocation,
                                      endLocation,
                                      startColumn,
                                      endColumn,
<span class="line-modified">!                                     parseResult.value().sourceElements,</span>
<span class="line-modified">!                                     parseResult.value().varDeclarations,</span>
<span class="line-modified">!                                     WTFMove(parseResult.value().functionDeclarations),</span>
                                      currentScope()-&gt;finalizeLexicalEnvironment(),
<span class="line-modified">!                                     WTFMove(parseResult.value().sloppyModeHoistedFunctions),</span>
<span class="line-modified">!                                     parseResult.value().parameters,</span>
                                      *m_source,
<span class="line-modified">!                                     parseResult.value().features,</span>
                                      currentScope()-&gt;innerArrowFunctionFeatures(),
<span class="line-modified">!                                     parseResult.value().numConstants,</span>
                                      WTFMove(m_moduleScopeData));
          result-&gt;setLoc(m_source-&gt;firstLine().oneBasedInt(), m_lexer-&gt;lineNumber(), m_lexer-&gt;currentOffset(), m_lexer-&gt;currentLineStartOffset());
          result-&gt;setEndOffset(m_lexer-&gt;currentOffset());
  
          if (!isFunctionParseMode(parseMode)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1999,38 ***</span>
  std::unique_ptr&lt;ParsedNode&gt; parse(
      VM&amp; vm, const SourceCode&amp; source,
      const Identifier&amp; name, JSParserBuiltinMode builtinMode,
      JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding,
      ParserError&amp; error, JSTextPosition* positionBeforeLastNewline = nullptr,
<span class="line-modified">!     ConstructorKind defaultConstructorKind = ConstructorKind::None,</span>
      DerivedContextType derivedContextType = DerivedContextType::None,
      EvalContextType evalContextType = EvalContextType::None,
<span class="line-modified">!     DebuggerParseData* debuggerParseData = nullptr)</span>
  {
      ASSERT(!source.provider()-&gt;source().isNull());
  
      MonotonicTime before;
      if (UNLIKELY(Options::reportParseTimes()))
          before = MonotonicTime::now();
  
      std::unique_ptr&lt;ParsedNode&gt; result;
      if (source.provider()-&gt;source().is8Bit()) {
<span class="line-modified">!         Parser&lt;Lexer&lt;LChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKind, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);</span>
<span class="line-modified">!         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program);</span>
          if (positionBeforeLastNewline)
              *positionBeforeLastNewline = parser.positionBeforeLastNewline();
          if (builtinMode == JSParserBuiltinMode::Builtin) {
              if (!result) {
                  ASSERT(error.isValid());
                  if (error.type() != ParserError::StackOverflow)
                      dataLogLn(&quot;Unexpected error compiling builtin: &quot;, error.message());
              }
          }
      } else {
<span class="line-modified">!         ASSERT_WITH_MESSAGE(defaultConstructorKind == ConstructorKind::None, &quot;BuiltinExecutables::createDefaultConstructor should always use a 8-bit string&quot;);</span>
<span class="line-modified">!         Parser&lt;Lexer&lt;UChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKind, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);</span>
<span class="line-modified">!         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program);</span>
          if (positionBeforeLastNewline)
              *positionBeforeLastNewline = parser.positionBeforeLastNewline();
      }
  
      if (UNLIKELY(Options::countParseTimes()))
<span class="line-new-header">--- 2038,39 ---</span>
  std::unique_ptr&lt;ParsedNode&gt; parse(
      VM&amp; vm, const SourceCode&amp; source,
      const Identifier&amp; name, JSParserBuiltinMode builtinMode,
      JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding,
      ParserError&amp; error, JSTextPosition* positionBeforeLastNewline = nullptr,
<span class="line-modified">!     ConstructorKind defaultConstructorKindForTopLevelFunction = ConstructorKind::None,</span>
      DerivedContextType derivedContextType = DerivedContextType::None,
      EvalContextType evalContextType = EvalContextType::None,
<span class="line-modified">!     DebuggerParseData* debuggerParseData = nullptr,</span>
<span class="line-added">+     const Vector&lt;JSTextPosition&gt;* instanceFieldLocations = nullptr)</span>
  {
      ASSERT(!source.provider()-&gt;source().isNull());
  
      MonotonicTime before;
      if (UNLIKELY(Options::reportParseTimes()))
          before = MonotonicTime::now();
  
      std::unique_ptr&lt;ParsedNode&gt; result;
      if (source.provider()-&gt;source().is8Bit()) {
<span class="line-modified">!         Parser&lt;Lexer&lt;LChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKindForTopLevelFunction, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);</span>
<span class="line-modified">!         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program, WTF::nullopt, instanceFieldLocations);</span>
          if (positionBeforeLastNewline)
              *positionBeforeLastNewline = parser.positionBeforeLastNewline();
          if (builtinMode == JSParserBuiltinMode::Builtin) {
              if (!result) {
                  ASSERT(error.isValid());
                  if (error.type() != ParserError::StackOverflow)
                      dataLogLn(&quot;Unexpected error compiling builtin: &quot;, error.message());
              }
          }
      } else {
<span class="line-modified">!         ASSERT_WITH_MESSAGE(defaultConstructorKindForTopLevelFunction == ConstructorKind::None, &quot;BuiltinExecutables&#39;s special constructors should always use a 8-bit string&quot;);</span>
<span class="line-modified">!         Parser&lt;Lexer&lt;UChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKindForTopLevelFunction, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);</span>
<span class="line-modified">!         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program, WTF::nullopt, instanceFieldLocations);</span>
          if (positionBeforeLastNewline)
              *positionBeforeLastNewline = parser.positionBeforeLastNewline();
      }
  
      if (UNLIKELY(Options::countParseTimes()))
</pre>
<center><a href="Parser.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ParserArena.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
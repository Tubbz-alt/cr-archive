<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListItems.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DisplayListItems.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DisplayListRecorder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListItems.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 

  28 #include &quot;FloatPoint.h&quot;
<span class="line-removed">  29 #include &quot;FloatRect.h&quot;</span>
  30 #include &quot;FloatRoundedRect.h&quot;
  31 #include &quot;Font.h&quot;
  32 #include &quot;GlyphBuffer.h&quot;
<span class="line-removed">  33 #include &quot;GraphicsContext.h&quot;</span>
  34 #include &quot;Image.h&quot;

  35 #include &lt;wtf/RefCounted.h&gt;
  36 #include &lt;wtf/TypeCasts.h&gt;
  37 
<span class="line-removed">  38 #if USE(CG)</span>
<span class="line-removed">  39 #include &quot;GraphicsContextPlatformPrivateCG.h&quot;</span>
<span class="line-removed">  40 #endif</span>
<span class="line-removed">  41 </span>
  42 namespace WTF {
  43 class TextStream;
  44 }
  45 
  46 namespace WebCore {
  47 
  48 struct ImagePaintingOptions;
  49 
  50 namespace DisplayList {
  51 
<span class="line-removed">  52 enum class ItemType {</span>
<span class="line-removed">  53     Save,</span>
<span class="line-removed">  54     Restore,</span>
<span class="line-removed">  55     Translate,</span>
<span class="line-removed">  56     Rotate,</span>
<span class="line-removed">  57     Scale,</span>
<span class="line-removed">  58     ConcatenateCTM,</span>
<span class="line-removed">  59     SetState,</span>
<span class="line-removed">  60     SetLineCap,</span>
<span class="line-removed">  61     SetLineDash,</span>
<span class="line-removed">  62     SetLineJoin,</span>
<span class="line-removed">  63     SetMiterLimit,</span>
<span class="line-removed">  64     ClearShadow,</span>
<span class="line-removed">  65     Clip,</span>
<span class="line-removed">  66     ClipOut,</span>
<span class="line-removed">  67     ClipOutToPath,</span>
<span class="line-removed">  68     ClipPath,</span>
<span class="line-removed">  69     DrawGlyphs,</span>
<span class="line-removed">  70     DrawImage,</span>
<span class="line-removed">  71     DrawTiledImage,</span>
<span class="line-removed">  72     DrawTiledScaledImage,</span>
<span class="line-removed">  73 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)</span>
<span class="line-removed">  74     DrawNativeImage,</span>
<span class="line-removed">  75 #endif</span>
<span class="line-removed">  76     DrawPattern,</span>
<span class="line-removed">  77     DrawRect,</span>
<span class="line-removed">  78     DrawLine,</span>
<span class="line-removed">  79     DrawLinesForText,</span>
<span class="line-removed">  80     DrawDotsForDocumentMarker,</span>
<span class="line-removed">  81     DrawEllipse,</span>
<span class="line-removed">  82     DrawPath,</span>
<span class="line-removed">  83     DrawFocusRingPath,</span>
<span class="line-removed">  84     DrawFocusRingRects,</span>
<span class="line-removed">  85     FillRect,</span>
<span class="line-removed">  86     FillRectWithColor,</span>
<span class="line-removed">  87     FillRectWithGradient,</span>
<span class="line-removed">  88     FillCompositedRect,</span>
<span class="line-removed">  89     FillRoundedRect,</span>
<span class="line-removed">  90     FillRectWithRoundedHole,</span>
<span class="line-removed">  91     FillPath,</span>
<span class="line-removed">  92     FillEllipse,</span>
<span class="line-removed">  93     StrokeRect,</span>
<span class="line-removed">  94     StrokePath,</span>
<span class="line-removed">  95     StrokeEllipse,</span>
<span class="line-removed">  96     ClearRect,</span>
<span class="line-removed">  97     BeginTransparencyLayer,</span>
<span class="line-removed">  98     EndTransparencyLayer,</span>
<span class="line-removed">  99 #if USE(CG)</span>
<span class="line-removed"> 100     ApplyStrokePattern, // FIXME: should not be a recorded item.</span>
<span class="line-removed"> 101     ApplyFillPattern, // FIXME: should not be a recorded item.</span>
<span class="line-removed"> 102 #endif</span>
<span class="line-removed"> 103     ApplyDeviceScaleFactor,</span>
<span class="line-removed"> 104 };</span>
<span class="line-removed"> 105 </span>
<span class="line-removed"> 106 class Item : public RefCounted&lt;Item&gt; {</span>
<span class="line-removed"> 107 public:</span>
<span class="line-removed"> 108     Item() = delete;</span>
<span class="line-removed"> 109 </span>
<span class="line-removed"> 110     Item(ItemType type)</span>
<span class="line-removed"> 111         : m_type(type)</span>
<span class="line-removed"> 112     {</span>
<span class="line-removed"> 113     }</span>
<span class="line-removed"> 114 </span>
<span class="line-removed"> 115     virtual ~Item() = default;</span>
<span class="line-removed"> 116 </span>
<span class="line-removed"> 117     ItemType type() const</span>
<span class="line-removed"> 118     {</span>
<span class="line-removed"> 119         return m_type;</span>
<span class="line-removed"> 120     }</span>
<span class="line-removed"> 121 </span>
<span class="line-removed"> 122     virtual void apply(GraphicsContext&amp;) const = 0;</span>
<span class="line-removed"> 123 </span>
<span class="line-removed"> 124     static constexpr bool isDisplayListItem = true;</span>
<span class="line-removed"> 125 </span>
<span class="line-removed"> 126     virtual bool isDrawingItem() const { return false; }</span>
<span class="line-removed"> 127 </span>
<span class="line-removed"> 128     // A state item is one preserved by Save/Restore.</span>
<span class="line-removed"> 129     bool isStateItem() const</span>
<span class="line-removed"> 130     {</span>
<span class="line-removed"> 131         return isStateItemType(m_type);</span>
<span class="line-removed"> 132     }</span>
<span class="line-removed"> 133 </span>
<span class="line-removed"> 134     static bool isStateItemType(ItemType itemType)</span>
<span class="line-removed"> 135     {</span>
<span class="line-removed"> 136         switch (itemType) {</span>
<span class="line-removed"> 137         case ItemType:: Translate:</span>
<span class="line-removed"> 138         case ItemType:: Rotate:</span>
<span class="line-removed"> 139         case ItemType:: Scale:</span>
<span class="line-removed"> 140         case ItemType:: ConcatenateCTM:</span>
<span class="line-removed"> 141         case ItemType:: SetState:</span>
<span class="line-removed"> 142         case ItemType:: SetLineCap:</span>
<span class="line-removed"> 143         case ItemType:: SetLineDash:</span>
<span class="line-removed"> 144         case ItemType:: SetLineJoin:</span>
<span class="line-removed"> 145         case ItemType:: SetMiterLimit:</span>
<span class="line-removed"> 146         case ItemType:: ClearShadow:</span>
<span class="line-removed"> 147             return true;</span>
<span class="line-removed"> 148         default:</span>
<span class="line-removed"> 149             return false;</span>
<span class="line-removed"> 150         }</span>
<span class="line-removed"> 151         return false;</span>
<span class="line-removed"> 152     }</span>
<span class="line-removed"> 153 </span>
<span class="line-removed"> 154 #if !defined(NDEBUG) || !LOG_DISABLED</span>
<span class="line-removed"> 155     WTF::CString description() const;</span>
<span class="line-removed"> 156 #endif</span>
<span class="line-removed"> 157     static size_t sizeInBytes(const Item&amp;);</span>
<span class="line-removed"> 158 </span>
<span class="line-removed"> 159 private:</span>
<span class="line-removed"> 160     ItemType m_type;</span>
<span class="line-removed"> 161 };</span>
<span class="line-removed"> 162 </span>
 163 class DrawingItem : public Item {
 164 public:
<span class="line-modified"> 165     explicit DrawingItem(ItemType type)</span>
<span class="line-modified"> 166         : Item(type)</span>
<span class="line-modified"> 167     {</span>
<span class="line-removed"> 168     }</span>
 169 
 170     void setExtent(const FloatRect&amp; r) { m_extent = r; }
 171     const FloatRect&amp; extent() const { return m_extent.value(); }
 172 
 173     bool extentKnown() const { return static_cast&lt;bool&gt;(m_extent); }
 174 
 175     // Return bounds of this drawing operation in local coordinates.
 176     // Does not include effets of transform, shadow etc in the state.
 177     virtual Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const { return WTF::nullopt; }
 178 
 179 private:
 180     bool isDrawingItem() const override { return true; }
 181 
 182     Optional&lt;FloatRect&gt; m_extent; // In base coordinates, taking shadows and transforms into account.
 183 };
 184 
 185 class Save : public Item {
 186 public:
 187     static Ref&lt;Save&gt; create()
 188     {
 189         return adoptRef(*new Save);
 190     }
 191 


 192     // Index in the display list of the corresponding Restore item. 0 if unmatched.
 193     size_t restoreIndex() const { return m_restoreIndex; }
 194     void setRestoreIndex(size_t index) { m_restoreIndex = index; }
 195 



 196 private:
<span class="line-modified"> 197     Save()</span>
<span class="line-removed"> 198         : Item(ItemType::Save)</span>
<span class="line-removed"> 199     {</span>
<span class="line-removed"> 200     }</span>
 201 
 202     void apply(GraphicsContext&amp;) const override;
 203 
 204     size_t m_restoreIndex { 0 };
 205 };
 206 




















 207 class Restore : public Item {
 208 public:
 209     static Ref&lt;Restore&gt; create()
 210     {
 211         return adoptRef(*new Restore);
 212     }
 213 





 214 private:
<span class="line-modified"> 215     Restore()</span>
<span class="line-removed"> 216         : Item(ItemType::Restore)</span>
<span class="line-removed"> 217     {</span>
<span class="line-removed"> 218     }</span>
 219 
 220     void apply(GraphicsContext&amp;) const override;
 221 };
 222 











 223 class Translate : public Item {
 224 public:
 225     static Ref&lt;Translate&gt; create(float x, float y)
 226     {
 227         return adoptRef(*new Translate(x, y));
 228     }
 229 


 230     float x() const { return m_x; }
 231     float y() const { return m_y; }
 232 



 233 private:
<span class="line-modified"> 234     Translate(float x, float y)</span>
<span class="line-removed"> 235         : Item(ItemType::Translate)</span>
<span class="line-removed"> 236         , m_x(x)</span>
<span class="line-removed"> 237         , m_y(y)</span>
<span class="line-removed"> 238     {</span>
<span class="line-removed"> 239     }</span>
 240 
 241     void apply(GraphicsContext&amp;) const override;
 242 
 243     float m_x;
 244     float m_y;
 245 };
 246 























 247 class Rotate : public Item {
 248 public:
 249     static Ref&lt;Rotate&gt; create(float angleInRadians)
 250     {
 251         return adoptRef(*new Rotate(angleInRadians));
 252     }
 253 


 254     float angle() const { return m_angle; }
 255 



 256 private:
<span class="line-modified"> 257     Rotate(float angle)</span>
<span class="line-removed"> 258         : Item(ItemType::Rotate)</span>
<span class="line-removed"> 259         , m_angle(angle)</span>
<span class="line-removed"> 260     {</span>
<span class="line-removed"> 261     }</span>
 262 
 263     void apply(GraphicsContext&amp;) const override;
 264 
 265     float m_angle; // In radians.
 266 };
 267 

















 268 class Scale : public Item {
 269 public:
 270     static Ref&lt;Scale&gt; create(const FloatSize&amp; size)
 271     {
 272         return adoptRef(*new Scale(size));
 273     }
 274 


 275     const FloatSize&amp; amount() const { return m_size; }
 276 



 277 private:
<span class="line-modified"> 278     Scale(const FloatSize&amp; size)</span>
<span class="line-modified"> 279         : Item(ItemType::Scale)</span>
<span class="line-modified"> 280         , m_size(size)</span>
























 281     {

 282     }
 283 










 284     void apply(GraphicsContext&amp;) const override;
 285 
<span class="line-modified"> 286     FloatSize m_size;</span>
 287 };
 288 

















 289 class ConcatenateCTM : public Item {
 290 public:
 291     static Ref&lt;ConcatenateCTM&gt; create(const AffineTransform&amp; matrix)
 292     {
 293         return adoptRef(*new ConcatenateCTM(matrix));
 294     }
 295 


 296     const AffineTransform&amp; transform() const { return m_transform; }
 297 



 298 private:
<span class="line-modified"> 299     ConcatenateCTM(const AffineTransform&amp;);</span>
 300 
 301     void apply(GraphicsContext&amp;) const override;
 302 
 303     AffineTransform m_transform;
 304 };
 305 

















 306 class SetState : public Item {
 307 public:
 308     static Ref&lt;SetState&gt; create(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 309     {
 310         return adoptRef(*new SetState(state, flags));
 311     }
 312 







 313     const GraphicsContextStateChange&amp; state() const { return m_state; }
 314 
 315     void accumulate(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
 316 
 317     void accumulate(GraphicsContextState&amp;) const;
 318 
<span class="line-modified"> 319     static void applyState(GraphicsContext&amp;, const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);</span>
 320 
 321     static void dumpStateChanges(WTF::TextStream&amp;, const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);




 322 private:
<span class="line-modified"> 323     SetState(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)</span>
<span class="line-modified"> 324         : Item(ItemType::SetState)</span>
<span class="line-removed"> 325         , m_state(state, flags)</span>
<span class="line-removed"> 326     {</span>
<span class="line-removed"> 327     }</span>
 328 
 329     void apply(GraphicsContext&amp;) const override;
 330 
 331     GraphicsContextStateChange m_state;
 332 };
 333 


























































































































































































































































































































 334 class SetLineCap : public Item {
 335 public:
 336     static Ref&lt;SetLineCap&gt; create(LineCap lineCap)
 337     {
 338         return adoptRef(*new SetLineCap(lineCap));
 339     }
 340 


 341     LineCap lineCap() const { return m_lineCap; }
 342 



 343 private:
<span class="line-modified"> 344     SetLineCap(LineCap lineCap)</span>
<span class="line-removed"> 345         : Item(ItemType::SetLineCap)</span>
<span class="line-removed"> 346         , m_lineCap(lineCap)</span>
<span class="line-removed"> 347     {</span>
<span class="line-removed"> 348     }</span>
 349 
 350     void apply(GraphicsContext&amp;) const override;
 351 
 352     LineCap m_lineCap;
 353 };
 354 

















 355 class SetLineDash : public Item {
 356 public:
 357     static Ref&lt;SetLineDash&gt; create(const DashArray&amp; dashArray, float dashOffset)
 358     {
 359         return adoptRef(*new SetLineDash(dashArray, dashOffset));
 360     }
 361 


 362     const DashArray&amp; dashArray() const { return m_dashArray; }
 363     float dashOffset() const { return m_dashOffset; }
 364 



 365 private:
<span class="line-modified"> 366     SetLineDash(const DashArray&amp; dashArray, float dashOffset)</span>
<span class="line-removed"> 367         : Item(ItemType::SetLineDash)</span>
<span class="line-removed"> 368         , m_dashArray(dashArray)</span>
<span class="line-removed"> 369         , m_dashOffset(dashOffset)</span>
<span class="line-removed"> 370     {</span>
<span class="line-removed"> 371     }</span>
 372 
 373     void apply(GraphicsContext&amp;) const override;
 374 
 375     DashArray m_dashArray;
 376     float m_dashOffset;
 377 };
 378 























 379 class SetLineJoin : public Item {
 380 public:
 381     static Ref&lt;SetLineJoin&gt; create(LineJoin lineJoin)
 382     {
 383         return adoptRef(*new SetLineJoin(lineJoin));
 384     }
 385 


 386     LineJoin lineJoin() const { return m_lineJoin; }
 387 



 388 private:
<span class="line-modified"> 389     SetLineJoin(LineJoin lineJoin)</span>
<span class="line-removed"> 390         : Item(ItemType::SetLineJoin)</span>
<span class="line-removed"> 391         , m_lineJoin(lineJoin)</span>
<span class="line-removed"> 392     {</span>
<span class="line-removed"> 393     }</span>
 394 
 395     void apply(GraphicsContext&amp;) const override;
 396 
 397     LineJoin m_lineJoin;
 398 };
 399 

















 400 class SetMiterLimit : public Item {
 401 public:
 402     static Ref&lt;SetMiterLimit&gt; create(float limit)
 403     {
 404         return adoptRef(*new SetMiterLimit(limit));
 405     }
 406 


 407     float miterLimit() const { return m_miterLimit; }
 408 



 409 private:
<span class="line-modified"> 410     SetMiterLimit(float miterLimit)</span>
<span class="line-removed"> 411         : Item(ItemType::SetMiterLimit)</span>
<span class="line-removed"> 412         , m_miterLimit(miterLimit)</span>
<span class="line-removed"> 413     {</span>
<span class="line-removed"> 414     }</span>
 415 
 416     void apply(GraphicsContext&amp;) const override;
 417 
 418     float m_miterLimit;
 419 };
 420 

















 421 class ClearShadow : public Item {
 422 public:
 423     static Ref&lt;ClearShadow&gt; create()
 424     {
 425         return adoptRef(*new ClearShadow);
 426     }
 427 





 428 private:
<span class="line-modified"> 429     ClearShadow()</span>
<span class="line-removed"> 430         : Item(ItemType::ClearShadow)</span>
<span class="line-removed"> 431     {</span>
<span class="line-removed"> 432     }</span>
 433 
 434     void apply(GraphicsContext&amp;) const override;
 435 };
 436 











 437 // FIXME: treat as DrawingItem?
 438 class Clip : public Item {
 439 public:
 440     static Ref&lt;Clip&gt; create(const FloatRect&amp; rect)
 441     {
 442         return adoptRef(*new Clip(rect));
 443     }
 444 


 445     FloatRect rect() const { return m_rect; }
 446 



 447 private:
<span class="line-modified"> 448     Clip(const FloatRect&amp; rect)</span>
<span class="line-removed"> 449         : Item(ItemType::Clip)</span>
<span class="line-removed"> 450         , m_rect(rect)</span>
<span class="line-removed"> 451     {</span>
<span class="line-removed"> 452     }</span>
 453 
 454     void apply(GraphicsContext&amp;) const override;
 455 
 456     FloatRect m_rect;
 457 };
 458 

















 459 class ClipOut : public Item {
 460 public:
 461     static Ref&lt;ClipOut&gt; create(const FloatRect&amp; rect)
 462     {
 463         return adoptRef(*new ClipOut(rect));
 464     }
 465 


 466     FloatRect rect() const { return m_rect; }
 467 



 468 private:
<span class="line-modified"> 469     ClipOut(const FloatRect&amp; rect)</span>
<span class="line-removed"> 470         : Item(ItemType::ClipOut)</span>
<span class="line-removed"> 471         , m_rect(rect)</span>
<span class="line-removed"> 472     {</span>
<span class="line-removed"> 473     }</span>
 474 
 475     void apply(GraphicsContext&amp;) const override;
 476 
 477     FloatRect m_rect;
 478 };
 479 

















 480 class ClipOutToPath : public Item {
 481 public:
 482     static Ref&lt;ClipOutToPath&gt; create(const Path&amp; path)
 483     {
 484         return adoptRef(*new ClipOutToPath(path));
 485     }
 486 


 487     const Path&amp; path() const { return m_path; }
 488 



 489 private:
<span class="line-modified"> 490     ClipOutToPath(const Path&amp; path)</span>
<span class="line-removed"> 491         : Item(ItemType::ClipOutToPath)</span>
<span class="line-removed"> 492         , m_path(path)</span>
<span class="line-removed"> 493     {</span>
<span class="line-removed"> 494     }</span>
 495 
 496     void apply(GraphicsContext&amp;) const override;
 497 
 498     const Path m_path;
 499 };
 500 

















 501 class ClipPath : public Item {
 502 public:
 503     static Ref&lt;ClipPath&gt; create(const Path&amp; path, WindRule windRule)
 504     {
 505         return adoptRef(*new ClipPath(path, windRule));
 506     }
 507 


 508     const Path&amp; path() const { return m_path; }
 509     WindRule windRule() const { return m_windRule; }
 510 



 511 private:
<span class="line-modified"> 512     ClipPath(const Path&amp; path, WindRule windRule)</span>
<span class="line-removed"> 513         : Item(ItemType::ClipPath)</span>
<span class="line-removed"> 514         , m_path(path)</span>
<span class="line-removed"> 515         , m_windRule(windRule)</span>
<span class="line-removed"> 516     {</span>
<span class="line-removed"> 517     }</span>
 518 
 519     void apply(GraphicsContext&amp;) const override;
 520 
 521     const Path m_path;
 522     WindRule m_windRule;
 523 };
 524 























 525 class DrawGlyphs : public DrawingItem {
 526 public:
 527     static Ref&lt;DrawGlyphs&gt; create(const Font&amp; font, const GlyphBufferGlyph* glyphs, const GlyphBufferAdvance* advances, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
 528     {
 529         return adoptRef(*new DrawGlyphs(font, glyphs, advances, count, blockLocation, localAnchor, smoothingMode));
 530     }
 531 







 532     const FloatPoint&amp; blockLocation() const { return m_blockLocation; }
 533     void setBlockLocation(const FloatPoint&amp; blockLocation) { m_blockLocation = blockLocation; }
 534 
 535     const FloatSize&amp; localAnchor() const { return m_localAnchor; }
 536 
 537     FloatPoint anchorPoint() const { return m_blockLocation + m_localAnchor; }
 538 
 539     const Vector&lt;GlyphBufferGlyph, 128&gt;&amp; glyphs() const { return m_glyphs; }
 540 



 541 private:
 542     DrawGlyphs(const Font&amp;, const GlyphBufferGlyph*, const GlyphBufferAdvance*, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode);

 543 
 544     void computeBounds();
 545 
 546     void apply(GraphicsContext&amp;) const override;
 547 
 548     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
 549 
 550     GlyphBuffer generateGlyphBuffer() const;
 551 
 552     Ref&lt;Font&gt; m_font;
 553     Vector&lt;GlyphBufferGlyph, 128&gt; m_glyphs;
 554     Vector&lt;GlyphBufferAdvance, 128&gt; m_advances;
 555     FloatRect m_bounds;
 556     FloatPoint m_blockLocation;
 557     FloatSize m_localAnchor;
 558     FontSmoothingMode m_smoothingMode;
 559 };
 560 




















































 561 class DrawImage : public DrawingItem {
 562 public:
 563     static Ref&lt;DrawImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)
 564     {
 565         return adoptRef(*new DrawImage(image, destination, source, imagePaintingOptions));
 566     }
 567 


 568     const Image&amp; image() const { return m_image.get(); }
 569     FloatRect source() const { return m_source; }
 570     FloatRect destination() const { return m_destination; }
 571 



 572 private:
<span class="line-modified"> 573     DrawImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp;);</span>
 574 
 575     void apply(GraphicsContext&amp;) const override;
 576 
 577     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
 578 
 579     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
 580     FloatRect m_destination;
 581     FloatRect m_source;
 582     ImagePaintingOptions m_imagePaintingOptions;
 583 };
 584 






































 585 class DrawTiledImage : public DrawingItem {
 586 public:
 587     static Ref&lt;DrawTiledImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)
 588     {
 589         return adoptRef(*new DrawTiledImage(image, destination, source, tileSize, spacing, imagePaintingOptions));
 590     }
 591 


 592     const Image&amp; image() const { return m_image.get(); }
 593     FloatPoint source() const { return m_source; }
 594     FloatRect destination() const { return m_destination; }
 595 
 596     FloatSize tileSize() const { return m_tileSize; }
 597     FloatSize spacing() const { return m_spacing; }
 598 



 599 private:
<span class="line-modified"> 600     DrawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp;);</span>
 601 
 602     void apply(GraphicsContext&amp;) const override;
 603 
 604     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
 605 
 606     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
 607     FloatRect m_destination;
 608     FloatPoint m_source;
 609     FloatSize m_tileSize;
 610     FloatSize m_spacing;
 611     ImagePaintingOptions m_imagePaintingOptions;
 612 };
 613 

















































 614 class DrawTiledScaledImage : public DrawingItem {
 615 public:
 616     static Ref&lt;DrawTiledScaledImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)
 617     {
 618         return adoptRef(*new DrawTiledScaledImage(image, destination, source, tileScaleFactor, hRule, vRule, imagePaintingOptions));
 619     }
 620 


 621     const Image&amp; image() const { return m_image.get(); }
 622     FloatRect source() const { return m_source; }
 623     FloatRect destination() const { return m_destination; }
 624 



 625 private:
<span class="line-modified"> 626     DrawTiledScaledImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp;);</span>
 627 
 628     void apply(GraphicsContext&amp;) const override;
 629 
 630     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
 631 
 632     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
 633     FloatRect m_destination;
 634     FloatRect m_source;
 635     FloatSize m_tileScaleFactor;
 636     Image::TileRule m_hRule;
 637     Image::TileRule m_vRule;
 638     ImagePaintingOptions m_imagePaintingOptions;
 639 };
 640 





















































 641 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
 642 class DrawNativeImage : public DrawingItem {
 643 public:
 644     static Ref&lt;DrawNativeImage&gt; create(const NativeImagePtr&amp; image, const FloatSize&amp; imageSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
 645     {
 646         return adoptRef(*new DrawNativeImage(image, imageSize, destRect, srcRect, options));
 647     }
 648 


 649     FloatRect source() const { return m_srcRect; }
<span class="line-modified"> 650     FloatRect destination() const { return m_destination; }</span>



 651 
 652 private:
<span class="line-modified"> 653     DrawNativeImage(const NativeImagePtr&amp;, const FloatSize&amp; selfSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp;);</span>
 654 
 655     void apply(GraphicsContext&amp;) const override;
 656 
<span class="line-modified"> 657     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }</span>
 658 
 659 #if USE(CG)
<span class="line-modified"> 660     RetainPtr&lt;CGImageRef&gt; m_image;</span>
 661 #endif
 662     FloatSize m_imageSize;
<span class="line-modified"> 663     FloatRect m_destination;</span>
 664     FloatRect m_srcRect;
 665     ImagePaintingOptions m_options;
 666 };



















































 667 #endif
 668 
 669 class DrawPattern : public DrawingItem {
 670 public:
 671     static Ref&lt;DrawPattern&gt; create(Image&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
 672     {
 673         return adoptRef(*new DrawPattern(image, destRect, tileRect, patternTransform, phase, spacing, options));
 674     }
 675 


 676     const Image&amp; image() const { return m_image.get(); }
 677     const AffineTransform&amp; patternTransform() const { return m_patternTransform; }
 678     FloatRect tileRect() const { return m_tileRect; }
 679     FloatRect destRect() const { return m_destination; }
 680     FloatPoint phase() const { return m_phase; }
 681     FloatSize spacing() const { return m_spacing; }
 682 



 683 private:
<span class="line-modified"> 684     DrawPattern(Image&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp;, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });</span>
 685 
 686     void apply(GraphicsContext&amp;) const override;
 687 
 688     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
 689 
 690     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
 691     AffineTransform m_patternTransform;
 692     FloatRect m_tileRect;
 693     FloatRect m_destination;
 694     FloatPoint m_phase;
 695     FloatSize m_spacing;
 696     ImagePaintingOptions m_options;
 697 };
 698 























































 699 // Is DrawingItem because the size of the transparency layer is implicitly the clip bounds.
 700 class BeginTransparencyLayer : public DrawingItem {
 701 public:
 702     static Ref&lt;BeginTransparencyLayer&gt; create(float opacity)
 703     {
 704         return adoptRef(*new BeginTransparencyLayer(opacity));
 705     }
 706 


 707     float opacity() const { return m_opacity; }
 708 



 709 private:
<span class="line-modified"> 710     BeginTransparencyLayer(float opacity)</span>
<span class="line-removed"> 711         : DrawingItem(ItemType::BeginTransparencyLayer)</span>
<span class="line-removed"> 712         , m_opacity(opacity)</span>
<span class="line-removed"> 713     {</span>
<span class="line-removed"> 714     }</span>
 715 
 716     void apply(GraphicsContext&amp;) const override;
 717 
 718     float m_opacity;
 719 };
 720 

















 721 class EndTransparencyLayer : public DrawingItem {
 722 public:
 723     static Ref&lt;EndTransparencyLayer&gt; create()
 724     {
 725         return adoptRef(*new EndTransparencyLayer);
 726     }
 727 





 728 private:
<span class="line-modified"> 729     EndTransparencyLayer()</span>
<span class="line-removed"> 730         : DrawingItem(ItemType::EndTransparencyLayer)</span>
<span class="line-removed"> 731     {</span>
<span class="line-removed"> 732     }</span>
 733 
 734     void apply(GraphicsContext&amp;) const override;
 735 };
 736 











 737 class DrawRect : public DrawingItem {
 738 public:
 739     static Ref&lt;DrawRect&gt; create(const FloatRect&amp; rect, float borderThickness)
 740     {
 741         return adoptRef(*new DrawRect(rect, borderThickness));
 742     }
 743 


 744     FloatRect rect() const { return m_rect; }
 745     float borderThickness() const { return m_borderThickness; }
 746 



 747 private:
<span class="line-modified"> 748     DrawRect(const FloatRect&amp; rect, float borderThickness)</span>
<span class="line-removed"> 749         : DrawingItem(ItemType::DrawRect)</span>
<span class="line-removed"> 750         , m_rect(rect)</span>
<span class="line-removed"> 751         , m_borderThickness(borderThickness)</span>
<span class="line-removed"> 752     {</span>
<span class="line-removed"> 753     }</span>
 754 
 755     void apply(GraphicsContext&amp;) const override;
 756     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
 757 
 758     FloatRect m_rect;
 759     float m_borderThickness;
 760 };
 761 























 762 class DrawLine : public DrawingItem {
 763 public:
 764     static Ref&lt;DrawLine&gt; create(const FloatPoint&amp; point1, const FloatPoint&amp; point2)
 765     {
 766         return adoptRef(*new DrawLine(point1, point2));
 767     }
 768 


 769     FloatPoint point1() const { return m_point1; }
 770     FloatPoint point2() const { return m_point2; }
 771 



 772 private:
<span class="line-modified"> 773     DrawLine(const FloatPoint&amp; point1, const FloatPoint&amp; point2)</span>
<span class="line-removed"> 774         : DrawingItem(ItemType::DrawLine)</span>
<span class="line-removed"> 775         , m_point1(point1)</span>
<span class="line-removed"> 776         , m_point2(point2)</span>
<span class="line-removed"> 777     {</span>
<span class="line-removed"> 778     }</span>
 779 
 780     void apply(GraphicsContext&amp;) const override;
 781     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
 782 
 783     FloatPoint m_point1;
 784     FloatPoint m_point2;
 785 };
 786 























 787 class DrawLinesForText : public DrawingItem {
 788 public:
 789     static Ref&lt;DrawLinesForText&gt; create(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines)
 790     {
 791         return adoptRef(*new DrawLinesForText(blockLocation, localAnchor, thickness, widths, printing, doubleLines));
 792     }
 793 


 794     void setBlockLocation(const FloatPoint&amp; blockLocation) { m_blockLocation = blockLocation; }
 795     const FloatPoint&amp; blockLocation() const { return m_blockLocation; }
 796     const FloatSize&amp; localAnchor() const { return m_localAnchor; }
 797     FloatPoint point() const { return m_blockLocation + m_localAnchor; }
 798     float thickness() const { return m_thickness; }
 799     const DashArray&amp; widths() const { return m_widths; }
 800     bool isPrinting() const { return m_printing; }
 801     bool doubleLines() const { return m_doubleLines; }
 802 



 803 private:
<span class="line-modified"> 804     DrawLinesForText(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines)</span>
<span class="line-removed"> 805         : DrawingItem(ItemType::DrawLinesForText)</span>
<span class="line-removed"> 806         , m_blockLocation(blockLocation)</span>
<span class="line-removed"> 807         , m_localAnchor(localAnchor)</span>
<span class="line-removed"> 808         , m_widths(widths)</span>
<span class="line-removed"> 809         , m_thickness(thickness)</span>
<span class="line-removed"> 810         , m_printing(printing)</span>
<span class="line-removed"> 811         , m_doubleLines(doubleLines)</span>
<span class="line-removed"> 812     {</span>
<span class="line-removed"> 813     }</span>
 814 
 815     void apply(GraphicsContext&amp;) const override;
 816 
 817     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
 818 
 819     FloatPoint m_blockLocation;
 820     FloatSize m_localAnchor;
 821     DashArray m_widths;
 822     float m_thickness;
 823     bool m_printing;
 824     bool m_doubleLines;
 825 };
 826 















































 827 class DrawDotsForDocumentMarker : public DrawingItem {
 828 public:
 829     static Ref&lt;DrawDotsForDocumentMarker&gt; create(const FloatRect&amp; rect, DocumentMarkerLineStyle style)
 830     {
 831         return adoptRef(*new DrawDotsForDocumentMarker(rect, style));
 832     }
 833 


 834     FloatRect rect() const { return m_rect; }
 835 



 836 private:
<span class="line-modified"> 837     DrawDotsForDocumentMarker(const FloatRect&amp; rect, DocumentMarkerLineStyle style)</span>
<span class="line-removed"> 838         : DrawingItem(ItemType::DrawDotsForDocumentMarker)</span>
<span class="line-removed"> 839         , m_rect(rect)</span>
<span class="line-removed"> 840         , m_style(style)</span>
<span class="line-removed"> 841     {</span>
<span class="line-removed"> 842     }</span>
 843 
 844     void apply(GraphicsContext&amp;) const override;
 845 
 846     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
 847 
 848     FloatRect m_rect;
 849     DocumentMarkerLineStyle m_style;
 850 };
 851 























 852 class DrawEllipse : public DrawingItem {
 853 public:
 854     static Ref&lt;DrawEllipse&gt; create(const FloatRect&amp; rect)
 855     {
 856         return adoptRef(*new DrawEllipse(rect));
 857     }
 858 


 859     FloatRect rect() const { return m_rect; }
 860 



 861 private:
<span class="line-modified"> 862     DrawEllipse(const FloatRect&amp; rect)</span>
<span class="line-removed"> 863         : DrawingItem(ItemType::DrawEllipse)</span>
<span class="line-removed"> 864         , m_rect(rect)</span>
<span class="line-removed"> 865     {</span>
<span class="line-removed"> 866     }</span>
 867 
 868     void apply(GraphicsContext&amp;) const override;
 869     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
 870 
 871     FloatRect m_rect;
 872 };
 873 

















 874 class DrawPath : public DrawingItem {
 875 public:
 876     static Ref&lt;DrawPath&gt; create(const Path&amp; path)
 877     {
 878         return adoptRef(*new DrawPath(path));
 879     }
 880 


 881     const Path&amp; path() const { return m_path; }
 882 



 883 private:
<span class="line-modified"> 884     DrawPath(const Path&amp; path)</span>
<span class="line-removed"> 885         : DrawingItem(ItemType::DrawPath)</span>
<span class="line-removed"> 886         , m_path(path)</span>
<span class="line-removed"> 887     {</span>
<span class="line-removed"> 888     }</span>
 889 
 890     void apply(GraphicsContext&amp;) const override;
 891 
 892     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_path.fastBoundingRect(); }
 893 
 894     const Path m_path;
 895 };
 896 

















 897 class DrawFocusRingPath : public DrawingItem {
 898 public:
 899     static Ref&lt;DrawFocusRingPath&gt; create(const Path&amp; path, float width, float offset, const Color&amp; color)
 900     {
 901         return adoptRef(*new DrawFocusRingPath(path, width, offset, color));
 902     }
 903 


 904     const Path&amp; path() const { return m_path; }
 905     float width() const { return m_width; }
 906     float offset() const { return m_offset; }
 907     const Color&amp; color() const { return m_color; }
 908 



 909 private:
<span class="line-modified"> 910     DrawFocusRingPath(const Path&amp; path, float width, float offset, const Color&amp; color)</span>
<span class="line-removed"> 911         : DrawingItem(ItemType::DrawFocusRingPath)</span>
<span class="line-removed"> 912         , m_path(path)</span>
<span class="line-removed"> 913         , m_width(width)</span>
<span class="line-removed"> 914         , m_offset(offset)</span>
<span class="line-removed"> 915         , m_color(color)</span>
<span class="line-removed"> 916     {</span>
<span class="line-removed"> 917     }</span>
 918 
 919     void apply(GraphicsContext&amp;) const override;
 920 
 921     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
 922 
 923     const Path m_path;
 924     float m_width;
 925     float m_offset;
 926     Color m_color;
 927 };
 928 



































 929 class DrawFocusRingRects : public DrawingItem {
 930 public:
 931     static Ref&lt;DrawFocusRingRects&gt; create(const Vector&lt;FloatRect&gt;&amp; rects, float width, float offset, const Color&amp; color)
 932     {
 933         return adoptRef(*new DrawFocusRingRects(rects, width, offset, color));
 934     }
 935 


 936     const Vector&lt;FloatRect&gt; rects() const { return m_rects; }
 937     float width() const { return m_width; }
 938     float offset() const { return m_offset; }
 939     const Color&amp; color() const { return m_color; }
 940 



 941 private:
<span class="line-modified"> 942     DrawFocusRingRects(const Vector&lt;FloatRect&gt;&amp; rects, float width, float offset, const Color&amp; color)</span>
<span class="line-removed"> 943         : DrawingItem(ItemType::DrawFocusRingRects)</span>
<span class="line-removed"> 944         , m_rects(rects)</span>
<span class="line-removed"> 945         , m_width(width)</span>
<span class="line-removed"> 946         , m_offset(offset)</span>
<span class="line-removed"> 947         , m_color(color)</span>
<span class="line-removed"> 948     {</span>
<span class="line-removed"> 949     }</span>
 950 
 951     void apply(GraphicsContext&amp;) const override;
 952 
 953     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
 954 
 955     Vector&lt;FloatRect&gt; m_rects;
 956     float m_width;
 957     float m_offset;
 958     Color m_color;
 959 };
 960 



































 961 class FillRect : public DrawingItem {
 962 public:
 963     static Ref&lt;FillRect&gt; create(const FloatRect&amp; rect)
 964     {
 965         return adoptRef(*new FillRect(rect));
 966     }
 967 


 968     FloatRect rect() const { return m_rect; }
 969 



 970 private:
<span class="line-modified"> 971     FillRect(const FloatRect&amp; rect)</span>
<span class="line-removed"> 972         : DrawingItem(ItemType::FillRect)</span>
<span class="line-removed"> 973         , m_rect(rect)</span>
<span class="line-removed"> 974     {</span>
<span class="line-removed"> 975     }</span>
 976 
 977     void apply(GraphicsContext&amp;) const override;
 978     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
 979 
 980     FloatRect m_rect;
 981 };
 982 

















 983 // FIXME: Make these inherit from FillRect proper.
 984 class FillRectWithColor : public DrawingItem {
 985 public:
 986     static Ref&lt;FillRectWithColor&gt; create(const FloatRect&amp; rect, const Color&amp; color)
 987     {
 988         return adoptRef(*new FillRectWithColor(rect, color));
 989     }
 990 


 991     FloatRect rect() const { return m_rect; }
 992     const Color&amp; color() const { return m_color; }
 993 



 994 private:
<span class="line-modified"> 995     FillRectWithColor(const FloatRect&amp; rect, const Color&amp; color)</span>
<span class="line-removed"> 996         : DrawingItem(ItemType::FillRectWithColor)</span>
<span class="line-removed"> 997         , m_rect(rect)</span>
<span class="line-removed"> 998         , m_color(color)</span>
<span class="line-removed"> 999     {</span>
<span class="line-removed">1000     }</span>
1001 
1002     void apply(GraphicsContext&amp;) const override;
1003     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1004 
1005     FloatRect m_rect;
1006     Color m_color;
1007 };
1008 























1009 class FillRectWithGradient : public DrawingItem {
1010 public:
1011     static Ref&lt;FillRectWithGradient&gt; create(const FloatRect&amp; rect, Gradient&amp; gradient)
1012     {
1013         return adoptRef(*new FillRectWithGradient(rect, gradient));
1014     }
1015 


1016     FloatRect rect() const { return m_rect; }
1017 



1018 private:
<span class="line-modified">1019     FillRectWithGradient(const FloatRect&amp; rect, Gradient&amp; gradient)</span>
<span class="line-removed">1020         : DrawingItem(ItemType::FillRectWithGradient)</span>
<span class="line-removed">1021         , m_rect(rect)</span>
<span class="line-removed">1022         , m_gradient(gradient)</span>
<span class="line-removed">1023     {</span>
<span class="line-removed">1024     }</span>
1025 
1026     void apply(GraphicsContext&amp;) const override;
1027     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1028 
1029     FloatRect m_rect;
1030     mutable Ref&lt;Gradient&gt; m_gradient; // FIXME: Make this not mutable
1031 };
1032 






















1033 class FillCompositedRect : public DrawingItem {
1034 public:
1035     static Ref&lt;FillCompositedRect&gt; create(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)
1036     {
1037         return adoptRef(*new FillCompositedRect(rect, color, op, blendMode));
1038     }
1039 


1040     FloatRect rect() const { return m_rect; }
1041     const Color&amp; color() const { return m_color; }
1042     CompositeOperator compositeOperator() const { return m_op; }
1043     BlendMode blendMode() const { return m_blendMode; }
1044 



1045 private:
<span class="line-modified">1046     FillCompositedRect(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)</span>
<span class="line-removed">1047         : DrawingItem(ItemType::FillCompositedRect)</span>
<span class="line-removed">1048         , m_rect(rect)</span>
<span class="line-removed">1049         , m_color(color)</span>
<span class="line-removed">1050         , m_op(op)</span>
<span class="line-removed">1051         , m_blendMode(blendMode)</span>
<span class="line-removed">1052     {</span>
<span class="line-removed">1053     }</span>
1054 
1055     void apply(GraphicsContext&amp;) const override;
1056     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1057 
1058     FloatRect m_rect;
1059     Color m_color;
1060     CompositeOperator m_op;
1061     BlendMode m_blendMode;
1062 };
1063 



































1064 class FillRoundedRect : public DrawingItem {
1065 public:
1066     static Ref&lt;FillRoundedRect&gt; create(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)
1067     {
1068         return adoptRef(*new FillRoundedRect(rect, color, blendMode));
1069     }
1070 


1071     const FloatRoundedRect&amp; roundedRect() const { return m_rect; }
1072     const Color&amp; color() const { return m_color; }
1073     BlendMode blendMode() const { return m_blendMode; }
1074 



1075 private:
<span class="line-modified">1076     FillRoundedRect(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)</span>
<span class="line-removed">1077         : DrawingItem(ItemType::FillRoundedRect)</span>
<span class="line-removed">1078         , m_rect(rect)</span>
<span class="line-removed">1079         , m_color(color)</span>
<span class="line-removed">1080         , m_blendMode(blendMode)</span>
<span class="line-removed">1081     {</span>
<span class="line-removed">1082     }</span>
1083 
1084     void apply(GraphicsContext&amp;) const override;
1085     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect.rect(); }
1086 
1087     FloatRoundedRect m_rect;
1088     Color m_color;
1089     BlendMode m_blendMode;
1090 };
1091 





























1092 class FillRectWithRoundedHole : public DrawingItem {
1093 public:
1094     static Ref&lt;FillRectWithRoundedHole&gt; create(const FloatRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
1095     {
1096         return adoptRef(*new FillRectWithRoundedHole(rect, roundedHoleRect, color));
1097     }
1098 


1099     const FloatRect&amp; rect() const { return m_rect; }
1100     const FloatRoundedRect&amp; roundedHoleRect() const { return m_roundedHoleRect; }
1101     const Color&amp; color() const { return m_color; }
1102 



1103 private:
<span class="line-modified">1104     FillRectWithRoundedHole(const FloatRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)</span>
<span class="line-removed">1105         : DrawingItem(ItemType::FillRectWithRoundedHole)</span>
<span class="line-removed">1106         , m_rect(rect)</span>
<span class="line-removed">1107         , m_roundedHoleRect(roundedHoleRect)</span>
<span class="line-removed">1108         , m_color(color)</span>
<span class="line-removed">1109     {</span>
<span class="line-removed">1110     }</span>
1111 
1112     void apply(GraphicsContext&amp;) const override;
1113     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1114 
1115     FloatRect m_rect;
1116     FloatRoundedRect m_roundedHoleRect;
1117     Color m_color;
1118 };
1119 





























1120 class FillPath : public DrawingItem {
1121 public:
1122     static Ref&lt;FillPath&gt; create(const Path&amp; path)
1123     {
1124         return adoptRef(*new FillPath(path));
1125     }
1126 


1127     const Path&amp; path() const { return m_path; }
1128 



1129 private:
<span class="line-modified">1130     FillPath(const Path&amp; path)</span>
<span class="line-removed">1131         : DrawingItem(ItemType::FillPath)</span>
<span class="line-removed">1132         , m_path(path)</span>
<span class="line-removed">1133     {</span>
<span class="line-removed">1134     }</span>
1135 
1136     void apply(GraphicsContext&amp;) const override;
1137     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_path.fastBoundingRect(); }
1138 
1139     const Path m_path;
1140 };
1141 

















1142 class FillEllipse : public DrawingItem {
1143 public:
1144     static Ref&lt;FillEllipse&gt; create(const FloatRect&amp; rect)
1145     {
1146         return adoptRef(*new FillEllipse(rect));
1147     }
1148 


1149     FloatRect rect() const { return m_rect; }
1150 



1151 private:
<span class="line-modified">1152     FillEllipse(const FloatRect&amp; rect)</span>
<span class="line-removed">1153         : DrawingItem(ItemType::FillEllipse)</span>
<span class="line-removed">1154         , m_rect(rect)</span>
<span class="line-removed">1155     {</span>
<span class="line-removed">1156     }</span>
1157 
1158     void apply(GraphicsContext&amp;) const override;
1159 
1160     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1161 
1162     FloatRect m_rect;
1163 };
1164 

















1165 class StrokeRect : public DrawingItem {
1166 public:
1167     static Ref&lt;StrokeRect&gt; create(const FloatRect&amp; rect, float lineWidth)
1168     {
1169         return adoptRef(*new StrokeRect(rect, lineWidth));
1170     }
1171 


1172     FloatRect rect() const { return m_rect; }
1173     float lineWidth() const { return m_lineWidth; }
1174 



1175 private:
<span class="line-modified">1176     StrokeRect(const FloatRect&amp; rect, float lineWidth)</span>
<span class="line-removed">1177         : DrawingItem(ItemType::StrokeRect)</span>
<span class="line-removed">1178         , m_rect(rect)</span>
<span class="line-removed">1179         , m_lineWidth(lineWidth)</span>
<span class="line-removed">1180     {</span>
<span class="line-removed">1181     }</span>
1182 
1183     void apply(GraphicsContext&amp;) const override;
1184     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1185 
1186     FloatRect m_rect;
1187     float m_lineWidth;
1188 };
1189 























1190 class StrokePath : public DrawingItem {
1191 public:
1192     static Ref&lt;StrokePath&gt; create(const Path&amp; path)
1193     {
1194         return adoptRef(*new StrokePath(path));
1195     }
1196 


1197     const Path&amp; path() const { return m_path; }
1198 



1199 private:
<span class="line-modified">1200     StrokePath(const Path&amp; path)</span>
<span class="line-removed">1201         : DrawingItem(ItemType::StrokePath)</span>
<span class="line-removed">1202         , m_path(path)</span>
<span class="line-removed">1203     {</span>
<span class="line-removed">1204     }</span>
1205 
1206     void apply(GraphicsContext&amp;) const override;
1207     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1208 
1209     const Path m_path;
<span class="line-removed">1210     FloatPoint m_blockLocation;</span>
1211 };
1212 

















1213 class StrokeEllipse : public DrawingItem {
1214 public:
1215     static Ref&lt;StrokeEllipse&gt; create(const FloatRect&amp; rect)
1216     {
1217         return adoptRef(*new StrokeEllipse(rect));
1218     }
1219 


1220     FloatRect rect() const { return m_rect; }
1221 



1222 private:
<span class="line-modified">1223     StrokeEllipse(const FloatRect&amp; rect)</span>
<span class="line-removed">1224         : DrawingItem(ItemType::StrokeEllipse)</span>
<span class="line-removed">1225         , m_rect(rect)</span>
<span class="line-removed">1226     {</span>
<span class="line-removed">1227     }</span>
1228 
1229     void apply(GraphicsContext&amp;) const override;
1230     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1231 
1232     FloatRect m_rect;
1233 };
1234 

















1235 class ClearRect : public DrawingItem {
1236 public:
1237     static Ref&lt;ClearRect&gt; create(const FloatRect&amp; rect)
1238     {
1239         return adoptRef(*new ClearRect(rect));
1240     }
1241 


1242     FloatRect rect() const { return m_rect; }
1243 



1244 private:
<span class="line-modified">1245     ClearRect(const FloatRect&amp; rect)</span>
<span class="line-removed">1246         : DrawingItem(ItemType::ClearRect)</span>
<span class="line-removed">1247         , m_rect(rect)</span>
<span class="line-removed">1248     {</span>
<span class="line-removed">1249     }</span>
1250 
1251     void apply(GraphicsContext&amp;) const override;
1252     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1253 
1254     FloatRect m_rect;
1255 };
1256 

















1257 #if USE(CG)
1258 class ApplyStrokePattern : public Item {
1259 public:
1260     static Ref&lt;ApplyStrokePattern&gt; create()
1261     {
1262         return adoptRef(*new ApplyStrokePattern);
1263     }
1264 





1265 private:
<span class="line-modified">1266     ApplyStrokePattern()</span>
<span class="line-removed">1267         : Item(ItemType::ApplyStrokePattern)</span>
<span class="line-removed">1268     {</span>
<span class="line-removed">1269     }</span>
1270 
1271     void apply(GraphicsContext&amp;) const override;
1272 };
1273 











1274 class ApplyFillPattern : public Item {
1275 public:
1276     static Ref&lt;ApplyFillPattern&gt; create()
1277     {
1278         return adoptRef(*new ApplyFillPattern);
1279     }
1280 





1281 private:
<span class="line-modified">1282     ApplyFillPattern()</span>
<span class="line-removed">1283         : Item(ItemType::ApplyFillPattern)</span>
<span class="line-removed">1284     {</span>
<span class="line-removed">1285     }</span>
1286 
1287     void apply(GraphicsContext&amp;) const override;
1288 };











1289 #endif
1290 
1291 class ApplyDeviceScaleFactor : public Item {
1292 public:
1293     static Ref&lt;ApplyDeviceScaleFactor&gt; create(float scaleFactor)
1294     {
1295         return adoptRef(*new ApplyDeviceScaleFactor(scaleFactor));
1296     }
1297 


1298     float scaleFactor() const { return m_scaleFactor; }
1299 



1300 private:
<span class="line-modified">1301     ApplyDeviceScaleFactor(float scaleFactor)</span>
<span class="line-removed">1302         : Item(ItemType::ApplyDeviceScaleFactor)</span>
<span class="line-removed">1303         , m_scaleFactor(scaleFactor)</span>
<span class="line-removed">1304     {</span>
<span class="line-removed">1305     }</span>
1306 
1307     void apply(GraphicsContext&amp;) const override;
1308 
1309     float m_scaleFactor;
1310 };
1311 


















1312 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Item&amp;);
1313 















































































































































































































































































































































































1314 } // namespace DisplayList
1315 } // namespace WebCore
1316 
1317 
1318 #define SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_DRAWINGITEM(ToValueTypeName, predicate) \
1319 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::DisplayList::ToValueTypeName) \
1320     static bool isType(const WebCore::DisplayList::Item&amp; object) { return object.predicate; } \
1321 SPECIALIZE_TYPE_TRAITS_END()
1322 
1323 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_DRAWINGITEM(DrawingItem, isDrawingItem())
1324 
1325 #define SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ToValueTypeName) \
1326 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::DisplayList::ToValueTypeName) \
1327     static bool isType(const WebCore::DisplayList::Item&amp; item) { return item.type() == WebCore::DisplayList::ItemType::ToValueTypeName; } \
1328 SPECIALIZE_TYPE_TRAITS_END()
1329 
1330 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Save)
1331 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Restore)
1332 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Translate)
1333 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Rotate)
1334 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Scale)

1335 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ConcatenateCTM)
1336 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetState)
1337 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineCap)
1338 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineDash)
1339 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineJoin)
1340 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetMiterLimit)
1341 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Clip)
1342 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClipOut)
1343 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClipOutToPath)
1344 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClipPath)
1345 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawGlyphs)
1346 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawImage)
1347 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawTiledImage)
1348 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawTiledScaledImage)
1349 #if USE(CG) || USE(CAIRO)
1350 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawNativeImage)
1351 #endif
1352 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawPattern)
1353 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawRect)
1354 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawLine)
</pre>
<hr />
<pre>
1362 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRectWithColor)
1363 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRectWithGradient)
1364 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillCompositedRect)
1365 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRoundedRect)
1366 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRectWithRoundedHole)
1367 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillPath)
1368 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillEllipse)
1369 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(StrokeRect)
1370 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(StrokePath)
1371 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(StrokeEllipse)
1372 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClearRect)
1373 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(BeginTransparencyLayer)
1374 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(EndTransparencyLayer)
1375 #if USE(CG)
1376 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyStrokePattern)
1377 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyFillPattern)
1378 #endif
1379 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyDeviceScaleFactor)
1380 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClearShadow)
1381 





























































</pre>
</td>
<td>
<hr />
<pre>
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
<span class="line-added">  28 #include &quot;DisplayList.h&quot;</span>
  29 #include &quot;FloatPoint.h&quot;

  30 #include &quot;FloatRoundedRect.h&quot;
  31 #include &quot;Font.h&quot;
  32 #include &quot;GlyphBuffer.h&quot;

  33 #include &quot;Image.h&quot;
<span class="line-added">  34 #include &quot;Pattern.h&quot;</span>
  35 #include &lt;wtf/RefCounted.h&gt;
  36 #include &lt;wtf/TypeCasts.h&gt;
  37 




  38 namespace WTF {
  39 class TextStream;
  40 }
  41 
  42 namespace WebCore {
  43 
  44 struct ImagePaintingOptions;
  45 
  46 namespace DisplayList {
  47 















































































































  48 class DrawingItem : public Item {
  49 public:
<span class="line-modified">  50     WEBCORE_EXPORT explicit DrawingItem(ItemType);</span>
<span class="line-modified">  51 </span>
<span class="line-modified">  52     WEBCORE_EXPORT virtual ~DrawingItem();</span>

  53 
  54     void setExtent(const FloatRect&amp; r) { m_extent = r; }
  55     const FloatRect&amp; extent() const { return m_extent.value(); }
  56 
  57     bool extentKnown() const { return static_cast&lt;bool&gt;(m_extent); }
  58 
  59     // Return bounds of this drawing operation in local coordinates.
  60     // Does not include effets of transform, shadow etc in the state.
  61     virtual Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const { return WTF::nullopt; }
  62 
  63 private:
  64     bool isDrawingItem() const override { return true; }
  65 
  66     Optional&lt;FloatRect&gt; m_extent; // In base coordinates, taking shadows and transforms into account.
  67 };
  68 
  69 class Save : public Item {
  70 public:
  71     static Ref&lt;Save&gt; create()
  72     {
  73         return adoptRef(*new Save);
  74     }
  75 
<span class="line-added">  76     WEBCORE_EXPORT virtual ~Save();</span>
<span class="line-added">  77 </span>
  78     // Index in the display list of the corresponding Restore item. 0 if unmatched.
  79     size_t restoreIndex() const { return m_restoreIndex; }
  80     void setRestoreIndex(size_t index) { m_restoreIndex = index; }
  81 
<span class="line-added">  82     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">  83     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Save&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">  84 </span>
  85 private:
<span class="line-modified">  86     WEBCORE_EXPORT Save();</span>



  87 
  88     void apply(GraphicsContext&amp;) const override;
  89 
  90     size_t m_restoreIndex { 0 };
  91 };
  92 
<span class="line-added">  93 template&lt;class Encoder&gt;</span>
<span class="line-added">  94 void Save::encode(Encoder&amp; encoder) const</span>
<span class="line-added">  95 {</span>
<span class="line-added">  96     encoder &lt;&lt; static_cast&lt;uint64_t&gt;(m_restoreIndex);</span>
<span class="line-added">  97 }</span>
<span class="line-added">  98 </span>
<span class="line-added">  99 template&lt;class Decoder&gt;</span>
<span class="line-added"> 100 Optional&lt;Ref&lt;Save&gt;&gt; Save::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 101 {</span>
<span class="line-added"> 102     Optional&lt;uint64_t&gt; restoreIndex;</span>
<span class="line-added"> 103     decoder &gt;&gt; restoreIndex;</span>
<span class="line-added"> 104     if (!restoreIndex)</span>
<span class="line-added"> 105         return WTF::nullopt;</span>
<span class="line-added"> 106 </span>
<span class="line-added"> 107     // FIXME: Validate restoreIndex? But we don&#39;t have the list context here.</span>
<span class="line-added"> 108     auto save = Save::create();</span>
<span class="line-added"> 109     save-&gt;setRestoreIndex(static_cast&lt;size_t&gt;(*restoreIndex));</span>
<span class="line-added"> 110     return save;</span>
<span class="line-added"> 111 }</span>
<span class="line-added"> 112 </span>
 113 class Restore : public Item {
 114 public:
 115     static Ref&lt;Restore&gt; create()
 116     {
 117         return adoptRef(*new Restore);
 118     }
 119 
<span class="line-added"> 120     WEBCORE_EXPORT virtual ~Restore();</span>
<span class="line-added"> 121 </span>
<span class="line-added"> 122     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 123     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Restore&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 124 </span>
 125 private:
<span class="line-modified"> 126     WEBCORE_EXPORT Restore();</span>



 127 
 128     void apply(GraphicsContext&amp;) const override;
 129 };
 130 
<span class="line-added"> 131 template&lt;class Encoder&gt;</span>
<span class="line-added"> 132 void Restore::encode(Encoder&amp;) const</span>
<span class="line-added"> 133 {</span>
<span class="line-added"> 134 }</span>
<span class="line-added"> 135 </span>
<span class="line-added"> 136 template&lt;class Decoder&gt;</span>
<span class="line-added"> 137 Optional&lt;Ref&lt;Restore&gt;&gt; Restore::decode(Decoder&amp;)</span>
<span class="line-added"> 138 {</span>
<span class="line-added"> 139     return Restore::create();</span>
<span class="line-added"> 140 }</span>
<span class="line-added"> 141 </span>
 142 class Translate : public Item {
 143 public:
 144     static Ref&lt;Translate&gt; create(float x, float y)
 145     {
 146         return adoptRef(*new Translate(x, y));
 147     }
 148 
<span class="line-added"> 149     WEBCORE_EXPORT virtual ~Translate();</span>
<span class="line-added"> 150 </span>
 151     float x() const { return m_x; }
 152     float y() const { return m_y; }
 153 
<span class="line-added"> 154     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 155     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Translate&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 156 </span>
 157 private:
<span class="line-modified"> 158     WEBCORE_EXPORT Translate(float x, float y);</span>





 159 
 160     void apply(GraphicsContext&amp;) const override;
 161 
 162     float m_x;
 163     float m_y;
 164 };
 165 
<span class="line-added"> 166 template&lt;class Encoder&gt;</span>
<span class="line-added"> 167 void Translate::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 168 {</span>
<span class="line-added"> 169     encoder &lt;&lt; m_x;</span>
<span class="line-added"> 170     encoder &lt;&lt; m_y;</span>
<span class="line-added"> 171 }</span>
<span class="line-added"> 172 </span>
<span class="line-added"> 173 template&lt;class Decoder&gt;</span>
<span class="line-added"> 174 Optional&lt;Ref&lt;Translate&gt;&gt; Translate::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 175 {</span>
<span class="line-added"> 176     Optional&lt;float&gt; x;</span>
<span class="line-added"> 177     decoder &gt;&gt; x;</span>
<span class="line-added"> 178     if (!x)</span>
<span class="line-added"> 179         return WTF::nullopt;</span>
<span class="line-added"> 180 </span>
<span class="line-added"> 181     Optional&lt;float&gt; y;</span>
<span class="line-added"> 182     decoder &gt;&gt; y;</span>
<span class="line-added"> 183     if (!y)</span>
<span class="line-added"> 184         return WTF::nullopt;</span>
<span class="line-added"> 185 </span>
<span class="line-added"> 186     return Translate::create(*x, *y);</span>
<span class="line-added"> 187 }</span>
<span class="line-added"> 188 </span>
 189 class Rotate : public Item {
 190 public:
 191     static Ref&lt;Rotate&gt; create(float angleInRadians)
 192     {
 193         return adoptRef(*new Rotate(angleInRadians));
 194     }
 195 
<span class="line-added"> 196     WEBCORE_EXPORT virtual ~Rotate();</span>
<span class="line-added"> 197 </span>
 198     float angle() const { return m_angle; }
 199 
<span class="line-added"> 200     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 201     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Rotate&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 202 </span>
 203 private:
<span class="line-modified"> 204     WEBCORE_EXPORT Rotate(float angle);</span>




 205 
 206     void apply(GraphicsContext&amp;) const override;
 207 
 208     float m_angle; // In radians.
 209 };
 210 
<span class="line-added"> 211 template&lt;class Encoder&gt;</span>
<span class="line-added"> 212 void Rotate::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 213 {</span>
<span class="line-added"> 214     encoder &lt;&lt; m_angle;</span>
<span class="line-added"> 215 }</span>
<span class="line-added"> 216 </span>
<span class="line-added"> 217 template&lt;class Decoder&gt;</span>
<span class="line-added"> 218 Optional&lt;Ref&lt;Rotate&gt;&gt; Rotate::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 219 {</span>
<span class="line-added"> 220     Optional&lt;float&gt; angle;</span>
<span class="line-added"> 221     decoder &gt;&gt; angle;</span>
<span class="line-added"> 222     if (!angle)</span>
<span class="line-added"> 223         return WTF::nullopt;</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225     return Rotate::create(*angle);</span>
<span class="line-added"> 226 }</span>
<span class="line-added"> 227 </span>
 228 class Scale : public Item {
 229 public:
 230     static Ref&lt;Scale&gt; create(const FloatSize&amp; size)
 231     {
 232         return adoptRef(*new Scale(size));
 233     }
 234 
<span class="line-added"> 235     WEBCORE_EXPORT virtual ~Scale();</span>
<span class="line-added"> 236 </span>
 237     const FloatSize&amp; amount() const { return m_size; }
 238 
<span class="line-added"> 239     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 240     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Scale&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 241 </span>
 242 private:
<span class="line-modified"> 243     WEBCORE_EXPORT Scale(const FloatSize&amp;);</span>
<span class="line-modified"> 244 </span>
<span class="line-modified"> 245     void apply(GraphicsContext&amp;) const override;</span>
<span class="line-added"> 246 </span>
<span class="line-added"> 247     FloatSize m_size;</span>
<span class="line-added"> 248 };</span>
<span class="line-added"> 249 </span>
<span class="line-added"> 250 template&lt;class Encoder&gt;</span>
<span class="line-added"> 251 void Scale::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 252 {</span>
<span class="line-added"> 253     encoder &lt;&lt; m_size;</span>
<span class="line-added"> 254 }</span>
<span class="line-added"> 255 </span>
<span class="line-added"> 256 template&lt;class Decoder&gt;</span>
<span class="line-added"> 257 Optional&lt;Ref&lt;Scale&gt;&gt; Scale::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 258 {</span>
<span class="line-added"> 259     Optional&lt;FloatSize&gt; scale;</span>
<span class="line-added"> 260     decoder &gt;&gt; scale;</span>
<span class="line-added"> 261     if (!scale)</span>
<span class="line-added"> 262         return WTF::nullopt;</span>
<span class="line-added"> 263 </span>
<span class="line-added"> 264     return Scale::create(*scale);</span>
<span class="line-added"> 265 }</span>
<span class="line-added"> 266 </span>
<span class="line-added"> 267 class SetCTM : public Item {</span>
<span class="line-added"> 268 public:</span>
<span class="line-added"> 269     static Ref&lt;SetCTM&gt; create(const AffineTransform&amp; matrix)</span>
 270     {
<span class="line-added"> 271         return adoptRef(*new SetCTM(matrix));</span>
 272     }
 273 
<span class="line-added"> 274     WEBCORE_EXPORT virtual ~SetCTM();</span>
<span class="line-added"> 275 </span>
<span class="line-added"> 276     const AffineTransform&amp; transform() const { return m_transform; }</span>
<span class="line-added"> 277 </span>
<span class="line-added"> 278     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 279     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetCTM&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 280 </span>
<span class="line-added"> 281 private:</span>
<span class="line-added"> 282     WEBCORE_EXPORT SetCTM(const AffineTransform&amp;);</span>
<span class="line-added"> 283 </span>
 284     void apply(GraphicsContext&amp;) const override;
 285 
<span class="line-modified"> 286     AffineTransform m_transform;</span>
 287 };
 288 
<span class="line-added"> 289 template&lt;class Encoder&gt;</span>
<span class="line-added"> 290 void SetCTM::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 291 {</span>
<span class="line-added"> 292     encoder &lt;&lt; m_transform;</span>
<span class="line-added"> 293 }</span>
<span class="line-added"> 294 </span>
<span class="line-added"> 295 template&lt;class Decoder&gt;</span>
<span class="line-added"> 296 Optional&lt;Ref&lt;SetCTM&gt;&gt; SetCTM::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 297 {</span>
<span class="line-added"> 298     Optional&lt;AffineTransform&gt; transform;</span>
<span class="line-added"> 299     decoder &gt;&gt; transform;</span>
<span class="line-added"> 300     if (!transform)</span>
<span class="line-added"> 301         return WTF::nullopt;</span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303     return SetCTM::create(*transform);</span>
<span class="line-added"> 304 }</span>
<span class="line-added"> 305 </span>
 306 class ConcatenateCTM : public Item {
 307 public:
 308     static Ref&lt;ConcatenateCTM&gt; create(const AffineTransform&amp; matrix)
 309     {
 310         return adoptRef(*new ConcatenateCTM(matrix));
 311     }
 312 
<span class="line-added"> 313     WEBCORE_EXPORT virtual ~ConcatenateCTM();</span>
<span class="line-added"> 314 </span>
 315     const AffineTransform&amp; transform() const { return m_transform; }
 316 
<span class="line-added"> 317     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 318     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ConcatenateCTM&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 319 </span>
 320 private:
<span class="line-modified"> 321     WEBCORE_EXPORT ConcatenateCTM(const AffineTransform&amp;);</span>
 322 
 323     void apply(GraphicsContext&amp;) const override;
 324 
 325     AffineTransform m_transform;
 326 };
 327 
<span class="line-added"> 328 template&lt;class Encoder&gt;</span>
<span class="line-added"> 329 void ConcatenateCTM::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 330 {</span>
<span class="line-added"> 331     encoder &lt;&lt; m_transform;</span>
<span class="line-added"> 332 }</span>
<span class="line-added"> 333 </span>
<span class="line-added"> 334 template&lt;class Decoder&gt;</span>
<span class="line-added"> 335 Optional&lt;Ref&lt;ConcatenateCTM&gt;&gt; ConcatenateCTM::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 336 {</span>
<span class="line-added"> 337     Optional&lt;AffineTransform&gt; transform;</span>
<span class="line-added"> 338     decoder &gt;&gt; transform;</span>
<span class="line-added"> 339     if (!transform)</span>
<span class="line-added"> 340         return WTF::nullopt;</span>
<span class="line-added"> 341 </span>
<span class="line-added"> 342     return ConcatenateCTM::create(*transform);</span>
<span class="line-added"> 343 }</span>
<span class="line-added"> 344 </span>
 345 class SetState : public Item {
 346 public:
 347     static Ref&lt;SetState&gt; create(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 348     {
 349         return adoptRef(*new SetState(state, flags));
 350     }
 351 
<span class="line-added"> 352     static Ref&lt;SetState&gt; create(const GraphicsContextStateChange&amp; stateChange)</span>
<span class="line-added"> 353     {</span>
<span class="line-added"> 354         return adoptRef(*new SetState(stateChange));</span>
<span class="line-added"> 355     }</span>
<span class="line-added"> 356 </span>
<span class="line-added"> 357     WEBCORE_EXPORT virtual ~SetState();</span>
<span class="line-added"> 358 </span>
 359     const GraphicsContextStateChange&amp; state() const { return m_state; }
 360 
 361     void accumulate(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
 362 
 363     void accumulate(GraphicsContextState&amp;) const;
 364 
<span class="line-modified"> 365     static void builderState(GraphicsContext&amp;, const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);</span>
 366 
 367     static void dumpStateChanges(WTF::TextStream&amp;, const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
<span class="line-added"> 368 </span>
<span class="line-added"> 369     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 370     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetState&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 371 </span>
 372 private:
<span class="line-modified"> 373     WEBCORE_EXPORT SetState(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);</span>
<span class="line-modified"> 374     WEBCORE_EXPORT SetState(const GraphicsContextStateChange&amp;);</span>



 375 
 376     void apply(GraphicsContext&amp;) const override;
 377 
 378     GraphicsContextStateChange m_state;
 379 };
 380 
<span class="line-added"> 381 template&lt;class Encoder&gt;</span>
<span class="line-added"> 382 void SetState::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 383 {</span>
<span class="line-added"> 384     auto changeFlags = m_state.m_changeFlags;</span>
<span class="line-added"> 385     encoder &lt;&lt; changeFlags;</span>
<span class="line-added"> 386 </span>
<span class="line-added"> 387     auto&amp; state = m_state.m_state;</span>
<span class="line-added"> 388 </span>
<span class="line-added"> 389     if (changeFlags.contains(GraphicsContextState::StrokeGradientChange)) {</span>
<span class="line-added"> 390         encoder &lt;&lt; !!state.strokeGradient;</span>
<span class="line-added"> 391         if (state.strokeGradient)</span>
<span class="line-added"> 392             encoder &lt;&lt; *state.strokeGradient;</span>
<span class="line-added"> 393     }</span>
<span class="line-added"> 394 </span>
<span class="line-added"> 395     if (changeFlags.contains(GraphicsContextState::StrokePatternChange)) {</span>
<span class="line-added"> 396         encoder &lt;&lt; !!state.strokePattern;</span>
<span class="line-added"> 397         if (state.strokePattern)</span>
<span class="line-added"> 398             encoder &lt;&lt; *state.strokePattern;</span>
<span class="line-added"> 399     }</span>
<span class="line-added"> 400 </span>
<span class="line-added"> 401     if (changeFlags.contains(GraphicsContextState::FillGradientChange)) {</span>
<span class="line-added"> 402         encoder &lt;&lt; !!state.fillGradient;</span>
<span class="line-added"> 403         if (state.fillGradient)</span>
<span class="line-added"> 404             encoder &lt;&lt; *state.fillGradient;</span>
<span class="line-added"> 405     }</span>
<span class="line-added"> 406 </span>
<span class="line-added"> 407     if (changeFlags.contains(GraphicsContextState::FillPatternChange)) {</span>
<span class="line-added"> 408         encoder &lt;&lt; !!state.fillPattern;</span>
<span class="line-added"> 409         if (state.fillPattern)</span>
<span class="line-added"> 410             encoder &lt;&lt; *state.fillPattern;</span>
<span class="line-added"> 411     }</span>
<span class="line-added"> 412 </span>
<span class="line-added"> 413     if (changeFlags.contains(GraphicsContextState::ShadowChange)) {</span>
<span class="line-added"> 414         encoder &lt;&lt; state.shadowOffset;</span>
<span class="line-added"> 415         encoder &lt;&lt; state.shadowBlur;</span>
<span class="line-added"> 416         encoder &lt;&lt; state.shadowColor;</span>
<span class="line-added"> 417 #if USE(CG)</span>
<span class="line-added"> 418         encoder &lt;&lt; state.shadowsUseLegacyRadius;</span>
<span class="line-added"> 419 #endif // USE(CG)</span>
<span class="line-added"> 420     }</span>
<span class="line-added"> 421 </span>
<span class="line-added"> 422     if (changeFlags.contains(GraphicsContextState::StrokeThicknessChange))</span>
<span class="line-added"> 423         encoder &lt;&lt; state.strokeThickness;</span>
<span class="line-added"> 424 </span>
<span class="line-added"> 425     if (changeFlags.contains(GraphicsContextState::TextDrawingModeChange))</span>
<span class="line-added"> 426         encoder.encodeEnum(state.textDrawingMode);</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428     if (changeFlags.contains(GraphicsContextState::StrokeColorChange))</span>
<span class="line-added"> 429         encoder &lt;&lt; state.strokeColor;</span>
<span class="line-added"> 430 </span>
<span class="line-added"> 431     if (changeFlags.contains(GraphicsContextState::FillColorChange))</span>
<span class="line-added"> 432         encoder &lt;&lt; state.fillColor;</span>
<span class="line-added"> 433 </span>
<span class="line-added"> 434     if (changeFlags.contains(GraphicsContextState::StrokeStyleChange))</span>
<span class="line-added"> 435         encoder.encodeEnum(state.strokeStyle);</span>
<span class="line-added"> 436 </span>
<span class="line-added"> 437     if (changeFlags.contains(GraphicsContextState::FillRuleChange))</span>
<span class="line-added"> 438         encoder &lt;&lt; state.fillRule;</span>
<span class="line-added"> 439 </span>
<span class="line-added"> 440     if (changeFlags.contains(GraphicsContextState::CompositeOperationChange))</span>
<span class="line-added"> 441         encoder &lt;&lt; state.compositeOperator;</span>
<span class="line-added"> 442 </span>
<span class="line-added"> 443     if (changeFlags.contains(GraphicsContextState::BlendModeChange))</span>
<span class="line-added"> 444         encoder &lt;&lt; state.blendMode;</span>
<span class="line-added"> 445 </span>
<span class="line-added"> 446     if (changeFlags.contains(GraphicsContextState::ImageInterpolationQualityChange))</span>
<span class="line-added"> 447         encoder &lt;&lt; state.imageInterpolationQuality;</span>
<span class="line-added"> 448 </span>
<span class="line-added"> 449     if (changeFlags.contains(GraphicsContextState::AlphaChange))</span>
<span class="line-added"> 450         encoder &lt;&lt; state.alpha;</span>
<span class="line-added"> 451 </span>
<span class="line-added"> 452     if (changeFlags.contains(GraphicsContextState::ShouldAntialiasChange))</span>
<span class="line-added"> 453         encoder &lt;&lt; state.shouldAntialias;</span>
<span class="line-added"> 454 </span>
<span class="line-added"> 455     if (changeFlags.contains(GraphicsContextState::ShouldSmoothFontsChange))</span>
<span class="line-added"> 456         encoder &lt;&lt; state.shouldSmoothFonts;</span>
<span class="line-added"> 457 </span>
<span class="line-added"> 458     if (changeFlags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange))</span>
<span class="line-added"> 459         encoder &lt;&lt; state.shouldSubpixelQuantizeFonts;</span>
<span class="line-added"> 460 </span>
<span class="line-added"> 461     if (changeFlags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange))</span>
<span class="line-added"> 462         encoder &lt;&lt; state.shadowsIgnoreTransforms;</span>
<span class="line-added"> 463 }</span>
<span class="line-added"> 464 </span>
<span class="line-added"> 465 template&lt;class Decoder&gt;</span>
<span class="line-added"> 466 Optional&lt;Ref&lt;SetState&gt;&gt; SetState::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 467 {</span>
<span class="line-added"> 468     Optional&lt;GraphicsContextState::StateChangeFlags&gt; changeFlags;</span>
<span class="line-added"> 469     decoder &gt;&gt; changeFlags;</span>
<span class="line-added"> 470     if (!changeFlags)</span>
<span class="line-added"> 471         return WTF::nullopt;</span>
<span class="line-added"> 472 </span>
<span class="line-added"> 473     GraphicsContextStateChange stateChange;</span>
<span class="line-added"> 474     stateChange.m_changeFlags = *changeFlags;</span>
<span class="line-added"> 475 </span>
<span class="line-added"> 476     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokeGradientChange)) {</span>
<span class="line-added"> 477         Optional&lt;bool&gt; hasStrokeGradient;</span>
<span class="line-added"> 478         decoder &gt;&gt; hasStrokeGradient;</span>
<span class="line-added"> 479         if (!hasStrokeGradient.hasValue())</span>
<span class="line-added"> 480             return WTF::nullopt;</span>
<span class="line-added"> 481 </span>
<span class="line-added"> 482         if (hasStrokeGradient.value()) {</span>
<span class="line-added"> 483             auto strokeGradient = Gradient::decode(decoder);</span>
<span class="line-added"> 484             if (!strokeGradient)</span>
<span class="line-added"> 485                 return WTF::nullopt;</span>
<span class="line-added"> 486 </span>
<span class="line-added"> 487             stateChange.m_state.strokeGradient = WTFMove(*strokeGradient);</span>
<span class="line-added"> 488         }</span>
<span class="line-added"> 489     }</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokePatternChange)) {</span>
<span class="line-added"> 492         Optional&lt;bool&gt; hasStrokePattern;</span>
<span class="line-added"> 493         decoder &gt;&gt; hasStrokePattern;</span>
<span class="line-added"> 494         if (!hasStrokePattern.hasValue())</span>
<span class="line-added"> 495             return WTF::nullopt;</span>
<span class="line-added"> 496 </span>
<span class="line-added"> 497         if (hasStrokePattern.value()) {</span>
<span class="line-added"> 498             auto strokePattern = Pattern::decode(decoder);</span>
<span class="line-added"> 499             if (!strokePattern)</span>
<span class="line-added"> 500                 return WTF::nullopt;</span>
<span class="line-added"> 501 </span>
<span class="line-added"> 502             stateChange.m_state.strokePattern = WTFMove(*strokePattern);</span>
<span class="line-added"> 503         }</span>
<span class="line-added"> 504     }</span>
<span class="line-added"> 505 </span>
<span class="line-added"> 506     if (stateChange.m_changeFlags.contains(GraphicsContextState::FillGradientChange)) {</span>
<span class="line-added"> 507         Optional&lt;bool&gt; hasFillGradient;</span>
<span class="line-added"> 508         decoder &gt;&gt; hasFillGradient;</span>
<span class="line-added"> 509         if (!hasFillGradient.hasValue())</span>
<span class="line-added"> 510             return WTF::nullopt;</span>
<span class="line-added"> 511 </span>
<span class="line-added"> 512         if (hasFillGradient.value()) {</span>
<span class="line-added"> 513             auto fillGradient = Gradient::decode(decoder);</span>
<span class="line-added"> 514             if (!fillGradient)</span>
<span class="line-added"> 515                 return WTF::nullopt;</span>
<span class="line-added"> 516 </span>
<span class="line-added"> 517             stateChange.m_state.fillGradient = WTFMove(*fillGradient);</span>
<span class="line-added"> 518         }</span>
<span class="line-added"> 519     }</span>
<span class="line-added"> 520 </span>
<span class="line-added"> 521     if (stateChange.m_changeFlags.contains(GraphicsContextState::FillPatternChange)) {</span>
<span class="line-added"> 522         Optional&lt;bool&gt; hasFillPattern;</span>
<span class="line-added"> 523         decoder &gt;&gt; hasFillPattern;</span>
<span class="line-added"> 524         if (!hasFillPattern.hasValue())</span>
<span class="line-added"> 525             return WTF::nullopt;</span>
<span class="line-added"> 526 </span>
<span class="line-added"> 527         if (hasFillPattern.value()) {</span>
<span class="line-added"> 528             auto fillPattern = Pattern::decode(decoder);</span>
<span class="line-added"> 529             if (!fillPattern)</span>
<span class="line-added"> 530                 return WTF::nullopt;</span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532             stateChange.m_state.fillPattern = WTFMove(*fillPattern);</span>
<span class="line-added"> 533         }</span>
<span class="line-added"> 534     }</span>
<span class="line-added"> 535 </span>
<span class="line-added"> 536     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShadowChange)) {</span>
<span class="line-added"> 537         Optional&lt;FloatSize&gt; shadowOffset;</span>
<span class="line-added"> 538         decoder &gt;&gt; shadowOffset;</span>
<span class="line-added"> 539         if (!shadowOffset)</span>
<span class="line-added"> 540             return WTF::nullopt;</span>
<span class="line-added"> 541 </span>
<span class="line-added"> 542         stateChange.m_state.shadowOffset = *shadowOffset;</span>
<span class="line-added"> 543 </span>
<span class="line-added"> 544         Optional&lt;float&gt; shadowBlur;</span>
<span class="line-added"> 545         decoder &gt;&gt; shadowBlur;</span>
<span class="line-added"> 546         if (!shadowBlur)</span>
<span class="line-added"> 547             return WTF::nullopt;</span>
<span class="line-added"> 548 </span>
<span class="line-added"> 549         stateChange.m_state.shadowBlur = *shadowBlur;</span>
<span class="line-added"> 550 </span>
<span class="line-added"> 551         Optional&lt;Color&gt; shadowColor;</span>
<span class="line-added"> 552         decoder &gt;&gt; shadowColor;</span>
<span class="line-added"> 553         if (!shadowColor)</span>
<span class="line-added"> 554             return WTF::nullopt;</span>
<span class="line-added"> 555 </span>
<span class="line-added"> 556         stateChange.m_state.shadowColor = *shadowColor;</span>
<span class="line-added"> 557 </span>
<span class="line-added"> 558 #if USE(CG)</span>
<span class="line-added"> 559         Optional&lt;bool&gt; shadowsUseLegacyRadius;</span>
<span class="line-added"> 560         decoder &gt;&gt; shadowsUseLegacyRadius;</span>
<span class="line-added"> 561         if (!shadowsUseLegacyRadius)</span>
<span class="line-added"> 562             return WTF::nullopt;</span>
<span class="line-added"> 563 </span>
<span class="line-added"> 564         stateChange.m_state.shadowsUseLegacyRadius = *shadowsUseLegacyRadius;</span>
<span class="line-added"> 565 #endif // USE(CG)</span>
<span class="line-added"> 566     }</span>
<span class="line-added"> 567 </span>
<span class="line-added"> 568     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokeThicknessChange)) {</span>
<span class="line-added"> 569         Optional&lt;float&gt; strokeThickness;</span>
<span class="line-added"> 570         decoder &gt;&gt; strokeThickness;</span>
<span class="line-added"> 571         if (!strokeThickness)</span>
<span class="line-added"> 572             return WTF::nullopt;</span>
<span class="line-added"> 573 </span>
<span class="line-added"> 574         stateChange.m_state.strokeThickness = *strokeThickness;</span>
<span class="line-added"> 575     }</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577     if (stateChange.m_changeFlags.contains(GraphicsContextState::TextDrawingModeChange)) {</span>
<span class="line-added"> 578         TextDrawingModeFlags textDrawingMode;</span>
<span class="line-added"> 579         if (!decoder.decodeEnum(textDrawingMode))</span>
<span class="line-added"> 580             return WTF::nullopt;</span>
<span class="line-added"> 581 </span>
<span class="line-added"> 582         stateChange.m_state.textDrawingMode = textDrawingMode;</span>
<span class="line-added"> 583     }</span>
<span class="line-added"> 584 </span>
<span class="line-added"> 585     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokeColorChange)) {</span>
<span class="line-added"> 586         Optional&lt;Color&gt; strokeColor;</span>
<span class="line-added"> 587         decoder &gt;&gt; strokeColor;</span>
<span class="line-added"> 588         if (!strokeColor)</span>
<span class="line-added"> 589             return WTF::nullopt;</span>
<span class="line-added"> 590 </span>
<span class="line-added"> 591         stateChange.m_state.strokeColor = *strokeColor;</span>
<span class="line-added"> 592     }</span>
<span class="line-added"> 593 </span>
<span class="line-added"> 594     if (stateChange.m_changeFlags.contains(GraphicsContextState::FillColorChange)) {</span>
<span class="line-added"> 595         Optional&lt;Color&gt; fillColor;</span>
<span class="line-added"> 596         decoder &gt;&gt; fillColor;</span>
<span class="line-added"> 597         if (!fillColor)</span>
<span class="line-added"> 598             return WTF::nullopt;</span>
<span class="line-added"> 599 </span>
<span class="line-added"> 600         stateChange.m_state.fillColor = *fillColor;</span>
<span class="line-added"> 601     }</span>
<span class="line-added"> 602 </span>
<span class="line-added"> 603     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokeStyleChange)) {</span>
<span class="line-added"> 604         StrokeStyle strokeStyle;</span>
<span class="line-added"> 605         if (!decoder.decodeEnum(strokeStyle))</span>
<span class="line-added"> 606             return WTF::nullopt;</span>
<span class="line-added"> 607 </span>
<span class="line-added"> 608         stateChange.m_state.strokeStyle = strokeStyle;</span>
<span class="line-added"> 609     }</span>
<span class="line-added"> 610 </span>
<span class="line-added"> 611     if (stateChange.m_changeFlags.contains(GraphicsContextState::FillRuleChange)) {</span>
<span class="line-added"> 612         Optional&lt;WindRule&gt; fillRule;</span>
<span class="line-added"> 613         decoder &gt;&gt; fillRule;</span>
<span class="line-added"> 614         if (!fillRule)</span>
<span class="line-added"> 615             return WTF::nullopt;</span>
<span class="line-added"> 616 </span>
<span class="line-added"> 617         stateChange.m_state.fillRule = *fillRule;</span>
<span class="line-added"> 618     }</span>
<span class="line-added"> 619 </span>
<span class="line-added"> 620     if (stateChange.m_changeFlags.contains(GraphicsContextState::CompositeOperationChange)) {</span>
<span class="line-added"> 621         Optional&lt;CompositeOperator&gt; compositeOperator;</span>
<span class="line-added"> 622         decoder &gt;&gt; compositeOperator;</span>
<span class="line-added"> 623         if (!compositeOperator)</span>
<span class="line-added"> 624             return WTF::nullopt;</span>
<span class="line-added"> 625 </span>
<span class="line-added"> 626         stateChange.m_state.compositeOperator = *compositeOperator;</span>
<span class="line-added"> 627     }</span>
<span class="line-added"> 628 </span>
<span class="line-added"> 629     if (stateChange.m_changeFlags.contains(GraphicsContextState::BlendModeChange)) {</span>
<span class="line-added"> 630         Optional&lt;BlendMode&gt; blendMode;</span>
<span class="line-added"> 631         decoder &gt;&gt; blendMode;</span>
<span class="line-added"> 632         if (!blendMode)</span>
<span class="line-added"> 633             return WTF::nullopt;</span>
<span class="line-added"> 634 </span>
<span class="line-added"> 635         stateChange.m_state.blendMode = *blendMode;</span>
<span class="line-added"> 636     }</span>
<span class="line-added"> 637 </span>
<span class="line-added"> 638     if (stateChange.m_changeFlags.contains(GraphicsContextState::ImageInterpolationQualityChange)) {</span>
<span class="line-added"> 639         Optional&lt;InterpolationQuality&gt; imageInterpolationQuality;</span>
<span class="line-added"> 640         decoder &gt;&gt; imageInterpolationQuality;</span>
<span class="line-added"> 641         if (!imageInterpolationQuality)</span>
<span class="line-added"> 642             return WTF::nullopt;</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644         stateChange.m_state.imageInterpolationQuality = *imageInterpolationQuality;</span>
<span class="line-added"> 645     }</span>
<span class="line-added"> 646 </span>
<span class="line-added"> 647     if (stateChange.m_changeFlags.contains(GraphicsContextState::AlphaChange)) {</span>
<span class="line-added"> 648         Optional&lt;float&gt; alpha;</span>
<span class="line-added"> 649         decoder &gt;&gt; alpha;</span>
<span class="line-added"> 650         if (!alpha)</span>
<span class="line-added"> 651             return WTF::nullopt;</span>
<span class="line-added"> 652 </span>
<span class="line-added"> 653         stateChange.m_state.alpha = *alpha;</span>
<span class="line-added"> 654     }</span>
<span class="line-added"> 655 </span>
<span class="line-added"> 656     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShouldAntialiasChange)) {</span>
<span class="line-added"> 657         Optional&lt;bool&gt; shouldAntialias;</span>
<span class="line-added"> 658         decoder &gt;&gt; shouldAntialias;</span>
<span class="line-added"> 659         if (!shouldAntialias)</span>
<span class="line-added"> 660             return WTF::nullopt;</span>
<span class="line-added"> 661 </span>
<span class="line-added"> 662         stateChange.m_state.shouldAntialias = *shouldAntialias;</span>
<span class="line-added"> 663     }</span>
<span class="line-added"> 664 </span>
<span class="line-added"> 665     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShouldSmoothFontsChange)) {</span>
<span class="line-added"> 666         Optional&lt;bool&gt; shouldSmoothFonts;</span>
<span class="line-added"> 667         decoder &gt;&gt; shouldSmoothFonts;</span>
<span class="line-added"> 668         if (!shouldSmoothFonts)</span>
<span class="line-added"> 669             return WTF::nullopt;</span>
<span class="line-added"> 670 </span>
<span class="line-added"> 671         stateChange.m_state.shouldSmoothFonts = *shouldSmoothFonts;</span>
<span class="line-added"> 672     }</span>
<span class="line-added"> 673 </span>
<span class="line-added"> 674     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange)) {</span>
<span class="line-added"> 675         Optional&lt;bool&gt; shouldSubpixelQuantizeFonts;</span>
<span class="line-added"> 676         decoder &gt;&gt; shouldSubpixelQuantizeFonts;</span>
<span class="line-added"> 677         if (!shouldSubpixelQuantizeFonts)</span>
<span class="line-added"> 678             return WTF::nullopt;</span>
<span class="line-added"> 679 </span>
<span class="line-added"> 680         stateChange.m_state.shouldSubpixelQuantizeFonts = *shouldSubpixelQuantizeFonts;</span>
<span class="line-added"> 681     }</span>
<span class="line-added"> 682 </span>
<span class="line-added"> 683     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange)) {</span>
<span class="line-added"> 684         Optional&lt;bool&gt; shadowsIgnoreTransforms;</span>
<span class="line-added"> 685         decoder &gt;&gt; shadowsIgnoreTransforms;</span>
<span class="line-added"> 686         if (!shadowsIgnoreTransforms)</span>
<span class="line-added"> 687             return WTF::nullopt;</span>
<span class="line-added"> 688 </span>
<span class="line-added"> 689         stateChange.m_state.shadowsIgnoreTransforms = *shadowsIgnoreTransforms;</span>
<span class="line-added"> 690     }</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692     return SetState::create(stateChange);</span>
<span class="line-added"> 693 }</span>
<span class="line-added"> 694 </span>
 695 class SetLineCap : public Item {
 696 public:
 697     static Ref&lt;SetLineCap&gt; create(LineCap lineCap)
 698     {
 699         return adoptRef(*new SetLineCap(lineCap));
 700     }
 701 
<span class="line-added"> 702     WEBCORE_EXPORT virtual ~SetLineCap();</span>
<span class="line-added"> 703 </span>
 704     LineCap lineCap() const { return m_lineCap; }
 705 
<span class="line-added"> 706     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 707     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetLineCap&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 708 </span>
 709 private:
<span class="line-modified"> 710     WEBCORE_EXPORT SetLineCap(LineCap);</span>




 711 
 712     void apply(GraphicsContext&amp;) const override;
 713 
 714     LineCap m_lineCap;
 715 };
 716 
<span class="line-added"> 717 template&lt;class Encoder&gt;</span>
<span class="line-added"> 718 void SetLineCap::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 719 {</span>
<span class="line-added"> 720     encoder &lt;&lt; m_lineCap;</span>
<span class="line-added"> 721 }</span>
<span class="line-added"> 722 </span>
<span class="line-added"> 723 template&lt;class Decoder&gt;</span>
<span class="line-added"> 724 Optional&lt;Ref&lt;SetLineCap&gt;&gt; SetLineCap::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 725 {</span>
<span class="line-added"> 726     Optional&lt;LineCap&gt; lineCap;</span>
<span class="line-added"> 727     decoder &gt;&gt; lineCap;</span>
<span class="line-added"> 728     if (!lineCap)</span>
<span class="line-added"> 729         return WTF::nullopt;</span>
<span class="line-added"> 730 </span>
<span class="line-added"> 731     return SetLineCap::create(*lineCap);</span>
<span class="line-added"> 732 }</span>
<span class="line-added"> 733 </span>
 734 class SetLineDash : public Item {
 735 public:
 736     static Ref&lt;SetLineDash&gt; create(const DashArray&amp; dashArray, float dashOffset)
 737     {
 738         return adoptRef(*new SetLineDash(dashArray, dashOffset));
 739     }
 740 
<span class="line-added"> 741     WEBCORE_EXPORT virtual ~SetLineDash();</span>
<span class="line-added"> 742 </span>
 743     const DashArray&amp; dashArray() const { return m_dashArray; }
 744     float dashOffset() const { return m_dashOffset; }
 745 
<span class="line-added"> 746     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 747     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetLineDash&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 748 </span>
 749 private:
<span class="line-modified"> 750     WEBCORE_EXPORT SetLineDash(const DashArray&amp;, float dashOffset);</span>





 751 
 752     void apply(GraphicsContext&amp;) const override;
 753 
 754     DashArray m_dashArray;
 755     float m_dashOffset;
 756 };
 757 
<span class="line-added"> 758 template&lt;class Encoder&gt;</span>
<span class="line-added"> 759 void SetLineDash::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 760 {</span>
<span class="line-added"> 761     encoder &lt;&lt; m_dashArray;</span>
<span class="line-added"> 762     encoder &lt;&lt; m_dashOffset;</span>
<span class="line-added"> 763 }</span>
<span class="line-added"> 764 </span>
<span class="line-added"> 765 template&lt;class Decoder&gt;</span>
<span class="line-added"> 766 Optional&lt;Ref&lt;SetLineDash&gt;&gt; SetLineDash::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 767 {</span>
<span class="line-added"> 768     Optional&lt;DashArray&gt; dashArray;</span>
<span class="line-added"> 769     decoder &gt;&gt; dashArray;</span>
<span class="line-added"> 770     if (!dashArray)</span>
<span class="line-added"> 771         return WTF::nullopt;</span>
<span class="line-added"> 772 </span>
<span class="line-added"> 773     Optional&lt;float&gt; dashOffset;</span>
<span class="line-added"> 774     decoder &gt;&gt; dashOffset;</span>
<span class="line-added"> 775     if (!dashOffset)</span>
<span class="line-added"> 776         return WTF::nullopt;</span>
<span class="line-added"> 777 </span>
<span class="line-added"> 778     return SetLineDash::create(*dashArray, *dashOffset);</span>
<span class="line-added"> 779 }</span>
<span class="line-added"> 780 </span>
 781 class SetLineJoin : public Item {
 782 public:
 783     static Ref&lt;SetLineJoin&gt; create(LineJoin lineJoin)
 784     {
 785         return adoptRef(*new SetLineJoin(lineJoin));
 786     }
 787 
<span class="line-added"> 788     WEBCORE_EXPORT virtual ~SetLineJoin();</span>
<span class="line-added"> 789 </span>
 790     LineJoin lineJoin() const { return m_lineJoin; }
 791 
<span class="line-added"> 792     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 793     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetLineJoin&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 794 </span>
 795 private:
<span class="line-modified"> 796     WEBCORE_EXPORT SetLineJoin(LineJoin);</span>




 797 
 798     void apply(GraphicsContext&amp;) const override;
 799 
 800     LineJoin m_lineJoin;
 801 };
 802 
<span class="line-added"> 803 template&lt;class Encoder&gt;</span>
<span class="line-added"> 804 void SetLineJoin::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 805 {</span>
<span class="line-added"> 806     encoder &lt;&lt; m_lineJoin;</span>
<span class="line-added"> 807 }</span>
<span class="line-added"> 808 </span>
<span class="line-added"> 809 template&lt;class Decoder&gt;</span>
<span class="line-added"> 810 Optional&lt;Ref&lt;SetLineJoin&gt;&gt; SetLineJoin::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 811 {</span>
<span class="line-added"> 812     Optional&lt;LineJoin&gt; lineJoin;</span>
<span class="line-added"> 813     decoder &gt;&gt; lineJoin;</span>
<span class="line-added"> 814     if (!lineJoin)</span>
<span class="line-added"> 815         return WTF::nullopt;</span>
<span class="line-added"> 816 </span>
<span class="line-added"> 817     return SetLineJoin::create(*lineJoin);</span>
<span class="line-added"> 818 }</span>
<span class="line-added"> 819 </span>
 820 class SetMiterLimit : public Item {
 821 public:
 822     static Ref&lt;SetMiterLimit&gt; create(float limit)
 823     {
 824         return adoptRef(*new SetMiterLimit(limit));
 825     }
 826 
<span class="line-added"> 827     WEBCORE_EXPORT virtual ~SetMiterLimit();</span>
<span class="line-added"> 828 </span>
 829     float miterLimit() const { return m_miterLimit; }
 830 
<span class="line-added"> 831     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 832     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetMiterLimit&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 833 </span>
 834 private:
<span class="line-modified"> 835     WEBCORE_EXPORT SetMiterLimit(float);</span>




 836 
 837     void apply(GraphicsContext&amp;) const override;
 838 
 839     float m_miterLimit;
 840 };
 841 
<span class="line-added"> 842 template&lt;class Encoder&gt;</span>
<span class="line-added"> 843 void SetMiterLimit::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 844 {</span>
<span class="line-added"> 845     encoder &lt;&lt; m_miterLimit;</span>
<span class="line-added"> 846 }</span>
<span class="line-added"> 847 </span>
<span class="line-added"> 848 template&lt;class Decoder&gt;</span>
<span class="line-added"> 849 Optional&lt;Ref&lt;SetMiterLimit&gt;&gt; SetMiterLimit::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 850 {</span>
<span class="line-added"> 851     Optional&lt;float&gt; miterLimit;</span>
<span class="line-added"> 852     decoder &gt;&gt; miterLimit;</span>
<span class="line-added"> 853     if (!miterLimit)</span>
<span class="line-added"> 854         return WTF::nullopt;</span>
<span class="line-added"> 855 </span>
<span class="line-added"> 856     return SetMiterLimit::create(*miterLimit);</span>
<span class="line-added"> 857 }</span>
<span class="line-added"> 858 </span>
 859 class ClearShadow : public Item {
 860 public:
 861     static Ref&lt;ClearShadow&gt; create()
 862     {
 863         return adoptRef(*new ClearShadow);
 864     }
 865 
<span class="line-added"> 866     WEBCORE_EXPORT virtual ~ClearShadow();</span>
<span class="line-added"> 867 </span>
<span class="line-added"> 868     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 869     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClearShadow&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 870 </span>
 871 private:
<span class="line-modified"> 872     WEBCORE_EXPORT ClearShadow();</span>



 873 
 874     void apply(GraphicsContext&amp;) const override;
 875 };
 876 
<span class="line-added"> 877 template&lt;class Encoder&gt;</span>
<span class="line-added"> 878 void ClearShadow::encode(Encoder&amp;) const</span>
<span class="line-added"> 879 {</span>
<span class="line-added"> 880 }</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882 template&lt;class Decoder&gt;</span>
<span class="line-added"> 883 Optional&lt;Ref&lt;ClearShadow&gt;&gt; ClearShadow::decode(Decoder&amp;)</span>
<span class="line-added"> 884 {</span>
<span class="line-added"> 885     return ClearShadow::create();</span>
<span class="line-added"> 886 }</span>
<span class="line-added"> 887 </span>
 888 // FIXME: treat as DrawingItem?
 889 class Clip : public Item {
 890 public:
 891     static Ref&lt;Clip&gt; create(const FloatRect&amp; rect)
 892     {
 893         return adoptRef(*new Clip(rect));
 894     }
 895 
<span class="line-added"> 896     WEBCORE_EXPORT virtual ~Clip();</span>
<span class="line-added"> 897 </span>
 898     FloatRect rect() const { return m_rect; }
 899 
<span class="line-added"> 900     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 901     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Clip&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 902 </span>
 903 private:
<span class="line-modified"> 904     WEBCORE_EXPORT Clip(const FloatRect&amp;);</span>




 905 
 906     void apply(GraphicsContext&amp;) const override;
 907 
 908     FloatRect m_rect;
 909 };
 910 
<span class="line-added"> 911 template&lt;class Encoder&gt;</span>
<span class="line-added"> 912 void Clip::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 913 {</span>
<span class="line-added"> 914     encoder &lt;&lt; m_rect;</span>
<span class="line-added"> 915 }</span>
<span class="line-added"> 916 </span>
<span class="line-added"> 917 template&lt;class Decoder&gt;</span>
<span class="line-added"> 918 Optional&lt;Ref&lt;Clip&gt;&gt; Clip::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 919 {</span>
<span class="line-added"> 920     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added"> 921     decoder &gt;&gt; rect;</span>
<span class="line-added"> 922     if (!rect)</span>
<span class="line-added"> 923         return WTF::nullopt;</span>
<span class="line-added"> 924 </span>
<span class="line-added"> 925     return Clip::create(*rect);</span>
<span class="line-added"> 926 }</span>
<span class="line-added"> 927 </span>
 928 class ClipOut : public Item {
 929 public:
 930     static Ref&lt;ClipOut&gt; create(const FloatRect&amp; rect)
 931     {
 932         return adoptRef(*new ClipOut(rect));
 933     }
 934 
<span class="line-added"> 935     WEBCORE_EXPORT virtual ~ClipOut();</span>
<span class="line-added"> 936 </span>
 937     FloatRect rect() const { return m_rect; }
 938 
<span class="line-added"> 939     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 940     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClipOut&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 941 </span>
 942 private:
<span class="line-modified"> 943     WEBCORE_EXPORT ClipOut(const FloatRect&amp;);</span>




 944 
 945     void apply(GraphicsContext&amp;) const override;
 946 
 947     FloatRect m_rect;
 948 };
 949 
<span class="line-added"> 950 template&lt;class Encoder&gt;</span>
<span class="line-added"> 951 void ClipOut::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 952 {</span>
<span class="line-added"> 953     encoder &lt;&lt; m_rect;</span>
<span class="line-added"> 954 }</span>
<span class="line-added"> 955 </span>
<span class="line-added"> 956 template&lt;class Decoder&gt;</span>
<span class="line-added"> 957 Optional&lt;Ref&lt;ClipOut&gt;&gt; ClipOut::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 958 {</span>
<span class="line-added"> 959     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added"> 960     decoder &gt;&gt; rect;</span>
<span class="line-added"> 961     if (!rect)</span>
<span class="line-added"> 962         return WTF::nullopt;</span>
<span class="line-added"> 963 </span>
<span class="line-added"> 964     return ClipOut::create(*rect);</span>
<span class="line-added"> 965 }</span>
<span class="line-added"> 966 </span>
 967 class ClipOutToPath : public Item {
 968 public:
 969     static Ref&lt;ClipOutToPath&gt; create(const Path&amp; path)
 970     {
 971         return adoptRef(*new ClipOutToPath(path));
 972     }
 973 
<span class="line-added"> 974     WEBCORE_EXPORT virtual ~ClipOutToPath();</span>
<span class="line-added"> 975 </span>
 976     const Path&amp; path() const { return m_path; }
 977 
<span class="line-added"> 978     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 979     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClipOutToPath&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 980 </span>
 981 private:
<span class="line-modified"> 982     WEBCORE_EXPORT ClipOutToPath(const Path&amp;);</span>




 983 
 984     void apply(GraphicsContext&amp;) const override;
 985 
 986     const Path m_path;
 987 };
 988 
<span class="line-added"> 989 template&lt;class Encoder&gt;</span>
<span class="line-added"> 990 void ClipOutToPath::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 991 {</span>
<span class="line-added"> 992     encoder &lt;&lt; m_path;</span>
<span class="line-added"> 993 }</span>
<span class="line-added"> 994 </span>
<span class="line-added"> 995 template&lt;class Decoder&gt;</span>
<span class="line-added"> 996 Optional&lt;Ref&lt;ClipOutToPath&gt;&gt; ClipOutToPath::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 997 {</span>
<span class="line-added"> 998     Optional&lt;Path&gt; path;</span>
<span class="line-added"> 999     decoder &gt;&gt; path;</span>
<span class="line-added">1000     if (!path)</span>
<span class="line-added">1001         return WTF::nullopt;</span>
<span class="line-added">1002 </span>
<span class="line-added">1003     return ClipOutToPath::create(*path);</span>
<span class="line-added">1004 }</span>
<span class="line-added">1005 </span>
1006 class ClipPath : public Item {
1007 public:
1008     static Ref&lt;ClipPath&gt; create(const Path&amp; path, WindRule windRule)
1009     {
1010         return adoptRef(*new ClipPath(path, windRule));
1011     }
1012 
<span class="line-added">1013     WEBCORE_EXPORT ~ClipPath();</span>
<span class="line-added">1014 </span>
1015     const Path&amp; path() const { return m_path; }
1016     WindRule windRule() const { return m_windRule; }
1017 
<span class="line-added">1018     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1019     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClipPath&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1020 </span>
1021 private:
<span class="line-modified">1022     WEBCORE_EXPORT ClipPath(const Path&amp;, WindRule);</span>





1023 
1024     void apply(GraphicsContext&amp;) const override;
1025 
1026     const Path m_path;
1027     WindRule m_windRule;
1028 };
1029 
<span class="line-added">1030 template&lt;class Encoder&gt;</span>
<span class="line-added">1031 void ClipPath::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1032 {</span>
<span class="line-added">1033     encoder &lt;&lt; m_path;</span>
<span class="line-added">1034     encoder &lt;&lt; m_windRule;</span>
<span class="line-added">1035 }</span>
<span class="line-added">1036 </span>
<span class="line-added">1037 template&lt;class Decoder&gt;</span>
<span class="line-added">1038 Optional&lt;Ref&lt;ClipPath&gt;&gt; ClipPath::decode(Decoder&amp; decoder)</span>
<span class="line-added">1039 {</span>
<span class="line-added">1040     Optional&lt;Path&gt; path;</span>
<span class="line-added">1041     decoder &gt;&gt; path;</span>
<span class="line-added">1042     if (!path)</span>
<span class="line-added">1043         return WTF::nullopt;</span>
<span class="line-added">1044 </span>
<span class="line-added">1045     Optional&lt;WindRule&gt; windRule;</span>
<span class="line-added">1046     decoder &gt;&gt; windRule;</span>
<span class="line-added">1047     if (!windRule)</span>
<span class="line-added">1048         return WTF::nullopt;</span>
<span class="line-added">1049 </span>
<span class="line-added">1050     return ClipPath::create(*path, *windRule);</span>
<span class="line-added">1051 }</span>
<span class="line-added">1052 </span>
1053 class DrawGlyphs : public DrawingItem {
1054 public:
1055     static Ref&lt;DrawGlyphs&gt; create(const Font&amp; font, const GlyphBufferGlyph* glyphs, const GlyphBufferAdvance* advances, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
1056     {
1057         return adoptRef(*new DrawGlyphs(font, glyphs, advances, count, blockLocation, localAnchor, smoothingMode));
1058     }
1059 
<span class="line-added">1060     static Ref&lt;DrawGlyphs&gt; create(const Font&amp; font, Vector&lt;GlyphBufferGlyph, 128&gt;&amp;&amp; glyphs, Vector&lt;GlyphBufferAdvance, 128&gt;&amp;&amp; advances, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)</span>
<span class="line-added">1061     {</span>
<span class="line-added">1062         return adoptRef(*new DrawGlyphs(font, WTFMove(glyphs), WTFMove(advances), blockLocation, localAnchor, smoothingMode));</span>
<span class="line-added">1063     }</span>
<span class="line-added">1064 </span>
<span class="line-added">1065     WEBCORE_EXPORT virtual ~DrawGlyphs();</span>
<span class="line-added">1066 </span>
1067     const FloatPoint&amp; blockLocation() const { return m_blockLocation; }
1068     void setBlockLocation(const FloatPoint&amp; blockLocation) { m_blockLocation = blockLocation; }
1069 
1070     const FloatSize&amp; localAnchor() const { return m_localAnchor; }
1071 
1072     FloatPoint anchorPoint() const { return m_blockLocation + m_localAnchor; }
1073 
1074     const Vector&lt;GlyphBufferGlyph, 128&gt;&amp; glyphs() const { return m_glyphs; }
1075 
<span class="line-added">1076     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1077     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawGlyphs&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1078 </span>
1079 private:
1080     DrawGlyphs(const Font&amp;, const GlyphBufferGlyph*, const GlyphBufferAdvance*, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode);
<span class="line-added">1081     WEBCORE_EXPORT DrawGlyphs(const Font&amp;, Vector&lt;GlyphBufferGlyph, 128&gt;&amp;&amp;, Vector&lt;GlyphBufferAdvance, 128&gt;&amp;&amp;, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode);</span>
1082 
1083     void computeBounds();
1084 
1085     void apply(GraphicsContext&amp;) const override;
1086 
1087     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1088 
1089     GlyphBuffer generateGlyphBuffer() const;
1090 
1091     Ref&lt;Font&gt; m_font;
1092     Vector&lt;GlyphBufferGlyph, 128&gt; m_glyphs;
1093     Vector&lt;GlyphBufferAdvance, 128&gt; m_advances;
1094     FloatRect m_bounds;
1095     FloatPoint m_blockLocation;
1096     FloatSize m_localAnchor;
1097     FontSmoothingMode m_smoothingMode;
1098 };
1099 
<span class="line-added">1100 template&lt;class Encoder&gt;</span>
<span class="line-added">1101 void DrawGlyphs::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1102 {</span>
<span class="line-added">1103     FontHandle handle;</span>
<span class="line-added">1104     handle.font = m_font.ptr();</span>
<span class="line-added">1105     encoder &lt;&lt; handle;</span>
<span class="line-added">1106     encoder &lt;&lt; m_glyphs;</span>
<span class="line-added">1107     encoder &lt;&lt; m_advances;</span>
<span class="line-added">1108     encoder &lt;&lt; m_blockLocation;</span>
<span class="line-added">1109     encoder &lt;&lt; m_localAnchor;</span>
<span class="line-added">1110     encoder &lt;&lt; m_smoothingMode;</span>
<span class="line-added">1111 }</span>
<span class="line-added">1112 </span>
<span class="line-added">1113 template&lt;class Decoder&gt;</span>
<span class="line-added">1114 Optional&lt;Ref&lt;DrawGlyphs&gt;&gt; DrawGlyphs::decode(Decoder&amp; decoder)</span>
<span class="line-added">1115 {</span>
<span class="line-added">1116     Optional&lt;FontHandle&gt; handle;</span>
<span class="line-added">1117     decoder &gt;&gt; handle;</span>
<span class="line-added">1118     if (!handle || !handle-&gt;font)</span>
<span class="line-added">1119         return WTF::nullopt;</span>
<span class="line-added">1120 </span>
<span class="line-added">1121     Optional&lt;Vector&lt;GlyphBufferGlyph, 128&gt;&gt; glyphs;</span>
<span class="line-added">1122     decoder &gt;&gt; glyphs;</span>
<span class="line-added">1123     if (!glyphs)</span>
<span class="line-added">1124         return WTF::nullopt;</span>
<span class="line-added">1125 </span>
<span class="line-added">1126     Optional&lt;Vector&lt;GlyphBufferAdvance, 128&gt;&gt; advances;</span>
<span class="line-added">1127     decoder &gt;&gt; advances;</span>
<span class="line-added">1128     if (!advances)</span>
<span class="line-added">1129         return WTF::nullopt;</span>
<span class="line-added">1130 </span>
<span class="line-added">1131     if (glyphs-&gt;size() != advances-&gt;size())</span>
<span class="line-added">1132         return WTF::nullopt;</span>
<span class="line-added">1133 </span>
<span class="line-added">1134     Optional&lt;FloatPoint&gt; blockLocation;</span>
<span class="line-added">1135     decoder &gt;&gt; blockLocation;</span>
<span class="line-added">1136     if (!blockLocation)</span>
<span class="line-added">1137         return WTF::nullopt;</span>
<span class="line-added">1138 </span>
<span class="line-added">1139     Optional&lt;FloatSize&gt; localAnchor;</span>
<span class="line-added">1140     decoder &gt;&gt; localAnchor;</span>
<span class="line-added">1141     if (!localAnchor)</span>
<span class="line-added">1142         return WTF::nullopt;</span>
<span class="line-added">1143 </span>
<span class="line-added">1144     Optional&lt;FontSmoothingMode&gt; smoothingMode;</span>
<span class="line-added">1145     decoder &gt;&gt; smoothingMode;</span>
<span class="line-added">1146     if (!smoothingMode)</span>
<span class="line-added">1147         return WTF::nullopt;</span>
<span class="line-added">1148 </span>
<span class="line-added">1149     return DrawGlyphs::create(handle-&gt;font.releaseNonNull(), WTFMove(*glyphs), WTFMove(*advances), *blockLocation, *localAnchor, *smoothingMode);</span>
<span class="line-added">1150 }</span>
<span class="line-added">1151 </span>
1152 class DrawImage : public DrawingItem {
1153 public:
1154     static Ref&lt;DrawImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)
1155     {
1156         return adoptRef(*new DrawImage(image, destination, source, imagePaintingOptions));
1157     }
1158 
<span class="line-added">1159     WEBCORE_EXPORT virtual ~DrawImage();</span>
<span class="line-added">1160 </span>
1161     const Image&amp; image() const { return m_image.get(); }
1162     FloatRect source() const { return m_source; }
1163     FloatRect destination() const { return m_destination; }
1164 
<span class="line-added">1165     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1166     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawImage&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1167 </span>
1168 private:
<span class="line-modified">1169     WEBCORE_EXPORT DrawImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp;);</span>
1170 
1171     void apply(GraphicsContext&amp;) const override;
1172 
1173     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
1174 
1175     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
1176     FloatRect m_destination;
1177     FloatRect m_source;
1178     ImagePaintingOptions m_imagePaintingOptions;
1179 };
1180 
<span class="line-added">1181 template&lt;class Encoder&gt;</span>
<span class="line-added">1182 void DrawImage::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1183 {</span>
<span class="line-added">1184     ImageHandle imageHandle;</span>
<span class="line-added">1185     imageHandle.image = m_image.ptr();</span>
<span class="line-added">1186 </span>
<span class="line-added">1187     encoder &lt;&lt; imageHandle;</span>
<span class="line-added">1188     encoder &lt;&lt; m_destination;</span>
<span class="line-added">1189     encoder &lt;&lt; m_source;</span>
<span class="line-added">1190     encoder &lt;&lt; m_imagePaintingOptions;</span>
<span class="line-added">1191 }</span>
<span class="line-added">1192 </span>
<span class="line-added">1193 template&lt;class Decoder&gt;</span>
<span class="line-added">1194 Optional&lt;Ref&lt;DrawImage&gt;&gt; DrawImage::decode(Decoder&amp; decoder)</span>
<span class="line-added">1195 {</span>
<span class="line-added">1196     Optional&lt;ImageHandle&gt; imageHandle;</span>
<span class="line-added">1197     decoder &gt;&gt; imageHandle;</span>
<span class="line-added">1198     if (!imageHandle)</span>
<span class="line-added">1199         return WTF::nullopt;</span>
<span class="line-added">1200 </span>
<span class="line-added">1201     Optional&lt;FloatRect&gt; destination;</span>
<span class="line-added">1202     decoder &gt;&gt; destination;</span>
<span class="line-added">1203     if (!destination)</span>
<span class="line-added">1204         return WTF::nullopt;</span>
<span class="line-added">1205 </span>
<span class="line-added">1206     Optional&lt;FloatRect&gt; source;</span>
<span class="line-added">1207     decoder &gt;&gt; source;</span>
<span class="line-added">1208     if (!source)</span>
<span class="line-added">1209         return WTF::nullopt;</span>
<span class="line-added">1210 </span>
<span class="line-added">1211     Optional&lt;ImagePaintingOptions&gt; imagePaintingOptions;</span>
<span class="line-added">1212     decoder &gt;&gt; imagePaintingOptions;</span>
<span class="line-added">1213     if (!imagePaintingOptions)</span>
<span class="line-added">1214         return WTF::nullopt;</span>
<span class="line-added">1215 </span>
<span class="line-added">1216     return DrawImage::create(*imageHandle-&gt;image, *destination, *source, *imagePaintingOptions);</span>
<span class="line-added">1217 }</span>
<span class="line-added">1218 </span>
1219 class DrawTiledImage : public DrawingItem {
1220 public:
1221     static Ref&lt;DrawTiledImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)
1222     {
1223         return adoptRef(*new DrawTiledImage(image, destination, source, tileSize, spacing, imagePaintingOptions));
1224     }
1225 
<span class="line-added">1226     WEBCORE_EXPORT virtual ~DrawTiledImage();</span>
<span class="line-added">1227 </span>
1228     const Image&amp; image() const { return m_image.get(); }
1229     FloatPoint source() const { return m_source; }
1230     FloatRect destination() const { return m_destination; }
1231 
1232     FloatSize tileSize() const { return m_tileSize; }
1233     FloatSize spacing() const { return m_spacing; }
1234 
<span class="line-added">1235     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1236     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawTiledImage&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1237 </span>
1238 private:
<span class="line-modified">1239     WEBCORE_EXPORT DrawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp;);</span>
1240 
1241     void apply(GraphicsContext&amp;) const override;
1242 
1243     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
1244 
1245     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
1246     FloatRect m_destination;
1247     FloatPoint m_source;
1248     FloatSize m_tileSize;
1249     FloatSize m_spacing;
1250     ImagePaintingOptions m_imagePaintingOptions;
1251 };
1252 
<span class="line-added">1253 template&lt;class Encoder&gt;</span>
<span class="line-added">1254 void DrawTiledImage::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1255 {</span>
<span class="line-added">1256     ImageHandle imageHandle;</span>
<span class="line-added">1257     imageHandle.image = m_image.ptr();</span>
<span class="line-added">1258     encoder &lt;&lt; imageHandle;</span>
<span class="line-added">1259     encoder &lt;&lt; m_destination;</span>
<span class="line-added">1260     encoder &lt;&lt; m_source;</span>
<span class="line-added">1261     encoder &lt;&lt; m_tileSize;</span>
<span class="line-added">1262     encoder &lt;&lt; m_spacing;</span>
<span class="line-added">1263     encoder &lt;&lt; m_imagePaintingOptions;</span>
<span class="line-added">1264 }</span>
<span class="line-added">1265 </span>
<span class="line-added">1266 template&lt;class Decoder&gt;</span>
<span class="line-added">1267 Optional&lt;Ref&lt;DrawTiledImage&gt;&gt; DrawTiledImage::decode(Decoder&amp; decoder)</span>
<span class="line-added">1268 {</span>
<span class="line-added">1269     Optional&lt;ImageHandle&gt; imageHandle;</span>
<span class="line-added">1270     decoder &gt;&gt; imageHandle;</span>
<span class="line-added">1271     if (!imageHandle)</span>
<span class="line-added">1272         return WTF::nullopt;</span>
<span class="line-added">1273 </span>
<span class="line-added">1274     Optional&lt;FloatRect&gt; destination;</span>
<span class="line-added">1275     decoder &gt;&gt; destination;</span>
<span class="line-added">1276     if (!destination)</span>
<span class="line-added">1277         return WTF::nullopt;</span>
<span class="line-added">1278 </span>
<span class="line-added">1279     Optional&lt;FloatPoint&gt; source;</span>
<span class="line-added">1280     decoder &gt;&gt; source;</span>
<span class="line-added">1281     if (!source)</span>
<span class="line-added">1282         return WTF::nullopt;</span>
<span class="line-added">1283 </span>
<span class="line-added">1284     Optional&lt;FloatSize&gt; tileSize;</span>
<span class="line-added">1285     decoder &gt;&gt; tileSize;</span>
<span class="line-added">1286     if (!tileSize)</span>
<span class="line-added">1287         return WTF::nullopt;</span>
<span class="line-added">1288 </span>
<span class="line-added">1289     Optional&lt;FloatSize&gt; spacing;</span>
<span class="line-added">1290     decoder &gt;&gt; spacing;</span>
<span class="line-added">1291     if (!spacing)</span>
<span class="line-added">1292         return WTF::nullopt;</span>
<span class="line-added">1293 </span>
<span class="line-added">1294     Optional&lt;ImagePaintingOptions&gt; imagePaintingOptions;</span>
<span class="line-added">1295     decoder &gt;&gt; imagePaintingOptions;</span>
<span class="line-added">1296     if (!imagePaintingOptions)</span>
<span class="line-added">1297         return WTF::nullopt;</span>
<span class="line-added">1298 </span>
<span class="line-added">1299     return DrawTiledImage::create(*imageHandle-&gt;image, *destination, *source, *tileSize, *spacing, *imagePaintingOptions);</span>
<span class="line-added">1300 }</span>
<span class="line-added">1301 </span>
1302 class DrawTiledScaledImage : public DrawingItem {
1303 public:
1304     static Ref&lt;DrawTiledScaledImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)
1305     {
1306         return adoptRef(*new DrawTiledScaledImage(image, destination, source, tileScaleFactor, hRule, vRule, imagePaintingOptions));
1307     }
1308 
<span class="line-added">1309     WEBCORE_EXPORT virtual ~DrawTiledScaledImage();</span>
<span class="line-added">1310 </span>
1311     const Image&amp; image() const { return m_image.get(); }
1312     FloatRect source() const { return m_source; }
1313     FloatRect destination() const { return m_destination; }
1314 
<span class="line-added">1315     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1316     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawTiledScaledImage&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1317 </span>
1318 private:
<span class="line-modified">1319     WEBCORE_EXPORT DrawTiledScaledImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp;);</span>
1320 
1321     void apply(GraphicsContext&amp;) const override;
1322 
1323     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
1324 
1325     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
1326     FloatRect m_destination;
1327     FloatRect m_source;
1328     FloatSize m_tileScaleFactor;
1329     Image::TileRule m_hRule;
1330     Image::TileRule m_vRule;
1331     ImagePaintingOptions m_imagePaintingOptions;
1332 };
1333 
<span class="line-added">1334 template&lt;class Encoder&gt;</span>
<span class="line-added">1335 void DrawTiledScaledImage::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1336 {</span>
<span class="line-added">1337     ImageHandle imageHandle;</span>
<span class="line-added">1338     imageHandle.image = m_image.ptr();</span>
<span class="line-added">1339     encoder &lt;&lt; imageHandle;</span>
<span class="line-added">1340     encoder &lt;&lt; m_destination;</span>
<span class="line-added">1341     encoder &lt;&lt; m_source;</span>
<span class="line-added">1342     encoder &lt;&lt; m_tileScaleFactor;</span>
<span class="line-added">1343     encoder.encodeEnum(m_hRule);</span>
<span class="line-added">1344     encoder.encodeEnum(m_vRule);</span>
<span class="line-added">1345     encoder &lt;&lt; m_imagePaintingOptions;</span>
<span class="line-added">1346 }</span>
<span class="line-added">1347 </span>
<span class="line-added">1348 template&lt;class Decoder&gt;</span>
<span class="line-added">1349 Optional&lt;Ref&lt;DrawTiledScaledImage&gt;&gt; DrawTiledScaledImage::decode(Decoder&amp; decoder)</span>
<span class="line-added">1350 {</span>
<span class="line-added">1351     Optional&lt;ImageHandle&gt; imageHandle;</span>
<span class="line-added">1352     decoder &gt;&gt; imageHandle;</span>
<span class="line-added">1353     if (!imageHandle)</span>
<span class="line-added">1354         return WTF::nullopt;</span>
<span class="line-added">1355 </span>
<span class="line-added">1356     Optional&lt;FloatRect&gt; destination;</span>
<span class="line-added">1357     decoder &gt;&gt; destination;</span>
<span class="line-added">1358     if (!destination)</span>
<span class="line-added">1359         return WTF::nullopt;</span>
<span class="line-added">1360 </span>
<span class="line-added">1361     Optional&lt;FloatRect&gt; source;</span>
<span class="line-added">1362     decoder &gt;&gt; source;</span>
<span class="line-added">1363     if (!source)</span>
<span class="line-added">1364         return WTF::nullopt;</span>
<span class="line-added">1365 </span>
<span class="line-added">1366     Optional&lt;FloatSize&gt; tileScaleFactor;</span>
<span class="line-added">1367     decoder &gt;&gt; tileScaleFactor;</span>
<span class="line-added">1368     if (!tileScaleFactor)</span>
<span class="line-added">1369         return WTF::nullopt;</span>
<span class="line-added">1370 </span>
<span class="line-added">1371     Image::TileRule hRule;</span>
<span class="line-added">1372     if (!decoder.decodeEnum(hRule))</span>
<span class="line-added">1373         return WTF::nullopt;</span>
<span class="line-added">1374 </span>
<span class="line-added">1375     Image::TileRule vRule;</span>
<span class="line-added">1376     if (!decoder.decodeEnum(vRule))</span>
<span class="line-added">1377         return WTF::nullopt;</span>
<span class="line-added">1378 </span>
<span class="line-added">1379     Optional&lt;ImagePaintingOptions&gt; imagePaintingOptions;</span>
<span class="line-added">1380     decoder &gt;&gt; imagePaintingOptions;</span>
<span class="line-added">1381     if (!imagePaintingOptions)</span>
<span class="line-added">1382         return WTF::nullopt;</span>
<span class="line-added">1383 </span>
<span class="line-added">1384     return DrawTiledScaledImage::create(*imageHandle-&gt;image, *destination, *source, *tileScaleFactor, hRule, vRule, *imagePaintingOptions);</span>
<span class="line-added">1385 }</span>
<span class="line-added">1386 </span>
1387 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
1388 class DrawNativeImage : public DrawingItem {
1389 public:
1390     static Ref&lt;DrawNativeImage&gt; create(const NativeImagePtr&amp; image, const FloatSize&amp; imageSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
1391     {
1392         return adoptRef(*new DrawNativeImage(image, imageSize, destRect, srcRect, options));
1393     }
1394 
<span class="line-added">1395     WEBCORE_EXPORT virtual ~DrawNativeImage();</span>
<span class="line-added">1396 </span>
1397     FloatRect source() const { return m_srcRect; }
<span class="line-modified">1398     FloatRect destinationRect() const { return m_destinationRect; }</span>
<span class="line-added">1399 </span>
<span class="line-added">1400     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1401     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawNativeImage&gt;&gt; decode(Decoder&amp;);</span>
1402 
1403 private:
<span class="line-modified">1404     WEBCORE_EXPORT DrawNativeImage(const NativeImagePtr&amp;, const FloatSize&amp; selfSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp;);</span>
1405 
1406     void apply(GraphicsContext&amp;) const override;
1407 
<span class="line-modified">1408     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destinationRect; }</span>
1409 
1410 #if USE(CG)
<span class="line-modified">1411     NativeImagePtr m_image;</span>
1412 #endif
1413     FloatSize m_imageSize;
<span class="line-modified">1414     FloatRect m_destinationRect;</span>
1415     FloatRect m_srcRect;
1416     ImagePaintingOptions m_options;
1417 };
<span class="line-added">1418 </span>
<span class="line-added">1419 template&lt;class Encoder&gt;</span>
<span class="line-added">1420 void DrawNativeImage::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1421 {</span>
<span class="line-added">1422 #if USE(CG)</span>
<span class="line-added">1423     NativeImageHandle handle { m_image };</span>
<span class="line-added">1424     encoder &lt;&lt; handle;</span>
<span class="line-added">1425 #endif</span>
<span class="line-added">1426     encoder &lt;&lt; m_imageSize;</span>
<span class="line-added">1427     encoder &lt;&lt; m_destinationRect;</span>
<span class="line-added">1428     encoder &lt;&lt; m_srcRect;</span>
<span class="line-added">1429     encoder &lt;&lt; m_options;</span>
<span class="line-added">1430 }</span>
<span class="line-added">1431 </span>
<span class="line-added">1432 template&lt;class Decoder&gt;</span>
<span class="line-added">1433 Optional&lt;Ref&lt;DrawNativeImage&gt;&gt; DrawNativeImage::decode(Decoder&amp; decoder)</span>
<span class="line-added">1434 {</span>
<span class="line-added">1435 #if USE(CG)</span>
<span class="line-added">1436     Optional&lt;NativeImageHandle&gt; handle;</span>
<span class="line-added">1437     decoder &gt;&gt; handle;</span>
<span class="line-added">1438     if (!handle)</span>
<span class="line-added">1439         return WTF::nullopt;</span>
<span class="line-added">1440 #endif</span>
<span class="line-added">1441 </span>
<span class="line-added">1442     Optional&lt;FloatSize&gt; imageSize;</span>
<span class="line-added">1443     decoder &gt;&gt; imageSize;</span>
<span class="line-added">1444     if (!imageSize)</span>
<span class="line-added">1445         return WTF::nullopt;</span>
<span class="line-added">1446 </span>
<span class="line-added">1447     Optional&lt;FloatRect&gt; destinationRect;</span>
<span class="line-added">1448     decoder &gt;&gt; destinationRect;</span>
<span class="line-added">1449     if (!destinationRect)</span>
<span class="line-added">1450         return WTF::nullopt;</span>
<span class="line-added">1451 </span>
<span class="line-added">1452     Optional&lt;FloatRect&gt; srcRect;</span>
<span class="line-added">1453     decoder &gt;&gt; srcRect;</span>
<span class="line-added">1454     if (!srcRect)</span>
<span class="line-added">1455         return WTF::nullopt;</span>
<span class="line-added">1456 </span>
<span class="line-added">1457     Optional&lt;ImagePaintingOptions&gt; options;</span>
<span class="line-added">1458     decoder &gt;&gt; options;</span>
<span class="line-added">1459     if (!options)</span>
<span class="line-added">1460         return WTF::nullopt;</span>
<span class="line-added">1461 </span>
<span class="line-added">1462 #if USE(CG)</span>
<span class="line-added">1463     NativeImagePtr image = handle-&gt;image;</span>
<span class="line-added">1464 #else</span>
<span class="line-added">1465     NativeImagePtr image = nullptr;</span>
<span class="line-added">1466 #endif</span>
<span class="line-added">1467     return DrawNativeImage::create(image, *imageSize, *destinationRect, *srcRect, *options);</span>
<span class="line-added">1468 }</span>
1469 #endif
1470 
1471 class DrawPattern : public DrawingItem {
1472 public:
1473     static Ref&lt;DrawPattern&gt; create(Image&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
1474     {
1475         return adoptRef(*new DrawPattern(image, destRect, tileRect, patternTransform, phase, spacing, options));
1476     }
1477 
<span class="line-added">1478     WEBCORE_EXPORT virtual ~DrawPattern();</span>
<span class="line-added">1479 </span>
1480     const Image&amp; image() const { return m_image.get(); }
1481     const AffineTransform&amp; patternTransform() const { return m_patternTransform; }
1482     FloatRect tileRect() const { return m_tileRect; }
1483     FloatRect destRect() const { return m_destination; }
1484     FloatPoint phase() const { return m_phase; }
1485     FloatSize spacing() const { return m_spacing; }
1486 
<span class="line-added">1487     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1488     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawPattern&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1489 </span>
1490 private:
<span class="line-modified">1491     WEBCORE_EXPORT DrawPattern(Image&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp;, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });</span>
1492 
1493     void apply(GraphicsContext&amp;) const override;
1494 
1495     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
1496 
1497     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
1498     AffineTransform m_patternTransform;
1499     FloatRect m_tileRect;
1500     FloatRect m_destination;
1501     FloatPoint m_phase;
1502     FloatSize m_spacing;
1503     ImagePaintingOptions m_options;
1504 };
1505 
<span class="line-added">1506 template&lt;class Encoder&gt;</span>
<span class="line-added">1507 void DrawPattern::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1508 {</span>
<span class="line-added">1509     ImageHandle imageHandle;</span>
<span class="line-added">1510     imageHandle.image = m_image.ptr();</span>
<span class="line-added">1511     encoder &lt;&lt; imageHandle;</span>
<span class="line-added">1512     encoder &lt;&lt; m_patternTransform;</span>
<span class="line-added">1513     encoder &lt;&lt; m_tileRect;</span>
<span class="line-added">1514     encoder &lt;&lt; m_destination;</span>
<span class="line-added">1515     encoder &lt;&lt; m_phase;</span>
<span class="line-added">1516     encoder &lt;&lt; m_spacing;</span>
<span class="line-added">1517     encoder &lt;&lt; m_options;</span>
<span class="line-added">1518 }</span>
<span class="line-added">1519 </span>
<span class="line-added">1520 template&lt;class Decoder&gt;</span>
<span class="line-added">1521 Optional&lt;Ref&lt;DrawPattern&gt;&gt; DrawPattern::decode(Decoder&amp; decoder)</span>
<span class="line-added">1522 {</span>
<span class="line-added">1523     Optional&lt;ImageHandle&gt; imageHandle;</span>
<span class="line-added">1524     decoder &gt;&gt; imageHandle;</span>
<span class="line-added">1525     if (!imageHandle)</span>
<span class="line-added">1526         return WTF::nullopt;</span>
<span class="line-added">1527 </span>
<span class="line-added">1528     Optional&lt;AffineTransform&gt; patternTransform;</span>
<span class="line-added">1529     decoder &gt;&gt; patternTransform;</span>
<span class="line-added">1530     if (!patternTransform)</span>
<span class="line-added">1531         return WTF::nullopt;</span>
<span class="line-added">1532 </span>
<span class="line-added">1533     Optional&lt;FloatRect&gt; tileRect;</span>
<span class="line-added">1534     decoder &gt;&gt; tileRect;</span>
<span class="line-added">1535     if (!tileRect)</span>
<span class="line-added">1536         return WTF::nullopt;</span>
<span class="line-added">1537 </span>
<span class="line-added">1538     Optional&lt;FloatRect&gt; destination;</span>
<span class="line-added">1539     decoder &gt;&gt; destination;</span>
<span class="line-added">1540     if (!destination)</span>
<span class="line-added">1541         return WTF::nullopt;</span>
<span class="line-added">1542 </span>
<span class="line-added">1543     Optional&lt;FloatPoint&gt; phase;</span>
<span class="line-added">1544     decoder &gt;&gt; phase;</span>
<span class="line-added">1545     if (!phase)</span>
<span class="line-added">1546         return WTF::nullopt;</span>
<span class="line-added">1547 </span>
<span class="line-added">1548     Optional&lt;FloatSize&gt; spacing;</span>
<span class="line-added">1549     decoder &gt;&gt; spacing;</span>
<span class="line-added">1550     if (!spacing)</span>
<span class="line-added">1551         return WTF::nullopt;</span>
<span class="line-added">1552 </span>
<span class="line-added">1553     Optional&lt;ImagePaintingOptions&gt; options;</span>
<span class="line-added">1554     decoder &gt;&gt; options;</span>
<span class="line-added">1555     if (!options)</span>
<span class="line-added">1556         return WTF::nullopt;</span>
<span class="line-added">1557 </span>
<span class="line-added">1558     return DrawPattern::create(*imageHandle-&gt;image, *destination, *tileRect, *patternTransform, *phase, *spacing, *options);</span>
<span class="line-added">1559 }</span>
<span class="line-added">1560 </span>
1561 // Is DrawingItem because the size of the transparency layer is implicitly the clip bounds.
1562 class BeginTransparencyLayer : public DrawingItem {
1563 public:
1564     static Ref&lt;BeginTransparencyLayer&gt; create(float opacity)
1565     {
1566         return adoptRef(*new BeginTransparencyLayer(opacity));
1567     }
1568 
<span class="line-added">1569     WEBCORE_EXPORT virtual ~BeginTransparencyLayer();</span>
<span class="line-added">1570 </span>
1571     float opacity() const { return m_opacity; }
1572 
<span class="line-added">1573     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1574     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;BeginTransparencyLayer&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1575 </span>
1576 private:
<span class="line-modified">1577     WEBCORE_EXPORT BeginTransparencyLayer(float opacity);</span>




1578 
1579     void apply(GraphicsContext&amp;) const override;
1580 
1581     float m_opacity;
1582 };
1583 
<span class="line-added">1584 template&lt;class Encoder&gt;</span>
<span class="line-added">1585 void BeginTransparencyLayer::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1586 {</span>
<span class="line-added">1587     encoder &lt;&lt; m_opacity;</span>
<span class="line-added">1588 }</span>
<span class="line-added">1589 </span>
<span class="line-added">1590 template&lt;class Decoder&gt;</span>
<span class="line-added">1591 Optional&lt;Ref&lt;BeginTransparencyLayer&gt;&gt; BeginTransparencyLayer::decode(Decoder&amp; decoder)</span>
<span class="line-added">1592 {</span>
<span class="line-added">1593     Optional&lt;float&gt; opacity;</span>
<span class="line-added">1594     decoder &gt;&gt; opacity;</span>
<span class="line-added">1595     if (!opacity)</span>
<span class="line-added">1596         return WTF::nullopt;</span>
<span class="line-added">1597 </span>
<span class="line-added">1598     return BeginTransparencyLayer::create(*opacity);</span>
<span class="line-added">1599 }</span>
<span class="line-added">1600 </span>
1601 class EndTransparencyLayer : public DrawingItem {
1602 public:
1603     static Ref&lt;EndTransparencyLayer&gt; create()
1604     {
1605         return adoptRef(*new EndTransparencyLayer);
1606     }
1607 
<span class="line-added">1608     WEBCORE_EXPORT virtual ~EndTransparencyLayer();</span>
<span class="line-added">1609 </span>
<span class="line-added">1610     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1611     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;EndTransparencyLayer&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1612 </span>
1613 private:
<span class="line-modified">1614     WEBCORE_EXPORT EndTransparencyLayer();</span>



1615 
1616     void apply(GraphicsContext&amp;) const override;
1617 };
1618 
<span class="line-added">1619 template&lt;class Encoder&gt;</span>
<span class="line-added">1620 void EndTransparencyLayer::encode(Encoder&amp;) const</span>
<span class="line-added">1621 {</span>
<span class="line-added">1622 }</span>
<span class="line-added">1623 </span>
<span class="line-added">1624 template&lt;class Decoder&gt;</span>
<span class="line-added">1625 Optional&lt;Ref&lt;EndTransparencyLayer&gt;&gt; EndTransparencyLayer::decode(Decoder&amp;)</span>
<span class="line-added">1626 {</span>
<span class="line-added">1627     return EndTransparencyLayer::create();</span>
<span class="line-added">1628 }</span>
<span class="line-added">1629 </span>
1630 class DrawRect : public DrawingItem {
1631 public:
1632     static Ref&lt;DrawRect&gt; create(const FloatRect&amp; rect, float borderThickness)
1633     {
1634         return adoptRef(*new DrawRect(rect, borderThickness));
1635     }
1636 
<span class="line-added">1637     WEBCORE_EXPORT virtual ~DrawRect();</span>
<span class="line-added">1638 </span>
1639     FloatRect rect() const { return m_rect; }
1640     float borderThickness() const { return m_borderThickness; }
1641 
<span class="line-added">1642     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1643     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawRect&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1644 </span>
1645 private:
<span class="line-modified">1646     WEBCORE_EXPORT DrawRect(const FloatRect&amp;, float borderThickness);</span>





1647 
1648     void apply(GraphicsContext&amp;) const override;
1649     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1650 
1651     FloatRect m_rect;
1652     float m_borderThickness;
1653 };
1654 
<span class="line-added">1655 template&lt;class Encoder&gt;</span>
<span class="line-added">1656 void DrawRect::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1657 {</span>
<span class="line-added">1658     encoder &lt;&lt; m_rect;</span>
<span class="line-added">1659     encoder &lt;&lt; m_borderThickness;</span>
<span class="line-added">1660 }</span>
<span class="line-added">1661 </span>
<span class="line-added">1662 template&lt;class Decoder&gt;</span>
<span class="line-added">1663 Optional&lt;Ref&lt;DrawRect&gt;&gt; DrawRect::decode(Decoder&amp; decoder)</span>
<span class="line-added">1664 {</span>
<span class="line-added">1665     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">1666     decoder &gt;&gt; rect;</span>
<span class="line-added">1667     if (!rect)</span>
<span class="line-added">1668         return WTF::nullopt;</span>
<span class="line-added">1669 </span>
<span class="line-added">1670     Optional&lt;float&gt; borderThickness;</span>
<span class="line-added">1671     decoder &gt;&gt; borderThickness;</span>
<span class="line-added">1672     if (!borderThickness)</span>
<span class="line-added">1673         return WTF::nullopt;</span>
<span class="line-added">1674 </span>
<span class="line-added">1675     return DrawRect::create(*rect, *borderThickness);</span>
<span class="line-added">1676 }</span>
<span class="line-added">1677 </span>
1678 class DrawLine : public DrawingItem {
1679 public:
1680     static Ref&lt;DrawLine&gt; create(const FloatPoint&amp; point1, const FloatPoint&amp; point2)
1681     {
1682         return adoptRef(*new DrawLine(point1, point2));
1683     }
1684 
<span class="line-added">1685     WEBCORE_EXPORT virtual ~DrawLine();</span>
<span class="line-added">1686 </span>
1687     FloatPoint point1() const { return m_point1; }
1688     FloatPoint point2() const { return m_point2; }
1689 
<span class="line-added">1690     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1691     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawLine&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1692 </span>
1693 private:
<span class="line-modified">1694     WEBCORE_EXPORT DrawLine(const FloatPoint&amp;, const FloatPoint&amp;);</span>





1695 
1696     void apply(GraphicsContext&amp;) const override;
1697     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1698 
1699     FloatPoint m_point1;
1700     FloatPoint m_point2;
1701 };
1702 
<span class="line-added">1703 template&lt;class Encoder&gt;</span>
<span class="line-added">1704 void DrawLine::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1705 {</span>
<span class="line-added">1706     encoder &lt;&lt; m_point1;</span>
<span class="line-added">1707     encoder &lt;&lt; m_point2;</span>
<span class="line-added">1708 }</span>
<span class="line-added">1709 </span>
<span class="line-added">1710 template&lt;class Decoder&gt;</span>
<span class="line-added">1711 Optional&lt;Ref&lt;DrawLine&gt;&gt; DrawLine::decode(Decoder&amp; decoder)</span>
<span class="line-added">1712 {</span>
<span class="line-added">1713     Optional&lt;FloatPoint&gt; point1;</span>
<span class="line-added">1714     decoder &gt;&gt; point1;</span>
<span class="line-added">1715     if (!point1)</span>
<span class="line-added">1716         return WTF::nullopt;</span>
<span class="line-added">1717 </span>
<span class="line-added">1718     Optional&lt;FloatPoint&gt; point2;</span>
<span class="line-added">1719     decoder &gt;&gt; point2;</span>
<span class="line-added">1720     if (!point2)</span>
<span class="line-added">1721         return WTF::nullopt;</span>
<span class="line-added">1722 </span>
<span class="line-added">1723     return DrawLine::create(*point1, *point2);</span>
<span class="line-added">1724 }</span>
<span class="line-added">1725 </span>
1726 class DrawLinesForText : public DrawingItem {
1727 public:
1728     static Ref&lt;DrawLinesForText&gt; create(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines)
1729     {
1730         return adoptRef(*new DrawLinesForText(blockLocation, localAnchor, thickness, widths, printing, doubleLines));
1731     }
1732 
<span class="line-added">1733     WEBCORE_EXPORT virtual ~DrawLinesForText();</span>
<span class="line-added">1734 </span>
1735     void setBlockLocation(const FloatPoint&amp; blockLocation) { m_blockLocation = blockLocation; }
1736     const FloatPoint&amp; blockLocation() const { return m_blockLocation; }
1737     const FloatSize&amp; localAnchor() const { return m_localAnchor; }
1738     FloatPoint point() const { return m_blockLocation + m_localAnchor; }
1739     float thickness() const { return m_thickness; }
1740     const DashArray&amp; widths() const { return m_widths; }
1741     bool isPrinting() const { return m_printing; }
1742     bool doubleLines() const { return m_doubleLines; }
1743 
<span class="line-added">1744     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1745     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawLinesForText&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1746 </span>
1747 private:
<span class="line-modified">1748     WEBCORE_EXPORT DrawLinesForText(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines);</span>









1749 
1750     void apply(GraphicsContext&amp;) const override;
1751 
1752     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1753 
1754     FloatPoint m_blockLocation;
1755     FloatSize m_localAnchor;
1756     DashArray m_widths;
1757     float m_thickness;
1758     bool m_printing;
1759     bool m_doubleLines;
1760 };
1761 
<span class="line-added">1762 template&lt;class Encoder&gt;</span>
<span class="line-added">1763 void DrawLinesForText::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1764 {</span>
<span class="line-added">1765     encoder &lt;&lt; m_blockLocation;</span>
<span class="line-added">1766     encoder &lt;&lt; m_localAnchor;</span>
<span class="line-added">1767     encoder &lt;&lt; m_widths;</span>
<span class="line-added">1768     encoder &lt;&lt; m_thickness;</span>
<span class="line-added">1769     encoder &lt;&lt; m_printing;</span>
<span class="line-added">1770     encoder &lt;&lt; m_doubleLines;</span>
<span class="line-added">1771 }</span>
<span class="line-added">1772 </span>
<span class="line-added">1773 template&lt;class Decoder&gt;</span>
<span class="line-added">1774 Optional&lt;Ref&lt;DrawLinesForText&gt;&gt; DrawLinesForText::decode(Decoder&amp; decoder)</span>
<span class="line-added">1775 {</span>
<span class="line-added">1776     Optional&lt;FloatPoint&gt; blockLocation;</span>
<span class="line-added">1777     decoder &gt;&gt; blockLocation;</span>
<span class="line-added">1778     if (!blockLocation)</span>
<span class="line-added">1779         return WTF::nullopt;</span>
<span class="line-added">1780 </span>
<span class="line-added">1781     Optional&lt;FloatSize&gt; localAnchor;</span>
<span class="line-added">1782     decoder &gt;&gt; localAnchor;</span>
<span class="line-added">1783     if (!localAnchor)</span>
<span class="line-added">1784         return WTF::nullopt;</span>
<span class="line-added">1785 </span>
<span class="line-added">1786     Optional&lt;DashArray&gt; widths;</span>
<span class="line-added">1787     decoder &gt;&gt; widths;</span>
<span class="line-added">1788     if (!widths)</span>
<span class="line-added">1789         return WTF::nullopt;</span>
<span class="line-added">1790 </span>
<span class="line-added">1791     Optional&lt;float&gt; thickness;</span>
<span class="line-added">1792     decoder &gt;&gt; thickness;</span>
<span class="line-added">1793     if (!thickness)</span>
<span class="line-added">1794         return WTF::nullopt;</span>
<span class="line-added">1795 </span>
<span class="line-added">1796     Optional&lt;bool&gt; printing;</span>
<span class="line-added">1797     decoder &gt;&gt; printing;</span>
<span class="line-added">1798     if (!printing)</span>
<span class="line-added">1799         return WTF::nullopt;</span>
<span class="line-added">1800 </span>
<span class="line-added">1801     Optional&lt;bool&gt; doubleLines;</span>
<span class="line-added">1802     decoder &gt;&gt; doubleLines;</span>
<span class="line-added">1803     if (!doubleLines)</span>
<span class="line-added">1804         return WTF::nullopt;</span>
<span class="line-added">1805 </span>
<span class="line-added">1806     return DrawLinesForText::create(*blockLocation, *localAnchor, *thickness, *widths, *printing, *doubleLines);</span>
<span class="line-added">1807 }</span>
<span class="line-added">1808 </span>
1809 class DrawDotsForDocumentMarker : public DrawingItem {
1810 public:
1811     static Ref&lt;DrawDotsForDocumentMarker&gt; create(const FloatRect&amp; rect, DocumentMarkerLineStyle style)
1812     {
1813         return adoptRef(*new DrawDotsForDocumentMarker(rect, style));
1814     }
1815 
<span class="line-added">1816     WEBCORE_EXPORT virtual ~DrawDotsForDocumentMarker();</span>
<span class="line-added">1817 </span>
1818     FloatRect rect() const { return m_rect; }
1819 
<span class="line-added">1820     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1821     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawDotsForDocumentMarker&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1822 </span>
1823 private:
<span class="line-modified">1824     WEBCORE_EXPORT DrawDotsForDocumentMarker(const FloatRect&amp;, DocumentMarkerLineStyle);</span>





1825 
1826     void apply(GraphicsContext&amp;) const override;
1827 
1828     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1829 
1830     FloatRect m_rect;
1831     DocumentMarkerLineStyle m_style;
1832 };
1833 
<span class="line-added">1834 template&lt;class Encoder&gt;</span>
<span class="line-added">1835 void DrawDotsForDocumentMarker::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1836 {</span>
<span class="line-added">1837     encoder &lt;&lt; m_rect;</span>
<span class="line-added">1838     encoder &lt;&lt; m_style;</span>
<span class="line-added">1839 }</span>
<span class="line-added">1840 </span>
<span class="line-added">1841 template&lt;class Decoder&gt;</span>
<span class="line-added">1842 Optional&lt;Ref&lt;DrawDotsForDocumentMarker&gt;&gt; DrawDotsForDocumentMarker::decode(Decoder&amp; decoder)</span>
<span class="line-added">1843 {</span>
<span class="line-added">1844     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">1845     decoder &gt;&gt; rect;</span>
<span class="line-added">1846     if (!rect)</span>
<span class="line-added">1847         return WTF::nullopt;</span>
<span class="line-added">1848 </span>
<span class="line-added">1849     Optional&lt;DocumentMarkerLineStyle&gt; style;</span>
<span class="line-added">1850     decoder &gt;&gt; style;</span>
<span class="line-added">1851     if (!style)</span>
<span class="line-added">1852         return WTF::nullopt;</span>
<span class="line-added">1853 </span>
<span class="line-added">1854     return DrawDotsForDocumentMarker::create(*rect, *style);</span>
<span class="line-added">1855 }</span>
<span class="line-added">1856 </span>
1857 class DrawEllipse : public DrawingItem {
1858 public:
1859     static Ref&lt;DrawEllipse&gt; create(const FloatRect&amp; rect)
1860     {
1861         return adoptRef(*new DrawEllipse(rect));
1862     }
1863 
<span class="line-added">1864     WEBCORE_EXPORT ~DrawEllipse();</span>
<span class="line-added">1865 </span>
1866     FloatRect rect() const { return m_rect; }
1867 
<span class="line-added">1868     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1869     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawEllipse&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1870 </span>
1871 private:
<span class="line-modified">1872     WEBCORE_EXPORT DrawEllipse(const FloatRect&amp;);</span>




1873 
1874     void apply(GraphicsContext&amp;) const override;
1875     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1876 
1877     FloatRect m_rect;
1878 };
1879 
<span class="line-added">1880 template&lt;class Encoder&gt;</span>
<span class="line-added">1881 void DrawEllipse::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1882 {</span>
<span class="line-added">1883     encoder &lt;&lt; m_rect;</span>
<span class="line-added">1884 }</span>
<span class="line-added">1885 </span>
<span class="line-added">1886 template&lt;class Decoder&gt;</span>
<span class="line-added">1887 Optional&lt;Ref&lt;DrawEllipse&gt;&gt; DrawEllipse::decode(Decoder&amp; decoder)</span>
<span class="line-added">1888 {</span>
<span class="line-added">1889     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">1890     decoder &gt;&gt; rect;</span>
<span class="line-added">1891     if (!rect)</span>
<span class="line-added">1892         return WTF::nullopt;</span>
<span class="line-added">1893 </span>
<span class="line-added">1894     return DrawEllipse::create(*rect);</span>
<span class="line-added">1895 }</span>
<span class="line-added">1896 </span>
1897 class DrawPath : public DrawingItem {
1898 public:
1899     static Ref&lt;DrawPath&gt; create(const Path&amp; path)
1900     {
1901         return adoptRef(*new DrawPath(path));
1902     }
1903 
<span class="line-added">1904     WEBCORE_EXPORT virtual ~DrawPath();</span>
<span class="line-added">1905 </span>
1906     const Path&amp; path() const { return m_path; }
1907 
<span class="line-added">1908     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1909     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawPath&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1910 </span>
1911 private:
<span class="line-modified">1912     WEBCORE_EXPORT DrawPath(const Path&amp;);</span>




1913 
1914     void apply(GraphicsContext&amp;) const override;
1915 
1916     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_path.fastBoundingRect(); }
1917 
1918     const Path m_path;
1919 };
1920 
<span class="line-added">1921 template&lt;class Encoder&gt;</span>
<span class="line-added">1922 void DrawPath::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1923 {</span>
<span class="line-added">1924     encoder &lt;&lt; m_path;</span>
<span class="line-added">1925 }</span>
<span class="line-added">1926 </span>
<span class="line-added">1927 template&lt;class Decoder&gt;</span>
<span class="line-added">1928 Optional&lt;Ref&lt;DrawPath&gt;&gt; DrawPath::decode(Decoder&amp; decoder)</span>
<span class="line-added">1929 {</span>
<span class="line-added">1930     Optional&lt;Path&gt; path;</span>
<span class="line-added">1931     decoder &gt;&gt; path;</span>
<span class="line-added">1932     if (!path)</span>
<span class="line-added">1933         return WTF::nullopt;</span>
<span class="line-added">1934 </span>
<span class="line-added">1935     return DrawPath::create(*path);</span>
<span class="line-added">1936 }</span>
<span class="line-added">1937 </span>
1938 class DrawFocusRingPath : public DrawingItem {
1939 public:
1940     static Ref&lt;DrawFocusRingPath&gt; create(const Path&amp; path, float width, float offset, const Color&amp; color)
1941     {
1942         return adoptRef(*new DrawFocusRingPath(path, width, offset, color));
1943     }
1944 
<span class="line-added">1945     WEBCORE_EXPORT virtual ~DrawFocusRingPath();</span>
<span class="line-added">1946 </span>
1947     const Path&amp; path() const { return m_path; }
1948     float width() const { return m_width; }
1949     float offset() const { return m_offset; }
1950     const Color&amp; color() const { return m_color; }
1951 
<span class="line-added">1952     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">1953     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawFocusRingPath&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">1954 </span>
1955 private:
<span class="line-modified">1956     WEBCORE_EXPORT DrawFocusRingPath(const Path&amp;, float width, float offset, const Color&amp;);</span>







1957 
1958     void apply(GraphicsContext&amp;) const override;
1959 
1960     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1961 
1962     const Path m_path;
1963     float m_width;
1964     float m_offset;
1965     Color m_color;
1966 };
1967 
<span class="line-added">1968 template&lt;class Encoder&gt;</span>
<span class="line-added">1969 void DrawFocusRingPath::encode(Encoder&amp; encoder) const</span>
<span class="line-added">1970 {</span>
<span class="line-added">1971     encoder &lt;&lt; m_path;</span>
<span class="line-added">1972     encoder &lt;&lt; m_width;</span>
<span class="line-added">1973     encoder &lt;&lt; m_offset;</span>
<span class="line-added">1974     encoder &lt;&lt; m_color;</span>
<span class="line-added">1975 }</span>
<span class="line-added">1976 </span>
<span class="line-added">1977 template&lt;class Decoder&gt;</span>
<span class="line-added">1978 Optional&lt;Ref&lt;DrawFocusRingPath&gt;&gt; DrawFocusRingPath::decode(Decoder&amp; decoder)</span>
<span class="line-added">1979 {</span>
<span class="line-added">1980     Optional&lt;Path&gt; path;</span>
<span class="line-added">1981     decoder &gt;&gt; path;</span>
<span class="line-added">1982     if (!path)</span>
<span class="line-added">1983         return WTF::nullopt;</span>
<span class="line-added">1984 </span>
<span class="line-added">1985     Optional&lt;float&gt; width;</span>
<span class="line-added">1986     decoder &gt;&gt; width;</span>
<span class="line-added">1987     if (!width)</span>
<span class="line-added">1988         return WTF::nullopt;</span>
<span class="line-added">1989 </span>
<span class="line-added">1990     Optional&lt;float&gt; offset;</span>
<span class="line-added">1991     decoder &gt;&gt; offset;</span>
<span class="line-added">1992     if (!offset)</span>
<span class="line-added">1993         return WTF::nullopt;</span>
<span class="line-added">1994 </span>
<span class="line-added">1995     Optional&lt;Color&gt; color;</span>
<span class="line-added">1996     decoder &gt;&gt; color;</span>
<span class="line-added">1997     if (!color)</span>
<span class="line-added">1998         return WTF::nullopt;</span>
<span class="line-added">1999 </span>
<span class="line-added">2000     return DrawFocusRingPath::create(*path, *width, *offset, *color);</span>
<span class="line-added">2001 }</span>
<span class="line-added">2002 </span>
2003 class DrawFocusRingRects : public DrawingItem {
2004 public:
2005     static Ref&lt;DrawFocusRingRects&gt; create(const Vector&lt;FloatRect&gt;&amp; rects, float width, float offset, const Color&amp; color)
2006     {
2007         return adoptRef(*new DrawFocusRingRects(rects, width, offset, color));
2008     }
2009 
<span class="line-added">2010     WEBCORE_EXPORT virtual ~DrawFocusRingRects();</span>
<span class="line-added">2011 </span>
2012     const Vector&lt;FloatRect&gt; rects() const { return m_rects; }
2013     float width() const { return m_width; }
2014     float offset() const { return m_offset; }
2015     const Color&amp; color() const { return m_color; }
2016 
<span class="line-added">2017     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2018     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawFocusRingRects&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2019 </span>
2020 private:
<span class="line-modified">2021     WEBCORE_EXPORT DrawFocusRingRects(const Vector&lt;FloatRect&gt;&amp;, float width, float offset, const Color&amp;);</span>







2022 
2023     void apply(GraphicsContext&amp;) const override;
2024 
2025     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
2026 
2027     Vector&lt;FloatRect&gt; m_rects;
2028     float m_width;
2029     float m_offset;
2030     Color m_color;
2031 };
2032 
<span class="line-added">2033 template&lt;class Encoder&gt;</span>
<span class="line-added">2034 void DrawFocusRingRects::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2035 {</span>
<span class="line-added">2036     encoder &lt;&lt; m_rects;</span>
<span class="line-added">2037     encoder &lt;&lt; m_width;</span>
<span class="line-added">2038     encoder &lt;&lt; m_offset;</span>
<span class="line-added">2039     encoder &lt;&lt; m_color;</span>
<span class="line-added">2040 }</span>
<span class="line-added">2041 </span>
<span class="line-added">2042 template&lt;class Decoder&gt;</span>
<span class="line-added">2043 Optional&lt;Ref&lt;DrawFocusRingRects&gt;&gt; DrawFocusRingRects::decode(Decoder&amp; decoder)</span>
<span class="line-added">2044 {</span>
<span class="line-added">2045     Optional&lt;Vector&lt;FloatRect&gt;&gt; rects;</span>
<span class="line-added">2046     decoder &gt;&gt; rects;</span>
<span class="line-added">2047     if (!rects)</span>
<span class="line-added">2048         return WTF::nullopt;</span>
<span class="line-added">2049 </span>
<span class="line-added">2050     Optional&lt;float&gt; width;</span>
<span class="line-added">2051     decoder &gt;&gt; width;</span>
<span class="line-added">2052     if (!width)</span>
<span class="line-added">2053         return WTF::nullopt;</span>
<span class="line-added">2054 </span>
<span class="line-added">2055     Optional&lt;float&gt; offset;</span>
<span class="line-added">2056     decoder &gt;&gt; offset;</span>
<span class="line-added">2057     if (!offset)</span>
<span class="line-added">2058         return WTF::nullopt;</span>
<span class="line-added">2059 </span>
<span class="line-added">2060     Optional&lt;Color&gt; color;</span>
<span class="line-added">2061     decoder &gt;&gt; color;</span>
<span class="line-added">2062     if (!color)</span>
<span class="line-added">2063         return WTF::nullopt;</span>
<span class="line-added">2064 </span>
<span class="line-added">2065     return DrawFocusRingRects::create(*rects, *width, *offset, *color);</span>
<span class="line-added">2066 }</span>
<span class="line-added">2067 </span>
2068 class FillRect : public DrawingItem {
2069 public:
2070     static Ref&lt;FillRect&gt; create(const FloatRect&amp; rect)
2071     {
2072         return adoptRef(*new FillRect(rect));
2073     }
2074 
<span class="line-added">2075     WEBCORE_EXPORT virtual ~FillRect();</span>
<span class="line-added">2076 </span>
2077     FloatRect rect() const { return m_rect; }
2078 
<span class="line-added">2079     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2080     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRect&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2081 </span>
2082 private:
<span class="line-modified">2083     WEBCORE_EXPORT FillRect(const FloatRect&amp;);</span>




2084 
2085     void apply(GraphicsContext&amp;) const override;
2086     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2087 
2088     FloatRect m_rect;
2089 };
2090 
<span class="line-added">2091 template&lt;class Encoder&gt;</span>
<span class="line-added">2092 void FillRect::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2093 {</span>
<span class="line-added">2094     encoder &lt;&lt; m_rect;</span>
<span class="line-added">2095 }</span>
<span class="line-added">2096 </span>
<span class="line-added">2097 template&lt;class Decoder&gt;</span>
<span class="line-added">2098 Optional&lt;Ref&lt;FillRect&gt;&gt; FillRect::decode(Decoder&amp; decoder)</span>
<span class="line-added">2099 {</span>
<span class="line-added">2100     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">2101     decoder &gt;&gt; rect;</span>
<span class="line-added">2102     if (!rect)</span>
<span class="line-added">2103         return WTF::nullopt;</span>
<span class="line-added">2104 </span>
<span class="line-added">2105     return FillRect::create(*rect);</span>
<span class="line-added">2106 }</span>
<span class="line-added">2107 </span>
2108 // FIXME: Make these inherit from FillRect proper.
2109 class FillRectWithColor : public DrawingItem {
2110 public:
2111     static Ref&lt;FillRectWithColor&gt; create(const FloatRect&amp; rect, const Color&amp; color)
2112     {
2113         return adoptRef(*new FillRectWithColor(rect, color));
2114     }
2115 
<span class="line-added">2116     WEBCORE_EXPORT virtual ~FillRectWithColor();</span>
<span class="line-added">2117 </span>
2118     FloatRect rect() const { return m_rect; }
2119     const Color&amp; color() const { return m_color; }
2120 
<span class="line-added">2121     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2122     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRectWithColor&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2123 </span>
2124 private:
<span class="line-modified">2125     WEBCORE_EXPORT FillRectWithColor(const FloatRect&amp;, const Color&amp;);</span>





2126 
2127     void apply(GraphicsContext&amp;) const override;
2128     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2129 
2130     FloatRect m_rect;
2131     Color m_color;
2132 };
2133 
<span class="line-added">2134 template&lt;class Encoder&gt;</span>
<span class="line-added">2135 void FillRectWithColor::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2136 {</span>
<span class="line-added">2137     encoder &lt;&lt; m_rect;</span>
<span class="line-added">2138     encoder &lt;&lt; m_color;</span>
<span class="line-added">2139 }</span>
<span class="line-added">2140 </span>
<span class="line-added">2141 template&lt;class Decoder&gt;</span>
<span class="line-added">2142 Optional&lt;Ref&lt;FillRectWithColor&gt;&gt; FillRectWithColor::decode(Decoder&amp; decoder)</span>
<span class="line-added">2143 {</span>
<span class="line-added">2144     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">2145     decoder &gt;&gt; rect;</span>
<span class="line-added">2146     if (!rect)</span>
<span class="line-added">2147         return WTF::nullopt;</span>
<span class="line-added">2148 </span>
<span class="line-added">2149     Optional&lt;Color&gt; color;</span>
<span class="line-added">2150     decoder &gt;&gt; color;</span>
<span class="line-added">2151     if (!color)</span>
<span class="line-added">2152         return WTF::nullopt;</span>
<span class="line-added">2153 </span>
<span class="line-added">2154     return FillRectWithColor::create(*rect, *color);</span>
<span class="line-added">2155 }</span>
<span class="line-added">2156 </span>
2157 class FillRectWithGradient : public DrawingItem {
2158 public:
2159     static Ref&lt;FillRectWithGradient&gt; create(const FloatRect&amp; rect, Gradient&amp; gradient)
2160     {
2161         return adoptRef(*new FillRectWithGradient(rect, gradient));
2162     }
2163 
<span class="line-added">2164     WEBCORE_EXPORT virtual ~FillRectWithGradient();</span>
<span class="line-added">2165 </span>
2166     FloatRect rect() const { return m_rect; }
2167 
<span class="line-added">2168     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2169     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRectWithGradient&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2170 </span>
2171 private:
<span class="line-modified">2172     WEBCORE_EXPORT FillRectWithGradient(const FloatRect&amp;, Gradient&amp;);</span>





2173 
2174     void apply(GraphicsContext&amp;) const override;
2175     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2176 
2177     FloatRect m_rect;
2178     mutable Ref&lt;Gradient&gt; m_gradient; // FIXME: Make this not mutable
2179 };
2180 
<span class="line-added">2181 template&lt;class Encoder&gt;</span>
<span class="line-added">2182 void FillRectWithGradient::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2183 {</span>
<span class="line-added">2184     encoder &lt;&lt; m_rect;</span>
<span class="line-added">2185     encoder &lt;&lt; m_gradient.get();</span>
<span class="line-added">2186 }</span>
<span class="line-added">2187 </span>
<span class="line-added">2188 template&lt;class Decoder&gt;</span>
<span class="line-added">2189 Optional&lt;Ref&lt;FillRectWithGradient&gt;&gt; FillRectWithGradient::decode(Decoder&amp; decoder)</span>
<span class="line-added">2190 {</span>
<span class="line-added">2191     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">2192     decoder &gt;&gt; rect;</span>
<span class="line-added">2193     if (!rect)</span>
<span class="line-added">2194         return WTF::nullopt;</span>
<span class="line-added">2195 </span>
<span class="line-added">2196     auto gradient = Gradient::decode(decoder);</span>
<span class="line-added">2197     if (!gradient)</span>
<span class="line-added">2198         return WTF::nullopt;</span>
<span class="line-added">2199 </span>
<span class="line-added">2200     return FillRectWithGradient::create(*rect, gradient-&gt;get());</span>
<span class="line-added">2201 }</span>
<span class="line-added">2202 </span>
2203 class FillCompositedRect : public DrawingItem {
2204 public:
2205     static Ref&lt;FillCompositedRect&gt; create(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)
2206     {
2207         return adoptRef(*new FillCompositedRect(rect, color, op, blendMode));
2208     }
2209 
<span class="line-added">2210     WEBCORE_EXPORT virtual ~FillCompositedRect();</span>
<span class="line-added">2211 </span>
2212     FloatRect rect() const { return m_rect; }
2213     const Color&amp; color() const { return m_color; }
2214     CompositeOperator compositeOperator() const { return m_op; }
2215     BlendMode blendMode() const { return m_blendMode; }
2216 
<span class="line-added">2217     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2218     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillCompositedRect&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2219 </span>
2220 private:
<span class="line-modified">2221     WEBCORE_EXPORT FillCompositedRect(const FloatRect&amp;, const Color&amp;, CompositeOperator, BlendMode);</span>







2222 
2223     void apply(GraphicsContext&amp;) const override;
2224     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2225 
2226     FloatRect m_rect;
2227     Color m_color;
2228     CompositeOperator m_op;
2229     BlendMode m_blendMode;
2230 };
2231 
<span class="line-added">2232 template&lt;class Encoder&gt;</span>
<span class="line-added">2233 void FillCompositedRect::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2234 {</span>
<span class="line-added">2235     encoder &lt;&lt; m_rect;</span>
<span class="line-added">2236     encoder &lt;&lt; m_color;</span>
<span class="line-added">2237     encoder &lt;&lt; m_op;</span>
<span class="line-added">2238     encoder &lt;&lt; m_blendMode;</span>
<span class="line-added">2239 }</span>
<span class="line-added">2240 </span>
<span class="line-added">2241 template&lt;class Decoder&gt;</span>
<span class="line-added">2242 Optional&lt;Ref&lt;FillCompositedRect&gt;&gt; FillCompositedRect::decode(Decoder&amp; decoder)</span>
<span class="line-added">2243 {</span>
<span class="line-added">2244     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">2245     decoder &gt;&gt; rect;</span>
<span class="line-added">2246     if (!rect)</span>
<span class="line-added">2247         return WTF::nullopt;</span>
<span class="line-added">2248 </span>
<span class="line-added">2249     Optional&lt;Color&gt; color;</span>
<span class="line-added">2250     decoder &gt;&gt; color;</span>
<span class="line-added">2251     if (!color)</span>
<span class="line-added">2252         return WTF::nullopt;</span>
<span class="line-added">2253 </span>
<span class="line-added">2254     Optional&lt;CompositeOperator&gt; op;</span>
<span class="line-added">2255     decoder &gt;&gt; op;</span>
<span class="line-added">2256     if (!op)</span>
<span class="line-added">2257         return WTF::nullopt;</span>
<span class="line-added">2258 </span>
<span class="line-added">2259     Optional&lt;BlendMode&gt; blendMode;</span>
<span class="line-added">2260     decoder &gt;&gt; blendMode;</span>
<span class="line-added">2261     if (!blendMode)</span>
<span class="line-added">2262         return WTF::nullopt;</span>
<span class="line-added">2263 </span>
<span class="line-added">2264     return FillCompositedRect::create(*rect, *color, *op, *blendMode);</span>
<span class="line-added">2265 }</span>
<span class="line-added">2266 </span>
2267 class FillRoundedRect : public DrawingItem {
2268 public:
2269     static Ref&lt;FillRoundedRect&gt; create(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)
2270     {
2271         return adoptRef(*new FillRoundedRect(rect, color, blendMode));
2272     }
2273 
<span class="line-added">2274     WEBCORE_EXPORT virtual ~FillRoundedRect();</span>
<span class="line-added">2275 </span>
2276     const FloatRoundedRect&amp; roundedRect() const { return m_rect; }
2277     const Color&amp; color() const { return m_color; }
2278     BlendMode blendMode() const { return m_blendMode; }
2279 
<span class="line-added">2280     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2281     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRoundedRect&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2282 </span>
2283 private:
<span class="line-modified">2284     WEBCORE_EXPORT FillRoundedRect(const FloatRoundedRect&amp;, const Color&amp;, BlendMode);</span>






2285 
2286     void apply(GraphicsContext&amp;) const override;
2287     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect.rect(); }
2288 
2289     FloatRoundedRect m_rect;
2290     Color m_color;
2291     BlendMode m_blendMode;
2292 };
2293 
<span class="line-added">2294 template&lt;class Encoder&gt;</span>
<span class="line-added">2295 void FillRoundedRect::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2296 {</span>
<span class="line-added">2297     encoder &lt;&lt; m_rect;</span>
<span class="line-added">2298     encoder &lt;&lt; m_color;</span>
<span class="line-added">2299     encoder &lt;&lt; m_blendMode;</span>
<span class="line-added">2300 }</span>
<span class="line-added">2301 </span>
<span class="line-added">2302 template&lt;class Decoder&gt;</span>
<span class="line-added">2303 Optional&lt;Ref&lt;FillRoundedRect&gt;&gt; FillRoundedRect::decode(Decoder&amp; decoder)</span>
<span class="line-added">2304 {</span>
<span class="line-added">2305     Optional&lt;FloatRoundedRect&gt; rect;</span>
<span class="line-added">2306     decoder &gt;&gt; rect;</span>
<span class="line-added">2307     if (!rect)</span>
<span class="line-added">2308         return WTF::nullopt;</span>
<span class="line-added">2309 </span>
<span class="line-added">2310     Optional&lt;Color&gt; color;</span>
<span class="line-added">2311     decoder &gt;&gt; color;</span>
<span class="line-added">2312     if (!color)</span>
<span class="line-added">2313         return WTF::nullopt;</span>
<span class="line-added">2314 </span>
<span class="line-added">2315     Optional&lt;BlendMode&gt; blendMode;</span>
<span class="line-added">2316     decoder &gt;&gt; blendMode;</span>
<span class="line-added">2317     if (!blendMode)</span>
<span class="line-added">2318         return WTF::nullopt;</span>
<span class="line-added">2319 </span>
<span class="line-added">2320     return FillRoundedRect::create(*rect, *color, *blendMode);</span>
<span class="line-added">2321 }</span>
<span class="line-added">2322 </span>
2323 class FillRectWithRoundedHole : public DrawingItem {
2324 public:
2325     static Ref&lt;FillRectWithRoundedHole&gt; create(const FloatRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
2326     {
2327         return adoptRef(*new FillRectWithRoundedHole(rect, roundedHoleRect, color));
2328     }
2329 
<span class="line-added">2330     WEBCORE_EXPORT virtual ~FillRectWithRoundedHole();</span>
<span class="line-added">2331 </span>
2332     const FloatRect&amp; rect() const { return m_rect; }
2333     const FloatRoundedRect&amp; roundedHoleRect() const { return m_roundedHoleRect; }
2334     const Color&amp; color() const { return m_color; }
2335 
<span class="line-added">2336     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2337     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRectWithRoundedHole&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2338 </span>
2339 private:
<span class="line-modified">2340     WEBCORE_EXPORT FillRectWithRoundedHole(const FloatRect&amp;, const FloatRoundedRect&amp;, const Color&amp;);</span>






2341 
2342     void apply(GraphicsContext&amp;) const override;
2343     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2344 
2345     FloatRect m_rect;
2346     FloatRoundedRect m_roundedHoleRect;
2347     Color m_color;
2348 };
2349 
<span class="line-added">2350 template&lt;class Encoder&gt;</span>
<span class="line-added">2351 void FillRectWithRoundedHole::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2352 {</span>
<span class="line-added">2353     encoder &lt;&lt; m_rect;</span>
<span class="line-added">2354     encoder &lt;&lt; m_roundedHoleRect;</span>
<span class="line-added">2355     encoder &lt;&lt; m_color;</span>
<span class="line-added">2356 }</span>
<span class="line-added">2357 </span>
<span class="line-added">2358 template&lt;class Decoder&gt;</span>
<span class="line-added">2359 Optional&lt;Ref&lt;FillRectWithRoundedHole&gt;&gt; FillRectWithRoundedHole::decode(Decoder&amp; decoder)</span>
<span class="line-added">2360 {</span>
<span class="line-added">2361     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">2362     decoder &gt;&gt; rect;</span>
<span class="line-added">2363     if (!rect)</span>
<span class="line-added">2364         return WTF::nullopt;</span>
<span class="line-added">2365 </span>
<span class="line-added">2366     Optional&lt;FloatRoundedRect&gt; roundedHoleRect;</span>
<span class="line-added">2367     decoder &gt;&gt; roundedHoleRect;</span>
<span class="line-added">2368     if (!roundedHoleRect)</span>
<span class="line-added">2369         return WTF::nullopt;</span>
<span class="line-added">2370 </span>
<span class="line-added">2371     Optional&lt;Color&gt; color;</span>
<span class="line-added">2372     decoder &gt;&gt; color;</span>
<span class="line-added">2373     if (!color)</span>
<span class="line-added">2374         return WTF::nullopt;</span>
<span class="line-added">2375 </span>
<span class="line-added">2376     return FillRectWithRoundedHole::create(*rect, *roundedHoleRect, *color);</span>
<span class="line-added">2377 }</span>
<span class="line-added">2378 </span>
2379 class FillPath : public DrawingItem {
2380 public:
2381     static Ref&lt;FillPath&gt; create(const Path&amp; path)
2382     {
2383         return adoptRef(*new FillPath(path));
2384     }
2385 
<span class="line-added">2386     WEBCORE_EXPORT virtual ~FillPath();</span>
<span class="line-added">2387 </span>
2388     const Path&amp; path() const { return m_path; }
2389 
<span class="line-added">2390     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2391     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillPath&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2392 </span>
2393 private:
<span class="line-modified">2394     WEBCORE_EXPORT FillPath(const Path&amp;);</span>




2395 
2396     void apply(GraphicsContext&amp;) const override;
2397     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_path.fastBoundingRect(); }
2398 
2399     const Path m_path;
2400 };
2401 
<span class="line-added">2402 template&lt;class Encoder&gt;</span>
<span class="line-added">2403 void FillPath::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2404 {</span>
<span class="line-added">2405     encoder &lt;&lt; m_path;</span>
<span class="line-added">2406 }</span>
<span class="line-added">2407 </span>
<span class="line-added">2408 template&lt;class Decoder&gt;</span>
<span class="line-added">2409 Optional&lt;Ref&lt;FillPath&gt;&gt; FillPath::decode(Decoder&amp; decoder)</span>
<span class="line-added">2410 {</span>
<span class="line-added">2411     Optional&lt;Path&gt; path;</span>
<span class="line-added">2412     decoder &gt;&gt; path;</span>
<span class="line-added">2413     if (!path)</span>
<span class="line-added">2414         return WTF::nullopt;</span>
<span class="line-added">2415 </span>
<span class="line-added">2416     return FillPath::create(*path);</span>
<span class="line-added">2417 }</span>
<span class="line-added">2418 </span>
2419 class FillEllipse : public DrawingItem {
2420 public:
2421     static Ref&lt;FillEllipse&gt; create(const FloatRect&amp; rect)
2422     {
2423         return adoptRef(*new FillEllipse(rect));
2424     }
2425 
<span class="line-added">2426     WEBCORE_EXPORT virtual ~FillEllipse();</span>
<span class="line-added">2427 </span>
2428     FloatRect rect() const { return m_rect; }
2429 
<span class="line-added">2430     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2431     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillEllipse&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2432 </span>
2433 private:
<span class="line-modified">2434     WEBCORE_EXPORT FillEllipse(const FloatRect&amp;);</span>




2435 
2436     void apply(GraphicsContext&amp;) const override;
2437 
2438     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2439 
2440     FloatRect m_rect;
2441 };
2442 
<span class="line-added">2443 template&lt;class Encoder&gt;</span>
<span class="line-added">2444 void FillEllipse::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2445 {</span>
<span class="line-added">2446     encoder &lt;&lt; m_rect;</span>
<span class="line-added">2447 }</span>
<span class="line-added">2448 </span>
<span class="line-added">2449 template&lt;class Decoder&gt;</span>
<span class="line-added">2450 Optional&lt;Ref&lt;FillEllipse&gt;&gt; FillEllipse::decode(Decoder&amp; decoder)</span>
<span class="line-added">2451 {</span>
<span class="line-added">2452     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">2453     decoder &gt;&gt; rect;</span>
<span class="line-added">2454     if (!rect)</span>
<span class="line-added">2455         return WTF::nullopt;</span>
<span class="line-added">2456 </span>
<span class="line-added">2457     return FillEllipse::create(*rect);</span>
<span class="line-added">2458 }</span>
<span class="line-added">2459 </span>
2460 class StrokeRect : public DrawingItem {
2461 public:
2462     static Ref&lt;StrokeRect&gt; create(const FloatRect&amp; rect, float lineWidth)
2463     {
2464         return adoptRef(*new StrokeRect(rect, lineWidth));
2465     }
2466 
<span class="line-added">2467     WEBCORE_EXPORT virtual ~StrokeRect();</span>
<span class="line-added">2468 </span>
2469     FloatRect rect() const { return m_rect; }
2470     float lineWidth() const { return m_lineWidth; }
2471 
<span class="line-added">2472     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2473     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;StrokeRect&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2474 </span>
2475 private:
<span class="line-modified">2476     WEBCORE_EXPORT StrokeRect(const FloatRect&amp;, float);</span>





2477 
2478     void apply(GraphicsContext&amp;) const override;
2479     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
2480 
2481     FloatRect m_rect;
2482     float m_lineWidth;
2483 };
2484 
<span class="line-added">2485 template&lt;class Encoder&gt;</span>
<span class="line-added">2486 void StrokeRect::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2487 {</span>
<span class="line-added">2488     encoder &lt;&lt; m_rect;</span>
<span class="line-added">2489     encoder &lt;&lt; m_lineWidth;</span>
<span class="line-added">2490 }</span>
<span class="line-added">2491 </span>
<span class="line-added">2492 template&lt;class Decoder&gt;</span>
<span class="line-added">2493 Optional&lt;Ref&lt;StrokeRect&gt;&gt; StrokeRect::decode(Decoder&amp; decoder)</span>
<span class="line-added">2494 {</span>
<span class="line-added">2495     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">2496     decoder &gt;&gt; rect;</span>
<span class="line-added">2497     if (!rect)</span>
<span class="line-added">2498         return WTF::nullopt;</span>
<span class="line-added">2499 </span>
<span class="line-added">2500     Optional&lt;float&gt; lineWidth;</span>
<span class="line-added">2501     decoder &gt;&gt; lineWidth;</span>
<span class="line-added">2502     if (!lineWidth)</span>
<span class="line-added">2503         return WTF::nullopt;</span>
<span class="line-added">2504 </span>
<span class="line-added">2505     return StrokeRect::create(*rect, *lineWidth);</span>
<span class="line-added">2506 }</span>
<span class="line-added">2507 </span>
2508 class StrokePath : public DrawingItem {
2509 public:
2510     static Ref&lt;StrokePath&gt; create(const Path&amp; path)
2511     {
2512         return adoptRef(*new StrokePath(path));
2513     }
2514 
<span class="line-added">2515     WEBCORE_EXPORT virtual ~StrokePath();</span>
<span class="line-added">2516 </span>
2517     const Path&amp; path() const { return m_path; }
2518 
<span class="line-added">2519     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2520     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;StrokePath&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2521 </span>
2522 private:
<span class="line-modified">2523     WEBCORE_EXPORT StrokePath(const Path&amp;);</span>




2524 
2525     void apply(GraphicsContext&amp;) const override;
2526     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
2527 
2528     const Path m_path;

2529 };
2530 
<span class="line-added">2531 template&lt;class Encoder&gt;</span>
<span class="line-added">2532 void StrokePath::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2533 {</span>
<span class="line-added">2534     encoder &lt;&lt; m_path;</span>
<span class="line-added">2535 }</span>
<span class="line-added">2536 </span>
<span class="line-added">2537 template&lt;class Decoder&gt;</span>
<span class="line-added">2538 Optional&lt;Ref&lt;StrokePath&gt;&gt; StrokePath::decode(Decoder&amp; decoder)</span>
<span class="line-added">2539 {</span>
<span class="line-added">2540     Optional&lt;Path&gt; path;</span>
<span class="line-added">2541     decoder &gt;&gt; path;</span>
<span class="line-added">2542     if (!path)</span>
<span class="line-added">2543         return WTF::nullopt;</span>
<span class="line-added">2544 </span>
<span class="line-added">2545     return StrokePath::create(*path);</span>
<span class="line-added">2546 }</span>
<span class="line-added">2547 </span>
2548 class StrokeEllipse : public DrawingItem {
2549 public:
2550     static Ref&lt;StrokeEllipse&gt; create(const FloatRect&amp; rect)
2551     {
2552         return adoptRef(*new StrokeEllipse(rect));
2553     }
2554 
<span class="line-added">2555     WEBCORE_EXPORT ~StrokeEllipse();</span>
<span class="line-added">2556 </span>
2557     FloatRect rect() const { return m_rect; }
2558 
<span class="line-added">2559     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2560     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;StrokeEllipse&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2561 </span>
2562 private:
<span class="line-modified">2563     WEBCORE_EXPORT StrokeEllipse(const FloatRect&amp;);</span>




2564 
2565     void apply(GraphicsContext&amp;) const override;
2566     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
2567 
2568     FloatRect m_rect;
2569 };
2570 
<span class="line-added">2571 template&lt;class Encoder&gt;</span>
<span class="line-added">2572 void StrokeEllipse::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2573 {</span>
<span class="line-added">2574     encoder &lt;&lt; m_rect;</span>
<span class="line-added">2575 }</span>
<span class="line-added">2576 </span>
<span class="line-added">2577 template&lt;class Decoder&gt;</span>
<span class="line-added">2578 Optional&lt;Ref&lt;StrokeEllipse&gt;&gt; StrokeEllipse::decode(Decoder&amp; decoder)</span>
<span class="line-added">2579 {</span>
<span class="line-added">2580     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">2581     decoder &gt;&gt; rect;</span>
<span class="line-added">2582     if (!rect)</span>
<span class="line-added">2583         return WTF::nullopt;</span>
<span class="line-added">2584 </span>
<span class="line-added">2585     return StrokeEllipse::create(*rect);</span>
<span class="line-added">2586 }</span>
<span class="line-added">2587 </span>
2588 class ClearRect : public DrawingItem {
2589 public:
2590     static Ref&lt;ClearRect&gt; create(const FloatRect&amp; rect)
2591     {
2592         return adoptRef(*new ClearRect(rect));
2593     }
2594 
<span class="line-added">2595     WEBCORE_EXPORT virtual ~ClearRect();</span>
<span class="line-added">2596 </span>
2597     FloatRect rect() const { return m_rect; }
2598 
<span class="line-added">2599     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2600     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClearRect&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2601 </span>
2602 private:
<span class="line-modified">2603     WEBCORE_EXPORT ClearRect(const FloatRect&amp;);</span>




2604 
2605     void apply(GraphicsContext&amp;) const override;
2606     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
2607 
2608     FloatRect m_rect;
2609 };
2610 
<span class="line-added">2611 template&lt;class Encoder&gt;</span>
<span class="line-added">2612 void ClearRect::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2613 {</span>
<span class="line-added">2614     encoder &lt;&lt; m_rect;</span>
<span class="line-added">2615 }</span>
<span class="line-added">2616 </span>
<span class="line-added">2617 template&lt;class Decoder&gt;</span>
<span class="line-added">2618 Optional&lt;Ref&lt;ClearRect&gt;&gt; ClearRect::decode(Decoder&amp; decoder)</span>
<span class="line-added">2619 {</span>
<span class="line-added">2620     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">2621     decoder &gt;&gt; rect;</span>
<span class="line-added">2622     if (!rect)</span>
<span class="line-added">2623         return WTF::nullopt;</span>
<span class="line-added">2624 </span>
<span class="line-added">2625     return ClearRect::create(*rect);</span>
<span class="line-added">2626 }</span>
<span class="line-added">2627 </span>
2628 #if USE(CG)
2629 class ApplyStrokePattern : public Item {
2630 public:
2631     static Ref&lt;ApplyStrokePattern&gt; create()
2632     {
2633         return adoptRef(*new ApplyStrokePattern);
2634     }
2635 
<span class="line-added">2636     WEBCORE_EXPORT virtual ~ApplyStrokePattern();</span>
<span class="line-added">2637 </span>
<span class="line-added">2638     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2639     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ApplyStrokePattern&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2640 </span>
2641 private:
<span class="line-modified">2642     WEBCORE_EXPORT ApplyStrokePattern();</span>



2643 
2644     void apply(GraphicsContext&amp;) const override;
2645 };
2646 
<span class="line-added">2647 template&lt;class Encoder&gt;</span>
<span class="line-added">2648 void ApplyStrokePattern::encode(Encoder&amp;) const</span>
<span class="line-added">2649 {</span>
<span class="line-added">2650 }</span>
<span class="line-added">2651 </span>
<span class="line-added">2652 template&lt;class Decoder&gt;</span>
<span class="line-added">2653 Optional&lt;Ref&lt;ApplyStrokePattern&gt;&gt; ApplyStrokePattern::decode(Decoder&amp;)</span>
<span class="line-added">2654 {</span>
<span class="line-added">2655     return ApplyStrokePattern::create();</span>
<span class="line-added">2656 }</span>
<span class="line-added">2657 </span>
2658 class ApplyFillPattern : public Item {
2659 public:
2660     static Ref&lt;ApplyFillPattern&gt; create()
2661     {
2662         return adoptRef(*new ApplyFillPattern);
2663     }
2664 
<span class="line-added">2665     WEBCORE_EXPORT virtual ~ApplyFillPattern();</span>
<span class="line-added">2666 </span>
<span class="line-added">2667     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2668     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ApplyFillPattern&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2669 </span>
2670 private:
<span class="line-modified">2671     WEBCORE_EXPORT ApplyFillPattern();</span>



2672 
2673     void apply(GraphicsContext&amp;) const override;
2674 };
<span class="line-added">2675 </span>
<span class="line-added">2676 template&lt;class Encoder&gt;</span>
<span class="line-added">2677 void ApplyFillPattern::encode(Encoder&amp;) const</span>
<span class="line-added">2678 {</span>
<span class="line-added">2679 }</span>
<span class="line-added">2680 </span>
<span class="line-added">2681 template&lt;class Decoder&gt;</span>
<span class="line-added">2682 Optional&lt;Ref&lt;ApplyFillPattern&gt;&gt; ApplyFillPattern::decode(Decoder&amp;)</span>
<span class="line-added">2683 {</span>
<span class="line-added">2684     return ApplyFillPattern::create();</span>
<span class="line-added">2685 }</span>
2686 #endif
2687 
2688 class ApplyDeviceScaleFactor : public Item {
2689 public:
2690     static Ref&lt;ApplyDeviceScaleFactor&gt; create(float scaleFactor)
2691     {
2692         return adoptRef(*new ApplyDeviceScaleFactor(scaleFactor));
2693     }
2694 
<span class="line-added">2695     WEBCORE_EXPORT virtual ~ApplyDeviceScaleFactor();</span>
<span class="line-added">2696 </span>
2697     float scaleFactor() const { return m_scaleFactor; }
2698 
<span class="line-added">2699     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">2700     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ApplyDeviceScaleFactor&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">2701 </span>
2702 private:
<span class="line-modified">2703     WEBCORE_EXPORT ApplyDeviceScaleFactor(float scaleFactor);</span>




2704 
2705     void apply(GraphicsContext&amp;) const override;
2706 
2707     float m_scaleFactor;
2708 };
2709 
<span class="line-added">2710 template&lt;class Encoder&gt;</span>
<span class="line-added">2711 void ApplyDeviceScaleFactor::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2712 {</span>
<span class="line-added">2713     encoder &lt;&lt; m_scaleFactor;</span>
<span class="line-added">2714 }</span>
<span class="line-added">2715 </span>
<span class="line-added">2716 template&lt;class Decoder&gt;</span>
<span class="line-added">2717 Optional&lt;Ref&lt;ApplyDeviceScaleFactor&gt;&gt; ApplyDeviceScaleFactor::decode(Decoder&amp; decoder)</span>
<span class="line-added">2718 {</span>
<span class="line-added">2719     Optional&lt;float&gt; scaleFactor;</span>
<span class="line-added">2720     decoder &gt;&gt; scaleFactor;</span>
<span class="line-added">2721     if (!scaleFactor)</span>
<span class="line-added">2722         return WTF::nullopt;</span>
<span class="line-added">2723 </span>
<span class="line-added">2724     return ApplyDeviceScaleFactor::create(*scaleFactor);</span>
<span class="line-added">2725 }</span>
<span class="line-added">2726 </span>
<span class="line-added">2727 </span>
2728 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Item&amp;);
2729 
<span class="line-added">2730 template&lt;class Encoder&gt;</span>
<span class="line-added">2731 void Item::encode(Encoder&amp; encoder) const</span>
<span class="line-added">2732 {</span>
<span class="line-added">2733     encoder &lt;&lt; m_type;</span>
<span class="line-added">2734 </span>
<span class="line-added">2735     switch (m_type) {</span>
<span class="line-added">2736     case ItemType::Save:</span>
<span class="line-added">2737         encoder &lt;&lt; downcast&lt;Save&gt;(*this);</span>
<span class="line-added">2738         break;</span>
<span class="line-added">2739     case ItemType::Restore:</span>
<span class="line-added">2740         encoder &lt;&lt; downcast&lt;Restore&gt;(*this);</span>
<span class="line-added">2741         break;</span>
<span class="line-added">2742     case ItemType::Translate:</span>
<span class="line-added">2743         encoder &lt;&lt; downcast&lt;Translate&gt;(*this);</span>
<span class="line-added">2744         break;</span>
<span class="line-added">2745     case ItemType::Rotate:</span>
<span class="line-added">2746         encoder &lt;&lt; downcast&lt;Rotate&gt;(*this);</span>
<span class="line-added">2747         break;</span>
<span class="line-added">2748     case ItemType::Scale:</span>
<span class="line-added">2749         encoder &lt;&lt; downcast&lt;Scale&gt;(*this);</span>
<span class="line-added">2750         break;</span>
<span class="line-added">2751     case ItemType::SetCTM:</span>
<span class="line-added">2752         encoder &lt;&lt; downcast&lt;SetCTM&gt;(*this);</span>
<span class="line-added">2753         break;</span>
<span class="line-added">2754     case ItemType::ConcatenateCTM:</span>
<span class="line-added">2755         encoder &lt;&lt; downcast&lt;ConcatenateCTM&gt;(*this);</span>
<span class="line-added">2756         break;</span>
<span class="line-added">2757     case ItemType::SetState:</span>
<span class="line-added">2758         encoder &lt;&lt; downcast&lt;SetState&gt;(*this);</span>
<span class="line-added">2759         break;</span>
<span class="line-added">2760     case ItemType::SetLineCap:</span>
<span class="line-added">2761         encoder &lt;&lt; downcast&lt;SetLineCap&gt;(*this);</span>
<span class="line-added">2762         break;</span>
<span class="line-added">2763     case ItemType::SetLineDash:</span>
<span class="line-added">2764         encoder &lt;&lt; downcast&lt;SetLineDash&gt;(*this);</span>
<span class="line-added">2765         break;</span>
<span class="line-added">2766     case ItemType::SetLineJoin:</span>
<span class="line-added">2767         encoder &lt;&lt; downcast&lt;SetLineJoin&gt;(*this);</span>
<span class="line-added">2768         break;</span>
<span class="line-added">2769     case ItemType::SetMiterLimit:</span>
<span class="line-added">2770         encoder &lt;&lt; downcast&lt;SetMiterLimit&gt;(*this);</span>
<span class="line-added">2771         break;</span>
<span class="line-added">2772     case ItemType::ClearShadow:</span>
<span class="line-added">2773         encoder &lt;&lt; downcast&lt;ClearShadow&gt;(*this);</span>
<span class="line-added">2774         break;</span>
<span class="line-added">2775     case ItemType::Clip:</span>
<span class="line-added">2776         encoder &lt;&lt; downcast&lt;Clip&gt;(*this);</span>
<span class="line-added">2777         break;</span>
<span class="line-added">2778     case ItemType::ClipOut:</span>
<span class="line-added">2779         encoder &lt;&lt; downcast&lt;ClipOut&gt;(*this);</span>
<span class="line-added">2780         break;</span>
<span class="line-added">2781     case ItemType::ClipOutToPath:</span>
<span class="line-added">2782         encoder &lt;&lt; downcast&lt;ClipOutToPath&gt;(*this);</span>
<span class="line-added">2783         break;</span>
<span class="line-added">2784     case ItemType::ClipPath:</span>
<span class="line-added">2785         encoder &lt;&lt; downcast&lt;ClipPath&gt;(*this);</span>
<span class="line-added">2786         break;</span>
<span class="line-added">2787     case ItemType::DrawGlyphs:</span>
<span class="line-added">2788         encoder &lt;&lt; downcast&lt;DrawGlyphs&gt;(*this);</span>
<span class="line-added">2789         break;</span>
<span class="line-added">2790     case ItemType::DrawImage:</span>
<span class="line-added">2791         encoder &lt;&lt; downcast&lt;DrawImage&gt;(*this);</span>
<span class="line-added">2792         break;</span>
<span class="line-added">2793     case ItemType::DrawTiledImage:</span>
<span class="line-added">2794         encoder &lt;&lt; downcast&lt;DrawTiledImage&gt;(*this);</span>
<span class="line-added">2795         break;</span>
<span class="line-added">2796     case ItemType::DrawTiledScaledImage:</span>
<span class="line-added">2797         encoder &lt;&lt; downcast&lt;DrawTiledScaledImage&gt;(*this);</span>
<span class="line-added">2798         break;</span>
<span class="line-added">2799 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)</span>
<span class="line-added">2800     case ItemType::DrawNativeImage:</span>
<span class="line-added">2801         encoder &lt;&lt; downcast&lt;DrawNativeImage&gt;(*this);</span>
<span class="line-added">2802         break;</span>
<span class="line-added">2803 #endif</span>
<span class="line-added">2804     case ItemType::DrawPattern:</span>
<span class="line-added">2805         encoder &lt;&lt; downcast&lt;DrawPattern&gt;(*this);</span>
<span class="line-added">2806         break;</span>
<span class="line-added">2807     case ItemType::DrawRect:</span>
<span class="line-added">2808         encoder &lt;&lt; downcast&lt;DrawRect&gt;(*this);</span>
<span class="line-added">2809         break;</span>
<span class="line-added">2810     case ItemType::DrawLine:</span>
<span class="line-added">2811         encoder &lt;&lt; downcast&lt;DrawLine&gt;(*this);</span>
<span class="line-added">2812         break;</span>
<span class="line-added">2813     case ItemType::DrawLinesForText:</span>
<span class="line-added">2814         encoder &lt;&lt; downcast&lt;DrawLinesForText&gt;(*this);</span>
<span class="line-added">2815         break;</span>
<span class="line-added">2816     case ItemType::DrawDotsForDocumentMarker:</span>
<span class="line-added">2817         encoder &lt;&lt; downcast&lt;DrawDotsForDocumentMarker&gt;(*this);</span>
<span class="line-added">2818         break;</span>
<span class="line-added">2819     case ItemType::DrawEllipse:</span>
<span class="line-added">2820         encoder &lt;&lt; downcast&lt;DrawEllipse&gt;(*this);</span>
<span class="line-added">2821         break;</span>
<span class="line-added">2822     case ItemType::DrawPath:</span>
<span class="line-added">2823         encoder &lt;&lt; downcast&lt;DrawPath&gt;(*this);</span>
<span class="line-added">2824         break;</span>
<span class="line-added">2825     case ItemType::DrawFocusRingPath:</span>
<span class="line-added">2826         encoder &lt;&lt; downcast&lt;DrawFocusRingPath&gt;(*this);</span>
<span class="line-added">2827         break;</span>
<span class="line-added">2828     case ItemType::DrawFocusRingRects:</span>
<span class="line-added">2829         encoder &lt;&lt; downcast&lt;DrawFocusRingRects&gt;(*this);</span>
<span class="line-added">2830         break;</span>
<span class="line-added">2831     case ItemType::FillRect:</span>
<span class="line-added">2832         encoder &lt;&lt; downcast&lt;FillRect&gt;(*this);</span>
<span class="line-added">2833         break;</span>
<span class="line-added">2834     case ItemType::FillRectWithColor:</span>
<span class="line-added">2835         encoder &lt;&lt; downcast&lt;FillRectWithColor&gt;(*this);</span>
<span class="line-added">2836         break;</span>
<span class="line-added">2837     case ItemType::FillRectWithGradient:</span>
<span class="line-added">2838         encoder &lt;&lt; downcast&lt;FillRectWithGradient&gt;(*this);</span>
<span class="line-added">2839         break;</span>
<span class="line-added">2840     case ItemType::FillCompositedRect:</span>
<span class="line-added">2841         encoder &lt;&lt; downcast&lt;FillCompositedRect&gt;(*this);</span>
<span class="line-added">2842         break;</span>
<span class="line-added">2843     case ItemType::FillRoundedRect:</span>
<span class="line-added">2844         encoder &lt;&lt; downcast&lt;FillRoundedRect&gt;(*this);</span>
<span class="line-added">2845         break;</span>
<span class="line-added">2846     case ItemType::FillRectWithRoundedHole:</span>
<span class="line-added">2847         encoder &lt;&lt; downcast&lt;FillRectWithRoundedHole&gt;(*this);</span>
<span class="line-added">2848         break;</span>
<span class="line-added">2849     case ItemType::FillPath:</span>
<span class="line-added">2850         encoder &lt;&lt; downcast&lt;FillPath&gt;(*this);</span>
<span class="line-added">2851         break;</span>
<span class="line-added">2852     case ItemType::FillEllipse:</span>
<span class="line-added">2853         encoder &lt;&lt; downcast&lt;FillEllipse&gt;(*this);</span>
<span class="line-added">2854         break;</span>
<span class="line-added">2855     case ItemType::StrokeRect:</span>
<span class="line-added">2856         encoder &lt;&lt; downcast&lt;StrokeRect&gt;(*this);</span>
<span class="line-added">2857         break;</span>
<span class="line-added">2858     case ItemType::StrokePath:</span>
<span class="line-added">2859         encoder &lt;&lt; downcast&lt;StrokePath&gt;(*this);</span>
<span class="line-added">2860         break;</span>
<span class="line-added">2861     case ItemType::StrokeEllipse:</span>
<span class="line-added">2862         encoder &lt;&lt; downcast&lt;StrokeEllipse&gt;(*this);</span>
<span class="line-added">2863         break;</span>
<span class="line-added">2864     case ItemType::ClearRect:</span>
<span class="line-added">2865         encoder &lt;&lt; downcast&lt;ClearRect&gt;(*this);</span>
<span class="line-added">2866         break;</span>
<span class="line-added">2867     case ItemType::BeginTransparencyLayer:</span>
<span class="line-added">2868         encoder &lt;&lt; downcast&lt;BeginTransparencyLayer&gt;(*this);</span>
<span class="line-added">2869         break;</span>
<span class="line-added">2870     case ItemType::EndTransparencyLayer:</span>
<span class="line-added">2871         encoder &lt;&lt; downcast&lt;EndTransparencyLayer&gt;(*this);</span>
<span class="line-added">2872         break;</span>
<span class="line-added">2873 #if USE(CG)</span>
<span class="line-added">2874     case ItemType::ApplyStrokePattern:</span>
<span class="line-added">2875         encoder &lt;&lt; downcast&lt;ApplyStrokePattern&gt;(*this);</span>
<span class="line-added">2876         break;</span>
<span class="line-added">2877     case ItemType::ApplyFillPattern:</span>
<span class="line-added">2878         encoder &lt;&lt; downcast&lt;ApplyFillPattern&gt;(*this);</span>
<span class="line-added">2879         break;</span>
<span class="line-added">2880 #endif</span>
<span class="line-added">2881     case ItemType::ApplyDeviceScaleFactor:</span>
<span class="line-added">2882         encoder &lt;&lt; downcast&lt;ApplyDeviceScaleFactor&gt;(*this);</span>
<span class="line-added">2883         break;</span>
<span class="line-added">2884     }</span>
<span class="line-added">2885 }</span>
<span class="line-added">2886 </span>
<span class="line-added">2887 template&lt;class Decoder&gt;</span>
<span class="line-added">2888 Optional&lt;Ref&lt;Item&gt;&gt; Item::decode(Decoder&amp; decoder)</span>
<span class="line-added">2889 {</span>
<span class="line-added">2890     Optional&lt;ItemType&gt; itemType;</span>
<span class="line-added">2891     decoder &gt;&gt; itemType;</span>
<span class="line-added">2892     if (!itemType)</span>
<span class="line-added">2893         return WTF::nullopt;</span>
<span class="line-added">2894 </span>
<span class="line-added">2895     switch (*itemType) {</span>
<span class="line-added">2896     case ItemType::Save:</span>
<span class="line-added">2897         if (auto item = Save::decode(decoder))</span>
<span class="line-added">2898             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2899         break;</span>
<span class="line-added">2900     case ItemType::Restore:</span>
<span class="line-added">2901         if (auto item = Restore::decode(decoder))</span>
<span class="line-added">2902             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2903         break;</span>
<span class="line-added">2904     case ItemType::Translate:</span>
<span class="line-added">2905         if (auto item = Translate::decode(decoder))</span>
<span class="line-added">2906             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2907         break;</span>
<span class="line-added">2908     case ItemType::Rotate:</span>
<span class="line-added">2909         if (auto item = Rotate::decode(decoder))</span>
<span class="line-added">2910             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2911         break;</span>
<span class="line-added">2912     case ItemType::Scale:</span>
<span class="line-added">2913         if (auto item = Scale::decode(decoder))</span>
<span class="line-added">2914             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2915         break;</span>
<span class="line-added">2916     case ItemType::SetCTM:</span>
<span class="line-added">2917         if (auto item = SetCTM::decode(decoder))</span>
<span class="line-added">2918             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2919         break;</span>
<span class="line-added">2920     case ItemType::ConcatenateCTM:</span>
<span class="line-added">2921         if (auto item = ConcatenateCTM::decode(decoder))</span>
<span class="line-added">2922             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2923         break;</span>
<span class="line-added">2924     case ItemType::SetState:</span>
<span class="line-added">2925         if (auto item = SetState::decode(decoder))</span>
<span class="line-added">2926             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2927         break;</span>
<span class="line-added">2928     case ItemType::SetLineCap:</span>
<span class="line-added">2929         if (auto item = SetLineCap::decode(decoder))</span>
<span class="line-added">2930             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2931         break;</span>
<span class="line-added">2932     case ItemType::SetLineDash:</span>
<span class="line-added">2933         if (auto item = SetLineDash::decode(decoder))</span>
<span class="line-added">2934             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2935         break;</span>
<span class="line-added">2936     case ItemType::SetLineJoin:</span>
<span class="line-added">2937         if (auto item = SetLineJoin::decode(decoder))</span>
<span class="line-added">2938             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2939         break;</span>
<span class="line-added">2940     case ItemType::SetMiterLimit:</span>
<span class="line-added">2941         if (auto item = SetMiterLimit::decode(decoder))</span>
<span class="line-added">2942             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2943         break;</span>
<span class="line-added">2944     case ItemType::ClearShadow:</span>
<span class="line-added">2945         if (auto item = ClearShadow::decode(decoder))</span>
<span class="line-added">2946             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2947         break;</span>
<span class="line-added">2948     case ItemType::Clip:</span>
<span class="line-added">2949         if (auto item = Clip::decode(decoder))</span>
<span class="line-added">2950             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2951         break;</span>
<span class="line-added">2952     case ItemType::ClipOut:</span>
<span class="line-added">2953         if (auto item = ClipOut::decode(decoder))</span>
<span class="line-added">2954             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2955         break;</span>
<span class="line-added">2956     case ItemType::ClipOutToPath:</span>
<span class="line-added">2957         if (auto item = ClipOutToPath::decode(decoder))</span>
<span class="line-added">2958             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2959         break;</span>
<span class="line-added">2960     case ItemType::ClipPath:</span>
<span class="line-added">2961         if (auto item = ClipPath::decode(decoder))</span>
<span class="line-added">2962             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2963         break;</span>
<span class="line-added">2964     case ItemType::DrawGlyphs:</span>
<span class="line-added">2965         if (auto item = DrawGlyphs::decode(decoder))</span>
<span class="line-added">2966             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2967         break;</span>
<span class="line-added">2968     case ItemType::DrawImage:</span>
<span class="line-added">2969         if (auto item = DrawImage::decode(decoder))</span>
<span class="line-added">2970             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2971         break;</span>
<span class="line-added">2972     case ItemType::DrawTiledImage:</span>
<span class="line-added">2973         if (auto item = DrawTiledImage::decode(decoder))</span>
<span class="line-added">2974             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2975         break;</span>
<span class="line-added">2976     case ItemType::DrawTiledScaledImage:</span>
<span class="line-added">2977         if (auto item = DrawTiledScaledImage::decode(decoder))</span>
<span class="line-added">2978             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2979         break;</span>
<span class="line-added">2980 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)</span>
<span class="line-added">2981     case ItemType::DrawNativeImage:</span>
<span class="line-added">2982         if (auto item = DrawNativeImage::decode(decoder))</span>
<span class="line-added">2983             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2984         break;</span>
<span class="line-added">2985 #endif</span>
<span class="line-added">2986     case ItemType::DrawPattern:</span>
<span class="line-added">2987         if (auto item = DrawPattern::decode(decoder))</span>
<span class="line-added">2988             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2989         break;</span>
<span class="line-added">2990     case ItemType::DrawRect:</span>
<span class="line-added">2991         if (auto item = DrawRect::decode(decoder))</span>
<span class="line-added">2992             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2993         break;</span>
<span class="line-added">2994     case ItemType::DrawLine:</span>
<span class="line-added">2995         if (auto item = DrawLine::decode(decoder))</span>
<span class="line-added">2996             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">2997         break;</span>
<span class="line-added">2998     case ItemType::DrawLinesForText:</span>
<span class="line-added">2999         if (auto item = DrawLinesForText::decode(decoder))</span>
<span class="line-added">3000             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3001         break;</span>
<span class="line-added">3002     case ItemType::DrawDotsForDocumentMarker:</span>
<span class="line-added">3003         if (auto item = DrawDotsForDocumentMarker::decode(decoder))</span>
<span class="line-added">3004             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3005         break;</span>
<span class="line-added">3006     case ItemType::DrawEllipse:</span>
<span class="line-added">3007         if (auto item = DrawEllipse::decode(decoder))</span>
<span class="line-added">3008             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3009         break;</span>
<span class="line-added">3010     case ItemType::DrawPath:</span>
<span class="line-added">3011         if (auto item = DrawPath::decode(decoder))</span>
<span class="line-added">3012             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3013         break;</span>
<span class="line-added">3014     case ItemType::DrawFocusRingPath:</span>
<span class="line-added">3015         if (auto item = DrawFocusRingPath::decode(decoder))</span>
<span class="line-added">3016             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3017         break;</span>
<span class="line-added">3018     case ItemType::DrawFocusRingRects:</span>
<span class="line-added">3019         if (auto item = DrawFocusRingRects::decode(decoder))</span>
<span class="line-added">3020             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3021         break;</span>
<span class="line-added">3022     case ItemType::FillRect:</span>
<span class="line-added">3023         if (auto item = FillRect::decode(decoder))</span>
<span class="line-added">3024             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3025         break;</span>
<span class="line-added">3026     case ItemType::FillRectWithColor:</span>
<span class="line-added">3027         if (auto item = FillRectWithColor::decode(decoder))</span>
<span class="line-added">3028             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3029         break;</span>
<span class="line-added">3030     case ItemType::FillRectWithGradient:</span>
<span class="line-added">3031         if (auto item = FillRectWithGradient::decode(decoder))</span>
<span class="line-added">3032             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3033         break;</span>
<span class="line-added">3034     case ItemType::FillCompositedRect:</span>
<span class="line-added">3035         if (auto item = FillCompositedRect::decode(decoder))</span>
<span class="line-added">3036             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3037         break;</span>
<span class="line-added">3038     case ItemType::FillRoundedRect:</span>
<span class="line-added">3039         if (auto item = FillRoundedRect::decode(decoder))</span>
<span class="line-added">3040             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3041         break;</span>
<span class="line-added">3042     case ItemType::FillRectWithRoundedHole:</span>
<span class="line-added">3043         if (auto item = FillRectWithRoundedHole::decode(decoder))</span>
<span class="line-added">3044             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3045         break;</span>
<span class="line-added">3046     case ItemType::FillPath:</span>
<span class="line-added">3047         if (auto item = FillPath::decode(decoder))</span>
<span class="line-added">3048             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3049         break;</span>
<span class="line-added">3050     case ItemType::FillEllipse:</span>
<span class="line-added">3051         if (auto item = FillEllipse::decode(decoder))</span>
<span class="line-added">3052             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3053         break;</span>
<span class="line-added">3054     case ItemType::StrokeRect:</span>
<span class="line-added">3055         if (auto item = StrokeRect::decode(decoder))</span>
<span class="line-added">3056             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3057         break;</span>
<span class="line-added">3058     case ItemType::StrokePath:</span>
<span class="line-added">3059         if (auto item = StrokePath::decode(decoder))</span>
<span class="line-added">3060             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3061         break;</span>
<span class="line-added">3062     case ItemType::StrokeEllipse:</span>
<span class="line-added">3063         if (auto item = StrokeEllipse::decode(decoder))</span>
<span class="line-added">3064             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3065         break;</span>
<span class="line-added">3066     case ItemType::ClearRect:</span>
<span class="line-added">3067         if (auto item = ClearRect::decode(decoder))</span>
<span class="line-added">3068             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3069         break;</span>
<span class="line-added">3070     case ItemType::BeginTransparencyLayer:</span>
<span class="line-added">3071         if (auto item = BeginTransparencyLayer::decode(decoder))</span>
<span class="line-added">3072             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3073         break;</span>
<span class="line-added">3074     case ItemType::EndTransparencyLayer:</span>
<span class="line-added">3075         if (auto item = EndTransparencyLayer::decode(decoder))</span>
<span class="line-added">3076             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3077         break;</span>
<span class="line-added">3078 #if USE(CG)</span>
<span class="line-added">3079     case ItemType::ApplyStrokePattern:</span>
<span class="line-added">3080         if (auto item = ApplyStrokePattern::decode(decoder))</span>
<span class="line-added">3081             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3082         break;</span>
<span class="line-added">3083     case ItemType::ApplyFillPattern:</span>
<span class="line-added">3084         if (auto item = ApplyFillPattern::decode(decoder))</span>
<span class="line-added">3085             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3086         break;</span>
<span class="line-added">3087 #endif</span>
<span class="line-added">3088     case ItemType::ApplyDeviceScaleFactor:</span>
<span class="line-added">3089         if (auto item = ApplyDeviceScaleFactor::decode(decoder))</span>
<span class="line-added">3090             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">3091         break;</span>
<span class="line-added">3092     }</span>
<span class="line-added">3093 </span>
<span class="line-added">3094     return WTF::nullopt;</span>
<span class="line-added">3095 }</span>
<span class="line-added">3096 </span>
3097 } // namespace DisplayList
3098 } // namespace WebCore
3099 
3100 
3101 #define SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_DRAWINGITEM(ToValueTypeName, predicate) \
3102 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::DisplayList::ToValueTypeName) \
3103     static bool isType(const WebCore::DisplayList::Item&amp; object) { return object.predicate; } \
3104 SPECIALIZE_TYPE_TRAITS_END()
3105 
3106 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_DRAWINGITEM(DrawingItem, isDrawingItem())
3107 
3108 #define SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ToValueTypeName) \
3109 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::DisplayList::ToValueTypeName) \
3110     static bool isType(const WebCore::DisplayList::Item&amp; item) { return item.type() == WebCore::DisplayList::ItemType::ToValueTypeName; } \
3111 SPECIALIZE_TYPE_TRAITS_END()
3112 
3113 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Save)
3114 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Restore)
3115 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Translate)
3116 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Rotate)
3117 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Scale)
<span class="line-added">3118 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetCTM)</span>
3119 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ConcatenateCTM)
3120 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetState)
3121 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineCap)
3122 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineDash)
3123 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineJoin)
3124 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetMiterLimit)
3125 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Clip)
3126 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClipOut)
3127 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClipOutToPath)
3128 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClipPath)
3129 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawGlyphs)
3130 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawImage)
3131 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawTiledImage)
3132 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawTiledScaledImage)
3133 #if USE(CG) || USE(CAIRO)
3134 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawNativeImage)
3135 #endif
3136 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawPattern)
3137 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawRect)
3138 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawLine)
</pre>
<hr />
<pre>
3146 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRectWithColor)
3147 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRectWithGradient)
3148 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillCompositedRect)
3149 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRoundedRect)
3150 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRectWithRoundedHole)
3151 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillPath)
3152 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillEllipse)
3153 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(StrokeRect)
3154 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(StrokePath)
3155 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(StrokeEllipse)
3156 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClearRect)
3157 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(BeginTransparencyLayer)
3158 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(EndTransparencyLayer)
3159 #if USE(CG)
3160 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyStrokePattern)
3161 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyFillPattern)
3162 #endif
3163 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyDeviceScaleFactor)
3164 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClearShadow)
3165 
<span class="line-added">3166 namespace WTF {</span>
<span class="line-added">3167 </span>
<span class="line-added">3168 template&lt;&gt; struct EnumTraits&lt;WebCore::DisplayList::ItemType&gt; {</span>
<span class="line-added">3169     using values = EnumValues&lt;</span>
<span class="line-added">3170     WebCore::DisplayList::ItemType,</span>
<span class="line-added">3171     WebCore::DisplayList::ItemType::Save,</span>
<span class="line-added">3172     WebCore::DisplayList::ItemType::Restore,</span>
<span class="line-added">3173     WebCore::DisplayList::ItemType::Translate,</span>
<span class="line-added">3174     WebCore::DisplayList::ItemType::Rotate,</span>
<span class="line-added">3175     WebCore::DisplayList::ItemType::Scale,</span>
<span class="line-added">3176     WebCore::DisplayList::ItemType::SetCTM,</span>
<span class="line-added">3177     WebCore::DisplayList::ItemType::ConcatenateCTM,</span>
<span class="line-added">3178     WebCore::DisplayList::ItemType::SetState,</span>
<span class="line-added">3179     WebCore::DisplayList::ItemType::SetLineCap,</span>
<span class="line-added">3180     WebCore::DisplayList::ItemType::SetLineDash,</span>
<span class="line-added">3181     WebCore::DisplayList::ItemType::SetLineJoin,</span>
<span class="line-added">3182     WebCore::DisplayList::ItemType::SetMiterLimit,</span>
<span class="line-added">3183     WebCore::DisplayList::ItemType::ClearShadow,</span>
<span class="line-added">3184     WebCore::DisplayList::ItemType::Clip,</span>
<span class="line-added">3185     WebCore::DisplayList::ItemType::ClipOut,</span>
<span class="line-added">3186     WebCore::DisplayList::ItemType::ClipOutToPath,</span>
<span class="line-added">3187     WebCore::DisplayList::ItemType::ClipPath,</span>
<span class="line-added">3188     WebCore::DisplayList::ItemType::DrawGlyphs,</span>
<span class="line-added">3189     WebCore::DisplayList::ItemType::DrawImage,</span>
<span class="line-added">3190     WebCore::DisplayList::ItemType::DrawTiledImage,</span>
<span class="line-added">3191     WebCore::DisplayList::ItemType::DrawTiledScaledImage,</span>
<span class="line-added">3192 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)</span>
<span class="line-added">3193     WebCore::DisplayList::ItemType::DrawNativeImage,</span>
<span class="line-added">3194 #endif</span>
<span class="line-added">3195     WebCore::DisplayList::ItemType::DrawPattern,</span>
<span class="line-added">3196     WebCore::DisplayList::ItemType::DrawRect,</span>
<span class="line-added">3197     WebCore::DisplayList::ItemType::DrawLine,</span>
<span class="line-added">3198     WebCore::DisplayList::ItemType::DrawLinesForText,</span>
<span class="line-added">3199     WebCore::DisplayList::ItemType::DrawDotsForDocumentMarker,</span>
<span class="line-added">3200     WebCore::DisplayList::ItemType::DrawEllipse,</span>
<span class="line-added">3201     WebCore::DisplayList::ItemType::DrawPath,</span>
<span class="line-added">3202     WebCore::DisplayList::ItemType::DrawFocusRingPath,</span>
<span class="line-added">3203     WebCore::DisplayList::ItemType::DrawFocusRingRects,</span>
<span class="line-added">3204     WebCore::DisplayList::ItemType::FillRect,</span>
<span class="line-added">3205     WebCore::DisplayList::ItemType::FillRectWithColor,</span>
<span class="line-added">3206     WebCore::DisplayList::ItemType::FillRectWithGradient,</span>
<span class="line-added">3207     WebCore::DisplayList::ItemType::FillCompositedRect,</span>
<span class="line-added">3208     WebCore::DisplayList::ItemType::FillRoundedRect,</span>
<span class="line-added">3209     WebCore::DisplayList::ItemType::FillRectWithRoundedHole,</span>
<span class="line-added">3210     WebCore::DisplayList::ItemType::FillPath,</span>
<span class="line-added">3211     WebCore::DisplayList::ItemType::FillEllipse,</span>
<span class="line-added">3212     WebCore::DisplayList::ItemType::StrokeRect,</span>
<span class="line-added">3213     WebCore::DisplayList::ItemType::StrokePath,</span>
<span class="line-added">3214     WebCore::DisplayList::ItemType::StrokeEllipse,</span>
<span class="line-added">3215     WebCore::DisplayList::ItemType::ClearRect,</span>
<span class="line-added">3216     WebCore::DisplayList::ItemType::BeginTransparencyLayer,</span>
<span class="line-added">3217     WebCore::DisplayList::ItemType::EndTransparencyLayer,</span>
<span class="line-added">3218 #if USE(CG)</span>
<span class="line-added">3219     WebCore::DisplayList::ItemType::ApplyStrokePattern,</span>
<span class="line-added">3220     WebCore::DisplayList::ItemType::ApplyFillPattern,</span>
<span class="line-added">3221 #endif</span>
<span class="line-added">3222     WebCore::DisplayList::ItemType::ApplyDeviceScaleFactor</span>
<span class="line-added">3223     &gt;;</span>
<span class="line-added">3224 };</span>
<span class="line-added">3225 </span>
<span class="line-added">3226 } // namespace WTF</span>
</pre>
</td>
</tr>
</table>
<center><a href="DisplayListItems.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DisplayListRecorder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
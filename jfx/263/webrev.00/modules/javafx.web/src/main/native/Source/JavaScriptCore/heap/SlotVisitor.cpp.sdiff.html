<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/SlotVisitor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PackedCellPtr.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SlotVisitor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/SlotVisitor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SlotVisitor.h&quot;
 28 
 29 #include &quot;BlockDirectoryInlines.h&quot;
 30 #include &quot;CPU.h&quot;
 31 #include &quot;ConservativeRoots.h&quot;
 32 #include &quot;GCSegmentedArrayInlines.h&quot;
 33 #include &quot;HeapAnalyzer.h&quot;
 34 #include &quot;HeapCellInlines.h&quot;
 35 #include &quot;HeapProfiler.h&quot;

 36 #include &quot;JSArray.h&quot;
 37 #include &quot;JSDestructibleObject.h&quot;
 38 #include &quot;JSObject.h&quot;
 39 #include &quot;JSString.h&quot;
 40 #include &quot;JSCInlines.h&quot;
 41 #include &quot;MarkedBlockInlines.h&quot;
 42 #include &quot;MarkingConstraintSolver.h&quot;
 43 #include &quot;SlotVisitorInlines.h&quot;
 44 #include &quot;StopIfNecessaryTimer.h&quot;
 45 #include &quot;SuperSampler.h&quot;
 46 #include &quot;VM.h&quot;
 47 #include &lt;wtf/ListDump.h&gt;
 48 #include &lt;wtf/Lock.h&gt;
 49 #include &lt;wtf/StdLibExtras.h&gt;
 50 
 51 namespace JSC {
 52 
 53 #if ENABLE(GC_VALIDATION)
 54 static void validate(JSCell* cell)
 55 {
</pre>
<hr />
<pre>
 71         if (cell-&gt;structure()-&gt;JSCell::classInfo(vm))
 72             ourClassName = cell-&gt;structure()-&gt;JSCell::classInfo(vm)-&gt;className;
 73         dataLogF(&quot;parent structure (%p &lt;%s&gt;) of cell at %p doesn&#39;t match cell&#39;s structure (%p &lt;%s&gt;)\n&quot;,
 74             cell-&gt;structure()-&gt;structure(), parentClassName, cell, cell-&gt;structure(), ourClassName);
 75         CRASH();
 76     }
 77 
 78     // Make sure we can walk the ClassInfo chain
 79     const ClassInfo* info = cell-&gt;classInfo(vm);
 80     do { } while ((info = info-&gt;parentClass));
 81 }
 82 #endif
 83 
 84 SlotVisitor::SlotVisitor(Heap&amp; heap, CString codeName)
 85     : m_bytesVisited(0)
 86     , m_visitCount(0)
 87     , m_isInParallelMode(false)
 88     , m_markingVersion(MarkedSpace::initialVersion)
 89     , m_heap(heap)
 90     , m_codeName(codeName)
<span class="line-modified"> 91 #if !ASSERT_DISABLED</span>
 92     , m_isCheckingForDefaultMarkViolation(false)
 93     , m_isDraining(false)
 94 #endif
 95 {
 96 }
 97 
 98 SlotVisitor::~SlotVisitor()
 99 {
100     clearMarkStacks();
101 }
102 
103 void SlotVisitor::didStartMarking()
104 {
105     auto scope = heap()-&gt;collectionScope();
106     if (scope) {
107         switch (*scope) {
108         case CollectionScope::Eden:
109             reset();
110             break;
111         case CollectionScope::Full:
</pre>
<hr />
<pre>
191         };
192 
193         // It&#39;s not OK for the structure to be null at any GC scan point. We must not GC while
194         // an object is not fully initialized.
195         if (!structureID)
196             die(&quot;GC scan found corrupt object: structureID is zero!\n&quot;);
197 
198         // It&#39;s not OK for the structure to be nuked at any GC scan point.
199         if (isNuked(structureID))
200             die(&quot;GC scan found object in bad state: structureID is nuked!\n&quot;);
201 
202 #if USE(JSVALUE64)
203         // This detects the worst of the badness.
204         if (!heap()-&gt;structureIDTable().isValid(structureID))
205             die(&quot;GC scan found corrupt object: structureID is invalid!\n&quot;);
206 #endif
207     };
208 
209     // In debug mode, we validate before marking since this makes it clearer what the problem
210     // was. It&#39;s also slower, so we don&#39;t do it normally.
<span class="line-modified">211     if (!ASSERT_DISABLED &amp;&amp; isJSCellKind(heapCell-&gt;cellKind()))</span>
212         validateCell(static_cast&lt;JSCell*&gt;(heapCell));
213 
214     if (Heap::testAndSetMarked(m_markingVersion, heapCell))
215         return;
216 
217     switch (heapCell-&gt;cellKind()) {
218     case HeapCell::JSCell:
219     case HeapCell::JSCellWithInteriorPointers: {
220         // We have ample budget to perform validation here.
221 
222         JSCell* jsCell = static_cast&lt;JSCell*&gt;(heapCell);
223         validateCell(jsCell);

224 
225         jsCell-&gt;setCellState(CellState::PossiblyGrey);
226 
227         appendToMarkStack(jsCell);
228         return;
229     }
230 
231     case HeapCell::Auxiliary: {
232         noteLiveAuxiliaryCell(heapCell);
233         return;
234     } }
235 }
236 
237 void SlotVisitor::appendSlow(JSCell* cell, Dependency dependency)
238 {
239     if (UNLIKELY(m_heapAnalyzer))
240         m_heapAnalyzer-&gt;analyzeEdge(m_currentCell, cell, m_rootMarkReason);
241 
242     appendHiddenSlowImpl(cell, dependency);
243 }
244 
245 void SlotVisitor::appendHiddenSlow(JSCell* cell, Dependency dependency)
246 {
247     appendHiddenSlowImpl(cell, dependency);
248 }
249 
250 ALWAYS_INLINE void SlotVisitor::appendHiddenSlowImpl(JSCell* cell, Dependency dependency)
251 {
252     ASSERT(!m_isCheckingForDefaultMarkViolation);
253 
254 #if ENABLE(GC_VALIDATION)
255     validate(cell);
256 #endif
257 
<span class="line-modified">258     if (cell-&gt;isLargeAllocation())</span>
<span class="line-modified">259         setMarkedAndAppendToMarkStack(cell-&gt;largeAllocation(), cell, dependency);</span>
260     else
261         setMarkedAndAppendToMarkStack(cell-&gt;markedBlock(), cell, dependency);
262 }
263 
264 template&lt;typename ContainerType&gt;
265 ALWAYS_INLINE void SlotVisitor::setMarkedAndAppendToMarkStack(ContainerType&amp; container, JSCell* cell, Dependency dependency)
266 {
267     if (container.testAndSetMarked(cell, dependency))
268         return;
269 
270     ASSERT(cell-&gt;structure());
271 
272     // Indicate that the object is grey and that:
273     // In case of concurrent GC: it&#39;s the first time it is grey in this GC cycle.
274     // In case of eden collection: it&#39;s a new object that became grey rather than an old remembered object.
275     cell-&gt;setCellState(CellState::PossiblyGrey);
276 
277     appendToMarkStack(container, cell);
278 }
279 
280 void SlotVisitor::appendToMarkStack(JSCell* cell)
281 {
<span class="line-modified">282     if (cell-&gt;isLargeAllocation())</span>
<span class="line-modified">283         appendToMarkStack(cell-&gt;largeAllocation(), cell);</span>
284     else
285         appendToMarkStack(cell-&gt;markedBlock(), cell);
286 }
287 
288 template&lt;typename ContainerType&gt;
289 ALWAYS_INLINE void SlotVisitor::appendToMarkStack(ContainerType&amp; container, JSCell* cell)
290 {
291     ASSERT(m_heap.isMarked(cell));
292 #if CPU(X86_64)
<span class="line-modified">293     if (Options::dumpZappedCellCrashData()) {</span>
294         if (UNLIKELY(cell-&gt;isZapped()))
295             reportZappedCellAndCrash(cell);
296     }
297 #endif
298     ASSERT(!cell-&gt;isZapped());
299 
300     container.noteMarked();
301 
302     m_visitCount++;
303     m_bytesVisited += container.cellSize();
304 
305     m_collectorStack.append(cell);
306 }
307 
308 void SlotVisitor::markAuxiliary(const void* base)
309 {
310     HeapCell* cell = bitwise_cast&lt;HeapCell*&gt;(base);
311 
312     ASSERT(cell-&gt;heap() == heap());
313 
</pre>
<hr />
<pre>
378 
379     WTF::storeLoadFence();
380 
381     switch (cell-&gt;type()) {
382     case StringType:
383         JSString::visitChildren(const_cast&lt;JSCell*&gt;(cell), *this);
384         break;
385 
386     case FinalObjectType:
387         JSFinalObject::visitChildren(const_cast&lt;JSCell*&gt;(cell), *this);
388         break;
389 
390     case ArrayType:
391         JSArray::visitChildren(const_cast&lt;JSCell*&gt;(cell), *this);
392         break;
393 
394     default:
395         // FIXME: This could be so much better.
396         // https://bugs.webkit.org/show_bug.cgi?id=162462
397 #if CPU(X86_64)
<span class="line-modified">398         if (Options::dumpZappedCellCrashData()) {</span>
399             Structure* structure = cell-&gt;structure(vm());
400             if (LIKELY(structure)) {
401                 const MethodTable* methodTable = &amp;structure-&gt;classInfo()-&gt;methodTable;
402                 methodTable-&gt;visitChildren(const_cast&lt;JSCell*&gt;(cell), *this);
403                 break;
404             }
405             reportZappedCellAndCrash(const_cast&lt;JSCell*&gt;(cell));
406         }
407 #endif
408         cell-&gt;methodTable(vm())-&gt;visitChildren(const_cast&lt;JSCell*&gt;(cell), *this);
409         break;
410     }
411 
412     if (UNLIKELY(m_heapAnalyzer)) {
413         if (m_isFirstVisit)
414             m_heapAnalyzer-&gt;analyzeNode(const_cast&lt;JSCell*&gt;(cell));
415     }
416 }
417 
418 void SlotVisitor::visitAsConstraint(const JSCell* cell)
</pre>
<hr />
<pre>
776 {
777     if (!m_isInParallelMode) {
778         dataLog(&quot;FATAL: Attempting to donate when not in parallel mode.\n&quot;);
779         RELEASE_ASSERT_NOT_REACHED();
780     }
781 
782     if (Options::numberOfGCMarkers() == 1)
783         return;
784 
785     donateKnownParallel();
786 }
787 
788 void SlotVisitor::donateAndDrain(MonotonicTime timeout)
789 {
790     donate();
791     drain(timeout);
792 }
793 
794 void SlotVisitor::didRace(const VisitRaceKey&amp; race)
795 {
<span class="line-modified">796     if (Options::verboseVisitRace())</span>
<span class="line-removed">797         dataLog(toCString(&quot;GC visit race: &quot;, race, &quot;\n&quot;));</span>
798 
799     auto locker = holdLock(heap()-&gt;m_raceMarkStackLock);
800     JSCell* cell = race.cell();
801     cell-&gt;setCellState(CellState::PossiblyGrey);
802     heap()-&gt;m_raceMarkStack-&gt;append(cell);
803 }
804 
805 void SlotVisitor::dump(PrintStream&amp; out) const
806 {
807     out.print(&quot;Collector: [&quot;, pointerListDump(collectorMarkStack()), &quot;], Mutator: [&quot;, pointerListDump(mutatorMarkStack()), &quot;]&quot;);
808 }
809 
810 MarkStackArray&amp; SlotVisitor::correspondingGlobalStack(MarkStackArray&amp; stack)
811 {
812     if (&amp;stack == &amp;m_collectorStack)
813         return *m_heap.m_sharedCollectorMarkStack;
814     RELEASE_ASSERT(&amp;stack == &amp;m_mutatorStack);
815     return *m_heap.m_sharedMutatorMarkStack;
816 }
817 
</pre>
</td>
<td>
<hr />
<pre>
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SlotVisitor.h&quot;
 28 
 29 #include &quot;BlockDirectoryInlines.h&quot;
 30 #include &quot;CPU.h&quot;
 31 #include &quot;ConservativeRoots.h&quot;
 32 #include &quot;GCSegmentedArrayInlines.h&quot;
 33 #include &quot;HeapAnalyzer.h&quot;
 34 #include &quot;HeapCellInlines.h&quot;
 35 #include &quot;HeapProfiler.h&quot;
<span class="line-added"> 36 #include &quot;IntegrityInlines.h&quot;</span>
 37 #include &quot;JSArray.h&quot;
 38 #include &quot;JSDestructibleObject.h&quot;
 39 #include &quot;JSObject.h&quot;
 40 #include &quot;JSString.h&quot;
 41 #include &quot;JSCInlines.h&quot;
 42 #include &quot;MarkedBlockInlines.h&quot;
 43 #include &quot;MarkingConstraintSolver.h&quot;
 44 #include &quot;SlotVisitorInlines.h&quot;
 45 #include &quot;StopIfNecessaryTimer.h&quot;
 46 #include &quot;SuperSampler.h&quot;
 47 #include &quot;VM.h&quot;
 48 #include &lt;wtf/ListDump.h&gt;
 49 #include &lt;wtf/Lock.h&gt;
 50 #include &lt;wtf/StdLibExtras.h&gt;
 51 
 52 namespace JSC {
 53 
 54 #if ENABLE(GC_VALIDATION)
 55 static void validate(JSCell* cell)
 56 {
</pre>
<hr />
<pre>
 72         if (cell-&gt;structure()-&gt;JSCell::classInfo(vm))
 73             ourClassName = cell-&gt;structure()-&gt;JSCell::classInfo(vm)-&gt;className;
 74         dataLogF(&quot;parent structure (%p &lt;%s&gt;) of cell at %p doesn&#39;t match cell&#39;s structure (%p &lt;%s&gt;)\n&quot;,
 75             cell-&gt;structure()-&gt;structure(), parentClassName, cell, cell-&gt;structure(), ourClassName);
 76         CRASH();
 77     }
 78 
 79     // Make sure we can walk the ClassInfo chain
 80     const ClassInfo* info = cell-&gt;classInfo(vm);
 81     do { } while ((info = info-&gt;parentClass));
 82 }
 83 #endif
 84 
 85 SlotVisitor::SlotVisitor(Heap&amp; heap, CString codeName)
 86     : m_bytesVisited(0)
 87     , m_visitCount(0)
 88     , m_isInParallelMode(false)
 89     , m_markingVersion(MarkedSpace::initialVersion)
 90     , m_heap(heap)
 91     , m_codeName(codeName)
<span class="line-modified"> 92 #if ASSERT_ENABLED</span>
 93     , m_isCheckingForDefaultMarkViolation(false)
 94     , m_isDraining(false)
 95 #endif
 96 {
 97 }
 98 
 99 SlotVisitor::~SlotVisitor()
100 {
101     clearMarkStacks();
102 }
103 
104 void SlotVisitor::didStartMarking()
105 {
106     auto scope = heap()-&gt;collectionScope();
107     if (scope) {
108         switch (*scope) {
109         case CollectionScope::Eden:
110             reset();
111             break;
112         case CollectionScope::Full:
</pre>
<hr />
<pre>
192         };
193 
194         // It&#39;s not OK for the structure to be null at any GC scan point. We must not GC while
195         // an object is not fully initialized.
196         if (!structureID)
197             die(&quot;GC scan found corrupt object: structureID is zero!\n&quot;);
198 
199         // It&#39;s not OK for the structure to be nuked at any GC scan point.
200         if (isNuked(structureID))
201             die(&quot;GC scan found object in bad state: structureID is nuked!\n&quot;);
202 
203 #if USE(JSVALUE64)
204         // This detects the worst of the badness.
205         if (!heap()-&gt;structureIDTable().isValid(structureID))
206             die(&quot;GC scan found corrupt object: structureID is invalid!\n&quot;);
207 #endif
208     };
209 
210     // In debug mode, we validate before marking since this makes it clearer what the problem
211     // was. It&#39;s also slower, so we don&#39;t do it normally.
<span class="line-modified">212     if (ASSERT_ENABLED &amp;&amp; isJSCellKind(heapCell-&gt;cellKind()))</span>
213         validateCell(static_cast&lt;JSCell*&gt;(heapCell));
214 
215     if (Heap::testAndSetMarked(m_markingVersion, heapCell))
216         return;
217 
218     switch (heapCell-&gt;cellKind()) {
219     case HeapCell::JSCell:
220     case HeapCell::JSCellWithInteriorPointers: {
221         // We have ample budget to perform validation here.
222 
223         JSCell* jsCell = static_cast&lt;JSCell*&gt;(heapCell);
224         validateCell(jsCell);
<span class="line-added">225         Integrity::auditCell(vm(), jsCell);</span>
226 
227         jsCell-&gt;setCellState(CellState::PossiblyGrey);
228 
229         appendToMarkStack(jsCell);
230         return;
231     }
232 
233     case HeapCell::Auxiliary: {
234         noteLiveAuxiliaryCell(heapCell);
235         return;
236     } }
237 }
238 
239 void SlotVisitor::appendSlow(JSCell* cell, Dependency dependency)
240 {
241     if (UNLIKELY(m_heapAnalyzer))
242         m_heapAnalyzer-&gt;analyzeEdge(m_currentCell, cell, m_rootMarkReason);
243 
244     appendHiddenSlowImpl(cell, dependency);
245 }
246 
247 void SlotVisitor::appendHiddenSlow(JSCell* cell, Dependency dependency)
248 {
249     appendHiddenSlowImpl(cell, dependency);
250 }
251 
252 ALWAYS_INLINE void SlotVisitor::appendHiddenSlowImpl(JSCell* cell, Dependency dependency)
253 {
254     ASSERT(!m_isCheckingForDefaultMarkViolation);
255 
256 #if ENABLE(GC_VALIDATION)
257     validate(cell);
258 #endif
259 
<span class="line-modified">260     if (cell-&gt;isPreciseAllocation())</span>
<span class="line-modified">261         setMarkedAndAppendToMarkStack(cell-&gt;preciseAllocation(), cell, dependency);</span>
262     else
263         setMarkedAndAppendToMarkStack(cell-&gt;markedBlock(), cell, dependency);
264 }
265 
266 template&lt;typename ContainerType&gt;
267 ALWAYS_INLINE void SlotVisitor::setMarkedAndAppendToMarkStack(ContainerType&amp; container, JSCell* cell, Dependency dependency)
268 {
269     if (container.testAndSetMarked(cell, dependency))
270         return;
271 
272     ASSERT(cell-&gt;structure());
273 
274     // Indicate that the object is grey and that:
275     // In case of concurrent GC: it&#39;s the first time it is grey in this GC cycle.
276     // In case of eden collection: it&#39;s a new object that became grey rather than an old remembered object.
277     cell-&gt;setCellState(CellState::PossiblyGrey);
278 
279     appendToMarkStack(container, cell);
280 }
281 
282 void SlotVisitor::appendToMarkStack(JSCell* cell)
283 {
<span class="line-modified">284     if (cell-&gt;isPreciseAllocation())</span>
<span class="line-modified">285         appendToMarkStack(cell-&gt;preciseAllocation(), cell);</span>
286     else
287         appendToMarkStack(cell-&gt;markedBlock(), cell);
288 }
289 
290 template&lt;typename ContainerType&gt;
291 ALWAYS_INLINE void SlotVisitor::appendToMarkStack(ContainerType&amp; container, JSCell* cell)
292 {
293     ASSERT(m_heap.isMarked(cell));
294 #if CPU(X86_64)
<span class="line-modified">295     if (UNLIKELY(Options::dumpZappedCellCrashData())) {</span>
296         if (UNLIKELY(cell-&gt;isZapped()))
297             reportZappedCellAndCrash(cell);
298     }
299 #endif
300     ASSERT(!cell-&gt;isZapped());
301 
302     container.noteMarked();
303 
304     m_visitCount++;
305     m_bytesVisited += container.cellSize();
306 
307     m_collectorStack.append(cell);
308 }
309 
310 void SlotVisitor::markAuxiliary(const void* base)
311 {
312     HeapCell* cell = bitwise_cast&lt;HeapCell*&gt;(base);
313 
314     ASSERT(cell-&gt;heap() == heap());
315 
</pre>
<hr />
<pre>
380 
381     WTF::storeLoadFence();
382 
383     switch (cell-&gt;type()) {
384     case StringType:
385         JSString::visitChildren(const_cast&lt;JSCell*&gt;(cell), *this);
386         break;
387 
388     case FinalObjectType:
389         JSFinalObject::visitChildren(const_cast&lt;JSCell*&gt;(cell), *this);
390         break;
391 
392     case ArrayType:
393         JSArray::visitChildren(const_cast&lt;JSCell*&gt;(cell), *this);
394         break;
395 
396     default:
397         // FIXME: This could be so much better.
398         // https://bugs.webkit.org/show_bug.cgi?id=162462
399 #if CPU(X86_64)
<span class="line-modified">400         if (UNLIKELY(Options::dumpZappedCellCrashData())) {</span>
401             Structure* structure = cell-&gt;structure(vm());
402             if (LIKELY(structure)) {
403                 const MethodTable* methodTable = &amp;structure-&gt;classInfo()-&gt;methodTable;
404                 methodTable-&gt;visitChildren(const_cast&lt;JSCell*&gt;(cell), *this);
405                 break;
406             }
407             reportZappedCellAndCrash(const_cast&lt;JSCell*&gt;(cell));
408         }
409 #endif
410         cell-&gt;methodTable(vm())-&gt;visitChildren(const_cast&lt;JSCell*&gt;(cell), *this);
411         break;
412     }
413 
414     if (UNLIKELY(m_heapAnalyzer)) {
415         if (m_isFirstVisit)
416             m_heapAnalyzer-&gt;analyzeNode(const_cast&lt;JSCell*&gt;(cell));
417     }
418 }
419 
420 void SlotVisitor::visitAsConstraint(const JSCell* cell)
</pre>
<hr />
<pre>
778 {
779     if (!m_isInParallelMode) {
780         dataLog(&quot;FATAL: Attempting to donate when not in parallel mode.\n&quot;);
781         RELEASE_ASSERT_NOT_REACHED();
782     }
783 
784     if (Options::numberOfGCMarkers() == 1)
785         return;
786 
787     donateKnownParallel();
788 }
789 
790 void SlotVisitor::donateAndDrain(MonotonicTime timeout)
791 {
792     donate();
793     drain(timeout);
794 }
795 
796 void SlotVisitor::didRace(const VisitRaceKey&amp; race)
797 {
<span class="line-modified">798     dataLogLnIf(Options::verboseVisitRace(), toCString(&quot;GC visit race: &quot;, race));</span>

799 
800     auto locker = holdLock(heap()-&gt;m_raceMarkStackLock);
801     JSCell* cell = race.cell();
802     cell-&gt;setCellState(CellState::PossiblyGrey);
803     heap()-&gt;m_raceMarkStack-&gt;append(cell);
804 }
805 
806 void SlotVisitor::dump(PrintStream&amp; out) const
807 {
808     out.print(&quot;Collector: [&quot;, pointerListDump(collectorMarkStack()), &quot;], Mutator: [&quot;, pointerListDump(mutatorMarkStack()), &quot;]&quot;);
809 }
810 
811 MarkStackArray&amp; SlotVisitor::correspondingGlobalStack(MarkStackArray&amp; stack)
812 {
813     if (&amp;stack == &amp;m_collectorStack)
814         return *m_heap.m_sharedCollectorMarkStack;
815     RELEASE_ASSERT(&amp;stack == &amp;m_mutatorStack);
816     return *m_heap.m_sharedMutatorMarkStack;
817 }
818 
</pre>
</td>
</tr>
</table>
<center><a href="PackedCellPtr.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SlotVisitor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
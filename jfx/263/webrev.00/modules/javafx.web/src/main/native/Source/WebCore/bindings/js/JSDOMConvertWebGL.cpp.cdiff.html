<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertWebGL.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMConvertVariadic.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertWebGL.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertWebGL.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 43,30 ***</span>
  #include &quot;JSOESTextureHalfFloatLinear.h&quot;
  #include &quot;JSOESVertexArrayObject.h&quot;
  #include &quot;JSWebGLBuffer.h&quot;
  #include &quot;JSWebGLCompressedTextureASTC.h&quot;
  #include &quot;JSWebGLCompressedTextureATC.h&quot;
  #include &quot;JSWebGLCompressedTexturePVRTC.h&quot;
  #include &quot;JSWebGLCompressedTextureS3TC.h&quot;
  #include &quot;JSWebGLDebugRendererInfo.h&quot;
  #include &quot;JSWebGLDebugShaders.h&quot;
  #include &quot;JSWebGLDepthTexture.h&quot;
  #include &quot;JSWebGLDrawBuffers.h&quot;
  #include &quot;JSWebGLFramebuffer.h&quot;
  #include &quot;JSWebGLLoseContext.h&quot;
  #include &quot;JSWebGLProgram.h&quot;
  #include &quot;JSWebGLRenderbuffer.h&quot;
  #include &quot;JSWebGLTexture.h&quot;
  #include &quot;JSWebGLVertexArrayObject.h&quot;
  #include &quot;JSWebGLVertexArrayObjectOES.h&quot;
  #include &lt;JavaScriptCore/JSCInlines.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  
  // FIXME: This should use the IDLUnion JSConverter.
<span class="line-modified">! JSValue convertToJSValue(ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const WebGLAny&amp; any)</span>
  {
      return WTF::switchOn(any,
          [] (std::nullptr_t) {
              return jsNull();
          },
<span class="line-new-header">--- 43,34 ---</span>
  #include &quot;JSOESTextureHalfFloatLinear.h&quot;
  #include &quot;JSOESVertexArrayObject.h&quot;
  #include &quot;JSWebGLBuffer.h&quot;
  #include &quot;JSWebGLCompressedTextureASTC.h&quot;
  #include &quot;JSWebGLCompressedTextureATC.h&quot;
<span class="line-added">+ #include &quot;JSWebGLCompressedTextureETC.h&quot;</span>
<span class="line-added">+ #include &quot;JSWebGLCompressedTextureETC1.h&quot;</span>
  #include &quot;JSWebGLCompressedTexturePVRTC.h&quot;
  #include &quot;JSWebGLCompressedTextureS3TC.h&quot;
  #include &quot;JSWebGLDebugRendererInfo.h&quot;
  #include &quot;JSWebGLDebugShaders.h&quot;
  #include &quot;JSWebGLDepthTexture.h&quot;
  #include &quot;JSWebGLDrawBuffers.h&quot;
  #include &quot;JSWebGLFramebuffer.h&quot;
  #include &quot;JSWebGLLoseContext.h&quot;
  #include &quot;JSWebGLProgram.h&quot;
  #include &quot;JSWebGLRenderbuffer.h&quot;
<span class="line-added">+ #include &quot;JSWebGLSampler.h&quot;</span>
  #include &quot;JSWebGLTexture.h&quot;
<span class="line-added">+ #include &quot;JSWebGLTransformFeedback.h&quot;</span>
  #include &quot;JSWebGLVertexArrayObject.h&quot;
  #include &quot;JSWebGLVertexArrayObjectOES.h&quot;
  #include &lt;JavaScriptCore/JSCInlines.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  
  // FIXME: This should use the IDLUnion JSConverter.
<span class="line-modified">! JSValue convertToJSValue(JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const WebGLAny&amp; any)</span>
  {
      return WTF::switchOn(any,
          [] (std::nullptr_t) {
              return jsNull();
          },
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,112 ***</span>
          },
          [] (float value) {
              return jsNumber(value);
          },
          [&amp;] (const String&amp; value) {
<span class="line-modified">!             return jsStringWithCache(&amp;state, value);</span>
          },
          [&amp;] (const Vector&lt;bool&gt;&amp; values) {
              MarkedArgumentBuffer list;
              for (auto&amp; value : values)
                  list.append(jsBoolean(value));
              RELEASE_ASSERT(!list.hasOverflowed());
<span class="line-modified">!             return constructArray(&amp;state, 0, &amp;globalObject, list);</span>
          },
          [&amp;] (const Vector&lt;int&gt;&amp; values) {
              MarkedArgumentBuffer list;
              for (auto&amp; value : values)
                  list.append(jsNumber(value));
              RELEASE_ASSERT(!list.hasOverflowed());
<span class="line-modified">!             return constructArray(&amp;state, 0, &amp;globalObject, list);</span>
          },
          [&amp;] (const RefPtr&lt;Float32Array&gt;&amp; array) {
<span class="line-modified">!             return toJS(&amp;state, &amp;globalObject, array.get());</span>
          },
          [&amp;] (const RefPtr&lt;Int32Array&gt;&amp; array) {
<span class="line-modified">!             return toJS(&amp;state, &amp;globalObject, array.get());</span>
          },
          [&amp;] (const RefPtr&lt;Uint8Array&gt;&amp; array) {
<span class="line-modified">!             return toJS(&amp;state, &amp;globalObject, array.get());</span>
          },
          [&amp;] (const RefPtr&lt;Uint32Array&gt;&amp; array) {
<span class="line-modified">!             return toJS(&amp;state, &amp;globalObject, array.get());</span>
          },
          [&amp;] (const RefPtr&lt;WebGLBuffer&gt;&amp; buffer) {
<span class="line-modified">!             return toJS(&amp;state, &amp;globalObject, buffer.get());</span>
          },
          [&amp;] (const RefPtr&lt;WebGLFramebuffer&gt;&amp; buffer) {
<span class="line-modified">!             return toJS(&amp;state, &amp;globalObject, buffer.get());</span>
          },
          [&amp;] (const RefPtr&lt;WebGLProgram&gt;&amp; program) {
<span class="line-modified">!             return toJS(&amp;state, &amp;globalObject, program.get());</span>
          },
          [&amp;] (const RefPtr&lt;WebGLRenderbuffer&gt;&amp; buffer) {
<span class="line-modified">!             return toJS(&amp;state, &amp;globalObject, buffer.get());</span>
          },
          [&amp;] (const RefPtr&lt;WebGLTexture&gt;&amp; texture) {
<span class="line-modified">!             return toJS(&amp;state, &amp;globalObject, texture.get());</span>
          },
          [&amp;] (const RefPtr&lt;WebGLVertexArrayObjectOES&gt;&amp; array) {
<span class="line-modified">!             return toJS(&amp;state, &amp;globalObject, array.get());</span>
          }
  #if ENABLE(WEBGL2)
          ,
          [&amp;] (const RefPtr&lt;WebGLVertexArrayObject&gt;&amp; array) {
<span class="line-modified">!             return toJS(&amp;state, &amp;globalObject, array.get());</span>
          }
  #endif
      );
  }
  
<span class="line-modified">! JSValue convertToJSValue(ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, WebGLExtension&amp; extension)</span>
  {
      switch (extension.getName()) {
      case WebGLExtension::WebGLLoseContextName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;WebGLLoseContext&amp;&gt;(extension));</span>
      case WebGLExtension::EXTShaderTextureLODName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;EXTShaderTextureLOD&amp;&gt;(extension));</span>
      case WebGLExtension::EXTTextureFilterAnisotropicName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;EXTTextureFilterAnisotropic&amp;&gt;(extension));</span>
      case WebGLExtension::EXTsRGBName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;EXTsRGB&amp;&gt;(extension));</span>
      case WebGLExtension::EXTFragDepthName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;EXTFragDepth&amp;&gt;(extension));</span>
      case WebGLExtension::EXTBlendMinMaxName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;EXTBlendMinMax&amp;&gt;(extension));</span>
      case WebGLExtension::OESStandardDerivativesName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;OESStandardDerivatives&amp;&gt;(extension));</span>
      case WebGLExtension::OESTextureFloatName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;OESTextureFloat&amp;&gt;(extension));</span>
      case WebGLExtension::OESTextureFloatLinearName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;OESTextureFloatLinear&amp;&gt;(extension));</span>
      case WebGLExtension::OESTextureHalfFloatName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;OESTextureHalfFloat&amp;&gt;(extension));</span>
      case WebGLExtension::OESTextureHalfFloatLinearName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;OESTextureHalfFloatLinear&amp;&gt;(extension));</span>
      case WebGLExtension::OESVertexArrayObjectName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;OESVertexArrayObject&amp;&gt;(extension));</span>
      case WebGLExtension::OESElementIndexUintName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;OESElementIndexUint&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLDebugRendererInfoName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;WebGLDebugRendererInfo&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLDebugShadersName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;WebGLDebugShaders&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLCompressedTextureATCName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;WebGLCompressedTextureATC&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLCompressedTexturePVRTCName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;WebGLCompressedTexturePVRTC&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLCompressedTextureS3TCName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;WebGLCompressedTextureS3TC&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLCompressedTextureASTCName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;WebGLCompressedTextureASTC&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLDepthTextureName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;WebGLDepthTexture&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLDrawBuffersName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;WebGLDrawBuffers&amp;&gt;(extension));</span>
      case WebGLExtension::ANGLEInstancedArraysName:
<span class="line-modified">!         return toJS(&amp;state, &amp;globalObject, static_cast&lt;ANGLEInstancedArrays&amp;&gt;(extension));</span>
      }
      ASSERT_NOT_REACHED();
      return jsNull();
  }
  
<span class="line-new-header">--- 88,122 ---</span>
          },
          [] (float value) {
              return jsNumber(value);
          },
          [&amp;] (const String&amp; value) {
<span class="line-modified">!             return jsStringWithCache(&amp;lexicalGlobalObject, value);</span>
          },
          [&amp;] (const Vector&lt;bool&gt;&amp; values) {
              MarkedArgumentBuffer list;
              for (auto&amp; value : values)
                  list.append(jsBoolean(value));
              RELEASE_ASSERT(!list.hasOverflowed());
<span class="line-modified">!             return constructArray(&amp;globalObject, static_cast&lt;JSC::ArrayAllocationProfile*&gt;(nullptr), list);</span>
          },
          [&amp;] (const Vector&lt;int&gt;&amp; values) {
              MarkedArgumentBuffer list;
              for (auto&amp; value : values)
                  list.append(jsNumber(value));
              RELEASE_ASSERT(!list.hasOverflowed());
<span class="line-modified">!             return constructArray(&amp;globalObject, static_cast&lt;JSC::ArrayAllocationProfile*&gt;(nullptr), list);</span>
          },
          [&amp;] (const RefPtr&lt;Float32Array&gt;&amp; array) {
<span class="line-modified">!             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, array.get());</span>
          },
          [&amp;] (const RefPtr&lt;Int32Array&gt;&amp; array) {
<span class="line-modified">!             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, array.get());</span>
          },
          [&amp;] (const RefPtr&lt;Uint8Array&gt;&amp; array) {
<span class="line-modified">!             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, array.get());</span>
          },
          [&amp;] (const RefPtr&lt;Uint32Array&gt;&amp; array) {
<span class="line-modified">!             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, array.get());</span>
          },
          [&amp;] (const RefPtr&lt;WebGLBuffer&gt;&amp; buffer) {
<span class="line-modified">!             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, buffer.get());</span>
          },
          [&amp;] (const RefPtr&lt;WebGLFramebuffer&gt;&amp; buffer) {
<span class="line-modified">!             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, buffer.get());</span>
          },
          [&amp;] (const RefPtr&lt;WebGLProgram&gt;&amp; program) {
<span class="line-modified">!             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, program.get());</span>
          },
          [&amp;] (const RefPtr&lt;WebGLRenderbuffer&gt;&amp; buffer) {
<span class="line-modified">!             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, buffer.get());</span>
          },
          [&amp;] (const RefPtr&lt;WebGLTexture&gt;&amp; texture) {
<span class="line-modified">!             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, texture.get());</span>
          },
          [&amp;] (const RefPtr&lt;WebGLVertexArrayObjectOES&gt;&amp; array) {
<span class="line-modified">!             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, array.get());</span>
          }
  #if ENABLE(WEBGL2)
          ,
<span class="line-added">+         [&amp;] (const RefPtr&lt;WebGLSampler&gt;&amp; sampler) {</span>
<span class="line-added">+             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, sampler.get());</span>
<span class="line-added">+         },</span>
<span class="line-added">+         [&amp;] (const RefPtr&lt;WebGLTransformFeedback&gt;&amp; transformFeedback) {</span>
<span class="line-added">+             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, transformFeedback.get());</span>
<span class="line-added">+         },</span>
          [&amp;] (const RefPtr&lt;WebGLVertexArrayObject&gt;&amp; array) {
<span class="line-modified">!             return toJS(&amp;lexicalGlobalObject, &amp;globalObject, array.get());</span>
          }
  #endif
      );
  }
  
<span class="line-modified">! JSValue convertToJSValue(JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, WebGLExtension&amp; extension)</span>
  {
      switch (extension.getName()) {
      case WebGLExtension::WebGLLoseContextName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;WebGLLoseContext&amp;&gt;(extension));</span>
      case WebGLExtension::EXTShaderTextureLODName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;EXTShaderTextureLOD&amp;&gt;(extension));</span>
      case WebGLExtension::EXTTextureFilterAnisotropicName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;EXTTextureFilterAnisotropic&amp;&gt;(extension));</span>
      case WebGLExtension::EXTsRGBName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;EXTsRGB&amp;&gt;(extension));</span>
      case WebGLExtension::EXTFragDepthName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;EXTFragDepth&amp;&gt;(extension));</span>
      case WebGLExtension::EXTBlendMinMaxName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;EXTBlendMinMax&amp;&gt;(extension));</span>
      case WebGLExtension::OESStandardDerivativesName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;OESStandardDerivatives&amp;&gt;(extension));</span>
      case WebGLExtension::OESTextureFloatName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;OESTextureFloat&amp;&gt;(extension));</span>
      case WebGLExtension::OESTextureFloatLinearName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;OESTextureFloatLinear&amp;&gt;(extension));</span>
      case WebGLExtension::OESTextureHalfFloatName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;OESTextureHalfFloat&amp;&gt;(extension));</span>
      case WebGLExtension::OESTextureHalfFloatLinearName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;OESTextureHalfFloatLinear&amp;&gt;(extension));</span>
      case WebGLExtension::OESVertexArrayObjectName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;OESVertexArrayObject&amp;&gt;(extension));</span>
      case WebGLExtension::OESElementIndexUintName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;OESElementIndexUint&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLDebugRendererInfoName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;WebGLDebugRendererInfo&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLDebugShadersName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;WebGLDebugShaders&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLCompressedTextureATCName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;WebGLCompressedTextureATC&amp;&gt;(extension));</span>
<span class="line-added">+     case WebGLExtension::WebGLCompressedTextureETCName:</span>
<span class="line-added">+         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;WebGLCompressedTextureETC&amp;&gt;(extension));</span>
<span class="line-added">+     case WebGLExtension::WebGLCompressedTextureETC1Name:</span>
<span class="line-added">+         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;WebGLCompressedTextureETC1&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLCompressedTexturePVRTCName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;WebGLCompressedTexturePVRTC&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLCompressedTextureS3TCName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;WebGLCompressedTextureS3TC&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLCompressedTextureASTCName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;WebGLCompressedTextureASTC&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLDepthTextureName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;WebGLDepthTexture&amp;&gt;(extension));</span>
      case WebGLExtension::WebGLDrawBuffersName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;WebGLDrawBuffers&amp;&gt;(extension));</span>
      case WebGLExtension::ANGLEInstancedArraysName:
<span class="line-modified">!         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, static_cast&lt;ANGLEInstancedArrays&amp;&gt;(extension));</span>
      }
      ASSERT_NOT_REACHED();
      return jsNull();
  }
  
</pre>
<center><a href="JSDOMConvertVariadic.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertWebGL.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/xml/parser/XMLDocumentParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2000 Peter Kelly (pmk@post.com)
  3  * Copyright (C) 2005-2017 Apple Inc. All rights reserved.
  4  * Copyright (C) 2006 Alexey Proskuryakov (ap@webkit.org)
  5  * Copyright (C) 2007 Samuel Weinig (sam@webkit.org)
  6  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
  7  * Copyright (C) 2008 Holger Hans Peter Freyther
  8  * Copyright (C) 2008 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  *
 10  * This library is free software; you can redistribute it and/or
 11  * modify it under the terms of the GNU Library General Public
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;XMLDocumentParser.h&quot;
 28 
 29 #include &quot;CDATASection.h&quot;
 30 #include &quot;Comment.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;DocumentFragment.h&quot;
 33 #include &quot;DocumentType.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 34 #include &quot;ElementAncestorIterator.h&quot;</span>
 35 #include &quot;Frame.h&quot;
 36 #include &quot;FrameLoader.h&quot;
 37 #include &quot;FrameView.h&quot;
 38 #include &quot;HTMLLinkElement.h&quot;
 39 #include &quot;HTMLNames.h&quot;
 40 #include &quot;HTMLStyleElement.h&quot;
 41 #include &quot;ImageLoader.h&quot;
 42 #include &quot;PendingScript.h&quot;
 43 #include &quot;ProcessingInstruction.h&quot;
 44 #include &quot;ResourceError.h&quot;
 45 #include &quot;ResourceRequest.h&quot;
 46 #include &quot;ResourceResponse.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 47 #include &quot;SVGForeignObjectElement.h&quot;</span>
 48 #include &quot;SVGNames.h&quot;
 49 #include &quot;SVGStyleElement.h&quot;
 50 #include &quot;ScriptElement.h&quot;
 51 #include &quot;ScriptSourceCode.h&quot;
 52 #include &quot;StyleScope.h&quot;
 53 #include &quot;TextResourceDecoder.h&quot;
 54 #include &quot;TreeDepthLimit.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 55 #include &quot;XMLNSNames.h&quot;</span>
 56 #include &lt;wtf/Ref.h&gt;
 57 #include &lt;wtf/Threading.h&gt;
 58 #include &lt;wtf/Vector.h&gt;
 59 
 60 namespace WebCore {
 61 
 62 using namespace HTMLNames;
 63 
 64 void XMLDocumentParser::pushCurrentNode(ContainerNode* n)
 65 {
 66     ASSERT(n);
 67     ASSERT(m_currentNode);
 68     if (n != document())
 69         n-&gt;ref();
 70     m_currentNodeStack.append(m_currentNode);
 71     m_currentNode = n;
 72     if (m_currentNodeStack.size() &gt; maxDOMTreeDepth)
 73         handleError(XMLErrors::fatal, &quot;Excessive node nesting.&quot;, textPosition());
 74 }
 75 
 76 void XMLDocumentParser::popCurrentNode()
 77 {
 78     if (!m_currentNode)
 79         return;
 80     ASSERT(m_currentNodeStack.size());
 81 
 82     if (m_currentNode != document())
 83         m_currentNode-&gt;deref();
 84 
 85     m_currentNode = m_currentNodeStack.last();
 86     m_currentNodeStack.removeLast();
 87 }
 88 
 89 void XMLDocumentParser::clearCurrentNodeStack()
 90 {
 91     if (m_currentNode &amp;&amp; m_currentNode != document())
 92         m_currentNode-&gt;deref();
 93     m_currentNode = nullptr;
 94     m_leafTextNode = nullptr;
 95 
 96     if (m_currentNodeStack.size()) { // Aborted parsing.
 97         for (size_t i = m_currentNodeStack.size() - 1; i != 0; --i)
 98             m_currentNodeStack[i]-&gt;deref();
 99         if (m_currentNodeStack[0] &amp;&amp; m_currentNodeStack[0] != document())
100             m_currentNodeStack[0]-&gt;deref();
101         m_currentNodeStack.clear();
102     }
103 }
104 
105 void XMLDocumentParser::insert(SegmentedString&amp;&amp;)
106 {
107     ASSERT_NOT_REACHED();
108 }
109 
110 void XMLDocumentParser::append(RefPtr&lt;StringImpl&gt;&amp;&amp; inputSource)
111 {
112     String source { WTFMove(inputSource) };
113 
114     if (m_sawXSLTransform || !m_sawFirstElement)
115         m_originalSourceForTransform.append(source);
116 
117     if (isStopped() || m_sawXSLTransform)
118         return;
119 
120     if (m_parserPaused) {
121         m_pendingSrc.append(source);
122         return;
123     }
124 
125     doWrite(source);
126 
127     // After parsing, dispatch image beforeload events.
128     ImageLoader::dispatchPendingBeforeLoadEvents();
129 }
130 
131 void XMLDocumentParser::handleError(XMLErrors::ErrorType type, const char* m, TextPosition position)
132 {
133     if (!m_xmlErrors)
134         m_xmlErrors = makeUnique&lt;XMLErrors&gt;(*document());
135     m_xmlErrors-&gt;handleError(type, m, position);
136     if (type != XMLErrors::warning)
137         m_sawError = true;
138     if (type == XMLErrors::fatal)
139         stopParsing();
140 }
141 
142 void XMLDocumentParser::createLeafTextNode()
143 {
144     if (m_leafTextNode)
145         return;
146 
147     ASSERT(m_bufferedText.size() == 0);
148     ASSERT(!m_leafTextNode);
149     m_leafTextNode = Text::create(m_currentNode-&gt;document(), &quot;&quot;);
150     m_currentNode-&gt;parserAppendChild(*m_leafTextNode);
151 }
152 
153 bool XMLDocumentParser::updateLeafTextNode()
154 {
155     if (isStopped())
156         return false;
157 
158     if (!m_leafTextNode)
159         return true;
160 
161     // This operation might fire mutation event, see below.
162     m_leafTextNode-&gt;appendData(String::fromUTF8(reinterpret_cast&lt;const char*&gt;(m_bufferedText.data()), m_bufferedText.size()));
163     m_bufferedText = { };
164 
165     m_leafTextNode = nullptr;
166 
167     // Hence, we need to check again whether the parser is stopped, since mutation
168     // event handlers executed by appendData might have detached this parser.
169     return !isStopped();
170 }
171 
172 void XMLDocumentParser::detach()
173 {
174     clearCurrentNodeStack();
175     ScriptableDocumentParser::detach();
176 }
177 
178 void XMLDocumentParser::end()
179 {
180     // XMLDocumentParserLibxml2 will do bad things to the document if doEnd() is called.
181     // I don&#39;t believe XMLDocumentParserQt needs doEnd called in the fragment case.
182     ASSERT(!m_parsingFragment);
183 
184     doEnd();
185 
186     // doEnd() call above can detach the parser and null out its document.
187     // In that case, we just bail out.
188     if (isDetached())
189         return;
190 
191     // doEnd() could process a script tag, thus pausing parsing.
192     if (m_parserPaused)
193         return;
194 
195     if (m_sawError &amp;&amp; !isStopped()) {
196         insertErrorMessageBlock();
197         if (isDetached()) // Inserting an error message may have ran arbitrary scripts.
198             return;
199     } else {
200         updateLeafTextNode();
201         document()-&gt;styleScope().didChangeStyleSheetEnvironment();
202     }
203 
204     if (isParsing())
205         prepareToStopParsing();
206     document()-&gt;setReadyState(Document::Interactive);
207     clearCurrentNodeStack();
208     document()-&gt;finishedParsing();
209 }
210 
211 void XMLDocumentParser::finish()
212 {
213     // FIXME: We should ASSERT(!m_parserStopped) here, since it does not
214     // makes sense to call any methods on DocumentParser once it&#39;s been stopped.
215     // However, FrameLoader::stop calls DocumentParser::finish unconditionally.
216 
217     Ref&lt;XMLDocumentParser&gt; protectedThis(*this);
218 
219     if (m_parserPaused)
220         m_finishCalled = true;
221     else
222         end();
223 }
224 
225 void XMLDocumentParser::insertErrorMessageBlock()
226 {
227     ASSERT(m_xmlErrors);
228     m_xmlErrors-&gt;insertErrorMessageBlock();
229 }
230 
231 void XMLDocumentParser::notifyFinished(PendingScript&amp; pendingScript)
232 {
233     ASSERT(&amp;pendingScript == m_pendingScript.get());
234 
235     // JavaScript can detach this parser, make sure it&#39;s kept alive even if detached.
236     Ref&lt;XMLDocumentParser&gt; protectedThis(*this);
237 
238     m_pendingScript = nullptr;
239     pendingScript.clearClient();
240 
241     pendingScript.element().executePendingScript(pendingScript);
242 
243     if (!isDetached() &amp;&amp; !m_requestingScript)
244         resumeParsing();
245 }
246 
247 bool XMLDocumentParser::isWaitingForScripts() const
248 {
249     return m_pendingScript;
250 }
251 
252 void XMLDocumentParser::pauseParsing()
253 {
254     ASSERT(!m_parserPaused);
255 
256     if (m_parsingFragment)
257         return;
258 
259     m_parserPaused = true;
260 }
261 
262 bool XMLDocumentParser::parseDocumentFragment(const String&amp; chunk, DocumentFragment&amp; fragment, Element* contextElement, ParserContentPolicy parserContentPolicy)
263 {
264     if (!chunk.length())
265         return true;
266 
267     // FIXME: We need to implement the HTML5 XML Fragment parsing algorithm:
268     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-xhtml-syntax.html#xml-fragment-parsing-algorithm
269     // For now we have a hack for script/style innerHTML support:
270     if (contextElement &amp;&amp; (contextElement-&gt;hasLocalName(HTMLNames::scriptTag-&gt;localName()) || contextElement-&gt;hasLocalName(HTMLNames::styleTag-&gt;localName()))) {
271         fragment.parserAppendChild(fragment.document().createTextNode(chunk));
272         return true;
273     }
274 
<a name="4" id="anc4"></a><span class="line-modified">275     HashMap&lt;AtomString, AtomString&gt; prefixToNamespaceMap;</span>
<span class="line-added">276     AtomString defaultNamespaceURI;</span>
<span class="line-added">277     bool stopLookingForDefaultNamespaceURI = false;</span>
<span class="line-added">278 </span>
<span class="line-added">279     for (auto&amp; element : elementLineage(contextElement)) {</span>
<span class="line-added">280         if (is&lt;SVGForeignObjectElement&gt;(element))</span>
<span class="line-added">281             stopLookingForDefaultNamespaceURI = true;</span>
<span class="line-added">282         else if (!stopLookingForDefaultNamespaceURI)</span>
<span class="line-added">283             defaultNamespaceURI = element.namespaceURI();</span>
<span class="line-added">284 </span>
<span class="line-added">285         if (!element.hasAttributes())</span>
<span class="line-added">286             continue;</span>
<span class="line-added">287 </span>
<span class="line-added">288         for (const Attribute&amp; attribute : element.attributesIterator()) {</span>
<span class="line-added">289             if (attribute.prefix() == xmlnsAtom())</span>
<span class="line-added">290                 prefixToNamespaceMap.set(attribute.localName(), attribute.value());</span>
<span class="line-added">291             else if (!stopLookingForDefaultNamespaceURI &amp;&amp; attribute.prefix() == xmlnsAtom())</span>
<span class="line-added">292                 defaultNamespaceURI = attribute.value();</span>
<span class="line-added">293         }</span>
<span class="line-added">294     }</span>
<span class="line-added">295 </span>
<span class="line-added">296     auto parser = XMLDocumentParser::create(fragment, WTFMove(prefixToNamespaceMap), defaultNamespaceURI, parserContentPolicy);</span>
297     bool wellFormed = parser-&gt;appendFragmentSource(chunk);
298     // Do not call finish(). The finish() and doEnd() implementations touch the main document and loader and can cause crashes in the fragment case.
299     parser-&gt;detach(); // Allows ~DocumentParser to assert it was detached before destruction.
300     return wellFormed; // appendFragmentSource()&#39;s wellFormed is more permissive than Document::wellFormed().
301 }
302 
303 } // namespace WebCore
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
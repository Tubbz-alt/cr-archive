<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ArrayBufferView.h&quot;
 29 #include &quot;DeferGC.h&quot;
 30 #include &quot;Error.h&quot;
 31 #include &quot;ExceptionHelpers.h&quot;
 32 #include &quot;JSArrayBuffer.h&quot;
<a name="1" id="anc1"></a>
 33 #include &quot;JSGenericTypedArrayView.h&quot;
 34 #include &quot;TypeError.h&quot;
 35 #include &quot;TypedArrays.h&quot;
 36 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 37 
 38 namespace JSC {
 39 
 40 template&lt;typename Adaptor&gt;
 41 JSGenericTypedArrayView&lt;Adaptor&gt;::JSGenericTypedArrayView(
 42     VM&amp; vm, ConstructionContext&amp; context)
 43     : Base(vm, context)
 44 {
 45 }
 46 
 47 template&lt;typename Adaptor&gt;
 48 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
<a name="2" id="anc2"></a><span class="line-modified"> 49     ExecState* exec, Structure* structure, unsigned length)</span>
 50 {
<a name="3" id="anc3"></a><span class="line-modified"> 51     VM&amp; vm = exec-&gt;vm();</span>
 52     auto scope = DECLARE_THROW_SCOPE(vm);
 53     ConstructionContext context(vm, structure, length, sizeof(typename Adaptor::Type));
 54     if (!context) {
<a name="4" id="anc4"></a><span class="line-modified"> 55         throwOutOfMemoryError(exec, scope);</span>
 56         return nullptr;
 57     }
 58     JSGenericTypedArrayView* result =
 59         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
 60         JSGenericTypedArrayView(vm, context);
 61     result-&gt;finishCreation(vm);
 62     return result;
 63 }
 64 
 65 template&lt;typename Adaptor&gt;
 66 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::createWithFastVector(
<a name="5" id="anc5"></a><span class="line-modified"> 67     ExecState* exec, Structure* structure, unsigned length, void* vector)</span>
 68 {
<a name="6" id="anc6"></a><span class="line-modified"> 69     VM&amp; vm = exec-&gt;vm();</span>
 70     ConstructionContext context(structure, length, vector);
 71     RELEASE_ASSERT(context);
 72     JSGenericTypedArrayView* result =
 73         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
 74         JSGenericTypedArrayView(vm, context);
 75     result-&gt;finishCreation(vm);
 76     return result;
 77 }
 78 
 79 template&lt;typename Adaptor&gt;
<a name="7" id="anc7"></a><span class="line-modified"> 80 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::createUninitialized(ExecState* exec, Structure* structure, unsigned length)</span>
 81 {
<a name="8" id="anc8"></a><span class="line-modified"> 82     VM&amp; vm = exec-&gt;vm();</span>
 83     auto scope = DECLARE_THROW_SCOPE(vm);
 84     ConstructionContext context(
 85         vm, structure, length, sizeof(typename Adaptor::Type),
 86         ConstructionContext::DontInitialize);
 87     if (!context) {
<a name="9" id="anc9"></a><span class="line-modified"> 88         throwOutOfMemoryError(exec, scope);</span>
 89         return nullptr;
 90     }
 91     JSGenericTypedArrayView* result =
 92         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
 93         JSGenericTypedArrayView(vm, context);
 94     result-&gt;finishCreation(vm);
 95     return result;
 96 }
 97 
 98 template&lt;typename Adaptor&gt;
 99 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
<a name="10" id="anc10"></a><span class="line-modified">100     ExecState* exec, Structure* structure, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; buffer,</span>
101     unsigned byteOffset, unsigned length)
102 {
<a name="11" id="anc11"></a><span class="line-modified">103     VM&amp; vm = exec-&gt;vm();</span>
104     auto scope = DECLARE_THROW_SCOPE(vm);
105     size_t size = sizeof(typename Adaptor::Type);
106     ASSERT(buffer);
107     if (!ArrayBufferView::verifySubRangeLength(*buffer, byteOffset, length, size)) {
<a name="12" id="anc12"></a><span class="line-modified">108         throwException(exec, scope, createRangeError(exec, &quot;Length out of range of buffer&quot;));</span>
109         return nullptr;
110     }
111     if (!ArrayBufferView::verifyByteOffsetAlignment(byteOffset, size)) {
<a name="13" id="anc13"></a><span class="line-modified">112         throwException(exec, scope, createRangeError(exec, &quot;Byte offset is not aligned&quot;));</span>
113         return nullptr;
114     }
115     ConstructionContext context(vm, structure, WTFMove(buffer), byteOffset, length);
116     ASSERT(context);
117     JSGenericTypedArrayView* result =
118         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
119         JSGenericTypedArrayView(vm, context);
120     result-&gt;finishCreation(vm);
121     return result;
122 }
123 
124 template&lt;typename Adaptor&gt;
125 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
126     VM&amp; vm, Structure* structure, RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl)
127 {
128     ConstructionContext context(vm, structure, impl-&gt;possiblySharedBuffer(), impl-&gt;byteOffset(), impl-&gt;length());
129     ASSERT(context);
130     JSGenericTypedArrayView* result =
131         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
132         JSGenericTypedArrayView(vm, context);
133     result-&gt;finishCreation(vm);
134     return result;
135 }
136 
137 template&lt;typename Adaptor&gt;
138 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
139     Structure* structure, JSGlobalObject* globalObject,
140     RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl)
141 {
142     return create(globalObject-&gt;vm(), structure, WTFMove(impl));
143 }
144 
145 template&lt;typename Adaptor&gt;
146 bool JSGenericTypedArrayView&lt;Adaptor&gt;::validateRange(
<a name="14" id="anc14"></a><span class="line-modified">147     ExecState* exec, unsigned offset, unsigned length)</span>
148 {
<a name="15" id="anc15"></a><span class="line-modified">149     VM&amp; vm = exec-&gt;vm();</span>
150     auto scope = DECLARE_THROW_SCOPE(vm);
151     if (canAccessRangeQuickly(offset, length))
152         return true;
153 
<a name="16" id="anc16"></a><span class="line-modified">154     throwException(exec, scope, createRangeError(exec, &quot;Range consisting of offset and length are out of bounds&quot;));</span>
155     return false;
156 }
157 
158 template&lt;typename Adaptor&gt;
159 template&lt;typename OtherAdaptor&gt;
160 bool JSGenericTypedArrayView&lt;Adaptor&gt;::setWithSpecificType(
<a name="17" id="anc17"></a><span class="line-modified">161     ExecState* exec, unsigned offset, JSGenericTypedArrayView&lt;OtherAdaptor&gt;* other,</span>
162     unsigned otherOffset, unsigned length, CopyType type)
163 {
164     // Handle the hilarious case: the act of getting the length could have resulted
165     // in neutering. Well, no. That&#39;ll never happen because there cannot be
166     // side-effects on getting the length of a typed array. But predicting where there
167     // are, or aren&#39;t, side-effects is a fool&#39;s game so we resort to this cheap
168     // check. Worst case, if we&#39;re wrong, people start seeing less things get copied
169     // but we won&#39;t have a security vulnerability.
170     length = std::min(length, other-&gt;length());
171 
172     RELEASE_ASSERT(other-&gt;canAccessRangeQuickly(otherOffset, length));
<a name="18" id="anc18"></a><span class="line-modified">173     if (!validateRange(exec, offset, length))</span>
174         return false;
175 
176     // This method doesn&#39;t support copying between the same array. Note that
177     // set() will only call this if the types differ, which implicitly guarantees
178     // that we can&#39;t be the same array. This is relevant because the way we detect
179     // non-overlapping is by checking if either (a) either array doesn&#39;t have a
180     // backing buffer or (b) the backing buffers are different, but that doesn&#39;t
181     // catch the case where it&#39;s the *same* array - fortunately though, this code
182     // path never needs to worry about that case.
183     ASSERT(static_cast&lt;JSCell*&gt;(this) != static_cast&lt;JSCell*&gt;(other));
184 
185     // 1) If the two arrays are non-overlapping, we can copy in any order we like
186     //    and we don&#39;t need an intermediate buffer. Arrays are definitely
187     //    non-overlapping if either one of them has no backing buffer (that means
188     //    that it *owns* its philosophical backing buffer) or if they have
189     //    different backing buffers.
190     // 2) If the two arrays overlap but have the same element size, we can do a
191     //    memmove-like copy where we flip-flop direction based on which vector
192     //    starts before the other:
193     //    A) If the destination vector is before the source vector, then a forward
194     //       copy is in order.
195     //    B) If the destination vector is after the source vector, then a backward
196     //       copy is in order.
197     // 3) If we have different element sizes and there is a chance of overlap then
198     //    we need an intermediate vector.
199 
200     // NB. Comparisons involving elementSize will be constant-folded by template
201     // specialization.
202 
203     unsigned otherElementSize = sizeof(typename OtherAdaptor::Type);
204 
205     // Handle cases (1) and (2A).
206     if (!hasArrayBuffer() || !other-&gt;hasArrayBuffer()
207         || existingBuffer() != other-&gt;existingBuffer()
208         || (elementSize == otherElementSize &amp;&amp; vector() &lt;= other-&gt;vector())
209         || type == CopyType::LeftToRight) {
210         for (unsigned i = 0; i &lt; length; ++i) {
211             setIndexQuicklyToNativeValue(
212                 offset + i, OtherAdaptor::template convertTo&lt;Adaptor&gt;(
213                     other-&gt;getIndexQuicklyAsNativeValue(i + otherOffset)));
214         }
215         return true;
216     }
217 
218     // Now we either have (2B) or (3) - so first we try to cover (2B).
219     if (elementSize == otherElementSize) {
220         for (unsigned i = length; i--;) {
221             setIndexQuicklyToNativeValue(
222                 offset + i, OtherAdaptor::template convertTo&lt;Adaptor&gt;(
223                     other-&gt;getIndexQuicklyAsNativeValue(i + otherOffset)));
224         }
225         return true;
226     }
227 
228     // Fail: we need an intermediate transfer buffer (i.e. case (3)).
229     Vector&lt;typename Adaptor::Type, 32&gt; transferBuffer(length);
230     for (unsigned i = length; i--;) {
231         transferBuffer[i] = OtherAdaptor::template convertTo&lt;Adaptor&gt;(
232             other-&gt;getIndexQuicklyAsNativeValue(i + otherOffset));
233     }
234     for (unsigned i = length; i--;)
235         setIndexQuicklyToNativeValue(offset + i, transferBuffer[i]);
236 
237     return true;
238 }
239 
240 template&lt;typename Adaptor&gt;
241 bool JSGenericTypedArrayView&lt;Adaptor&gt;::set(
<a name="19" id="anc19"></a><span class="line-modified">242     ExecState* exec, unsigned offset, JSObject* object, unsigned objectOffset, unsigned length, CopyType type)</span>
243 {
<a name="20" id="anc20"></a><span class="line-modified">244     VM&amp; vm = exec-&gt;vm();</span>
245     auto scope = DECLARE_THROW_SCOPE(vm);
246 
247     const ClassInfo* ci = object-&gt;classInfo(vm);
248     if (ci-&gt;typedArrayStorageType == Adaptor::typeValue) {
249         // The super fast case: we can just memcpy since we&#39;re the same type.
250         JSGenericTypedArrayView* other = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
251         length = std::min(length, other-&gt;length());
252 
253         RELEASE_ASSERT(other-&gt;canAccessRangeQuickly(objectOffset, length));
<a name="21" id="anc21"></a><span class="line-modified">254         bool success = validateRange(exec, offset, length);</span>
255         EXCEPTION_ASSERT(!scope.exception() == success);
256         if (!success)
257             return false;
258 
259         memmove(typedVector() + offset, other-&gt;typedVector() + objectOffset, length * elementSize);
260         return true;
261     }
262 
263     switch (ci-&gt;typedArrayStorageType) {
264     case TypeInt8:
265         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int8Adaptor&gt;(
<a name="22" id="anc22"></a><span class="line-modified">266             exec, offset, jsCast&lt;JSInt8Array*&gt;(object), objectOffset, length, type));</span>
267     case TypeInt16:
268         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int16Adaptor&gt;(
<a name="23" id="anc23"></a><span class="line-modified">269             exec, offset, jsCast&lt;JSInt16Array*&gt;(object), objectOffset, length, type));</span>
270     case TypeInt32:
271         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int32Adaptor&gt;(
<a name="24" id="anc24"></a><span class="line-modified">272             exec, offset, jsCast&lt;JSInt32Array*&gt;(object), objectOffset, length, type));</span>
273     case TypeUint8:
274         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint8Adaptor&gt;(
<a name="25" id="anc25"></a><span class="line-modified">275             exec, offset, jsCast&lt;JSUint8Array*&gt;(object), objectOffset, length, type));</span>
276     case TypeUint8Clamped:
277         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint8ClampedAdaptor&gt;(
<a name="26" id="anc26"></a><span class="line-modified">278             exec, offset, jsCast&lt;JSUint8ClampedArray*&gt;(object), objectOffset, length, type));</span>
279     case TypeUint16:
280         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint16Adaptor&gt;(
<a name="27" id="anc27"></a><span class="line-modified">281             exec, offset, jsCast&lt;JSUint16Array*&gt;(object), objectOffset, length, type));</span>
282     case TypeUint32:
283         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint32Adaptor&gt;(
<a name="28" id="anc28"></a><span class="line-modified">284             exec, offset, jsCast&lt;JSUint32Array*&gt;(object), objectOffset, length, type));</span>
285     case TypeFloat32:
286         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Float32Adaptor&gt;(
<a name="29" id="anc29"></a><span class="line-modified">287             exec, offset, jsCast&lt;JSFloat32Array*&gt;(object), objectOffset, length, type));</span>
288     case TypeFloat64:
289         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Float64Adaptor&gt;(
<a name="30" id="anc30"></a><span class="line-modified">290             exec, offset, jsCast&lt;JSFloat64Array*&gt;(object), objectOffset, length, type));</span>
291     case NotTypedArray:
292     case TypeDataView: {
<a name="31" id="anc31"></a><span class="line-modified">293         bool success = validateRange(exec, offset, length);</span>
294         EXCEPTION_ASSERT(!scope.exception() == success);
295         if (!success)
296             return false;
297 
298         // We could optimize this case. But right now, we don&#39;t.
299         for (unsigned i = 0; i &lt; length; ++i) {
<a name="32" id="anc32"></a><span class="line-modified">300             JSValue value = object-&gt;get(exec, i + objectOffset);</span>
301             RETURN_IF_EXCEPTION(scope, false);
<a name="33" id="anc33"></a><span class="line-modified">302             bool success = setIndex(exec, offset + i, value);</span>
303             EXCEPTION_ASSERT(!scope.exception() || !success);
304             if (!success)
305                 return false;
306         }
307         return true;
308     } }
309 
310     RELEASE_ASSERT_NOT_REACHED();
311     return false;
312 }
313 
314 template&lt;typename Adaptor&gt;
315 RefPtr&lt;typename Adaptor::ViewType&gt; JSGenericTypedArrayView&lt;Adaptor&gt;::possiblySharedTypedImpl()
316 {
317     return Adaptor::ViewType::tryCreate(possiblySharedBuffer(), byteOffset(), length());
318 }
319 
320 template&lt;typename Adaptor&gt;
321 RefPtr&lt;typename Adaptor::ViewType&gt; JSGenericTypedArrayView&lt;Adaptor&gt;::unsharedTypedImpl()
322 {
323     return Adaptor::ViewType::tryCreate(unsharedBuffer(), byteOffset(), length());
324 }
325 
326 template&lt;typename Adaptor&gt;
327 ArrayBuffer* JSGenericTypedArrayView&lt;Adaptor&gt;::existingBuffer()
328 {
329     return existingBufferInButterfly();
330 }
331 
332 template&lt;typename Adaptor&gt;
<a name="34" id="anc34"></a><span class="line-modified">333 EncodedJSValue JSGenericTypedArrayView&lt;Adaptor&gt;::throwNeuteredTypedArrayTypeError(ExecState* exec, EncodedJSValue object, PropertyName)</span>
334 {
<a name="35" id="anc35"></a><span class="line-modified">335     VM&amp; vm = exec-&gt;vm();</span>
336     auto scope = DECLARE_THROW_SCOPE(vm);
337     ASSERT_UNUSED(object, jsCast&lt;JSGenericTypedArrayView*&gt;(JSValue::decode(object))-&gt;isNeutered());
<a name="36" id="anc36"></a><span class="line-modified">338     return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
339 }
340 
341 template&lt;typename Adaptor&gt;
342 bool JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertySlot(
<a name="37" id="anc37"></a><span class="line-modified">343     JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
344 {
345     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
346 
347     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
348         if (thisObject-&gt;isNeutered()) {
349             slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), throwNeuteredTypedArrayTypeError);
350             return true;
351         }
352 
353         if (thisObject-&gt;canGetIndexQuickly(index.value())) {
354             slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete), thisObject-&gt;getIndexQuickly(index.value()));
355             return true;
356         }
357 
358         return false;
359     }
360 
361     if (isCanonicalNumericIndexString(propertyName)) {
362         if (thisObject-&gt;isNeutered()) {
363             slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), throwNeuteredTypedArrayTypeError);
364             return true;
365         }
366 
367         return false;
368     }
369 
<a name="38" id="anc38"></a><span class="line-modified">370     return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
371 }
372 
373 template&lt;typename Adaptor&gt;
374 bool JSGenericTypedArrayView&lt;Adaptor&gt;::put(
<a name="39" id="anc39"></a><span class="line-modified">375     JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value,</span>
376     PutPropertySlot&amp; slot)
377 {
<a name="40" id="anc40"></a><span class="line-modified">378     VM&amp; vm = exec-&gt;vm();</span>
379     auto scope = DECLARE_THROW_SCOPE(vm);
380 
381     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
382 
383     // https://tc39.github.io/ecma262/#sec-integer-indexed-exotic-objects-set-p-v-receiver
384     // Ignore the receiver even if the receiver is altered to non base value.
385     // 9.4.5.5-2-b-i Return ? IntegerIndexedElementSet(O, numericIndex, V).
386     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<a name="41" id="anc41"></a><span class="line-modified">387         RELEASE_AND_RETURN(scope, putByIndex(thisObject, exec, index.value(), value, slot.isStrictMode()));</span>
388 
389     if (isCanonicalNumericIndexString(propertyName)) {
390         if (thisObject-&gt;isNeutered())
<a name="42" id="anc42"></a><span class="line-modified">391             throwTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
392         return false;
393     }
394 
<a name="43" id="anc43"></a><span class="line-modified">395     RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));</span>
396 }
397 
398 template&lt;typename Adaptor&gt;
399 bool JSGenericTypedArrayView&lt;Adaptor&gt;::defineOwnProperty(
<a name="44" id="anc44"></a><span class="line-modified">400     JSObject* object, ExecState* exec, PropertyName propertyName,</span>
401     const PropertyDescriptor&amp; descriptor, bool shouldThrow)
402 {
<a name="45" id="anc45"></a><span class="line-modified">403     VM&amp; vm = exec-&gt;vm();</span>
404     auto scope = DECLARE_THROW_SCOPE(vm);
405     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
406 
407     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
408         auto throwTypeErrorIfNeeded = [&amp;] (const char* errorMessage) -&gt; bool {
409             if (shouldThrow)
<a name="46" id="anc46"></a><span class="line-modified">410                 throwTypeError(exec, scope, makeString(errorMessage, *index));</span>
411             return false;
412         };
413 
414         if (index.value() &gt;= thisObject-&gt;m_length)
415             return false;
416 
417         if (descriptor.isAccessorDescriptor())
418             return throwTypeErrorIfNeeded(&quot;Attempting to store accessor property on a typed array at index: &quot;);
419 
420         if (descriptor.configurable())
421             return throwTypeErrorIfNeeded(&quot;Attempting to configure non-configurable property on a typed array at index: &quot;);
422 
423         if (!descriptor.enumerable() || !descriptor.writable())
424             return throwTypeErrorIfNeeded(&quot;Attempting to store non-enumerable or non-writable property on a typed array at index: &quot;);
425 
426         if (descriptor.value())
<a name="47" id="anc47"></a><span class="line-modified">427             RELEASE_AND_RETURN(scope, thisObject-&gt;putByIndex(thisObject, exec, index.value(), descriptor.value(), shouldThrow));</span>
428 
429         return true;
430     }
431 
432     if (isCanonicalNumericIndexString(propertyName))
433         return false;
434 
<a name="48" id="anc48"></a><span class="line-modified">435     RELEASE_AND_RETURN(scope, Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow));</span>
436 }
437 
438 template&lt;typename Adaptor&gt;
439 bool JSGenericTypedArrayView&lt;Adaptor&gt;::deleteProperty(
<a name="49" id="anc49"></a><span class="line-modified">440     JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
441 {
<a name="50" id="anc50"></a><span class="line-modified">442     VM&amp; vm = exec-&gt;vm();</span>
443     auto scope = DECLARE_THROW_SCOPE(vm);
444     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
445 
446     if (thisObject-&gt;isNeutered())
<a name="51" id="anc51"></a><span class="line-modified">447         return typeError(exec, scope, true, typedArrayBufferHasBeenDetachedErrorMessage);</span>
448 
449     if (parseIndex(propertyName))
450         return false;
451 
<a name="52" id="anc52"></a><span class="line-modified">452     return Base::deleteProperty(thisObject, exec, propertyName);</span>
453 }
454 
455 template&lt;typename Adaptor&gt;
456 bool JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertySlotByIndex(
<a name="53" id="anc53"></a><span class="line-modified">457     JSObject* object, ExecState*, unsigned propertyName, PropertySlot&amp; slot)</span>
458 {
459     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
460 
461     if (thisObject-&gt;isNeutered()) {
462         slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), throwNeuteredTypedArrayTypeError);
463         return true;
464     }
465 
466     if (!thisObject-&gt;canGetIndexQuickly(propertyName))
467         return false;
468 
469     slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete), thisObject-&gt;getIndexQuickly(propertyName));
470     return true;
471 }
472 
473 template&lt;typename Adaptor&gt;
474 bool JSGenericTypedArrayView&lt;Adaptor&gt;::putByIndex(
<a name="54" id="anc54"></a><span class="line-modified">475     JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool)</span>
476 {
477     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
<a name="55" id="anc55"></a><span class="line-modified">478     return thisObject-&gt;setIndex(exec, propertyName, value);</span>
479 }
480 
481 template&lt;typename Adaptor&gt;
482 bool JSGenericTypedArrayView&lt;Adaptor&gt;::deletePropertyByIndex(
<a name="56" id="anc56"></a><span class="line-modified">483     JSCell* cell, ExecState* exec, unsigned propertyName)</span>
484 {
<a name="57" id="anc57"></a><span class="line-modified">485     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">486     return cell-&gt;methodTable(vm)-&gt;deleteProperty(cell, exec, Identifier::from(vm, propertyName));</span>
487 }
488 
489 template&lt;typename Adaptor&gt;
490 void JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertyNames(
<a name="58" id="anc58"></a><span class="line-modified">491     JSObject* object, ExecState* exec, PropertyNameArray&amp; array, EnumerationMode mode)</span>
492 {
<a name="59" id="anc59"></a><span class="line-modified">493     VM&amp; vm = exec-&gt;vm();</span>
494     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
495 
496     if (array.includeStringProperties()) {
497         for (unsigned i = 0; i &lt; thisObject-&gt;m_length; ++i)
498             array.add(Identifier::from(vm, i));
499     }
500 
<a name="60" id="anc60"></a><span class="line-modified">501     return Base::getOwnPropertyNames(object, exec, array, mode);</span>
502 }
503 
504 template&lt;typename Adaptor&gt;
505 size_t JSGenericTypedArrayView&lt;Adaptor&gt;::estimatedSize(JSCell* cell, VM&amp; vm)
506 {
507     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
508 
509     if (thisObject-&gt;m_mode == OversizeTypedArray)
510         return Base::estimatedSize(thisObject, vm) + thisObject-&gt;byteSize();
511     if (thisObject-&gt;m_mode == FastTypedArray &amp;&amp; thisObject-&gt;hasVector())
512         return Base::estimatedSize(thisObject, vm) + thisObject-&gt;byteSize();
513 
514     return Base::estimatedSize(thisObject, vm);
515 }
516 
517 template&lt;typename Adaptor&gt;
518 void JSGenericTypedArrayView&lt;Adaptor&gt;::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
519 {
520     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
521     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
522     Base::visitChildren(thisObject, visitor);
523 
524     TypedArrayMode mode;
525     void* vector;
526     size_t byteSize;
527 
528     {
529         auto locker = holdLock(thisObject-&gt;cellLock());
530         mode = thisObject-&gt;m_mode;
531         vector = thisObject-&gt;vector();
532         byteSize = thisObject-&gt;byteSize();
533     }
534 
535     switch (mode) {
536     case FastTypedArray: {
537         if (vector)
538             visitor.markAuxiliary(vector);
539         break;
540     }
541 
542     case OversizeTypedArray: {
543         visitor.reportExtraMemoryVisited(byteSize);
544         break;
545     }
546 
547     case WastefulTypedArray:
548         break;
549 
550     case DataViewMode:
551         RELEASE_ASSERT_NOT_REACHED();
552         break;
553     }
554 }
555 
556 } // namespace JSC
<a name="61" id="anc61"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="61" type="hidden" />
</body>
</html>
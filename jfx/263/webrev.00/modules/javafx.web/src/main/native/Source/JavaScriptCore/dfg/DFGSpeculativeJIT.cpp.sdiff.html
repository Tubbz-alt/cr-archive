<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSlowPathGenerator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   24  */
   25 
   26 #include &quot;config.h&quot;
   27 #include &quot;DFGSpeculativeJIT.h&quot;
   28 
   29 #if ENABLE(DFG_JIT)
   30 
   31 #include &quot;BinarySwitch.h&quot;
   32 #include &quot;DFGAbstractInterpreterInlines.h&quot;
   33 #include &quot;DFGArrayifySlowPathGenerator.h&quot;
   34 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
   35 #include &quot;DFGCallCreateDirectArgumentsSlowPathGenerator.h&quot;
   36 #include &quot;DFGCapabilities.h&quot;
   37 #include &quot;DFGMayExit.h&quot;
   38 #include &quot;DFGOSRExitFuzz.h&quot;
   39 #include &quot;DFGSaneStringGetByValSlowPathGenerator.h&quot;
   40 #include &quot;DFGSlowPathGenerator.h&quot;
   41 #include &quot;DFGSnippetParams.h&quot;

   42 #include &quot;DirectArguments.h&quot;
   43 #include &quot;DisallowMacroScratchRegisterUsage.h&quot;
   44 #include &quot;JITAddGenerator.h&quot;
   45 #include &quot;JITBitAndGenerator.h&quot;
   46 #include &quot;JITBitOrGenerator.h&quot;
   47 #include &quot;JITBitXorGenerator.h&quot;
   48 #include &quot;JITDivGenerator.h&quot;
   49 #include &quot;JITLeftShiftGenerator.h&quot;
   50 #include &quot;JITMulGenerator.h&quot;
   51 #include &quot;JITRightShiftGenerator.h&quot;
   52 #include &quot;JITSubGenerator.h&quot;

   53 #include &quot;JSAsyncFunction.h&quot;
   54 #include &quot;JSAsyncGeneratorFunction.h&quot;
   55 #include &quot;JSCInlines.h&quot;
<span class="line-removed">   56 #include &quot;JSFixedArray.h&quot;</span>
   57 #include &quot;JSGeneratorFunction.h&quot;
   58 #include &quot;JSImmutableButterfly.h&quot;
   59 #include &quot;JSLexicalEnvironment.h&quot;
   60 #include &quot;JSPropertyNameEnumerator.h&quot;
   61 #include &quot;LinkBuffer.h&quot;
   62 #include &quot;RegExpObject.h&quot;
   63 #include &quot;ScopedArguments.h&quot;
   64 #include &quot;ScratchRegisterAllocator.h&quot;
   65 #include &quot;SuperSampler.h&quot;
   66 #include &quot;TypeProfilerLog.h&quot;
   67 #include &quot;WeakMapImpl.h&quot;
   68 #include &lt;wtf/BitVector.h&gt;
   69 #include &lt;wtf/Box.h&gt;
   70 #include &lt;wtf/MathExtras.h&gt;
   71 
   72 namespace JSC { namespace DFG {
   73 


   74 SpeculativeJIT::SpeculativeJIT(JITCompiler&amp; jit)
   75     : m_jit(jit)
   76     , m_graph(m_jit.graph())
   77     , m_currentNode(0)
   78     , m_lastGeneratedNode(LastNodeType)
   79     , m_indexInBlock(0)
   80     , m_generationInfo(m_jit.graph().frameRegisterCount())
   81     , m_compileOkay(true)
   82     , m_state(m_jit.graph())
   83     , m_interpreter(m_jit.graph(), m_state)
   84     , m_stream(&amp;jit.jitCode()-&gt;variableEventStream)
   85     , m_minifiedGraph(&amp;jit.jitCode()-&gt;minifiedDFG)
   86 {
   87 }
   88 
   89 SpeculativeJIT::~SpeculativeJIT()
   90 {
   91 }
   92 
   93 void SpeculativeJIT::emitAllocateRawObject(GPRReg resultGPR, RegisteredStructure structure, GPRReg storageGPR, unsigned numElements, unsigned vectorLength)
</pre>
<hr />
<pre>
  653 #endif // USE(JSVALUE64)
  654     case SetBooleanConstant:
  655         m_jit.move(TrustedImm32(plan.node()-&gt;asBoolean()), plan.gpr());
  656         break;
  657     case SetCellConstant:
  658         ASSERT(plan.node()-&gt;constant()-&gt;value().isCell());
  659         m_jit.move(TrustedImmPtr(plan.node()-&gt;constant()), plan.gpr());
  660         break;
  661 #if USE(JSVALUE64)
  662     case SetTrustedJSConstant:
  663         m_jit.move(valueOfJSConstantAsImm64(plan.node()).asTrustedImm64(), plan.gpr());
  664         break;
  665     case SetJSConstant:
  666         m_jit.move(valueOfJSConstantAsImm64(plan.node()), plan.gpr());
  667         break;
  668     case SetDoubleConstant:
  669         m_jit.moveDouble(Imm64(reinterpretDoubleToInt64(plan.node()-&gt;asNumber())), plan.fpr());
  670         break;
  671     case Load32PayloadBoxInt:
  672         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
<span class="line-modified">  673         m_jit.or64(GPRInfo::tagTypeNumberRegister, plan.gpr());</span>
  674         break;
  675     case Load32PayloadConvertToInt52:
  676         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  677         m_jit.signExtend32ToPtr(plan.gpr(), plan.gpr());
  678         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), plan.gpr());
  679         break;
  680     case Load32PayloadSignExtend:
  681         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  682         m_jit.signExtend32ToPtr(plan.gpr(), plan.gpr());
  683         break;
  684 #else
  685     case SetJSConstantTag:
  686         m_jit.move(Imm32(plan.node()-&gt;asJSValue().tag()), plan.gpr());
  687         break;
  688     case SetJSConstantPayload:
  689         m_jit.move(Imm32(plan.node()-&gt;asJSValue().payload()), plan.gpr());
  690         break;
  691     case SetInt32Tag:
  692         m_jit.move(TrustedImm32(JSValue::Int32Tag), plan.gpr());
  693         break;
</pre>
<hr />
<pre>
  809                 TrustedImm32(SlowPutArrayStorageShape - ArrayStorageShape)));
  810         return result;
  811     }
  812     default:
  813         CRASH();
  814         break;
  815     }
  816 
  817     return result;
  818 }
  819 
  820 void SpeculativeJIT::checkArray(Node* node)
  821 {
  822     ASSERT(node-&gt;arrayMode().isSpecific());
  823     ASSERT(!node-&gt;arrayMode().doesConversion());
  824 
  825     SpeculateCellOperand base(this, node-&gt;child1());
  826     GPRReg baseReg = base.gpr();
  827 
  828     if (node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1()))) {


  829         noResult(m_currentNode);
  830         return;
  831     }
  832 


























  833     switch (node-&gt;arrayMode().type()) {
  834     case Array::AnyTypedArray:
  835     case Array::String:
  836         RELEASE_ASSERT_NOT_REACHED(); // Should have been a Phantom(String:)
  837         return;
  838     case Array::Int32:
  839     case Array::Double:
  840     case Array::Contiguous:
  841     case Array::Undecided:
  842     case Array::ArrayStorage:
  843     case Array::SlowPutArrayStorage: {
<span class="line-modified">  844         GPRTemporary temp(this);</span>
<span class="line-removed">  845         GPRReg tempGPR = temp.gpr();</span>
<span class="line-removed">  846         m_jit.load8(MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR);</span>
  847         speculationCheck(
  848             BadIndexingType, JSValueSource::unboxedCell(baseReg), 0,
<span class="line-modified">  849             jumpSlowForUnwantedArrayMode(tempGPR, node-&gt;arrayMode()));</span>
<span class="line-modified">  850 </span>
<span class="line-removed">  851         noResult(m_currentNode);</span>
<span class="line-removed">  852         return;</span>
  853     }
  854     case Array::DirectArguments:
  855         speculateCellTypeWithoutTypeFiltering(node-&gt;child1(), baseReg, DirectArgumentsType);
<span class="line-modified">  856         noResult(m_currentNode);</span>
<span class="line-removed">  857         return;</span>
  858     case Array::ScopedArguments:
  859         speculateCellTypeWithoutTypeFiltering(node-&gt;child1(), baseReg, ScopedArgumentsType);
<span class="line-modified">  860         noResult(m_currentNode);</span>
<span class="line-removed">  861         return;</span>
  862     default:
  863         speculateCellTypeWithoutTypeFiltering(
  864             node-&gt;child1(), baseReg,
  865             typeForTypedArrayType(node-&gt;arrayMode().typedArrayType()));
<span class="line-modified">  866         noResult(m_currentNode);</span>
<span class="line-removed">  867         return;</span>
  868     }




  869 }
  870 
  871 void SpeculativeJIT::arrayify(Node* node, GPRReg baseReg, GPRReg propertyReg)
  872 {
  873     ASSERT(node-&gt;arrayMode().doesConversion());
  874 
  875     GPRTemporary temp(this);
  876     GPRTemporary structure;
  877     GPRReg tempGPR = temp.gpr();
  878     GPRReg structureGPR = InvalidGPRReg;
  879 
  880     if (node-&gt;op() != ArrayifyToStructure) {
  881         GPRTemporary realStructure(this);
  882         structure.adopt(realStructure);
  883         structureGPR = structure.gpr();
  884     }
  885 
  886     // We can skip all that comes next if we already have array storage.
  887     MacroAssembler::JumpList slowPath;
  888 
</pre>
<hr />
<pre>
  966             return;
  967         }
  968         use(child1);
  969 
  970         Edge child2 = node-&gt;child2();
  971         if (!child2) {
  972             ASSERT(!node-&gt;child3());
  973             return;
  974         }
  975         use(child2);
  976 
  977         Edge child3 = node-&gt;child3();
  978         if (!child3)
  979             return;
  980         use(child3);
  981     }
  982 }
  983 
  984 void SpeculativeJIT::compileGetById(Node* node, AccessType accessType)
  985 {
<span class="line-modified">  986     ASSERT(accessType == AccessType::Get || accessType == AccessType::GetDirect || accessType == AccessType::TryGet);</span>
  987 
  988     switch (node-&gt;child1().useKind()) {
  989     case CellUse: {
  990         SpeculateCellOperand base(this, node-&gt;child1());
  991         JSValueRegsTemporary result(this, Reuse, base);
  992 
  993         JSValueRegs baseRegs = JSValueRegs::payloadOnly(base.gpr());
  994         JSValueRegs resultRegs = result.regs();
  995 
  996         base.use();
  997 
  998         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), JITCompiler::Jump(), NeedToSpill, accessType);
  999 
 1000         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1001         break;
 1002     }
 1003 
 1004     case UntypedUse: {
 1005         JSValueOperand base(this, node-&gt;child1());
 1006         JSValueRegsTemporary result(this, Reuse, base);
</pre>
<hr />
<pre>
 1073 {
 1074     SpeculateCellOperand base(this, node-&gt;child1());
 1075     JSValueRegsTemporary result(this, Reuse, base, PayloadWord);
 1076 
 1077     GPRReg baseGPR = base.gpr();
 1078     JSValueRegs resultRegs = result.regs();
 1079 
 1080     base.use();
 1081 
 1082     CodeOrigin codeOrigin = node-&gt;origin.semantic;
 1083     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 1084     RegisterSet usedRegisters = this-&gt;usedRegisters();
 1085     JITInByIdGenerator gen(
 1086         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(node-&gt;identifierNumber()),
 1087         JSValueRegs::payloadOnly(baseGPR), resultRegs);
 1088     gen.generateFastPath(m_jit);
 1089 
 1090     auto slowPath = slowPathCall(
 1091         gen.slowPathJump(), this, operationInByIdOptimize,
 1092         NeedToSpill, ExceptionCheckRequirement::CheckNeeded,
<span class="line-modified"> 1093         resultRegs, gen.stubInfo(), CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;identifierNumber()));</span>
 1094 
 1095     m_jit.addInById(gen, slowPath.get());
 1096     addSlowPathGenerator(WTFMove(slowPath));
 1097 
 1098     blessedBooleanResult(resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
 1099 }
 1100 
 1101 void SpeculativeJIT::compileInByVal(Node* node)
 1102 {
 1103     SpeculateCellOperand base(this, node-&gt;child1());
 1104     JSValueOperand key(this, node-&gt;child2());
 1105 
 1106     GPRReg baseGPR = base.gpr();
 1107     JSValueRegs regs = key.jsValueRegs();
 1108 
 1109     base.use();
 1110     key.use();
 1111 
 1112     flushRegisters();
 1113     JSValueRegsFlushedCallResult result(this);
 1114     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 1115     callOperation(operationInByVal, resultRegs, baseGPR, regs);</span>
 1116     m_jit.exceptionCheck();
 1117     blessedBooleanResult(resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
 1118 }
 1119 
 1120 void SpeculativeJIT::compileDeleteById(Node* node)
 1121 {
 1122     JSValueOperand value(this, node-&gt;child1());
 1123     GPRFlushedCallResult result(this);
 1124 
 1125     JSValueRegs valueRegs = value.jsValueRegs();
 1126     GPRReg resultGPR = result.gpr();
 1127 
 1128     value.use();
 1129 
 1130     flushRegisters();
<span class="line-modified"> 1131     callOperation(operationDeleteById, resultGPR, valueRegs, identifierUID(node-&gt;identifierNumber()));</span>
 1132     m_jit.exceptionCheck();
 1133 
 1134     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 1135 }
 1136 
 1137 void SpeculativeJIT::compileDeleteByVal(Node* node)
 1138 {
 1139     JSValueOperand base(this, node-&gt;child1());
 1140     JSValueOperand key(this, node-&gt;child2());
 1141     GPRFlushedCallResult result(this);
 1142 
 1143     JSValueRegs baseRegs = base.jsValueRegs();
 1144     JSValueRegs keyRegs = key.jsValueRegs();
 1145     GPRReg resultGPR = result.gpr();
 1146 
 1147     base.use();
 1148     key.use();
 1149 
 1150     flushRegisters();
<span class="line-modified"> 1151     callOperation(operationDeleteByVal, resultGPR, baseRegs, keyRegs);</span>
 1152     m_jit.exceptionCheck();
 1153 
 1154     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 1155 }
 1156 
 1157 void SpeculativeJIT::compilePushWithScope(Node* node)
 1158 {
 1159     SpeculateCellOperand currentScope(this, node-&gt;child1());
 1160     GPRReg currentScopeGPR = currentScope.gpr();
 1161 
 1162     GPRFlushedCallResult result(this);
 1163     GPRReg resultGPR = result.gpr();
 1164 
 1165     auto objectEdge = node-&gt;child2();
 1166     if (objectEdge.useKind() == ObjectUse) {
 1167         SpeculateCellOperand object(this, objectEdge);
 1168         GPRReg objectGPR = object.gpr();
 1169         speculateObject(objectEdge, objectGPR);
 1170 
 1171         flushRegisters();
<span class="line-modified"> 1172         callOperation(operationPushWithScopeObject, resultGPR, currentScopeGPR, objectGPR);</span>
 1173         // No exception check here as we did not have to call toObject().
 1174     } else {
 1175         ASSERT(objectEdge.useKind() == UntypedUse);
 1176         JSValueOperand object(this, objectEdge);
 1177         JSValueRegs objectRegs = object.jsValueRegs();
 1178 
 1179         flushRegisters();
<span class="line-modified"> 1180         callOperation(operationPushWithScope, resultGPR, currentScopeGPR, objectRegs);</span>
 1181         m_jit.exceptionCheck();
 1182     }
 1183 
 1184     cellResult(resultGPR, node);
 1185 }
 1186 
 1187 bool SpeculativeJIT::nonSpeculativeStrictEq(Node* node, bool invert)
 1188 {
 1189     unsigned branchIndexInBlock = detectPeepHoleBranch();
 1190     if (branchIndexInBlock != UINT_MAX) {
 1191         Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 1192 
 1193         ASSERT(node-&gt;adjustedRefCount() == 1);
 1194 
 1195         nonSpeculativePeepholeStrictEq(node, branchNode, invert);
 1196 
 1197         m_indexInBlock = branchIndexInBlock;
 1198         m_currentNode = branchNode;
 1199 
 1200         return true;
</pre>
<hr />
<pre>
 1587 
 1588     // Load the character into scratchReg
 1589     m_jit.zeroExtend32ToPtr(startIndexGPR, startIndexGPR);
 1590     auto is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(temp2GPR, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 1591 
 1592     m_jit.load8(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesOne, 0), tempGPR);
 1593     auto cont8Bit = m_jit.jump();
 1594 
 1595     is16Bit.link(&amp;m_jit);
 1596     m_jit.load16(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesTwo, 0), tempGPR);
 1597 
 1598     auto bigCharacter = m_jit.branch32(MacroAssembler::Above, tempGPR, TrustedImm32(maxSingleCharacterString));
 1599 
 1600     // 8 bit string values don&#39;t need the isASCII check.
 1601     cont8Bit.link(&amp;m_jit);
 1602 
 1603     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), tempGPR);
 1604     m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), tempGPR);
 1605     m_jit.loadPtr(tempGPR, tempGPR);
 1606 
<span class="line-modified"> 1607     addSlowPathGenerator(slowPathCall(bigCharacter, this, operationSingleCharacterString, tempGPR, tempGPR));</span>
 1608 
<span class="line-modified"> 1609     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringSubstr, tempGPR, stringGPR, startIndexGPR, tempGPR));</span>
 1610 
 1611     if (endGPR)
<span class="line-modified"> 1612         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, stringGPR, startGPR, *endGPR));</span>
 1613     else
<span class="line-modified"> 1614         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, stringGPR, startGPR, TrustedImm32(std::numeric_limits&lt;int32_t&gt;::max())));</span>
 1615 
 1616     doneCases.link(&amp;m_jit);
 1617     cellResult(tempGPR, node);
 1618 }
 1619 
 1620 void SpeculativeJIT::compileToLowerCase(Node* node)
 1621 {
 1622     ASSERT(node-&gt;op() == ToLowerCase);
 1623     SpeculateCellOperand string(this, node-&gt;child1());
 1624     GPRTemporary temp(this);
 1625     GPRTemporary index(this);
 1626     GPRTemporary charReg(this);
 1627     GPRTemporary length(this);
 1628 
 1629     GPRReg stringGPR = string.gpr();
 1630     GPRReg tempGPR = temp.gpr();
 1631     GPRReg indexGPR = index.gpr();
 1632     GPRReg charGPR = charReg.gpr();
 1633     GPRReg lengthGPR = length.gpr();
 1634 
</pre>
<hr />
<pre>
 1641     m_jit.loadPtr(MacroAssembler::Address(stringGPR, JSString::offsetOfValue()), tempGPR);
 1642     slowPath.append(m_jit.branchIfRopeStringImpl(tempGPR));
 1643     slowPath.append(m_jit.branchTest32(
 1644         MacroAssembler::Zero, MacroAssembler::Address(tempGPR, StringImpl::flagsOffset()),
 1645         MacroAssembler::TrustedImm32(StringImpl::flagIs8Bit())));
 1646     m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
 1647     m_jit.loadPtr(MacroAssembler::Address(tempGPR, StringImpl::dataOffset()), tempGPR);
 1648 
 1649     auto loopStart = m_jit.label();
 1650     auto loopDone = m_jit.branch32(CCallHelpers::AboveOrEqual, indexGPR, lengthGPR);
 1651     m_jit.load8(MacroAssembler::BaseIndex(tempGPR, indexGPR, MacroAssembler::TimesOne), charGPR);
 1652     slowPath.append(m_jit.branchTest32(CCallHelpers::NonZero, charGPR, TrustedImm32(~0x7F)));
 1653     m_jit.sub32(TrustedImm32(&#39;A&#39;), charGPR);
 1654     slowPath.append(m_jit.branch32(CCallHelpers::BelowOrEqual, charGPR, TrustedImm32(&#39;Z&#39; - &#39;A&#39;)));
 1655 
 1656     m_jit.add32(TrustedImm32(1), indexGPR);
 1657     m_jit.jump().linkTo(loopStart, &amp;m_jit);
 1658 
 1659     slowPath.link(&amp;m_jit);
 1660     silentSpillAllRegisters(lengthGPR);
<span class="line-modified"> 1661     callOperation(operationToLowerCase, lengthGPR, stringGPR, indexGPR);</span>
 1662     silentFillAllRegisters();
 1663     m_jit.exceptionCheck();
 1664     auto done = m_jit.jump();
 1665 
 1666     loopDone.link(&amp;m_jit);
 1667     m_jit.move(stringGPR, lengthGPR);
 1668 
 1669     done.link(&amp;m_jit);
 1670     cellResult(lengthGPR, node);
 1671 }
 1672 
 1673 void SpeculativeJIT::compilePeepHoleInt32Branch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
 1674 {
 1675     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1676     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1677 
 1678     // The branch instruction will branch to the taken block.
 1679     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 1680     if (taken == nextBlock()) {
 1681         condition = JITCompiler::invert(condition);
</pre>
<hr />
<pre>
 1685     }
 1686 
 1687     if (node-&gt;child1()-&gt;isInt32Constant()) {
 1688         int32_t imm = node-&gt;child1()-&gt;asInt32();
 1689         SpeculateInt32Operand op2(this, node-&gt;child2());
 1690         branch32(condition, JITCompiler::Imm32(imm), op2.gpr(), taken);
 1691     } else if (node-&gt;child2()-&gt;isInt32Constant()) {
 1692         SpeculateInt32Operand op1(this, node-&gt;child1());
 1693         int32_t imm = node-&gt;child2()-&gt;asInt32();
 1694         branch32(condition, op1.gpr(), JITCompiler::Imm32(imm), taken);
 1695     } else {
 1696         SpeculateInt32Operand op1(this, node-&gt;child1());
 1697         SpeculateInt32Operand op2(this, node-&gt;child2());
 1698         branch32(condition, op1.gpr(), op2.gpr(), taken);
 1699     }
 1700 
 1701     jump(notTaken);
 1702 }
 1703 
 1704 // Returns true if the compare is fused with a subsequent branch.
<span class="line-modified"> 1705 bool SpeculativeJIT::compilePeepHoleBranch(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_EJJ operation)</span>
 1706 {
 1707     // Fused compare &amp; branch.
 1708     unsigned branchIndexInBlock = detectPeepHoleBranch();
 1709     if (branchIndexInBlock != UINT_MAX) {
 1710         Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 1711 
 1712         // detectPeepHoleBranch currently only permits the branch to be the very next node,
 1713         // so can be no intervening nodes to also reference the compare.
 1714         ASSERT(node-&gt;adjustedRefCount() == 1);
 1715 
 1716         if (node-&gt;isBinaryUseKind(Int32Use))
 1717             compilePeepHoleInt32Branch(node, branchNode, condition);
 1718 #if USE(JSVALUE64)
 1719         else if (node-&gt;isBinaryUseKind(Int52RepUse))
 1720             compilePeepHoleInt52Branch(node, branchNode, condition);
 1721 #endif // USE(JSVALUE64)
 1722         else if (node-&gt;isBinaryUseKind(StringUse) || node-&gt;isBinaryUseKind(StringIdentUse)) {
 1723             // Use non-peephole comparison, for now.
 1724             return false;
 1725         } else if (node-&gt;isBinaryUseKind(DoubleRepUse))
</pre>
<hr />
<pre>
 1758 }
 1759 
 1760 void SpeculativeJIT::noticeOSRBirth(Node* node)
 1761 {
 1762     if (!node-&gt;hasVirtualRegister())
 1763         return;
 1764 
 1765     VirtualRegister virtualRegister = node-&gt;virtualRegister();
 1766     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 1767 
 1768     info.noticeOSRBirth(*m_stream, node, virtualRegister);
 1769 }
 1770 
 1771 void SpeculativeJIT::compileMovHint(Node* node)
 1772 {
 1773     ASSERT(node-&gt;containsMovHint() &amp;&amp; node-&gt;op() != ZombieHint);
 1774 
 1775     Node* child = node-&gt;child1().node();
 1776     noticeOSRBirth(child);
 1777 
<span class="line-modified"> 1778     m_stream-&gt;appendAndLog(VariableEvent::movHint(MinifiedID(child), node-&gt;unlinkedLocal()));</span>












 1779 }
 1780 
 1781 void SpeculativeJIT::bail(AbortReason reason)
 1782 {
 1783     if (verboseCompilationEnabled())
 1784         dataLog(&quot;Bailing compilation.\n&quot;);
 1785     m_compileOkay = true;
 1786     m_jit.abortWithReason(reason, m_lastGeneratedNode);
 1787     clearGenerationInfo();
 1788 }
 1789 
 1790 void SpeculativeJIT::compileCurrentBlock()
 1791 {
 1792     ASSERT(m_compileOkay);
 1793 
 1794     if (!m_block)
 1795         return;
 1796 
 1797     ASSERT(m_block-&gt;isReachable);
 1798 
 1799     m_jit.blockHeads()[m_block-&gt;index] = m_jit.label();
 1800 
 1801     if (!m_block-&gt;intersectionOfCFAHasVisited) {
 1802         // Don&#39;t generate code for basic blocks that are unreachable according to CFA.
 1803         // But to be sure that nobody has generated a jump to this block, drop in a
 1804         // breakpoint here.
 1805         m_jit.abortWithReason(DFGUnreachableBasicBlock);
 1806         return;
 1807     }
 1808 
 1809     if (m_block-&gt;isCatchEntrypoint) {
 1810         m_jit.addPtr(CCallHelpers::TrustedImm32(-(m_jit.graph().frameRegisterCount() * sizeof(Register))), GPRInfo::callFrameRegister,  CCallHelpers::stackPointerRegister);
<span class="line-removed"> 1811         if (Options::zeroStackFrame())</span>
<span class="line-removed"> 1812             m_jit.clearStackFrame(GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister, GPRInfo::regT0, m_jit.graph().frameRegisterCount() * sizeof(Register));</span>
 1813         m_jit.emitSaveCalleeSaves();
 1814         m_jit.emitMaterializeTagCheckRegisters();
 1815         m_jit.emitPutToCallFrameHeader(m_jit.codeBlock(), CallFrameSlot::codeBlock);
 1816     }
 1817 
 1818     m_stream-&gt;appendAndLog(VariableEvent::reset());
 1819 
 1820     m_jit.jitAssertHasValidCallFrame();
 1821     m_jit.jitAssertTagsInPlace();
 1822     m_jit.jitAssertArgumentCountSane();
 1823 
 1824     m_state.reset();
 1825     m_state.beginBasicBlock(m_block);
 1826 
 1827     for (size_t i = m_block-&gt;variablesAtHead.size(); i--;) {
<span class="line-modified"> 1828         int operand = m_block-&gt;variablesAtHead.operandForIndex(i);</span>
 1829         Node* node = m_block-&gt;variablesAtHead[i];
 1830         if (!node)
 1831             continue; // No need to record dead SetLocal&#39;s.
 1832 
 1833         VariableAccessData* variable = node-&gt;variableAccessData();
 1834         DataFormat format;
 1835         if (!node-&gt;refCount())
 1836             continue; // No need to record dead SetLocal&#39;s.
 1837         format = dataFormatFor(variable-&gt;flushFormat());
<span class="line-modified"> 1838         m_stream-&gt;appendAndLog(</span>
<span class="line-modified"> 1839             VariableEvent::setLocal(</span>
<span class="line-removed"> 1840                 VirtualRegister(operand),</span>
<span class="line-removed"> 1841                 variable-&gt;machineLocal(),</span>
<span class="line-removed"> 1842                 format));</span>
 1843     }
 1844 
 1845     m_origin = NodeOrigin();
 1846 
 1847     for (m_indexInBlock = 0; m_indexInBlock &lt; m_block-&gt;size(); ++m_indexInBlock) {
 1848         m_currentNode = m_block-&gt;at(m_indexInBlock);
 1849 
 1850         // We may have hit a contradiction that the CFA was aware of but that the JIT
 1851         // didn&#39;t cause directly.
 1852         if (!m_state.isValid()) {
 1853             bail(DFGBailedAtTopOfBlock);
 1854             return;
 1855         }
 1856 
 1857         m_interpreter.startExecuting();
 1858         m_interpreter.executeKnownEdgeTypes(m_currentNode);
 1859         m_jit.setForNode(m_currentNode);
 1860         m_origin = m_currentNode-&gt;origin;
 1861         m_lastGeneratedNode = m_currentNode-&gt;op();
 1862 
 1863         ASSERT(m_currentNode-&gt;shouldGenerate());
 1864 
<span class="line-modified"> 1865         if (verboseCompilationEnabled()) {</span>
<span class="line-modified"> 1866             dataLogF(</span>
<span class="line-removed"> 1867                 &quot;SpeculativeJIT generating Node @%d (bc#%u) at JIT offset 0x%x&quot;,</span>
<span class="line-removed"> 1868                 (int)m_currentNode-&gt;index(),</span>
<span class="line-removed"> 1869                 m_currentNode-&gt;origin.semantic.bytecodeIndex(), m_jit.debugOffset());</span>
<span class="line-removed"> 1870             dataLog(&quot;\n&quot;);</span>
<span class="line-removed"> 1871         }</span>
 1872 
 1873         if (Options::validateDFGExceptionHandling() &amp;&amp; (mayExit(m_jit.graph(), m_currentNode) != DoesNotExit || m_currentNode-&gt;isTerminal()))
 1874             m_jit.jitReleaseAssertNoException(m_jit.vm());
 1875 
 1876         m_jit.pcToCodeOriginMapBuilder().appendItem(m_jit.labelIgnoringWatchpoints(), m_origin.semantic);
 1877 
 1878         compile(m_currentNode);
 1879 
 1880         if (belongsInMinifiedGraph(m_currentNode-&gt;op()))
 1881             m_minifiedGraph-&gt;append(MinifiedNode::fromNode(m_currentNode));
 1882 
 1883 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 1884         m_jit.clearRegisterAllocationOffsets();
 1885 #endif
 1886 
 1887         if (!m_compileOkay) {
 1888             bail(DFGBailedAtEndOfNode);
 1889             return;
 1890         }
 1891 
 1892         // Make sure that the abstract state is rematerialized for the next node.
 1893         m_interpreter.executeEffects(m_indexInBlock);
 1894     }
 1895 
 1896     // Perform the most basic verification that children have been used correctly.
<span class="line-modified"> 1897     if (!ASSERT_DISABLED) {</span>
 1898         for (auto&amp; info : m_generationInfo)
 1899             RELEASE_ASSERT(!info.alive());
 1900     }
 1901 }
 1902 
 1903 // If we are making type predictions about our arguments then
 1904 // we need to check that they are correct on function entry.
 1905 void SpeculativeJIT::checkArgumentTypes()
 1906 {
 1907     ASSERT(!m_currentNode);
<span class="line-modified"> 1908     m_origin = NodeOrigin(CodeOrigin(0), CodeOrigin(0), true);</span>
 1909 
 1910     auto&amp; arguments = m_jit.graph().m_rootToArguments.find(m_jit.graph().block(0))-&gt;value;
 1911     for (int i = 0; i &lt; m_jit.codeBlock()-&gt;numParameters(); ++i) {
 1912         Node* node = arguments[i];
 1913         if (!node) {
 1914             // The argument is dead. We don&#39;t do any checks for such arguments.
 1915             continue;
 1916         }
 1917 
 1918         ASSERT(node-&gt;op() == SetArgumentDefinitely);
 1919         ASSERT(node-&gt;shouldGenerate());
 1920 
 1921         VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 1922         FlushFormat format = variableAccessData-&gt;flushFormat();
 1923 
 1924         if (format == FlushedJSValue)
 1925             continue;
 1926 
<span class="line-modified"> 1927         VirtualRegister virtualRegister = variableAccessData-&gt;local();</span>

 1928 
 1929         JSValueSource valueSource = JSValueSource(JITCompiler::addressFor(virtualRegister));
 1930 
 1931 #if USE(JSVALUE64)
 1932         switch (format) {
 1933         case FlushedInt32: {
<span class="line-modified"> 1934             speculationCheck(BadType, valueSource, node, m_jit.branch64(MacroAssembler::Below, JITCompiler::addressFor(virtualRegister), GPRInfo::tagTypeNumberRegister));</span>
 1935             break;
 1936         }
 1937         case FlushedBoolean: {
 1938             GPRTemporary temp(this);
 1939             m_jit.load64(JITCompiler::addressFor(virtualRegister), temp.gpr());
<span class="line-modified"> 1940             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), temp.gpr());</span>
 1941             speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, temp.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
 1942             break;
 1943         }
 1944         case FlushedCell: {
<span class="line-modified"> 1945             speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, JITCompiler::addressFor(virtualRegister), GPRInfo::tagMaskRegister));</span>
 1946             break;
 1947         }
 1948         default:
 1949             RELEASE_ASSERT_NOT_REACHED();
 1950             break;
 1951         }
 1952 #else
 1953         switch (format) {
 1954         case FlushedInt32: {
 1955             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::Int32Tag)));
 1956             break;
 1957         }
 1958         case FlushedBoolean: {
 1959             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::BooleanTag)));
 1960             break;
 1961         }
 1962         case FlushedCell: {
 1963             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::CellTag)));
 1964             break;
 1965         }
</pre>
<hr />
<pre>
 2036 
 2037     if (verboseCompilationEnabled()) {
 2038         DumpContext dumpContext;
 2039         dataLog(&quot;OSR Entries:\n&quot;);
 2040         for (OSREntryData&amp; entryData : m_jit.jitCode()-&gt;osrEntry)
 2041             dataLog(&quot;    &quot;, inContext(entryData, &amp;dumpContext), &quot;\n&quot;);
 2042         if (!dumpContext.isEmpty())
 2043             dumpContext.dump(WTF::dataFile());
 2044     }
 2045 }
 2046 
 2047 void SpeculativeJIT::compileCheckTraps(Node* node)
 2048 {
 2049     ASSERT(Options::usePollingTraps());
 2050     GPRTemporary unused(this);
 2051     GPRReg unusedGPR = unused.gpr();
 2052 
 2053     JITCompiler::Jump needTrapHandling = m_jit.branchTest8(JITCompiler::NonZero,
 2054         JITCompiler::AbsoluteAddress(m_jit.vm().needTrapHandlingAddress()));
 2055 
<span class="line-modified"> 2056     addSlowPathGenerator(slowPathCall(needTrapHandling, this, operationHandleTraps, unusedGPR));</span>
 2057     noResult(node);
 2058 }
 2059 
 2060 void SpeculativeJIT::compileDoublePutByVal(Node* node, SpeculateCellOperand&amp; base, SpeculateStrictInt32Operand&amp; property)
 2061 {
 2062     Edge child3 = m_jit.graph().varArgChild(node, 2);
 2063     Edge child4 = m_jit.graph().varArgChild(node, 3);
 2064 
 2065     ArrayMode arrayMode = node-&gt;arrayMode();
 2066 
 2067     GPRReg baseReg = base.gpr();
 2068     GPRReg propertyReg = property.gpr();
 2069 
 2070     SpeculateDoubleOperand value(this, child3);
 2071 
 2072     FPRReg valueReg = value.fpr();
 2073 
 2074     DFG_TYPE_CHECK(
 2075         JSValueRegs(), child3, SpecFullRealNumber,
 2076         m_jit.branchIfNaN(valueReg));
</pre>
<hr />
<pre>
 2111         m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
 2112         m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
 2113 
 2114         inBounds.link(&amp;m_jit);
 2115     }
 2116 
 2117     m_jit.storeDouble(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
 2118 
 2119     base.use();
 2120     property.use();
 2121     value.use();
 2122     storage.use();
 2123 
 2124     if (arrayMode.isOutOfBounds()) {
 2125         addSlowPathGenerator(
 2126             slowPathCall(
 2127                 slowCase, this,
 2128                 m_jit.isStrictModeFor(node-&gt;origin.semantic)
 2129                     ? (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
 2130                     : (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
<span class="line-modified"> 2131                 NoResult, baseReg, propertyReg, valueReg));</span>
 2132     }
 2133 
 2134     noResult(m_currentNode, UseChildrenCalledExplicitly);
 2135 }
 2136 
 2137 void SpeculativeJIT::compileGetCharCodeAt(Node* node)
 2138 {
 2139     SpeculateCellOperand string(this, node-&gt;child1());
 2140     SpeculateStrictInt32Operand index(this, node-&gt;child2());
 2141     StorageOperand storage(this, node-&gt;child3());
 2142 
 2143     GPRReg stringReg = string.gpr();
 2144     GPRReg indexReg = index.gpr();
 2145     GPRReg storageReg = storage.gpr();
 2146 
 2147     ASSERT(speculationChecked(m_state.forNode(node-&gt;child1()).m_type, SpecString));
 2148 
 2149     GPRTemporary scratch(this);
 2150     GPRReg scratchReg = scratch.gpr();
 2151 
</pre>
<hr />
<pre>
 2206     m_jit.load8(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne, 0), scratchReg);
 2207     JITCompiler::Jump cont8Bit = m_jit.jump();
 2208 
 2209     is16Bit.link(&amp;m_jit);
 2210 
 2211     m_jit.load16(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo, 0), scratchReg);
 2212 
 2213     JITCompiler::Jump bigCharacter =
 2214         m_jit.branch32(MacroAssembler::Above, scratchReg, TrustedImm32(maxSingleCharacterString));
 2215 
 2216     // 8 bit string values don&#39;t need the isASCII check.
 2217     cont8Bit.link(&amp;m_jit);
 2218 
 2219     VM&amp; vm = this-&gt;vm();
 2220     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), scratchReg);
 2221     m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), scratchReg);
 2222     m_jit.loadPtr(scratchReg, scratchReg);
 2223 
 2224     addSlowPathGenerator(
 2225         slowPathCall(
<span class="line-modified"> 2226             bigCharacter, this, operationSingleCharacterString, scratchReg, scratchReg));</span>
 2227 
 2228     if (node-&gt;arrayMode().isOutOfBounds()) {
 2229 #if USE(JSVALUE32_64)
 2230         m_jit.move(TrustedImm32(JSValue::CellTag), resultTagReg);
 2231 #endif
 2232 
 2233         JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);
 2234         Structure* stringPrototypeStructure = globalObject-&gt;stringPrototype()-&gt;structure(vm);
 2235         Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm);
 2236         WTF::loadLoadFence();
 2237 
 2238         if (globalObject-&gt;stringPrototypeChainIsSane()) {
 2239             // FIXME: This could be captured using a Speculation mode that means &quot;out-of-bounds
 2240             // loads return a trivial value&quot;. Something like SaneChainOutOfBounds. This should
 2241             // speculate that we don&#39;t take negative out-of-bounds, or better yet, it should rely
 2242             // on a stringPrototypeChainIsSane() guaranteeing that the prototypes have no negative
 2243             // indexed properties either.
 2244             // https://bugs.webkit.org/show_bug.cgi?id=144668
 2245             m_jit.graph().registerAndWatchStructureTransition(stringPrototypeStructure);
 2246             m_jit.graph().registerAndWatchStructureTransition(objectPrototypeStructure);
 2247 
 2248 #if USE(JSVALUE64)
 2249             addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(
<span class="line-modified"> 2250                 outOfBounds, this, JSValueRegs(scratchReg), baseReg, propertyReg));</span>
 2251 #else
 2252             addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(
<span class="line-modified"> 2253                 outOfBounds, this, JSValueRegs(resultTagReg, scratchReg),</span>
<span class="line-removed"> 2254                 baseReg, propertyReg));</span>
 2255 #endif
 2256         } else {
 2257 #if USE(JSVALUE64)
 2258             addSlowPathGenerator(
 2259                 slowPathCall(
 2260                     outOfBounds, this, operationGetByValStringInt,
<span class="line-modified"> 2261                     scratchReg, baseReg, propertyReg));</span>
 2262 #else
 2263             addSlowPathGenerator(
 2264                 slowPathCall(
 2265                     outOfBounds, this, operationGetByValStringInt,
<span class="line-modified"> 2266                     JSValueRegs(resultTagReg, scratchReg), baseReg, propertyReg));</span>
 2267 #endif
 2268         }
 2269 
 2270 #if USE(JSVALUE64)
 2271         jsValueResult(scratchReg, m_currentNode);
 2272 #else
 2273         jsValueResult(resultTagReg, scratchReg, m_currentNode);
 2274 #endif
 2275     } else
 2276         cellResult(scratchReg, m_currentNode);
 2277 }
 2278 
 2279 void SpeculativeJIT::compileFromCharCode(Node* node)
 2280 {
 2281     Edge&amp; child = node-&gt;child1();
 2282     if (child.useKind() == UntypedUse) {
 2283         JSValueOperand opr(this, child);
 2284         JSValueRegs oprRegs = opr.jsValueRegs();
 2285 
 2286         flushRegisters();
 2287         JSValueRegsFlushedCallResult result(this);
 2288         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 2289         callOperation(operationStringFromCharCodeUntyped, resultRegs, oprRegs);</span>
 2290         m_jit.exceptionCheck();
 2291 
 2292         jsValueResult(resultRegs, node);
 2293         return;
 2294     }
 2295 
 2296     SpeculateStrictInt32Operand property(this, child);
 2297     GPRReg propertyReg = property.gpr();
 2298     GPRTemporary smallStrings(this);
 2299     GPRTemporary scratch(this);
 2300     GPRReg scratchReg = scratch.gpr();
 2301     GPRReg smallStringsReg = smallStrings.gpr();
 2302 
 2303     JITCompiler::JumpList slowCases;
 2304     slowCases.append(m_jit.branch32(MacroAssembler::Above, propertyReg, TrustedImm32(maxSingleCharacterString)));
 2305     m_jit.move(TrustedImmPtr(vm().smallStrings.singleCharacterStrings()), smallStringsReg);
 2306     m_jit.loadPtr(MacroAssembler::BaseIndex(smallStringsReg, propertyReg, MacroAssembler::ScalePtr, 0), scratchReg);
 2307 
 2308     slowCases.append(m_jit.branchTest32(MacroAssembler::Zero, scratchReg));
<span class="line-modified"> 2309     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringFromCharCode, scratchReg, propertyReg));</span>
 2310     cellResult(scratchReg, m_currentNode);
 2311 }
 2312 
 2313 GeneratedOperandType SpeculativeJIT::checkGeneratedTypeForToInt32(Node* node)
 2314 {
 2315     VirtualRegister virtualRegister = node-&gt;virtualRegister();
 2316     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 2317 
 2318     switch (info.registerFormat()) {
 2319     case DataFormatStorage:
 2320         RELEASE_ASSERT_NOT_REACHED();
 2321 
 2322     case DataFormatBoolean:
 2323     case DataFormatCell:
 2324         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 2325         return GeneratedOperandTypeUnknown;
 2326 
 2327     case DataFormatNone:
 2328     case DataFormatJSCell:
 2329     case DataFormatJS:
</pre>
<hr />
<pre>
 2392 
 2393             GPRReg gpr = op1.gpr();
 2394             GPRReg resultGpr = result.gpr();
 2395             FPRTemporary tempFpr(this);
 2396             FPRReg fpr = tempFpr.fpr();
 2397 
 2398             JITCompiler::Jump isInteger = m_jit.branchIfInt32(gpr);
 2399             JITCompiler::JumpList converted;
 2400 
 2401             if (node-&gt;child1().useKind() == NumberUse) {
 2402                 DFG_TYPE_CHECK(
 2403                     JSValueRegs(gpr), node-&gt;child1(), SpecBytecodeNumber,
 2404                     m_jit.branchIfNotNumber(gpr));
 2405             } else {
 2406                 JITCompiler::Jump isNumber = m_jit.branchIfNumber(gpr);
 2407 
 2408                 DFG_TYPE_CHECK(
 2409                     JSValueRegs(gpr), node-&gt;child1(), ~SpecCellCheck, m_jit.branchIfCell(JSValueRegs(gpr)));
 2410 
 2411                 // It&#39;s not a cell: so true turns into 1 and all else turns into 0.
<span class="line-modified"> 2412                 m_jit.compare64(JITCompiler::Equal, gpr, TrustedImm32(ValueTrue), resultGpr);</span>
 2413                 converted.append(m_jit.jump());
 2414 
 2415                 isNumber.link(&amp;m_jit);
 2416             }
 2417 
 2418             // First, if we get here we have a double encoded as a JSValue
 2419             unboxDouble(gpr, resultGpr, fpr);
 2420 #if CPU(ARM64)
 2421             if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics())
 2422                 m_jit.convertDoubleToInt32UsingJavaScriptSemantics(fpr, resultGpr);
 2423             else
 2424 #endif
 2425             {
 2426                 silentSpillAllRegisters(resultGpr);
 2427                 callOperation(operationToInt32, resultGpr, fpr);
 2428                 silentFillAllRegisters();
 2429             }
 2430 
 2431             converted.append(m_jit.jump());
 2432 
</pre>
<hr />
<pre>
 2613             return;
 2614         }
 2615 
 2616         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2617         FPRTemporary result(this);
 2618 
 2619 #if USE(JSVALUE64)
 2620         GPRTemporary temp(this);
 2621 
 2622         GPRReg op1GPR = op1.gpr();
 2623         GPRReg tempGPR = temp.gpr();
 2624         FPRReg resultFPR = result.fpr();
 2625         JITCompiler::JumpList done;
 2626 
 2627         JITCompiler::Jump isInteger = m_jit.branchIfInt32(op1GPR);
 2628 
 2629         if (node-&gt;child1().useKind() == NotCellUse) {
 2630             JITCompiler::Jump isNumber = m_jit.branchIfNumber(op1GPR);
 2631             JITCompiler::Jump isUndefined = m_jit.branchIfUndefined(op1GPR);
 2632 
<span class="line-modified"> 2633             static const double zero = 0;</span>
 2634             m_jit.loadDouble(TrustedImmPtr(&amp;zero), resultFPR);
 2635 
 2636             JITCompiler::Jump isNull = m_jit.branchIfNull(op1GPR);
 2637             done.append(isNull);
 2638 
 2639             DFG_TYPE_CHECK(JSValueRegs(op1GPR), node-&gt;child1(), ~SpecCellCheck,
<span class="line-modified"> 2640                 m_jit.branchTest64(JITCompiler::Zero, op1GPR, TrustedImm32(static_cast&lt;int32_t&gt;(TagBitBool))));</span>
 2641 
<span class="line-modified"> 2642             JITCompiler::Jump isFalse = m_jit.branch64(JITCompiler::Equal, op1GPR, TrustedImm64(ValueFalse));</span>
<span class="line-modified"> 2643             static const double one = 1;</span>
 2644             m_jit.loadDouble(TrustedImmPtr(&amp;one), resultFPR);
 2645             done.append(m_jit.jump());
 2646             done.append(isFalse);
 2647 
 2648             isUndefined.link(&amp;m_jit);
 2649             static const double NaN = PNaN;
 2650             m_jit.loadDouble(TrustedImmPtr(&amp;NaN), resultFPR);
 2651             done.append(m_jit.jump());
 2652 
 2653             isNumber.link(&amp;m_jit);
 2654         } else if (needsTypeCheck(node-&gt;child1(), SpecBytecodeNumber)) {
 2655             typeCheck(
 2656                 JSValueRegs(op1GPR), node-&gt;child1(), SpecBytecodeNumber,
 2657                 m_jit.branchIfNotNumber(op1GPR));
 2658         }
 2659 
 2660         unboxDouble(op1GPR, tempGPR, resultFPR);
 2661         done.append(m_jit.jump());
 2662 
 2663         isInteger.link(&amp;m_jit);
 2664         m_jit.convertInt32ToDouble(op1GPR, resultFPR);
 2665         done.link(&amp;m_jit);
 2666 #else // USE(JSVALUE64) -&gt; this is the 32_64 case
 2667         FPRTemporary temp(this);
 2668 
 2669         GPRReg op1TagGPR = op1.tagGPR();
 2670         GPRReg op1PayloadGPR = op1.payloadGPR();
 2671         FPRReg tempFPR = temp.fpr();
 2672         FPRReg resultFPR = result.fpr();
 2673         JITCompiler::JumpList done;
 2674 
 2675         JITCompiler::Jump isInteger = m_jit.branchIfInt32(op1TagGPR);
 2676 
 2677         if (node-&gt;child1().useKind() == NotCellUse) {
 2678             JITCompiler::Jump isNumber = m_jit.branch32(JITCompiler::Below, op1TagGPR, JITCompiler::TrustedImm32(JSValue::LowestTag + 1));
 2679             JITCompiler::Jump isUndefined = m_jit.branchIfUndefined(op1TagGPR);
 2680 
<span class="line-modified"> 2681             static const double zero = 0;</span>
 2682             m_jit.loadDouble(TrustedImmPtr(&amp;zero), resultFPR);
 2683 
 2684             JITCompiler::Jump isNull = m_jit.branchIfNull(op1TagGPR);
 2685             done.append(isNull);
 2686 
 2687             DFG_TYPE_CHECK(JSValueRegs(op1TagGPR, op1PayloadGPR), node-&gt;child1(), ~SpecCell, m_jit.branchIfNotBoolean(op1TagGPR, InvalidGPRReg));
 2688 
 2689             JITCompiler::Jump isFalse = m_jit.branchTest32(JITCompiler::Zero, op1PayloadGPR, TrustedImm32(1));
<span class="line-modified"> 2690             static const double one = 1;</span>
 2691             m_jit.loadDouble(TrustedImmPtr(&amp;one), resultFPR);
 2692             done.append(m_jit.jump());
 2693             done.append(isFalse);
 2694 
 2695             isUndefined.link(&amp;m_jit);
 2696             static const double NaN = PNaN;
 2697             m_jit.loadDouble(TrustedImmPtr(&amp;NaN), resultFPR);
 2698             done.append(m_jit.jump());
 2699 
 2700             isNumber.link(&amp;m_jit);
 2701         } else if (needsTypeCheck(node-&gt;child1(), SpecBytecodeNumber)) {
 2702             // This check fails with Int32Tag, but it is OK since Int32 case is already excluded.
 2703             typeCheck(
 2704                 JSValueRegs(op1TagGPR, op1PayloadGPR), node-&gt;child1(), SpecBytecodeNumber,
 2705                 m_jit.branch32(MacroAssembler::AboveOrEqual, op1TagGPR, TrustedImm32(JSValue::LowestTag)));
 2706         }
 2707 
 2708         unboxDouble(op1TagGPR, op1PayloadGPR, resultFPR, tempFPR);
 2709         done.append(m_jit.jump());
 2710 
</pre>
<hr />
<pre>
 2790     else if (d &gt; 255)
 2791         d = 255;
 2792     return d;
 2793 }
 2794 
 2795 static void compileClampIntegerToByte(JITCompiler&amp; jit, GPRReg result)
 2796 {
 2797     MacroAssembler::Jump inBounds = jit.branch32(MacroAssembler::BelowOrEqual, result, JITCompiler::TrustedImm32(0xff));
 2798     MacroAssembler::Jump tooBig = jit.branch32(MacroAssembler::GreaterThan, result, JITCompiler::TrustedImm32(0xff));
 2799     jit.xorPtr(result, result);
 2800     MacroAssembler::Jump clamped = jit.jump();
 2801     tooBig.link(&amp;jit);
 2802     jit.move(JITCompiler::TrustedImm32(255), result);
 2803     clamped.link(&amp;jit);
 2804     inBounds.link(&amp;jit);
 2805 }
 2806 
 2807 static void compileClampDoubleToByte(JITCompiler&amp; jit, GPRReg result, FPRReg source, FPRReg scratch)
 2808 {
 2809     // Unordered compare so we pick up NaN
<span class="line-modified"> 2810     static const double zero = 0;</span>
<span class="line-modified"> 2811     static const double byteMax = 255;</span>
<span class="line-modified"> 2812     static const double half = 0.5;</span>
 2813     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;zero), scratch);
 2814     MacroAssembler::Jump tooSmall = jit.branchDouble(MacroAssembler::DoubleLessThanOrEqualOrUnordered, source, scratch);
 2815     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;byteMax), scratch);
 2816     MacroAssembler::Jump tooBig = jit.branchDouble(MacroAssembler::DoubleGreaterThan, source, scratch);
 2817 
 2818     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;half), scratch);
 2819     // FIXME: This should probably just use a floating point round!
 2820     // https://bugs.webkit.org/show_bug.cgi?id=72054
 2821     jit.addDouble(source, scratch);
 2822     jit.truncateDoubleToInt32(scratch, result);
 2823     MacroAssembler::Jump truncatedInt = jit.jump();
 2824 
 2825     tooSmall.link(&amp;jit);
 2826     jit.xorPtr(result, result);
 2827     MacroAssembler::Jump zeroed = jit.jump();
 2828 
 2829     tooBig.link(&amp;jit);
 2830     jit.move(JITCompiler::TrustedImm32(255), result);
 2831 
 2832     truncatedInt.link(&amp;jit);
</pre>
<hr />
<pre>
 3055                 propertyTag.adopt(realPropertyTag);
 3056                 GPRReg propertyTagGPR = propertyTag.gpr();
 3057 
 3058                 GPRTemporary realValueTag(this);
 3059                 valueTag.adopt(realValueTag);
 3060                 GPRReg valueTagGPR = valueTag.gpr();
 3061 #endif
 3062                 SpeculateDoubleOperand valueOp(this, valueUse);
 3063                 GPRTemporary result(this);
 3064                 FPRReg fpr = valueOp.fpr();
 3065                 GPRReg gpr = result.gpr();
 3066                 MacroAssembler::Jump notNaN = m_jit.branchIfNotNaN(fpr);
 3067                 m_jit.xorPtr(gpr, gpr);
 3068                 MacroAssembler::JumpList fixed(m_jit.jump());
 3069                 notNaN.link(&amp;m_jit);
 3070 
 3071                 fixed.append(m_jit.branchTruncateDoubleToInt32(
 3072                     fpr, gpr, MacroAssembler::BranchIfTruncateSuccessful));
 3073 
 3074 #if USE(JSVALUE64)
<span class="line-modified"> 3075                 m_jit.or64(GPRInfo::tagTypeNumberRegister, property);</span>
 3076                 boxDouble(fpr, gpr);
 3077 #else
 3078                 UNUSED_PARAM(property);
 3079                 m_jit.move(TrustedImm32(JSValue::Int32Tag), propertyTagGPR);
 3080                 boxDouble(fpr, valueTagGPR, gpr);
 3081 #endif
 3082                 slowPathCases.append(m_jit.jump());
 3083 
 3084                 fixed.link(&amp;m_jit);
 3085                 value.adopt(result);
 3086             }
 3087             break;
 3088         }
 3089 
 3090         default:
 3091             RELEASE_ASSERT_NOT_REACHED();
 3092             break;
 3093         }
 3094     }
 3095     return true;
</pre>
<hr />
<pre>
 3141     case 2:
 3142         m_jit.store16(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesTwo));
 3143         break;
 3144     case 4:
 3145         m_jit.store32(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesFour));
 3146         break;
 3147     default:
 3148         CRASH();
 3149     }
 3150 
 3151     JITCompiler::Jump done = jumpForTypedArrayIsNeuteredIfOutOfBounds(node, base, outOfBounds);
 3152     if (done.isSet())
 3153         done.link(&amp;m_jit);
 3154 
 3155     if (!slowPathCases.empty()) {
 3156 #if USE(JSVALUE64)
 3157         if (node-&gt;op() == PutByValDirect) {
 3158             addSlowPathGenerator(slowPathCall(
 3159                 slowPathCases, this,
 3160                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict,
<span class="line-modified"> 3161                 NoResult, base, property, valueGPR));</span>
 3162         } else {
 3163             addSlowPathGenerator(slowPathCall(
 3164                 slowPathCases, this,
 3165                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict,
<span class="line-modified"> 3166                 NoResult, base, property, valueGPR));</span>
 3167         }
 3168 #else // not USE(JSVALUE64)
 3169         if (node-&gt;op() == PutByValDirect) {
 3170             addSlowPathGenerator(slowPathCall(
 3171                 slowPathCases, this,
 3172                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict,
<span class="line-modified"> 3173                 NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));</span>
 3174         } else {
 3175             addSlowPathGenerator(slowPathCall(
 3176                 slowPathCases, this,
 3177                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict,
<span class="line-modified"> 3178                 NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));</span>
 3179         }
 3180 #endif
 3181     }
 3182 
 3183     noResult(node);
 3184 }
 3185 
 3186 void SpeculativeJIT::compileGetByValOnFloatTypedArray(Node* node, TypedArrayType type)
 3187 {
 3188     ASSERT(isFloat(type));
 3189 
 3190     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 3191     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 3192     StorageOperand storage(this, m_graph.varArgChild(node, 2));
 3193 
 3194     GPRReg baseReg = base.gpr();
 3195     GPRReg propertyReg = property.gpr();
 3196     GPRReg storageReg = storage.gpr();
 3197 
 3198     FPRTemporary result(this);
</pre>
<hr />
<pre>
 3250     JITCompiler::Jump done = jumpForTypedArrayIsNeuteredIfOutOfBounds(node, base, outOfBounds);
 3251     if (done.isSet())
 3252         done.link(&amp;m_jit);
 3253     noResult(node);
 3254 }
 3255 
 3256 void SpeculativeJIT::compileGetByValForObjectWithString(Node* node)
 3257 {
 3258     SpeculateCellOperand arg1(this, m_graph.varArgChild(node, 0));
 3259     SpeculateCellOperand arg2(this, m_graph.varArgChild(node, 1));
 3260 
 3261     GPRReg arg1GPR = arg1.gpr();
 3262     GPRReg arg2GPR = arg2.gpr();
 3263 
 3264     speculateObject(m_graph.varArgChild(node, 0), arg1GPR);
 3265     speculateString(m_graph.varArgChild(node, 1), arg2GPR);
 3266 
 3267     flushRegisters();
 3268     JSValueRegsFlushedCallResult result(this);
 3269     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3270     callOperation(operationGetByValObjectString, resultRegs, arg1GPR, arg2GPR);</span>
 3271     m_jit.exceptionCheck();
 3272 
 3273     jsValueResult(resultRegs, node);
 3274 }
 3275 
 3276 void SpeculativeJIT::compileGetByValForObjectWithSymbol(Node* node)
 3277 {
 3278     SpeculateCellOperand arg1(this, m_graph.varArgChild(node, 0));
 3279     SpeculateCellOperand arg2(this, m_graph.varArgChild(node, 1));
 3280 
 3281     GPRReg arg1GPR = arg1.gpr();
 3282     GPRReg arg2GPR = arg2.gpr();
 3283 
 3284     speculateObject(m_graph.varArgChild(node, 0), arg1GPR);
 3285     speculateSymbol(m_graph.varArgChild(node, 1), arg2GPR);
 3286 
 3287     flushRegisters();
 3288     JSValueRegsFlushedCallResult result(this);
 3289     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3290     callOperation(operationGetByValObjectSymbol, resultRegs, arg1GPR, arg2GPR);</span>
 3291     m_jit.exceptionCheck();
 3292 
 3293     jsValueResult(resultRegs, node);
 3294 }
 3295 
 3296 void SpeculativeJIT::compilePutByValForCellWithString(Node* node, Edge&amp; child1, Edge&amp; child2, Edge&amp; child3)
 3297 {
 3298     SpeculateCellOperand arg1(this, child1);
 3299     SpeculateCellOperand arg2(this, child2);
 3300     JSValueOperand arg3(this, child3);
 3301 
 3302     GPRReg arg1GPR = arg1.gpr();
 3303     GPRReg arg2GPR = arg2.gpr();
 3304     JSValueRegs arg3Regs = arg3.jsValueRegs();
 3305 
 3306     speculateString(child2, arg2GPR);
 3307 
 3308     flushRegisters();
<span class="line-modified"> 3309     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStringStrict : operationPutByValCellStringNonStrict, arg1GPR, arg2GPR, arg3Regs);</span>
 3310     m_jit.exceptionCheck();
 3311 
 3312     noResult(node);
 3313 }
 3314 
 3315 void SpeculativeJIT::compilePutByValForCellWithSymbol(Node* node, Edge&amp; child1, Edge&amp; child2, Edge&amp; child3)
 3316 {
 3317     SpeculateCellOperand arg1(this, child1);
 3318     SpeculateCellOperand arg2(this, child2);
 3319     JSValueOperand arg3(this, child3);
 3320 
 3321     GPRReg arg1GPR = arg1.gpr();
 3322     GPRReg arg2GPR = arg2.gpr();
 3323     JSValueRegs arg3Regs = arg3.jsValueRegs();
 3324 
 3325     speculateSymbol(child2, arg2GPR);
 3326 
 3327     flushRegisters();
<span class="line-modified"> 3328     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellSymbolStrict : operationPutByValCellSymbolNonStrict, arg1GPR, arg2GPR, arg3Regs);</span>
 3329     m_jit.exceptionCheck();
 3330 
 3331     noResult(node);
 3332 }
 3333 
 3334 void SpeculativeJIT::compileGetByValWithThis(Node* node)
 3335 {
 3336     JSValueOperand base(this, node-&gt;child1());
 3337     JSValueRegs baseRegs = base.jsValueRegs();
 3338     JSValueOperand thisValue(this, node-&gt;child2());
 3339     JSValueRegs thisValueRegs = thisValue.jsValueRegs();
 3340     JSValueOperand subscript(this, node-&gt;child3());
 3341     JSValueRegs subscriptRegs = subscript.jsValueRegs();
 3342 
 3343     flushRegisters();
 3344     JSValueRegsFlushedCallResult result(this);
 3345     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3346     callOperation(operationGetByValWithThis, resultRegs, baseRegs, thisValueRegs, subscriptRegs);</span>
 3347     m_jit.exceptionCheck();
 3348 
 3349     jsValueResult(resultRegs, node);
 3350 }
 3351 
 3352 void SpeculativeJIT::compileCheckTypeInfoFlags(Node* node)
 3353 {
 3354     SpeculateCellOperand base(this, node-&gt;child1());
 3355 
 3356     GPRReg baseGPR = base.gpr();
 3357 
 3358     // FIXME: This only works for checking if a single bit is set. If we want to check more
 3359     // than one bit at once, we&#39;ll need to fix this:
 3360     // https://bugs.webkit.org/show_bug.cgi?id=185705
 3361     speculationCheck(BadTypeInfoFlags, JSValueRegs(), 0, m_jit.branchTest8(MacroAssembler::Zero, MacroAssembler::Address(baseGPR, JSCell::typeInfoFlagsOffset()), MacroAssembler::TrustedImm32(node-&gt;typeInfoOperand())));
 3362 
 3363     noResult(node);
 3364 }
 3365 
 3366 void SpeculativeJIT::compileParseInt(Node* node)
 3367 {
 3368     RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse || node-&gt;child1().useKind() == StringUse);
 3369     if (node-&gt;child2()) {
 3370         SpeculateInt32Operand radix(this, node-&gt;child2());
 3371         GPRReg radixGPR = radix.gpr();
 3372         if (node-&gt;child1().useKind() == UntypedUse) {
 3373             JSValueOperand value(this, node-&gt;child1());
 3374             JSValueRegs valueRegs = value.jsValueRegs();
 3375 
 3376             flushRegisters();
 3377             JSValueRegsFlushedCallResult result(this);
 3378             JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3379             callOperation(operationParseIntGeneric, resultRegs, valueRegs, radixGPR);</span>
 3380             m_jit.exceptionCheck();
 3381             jsValueResult(resultRegs, node);
 3382             return;
 3383         }
 3384 
 3385         SpeculateCellOperand value(this, node-&gt;child1());
 3386         GPRReg valueGPR = value.gpr();
 3387         speculateString(node-&gt;child1(), valueGPR);
 3388 
 3389         flushRegisters();
 3390         JSValueRegsFlushedCallResult result(this);
 3391         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3392         callOperation(operationParseIntString, resultRegs, valueGPR, radixGPR);</span>
 3393         m_jit.exceptionCheck();
 3394         jsValueResult(resultRegs, node);
 3395         return;
 3396     }
 3397 
 3398     if (node-&gt;child1().useKind() == UntypedUse) {
 3399         JSValueOperand value(this, node-&gt;child1());
 3400         JSValueRegs valueRegs = value.jsValueRegs();
 3401 
 3402         flushRegisters();
 3403         JSValueRegsFlushedCallResult result(this);
 3404         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3405         callOperation(operationParseIntNoRadixGeneric, resultRegs, valueRegs);</span>
 3406         m_jit.exceptionCheck();
 3407         jsValueResult(resultRegs, node);
 3408         return;
 3409     }
 3410 
 3411     SpeculateCellOperand value(this, node-&gt;child1());
 3412     GPRReg valueGPR = value.gpr();
 3413     speculateString(node-&gt;child1(), valueGPR);
 3414 
 3415     flushRegisters();
 3416     JSValueRegsFlushedCallResult result(this);
 3417     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3418     callOperation(operationParseIntStringNoRadix, resultRegs, valueGPR);</span>
 3419     m_jit.exceptionCheck();
 3420     jsValueResult(resultRegs, node);
 3421 }
 3422 
 3423 void SpeculativeJIT::compileOverridesHasInstance(Node* node)
 3424 {
 3425     Node* hasInstanceValueNode = node-&gt;child2().node();
 3426     JSFunction* defaultHasInstanceFunction = jsCast&lt;JSFunction*&gt;(node-&gt;cellOperand()-&gt;value());
 3427 
 3428     MacroAssembler::JumpList notDefault;
 3429     SpeculateCellOperand base(this, node-&gt;child1());
 3430     JSValueOperand hasInstanceValue(this, node-&gt;child2());
 3431     GPRTemporary result(this);
 3432 
 3433     GPRReg baseGPR = base.gpr();
 3434     GPRReg resultGPR = result.gpr();
 3435 
 3436     // It would be great if constant folding handled automatically the case where we knew the hasInstance function
 3437     // was a constant. Unfortunately, the folding rule for OverridesHasInstance is in the strength reduction phase
 3438     // since it relies on OSR information. https://bugs.webkit.org/show_bug.cgi?id=154832
</pre>
<hr />
<pre>
 3456     }
 3457 
 3458     done.link(&amp;m_jit);
 3459     unblessedBooleanResult(resultGPR, node);
 3460 }
 3461 
 3462 void SpeculativeJIT::compileInstanceOfForCells(Node* node, JSValueRegs valueRegs, JSValueRegs prototypeRegs, GPRReg resultGPR, GPRReg scratchGPR, GPRReg scratch2GPR, JITCompiler::Jump slowCase)
 3463 {
 3464     CallSiteIndex callSiteIndex = m_jit.addCallSite(node-&gt;origin.semantic);
 3465 
 3466     JITInstanceOfGenerator gen(
 3467         m_jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex, usedRegisters(), resultGPR,
 3468         valueRegs.payloadGPR(), prototypeRegs.payloadGPR(), scratchGPR, scratch2GPR,
 3469         m_state.forNode(node-&gt;child2()).isType(SpecObject | ~SpecCell));
 3470     gen.generateFastPath(m_jit);
 3471 
 3472     JITCompiler::JumpList slowCases;
 3473     slowCases.append(slowCase);
 3474 
 3475     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
<span class="line-modified"> 3476         slowCases, this, operationInstanceOfOptimize, resultGPR, gen.stubInfo(), valueRegs,</span>
 3477         prototypeRegs);
 3478 
 3479     m_jit.addInstanceOf(gen, slowPath.get());
 3480     addSlowPathGenerator(WTFMove(slowPath));
 3481 }
 3482 
 3483 void SpeculativeJIT::compileInstanceOf(Node* node)
 3484 {
 3485 #if USE(JSVALUE64)
 3486     if (node-&gt;child1().useKind() == CellUse
 3487         &amp;&amp; node-&gt;child2().useKind() == CellUse) {
 3488         SpeculateCellOperand value(this, node-&gt;child1());
 3489         SpeculateCellOperand prototype(this, node-&gt;child2());
 3490 
 3491         GPRTemporary result(this);
 3492         GPRTemporary scratch(this);
 3493         GPRTemporary scratch2(this);
 3494 
 3495         GPRReg valueGPR = value.gpr();
 3496         GPRReg prototypeGPR = prototype.gpr();
</pre>
<hr />
<pre>
 3533 
 3534     done.link(&amp;m_jit);
 3535     blessedBooleanResult(resultGPR, node);
 3536     return;
 3537 }
 3538 
 3539 void SpeculativeJIT::compileValueBitNot(Node* node)
 3540 {
 3541     Edge&amp; child1 = node-&gt;child1();
 3542 
 3543     if (child1.useKind() == BigIntUse) {
 3544         SpeculateCellOperand operand(this, child1);
 3545         GPRReg operandGPR = operand.gpr();
 3546 
 3547         speculateBigInt(child1, operandGPR);
 3548 
 3549         flushRegisters();
 3550         GPRFlushedCallResult result(this);
 3551         GPRReg resultGPR = result.gpr();
 3552 
<span class="line-modified"> 3553         callOperation(operationBitNotBigInt, resultGPR, operandGPR);</span>
 3554         m_jit.exceptionCheck();
 3555         cellResult(resultGPR, node);
 3556 
 3557         return;
 3558     }
 3559 
 3560     JSValueOperand operand(this, child1);
 3561     JSValueRegs operandRegs = operand.jsValueRegs();
 3562 
 3563     flushRegisters();
 3564     JSValueRegsFlushedCallResult result(this);
 3565     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3566     callOperation(operationValueBitNot, resultRegs, operandRegs);</span>
 3567     m_jit.exceptionCheck();
 3568 
 3569     jsValueResult(resultRegs, node);
 3570 }
 3571 
 3572 void SpeculativeJIT::compileBitwiseNot(Node* node)
 3573 {
 3574     Edge&amp; child1 = node-&gt;child1();
 3575 
 3576     SpeculateInt32Operand operand(this, child1);
 3577     GPRTemporary result(this);
 3578     GPRReg resultGPR = result.gpr();
 3579 
 3580     m_jit.move(operand.gpr(), resultGPR);
 3581 
 3582     m_jit.not32(resultGPR);
 3583 
 3584     int32Result(resultGPR, node);
 3585 }
 3586 
<span class="line-modified"> 3587 template&lt;typename SnippetGenerator, J_JITOperation_EJJ snippetSlowPathFunction&gt;</span>
 3588 void SpeculativeJIT::emitUntypedBitOp(Node* node)
 3589 {
 3590     Edge&amp; leftChild = node-&gt;child1();
 3591     Edge&amp; rightChild = node-&gt;child2();
 3592 
 3593     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3594         JSValueOperand left(this, leftChild);
 3595         JSValueOperand right(this, rightChild);
 3596         JSValueRegs leftRegs = left.jsValueRegs();
 3597         JSValueRegs rightRegs = right.jsValueRegs();
 3598 
 3599         flushRegisters();
 3600         JSValueRegsFlushedCallResult result(this);
 3601         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3602         callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);</span>
 3603         m_jit.exceptionCheck();
 3604 
 3605         jsValueResult(resultRegs, node);
 3606         return;
 3607     }
 3608 
 3609     Optional&lt;JSValueOperand&gt; left;
 3610     Optional&lt;JSValueOperand&gt; right;
 3611 
 3612     JSValueRegs leftRegs;
 3613     JSValueRegs rightRegs;
 3614 
 3615 #if USE(JSVALUE64)
 3616     GPRTemporary result(this);
 3617     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 3618     GPRTemporary scratch(this);
 3619     GPRReg scratchGPR = scratch.gpr();
 3620 #else
 3621     GPRTemporary resultTag(this);
 3622     GPRTemporary resultPayload(this);
</pre>
<hr />
<pre>
 3645         rightRegs = right-&gt;jsValueRegs();
 3646     }
 3647 
 3648     SnippetGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs, scratchGPR);
 3649     gen.generateFastPath(m_jit);
 3650 
 3651     ASSERT(gen.didEmitFastPath());
 3652     gen.endJumpList().append(m_jit.jump());
 3653 
 3654     gen.slowPathJumpList().link(&amp;m_jit);
 3655     silentSpillAllRegisters(resultRegs);
 3656 
 3657     if (leftOperand.isConst()) {
 3658         leftRegs = resultRegs;
 3659         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 3660     } else if (rightOperand.isConst()) {
 3661         rightRegs = resultRegs;
 3662         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 3663     }
 3664 
<span class="line-modified"> 3665     callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);</span>
 3666 
 3667     silentFillAllRegisters();
 3668     m_jit.exceptionCheck();
 3669 
 3670     gen.endJumpList().link(&amp;m_jit);
 3671     jsValueResult(resultRegs, node);
 3672 }
 3673 
 3674 void SpeculativeJIT::compileValueBitwiseOp(Node* node)
 3675 {
 3676     NodeType op = node-&gt;op();
 3677     Edge&amp; leftChild = node-&gt;child1();
 3678     Edge&amp; rightChild = node-&gt;child2();
 3679 
 3680     if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
 3681         switch (op) {
 3682         case ValueBitAnd:
 3683             emitUntypedBitOp&lt;JITBitAndGenerator, operationValueBitAnd&gt;(node);
 3684             return;
 3685         case ValueBitXor:
</pre>
<hr />
<pre>
 3692             RELEASE_ASSERT_NOT_REACHED();
 3693         }
 3694     }
 3695 
 3696     ASSERT(leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse);
 3697 
 3698     SpeculateCellOperand left(this, node-&gt;child1());
 3699     SpeculateCellOperand right(this, node-&gt;child2());
 3700     GPRReg leftGPR = left.gpr();
 3701     GPRReg rightGPR = right.gpr();
 3702 
 3703     speculateBigInt(leftChild, leftGPR);
 3704     speculateBigInt(rightChild, rightGPR);
 3705 
 3706     flushRegisters();
 3707     GPRFlushedCallResult result(this);
 3708     GPRReg resultGPR = result.gpr();
 3709 
 3710     switch (op) {
 3711     case ValueBitAnd:
<span class="line-modified"> 3712         callOperation(operationBitAndBigInt, resultGPR, leftGPR, rightGPR);</span>
 3713         break;
 3714     case ValueBitXor:
<span class="line-modified"> 3715         callOperation(operationBitXorBigInt, resultGPR, leftGPR, rightGPR);</span>
 3716         break;
 3717     case ValueBitOr:
<span class="line-modified"> 3718         callOperation(operationBitOrBigInt, resultGPR, leftGPR, rightGPR);</span>
 3719         break;
 3720     default:
 3721         RELEASE_ASSERT_NOT_REACHED();
 3722     }
 3723 
 3724     m_jit.exceptionCheck();
 3725     cellResult(resultGPR, node);
 3726 }
 3727 
 3728 void SpeculativeJIT::compileBitwiseOp(Node* node)
 3729 {
 3730     NodeType op = node-&gt;op();
 3731     Edge&amp; leftChild = node-&gt;child1();
 3732     Edge&amp; rightChild = node-&gt;child2();
 3733 
 3734     if (leftChild-&gt;isInt32Constant()) {
 3735         SpeculateInt32Operand op2(this, rightChild);
 3736         GPRTemporary result(this, Reuse, op2);
 3737 
 3738         bitOp(op, leftChild-&gt;asInt32(), op2.gpr(), result.gpr());
</pre>
<hr />
<pre>
 3747 
 3748         bitOp(op, rightChild-&gt;asInt32(), op1.gpr(), result.gpr());
 3749 
 3750         int32Result(result.gpr(), node);
 3751         return;
 3752     }
 3753 
 3754     SpeculateInt32Operand op1(this, leftChild);
 3755     SpeculateInt32Operand op2(this, rightChild);
 3756     GPRTemporary result(this, Reuse, op1, op2);
 3757 
 3758     GPRReg reg1 = op1.gpr();
 3759     GPRReg reg2 = op2.gpr();
 3760     bitOp(op, reg1, reg2, result.gpr());
 3761 
 3762     int32Result(result.gpr(), node);
 3763 }
 3764 
 3765 void SpeculativeJIT::emitUntypedRightShiftBitOp(Node* node)
 3766 {
<span class="line-modified"> 3767     J_JITOperation_EJJ snippetSlowPathFunction = node-&gt;op() == BitRShift</span>
 3768         ? operationValueBitRShift : operationValueBitURShift;
<span class="line-modified"> 3769     JITRightShiftGenerator::ShiftType shiftType = node-&gt;op() == BitRShift</span>
 3770         ? JITRightShiftGenerator::SignedShift : JITRightShiftGenerator::UnsignedShift;
 3771 
 3772     Edge&amp; leftChild = node-&gt;child1();
 3773     Edge&amp; rightChild = node-&gt;child2();
 3774 
 3775     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3776         JSValueOperand left(this, leftChild);
 3777         JSValueOperand right(this, rightChild);
 3778         JSValueRegs leftRegs = left.jsValueRegs();
 3779         JSValueRegs rightRegs = right.jsValueRegs();
 3780 
 3781         flushRegisters();
 3782         JSValueRegsFlushedCallResult result(this);
 3783         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3784         callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);</span>
 3785         m_jit.exceptionCheck();
 3786 
 3787         jsValueResult(resultRegs, node);
 3788         return;
 3789     }
 3790 
 3791     Optional&lt;JSValueOperand&gt; left;
 3792     Optional&lt;JSValueOperand&gt; right;
 3793 
 3794     JSValueRegs leftRegs;
 3795     JSValueRegs rightRegs;
 3796 
 3797     FPRTemporary leftNumber(this);
 3798     FPRReg leftFPR = leftNumber.fpr();
 3799 
 3800 #if USE(JSVALUE64)
 3801     GPRTemporary result(this);
 3802     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 3803     GPRTemporary scratch(this);
 3804     GPRReg scratchGPR = scratch.gpr();
</pre>
<hr />
<pre>
 3834     }
 3835 
 3836     JITRightShiftGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs,
 3837         leftFPR, scratchGPR, scratchFPR, shiftType);
 3838     gen.generateFastPath(m_jit);
 3839 
 3840     ASSERT(gen.didEmitFastPath());
 3841     gen.endJumpList().append(m_jit.jump());
 3842 
 3843     gen.slowPathJumpList().link(&amp;m_jit);
 3844     silentSpillAllRegisters(resultRegs);
 3845 
 3846     if (leftOperand.isConst()) {
 3847         leftRegs = resultRegs;
 3848         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 3849     } else if (rightOperand.isConst()) {
 3850         rightRegs = resultRegs;
 3851         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 3852     }
 3853 
<span class="line-modified"> 3854     callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);</span>
 3855 
 3856     silentFillAllRegisters();
 3857     m_jit.exceptionCheck();
 3858 
 3859     gen.endJumpList().link(&amp;m_jit);
 3860     jsValueResult(resultRegs, node);
 3861     return;
 3862 }
 3863 
 3864 void SpeculativeJIT::compileValueLShiftOp(Node* node)
 3865 {
 3866     Edge&amp; leftChild = node-&gt;child1();
 3867     Edge&amp; rightChild = node-&gt;child2();
 3868 
 3869     if (node-&gt;binaryUseKind() == BigIntUse) {
 3870         SpeculateCellOperand left(this, leftChild);
 3871         SpeculateCellOperand right(this, rightChild);
 3872         GPRReg leftGPR = left.gpr();
 3873         GPRReg rightGPR = right.gpr();
 3874 
 3875         speculateBigInt(leftChild, leftGPR);
 3876         speculateBigInt(rightChild, rightGPR);
 3877 
 3878         flushRegisters();
 3879         GPRFlushedCallResult result(this);
 3880         GPRReg resultGPR = result.gpr();
 3881 
<span class="line-modified"> 3882         callOperation(operationBitLShiftBigInt, resultGPR, leftGPR, rightGPR);</span>
 3883         m_jit.exceptionCheck();
 3884         cellResult(resultGPR, node);
 3885         return;
 3886     }
 3887 
 3888     ASSERT(leftChild.useKind() == UntypedUse &amp;&amp; rightChild.useKind() == UntypedUse);
 3889     emitUntypedBitOp&lt;JITLeftShiftGenerator, operationValueBitLShift&gt;(node);
 3890 }
 3891 




























 3892 void SpeculativeJIT::compileShiftOp(Node* node)
 3893 {
 3894     NodeType op = node-&gt;op();
 3895     Edge&amp; leftChild = node-&gt;child1();
 3896     Edge&amp; rightChild = node-&gt;child2();
 3897 
 3898     if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
<span class="line-modified"> 3899         switch (op) {</span>
<span class="line-modified"> 3900         case BitRShift:</span>
<span class="line-modified"> 3901         case BitURShift:</span>
<span class="line-removed"> 3902             emitUntypedRightShiftBitOp(node);</span>
<span class="line-removed"> 3903             return;</span>
<span class="line-removed"> 3904         default:</span>
<span class="line-removed"> 3905             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 3906         }</span>
 3907     }
 3908 
 3909     if (rightChild-&gt;isInt32Constant()) {
 3910         SpeculateInt32Operand op1(this, leftChild);
 3911         GPRTemporary result(this, Reuse, op1);
 3912 
 3913         shiftOp(op, op1.gpr(), rightChild-&gt;asInt32() &amp; 0x1f, result.gpr());
 3914 
 3915         int32Result(result.gpr(), node);
 3916     } else {
 3917         // Do not allow shift amount to be used as the result, MacroAssembler does not permit this.
 3918         SpeculateInt32Operand op1(this, leftChild);
 3919         SpeculateInt32Operand op2(this, rightChild);
 3920         GPRTemporary result(this, Reuse, op1);
 3921 
 3922         GPRReg reg1 = op1.gpr();
 3923         GPRReg reg2 = op2.gpr();
 3924         shiftOp(op, reg1, reg2, result.gpr());
 3925 
 3926         int32Result(result.gpr(), node);
 3927     }
 3928 }
 3929 
 3930 void SpeculativeJIT::compileValueAdd(Node* node)
 3931 {
 3932     Edge&amp; leftChild = node-&gt;child1();
 3933     Edge&amp; rightChild = node-&gt;child2();
 3934 
 3935     if (node-&gt;isBinaryUseKind(BigIntUse)) {
 3936         SpeculateCellOperand left(this, node-&gt;child1());
 3937         SpeculateCellOperand right(this, node-&gt;child2());
 3938         GPRReg leftGPR = left.gpr();
 3939         GPRReg rightGPR = right.gpr();
 3940 
 3941         speculateBigInt(leftChild, leftGPR);
 3942         speculateBigInt(rightChild, rightGPR);
 3943 
 3944         flushRegisters();
 3945         GPRFlushedCallResult result(this);
 3946         GPRReg resultGPR = result.gpr();
<span class="line-modified"> 3947         callOperation(operationAddBigInt, resultGPR, leftGPR, rightGPR);</span>
 3948         m_jit.exceptionCheck();
 3949 
 3950         cellResult(resultGPR, node);
 3951         return;
 3952     }
 3953 
 3954     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3955         JSValueOperand left(this, leftChild);
 3956         JSValueOperand right(this, rightChild);
 3957         JSValueRegs leftRegs = left.jsValueRegs();
 3958         JSValueRegs rightRegs = right.jsValueRegs();
 3959 
 3960         flushRegisters();
 3961         JSValueRegsFlushedCallResult result(this);
 3962         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3963         callOperation(operationValueAddNotNumber, resultRegs, leftRegs, rightRegs);</span>
 3964         m_jit.exceptionCheck();
 3965 
 3966         jsValueResult(resultRegs, node);
 3967         return;
 3968     }
 3969 
 3970 #if USE(JSVALUE64)
 3971     bool needsScratchGPRReg = true;
 3972     bool needsScratchFPRReg = false;
 3973 #else
 3974     bool needsScratchGPRReg = true;
 3975     bool needsScratchFPRReg = true;
 3976 #endif
 3977 
 3978     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 3979     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 3980     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
 3981     JITAddIC* addIC = m_jit.codeBlock()-&gt;addJITAddIC(arithProfile);
 3982     auto repatchingFunction = operationValueAddOptimize;
 3983     auto nonRepatchingFunction = operationValueAdd;
 3984 
 3985     compileMathIC(node, addIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 3986 }
 3987 
 3988 void SpeculativeJIT::compileValueSub(Node* node)
 3989 {
 3990     Edge&amp; leftChild = node-&gt;child1();
 3991     Edge&amp; rightChild = node-&gt;child2();
 3992 
 3993     if (node-&gt;binaryUseKind() == UntypedUse) {
 3994 #if USE(JSVALUE64)
 3995         bool needsScratchGPRReg = true;
 3996         bool needsScratchFPRReg = false;
 3997 #else
 3998         bool needsScratchGPRReg = true;
 3999         bool needsScratchFPRReg = true;
 4000 #endif
 4001 
 4002         CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 4003         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4004         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
 4005         JITSubIC* subIC = m_jit.codeBlock()-&gt;addJITSubIC(arithProfile);
 4006         auto repatchingFunction = operationValueSubOptimize;
 4007         auto nonRepatchingFunction = operationValueSub;
 4008 
 4009         compileMathIC(node, subIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4010         return;
 4011     }
 4012 
 4013     ASSERT(leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse);
 4014 
 4015     SpeculateCellOperand left(this, node-&gt;child1());
 4016     SpeculateCellOperand right(this, node-&gt;child2());
 4017     GPRReg leftGPR = left.gpr();
 4018     GPRReg rightGPR = right.gpr();
 4019 
 4020     speculateBigInt(leftChild, leftGPR);
 4021     speculateBigInt(rightChild, rightGPR);
 4022 
 4023     flushRegisters();
 4024     GPRFlushedCallResult result(this);
 4025     GPRReg resultGPR = result.gpr();
 4026 
<span class="line-modified"> 4027     callOperation(operationSubBigInt, resultGPR, leftGPR, rightGPR);</span>
 4028 
 4029     m_jit.exceptionCheck();
 4030     cellResult(resultGPR, node);
 4031 }
 4032 
 4033 template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
 4034 void SpeculativeJIT::compileMathIC(Node* node, JITBinaryMathIC&lt;Generator&gt;* mathIC, bool needsScratchGPRReg, bool needsScratchFPRReg, RepatchingFunction repatchingFunction, NonRepatchingFunction nonRepatchingFunction)
 4035 {
 4036     Edge&amp; leftChild = node-&gt;child1();
 4037     Edge&amp; rightChild = node-&gt;child2();
 4038 
 4039     Optional&lt;JSValueOperand&gt; left;
 4040     Optional&lt;JSValueOperand&gt; right;
 4041 
 4042     JSValueRegs leftRegs;
 4043     JSValueRegs rightRegs;
 4044 
 4045     FPRTemporary leftNumber(this);
 4046     FPRTemporary rightNumber(this);
 4047     FPRReg leftFPR = leftNumber.fpr();
</pre>
<hr />
<pre>
 4114         addSlowPathGeneratorLambda([=, savePlans = WTFMove(savePlans)] () {
 4115             addICGenerationState-&gt;slowPathJumps.link(&amp;m_jit);
 4116             addICGenerationState-&gt;slowPathStart = m_jit.label();
 4117 #if ENABLE(MATH_IC_STATS)
 4118             auto slowPathStart = m_jit.label();
 4119 #endif
 4120 
 4121             silentSpill(savePlans);
 4122 
 4123             auto innerLeftRegs = leftRegs;
 4124             auto innerRightRegs = rightRegs;
 4125             if (Generator::isLeftOperandValidConstant(leftOperand)) {
 4126                 innerLeftRegs = resultRegs;
 4127                 m_jit.moveValue(leftChild-&gt;asJSValue(), innerLeftRegs);
 4128             } else if (Generator::isRightOperandValidConstant(rightOperand)) {
 4129                 innerRightRegs = resultRegs;
 4130                 m_jit.moveValue(rightChild-&gt;asJSValue(), innerRightRegs);
 4131             }
 4132 
 4133             if (addICGenerationState-&gt;shouldSlowPathRepatch)
<span class="line-modified"> 4134                 addICGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_EJJMic&gt;(repatchingFunction), resultRegs, innerLeftRegs, innerRightRegs, TrustedImmPtr(mathIC));</span>
 4135             else
<span class="line-modified"> 4136                 addICGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, innerLeftRegs, innerRightRegs);</span>
 4137 
 4138             silentFill(savePlans);
 4139             m_jit.exceptionCheck();
 4140             m_jit.jump().linkTo(done, &amp;m_jit);
 4141 
 4142             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4143                 mathIC-&gt;finalizeInlineCode(*addICGenerationState, linkBuffer);
 4144             });
 4145 
 4146 #if ENABLE(MATH_IC_STATS)
 4147             auto slowPathEnd = m_jit.label();
 4148             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4149                 size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathStart).executableAddress());
 4150                 mathIC-&gt;m_generatedCodeSize += size;
 4151             });
 4152 #endif
 4153 
 4154         });
 4155     } else {
 4156         if (Generator::isLeftOperandValidConstant(leftOperand)) {
 4157             left.emplace(this, leftChild);
 4158             leftRegs = left-&gt;jsValueRegs();
 4159         } else if (Generator::isRightOperandValidConstant(rightOperand)) {
 4160             right.emplace(this, rightChild);
 4161             rightRegs = right-&gt;jsValueRegs();
 4162         }
 4163 
 4164         flushRegisters();
<span class="line-modified"> 4165         callOperation(nonRepatchingFunction, resultRegs, leftRegs, rightRegs);</span>
 4166         m_jit.exceptionCheck();
 4167     }
 4168 
 4169 #if ENABLE(MATH_IC_STATS)
 4170     auto inlineEnd = m_jit.label();
 4171     m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4172         size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineStart).executableAddress());
 4173         mathIC-&gt;m_generatedCodeSize += size;
 4174     });
 4175 #endif
 4176 
 4177     jsValueResult(resultRegs, node);
 4178     return;
 4179 }
 4180 
 4181 void SpeculativeJIT::compileInstanceOfCustom(Node* node)
 4182 {
 4183     // We could do something smarter here but this case is currently super rare and unless
 4184     // Symbol.hasInstance becomes popular will likely remain that way.
 4185 
 4186     JSValueOperand value(this, node-&gt;child1());
 4187     SpeculateCellOperand constructor(this, node-&gt;child2());
 4188     JSValueOperand hasInstanceValue(this, node-&gt;child3());
 4189     GPRTemporary result(this);
 4190 
 4191     JSValueRegs valueRegs = value.jsValueRegs();
 4192     GPRReg constructorGPR = constructor.gpr();
 4193     JSValueRegs hasInstanceRegs = hasInstanceValue.jsValueRegs();
 4194     GPRReg resultGPR = result.gpr();
 4195 
 4196     MacroAssembler::Jump slowCase = m_jit.jump();
 4197 
<span class="line-modified"> 4198     addSlowPathGenerator(slowPathCall(slowCase, this, operationInstanceOfCustom, resultGPR, valueRegs, constructorGPR, hasInstanceRegs));</span>
 4199 
 4200     unblessedBooleanResult(resultGPR, node);
 4201 }
 4202 
 4203 void SpeculativeJIT::compileIsCellWithType(Node* node)
 4204 {
 4205     switch (node-&gt;child1().useKind()) {
 4206     case UntypedUse: {
 4207         JSValueOperand value(this, node-&gt;child1());
 4208         GPRTemporary result(this, Reuse, value, PayloadWord);
 4209 
 4210         JSValueRegs valueRegs = value.jsValueRegs();
 4211         GPRReg resultGPR = result.gpr();
 4212 
 4213         JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 4214 
 4215         m_jit.compare8(JITCompiler::Equal,
 4216             JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()),
 4217             TrustedImm32(node-&gt;queriedType()),
 4218             resultGPR);
</pre>
<hr />
<pre>
 4273 
 4274     done.link(&amp;m_jit);
 4275     blessedBooleanResult(resultGPR, node);
 4276 }
 4277 
 4278 void SpeculativeJIT::compileToObjectOrCallObjectConstructor(Node* node)
 4279 {
 4280     RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse);
 4281 
 4282     JSValueOperand value(this, node-&gt;child1());
 4283     GPRTemporary result(this, Reuse, value, PayloadWord);
 4284 
 4285     JSValueRegs valueRegs = value.jsValueRegs();
 4286     GPRReg resultGPR = result.gpr();
 4287 
 4288     MacroAssembler::JumpList slowCases;
 4289     slowCases.append(m_jit.branchIfNotCell(valueRegs));
 4290     slowCases.append(m_jit.branchIfNotObject(valueRegs.payloadGPR()));
 4291     m_jit.move(valueRegs.payloadGPR(), resultGPR);
 4292 
<span class="line-modified"> 4293     if (node-&gt;op() == ToObject)</span>
<span class="line-modified"> 4294         addSlowPathGenerator(slowPathCall(slowCases, this, operationToObject, resultGPR, m_jit.graph().globalObjectFor(node-&gt;origin.semantic), valueRegs, identifierUID(node-&gt;identifierNumber())));</span>
<span class="line-modified"> 4295     else</span>



 4296         addSlowPathGenerator(slowPathCall(slowCases, this, operationCallObjectConstructor, resultGPR, TrustedImmPtr(node-&gt;cellOperand()), valueRegs));
 4297 
 4298     cellResult(resultGPR, node);
 4299 }
 4300 
 4301 void SpeculativeJIT::compileArithAdd(Node* node)
 4302 {
 4303     switch (node-&gt;binaryUseKind()) {
 4304     case Int32Use: {
 4305         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4306 
 4307         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4308             SpeculateInt32Operand op1(this, node-&gt;child1());
 4309             GPRTemporary result(this, Reuse, op1);
 4310 
 4311             GPRReg gpr1 = op1.gpr();
 4312             int32_t imm2 = node-&gt;child2()-&gt;asInt32();
 4313             GPRReg gprResult = result.gpr();
 4314 
 4315             if (!shouldCheckOverflow(node-&gt;arithMode())) {
</pre>
<hr />
<pre>
 4420             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, result.gpr()));
 4421         int32Result(result.gpr(), node);
 4422         break;
 4423     }
 4424 
 4425     case DoubleRepUse: {
 4426         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4427         FPRTemporary result(this);
 4428 
 4429         m_jit.absDouble(op1.fpr(), result.fpr());
 4430         doubleResult(result.fpr(), node);
 4431         break;
 4432     }
 4433 
 4434     default: {
 4435         DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
 4436         JSValueOperand op1(this, node-&gt;child1());
 4437         JSValueRegs op1Regs = op1.jsValueRegs();
 4438         flushRegisters();
 4439         FPRResult result(this);
<span class="line-modified"> 4440         callOperation(operationArithAbs, result.fpr(), op1Regs);</span>
 4441         m_jit.exceptionCheck();
 4442         doubleResult(result.fpr(), node);
 4443         break;
 4444     }
 4445     }
 4446 }
 4447 
 4448 void SpeculativeJIT::compileArithClz32(Node* node)
 4449 {
 4450     if (node-&gt;child1().useKind() == Int32Use || node-&gt;child1().useKind() == KnownInt32Use) {
 4451         SpeculateInt32Operand value(this, node-&gt;child1());
 4452         GPRTemporary result(this, Reuse, value);
 4453         GPRReg valueReg = value.gpr();
 4454         GPRReg resultReg = result.gpr();
 4455         m_jit.countLeadingZeros32(valueReg, resultReg);
 4456         int32Result(resultReg, node);
 4457         return;
 4458     }
 4459     JSValueOperand op1(this, node-&gt;child1());
 4460     JSValueRegs op1Regs = op1.jsValueRegs();
 4461     GPRTemporary result(this);
 4462     GPRReg resultReg = result.gpr();
 4463     flushRegisters();
<span class="line-modified"> 4464     callOperation(operationArithClz32, resultReg, op1Regs);</span>
 4465     m_jit.exceptionCheck();
 4466     int32Result(resultReg, node);
 4467 }
 4468 
<span class="line-modified"> 4469 void SpeculativeJIT::compileArithDoubleUnaryOp(Node* node, double (*doubleFunction)(double), double (*operation)(ExecState*, EncodedJSValue))</span>
 4470 {
 4471     if (node-&gt;child1().useKind() == DoubleRepUse) {
 4472         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4473         FPRReg op1FPR = op1.fpr();
 4474 
 4475         flushRegisters();
 4476 
 4477         FPRResult result(this);
 4478         callOperation(doubleFunction, result.fpr(), op1FPR);
 4479 
 4480         doubleResult(result.fpr(), node);
 4481         return;
 4482     }
 4483 
 4484     JSValueOperand op1(this, node-&gt;child1());
 4485     JSValueRegs op1Regs = op1.jsValueRegs();
 4486     flushRegisters();
 4487     FPRResult result(this);
<span class="line-modified"> 4488     callOperation(operation, result.fpr(), op1Regs);</span>
 4489     m_jit.exceptionCheck();
 4490     doubleResult(result.fpr(), node);
 4491 }
 4492 
 4493 void SpeculativeJIT::compileArithSub(Node* node)
 4494 {
 4495     switch (node-&gt;binaryUseKind()) {
 4496     case Int32Use: {
 4497         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4498 
 4499         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4500             SpeculateInt32Operand op1(this, node-&gt;child1());
 4501             int32_t imm2 = node-&gt;child2()-&gt;asInt32();
 4502             GPRTemporary result(this);
 4503 
 4504             if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4505                 m_jit.move(op1.gpr(), result.gpr());
 4506                 m_jit.sub32(Imm32(imm2), result.gpr());
 4507             } else {
 4508                 GPRTemporary scratch(this);
</pre>
<hr />
<pre>
 4574 
 4575     case DoubleRepUse: {
 4576         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4577         SpeculateDoubleOperand op2(this, node-&gt;child2());
 4578         FPRTemporary result(this, op1);
 4579 
 4580         FPRReg reg1 = op1.fpr();
 4581         FPRReg reg2 = op2.fpr();
 4582         m_jit.subDouble(reg1, reg2, result.fpr());
 4583 
 4584         doubleResult(result.fpr(), node);
 4585         return;
 4586     }
 4587 
 4588     default:
 4589         RELEASE_ASSERT_NOT_REACHED();
 4590         return;
 4591     }
 4592 }
 4593 
















 4594 void SpeculativeJIT::compileValueNegate(Node* node)
 4595 {
 4596     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 4597     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4598     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
 4599     JITNegIC* negIC = m_jit.codeBlock()-&gt;addJITNegIC(arithProfile);
 4600     auto repatchingFunction = operationArithNegateOptimize;
 4601     auto nonRepatchingFunction = operationArithNegate;
 4602     bool needsScratchGPRReg = true;
 4603     compileMathIC(node, negIC, needsScratchGPRReg, repatchingFunction, nonRepatchingFunction);
 4604 }
 4605 
 4606 void SpeculativeJIT::compileArithNegate(Node* node)
 4607 {
 4608     switch (node-&gt;child1().useKind()) {
 4609     case Int32Use: {
 4610         SpeculateInt32Operand op1(this, node-&gt;child1());
 4611         GPRTemporary result(this);
 4612 
 4613         m_jit.move(op1.gpr(), result.gpr());
 4614 
 4615         // Note: there is no notion of being not used as a number, but someone
 4616         // caring about negative zero.
 4617 
 4618         if (!shouldCheckOverflow(node-&gt;arithMode()))
</pre>
<hr />
<pre>
 4712     bool shouldEmitProfiling = false;
 4713     bool generatedInline = mathIC-&gt;generateInline(m_jit, *icGenerationState, shouldEmitProfiling);
 4714     if (generatedInline) {
 4715         ASSERT(!icGenerationState-&gt;slowPathJumps.empty());
 4716 
 4717         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
 4718         silentSpillAllRegistersImpl(false, savePlans, resultRegs);
 4719 
 4720         auto done = m_jit.label();
 4721 
 4722         addSlowPathGeneratorLambda([=, savePlans = WTFMove(savePlans)] () {
 4723             icGenerationState-&gt;slowPathJumps.link(&amp;m_jit);
 4724             icGenerationState-&gt;slowPathStart = m_jit.label();
 4725 #if ENABLE(MATH_IC_STATS)
 4726             auto slowPathStart = m_jit.label();
 4727 #endif
 4728 
 4729             silentSpill(savePlans);
 4730 
 4731             if (icGenerationState-&gt;shouldSlowPathRepatch)
<span class="line-modified"> 4732                 icGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_EJMic&gt;(repatchingFunction), resultRegs, childRegs, TrustedImmPtr(mathIC));</span>
 4733             else
<span class="line-modified"> 4734                 icGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, childRegs);</span>
 4735 
 4736             silentFill(savePlans);
 4737             m_jit.exceptionCheck();
 4738             m_jit.jump().linkTo(done, &amp;m_jit);
 4739 
 4740             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4741                 mathIC-&gt;finalizeInlineCode(*icGenerationState, linkBuffer);
 4742             });
 4743 
 4744 #if ENABLE(MATH_IC_STATS)
 4745             auto slowPathEnd = m_jit.label();
 4746             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4747                 size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathStart).executableAddress());
 4748                 mathIC-&gt;m_generatedCodeSize += size;
 4749             });
 4750 #endif
 4751 
 4752         });
 4753     } else {
 4754         flushRegisters();
<span class="line-modified"> 4755         callOperation(nonRepatchingFunction, resultRegs, childRegs);</span>
 4756         m_jit.exceptionCheck();
 4757     }
 4758 
 4759 #if ENABLE(MATH_IC_STATS)
 4760     auto inlineEnd = m_jit.label();
 4761     m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4762         size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineStart).executableAddress());
 4763         mathIC-&gt;m_generatedCodeSize += size;
 4764     });
 4765 #endif
 4766 
 4767     jsValueResult(resultRegs, node);
 4768     return;
 4769 }
 4770 
 4771 void SpeculativeJIT::compileValueMul(Node* node)
 4772 {
 4773     Edge&amp; leftChild = node-&gt;child1();
 4774     Edge&amp; rightChild = node-&gt;child2();
 4775 
 4776     if (leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse) {
 4777         SpeculateCellOperand left(this, leftChild);
 4778         SpeculateCellOperand right(this, rightChild);
 4779         GPRReg leftGPR = left.gpr();
 4780         GPRReg rightGPR = right.gpr();
 4781 
 4782         speculateBigInt(leftChild, leftGPR);
 4783         speculateBigInt(rightChild, rightGPR);
 4784 
 4785         flushRegisters();
 4786         GPRFlushedCallResult result(this);
 4787         GPRReg resultGPR = result.gpr();
 4788 
<span class="line-modified"> 4789         callOperation(operationMulBigInt, resultGPR, leftGPR, rightGPR);</span>
 4790 
 4791         m_jit.exceptionCheck();
 4792         cellResult(resultGPR, node);
 4793         return;
 4794     }
 4795 
 4796     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 4797         JSValueOperand left(this, leftChild);
 4798         JSValueOperand right(this, rightChild);
 4799         JSValueRegs leftRegs = left.jsValueRegs();
 4800         JSValueRegs rightRegs = right.jsValueRegs();
 4801 
 4802         flushRegisters();
 4803         JSValueRegsFlushedCallResult result(this);
 4804         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 4805         callOperation(operationValueMul, resultRegs, leftRegs, rightRegs);</span>
 4806         m_jit.exceptionCheck();
 4807 
 4808         jsValueResult(resultRegs, node);
 4809         return;
 4810     }
 4811 
 4812     bool needsScratchGPRReg = true;
 4813 #if USE(JSVALUE64)
 4814     bool needsScratchFPRReg = false;
 4815 #else
 4816     bool needsScratchFPRReg = true;
 4817 #endif
 4818 
 4819     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 4820     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4821     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
 4822     JITMulIC* mulIC = m_jit.codeBlock()-&gt;addJITMulIC(arithProfile);
 4823     auto repatchingFunction = operationValueMulOptimize;
 4824     auto nonRepatchingFunction = operationValueMul;
 4825 
 4826     compileMathIC(node, mulIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4827 }
 4828 
 4829 void SpeculativeJIT::compileArithMul(Node* node)
 4830 {
 4831     switch (node-&gt;binaryUseKind()) {
 4832     case Int32Use: {
 4833         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4834             SpeculateInt32Operand op1(this, node-&gt;child1());
 4835             GPRTemporary result(this);
 4836 
 4837             int32_t imm = node-&gt;child2()-&gt;asInt32();
 4838             GPRReg op1GPR = op1.gpr();
 4839             GPRReg resultGPR = result.gpr();
 4840 
 4841             if (!shouldCheckOverflow(node-&gt;arithMode()))
</pre>
<hr />
<pre>
 4971 }
 4972 
 4973 void SpeculativeJIT::compileValueDiv(Node* node)
 4974 {
 4975     Edge&amp; leftChild = node-&gt;child1();
 4976     Edge&amp; rightChild = node-&gt;child2();
 4977 
 4978     if (leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse) {
 4979         SpeculateCellOperand left(this, leftChild);
 4980         SpeculateCellOperand right(this, rightChild);
 4981         GPRReg leftGPR = left.gpr();
 4982         GPRReg rightGPR = right.gpr();
 4983 
 4984         speculateBigInt(leftChild, leftGPR);
 4985         speculateBigInt(rightChild, rightGPR);
 4986 
 4987         flushRegisters();
 4988         GPRFlushedCallResult result(this);
 4989         GPRReg resultGPR = result.gpr();
 4990 
<span class="line-modified"> 4991         callOperation(operationDivBigInt, resultGPR, leftGPR, rightGPR);</span>
 4992 
 4993         m_jit.exceptionCheck();
 4994         cellResult(resultGPR, node);
 4995         return;
 4996     }
 4997 
 4998     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 4999         JSValueOperand left(this, leftChild);
 5000         JSValueOperand right(this, rightChild);
 5001         JSValueRegs leftRegs = left.jsValueRegs();
 5002         JSValueRegs rightRegs = right.jsValueRegs();
 5003 
 5004         flushRegisters();
 5005         JSValueRegsFlushedCallResult result(this);
 5006         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 5007         callOperation(operationValueDiv, resultRegs, leftRegs, rightRegs);</span>
 5008         m_jit.exceptionCheck();
 5009 
 5010         jsValueResult(resultRegs, node);
 5011         return;
 5012     }
 5013 
 5014     Optional&lt;JSValueOperand&gt; left;
 5015     Optional&lt;JSValueOperand&gt; right;
 5016 
 5017     JSValueRegs leftRegs;
 5018     JSValueRegs rightRegs;
 5019 
 5020     FPRTemporary leftNumber(this);
 5021     FPRTemporary rightNumber(this);
 5022     FPRReg leftFPR = leftNumber.fpr();
 5023     FPRReg rightFPR = rightNumber.fpr();
 5024     FPRTemporary fprScratch(this);
 5025     FPRReg scratchFPR = fprScratch.fpr();
 5026 
 5027 #if USE(JSVALUE64)
</pre>
<hr />
<pre>
 5069 
 5070     JITDivGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs,
 5071         leftFPR, rightFPR, scratchGPR, scratchFPR);
 5072     gen.generateFastPath(m_jit);
 5073 
 5074     ASSERT(gen.didEmitFastPath());
 5075     gen.endJumpList().append(m_jit.jump());
 5076 
 5077     gen.slowPathJumpList().link(&amp;m_jit);
 5078     silentSpillAllRegisters(resultRegs);
 5079 
 5080     if (leftOperand.isConst()) {
 5081         leftRegs = resultRegs;
 5082         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 5083     }
 5084     if (rightOperand.isConst()) {
 5085         rightRegs = resultRegs;
 5086         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 5087     }
 5088 
<span class="line-modified"> 5089     callOperation(operationValueDiv, resultRegs, leftRegs, rightRegs);</span>
 5090 
 5091     silentFillAllRegisters();
 5092     m_jit.exceptionCheck();
 5093 
 5094     gen.endJumpList().link(&amp;m_jit);
 5095     jsValueResult(resultRegs, node);
 5096 }
 5097 
 5098 void SpeculativeJIT::compileArithDiv(Node* node)
 5099 {
 5100     switch (node-&gt;binaryUseKind()) {
 5101     case Int32Use: {
<span class="line-modified"> 5102 #if CPU(X86) || CPU(X86_64)</span>
 5103         SpeculateInt32Operand op1(this, node-&gt;child1());
 5104         SpeculateInt32Operand op2(this, node-&gt;child2());
 5105         GPRTemporary eax(this, X86Registers::eax);
 5106         GPRTemporary edx(this, X86Registers::edx);
 5107         GPRReg op1GPR = op1.gpr();
 5108         GPRReg op2GPR = op2.gpr();
 5109 
 5110         GPRReg op2TempGPR;
 5111         GPRReg temp;
 5112         if (op2GPR == X86Registers::eax || op2GPR == X86Registers::edx) {
 5113             op2TempGPR = allocate();
 5114             temp = op2TempGPR;
 5115         } else {
 5116             op2TempGPR = InvalidGPRReg;
 5117             if (op1GPR == X86Registers::eax)
 5118                 temp = X86Registers::edx;
 5119             else
 5120                 temp = X86Registers::eax;
 5121         }
 5122 
</pre>
<hr />
<pre>
 5233         RELEASE_ASSERT_NOT_REACHED();
 5234         break;
 5235     }
 5236 }
 5237 
 5238 void SpeculativeJIT::compileArithFRound(Node* node)
 5239 {
 5240     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5241         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5242         FPRTemporary result(this, op1);
 5243         m_jit.convertDoubleToFloat(op1.fpr(), result.fpr());
 5244         m_jit.convertFloatToDouble(result.fpr(), result.fpr());
 5245         doubleResult(result.fpr(), node);
 5246         return;
 5247     }
 5248 
 5249     JSValueOperand op1(this, node-&gt;child1());
 5250     JSValueRegs op1Regs = op1.jsValueRegs();
 5251     flushRegisters();
 5252     FPRResult result(this);
<span class="line-modified"> 5253     callOperation(operationArithFRound, result.fpr(), op1Regs);</span>
 5254     m_jit.exceptionCheck();
 5255     doubleResult(result.fpr(), node);
 5256 }
 5257 
 5258 void SpeculativeJIT::compileValueMod(Node* node)
 5259 {
 5260     Edge&amp; leftChild = node-&gt;child1();
 5261     Edge&amp; rightChild = node-&gt;child2();
 5262 
 5263     if (node-&gt;binaryUseKind() == BigIntUse) {
 5264         SpeculateCellOperand left(this, leftChild);
 5265         SpeculateCellOperand right(this, rightChild);
 5266         GPRReg leftGPR = left.gpr();
 5267         GPRReg rightGPR = right.gpr();
 5268 
 5269         speculateBigInt(leftChild, leftGPR);
 5270         speculateBigInt(rightChild, rightGPR);
 5271 
 5272         flushRegisters();
 5273         GPRFlushedCallResult result(this);
 5274         GPRReg resultGPR = result.gpr();
 5275 
<span class="line-modified"> 5276         callOperation(operationModBigInt, resultGPR, leftGPR, rightGPR);</span>
 5277 
 5278         m_jit.exceptionCheck();
 5279         cellResult(resultGPR, node);
 5280         return;
 5281     }
 5282 
 5283     DFG_ASSERT(m_jit.graph(), node, node-&gt;binaryUseKind() == UntypedUse, node-&gt;binaryUseKind());
 5284     JSValueOperand op1(this, leftChild);
 5285     JSValueOperand op2(this, rightChild);
 5286     JSValueRegs op1Regs = op1.jsValueRegs();
 5287     JSValueRegs op2Regs = op2.jsValueRegs();
 5288     flushRegisters();
 5289     JSValueRegsFlushedCallResult result(this);
 5290     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 5291     callOperation(operationValueMod, resultRegs, op1Regs, op2Regs);</span>
 5292     m_jit.exceptionCheck();
 5293     jsValueResult(resultRegs, node);
 5294 }
 5295 
 5296 void SpeculativeJIT::compileArithMod(Node* node)
 5297 {
 5298     switch (node-&gt;binaryUseKind()) {
 5299     case Int32Use: {
 5300         // In the fast path, the dividend value could be the final result
 5301         // (in case of |dividend| &lt; |divisor|), so we speculate it as strict int32.
 5302         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 5303 
 5304         if (node-&gt;child2()-&gt;isInt32Constant()) {
 5305             int32_t divisor = node-&gt;child2()-&gt;asInt32();
 5306             if (divisor &gt; 1 &amp;&amp; hasOneBitSet(divisor)) {
 5307                 unsigned logarithm = WTF::fastLog2(static_cast&lt;uint32_t&gt;(divisor));
 5308                 GPRReg dividendGPR = op1.gpr();
 5309                 GPRTemporary result(this);
 5310                 GPRReg resultGPR = result.gpr();
 5311 
</pre>
<hr />
<pre>
 5345                 m_jit.and32(TrustedImm32(-divisor), resultGPR);
 5346 
 5347                 // Subtract resultGPR from dividendGPR, which yields the remainder:
 5348                 //
 5349                 // resultGPR = dividendGPR - resultGPR
 5350                 m_jit.neg32(resultGPR);
 5351                 m_jit.add32(dividendGPR, resultGPR);
 5352 
 5353                 if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5354                     // Check that we&#39;re not about to create negative zero.
 5355                     JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, dividendGPR, TrustedImm32(0));
 5356                     speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, resultGPR));
 5357                     numeratorPositive.link(&amp;m_jit);
 5358                 }
 5359 
 5360                 int32Result(resultGPR, node);
 5361                 return;
 5362             }
 5363         }
 5364 
<span class="line-modified"> 5365 #if CPU(X86) || CPU(X86_64)</span>
 5366         if (node-&gt;child2()-&gt;isInt32Constant()) {
 5367             int32_t divisor = node-&gt;child2()-&gt;asInt32();
 5368             if (divisor &amp;&amp; divisor != -1) {
 5369                 GPRReg op1Gpr = op1.gpr();
 5370 
 5371                 GPRTemporary eax(this, X86Registers::eax);
 5372                 GPRTemporary edx(this, X86Registers::edx);
 5373                 GPRTemporary scratch(this);
 5374                 GPRReg scratchGPR = scratch.gpr();
 5375 
 5376                 GPRReg op1SaveGPR;
 5377                 if (op1Gpr == X86Registers::eax || op1Gpr == X86Registers::edx) {
 5378                     op1SaveGPR = allocate();
 5379                     ASSERT(op1Gpr != op1SaveGPR);
 5380                     m_jit.move(op1Gpr, op1SaveGPR);
 5381                 } else
 5382                     op1SaveGPR = op1Gpr;
 5383                 ASSERT(op1SaveGPR != X86Registers::eax);
 5384                 ASSERT(op1SaveGPR != X86Registers::edx);
 5385 
 5386                 m_jit.move(op1Gpr, eax.gpr());
 5387                 m_jit.move(TrustedImm32(divisor), scratchGPR);
 5388                 m_jit.x86ConvertToDoubleWord32();
 5389                 m_jit.x86Div32(scratchGPR);
 5390                 if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5391                     JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, op1SaveGPR, TrustedImm32(0));
 5392                     speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, edx.gpr()));
 5393                     numeratorPositive.link(&amp;m_jit);
 5394                 }
 5395 
 5396                 if (op1SaveGPR != op1Gpr)
 5397                     unlock(op1SaveGPR);
 5398 
 5399                 int32Result(edx.gpr(), node);
 5400                 return;
 5401             }
 5402         }
 5403 #endif
 5404 
 5405         SpeculateInt32Operand op2(this, node-&gt;child2());
<span class="line-modified"> 5406 #if CPU(X86) || CPU(X86_64)</span>
 5407         GPRTemporary eax(this, X86Registers::eax);
 5408         GPRTemporary edx(this, X86Registers::edx);
 5409         GPRReg op1GPR = op1.gpr();
 5410         GPRReg op2GPR = op2.gpr();
 5411 
 5412         GPRReg op2TempGPR;
 5413         GPRReg temp;
 5414         GPRReg op1SaveGPR;
 5415 
 5416         if (op2GPR == X86Registers::eax || op2GPR == X86Registers::edx) {
 5417             op2TempGPR = allocate();
 5418             temp = op2TempGPR;
 5419         } else {
 5420             op2TempGPR = InvalidGPRReg;
 5421             if (op1GPR == X86Registers::eax)
 5422                 temp = X86Registers::edx;
 5423             else
 5424                 temp = X86Registers::eax;
 5425         }
 5426 
</pre>
<hr />
<pre>
 5581             if (producesInteger(node-&gt;arithRoundingMode())) {
 5582                 GPRTemporary roundedResultAsInt32(this);
 5583                 FPRTemporary scratch(this);
 5584                 FPRReg scratchFPR = scratch.fpr();
 5585                 GPRReg resultGPR = roundedResultAsInt32.gpr();
 5586                 JITCompiler::JumpList failureCases;
 5587                 m_jit.branchConvertDoubleToInt32(resultFPR, resultGPR, failureCases, scratchFPR, shouldCheckNegativeZero(node-&gt;arithRoundingMode()));
 5588                 speculationCheck(Overflow, JSValueRegs(), node, failureCases);
 5589 
 5590                 int32Result(resultGPR, node);
 5591             } else
 5592                 doubleResult(resultFPR, node);
 5593         };
 5594 
 5595         if (m_jit.supportsFloatingPointRounding()) {
 5596             switch (node-&gt;op()) {
 5597             case ArithRound: {
 5598                 FPRTemporary result(this);
 5599                 FPRReg resultFPR = result.fpr();
 5600                 if (producesInteger(node-&gt;arithRoundingMode()) &amp;&amp; !shouldCheckNegativeZero(node-&gt;arithRoundingMode())) {
<span class="line-modified"> 5601                     static const double halfConstant = 0.5;</span>
 5602                     m_jit.loadDouble(TrustedImmPtr(&amp;halfConstant), resultFPR);
 5603                     m_jit.addDouble(valueFPR, resultFPR);
 5604                     m_jit.floorDouble(resultFPR, resultFPR);
 5605                 } else {
 5606                     m_jit.ceilDouble(valueFPR, resultFPR);
<span class="line-removed"> 5607                     FPRTemporary realPart(this);</span>
<span class="line-removed"> 5608                     FPRReg realPartFPR = realPart.fpr();</span>
<span class="line-removed"> 5609                     m_jit.subDouble(resultFPR, valueFPR, realPartFPR);</span>
 5610 
 5611                     FPRTemporary scratch(this);
 5612                     FPRReg scratchFPR = scratch.fpr();
<span class="line-modified"> 5613                     static const double halfConstant = 0.5;</span>
 5614                     m_jit.loadDouble(TrustedImmPtr(&amp;halfConstant), scratchFPR);

 5615 
<span class="line-modified"> 5616                     JITCompiler::Jump shouldUseCeiled = m_jit.branchDouble(JITCompiler::DoubleLessThanOrEqual, realPartFPR, scratchFPR);</span>
<span class="line-modified"> 5617                     static const double oneConstant = -1.0;</span>
 5618                     m_jit.loadDouble(TrustedImmPtr(&amp;oneConstant), scratchFPR);
 5619                     m_jit.addDouble(scratchFPR, resultFPR);
 5620                     shouldUseCeiled.link(&amp;m_jit);
 5621                 }
 5622                 setResult(resultFPR);
 5623                 return;
 5624             }
 5625 
 5626             case ArithFloor: {
 5627                 FPRTemporary rounded(this);
 5628                 FPRReg resultFPR = rounded.fpr();
 5629                 m_jit.floorDouble(valueFPR, resultFPR);
 5630                 setResult(resultFPR);
 5631                 return;
 5632             }
 5633 
 5634             case ArithCeil: {
 5635                 FPRTemporary rounded(this);
 5636                 FPRReg resultFPR = rounded.fpr();
 5637                 m_jit.ceilDouble(valueFPR, resultFPR);
</pre>
<hr />
<pre>
 5661                 callOperation&lt;OperationType&gt;(floor, resultFPR, valueFPR);
 5662             else if (node-&gt;op() == ArithCeil)
 5663                 callOperation&lt;OperationType&gt;(ceil, resultFPR, valueFPR);
 5664             else {
 5665                 ASSERT(node-&gt;op() == ArithTrunc);
 5666                 callOperation&lt;OperationType&gt;(trunc, resultFPR, valueFPR);
 5667             }
 5668             setResult(resultFPR);
 5669         }
 5670         return;
 5671     }
 5672 
 5673     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
 5674 
 5675     JSValueOperand argument(this, node-&gt;child1());
 5676     JSValueRegs argumentRegs = argument.jsValueRegs();
 5677 
 5678     flushRegisters();
 5679     JSValueRegsFlushedCallResult result(this);
 5680     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 5681     J_JITOperation_EJ operation = nullptr;</span>
 5682     if (node-&gt;op() == ArithRound)
 5683         operation = operationArithRound;
 5684     else if (node-&gt;op() == ArithFloor)
 5685         operation = operationArithFloor;
 5686     else if (node-&gt;op() == ArithCeil)
 5687         operation = operationArithCeil;
 5688     else {
 5689         ASSERT(node-&gt;op() == ArithTrunc);
 5690         operation = operationArithTrunc;
 5691     }
<span class="line-modified"> 5692     callOperation(operation, resultRegs, argumentRegs);</span>
 5693     m_jit.exceptionCheck();
 5694     jsValueResult(resultRegs, node);
 5695 }
 5696 
 5697 void SpeculativeJIT::compileArithUnary(Node* node)
 5698 {
 5699     compileArithDoubleUnaryOp(node, arithUnaryFunction(node-&gt;arithUnaryType()), arithUnaryOperation(node-&gt;arithUnaryType()));
 5700 }
 5701 
 5702 void SpeculativeJIT::compileArithSqrt(Node* node)
 5703 {
 5704     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5705         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5706         FPRReg op1FPR = op1.fpr();
 5707 
 5708         if (!MacroAssembler::supportsFloatingPointSqrt() || !Options::useArchitectureSpecificOptimizations()) {
 5709             flushRegisters();
 5710             FPRResult result(this);
 5711             callOperation&lt;D_JITOperation_D&gt;(sqrt, result.fpr(), op1FPR);
 5712             doubleResult(result.fpr(), node);
 5713         } else {
 5714             FPRTemporary result(this, op1);
 5715             m_jit.sqrtDouble(op1.fpr(), result.fpr());
 5716             doubleResult(result.fpr(), node);
 5717         }
 5718         return;
 5719     }
 5720 
 5721     JSValueOperand op1(this, node-&gt;child1());
 5722     JSValueRegs op1Regs = op1.jsValueRegs();
 5723     flushRegisters();
 5724     FPRResult result(this);
<span class="line-modified"> 5725     callOperation(operationArithSqrt, result.fpr(), op1Regs);</span>
 5726     m_jit.exceptionCheck();
 5727     doubleResult(result.fpr(), node);
 5728 }
 5729 
 5730 void SpeculativeJIT::compileArithMinMax(Node* node)
 5731 {
 5732     switch (node-&gt;binaryUseKind()) {
 5733     case Int32Use: {
 5734         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 5735         SpeculateStrictInt32Operand op2(this, node-&gt;child2());
 5736         GPRTemporary result(this, Reuse, op1);
 5737 
 5738         GPRReg op1GPR = op1.gpr();
 5739         GPRReg op2GPR = op2.gpr();
 5740         GPRReg resultGPR = result.gpr();
 5741 
 5742         MacroAssembler::Jump op1Less = m_jit.branch32(node-&gt;op() == ArithMin ? MacroAssembler::LessThan : MacroAssembler::GreaterThan, op1GPR, op2GPR);
 5743         m_jit.move(op2GPR, resultGPR);
 5744         if (op1GPR != resultGPR) {
 5745             MacroAssembler::Jump done = m_jit.jump();
</pre>
<hr />
<pre>
 5787 
 5788         done.link(&amp;m_jit);
 5789 
 5790         doubleResult(resultFPR, node);
 5791         break;
 5792     }
 5793 
 5794     default:
 5795         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 5796         break;
 5797     }
 5798 }
 5799 
 5800 // For small positive integers , it is worth doing a tiny inline loop to exponentiate the base.
 5801 // Every register is clobbered by this helper.
 5802 static MacroAssembler::Jump compileArithPowIntegerFastPath(JITCompiler&amp; assembler, FPRReg xOperand, GPRReg yOperand, FPRReg result)
 5803 {
 5804     MacroAssembler::JumpList skipFastPath;
 5805     skipFastPath.append(assembler.branch32(MacroAssembler::Above, yOperand, MacroAssembler::TrustedImm32(maxExponentForIntegerMathPow)));
 5806 
<span class="line-modified"> 5807     static const double oneConstant = 1.0;</span>
 5808     assembler.loadDouble(MacroAssembler::TrustedImmPtr(&amp;oneConstant), result);
 5809 
 5810     MacroAssembler::Label startLoop(assembler.label());
 5811     MacroAssembler::Jump exponentIsEven = assembler.branchTest32(MacroAssembler::Zero, yOperand, MacroAssembler::TrustedImm32(1));
 5812     assembler.mulDouble(xOperand, result);
 5813     exponentIsEven.link(&amp;assembler);
 5814     assembler.mulDouble(xOperand, xOperand);
 5815     assembler.rshift32(MacroAssembler::TrustedImm32(1), yOperand);
 5816     assembler.branchTest32(MacroAssembler::NonZero, yOperand).linkTo(startLoop, &amp;assembler);
 5817 
 5818     MacroAssembler::Jump skipSlowPath = assembler.jump();
 5819     skipFastPath.link(&amp;assembler);
 5820 
 5821     return skipSlowPath;
 5822 }
 5823 
 5824 void SpeculativeJIT::compileValuePow(Node* node)
 5825 {
 5826     Edge&amp; leftChild = node-&gt;child1();
 5827     Edge&amp; rightChild = node-&gt;child2();
 5828 
 5829     if (node-&gt;binaryUseKind() == BigIntUse) {
 5830         SpeculateCellOperand left(this, leftChild);
 5831         SpeculateCellOperand right(this, rightChild);
 5832         GPRReg leftGPR = left.gpr();
 5833         GPRReg rightGPR = right.gpr();
 5834 
 5835         speculateBigInt(leftChild, leftGPR);
 5836         speculateBigInt(rightChild, rightGPR);
 5837 
 5838         flushRegisters();
 5839         GPRFlushedCallResult result(this);
 5840         GPRReg resultGPR = result.gpr();
 5841 
<span class="line-modified"> 5842         callOperation(operationPowBigInt, resultGPR, leftGPR, rightGPR);</span>
 5843 
 5844         m_jit.exceptionCheck();
 5845         cellResult(resultGPR, node);
 5846         return;
 5847     }
 5848 
 5849     DFG_ASSERT(m_jit.graph(), node, node-&gt;binaryUseKind() == UntypedUse, node-&gt;binaryUseKind());
 5850 
 5851     JSValueOperand left(this, leftChild);
 5852     JSValueOperand right(this, rightChild);
 5853     JSValueRegs leftRegs = left.jsValueRegs();
 5854     JSValueRegs rightRegs = right.jsValueRegs();
 5855 
 5856     flushRegisters();
 5857     JSValueRegsFlushedCallResult result(this);
 5858     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 5859     callOperation(operationValuePow, resultRegs, leftRegs, rightRegs);</span>
 5860     m_jit.exceptionCheck();
 5861 
 5862     jsValueResult(resultRegs, node);
 5863 }
 5864 
 5865 void SpeculativeJIT::compileArithPow(Node* node)
 5866 {
 5867     if (node-&gt;child2().useKind() == Int32Use) {
 5868         SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5869         SpeculateInt32Operand yOperand(this, node-&gt;child2());
 5870         FPRReg xOperandfpr = xOperand.fpr();
 5871         GPRReg yOperandGpr = yOperand.gpr();
 5872         FPRTemporary yOperandfpr(this);
 5873 
 5874         flushRegisters();
 5875 
 5876         FPRResult result(this);
 5877         FPRReg resultFpr = result.fpr();
 5878 
 5879         FPRTemporary xOperandCopy(this);
 5880         FPRReg xOperandCopyFpr = xOperandCopy.fpr();
 5881         m_jit.moveDouble(xOperandfpr, xOperandCopyFpr);
 5882 
 5883         GPRTemporary counter(this);
 5884         GPRReg counterGpr = counter.gpr();
 5885         m_jit.move(yOperandGpr, counterGpr);
 5886 
 5887         MacroAssembler::Jump skipFallback = compileArithPowIntegerFastPath(m_jit, xOperandCopyFpr, counterGpr, resultFpr);
 5888         m_jit.convertInt32ToDouble(yOperandGpr, yOperandfpr.fpr());
 5889         callOperation(operationMathPow, resultFpr, xOperandfpr, yOperandfpr.fpr());
 5890 
 5891         skipFallback.link(&amp;m_jit);
 5892         doubleResult(resultFpr, node);
 5893         return;
 5894     }
 5895 
 5896     if (node-&gt;child2()-&gt;isDoubleConstant()) {
 5897         double exponent = node-&gt;child2()-&gt;asNumber();
<span class="line-modified"> 5898         static const double infinityConstant = std::numeric_limits&lt;double&gt;::infinity();</span>
<span class="line-modified"> 5899         static const double minusInfinityConstant = -std::numeric_limits&lt;double&gt;::infinity();</span>
 5900         if (exponent == 0.5) {
 5901             SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5902             FPRTemporary result(this);
 5903             FPRReg xOperandFpr = xOperand.fpr();
 5904             FPRReg resultFpr = result.fpr();
 5905 
 5906             m_jit.moveZeroToDouble(resultFpr);
 5907             MacroAssembler::Jump xIsZeroOrNegativeZero = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5908 
 5909             m_jit.loadDouble(TrustedImmPtr(&amp;minusInfinityConstant), resultFpr);
 5910             MacroAssembler::Jump xIsMinusInfinity = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5911             m_jit.sqrtDouble(xOperandFpr, resultFpr);
 5912             MacroAssembler::Jump doneWithSqrt = m_jit.jump();
 5913 
 5914             xIsMinusInfinity.link(&amp;m_jit);
 5915             if (isX86())
 5916                 m_jit.loadDouble(TrustedImmPtr(&amp;infinityConstant), resultFpr);
 5917             else
 5918                 m_jit.absDouble(resultFpr, resultFpr);
 5919 
 5920             xIsZeroOrNegativeZero.link(&amp;m_jit);
 5921             doneWithSqrt.link(&amp;m_jit);
 5922             doubleResult(resultFpr, node);
 5923             return;
 5924         }
 5925         if (exponent == -0.5) {
 5926             SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5927             FPRTemporary scratch(this);
 5928             FPRTemporary result(this);
 5929             FPRReg xOperandFpr = xOperand.fpr();
 5930             FPRReg scratchFPR = scratch.fpr();
 5931             FPRReg resultFpr = result.fpr();
 5932 
 5933             m_jit.moveZeroToDouble(resultFpr);
 5934             MacroAssembler::Jump xIsZeroOrNegativeZero = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5935 
 5936             m_jit.loadDouble(TrustedImmPtr(&amp;minusInfinityConstant), resultFpr);
 5937             MacroAssembler::Jump xIsMinusInfinity = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5938 
<span class="line-modified"> 5939             static const double oneConstant = 1.;</span>
 5940             m_jit.loadDouble(TrustedImmPtr(&amp;oneConstant), resultFpr);
 5941             m_jit.sqrtDouble(xOperandFpr, scratchFPR);
 5942             m_jit.divDouble(resultFpr, scratchFPR, resultFpr);
 5943             MacroAssembler::Jump doneWithSqrt = m_jit.jump();
 5944 
 5945             xIsZeroOrNegativeZero.link(&amp;m_jit);
 5946             m_jit.loadDouble(TrustedImmPtr(&amp;infinityConstant), resultFpr);
 5947             MacroAssembler::Jump doneWithBaseZero = m_jit.jump();
 5948 
 5949             xIsMinusInfinity.link(&amp;m_jit);
 5950             m_jit.moveZeroToDouble(resultFpr);
 5951 
 5952             doneWithBaseZero.link(&amp;m_jit);
 5953             doneWithSqrt.link(&amp;m_jit);
 5954             doubleResult(resultFpr, node);
 5955             return;
 5956         }
 5957     }
 5958 
 5959     SpeculateDoubleOperand xOperand(this, node-&gt;child1());
</pre>
<hr />
<pre>
 5970     FPRReg xOperandCopyFpr = xOperandCopy.fpr();
 5971 
 5972     FPRTemporary scratch(this);
 5973     FPRReg scratchFpr = scratch.fpr();
 5974 
 5975     GPRTemporary yOperandInteger(this);
 5976     GPRReg yOperandIntegerGpr = yOperandInteger.gpr();
 5977     MacroAssembler::JumpList failedExponentConversionToInteger;
 5978     m_jit.branchConvertDoubleToInt32(yOperandfpr, yOperandIntegerGpr, failedExponentConversionToInteger, scratchFpr, false);
 5979 
 5980     m_jit.moveDouble(xOperandfpr, xOperandCopyFpr);
 5981     MacroAssembler::Jump skipFallback = compileArithPowIntegerFastPath(m_jit, xOperandCopyFpr, yOperandInteger.gpr(), resultFpr);
 5982     failedExponentConversionToInteger.link(&amp;m_jit);
 5983 
 5984     callOperation(operationMathPow, resultFpr, xOperandfpr, yOperandfpr);
 5985     skipFallback.link(&amp;m_jit);
 5986     doubleResult(resultFpr, node);
 5987 }
 5988 
 5989 // Returns true if the compare is fused with a subsequent branch.
<span class="line-modified"> 5990 bool SpeculativeJIT::compare(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_EJJ operation)</span>
 5991 {
 5992     if (compilePeepHoleBranch(node, condition, doubleCondition, operation))
 5993         return true;
 5994 
 5995     if (node-&gt;isBinaryUseKind(Int32Use)) {
 5996         compileInt32Compare(node, condition);
 5997         return false;
 5998     }
 5999 
 6000 #if USE(JSVALUE64)
 6001     if (node-&gt;isBinaryUseKind(Int52RepUse)) {
 6002         compileInt52Compare(node, condition);
 6003         return false;
 6004     }
 6005 #endif // USE(JSVALUE64)
 6006 
 6007     if (node-&gt;isBinaryUseKind(DoubleRepUse)) {
 6008         compileDoubleCompare(node, doubleCondition);
 6009         return false;
 6010     }
</pre>
<hr />
<pre>
 6424 
 6425     // This isn&#39;t going to generate the best code on x86. But that&#39;s OK, it&#39;s still better
 6426     // than not inlining.
 6427     m_jit.load8(MacroAssembler::BaseIndex(leftTempGPR, lengthGPR, MacroAssembler::TimesOne), leftTemp2GPR);
 6428     m_jit.load8(MacroAssembler::BaseIndex(rightTempGPR, lengthGPR, MacroAssembler::TimesOne), rightTemp2GPR);
 6429     falseCase.append(m_jit.branch32(MacroAssembler::NotEqual, leftTemp2GPR, rightTemp2GPR));
 6430 
 6431     m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 6432 
 6433     trueCase.link(&amp;m_jit);
 6434     moveTrueTo(leftTempGPR);
 6435 
 6436     JITCompiler::Jump done = m_jit.jump();
 6437 
 6438     falseCase.link(&amp;m_jit);
 6439     moveFalseTo(leftTempGPR);
 6440 
 6441     done.link(&amp;m_jit);
 6442     addSlowPathGenerator(
 6443         slowPathCall(
<span class="line-modified"> 6444             slowCase, this, operationCompareStringEq, leftTempGPR, leftGPR, rightGPR));</span>
 6445 
 6446     blessedBooleanResult(leftTempGPR, node);
 6447 }
 6448 
 6449 void SpeculativeJIT::compileStringEquality(Node* node)
 6450 {
 6451     SpeculateCellOperand left(this, node-&gt;child1());
 6452     SpeculateCellOperand right(this, node-&gt;child2());
 6453     GPRTemporary length(this);
 6454     GPRTemporary leftTemp(this);
 6455     GPRTemporary rightTemp(this);
 6456     GPRTemporary leftTemp2(this, Reuse, left);
 6457     GPRTemporary rightTemp2(this, Reuse, right);
 6458 
 6459     GPRReg leftGPR = left.gpr();
 6460     GPRReg rightGPR = right.gpr();
 6461     GPRReg lengthGPR = length.gpr();
 6462     GPRReg leftTempGPR = leftTemp.gpr();
 6463     GPRReg rightTempGPR = rightTemp.gpr();
 6464     GPRReg leftTemp2GPR = leftTemp2.gpr();
</pre>
<hr />
<pre>
 6558     notString.append(m_jit.branchIfNotString(rightRegs.payloadGPR()));
 6559 
 6560     speculateStringIdentAndLoadStorage(notStringVarEdge, rightRegs.payloadGPR(), rightTempGPR);
 6561 
 6562     m_jit.comparePtr(MacroAssembler::Equal, leftTempGPR, rightTempGPR, rightTempGPR);
 6563     notString.link(&amp;m_jit);
 6564 
 6565     unblessedBooleanResult(rightTempGPR, node);
 6566 }
 6567 
 6568 void SpeculativeJIT::compileStringCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6569 {
 6570     SpeculateCellOperand left(this, node-&gt;child1());
 6571     SpeculateCellOperand right(this, node-&gt;child2());
 6572     GPRReg leftGPR = left.gpr();
 6573     GPRReg rightGPR = right.gpr();
 6574 
 6575     speculateString(node-&gt;child1(), leftGPR);
 6576     speculateString(node-&gt;child2(), rightGPR);
 6577 
<span class="line-modified"> 6578     C_JITOperation_B_EJssJss compareFunction = nullptr;</span>
 6579     if (condition == MacroAssembler::LessThan)
 6580         compareFunction = operationCompareStringLess;
 6581     else if (condition == MacroAssembler::LessThanOrEqual)
 6582         compareFunction = operationCompareStringLessEq;
 6583     else if (condition == MacroAssembler::GreaterThan)
 6584         compareFunction = operationCompareStringGreater;
 6585     else if (condition == MacroAssembler::GreaterThanOrEqual)
 6586         compareFunction = operationCompareStringGreaterEq;
 6587     else
 6588         RELEASE_ASSERT_NOT_REACHED();
 6589 
 6590     GPRFlushedCallResult result(this);
 6591     GPRReg resultGPR = result.gpr();
 6592 
 6593     flushRegisters();
<span class="line-modified"> 6594     callOperation(compareFunction, resultGPR, leftGPR, rightGPR);</span>
 6595     m_jit.exceptionCheck();
 6596 
 6597     unblessedBooleanResult(resultGPR, node);
 6598 }
 6599 
 6600 void SpeculativeJIT::compileStringIdentCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6601 {
 6602     SpeculateCellOperand left(this, node-&gt;child1());
 6603     SpeculateCellOperand right(this, node-&gt;child2());
 6604     GPRFlushedCallResult result(this);
 6605     GPRTemporary leftTemp(this);
 6606     GPRTemporary rightTemp(this);
 6607 
 6608     GPRReg leftGPR = left.gpr();
 6609     GPRReg rightGPR = right.gpr();
 6610     GPRReg resultGPR = result.gpr();
 6611     GPRReg leftTempGPR = leftTemp.gpr();
 6612     GPRReg rightTempGPR = rightTemp.gpr();
 6613 
 6614     speculateString(node-&gt;child1(), leftGPR);
</pre>
<hr />
<pre>
 6675         done.link(&amp;m_jit);
 6676 
 6677         unblessedBooleanResult(resultGPR, node);
 6678         return;
 6679     }
 6680 
 6681     ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
 6682 
 6683     JSValueOperand arg1(this, node-&gt;child1());
 6684     JSValueOperand arg2(this, node-&gt;child2());
 6685     JSValueRegs arg1Regs = arg1.jsValueRegs();
 6686     JSValueRegs arg2Regs = arg2.jsValueRegs();
 6687 
 6688     arg1.use();
 6689     arg2.use();
 6690 
 6691     flushRegisters();
 6692 
 6693     GPRFlushedCallResult result(this);
 6694     GPRReg resultGPR = result.gpr();
<span class="line-modified"> 6695     callOperation(operationSameValue, resultGPR, arg1Regs, arg2Regs);</span>
 6696     m_jit.exceptionCheck();
 6697 
 6698     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 6699 }
 6700 
 6701 void SpeculativeJIT::compileStringZeroLength(Node* node)
 6702 {
 6703     SpeculateCellOperand str(this, node-&gt;child1());
 6704     GPRReg strGPR = str.gpr();
 6705 
 6706     // Make sure that this is a string.
 6707     speculateString(node-&gt;child1(), strGPR);
 6708 
 6709     GPRTemporary eq(this);
 6710     GPRReg eqGPR = eq.gpr();
 6711 
 6712     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), eqGPR);
 6713     m_jit.comparePtr(CCallHelpers::Equal, strGPR, eqGPR, eqGPR);
 6714     unblessedBooleanResult(eqGPR, node);
 6715 }
</pre>
<hr />
<pre>
 6814     m_jit.cageWithoutUntagging(Gigacage::Primitive, storageReg);
 6815 #endif
 6816     untagArrayPtr();
 6817 }
 6818 
 6819 void SpeculativeJIT::compileGetIndexedPropertyStorage(Node* node)
 6820 {
 6821     SpeculateCellOperand base(this, node-&gt;child1());
 6822     GPRReg baseReg = base.gpr();
 6823 
 6824     GPRTemporary storage(this);
 6825     GPRReg storageReg = storage.gpr();
 6826 
 6827     switch (node-&gt;arrayMode().type()) {
 6828     case Array::String:
 6829         m_jit.loadPtr(MacroAssembler::Address(baseReg, JSString::offsetOfValue()), storageReg);
 6830 
 6831         addSlowPathGenerator(
 6832             slowPathCall(
 6833                 m_jit.branchIfRopeStringImpl(storageReg),
<span class="line-modified"> 6834                 this, operationResolveRope, storageReg, baseReg));</span>
 6835 
 6836         m_jit.loadPtr(MacroAssembler::Address(storageReg, StringImpl::dataOffset()), storageReg);
 6837         break;
 6838 
 6839     default: {
 6840         auto typedArrayType = node-&gt;arrayMode().typedArrayType();
 6841         ASSERT_UNUSED(typedArrayType, isTypedView(typedArrayType));
 6842 
 6843         m_jit.loadPtr(JITCompiler::Address(baseReg, JSArrayBufferView::offsetOfVector()), storageReg);
 6844         cageTypedArrayStorage(baseReg, storageReg);
 6845         break;
 6846     }
 6847     }
 6848 
 6849     storageResult(storageReg, node);
 6850 }
 6851 
 6852 void SpeculativeJIT::compileGetTypedArrayByteOffset(Node* node)
 6853 {
 6854     SpeculateCellOperand base(this, node-&gt;child1());
</pre>
<hr />
<pre>
 6921     speculationCheck(
 6922         ExoticObjectMode, JSValueSource(), 0,
 6923         m_jit.branchTestPtr(
 6924             MacroAssembler::NonZero,
 6925             MacroAssembler::Address(baseReg, DirectArguments::offsetOfMappedArguments())));
 6926 
 6927     m_jit.load32(CCallHelpers::Address(baseReg, DirectArguments::offsetOfLength()), scratchReg);
 6928     auto isOutOfBounds = m_jit.branch32(CCallHelpers::AboveOrEqual, propertyReg, scratchReg);
 6929     if (node-&gt;arrayMode().isInBounds())
 6930         speculationCheck(OutOfBounds, JSValueSource(), 0, isOutOfBounds);
 6931 
 6932     m_jit.loadValue(
 6933         MacroAssembler::BaseIndex(
 6934             baseReg, propertyReg, MacroAssembler::TimesEight, DirectArguments::storageOffset()),
 6935         resultRegs);
 6936 
 6937     if (!node-&gt;arrayMode().isInBounds()) {
 6938         addSlowPathGenerator(
 6939             slowPathCall(
 6940                 isOutOfBounds, this, operationGetByValObjectInt,
<span class="line-modified"> 6941                 extractResult(resultRegs), baseReg, propertyReg));</span>
 6942     }
 6943 
 6944     jsValueResult(resultRegs, node);
 6945 }
 6946 
 6947 void SpeculativeJIT::compileGetByValOnScopedArguments(Node* node)
 6948 {
 6949     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 6950     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 6951     JSValueRegsTemporary result(this);
 6952     GPRTemporary scratch(this);
 6953     GPRTemporary scratch2(this);
<span class="line-removed"> 6954     GPRTemporary indexMask(this);</span>
 6955 
 6956     GPRReg baseReg = base.gpr();
 6957     GPRReg propertyReg = property.gpr();
 6958     JSValueRegs resultRegs = result.regs();
 6959     GPRReg scratchReg = scratch.gpr();
 6960     GPRReg scratch2Reg = scratch2.gpr();
<span class="line-removed"> 6961     GPRReg indexMaskReg = indexMask.gpr();</span>
 6962 
 6963     if (!m_compileOkay)
 6964         return;
 6965 
 6966     ASSERT(ArrayMode(Array::ScopedArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));
 6967 
 6968     m_jit.loadPtr(
 6969         MacroAssembler::Address(baseReg, ScopedArguments::offsetOfStorage()), resultRegs.payloadGPR());
<span class="line-removed"> 6970     m_jit.load32(</span>
<span class="line-removed"> 6971         MacroAssembler::Address(resultRegs.payloadGPR(), ScopedArguments::offsetOfTotalLengthInStorage()),</span>
<span class="line-removed"> 6972         scratchReg);</span>
 6973 
 6974     speculationCheck(
 6975         ExoticObjectMode, JSValueSource(), nullptr,
<span class="line-modified"> 6976         m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, scratchReg));</span>
<span class="line-modified"> 6977 </span>
<span class="line-modified"> 6978     m_jit.emitPreparePreciseIndexMask32(propertyReg, scratchReg, indexMaskReg);</span>
 6979 
 6980     m_jit.loadPtr(MacroAssembler::Address(baseReg, ScopedArguments::offsetOfTable()), scratchReg);
 6981     m_jit.load32(
 6982         MacroAssembler::Address(scratchReg, ScopedArgumentsTable::offsetOfLength()), scratch2Reg);
 6983 
 6984     MacroAssembler::Jump overflowArgument = m_jit.branch32(
 6985         MacroAssembler::AboveOrEqual, propertyReg, scratch2Reg);
 6986 
 6987     m_jit.loadPtr(MacroAssembler::Address(baseReg, ScopedArguments::offsetOfScope()), scratch2Reg);
 6988 
 6989     m_jit.loadPtr(
 6990         MacroAssembler::Address(scratchReg, ScopedArgumentsTable::offsetOfArguments()),
 6991         scratchReg);
 6992     m_jit.load32(
 6993         MacroAssembler::BaseIndex(scratchReg, propertyReg, MacroAssembler::TimesFour),
 6994         scratchReg);
 6995 
 6996     speculationCheck(
 6997         ExoticObjectMode, JSValueSource(), nullptr,
 6998         m_jit.branch32(
</pre>
<hr />
<pre>
 7001     m_jit.loadValue(
 7002         MacroAssembler::BaseIndex(
 7003             scratch2Reg, propertyReg, MacroAssembler::TimesEight,
 7004             JSLexicalEnvironment::offsetOfVariables()),
 7005         resultRegs);
 7006 
 7007     MacroAssembler::Jump done = m_jit.jump();
 7008     overflowArgument.link(&amp;m_jit);
 7009 
 7010     m_jit.sub32(propertyReg, scratch2Reg);
 7011     m_jit.neg32(scratch2Reg);
 7012 
 7013     m_jit.loadValue(
 7014         MacroAssembler::BaseIndex(
 7015             resultRegs.payloadGPR(), scratch2Reg, MacroAssembler::TimesEight),
 7016         resultRegs);
 7017     speculationCheck(ExoticObjectMode, JSValueSource(), nullptr, m_jit.branchIfEmpty(resultRegs));
 7018 
 7019     done.link(&amp;m_jit);
 7020 
<span class="line-removed"> 7021     m_jit.andPtr(indexMaskReg, resultRegs.payloadGPR());</span>
<span class="line-removed"> 7022 </span>
 7023     jsValueResult(resultRegs, node);
 7024 }
 7025 
 7026 void SpeculativeJIT::compileGetScope(Node* node)
 7027 {
 7028     SpeculateCellOperand function(this, node-&gt;child1());
 7029     GPRTemporary result(this, Reuse, function);
 7030     m_jit.loadPtr(JITCompiler::Address(function.gpr(), JSFunction::offsetOfScopeChain()), result.gpr());
 7031     cellResult(result.gpr(), node);
 7032 }
 7033 
 7034 void SpeculativeJIT::compileSkipScope(Node* node)
 7035 {
 7036     SpeculateCellOperand scope(this, node-&gt;child1());
 7037     GPRTemporary result(this, Reuse, scope);
 7038     m_jit.loadPtr(JITCompiler::Address(scope.gpr(), JSScope::offsetOfNext()), result.gpr());
 7039     cellResult(result.gpr(), node);
 7040 }
 7041 
 7042 void SpeculativeJIT::compileGetGlobalObject(Node* node)
</pre>
<hr />
<pre>
 7133 
 7134         if (!m_compileOkay)
 7135             return;
 7136 
 7137         ASSERT(ArrayMode(Array::DirectArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
 7138 
 7139         speculationCheck(
 7140             ExoticObjectMode, JSValueSource(), 0,
 7141             m_jit.branchTestPtr(
 7142                 MacroAssembler::NonZero,
 7143                 MacroAssembler::Address(baseReg, DirectArguments::offsetOfMappedArguments())));
 7144 
 7145         m_jit.load32(
 7146             MacroAssembler::Address(baseReg, DirectArguments::offsetOfLength()), resultReg);
 7147 
 7148         int32Result(resultReg, node);
 7149         break;
 7150     }
 7151     case Array::ScopedArguments: {
 7152         SpeculateCellOperand base(this, node-&gt;child1());
<span class="line-modified"> 7153         GPRTemporary result(this);</span>
 7154 
 7155         GPRReg baseReg = base.gpr();
 7156         GPRReg resultReg = result.gpr();
 7157 
 7158         if (!m_compileOkay)
 7159             return;
 7160 
 7161         ASSERT(ArrayMode(Array::ScopedArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
 7162 
<span class="line-removed"> 7163         m_jit.loadPtr(</span>
<span class="line-removed"> 7164             MacroAssembler::Address(baseReg, ScopedArguments::offsetOfStorage()), resultReg);</span>
<span class="line-removed"> 7165 </span>
 7166         speculationCheck(
 7167             ExoticObjectMode, JSValueSource(), 0,
 7168             m_jit.branchTest8(
 7169                 MacroAssembler::NonZero,
<span class="line-modified"> 7170                 MacroAssembler::Address(resultReg, ScopedArguments::offsetOfOverrodeThingsInStorage())));</span>
 7171 
 7172         m_jit.load32(
<span class="line-modified"> 7173             MacroAssembler::Address(resultReg, ScopedArguments::offsetOfTotalLengthInStorage()), resultReg);</span>
 7174 
 7175         int32Result(resultReg, node);
 7176         break;
 7177     }
 7178     default: {
 7179         ASSERT(node-&gt;arrayMode().isSomeTypedArrayView());
 7180         SpeculateCellOperand base(this, node-&gt;child1());
 7181         GPRTemporary result(this, Reuse, base);
 7182         GPRReg baseGPR = base.gpr();
 7183         GPRReg resultGPR = result.gpr();
 7184         m_jit.load32(MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfLength()), resultGPR);
 7185         int32Result(resultGPR, node);
 7186         break;
 7187     } }
 7188 }
 7189 
<span class="line-modified"> 7190 void SpeculativeJIT::compileCheckStringIdent(Node* node)</span>
 7191 {
<span class="line-modified"> 7192     SpeculateCellOperand string(this, node-&gt;child1());</span>
<span class="line-modified"> 7193     GPRTemporary storage(this);</span>


 7194 
<span class="line-modified"> 7195     GPRReg stringGPR = string.gpr();</span>
<span class="line-modified"> 7196     GPRReg storageGPR = storage.gpr();</span>
<span class="line-modified"> 7197 </span>
<span class="line-modified"> 7198     speculateString(node-&gt;child1(), stringGPR);</span>
<span class="line-modified"> 7199     speculateStringIdentAndLoadStorage(node-&gt;child1(), stringGPR, storageGPR);</span>



 7200 
 7201     UniquedStringImpl* uid = node-&gt;uidOperand();
 7202     speculationCheck(
 7203         BadIdent, JSValueSource(), nullptr,
<span class="line-modified"> 7204         m_jit.branchPtr(JITCompiler::NotEqual, storageGPR, TrustedImmPtr(uid)));</span>
 7205     noResult(node);
 7206 }
 7207 
 7208 template &lt;typename ClassType&gt;
 7209 void SpeculativeJIT::compileNewFunctionCommon(GPRReg resultGPR, RegisteredStructure structure, GPRReg scratch1GPR, GPRReg scratch2GPR, GPRReg scopeGPR, MacroAssembler::JumpList&amp; slowPath, size_t size, FunctionExecutable* executable)
 7210 {
 7211     auto butterfly = TrustedImmPtr(nullptr);
 7212     emitAllocateJSObjectWithKnownSize&lt;ClassType&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath, size);
 7213 
 7214     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfScopeChain()));
<span class="line-modified"> 7215     m_jit.storePtr(TrustedImmPtr::weakPointer(m_jit.graph(), executable), JITCompiler::Address(resultGPR, JSFunction::offsetOfExecutable()));</span>
<span class="line-modified"> 7216     m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));</span>
<span class="line-removed"> 7217 </span>
<span class="line-removed"> 7218     if (executable-&gt;isAnonymousBuiltinFunction()) {</span>
<span class="line-removed"> 7219         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed"> 7220         m_jit.mutatorFence(vm);</span>
<span class="line-removed"> 7221         GPRTemporary allocator(this);</span>
<span class="line-removed"> 7222         Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;FunctionRareData&gt;(vm, sizeof(FunctionRareData), AllocatorForMode::AllocatorIfExists);</span>
<span class="line-removed"> 7223         emitAllocateJSCell(scratch1GPR, JITAllocator::constant(allocatorValue), allocator.gpr(), TrustedImmPtr(m_jit.graph().registerStructure(vm.functionRareDataStructure.get())), scratch2GPR, slowPath);</span>
<span class="line-removed"> 7224 </span>
<span class="line-removed"> 7225         ptrdiff_t objectAllocationProfileOffset = FunctionRareData::offsetOfObjectAllocationProfile();</span>
<span class="line-removed"> 7226         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfAllocator()));</span>
<span class="line-removed"> 7227         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfStructure()));</span>
<span class="line-removed"> 7228         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfPrototype()));</span>
<span class="line-removed"> 7229         m_jit.storePtr(TrustedImmPtr(0x1), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfObjectAllocationProfileWatchpoint()));</span>
<span class="line-removed"> 7230         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfInternalFunctionAllocationProfile() + InternalFunctionAllocationProfile::offsetOfStructure()));</span>
<span class="line-removed"> 7231         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfBoundFunctionStructure()));</span>
<span class="line-removed"> 7232         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfAllocationProfileClearingWatchpoint()));</span>
<span class="line-removed"> 7233         m_jit.store8(TrustedImm32(0), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfHasReifiedLength()));</span>
<span class="line-removed"> 7234         m_jit.store8(TrustedImm32(1), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfHasReifiedName()));</span>
<span class="line-removed"> 7235         m_jit.mutatorFence(vm);</span>
<span class="line-removed"> 7236         m_jit.storePtr(scratch1GPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));</span>
<span class="line-removed"> 7237     } else</span>
<span class="line-removed"> 7238         m_jit.mutatorFence(vm());</span>
<span class="line-removed"> 7239 </span>
 7240 }
 7241 
 7242 void SpeculativeJIT::compileNewFunction(Node* node)
 7243 {
 7244     NodeType nodeType = node-&gt;op();
 7245     ASSERT(nodeType == NewFunction || nodeType == NewGeneratorFunction || nodeType == NewAsyncFunction || nodeType == NewAsyncGeneratorFunction);
 7246 
 7247     SpeculateCellOperand scope(this, node-&gt;child1());
 7248     GPRReg scopeGPR = scope.gpr();
 7249 
 7250     FunctionExecutable* executable = node-&gt;castOperand&lt;FunctionExecutable*&gt;();
 7251 
 7252     if (executable-&gt;singleton().isStillValid()) {
 7253         GPRFlushedCallResult result(this);
 7254         GPRReg resultGPR = result.gpr();
 7255 
 7256         flushRegisters();
 7257 
 7258         if (nodeType == NewGeneratorFunction)
<span class="line-modified"> 7259             callOperation(operationNewGeneratorFunction, resultGPR, scopeGPR, executable);</span>
 7260         else if (nodeType == NewAsyncFunction)
<span class="line-modified"> 7261             callOperation(operationNewAsyncFunction, resultGPR, scopeGPR, executable);</span>
 7262         else if (nodeType == NewAsyncGeneratorFunction)
<span class="line-modified"> 7263             callOperation(operationNewAsyncGeneratorFunction, resultGPR, scopeGPR, executable);</span>
 7264         else
<span class="line-modified"> 7265             callOperation(operationNewFunction, resultGPR, scopeGPR, executable);</span>
 7266         m_jit.exceptionCheck();
 7267         cellResult(resultGPR, node);
 7268         return;
 7269     }
 7270 
 7271     RegisteredStructure structure = m_jit.graph().registerStructure(
 7272         [&amp;] () {
 7273             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 7274             switch (nodeType) {
 7275             case NewGeneratorFunction:
 7276                 return globalObject-&gt;generatorFunctionStructure();
 7277             case NewAsyncFunction:
 7278                 return globalObject-&gt;asyncFunctionStructure();
 7279             case NewAsyncGeneratorFunction:
 7280                 return globalObject-&gt;asyncGeneratorFunctionStructure();
 7281             case NewFunction:
 7282                 return JSFunction::selectStructureForNewFuncExp(globalObject, node-&gt;castOperand&lt;FunctionExecutable*&gt;());
 7283             default:
 7284                 RELEASE_ASSERT_NOT_REACHED();
 7285             }
 7286         }());
 7287 
 7288     GPRTemporary result(this);
 7289     GPRTemporary scratch1(this);
 7290     GPRTemporary scratch2(this);
 7291 
 7292     GPRReg resultGPR = result.gpr();
 7293     GPRReg scratch1GPR = scratch1.gpr();
 7294     GPRReg scratch2GPR = scratch2.gpr();
 7295 
 7296     JITCompiler::JumpList slowPath;
 7297 
 7298     if (nodeType == NewFunction) {
 7299         compileNewFunctionCommon&lt;JSFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSFunction::allocationSize(0), executable);
 7300 
<span class="line-modified"> 7301         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));</span>
 7302     }
 7303 
 7304     if (nodeType == NewGeneratorFunction) {
 7305         compileNewFunctionCommon&lt;JSGeneratorFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSGeneratorFunction::allocationSize(0), executable);
 7306 
<span class="line-modified"> 7307         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));</span>
 7308     }
 7309 
 7310     if (nodeType == NewAsyncFunction) {
 7311         compileNewFunctionCommon&lt;JSAsyncFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSAsyncFunction::allocationSize(0), executable);
 7312 
<span class="line-modified"> 7313         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));</span>
 7314     }
 7315 
 7316     if (nodeType == NewAsyncGeneratorFunction) {
 7317         compileNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSAsyncGeneratorFunction::allocationSize(0), executable);
 7318 
<span class="line-modified"> 7319         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));</span>
 7320     }
 7321 
 7322     cellResult(resultGPR, node);
 7323 }
 7324 
 7325 void SpeculativeJIT::compileSetFunctionName(Node* node)
 7326 {
 7327     SpeculateCellOperand func(this, node-&gt;child1());
 7328     GPRReg funcGPR = func.gpr();
 7329     JSValueOperand nameValue(this, node-&gt;child2());
 7330     JSValueRegs nameValueRegs = nameValue.jsValueRegs();
 7331 
 7332     flushRegisters();
<span class="line-modified"> 7333     callOperation(operationSetFunctionName, funcGPR, nameValueRegs);</span>
 7334     m_jit.exceptionCheck();
 7335 
 7336     noResult(node);
 7337 }
 7338 
<span class="line-modified"> 7339 void SpeculativeJIT::compileLoadVarargs(Node* node)</span>
 7340 {
 7341     LoadVarargsData* data = node-&gt;loadVarargsData();
 7342 
 7343     JSValueRegs argumentsRegs;
<span class="line-modified"> 7344     {</span>
<span class="line-modified"> 7345         JSValueOperand arguments(this, node-&gt;child1());</span>
<span class="line-modified"> 7346         argumentsRegs = arguments.jsValueRegs();</span>
<span class="line-modified"> 7347         flushRegisters();</span>
<span class="line-modified"> 7348     }</span>
 7349 
<span class="line-modified"> 7350     callOperation(operationSizeOfVarargs, GPRInfo::returnValueGPR, argumentsRegs, data-&gt;offset);</span>
 7351     m_jit.exceptionCheck();
 7352 
 7353     lock(GPRInfo::returnValueGPR);
<span class="line-modified"> 7354     {</span>
<span class="line-modified"> 7355         JSValueOperand arguments(this, node-&gt;child1());</span>
<span class="line-removed"> 7356         argumentsRegs = arguments.jsValueRegs();</span>
<span class="line-removed"> 7357         flushRegisters();</span>
<span class="line-removed"> 7358     }</span>
 7359     unlock(GPRInfo::returnValueGPR);
 7360 
<span class="line-modified"> 7361     // FIXME: There is a chance that we will call an effectful length property twice. This is safe</span>
<span class="line-modified"> 7362     // from the standpoint of the VM&#39;s integrity, but it&#39;s subtly wrong from a spec compliance</span>
<span class="line-modified"> 7363     // standpoint. The best solution would be one where we can exit *into* the op_call_varargs right</span>
<span class="line-modified"> 7364     // past the sizing.</span>
<span class="line-removed"> 7365     // https://bugs.webkit.org/show_bug.cgi?id=141448</span>
 7366 
<span class="line-modified"> 7367     GPRReg argCountIncludingThisGPR =</span>
<span class="line-modified"> 7368         JITCompiler::selectScratchGPR(GPRInfo::returnValueGPR, argumentsRegs);</span>

 7369 
<span class="line-modified"> 7370     m_jit.add32(TrustedImm32(1), GPRInfo::returnValueGPR, argCountIncludingThisGPR);</span>



 7371 
 7372     speculationCheck(
<span class="line-modified"> 7373         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(</span>
<span class="line-modified"> 7374             MacroAssembler::Above,</span>
<span class="line-modified"> 7375             GPRInfo::returnValueGPR,</span>
<span class="line-removed"> 7376             argCountIncludingThisGPR));</span>
 7377 
 7378     speculationCheck(
 7379         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7380             MacroAssembler::Above,
<span class="line-modified"> 7381             argCountIncludingThisGPR,</span>
 7382             TrustedImm32(data-&gt;limit)));
 7383 
<span class="line-modified"> 7384     m_jit.store32(argCountIncludingThisGPR, JITCompiler::payloadFor(data-&gt;machineCount));</span>


 7385 
<span class="line-modified"> 7386     callOperation(operationLoadVarargs, data-&gt;machineStart.offset(), argumentsRegs, data-&gt;offset, GPRInfo::returnValueGPR, data-&gt;mandatoryMinimum);</span>
 7387     m_jit.exceptionCheck();
 7388 
 7389     noResult(node);
 7390 }
 7391 
 7392 void SpeculativeJIT::compileForwardVarargs(Node* node)
 7393 {
 7394     LoadVarargsData* data = node-&gt;loadVarargsData();
 7395     InlineCallFrame* inlineCallFrame;
<span class="line-modified"> 7396     if (node-&gt;child1())</span>
<span class="line-modified"> 7397         inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
 7398     else
 7399         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 7400 

 7401     GPRTemporary length(this);
 7402     JSValueRegsTemporary temp(this);
<span class="line-modified"> 7403     GPRReg lengthGPR = length.gpr();</span>

 7404     JSValueRegs tempRegs = temp.regs();
 7405 
<span class="line-modified"> 7406     emitGetLength(inlineCallFrame, lengthGPR, /* includeThis = */ true);</span>
 7407     if (data-&gt;offset)
 7408         m_jit.sub32(TrustedImm32(data-&gt;offset), lengthGPR);
 7409 
 7410     speculationCheck(
 7411         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7412             MacroAssembler::Above,
 7413             lengthGPR, TrustedImm32(data-&gt;limit)));
 7414 
 7415     m_jit.store32(lengthGPR, JITCompiler::payloadFor(data-&gt;machineCount));
 7416 
 7417     VirtualRegister sourceStart = JITCompiler::argumentsStart(inlineCallFrame) + data-&gt;offset;
 7418     VirtualRegister targetStart = data-&gt;machineStart;
 7419 
 7420     m_jit.sub32(TrustedImm32(1), lengthGPR);
 7421 
 7422     // First have a loop that fills in the undefined slots in case of an arity check failure.
 7423     m_jit.move(TrustedImm32(data-&gt;mandatoryMinimum), tempRegs.payloadGPR());
 7424     JITCompiler::Jump done = m_jit.branch32(JITCompiler::BelowOrEqual, tempRegs.payloadGPR(), lengthGPR);
 7425 
 7426     JITCompiler::Label loop = m_jit.label();
</pre>
<hr />
<pre>
 7463 
 7464     SpeculateCellOperand scope(this, node-&gt;child1());
 7465     GPRReg scopeGPR = scope.gpr();
 7466     JSValue initializationValue = node-&gt;initializationValueForActivation();
 7467     ASSERT(initializationValue == jsUndefined() || initializationValue == jsTDZValue());
 7468 
 7469     if (table-&gt;singleton().isStillValid()) {
 7470         GPRFlushedCallResult result(this);
 7471         GPRReg resultGPR = result.gpr();
 7472 
 7473 #if USE(JSVALUE32_64)
 7474         JSValueRegsTemporary initialization(this);
 7475         JSValueRegs initializationRegs = initialization.regs();
 7476         m_jit.moveTrustedValue(initializationValue, initializationRegs);
 7477 #endif
 7478 
 7479         flushRegisters();
 7480 
 7481 #if USE(JSVALUE64)
 7482         callOperation(operationCreateActivationDirect,
<span class="line-modified"> 7483             resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue)));</span>
 7484 #else
 7485         callOperation(operationCreateActivationDirect,
<span class="line-modified"> 7486             resultGPR, structure, scopeGPR, table, initializationRegs);</span>
 7487 #endif
 7488         m_jit.exceptionCheck();
 7489         cellResult(resultGPR, node);
 7490         return;
 7491     }
 7492 
 7493     GPRTemporary result(this);
 7494     GPRTemporary scratch1(this);
 7495     GPRTemporary scratch2(this);
 7496     GPRReg resultGPR = result.gpr();
 7497     GPRReg scratch1GPR = scratch1.gpr();
 7498     GPRReg scratch2GPR = scratch2.gpr();
 7499 
 7500 #if USE(JSVALUE32_64)
 7501     JSValueRegsTemporary initialization(this);
 7502     JSValueRegs initializationRegs = initialization.regs();
 7503     m_jit.moveTrustedValue(initializationValue, initializationRegs);
 7504 #endif
 7505 
 7506     JITCompiler::JumpList slowPath;
</pre>
<hr />
<pre>
 7512     // Don&#39;t need a memory barriers since we just fast-created the activation, so the
 7513     // activation must be young.
 7514     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSScope::offsetOfNext()));
 7515     m_jit.storePtr(
 7516         TrustedImmPtr(node-&gt;cellOperand()),
 7517         JITCompiler::Address(resultGPR, JSLexicalEnvironment::offsetOfSymbolTable()));
 7518 
 7519     // Must initialize all members to undefined or the TDZ empty value.
 7520     for (unsigned i = 0; i &lt; table-&gt;scopeSize(); ++i) {
 7521         m_jit.storeTrustedValue(
 7522             initializationValue,
 7523             JITCompiler::Address(
 7524                 resultGPR, JSLexicalEnvironment::offsetOfVariable(ScopeOffset(i))));
 7525     }
 7526 
 7527     m_jit.mutatorFence(vm());
 7528 
 7529 #if USE(JSVALUE64)
 7530     addSlowPathGenerator(
 7531         slowPathCall(
<span class="line-modified"> 7532             slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue))));</span>
 7533 #else
 7534     addSlowPathGenerator(
 7535         slowPathCall(
<span class="line-modified"> 7536             slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, initializationRegs));</span>
 7537 #endif
 7538 
 7539     cellResult(resultGPR, node);
 7540 }
 7541 
 7542 void SpeculativeJIT::compileCreateDirectArguments(Node* node)
 7543 {
 7544     // FIXME: A more effective way of dealing with the argument count and callee is to have
 7545     // them be explicit arguments to this node.
 7546     // https://bugs.webkit.org/show_bug.cgi?id=142207
 7547 
 7548     GPRTemporary result(this);
 7549     GPRTemporary scratch1(this);
 7550     GPRTemporary scratch2(this);
 7551     GPRTemporary length;
 7552     GPRReg resultGPR = result.gpr();
 7553     GPRReg scratch1GPR = scratch1.gpr();
 7554     GPRReg scratch2GPR = scratch2.gpr();
 7555     GPRReg lengthGPR = InvalidGPRReg;
 7556     JSValueRegs valueRegs = JSValueRegs::withTwoAvailableRegs(scratch1GPR, scratch2GPR);
 7557 
 7558     unsigned minCapacity = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic)-&gt;numParameters() - 1;
 7559 
 7560     unsigned knownLength;
 7561     bool lengthIsKnown; // if false, lengthGPR will have the length.
 7562     auto* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 7563     if (inlineCallFrame
 7564         &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
<span class="line-modified"> 7565         knownLength = inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
 7566         lengthIsKnown = true;
 7567     } else {
 7568         knownLength = UINT_MAX;
 7569         lengthIsKnown = false;
 7570 
 7571         GPRTemporary realLength(this);
 7572         length.adopt(realLength);
 7573         lengthGPR = length.gpr();
 7574 
 7575         VirtualRegister argumentCountRegister = m_jit.argumentCount(node-&gt;origin.semantic);
 7576         m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), lengthGPR);
 7577         m_jit.sub32(TrustedImm32(1), lengthGPR);
 7578     }
 7579 
 7580     RegisteredStructure structure =
 7581         m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;directArgumentsStructure());
 7582 
 7583     // Use a different strategy for allocating the object depending on whether we know its
 7584     // size statically.
 7585     JITCompiler::JumpList slowPath;
</pre>
<hr />
<pre>
 7611             resultGPR, TrustedImmPtr(structure), scratch1GPR, scratch1GPR, scratch2GPR,
 7612             slowPath);
 7613 
 7614         m_jit.store32(
 7615             lengthGPR, JITCompiler::Address(resultGPR, DirectArguments::offsetOfLength()));
 7616     }
 7617 
 7618     m_jit.store32(
 7619         TrustedImm32(minCapacity),
 7620         JITCompiler::Address(resultGPR, DirectArguments::offsetOfMinCapacity()));
 7621 
 7622     m_jit.storePtr(
 7623         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfMappedArguments()));
 7624 
 7625     m_jit.storePtr(
 7626         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfModifiedArgumentsDescriptor()));
 7627 
 7628     if (lengthIsKnown) {
 7629         addSlowPathGenerator(
 7630             slowPathCall(
<span class="line-modified"> 7631                 slowPath, this, operationCreateDirectArguments, resultGPR, structure,</span>
 7632                 knownLength, minCapacity));
 7633     } else {
 7634         auto generator = makeUnique&lt;CallCreateDirectArgumentsSlowPathGenerator&gt;(
 7635             slowPath, this, resultGPR, structure, lengthGPR, minCapacity);
 7636         addSlowPathGenerator(WTFMove(generator));
 7637     }
 7638 
 7639     if (inlineCallFrame) {
 7640         if (inlineCallFrame-&gt;isClosureCall) {
 7641             m_jit.loadPtr(
 7642                 JITCompiler::addressFor(
 7643                     inlineCallFrame-&gt;calleeRecovery.virtualRegister()),
 7644                 scratch1GPR);
 7645         } else {
 7646             m_jit.move(
 7647                 TrustedImmPtr::weakPointer(
 7648                     m_jit.graph(), inlineCallFrame-&gt;calleeRecovery.constant().asCell()),
 7649                 scratch1GPR);
 7650         }
 7651     } else
</pre>
<hr />
<pre>
 7728     auto argumentOutOfBounds = m_jit.branch32(CCallHelpers::LessThanOrEqual, argumentCountGPR, CCallHelpers::TrustedImm32(node-&gt;argumentIndex()));
 7729     m_jit.loadValue(CCallHelpers::addressFor(CCallHelpers::argumentsStart(node-&gt;origin.semantic) + node-&gt;argumentIndex() - 1), resultRegs);
 7730     auto done = m_jit.jump();
 7731 
 7732     argumentOutOfBounds.link(&amp;m_jit);
 7733     m_jit.moveValue(jsUndefined(), resultRegs);
 7734 
 7735     done.link(&amp;m_jit);
 7736     jsValueResult(resultRegs, node);
 7737 }
 7738 
 7739 void SpeculativeJIT::compileCreateScopedArguments(Node* node)
 7740 {
 7741     SpeculateCellOperand scope(this, node-&gt;child1());
 7742     GPRReg scopeGPR = scope.gpr();
 7743 
 7744     GPRFlushedCallResult result(this);
 7745     GPRReg resultGPR = result.gpr();
 7746     flushRegisters();
 7747 


 7748     // We set up the arguments ourselves, because we have the whole register file and we can
 7749     // set them up directly into the argument registers. This also means that we don&#39;t have to
 7750     // invent a four-argument-register shuffle.
 7751 
<span class="line-modified"> 7752     // Arguments: 0:exec, 1:structure, 2:start, 3:length, 4:callee, 5:scope</span>
 7753 
 7754     // Do the scopeGPR first, since it might alias an argument register.
 7755     m_jit.setupArgument(5, [&amp;] (GPRReg destGPR) { m_jit.move(scopeGPR, destGPR); });
 7756 
 7757     // These other things could be done in any order.
 7758     m_jit.setupArgument(4, [&amp;] (GPRReg destGPR) { emitGetCallee(node-&gt;origin.semantic, destGPR); });
 7759     m_jit.setupArgument(3, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });
 7760     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });
 7761     m_jit.setupArgument(
 7762         1, [&amp;] (GPRReg destGPR) {
 7763             m_jit.move(
<span class="line-modified"> 7764                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)-&gt;scopedArgumentsStructure()),</span>
 7765                 destGPR);
 7766         });
<span class="line-modified"> 7767     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(GPRInfo::callFrameRegister, destGPR); });</span>
 7768 
 7769     appendCallSetResult(operationCreateScopedArguments, resultGPR);
 7770     m_jit.exceptionCheck();
 7771 
 7772     cellResult(resultGPR, node);
 7773 }
 7774 
 7775 void SpeculativeJIT::compileCreateClonedArguments(Node* node)
 7776 {
 7777     GPRFlushedCallResult result(this);
 7778     GPRReg resultGPR = result.gpr();
 7779     flushRegisters();
 7780 


 7781     // We set up the arguments ourselves, because we have the whole register file and we can
 7782     // set them up directly into the argument registers.
 7783 
<span class="line-modified"> 7784     // Arguments: 0:exec, 1:structure, 2:start, 3:length, 4:callee</span>
 7785     m_jit.setupArgument(4, [&amp;] (GPRReg destGPR) { emitGetCallee(node-&gt;origin.semantic, destGPR); });
 7786     m_jit.setupArgument(3, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });
 7787     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });
 7788     m_jit.setupArgument(
 7789         1, [&amp;] (GPRReg destGPR) {
 7790             m_jit.move(
 7791                 TrustedImmPtr::weakPointer(
<span class="line-modified"> 7792                     m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)-&gt;clonedArgumentsStructure()),</span>
 7793                 destGPR);
 7794         });
<span class="line-modified"> 7795     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(GPRInfo::callFrameRegister, destGPR); });</span>
 7796 
 7797     appendCallSetResult(operationCreateClonedArguments, resultGPR);
 7798     m_jit.exceptionCheck();
 7799 
 7800     cellResult(resultGPR, node);
 7801 }
 7802 






















 7803 void SpeculativeJIT::compileCreateRest(Node* node)
 7804 {
 7805     ASSERT(node-&gt;op() == CreateRest);
 7806 
<span class="line-removed"> 7807 #if !CPU(X86)</span>
 7808     if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
 7809         SpeculateStrictInt32Operand arrayLength(this, node-&gt;child1());
 7810         GPRTemporary arrayResult(this);
 7811 
 7812         GPRReg arrayLengthGPR = arrayLength.gpr();
 7813         GPRReg arrayResultGPR = arrayResult.gpr();
 7814 
 7815         // We can tell compileAllocateNewArrayWithSize() that it does not need to check
 7816         // for large arrays and use ArrayStorage structure because arrayLength here will
 7817         // always be bounded by stack size. Realistically, we won&#39;t be able to push enough
 7818         // arguments to have arrayLength exceed MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH.
 7819         bool shouldAllowForArrayStorageStructureForLargeArrays = false;
<span class="line-removed"> 7820         ASSERT(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure()-&gt;indexingMode() == ArrayWithContiguous || m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;isHavingABadTime());</span>
 7821         compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node-&gt;origin.semantic), arrayResultGPR, arrayLengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);
 7822 
 7823         GPRTemporary argumentsStart(this);
 7824         GPRReg argumentsStartGPR = argumentsStart.gpr();
 7825 
 7826         emitGetArgumentStart(node-&gt;origin.semantic, argumentsStartGPR);
 7827 
 7828         GPRTemporary butterfly(this);
 7829         GPRTemporary currentLength(this);
 7830         JSValueRegsTemporary value(this);
 7831 
 7832         JSValueRegs valueRegs = value.regs();
 7833         GPRReg currentLengthGPR = currentLength.gpr();
 7834         GPRReg butterflyGPR = butterfly.gpr();
 7835 
 7836         m_jit.loadPtr(MacroAssembler::Address(arrayResultGPR, JSObject::butterflyOffset()), butterflyGPR);
 7837 
 7838         CCallHelpers::Jump skipLoop = m_jit.branch32(MacroAssembler::Equal, arrayLengthGPR, TrustedImm32(0));
 7839         m_jit.zeroExtend32ToPtr(arrayLengthGPR, currentLengthGPR);
 7840         m_jit.addPtr(Imm32(sizeof(Register) * node-&gt;numberOfArgumentsToSkip()), argumentsStartGPR);
 7841 
 7842         auto loop = m_jit.label();
 7843         m_jit.sub32(TrustedImm32(1), currentLengthGPR);
 7844         m_jit.loadValue(JITCompiler::BaseIndex(argumentsStartGPR, currentLengthGPR, MacroAssembler::TimesEight), valueRegs);
 7845         m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(butterflyGPR, currentLengthGPR, MacroAssembler::TimesEight));
 7846         m_jit.branch32(MacroAssembler::NotEqual, currentLengthGPR, TrustedImm32(0)).linkTo(loop, &amp;m_jit);
 7847 
 7848         skipLoop.link(&amp;m_jit);
 7849         cellResult(arrayResultGPR, node);
 7850         return;
 7851     }
<span class="line-removed"> 7852 #endif // !CPU(X86)</span>
 7853 
 7854     SpeculateStrictInt32Operand arrayLength(this, node-&gt;child1());
 7855     GPRTemporary argumentsStart(this);
 7856     GPRTemporary numberOfArgumentsToSkip(this);
 7857 
 7858     GPRReg arrayLengthGPR = arrayLength.gpr();
 7859     GPRReg argumentsStartGPR = argumentsStart.gpr();
 7860 
 7861     emitGetArgumentStart(node-&gt;origin.semantic, argumentsStartGPR);
 7862 
 7863     flushRegisters();
 7864 
 7865     GPRFlushedCallResult result(this);
 7866     GPRReg resultGPR = result.gpr();
<span class="line-modified"> 7867     callOperation(operationCreateRest, resultGPR, argumentsStartGPR, Imm32(node-&gt;numberOfArgumentsToSkip()), arrayLengthGPR);</span>
 7868     m_jit.exceptionCheck();
 7869 
 7870     cellResult(resultGPR, node);
 7871 }
 7872 
 7873 void SpeculativeJIT::compileSpread(Node* node)
 7874 {
 7875     ASSERT(node-&gt;op() == Spread);
 7876 
 7877     SpeculateCellOperand operand(this, node-&gt;child1());
 7878     GPRReg argument = operand.gpr();
 7879 
 7880     if (node-&gt;child1().useKind() == ArrayUse)
 7881         speculateArray(node-&gt;child1(), argument);
 7882 
 7883     if (m_jit.graph().canDoFastSpread(node, m_state.forNode(node-&gt;child1()))) {
 7884 #if USE(JSVALUE64)
 7885         GPRTemporary result(this);
 7886         GPRTemporary scratch1(this);
 7887         GPRTemporary scratch2(this);
 7888         GPRTemporary length(this);
 7889         FPRTemporary doubleRegister(this);
 7890 
 7891         GPRReg resultGPR = result.gpr();
 7892         GPRReg scratch1GPR = scratch1.gpr();
 7893         GPRReg scratch2GPR = scratch2.gpr();
 7894         GPRReg lengthGPR = length.gpr();
 7895         FPRReg doubleFPR = doubleRegister.fpr();
 7896 
 7897         MacroAssembler::JumpList slowPath;

 7898 
 7899         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch1GPR);







 7900         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch1GPR);
 7901         m_jit.sub32(TrustedImm32(Int32Shape), scratch1GPR);
 7902 
 7903         slowPath.append(m_jit.branch32(MacroAssembler::Above, scratch1GPR, TrustedImm32(ContiguousShape - Int32Shape)));
 7904 
 7905         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), lengthGPR);
 7906         m_jit.load32(MacroAssembler::Address(lengthGPR, Butterfly::offsetOfPublicLength()), lengthGPR);

 7907         static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
 7908         m_jit.move(lengthGPR, scratch1GPR);
 7909         m_jit.lshift32(TrustedImm32(3), scratch1GPR);
<span class="line-modified"> 7910         m_jit.add32(TrustedImm32(JSFixedArray::offsetOfData()), scratch1GPR);</span>
 7911 
<span class="line-modified"> 7912         m_jit.emitAllocateVariableSizedCell&lt;JSFixedArray&gt;(vm(), resultGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.graph().m_vm.fixedArrayStructure.get())), scratch1GPR, scratch1GPR, scratch2GPR, slowPath);</span>
<span class="line-modified"> 7913         m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSFixedArray::offsetOfSize()));</span>

 7914 
 7915         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), scratch1GPR);
 7916 
<span class="line-removed"> 7917         MacroAssembler::JumpList done;</span>
<span class="line-removed"> 7918 </span>
 7919         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch2GPR);
 7920         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch2GPR);
 7921         auto isDoubleArray = m_jit.branch32(MacroAssembler::Equal, scratch2GPR, TrustedImm32(DoubleShape));
 7922 
 7923         {
 7924             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 7925             auto loopStart = m_jit.label();
 7926             m_jit.sub32(TrustedImm32(1), lengthGPR);
 7927             m_jit.load64(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), scratch2GPR);
 7928             auto notEmpty = m_jit.branchIfNotEmpty(scratch2GPR);
 7929             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 7930             notEmpty.link(&amp;m_jit);
<span class="line-modified"> 7931             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));</span>
 7932             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 7933             done.append(m_jit.jump());
 7934         }
 7935 
 7936         isDoubleArray.link(&amp;m_jit);
 7937         {
 7938             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 7939             auto loopStart = m_jit.label();
 7940             m_jit.sub32(TrustedImm32(1), lengthGPR);
 7941             m_jit.loadDouble(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), doubleFPR);
 7942             auto notEmpty = m_jit.branchIfNotNaN(doubleFPR);
 7943             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 7944             auto doStore = m_jit.jump();
 7945             notEmpty.link(&amp;m_jit);
 7946             m_jit.boxDouble(doubleFPR, scratch2GPR);
 7947             doStore.link(&amp;m_jit);
<span class="line-modified"> 7948             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));</span>
 7949             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 7950             done.append(m_jit.jump());
 7951         }
 7952 
<span class="line-modified"> 7953         m_jit.mutatorFence(vm());</span>
<span class="line-removed"> 7954 </span>
<span class="line-removed"> 7955         slowPath.link(&amp;m_jit);</span>
<span class="line-removed"> 7956         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationSpreadFastArray, resultGPR, argument));</span>
 7957 
 7958         done.link(&amp;m_jit);

 7959         cellResult(resultGPR, node);
 7960 #else
 7961         flushRegisters();
 7962 
 7963         GPRFlushedCallResult result(this);
 7964         GPRReg resultGPR = result.gpr();
<span class="line-modified"> 7965         callOperation(operationSpreadFastArray, resultGPR, argument);</span>
 7966         m_jit.exceptionCheck();
 7967         cellResult(resultGPR, node);
 7968 #endif // USE(JSVALUE64)
 7969     } else {
 7970         flushRegisters();
 7971 
 7972         GPRFlushedCallResult result(this);
 7973         GPRReg resultGPR = result.gpr();
<span class="line-modified"> 7974         callOperation(operationSpreadGeneric, resultGPR, argument);</span>
 7975         m_jit.exceptionCheck();
 7976         cellResult(resultGPR, node);
 7977     }
 7978 }
 7979 
 7980 void SpeculativeJIT::compileNewArray(Node* node)
 7981 {
 7982     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);

 7983     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingType())) {
<span class="line-removed"> 7984         RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()));</span>
<span class="line-removed"> 7985         DFG_ASSERT(m_jit.graph(), node, structure-&gt;indexingType() == node-&gt;indexingType(), structure-&gt;indexingType(), node-&gt;indexingType());</span>
<span class="line-removed"> 7986         ASSERT(</span>
<span class="line-removed"> 7987             hasUndecided(structure-&gt;indexingType())</span>
<span class="line-removed"> 7988             || hasInt32(structure-&gt;indexingType())</span>
<span class="line-removed"> 7989             || hasDouble(structure-&gt;indexingType())</span>
<span class="line-removed"> 7990             || hasContiguous(structure-&gt;indexingType()));</span>
<span class="line-removed"> 7991 </span>
 7992         unsigned numElements = node-&gt;numChildren();
 7993         unsigned vectorLengthHint = node-&gt;vectorLengthHint();
 7994         ASSERT(vectorLengthHint &gt;= numElements);
 7995 
 7996         GPRTemporary result(this);
 7997         GPRTemporary storage(this);
 7998 
 7999         GPRReg resultGPR = result.gpr();
 8000         GPRReg storageGPR = storage.gpr();
 8001 
 8002         emitAllocateRawObject(resultGPR, structure, storageGPR, numElements, vectorLengthHint);
 8003 
 8004         // At this point, one way or another, resultGPR and storageGPR have pointers to
 8005         // the JSArray and the Butterfly, respectively.
 8006 
 8007         ASSERT(!hasUndecided(structure-&gt;indexingType()) || !node-&gt;numChildren());
 8008 
 8009         for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
 8010             Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + operandIdx];
 8011             switch (node-&gt;indexingType()) {
</pre>
<hr />
<pre>
 8037             default:
 8038                 CRASH();
 8039                 break;
 8040             }
 8041         }
 8042 
 8043         // Yuck, we should *really* have a way of also returning the storageGPR. But
 8044         // that&#39;s the least of what&#39;s wrong with this code. We really shouldn&#39;t be
 8045         // allocating the array after having computed - and probably spilled to the
 8046         // stack - all of the things that will go into the array. The solution to that
 8047         // bigger problem will also likely fix the redundancy in reloading the storage
 8048         // pointer that we currently have.
 8049 
 8050         cellResult(resultGPR, node);
 8051         return;
 8052     }
 8053 
 8054     if (!node-&gt;numChildren()) {
 8055         flushRegisters();
 8056         GPRFlushedCallResult result(this);
<span class="line-modified"> 8057         callOperation(operationNewEmptyArray, result.gpr(), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())));</span>
 8058         m_jit.exceptionCheck();
 8059         cellResult(result.gpr(), node);
 8060         return;
 8061     }
 8062 
 8063     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
 8064     ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8065     EncodedJSValue* buffer = scratchBuffer ? static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;
 8066 
 8067     for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
 8068         // Need to perform the speculations that this node promises to perform. If we&#39;re
 8069         // emitting code here and the indexing type is not array storage then there is
 8070         // probably something hilarious going on and we&#39;re already failing at all the
 8071         // things, but at least we&#39;re going to be sound.
 8072         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + operandIdx];
 8073         switch (node-&gt;indexingType()) {
 8074         case ALL_BLANK_INDEXING_TYPES:
 8075         case ALL_UNDECIDED_INDEXING_TYPES:
 8076             CRASH();
 8077             break;
</pre>
<hr />
<pre>
 8108         }
 8109         default:
 8110             CRASH();
 8111             break;
 8112         }
 8113     }
 8114 
 8115     flushRegisters();
 8116 
 8117     if (scratchSize) {
 8118         GPRTemporary scratch(this);
 8119 
 8120         // Tell GC mark phase how much of the scratch buffer is active during call.
 8121         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8122         m_jit.storePtr(TrustedImmPtr(scratchSize), scratch.gpr());
 8123     }
 8124 
 8125     GPRFlushedCallResult result(this);
 8126 
 8127     callOperation(
<span class="line-modified"> 8128         operationNewArray, result.gpr(), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())),</span>
 8129         static_cast&lt;void*&gt;(buffer), size_t(node-&gt;numChildren()));
 8130     m_jit.exceptionCheck();
 8131 
 8132     if (scratchSize) {
 8133         GPRTemporary scratch(this);
 8134 
 8135         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8136         m_jit.storePtr(TrustedImmPtr(nullptr), scratch.gpr());
 8137     }
 8138 
 8139     cellResult(result.gpr(), node, UseChildrenCalledExplicitly);
 8140 }
 8141 
 8142 void SpeculativeJIT::compileNewArrayWithSpread(Node* node)
 8143 {
 8144     ASSERT(node-&gt;op() == NewArrayWithSpread);

 8145 
 8146 #if USE(JSVALUE64)
 8147     if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
 8148         GPRTemporary result(this);
 8149         GPRReg resultGPR = result.gpr();
 8150 
 8151         BitVector* bitVector = node-&gt;bitVector();






























 8152         {
 8153             unsigned startLength = 0;
 8154             for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8155                 if (!bitVector-&gt;get(i))
 8156                     ++startLength;
 8157             }
 8158 
 8159             GPRTemporary length(this);
 8160             GPRReg lengthGPR = length.gpr();
 8161             m_jit.move(TrustedImm32(startLength), lengthGPR);
 8162 
 8163             for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8164                 if (bitVector-&gt;get(i)) {
 8165                     Edge use = m_jit.graph().varArgChild(node, i);
<span class="line-modified"> 8166                     SpeculateCellOperand fixedArray(this, use);</span>
<span class="line-modified"> 8167                     GPRReg fixedArrayGPR = fixedArray.gpr();</span>
<span class="line-modified"> 8168                     speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchAdd32(MacroAssembler::Overflow, MacroAssembler::Address(fixedArrayGPR, JSFixedArray::offsetOfSize()), lengthGPR));</span>
 8169                 }
 8170             }
 8171 
 8172             speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branch32(MacroAssembler::AboveOrEqual, lengthGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));
 8173 
 8174             // We can tell compileAllocateNewArrayWithSize() that it does not need to
 8175             // check for large arrays and use ArrayStorage structure because we already
 8176             // ensured above that the spread array length will definitely fit in a
 8177             // non-ArrayStorage shaped array.
 8178             bool shouldAllowForArrayStorageStructureForLargeArrays = false;
<span class="line-modified"> 8179             ASSERT(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure()-&gt;indexingType() == ArrayWithContiguous || m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;isHavingABadTime());</span>
<span class="line-removed"> 8180             compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node-&gt;origin.semantic), resultGPR, lengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);</span>
 8181         }
 8182 
 8183         GPRTemporary index(this);
 8184         GPRReg indexGPR = index.gpr();
 8185 
 8186         GPRTemporary storage(this);
 8187         GPRReg storageGPR = storage.gpr();
 8188 
 8189         m_jit.move(TrustedImm32(0), indexGPR);
 8190         m_jit.loadPtr(MacroAssembler::Address(resultGPR, JSObject::butterflyOffset()), storageGPR);
 8191 
 8192         for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8193             Edge use = m_jit.graph().varArgChild(node, i);
 8194             if (bitVector-&gt;get(i)) {
<span class="line-modified"> 8195                 SpeculateCellOperand fixedArray(this, use);</span>
<span class="line-modified"> 8196                 GPRReg fixedArrayGPR = fixedArray.gpr();</span>
 8197 
<span class="line-modified"> 8198                 GPRTemporary fixedIndex(this);</span>
<span class="line-modified"> 8199                 GPRReg fixedIndexGPR = fixedIndex.gpr();</span>
 8200 
 8201                 GPRTemporary item(this);
 8202                 GPRReg itemGPR = item.gpr();
 8203 
<span class="line-modified"> 8204                 GPRTemporary fixedLength(this);</span>
<span class="line-modified"> 8205                 GPRReg fixedLengthGPR = fixedLength.gpr();</span>
 8206 
<span class="line-modified"> 8207                 m_jit.load32(MacroAssembler::Address(fixedArrayGPR, JSFixedArray::offsetOfSize()), fixedLengthGPR);</span>
<span class="line-modified"> 8208                 m_jit.move(TrustedImm32(0), fixedIndexGPR);</span>
<span class="line-modified"> 8209                 auto done = m_jit.branchPtr(MacroAssembler::AboveOrEqual, fixedIndexGPR, fixedLengthGPR);</span>
 8210                 auto loopStart = m_jit.label();
 8211                 m_jit.load64(
<span class="line-modified"> 8212                     MacroAssembler::BaseIndex(fixedArrayGPR, fixedIndexGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()),</span>
 8213                     itemGPR);
 8214 
 8215                 m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
<span class="line-modified"> 8216                 m_jit.addPtr(TrustedImm32(1), fixedIndexGPR);</span>
 8217                 m_jit.addPtr(TrustedImm32(1), indexGPR);
<span class="line-modified"> 8218                 m_jit.branchPtr(MacroAssembler::Below, fixedIndexGPR, fixedLengthGPR).linkTo(loopStart, &amp;m_jit);</span>
 8219 
 8220                 done.link(&amp;m_jit);
 8221             } else {
 8222                 JSValueOperand item(this, use);
 8223                 GPRReg itemGPR = item.gpr();
 8224                 m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
 8225                 m_jit.addPtr(TrustedImm32(1), indexGPR);
 8226             }
 8227         }
 8228 
 8229         cellResult(resultGPR, node);
 8230         return;
 8231     }
 8232 #endif // USE(JSVALUE64)
 8233 
 8234     ASSERT(node-&gt;numChildren());
 8235     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
 8236     ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8237     EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 8238 
 8239     BitVector* bitVector = node-&gt;bitVector();
 8240     for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8241         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + i];
 8242         if (bitVector-&gt;get(i)) {
<span class="line-modified"> 8243             SpeculateCellOperand fixedArray(this, use);</span>
<span class="line-modified"> 8244             GPRReg arrayGPR = fixedArray.gpr();</span>
 8245 #if USE(JSVALUE64)
<span class="line-modified"> 8246             m_jit.store64(arrayGPR, &amp;buffer[i]);</span>
 8247 #else
 8248             char* pointer = static_cast&lt;char*&gt;(static_cast&lt;void*&gt;(&amp;buffer[i]));
<span class="line-modified"> 8249             m_jit.store32(arrayGPR, pointer + PayloadOffset);</span>
 8250             m_jit.store32(TrustedImm32(JSValue::CellTag), pointer + TagOffset);
 8251 #endif
 8252         } else {
 8253             JSValueOperand input(this, use);
 8254             JSValueRegs inputRegs = input.jsValueRegs();
 8255             m_jit.storeValue(inputRegs, &amp;buffer[i]);
 8256         }
 8257     }
 8258 
 8259     {
 8260         GPRTemporary scratch(this);
 8261         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8262         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(scratch.gpr()));
 8263     }
 8264 
 8265     flushRegisters();
 8266 
 8267     GPRFlushedCallResult result(this);
 8268     GPRReg resultGPR = result.gpr();
 8269 
<span class="line-modified"> 8270     callOperation(operationNewArrayWithSpreadSlow, resultGPR, buffer, node-&gt;numChildren());</span>
 8271     m_jit.exceptionCheck();
 8272     {
 8273         GPRTemporary scratch(this);
 8274         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8275         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(scratch.gpr()));
 8276     }
 8277 
 8278     cellResult(resultGPR, node);
 8279 }
 8280 
 8281 void SpeculativeJIT::compileGetRestLength(Node* node)
 8282 {
 8283     ASSERT(node-&gt;op() == GetRestLength);
 8284 
 8285     GPRTemporary result(this);
 8286     GPRReg resultGPR = result.gpr();
 8287 
 8288     emitGetLength(node-&gt;origin.semantic, resultGPR);
 8289     CCallHelpers::Jump hasNonZeroLength = m_jit.branch32(MacroAssembler::Above, resultGPR, Imm32(node-&gt;numberOfArgumentsToSkip()));
 8290     m_jit.move(TrustedImm32(0), resultGPR);
</pre>
<hr />
<pre>
 8435 
 8436         MacroAssembler::JumpList slowCases;
 8437         m_jit.move(TrustedImmPtr(nullptr), storageResultGPR);
 8438         // Enable the fast case on 64-bit platforms, where a sufficient amount of GP registers should be available.
 8439         // Other platforms could support the same approach with custom code, but that is not currently worth the extra code maintenance.
 8440         if (is64Bit()) {
 8441             GPRTemporary scratch(this);
 8442             GPRTemporary scratch2(this);
 8443             GPRReg scratchGPR = scratch.gpr();
 8444             GPRReg scratch2GPR = scratch2.gpr();
 8445 
 8446             emitAllocateButterfly(storageResultGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
 8447             emitInitializeButterfly(storageResultGPR, sizeGPR, emptyValueRegs, scratchGPR);
 8448             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, tempValue, storageResultGPR, scratchGPR, scratch2GPR, slowCases);
 8449             m_jit.mutatorFence(vm());
 8450         } else {
 8451             slowCases.append(m_jit.jump());
 8452         }
 8453 
 8454         addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableStructureVariableSizeSlowPathGenerator&gt;(
<span class="line-modified"> 8455             slowCases, this, operationNewArrayWithSize, resultGPR, tempValue, sizeGPR, storageResultGPR));</span>
 8456     }
 8457 
 8458     GPRTemporary temp4(this);
 8459     GPRReg loadIndex = temp4.gpr();
 8460 
 8461     if (node-&gt;numChildren() == 2) {
 8462         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempGPR);
 8463         m_jit.move(TrustedImm32(0), loadIndex);
 8464     } else {
 8465         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempValue);
 8466         if (node-&gt;numChildren() == 4)
 8467             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, tempValue, tempGPR);
 8468         else
 8469             m_jit.move(tempValue, tempGPR);
 8470         emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 1), WTF::nullopt, tempValue, loadIndex);
 8471     }
 8472 
 8473     GPRTemporary temp5(this);
 8474     GPRReg storeIndex = temp5.gpr();
 8475     m_jit.move(TrustedImmPtr(nullptr), storeIndex);
</pre>
<hr />
<pre>
 8654         m_jit.add32(TrustedImm32(1), indexGPR);
 8655         m_jit.jump().linkTo(loop, &amp;m_jit);
 8656 
 8657         notFound.link(&amp;m_jit);
 8658         m_jit.move(TrustedImm32(-1), indexGPR);
 8659         found.link(&amp;m_jit);
 8660         int32Result(indexGPR, node);
 8661         return;
 8662     }
 8663 
 8664     case StringUse: {
 8665         ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
 8666         SpeculateCellOperand searchElement(this, searchElementEdge);
 8667 
 8668         GPRReg searchElementGPR = searchElement.gpr();
 8669 
 8670         speculateString(searchElementEdge, searchElementGPR);
 8671 
 8672         flushRegisters();
 8673 
<span class="line-modified"> 8674         callOperation(operationArrayIndexOfString, lengthGPR, storageGPR, searchElementGPR, indexGPR);</span>
 8675         m_jit.exceptionCheck();
 8676 
 8677         int32Result(lengthGPR, node);
 8678         return;
 8679     }
 8680 
 8681     case UntypedUse: {
 8682         JSValueOperand searchElement(this, searchElementEdge);
 8683 
 8684         JSValueRegs searchElementRegs = searchElement.jsValueRegs();
 8685 
 8686         flushRegisters();
 8687         switch (node-&gt;arrayMode().type()) {
 8688         case Array::Double:
<span class="line-modified"> 8689             callOperation(operationArrayIndexOfValueDouble, lengthGPR, storageGPR, searchElementRegs, indexGPR);</span>
 8690             break;
 8691         case Array::Int32:
 8692         case Array::Contiguous:
<span class="line-modified"> 8693             callOperation(operationArrayIndexOfValueInt32OrContiguous, lengthGPR, storageGPR, searchElementRegs, indexGPR);</span>
 8694             break;
 8695         default:
 8696             RELEASE_ASSERT_NOT_REACHED();
 8697             break;
 8698         }
 8699         m_jit.exceptionCheck();
 8700 
 8701         int32Result(lengthGPR, node);
 8702         return;
 8703     }
 8704 
 8705     default:
 8706         RELEASE_ASSERT_NOT_REACHED();
 8707         return;
 8708     }
 8709 }
 8710 
 8711 void SpeculativeJIT::compileArrayPush(Node* node)
 8712 {
 8713     ASSERT(node-&gt;arrayMode().isJSArray());
</pre>
<hr />
<pre>
 8742     switch (node-&gt;arrayMode().type()) {
 8743     case Array::Int32:
 8744     case Array::Contiguous: {
 8745         if (elementCount == 1) {
 8746             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8747             if (node-&gt;arrayMode().type() == Array::Int32) {
 8748                 ASSERT(element.useKind() == Int32Use);
 8749                 speculateInt32(element);
 8750             }
 8751             JSValueOperand value(this, element, ManualOperandSpeculation);
 8752             JSValueRegs valueRegs = value.jsValueRegs();
 8753 
 8754             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8755             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8756             m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8757             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8758             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8759             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8760 
 8761             addSlowPathGenerator(
<span class="line-modified"> 8762                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, valueRegs, baseGPR));</span>
 8763 
 8764             jsValueResult(resultRegs, node);
 8765             return;
 8766         }
 8767 
 8768         if (node-&gt;arrayMode().type() == Array::Int32) {
 8769             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8770                 Edge element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8771                 ASSERT(element.useKind() == Int32Use);
 8772                 speculateInt32(element);
 8773             }
 8774         }
 8775 
 8776         GPRTemporary buffer(this);
 8777         GPRReg bufferGPR = buffer.gpr();
 8778 
 8779         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8780         m_jit.move(storageLengthGPR, bufferGPR);
 8781         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8782         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
</pre>
<hr />
<pre>
 8790         slowPath.link(&amp;m_jit);
 8791 
 8792         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 8793         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8794         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8795         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8796         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8797 
 8798         storageDone.link(&amp;m_jit);
 8799         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8800             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8801             JSValueOperand value(this, element, ManualOperandSpeculation); // We did type checks above.
 8802             JSValueRegs valueRegs = value.jsValueRegs();
 8803 
 8804             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 8805             value.use();
 8806         }
 8807 
 8808         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8809 
<span class="line-modified"> 8810         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
 8811 
 8812         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8813         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8814 
 8815         base.use();
 8816         storage.use();
 8817 
 8818         fastPath.link(&amp;m_jit);
 8819         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8820         return;
 8821     }
 8822 
 8823     case Array::Double: {
 8824         if (elementCount == 1) {
 8825             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8826             speculate(node, element);
 8827             SpeculateDoubleOperand value(this, element);
 8828             FPRReg valueFPR = value.fpr();
 8829 
 8830             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8831             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8832             m_jit.storeDouble(valueFPR, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8833             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8834             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8835             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8836 
 8837             addSlowPathGenerator(
<span class="line-modified"> 8838                 slowPathCall(slowPath, this, operationArrayPushDouble, resultRegs, valueFPR, baseGPR));</span>
 8839 
 8840             jsValueResult(resultRegs, node);
 8841             return;
 8842         }
 8843 
 8844         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8845             Edge element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8846             ASSERT(element.useKind() == DoubleRepRealUse);
 8847             speculate(node, element);
 8848         }
 8849 
 8850         GPRTemporary buffer(this);
 8851         GPRReg bufferGPR = buffer.gpr();
 8852 
 8853         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8854         m_jit.move(storageLengthGPR, bufferGPR);
 8855         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8856         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8857 
 8858         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
</pre>
<hr />
<pre>
 8864         slowPath.link(&amp;m_jit);
 8865 
 8866         size_t scratchSize = sizeof(double) * elementCount;
 8867         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8868         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8869         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8870         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8871 
 8872         storageDone.link(&amp;m_jit);
 8873         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8874             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8875             SpeculateDoubleOperand value(this, element);
 8876             FPRReg valueFPR = value.fpr();
 8877 
 8878             m_jit.storeDouble(valueFPR, MacroAssembler::Address(bufferGPR, sizeof(double) * elementIndex));
 8879             value.use();
 8880         }
 8881 
 8882         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8883 
<span class="line-modified"> 8884         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushDoubleMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
 8885 
 8886         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8887         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8888 
 8889         base.use();
 8890         storage.use();
 8891 
 8892         fastPath.link(&amp;m_jit);
 8893         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8894         return;
 8895     }
 8896 
 8897     case Array::ArrayStorage: {
 8898         // This ensures that the result of ArrayPush is Int32 in AI.
 8899         int32_t largestPositiveInt32Length = 0x7fffffff - elementCount;
 8900         if (elementCount == 1) {
 8901             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8902             JSValueOperand value(this, element);
 8903             JSValueRegs valueRegs = value.jsValueRegs();
 8904 
 8905             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
 8906 
 8907             // Refuse to handle bizarre lengths.
 8908             speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::Above, storageLengthGPR, TrustedImm32(largestPositiveInt32Length)));
 8909 
 8910             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
 8911 
 8912             m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
 8913 
 8914             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8915             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
 8916             m_jit.add32(TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 8917             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8918 
 8919             addSlowPathGenerator(
<span class="line-modified"> 8920                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, valueRegs, baseGPR));</span>
 8921 
 8922             jsValueResult(resultRegs, node);
 8923             return;
 8924         }
 8925 
 8926         GPRTemporary buffer(this);
 8927         GPRReg bufferGPR = buffer.gpr();
 8928 
 8929         m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
 8930 
 8931         // Refuse to handle bizarre lengths.
 8932         speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::Above, storageLengthGPR, TrustedImm32(largestPositiveInt32Length)));
 8933 
 8934         m_jit.move(storageLengthGPR, bufferGPR);
 8935         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8936         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
 8937 
 8938         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
 8939         getStorageBufferAddress(storageGPR, storageLengthGPR, ArrayStorage::vectorOffset(), bufferGPR);
 8940         m_jit.add32(TrustedImm32(elementCount), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
</pre>
<hr />
<pre>
 8946 
 8947         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 8948         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8949         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8950         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8951         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8952 
 8953         storageDone.link(&amp;m_jit);
 8954         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8955             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8956             JSValueOperand value(this, element);
 8957             JSValueRegs valueRegs = value.jsValueRegs();
 8958 
 8959             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 8960             value.use();
 8961         }
 8962 
 8963         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8964 
 8965         addSlowPathGenerator(
<span class="line-modified"> 8966             slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
 8967 
 8968         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8969         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8970 
 8971         base.use();
 8972         storage.use();
 8973 
 8974         fastPath.link(&amp;m_jit);
 8975         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8976         return;
 8977     }
 8978 
 8979     default:
 8980         RELEASE_ASSERT_NOT_REACHED();
 8981     }
 8982 }
 8983 
 8984 void SpeculativeJIT::compileNotifyWrite(Node* node)
 8985 {
 8986     WatchpointSet* set = node-&gt;watchpointSet();
 8987 
 8988     JITCompiler::Jump slowCase = m_jit.branch8(
 8989         JITCompiler::NotEqual,
 8990         JITCompiler::AbsoluteAddress(set-&gt;addressOfState()),
 8991         TrustedImm32(IsInvalidated));
 8992 
 8993     addSlowPathGenerator(
<span class="line-modified"> 8994         slowPathCall(slowCase, this, operationNotifyWrite, NeedToSpill, ExceptionCheckRequirement::CheckNotNeeded, NoResult, set));</span>
 8995 
 8996     noResult(node);
 8997 }
 8998 
 8999 void SpeculativeJIT::compileIsObject(Node* node)
 9000 {
 9001     JSValueOperand value(this, node-&gt;child1());
 9002     GPRTemporary result(this, Reuse, value, TagWord);
 9003 
 9004     JSValueRegs valueRegs = value.jsValueRegs();
 9005     GPRReg resultGPR = result.gpr();
 9006 
 9007     JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 9008 
 9009     m_jit.compare8(JITCompiler::AboveOrEqual,
 9010         JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()),
 9011         TrustedImm32(ObjectType),
 9012         resultGPR);
 9013     JITCompiler::Jump done = m_jit.jump();
 9014 
</pre>
<hr />
<pre>
 9221     }
 9222 }
 9223 
 9224 void SpeculativeJIT::compileAllocatePropertyStorage(Node* node)
 9225 {
 9226     ASSERT(!node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity());
 9227     ASSERT(initialOutOfLineCapacity == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity());
 9228 
 9229     size_t size = initialOutOfLineCapacity * sizeof(JSValue);
 9230 
 9231     Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists);
 9232 
 9233     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9234         SpeculateCellOperand base(this, node-&gt;child1());
 9235 
 9236         GPRReg baseGPR = base.gpr();
 9237 
 9238         flushRegisters();
 9239 
 9240         GPRFlushedCallResult result(this);
<span class="line-modified"> 9241         callOperation(operationAllocateComplexPropertyStorageWithInitialCapacity, result.gpr(), baseGPR);</span>
 9242         m_jit.exceptionCheck();
 9243 
 9244         storageResult(result.gpr(), node);
 9245         return;
 9246     }
 9247 
 9248     GPRTemporary scratch1(this);
 9249     GPRTemporary scratch2(this);
 9250     GPRTemporary scratch3(this);
 9251 
 9252     GPRReg scratchGPR1 = scratch1.gpr();
 9253     GPRReg scratchGPR2 = scratch2.gpr();
 9254     GPRReg scratchGPR3 = scratch3.gpr();
 9255 
 9256     JITCompiler::JumpList slowPath;
 9257     m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
 9258     m_jit.addPtr(JITCompiler::TrustedImm32(size + sizeof(IndexingHeader)), scratchGPR1);
 9259 
 9260     addSlowPathGenerator(
<span class="line-modified"> 9261         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorageWithInitialCapacity, scratchGPR1));</span>
 9262 
 9263     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(size); offset += sizeof(void*))
 9264         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9265 
 9266     storageResult(scratchGPR1, node);
 9267 }
 9268 
 9269 void SpeculativeJIT::compileReallocatePropertyStorage(Node* node)
 9270 {
 9271     size_t oldSize = node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity() * sizeof(JSValue);
 9272     size_t newSize = oldSize * outOfLineGrowthFactor;
 9273     ASSERT(newSize == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity() * sizeof(JSValue));
 9274 
 9275     Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(newSize, AllocatorForMode::AllocatorIfExists);
 9276 
 9277     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9278         SpeculateCellOperand base(this, node-&gt;child1());
 9279 
 9280         GPRReg baseGPR = base.gpr();
 9281 
 9282         flushRegisters();
 9283 
 9284         GPRFlushedCallResult result(this);
<span class="line-modified"> 9285         callOperation(operationAllocateComplexPropertyStorage, result.gpr(), baseGPR, newSize / sizeof(JSValue));</span>
 9286         m_jit.exceptionCheck();
 9287 
 9288         storageResult(result.gpr(), node);
 9289         return;
 9290     }
 9291 
 9292     StorageOperand oldStorage(this, node-&gt;child2());
 9293     GPRTemporary scratch1(this);
 9294     GPRTemporary scratch2(this);
 9295     GPRTemporary scratch3(this);
 9296 
 9297     GPRReg oldStorageGPR = oldStorage.gpr();
 9298     GPRReg scratchGPR1 = scratch1.gpr();
 9299     GPRReg scratchGPR2 = scratch2.gpr();
 9300     GPRReg scratchGPR3 = scratch3.gpr();
 9301 
 9302     JITCompiler::JumpList slowPath;
 9303     m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
 9304 
 9305     m_jit.addPtr(JITCompiler::TrustedImm32(newSize + sizeof(IndexingHeader)), scratchGPR1);
 9306 
 9307     addSlowPathGenerator(
<span class="line-modified"> 9308         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorage, scratchGPR1, newSize / sizeof(JSValue)));</span>
 9309 
 9310     for (ptrdiff_t offset = oldSize; offset &lt; static_cast&lt;ptrdiff_t&gt;(newSize); offset += sizeof(void*))
 9311         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9312 
 9313     // We have scratchGPR1 = new storage, scratchGPR2 = scratch
 9314     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(oldSize); offset += sizeof(void*)) {
 9315         m_jit.loadPtr(JITCompiler::Address(oldStorageGPR, -(offset + sizeof(JSValue) + sizeof(void*))), scratchGPR2);
 9316         m_jit.storePtr(scratchGPR2, JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9317     }
 9318 
 9319     storageResult(scratchGPR1, node);
 9320 }
 9321 
 9322 void SpeculativeJIT::compileNukeStructureAndSetButterfly(Node* node)
 9323 {
 9324     SpeculateCellOperand base(this, node-&gt;child1());
 9325     StorageOperand storage(this, node-&gt;child2());
 9326 
 9327     GPRReg baseGPR = base.gpr();
 9328     GPRReg storageGPR = storage.gpr();
</pre>
<hr />
<pre>
 9406                 break;
 9407             case SpecInt32Only:
 9408                 appendInt32(edge);
 9409                 break;
 9410             case SpecBoolean:
 9411                 appendBoolean(edge);
 9412                 break;
 9413             default:
 9414                 RELEASE_ASSERT_NOT_REACHED();
 9415                 break;
 9416             }
 9417         }
 9418         ++index;
 9419     });
 9420 
 9421     JSValueRegsTemporary result(this);
 9422     JSValueRegs resultRegs = result.regs();
 9423 
 9424     flushRegisters();
 9425 


 9426     auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);
 9427     unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
 9428     switch (argumentCountIncludingThis) {
 9429     case 1:
<span class="line-modified"> 9430         callOperation(reinterpret_cast&lt;J_JITOperation_EP&gt;(function.get()), extractResult(resultRegs), regs[0]);</span>
 9431         break;
 9432     case 2:
<span class="line-modified"> 9433         callOperation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(function.get()), extractResult(resultRegs), regs[0], regs[1]);</span>
 9434         break;
 9435     case 3:
<span class="line-modified"> 9436         callOperation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(function.get()), extractResult(resultRegs), regs[0], regs[1], regs[2]);</span>
 9437         break;
 9438     default:
 9439         RELEASE_ASSERT_NOT_REACHED();
 9440         break;
 9441     }
 9442 
 9443     m_jit.exceptionCheck();
 9444     jsValueResult(resultRegs, node);
 9445 }
 9446 
 9447 void SpeculativeJIT::compileCallDOMGetter(Node* node)
 9448 {
 9449     DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
 9450     if (!snippet) {
 9451         FunctionPtr&lt;OperationPtrTag&gt; getter = node-&gt;callDOMGetterData()-&gt;customAccessorGetter;
 9452         SpeculateCellOperand base(this, node-&gt;child1());
 9453         JSValueRegsTemporary result(this);
 9454 
 9455         JSValueRegs resultRegs = result.regs();
 9456         GPRReg baseGPR = base.gpr();
 9457 
 9458         flushRegisters();
<span class="line-modified"> 9459         m_jit.setupArguments&lt;J_JITOperation_EJI&gt;(CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;callDOMGetterData()-&gt;identifierNumber));</span>
 9460         m_jit.storePtr(GPRInfo::callFrameRegister, &amp;vm().topCallFrame);
 9461         m_jit.emitStoreCodeOrigin(m_currentNode-&gt;origin.semantic);
 9462         m_jit.appendCall(getter.retagged&lt;CFunctionPtrTag&gt;());
 9463         m_jit.setupResults(resultRegs);
 9464 
 9465         m_jit.exceptionCheck();
 9466         jsValueResult(resultRegs, node);
 9467         return;
 9468     }
 9469 
 9470     Vector&lt;GPRReg&gt; gpScratch;
 9471     Vector&lt;FPRReg&gt; fpScratch;
 9472     Vector&lt;SnippetParams::Value&gt; regs;
 9473 
 9474     JSValueRegsTemporary result(this);
 9475     regs.append(result.regs());
 9476 
 9477     Edge&amp; baseEdge = node-&gt;child1();
 9478     SpeculateCellOperand base(this, baseEdge);
 9479     regs.append(SnippetParams::Value(base.gpr(), m_state.forNode(baseEdge).value()));
</pre>
<hr />
<pre>
 9548     temporary.adopt(realTemporary);
 9549     return temporary.gpr();
 9550 }
 9551 
 9552 void SpeculativeJIT::compileToStringOrCallStringConstructorOrStringValueOf(Node* node)
 9553 {
 9554     ASSERT(node-&gt;op() != StringValueOf || node-&gt;child1().useKind() == UntypedUse);
 9555     switch (node-&gt;child1().useKind()) {
 9556     case NotCellUse: {
 9557         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 9558         JSValueRegs op1Regs = op1.jsValueRegs();
 9559 
 9560         GPRFlushedCallResult result(this);
 9561         GPRReg resultGPR = result.gpr();
 9562 
 9563         speculateNotCell(node-&gt;child1(), op1Regs);
 9564 
 9565         flushRegisters();
 9566 
 9567         if (node-&gt;op() == ToString)
<span class="line-modified"> 9568             callOperation(operationToString, resultGPR, op1Regs);</span>
 9569         else {
 9570             ASSERT(node-&gt;op() == CallStringConstructor);
<span class="line-modified"> 9571             callOperation(operationCallStringConstructor, resultGPR, op1Regs);</span>
 9572         }
 9573         m_jit.exceptionCheck();
 9574         cellResult(resultGPR, node);
 9575         return;
 9576     }
 9577 
 9578     case UntypedUse: {
 9579         JSValueOperand op1(this, node-&gt;child1());
 9580         JSValueRegs op1Regs = op1.jsValueRegs();
 9581         GPRReg op1PayloadGPR = op1Regs.payloadGPR();
 9582 
 9583         GPRFlushedCallResult result(this);
 9584         GPRReg resultGPR = result.gpr();
 9585 
 9586         flushRegisters();
 9587 
 9588         JITCompiler::Jump done;
 9589         if (node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 9590             JITCompiler::Jump slowPath1 = m_jit.branchIfNotCell(op1.jsValueRegs());
 9591             JITCompiler::Jump slowPath2 = m_jit.branchIfNotString(op1PayloadGPR);
 9592             m_jit.move(op1PayloadGPR, resultGPR);
 9593             done = m_jit.jump();
 9594             slowPath1.link(&amp;m_jit);
 9595             slowPath2.link(&amp;m_jit);
 9596         }
 9597         if (node-&gt;op() == ToString)
<span class="line-modified"> 9598             callOperation(operationToString, resultGPR, op1Regs);</span>
 9599         else if (node-&gt;op() == StringValueOf)
<span class="line-modified"> 9600             callOperation(operationStringValueOf, resultGPR, op1Regs);</span>
 9601         else {
 9602             ASSERT(node-&gt;op() == CallStringConstructor);
<span class="line-modified"> 9603             callOperation(operationCallStringConstructor, resultGPR, op1Regs);</span>
 9604         }
 9605         m_jit.exceptionCheck();
 9606         if (done.isSet())
 9607             done.link(&amp;m_jit);
 9608         cellResult(resultGPR, node);
 9609         return;
 9610     }
 9611 
 9612     case Int32Use:
 9613     case Int52RepUse:
 9614     case DoubleRepUse:
 9615         compileNumberToStringWithValidRadixConstant(node, 10);
 9616         return;
 9617 
 9618     default:
 9619         break;
 9620     }
 9621 
 9622     SpeculateCellOperand op1(this, node-&gt;child1());
 9623     GPRReg op1GPR = op1.gpr();
</pre>
<hr />
<pre>
 9654         cellResult(resultGPR, node);
 9655         break;
 9656     }
 9657 
 9658     case CellUse: {
 9659         GPRFlushedCallResult result(this);
 9660         GPRReg resultGPR = result.gpr();
 9661 
 9662         // We flush registers instead of silent spill/fill because in this mode we
 9663         // believe that most likely the input is not a string, and we need to take
 9664         // slow path.
 9665         flushRegisters();
 9666         JITCompiler::Jump done;
 9667         if (node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 9668             JITCompiler::Jump needCall = m_jit.branchIfNotString(op1GPR);
 9669             m_jit.move(op1GPR, resultGPR);
 9670             done = m_jit.jump();
 9671             needCall.link(&amp;m_jit);
 9672         }
 9673         if (node-&gt;op() == ToString)
<span class="line-modified"> 9674             callOperation(operationToStringOnCell, resultGPR, op1GPR);</span>
 9675         else {
 9676             ASSERT(node-&gt;op() == CallStringConstructor);
<span class="line-modified"> 9677             callOperation(operationCallStringConstructorOnCell, resultGPR, op1GPR);</span>
 9678         }
 9679         m_jit.exceptionCheck();
 9680         if (done.isSet())
 9681             done.link(&amp;m_jit);
 9682         cellResult(resultGPR, node);
 9683         break;
 9684     }
 9685 
 9686     default:
 9687         RELEASE_ASSERT_NOT_REACHED();
 9688     }
 9689 }
 9690 
 9691 void SpeculativeJIT::compileNumberToStringWithValidRadixConstant(Node* node)
 9692 {
 9693     compileNumberToStringWithValidRadixConstant(node, node-&gt;validRadixConstant());
 9694 }
 9695 
 9696 void SpeculativeJIT::compileNumberToStringWithValidRadixConstant(Node* node, int32_t radix)
 9697 {
 9698     auto callToString = [&amp;] (auto operation, GPRReg resultGPR, auto valueReg) {
 9699         flushRegisters();
<span class="line-modified"> 9700         callOperation(operation, resultGPR, valueReg, TrustedImm32(radix));</span>
 9701         m_jit.exceptionCheck();
 9702         cellResult(resultGPR, node);
 9703     };
 9704 
 9705     switch (node-&gt;child1().useKind()) {
 9706     case Int32Use: {
 9707         SpeculateStrictInt32Operand value(this, node-&gt;child1());
 9708         GPRFlushedCallResult result(this);
 9709         callToString(operationInt32ToStringWithValidRadix, result.gpr(), value.gpr());
 9710         break;
 9711     }
 9712 
 9713 #if USE(JSVALUE64)
 9714     case Int52RepUse: {
 9715         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 9716         GPRFlushedCallResult result(this);
 9717         callToString(operationInt52ToStringWithValidRadix, result.gpr(), value.gpr());
 9718         break;
 9719     }
 9720 #endif
</pre>
<hr />
<pre>
 9725         callToString(operationDoubleToStringWithValidRadix, result.gpr(), value.fpr());
 9726         break;
 9727     }
 9728 
 9729     default:
 9730         RELEASE_ASSERT_NOT_REACHED();
 9731     }
 9732 }
 9733 
 9734 void SpeculativeJIT::compileNumberToStringWithRadix(Node* node)
 9735 {
 9736     bool validRadixIsGuaranteed = false;
 9737     if (node-&gt;child2()-&gt;isInt32Constant()) {
 9738         int32_t radix = node-&gt;child2()-&gt;asInt32();
 9739         if (radix &gt;= 2 &amp;&amp; radix &lt;= 36)
 9740             validRadixIsGuaranteed = true;
 9741     }
 9742 
 9743     auto callToString = [&amp;] (auto operation, GPRReg resultGPR, auto valueReg, GPRReg radixGPR) {
 9744         flushRegisters();
<span class="line-modified"> 9745         callOperation(operation, resultGPR, valueReg, radixGPR);</span>
 9746         m_jit.exceptionCheck();
 9747         cellResult(resultGPR, node);
 9748     };
 9749 
 9750     switch (node-&gt;child1().useKind()) {
 9751     case Int32Use: {
 9752         SpeculateStrictInt32Operand value(this, node-&gt;child1());
 9753         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9754         GPRFlushedCallResult result(this);
 9755         callToString(validRadixIsGuaranteed ? operationInt32ToStringWithValidRadix : operationInt32ToString, result.gpr(), value.gpr(), radix.gpr());
 9756         break;
 9757     }
 9758 
 9759 #if USE(JSVALUE64)
 9760     case Int52RepUse: {
 9761         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 9762         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9763         GPRFlushedCallResult result(this);
 9764         callToString(validRadixIsGuaranteed ? operationInt52ToStringWithValidRadix : operationInt52ToString, result.gpr(), value.gpr(), radix.gpr());
 9765         break;
</pre>
<hr />
<pre>
 9800         slowPath);
 9801 
 9802     m_jit.storePtr(
 9803         TrustedImmPtr(StringObject::info()),
 9804         JITCompiler::Address(resultGPR, JSDestructibleObject::classInfoOffset()));
 9805 #if USE(JSVALUE64)
 9806     m_jit.store64(
 9807         operandGPR, JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset()));
 9808 #else
 9809     m_jit.store32(
 9810         TrustedImm32(JSValue::CellTag),
 9811         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 9812     m_jit.store32(
 9813         operandGPR,
 9814         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 9815 #endif
 9816 
 9817     m_jit.mutatorFence(vm());
 9818 
 9819     addSlowPathGenerator(slowPathCall(
<span class="line-modified"> 9820         slowPath, this, operationNewStringObject, resultGPR, operandGPR, node-&gt;structure()));</span>
 9821 
 9822     cellResult(resultGPR, node);
 9823 }
 9824 
 9825 void SpeculativeJIT::compileNewSymbol(Node* node)
 9826 {
 9827     if (!node-&gt;child1()) {
 9828         flushRegisters();
 9829         GPRFlushedCallResult result(this);
 9830         GPRReg resultGPR = result.gpr();
<span class="line-modified"> 9831         callOperation(operationNewSymbol, resultGPR);</span>
 9832         m_jit.exceptionCheck();
 9833         cellResult(resultGPR, node);
 9834         return;
 9835     }
 9836 
 9837 
 9838     ASSERT(node-&gt;child1().useKind() == KnownStringUse);
 9839     SpeculateCellOperand operand(this, node-&gt;child1());
 9840 
 9841     GPRReg stringGPR = operand.gpr();
 9842 
 9843     flushRegisters();
 9844     GPRFlushedCallResult result(this);
 9845     GPRReg resultGPR = result.gpr();
<span class="line-modified"> 9846     callOperation(operationNewSymbolWithDescription, resultGPR, stringGPR);</span>
 9847     m_jit.exceptionCheck();
 9848     cellResult(resultGPR, node);
 9849 }
 9850 
 9851 void SpeculativeJIT::compileNewTypedArrayWithSize(Node* node)
 9852 {
 9853     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 9854     auto typedArrayType = node-&gt;typedArrayType();
 9855     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType));
 9856     RELEASE_ASSERT(structure.get());
 9857 
 9858     SpeculateInt32Operand size(this, node-&gt;child1());
 9859     GPRReg sizeGPR = size.gpr();
 9860 
 9861     GPRTemporary result(this);
 9862     GPRTemporary storage(this);
 9863     GPRTemporary scratch(this);
 9864     GPRTemporary scratch2(this);
 9865     GPRReg resultGPR = result.gpr();
 9866     GPRReg storageGPR = storage.gpr();
</pre>
<hr />
<pre>
 9893             if (elementSize(typedArrayType) &gt; 1)
 9894                 m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType)), scratchGPR);
 9895             m_jit.add32(TrustedImm32(3), scratchGPR);
 9896             m_jit.urshift32(TrustedImm32(2), scratchGPR);
 9897         }
 9898     }
 9899     MacroAssembler::Label loop = m_jit.label();
 9900     m_jit.sub32(TrustedImm32(1), scratchGPR);
 9901     m_jit.store32(
 9902         TrustedImm32(0),
 9903         MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesFour));
 9904     m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
 9905     done.link(&amp;m_jit);
 9906 #if CPU(ARM64E)
 9907     // sizeGPR is still boxed as a number and there is no 32-bit variant of the PAC instructions.
 9908     m_jit.zeroExtend32ToPtr(sizeGPR, scratchGPR);
 9909     m_jit.tagArrayPtr(scratchGPR, storageGPR);
 9910 #endif
 9911 
 9912     auto butterfly = TrustedImmPtr(nullptr);
<span class="line-modified"> 9913     emitAllocateJSObject&lt;JSArrayBufferView&gt;(</span>
<span class="line-modified"> 9914         resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2,</span>
<span class="line-modified"> 9915         slowCases);</span>











 9916 
 9917     m_jit.storePtr(
 9918         storageGPR,
 9919         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfVector()));
 9920     m_jit.store32(
 9921         sizeGPR,
 9922         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfLength()));
 9923     m_jit.store32(
 9924         TrustedImm32(FastTypedArray),
 9925         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfMode()));
 9926 
 9927     m_jit.mutatorFence(vm());
 9928 
 9929     addSlowPathGenerator(slowPathCall(
 9930         slowCases, this, operationNewTypedArrayWithSizeForType(typedArrayType),
<span class="line-modified"> 9931         resultGPR, structure, sizeGPR, storageGPR));</span>
 9932 
 9933     cellResult(resultGPR, node);
 9934 }
 9935 
 9936 void SpeculativeJIT::compileNewRegexp(Node* node)
 9937 {
 9938     RegExp* regexp = node-&gt;castOperand&lt;RegExp*&gt;();
 9939 
 9940     GPRTemporary result(this);
 9941     GPRTemporary scratch1(this);
 9942     GPRTemporary scratch2(this);
 9943     JSValueOperand lastIndex(this, node-&gt;child1());
 9944 
 9945     GPRReg resultGPR = result.gpr();
 9946     GPRReg scratch1GPR = scratch1.gpr();
 9947     GPRReg scratch2GPR = scratch2.gpr();
 9948     JSValueRegs lastIndexRegs = lastIndex.jsValueRegs();
 9949 
 9950     JITCompiler::JumpList slowPath;
 9951 
 9952     auto structure = m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
 9953     auto butterfly = TrustedImmPtr(nullptr);
 9954     emitAllocateJSObject&lt;RegExpObject&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath);
 9955 
 9956     m_jit.storePtr(
 9957         TrustedImmPtr(node-&gt;cellOperand()),
 9958         CCallHelpers::Address(resultGPR, RegExpObject::offsetOfRegExpAndLastIndexIsNotWritableFlag()));
 9959     m_jit.storeValue(lastIndexRegs, CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndex()));
 9960     m_jit.mutatorFence(vm());
 9961 
<span class="line-modified"> 9962     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewRegexpWithLastIndex, resultGPR, regexp, lastIndexRegs));</span>
 9963 
 9964     cellResult(resultGPR, node);
 9965 }
 9966 
 9967 void SpeculativeJIT::speculateCellTypeWithoutTypeFiltering(
 9968     Edge edge, GPRReg cellGPR, JSType jsType)
 9969 {
 9970     speculationCheck(
 9971         BadType, JSValueSource::unboxedCell(cellGPR), edge,
 9972         m_jit.branchIfNotType(cellGPR, jsType));
 9973 }
 9974 
 9975 void SpeculativeJIT::speculateCellType(
 9976     Edge edge, GPRReg cellGPR, SpeculatedType specType, JSType jsType)
 9977 {
 9978     DFG_TYPE_CHECK(
 9979         JSValueSource::unboxedCell(cellGPR), edge, specType,
 9980         m_jit.branchIfNotType(cellGPR, jsType));
 9981 }
 9982 
</pre>
<hr />
<pre>
10166         return;
10167 
10168     SpeculateCellOperand operand(this, edge);
10169     speculateProxyObject(edge, operand.gpr());
10170 }
10171 
10172 void SpeculativeJIT::speculateDerivedArray(Edge edge, GPRReg cell)
10173 {
10174     speculateCellType(edge, cell, SpecDerivedArray, DerivedArrayType);
10175 }
10176 
10177 void SpeculativeJIT::speculateDerivedArray(Edge edge)
10178 {
10179     if (!needsTypeCheck(edge, SpecDerivedArray))
10180         return;
10181 
10182     SpeculateCellOperand operand(this, edge);
10183     speculateDerivedArray(edge, operand.gpr());
10184 }
10185 




























10186 void SpeculativeJIT::speculateMapObject(Edge edge, GPRReg cell)
10187 {
10188     speculateCellType(edge, cell, SpecMapObject, JSMapType);
10189 }
10190 
10191 void SpeculativeJIT::speculateMapObject(Edge edge)
10192 {
10193     if (!needsTypeCheck(edge, SpecMapObject))
10194         return;
10195 
10196     SpeculateCellOperand operand(this, edge);
10197     speculateMapObject(edge, operand.gpr());
10198 }
10199 
10200 void SpeculativeJIT::speculateSetObject(Edge edge, GPRReg cell)
10201 {
10202     speculateCellType(edge, cell, SpecSetObject, JSSetType);
10203 }
10204 
10205 void SpeculativeJIT::speculateSetObject(Edge edge)
</pre>
<hr />
<pre>
10480 
10481     GPRTemporary temp(this);
10482     GPRReg tempGPR = temp.gpr();
10483     speculateOther(edge, regs, tempGPR);
10484 }
10485 
10486 void SpeculativeJIT::speculateOther(Edge edge)
10487 {
10488     if (!needsTypeCheck(edge, SpecOther))
10489         return;
10490 
10491     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10492     speculateOther(edge, operand.jsValueRegs());
10493 }
10494 
10495 void SpeculativeJIT::speculateMisc(Edge edge, JSValueRegs regs)
10496 {
10497 #if USE(JSVALUE64)
10498     DFG_TYPE_CHECK(
10499         regs, edge, SpecMisc,
<span class="line-modified">10500         m_jit.branch64(MacroAssembler::Above, regs.gpr(), MacroAssembler::TrustedImm64(TagBitTypeOther | TagBitBool | TagBitUndefined)));</span>
10501 #else
10502     IGNORE_WARNINGS_BEGIN(&quot;enum-compare&quot;)
10503     static_assert(JSValue::Int32Tag &gt;= JSValue::UndefinedTag, &quot;Int32Tag is included in &gt;= JSValue::UndefinedTag range.&quot;);
10504     IGNORE_WARNINGS_END
10505     DFG_TYPE_CHECK(
10506         regs, edge, ~SpecInt32Only,
10507         m_jit.branchIfInt32(regs.tagGPR()));
10508     DFG_TYPE_CHECK(
10509         regs, edge, SpecMisc,
10510         m_jit.branch32(MacroAssembler::Below, regs.tagGPR(), MacroAssembler::TrustedImm32(JSValue::UndefinedTag)));
10511 #endif
10512 }
10513 
10514 void SpeculativeJIT::speculateMisc(Edge edge)
10515 {
10516     if (!needsTypeCheck(edge, SpecMisc))
10517         return;
10518 
10519     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10520     speculateMisc(edge, operand.jsValueRegs());
</pre>
<hr />
<pre>
10562         speculateCell(edge);
10563         break;
10564     case CellOrOtherUse:
10565         speculateCellOrOther(edge);
10566         break;
10567     case ObjectUse:
10568         speculateObject(edge);
10569         break;
10570     case FunctionUse:
10571         speculateFunction(edge);
10572         break;
10573     case ArrayUse:
10574         speculateArray(edge);
10575         break;
10576     case FinalObjectUse:
10577         speculateFinalObject(edge);
10578         break;
10579     case RegExpObjectUse:
10580         speculateRegExpObject(edge);
10581         break;



10582     case ProxyObjectUse:
10583         speculateProxyObject(edge);
10584         break;
10585     case DerivedArrayUse:
10586         speculateDerivedArray(edge);
10587         break;



10588     case MapObjectUse:
10589         speculateMapObject(edge);
10590         break;
10591     case SetObjectUse:
10592         speculateSetObject(edge);
10593         break;
10594     case WeakMapObjectUse:
10595         speculateWeakMapObject(edge);
10596         break;
10597     case WeakSetObjectUse:
10598         speculateWeakSetObject(edge);
10599         break;
10600     case DataViewObjectUse:
10601         speculateDataViewObject(edge);
10602         break;
10603     case ObjectOrOtherUse:
10604         speculateObjectOrOther(edge);
10605         break;
10606     case StringIdentUse:
10607         speculateStringIdent(edge);
</pre>
<hr />
<pre>
10668         SpeculateInt32Operand value(this, node-&gt;child1());
10669         GPRTemporary temp(this);
10670         emitSwitchIntJump(data, value.gpr(), temp.gpr());
10671         noResult(node);
10672         break;
10673     }
10674 
10675     case UntypedUse: {
10676         JSValueOperand value(this, node-&gt;child1());
10677         GPRTemporary temp(this);
10678         JSValueRegs valueRegs = value.jsValueRegs();
10679         GPRReg scratch = temp.gpr();
10680 
10681         value.use();
10682 
10683         auto notInt32 = m_jit.branchIfNotInt32(valueRegs);
10684         emitSwitchIntJump(data, valueRegs.payloadGPR(), scratch);
10685         notInt32.link(&amp;m_jit);
10686         addBranch(m_jit.branchIfNotNumber(valueRegs, scratch), data-&gt;fallThrough.block);
10687         silentSpillAllRegisters(scratch);
<span class="line-modified">10688         callOperation(operationFindSwitchImmTargetForDouble, scratch, valueRegs, data-&gt;switchTableIndex);</span>
10689         silentFillAllRegisters();
10690 
10691         m_jit.farJump(scratch, JSSwitchPtrTag);
10692         noResult(node, UseChildrenCalledExplicitly);
10693         break;
10694     }
10695 
10696     default:
10697         RELEASE_ASSERT_NOT_REACHED();
10698         break;
10699     }
10700 }
10701 
<span class="line-modified">10702 void SpeculativeJIT::emitSwitchCharStringJump(</span>
<span class="line-removed">10703     SwitchData* data, GPRReg value, GPRReg scratch)</span>
10704 {
10705     m_jit.loadPtr(MacroAssembler::Address(value, JSString::offsetOfValue()), scratch);
10706     auto isRope = m_jit.branchIfRopeStringImpl(scratch);

10707 
10708     addBranch(
10709         m_jit.branch32(
10710             MacroAssembler::NotEqual,
10711             MacroAssembler::Address(scratch, StringImpl::lengthMemoryOffset()),
10712             TrustedImm32(1)),
10713         data-&gt;fallThrough.block);
10714 
<span class="line-removed">10715     addSlowPathGenerator(slowPathCall(isRope, this, operationResolveRope, scratch, value));</span>
<span class="line-removed">10716 </span>
10717     m_jit.loadPtr(MacroAssembler::Address(scratch, StringImpl::dataOffset()), value);
10718 
10719     JITCompiler::Jump is8Bit = m_jit.branchTest32(
10720         MacroAssembler::NonZero,
10721         MacroAssembler::Address(scratch, StringImpl::flagsOffset()),
10722         TrustedImm32(StringImpl::flagIs8Bit()));
10723 
10724     m_jit.load16(MacroAssembler::Address(value), scratch);
10725 
10726     JITCompiler::Jump ready = m_jit.jump();
10727 
10728     is8Bit.link(&amp;m_jit);
10729     m_jit.load8(MacroAssembler::Address(value), scratch);
10730 
10731     ready.link(&amp;m_jit);
10732     emitSwitchIntJump(data, scratch, value);
10733 }
10734 
10735 void SpeculativeJIT::emitSwitchChar(Node* node, SwitchData* data)
10736 {
10737     switch (node-&gt;child1().useKind()) {
10738     case StringUse: {
10739         SpeculateCellOperand op1(this, node-&gt;child1());
10740         GPRTemporary temp(this);
10741 
10742         GPRReg op1GPR = op1.gpr();
10743         GPRReg tempGPR = temp.gpr();
10744 
10745         op1.use();
10746 
10747         speculateString(node-&gt;child1(), op1GPR);
<span class="line-modified">10748         emitSwitchCharStringJump(data, op1GPR, tempGPR);</span>
10749         noResult(node, UseChildrenCalledExplicitly);
10750         break;
10751     }
10752 
10753     case UntypedUse: {
10754         JSValueOperand op1(this, node-&gt;child1());
10755         GPRTemporary temp(this);
10756 
10757         JSValueRegs op1Regs = op1.jsValueRegs();
10758         GPRReg tempGPR = temp.gpr();
10759 
10760         op1.use();
10761 
10762         addBranch(m_jit.branchIfNotCell(op1Regs), data-&gt;fallThrough.block);
10763 
10764         addBranch(m_jit.branchIfNotString(op1Regs.payloadGPR()), data-&gt;fallThrough.block);
10765 
<span class="line-modified">10766         emitSwitchCharStringJump(data, op1Regs.payloadGPR(), tempGPR);</span>
10767         noResult(node, UseChildrenCalledExplicitly);
10768         break;
10769     }
10770 
10771     default:
10772         RELEASE_ASSERT_NOT_REACHED();
10773         break;
10774     }
10775 }
10776 
10777 namespace {
10778 
10779 struct CharacterCase {
10780     bool operator&lt;(const CharacterCase&amp; other) const
10781     {
10782         return character &lt; other.character;
10783     }
10784 
10785     LChar character;
10786     unsigned begin;
10787     unsigned end;
10788 };
10789 
10790 } // anonymous namespace
10791 
10792 void SpeculativeJIT::emitBinarySwitchStringRecurse(
10793     SwitchData* data, const Vector&lt;SpeculativeJIT::StringSwitchCase&gt;&amp; cases,
10794     unsigned numChecked, unsigned begin, unsigned end, GPRReg buffer, GPRReg length,
10795     GPRReg temp, unsigned alreadyCheckedLength, bool checkedExactLength)
10796 {
<span class="line-modified">10797     static const bool verbose = false;</span>
10798 
10799     if (verbose) {
10800         dataLog(&quot;We&#39;re down to the following cases, alreadyCheckedLength = &quot;, alreadyCheckedLength, &quot;:\n&quot;);
10801         for (unsigned i = begin; i &lt; end; ++i) {
10802             dataLog(&quot;    &quot;, cases[i].string, &quot;\n&quot;);
10803         }
10804     }
10805 
10806     if (begin == end) {
10807         jump(data-&gt;fallThrough.block, ForceJump);
10808         return;
10809     }
10810 
10811     unsigned minLength = cases[begin].string-&gt;length();
10812     unsigned commonChars = minLength;
10813     bool allLengthsEqual = true;
10814     for (unsigned i = begin + 1; i &lt; end; ++i) {
10815         unsigned myCommonChars = numChecked;
10816         for (unsigned j = numChecked;
10817             j &lt; std::min(cases[begin].string-&gt;length(), cases[i].string-&gt;length());
</pre>
<hr />
<pre>
10838 
10839     if (verbose)
10840         dataLog(&quot;length = &quot;, minLength, &quot;, commonChars = &quot;, commonChars, &quot;, allLengthsEqual = &quot;, allLengthsEqual, &quot;\n&quot;);
10841 
10842     if (!allLengthsEqual &amp;&amp; alreadyCheckedLength &lt; minLength)
10843         branch32(MacroAssembler::Below, length, Imm32(minLength), data-&gt;fallThrough.block);
10844     if (allLengthsEqual &amp;&amp; (alreadyCheckedLength &lt; minLength || !checkedExactLength))
10845         branch32(MacroAssembler::NotEqual, length, Imm32(minLength), data-&gt;fallThrough.block);
10846 
10847     for (unsigned i = numChecked; i &lt; commonChars; ++i) {
10848         branch8(
10849             MacroAssembler::NotEqual, MacroAssembler::Address(buffer, i),
10850             TrustedImm32(cases[begin].string-&gt;at(i)), data-&gt;fallThrough.block);
10851     }
10852 
10853     if (minLength == commonChars) {
10854         // This is the case where one of the cases is a prefix of all of the other cases.
10855         // We&#39;ve already checked that the input string is a prefix of all of the cases,
10856         // so we just check length to jump to that case.
10857 
<span class="line-modified">10858         if (!ASSERT_DISABLED) {</span>
10859             ASSERT(cases[begin].string-&gt;length() == commonChars);
10860             for (unsigned i = begin + 1; i &lt; end; ++i)
10861                 ASSERT(cases[i].string-&gt;length() &gt; commonChars);
10862         }
10863 
10864         if (allLengthsEqual) {
10865             RELEASE_ASSERT(end == begin + 1);
10866             jump(cases[begin].target, ForceJump);
10867             return;
10868         }
10869 
10870         branch32(MacroAssembler::Equal, length, Imm32(commonChars), cases[begin].target);
10871 
10872         // We&#39;ve checked if the length is &gt;= minLength, and then we checked if the
10873         // length is == commonChars. We get to this point if it is &gt;= minLength but not
10874         // == commonChars. Hence we know that it now must be &gt; minLength, i.e., that
10875         // it&#39;s &gt;= minLength + 1.
10876         emitBinarySwitchStringRecurse(
10877             data, cases, commonChars, begin + 1, end, buffer, length, temp, minLength + 1, false);
10878         return;
</pre>
<hr />
<pre>
10903         } else
10904             currentCase.end = i + 1;
10905     }
10906     characterCases.append(currentCase);
10907 
10908     Vector&lt;int64_t&gt; characterCaseValues;
10909     for (unsigned i = 0; i &lt; characterCases.size(); ++i)
10910         characterCaseValues.append(characterCases[i].character);
10911 
10912     BinarySwitch binarySwitch(temp, characterCaseValues, BinarySwitch::Int32);
10913     while (binarySwitch.advance(m_jit)) {
10914         const CharacterCase&amp; myCase = characterCases[binarySwitch.caseIndex()];
10915         emitBinarySwitchStringRecurse(
10916             data, cases, commonChars + 1, myCase.begin, myCase.end, buffer, length,
10917             temp, minLength, allLengthsEqual);
10918     }
10919 
10920     addBranch(binarySwitch.fallThrough(), data-&gt;fallThrough.block);
10921 }
10922 
<span class="line-modified">10923 void SpeculativeJIT::emitSwitchStringOnString(SwitchData* data, GPRReg string)</span>
10924 {
10925     data-&gt;didUseJumpTable = true;
10926 
10927     bool canDoBinarySwitch = true;
10928     unsigned totalLength = 0;
10929 
10930     for (unsigned i = data-&gt;cases.size(); i--;) {
10931         StringImpl* string = data-&gt;cases[i].value.stringImpl();
10932         if (!string-&gt;is8Bit()) {
10933             canDoBinarySwitch = false;
10934             break;
10935         }
10936         if (string-&gt;length() &gt; Options::maximumBinaryStringSwitchCaseLength()) {
10937             canDoBinarySwitch = false;
10938             break;
10939         }
10940         totalLength += string-&gt;length();
10941     }
10942 
10943     if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
10944         flushRegisters();
10945         callOperation(
<span class="line-modified">10946             operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);</span>
10947         m_jit.exceptionCheck();
10948         m_jit.farJump(string, JSSwitchPtrTag);
10949         return;
10950     }
10951 
10952     GPRTemporary length(this);
10953     GPRTemporary temp(this);
10954 
10955     GPRReg lengthGPR = length.gpr();
10956     GPRReg tempGPR = temp.gpr();
10957 
10958     MacroAssembler::JumpList slowCases;
10959     m_jit.loadPtr(MacroAssembler::Address(string, JSString::offsetOfValue()), tempGPR);
10960     slowCases.append(m_jit.branchIfRopeStringImpl(tempGPR));
10961     m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
10962 
10963     slowCases.append(m_jit.branchTest32(
10964         MacroAssembler::Zero,
10965         MacroAssembler::Address(tempGPR, StringImpl::flagsOffset()),
10966         TrustedImm32(StringImpl::flagIs8Bit())));
10967 
10968     m_jit.loadPtr(MacroAssembler::Address(tempGPR, StringImpl::dataOffset()), string);
10969 
10970     Vector&lt;StringSwitchCase&gt; cases;
10971     for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
10972         cases.append(
10973             StringSwitchCase(data-&gt;cases[i].value.stringImpl(), data-&gt;cases[i].target.block));
10974     }
10975 
10976     std::sort(cases.begin(), cases.end());
10977 
10978     emitBinarySwitchStringRecurse(
10979         data, cases, 0, 0, cases.size(), string, lengthGPR, tempGPR, 0, false);
10980 
10981     slowCases.link(&amp;m_jit);
10982     silentSpillAllRegisters(string);
<span class="line-modified">10983     callOperation(operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);</span>
10984     silentFillAllRegisters();
10985     m_jit.exceptionCheck();
10986     m_jit.farJump(string, JSSwitchPtrTag);
10987 }
10988 
10989 void SpeculativeJIT::emitSwitchString(Node* node, SwitchData* data)
10990 {
10991     switch (node-&gt;child1().useKind()) {
10992     case StringIdentUse: {
10993         SpeculateCellOperand op1(this, node-&gt;child1());
10994         GPRTemporary temp(this);
10995 
10996         GPRReg op1GPR = op1.gpr();
10997         GPRReg tempGPR = temp.gpr();
10998 
10999         speculateString(node-&gt;child1(), op1GPR);
11000         speculateStringIdentAndLoadStorage(node-&gt;child1(), op1GPR, tempGPR);
11001 
11002         Vector&lt;int64_t&gt; identifierCaseValues;
11003         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
</pre>
<hr />
<pre>
11005                 static_cast&lt;int64_t&gt;(bitwise_cast&lt;intptr_t&gt;(data-&gt;cases[i].value.stringImpl())));
11006         }
11007 
11008         BinarySwitch binarySwitch(tempGPR, identifierCaseValues, BinarySwitch::IntPtr);
11009         while (binarySwitch.advance(m_jit))
11010             jump(data-&gt;cases[binarySwitch.caseIndex()].target.block, ForceJump);
11011         addBranch(binarySwitch.fallThrough(), data-&gt;fallThrough.block);
11012 
11013         noResult(node);
11014         break;
11015     }
11016 
11017     case StringUse: {
11018         SpeculateCellOperand op1(this, node-&gt;child1());
11019 
11020         GPRReg op1GPR = op1.gpr();
11021 
11022         op1.use();
11023 
11024         speculateString(node-&gt;child1(), op1GPR);
<span class="line-modified">11025         emitSwitchStringOnString(data, op1GPR);</span>
11026         noResult(node, UseChildrenCalledExplicitly);
11027         break;
11028     }
11029 
11030     case UntypedUse: {
11031         JSValueOperand op1(this, node-&gt;child1());
11032 
11033         JSValueRegs op1Regs = op1.jsValueRegs();
11034 
11035         op1.use();
11036 
11037         addBranch(m_jit.branchIfNotCell(op1Regs), data-&gt;fallThrough.block);
11038 
11039         addBranch(m_jit.branchIfNotString(op1Regs.payloadGPR()), data-&gt;fallThrough.block);
11040 
<span class="line-modified">11041         emitSwitchStringOnString(data, op1Regs.payloadGPR());</span>
11042         noResult(node, UseChildrenCalledExplicitly);
11043         break;
11044     }
11045 
11046     default:
11047         RELEASE_ASSERT_NOT_REACHED();
11048         break;
11049     }
11050 }
11051 
11052 void SpeculativeJIT::emitSwitch(Node* node)
11053 {
11054     SwitchData* data = node-&gt;switchData();
11055     switch (data-&gt;kind) {
11056     case SwitchImm: {
11057         emitSwitchImm(node, data);
11058         return;
11059     }
11060     case SwitchChar: {
11061         emitSwitchChar(node, data);
</pre>
<hr />
<pre>
11092 
11093     SpeculateCellOperand base(this, node-&gt;child1());
11094     GPRTemporary scratch1(this);
11095 
11096     GPRReg baseGPR = base.gpr();
11097     GPRReg scratch1GPR = scratch1.gpr();
11098 
11099     JITCompiler::JumpList ok;
11100 
11101     if (isFenced) {
11102         ok.append(m_jit.barrierBranch(vm(), baseGPR, scratch1GPR));
11103 
11104         JITCompiler::Jump noFence = m_jit.jumpIfMutatorFenceNotNeeded(vm());
11105         m_jit.memoryFence();
11106         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
11107         noFence.link(&amp;m_jit);
11108     } else
11109         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
11110 
11111     silentSpillAllRegisters(InvalidGPRReg);
<span class="line-modified">11112     callOperation(operationWriteBarrierSlowPath, baseGPR);</span>
11113     silentFillAllRegisters();
11114 
11115     ok.link(&amp;m_jit);
11116 
11117     noResult(node);
11118 }
11119 
11120 void SpeculativeJIT::compilePutAccessorById(Node* node)
11121 {
11122     SpeculateCellOperand base(this, node-&gt;child1());
11123     SpeculateCellOperand accessor(this, node-&gt;child2());
11124 
11125     GPRReg baseGPR = base.gpr();
11126     GPRReg accessorGPR = accessor.gpr();
11127 
11128     flushRegisters();
<span class="line-modified">11129     callOperation(node-&gt;op() == PutGetterById ? operationPutGetterById : operationPutSetterById, NoResult, baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), accessorGPR);</span>
11130     m_jit.exceptionCheck();
11131 
11132     noResult(node);
11133 }
11134 
11135 void SpeculativeJIT::compilePutGetterSetterById(Node* node)
11136 {
11137     SpeculateCellOperand base(this, node-&gt;child1());
11138     JSValueOperand getter(this, node-&gt;child2());
11139     JSValueOperand setter(this, node-&gt;child3());
11140 
11141 #if USE(JSVALUE64)
11142     GPRReg baseGPR = base.gpr();
11143     GPRReg getterGPR = getter.gpr();
11144     GPRReg setterGPR = setter.gpr();
11145 
11146     flushRegisters();
<span class="line-modified">11147     callOperation(operationPutGetterSetter, NoResult, baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterGPR, setterGPR);</span>
11148 #else
11149     // These JSValues may be JSUndefined OR JSFunction*.
11150     // At that time,
11151     // 1. If the JSValue is JSUndefined, its payload becomes nullptr.
11152     // 2. If the JSValue is JSFunction*, its payload becomes JSFunction*.
11153     // So extract payload and pass it to operationPutGetterSetter. This hack is used as the same way in baseline JIT.
11154     GPRReg baseGPR = base.gpr();
11155     JSValueRegs getterRegs = getter.jsValueRegs();
11156     JSValueRegs setterRegs = setter.jsValueRegs();
11157 
11158     flushRegisters();
<span class="line-modified">11159     callOperation(operationPutGetterSetter, NoResult, baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterRegs.payloadGPR(), setterRegs.payloadGPR());</span>
11160 #endif
11161     m_jit.exceptionCheck();
11162 
11163     noResult(node);
11164 }
11165 
11166 void SpeculativeJIT::compileResolveScope(Node* node)
11167 {
11168     SpeculateCellOperand scope(this, node-&gt;child1());
11169     GPRReg scopeGPR = scope.gpr();
11170     GPRFlushedCallResult result(this);
11171     GPRReg resultGPR = result.gpr();
11172     flushRegisters();
<span class="line-modified">11173     callOperation(operationResolveScope, resultGPR, scopeGPR, identifierUID(node-&gt;identifierNumber()));</span>
11174     m_jit.exceptionCheck();
11175     cellResult(resultGPR, node);
11176 }
11177 
11178 void SpeculativeJIT::compileResolveScopeForHoistingFuncDeclInEval(Node* node)
11179 {
11180     SpeculateCellOperand scope(this, node-&gt;child1());
11181     GPRReg scopeGPR = scope.gpr();
11182     flushRegisters();
11183     JSValueRegsFlushedCallResult result(this);
11184     JSValueRegs resultRegs = result.regs();
<span class="line-modified">11185     callOperation(operationResolveScopeForHoistingFuncDeclInEval, resultRegs, scopeGPR, identifierUID(node-&gt;identifierNumber()));</span>
11186     m_jit.exceptionCheck();
11187     jsValueResult(resultRegs, node);
11188 }
11189 
11190 void SpeculativeJIT::compileGetGlobalVariable(Node* node)
11191 {
11192     JSValueRegsTemporary result(this);
11193     JSValueRegs resultRegs = result.regs();
11194     m_jit.loadValue(node-&gt;variablePointer(), resultRegs);
11195     jsValueResult(resultRegs, node);
11196 }
11197 
11198 void SpeculativeJIT::compilePutGlobalVariable(Node* node)
11199 {
11200     JSValueOperand value(this, node-&gt;child2());
11201     JSValueRegs valueRegs = value.jsValueRegs();
11202     m_jit.storeValue(valueRegs, node-&gt;variablePointer());
11203     noResult(node);
11204 }
11205 
11206 void SpeculativeJIT::compileGetDynamicVar(Node* node)
11207 {
11208     SpeculateCellOperand scope(this, node-&gt;child1());
11209     GPRReg scopeGPR = scope.gpr();
11210     flushRegisters();
11211     JSValueRegsFlushedCallResult result(this);
11212     JSValueRegs resultRegs = result.regs();
<span class="line-modified">11213     callOperation(operationGetDynamicVar, resultRegs, scopeGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
11214     m_jit.exceptionCheck();
11215     jsValueResult(resultRegs, node);
11216 }
11217 
11218 void SpeculativeJIT::compilePutDynamicVar(Node* node)
11219 {
11220     SpeculateCellOperand scope(this, node-&gt;child1());
11221     JSValueOperand value(this, node-&gt;child2());
11222 
11223     GPRReg scopeGPR = scope.gpr();
11224     JSValueRegs valueRegs = value.jsValueRegs();
11225 
11226     flushRegisters();
<span class="line-modified">11227     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict, NoResult, scopeGPR, valueRegs, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
11228     m_jit.exceptionCheck();
11229     noResult(node);
11230 }
11231 
11232 void SpeculativeJIT::compileGetClosureVar(Node* node)
11233 {
11234     SpeculateCellOperand base(this, node-&gt;child1());
11235     JSValueRegsTemporary result(this);
11236 
11237     GPRReg baseGPR = base.gpr();
11238     JSValueRegs resultRegs = result.regs();
11239 
11240     m_jit.loadValue(JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())), resultRegs);
11241     jsValueResult(resultRegs, node);
11242 }
11243 
11244 void SpeculativeJIT::compilePutClosureVar(Node* node)
11245 {
11246     SpeculateCellOperand base(this, node-&gt;child1());
11247     JSValueOperand value(this, node-&gt;child2());
11248 
11249     GPRReg baseGPR = base.gpr();
11250     JSValueRegs valueRegs = value.jsValueRegs();
11251 
11252     m_jit.storeValue(valueRegs, JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())));
11253     noResult(node);
11254 }
11255 
























11256 void SpeculativeJIT::compilePutAccessorByVal(Node* node)
11257 {
11258     SpeculateCellOperand base(this, node-&gt;child1());
11259     JSValueOperand subscript(this, node-&gt;child2());
11260     SpeculateCellOperand accessor(this, node-&gt;child3());
11261 
11262     auto operation = node-&gt;op() == PutGetterByVal ? operationPutGetterByVal : operationPutSetterByVal;
11263 
11264     GPRReg baseGPR = base.gpr();
11265     JSValueRegs subscriptRegs = subscript.jsValueRegs();
11266     GPRReg accessorGPR = accessor.gpr();
11267 
11268     flushRegisters();
<span class="line-modified">11269     callOperation(operation, NoResult, baseGPR, subscriptRegs, node-&gt;accessorAttributes(), accessorGPR);</span>
11270     m_jit.exceptionCheck();
11271 
11272     noResult(node);
11273 }
11274 
11275 void SpeculativeJIT::compileGetRegExpObjectLastIndex(Node* node)
11276 {
11277     SpeculateCellOperand regExp(this, node-&gt;child1());
11278     JSValueRegsTemporary result(this);
11279     GPRReg regExpGPR = regExp.gpr();
11280     JSValueRegs resultRegs = result.regs();
11281     speculateRegExpObject(node-&gt;child1(), regExpGPR);
11282     m_jit.loadValue(JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()), resultRegs);
11283     jsValueResult(resultRegs, node);
11284 }
11285 
11286 void SpeculativeJIT::compileSetRegExpObjectLastIndex(Node* node)
11287 {
11288     SpeculateCellOperand regExp(this, node-&gt;child1());
11289     JSValueOperand value(this, node-&gt;child2());
</pre>
<hr />
<pre>
11426 {
11427     ASSERT(node-&gt;op() == StringReplace || node-&gt;op() == StringReplaceRegExp);
11428     bool sample = false;
11429     if (sample)
11430         m_jit.incrementSuperSamplerCount();
11431 
11432     if (node-&gt;child1().useKind() == StringUse
11433         &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
11434         &amp;&amp; node-&gt;child3().useKind() == StringUse) {
11435         if (JSString* replace = node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
11436             if (!replace-&gt;length()) {
11437                 SpeculateCellOperand string(this, node-&gt;child1());
11438                 SpeculateCellOperand regExp(this, node-&gt;child2());
11439                 GPRReg stringGPR = string.gpr();
11440                 GPRReg regExpGPR = regExp.gpr();
11441                 speculateString(node-&gt;child1(), stringGPR);
11442                 speculateRegExpObject(node-&gt;child2(), regExpGPR);
11443 
11444                 flushRegisters();
11445                 GPRFlushedCallResult result(this);
<span class="line-modified">11446                 callOperation(operationStringProtoFuncReplaceRegExpEmptyStr, result.gpr(), stringGPR, regExpGPR);</span>
11447                 m_jit.exceptionCheck();
11448                 cellResult(result.gpr(), node);
11449                 if (sample)
11450                     m_jit.decrementSuperSamplerCount();
11451                 return;
11452             }
11453         }
11454 
11455         SpeculateCellOperand string(this, node-&gt;child1());
11456         SpeculateCellOperand regExp(this, node-&gt;child2());
11457         SpeculateCellOperand replace(this, node-&gt;child3());
11458         GPRReg stringGPR = string.gpr();
11459         GPRReg regExpGPR = regExp.gpr();
11460         GPRReg replaceGPR = replace.gpr();
11461         speculateString(node-&gt;child1(), stringGPR);
11462         speculateRegExpObject(node-&gt;child2(), regExpGPR);
11463         speculateString(node-&gt;child3(), replaceGPR);
11464 
11465         flushRegisters();
11466         GPRFlushedCallResult result(this);
<span class="line-modified">11467         callOperation(operationStringProtoFuncReplaceRegExpString, result.gpr(), stringGPR, regExpGPR, replaceGPR);</span>
11468         m_jit.exceptionCheck();
11469         cellResult(result.gpr(), node);
11470         if (sample)
11471             m_jit.decrementSuperSamplerCount();
11472         return;
11473     }
11474 
11475     // If we fixed up the edge of child2, we inserted a Check(@child2, String).
11476     OperandSpeculationMode child2SpeculationMode = AutomaticOperandSpeculation;
11477     if (node-&gt;child2().useKind() == StringUse)
11478         child2SpeculationMode = ManualOperandSpeculation;
11479 
11480     JSValueOperand string(this, node-&gt;child1());
11481     JSValueOperand search(this, node-&gt;child2(), child2SpeculationMode);
11482     JSValueOperand replace(this, node-&gt;child3());
11483     JSValueRegs stringRegs = string.jsValueRegs();
11484     JSValueRegs searchRegs = search.jsValueRegs();
11485     JSValueRegs replaceRegs = replace.jsValueRegs();
11486 
11487     flushRegisters();
11488     GPRFlushedCallResult result(this);
<span class="line-modified">11489     callOperation(operationStringProtoFuncReplaceGeneric, result.gpr(), stringRegs, searchRegs, replaceRegs);</span>
11490     m_jit.exceptionCheck();
11491     cellResult(result.gpr(), node);
11492     if (sample)
11493         m_jit.decrementSuperSamplerCount();
11494 }
11495 
11496 void SpeculativeJIT::compileRegExpExecNonGlobalOrSticky(Node* node)
11497 {
11498     SpeculateCellOperand globalObject(this, node-&gt;child1());
11499     SpeculateCellOperand argument(this, node-&gt;child2());
11500     GPRReg globalObjectGPR = globalObject.gpr();
11501     GPRReg argumentGPR = argument.gpr();
11502 
11503     speculateString(node-&gt;child2(), argumentGPR);
11504 
11505     flushRegisters();
11506     JSValueRegsFlushedCallResult result(this);
11507     JSValueRegs resultRegs = result.regs();
11508     callOperation(
11509         operationRegExpExecNonGlobalOrSticky, resultRegs,
</pre>
<hr />
<pre>
11692 
11693     SpeculateCellOperand base(this, m_jit.graph().varArgChild(node, 0));
11694     GPRReg baseGPR = base.gpr();
11695 
11696     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
11697     JSValueRegs valueRegs = value.jsValueRegs();
11698 
11699     SpeculateInt32Operand attributes(this, m_jit.graph().varArgChild(node, 3));
11700     GPRReg attributesGPR = attributes.gpr();
11701 
11702     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
11703     switch (propertyEdge.useKind()) {
11704     case StringUse: {
11705         SpeculateCellOperand property(this, propertyEdge);
11706         GPRReg propertyGPR = property.gpr();
11707         speculateString(propertyEdge, propertyGPR);
11708 
11709         useChildren(node);
11710 
11711         flushRegisters();
<span class="line-modified">11712         callOperation(operationDefineDataPropertyString, NoResult, baseGPR, propertyGPR, valueRegs, attributesGPR);</span>
11713         m_jit.exceptionCheck();
11714         break;
11715     }
11716     case StringIdentUse: {
11717         SpeculateCellOperand property(this, propertyEdge);
11718         GPRTemporary ident(this);
11719 
11720         GPRReg propertyGPR = property.gpr();
11721         GPRReg identGPR = ident.gpr();
11722 
11723         speculateString(propertyEdge, propertyGPR);
11724         speculateStringIdentAndLoadStorage(propertyEdge, propertyGPR, identGPR);
11725 
11726         useChildren(node);
11727 
11728         flushRegisters();
<span class="line-modified">11729         callOperation(operationDefineDataPropertyStringIdent, NoResult, baseGPR, identGPR, valueRegs, attributesGPR);</span>
11730         m_jit.exceptionCheck();
11731         break;
11732     }
11733     case SymbolUse: {
11734         SpeculateCellOperand property(this, propertyEdge);
11735         GPRReg propertyGPR = property.gpr();
11736         speculateSymbol(propertyEdge, propertyGPR);
11737 
11738         useChildren(node);
11739 
11740         flushRegisters();
<span class="line-modified">11741         callOperation(operationDefineDataPropertySymbol, NoResult, baseGPR, propertyGPR, valueRegs, attributesGPR);</span>
11742         m_jit.exceptionCheck();
11743         break;
11744     }
11745     case UntypedUse: {
11746         JSValueOperand property(this, propertyEdge);
11747         JSValueRegs propertyRegs = property.jsValueRegs();
11748 
11749         useChildren(node);
11750 
11751         flushRegisters();
<span class="line-modified">11752         callOperation(operationDefineDataProperty, NoResult, baseGPR, propertyRegs, valueRegs, attributesGPR);</span>
11753         m_jit.exceptionCheck();
11754         break;
11755     }
11756     default:
11757         RELEASE_ASSERT_NOT_REACHED();
11758     }
11759 
11760     noResult(node, UseChildrenCalledExplicitly);
11761 }
11762 
11763 void SpeculativeJIT::compileDefineAccessorProperty(Node* node)
11764 {
11765 #if USE(JSVALUE64)
11766     static_assert(GPRInfo::numberOfRegisters &gt;= 5, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11767 #else
11768     static_assert(GPRInfo::numberOfRegisters &gt;= 6, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11769 #endif
11770 
11771     SpeculateCellOperand base(this, m_jit.graph().varArgChild(node, 0));
11772     GPRReg baseGPR = base.gpr();
11773 
11774     SpeculateCellOperand getter(this, m_jit.graph().varArgChild(node, 2));
11775     GPRReg getterGPR = getter.gpr();
11776 
11777     SpeculateCellOperand setter(this, m_jit.graph().varArgChild(node, 3));
11778     GPRReg setterGPR = setter.gpr();
11779 
11780     SpeculateInt32Operand attributes(this, m_jit.graph().varArgChild(node, 4));
11781     GPRReg attributesGPR = attributes.gpr();
11782 
11783     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
11784     switch (propertyEdge.useKind()) {
11785     case StringUse: {
11786         SpeculateCellOperand property(this, propertyEdge);
11787         GPRReg propertyGPR = property.gpr();
11788         speculateString(propertyEdge, propertyGPR);
11789 
11790         useChildren(node);
11791 
11792         flushRegisters();
<span class="line-modified">11793         callOperation(operationDefineAccessorPropertyString, NoResult, baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);</span>
11794         m_jit.exceptionCheck();
11795         break;
11796     }
11797     case StringIdentUse: {
11798         SpeculateCellOperand property(this, propertyEdge);
11799         GPRTemporary ident(this);
11800 
11801         GPRReg propertyGPR = property.gpr();
11802         GPRReg identGPR = ident.gpr();
11803 
11804         speculateString(propertyEdge, propertyGPR);
11805         speculateStringIdentAndLoadStorage(propertyEdge, propertyGPR, identGPR);
11806 
11807         useChildren(node);
11808 
11809         flushRegisters();
<span class="line-modified">11810         callOperation(operationDefineAccessorPropertyStringIdent, NoResult, baseGPR, identGPR, getterGPR, setterGPR, attributesGPR);</span>
11811         m_jit.exceptionCheck();
11812         break;
11813     }
11814     case SymbolUse: {
11815         SpeculateCellOperand property(this, propertyEdge);
11816         GPRReg propertyGPR = property.gpr();
11817         speculateSymbol(propertyEdge, propertyGPR);
11818 
11819         useChildren(node);
11820 
11821         flushRegisters();
<span class="line-modified">11822         callOperation(operationDefineAccessorPropertySymbol, NoResult, baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);</span>
11823         m_jit.exceptionCheck();
11824         break;
11825     }
11826     case UntypedUse: {
11827         JSValueOperand property(this, propertyEdge);
11828         JSValueRegs propertyRegs = property.jsValueRegs();
11829 
11830         useChildren(node);
11831 
11832         flushRegisters();
<span class="line-modified">11833         callOperation(operationDefineAccessorProperty, NoResult, baseGPR, propertyRegs, getterGPR, setterGPR, attributesGPR);</span>
11834         m_jit.exceptionCheck();
11835         break;
11836     }
11837     default:
11838         RELEASE_ASSERT_NOT_REACHED();
11839     }
11840 
11841     noResult(node, UseChildrenCalledExplicitly);
11842 }
11843 
11844 void SpeculativeJIT::emitAllocateButterfly(GPRReg storageResultGPR, GPRReg sizeGPR, GPRReg scratch1, GPRReg scratch2, GPRReg scratch3, MacroAssembler::JumpList&amp; slowCases)
11845 {
11846     RELEASE_ASSERT(RegisterSet(storageResultGPR, sizeGPR, scratch1, scratch2, scratch3).numberOfSetGPRs() == 5);
11847     ASSERT((1 &lt;&lt; 3) == sizeof(JSValue));
11848     m_jit.zeroExtend32ToPtr(sizeGPR, scratch1);
11849     m_jit.lshift32(TrustedImm32(3), scratch1);
11850     m_jit.add32(TrustedImm32(sizeof(IndexingHeader)), scratch1, scratch2);
<span class="line-modified">11851 #if !ASSERT_DISABLED</span>
11852     MacroAssembler::Jump didNotOverflow = m_jit.branch32(MacroAssembler::AboveOrEqual, scratch2, sizeGPR);
11853     m_jit.abortWithReason(UncheckedOverflow);
11854     didNotOverflow.link(&amp;m_jit);
11855 #endif
11856     m_jit.emitAllocateVariableSized(
11857         storageResultGPR, vm().jsValueGigacageAuxiliarySpace, scratch2, scratch1, scratch3, slowCases);
11858     m_jit.addPtr(TrustedImm32(sizeof(IndexingHeader)), storageResultGPR);
11859 
11860     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfPublicLength()));
11861     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfVectorLength()));
11862 }
11863 
11864 void SpeculativeJIT::compileNormalizeMapKey(Node* node)
11865 {
11866     ASSERT(node-&gt;child1().useKind() == UntypedUse);
11867     JSValueOperand key(this, node-&gt;child1());
11868     JSValueRegsTemporary result(this, Reuse, key);
11869     GPRTemporary scratch(this);
11870     FPRTemporary doubleValue(this);
11871     FPRTemporary temp(this);
</pre>
<hr />
<pre>
12001     done.link(&amp;m_jit);
12002 #else
12003     auto isEmpty = m_jit.branchIfEmpty(valueRegs.tagGPR());
12004     m_jit.moveValueRegs(valueRegs, resultRegs);
12005     auto done = m_jit.jump();
12006 
12007     isEmpty.link(&amp;m_jit);
12008     m_jit.moveValue(jsUndefined(), resultRegs);
12009 
12010     done.link(&amp;m_jit);
12011 #endif
12012 
12013     jsValueResult(resultRegs, node, DataFormatJS);
12014 }
12015 
12016 void SpeculativeJIT::compileThrow(Node* node)
12017 {
12018     JSValueOperand value(this, node-&gt;child1());
12019     JSValueRegs valueRegs = value.jsValueRegs();
12020     flushRegisters();
<span class="line-modified">12021     callOperation(operationThrowDFG, valueRegs);</span>
12022     m_jit.exceptionCheck();
12023     m_jit.breakpoint();
12024     noResult(node);
12025 }
12026 
12027 void SpeculativeJIT::compileThrowStaticError(Node* node)
12028 {
12029     SpeculateCellOperand message(this, node-&gt;child1());
12030     GPRReg messageGPR = message.gpr();
12031     speculateString(node-&gt;child1(), messageGPR);
12032     flushRegisters();
<span class="line-modified">12033     callOperation(operationThrowStaticError, messageGPR, node-&gt;errorType());</span>
12034     m_jit.exceptionCheck();
12035     m_jit.breakpoint();
12036     noResult(node);
12037 }
12038 
12039 void SpeculativeJIT::compileGetEnumerableLength(Node* node)
12040 {
12041     SpeculateCellOperand enumerator(this, node-&gt;child1());
12042     GPRFlushedCallResult result(this);
12043     GPRReg resultGPR = result.gpr();
12044 
12045     m_jit.load32(MacroAssembler::Address(enumerator.gpr(), JSPropertyNameEnumerator::indexedLengthOffset()), resultGPR);
12046     int32Result(resultGPR, node);
12047 }
12048 
12049 void SpeculativeJIT::compileHasGenericProperty(Node* node)
12050 {
12051     JSValueOperand base(this, node-&gt;child1());
12052     SpeculateCellOperand property(this, node-&gt;child2());
12053 
12054     JSValueRegs baseRegs = base.jsValueRegs();
12055     GPRReg propertyGPR = property.gpr();
12056 
12057     flushRegisters();
12058     JSValueRegsFlushedCallResult result(this);
12059     JSValueRegs resultRegs = result.regs();
<span class="line-modified">12060     callOperation(operationHasGenericProperty, resultRegs, baseRegs, propertyGPR);</span>
12061     m_jit.exceptionCheck();
12062     blessedBooleanResult(resultRegs.payloadGPR(), node);
12063 }
12064 
12065 void SpeculativeJIT::compileToIndexString(Node* node)
12066 {
12067     SpeculateInt32Operand index(this, node-&gt;child1());
12068     GPRReg indexGPR = index.gpr();
12069 
12070     flushRegisters();
12071     GPRFlushedCallResult result(this);
12072     GPRReg resultGPR = result.gpr();
<span class="line-modified">12073     callOperation(operationToIndexString, resultGPR, indexGPR);</span>
12074     m_jit.exceptionCheck();
12075     cellResult(resultGPR, node);
12076 }
12077 
12078 void SpeculativeJIT::compilePutByIdFlush(Node* node)
12079 {
12080     SpeculateCellOperand base(this, node-&gt;child1());
12081     JSValueOperand value(this, node-&gt;child2());
12082     GPRTemporary scratch(this);
12083 
12084     GPRReg baseGPR = base.gpr();
12085     JSValueRegs valueRegs = value.jsValueRegs();
12086     GPRReg scratchGPR = scratch.gpr();
12087     flushRegisters();
12088 
12089     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), NotDirect, MacroAssembler::Jump(), DontSpill);
12090 
12091     noResult(node);
12092 }
12093 
</pre>
<hr />
<pre>
12115     GPRReg baseGPR = base.gpr();
12116     JSValueRegs valueRegs = value.jsValueRegs();
12117     GPRReg scratchGPR = scratch.gpr();
12118 
12119     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), Direct);
12120 
12121     noResult(node);
12122 }
12123 
12124 void SpeculativeJIT::compilePutByIdWithThis(Node* node)
12125 {
12126     JSValueOperand base(this, node-&gt;child1());
12127     JSValueRegs baseRegs = base.jsValueRegs();
12128     JSValueOperand thisValue(this, node-&gt;child2());
12129     JSValueRegs thisRegs = thisValue.jsValueRegs();
12130     JSValueOperand value(this, node-&gt;child3());
12131     JSValueRegs valueRegs = value.jsValueRegs();
12132 
12133     flushRegisters();
12134     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByIdWithThisStrict : operationPutByIdWithThis,
<span class="line-modified">12135         NoResult, baseRegs, thisRegs, valueRegs, identifierUID(node-&gt;identifierNumber()));</span>
12136     m_jit.exceptionCheck();
12137 
12138     noResult(node);
12139 }
12140 
12141 void SpeculativeJIT::compileGetByOffset(Node* node)
12142 {
12143     StorageOperand storage(this, node-&gt;child1());
12144     JSValueRegsTemporary result(this, Reuse, storage);
12145 
12146     GPRReg storageGPR = storage.gpr();
12147     JSValueRegs resultRegs = result.regs();
12148 
12149     StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
12150 
12151     m_jit.loadValue(JITCompiler::Address(storageGPR, offsetRelativeToBase(storageAccessData.offset)), resultRegs);
12152 
12153     jsValueResult(resultRegs, node);
12154 }
12155 
</pre>
<hr />
<pre>
12205     JSValueRegsTemporary result(this);
12206 
12207     JSValueRegs baseRegs = base.jsValueRegs();
12208     GPRReg propertyGPR = property.gpr();
12209     JSValueRegs resultRegs = result.regs();
12210 
12211     CCallHelpers::JumpList wrongStructure;
12212 
12213     wrongStructure.append(m_jit.branchIfNotCell(baseRegs));
12214 
12215     m_jit.load32(MacroAssembler::Address(baseRegs.payloadGPR(), JSCell::structureIDOffset()), resultRegs.payloadGPR());
12216     wrongStructure.append(m_jit.branch32(MacroAssembler::NotEqual,
12217         resultRegs.payloadGPR(),
12218         MacroAssembler::Address(enumerator.gpr(), JSPropertyNameEnumerator::cachedStructureIDOffset())));
12219 
12220     moveTrueTo(resultRegs.payloadGPR());
12221     MacroAssembler::Jump done = m_jit.jump();
12222 
12223     done.link(&amp;m_jit);
12224 
<span class="line-modified">12225     addSlowPathGenerator(slowPathCall(wrongStructure, this, operationHasGenericProperty, resultRegs, baseRegs, propertyGPR));</span>
12226     blessedBooleanResult(resultRegs.payloadGPR(), node);
12227 }
12228 
12229 void SpeculativeJIT::compileGetPropertyEnumerator(Node* node)
12230 {
12231     if (node-&gt;child1().useKind() == CellUse) {
12232         SpeculateCellOperand base(this, node-&gt;child1());
12233         GPRReg baseGPR = base.gpr();
12234 
12235         flushRegisters();
12236         GPRFlushedCallResult result(this);
12237         GPRReg resultGPR = result.gpr();
<span class="line-modified">12238         callOperation(operationGetPropertyEnumeratorCell, resultGPR, baseGPR);</span>
12239         m_jit.exceptionCheck();
12240         cellResult(resultGPR, node);
12241         return;
12242     }
12243 
12244     JSValueOperand base(this, node-&gt;child1());
12245     JSValueRegs baseRegs = base.jsValueRegs();
12246 
12247     flushRegisters();
12248     GPRFlushedCallResult result(this);
12249     GPRReg resultGPR = result.gpr();
<span class="line-modified">12250     callOperation(operationGetPropertyEnumerator, resultGPR, baseRegs);</span>
12251     m_jit.exceptionCheck();
12252     cellResult(resultGPR, node);
12253 }
12254 
12255 void SpeculativeJIT::compileGetEnumeratorPname(Node* node)
12256 {
12257     ASSERT(node-&gt;op() == GetEnumeratorStructurePname || node-&gt;op() == GetEnumeratorGenericPname);
12258     SpeculateCellOperand enumerator(this, node-&gt;child1());
12259     SpeculateStrictInt32Operand index(this, node-&gt;child2());
12260     GPRTemporary scratch(this);
12261     JSValueRegsTemporary result(this);
12262 
12263     GPRReg enumeratorGPR = enumerator.gpr();
12264     GPRReg indexGPR = index.gpr();
12265     GPRReg scratchGPR = scratch.gpr();
12266     JSValueRegs resultRegs = result.regs();
12267 
12268     MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, indexGPR,
12269         MacroAssembler::Address(enumeratorGPR, (node-&gt;op() == GetEnumeratorStructurePname)
12270             ? JSPropertyNameEnumerator::endStructurePropertyIndexOffset()
</pre>
<hr />
<pre>
12275     MacroAssembler::Jump done = m_jit.jump();
12276     inBounds.link(&amp;m_jit);
12277 
12278     m_jit.loadPtr(MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedPropertyNamesVectorOffset()), scratchGPR);
12279     m_jit.loadPtr(MacroAssembler::BaseIndex(scratchGPR, indexGPR, MacroAssembler::ScalePtr), resultRegs.payloadGPR());
12280 #if USE(JSVALUE32_64)
12281     m_jit.move(MacroAssembler::TrustedImm32(JSValue::CellTag), resultRegs.tagGPR());
12282 #endif
12283 
12284     done.link(&amp;m_jit);
12285     jsValueResult(resultRegs, node);
12286 }
12287 
12288 void SpeculativeJIT::compileGetExecutable(Node* node)
12289 {
12290     SpeculateCellOperand function(this, node-&gt;child1());
12291     GPRTemporary result(this, Reuse, function);
12292     GPRReg functionGPR = function.gpr();
12293     GPRReg resultGPR = result.gpr();
12294     speculateCellType(node-&gt;child1(), functionGPR, SpecFunction, JSFunctionType);
<span class="line-modified">12295     m_jit.loadPtr(JITCompiler::Address(functionGPR, JSFunction::offsetOfExecutable()), resultGPR);</span>



12296     cellResult(resultGPR, node);
12297 }
12298 
12299 void SpeculativeJIT::compileGetGetter(Node* node)
12300 {
12301     SpeculateCellOperand op1(this, node-&gt;child1());
12302     GPRTemporary result(this, Reuse, op1);
12303 
12304     GPRReg op1GPR = op1.gpr();
12305     GPRReg resultGPR = result.gpr();
12306 
12307     m_jit.loadPtr(JITCompiler::Address(op1GPR, GetterSetter::offsetOfGetter()), resultGPR);
12308 
12309     cellResult(resultGPR, node);
12310 }
12311 
12312 void SpeculativeJIT::compileGetSetter(Node* node)
12313 {
12314     SpeculateCellOperand op1(this, node-&gt;child1());
12315     GPRTemporary result(this, Reuse, op1);
</pre>
<hr />
<pre>
12326 {
12327     GPRTemporary result(this);
12328     m_jit.loadPtr(JITCompiler::payloadFor(CallFrameSlot::callee), result.gpr());
12329     cellResult(result.gpr(), node);
12330 }
12331 
12332 void SpeculativeJIT::compileSetCallee(Node* node)
12333 {
12334     SpeculateCellOperand callee(this, node-&gt;child1());
12335     m_jit.storeCell(callee.gpr(), JITCompiler::payloadFor(CallFrameSlot::callee));
12336     noResult(node);
12337 }
12338 
12339 void SpeculativeJIT::compileGetArgumentCountIncludingThis(Node* node)
12340 {
12341     GPRTemporary result(this);
12342     VirtualRegister argumentCountRegister;
12343     if (InlineCallFrame* inlineCallFrame = node-&gt;argumentsInlineCallFrame())
12344         argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
12345     else
<span class="line-modified">12346         argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCount);</span>
12347     m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), result.gpr());
12348     int32Result(result.gpr(), node);
12349 }
12350 
12351 void SpeculativeJIT::compileSetArgumentCountIncludingThis(Node* node)
12352 {
<span class="line-modified">12353     m_jit.store32(TrustedImm32(node-&gt;argumentCountIncludingThis()), JITCompiler::payloadFor(CallFrameSlot::argumentCount));</span>
12354     noResult(node);
12355 }
12356 
12357 void SpeculativeJIT::compileStrCat(Node* node)
12358 {
12359     JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
12360     JSValueOperand op2(this, node-&gt;child2(), ManualOperandSpeculation);
12361     JSValueOperand op3(this, node-&gt;child3(), ManualOperandSpeculation);
12362 
12363     JSValueRegs op1Regs = op1.jsValueRegs();
12364     JSValueRegs op2Regs = op2.jsValueRegs();
12365     JSValueRegs op3Regs;
12366 
12367     if (node-&gt;child3())
12368         op3Regs = op3.jsValueRegs();
12369 
12370     flushRegisters();
12371 
12372     GPRFlushedCallResult result(this);
12373     if (node-&gt;child3())
<span class="line-modified">12374         callOperation(operationStrCat3, result.gpr(), op1Regs, op2Regs, op3Regs);</span>
12375     else
<span class="line-modified">12376         callOperation(operationStrCat2, result.gpr(), op1Regs, op2Regs);</span>
12377     m_jit.exceptionCheck();
12378 
12379     cellResult(result.gpr(), node);
12380 }
12381 
12382 void SpeculativeJIT::compileNewArrayBuffer(Node* node)
12383 {
12384     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12385     auto* array = node-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
12386 
12387     IndexingType indexingMode = node-&gt;indexingMode();
12388     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode));
12389 
12390     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(indexingMode)) {
12391         GPRTemporary result(this);
12392         GPRTemporary scratch1(this);
12393         GPRTemporary scratch2(this);
12394 
12395         GPRReg resultGPR = result.gpr();
12396         GPRReg scratch1GPR = scratch1.gpr();
12397         GPRReg scratch2GPR = scratch2.gpr();
12398 
12399         MacroAssembler::JumpList slowCases;
12400 
12401         emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), TrustedImmPtr(array-&gt;toButterfly()), scratch1GPR, scratch2GPR, slowCases);
12402 
<span class="line-modified">12403         addSlowPathGenerator(slowPathCall(slowCases, this, operationNewArrayBuffer, result.gpr(), structure, array));</span>
12404 
12405         DFG_ASSERT(m_jit.graph(), node, indexingMode &amp; IsArray, indexingMode);
12406         cellResult(resultGPR, node);
12407         return;
12408     }
12409 
12410     flushRegisters();
12411     GPRFlushedCallResult result(this);
12412 
<span class="line-modified">12413     callOperation(operationNewArrayBuffer, result.gpr(), structure, TrustedImmPtr(node-&gt;cellOperand()));</span>
12414     m_jit.exceptionCheck();
12415 
12416     cellResult(result.gpr(), node);
12417 }
12418 
12419 void SpeculativeJIT::compileNewArrayWithSize(Node* node)
12420 {
12421     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12422     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingType())) {
12423         SpeculateStrictInt32Operand size(this, node-&gt;child1());
12424         GPRTemporary result(this);
12425 
12426         GPRReg sizeGPR = size.gpr();
12427         GPRReg resultGPR = result.gpr();
12428 
12429         compileAllocateNewArrayWithSize(globalObject, resultGPR, sizeGPR, node-&gt;indexingType());
12430         cellResult(resultGPR, node);
12431         return;
12432     }
12433 
12434     SpeculateStrictInt32Operand size(this, node-&gt;child1());
12435     GPRReg sizeGPR = size.gpr();
12436     flushRegisters();
12437     GPRFlushedCallResult result(this);
12438     GPRReg resultGPR = result.gpr();
12439     GPRReg structureGPR = AssemblyHelpers::selectScratchGPR(sizeGPR);
12440     MacroAssembler::Jump bigLength = m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
12441     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()))), structureGPR);
12442     MacroAssembler::Jump done = m_jit.jump();
12443     bigLength.link(&amp;m_jit);
12444     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))), structureGPR);
12445     done.link(&amp;m_jit);
<span class="line-modified">12446     callOperation(operationNewArrayWithSize, resultGPR, structureGPR, sizeGPR, nullptr);</span>
12447     m_jit.exceptionCheck();
12448     cellResult(resultGPR, node);
12449 }
12450 
12451 void SpeculativeJIT::compileNewTypedArray(Node* node)
12452 {
12453     switch (node-&gt;child1().useKind()) {
12454     case Int32Use:
12455         compileNewTypedArrayWithSize(node);
12456         break;
12457     case UntypedUse: {
12458         JSValueOperand argument(this, node-&gt;child1());
12459         JSValueRegs argumentRegs = argument.jsValueRegs();
12460 
12461         flushRegisters();
12462 
12463         GPRFlushedCallResult result(this);
12464         GPRReg resultGPR = result.gpr();
12465 
12466         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12467         callOperation(
12468             operationNewTypedArrayWithOneArgumentForType(node-&gt;typedArrayType()),
<span class="line-modified">12469             resultGPR, m_jit.graph().registerStructure(globalObject-&gt;typedArrayStructureConcurrently(node-&gt;typedArrayType())), argumentRegs);</span>
12470         m_jit.exceptionCheck();
12471 
12472         cellResult(resultGPR, node);
12473         break;
12474     }
12475     default:
12476         RELEASE_ASSERT_NOT_REACHED();
12477         break;
12478     }
12479 }
12480 
12481 void SpeculativeJIT::compileToThis(Node* node)
12482 {
12483     ASSERT(node-&gt;child1().useKind() == UntypedUse);
12484     JSValueOperand thisValue(this, node-&gt;child1());
12485     JSValueRegsTemporary temp(this);
12486 
12487     JSValueRegs thisValueRegs = thisValue.jsValueRegs();
12488     JSValueRegs tempRegs = temp.regs();
12489 
12490     MacroAssembler::JumpList slowCases;
12491     slowCases.append(m_jit.branchIfNotCell(thisValueRegs));
12492     slowCases.append(
12493         m_jit.branchTest8(
12494             MacroAssembler::NonZero,
12495             MacroAssembler::Address(thisValueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
12496             MacroAssembler::TrustedImm32(OverridesToThis)));
12497     m_jit.moveValueRegs(thisValueRegs, tempRegs);
12498 
<span class="line-modified">12499     J_JITOperation_EJ function;</span>
12500     if (m_jit.isStrictModeFor(node-&gt;origin.semantic))
12501         function = operationToThisStrict;
12502     else
12503         function = operationToThis;
<span class="line-modified">12504     addSlowPathGenerator(slowPathCall(slowCases, this, function, tempRegs, thisValueRegs));</span>
12505 
12506     jsValueResult(tempRegs, node);
12507 }
12508 
12509 void SpeculativeJIT::compileObjectKeys(Node* node)
12510 {
12511     switch (node-&gt;child1().useKind()) {
12512     case ObjectUse: {
12513         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
12514             SpeculateCellOperand object(this, node-&gt;child1());
12515             GPRTemporary structure(this);
12516             GPRTemporary scratch(this);
12517             GPRTemporary scratch2(this);
12518             GPRTemporary scratch3(this);
12519             GPRTemporary result(this);
12520 
12521             GPRReg objectGPR = object.gpr();
12522             GPRReg structureGPR = structure.gpr();
12523             GPRReg scratchGPR = scratch.gpr();
12524             GPRReg scratch2GPR = scratch2.gpr();
</pre>
<hr />
<pre>
12528             speculateObject(node-&gt;child1(), objectGPR);
12529 
12530             CCallHelpers::JumpList slowCases;
12531             m_jit.emitLoadStructure(vm(), objectGPR, structureGPR, scratchGPR);
12532             m_jit.loadPtr(CCallHelpers::Address(structureGPR, Structure::previousOrRareDataOffset()), scratchGPR);
12533 
12534             slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, scratchGPR));
12535             slowCases.append(m_jit.branch32(CCallHelpers::Equal, CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()), TrustedImm32(bitwise_cast&lt;int32_t&gt;(vm().structureStructure-&gt;structureID()))));
12536 
12537             m_jit.loadPtr(CCallHelpers::Address(scratchGPR, StructureRareData::offsetOfCachedOwnKeys()), scratchGPR);
12538 
12539             ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
12540             slowCases.append(m_jit.branchPtr(CCallHelpers::BelowOrEqual, scratchGPR, TrustedImmPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))));
12541 
12542             MacroAssembler::JumpList slowButArrayBufferCases;
12543 
12544             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12545             RegisteredStructure arrayStructure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
12546 
12547             m_jit.move(scratchGPR, scratch3GPR);
<span class="line-modified">12548             m_jit.addPtr(TrustedImmPtr(JSImmutableButterfly::offsetOfData()), scratchGPR);</span>
12549 
12550             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(arrayStructure), scratchGPR, structureGPR, scratch2GPR, slowButArrayBufferCases);
12551 
<span class="line-modified">12552             addSlowPathGenerator(slowPathCall(slowButArrayBufferCases, this, operationNewArrayBuffer, resultGPR, arrayStructure, scratch3GPR));</span>
12553 
<span class="line-modified">12554             addSlowPathGenerator(slowPathCall(slowCases, this, operationObjectKeysObject, resultGPR, objectGPR));</span>
12555 
12556             cellResult(resultGPR, node);
12557             break;
12558         }
12559 
12560         SpeculateCellOperand object(this, node-&gt;child1());
12561 
12562         GPRReg objectGPR = object.gpr();
12563 
12564         speculateObject(node-&gt;child1(), objectGPR);
12565 
12566         flushRegisters();
12567         GPRFlushedCallResult result(this);
12568         GPRReg resultGPR = result.gpr();
<span class="line-modified">12569         callOperation(operationObjectKeysObject, resultGPR, objectGPR);</span>
12570         m_jit.exceptionCheck();
12571 
12572         cellResult(resultGPR, node);
12573         break;
12574     }
12575 
12576     case UntypedUse: {
12577         JSValueOperand object(this, node-&gt;child1());
12578 
12579         JSValueRegs objectRegs = object.jsValueRegs();
12580 
12581         flushRegisters();
12582         GPRFlushedCallResult result(this);
12583         GPRReg resultGPR = result.gpr();
<span class="line-modified">12584         callOperation(operationObjectKeys, resultGPR, objectRegs);</span>
12585         m_jit.exceptionCheck();
12586 
12587         cellResult(resultGPR, node);
12588         break;
12589     }
12590 
12591     default:
12592         RELEASE_ASSERT_NOT_REACHED();
12593         break;
12594     }
12595 }
12596 
12597 void SpeculativeJIT::compileObjectCreate(Node* node)
12598 {
12599     switch (node-&gt;child1().useKind()) {
12600     case ObjectUse: {
12601         SpeculateCellOperand prototype(this, node-&gt;child1());
12602 
12603         GPRReg prototypeGPR = prototype.gpr();
12604 
12605         speculateObject(node-&gt;child1(), prototypeGPR);
12606 
12607         flushRegisters();
12608         GPRFlushedCallResult result(this);
12609         GPRReg resultGPR = result.gpr();
<span class="line-modified">12610         callOperation(operationObjectCreateObject, resultGPR, prototypeGPR);</span>
12611         m_jit.exceptionCheck();
12612 
12613         cellResult(resultGPR, node);
12614         break;
12615     }
12616 
12617     case UntypedUse: {
12618         JSValueOperand prototype(this, node-&gt;child1());
12619 
12620         JSValueRegs prototypeRegs = prototype.jsValueRegs();
12621 
12622         flushRegisters();
12623         GPRFlushedCallResult result(this);
12624         GPRReg resultGPR = result.gpr();
<span class="line-modified">12625         callOperation(operationObjectCreate, resultGPR, prototypeRegs);</span>
12626         m_jit.exceptionCheck();
12627 
12628         cellResult(resultGPR, node);
12629         break;
12630     }
12631 
12632     default:
12633         RELEASE_ASSERT_NOT_REACHED();
12634         break;
12635     }
12636 }
12637 
12638 void SpeculativeJIT::compileCreateThis(Node* node)
12639 {
12640     // Note that there is not so much profit to speculate here. The only things we
12641     // speculate on are (1) that it&#39;s a cell, since that eliminates cell checks
12642     // later if the proto is reused, and (2) if we have a FinalObject prediction
12643     // then we speculate because we want to get recompiled if it isn&#39;t (since
12644     // otherwise we&#39;d start taking slow path a lot).
12645 
12646     SpeculateCellOperand callee(this, node-&gt;child1());
12647     GPRTemporary result(this);
12648     GPRTemporary allocator(this);
12649     GPRTemporary structure(this);
12650     GPRTemporary scratch(this);
12651 
12652     GPRReg calleeGPR = callee.gpr();
12653     GPRReg resultGPR = result.gpr();
12654     GPRReg allocatorGPR = allocator.gpr();
12655     GPRReg structureGPR = structure.gpr();
12656     GPRReg scratchGPR = scratch.gpr();
12657     // Rare data is only used to access the allocator &amp; structure
12658     // We can avoid using an additional GPR this way
12659     GPRReg rareDataGPR = structureGPR;
12660     GPRReg inlineCapacityGPR = rareDataGPR;
12661 
12662     MacroAssembler::JumpList slowPath;
12663 
12664     slowPath.append(m_jit.branchIfNotFunction(calleeGPR));
<span class="line-modified">12665     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfRareData()), rareDataGPR);</span>
<span class="line-modified">12666     slowPath.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR));</span>
<span class="line-modified">12667     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator()), allocatorGPR);</span>
<span class="line-modified">12668     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure()), structureGPR);</span>
12669 
12670     auto butterfly = TrustedImmPtr(nullptr);
12671     emitAllocateJSObject(resultGPR, JITAllocator::variable(), allocatorGPR, structureGPR, butterfly, scratchGPR, slowPath);
12672 
12673     m_jit.load8(JITCompiler::Address(structureGPR, Structure::inlineCapacityOffset()), inlineCapacityGPR);
12674     m_jit.emitInitializeInlineStorage(resultGPR, inlineCapacityGPR);
12675     m_jit.mutatorFence(vm());
12676 
<span class="line-modified">12677     addSlowPathGenerator(slowPathCall(slowPath, this, operationCreateThis, resultGPR, calleeGPR, node-&gt;inlineCapacity()));</span>

















































12678 
12679     cellResult(resultGPR, node);
12680 }
12681 
























































12682 void SpeculativeJIT::compileNewObject(Node* node)
12683 {
12684     GPRTemporary result(this);
12685     GPRTemporary allocator(this);
12686     GPRTemporary scratch(this);
12687 
12688     GPRReg resultGPR = result.gpr();
12689     GPRReg allocatorGPR = allocator.gpr();
12690     GPRReg scratchGPR = scratch.gpr();
12691 
12692     MacroAssembler::JumpList slowPath;
12693 
12694     RegisteredStructure structure = node-&gt;structure();
12695     size_t allocationSize = JSFinalObject::allocationSize(structure-&gt;inlineCapacity());
12696     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm(), allocationSize, AllocatorForMode::AllocatorIfExists);
12697     if (!allocatorValue)
12698         slowPath.append(m_jit.jump());
12699     else {
12700         auto butterfly = TrustedImmPtr(nullptr);
12701         emitAllocateJSObject(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(structure), butterfly, scratchGPR, slowPath);
12702         m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
12703         m_jit.mutatorFence(vm());
12704     }
12705 
<span class="line-modified">12706     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewObject, resultGPR, structure));</span>



























12707 
12708     cellResult(resultGPR, node);
12709 }
12710 










































12711 void SpeculativeJIT::compileToPrimitive(Node* node)
12712 {
12713     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
12714     JSValueOperand argument(this, node-&gt;child1());
12715     JSValueRegsTemporary result(this, Reuse, argument);
12716 
12717     JSValueRegs argumentRegs = argument.jsValueRegs();
12718     JSValueRegs resultRegs = result.regs();
12719 
12720     argument.use();
12721 
12722     MacroAssembler::Jump alreadyPrimitive = m_jit.branchIfNotCell(argumentRegs);
12723     MacroAssembler::Jump notPrimitive = m_jit.branchIfObject(argumentRegs.payloadGPR());
12724 
12725     alreadyPrimitive.link(&amp;m_jit);
12726     m_jit.moveValueRegs(argumentRegs, resultRegs);
12727 
<span class="line-modified">12728     addSlowPathGenerator(slowPathCall(notPrimitive, this, operationToPrimitive, resultRegs, argumentRegs));</span>
12729 
12730     jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
12731 }
12732 




















































12733 void SpeculativeJIT::compileLogShadowChickenPrologue(Node* node)
12734 {
12735     flushRegisters();
12736     prepareForExternalCall();
12737     m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
12738 
12739     GPRTemporary scratch1(this, GPRInfo::nonArgGPR0); // This must be a non-argument GPR.
12740     GPRReg scratch1Reg = scratch1.gpr();
12741     GPRTemporary scratch2(this);
12742     GPRReg scratch2Reg = scratch2.gpr();
12743     GPRTemporary shadowPacket(this);
12744     GPRReg shadowPacketReg = shadowPacket.gpr();
12745 
12746     m_jit.ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
12747 
12748     SpeculateCellOperand scope(this, node-&gt;child1());
12749     GPRReg scopeReg = scope.gpr();
12750 
12751     m_jit.logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, scopeReg);
12752     noResult(node);
</pre>
<hr />
<pre>
12774 
12775     m_jit.logShadowChickenTailPacket(shadowPacketReg, thisRegs, scopeReg, m_jit.codeBlock(), callSiteIndex);
12776     noResult(node);
12777 }
12778 
12779 void SpeculativeJIT::compileSetAdd(Node* node)
12780 {
12781     SpeculateCellOperand set(this, node-&gt;child1());
12782     JSValueOperand key(this, node-&gt;child2());
12783     SpeculateInt32Operand hash(this, node-&gt;child3());
12784 
12785     GPRReg setGPR = set.gpr();
12786     JSValueRegs keyRegs = key.jsValueRegs();
12787     GPRReg hashGPR = hash.gpr();
12788 
12789     speculateSetObject(node-&gt;child1(), setGPR);
12790 
12791     flushRegisters();
12792     GPRFlushedCallResult result(this);
12793     GPRReg resultGPR = result.gpr();
<span class="line-modified">12794     callOperation(operationSetAdd, resultGPR, setGPR, keyRegs, hashGPR);</span>
12795     m_jit.exceptionCheck();
12796     cellResult(resultGPR, node);
12797 }
12798 
12799 void SpeculativeJIT::compileMapSet(Node* node)
12800 {
12801     SpeculateCellOperand map(this, m_jit.graph().varArgChild(node, 0));
12802     JSValueOperand key(this, m_jit.graph().varArgChild(node, 1));
12803     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
12804     SpeculateInt32Operand hash(this, m_jit.graph().varArgChild(node, 3));
12805 
12806     GPRReg mapGPR = map.gpr();
12807     JSValueRegs keyRegs = key.jsValueRegs();
12808     JSValueRegs valueRegs = value.jsValueRegs();
12809     GPRReg hashGPR = hash.gpr();
12810 
12811     speculateMapObject(m_jit.graph().varArgChild(node, 0), mapGPR);
12812 
12813     flushRegisters();
12814     GPRFlushedCallResult result(this);
12815     GPRReg resultGPR = result.gpr();
<span class="line-modified">12816     callOperation(operationMapSet, resultGPR, mapGPR, keyRegs, valueRegs, hashGPR);</span>
12817     m_jit.exceptionCheck();
12818     cellResult(resultGPR, node);
12819 }
12820 
12821 void SpeculativeJIT::compileWeakMapGet(Node* node)
12822 {
12823     GPRTemporary mask(this);
12824     GPRTemporary buffer(this);
12825     JSValueRegsTemporary result(this);
12826 
12827     GPRReg maskGPR = mask.gpr();
12828     GPRReg bufferGPR = buffer.gpr();
12829     JSValueRegs resultRegs = result.regs();
12830 
12831     GPRTemporary index;
12832     GPRReg indexGPR { InvalidGPRReg };
12833     {
12834         SpeculateInt32Operand hash(this, node-&gt;child3());
12835         GPRReg hashGPR = hash.gpr();
12836         index = GPRTemporary(this, Reuse, hash);
</pre>
<hr />
<pre>
12913         m_jit.loadValue(MacroAssembler::Address(bucketGPR, WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfValue()), resultRegs);
12914 #endif
12915 
12916     jsValueResult(resultRegs, node);
12917 }
12918 
12919 void SpeculativeJIT::compileWeakSetAdd(Node* node)
12920 {
12921     SpeculateCellOperand set(this, node-&gt;child1());
12922     SpeculateCellOperand key(this, node-&gt;child2());
12923     SpeculateInt32Operand hash(this, node-&gt;child3());
12924 
12925     GPRReg setGPR = set.gpr();
12926     GPRReg keyGPR = key.gpr();
12927     GPRReg hashGPR = hash.gpr();
12928 
12929     speculateWeakSetObject(node-&gt;child1(), setGPR);
12930     speculateObject(node-&gt;child2(), keyGPR);
12931 
12932     flushRegisters();
<span class="line-modified">12933     callOperation(operationWeakSetAdd, setGPR, keyGPR, hashGPR);</span>
12934     m_jit.exceptionCheck();
12935     noResult(node);
12936 }
12937 
12938 void SpeculativeJIT::compileWeakMapSet(Node* node)
12939 {
12940     SpeculateCellOperand map(this, m_jit.graph().varArgChild(node, 0));
12941     SpeculateCellOperand key(this, m_jit.graph().varArgChild(node, 1));
12942     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
12943     SpeculateInt32Operand hash(this, m_jit.graph().varArgChild(node, 3));
12944 
12945     GPRReg mapGPR = map.gpr();
12946     GPRReg keyGPR = key.gpr();
12947     JSValueRegs valueRegs = value.jsValueRegs();
12948     GPRReg hashGPR = hash.gpr();
12949 
12950     speculateWeakMapObject(m_jit.graph().varArgChild(node, 0), mapGPR);
12951     speculateObject(m_jit.graph().varArgChild(node, 1), keyGPR);
12952 
12953     flushRegisters();
<span class="line-modified">12954     callOperation(operationWeakMapSet, mapGPR, keyGPR, valueRegs, hashGPR);</span>
12955     m_jit.exceptionCheck();
12956     noResult(node);
12957 }
12958 
12959 void SpeculativeJIT::compileGetPrototypeOf(Node* node)
12960 {
12961     switch (node-&gt;child1().useKind()) {
12962     case ArrayUse:
12963     case FunctionUse:
12964     case FinalObjectUse: {
12965         SpeculateCellOperand object(this, node-&gt;child1());
12966         GPRTemporary temp(this);
12967         GPRTemporary temp2(this);
12968 
12969         GPRReg objectGPR = object.gpr();
12970         GPRReg tempGPR = temp.gpr();
12971         GPRReg temp2GPR = temp2.gpr();
12972 
12973         switch (node-&gt;child1().useKind()) {
12974         case ArrayUse:
</pre>
<hr />
<pre>
13033         m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + TagOffset), temp2GPR);
13034         m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + PayloadOffset), tempGPR);
13035         auto hasMonoProto = m_jit.branchIfNotEmpty(temp2GPR);
13036         m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + TagOffset), temp2GPR);
13037         m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), tempGPR);
13038         hasMonoProto.link(&amp;m_jit);
13039         jsValueResult(temp2GPR, tempGPR, node);
13040 #endif
13041         return;
13042     }
13043     case ObjectUse: {
13044         SpeculateCellOperand value(this, node-&gt;child1());
13045         JSValueRegsTemporary result(this);
13046 
13047         GPRReg valueGPR = value.gpr();
13048         JSValueRegs resultRegs = result.regs();
13049 
13050         speculateObject(node-&gt;child1(), valueGPR);
13051 
13052         flushRegisters();
<span class="line-modified">13053         callOperation(operationGetPrototypeOfObject, resultRegs, valueGPR);</span>
13054         m_jit.exceptionCheck();
13055         jsValueResult(resultRegs, node);
13056         return;
13057     }
13058     default: {
13059         JSValueOperand value(this, node-&gt;child1());
13060         JSValueRegsTemporary result(this);
13061 
13062         JSValueRegs valueRegs = value.jsValueRegs();
13063         JSValueRegs resultRegs = result.regs();
13064 
13065         flushRegisters();
<span class="line-modified">13066         callOperation(operationGetPrototypeOf, resultRegs, valueRegs);</span>
13067         m_jit.exceptionCheck();
13068         jsValueResult(resultRegs, node);
13069         return;
13070     }
13071     }
13072 }
13073 
13074 void SpeculativeJIT::compileIdentity(Node* node)
13075 {
13076     speculate(node, node-&gt;child1());
13077     switch (node-&gt;child1().useKind()) {
13078 #if USE(JSVALUE64)
13079     case DoubleRepAnyIntUse:
13080 #endif
13081     case DoubleRepUse:
13082     case DoubleRepRealUse: {
13083         SpeculateDoubleOperand op(this, node-&gt;child1());
13084         FPRTemporary scratch(this, op);
13085         m_jit.moveDouble(op.fpr(), scratch.fpr());
13086         doubleResult(scratch.fpr(), node);
</pre>
<hr />
<pre>
13138     m_jit.storeValue(emptyValueRegs, MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesEight));
13139     m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
13140     done.link(&amp;m_jit);
13141 }
13142 
13143 void SpeculativeJIT::compileAllocateNewArrayWithSize(JSGlobalObject* globalObject, GPRReg resultGPR, GPRReg sizeGPR, IndexingType indexingType, bool shouldConvertLargeSizeToArrayStorage)
13144 {
13145     GPRTemporary storage(this);
13146     GPRTemporary scratch(this);
13147     GPRTemporary scratch2(this);
13148 
13149     GPRReg storageGPR = storage.gpr();
13150     GPRReg scratchGPR = scratch.gpr();
13151     GPRReg scratch2GPR = scratch2.gpr();
13152 
13153     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
13154 
13155     MacroAssembler::JumpList slowCases;
13156     if (shouldConvertLargeSizeToArrayStorage)
13157         slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));
<span class="line-modified">13158 #if !ASSERT_DISABLED</span>
13159     else {
13160         MacroAssembler::Jump lengthIsWithinLimits;
13161         lengthIsWithinLimits = m_jit.branch32(MacroAssembler::Below, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
13162         m_jit.abortWithReason(UncheckedOverflow);
13163         lengthIsWithinLimits.link(&amp;m_jit);
13164     }
<span class="line-modified">13165 #endif</span>
13166 
13167     // We can use resultGPR as a scratch right now.
13168     emitAllocateButterfly(storageGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
13169 
13170 #if USE(JSVALUE64)
13171     JSValueRegs emptyValueRegs(scratchGPR);
13172     if (hasDouble(indexingType))
13173         m_jit.move(TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), emptyValueRegs.gpr());
13174     else
13175         m_jit.move(TrustedImm64(JSValue::encode(JSValue())), emptyValueRegs.gpr());
13176 #else
13177     JSValueRegs emptyValueRegs(scratchGPR, scratch2GPR);
13178     if (hasDouble(indexingType))
13179         m_jit.moveValue(JSValue(JSValue::EncodeAsDouble, PNaN), emptyValueRegs);
13180     else
13181         m_jit.moveValue(JSValue(), emptyValueRegs);
13182 #endif
13183     emitInitializeButterfly(storageGPR, sizeGPR, emptyValueRegs, resultGPR);
13184 
13185     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType));
13186 
13187     emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), storageGPR, scratchGPR, scratch2GPR, slowCases);
13188 
13189     m_jit.mutatorFence(vm());
13190 
13191     addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableSizeSlowPathGenerator&gt;(
13192         slowCases, this, operationNewArrayWithSize, resultGPR,

13193         structure,
13194         shouldConvertLargeSizeToArrayStorage ? m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage)) : structure,
13195         sizeGPR, storageGPR));
13196 }
13197 
13198 void SpeculativeJIT::compileHasIndexedProperty(Node* node)
13199 {
13200     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
13201     SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
13202     GPRTemporary result(this);
13203 
13204     GPRReg baseGPR = base.gpr();
13205     GPRReg indexGPR = index.gpr();
13206     GPRReg resultGPR = result.gpr();
13207 
13208     MacroAssembler::JumpList slowCases;
13209     ArrayMode mode = node-&gt;arrayMode();
13210     switch (mode.type()) {
13211     case Array::Int32:
13212     case Array::Contiguous: {
</pre>
<hr />
<pre>
13264             speculationCheck(OutOfBounds, JSValueRegs(), nullptr, outOfBounds);
13265         else
13266             slowCases.append(outOfBounds);
13267 
13268 #if USE(JSVALUE64)
13269         m_jit.load64(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), scratchGPR);
13270         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13271 #else
13272         m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), scratchGPR);
13273         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13274 #endif
13275         m_jit.move(TrustedImm32(1), resultGPR);
13276         break;
13277     }
13278     default: {
13279         slowCases.append(m_jit.jump());
13280         break;
13281     }
13282     }
13283 
<span class="line-modified">13284     addSlowPathGenerator(slowPathCall(slowCases, this, operationHasIndexedPropertyByInt, resultGPR, baseGPR, indexGPR, static_cast&lt;int32_t&gt;(node-&gt;internalMethodType())));</span>
13285 
13286     unblessedBooleanResult(resultGPR, node);
13287 }
13288 
13289 void SpeculativeJIT::compileGetDirectPname(Node* node)
13290 {
13291     Edge&amp; baseEdge = m_jit.graph().varArgChild(node, 0);
13292     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
13293     Edge&amp; indexEdge = m_jit.graph().varArgChild(node, 2);
13294 
13295     SpeculateCellOperand base(this, baseEdge);
13296     SpeculateCellOperand property(this, propertyEdge);
13297     GPRReg baseGPR = base.gpr();
13298     GPRReg propertyGPR = property.gpr();
13299 
<span class="line-removed">13300 #if CPU(X86)</span>
<span class="line-removed">13301     // Not enough registers on X86 for this code, so always use the slow path.</span>
<span class="line-removed">13302     speculate(node, indexEdge);</span>
<span class="line-removed">13303     flushRegisters();</span>
<span class="line-removed">13304     JSValueRegsFlushedCallResult result(this);</span>
<span class="line-removed">13305     JSValueRegs resultRegs = result.regs();</span>
<span class="line-removed">13306     callOperation(operationGetByValCell, resultRegs, baseGPR, CCallHelpers::CellValue(propertyGPR));</span>
<span class="line-removed">13307     m_jit.exceptionCheck();</span>
<span class="line-removed">13308     jsValueResult(resultRegs, node);</span>
<span class="line-removed">13309 #else</span>
13310     Edge&amp; enumeratorEdge = m_jit.graph().varArgChild(node, 3);
13311     SpeculateStrictInt32Operand index(this, indexEdge);
13312     SpeculateCellOperand enumerator(this, enumeratorEdge);
13313     GPRTemporary scratch(this);
13314     JSValueRegsTemporary result(this);
13315 
13316     GPRReg indexGPR = index.gpr();
13317     GPRReg enumeratorGPR = enumerator.gpr();
13318     GPRReg scratchGPR = scratch.gpr();
13319     JSValueRegs resultRegs = result.regs();
13320 
13321     MacroAssembler::JumpList slowPath;
13322 
13323     // Check the structure
13324     m_jit.load32(MacroAssembler::Address(baseGPR, JSCell::structureIDOffset()), scratchGPR);
13325     slowPath.append(
13326         m_jit.branch32(
13327             MacroAssembler::NotEqual,
13328             scratchGPR,
13329             MacroAssembler::Address(
</pre>
<hr />
<pre>
13333     // If index is less than the enumerator&#39;s cached inline storage, then it&#39;s an inline access
13334     MacroAssembler::Jump outOfLineAccess = m_jit.branch32(MacroAssembler::AboveOrEqual,
13335         indexGPR, MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()));
13336 
13337     m_jit.loadValue(MacroAssembler::BaseIndex(baseGPR, indexGPR, MacroAssembler::TimesEight, JSObject::offsetOfInlineStorage()), resultRegs);
13338 
13339     MacroAssembler::Jump done = m_jit.jump();
13340 
13341     // Otherwise it&#39;s out of line
13342     outOfLineAccess.link(&amp;m_jit);
13343     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), resultRegs.payloadGPR());
13344     m_jit.move(indexGPR, scratchGPR);
13345     m_jit.sub32(MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()), scratchGPR);
13346     m_jit.neg32(scratchGPR);
13347     m_jit.signExtend32ToPtr(scratchGPR, scratchGPR);
13348     int32_t offsetOfFirstProperty = static_cast&lt;int32_t&gt;(offsetInButterfly(firstOutOfLineOffset)) * sizeof(EncodedJSValue);
13349     m_jit.loadValue(MacroAssembler::BaseIndex(resultRegs.payloadGPR(), scratchGPR, MacroAssembler::TimesEight, offsetOfFirstProperty), resultRegs);
13350 
13351     done.link(&amp;m_jit);
13352 
<span class="line-modified">13353     addSlowPathGenerator(slowPathCall(slowPath, this, operationGetByValCell, resultRegs, baseGPR, CCallHelpers::CellValue(propertyGPR)));</span>
13354 
13355     jsValueResult(resultRegs, node);
<span class="line-removed">13356 #endif</span>
13357 }
13358 
13359 void SpeculativeJIT::compileExtractCatchLocal(Node* node)
13360 {
13361     JSValueRegsTemporary result(this);
13362     JSValueRegs resultRegs = result.regs();
13363 
13364     JSValue* ptr = &amp;reinterpret_cast&lt;JSValue*&gt;(m_jit.jitCode()-&gt;common.catchOSREntryBuffer-&gt;dataBuffer())[node-&gt;catchOSREntryIndex()];
13365     m_jit.loadValue(ptr, resultRegs);
13366     jsValueResult(resultRegs, node);
13367 }
13368 
13369 void SpeculativeJIT::compileClearCatchLocals(Node* node)
13370 {
13371     ScratchBuffer* scratchBuffer = m_jit.jitCode()-&gt;common.catchOSREntryBuffer;
13372     ASSERT(scratchBuffer);
13373     GPRTemporary scratch(this);
13374     GPRReg scratchGPR = scratch.gpr();
13375     m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratchGPR);
13376     m_jit.storePtr(TrustedImmPtr(nullptr), scratchGPR);
</pre>
<hr />
<pre>
13423     m_jit.storeValue(valueRegs, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::valueOffset()));
13424 
13425     // Store the structureID of the cell if valueRegs is a cell, otherwise, store 0 on the log entry.
13426     MacroAssembler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
13427     m_jit.load32(MacroAssembler::Address(valueRegs.payloadGPR(), JSCell::structureIDOffset()), scratch3GPR);
13428     m_jit.store32(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13429     MacroAssembler::Jump skipIsCell = m_jit.jump();
13430     isNotCell.link(&amp;m_jit);
13431     m_jit.store32(TrustedImm32(0), MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13432     skipIsCell.link(&amp;m_jit);
13433 
13434     // Store the typeLocation on the log entry.
13435     m_jit.move(TrustedImmPtr(cachedTypeLocation), scratch3GPR);
13436     m_jit.storePtr(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::locationOffset()));
13437 
13438     // Increment the current log entry.
13439     m_jit.addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), scratch1GPR);
13440     m_jit.storePtr(scratch1GPR, MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()));
13441     MacroAssembler::Jump clearLog = m_jit.branchPtr(MacroAssembler::Equal, scratch1GPR, TrustedImmPtr(cachedTypeProfilerLog-&gt;logEndPtr()));
13442     addSlowPathGenerator(
<span class="line-modified">13443         slowPathCall(clearLog, this, operationProcessTypeProfilerLogDFG, NoResult));</span>
13444 
13445     jumpToEnd.link(&amp;m_jit);
13446 
13447     noResult(node);
13448 }
13449 
13450 void SpeculativeJIT::cachedPutById(CodeOrigin codeOrigin, GPRReg baseGPR, JSValueRegs valueRegs, GPRReg scratchGPR, unsigned identifierNumber, PutKind putKind, JITCompiler::Jump slowPathTarget, SpillRegistersMode spillMode)
13451 {
13452     RegisterSet usedRegisters = this-&gt;usedRegisters();
13453     if (spillMode == DontSpill) {
13454         // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
13455         usedRegisters.set(baseGPR, false);
13456         usedRegisters.set(valueRegs, false);
13457     }
13458     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
13459     JITPutByIdGenerator gen(
13460         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters,
13461         JSValueRegs::payloadOnly(baseGPR), valueRegs,
13462         scratchGPR, m_jit.ecmaModeFor(codeOrigin), putKind);
13463 
13464     gen.generateFastPath(m_jit);
13465 
13466     JITCompiler::JumpList slowCases;
13467     if (slowPathTarget.isSet())
13468         slowCases.append(slowPathTarget);
13469     slowCases.append(gen.slowPathJump());
13470 
13471     auto slowPath = slowPathCall(
<span class="line-modified">13472         slowCases, this, gen.slowPathFunction(), NoResult, gen.stubInfo(), valueRegs,</span>
13473         CCallHelpers::CellValue(baseGPR), identifierUID(identifierNumber));
13474 
13475     m_jit.addPutById(gen, slowPath.get());
13476     addSlowPathGenerator(WTFMove(slowPath));
13477 }
13478 
<span class="line-modified">13479 void SpeculativeJIT::nonSpeculativeNonPeepholeCompare(Node* node, MacroAssembler::RelationalCondition cond, S_JITOperation_EJJ helperFunction)</span>
13480 {
13481     ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
13482     JSValueOperand arg1(this, node-&gt;child1());
13483     JSValueOperand arg2(this, node-&gt;child2());
13484 
13485     JSValueRegs arg1Regs = arg1.jsValueRegs();
13486     JSValueRegs arg2Regs = arg2.jsValueRegs();
13487 
13488     JITCompiler::JumpList slowPath;
13489 
13490     if (isKnownNotInteger(node-&gt;child1().node()) || isKnownNotInteger(node-&gt;child2().node())) {
13491         GPRFlushedCallResult result(this);
13492         GPRReg resultGPR = result.gpr();
13493 
13494         arg1.use();
13495         arg2.use();
13496 
13497         flushRegisters();
<span class="line-modified">13498         callOperation(helperFunction, resultGPR, arg1Regs, arg2Regs);</span>
13499         m_jit.exceptionCheck();
13500 
13501         unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13502         return;
13503     }
13504 
13505     GPRTemporary result(this, Reuse, arg1, TagWord);
13506     GPRReg resultGPR = result.gpr();
13507 
13508     arg1.use();
13509     arg2.use();
13510 
13511     if (!isKnownInteger(node-&gt;child1().node()))
13512         slowPath.append(m_jit.branchIfNotInt32(arg1Regs));
13513     if (!isKnownInteger(node-&gt;child2().node()))
13514         slowPath.append(m_jit.branchIfNotInt32(arg2Regs));
13515 
13516     m_jit.compare32(cond, arg1Regs.payloadGPR(), arg2Regs.payloadGPR(), resultGPR);
13517 
13518     if (!isKnownInteger(node-&gt;child1().node()) || !isKnownInteger(node-&gt;child2().node()))
<span class="line-modified">13519         addSlowPathGenerator(slowPathCall(slowPath, this, helperFunction, resultGPR, arg1Regs, arg2Regs));</span>
13520 
13521     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13522 }
13523 
<span class="line-modified">13524 void SpeculativeJIT::nonSpeculativePeepholeBranch(Node* node, Node* branchNode, MacroAssembler::RelationalCondition cond, S_JITOperation_EJJ helperFunction)</span>
13525 {
13526     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
13527     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
13528 
13529     JITCompiler::ResultCondition callResultCondition = JITCompiler::NonZero;
13530 
13531     // The branch instruction will branch to the taken block.
13532     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
13533     if (taken == nextBlock()) {
13534         cond = JITCompiler::invert(cond);
13535         callResultCondition = JITCompiler::Zero;
13536         BasicBlock* tmp = taken;
13537         taken = notTaken;
13538         notTaken = tmp;
13539     }
13540 
13541     JSValueOperand arg1(this, node-&gt;child1());
13542     JSValueOperand arg2(this, node-&gt;child2());
13543     JSValueRegs arg1Regs = arg1.jsValueRegs();
13544     JSValueRegs arg2Regs = arg2.jsValueRegs();
13545 
13546     JITCompiler::JumpList slowPath;
13547 
13548     if (isKnownNotInteger(node-&gt;child1().node()) || isKnownNotInteger(node-&gt;child2().node())) {
13549         GPRFlushedCallResult result(this);
13550         GPRReg resultGPR = result.gpr();
13551 
13552         arg1.use();
13553         arg2.use();
13554 
13555         flushRegisters();
<span class="line-modified">13556         callOperation(helperFunction, resultGPR, arg1Regs, arg2Regs);</span>
13557         m_jit.exceptionCheck();
13558 
13559         branchTest32(callResultCondition, resultGPR, taken);
13560     } else {
13561         GPRTemporary result(this, Reuse, arg2, TagWord);
13562         GPRReg resultGPR = result.gpr();
13563 
13564         arg1.use();
13565         arg2.use();
13566 
13567         if (!isKnownInteger(node-&gt;child1().node()))
13568             slowPath.append(m_jit.branchIfNotInt32(arg1Regs));
13569         if (!isKnownInteger(node-&gt;child2().node()))
13570             slowPath.append(m_jit.branchIfNotInt32(arg2Regs));
13571 
13572         branch32(cond, arg1Regs.payloadGPR(), arg2Regs.payloadGPR(), taken);
13573 
13574         if (!isKnownInteger(node-&gt;child1().node()) || !isKnownInteger(node-&gt;child2().node())) {
13575             jump(notTaken, ForceJump);
13576 
13577             slowPath.link(&amp;m_jit);
13578 
13579             silentSpillAllRegisters(resultGPR);
<span class="line-modified">13580             callOperation(helperFunction, resultGPR, arg1Regs, arg2Regs);</span>
13581             silentFillAllRegisters();
13582             m_jit.exceptionCheck();
13583 
13584             branchTest32(callResultCondition, resultGPR, taken);
13585         }
13586     }
13587 
13588     jump(notTaken);
13589 
13590     m_indexInBlock = m_block-&gt;size() - 1;
13591     m_currentNode = branchNode;
13592 }
13593 
13594 void SpeculativeJIT::compileBigIntEquality(Node* node)
13595 {
13596     // FIXME: [ESNext][BigInt] Create specialized version of strict equals for BigIntUse
13597     // https://bugs.webkit.org/show_bug.cgi?id=182895
13598     SpeculateCellOperand left(this, node-&gt;child1());
13599     SpeculateCellOperand right(this, node-&gt;child2());
13600     GPRTemporary result(this, Reuse, left);
13601     GPRReg leftGPR = left.gpr();
13602     GPRReg rightGPR = right.gpr();
13603     GPRReg resultGPR = result.gpr();
13604 
13605     left.use();
13606     right.use();
13607 
13608     speculateBigInt(node-&gt;child1(), leftGPR);
13609     speculateBigInt(node-&gt;child2(), rightGPR);
13610 
13611     JITCompiler::Jump notEqualCase = m_jit.branchPtr(JITCompiler::NotEqual, leftGPR, rightGPR);
13612 
13613     m_jit.move(JITCompiler::TrustedImm32(1), resultGPR);
13614 
13615     JITCompiler::Jump done = m_jit.jump();
13616 
13617     notEqualCase.link(&amp;m_jit);
13618 
13619     silentSpillAllRegisters(resultGPR);
<span class="line-modified">13620     callOperation(operationCompareStrictEqCell, resultGPR, leftGPR, rightGPR);</span>
13621     silentFillAllRegisters();
13622 
13623     done.link(&amp;m_jit);
13624 
13625     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13626 }
13627 
13628 void SpeculativeJIT::compileMakeRope(Node* node)
13629 {
13630     ASSERT(node-&gt;child1().useKind() == KnownStringUse);
13631     ASSERT(node-&gt;child2().useKind() == KnownStringUse);
13632     ASSERT(!node-&gt;child3() || node-&gt;child3().useKind() == KnownStringUse);
13633 
13634     SpeculateCellOperand op1(this, node-&gt;child1());
13635     SpeculateCellOperand op2(this, node-&gt;child2());
13636     SpeculateCellOperand op3(this, node-&gt;child3());
13637     GPRReg opGPRs[3];
13638     unsigned numOpGPRs;
13639     opGPRs[0] = op1.gpr();
13640     opGPRs[1] = op2.gpr();
</pre>
<hr />
<pre>
13676         } else {
13677             bool needsRopeCase = canBeRope(edges[0]);
13678             m_jit.loadPtr(CCallHelpers::Address(opGPRs[0], JSString::offsetOfValue()), scratch2GPR);
13679             CCallHelpers::Jump isRope;
13680             if (needsRopeCase)
13681                 isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
13682 
13683             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);
13684             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR);
13685 
13686             if (needsRopeCase) {
13687                 auto done = m_jit.jump();
13688 
13689                 isRope.link(&amp;m_jit);
13690                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfFlags()), scratchGPR);
13691                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfLength()), allocatorGPR);
13692                 done.link(&amp;m_jit);
13693             }
13694         }
13695 
<span class="line-modified">13696         if (!ASSERT_DISABLED) {</span>
13697             CCallHelpers::Jump ok = m_jit.branch32(
13698                 CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
13699             m_jit.abortWithReason(DFGNegativeStringLength);
13700             ok.link(&amp;m_jit);
13701         }
13702     }
13703 
13704     for (unsigned i = 1; i &lt; numOpGPRs; ++i) {
13705         if (JSString* string = edges[i]-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
13706             m_jit.and32(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
13707             speculationCheck(
13708                 Uncountable, JSValueSource(), nullptr,
13709                 m_jit.branchAdd32(
13710                     CCallHelpers::Overflow,
13711                     TrustedImm32(string-&gt;length()), allocatorGPR));
13712         } else {
13713             bool needsRopeCase = canBeRope(edges[i]);
13714             m_jit.loadPtr(CCallHelpers::Address(opGPRs[i], JSString::offsetOfValue()), scratch2GPR);
13715             CCallHelpers::Jump isRope;
13716             if (needsRopeCase)
</pre>
<hr />
<pre>
13720             speculationCheck(
13721                 Uncountable, JSValueSource(), nullptr,
13722                 m_jit.branchAdd32(
13723                     CCallHelpers::Overflow,
13724                     CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR));
13725             if (needsRopeCase) {
13726                 auto done = m_jit.jump();
13727 
13728                 isRope.link(&amp;m_jit);
13729                 m_jit.and32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfFlags()), scratchGPR);
13730                 m_jit.load32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfLength()), scratch2GPR);
13731                 speculationCheck(
13732                     Uncountable, JSValueSource(), nullptr,
13733                     m_jit.branchAdd32(
13734                         CCallHelpers::Overflow, scratch2GPR, allocatorGPR));
13735                 done.link(&amp;m_jit);
13736             }
13737         }
13738     }
13739 
<span class="line-modified">13740     if (!ASSERT_DISABLED) {</span>
13741         CCallHelpers::Jump ok = m_jit.branch32(
13742             CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
13743         m_jit.abortWithReason(DFGNegativeStringLength);
13744         ok.link(&amp;m_jit);
13745     }
13746 
13747     static_assert(StringImpl::flagIs8Bit() == JSRopeString::is8BitInPointer, &quot;&quot;);
13748     m_jit.and32(TrustedImm32(StringImpl::flagIs8Bit()), scratchGPR);
13749     m_jit.orPtr(opGPRs[0], scratchGPR);
13750     m_jit.orPtr(TrustedImmPtr(JSString::isRopeInPointer), scratchGPR);
13751     m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));
13752 
13753     m_jit.move(opGPRs[1], scratchGPR);
13754     m_jit.lshiftPtr(TrustedImm32(32), scratchGPR);
13755     m_jit.orPtr(allocatorGPR, scratchGPR);
13756     m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber1()));
13757 
13758     if (numOpGPRs == 2) {
13759         m_jit.move(opGPRs[1], scratchGPR);
13760         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);
13761         m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2()));
13762     } else {
13763         m_jit.move(opGPRs[1], scratchGPR);
13764         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);
13765         m_jit.move(opGPRs[2], scratch2GPR);
13766         m_jit.lshiftPtr(TrustedImm32(16), scratch2GPR);
13767         m_jit.orPtr(scratch2GPR, scratchGPR);
13768         m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2()));
13769     }
13770 
13771     auto isNonEmptyString = m_jit.branchTest32(CCallHelpers::NonZero, allocatorGPR);
13772 
13773     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.graph().m_vm)), resultGPR);
13774 
13775     isNonEmptyString.link(&amp;m_jit);
13776     m_jit.mutatorFence(vm());
13777 
13778     switch (numOpGPRs) {
13779     case 2:
13780         addSlowPathGenerator(slowPathCall(
<span class="line-modified">13781             slowPath, this, operationMakeRope2, resultGPR, opGPRs[0], opGPRs[1]));</span>
13782         break;
13783     case 3:
13784         addSlowPathGenerator(slowPathCall(
<span class="line-modified">13785             slowPath, this, operationMakeRope3, resultGPR, opGPRs[0], opGPRs[1], opGPRs[2]));</span>
13786         break;
13787     default:
13788         RELEASE_ASSERT_NOT_REACHED();
13789         break;
13790     }
13791 
13792     cellResult(resultGPR, node);
13793 #else
13794     flushRegisters();
13795     GPRFlushedCallResult result(this);
13796     GPRReg resultGPR = result.gpr();
13797     switch (numOpGPRs) {
13798     case 2:
<span class="line-modified">13799         callOperation(operationMakeRope2, resultGPR, opGPRs[0], opGPRs[1]);</span>
13800         m_jit.exceptionCheck();
13801         break;
13802     case 3:
<span class="line-modified">13803         callOperation(operationMakeRope3, resultGPR, opGPRs[0], opGPRs[1], opGPRs[2]);</span>
13804         m_jit.exceptionCheck();
13805         break;
13806     default:
13807         RELEASE_ASSERT_NOT_REACHED();
13808         break;
13809     }
13810 
13811     cellResult(resultGPR, node);
13812 #endif
13813 }
13814 
13815 } } // namespace JSC::DFG
13816 
13817 #endif
</pre>
</td>
<td>
<hr />
<pre>
   22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   24  */
   25 
   26 #include &quot;config.h&quot;
   27 #include &quot;DFGSpeculativeJIT.h&quot;
   28 
   29 #if ENABLE(DFG_JIT)
   30 
   31 #include &quot;BinarySwitch.h&quot;
   32 #include &quot;DFGAbstractInterpreterInlines.h&quot;
   33 #include &quot;DFGArrayifySlowPathGenerator.h&quot;
   34 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
   35 #include &quot;DFGCallCreateDirectArgumentsSlowPathGenerator.h&quot;
   36 #include &quot;DFGCapabilities.h&quot;
   37 #include &quot;DFGMayExit.h&quot;
   38 #include &quot;DFGOSRExitFuzz.h&quot;
   39 #include &quot;DFGSaneStringGetByValSlowPathGenerator.h&quot;
   40 #include &quot;DFGSlowPathGenerator.h&quot;
   41 #include &quot;DFGSnippetParams.h&quot;
<span class="line-added">   42 #include &quot;DateInstance.h&quot;</span>
   43 #include &quot;DirectArguments.h&quot;
   44 #include &quot;DisallowMacroScratchRegisterUsage.h&quot;
   45 #include &quot;JITAddGenerator.h&quot;
   46 #include &quot;JITBitAndGenerator.h&quot;
   47 #include &quot;JITBitOrGenerator.h&quot;
   48 #include &quot;JITBitXorGenerator.h&quot;
   49 #include &quot;JITDivGenerator.h&quot;
   50 #include &quot;JITLeftShiftGenerator.h&quot;
   51 #include &quot;JITMulGenerator.h&quot;
   52 #include &quot;JITRightShiftGenerator.h&quot;
   53 #include &quot;JITSubGenerator.h&quot;
<span class="line-added">   54 #include &quot;JSArrayIterator.h&quot;</span>
   55 #include &quot;JSAsyncFunction.h&quot;
   56 #include &quot;JSAsyncGeneratorFunction.h&quot;
   57 #include &quot;JSCInlines.h&quot;

   58 #include &quot;JSGeneratorFunction.h&quot;
   59 #include &quot;JSImmutableButterfly.h&quot;
   60 #include &quot;JSLexicalEnvironment.h&quot;
   61 #include &quot;JSPropertyNameEnumerator.h&quot;
   62 #include &quot;LinkBuffer.h&quot;
   63 #include &quot;RegExpObject.h&quot;
   64 #include &quot;ScopedArguments.h&quot;
   65 #include &quot;ScratchRegisterAllocator.h&quot;
   66 #include &quot;SuperSampler.h&quot;
   67 #include &quot;TypeProfilerLog.h&quot;
   68 #include &quot;WeakMapImpl.h&quot;
   69 #include &lt;wtf/BitVector.h&gt;
   70 #include &lt;wtf/Box.h&gt;
   71 #include &lt;wtf/MathExtras.h&gt;
   72 
   73 namespace JSC { namespace DFG {
   74 
<span class="line-added">   75 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SpeculativeJIT);</span>
<span class="line-added">   76 </span>
   77 SpeculativeJIT::SpeculativeJIT(JITCompiler&amp; jit)
   78     : m_jit(jit)
   79     , m_graph(m_jit.graph())
   80     , m_currentNode(0)
   81     , m_lastGeneratedNode(LastNodeType)
   82     , m_indexInBlock(0)
   83     , m_generationInfo(m_jit.graph().frameRegisterCount())
   84     , m_compileOkay(true)
   85     , m_state(m_jit.graph())
   86     , m_interpreter(m_jit.graph(), m_state)
   87     , m_stream(&amp;jit.jitCode()-&gt;variableEventStream)
   88     , m_minifiedGraph(&amp;jit.jitCode()-&gt;minifiedDFG)
   89 {
   90 }
   91 
   92 SpeculativeJIT::~SpeculativeJIT()
   93 {
   94 }
   95 
   96 void SpeculativeJIT::emitAllocateRawObject(GPRReg resultGPR, RegisteredStructure structure, GPRReg storageGPR, unsigned numElements, unsigned vectorLength)
</pre>
<hr />
<pre>
  656 #endif // USE(JSVALUE64)
  657     case SetBooleanConstant:
  658         m_jit.move(TrustedImm32(plan.node()-&gt;asBoolean()), plan.gpr());
  659         break;
  660     case SetCellConstant:
  661         ASSERT(plan.node()-&gt;constant()-&gt;value().isCell());
  662         m_jit.move(TrustedImmPtr(plan.node()-&gt;constant()), plan.gpr());
  663         break;
  664 #if USE(JSVALUE64)
  665     case SetTrustedJSConstant:
  666         m_jit.move(valueOfJSConstantAsImm64(plan.node()).asTrustedImm64(), plan.gpr());
  667         break;
  668     case SetJSConstant:
  669         m_jit.move(valueOfJSConstantAsImm64(plan.node()), plan.gpr());
  670         break;
  671     case SetDoubleConstant:
  672         m_jit.moveDouble(Imm64(reinterpretDoubleToInt64(plan.node()-&gt;asNumber())), plan.fpr());
  673         break;
  674     case Load32PayloadBoxInt:
  675         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
<span class="line-modified">  676         m_jit.or64(GPRInfo::numberTagRegister, plan.gpr());</span>
  677         break;
  678     case Load32PayloadConvertToInt52:
  679         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  680         m_jit.signExtend32ToPtr(plan.gpr(), plan.gpr());
  681         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), plan.gpr());
  682         break;
  683     case Load32PayloadSignExtend:
  684         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  685         m_jit.signExtend32ToPtr(plan.gpr(), plan.gpr());
  686         break;
  687 #else
  688     case SetJSConstantTag:
  689         m_jit.move(Imm32(plan.node()-&gt;asJSValue().tag()), plan.gpr());
  690         break;
  691     case SetJSConstantPayload:
  692         m_jit.move(Imm32(plan.node()-&gt;asJSValue().payload()), plan.gpr());
  693         break;
  694     case SetInt32Tag:
  695         m_jit.move(TrustedImm32(JSValue::Int32Tag), plan.gpr());
  696         break;
</pre>
<hr />
<pre>
  812                 TrustedImm32(SlowPutArrayStorageShape - ArrayStorageShape)));
  813         return result;
  814     }
  815     default:
  816         CRASH();
  817         break;
  818     }
  819 
  820     return result;
  821 }
  822 
  823 void SpeculativeJIT::checkArray(Node* node)
  824 {
  825     ASSERT(node-&gt;arrayMode().isSpecific());
  826     ASSERT(!node-&gt;arrayMode().doesConversion());
  827 
  828     SpeculateCellOperand base(this, node-&gt;child1());
  829     GPRReg baseReg = base.gpr();
  830 
  831     if (node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1()))) {
<span class="line-added">  832         // We can purge Empty check completely in this case of CheckArrayOrEmpty since CellUse only accepts SpecCell | SpecEmpty.</span>
<span class="line-added">  833         ASSERT(typeFilterFor(node-&gt;child1().useKind()) &amp; SpecEmpty);</span>
  834         noResult(m_currentNode);
  835         return;
  836     }
  837 
<span class="line-added">  838     Optional&lt;GPRTemporary&gt; temp;</span>
<span class="line-added">  839     Optional&lt;GPRReg&gt; tempGPR;</span>
<span class="line-added">  840     switch (node-&gt;arrayMode().type()) {</span>
<span class="line-added">  841     case Array::Int32:</span>
<span class="line-added">  842     case Array::Double:</span>
<span class="line-added">  843     case Array::Contiguous:</span>
<span class="line-added">  844     case Array::Undecided:</span>
<span class="line-added">  845     case Array::ArrayStorage:</span>
<span class="line-added">  846     case Array::SlowPutArrayStorage: {</span>
<span class="line-added">  847         temp.emplace(this);</span>
<span class="line-added">  848         tempGPR = temp-&gt;gpr();</span>
<span class="line-added">  849         break;</span>
<span class="line-added">  850     }</span>
<span class="line-added">  851     default:</span>
<span class="line-added">  852         break;</span>
<span class="line-added">  853     }</span>
<span class="line-added">  854 </span>
<span class="line-added">  855     CCallHelpers::Jump isEmpty;</span>
<span class="line-added">  856 </span>
<span class="line-added">  857 #if USE(JSVALUE64)</span>
<span class="line-added">  858     if (node-&gt;op() == CheckArrayOrEmpty) {</span>
<span class="line-added">  859         if (m_interpreter.forNode(node-&gt;child1()).m_type &amp; SpecEmpty)</span>
<span class="line-added">  860             isEmpty = m_jit.branchIfEmpty(baseReg);</span>
<span class="line-added">  861     }</span>
<span class="line-added">  862 #endif</span>
<span class="line-added">  863 </span>
  864     switch (node-&gt;arrayMode().type()) {
  865     case Array::AnyTypedArray:
  866     case Array::String:
  867         RELEASE_ASSERT_NOT_REACHED(); // Should have been a Phantom(String:)
  868         return;
  869     case Array::Int32:
  870     case Array::Double:
  871     case Array::Contiguous:
  872     case Array::Undecided:
  873     case Array::ArrayStorage:
  874     case Array::SlowPutArrayStorage: {
<span class="line-modified">  875         m_jit.load8(MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR.value());</span>


  876         speculationCheck(
  877             BadIndexingType, JSValueSource::unboxedCell(baseReg), 0,
<span class="line-modified">  878             jumpSlowForUnwantedArrayMode(tempGPR.value(), node-&gt;arrayMode()));</span>
<span class="line-modified">  879         break;</span>


  880     }
  881     case Array::DirectArguments:
  882         speculateCellTypeWithoutTypeFiltering(node-&gt;child1(), baseReg, DirectArgumentsType);
<span class="line-modified">  883         break;</span>

  884     case Array::ScopedArguments:
  885         speculateCellTypeWithoutTypeFiltering(node-&gt;child1(), baseReg, ScopedArgumentsType);
<span class="line-modified">  886         break;</span>

  887     default:
  888         speculateCellTypeWithoutTypeFiltering(
  889             node-&gt;child1(), baseReg,
  890             typeForTypedArrayType(node-&gt;arrayMode().typedArrayType()));
<span class="line-modified">  891         break;</span>

  892     }
<span class="line-added">  893 </span>
<span class="line-added">  894     if (isEmpty.isSet())</span>
<span class="line-added">  895         isEmpty.link(&amp;m_jit);</span>
<span class="line-added">  896     noResult(m_currentNode);</span>
  897 }
  898 
  899 void SpeculativeJIT::arrayify(Node* node, GPRReg baseReg, GPRReg propertyReg)
  900 {
  901     ASSERT(node-&gt;arrayMode().doesConversion());
  902 
  903     GPRTemporary temp(this);
  904     GPRTemporary structure;
  905     GPRReg tempGPR = temp.gpr();
  906     GPRReg structureGPR = InvalidGPRReg;
  907 
  908     if (node-&gt;op() != ArrayifyToStructure) {
  909         GPRTemporary realStructure(this);
  910         structure.adopt(realStructure);
  911         structureGPR = structure.gpr();
  912     }
  913 
  914     // We can skip all that comes next if we already have array storage.
  915     MacroAssembler::JumpList slowPath;
  916 
</pre>
<hr />
<pre>
  994             return;
  995         }
  996         use(child1);
  997 
  998         Edge child2 = node-&gt;child2();
  999         if (!child2) {
 1000             ASSERT(!node-&gt;child3());
 1001             return;
 1002         }
 1003         use(child2);
 1004 
 1005         Edge child3 = node-&gt;child3();
 1006         if (!child3)
 1007             return;
 1008         use(child3);
 1009     }
 1010 }
 1011 
 1012 void SpeculativeJIT::compileGetById(Node* node, AccessType accessType)
 1013 {
<span class="line-modified"> 1014     ASSERT(accessType == AccessType::GetById || accessType == AccessType::GetByIdDirect || accessType == AccessType::TryGetById);</span>
 1015 
 1016     switch (node-&gt;child1().useKind()) {
 1017     case CellUse: {
 1018         SpeculateCellOperand base(this, node-&gt;child1());
 1019         JSValueRegsTemporary result(this, Reuse, base);
 1020 
 1021         JSValueRegs baseRegs = JSValueRegs::payloadOnly(base.gpr());
 1022         JSValueRegs resultRegs = result.regs();
 1023 
 1024         base.use();
 1025 
 1026         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), JITCompiler::Jump(), NeedToSpill, accessType);
 1027 
 1028         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1029         break;
 1030     }
 1031 
 1032     case UntypedUse: {
 1033         JSValueOperand base(this, node-&gt;child1());
 1034         JSValueRegsTemporary result(this, Reuse, base);
</pre>
<hr />
<pre>
 1101 {
 1102     SpeculateCellOperand base(this, node-&gt;child1());
 1103     JSValueRegsTemporary result(this, Reuse, base, PayloadWord);
 1104 
 1105     GPRReg baseGPR = base.gpr();
 1106     JSValueRegs resultRegs = result.regs();
 1107 
 1108     base.use();
 1109 
 1110     CodeOrigin codeOrigin = node-&gt;origin.semantic;
 1111     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 1112     RegisterSet usedRegisters = this-&gt;usedRegisters();
 1113     JITInByIdGenerator gen(
 1114         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(node-&gt;identifierNumber()),
 1115         JSValueRegs::payloadOnly(baseGPR), resultRegs);
 1116     gen.generateFastPath(m_jit);
 1117 
 1118     auto slowPath = slowPathCall(
 1119         gen.slowPathJump(), this, operationInByIdOptimize,
 1120         NeedToSpill, ExceptionCheckRequirement::CheckNeeded,
<span class="line-modified"> 1121         resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), gen.stubInfo(), CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;identifierNumber()));</span>
 1122 
 1123     m_jit.addInById(gen, slowPath.get());
 1124     addSlowPathGenerator(WTFMove(slowPath));
 1125 
 1126     blessedBooleanResult(resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
 1127 }
 1128 
 1129 void SpeculativeJIT::compileInByVal(Node* node)
 1130 {
 1131     SpeculateCellOperand base(this, node-&gt;child1());
 1132     JSValueOperand key(this, node-&gt;child2());
 1133 
 1134     GPRReg baseGPR = base.gpr();
 1135     JSValueRegs regs = key.jsValueRegs();
 1136 
 1137     base.use();
 1138     key.use();
 1139 
 1140     flushRegisters();
 1141     JSValueRegsFlushedCallResult result(this);
 1142     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 1143     callOperation(operationInByVal, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, regs);</span>
 1144     m_jit.exceptionCheck();
 1145     blessedBooleanResult(resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
 1146 }
 1147 
 1148 void SpeculativeJIT::compileDeleteById(Node* node)
 1149 {
 1150     JSValueOperand value(this, node-&gt;child1());
 1151     GPRFlushedCallResult result(this);
 1152 
 1153     JSValueRegs valueRegs = value.jsValueRegs();
 1154     GPRReg resultGPR = result.gpr();
 1155 
 1156     value.use();
 1157 
 1158     flushRegisters();
<span class="line-modified"> 1159     callOperation(operationDeleteById, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, identifierUID(node-&gt;identifierNumber()));</span>
 1160     m_jit.exceptionCheck();
 1161 
 1162     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 1163 }
 1164 
 1165 void SpeculativeJIT::compileDeleteByVal(Node* node)
 1166 {
 1167     JSValueOperand base(this, node-&gt;child1());
 1168     JSValueOperand key(this, node-&gt;child2());
 1169     GPRFlushedCallResult result(this);
 1170 
 1171     JSValueRegs baseRegs = base.jsValueRegs();
 1172     JSValueRegs keyRegs = key.jsValueRegs();
 1173     GPRReg resultGPR = result.gpr();
 1174 
 1175     base.use();
 1176     key.use();
 1177 
 1178     flushRegisters();
<span class="line-modified"> 1179     callOperation(operationDeleteByVal, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, keyRegs);</span>
 1180     m_jit.exceptionCheck();
 1181 
 1182     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 1183 }
 1184 
 1185 void SpeculativeJIT::compilePushWithScope(Node* node)
 1186 {
 1187     SpeculateCellOperand currentScope(this, node-&gt;child1());
 1188     GPRReg currentScopeGPR = currentScope.gpr();
 1189 
 1190     GPRFlushedCallResult result(this);
 1191     GPRReg resultGPR = result.gpr();
 1192 
 1193     auto objectEdge = node-&gt;child2();
 1194     if (objectEdge.useKind() == ObjectUse) {
 1195         SpeculateCellOperand object(this, objectEdge);
 1196         GPRReg objectGPR = object.gpr();
 1197         speculateObject(objectEdge, objectGPR);
 1198 
 1199         flushRegisters();
<span class="line-modified"> 1200         callOperation(operationPushWithScopeObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), currentScopeGPR, objectGPR);</span>
 1201         // No exception check here as we did not have to call toObject().
 1202     } else {
 1203         ASSERT(objectEdge.useKind() == UntypedUse);
 1204         JSValueOperand object(this, objectEdge);
 1205         JSValueRegs objectRegs = object.jsValueRegs();
 1206 
 1207         flushRegisters();
<span class="line-modified"> 1208         callOperation(operationPushWithScope, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), currentScopeGPR, objectRegs);</span>
 1209         m_jit.exceptionCheck();
 1210     }
 1211 
 1212     cellResult(resultGPR, node);
 1213 }
 1214 
 1215 bool SpeculativeJIT::nonSpeculativeStrictEq(Node* node, bool invert)
 1216 {
 1217     unsigned branchIndexInBlock = detectPeepHoleBranch();
 1218     if (branchIndexInBlock != UINT_MAX) {
 1219         Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 1220 
 1221         ASSERT(node-&gt;adjustedRefCount() == 1);
 1222 
 1223         nonSpeculativePeepholeStrictEq(node, branchNode, invert);
 1224 
 1225         m_indexInBlock = branchIndexInBlock;
 1226         m_currentNode = branchNode;
 1227 
 1228         return true;
</pre>
<hr />
<pre>
 1615 
 1616     // Load the character into scratchReg
 1617     m_jit.zeroExtend32ToPtr(startIndexGPR, startIndexGPR);
 1618     auto is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(temp2GPR, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 1619 
 1620     m_jit.load8(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesOne, 0), tempGPR);
 1621     auto cont8Bit = m_jit.jump();
 1622 
 1623     is16Bit.link(&amp;m_jit);
 1624     m_jit.load16(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesTwo, 0), tempGPR);
 1625 
 1626     auto bigCharacter = m_jit.branch32(MacroAssembler::Above, tempGPR, TrustedImm32(maxSingleCharacterString));
 1627 
 1628     // 8 bit string values don&#39;t need the isASCII check.
 1629     cont8Bit.link(&amp;m_jit);
 1630 
 1631     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), tempGPR);
 1632     m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), tempGPR);
 1633     m_jit.loadPtr(tempGPR, tempGPR);
 1634 
<span class="line-modified"> 1635     addSlowPathGenerator(slowPathCall(bigCharacter, this, operationSingleCharacterString, tempGPR, &amp;vm, tempGPR));</span>
 1636 
<span class="line-modified"> 1637     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringSubstr, tempGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, startIndexGPR, tempGPR));</span>
 1638 
 1639     if (endGPR)
<span class="line-modified"> 1640         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, startGPR, *endGPR));</span>
 1641     else
<span class="line-modified"> 1642         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, startGPR, TrustedImm32(std::numeric_limits&lt;int32_t&gt;::max())));</span>
 1643 
 1644     doneCases.link(&amp;m_jit);
 1645     cellResult(tempGPR, node);
 1646 }
 1647 
 1648 void SpeculativeJIT::compileToLowerCase(Node* node)
 1649 {
 1650     ASSERT(node-&gt;op() == ToLowerCase);
 1651     SpeculateCellOperand string(this, node-&gt;child1());
 1652     GPRTemporary temp(this);
 1653     GPRTemporary index(this);
 1654     GPRTemporary charReg(this);
 1655     GPRTemporary length(this);
 1656 
 1657     GPRReg stringGPR = string.gpr();
 1658     GPRReg tempGPR = temp.gpr();
 1659     GPRReg indexGPR = index.gpr();
 1660     GPRReg charGPR = charReg.gpr();
 1661     GPRReg lengthGPR = length.gpr();
 1662 
</pre>
<hr />
<pre>
 1669     m_jit.loadPtr(MacroAssembler::Address(stringGPR, JSString::offsetOfValue()), tempGPR);
 1670     slowPath.append(m_jit.branchIfRopeStringImpl(tempGPR));
 1671     slowPath.append(m_jit.branchTest32(
 1672         MacroAssembler::Zero, MacroAssembler::Address(tempGPR, StringImpl::flagsOffset()),
 1673         MacroAssembler::TrustedImm32(StringImpl::flagIs8Bit())));
 1674     m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
 1675     m_jit.loadPtr(MacroAssembler::Address(tempGPR, StringImpl::dataOffset()), tempGPR);
 1676 
 1677     auto loopStart = m_jit.label();
 1678     auto loopDone = m_jit.branch32(CCallHelpers::AboveOrEqual, indexGPR, lengthGPR);
 1679     m_jit.load8(MacroAssembler::BaseIndex(tempGPR, indexGPR, MacroAssembler::TimesOne), charGPR);
 1680     slowPath.append(m_jit.branchTest32(CCallHelpers::NonZero, charGPR, TrustedImm32(~0x7F)));
 1681     m_jit.sub32(TrustedImm32(&#39;A&#39;), charGPR);
 1682     slowPath.append(m_jit.branch32(CCallHelpers::BelowOrEqual, charGPR, TrustedImm32(&#39;Z&#39; - &#39;A&#39;)));
 1683 
 1684     m_jit.add32(TrustedImm32(1), indexGPR);
 1685     m_jit.jump().linkTo(loopStart, &amp;m_jit);
 1686 
 1687     slowPath.link(&amp;m_jit);
 1688     silentSpillAllRegisters(lengthGPR);
<span class="line-modified"> 1689     callOperation(operationToLowerCase, lengthGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, indexGPR);</span>
 1690     silentFillAllRegisters();
 1691     m_jit.exceptionCheck();
 1692     auto done = m_jit.jump();
 1693 
 1694     loopDone.link(&amp;m_jit);
 1695     m_jit.move(stringGPR, lengthGPR);
 1696 
 1697     done.link(&amp;m_jit);
 1698     cellResult(lengthGPR, node);
 1699 }
 1700 
 1701 void SpeculativeJIT::compilePeepHoleInt32Branch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
 1702 {
 1703     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1704     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1705 
 1706     // The branch instruction will branch to the taken block.
 1707     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 1708     if (taken == nextBlock()) {
 1709         condition = JITCompiler::invert(condition);
</pre>
<hr />
<pre>
 1713     }
 1714 
 1715     if (node-&gt;child1()-&gt;isInt32Constant()) {
 1716         int32_t imm = node-&gt;child1()-&gt;asInt32();
 1717         SpeculateInt32Operand op2(this, node-&gt;child2());
 1718         branch32(condition, JITCompiler::Imm32(imm), op2.gpr(), taken);
 1719     } else if (node-&gt;child2()-&gt;isInt32Constant()) {
 1720         SpeculateInt32Operand op1(this, node-&gt;child1());
 1721         int32_t imm = node-&gt;child2()-&gt;asInt32();
 1722         branch32(condition, op1.gpr(), JITCompiler::Imm32(imm), taken);
 1723     } else {
 1724         SpeculateInt32Operand op1(this, node-&gt;child1());
 1725         SpeculateInt32Operand op2(this, node-&gt;child2());
 1726         branch32(condition, op1.gpr(), op2.gpr(), taken);
 1727     }
 1728 
 1729     jump(notTaken);
 1730 }
 1731 
 1732 // Returns true if the compare is fused with a subsequent branch.
<span class="line-modified"> 1733 bool SpeculativeJIT::compilePeepHoleBranch(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_GJJ operation)</span>
 1734 {
 1735     // Fused compare &amp; branch.
 1736     unsigned branchIndexInBlock = detectPeepHoleBranch();
 1737     if (branchIndexInBlock != UINT_MAX) {
 1738         Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 1739 
 1740         // detectPeepHoleBranch currently only permits the branch to be the very next node,
 1741         // so can be no intervening nodes to also reference the compare.
 1742         ASSERT(node-&gt;adjustedRefCount() == 1);
 1743 
 1744         if (node-&gt;isBinaryUseKind(Int32Use))
 1745             compilePeepHoleInt32Branch(node, branchNode, condition);
 1746 #if USE(JSVALUE64)
 1747         else if (node-&gt;isBinaryUseKind(Int52RepUse))
 1748             compilePeepHoleInt52Branch(node, branchNode, condition);
 1749 #endif // USE(JSVALUE64)
 1750         else if (node-&gt;isBinaryUseKind(StringUse) || node-&gt;isBinaryUseKind(StringIdentUse)) {
 1751             // Use non-peephole comparison, for now.
 1752             return false;
 1753         } else if (node-&gt;isBinaryUseKind(DoubleRepUse))
</pre>
<hr />
<pre>
 1786 }
 1787 
 1788 void SpeculativeJIT::noticeOSRBirth(Node* node)
 1789 {
 1790     if (!node-&gt;hasVirtualRegister())
 1791         return;
 1792 
 1793     VirtualRegister virtualRegister = node-&gt;virtualRegister();
 1794     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 1795 
 1796     info.noticeOSRBirth(*m_stream, node, virtualRegister);
 1797 }
 1798 
 1799 void SpeculativeJIT::compileMovHint(Node* node)
 1800 {
 1801     ASSERT(node-&gt;containsMovHint() &amp;&amp; node-&gt;op() != ZombieHint);
 1802 
 1803     Node* child = node-&gt;child1().node();
 1804     noticeOSRBirth(child);
 1805 
<span class="line-modified"> 1806     m_stream-&gt;appendAndLog(VariableEvent::movHint(MinifiedID(child), node-&gt;unlinkedOperand()));</span>
<span class="line-added"> 1807 }</span>
<span class="line-added"> 1808 </span>
<span class="line-added"> 1809 void SpeculativeJIT::compileCheckNeutered(Node* node)</span>
<span class="line-added"> 1810 {</span>
<span class="line-added"> 1811     SpeculateCellOperand base(this, node-&gt;child1());</span>
<span class="line-added"> 1812     GPRReg baseReg = base.gpr();</span>
<span class="line-added"> 1813 </span>
<span class="line-added"> 1814     speculationCheck(</span>
<span class="line-added"> 1815         BadIndexingType, JSValueSource::unboxedCell(baseReg), node-&gt;child1(),</span>
<span class="line-added"> 1816         m_jit.branchTestPtr(MacroAssembler::Zero, MacroAssembler::Address(baseReg, JSArrayBufferView::offsetOfVector())));</span>
<span class="line-added"> 1817 </span>
<span class="line-added"> 1818     noResult(node);</span>
 1819 }
 1820 
 1821 void SpeculativeJIT::bail(AbortReason reason)
 1822 {
 1823     if (verboseCompilationEnabled())
 1824         dataLog(&quot;Bailing compilation.\n&quot;);
 1825     m_compileOkay = true;
 1826     m_jit.abortWithReason(reason, m_lastGeneratedNode);
 1827     clearGenerationInfo();
 1828 }
 1829 
 1830 void SpeculativeJIT::compileCurrentBlock()
 1831 {
 1832     ASSERT(m_compileOkay);
 1833 
 1834     if (!m_block)
 1835         return;
 1836 
 1837     ASSERT(m_block-&gt;isReachable);
 1838 
 1839     m_jit.blockHeads()[m_block-&gt;index] = m_jit.label();
 1840 
 1841     if (!m_block-&gt;intersectionOfCFAHasVisited) {
 1842         // Don&#39;t generate code for basic blocks that are unreachable according to CFA.
 1843         // But to be sure that nobody has generated a jump to this block, drop in a
 1844         // breakpoint here.
 1845         m_jit.abortWithReason(DFGUnreachableBasicBlock);
 1846         return;
 1847     }
 1848 
 1849     if (m_block-&gt;isCatchEntrypoint) {
 1850         m_jit.addPtr(CCallHelpers::TrustedImm32(-(m_jit.graph().frameRegisterCount() * sizeof(Register))), GPRInfo::callFrameRegister,  CCallHelpers::stackPointerRegister);


 1851         m_jit.emitSaveCalleeSaves();
 1852         m_jit.emitMaterializeTagCheckRegisters();
 1853         m_jit.emitPutToCallFrameHeader(m_jit.codeBlock(), CallFrameSlot::codeBlock);
 1854     }
 1855 
 1856     m_stream-&gt;appendAndLog(VariableEvent::reset());
 1857 
 1858     m_jit.jitAssertHasValidCallFrame();
 1859     m_jit.jitAssertTagsInPlace();
 1860     m_jit.jitAssertArgumentCountSane();
 1861 
 1862     m_state.reset();
 1863     m_state.beginBasicBlock(m_block);
 1864 
 1865     for (size_t i = m_block-&gt;variablesAtHead.size(); i--;) {
<span class="line-modified"> 1866         Operand operand = m_block-&gt;variablesAtHead.operandForIndex(i);</span>
 1867         Node* node = m_block-&gt;variablesAtHead[i];
 1868         if (!node)
 1869             continue; // No need to record dead SetLocal&#39;s.
 1870 
 1871         VariableAccessData* variable = node-&gt;variableAccessData();
 1872         DataFormat format;
 1873         if (!node-&gt;refCount())
 1874             continue; // No need to record dead SetLocal&#39;s.
 1875         format = dataFormatFor(variable-&gt;flushFormat());
<span class="line-modified"> 1876         DFG_ASSERT(m_jit.graph(), node, !operand.isArgument() || operand.virtualRegister().toArgument() &gt;= 0);</span>
<span class="line-modified"> 1877         m_stream-&gt;appendAndLog(VariableEvent::setLocal(operand, variable-&gt;machineLocal(), format));</span>



 1878     }
 1879 
 1880     m_origin = NodeOrigin();
 1881 
 1882     for (m_indexInBlock = 0; m_indexInBlock &lt; m_block-&gt;size(); ++m_indexInBlock) {
 1883         m_currentNode = m_block-&gt;at(m_indexInBlock);
 1884 
 1885         // We may have hit a contradiction that the CFA was aware of but that the JIT
 1886         // didn&#39;t cause directly.
 1887         if (!m_state.isValid()) {
 1888             bail(DFGBailedAtTopOfBlock);
 1889             return;
 1890         }
 1891 
 1892         m_interpreter.startExecuting();
 1893         m_interpreter.executeKnownEdgeTypes(m_currentNode);
 1894         m_jit.setForNode(m_currentNode);
 1895         m_origin = m_currentNode-&gt;origin;
 1896         m_lastGeneratedNode = m_currentNode-&gt;op();
 1897 
 1898         ASSERT(m_currentNode-&gt;shouldGenerate());
 1899 
<span class="line-modified"> 1900         if (verboseCompilationEnabled())</span>
<span class="line-modified"> 1901             dataLogLn(&quot;SpeculativeJIT generating Node @&quot;, (int)m_currentNode-&gt;index(), &quot; (&quot;, m_currentNode-&gt;origin.semantic.bytecodeIndex().offset(), &quot;) at JIT offset 0x&quot;, m_jit.debugOffset());</span>





 1902 
 1903         if (Options::validateDFGExceptionHandling() &amp;&amp; (mayExit(m_jit.graph(), m_currentNode) != DoesNotExit || m_currentNode-&gt;isTerminal()))
 1904             m_jit.jitReleaseAssertNoException(m_jit.vm());
 1905 
 1906         m_jit.pcToCodeOriginMapBuilder().appendItem(m_jit.labelIgnoringWatchpoints(), m_origin.semantic);
 1907 
 1908         compile(m_currentNode);
 1909 
 1910         if (belongsInMinifiedGraph(m_currentNode-&gt;op()))
 1911             m_minifiedGraph-&gt;append(MinifiedNode::fromNode(m_currentNode));
 1912 
 1913 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 1914         m_jit.clearRegisterAllocationOffsets();
 1915 #endif
 1916 
 1917         if (!m_compileOkay) {
 1918             bail(DFGBailedAtEndOfNode);
 1919             return;
 1920         }
 1921 
 1922         // Make sure that the abstract state is rematerialized for the next node.
 1923         m_interpreter.executeEffects(m_indexInBlock);
 1924     }
 1925 
 1926     // Perform the most basic verification that children have been used correctly.
<span class="line-modified"> 1927     if (ASSERT_ENABLED) {</span>
 1928         for (auto&amp; info : m_generationInfo)
 1929             RELEASE_ASSERT(!info.alive());
 1930     }
 1931 }
 1932 
 1933 // If we are making type predictions about our arguments then
 1934 // we need to check that they are correct on function entry.
 1935 void SpeculativeJIT::checkArgumentTypes()
 1936 {
 1937     ASSERT(!m_currentNode);
<span class="line-modified"> 1938     m_origin = NodeOrigin(CodeOrigin(BytecodeIndex(0)), CodeOrigin(BytecodeIndex(0)), true);</span>
 1939 
 1940     auto&amp; arguments = m_jit.graph().m_rootToArguments.find(m_jit.graph().block(0))-&gt;value;
 1941     for (int i = 0; i &lt; m_jit.codeBlock()-&gt;numParameters(); ++i) {
 1942         Node* node = arguments[i];
 1943         if (!node) {
 1944             // The argument is dead. We don&#39;t do any checks for such arguments.
 1945             continue;
 1946         }
 1947 
 1948         ASSERT(node-&gt;op() == SetArgumentDefinitely);
 1949         ASSERT(node-&gt;shouldGenerate());
 1950 
 1951         VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 1952         FlushFormat format = variableAccessData-&gt;flushFormat();
 1953 
 1954         if (format == FlushedJSValue)
 1955             continue;
 1956 
<span class="line-modified"> 1957         VirtualRegister virtualRegister = variableAccessData-&gt;operand().virtualRegister();</span>
<span class="line-added"> 1958         ASSERT(virtualRegister.isArgument());</span>
 1959 
 1960         JSValueSource valueSource = JSValueSource(JITCompiler::addressFor(virtualRegister));
 1961 
 1962 #if USE(JSVALUE64)
 1963         switch (format) {
 1964         case FlushedInt32: {
<span class="line-modified"> 1965             speculationCheck(BadType, valueSource, node, m_jit.branch64(MacroAssembler::Below, JITCompiler::addressFor(virtualRegister), GPRInfo::numberTagRegister));</span>
 1966             break;
 1967         }
 1968         case FlushedBoolean: {
 1969             GPRTemporary temp(this);
 1970             m_jit.load64(JITCompiler::addressFor(virtualRegister), temp.gpr());
<span class="line-modified"> 1971             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), temp.gpr());</span>
 1972             speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, temp.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
 1973             break;
 1974         }
 1975         case FlushedCell: {
<span class="line-modified"> 1976             speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, JITCompiler::addressFor(virtualRegister), GPRInfo::notCellMaskRegister));</span>
 1977             break;
 1978         }
 1979         default:
 1980             RELEASE_ASSERT_NOT_REACHED();
 1981             break;
 1982         }
 1983 #else
 1984         switch (format) {
 1985         case FlushedInt32: {
 1986             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::Int32Tag)));
 1987             break;
 1988         }
 1989         case FlushedBoolean: {
 1990             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::BooleanTag)));
 1991             break;
 1992         }
 1993         case FlushedCell: {
 1994             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::CellTag)));
 1995             break;
 1996         }
</pre>
<hr />
<pre>
 2067 
 2068     if (verboseCompilationEnabled()) {
 2069         DumpContext dumpContext;
 2070         dataLog(&quot;OSR Entries:\n&quot;);
 2071         for (OSREntryData&amp; entryData : m_jit.jitCode()-&gt;osrEntry)
 2072             dataLog(&quot;    &quot;, inContext(entryData, &amp;dumpContext), &quot;\n&quot;);
 2073         if (!dumpContext.isEmpty())
 2074             dumpContext.dump(WTF::dataFile());
 2075     }
 2076 }
 2077 
 2078 void SpeculativeJIT::compileCheckTraps(Node* node)
 2079 {
 2080     ASSERT(Options::usePollingTraps());
 2081     GPRTemporary unused(this);
 2082     GPRReg unusedGPR = unused.gpr();
 2083 
 2084     JITCompiler::Jump needTrapHandling = m_jit.branchTest8(JITCompiler::NonZero,
 2085         JITCompiler::AbsoluteAddress(m_jit.vm().needTrapHandlingAddress()));
 2086 
<span class="line-modified"> 2087     addSlowPathGenerator(slowPathCall(needTrapHandling, this, operationHandleTraps, unusedGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic))));</span>
 2088     noResult(node);
 2089 }
 2090 
 2091 void SpeculativeJIT::compileDoublePutByVal(Node* node, SpeculateCellOperand&amp; base, SpeculateStrictInt32Operand&amp; property)
 2092 {
 2093     Edge child3 = m_jit.graph().varArgChild(node, 2);
 2094     Edge child4 = m_jit.graph().varArgChild(node, 3);
 2095 
 2096     ArrayMode arrayMode = node-&gt;arrayMode();
 2097 
 2098     GPRReg baseReg = base.gpr();
 2099     GPRReg propertyReg = property.gpr();
 2100 
 2101     SpeculateDoubleOperand value(this, child3);
 2102 
 2103     FPRReg valueReg = value.fpr();
 2104 
 2105     DFG_TYPE_CHECK(
 2106         JSValueRegs(), child3, SpecFullRealNumber,
 2107         m_jit.branchIfNaN(valueReg));
</pre>
<hr />
<pre>
 2142         m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
 2143         m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
 2144 
 2145         inBounds.link(&amp;m_jit);
 2146     }
 2147 
 2148     m_jit.storeDouble(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
 2149 
 2150     base.use();
 2151     property.use();
 2152     value.use();
 2153     storage.use();
 2154 
 2155     if (arrayMode.isOutOfBounds()) {
 2156         addSlowPathGenerator(
 2157             slowPathCall(
 2158                 slowCase, this,
 2159                 m_jit.isStrictModeFor(node-&gt;origin.semantic)
 2160                     ? (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
 2161                     : (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
<span class="line-modified"> 2162                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, valueReg));</span>
 2163     }
 2164 
 2165     noResult(m_currentNode, UseChildrenCalledExplicitly);
 2166 }
 2167 
 2168 void SpeculativeJIT::compileGetCharCodeAt(Node* node)
 2169 {
 2170     SpeculateCellOperand string(this, node-&gt;child1());
 2171     SpeculateStrictInt32Operand index(this, node-&gt;child2());
 2172     StorageOperand storage(this, node-&gt;child3());
 2173 
 2174     GPRReg stringReg = string.gpr();
 2175     GPRReg indexReg = index.gpr();
 2176     GPRReg storageReg = storage.gpr();
 2177 
 2178     ASSERT(speculationChecked(m_state.forNode(node-&gt;child1()).m_type, SpecString));
 2179 
 2180     GPRTemporary scratch(this);
 2181     GPRReg scratchReg = scratch.gpr();
 2182 
</pre>
<hr />
<pre>
 2237     m_jit.load8(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne, 0), scratchReg);
 2238     JITCompiler::Jump cont8Bit = m_jit.jump();
 2239 
 2240     is16Bit.link(&amp;m_jit);
 2241 
 2242     m_jit.load16(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo, 0), scratchReg);
 2243 
 2244     JITCompiler::Jump bigCharacter =
 2245         m_jit.branch32(MacroAssembler::Above, scratchReg, TrustedImm32(maxSingleCharacterString));
 2246 
 2247     // 8 bit string values don&#39;t need the isASCII check.
 2248     cont8Bit.link(&amp;m_jit);
 2249 
 2250     VM&amp; vm = this-&gt;vm();
 2251     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), scratchReg);
 2252     m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), scratchReg);
 2253     m_jit.loadPtr(scratchReg, scratchReg);
 2254 
 2255     addSlowPathGenerator(
 2256         slowPathCall(
<span class="line-modified"> 2257             bigCharacter, this, operationSingleCharacterString, scratchReg, &amp;vm, scratchReg));</span>
 2258 
 2259     if (node-&gt;arrayMode().isOutOfBounds()) {
 2260 #if USE(JSVALUE32_64)
 2261         m_jit.move(TrustedImm32(JSValue::CellTag), resultTagReg);
 2262 #endif
 2263 
 2264         JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);
 2265         Structure* stringPrototypeStructure = globalObject-&gt;stringPrototype()-&gt;structure(vm);
 2266         Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm);
 2267         WTF::loadLoadFence();
 2268 
 2269         if (globalObject-&gt;stringPrototypeChainIsSane()) {
 2270             // FIXME: This could be captured using a Speculation mode that means &quot;out-of-bounds
 2271             // loads return a trivial value&quot;. Something like SaneChainOutOfBounds. This should
 2272             // speculate that we don&#39;t take negative out-of-bounds, or better yet, it should rely
 2273             // on a stringPrototypeChainIsSane() guaranteeing that the prototypes have no negative
 2274             // indexed properties either.
 2275             // https://bugs.webkit.org/show_bug.cgi?id=144668
 2276             m_jit.graph().registerAndWatchStructureTransition(stringPrototypeStructure);
 2277             m_jit.graph().registerAndWatchStructureTransition(objectPrototypeStructure);
 2278 
 2279 #if USE(JSVALUE64)
 2280             addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(
<span class="line-modified"> 2281                 outOfBounds, this, JSValueRegs(scratchReg), TrustedImmPtr::weakPointer(m_graph, globalObject), baseReg, propertyReg));</span>
 2282 #else
 2283             addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(
<span class="line-modified"> 2284                 outOfBounds, this, JSValueRegs(resultTagReg, scratchReg), TrustedImmPtr::weakPointer(m_graph, globalObject), baseReg, propertyReg));</span>

 2285 #endif
 2286         } else {
 2287 #if USE(JSVALUE64)
 2288             addSlowPathGenerator(
 2289                 slowPathCall(
 2290                     outOfBounds, this, operationGetByValStringInt,
<span class="line-modified"> 2291                     scratchReg, TrustedImmPtr::weakPointer(m_graph, globalObject), baseReg, propertyReg));</span>
 2292 #else
 2293             addSlowPathGenerator(
 2294                 slowPathCall(
 2295                     outOfBounds, this, operationGetByValStringInt,
<span class="line-modified"> 2296                     JSValueRegs(resultTagReg, scratchReg), TrustedImmPtr::weakPointer(m_graph, globalObject), baseReg, propertyReg));</span>
 2297 #endif
 2298         }
 2299 
 2300 #if USE(JSVALUE64)
 2301         jsValueResult(scratchReg, m_currentNode);
 2302 #else
 2303         jsValueResult(resultTagReg, scratchReg, m_currentNode);
 2304 #endif
 2305     } else
 2306         cellResult(scratchReg, m_currentNode);
 2307 }
 2308 
 2309 void SpeculativeJIT::compileFromCharCode(Node* node)
 2310 {
 2311     Edge&amp; child = node-&gt;child1();
 2312     if (child.useKind() == UntypedUse) {
 2313         JSValueOperand opr(this, child);
 2314         JSValueRegs oprRegs = opr.jsValueRegs();
 2315 
 2316         flushRegisters();
 2317         JSValueRegsFlushedCallResult result(this);
 2318         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 2319         callOperation(operationStringFromCharCodeUntyped, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), oprRegs);</span>
 2320         m_jit.exceptionCheck();
 2321 
 2322         jsValueResult(resultRegs, node);
 2323         return;
 2324     }
 2325 
 2326     SpeculateStrictInt32Operand property(this, child);
 2327     GPRReg propertyReg = property.gpr();
 2328     GPRTemporary smallStrings(this);
 2329     GPRTemporary scratch(this);
 2330     GPRReg scratchReg = scratch.gpr();
 2331     GPRReg smallStringsReg = smallStrings.gpr();
 2332 
 2333     JITCompiler::JumpList slowCases;
 2334     slowCases.append(m_jit.branch32(MacroAssembler::Above, propertyReg, TrustedImm32(maxSingleCharacterString)));
 2335     m_jit.move(TrustedImmPtr(vm().smallStrings.singleCharacterStrings()), smallStringsReg);
 2336     m_jit.loadPtr(MacroAssembler::BaseIndex(smallStringsReg, propertyReg, MacroAssembler::ScalePtr, 0), scratchReg);
 2337 
 2338     slowCases.append(m_jit.branchTest32(MacroAssembler::Zero, scratchReg));
<span class="line-modified"> 2339     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringFromCharCode, scratchReg, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), propertyReg));</span>
 2340     cellResult(scratchReg, m_currentNode);
 2341 }
 2342 
 2343 GeneratedOperandType SpeculativeJIT::checkGeneratedTypeForToInt32(Node* node)
 2344 {
 2345     VirtualRegister virtualRegister = node-&gt;virtualRegister();
 2346     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 2347 
 2348     switch (info.registerFormat()) {
 2349     case DataFormatStorage:
 2350         RELEASE_ASSERT_NOT_REACHED();
 2351 
 2352     case DataFormatBoolean:
 2353     case DataFormatCell:
 2354         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 2355         return GeneratedOperandTypeUnknown;
 2356 
 2357     case DataFormatNone:
 2358     case DataFormatJSCell:
 2359     case DataFormatJS:
</pre>
<hr />
<pre>
 2422 
 2423             GPRReg gpr = op1.gpr();
 2424             GPRReg resultGpr = result.gpr();
 2425             FPRTemporary tempFpr(this);
 2426             FPRReg fpr = tempFpr.fpr();
 2427 
 2428             JITCompiler::Jump isInteger = m_jit.branchIfInt32(gpr);
 2429             JITCompiler::JumpList converted;
 2430 
 2431             if (node-&gt;child1().useKind() == NumberUse) {
 2432                 DFG_TYPE_CHECK(
 2433                     JSValueRegs(gpr), node-&gt;child1(), SpecBytecodeNumber,
 2434                     m_jit.branchIfNotNumber(gpr));
 2435             } else {
 2436                 JITCompiler::Jump isNumber = m_jit.branchIfNumber(gpr);
 2437 
 2438                 DFG_TYPE_CHECK(
 2439                     JSValueRegs(gpr), node-&gt;child1(), ~SpecCellCheck, m_jit.branchIfCell(JSValueRegs(gpr)));
 2440 
 2441                 // It&#39;s not a cell: so true turns into 1 and all else turns into 0.
<span class="line-modified"> 2442                 m_jit.compare64(JITCompiler::Equal, gpr, TrustedImm32(JSValue::ValueTrue), resultGpr);</span>
 2443                 converted.append(m_jit.jump());
 2444 
 2445                 isNumber.link(&amp;m_jit);
 2446             }
 2447 
 2448             // First, if we get here we have a double encoded as a JSValue
 2449             unboxDouble(gpr, resultGpr, fpr);
 2450 #if CPU(ARM64)
 2451             if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics())
 2452                 m_jit.convertDoubleToInt32UsingJavaScriptSemantics(fpr, resultGpr);
 2453             else
 2454 #endif
 2455             {
 2456                 silentSpillAllRegisters(resultGpr);
 2457                 callOperation(operationToInt32, resultGpr, fpr);
 2458                 silentFillAllRegisters();
 2459             }
 2460 
 2461             converted.append(m_jit.jump());
 2462 
</pre>
<hr />
<pre>
 2643             return;
 2644         }
 2645 
 2646         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2647         FPRTemporary result(this);
 2648 
 2649 #if USE(JSVALUE64)
 2650         GPRTemporary temp(this);
 2651 
 2652         GPRReg op1GPR = op1.gpr();
 2653         GPRReg tempGPR = temp.gpr();
 2654         FPRReg resultFPR = result.fpr();
 2655         JITCompiler::JumpList done;
 2656 
 2657         JITCompiler::Jump isInteger = m_jit.branchIfInt32(op1GPR);
 2658 
 2659         if (node-&gt;child1().useKind() == NotCellUse) {
 2660             JITCompiler::Jump isNumber = m_jit.branchIfNumber(op1GPR);
 2661             JITCompiler::Jump isUndefined = m_jit.branchIfUndefined(op1GPR);
 2662 
<span class="line-modified"> 2663             static constexpr double zero = 0;</span>
 2664             m_jit.loadDouble(TrustedImmPtr(&amp;zero), resultFPR);
 2665 
 2666             JITCompiler::Jump isNull = m_jit.branchIfNull(op1GPR);
 2667             done.append(isNull);
 2668 
 2669             DFG_TYPE_CHECK(JSValueRegs(op1GPR), node-&gt;child1(), ~SpecCellCheck,
<span class="line-modified"> 2670                 m_jit.branchTest64(JITCompiler::Zero, op1GPR, TrustedImm32(JSValue::BoolTag)));</span>
 2671 
<span class="line-modified"> 2672             JITCompiler::Jump isFalse = m_jit.branch64(JITCompiler::Equal, op1GPR, TrustedImm64(JSValue::ValueFalse));</span>
<span class="line-modified"> 2673             static constexpr double one = 1;</span>
 2674             m_jit.loadDouble(TrustedImmPtr(&amp;one), resultFPR);
 2675             done.append(m_jit.jump());
 2676             done.append(isFalse);
 2677 
 2678             isUndefined.link(&amp;m_jit);
 2679             static const double NaN = PNaN;
 2680             m_jit.loadDouble(TrustedImmPtr(&amp;NaN), resultFPR);
 2681             done.append(m_jit.jump());
 2682 
 2683             isNumber.link(&amp;m_jit);
 2684         } else if (needsTypeCheck(node-&gt;child1(), SpecBytecodeNumber)) {
 2685             typeCheck(
 2686                 JSValueRegs(op1GPR), node-&gt;child1(), SpecBytecodeNumber,
 2687                 m_jit.branchIfNotNumber(op1GPR));
 2688         }
 2689 
 2690         unboxDouble(op1GPR, tempGPR, resultFPR);
 2691         done.append(m_jit.jump());
 2692 
 2693         isInteger.link(&amp;m_jit);
 2694         m_jit.convertInt32ToDouble(op1GPR, resultFPR);
 2695         done.link(&amp;m_jit);
 2696 #else // USE(JSVALUE64) -&gt; this is the 32_64 case
 2697         FPRTemporary temp(this);
 2698 
 2699         GPRReg op1TagGPR = op1.tagGPR();
 2700         GPRReg op1PayloadGPR = op1.payloadGPR();
 2701         FPRReg tempFPR = temp.fpr();
 2702         FPRReg resultFPR = result.fpr();
 2703         JITCompiler::JumpList done;
 2704 
 2705         JITCompiler::Jump isInteger = m_jit.branchIfInt32(op1TagGPR);
 2706 
 2707         if (node-&gt;child1().useKind() == NotCellUse) {
 2708             JITCompiler::Jump isNumber = m_jit.branch32(JITCompiler::Below, op1TagGPR, JITCompiler::TrustedImm32(JSValue::LowestTag + 1));
 2709             JITCompiler::Jump isUndefined = m_jit.branchIfUndefined(op1TagGPR);
 2710 
<span class="line-modified"> 2711             static constexpr double zero = 0;</span>
 2712             m_jit.loadDouble(TrustedImmPtr(&amp;zero), resultFPR);
 2713 
 2714             JITCompiler::Jump isNull = m_jit.branchIfNull(op1TagGPR);
 2715             done.append(isNull);
 2716 
 2717             DFG_TYPE_CHECK(JSValueRegs(op1TagGPR, op1PayloadGPR), node-&gt;child1(), ~SpecCell, m_jit.branchIfNotBoolean(op1TagGPR, InvalidGPRReg));
 2718 
 2719             JITCompiler::Jump isFalse = m_jit.branchTest32(JITCompiler::Zero, op1PayloadGPR, TrustedImm32(1));
<span class="line-modified"> 2720             static constexpr double one = 1;</span>
 2721             m_jit.loadDouble(TrustedImmPtr(&amp;one), resultFPR);
 2722             done.append(m_jit.jump());
 2723             done.append(isFalse);
 2724 
 2725             isUndefined.link(&amp;m_jit);
 2726             static const double NaN = PNaN;
 2727             m_jit.loadDouble(TrustedImmPtr(&amp;NaN), resultFPR);
 2728             done.append(m_jit.jump());
 2729 
 2730             isNumber.link(&amp;m_jit);
 2731         } else if (needsTypeCheck(node-&gt;child1(), SpecBytecodeNumber)) {
 2732             // This check fails with Int32Tag, but it is OK since Int32 case is already excluded.
 2733             typeCheck(
 2734                 JSValueRegs(op1TagGPR, op1PayloadGPR), node-&gt;child1(), SpecBytecodeNumber,
 2735                 m_jit.branch32(MacroAssembler::AboveOrEqual, op1TagGPR, TrustedImm32(JSValue::LowestTag)));
 2736         }
 2737 
 2738         unboxDouble(op1TagGPR, op1PayloadGPR, resultFPR, tempFPR);
 2739         done.append(m_jit.jump());
 2740 
</pre>
<hr />
<pre>
 2820     else if (d &gt; 255)
 2821         d = 255;
 2822     return d;
 2823 }
 2824 
 2825 static void compileClampIntegerToByte(JITCompiler&amp; jit, GPRReg result)
 2826 {
 2827     MacroAssembler::Jump inBounds = jit.branch32(MacroAssembler::BelowOrEqual, result, JITCompiler::TrustedImm32(0xff));
 2828     MacroAssembler::Jump tooBig = jit.branch32(MacroAssembler::GreaterThan, result, JITCompiler::TrustedImm32(0xff));
 2829     jit.xorPtr(result, result);
 2830     MacroAssembler::Jump clamped = jit.jump();
 2831     tooBig.link(&amp;jit);
 2832     jit.move(JITCompiler::TrustedImm32(255), result);
 2833     clamped.link(&amp;jit);
 2834     inBounds.link(&amp;jit);
 2835 }
 2836 
 2837 static void compileClampDoubleToByte(JITCompiler&amp; jit, GPRReg result, FPRReg source, FPRReg scratch)
 2838 {
 2839     // Unordered compare so we pick up NaN
<span class="line-modified"> 2840     static constexpr double zero = 0;</span>
<span class="line-modified"> 2841     static constexpr double byteMax = 255;</span>
<span class="line-modified"> 2842     static constexpr double half = 0.5;</span>
 2843     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;zero), scratch);
 2844     MacroAssembler::Jump tooSmall = jit.branchDouble(MacroAssembler::DoubleLessThanOrEqualOrUnordered, source, scratch);
 2845     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;byteMax), scratch);
 2846     MacroAssembler::Jump tooBig = jit.branchDouble(MacroAssembler::DoubleGreaterThan, source, scratch);
 2847 
 2848     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;half), scratch);
 2849     // FIXME: This should probably just use a floating point round!
 2850     // https://bugs.webkit.org/show_bug.cgi?id=72054
 2851     jit.addDouble(source, scratch);
 2852     jit.truncateDoubleToInt32(scratch, result);
 2853     MacroAssembler::Jump truncatedInt = jit.jump();
 2854 
 2855     tooSmall.link(&amp;jit);
 2856     jit.xorPtr(result, result);
 2857     MacroAssembler::Jump zeroed = jit.jump();
 2858 
 2859     tooBig.link(&amp;jit);
 2860     jit.move(JITCompiler::TrustedImm32(255), result);
 2861 
 2862     truncatedInt.link(&amp;jit);
</pre>
<hr />
<pre>
 3085                 propertyTag.adopt(realPropertyTag);
 3086                 GPRReg propertyTagGPR = propertyTag.gpr();
 3087 
 3088                 GPRTemporary realValueTag(this);
 3089                 valueTag.adopt(realValueTag);
 3090                 GPRReg valueTagGPR = valueTag.gpr();
 3091 #endif
 3092                 SpeculateDoubleOperand valueOp(this, valueUse);
 3093                 GPRTemporary result(this);
 3094                 FPRReg fpr = valueOp.fpr();
 3095                 GPRReg gpr = result.gpr();
 3096                 MacroAssembler::Jump notNaN = m_jit.branchIfNotNaN(fpr);
 3097                 m_jit.xorPtr(gpr, gpr);
 3098                 MacroAssembler::JumpList fixed(m_jit.jump());
 3099                 notNaN.link(&amp;m_jit);
 3100 
 3101                 fixed.append(m_jit.branchTruncateDoubleToInt32(
 3102                     fpr, gpr, MacroAssembler::BranchIfTruncateSuccessful));
 3103 
 3104 #if USE(JSVALUE64)
<span class="line-modified"> 3105                 m_jit.or64(GPRInfo::numberTagRegister, property);</span>
 3106                 boxDouble(fpr, gpr);
 3107 #else
 3108                 UNUSED_PARAM(property);
 3109                 m_jit.move(TrustedImm32(JSValue::Int32Tag), propertyTagGPR);
 3110                 boxDouble(fpr, valueTagGPR, gpr);
 3111 #endif
 3112                 slowPathCases.append(m_jit.jump());
 3113 
 3114                 fixed.link(&amp;m_jit);
 3115                 value.adopt(result);
 3116             }
 3117             break;
 3118         }
 3119 
 3120         default:
 3121             RELEASE_ASSERT_NOT_REACHED();
 3122             break;
 3123         }
 3124     }
 3125     return true;
</pre>
<hr />
<pre>
 3171     case 2:
 3172         m_jit.store16(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesTwo));
 3173         break;
 3174     case 4:
 3175         m_jit.store32(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesFour));
 3176         break;
 3177     default:
 3178         CRASH();
 3179     }
 3180 
 3181     JITCompiler::Jump done = jumpForTypedArrayIsNeuteredIfOutOfBounds(node, base, outOfBounds);
 3182     if (done.isSet())
 3183         done.link(&amp;m_jit);
 3184 
 3185     if (!slowPathCases.empty()) {
 3186 #if USE(JSVALUE64)
 3187         if (node-&gt;op() == PutByValDirect) {
 3188             addSlowPathGenerator(slowPathCall(
 3189                 slowPathCases, this,
 3190                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict,
<span class="line-modified"> 3191                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), base, property, valueGPR));</span>
 3192         } else {
 3193             addSlowPathGenerator(slowPathCall(
 3194                 slowPathCases, this,
 3195                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict,
<span class="line-modified"> 3196                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), base, property, valueGPR));</span>
 3197         }
 3198 #else // not USE(JSVALUE64)
 3199         if (node-&gt;op() == PutByValDirect) {
 3200             addSlowPathGenerator(slowPathCall(
 3201                 slowPathCases, this,
 3202                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict,
<span class="line-modified"> 3203                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));</span>
 3204         } else {
 3205             addSlowPathGenerator(slowPathCall(
 3206                 slowPathCases, this,
 3207                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict,
<span class="line-modified"> 3208                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));</span>
 3209         }
 3210 #endif
 3211     }
 3212 
 3213     noResult(node);
 3214 }
 3215 
 3216 void SpeculativeJIT::compileGetByValOnFloatTypedArray(Node* node, TypedArrayType type)
 3217 {
 3218     ASSERT(isFloat(type));
 3219 
 3220     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 3221     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 3222     StorageOperand storage(this, m_graph.varArgChild(node, 2));
 3223 
 3224     GPRReg baseReg = base.gpr();
 3225     GPRReg propertyReg = property.gpr();
 3226     GPRReg storageReg = storage.gpr();
 3227 
 3228     FPRTemporary result(this);
</pre>
<hr />
<pre>
 3280     JITCompiler::Jump done = jumpForTypedArrayIsNeuteredIfOutOfBounds(node, base, outOfBounds);
 3281     if (done.isSet())
 3282         done.link(&amp;m_jit);
 3283     noResult(node);
 3284 }
 3285 
 3286 void SpeculativeJIT::compileGetByValForObjectWithString(Node* node)
 3287 {
 3288     SpeculateCellOperand arg1(this, m_graph.varArgChild(node, 0));
 3289     SpeculateCellOperand arg2(this, m_graph.varArgChild(node, 1));
 3290 
 3291     GPRReg arg1GPR = arg1.gpr();
 3292     GPRReg arg2GPR = arg2.gpr();
 3293 
 3294     speculateObject(m_graph.varArgChild(node, 0), arg1GPR);
 3295     speculateString(m_graph.varArgChild(node, 1), arg2GPR);
 3296 
 3297     flushRegisters();
 3298     JSValueRegsFlushedCallResult result(this);
 3299     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3300     callOperation(operationGetByValObjectString, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR);</span>
 3301     m_jit.exceptionCheck();
 3302 
 3303     jsValueResult(resultRegs, node);
 3304 }
 3305 
 3306 void SpeculativeJIT::compileGetByValForObjectWithSymbol(Node* node)
 3307 {
 3308     SpeculateCellOperand arg1(this, m_graph.varArgChild(node, 0));
 3309     SpeculateCellOperand arg2(this, m_graph.varArgChild(node, 1));
 3310 
 3311     GPRReg arg1GPR = arg1.gpr();
 3312     GPRReg arg2GPR = arg2.gpr();
 3313 
 3314     speculateObject(m_graph.varArgChild(node, 0), arg1GPR);
 3315     speculateSymbol(m_graph.varArgChild(node, 1), arg2GPR);
 3316 
 3317     flushRegisters();
 3318     JSValueRegsFlushedCallResult result(this);
 3319     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3320     callOperation(operationGetByValObjectSymbol, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR);</span>
 3321     m_jit.exceptionCheck();
 3322 
 3323     jsValueResult(resultRegs, node);
 3324 }
 3325 
 3326 void SpeculativeJIT::compilePutByValForCellWithString(Node* node, Edge&amp; child1, Edge&amp; child2, Edge&amp; child3)
 3327 {
 3328     SpeculateCellOperand arg1(this, child1);
 3329     SpeculateCellOperand arg2(this, child2);
 3330     JSValueOperand arg3(this, child3);
 3331 
 3332     GPRReg arg1GPR = arg1.gpr();
 3333     GPRReg arg2GPR = arg2.gpr();
 3334     JSValueRegs arg3Regs = arg3.jsValueRegs();
 3335 
 3336     speculateString(child2, arg2GPR);
 3337 
 3338     flushRegisters();
<span class="line-modified"> 3339     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStringStrict : operationPutByValCellStringNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR, arg3Regs);</span>
 3340     m_jit.exceptionCheck();
 3341 
 3342     noResult(node);
 3343 }
 3344 
 3345 void SpeculativeJIT::compilePutByValForCellWithSymbol(Node* node, Edge&amp; child1, Edge&amp; child2, Edge&amp; child3)
 3346 {
 3347     SpeculateCellOperand arg1(this, child1);
 3348     SpeculateCellOperand arg2(this, child2);
 3349     JSValueOperand arg3(this, child3);
 3350 
 3351     GPRReg arg1GPR = arg1.gpr();
 3352     GPRReg arg2GPR = arg2.gpr();
 3353     JSValueRegs arg3Regs = arg3.jsValueRegs();
 3354 
 3355     speculateSymbol(child2, arg2GPR);
 3356 
 3357     flushRegisters();
<span class="line-modified"> 3358     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellSymbolStrict : operationPutByValCellSymbolNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR, arg3Regs);</span>
 3359     m_jit.exceptionCheck();
 3360 
 3361     noResult(node);
 3362 }
 3363 
 3364 void SpeculativeJIT::compileGetByValWithThis(Node* node)
 3365 {
 3366     JSValueOperand base(this, node-&gt;child1());
 3367     JSValueRegs baseRegs = base.jsValueRegs();
 3368     JSValueOperand thisValue(this, node-&gt;child2());
 3369     JSValueRegs thisValueRegs = thisValue.jsValueRegs();
 3370     JSValueOperand subscript(this, node-&gt;child3());
 3371     JSValueRegs subscriptRegs = subscript.jsValueRegs();
 3372 
 3373     flushRegisters();
 3374     JSValueRegsFlushedCallResult result(this);
 3375     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3376     callOperation(operationGetByValWithThis, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, thisValueRegs, subscriptRegs);</span>
 3377     m_jit.exceptionCheck();
 3378 
 3379     jsValueResult(resultRegs, node);
 3380 }
 3381 
 3382 void SpeculativeJIT::compileCheckTypeInfoFlags(Node* node)
 3383 {
 3384     SpeculateCellOperand base(this, node-&gt;child1());
 3385 
 3386     GPRReg baseGPR = base.gpr();
 3387 
 3388     // FIXME: This only works for checking if a single bit is set. If we want to check more
 3389     // than one bit at once, we&#39;ll need to fix this:
 3390     // https://bugs.webkit.org/show_bug.cgi?id=185705
 3391     speculationCheck(BadTypeInfoFlags, JSValueRegs(), 0, m_jit.branchTest8(MacroAssembler::Zero, MacroAssembler::Address(baseGPR, JSCell::typeInfoFlagsOffset()), MacroAssembler::TrustedImm32(node-&gt;typeInfoOperand())));
 3392 
 3393     noResult(node);
 3394 }
 3395 
 3396 void SpeculativeJIT::compileParseInt(Node* node)
 3397 {
 3398     RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse || node-&gt;child1().useKind() == StringUse);
 3399     if (node-&gt;child2()) {
 3400         SpeculateInt32Operand radix(this, node-&gt;child2());
 3401         GPRReg radixGPR = radix.gpr();
 3402         if (node-&gt;child1().useKind() == UntypedUse) {
 3403             JSValueOperand value(this, node-&gt;child1());
 3404             JSValueRegs valueRegs = value.jsValueRegs();
 3405 
 3406             flushRegisters();
 3407             JSValueRegsFlushedCallResult result(this);
 3408             JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3409             callOperation(operationParseIntGeneric, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, radixGPR);</span>
 3410             m_jit.exceptionCheck();
 3411             jsValueResult(resultRegs, node);
 3412             return;
 3413         }
 3414 
 3415         SpeculateCellOperand value(this, node-&gt;child1());
 3416         GPRReg valueGPR = value.gpr();
 3417         speculateString(node-&gt;child1(), valueGPR);
 3418 
 3419         flushRegisters();
 3420         JSValueRegsFlushedCallResult result(this);
 3421         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3422         callOperation(operationParseIntString, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueGPR, radixGPR);</span>
 3423         m_jit.exceptionCheck();
 3424         jsValueResult(resultRegs, node);
 3425         return;
 3426     }
 3427 
 3428     if (node-&gt;child1().useKind() == UntypedUse) {
 3429         JSValueOperand value(this, node-&gt;child1());
 3430         JSValueRegs valueRegs = value.jsValueRegs();
 3431 
 3432         flushRegisters();
 3433         JSValueRegsFlushedCallResult result(this);
 3434         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3435         callOperation(operationParseIntNoRadixGeneric, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs);</span>
 3436         m_jit.exceptionCheck();
 3437         jsValueResult(resultRegs, node);
 3438         return;
 3439     }
 3440 
 3441     SpeculateCellOperand value(this, node-&gt;child1());
 3442     GPRReg valueGPR = value.gpr();
 3443     speculateString(node-&gt;child1(), valueGPR);
 3444 
 3445     flushRegisters();
 3446     JSValueRegsFlushedCallResult result(this);
 3447     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3448     callOperation(operationParseIntStringNoRadix, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueGPR);</span>
 3449     m_jit.exceptionCheck();
 3450     jsValueResult(resultRegs, node);
 3451 }
 3452 
 3453 void SpeculativeJIT::compileOverridesHasInstance(Node* node)
 3454 {
 3455     Node* hasInstanceValueNode = node-&gt;child2().node();
 3456     JSFunction* defaultHasInstanceFunction = jsCast&lt;JSFunction*&gt;(node-&gt;cellOperand()-&gt;value());
 3457 
 3458     MacroAssembler::JumpList notDefault;
 3459     SpeculateCellOperand base(this, node-&gt;child1());
 3460     JSValueOperand hasInstanceValue(this, node-&gt;child2());
 3461     GPRTemporary result(this);
 3462 
 3463     GPRReg baseGPR = base.gpr();
 3464     GPRReg resultGPR = result.gpr();
 3465 
 3466     // It would be great if constant folding handled automatically the case where we knew the hasInstance function
 3467     // was a constant. Unfortunately, the folding rule for OverridesHasInstance is in the strength reduction phase
 3468     // since it relies on OSR information. https://bugs.webkit.org/show_bug.cgi?id=154832
</pre>
<hr />
<pre>
 3486     }
 3487 
 3488     done.link(&amp;m_jit);
 3489     unblessedBooleanResult(resultGPR, node);
 3490 }
 3491 
 3492 void SpeculativeJIT::compileInstanceOfForCells(Node* node, JSValueRegs valueRegs, JSValueRegs prototypeRegs, GPRReg resultGPR, GPRReg scratchGPR, GPRReg scratch2GPR, JITCompiler::Jump slowCase)
 3493 {
 3494     CallSiteIndex callSiteIndex = m_jit.addCallSite(node-&gt;origin.semantic);
 3495 
 3496     JITInstanceOfGenerator gen(
 3497         m_jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex, usedRegisters(), resultGPR,
 3498         valueRegs.payloadGPR(), prototypeRegs.payloadGPR(), scratchGPR, scratch2GPR,
 3499         m_state.forNode(node-&gt;child2()).isType(SpecObject | ~SpecCell));
 3500     gen.generateFastPath(m_jit);
 3501 
 3502     JITCompiler::JumpList slowCases;
 3503     slowCases.append(slowCase);
 3504 
 3505     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
<span class="line-modified"> 3506         slowCases, this, operationInstanceOfOptimize, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), gen.stubInfo(), valueRegs,</span>
 3507         prototypeRegs);
 3508 
 3509     m_jit.addInstanceOf(gen, slowPath.get());
 3510     addSlowPathGenerator(WTFMove(slowPath));
 3511 }
 3512 
 3513 void SpeculativeJIT::compileInstanceOf(Node* node)
 3514 {
 3515 #if USE(JSVALUE64)
 3516     if (node-&gt;child1().useKind() == CellUse
 3517         &amp;&amp; node-&gt;child2().useKind() == CellUse) {
 3518         SpeculateCellOperand value(this, node-&gt;child1());
 3519         SpeculateCellOperand prototype(this, node-&gt;child2());
 3520 
 3521         GPRTemporary result(this);
 3522         GPRTemporary scratch(this);
 3523         GPRTemporary scratch2(this);
 3524 
 3525         GPRReg valueGPR = value.gpr();
 3526         GPRReg prototypeGPR = prototype.gpr();
</pre>
<hr />
<pre>
 3563 
 3564     done.link(&amp;m_jit);
 3565     blessedBooleanResult(resultGPR, node);
 3566     return;
 3567 }
 3568 
 3569 void SpeculativeJIT::compileValueBitNot(Node* node)
 3570 {
 3571     Edge&amp; child1 = node-&gt;child1();
 3572 
 3573     if (child1.useKind() == BigIntUse) {
 3574         SpeculateCellOperand operand(this, child1);
 3575         GPRReg operandGPR = operand.gpr();
 3576 
 3577         speculateBigInt(child1, operandGPR);
 3578 
 3579         flushRegisters();
 3580         GPRFlushedCallResult result(this);
 3581         GPRReg resultGPR = result.gpr();
 3582 
<span class="line-modified"> 3583         callOperation(operationBitNotBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), operandGPR);</span>
 3584         m_jit.exceptionCheck();
 3585         cellResult(resultGPR, node);
 3586 
 3587         return;
 3588     }
 3589 
 3590     JSValueOperand operand(this, child1);
 3591     JSValueRegs operandRegs = operand.jsValueRegs();
 3592 
 3593     flushRegisters();
 3594     JSValueRegsFlushedCallResult result(this);
 3595     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3596     callOperation(operationValueBitNot, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), operandRegs);</span>
 3597     m_jit.exceptionCheck();
 3598 
 3599     jsValueResult(resultRegs, node);
 3600 }
 3601 
 3602 void SpeculativeJIT::compileBitwiseNot(Node* node)
 3603 {
 3604     Edge&amp; child1 = node-&gt;child1();
 3605 
 3606     SpeculateInt32Operand operand(this, child1);
 3607     GPRTemporary result(this);
 3608     GPRReg resultGPR = result.gpr();
 3609 
 3610     m_jit.move(operand.gpr(), resultGPR);
 3611 
 3612     m_jit.not32(resultGPR);
 3613 
 3614     int32Result(resultGPR, node);
 3615 }
 3616 
<span class="line-modified"> 3617 template&lt;typename SnippetGenerator, J_JITOperation_GJJ snippetSlowPathFunction&gt;</span>
 3618 void SpeculativeJIT::emitUntypedBitOp(Node* node)
 3619 {
 3620     Edge&amp; leftChild = node-&gt;child1();
 3621     Edge&amp; rightChild = node-&gt;child2();
 3622 
 3623     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3624         JSValueOperand left(this, leftChild);
 3625         JSValueOperand right(this, rightChild);
 3626         JSValueRegs leftRegs = left.jsValueRegs();
 3627         JSValueRegs rightRegs = right.jsValueRegs();
 3628 
 3629         flushRegisters();
 3630         JSValueRegsFlushedCallResult result(this);
 3631         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3632         callOperation(snippetSlowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 3633         m_jit.exceptionCheck();
 3634 
 3635         jsValueResult(resultRegs, node);
 3636         return;
 3637     }
 3638 
 3639     Optional&lt;JSValueOperand&gt; left;
 3640     Optional&lt;JSValueOperand&gt; right;
 3641 
 3642     JSValueRegs leftRegs;
 3643     JSValueRegs rightRegs;
 3644 
 3645 #if USE(JSVALUE64)
 3646     GPRTemporary result(this);
 3647     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 3648     GPRTemporary scratch(this);
 3649     GPRReg scratchGPR = scratch.gpr();
 3650 #else
 3651     GPRTemporary resultTag(this);
 3652     GPRTemporary resultPayload(this);
</pre>
<hr />
<pre>
 3675         rightRegs = right-&gt;jsValueRegs();
 3676     }
 3677 
 3678     SnippetGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs, scratchGPR);
 3679     gen.generateFastPath(m_jit);
 3680 
 3681     ASSERT(gen.didEmitFastPath());
 3682     gen.endJumpList().append(m_jit.jump());
 3683 
 3684     gen.slowPathJumpList().link(&amp;m_jit);
 3685     silentSpillAllRegisters(resultRegs);
 3686 
 3687     if (leftOperand.isConst()) {
 3688         leftRegs = resultRegs;
 3689         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 3690     } else if (rightOperand.isConst()) {
 3691         rightRegs = resultRegs;
 3692         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 3693     }
 3694 
<span class="line-modified"> 3695     callOperation(snippetSlowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 3696 
 3697     silentFillAllRegisters();
 3698     m_jit.exceptionCheck();
 3699 
 3700     gen.endJumpList().link(&amp;m_jit);
 3701     jsValueResult(resultRegs, node);
 3702 }
 3703 
 3704 void SpeculativeJIT::compileValueBitwiseOp(Node* node)
 3705 {
 3706     NodeType op = node-&gt;op();
 3707     Edge&amp; leftChild = node-&gt;child1();
 3708     Edge&amp; rightChild = node-&gt;child2();
 3709 
 3710     if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
 3711         switch (op) {
 3712         case ValueBitAnd:
 3713             emitUntypedBitOp&lt;JITBitAndGenerator, operationValueBitAnd&gt;(node);
 3714             return;
 3715         case ValueBitXor:
</pre>
<hr />
<pre>
 3722             RELEASE_ASSERT_NOT_REACHED();
 3723         }
 3724     }
 3725 
 3726     ASSERT(leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse);
 3727 
 3728     SpeculateCellOperand left(this, node-&gt;child1());
 3729     SpeculateCellOperand right(this, node-&gt;child2());
 3730     GPRReg leftGPR = left.gpr();
 3731     GPRReg rightGPR = right.gpr();
 3732 
 3733     speculateBigInt(leftChild, leftGPR);
 3734     speculateBigInt(rightChild, rightGPR);
 3735 
 3736     flushRegisters();
 3737     GPRFlushedCallResult result(this);
 3738     GPRReg resultGPR = result.gpr();
 3739 
 3740     switch (op) {
 3741     case ValueBitAnd:
<span class="line-modified"> 3742         callOperation(operationBitAndBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 3743         break;
 3744     case ValueBitXor:
<span class="line-modified"> 3745         callOperation(operationBitXorBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 3746         break;
 3747     case ValueBitOr:
<span class="line-modified"> 3748         callOperation(operationBitOrBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 3749         break;
 3750     default:
 3751         RELEASE_ASSERT_NOT_REACHED();
 3752     }
 3753 
 3754     m_jit.exceptionCheck();
 3755     cellResult(resultGPR, node);
 3756 }
 3757 
 3758 void SpeculativeJIT::compileBitwiseOp(Node* node)
 3759 {
 3760     NodeType op = node-&gt;op();
 3761     Edge&amp; leftChild = node-&gt;child1();
 3762     Edge&amp; rightChild = node-&gt;child2();
 3763 
 3764     if (leftChild-&gt;isInt32Constant()) {
 3765         SpeculateInt32Operand op2(this, rightChild);
 3766         GPRTemporary result(this, Reuse, op2);
 3767 
 3768         bitOp(op, leftChild-&gt;asInt32(), op2.gpr(), result.gpr());
</pre>
<hr />
<pre>
 3777 
 3778         bitOp(op, rightChild-&gt;asInt32(), op1.gpr(), result.gpr());
 3779 
 3780         int32Result(result.gpr(), node);
 3781         return;
 3782     }
 3783 
 3784     SpeculateInt32Operand op1(this, leftChild);
 3785     SpeculateInt32Operand op2(this, rightChild);
 3786     GPRTemporary result(this, Reuse, op1, op2);
 3787 
 3788     GPRReg reg1 = op1.gpr();
 3789     GPRReg reg2 = op2.gpr();
 3790     bitOp(op, reg1, reg2, result.gpr());
 3791 
 3792     int32Result(result.gpr(), node);
 3793 }
 3794 
 3795 void SpeculativeJIT::emitUntypedRightShiftBitOp(Node* node)
 3796 {
<span class="line-modified"> 3797     J_JITOperation_GJJ snippetSlowPathFunction = node-&gt;op() == ValueBitRShift</span>
 3798         ? operationValueBitRShift : operationValueBitURShift;
<span class="line-modified"> 3799     JITRightShiftGenerator::ShiftType shiftType = node-&gt;op() == ValueBitRShift</span>
 3800         ? JITRightShiftGenerator::SignedShift : JITRightShiftGenerator::UnsignedShift;
 3801 
 3802     Edge&amp; leftChild = node-&gt;child1();
 3803     Edge&amp; rightChild = node-&gt;child2();
 3804 
 3805     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3806         JSValueOperand left(this, leftChild);
 3807         JSValueOperand right(this, rightChild);
 3808         JSValueRegs leftRegs = left.jsValueRegs();
 3809         JSValueRegs rightRegs = right.jsValueRegs();
 3810 
 3811         flushRegisters();
 3812         JSValueRegsFlushedCallResult result(this);
 3813         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 3814         callOperation(snippetSlowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 3815         m_jit.exceptionCheck();
 3816 
 3817         jsValueResult(resultRegs, node);
 3818         return;
 3819     }
 3820 
 3821     Optional&lt;JSValueOperand&gt; left;
 3822     Optional&lt;JSValueOperand&gt; right;
 3823 
 3824     JSValueRegs leftRegs;
 3825     JSValueRegs rightRegs;
 3826 
 3827     FPRTemporary leftNumber(this);
 3828     FPRReg leftFPR = leftNumber.fpr();
 3829 
 3830 #if USE(JSVALUE64)
 3831     GPRTemporary result(this);
 3832     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 3833     GPRTemporary scratch(this);
 3834     GPRReg scratchGPR = scratch.gpr();
</pre>
<hr />
<pre>
 3864     }
 3865 
 3866     JITRightShiftGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs,
 3867         leftFPR, scratchGPR, scratchFPR, shiftType);
 3868     gen.generateFastPath(m_jit);
 3869 
 3870     ASSERT(gen.didEmitFastPath());
 3871     gen.endJumpList().append(m_jit.jump());
 3872 
 3873     gen.slowPathJumpList().link(&amp;m_jit);
 3874     silentSpillAllRegisters(resultRegs);
 3875 
 3876     if (leftOperand.isConst()) {
 3877         leftRegs = resultRegs;
 3878         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 3879     } else if (rightOperand.isConst()) {
 3880         rightRegs = resultRegs;
 3881         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 3882     }
 3883 
<span class="line-modified"> 3884     callOperation(snippetSlowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 3885 
 3886     silentFillAllRegisters();
 3887     m_jit.exceptionCheck();
 3888 
 3889     gen.endJumpList().link(&amp;m_jit);
 3890     jsValueResult(resultRegs, node);
 3891     return;
 3892 }
 3893 
 3894 void SpeculativeJIT::compileValueLShiftOp(Node* node)
 3895 {
 3896     Edge&amp; leftChild = node-&gt;child1();
 3897     Edge&amp; rightChild = node-&gt;child2();
 3898 
 3899     if (node-&gt;binaryUseKind() == BigIntUse) {
 3900         SpeculateCellOperand left(this, leftChild);
 3901         SpeculateCellOperand right(this, rightChild);
 3902         GPRReg leftGPR = left.gpr();
 3903         GPRReg rightGPR = right.gpr();
 3904 
 3905         speculateBigInt(leftChild, leftGPR);
 3906         speculateBigInt(rightChild, rightGPR);
 3907 
 3908         flushRegisters();
 3909         GPRFlushedCallResult result(this);
 3910         GPRReg resultGPR = result.gpr();
 3911 
<span class="line-modified"> 3912         callOperation(operationBitLShiftBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 3913         m_jit.exceptionCheck();
 3914         cellResult(resultGPR, node);
 3915         return;
 3916     }
 3917 
 3918     ASSERT(leftChild.useKind() == UntypedUse &amp;&amp; rightChild.useKind() == UntypedUse);
 3919     emitUntypedBitOp&lt;JITLeftShiftGenerator, operationValueBitLShift&gt;(node);
 3920 }
 3921 
<span class="line-added"> 3922 void SpeculativeJIT::compileValueBitRShift(Node* node)</span>
<span class="line-added"> 3923 {</span>
<span class="line-added"> 3924     Edge&amp; leftChild = node-&gt;child1();</span>
<span class="line-added"> 3925     Edge&amp; rightChild = node-&gt;child2();</span>
<span class="line-added"> 3926 </span>
<span class="line-added"> 3927     if (node-&gt;isBinaryUseKind(BigIntUse)) {</span>
<span class="line-added"> 3928         SpeculateCellOperand left(this, leftChild);</span>
<span class="line-added"> 3929         SpeculateCellOperand right(this, rightChild);</span>
<span class="line-added"> 3930         GPRReg leftGPR = left.gpr();</span>
<span class="line-added"> 3931         GPRReg rightGPR = right.gpr();</span>
<span class="line-added"> 3932 </span>
<span class="line-added"> 3933         speculateBigInt(leftChild, leftGPR);</span>
<span class="line-added"> 3934         speculateBigInt(rightChild, rightGPR);</span>
<span class="line-added"> 3935 </span>
<span class="line-added"> 3936         flushRegisters();</span>
<span class="line-added"> 3937         GPRFlushedCallResult result(this);</span>
<span class="line-added"> 3938         GPRReg resultGPR = result.gpr();</span>
<span class="line-added"> 3939         callOperation(operationBitRShiftBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
<span class="line-added"> 3940         m_jit.exceptionCheck();</span>
<span class="line-added"> 3941 </span>
<span class="line-added"> 3942         cellResult(resultGPR, node);</span>
<span class="line-added"> 3943         return;</span>
<span class="line-added"> 3944     }</span>
<span class="line-added"> 3945 </span>
<span class="line-added"> 3946     ASSERT(leftChild.useKind() == UntypedUse &amp;&amp; rightChild.useKind() == UntypedUse);</span>
<span class="line-added"> 3947     emitUntypedRightShiftBitOp(node);</span>
<span class="line-added"> 3948 }</span>
<span class="line-added"> 3949 </span>
 3950 void SpeculativeJIT::compileShiftOp(Node* node)
 3951 {
 3952     NodeType op = node-&gt;op();
 3953     Edge&amp; leftChild = node-&gt;child1();
 3954     Edge&amp; rightChild = node-&gt;child2();
 3955 
 3956     if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
<span class="line-modified"> 3957         RELEASE_ASSERT(op == BitURShift);</span>
<span class="line-modified"> 3958         emitUntypedRightShiftBitOp(node);</span>
<span class="line-modified"> 3959         return;</span>





 3960     }
 3961 
 3962     if (rightChild-&gt;isInt32Constant()) {
 3963         SpeculateInt32Operand op1(this, leftChild);
 3964         GPRTemporary result(this, Reuse, op1);
 3965 
 3966         shiftOp(op, op1.gpr(), rightChild-&gt;asInt32() &amp; 0x1f, result.gpr());
 3967 
 3968         int32Result(result.gpr(), node);
 3969     } else {
 3970         // Do not allow shift amount to be used as the result, MacroAssembler does not permit this.
 3971         SpeculateInt32Operand op1(this, leftChild);
 3972         SpeculateInt32Operand op2(this, rightChild);
 3973         GPRTemporary result(this, Reuse, op1);
 3974 
 3975         GPRReg reg1 = op1.gpr();
 3976         GPRReg reg2 = op2.gpr();
 3977         shiftOp(op, reg1, reg2, result.gpr());
 3978 
 3979         int32Result(result.gpr(), node);
 3980     }
 3981 }
 3982 
 3983 void SpeculativeJIT::compileValueAdd(Node* node)
 3984 {
 3985     Edge&amp; leftChild = node-&gt;child1();
 3986     Edge&amp; rightChild = node-&gt;child2();
 3987 
 3988     if (node-&gt;isBinaryUseKind(BigIntUse)) {
 3989         SpeculateCellOperand left(this, node-&gt;child1());
 3990         SpeculateCellOperand right(this, node-&gt;child2());
 3991         GPRReg leftGPR = left.gpr();
 3992         GPRReg rightGPR = right.gpr();
 3993 
 3994         speculateBigInt(leftChild, leftGPR);
 3995         speculateBigInt(rightChild, rightGPR);
 3996 
 3997         flushRegisters();
 3998         GPRFlushedCallResult result(this);
 3999         GPRReg resultGPR = result.gpr();
<span class="line-modified"> 4000         callOperation(operationAddBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 4001         m_jit.exceptionCheck();
 4002 
 4003         cellResult(resultGPR, node);
 4004         return;
 4005     }
 4006 
 4007     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 4008         JSValueOperand left(this, leftChild);
 4009         JSValueOperand right(this, rightChild);
 4010         JSValueRegs leftRegs = left.jsValueRegs();
 4011         JSValueRegs rightRegs = right.jsValueRegs();
 4012 
 4013         flushRegisters();
 4014         JSValueRegsFlushedCallResult result(this);
 4015         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 4016         callOperation(operationValueAddNotNumber, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 4017         m_jit.exceptionCheck();
 4018 
 4019         jsValueResult(resultRegs, node);
 4020         return;
 4021     }
 4022 
 4023 #if USE(JSVALUE64)
 4024     bool needsScratchGPRReg = true;
 4025     bool needsScratchFPRReg = false;
 4026 #else
 4027     bool needsScratchGPRReg = true;
 4028     bool needsScratchFPRReg = true;
 4029 #endif
 4030 
 4031     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 4032     BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4033     BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 4034     JITAddIC* addIC = m_jit.codeBlock()-&gt;addJITAddIC(arithProfile);
 4035     auto repatchingFunction = operationValueAddOptimize;
 4036     auto nonRepatchingFunction = operationValueAdd;
 4037 
 4038     compileMathIC(node, addIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4039 }
 4040 
 4041 void SpeculativeJIT::compileValueSub(Node* node)
 4042 {
 4043     Edge&amp; leftChild = node-&gt;child1();
 4044     Edge&amp; rightChild = node-&gt;child2();
 4045 
 4046     if (node-&gt;binaryUseKind() == UntypedUse) {
 4047 #if USE(JSVALUE64)
 4048         bool needsScratchGPRReg = true;
 4049         bool needsScratchFPRReg = false;
 4050 #else
 4051         bool needsScratchGPRReg = true;
 4052         bool needsScratchFPRReg = true;
 4053 #endif
 4054 
 4055         CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 4056         BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4057         BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 4058         JITSubIC* subIC = m_jit.codeBlock()-&gt;addJITSubIC(arithProfile);
 4059         auto repatchingFunction = operationValueSubOptimize;
 4060         auto nonRepatchingFunction = operationValueSub;
 4061 
 4062         compileMathIC(node, subIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4063         return;
 4064     }
 4065 
 4066     ASSERT(leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse);
 4067 
 4068     SpeculateCellOperand left(this, node-&gt;child1());
 4069     SpeculateCellOperand right(this, node-&gt;child2());
 4070     GPRReg leftGPR = left.gpr();
 4071     GPRReg rightGPR = right.gpr();
 4072 
 4073     speculateBigInt(leftChild, leftGPR);
 4074     speculateBigInt(rightChild, rightGPR);
 4075 
 4076     flushRegisters();
 4077     GPRFlushedCallResult result(this);
 4078     GPRReg resultGPR = result.gpr();
 4079 
<span class="line-modified"> 4080     callOperation(operationSubBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 4081 
 4082     m_jit.exceptionCheck();
 4083     cellResult(resultGPR, node);
 4084 }
 4085 
 4086 template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
 4087 void SpeculativeJIT::compileMathIC(Node* node, JITBinaryMathIC&lt;Generator&gt;* mathIC, bool needsScratchGPRReg, bool needsScratchFPRReg, RepatchingFunction repatchingFunction, NonRepatchingFunction nonRepatchingFunction)
 4088 {
 4089     Edge&amp; leftChild = node-&gt;child1();
 4090     Edge&amp; rightChild = node-&gt;child2();
 4091 
 4092     Optional&lt;JSValueOperand&gt; left;
 4093     Optional&lt;JSValueOperand&gt; right;
 4094 
 4095     JSValueRegs leftRegs;
 4096     JSValueRegs rightRegs;
 4097 
 4098     FPRTemporary leftNumber(this);
 4099     FPRTemporary rightNumber(this);
 4100     FPRReg leftFPR = leftNumber.fpr();
</pre>
<hr />
<pre>
 4167         addSlowPathGeneratorLambda([=, savePlans = WTFMove(savePlans)] () {
 4168             addICGenerationState-&gt;slowPathJumps.link(&amp;m_jit);
 4169             addICGenerationState-&gt;slowPathStart = m_jit.label();
 4170 #if ENABLE(MATH_IC_STATS)
 4171             auto slowPathStart = m_jit.label();
 4172 #endif
 4173 
 4174             silentSpill(savePlans);
 4175 
 4176             auto innerLeftRegs = leftRegs;
 4177             auto innerRightRegs = rightRegs;
 4178             if (Generator::isLeftOperandValidConstant(leftOperand)) {
 4179                 innerLeftRegs = resultRegs;
 4180                 m_jit.moveValue(leftChild-&gt;asJSValue(), innerLeftRegs);
 4181             } else if (Generator::isRightOperandValidConstant(rightOperand)) {
 4182                 innerRightRegs = resultRegs;
 4183                 m_jit.moveValue(rightChild-&gt;asJSValue(), innerRightRegs);
 4184             }
 4185 
 4186             if (addICGenerationState-&gt;shouldSlowPathRepatch)
<span class="line-modified"> 4187                 addICGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_GJJMic&gt;(repatchingFunction), resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), innerLeftRegs, innerRightRegs, TrustedImmPtr(mathIC));</span>
 4188             else
<span class="line-modified"> 4189                 addICGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), innerLeftRegs, innerRightRegs);</span>
 4190 
 4191             silentFill(savePlans);
 4192             m_jit.exceptionCheck();
 4193             m_jit.jump().linkTo(done, &amp;m_jit);
 4194 
 4195             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4196                 mathIC-&gt;finalizeInlineCode(*addICGenerationState, linkBuffer);
 4197             });
 4198 
 4199 #if ENABLE(MATH_IC_STATS)
 4200             auto slowPathEnd = m_jit.label();
 4201             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4202                 size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathStart).executableAddress());
 4203                 mathIC-&gt;m_generatedCodeSize += size;
 4204             });
 4205 #endif
 4206 
 4207         });
 4208     } else {
 4209         if (Generator::isLeftOperandValidConstant(leftOperand)) {
 4210             left.emplace(this, leftChild);
 4211             leftRegs = left-&gt;jsValueRegs();
 4212         } else if (Generator::isRightOperandValidConstant(rightOperand)) {
 4213             right.emplace(this, rightChild);
 4214             rightRegs = right-&gt;jsValueRegs();
 4215         }
 4216 
 4217         flushRegisters();
<span class="line-modified"> 4218         callOperation(nonRepatchingFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 4219         m_jit.exceptionCheck();
 4220     }
 4221 
 4222 #if ENABLE(MATH_IC_STATS)
 4223     auto inlineEnd = m_jit.label();
 4224     m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4225         size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineStart).executableAddress());
 4226         mathIC-&gt;m_generatedCodeSize += size;
 4227     });
 4228 #endif
 4229 
 4230     jsValueResult(resultRegs, node);
 4231     return;
 4232 }
 4233 
 4234 void SpeculativeJIT::compileInstanceOfCustom(Node* node)
 4235 {
 4236     // We could do something smarter here but this case is currently super rare and unless
 4237     // Symbol.hasInstance becomes popular will likely remain that way.
 4238 
 4239     JSValueOperand value(this, node-&gt;child1());
 4240     SpeculateCellOperand constructor(this, node-&gt;child2());
 4241     JSValueOperand hasInstanceValue(this, node-&gt;child3());
 4242     GPRTemporary result(this);
 4243 
 4244     JSValueRegs valueRegs = value.jsValueRegs();
 4245     GPRReg constructorGPR = constructor.gpr();
 4246     JSValueRegs hasInstanceRegs = hasInstanceValue.jsValueRegs();
 4247     GPRReg resultGPR = result.gpr();
 4248 
 4249     MacroAssembler::Jump slowCase = m_jit.jump();
 4250 
<span class="line-modified"> 4251     addSlowPathGenerator(slowPathCall(slowCase, this, operationInstanceOfCustom, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, constructorGPR, hasInstanceRegs));</span>
 4252 
 4253     unblessedBooleanResult(resultGPR, node);
 4254 }
 4255 
 4256 void SpeculativeJIT::compileIsCellWithType(Node* node)
 4257 {
 4258     switch (node-&gt;child1().useKind()) {
 4259     case UntypedUse: {
 4260         JSValueOperand value(this, node-&gt;child1());
 4261         GPRTemporary result(this, Reuse, value, PayloadWord);
 4262 
 4263         JSValueRegs valueRegs = value.jsValueRegs();
 4264         GPRReg resultGPR = result.gpr();
 4265 
 4266         JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 4267 
 4268         m_jit.compare8(JITCompiler::Equal,
 4269             JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()),
 4270             TrustedImm32(node-&gt;queriedType()),
 4271             resultGPR);
</pre>
<hr />
<pre>
 4326 
 4327     done.link(&amp;m_jit);
 4328     blessedBooleanResult(resultGPR, node);
 4329 }
 4330 
 4331 void SpeculativeJIT::compileToObjectOrCallObjectConstructor(Node* node)
 4332 {
 4333     RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse);
 4334 
 4335     JSValueOperand value(this, node-&gt;child1());
 4336     GPRTemporary result(this, Reuse, value, PayloadWord);
 4337 
 4338     JSValueRegs valueRegs = value.jsValueRegs();
 4339     GPRReg resultGPR = result.gpr();
 4340 
 4341     MacroAssembler::JumpList slowCases;
 4342     slowCases.append(m_jit.branchIfNotCell(valueRegs));
 4343     slowCases.append(m_jit.branchIfNotObject(valueRegs.payloadGPR()));
 4344     m_jit.move(valueRegs.payloadGPR(), resultGPR);
 4345 
<span class="line-modified"> 4346     if (node-&gt;op() == ToObject) {</span>
<span class="line-modified"> 4347         UniquedStringImpl* errorMessage = nullptr;</span>
<span class="line-modified"> 4348         if (node-&gt;identifierNumber() != UINT32_MAX)</span>
<span class="line-added"> 4349             errorMessage = identifierUID(node-&gt;identifierNumber());</span>
<span class="line-added"> 4350         addSlowPathGenerator(slowPathCall(slowCases, this, operationToObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, errorMessage));</span>
<span class="line-added"> 4351     } else</span>
 4352         addSlowPathGenerator(slowPathCall(slowCases, this, operationCallObjectConstructor, resultGPR, TrustedImmPtr(node-&gt;cellOperand()), valueRegs));
 4353 
 4354     cellResult(resultGPR, node);
 4355 }
 4356 
 4357 void SpeculativeJIT::compileArithAdd(Node* node)
 4358 {
 4359     switch (node-&gt;binaryUseKind()) {
 4360     case Int32Use: {
 4361         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4362 
 4363         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4364             SpeculateInt32Operand op1(this, node-&gt;child1());
 4365             GPRTemporary result(this, Reuse, op1);
 4366 
 4367             GPRReg gpr1 = op1.gpr();
 4368             int32_t imm2 = node-&gt;child2()-&gt;asInt32();
 4369             GPRReg gprResult = result.gpr();
 4370 
 4371             if (!shouldCheckOverflow(node-&gt;arithMode())) {
</pre>
<hr />
<pre>
 4476             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, result.gpr()));
 4477         int32Result(result.gpr(), node);
 4478         break;
 4479     }
 4480 
 4481     case DoubleRepUse: {
 4482         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4483         FPRTemporary result(this);
 4484 
 4485         m_jit.absDouble(op1.fpr(), result.fpr());
 4486         doubleResult(result.fpr(), node);
 4487         break;
 4488     }
 4489 
 4490     default: {
 4491         DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
 4492         JSValueOperand op1(this, node-&gt;child1());
 4493         JSValueRegs op1Regs = op1.jsValueRegs();
 4494         flushRegisters();
 4495         FPRResult result(this);
<span class="line-modified"> 4496         callOperation(operationArithAbs, result.fpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 4497         m_jit.exceptionCheck();
 4498         doubleResult(result.fpr(), node);
 4499         break;
 4500     }
 4501     }
 4502 }
 4503 
 4504 void SpeculativeJIT::compileArithClz32(Node* node)
 4505 {
 4506     if (node-&gt;child1().useKind() == Int32Use || node-&gt;child1().useKind() == KnownInt32Use) {
 4507         SpeculateInt32Operand value(this, node-&gt;child1());
 4508         GPRTemporary result(this, Reuse, value);
 4509         GPRReg valueReg = value.gpr();
 4510         GPRReg resultReg = result.gpr();
 4511         m_jit.countLeadingZeros32(valueReg, resultReg);
 4512         int32Result(resultReg, node);
 4513         return;
 4514     }
 4515     JSValueOperand op1(this, node-&gt;child1());
 4516     JSValueRegs op1Regs = op1.jsValueRegs();
 4517     GPRTemporary result(this);
 4518     GPRReg resultReg = result.gpr();
 4519     flushRegisters();
<span class="line-modified"> 4520     callOperation(operationArithClz32, resultReg, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 4521     m_jit.exceptionCheck();
 4522     int32Result(resultReg, node);
 4523 }
 4524 
<span class="line-modified"> 4525 void SpeculativeJIT::compileArithDoubleUnaryOp(Node* node, double (*doubleFunction)(double), double (*operation)(JSGlobalObject*, EncodedJSValue))</span>
 4526 {
 4527     if (node-&gt;child1().useKind() == DoubleRepUse) {
 4528         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4529         FPRReg op1FPR = op1.fpr();
 4530 
 4531         flushRegisters();
 4532 
 4533         FPRResult result(this);
 4534         callOperation(doubleFunction, result.fpr(), op1FPR);
 4535 
 4536         doubleResult(result.fpr(), node);
 4537         return;
 4538     }
 4539 
 4540     JSValueOperand op1(this, node-&gt;child1());
 4541     JSValueRegs op1Regs = op1.jsValueRegs();
 4542     flushRegisters();
 4543     FPRResult result(this);
<span class="line-modified"> 4544     callOperation(operation, result.fpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 4545     m_jit.exceptionCheck();
 4546     doubleResult(result.fpr(), node);
 4547 }
 4548 
 4549 void SpeculativeJIT::compileArithSub(Node* node)
 4550 {
 4551     switch (node-&gt;binaryUseKind()) {
 4552     case Int32Use: {
 4553         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4554 
 4555         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4556             SpeculateInt32Operand op1(this, node-&gt;child1());
 4557             int32_t imm2 = node-&gt;child2()-&gt;asInt32();
 4558             GPRTemporary result(this);
 4559 
 4560             if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4561                 m_jit.move(op1.gpr(), result.gpr());
 4562                 m_jit.sub32(Imm32(imm2), result.gpr());
 4563             } else {
 4564                 GPRTemporary scratch(this);
</pre>
<hr />
<pre>
 4630 
 4631     case DoubleRepUse: {
 4632         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4633         SpeculateDoubleOperand op2(this, node-&gt;child2());
 4634         FPRTemporary result(this, op1);
 4635 
 4636         FPRReg reg1 = op1.fpr();
 4637         FPRReg reg2 = op2.fpr();
 4638         m_jit.subDouble(reg1, reg2, result.fpr());
 4639 
 4640         doubleResult(result.fpr(), node);
 4641         return;
 4642     }
 4643 
 4644     default:
 4645         RELEASE_ASSERT_NOT_REACHED();
 4646         return;
 4647     }
 4648 }
 4649 
<span class="line-added"> 4650 void SpeculativeJIT::compileIncOrDec(Node* node)</span>
<span class="line-added"> 4651 {</span>
<span class="line-added"> 4652     // In all other cases the node should have been transformed into an add or a sub by FixupPhase</span>
<span class="line-added"> 4653     ASSERT(node-&gt;child1().useKind() == UntypedUse);</span>
<span class="line-added"> 4654 </span>
<span class="line-added"> 4655     JSValueOperand op1(this, node-&gt;child1());</span>
<span class="line-added"> 4656     JSValueRegs op1Regs = op1.jsValueRegs();</span>
<span class="line-added"> 4657     flushRegisters();</span>
<span class="line-added"> 4658     JSValueRegsFlushedCallResult result(this);</span>
<span class="line-added"> 4659     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added"> 4660     auto operation = node-&gt;op() == Inc ? operationInc : operationDec;</span>
<span class="line-added"> 4661     callOperation(operation, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
<span class="line-added"> 4662     m_jit.exceptionCheck();</span>
<span class="line-added"> 4663     jsValueResult(resultRegs, node);</span>
<span class="line-added"> 4664 }</span>
<span class="line-added"> 4665 </span>
 4666 void SpeculativeJIT::compileValueNegate(Node* node)
 4667 {
 4668     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 4669     BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4670     UnaryArithProfile* arithProfile = baselineCodeBlock-&gt;unaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 4671     JITNegIC* negIC = m_jit.codeBlock()-&gt;addJITNegIC(arithProfile);
 4672     auto repatchingFunction = operationArithNegateOptimize;
 4673     auto nonRepatchingFunction = operationArithNegate;
 4674     bool needsScratchGPRReg = true;
 4675     compileMathIC(node, negIC, needsScratchGPRReg, repatchingFunction, nonRepatchingFunction);
 4676 }
 4677 
 4678 void SpeculativeJIT::compileArithNegate(Node* node)
 4679 {
 4680     switch (node-&gt;child1().useKind()) {
 4681     case Int32Use: {
 4682         SpeculateInt32Operand op1(this, node-&gt;child1());
 4683         GPRTemporary result(this);
 4684 
 4685         m_jit.move(op1.gpr(), result.gpr());
 4686 
 4687         // Note: there is no notion of being not used as a number, but someone
 4688         // caring about negative zero.
 4689 
 4690         if (!shouldCheckOverflow(node-&gt;arithMode()))
</pre>
<hr />
<pre>
 4784     bool shouldEmitProfiling = false;
 4785     bool generatedInline = mathIC-&gt;generateInline(m_jit, *icGenerationState, shouldEmitProfiling);
 4786     if (generatedInline) {
 4787         ASSERT(!icGenerationState-&gt;slowPathJumps.empty());
 4788 
 4789         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
 4790         silentSpillAllRegistersImpl(false, savePlans, resultRegs);
 4791 
 4792         auto done = m_jit.label();
 4793 
 4794         addSlowPathGeneratorLambda([=, savePlans = WTFMove(savePlans)] () {
 4795             icGenerationState-&gt;slowPathJumps.link(&amp;m_jit);
 4796             icGenerationState-&gt;slowPathStart = m_jit.label();
 4797 #if ENABLE(MATH_IC_STATS)
 4798             auto slowPathStart = m_jit.label();
 4799 #endif
 4800 
 4801             silentSpill(savePlans);
 4802 
 4803             if (icGenerationState-&gt;shouldSlowPathRepatch)
<span class="line-modified"> 4804                 icGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_GJMic&gt;(repatchingFunction), resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), childRegs, TrustedImmPtr(mathIC));</span>
 4805             else
<span class="line-modified"> 4806                 icGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), childRegs);</span>
 4807 
 4808             silentFill(savePlans);
 4809             m_jit.exceptionCheck();
 4810             m_jit.jump().linkTo(done, &amp;m_jit);
 4811 
 4812             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4813                 mathIC-&gt;finalizeInlineCode(*icGenerationState, linkBuffer);
 4814             });
 4815 
 4816 #if ENABLE(MATH_IC_STATS)
 4817             auto slowPathEnd = m_jit.label();
 4818             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4819                 size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathStart).executableAddress());
 4820                 mathIC-&gt;m_generatedCodeSize += size;
 4821             });
 4822 #endif
 4823 
 4824         });
 4825     } else {
 4826         flushRegisters();
<span class="line-modified"> 4827         callOperation(nonRepatchingFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), childRegs);</span>
 4828         m_jit.exceptionCheck();
 4829     }
 4830 
 4831 #if ENABLE(MATH_IC_STATS)
 4832     auto inlineEnd = m_jit.label();
 4833     m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4834         size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineStart).executableAddress());
 4835         mathIC-&gt;m_generatedCodeSize += size;
 4836     });
 4837 #endif
 4838 
 4839     jsValueResult(resultRegs, node);
 4840     return;
 4841 }
 4842 
 4843 void SpeculativeJIT::compileValueMul(Node* node)
 4844 {
 4845     Edge&amp; leftChild = node-&gt;child1();
 4846     Edge&amp; rightChild = node-&gt;child2();
 4847 
 4848     if (leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse) {
 4849         SpeculateCellOperand left(this, leftChild);
 4850         SpeculateCellOperand right(this, rightChild);
 4851         GPRReg leftGPR = left.gpr();
 4852         GPRReg rightGPR = right.gpr();
 4853 
 4854         speculateBigInt(leftChild, leftGPR);
 4855         speculateBigInt(rightChild, rightGPR);
 4856 
 4857         flushRegisters();
 4858         GPRFlushedCallResult result(this);
 4859         GPRReg resultGPR = result.gpr();
 4860 
<span class="line-modified"> 4861         callOperation(operationMulBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 4862 
 4863         m_jit.exceptionCheck();
 4864         cellResult(resultGPR, node);
 4865         return;
 4866     }
 4867 
 4868     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 4869         JSValueOperand left(this, leftChild);
 4870         JSValueOperand right(this, rightChild);
 4871         JSValueRegs leftRegs = left.jsValueRegs();
 4872         JSValueRegs rightRegs = right.jsValueRegs();
 4873 
 4874         flushRegisters();
 4875         JSValueRegsFlushedCallResult result(this);
 4876         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 4877         callOperation(operationValueMul, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 4878         m_jit.exceptionCheck();
 4879 
 4880         jsValueResult(resultRegs, node);
 4881         return;
 4882     }
 4883 
 4884     bool needsScratchGPRReg = true;
 4885 #if USE(JSVALUE64)
 4886     bool needsScratchFPRReg = false;
 4887 #else
 4888     bool needsScratchFPRReg = true;
 4889 #endif
 4890 
 4891     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 4892     BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4893     BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 4894     JITMulIC* mulIC = m_jit.codeBlock()-&gt;addJITMulIC(arithProfile);
 4895     auto repatchingFunction = operationValueMulOptimize;
 4896     auto nonRepatchingFunction = operationValueMul;
 4897 
 4898     compileMathIC(node, mulIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4899 }
 4900 
 4901 void SpeculativeJIT::compileArithMul(Node* node)
 4902 {
 4903     switch (node-&gt;binaryUseKind()) {
 4904     case Int32Use: {
 4905         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4906             SpeculateInt32Operand op1(this, node-&gt;child1());
 4907             GPRTemporary result(this);
 4908 
 4909             int32_t imm = node-&gt;child2()-&gt;asInt32();
 4910             GPRReg op1GPR = op1.gpr();
 4911             GPRReg resultGPR = result.gpr();
 4912 
 4913             if (!shouldCheckOverflow(node-&gt;arithMode()))
</pre>
<hr />
<pre>
 5043 }
 5044 
 5045 void SpeculativeJIT::compileValueDiv(Node* node)
 5046 {
 5047     Edge&amp; leftChild = node-&gt;child1();
 5048     Edge&amp; rightChild = node-&gt;child2();
 5049 
 5050     if (leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse) {
 5051         SpeculateCellOperand left(this, leftChild);
 5052         SpeculateCellOperand right(this, rightChild);
 5053         GPRReg leftGPR = left.gpr();
 5054         GPRReg rightGPR = right.gpr();
 5055 
 5056         speculateBigInt(leftChild, leftGPR);
 5057         speculateBigInt(rightChild, rightGPR);
 5058 
 5059         flushRegisters();
 5060         GPRFlushedCallResult result(this);
 5061         GPRReg resultGPR = result.gpr();
 5062 
<span class="line-modified"> 5063         callOperation(operationDivBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 5064 
 5065         m_jit.exceptionCheck();
 5066         cellResult(resultGPR, node);
 5067         return;
 5068     }
 5069 
 5070     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 5071         JSValueOperand left(this, leftChild);
 5072         JSValueOperand right(this, rightChild);
 5073         JSValueRegs leftRegs = left.jsValueRegs();
 5074         JSValueRegs rightRegs = right.jsValueRegs();
 5075 
 5076         flushRegisters();
 5077         JSValueRegsFlushedCallResult result(this);
 5078         JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 5079         callOperation(operationValueDiv, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 5080         m_jit.exceptionCheck();
 5081 
 5082         jsValueResult(resultRegs, node);
 5083         return;
 5084     }
 5085 
 5086     Optional&lt;JSValueOperand&gt; left;
 5087     Optional&lt;JSValueOperand&gt; right;
 5088 
 5089     JSValueRegs leftRegs;
 5090     JSValueRegs rightRegs;
 5091 
 5092     FPRTemporary leftNumber(this);
 5093     FPRTemporary rightNumber(this);
 5094     FPRReg leftFPR = leftNumber.fpr();
 5095     FPRReg rightFPR = rightNumber.fpr();
 5096     FPRTemporary fprScratch(this);
 5097     FPRReg scratchFPR = fprScratch.fpr();
 5098 
 5099 #if USE(JSVALUE64)
</pre>
<hr />
<pre>
 5141 
 5142     JITDivGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs,
 5143         leftFPR, rightFPR, scratchGPR, scratchFPR);
 5144     gen.generateFastPath(m_jit);
 5145 
 5146     ASSERT(gen.didEmitFastPath());
 5147     gen.endJumpList().append(m_jit.jump());
 5148 
 5149     gen.slowPathJumpList().link(&amp;m_jit);
 5150     silentSpillAllRegisters(resultRegs);
 5151 
 5152     if (leftOperand.isConst()) {
 5153         leftRegs = resultRegs;
 5154         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 5155     }
 5156     if (rightOperand.isConst()) {
 5157         rightRegs = resultRegs;
 5158         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 5159     }
 5160 
<span class="line-modified"> 5161     callOperation(operationValueDiv, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 5162 
 5163     silentFillAllRegisters();
 5164     m_jit.exceptionCheck();
 5165 
 5166     gen.endJumpList().link(&amp;m_jit);
 5167     jsValueResult(resultRegs, node);
 5168 }
 5169 
 5170 void SpeculativeJIT::compileArithDiv(Node* node)
 5171 {
 5172     switch (node-&gt;binaryUseKind()) {
 5173     case Int32Use: {
<span class="line-modified"> 5174 #if CPU(X86_64)</span>
 5175         SpeculateInt32Operand op1(this, node-&gt;child1());
 5176         SpeculateInt32Operand op2(this, node-&gt;child2());
 5177         GPRTemporary eax(this, X86Registers::eax);
 5178         GPRTemporary edx(this, X86Registers::edx);
 5179         GPRReg op1GPR = op1.gpr();
 5180         GPRReg op2GPR = op2.gpr();
 5181 
 5182         GPRReg op2TempGPR;
 5183         GPRReg temp;
 5184         if (op2GPR == X86Registers::eax || op2GPR == X86Registers::edx) {
 5185             op2TempGPR = allocate();
 5186             temp = op2TempGPR;
 5187         } else {
 5188             op2TempGPR = InvalidGPRReg;
 5189             if (op1GPR == X86Registers::eax)
 5190                 temp = X86Registers::edx;
 5191             else
 5192                 temp = X86Registers::eax;
 5193         }
 5194 
</pre>
<hr />
<pre>
 5305         RELEASE_ASSERT_NOT_REACHED();
 5306         break;
 5307     }
 5308 }
 5309 
 5310 void SpeculativeJIT::compileArithFRound(Node* node)
 5311 {
 5312     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5313         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5314         FPRTemporary result(this, op1);
 5315         m_jit.convertDoubleToFloat(op1.fpr(), result.fpr());
 5316         m_jit.convertFloatToDouble(result.fpr(), result.fpr());
 5317         doubleResult(result.fpr(), node);
 5318         return;
 5319     }
 5320 
 5321     JSValueOperand op1(this, node-&gt;child1());
 5322     JSValueRegs op1Regs = op1.jsValueRegs();
 5323     flushRegisters();
 5324     FPRResult result(this);
<span class="line-modified"> 5325     callOperation(operationArithFRound, result.fpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 5326     m_jit.exceptionCheck();
 5327     doubleResult(result.fpr(), node);
 5328 }
 5329 
 5330 void SpeculativeJIT::compileValueMod(Node* node)
 5331 {
 5332     Edge&amp; leftChild = node-&gt;child1();
 5333     Edge&amp; rightChild = node-&gt;child2();
 5334 
 5335     if (node-&gt;binaryUseKind() == BigIntUse) {
 5336         SpeculateCellOperand left(this, leftChild);
 5337         SpeculateCellOperand right(this, rightChild);
 5338         GPRReg leftGPR = left.gpr();
 5339         GPRReg rightGPR = right.gpr();
 5340 
 5341         speculateBigInt(leftChild, leftGPR);
 5342         speculateBigInt(rightChild, rightGPR);
 5343 
 5344         flushRegisters();
 5345         GPRFlushedCallResult result(this);
 5346         GPRReg resultGPR = result.gpr();
 5347 
<span class="line-modified"> 5348         callOperation(operationModBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 5349 
 5350         m_jit.exceptionCheck();
 5351         cellResult(resultGPR, node);
 5352         return;
 5353     }
 5354 
 5355     DFG_ASSERT(m_jit.graph(), node, node-&gt;binaryUseKind() == UntypedUse, node-&gt;binaryUseKind());
 5356     JSValueOperand op1(this, leftChild);
 5357     JSValueOperand op2(this, rightChild);
 5358     JSValueRegs op1Regs = op1.jsValueRegs();
 5359     JSValueRegs op2Regs = op2.jsValueRegs();
 5360     flushRegisters();
 5361     JSValueRegsFlushedCallResult result(this);
 5362     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 5363     callOperation(operationValueMod, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs, op2Regs);</span>
 5364     m_jit.exceptionCheck();
 5365     jsValueResult(resultRegs, node);
 5366 }
 5367 
 5368 void SpeculativeJIT::compileArithMod(Node* node)
 5369 {
 5370     switch (node-&gt;binaryUseKind()) {
 5371     case Int32Use: {
 5372         // In the fast path, the dividend value could be the final result
 5373         // (in case of |dividend| &lt; |divisor|), so we speculate it as strict int32.
 5374         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 5375 
 5376         if (node-&gt;child2()-&gt;isInt32Constant()) {
 5377             int32_t divisor = node-&gt;child2()-&gt;asInt32();
 5378             if (divisor &gt; 1 &amp;&amp; hasOneBitSet(divisor)) {
 5379                 unsigned logarithm = WTF::fastLog2(static_cast&lt;uint32_t&gt;(divisor));
 5380                 GPRReg dividendGPR = op1.gpr();
 5381                 GPRTemporary result(this);
 5382                 GPRReg resultGPR = result.gpr();
 5383 
</pre>
<hr />
<pre>
 5417                 m_jit.and32(TrustedImm32(-divisor), resultGPR);
 5418 
 5419                 // Subtract resultGPR from dividendGPR, which yields the remainder:
 5420                 //
 5421                 // resultGPR = dividendGPR - resultGPR
 5422                 m_jit.neg32(resultGPR);
 5423                 m_jit.add32(dividendGPR, resultGPR);
 5424 
 5425                 if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5426                     // Check that we&#39;re not about to create negative zero.
 5427                     JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, dividendGPR, TrustedImm32(0));
 5428                     speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, resultGPR));
 5429                     numeratorPositive.link(&amp;m_jit);
 5430                 }
 5431 
 5432                 int32Result(resultGPR, node);
 5433                 return;
 5434             }
 5435         }
 5436 
<span class="line-modified"> 5437 #if CPU(X86_64)</span>
 5438         if (node-&gt;child2()-&gt;isInt32Constant()) {
 5439             int32_t divisor = node-&gt;child2()-&gt;asInt32();
 5440             if (divisor &amp;&amp; divisor != -1) {
 5441                 GPRReg op1Gpr = op1.gpr();
 5442 
 5443                 GPRTemporary eax(this, X86Registers::eax);
 5444                 GPRTemporary edx(this, X86Registers::edx);
 5445                 GPRTemporary scratch(this);
 5446                 GPRReg scratchGPR = scratch.gpr();
 5447 
 5448                 GPRReg op1SaveGPR;
 5449                 if (op1Gpr == X86Registers::eax || op1Gpr == X86Registers::edx) {
 5450                     op1SaveGPR = allocate();
 5451                     ASSERT(op1Gpr != op1SaveGPR);
 5452                     m_jit.move(op1Gpr, op1SaveGPR);
 5453                 } else
 5454                     op1SaveGPR = op1Gpr;
 5455                 ASSERT(op1SaveGPR != X86Registers::eax);
 5456                 ASSERT(op1SaveGPR != X86Registers::edx);
 5457 
 5458                 m_jit.move(op1Gpr, eax.gpr());
 5459                 m_jit.move(TrustedImm32(divisor), scratchGPR);
 5460                 m_jit.x86ConvertToDoubleWord32();
 5461                 m_jit.x86Div32(scratchGPR);
 5462                 if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5463                     JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, op1SaveGPR, TrustedImm32(0));
 5464                     speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, edx.gpr()));
 5465                     numeratorPositive.link(&amp;m_jit);
 5466                 }
 5467 
 5468                 if (op1SaveGPR != op1Gpr)
 5469                     unlock(op1SaveGPR);
 5470 
 5471                 int32Result(edx.gpr(), node);
 5472                 return;
 5473             }
 5474         }
 5475 #endif
 5476 
 5477         SpeculateInt32Operand op2(this, node-&gt;child2());
<span class="line-modified"> 5478 #if CPU(X86_64)</span>
 5479         GPRTemporary eax(this, X86Registers::eax);
 5480         GPRTemporary edx(this, X86Registers::edx);
 5481         GPRReg op1GPR = op1.gpr();
 5482         GPRReg op2GPR = op2.gpr();
 5483 
 5484         GPRReg op2TempGPR;
 5485         GPRReg temp;
 5486         GPRReg op1SaveGPR;
 5487 
 5488         if (op2GPR == X86Registers::eax || op2GPR == X86Registers::edx) {
 5489             op2TempGPR = allocate();
 5490             temp = op2TempGPR;
 5491         } else {
 5492             op2TempGPR = InvalidGPRReg;
 5493             if (op1GPR == X86Registers::eax)
 5494                 temp = X86Registers::edx;
 5495             else
 5496                 temp = X86Registers::eax;
 5497         }
 5498 
</pre>
<hr />
<pre>
 5653             if (producesInteger(node-&gt;arithRoundingMode())) {
 5654                 GPRTemporary roundedResultAsInt32(this);
 5655                 FPRTemporary scratch(this);
 5656                 FPRReg scratchFPR = scratch.fpr();
 5657                 GPRReg resultGPR = roundedResultAsInt32.gpr();
 5658                 JITCompiler::JumpList failureCases;
 5659                 m_jit.branchConvertDoubleToInt32(resultFPR, resultGPR, failureCases, scratchFPR, shouldCheckNegativeZero(node-&gt;arithRoundingMode()));
 5660                 speculationCheck(Overflow, JSValueRegs(), node, failureCases);
 5661 
 5662                 int32Result(resultGPR, node);
 5663             } else
 5664                 doubleResult(resultFPR, node);
 5665         };
 5666 
 5667         if (m_jit.supportsFloatingPointRounding()) {
 5668             switch (node-&gt;op()) {
 5669             case ArithRound: {
 5670                 FPRTemporary result(this);
 5671                 FPRReg resultFPR = result.fpr();
 5672                 if (producesInteger(node-&gt;arithRoundingMode()) &amp;&amp; !shouldCheckNegativeZero(node-&gt;arithRoundingMode())) {
<span class="line-modified"> 5673                     static constexpr double halfConstant = 0.5;</span>
 5674                     m_jit.loadDouble(TrustedImmPtr(&amp;halfConstant), resultFPR);
 5675                     m_jit.addDouble(valueFPR, resultFPR);
 5676                     m_jit.floorDouble(resultFPR, resultFPR);
 5677                 } else {
 5678                     m_jit.ceilDouble(valueFPR, resultFPR);



 5679 
 5680                     FPRTemporary scratch(this);
 5681                     FPRReg scratchFPR = scratch.fpr();
<span class="line-modified"> 5682                     static constexpr double halfConstant = -0.5;</span>
 5683                     m_jit.loadDouble(TrustedImmPtr(&amp;halfConstant), scratchFPR);
<span class="line-added"> 5684                     m_jit.addDouble(resultFPR, scratchFPR);</span>
 5685 
<span class="line-modified"> 5686                     JITCompiler::Jump shouldUseCeiled = m_jit.branchDouble(JITCompiler::DoubleLessThanOrEqual, scratchFPR, valueFPR);</span>
<span class="line-modified"> 5687                     static constexpr double oneConstant = -1.0;</span>
 5688                     m_jit.loadDouble(TrustedImmPtr(&amp;oneConstant), scratchFPR);
 5689                     m_jit.addDouble(scratchFPR, resultFPR);
 5690                     shouldUseCeiled.link(&amp;m_jit);
 5691                 }
 5692                 setResult(resultFPR);
 5693                 return;
 5694             }
 5695 
 5696             case ArithFloor: {
 5697                 FPRTemporary rounded(this);
 5698                 FPRReg resultFPR = rounded.fpr();
 5699                 m_jit.floorDouble(valueFPR, resultFPR);
 5700                 setResult(resultFPR);
 5701                 return;
 5702             }
 5703 
 5704             case ArithCeil: {
 5705                 FPRTemporary rounded(this);
 5706                 FPRReg resultFPR = rounded.fpr();
 5707                 m_jit.ceilDouble(valueFPR, resultFPR);
</pre>
<hr />
<pre>
 5731                 callOperation&lt;OperationType&gt;(floor, resultFPR, valueFPR);
 5732             else if (node-&gt;op() == ArithCeil)
 5733                 callOperation&lt;OperationType&gt;(ceil, resultFPR, valueFPR);
 5734             else {
 5735                 ASSERT(node-&gt;op() == ArithTrunc);
 5736                 callOperation&lt;OperationType&gt;(trunc, resultFPR, valueFPR);
 5737             }
 5738             setResult(resultFPR);
 5739         }
 5740         return;
 5741     }
 5742 
 5743     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
 5744 
 5745     JSValueOperand argument(this, node-&gt;child1());
 5746     JSValueRegs argumentRegs = argument.jsValueRegs();
 5747 
 5748     flushRegisters();
 5749     JSValueRegsFlushedCallResult result(this);
 5750     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 5751     J_JITOperation_GJ operation = nullptr;</span>
 5752     if (node-&gt;op() == ArithRound)
 5753         operation = operationArithRound;
 5754     else if (node-&gt;op() == ArithFloor)
 5755         operation = operationArithFloor;
 5756     else if (node-&gt;op() == ArithCeil)
 5757         operation = operationArithCeil;
 5758     else {
 5759         ASSERT(node-&gt;op() == ArithTrunc);
 5760         operation = operationArithTrunc;
 5761     }
<span class="line-modified"> 5762     callOperation(operation, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs);</span>
 5763     m_jit.exceptionCheck();
 5764     jsValueResult(resultRegs, node);
 5765 }
 5766 
 5767 void SpeculativeJIT::compileArithUnary(Node* node)
 5768 {
 5769     compileArithDoubleUnaryOp(node, arithUnaryFunction(node-&gt;arithUnaryType()), arithUnaryOperation(node-&gt;arithUnaryType()));
 5770 }
 5771 
 5772 void SpeculativeJIT::compileArithSqrt(Node* node)
 5773 {
 5774     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5775         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5776         FPRReg op1FPR = op1.fpr();
 5777 
 5778         if (!MacroAssembler::supportsFloatingPointSqrt() || !Options::useArchitectureSpecificOptimizations()) {
 5779             flushRegisters();
 5780             FPRResult result(this);
 5781             callOperation&lt;D_JITOperation_D&gt;(sqrt, result.fpr(), op1FPR);
 5782             doubleResult(result.fpr(), node);
 5783         } else {
 5784             FPRTemporary result(this, op1);
 5785             m_jit.sqrtDouble(op1.fpr(), result.fpr());
 5786             doubleResult(result.fpr(), node);
 5787         }
 5788         return;
 5789     }
 5790 
 5791     JSValueOperand op1(this, node-&gt;child1());
 5792     JSValueRegs op1Regs = op1.jsValueRegs();
 5793     flushRegisters();
 5794     FPRResult result(this);
<span class="line-modified"> 5795     callOperation(operationArithSqrt, result.fpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 5796     m_jit.exceptionCheck();
 5797     doubleResult(result.fpr(), node);
 5798 }
 5799 
 5800 void SpeculativeJIT::compileArithMinMax(Node* node)
 5801 {
 5802     switch (node-&gt;binaryUseKind()) {
 5803     case Int32Use: {
 5804         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 5805         SpeculateStrictInt32Operand op2(this, node-&gt;child2());
 5806         GPRTemporary result(this, Reuse, op1);
 5807 
 5808         GPRReg op1GPR = op1.gpr();
 5809         GPRReg op2GPR = op2.gpr();
 5810         GPRReg resultGPR = result.gpr();
 5811 
 5812         MacroAssembler::Jump op1Less = m_jit.branch32(node-&gt;op() == ArithMin ? MacroAssembler::LessThan : MacroAssembler::GreaterThan, op1GPR, op2GPR);
 5813         m_jit.move(op2GPR, resultGPR);
 5814         if (op1GPR != resultGPR) {
 5815             MacroAssembler::Jump done = m_jit.jump();
</pre>
<hr />
<pre>
 5857 
 5858         done.link(&amp;m_jit);
 5859 
 5860         doubleResult(resultFPR, node);
 5861         break;
 5862     }
 5863 
 5864     default:
 5865         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 5866         break;
 5867     }
 5868 }
 5869 
 5870 // For small positive integers , it is worth doing a tiny inline loop to exponentiate the base.
 5871 // Every register is clobbered by this helper.
 5872 static MacroAssembler::Jump compileArithPowIntegerFastPath(JITCompiler&amp; assembler, FPRReg xOperand, GPRReg yOperand, FPRReg result)
 5873 {
 5874     MacroAssembler::JumpList skipFastPath;
 5875     skipFastPath.append(assembler.branch32(MacroAssembler::Above, yOperand, MacroAssembler::TrustedImm32(maxExponentForIntegerMathPow)));
 5876 
<span class="line-modified"> 5877     static constexpr double oneConstant = 1.0;</span>
 5878     assembler.loadDouble(MacroAssembler::TrustedImmPtr(&amp;oneConstant), result);
 5879 
 5880     MacroAssembler::Label startLoop(assembler.label());
 5881     MacroAssembler::Jump exponentIsEven = assembler.branchTest32(MacroAssembler::Zero, yOperand, MacroAssembler::TrustedImm32(1));
 5882     assembler.mulDouble(xOperand, result);
 5883     exponentIsEven.link(&amp;assembler);
 5884     assembler.mulDouble(xOperand, xOperand);
 5885     assembler.rshift32(MacroAssembler::TrustedImm32(1), yOperand);
 5886     assembler.branchTest32(MacroAssembler::NonZero, yOperand).linkTo(startLoop, &amp;assembler);
 5887 
 5888     MacroAssembler::Jump skipSlowPath = assembler.jump();
 5889     skipFastPath.link(&amp;assembler);
 5890 
 5891     return skipSlowPath;
 5892 }
 5893 
 5894 void SpeculativeJIT::compileValuePow(Node* node)
 5895 {
 5896     Edge&amp; leftChild = node-&gt;child1();
 5897     Edge&amp; rightChild = node-&gt;child2();
 5898 
 5899     if (node-&gt;binaryUseKind() == BigIntUse) {
 5900         SpeculateCellOperand left(this, leftChild);
 5901         SpeculateCellOperand right(this, rightChild);
 5902         GPRReg leftGPR = left.gpr();
 5903         GPRReg rightGPR = right.gpr();
 5904 
 5905         speculateBigInt(leftChild, leftGPR);
 5906         speculateBigInt(rightChild, rightGPR);
 5907 
 5908         flushRegisters();
 5909         GPRFlushedCallResult result(this);
 5910         GPRReg resultGPR = result.gpr();
 5911 
<span class="line-modified"> 5912         callOperation(operationPowBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 5913 
 5914         m_jit.exceptionCheck();
 5915         cellResult(resultGPR, node);
 5916         return;
 5917     }
 5918 
 5919     DFG_ASSERT(m_jit.graph(), node, node-&gt;binaryUseKind() == UntypedUse, node-&gt;binaryUseKind());
 5920 
 5921     JSValueOperand left(this, leftChild);
 5922     JSValueOperand right(this, rightChild);
 5923     JSValueRegs leftRegs = left.jsValueRegs();
 5924     JSValueRegs rightRegs = right.jsValueRegs();
 5925 
 5926     flushRegisters();
 5927     JSValueRegsFlushedCallResult result(this);
 5928     JSValueRegs resultRegs = result.regs();
<span class="line-modified"> 5929     callOperation(operationValuePow, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 5930     m_jit.exceptionCheck();
 5931 
 5932     jsValueResult(resultRegs, node);
 5933 }
 5934 
 5935 void SpeculativeJIT::compileArithPow(Node* node)
 5936 {
 5937     if (node-&gt;child2().useKind() == Int32Use) {
 5938         SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5939         SpeculateInt32Operand yOperand(this, node-&gt;child2());
 5940         FPRReg xOperandfpr = xOperand.fpr();
 5941         GPRReg yOperandGpr = yOperand.gpr();
 5942         FPRTemporary yOperandfpr(this);
 5943 
 5944         flushRegisters();
 5945 
 5946         FPRResult result(this);
 5947         FPRReg resultFpr = result.fpr();
 5948 
 5949         FPRTemporary xOperandCopy(this);
 5950         FPRReg xOperandCopyFpr = xOperandCopy.fpr();
 5951         m_jit.moveDouble(xOperandfpr, xOperandCopyFpr);
 5952 
 5953         GPRTemporary counter(this);
 5954         GPRReg counterGpr = counter.gpr();
 5955         m_jit.move(yOperandGpr, counterGpr);
 5956 
 5957         MacroAssembler::Jump skipFallback = compileArithPowIntegerFastPath(m_jit, xOperandCopyFpr, counterGpr, resultFpr);
 5958         m_jit.convertInt32ToDouble(yOperandGpr, yOperandfpr.fpr());
 5959         callOperation(operationMathPow, resultFpr, xOperandfpr, yOperandfpr.fpr());
 5960 
 5961         skipFallback.link(&amp;m_jit);
 5962         doubleResult(resultFpr, node);
 5963         return;
 5964     }
 5965 
 5966     if (node-&gt;child2()-&gt;isDoubleConstant()) {
 5967         double exponent = node-&gt;child2()-&gt;asNumber();
<span class="line-modified"> 5968         static constexpr double infinityConstant = std::numeric_limits&lt;double&gt;::infinity();</span>
<span class="line-modified"> 5969         static constexpr double minusInfinityConstant = -std::numeric_limits&lt;double&gt;::infinity();</span>
 5970         if (exponent == 0.5) {
 5971             SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5972             FPRTemporary result(this);
 5973             FPRReg xOperandFpr = xOperand.fpr();
 5974             FPRReg resultFpr = result.fpr();
 5975 
 5976             m_jit.moveZeroToDouble(resultFpr);
 5977             MacroAssembler::Jump xIsZeroOrNegativeZero = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5978 
 5979             m_jit.loadDouble(TrustedImmPtr(&amp;minusInfinityConstant), resultFpr);
 5980             MacroAssembler::Jump xIsMinusInfinity = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5981             m_jit.sqrtDouble(xOperandFpr, resultFpr);
 5982             MacroAssembler::Jump doneWithSqrt = m_jit.jump();
 5983 
 5984             xIsMinusInfinity.link(&amp;m_jit);
 5985             if (isX86())
 5986                 m_jit.loadDouble(TrustedImmPtr(&amp;infinityConstant), resultFpr);
 5987             else
 5988                 m_jit.absDouble(resultFpr, resultFpr);
 5989 
 5990             xIsZeroOrNegativeZero.link(&amp;m_jit);
 5991             doneWithSqrt.link(&amp;m_jit);
 5992             doubleResult(resultFpr, node);
 5993             return;
 5994         }
 5995         if (exponent == -0.5) {
 5996             SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5997             FPRTemporary scratch(this);
 5998             FPRTemporary result(this);
 5999             FPRReg xOperandFpr = xOperand.fpr();
 6000             FPRReg scratchFPR = scratch.fpr();
 6001             FPRReg resultFpr = result.fpr();
 6002 
 6003             m_jit.moveZeroToDouble(resultFpr);
 6004             MacroAssembler::Jump xIsZeroOrNegativeZero = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 6005 
 6006             m_jit.loadDouble(TrustedImmPtr(&amp;minusInfinityConstant), resultFpr);
 6007             MacroAssembler::Jump xIsMinusInfinity = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 6008 
<span class="line-modified"> 6009             static constexpr double oneConstant = 1.;</span>
 6010             m_jit.loadDouble(TrustedImmPtr(&amp;oneConstant), resultFpr);
 6011             m_jit.sqrtDouble(xOperandFpr, scratchFPR);
 6012             m_jit.divDouble(resultFpr, scratchFPR, resultFpr);
 6013             MacroAssembler::Jump doneWithSqrt = m_jit.jump();
 6014 
 6015             xIsZeroOrNegativeZero.link(&amp;m_jit);
 6016             m_jit.loadDouble(TrustedImmPtr(&amp;infinityConstant), resultFpr);
 6017             MacroAssembler::Jump doneWithBaseZero = m_jit.jump();
 6018 
 6019             xIsMinusInfinity.link(&amp;m_jit);
 6020             m_jit.moveZeroToDouble(resultFpr);
 6021 
 6022             doneWithBaseZero.link(&amp;m_jit);
 6023             doneWithSqrt.link(&amp;m_jit);
 6024             doubleResult(resultFpr, node);
 6025             return;
 6026         }
 6027     }
 6028 
 6029     SpeculateDoubleOperand xOperand(this, node-&gt;child1());
</pre>
<hr />
<pre>
 6040     FPRReg xOperandCopyFpr = xOperandCopy.fpr();
 6041 
 6042     FPRTemporary scratch(this);
 6043     FPRReg scratchFpr = scratch.fpr();
 6044 
 6045     GPRTemporary yOperandInteger(this);
 6046     GPRReg yOperandIntegerGpr = yOperandInteger.gpr();
 6047     MacroAssembler::JumpList failedExponentConversionToInteger;
 6048     m_jit.branchConvertDoubleToInt32(yOperandfpr, yOperandIntegerGpr, failedExponentConversionToInteger, scratchFpr, false);
 6049 
 6050     m_jit.moveDouble(xOperandfpr, xOperandCopyFpr);
 6051     MacroAssembler::Jump skipFallback = compileArithPowIntegerFastPath(m_jit, xOperandCopyFpr, yOperandInteger.gpr(), resultFpr);
 6052     failedExponentConversionToInteger.link(&amp;m_jit);
 6053 
 6054     callOperation(operationMathPow, resultFpr, xOperandfpr, yOperandfpr);
 6055     skipFallback.link(&amp;m_jit);
 6056     doubleResult(resultFpr, node);
 6057 }
 6058 
 6059 // Returns true if the compare is fused with a subsequent branch.
<span class="line-modified"> 6060 bool SpeculativeJIT::compare(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_GJJ operation)</span>
 6061 {
 6062     if (compilePeepHoleBranch(node, condition, doubleCondition, operation))
 6063         return true;
 6064 
 6065     if (node-&gt;isBinaryUseKind(Int32Use)) {
 6066         compileInt32Compare(node, condition);
 6067         return false;
 6068     }
 6069 
 6070 #if USE(JSVALUE64)
 6071     if (node-&gt;isBinaryUseKind(Int52RepUse)) {
 6072         compileInt52Compare(node, condition);
 6073         return false;
 6074     }
 6075 #endif // USE(JSVALUE64)
 6076 
 6077     if (node-&gt;isBinaryUseKind(DoubleRepUse)) {
 6078         compileDoubleCompare(node, doubleCondition);
 6079         return false;
 6080     }
</pre>
<hr />
<pre>
 6494 
 6495     // This isn&#39;t going to generate the best code on x86. But that&#39;s OK, it&#39;s still better
 6496     // than not inlining.
 6497     m_jit.load8(MacroAssembler::BaseIndex(leftTempGPR, lengthGPR, MacroAssembler::TimesOne), leftTemp2GPR);
 6498     m_jit.load8(MacroAssembler::BaseIndex(rightTempGPR, lengthGPR, MacroAssembler::TimesOne), rightTemp2GPR);
 6499     falseCase.append(m_jit.branch32(MacroAssembler::NotEqual, leftTemp2GPR, rightTemp2GPR));
 6500 
 6501     m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 6502 
 6503     trueCase.link(&amp;m_jit);
 6504     moveTrueTo(leftTempGPR);
 6505 
 6506     JITCompiler::Jump done = m_jit.jump();
 6507 
 6508     falseCase.link(&amp;m_jit);
 6509     moveFalseTo(leftTempGPR);
 6510 
 6511     done.link(&amp;m_jit);
 6512     addSlowPathGenerator(
 6513         slowPathCall(
<span class="line-modified"> 6514             slowCase, this, operationCompareStringEq, leftTempGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR));</span>
 6515 
 6516     blessedBooleanResult(leftTempGPR, node);
 6517 }
 6518 
 6519 void SpeculativeJIT::compileStringEquality(Node* node)
 6520 {
 6521     SpeculateCellOperand left(this, node-&gt;child1());
 6522     SpeculateCellOperand right(this, node-&gt;child2());
 6523     GPRTemporary length(this);
 6524     GPRTemporary leftTemp(this);
 6525     GPRTemporary rightTemp(this);
 6526     GPRTemporary leftTemp2(this, Reuse, left);
 6527     GPRTemporary rightTemp2(this, Reuse, right);
 6528 
 6529     GPRReg leftGPR = left.gpr();
 6530     GPRReg rightGPR = right.gpr();
 6531     GPRReg lengthGPR = length.gpr();
 6532     GPRReg leftTempGPR = leftTemp.gpr();
 6533     GPRReg rightTempGPR = rightTemp.gpr();
 6534     GPRReg leftTemp2GPR = leftTemp2.gpr();
</pre>
<hr />
<pre>
 6628     notString.append(m_jit.branchIfNotString(rightRegs.payloadGPR()));
 6629 
 6630     speculateStringIdentAndLoadStorage(notStringVarEdge, rightRegs.payloadGPR(), rightTempGPR);
 6631 
 6632     m_jit.comparePtr(MacroAssembler::Equal, leftTempGPR, rightTempGPR, rightTempGPR);
 6633     notString.link(&amp;m_jit);
 6634 
 6635     unblessedBooleanResult(rightTempGPR, node);
 6636 }
 6637 
 6638 void SpeculativeJIT::compileStringCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6639 {
 6640     SpeculateCellOperand left(this, node-&gt;child1());
 6641     SpeculateCellOperand right(this, node-&gt;child2());
 6642     GPRReg leftGPR = left.gpr();
 6643     GPRReg rightGPR = right.gpr();
 6644 
 6645     speculateString(node-&gt;child1(), leftGPR);
 6646     speculateString(node-&gt;child2(), rightGPR);
 6647 
<span class="line-modified"> 6648     C_JITOperation_B_GJssJss compareFunction = nullptr;</span>
 6649     if (condition == MacroAssembler::LessThan)
 6650         compareFunction = operationCompareStringLess;
 6651     else if (condition == MacroAssembler::LessThanOrEqual)
 6652         compareFunction = operationCompareStringLessEq;
 6653     else if (condition == MacroAssembler::GreaterThan)
 6654         compareFunction = operationCompareStringGreater;
 6655     else if (condition == MacroAssembler::GreaterThanOrEqual)
 6656         compareFunction = operationCompareStringGreaterEq;
 6657     else
 6658         RELEASE_ASSERT_NOT_REACHED();
 6659 
 6660     GPRFlushedCallResult result(this);
 6661     GPRReg resultGPR = result.gpr();
 6662 
 6663     flushRegisters();
<span class="line-modified"> 6664     callOperation(compareFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 6665     m_jit.exceptionCheck();
 6666 
 6667     unblessedBooleanResult(resultGPR, node);
 6668 }
 6669 
 6670 void SpeculativeJIT::compileStringIdentCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6671 {
 6672     SpeculateCellOperand left(this, node-&gt;child1());
 6673     SpeculateCellOperand right(this, node-&gt;child2());
 6674     GPRFlushedCallResult result(this);
 6675     GPRTemporary leftTemp(this);
 6676     GPRTemporary rightTemp(this);
 6677 
 6678     GPRReg leftGPR = left.gpr();
 6679     GPRReg rightGPR = right.gpr();
 6680     GPRReg resultGPR = result.gpr();
 6681     GPRReg leftTempGPR = leftTemp.gpr();
 6682     GPRReg rightTempGPR = rightTemp.gpr();
 6683 
 6684     speculateString(node-&gt;child1(), leftGPR);
</pre>
<hr />
<pre>
 6745         done.link(&amp;m_jit);
 6746 
 6747         unblessedBooleanResult(resultGPR, node);
 6748         return;
 6749     }
 6750 
 6751     ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
 6752 
 6753     JSValueOperand arg1(this, node-&gt;child1());
 6754     JSValueOperand arg2(this, node-&gt;child2());
 6755     JSValueRegs arg1Regs = arg1.jsValueRegs();
 6756     JSValueRegs arg2Regs = arg2.jsValueRegs();
 6757 
 6758     arg1.use();
 6759     arg2.use();
 6760 
 6761     flushRegisters();
 6762 
 6763     GPRFlushedCallResult result(this);
 6764     GPRReg resultGPR = result.gpr();
<span class="line-modified"> 6765     callOperation(operationSameValue, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
 6766     m_jit.exceptionCheck();
 6767 
 6768     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 6769 }
 6770 
 6771 void SpeculativeJIT::compileStringZeroLength(Node* node)
 6772 {
 6773     SpeculateCellOperand str(this, node-&gt;child1());
 6774     GPRReg strGPR = str.gpr();
 6775 
 6776     // Make sure that this is a string.
 6777     speculateString(node-&gt;child1(), strGPR);
 6778 
 6779     GPRTemporary eq(this);
 6780     GPRReg eqGPR = eq.gpr();
 6781 
 6782     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), eqGPR);
 6783     m_jit.comparePtr(CCallHelpers::Equal, strGPR, eqGPR, eqGPR);
 6784     unblessedBooleanResult(eqGPR, node);
 6785 }
</pre>
<hr />
<pre>
 6884     m_jit.cageWithoutUntagging(Gigacage::Primitive, storageReg);
 6885 #endif
 6886     untagArrayPtr();
 6887 }
 6888 
 6889 void SpeculativeJIT::compileGetIndexedPropertyStorage(Node* node)
 6890 {
 6891     SpeculateCellOperand base(this, node-&gt;child1());
 6892     GPRReg baseReg = base.gpr();
 6893 
 6894     GPRTemporary storage(this);
 6895     GPRReg storageReg = storage.gpr();
 6896 
 6897     switch (node-&gt;arrayMode().type()) {
 6898     case Array::String:
 6899         m_jit.loadPtr(MacroAssembler::Address(baseReg, JSString::offsetOfValue()), storageReg);
 6900 
 6901         addSlowPathGenerator(
 6902             slowPathCall(
 6903                 m_jit.branchIfRopeStringImpl(storageReg),
<span class="line-modified"> 6904                 this, operationResolveRope, storageReg, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg));</span>
 6905 
 6906         m_jit.loadPtr(MacroAssembler::Address(storageReg, StringImpl::dataOffset()), storageReg);
 6907         break;
 6908 
 6909     default: {
 6910         auto typedArrayType = node-&gt;arrayMode().typedArrayType();
 6911         ASSERT_UNUSED(typedArrayType, isTypedView(typedArrayType));
 6912 
 6913         m_jit.loadPtr(JITCompiler::Address(baseReg, JSArrayBufferView::offsetOfVector()), storageReg);
 6914         cageTypedArrayStorage(baseReg, storageReg);
 6915         break;
 6916     }
 6917     }
 6918 
 6919     storageResult(storageReg, node);
 6920 }
 6921 
 6922 void SpeculativeJIT::compileGetTypedArrayByteOffset(Node* node)
 6923 {
 6924     SpeculateCellOperand base(this, node-&gt;child1());
</pre>
<hr />
<pre>
 6991     speculationCheck(
 6992         ExoticObjectMode, JSValueSource(), 0,
 6993         m_jit.branchTestPtr(
 6994             MacroAssembler::NonZero,
 6995             MacroAssembler::Address(baseReg, DirectArguments::offsetOfMappedArguments())));
 6996 
 6997     m_jit.load32(CCallHelpers::Address(baseReg, DirectArguments::offsetOfLength()), scratchReg);
 6998     auto isOutOfBounds = m_jit.branch32(CCallHelpers::AboveOrEqual, propertyReg, scratchReg);
 6999     if (node-&gt;arrayMode().isInBounds())
 7000         speculationCheck(OutOfBounds, JSValueSource(), 0, isOutOfBounds);
 7001 
 7002     m_jit.loadValue(
 7003         MacroAssembler::BaseIndex(
 7004             baseReg, propertyReg, MacroAssembler::TimesEight, DirectArguments::storageOffset()),
 7005         resultRegs);
 7006 
 7007     if (!node-&gt;arrayMode().isInBounds()) {
 7008         addSlowPathGenerator(
 7009             slowPathCall(
 7010                 isOutOfBounds, this, operationGetByValObjectInt,
<span class="line-modified"> 7011                 extractResult(resultRegs), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
 7012     }
 7013 
 7014     jsValueResult(resultRegs, node);
 7015 }
 7016 
 7017 void SpeculativeJIT::compileGetByValOnScopedArguments(Node* node)
 7018 {
 7019     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 7020     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 7021     JSValueRegsTemporary result(this);
 7022     GPRTemporary scratch(this);
 7023     GPRTemporary scratch2(this);

 7024 
 7025     GPRReg baseReg = base.gpr();
 7026     GPRReg propertyReg = property.gpr();
 7027     JSValueRegs resultRegs = result.regs();
 7028     GPRReg scratchReg = scratch.gpr();
 7029     GPRReg scratch2Reg = scratch2.gpr();

 7030 
 7031     if (!m_compileOkay)
 7032         return;
 7033 
 7034     ASSERT(ArrayMode(Array::ScopedArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));
 7035 
 7036     m_jit.loadPtr(
 7037         MacroAssembler::Address(baseReg, ScopedArguments::offsetOfStorage()), resultRegs.payloadGPR());



 7038 
 7039     speculationCheck(
 7040         ExoticObjectMode, JSValueSource(), nullptr,
<span class="line-modified"> 7041         m_jit.branch32(</span>
<span class="line-modified"> 7042             MacroAssembler::AboveOrEqual, propertyReg,</span>
<span class="line-modified"> 7043             MacroAssembler::Address(baseReg, ScopedArguments::offsetOfTotalLength())));</span>
 7044 
 7045     m_jit.loadPtr(MacroAssembler::Address(baseReg, ScopedArguments::offsetOfTable()), scratchReg);
 7046     m_jit.load32(
 7047         MacroAssembler::Address(scratchReg, ScopedArgumentsTable::offsetOfLength()), scratch2Reg);
 7048 
 7049     MacroAssembler::Jump overflowArgument = m_jit.branch32(
 7050         MacroAssembler::AboveOrEqual, propertyReg, scratch2Reg);
 7051 
 7052     m_jit.loadPtr(MacroAssembler::Address(baseReg, ScopedArguments::offsetOfScope()), scratch2Reg);
 7053 
 7054     m_jit.loadPtr(
 7055         MacroAssembler::Address(scratchReg, ScopedArgumentsTable::offsetOfArguments()),
 7056         scratchReg);
 7057     m_jit.load32(
 7058         MacroAssembler::BaseIndex(scratchReg, propertyReg, MacroAssembler::TimesFour),
 7059         scratchReg);
 7060 
 7061     speculationCheck(
 7062         ExoticObjectMode, JSValueSource(), nullptr,
 7063         m_jit.branch32(
</pre>
<hr />
<pre>
 7066     m_jit.loadValue(
 7067         MacroAssembler::BaseIndex(
 7068             scratch2Reg, propertyReg, MacroAssembler::TimesEight,
 7069             JSLexicalEnvironment::offsetOfVariables()),
 7070         resultRegs);
 7071 
 7072     MacroAssembler::Jump done = m_jit.jump();
 7073     overflowArgument.link(&amp;m_jit);
 7074 
 7075     m_jit.sub32(propertyReg, scratch2Reg);
 7076     m_jit.neg32(scratch2Reg);
 7077 
 7078     m_jit.loadValue(
 7079         MacroAssembler::BaseIndex(
 7080             resultRegs.payloadGPR(), scratch2Reg, MacroAssembler::TimesEight),
 7081         resultRegs);
 7082     speculationCheck(ExoticObjectMode, JSValueSource(), nullptr, m_jit.branchIfEmpty(resultRegs));
 7083 
 7084     done.link(&amp;m_jit);
 7085 


 7086     jsValueResult(resultRegs, node);
 7087 }
 7088 
 7089 void SpeculativeJIT::compileGetScope(Node* node)
 7090 {
 7091     SpeculateCellOperand function(this, node-&gt;child1());
 7092     GPRTemporary result(this, Reuse, function);
 7093     m_jit.loadPtr(JITCompiler::Address(function.gpr(), JSFunction::offsetOfScopeChain()), result.gpr());
 7094     cellResult(result.gpr(), node);
 7095 }
 7096 
 7097 void SpeculativeJIT::compileSkipScope(Node* node)
 7098 {
 7099     SpeculateCellOperand scope(this, node-&gt;child1());
 7100     GPRTemporary result(this, Reuse, scope);
 7101     m_jit.loadPtr(JITCompiler::Address(scope.gpr(), JSScope::offsetOfNext()), result.gpr());
 7102     cellResult(result.gpr(), node);
 7103 }
 7104 
 7105 void SpeculativeJIT::compileGetGlobalObject(Node* node)
</pre>
<hr />
<pre>
 7196 
 7197         if (!m_compileOkay)
 7198             return;
 7199 
 7200         ASSERT(ArrayMode(Array::DirectArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
 7201 
 7202         speculationCheck(
 7203             ExoticObjectMode, JSValueSource(), 0,
 7204             m_jit.branchTestPtr(
 7205                 MacroAssembler::NonZero,
 7206                 MacroAssembler::Address(baseReg, DirectArguments::offsetOfMappedArguments())));
 7207 
 7208         m_jit.load32(
 7209             MacroAssembler::Address(baseReg, DirectArguments::offsetOfLength()), resultReg);
 7210 
 7211         int32Result(resultReg, node);
 7212         break;
 7213     }
 7214     case Array::ScopedArguments: {
 7215         SpeculateCellOperand base(this, node-&gt;child1());
<span class="line-modified"> 7216         GPRTemporary result(this, Reuse, base);</span>
 7217 
 7218         GPRReg baseReg = base.gpr();
 7219         GPRReg resultReg = result.gpr();
 7220 
 7221         if (!m_compileOkay)
 7222             return;
 7223 
 7224         ASSERT(ArrayMode(Array::ScopedArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
 7225 



 7226         speculationCheck(
 7227             ExoticObjectMode, JSValueSource(), 0,
 7228             m_jit.branchTest8(
 7229                 MacroAssembler::NonZero,
<span class="line-modified"> 7230                 MacroAssembler::Address(baseReg, ScopedArguments::offsetOfOverrodeThings())));</span>
 7231 
 7232         m_jit.load32(
<span class="line-modified"> 7233             MacroAssembler::Address(baseReg, ScopedArguments::offsetOfTotalLength()), resultReg);</span>
 7234 
 7235         int32Result(resultReg, node);
 7236         break;
 7237     }
 7238     default: {
 7239         ASSERT(node-&gt;arrayMode().isSomeTypedArrayView());
 7240         SpeculateCellOperand base(this, node-&gt;child1());
 7241         GPRTemporary result(this, Reuse, base);
 7242         GPRReg baseGPR = base.gpr();
 7243         GPRReg resultGPR = result.gpr();
 7244         m_jit.load32(MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfLength()), resultGPR);
 7245         int32Result(resultGPR, node);
 7246         break;
 7247     } }
 7248 }
 7249 
<span class="line-modified"> 7250 void SpeculativeJIT::compileCheckIdent(Node* node)</span>
 7251 {
<span class="line-modified"> 7252     SpeculateCellOperand stringOrSymbol(this, node-&gt;child1());</span>
<span class="line-modified"> 7253     GPRTemporary impl(this);</span>
<span class="line-added"> 7254     GPRReg stringOrSymbolGPR = stringOrSymbol.gpr();</span>
<span class="line-added"> 7255     GPRReg implGPR = impl.gpr();</span>
 7256 
<span class="line-modified"> 7257     if (node-&gt;child1().useKind() == StringIdentUse) {</span>
<span class="line-modified"> 7258         speculateString(node-&gt;child1(), stringOrSymbolGPR);</span>
<span class="line-modified"> 7259         speculateStringIdentAndLoadStorage(node-&gt;child1(), stringOrSymbolGPR, implGPR);</span>
<span class="line-modified"> 7260     } else {</span>
<span class="line-modified"> 7261         ASSERT(node-&gt;child1().useKind() == SymbolUse);</span>
<span class="line-added"> 7262         speculateSymbol(node-&gt;child1(), stringOrSymbolGPR);</span>
<span class="line-added"> 7263         m_jit.loadPtr(MacroAssembler::Address(stringOrSymbolGPR, Symbol::offsetOfSymbolImpl()), implGPR);</span>
<span class="line-added"> 7264     }</span>
 7265 
 7266     UniquedStringImpl* uid = node-&gt;uidOperand();
 7267     speculationCheck(
 7268         BadIdent, JSValueSource(), nullptr,
<span class="line-modified"> 7269         m_jit.branchPtr(JITCompiler::NotEqual, implGPR, TrustedImmPtr(uid)));</span>
 7270     noResult(node);
 7271 }
 7272 
 7273 template &lt;typename ClassType&gt;
 7274 void SpeculativeJIT::compileNewFunctionCommon(GPRReg resultGPR, RegisteredStructure structure, GPRReg scratch1GPR, GPRReg scratch2GPR, GPRReg scopeGPR, MacroAssembler::JumpList&amp; slowPath, size_t size, FunctionExecutable* executable)
 7275 {
 7276     auto butterfly = TrustedImmPtr(nullptr);
 7277     emitAllocateJSObjectWithKnownSize&lt;ClassType&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath, size);
 7278 
 7279     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfScopeChain()));
<span class="line-modified"> 7280     m_jit.storePtr(TrustedImmPtr::weakPointer(m_jit.graph(), executable), JITCompiler::Address(resultGPR, JSFunction::offsetOfExecutableOrRareData()));</span>
<span class="line-modified"> 7281     m_jit.mutatorFence(vm());</span>























 7282 }
 7283 
 7284 void SpeculativeJIT::compileNewFunction(Node* node)
 7285 {
 7286     NodeType nodeType = node-&gt;op();
 7287     ASSERT(nodeType == NewFunction || nodeType == NewGeneratorFunction || nodeType == NewAsyncFunction || nodeType == NewAsyncGeneratorFunction);
 7288 
 7289     SpeculateCellOperand scope(this, node-&gt;child1());
 7290     GPRReg scopeGPR = scope.gpr();
 7291 
 7292     FunctionExecutable* executable = node-&gt;castOperand&lt;FunctionExecutable*&gt;();
 7293 
 7294     if (executable-&gt;singleton().isStillValid()) {
 7295         GPRFlushedCallResult result(this);
 7296         GPRReg resultGPR = result.gpr();
 7297 
 7298         flushRegisters();
 7299 
 7300         if (nodeType == NewGeneratorFunction)
<span class="line-modified"> 7301             callOperation(operationNewGeneratorFunction, resultGPR, &amp;vm(), scopeGPR, executable);</span>
 7302         else if (nodeType == NewAsyncFunction)
<span class="line-modified"> 7303             callOperation(operationNewAsyncFunction, resultGPR, &amp;vm(), scopeGPR, executable);</span>
 7304         else if (nodeType == NewAsyncGeneratorFunction)
<span class="line-modified"> 7305             callOperation(operationNewAsyncGeneratorFunction, resultGPR, &amp;vm(), scopeGPR, executable);</span>
 7306         else
<span class="line-modified"> 7307             callOperation(operationNewFunction, resultGPR, &amp;vm(), scopeGPR, executable);</span>
 7308         m_jit.exceptionCheck();
 7309         cellResult(resultGPR, node);
 7310         return;
 7311     }
 7312 
 7313     RegisteredStructure structure = m_jit.graph().registerStructure(
 7314         [&amp;] () {
 7315             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 7316             switch (nodeType) {
 7317             case NewGeneratorFunction:
 7318                 return globalObject-&gt;generatorFunctionStructure();
 7319             case NewAsyncFunction:
 7320                 return globalObject-&gt;asyncFunctionStructure();
 7321             case NewAsyncGeneratorFunction:
 7322                 return globalObject-&gt;asyncGeneratorFunctionStructure();
 7323             case NewFunction:
 7324                 return JSFunction::selectStructureForNewFuncExp(globalObject, node-&gt;castOperand&lt;FunctionExecutable*&gt;());
 7325             default:
 7326                 RELEASE_ASSERT_NOT_REACHED();
 7327             }
 7328         }());
 7329 
 7330     GPRTemporary result(this);
 7331     GPRTemporary scratch1(this);
 7332     GPRTemporary scratch2(this);
 7333 
 7334     GPRReg resultGPR = result.gpr();
 7335     GPRReg scratch1GPR = scratch1.gpr();
 7336     GPRReg scratch2GPR = scratch2.gpr();
 7337 
 7338     JITCompiler::JumpList slowPath;
 7339 
 7340     if (nodeType == NewFunction) {
 7341         compileNewFunctionCommon&lt;JSFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSFunction::allocationSize(0), executable);
 7342 
<span class="line-modified"> 7343         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewFunctionWithInvalidatedReallocationWatchpoint, resultGPR, &amp;vm(), scopeGPR, executable));</span>
 7344     }
 7345 
 7346     if (nodeType == NewGeneratorFunction) {
 7347         compileNewFunctionCommon&lt;JSGeneratorFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSGeneratorFunction::allocationSize(0), executable);
 7348 
<span class="line-modified"> 7349         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, &amp;vm(), scopeGPR, executable));</span>
 7350     }
 7351 
 7352     if (nodeType == NewAsyncFunction) {
 7353         compileNewFunctionCommon&lt;JSAsyncFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSAsyncFunction::allocationSize(0), executable);
 7354 
<span class="line-modified"> 7355         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint, resultGPR, &amp;vm(), scopeGPR, executable));</span>
 7356     }
 7357 
 7358     if (nodeType == NewAsyncGeneratorFunction) {
 7359         compileNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSAsyncGeneratorFunction::allocationSize(0), executable);
 7360 
<span class="line-modified"> 7361         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, &amp;vm(), scopeGPR, executable));</span>
 7362     }
 7363 
 7364     cellResult(resultGPR, node);
 7365 }
 7366 
 7367 void SpeculativeJIT::compileSetFunctionName(Node* node)
 7368 {
 7369     SpeculateCellOperand func(this, node-&gt;child1());
 7370     GPRReg funcGPR = func.gpr();
 7371     JSValueOperand nameValue(this, node-&gt;child2());
 7372     JSValueRegs nameValueRegs = nameValue.jsValueRegs();
 7373 
 7374     flushRegisters();
<span class="line-modified"> 7375     callOperation(operationSetFunctionName, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), funcGPR, nameValueRegs);</span>
 7376     m_jit.exceptionCheck();
 7377 
 7378     noResult(node);
 7379 }
 7380 
<span class="line-modified"> 7381 void SpeculativeJIT::compileVarargsLength(Node* node)</span>
 7382 {
 7383     LoadVarargsData* data = node-&gt;loadVarargsData();
 7384 
 7385     JSValueRegs argumentsRegs;
<span class="line-modified"> 7386     lock(GPRInfo::returnValueGPR);</span>
<span class="line-modified"> 7387     JSValueOperand arguments(this, node-&gt;argumentsChild());</span>
<span class="line-modified"> 7388     argumentsRegs = arguments.jsValueRegs();</span>
<span class="line-modified"> 7389     flushRegisters();</span>
<span class="line-modified"> 7390     unlock(GPRInfo::returnValueGPR);</span>
 7391 
<span class="line-modified"> 7392     callOperation(operationSizeOfVarargs, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentsRegs, data-&gt;offset);</span>
 7393     m_jit.exceptionCheck();
 7394 
 7395     lock(GPRInfo::returnValueGPR);
<span class="line-modified"> 7396     GPRTemporary argCountIncludingThis(this);</span>
<span class="line-modified"> 7397     GPRReg argCountIncludingThisGPR = argCountIncludingThis.gpr();</span>



 7398     unlock(GPRInfo::returnValueGPR);
 7399 
<span class="line-modified"> 7400     m_jit.add32(TrustedImm32(1), GPRInfo::returnValueGPR, argCountIncludingThisGPR);</span>
<span class="line-modified"> 7401 </span>
<span class="line-modified"> 7402     int32Result(argCountIncludingThisGPR, node);</span>
<span class="line-modified"> 7403 }</span>

 7404 
<span class="line-modified"> 7405 void SpeculativeJIT::compileLoadVarargs(Node* node)</span>
<span class="line-modified"> 7406 {</span>
<span class="line-added"> 7407     LoadVarargsData* data = node-&gt;loadVarargsData();</span>
 7408 
<span class="line-modified"> 7409     SpeculateStrictInt32Operand argumentCount(this, node-&gt;child1());</span>
<span class="line-added"> 7410     JSValueOperand arguments(this, node-&gt;argumentsChild());</span>
<span class="line-added"> 7411     GPRReg argumentCountIncludingThis = argumentCount.gpr();</span>
<span class="line-added"> 7412     JSValueRegs argumentsRegs = arguments.jsValueRegs();</span>
 7413 
 7414     speculationCheck(
<span class="line-modified"> 7415         VarargsOverflow, JSValueSource(), Edge(), m_jit.branchTest32(</span>
<span class="line-modified"> 7416             MacroAssembler::Zero,</span>
<span class="line-modified"> 7417             argumentCountIncludingThis));</span>

 7418 
 7419     speculationCheck(
 7420         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7421             MacroAssembler::Above,
<span class="line-modified"> 7422             argumentCountIncludingThis,</span>
 7423             TrustedImm32(data-&gt;limit)));
 7424 
<span class="line-modified"> 7425     flushRegisters();</span>
<span class="line-added"> 7426 </span>
<span class="line-added"> 7427     m_jit.store32(argumentCountIncludingThis, JITCompiler::payloadFor(data-&gt;machineCount));</span>
 7428 
<span class="line-modified"> 7429     callOperation(operationLoadVarargs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), data-&gt;machineStart.offset(), argumentsRegs, data-&gt;offset, argumentCountIncludingThis, data-&gt;mandatoryMinimum);</span>
 7430     m_jit.exceptionCheck();
 7431 
 7432     noResult(node);
 7433 }
 7434 
 7435 void SpeculativeJIT::compileForwardVarargs(Node* node)
 7436 {
 7437     LoadVarargsData* data = node-&gt;loadVarargsData();
 7438     InlineCallFrame* inlineCallFrame;
<span class="line-modified"> 7439     if (node-&gt;argumentsChild())</span>
<span class="line-modified"> 7440         inlineCallFrame = node-&gt;argumentsChild()-&gt;origin.semantic.inlineCallFrame();</span>
 7441     else
 7442         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 7443 
<span class="line-added"> 7444     SpeculateStrictInt32Operand argumentCount(this, node-&gt;child1());</span>
 7445     GPRTemporary length(this);
 7446     JSValueRegsTemporary temp(this);
<span class="line-modified"> 7447     GPRReg argumentCountIncludingThis = argumentCount.gpr();</span>
<span class="line-added"> 7448     GPRReg lengthGPR = argumentCount.gpr();</span>
 7449     JSValueRegs tempRegs = temp.regs();
 7450 
<span class="line-modified"> 7451     m_jit.move(argumentCountIncludingThis, lengthGPR);</span>
 7452     if (data-&gt;offset)
 7453         m_jit.sub32(TrustedImm32(data-&gt;offset), lengthGPR);
 7454 
 7455     speculationCheck(
 7456         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7457             MacroAssembler::Above,
 7458             lengthGPR, TrustedImm32(data-&gt;limit)));
 7459 
 7460     m_jit.store32(lengthGPR, JITCompiler::payloadFor(data-&gt;machineCount));
 7461 
 7462     VirtualRegister sourceStart = JITCompiler::argumentsStart(inlineCallFrame) + data-&gt;offset;
 7463     VirtualRegister targetStart = data-&gt;machineStart;
 7464 
 7465     m_jit.sub32(TrustedImm32(1), lengthGPR);
 7466 
 7467     // First have a loop that fills in the undefined slots in case of an arity check failure.
 7468     m_jit.move(TrustedImm32(data-&gt;mandatoryMinimum), tempRegs.payloadGPR());
 7469     JITCompiler::Jump done = m_jit.branch32(JITCompiler::BelowOrEqual, tempRegs.payloadGPR(), lengthGPR);
 7470 
 7471     JITCompiler::Label loop = m_jit.label();
</pre>
<hr />
<pre>
 7508 
 7509     SpeculateCellOperand scope(this, node-&gt;child1());
 7510     GPRReg scopeGPR = scope.gpr();
 7511     JSValue initializationValue = node-&gt;initializationValueForActivation();
 7512     ASSERT(initializationValue == jsUndefined() || initializationValue == jsTDZValue());
 7513 
 7514     if (table-&gt;singleton().isStillValid()) {
 7515         GPRFlushedCallResult result(this);
 7516         GPRReg resultGPR = result.gpr();
 7517 
 7518 #if USE(JSVALUE32_64)
 7519         JSValueRegsTemporary initialization(this);
 7520         JSValueRegs initializationRegs = initialization.regs();
 7521         m_jit.moveTrustedValue(initializationValue, initializationRegs);
 7522 #endif
 7523 
 7524         flushRegisters();
 7525 
 7526 #if USE(JSVALUE64)
 7527         callOperation(operationCreateActivationDirect,
<span class="line-modified"> 7528             resultGPR, &amp;vm(), structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue)));</span>
 7529 #else
 7530         callOperation(operationCreateActivationDirect,
<span class="line-modified"> 7531             resultGPR, &amp;vm(), structure, scopeGPR, table, initializationRegs);</span>
 7532 #endif
 7533         m_jit.exceptionCheck();
 7534         cellResult(resultGPR, node);
 7535         return;
 7536     }
 7537 
 7538     GPRTemporary result(this);
 7539     GPRTemporary scratch1(this);
 7540     GPRTemporary scratch2(this);
 7541     GPRReg resultGPR = result.gpr();
 7542     GPRReg scratch1GPR = scratch1.gpr();
 7543     GPRReg scratch2GPR = scratch2.gpr();
 7544 
 7545 #if USE(JSVALUE32_64)
 7546     JSValueRegsTemporary initialization(this);
 7547     JSValueRegs initializationRegs = initialization.regs();
 7548     m_jit.moveTrustedValue(initializationValue, initializationRegs);
 7549 #endif
 7550 
 7551     JITCompiler::JumpList slowPath;
</pre>
<hr />
<pre>
 7557     // Don&#39;t need a memory barriers since we just fast-created the activation, so the
 7558     // activation must be young.
 7559     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSScope::offsetOfNext()));
 7560     m_jit.storePtr(
 7561         TrustedImmPtr(node-&gt;cellOperand()),
 7562         JITCompiler::Address(resultGPR, JSLexicalEnvironment::offsetOfSymbolTable()));
 7563 
 7564     // Must initialize all members to undefined or the TDZ empty value.
 7565     for (unsigned i = 0; i &lt; table-&gt;scopeSize(); ++i) {
 7566         m_jit.storeTrustedValue(
 7567             initializationValue,
 7568             JITCompiler::Address(
 7569                 resultGPR, JSLexicalEnvironment::offsetOfVariable(ScopeOffset(i))));
 7570     }
 7571 
 7572     m_jit.mutatorFence(vm());
 7573 
 7574 #if USE(JSVALUE64)
 7575     addSlowPathGenerator(
 7576         slowPathCall(
<span class="line-modified"> 7577             slowPath, this, operationCreateActivationDirect, resultGPR, &amp;vm(), structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue))));</span>
 7578 #else
 7579     addSlowPathGenerator(
 7580         slowPathCall(
<span class="line-modified"> 7581             slowPath, this, operationCreateActivationDirect, resultGPR, &amp;vm(), structure, scopeGPR, table, initializationRegs));</span>
 7582 #endif
 7583 
 7584     cellResult(resultGPR, node);
 7585 }
 7586 
 7587 void SpeculativeJIT::compileCreateDirectArguments(Node* node)
 7588 {
 7589     // FIXME: A more effective way of dealing with the argument count and callee is to have
 7590     // them be explicit arguments to this node.
 7591     // https://bugs.webkit.org/show_bug.cgi?id=142207
 7592 
 7593     GPRTemporary result(this);
 7594     GPRTemporary scratch1(this);
 7595     GPRTemporary scratch2(this);
 7596     GPRTemporary length;
 7597     GPRReg resultGPR = result.gpr();
 7598     GPRReg scratch1GPR = scratch1.gpr();
 7599     GPRReg scratch2GPR = scratch2.gpr();
 7600     GPRReg lengthGPR = InvalidGPRReg;
 7601     JSValueRegs valueRegs = JSValueRegs::withTwoAvailableRegs(scratch1GPR, scratch2GPR);
 7602 
 7603     unsigned minCapacity = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic)-&gt;numParameters() - 1;
 7604 
 7605     unsigned knownLength;
 7606     bool lengthIsKnown; // if false, lengthGPR will have the length.
 7607     auto* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 7608     if (inlineCallFrame
 7609         &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
<span class="line-modified"> 7610         knownLength = static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
 7611         lengthIsKnown = true;
 7612     } else {
 7613         knownLength = UINT_MAX;
 7614         lengthIsKnown = false;
 7615 
 7616         GPRTemporary realLength(this);
 7617         length.adopt(realLength);
 7618         lengthGPR = length.gpr();
 7619 
 7620         VirtualRegister argumentCountRegister = m_jit.argumentCount(node-&gt;origin.semantic);
 7621         m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), lengthGPR);
 7622         m_jit.sub32(TrustedImm32(1), lengthGPR);
 7623     }
 7624 
 7625     RegisteredStructure structure =
 7626         m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;directArgumentsStructure());
 7627 
 7628     // Use a different strategy for allocating the object depending on whether we know its
 7629     // size statically.
 7630     JITCompiler::JumpList slowPath;
</pre>
<hr />
<pre>
 7656             resultGPR, TrustedImmPtr(structure), scratch1GPR, scratch1GPR, scratch2GPR,
 7657             slowPath);
 7658 
 7659         m_jit.store32(
 7660             lengthGPR, JITCompiler::Address(resultGPR, DirectArguments::offsetOfLength()));
 7661     }
 7662 
 7663     m_jit.store32(
 7664         TrustedImm32(minCapacity),
 7665         JITCompiler::Address(resultGPR, DirectArguments::offsetOfMinCapacity()));
 7666 
 7667     m_jit.storePtr(
 7668         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfMappedArguments()));
 7669 
 7670     m_jit.storePtr(
 7671         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfModifiedArgumentsDescriptor()));
 7672 
 7673     if (lengthIsKnown) {
 7674         addSlowPathGenerator(
 7675             slowPathCall(
<span class="line-modified"> 7676                 slowPath, this, operationCreateDirectArguments, resultGPR, &amp;vm(), structure,</span>
 7677                 knownLength, minCapacity));
 7678     } else {
 7679         auto generator = makeUnique&lt;CallCreateDirectArgumentsSlowPathGenerator&gt;(
 7680             slowPath, this, resultGPR, structure, lengthGPR, minCapacity);
 7681         addSlowPathGenerator(WTFMove(generator));
 7682     }
 7683 
 7684     if (inlineCallFrame) {
 7685         if (inlineCallFrame-&gt;isClosureCall) {
 7686             m_jit.loadPtr(
 7687                 JITCompiler::addressFor(
 7688                     inlineCallFrame-&gt;calleeRecovery.virtualRegister()),
 7689                 scratch1GPR);
 7690         } else {
 7691             m_jit.move(
 7692                 TrustedImmPtr::weakPointer(
 7693                     m_jit.graph(), inlineCallFrame-&gt;calleeRecovery.constant().asCell()),
 7694                 scratch1GPR);
 7695         }
 7696     } else
</pre>
<hr />
<pre>
 7773     auto argumentOutOfBounds = m_jit.branch32(CCallHelpers::LessThanOrEqual, argumentCountGPR, CCallHelpers::TrustedImm32(node-&gt;argumentIndex()));
 7774     m_jit.loadValue(CCallHelpers::addressFor(CCallHelpers::argumentsStart(node-&gt;origin.semantic) + node-&gt;argumentIndex() - 1), resultRegs);
 7775     auto done = m_jit.jump();
 7776 
 7777     argumentOutOfBounds.link(&amp;m_jit);
 7778     m_jit.moveValue(jsUndefined(), resultRegs);
 7779 
 7780     done.link(&amp;m_jit);
 7781     jsValueResult(resultRegs, node);
 7782 }
 7783 
 7784 void SpeculativeJIT::compileCreateScopedArguments(Node* node)
 7785 {
 7786     SpeculateCellOperand scope(this, node-&gt;child1());
 7787     GPRReg scopeGPR = scope.gpr();
 7788 
 7789     GPRFlushedCallResult result(this);
 7790     GPRReg resultGPR = result.gpr();
 7791     flushRegisters();
 7792 
<span class="line-added"> 7793     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added"> 7794 </span>
 7795     // We set up the arguments ourselves, because we have the whole register file and we can
 7796     // set them up directly into the argument registers. This also means that we don&#39;t have to
 7797     // invent a four-argument-register shuffle.
 7798 
<span class="line-modified"> 7799     // Arguments: 0:JSGlobalObject*, 1:structure, 2:start, 3:length, 4:callee, 5:scope</span>
 7800 
 7801     // Do the scopeGPR first, since it might alias an argument register.
 7802     m_jit.setupArgument(5, [&amp;] (GPRReg destGPR) { m_jit.move(scopeGPR, destGPR); });
 7803 
 7804     // These other things could be done in any order.
 7805     m_jit.setupArgument(4, [&amp;] (GPRReg destGPR) { emitGetCallee(node-&gt;origin.semantic, destGPR); });
 7806     m_jit.setupArgument(3, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });
 7807     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });
 7808     m_jit.setupArgument(
 7809         1, [&amp;] (GPRReg destGPR) {
 7810             m_jit.move(
<span class="line-modified"> 7811                 TrustedImmPtr::weakPointer(m_jit.graph(), globalObject-&gt;scopedArgumentsStructure()),</span>
 7812                 destGPR);
 7813         });
<span class="line-modified"> 7814     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), destGPR); });</span>
 7815 
 7816     appendCallSetResult(operationCreateScopedArguments, resultGPR);
 7817     m_jit.exceptionCheck();
 7818 
 7819     cellResult(resultGPR, node);
 7820 }
 7821 
 7822 void SpeculativeJIT::compileCreateClonedArguments(Node* node)
 7823 {
 7824     GPRFlushedCallResult result(this);
 7825     GPRReg resultGPR = result.gpr();
 7826     flushRegisters();
 7827 
<span class="line-added"> 7828     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added"> 7829 </span>
 7830     // We set up the arguments ourselves, because we have the whole register file and we can
 7831     // set them up directly into the argument registers.
 7832 
<span class="line-modified"> 7833     // Arguments: 0:JSGlobalObject*, 1:structure, 2:start, 3:length, 4:callee</span>
 7834     m_jit.setupArgument(4, [&amp;] (GPRReg destGPR) { emitGetCallee(node-&gt;origin.semantic, destGPR); });
 7835     m_jit.setupArgument(3, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });
 7836     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });
 7837     m_jit.setupArgument(
 7838         1, [&amp;] (GPRReg destGPR) {
 7839             m_jit.move(
 7840                 TrustedImmPtr::weakPointer(
<span class="line-modified"> 7841                     m_jit.graph(), globalObject-&gt;clonedArgumentsStructure()),</span>
 7842                 destGPR);
 7843         });
<span class="line-modified"> 7844     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), destGPR); });</span>
 7845 
 7846     appendCallSetResult(operationCreateClonedArguments, resultGPR);
 7847     m_jit.exceptionCheck();
 7848 
 7849     cellResult(resultGPR, node);
 7850 }
 7851 
<span class="line-added"> 7852 void SpeculativeJIT::compileCreateArgumentsButterfly(Node* node)</span>
<span class="line-added"> 7853 {</span>
<span class="line-added"> 7854     GPRFlushedCallResult result(this);</span>
<span class="line-added"> 7855     GPRReg resultGPR = result.gpr();</span>
<span class="line-added"> 7856     flushRegisters();</span>
<span class="line-added"> 7857 </span>
<span class="line-added"> 7858     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added"> 7859 </span>
<span class="line-added"> 7860     // We set up the arguments ourselves, because we have the whole register file and we can</span>
<span class="line-added"> 7861     // set them up directly into the argument registers.</span>
<span class="line-added"> 7862 </span>
<span class="line-added"> 7863     // Arguments: 0:JSGlobalObject*, 1:start, 3:length</span>
<span class="line-added"> 7864     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });</span>
<span class="line-added"> 7865     m_jit.setupArgument(1, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });</span>
<span class="line-added"> 7866     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), destGPR); });</span>
<span class="line-added"> 7867 </span>
<span class="line-added"> 7868     appendCallSetResult(operationCreateArgumentsButterfly, resultGPR);</span>
<span class="line-added"> 7869     m_jit.exceptionCheck();</span>
<span class="line-added"> 7870 </span>
<span class="line-added"> 7871     cellResult(resultGPR, node);</span>
<span class="line-added"> 7872 }</span>
<span class="line-added"> 7873 </span>
 7874 void SpeculativeJIT::compileCreateRest(Node* node)
 7875 {
 7876     ASSERT(node-&gt;op() == CreateRest);
 7877 

 7878     if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
 7879         SpeculateStrictInt32Operand arrayLength(this, node-&gt;child1());
 7880         GPRTemporary arrayResult(this);
 7881 
 7882         GPRReg arrayLengthGPR = arrayLength.gpr();
 7883         GPRReg arrayResultGPR = arrayResult.gpr();
 7884 
 7885         // We can tell compileAllocateNewArrayWithSize() that it does not need to check
 7886         // for large arrays and use ArrayStorage structure because arrayLength here will
 7887         // always be bounded by stack size. Realistically, we won&#39;t be able to push enough
 7888         // arguments to have arrayLength exceed MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH.
 7889         bool shouldAllowForArrayStorageStructureForLargeArrays = false;

 7890         compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node-&gt;origin.semantic), arrayResultGPR, arrayLengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);
 7891 
 7892         GPRTemporary argumentsStart(this);
 7893         GPRReg argumentsStartGPR = argumentsStart.gpr();
 7894 
 7895         emitGetArgumentStart(node-&gt;origin.semantic, argumentsStartGPR);
 7896 
 7897         GPRTemporary butterfly(this);
 7898         GPRTemporary currentLength(this);
 7899         JSValueRegsTemporary value(this);
 7900 
 7901         JSValueRegs valueRegs = value.regs();
 7902         GPRReg currentLengthGPR = currentLength.gpr();
 7903         GPRReg butterflyGPR = butterfly.gpr();
 7904 
 7905         m_jit.loadPtr(MacroAssembler::Address(arrayResultGPR, JSObject::butterflyOffset()), butterflyGPR);
 7906 
 7907         CCallHelpers::Jump skipLoop = m_jit.branch32(MacroAssembler::Equal, arrayLengthGPR, TrustedImm32(0));
 7908         m_jit.zeroExtend32ToPtr(arrayLengthGPR, currentLengthGPR);
 7909         m_jit.addPtr(Imm32(sizeof(Register) * node-&gt;numberOfArgumentsToSkip()), argumentsStartGPR);
 7910 
 7911         auto loop = m_jit.label();
 7912         m_jit.sub32(TrustedImm32(1), currentLengthGPR);
 7913         m_jit.loadValue(JITCompiler::BaseIndex(argumentsStartGPR, currentLengthGPR, MacroAssembler::TimesEight), valueRegs);
 7914         m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(butterflyGPR, currentLengthGPR, MacroAssembler::TimesEight));
 7915         m_jit.branch32(MacroAssembler::NotEqual, currentLengthGPR, TrustedImm32(0)).linkTo(loop, &amp;m_jit);
 7916 
 7917         skipLoop.link(&amp;m_jit);
 7918         cellResult(arrayResultGPR, node);
 7919         return;
 7920     }

 7921 
 7922     SpeculateStrictInt32Operand arrayLength(this, node-&gt;child1());
 7923     GPRTemporary argumentsStart(this);
 7924     GPRTemporary numberOfArgumentsToSkip(this);
 7925 
 7926     GPRReg arrayLengthGPR = arrayLength.gpr();
 7927     GPRReg argumentsStartGPR = argumentsStart.gpr();
 7928 
 7929     emitGetArgumentStart(node-&gt;origin.semantic, argumentsStartGPR);
 7930 
 7931     flushRegisters();
 7932 
 7933     GPRFlushedCallResult result(this);
 7934     GPRReg resultGPR = result.gpr();
<span class="line-modified"> 7935     callOperation(operationCreateRest, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentsStartGPR, Imm32(node-&gt;numberOfArgumentsToSkip()), arrayLengthGPR);</span>
 7936     m_jit.exceptionCheck();
 7937 
 7938     cellResult(resultGPR, node);
 7939 }
 7940 
 7941 void SpeculativeJIT::compileSpread(Node* node)
 7942 {
 7943     ASSERT(node-&gt;op() == Spread);
 7944 
 7945     SpeculateCellOperand operand(this, node-&gt;child1());
 7946     GPRReg argument = operand.gpr();
 7947 
 7948     if (node-&gt;child1().useKind() == ArrayUse)
 7949         speculateArray(node-&gt;child1(), argument);
 7950 
 7951     if (m_jit.graph().canDoFastSpread(node, m_state.forNode(node-&gt;child1()))) {
 7952 #if USE(JSVALUE64)
 7953         GPRTemporary result(this);
 7954         GPRTemporary scratch1(this);
 7955         GPRTemporary scratch2(this);
 7956         GPRTemporary length(this);
 7957         FPRTemporary doubleRegister(this);
 7958 
 7959         GPRReg resultGPR = result.gpr();
 7960         GPRReg scratch1GPR = scratch1.gpr();
 7961         GPRReg scratch2GPR = scratch2.gpr();
 7962         GPRReg lengthGPR = length.gpr();
 7963         FPRReg doubleFPR = doubleRegister.fpr();
 7964 
 7965         MacroAssembler::JumpList slowPath;
<span class="line-added"> 7966         MacroAssembler::JumpList done;</span>
 7967 
 7968         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch1GPR);
<span class="line-added"> 7969         m_jit.and32(TrustedImm32(IndexingModeMask), scratch1GPR);</span>
<span class="line-added"> 7970         auto notShareCase = m_jit.branch32(CCallHelpers::NotEqual, scratch1GPR, TrustedImm32(CopyOnWriteArrayWithContiguous));</span>
<span class="line-added"> 7971         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), resultGPR);</span>
<span class="line-added"> 7972         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(JSImmutableButterfly::offsetOfData())), resultGPR);</span>
<span class="line-added"> 7973         done.append(m_jit.jump());</span>
<span class="line-added"> 7974 </span>
<span class="line-added"> 7975         notShareCase.link(&amp;m_jit);</span>
 7976         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch1GPR);
 7977         m_jit.sub32(TrustedImm32(Int32Shape), scratch1GPR);
 7978 
 7979         slowPath.append(m_jit.branch32(MacroAssembler::Above, scratch1GPR, TrustedImm32(ContiguousShape - Int32Shape)));
 7980 
 7981         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), lengthGPR);
 7982         m_jit.load32(MacroAssembler::Address(lengthGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
<span class="line-added"> 7983         slowPath.append(m_jit.branch32(MacroAssembler::Above, lengthGPR, TrustedImm32(MAX_STORAGE_VECTOR_LENGTH)));</span>
 7984         static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
 7985         m_jit.move(lengthGPR, scratch1GPR);
 7986         m_jit.lshift32(TrustedImm32(3), scratch1GPR);
<span class="line-modified"> 7987         m_jit.add32(TrustedImm32(JSImmutableButterfly::offsetOfData()), scratch1GPR);</span>
 7988 
<span class="line-modified"> 7989         m_jit.emitAllocateVariableSizedCell&lt;JSImmutableButterfly&gt;(vm(), resultGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.graph().m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get())), scratch1GPR, scratch1GPR, scratch2GPR, slowPath);</span>
<span class="line-modified"> 7990         m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSImmutableButterfly::offsetOfPublicLength()));</span>
<span class="line-added"> 7991         m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSImmutableButterfly::offsetOfVectorLength()));</span>
 7992 
 7993         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), scratch1GPR);
 7994 


 7995         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch2GPR);
 7996         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch2GPR);
 7997         auto isDoubleArray = m_jit.branch32(MacroAssembler::Equal, scratch2GPR, TrustedImm32(DoubleShape));
 7998 
 7999         {
 8000             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 8001             auto loopStart = m_jit.label();
 8002             m_jit.sub32(TrustedImm32(1), lengthGPR);
 8003             m_jit.load64(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), scratch2GPR);
 8004             auto notEmpty = m_jit.branchIfNotEmpty(scratch2GPR);
 8005             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 8006             notEmpty.link(&amp;m_jit);
<span class="line-modified"> 8007             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSImmutableButterfly::offsetOfData()));</span>
 8008             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 8009             done.append(m_jit.jump());
 8010         }
 8011 
 8012         isDoubleArray.link(&amp;m_jit);
 8013         {
 8014             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 8015             auto loopStart = m_jit.label();
 8016             m_jit.sub32(TrustedImm32(1), lengthGPR);
 8017             m_jit.loadDouble(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), doubleFPR);
 8018             auto notEmpty = m_jit.branchIfNotNaN(doubleFPR);
 8019             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 8020             auto doStore = m_jit.jump();
 8021             notEmpty.link(&amp;m_jit);
 8022             m_jit.boxDouble(doubleFPR, scratch2GPR);
 8023             doStore.link(&amp;m_jit);
<span class="line-modified"> 8024             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSImmutableButterfly::offsetOfData()));</span>
 8025             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 8026             done.append(m_jit.jump());
 8027         }
 8028 
<span class="line-modified"> 8029         addSlowPathGenerator(slowPathCall(slowPath, this, operationSpreadFastArray, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argument));</span>



 8030 
 8031         done.link(&amp;m_jit);
<span class="line-added"> 8032         m_jit.mutatorFence(vm());</span>
 8033         cellResult(resultGPR, node);
 8034 #else
 8035         flushRegisters();
 8036 
 8037         GPRFlushedCallResult result(this);
 8038         GPRReg resultGPR = result.gpr();
<span class="line-modified"> 8039         callOperation(operationSpreadFastArray, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argument);</span>
 8040         m_jit.exceptionCheck();
 8041         cellResult(resultGPR, node);
 8042 #endif // USE(JSVALUE64)
 8043     } else {
 8044         flushRegisters();
 8045 
 8046         GPRFlushedCallResult result(this);
 8047         GPRReg resultGPR = result.gpr();
<span class="line-modified"> 8048         callOperation(operationSpreadGeneric, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argument);</span>
 8049         m_jit.exceptionCheck();
 8050         cellResult(resultGPR, node);
 8051     }
 8052 }
 8053 
 8054 void SpeculativeJIT::compileNewArray(Node* node)
 8055 {
 8056     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
<span class="line-added"> 8057     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()));</span>
 8058     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingType())) {








 8059         unsigned numElements = node-&gt;numChildren();
 8060         unsigned vectorLengthHint = node-&gt;vectorLengthHint();
 8061         ASSERT(vectorLengthHint &gt;= numElements);
 8062 
 8063         GPRTemporary result(this);
 8064         GPRTemporary storage(this);
 8065 
 8066         GPRReg resultGPR = result.gpr();
 8067         GPRReg storageGPR = storage.gpr();
 8068 
 8069         emitAllocateRawObject(resultGPR, structure, storageGPR, numElements, vectorLengthHint);
 8070 
 8071         // At this point, one way or another, resultGPR and storageGPR have pointers to
 8072         // the JSArray and the Butterfly, respectively.
 8073 
 8074         ASSERT(!hasUndecided(structure-&gt;indexingType()) || !node-&gt;numChildren());
 8075 
 8076         for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
 8077             Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + operandIdx];
 8078             switch (node-&gt;indexingType()) {
</pre>
<hr />
<pre>
 8104             default:
 8105                 CRASH();
 8106                 break;
 8107             }
 8108         }
 8109 
 8110         // Yuck, we should *really* have a way of also returning the storageGPR. But
 8111         // that&#39;s the least of what&#39;s wrong with this code. We really shouldn&#39;t be
 8112         // allocating the array after having computed - and probably spilled to the
 8113         // stack - all of the things that will go into the array. The solution to that
 8114         // bigger problem will also likely fix the redundancy in reloading the storage
 8115         // pointer that we currently have.
 8116 
 8117         cellResult(resultGPR, node);
 8118         return;
 8119     }
 8120 
 8121     if (!node-&gt;numChildren()) {
 8122         flushRegisters();
 8123         GPRFlushedCallResult result(this);
<span class="line-modified"> 8124         callOperation(operationNewEmptyArray, result.gpr(), &amp;vm(), structure);</span>
 8125         m_jit.exceptionCheck();
 8126         cellResult(result.gpr(), node);
 8127         return;
 8128     }
 8129 
 8130     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
 8131     ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8132     EncodedJSValue* buffer = scratchBuffer ? static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;
 8133 
 8134     for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
 8135         // Need to perform the speculations that this node promises to perform. If we&#39;re
 8136         // emitting code here and the indexing type is not array storage then there is
 8137         // probably something hilarious going on and we&#39;re already failing at all the
 8138         // things, but at least we&#39;re going to be sound.
 8139         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + operandIdx];
 8140         switch (node-&gt;indexingType()) {
 8141         case ALL_BLANK_INDEXING_TYPES:
 8142         case ALL_UNDECIDED_INDEXING_TYPES:
 8143             CRASH();
 8144             break;
</pre>
<hr />
<pre>
 8175         }
 8176         default:
 8177             CRASH();
 8178             break;
 8179         }
 8180     }
 8181 
 8182     flushRegisters();
 8183 
 8184     if (scratchSize) {
 8185         GPRTemporary scratch(this);
 8186 
 8187         // Tell GC mark phase how much of the scratch buffer is active during call.
 8188         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8189         m_jit.storePtr(TrustedImmPtr(scratchSize), scratch.gpr());
 8190     }
 8191 
 8192     GPRFlushedCallResult result(this);
 8193 
 8194     callOperation(
<span class="line-modified"> 8195         operationNewArray, result.gpr(), TrustedImmPtr::weakPointer(m_graph, globalObject), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())),</span>
 8196         static_cast&lt;void*&gt;(buffer), size_t(node-&gt;numChildren()));
 8197     m_jit.exceptionCheck();
 8198 
 8199     if (scratchSize) {
 8200         GPRTemporary scratch(this);
 8201 
 8202         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8203         m_jit.storePtr(TrustedImmPtr(nullptr), scratch.gpr());
 8204     }
 8205 
 8206     cellResult(result.gpr(), node, UseChildrenCalledExplicitly);
 8207 }
 8208 
 8209 void SpeculativeJIT::compileNewArrayWithSpread(Node* node)
 8210 {
 8211     ASSERT(node-&gt;op() == NewArrayWithSpread);
<span class="line-added"> 8212     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);</span>
 8213 
 8214 #if USE(JSVALUE64)
 8215     if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
 8216         GPRTemporary result(this);
 8217         GPRReg resultGPR = result.gpr();
 8218 
 8219         BitVector* bitVector = node-&gt;bitVector();
<span class="line-added"> 8220 </span>
<span class="line-added"> 8221         if (node-&gt;numChildren() == 1 &amp;&amp; bitVector-&gt;get(0)) {</span>
<span class="line-added"> 8222             Edge use = m_jit.graph().varArgChild(node, 0);</span>
<span class="line-added"> 8223             SpeculateCellOperand immutableButterfly(this, use);</span>
<span class="line-added"> 8224             GPRTemporary result(this);</span>
<span class="line-added"> 8225             GPRTemporary butterfly(this);</span>
<span class="line-added"> 8226             GPRTemporary scratch1(this);</span>
<span class="line-added"> 8227             GPRTemporary scratch2(this);</span>
<span class="line-added"> 8228 </span>
<span class="line-added"> 8229             GPRReg immutableButterflyGPR = immutableButterfly.gpr();</span>
<span class="line-added"> 8230             GPRReg resultGPR = result.gpr();</span>
<span class="line-added"> 8231             GPRReg butterflyGPR = butterfly.gpr();</span>
<span class="line-added"> 8232             GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="line-added"> 8233             GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="line-added"> 8234 </span>
<span class="line-added"> 8235             RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));</span>
<span class="line-added"> 8236 </span>
<span class="line-added"> 8237             MacroAssembler::JumpList slowCases;</span>
<span class="line-added"> 8238 </span>
<span class="line-added"> 8239             m_jit.move(immutableButterflyGPR, butterflyGPR);</span>
<span class="line-added"> 8240             m_jit.addPtr(TrustedImm32(JSImmutableButterfly::offsetOfData()), butterflyGPR);</span>
<span class="line-added"> 8241 </span>
<span class="line-added"> 8242             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), butterflyGPR, scratch1GPR, scratch2GPR, slowCases);</span>
<span class="line-added"> 8243 </span>
<span class="line-added"> 8244             addSlowPathGenerator(slowPathCall(slowCases, this, operationNewArrayBuffer, resultGPR, &amp;vm(), structure, immutableButterflyGPR));</span>
<span class="line-added"> 8245 </span>
<span class="line-added"> 8246             cellResult(resultGPR, node);</span>
<span class="line-added"> 8247             return;</span>
<span class="line-added"> 8248         }</span>
<span class="line-added"> 8249 </span>
 8250         {
 8251             unsigned startLength = 0;
 8252             for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8253                 if (!bitVector-&gt;get(i))
 8254                     ++startLength;
 8255             }
 8256 
 8257             GPRTemporary length(this);
 8258             GPRReg lengthGPR = length.gpr();
 8259             m_jit.move(TrustedImm32(startLength), lengthGPR);
 8260 
 8261             for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8262                 if (bitVector-&gt;get(i)) {
 8263                     Edge use = m_jit.graph().varArgChild(node, i);
<span class="line-modified"> 8264                     SpeculateCellOperand immutableButterfly(this, use);</span>
<span class="line-modified"> 8265                     GPRReg immutableButterflyGPR = immutableButterfly.gpr();</span>
<span class="line-modified"> 8266                     speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchAdd32(MacroAssembler::Overflow, MacroAssembler::Address(immutableButterflyGPR, JSImmutableButterfly::offsetOfPublicLength()), lengthGPR));</span>
 8267                 }
 8268             }
 8269 
 8270             speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branch32(MacroAssembler::AboveOrEqual, lengthGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));
 8271 
 8272             // We can tell compileAllocateNewArrayWithSize() that it does not need to
 8273             // check for large arrays and use ArrayStorage structure because we already
 8274             // ensured above that the spread array length will definitely fit in a
 8275             // non-ArrayStorage shaped array.
 8276             bool shouldAllowForArrayStorageStructureForLargeArrays = false;
<span class="line-modified"> 8277             compileAllocateNewArrayWithSize(globalObject, resultGPR, lengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);</span>

 8278         }
 8279 
 8280         GPRTemporary index(this);
 8281         GPRReg indexGPR = index.gpr();
 8282 
 8283         GPRTemporary storage(this);
 8284         GPRReg storageGPR = storage.gpr();
 8285 
 8286         m_jit.move(TrustedImm32(0), indexGPR);
 8287         m_jit.loadPtr(MacroAssembler::Address(resultGPR, JSObject::butterflyOffset()), storageGPR);
 8288 
 8289         for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8290             Edge use = m_jit.graph().varArgChild(node, i);
 8291             if (bitVector-&gt;get(i)) {
<span class="line-modified"> 8292                 SpeculateCellOperand immutableButterfly(this, use);</span>
<span class="line-modified"> 8293                 GPRReg immutableButterflyGPR = immutableButterfly.gpr();</span>
 8294 
<span class="line-modified"> 8295                 GPRTemporary immutableButterflyIndex(this);</span>
<span class="line-modified"> 8296                 GPRReg immutableButterflyIndexGPR = immutableButterflyIndex.gpr();</span>
 8297 
 8298                 GPRTemporary item(this);
 8299                 GPRReg itemGPR = item.gpr();
 8300 
<span class="line-modified"> 8301                 GPRTemporary immutableButterflyLength(this);</span>
<span class="line-modified"> 8302                 GPRReg immutableButterflyLengthGPR = immutableButterflyLength.gpr();</span>
 8303 
<span class="line-modified"> 8304                 m_jit.load32(MacroAssembler::Address(immutableButterflyGPR, JSImmutableButterfly::offsetOfPublicLength()), immutableButterflyLengthGPR);</span>
<span class="line-modified"> 8305                 m_jit.move(TrustedImm32(0), immutableButterflyIndexGPR);</span>
<span class="line-modified"> 8306                 auto done = m_jit.branchPtr(MacroAssembler::AboveOrEqual, immutableButterflyIndexGPR, immutableButterflyLengthGPR);</span>
 8307                 auto loopStart = m_jit.label();
 8308                 m_jit.load64(
<span class="line-modified"> 8309                     MacroAssembler::BaseIndex(immutableButterflyGPR, immutableButterflyIndexGPR, MacroAssembler::TimesEight, JSImmutableButterfly::offsetOfData()),</span>
 8310                     itemGPR);
 8311 
 8312                 m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
<span class="line-modified"> 8313                 m_jit.addPtr(TrustedImm32(1), immutableButterflyIndexGPR);</span>
 8314                 m_jit.addPtr(TrustedImm32(1), indexGPR);
<span class="line-modified"> 8315                 m_jit.branchPtr(MacroAssembler::Below, immutableButterflyIndexGPR, immutableButterflyLengthGPR).linkTo(loopStart, &amp;m_jit);</span>
 8316 
 8317                 done.link(&amp;m_jit);
 8318             } else {
 8319                 JSValueOperand item(this, use);
 8320                 GPRReg itemGPR = item.gpr();
 8321                 m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
 8322                 m_jit.addPtr(TrustedImm32(1), indexGPR);
 8323             }
 8324         }
 8325 
 8326         cellResult(resultGPR, node);
 8327         return;
 8328     }
 8329 #endif // USE(JSVALUE64)
 8330 
 8331     ASSERT(node-&gt;numChildren());
 8332     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
 8333     ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8334     EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 8335 
 8336     BitVector* bitVector = node-&gt;bitVector();
 8337     for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8338         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + i];
 8339         if (bitVector-&gt;get(i)) {
<span class="line-modified"> 8340             SpeculateCellOperand immutableButterfly(this, use);</span>
<span class="line-modified"> 8341             GPRReg immutableButterflyGPR = immutableButterfly.gpr();</span>
 8342 #if USE(JSVALUE64)
<span class="line-modified"> 8343             m_jit.store64(immutableButterflyGPR, &amp;buffer[i]);</span>
 8344 #else
 8345             char* pointer = static_cast&lt;char*&gt;(static_cast&lt;void*&gt;(&amp;buffer[i]));
<span class="line-modified"> 8346             m_jit.store32(immutableButterflyGPR, pointer + PayloadOffset);</span>
 8347             m_jit.store32(TrustedImm32(JSValue::CellTag), pointer + TagOffset);
 8348 #endif
 8349         } else {
 8350             JSValueOperand input(this, use);
 8351             JSValueRegs inputRegs = input.jsValueRegs();
 8352             m_jit.storeValue(inputRegs, &amp;buffer[i]);
 8353         }
 8354     }
 8355 
 8356     {
 8357         GPRTemporary scratch(this);
 8358         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8359         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(scratch.gpr()));
 8360     }
 8361 
 8362     flushRegisters();
 8363 
 8364     GPRFlushedCallResult result(this);
 8365     GPRReg resultGPR = result.gpr();
 8366 
<span class="line-modified"> 8367     callOperation(operationNewArrayWithSpreadSlow, resultGPR, TrustedImmPtr::weakPointer(m_graph, globalObject), buffer, node-&gt;numChildren());</span>
 8368     m_jit.exceptionCheck();
 8369     {
 8370         GPRTemporary scratch(this);
 8371         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8372         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(scratch.gpr()));
 8373     }
 8374 
 8375     cellResult(resultGPR, node);
 8376 }
 8377 
 8378 void SpeculativeJIT::compileGetRestLength(Node* node)
 8379 {
 8380     ASSERT(node-&gt;op() == GetRestLength);
 8381 
 8382     GPRTemporary result(this);
 8383     GPRReg resultGPR = result.gpr();
 8384 
 8385     emitGetLength(node-&gt;origin.semantic, resultGPR);
 8386     CCallHelpers::Jump hasNonZeroLength = m_jit.branch32(MacroAssembler::Above, resultGPR, Imm32(node-&gt;numberOfArgumentsToSkip()));
 8387     m_jit.move(TrustedImm32(0), resultGPR);
</pre>
<hr />
<pre>
 8532 
 8533         MacroAssembler::JumpList slowCases;
 8534         m_jit.move(TrustedImmPtr(nullptr), storageResultGPR);
 8535         // Enable the fast case on 64-bit platforms, where a sufficient amount of GP registers should be available.
 8536         // Other platforms could support the same approach with custom code, but that is not currently worth the extra code maintenance.
 8537         if (is64Bit()) {
 8538             GPRTemporary scratch(this);
 8539             GPRTemporary scratch2(this);
 8540             GPRReg scratchGPR = scratch.gpr();
 8541             GPRReg scratch2GPR = scratch2.gpr();
 8542 
 8543             emitAllocateButterfly(storageResultGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
 8544             emitInitializeButterfly(storageResultGPR, sizeGPR, emptyValueRegs, scratchGPR);
 8545             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, tempValue, storageResultGPR, scratchGPR, scratch2GPR, slowCases);
 8546             m_jit.mutatorFence(vm());
 8547         } else {
 8548             slowCases.append(m_jit.jump());
 8549         }
 8550 
 8551         addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableStructureVariableSizeSlowPathGenerator&gt;(
<span class="line-modified"> 8552             slowCases, this, operationNewArrayWithSize, resultGPR, TrustedImmPtr::weakPointer(m_graph, globalObject), tempValue, sizeGPR, storageResultGPR));</span>
 8553     }
 8554 
 8555     GPRTemporary temp4(this);
 8556     GPRReg loadIndex = temp4.gpr();
 8557 
 8558     if (node-&gt;numChildren() == 2) {
 8559         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempGPR);
 8560         m_jit.move(TrustedImm32(0), loadIndex);
 8561     } else {
 8562         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempValue);
 8563         if (node-&gt;numChildren() == 4)
 8564             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, tempValue, tempGPR);
 8565         else
 8566             m_jit.move(tempValue, tempGPR);
 8567         emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 1), WTF::nullopt, tempValue, loadIndex);
 8568     }
 8569 
 8570     GPRTemporary temp5(this);
 8571     GPRReg storeIndex = temp5.gpr();
 8572     m_jit.move(TrustedImmPtr(nullptr), storeIndex);
</pre>
<hr />
<pre>
 8751         m_jit.add32(TrustedImm32(1), indexGPR);
 8752         m_jit.jump().linkTo(loop, &amp;m_jit);
 8753 
 8754         notFound.link(&amp;m_jit);
 8755         m_jit.move(TrustedImm32(-1), indexGPR);
 8756         found.link(&amp;m_jit);
 8757         int32Result(indexGPR, node);
 8758         return;
 8759     }
 8760 
 8761     case StringUse: {
 8762         ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
 8763         SpeculateCellOperand searchElement(this, searchElementEdge);
 8764 
 8765         GPRReg searchElementGPR = searchElement.gpr();
 8766 
 8767         speculateString(searchElementEdge, searchElementGPR);
 8768 
 8769         flushRegisters();
 8770 
<span class="line-modified"> 8771         callOperation(operationArrayIndexOfString, lengthGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), storageGPR, searchElementGPR, indexGPR);</span>
 8772         m_jit.exceptionCheck();
 8773 
 8774         int32Result(lengthGPR, node);
 8775         return;
 8776     }
 8777 
 8778     case UntypedUse: {
 8779         JSValueOperand searchElement(this, searchElementEdge);
 8780 
 8781         JSValueRegs searchElementRegs = searchElement.jsValueRegs();
 8782 
 8783         flushRegisters();
 8784         switch (node-&gt;arrayMode().type()) {
 8785         case Array::Double:
<span class="line-modified"> 8786             callOperation(operationArrayIndexOfValueDouble, lengthGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), storageGPR, searchElementRegs, indexGPR);</span>
 8787             break;
 8788         case Array::Int32:
 8789         case Array::Contiguous:
<span class="line-modified"> 8790             callOperation(operationArrayIndexOfValueInt32OrContiguous, lengthGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), storageGPR, searchElementRegs, indexGPR);</span>
 8791             break;
 8792         default:
 8793             RELEASE_ASSERT_NOT_REACHED();
 8794             break;
 8795         }
 8796         m_jit.exceptionCheck();
 8797 
 8798         int32Result(lengthGPR, node);
 8799         return;
 8800     }
 8801 
 8802     default:
 8803         RELEASE_ASSERT_NOT_REACHED();
 8804         return;
 8805     }
 8806 }
 8807 
 8808 void SpeculativeJIT::compileArrayPush(Node* node)
 8809 {
 8810     ASSERT(node-&gt;arrayMode().isJSArray());
</pre>
<hr />
<pre>
 8839     switch (node-&gt;arrayMode().type()) {
 8840     case Array::Int32:
 8841     case Array::Contiguous: {
 8842         if (elementCount == 1) {
 8843             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8844             if (node-&gt;arrayMode().type() == Array::Int32) {
 8845                 ASSERT(element.useKind() == Int32Use);
 8846                 speculateInt32(element);
 8847             }
 8848             JSValueOperand value(this, element, ManualOperandSpeculation);
 8849             JSValueRegs valueRegs = value.jsValueRegs();
 8850 
 8851             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8852             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8853             m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8854             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8855             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8856             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8857 
 8858             addSlowPathGenerator(
<span class="line-modified"> 8859                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, baseGPR));</span>
 8860 
 8861             jsValueResult(resultRegs, node);
 8862             return;
 8863         }
 8864 
 8865         if (node-&gt;arrayMode().type() == Array::Int32) {
 8866             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8867                 Edge element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8868                 ASSERT(element.useKind() == Int32Use);
 8869                 speculateInt32(element);
 8870             }
 8871         }
 8872 
 8873         GPRTemporary buffer(this);
 8874         GPRReg bufferGPR = buffer.gpr();
 8875 
 8876         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8877         m_jit.move(storageLengthGPR, bufferGPR);
 8878         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8879         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
</pre>
<hr />
<pre>
 8887         slowPath.link(&amp;m_jit);
 8888 
 8889         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 8890         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8891         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8892         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8893         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8894 
 8895         storageDone.link(&amp;m_jit);
 8896         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8897             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8898             JSValueOperand value(this, element, ManualOperandSpeculation); // We did type checks above.
 8899             JSValueRegs valueRegs = value.jsValueRegs();
 8900 
 8901             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 8902             value.use();
 8903         }
 8904 
 8905         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8906 
<span class="line-modified"> 8907         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
 8908 
 8909         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8910         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8911 
 8912         base.use();
 8913         storage.use();
 8914 
 8915         fastPath.link(&amp;m_jit);
 8916         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8917         return;
 8918     }
 8919 
 8920     case Array::Double: {
 8921         if (elementCount == 1) {
 8922             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8923             speculate(node, element);
 8924             SpeculateDoubleOperand value(this, element);
 8925             FPRReg valueFPR = value.fpr();
 8926 
 8927             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8928             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8929             m_jit.storeDouble(valueFPR, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8930             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8931             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8932             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8933 
 8934             addSlowPathGenerator(
<span class="line-modified"> 8935                 slowPathCall(slowPath, this, operationArrayPushDouble, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueFPR, baseGPR));</span>
 8936 
 8937             jsValueResult(resultRegs, node);
 8938             return;
 8939         }
 8940 
 8941         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8942             Edge element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8943             ASSERT(element.useKind() == DoubleRepRealUse);
 8944             speculate(node, element);
 8945         }
 8946 
 8947         GPRTemporary buffer(this);
 8948         GPRReg bufferGPR = buffer.gpr();
 8949 
 8950         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8951         m_jit.move(storageLengthGPR, bufferGPR);
 8952         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8953         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8954 
 8955         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
</pre>
<hr />
<pre>
 8961         slowPath.link(&amp;m_jit);
 8962 
 8963         size_t scratchSize = sizeof(double) * elementCount;
 8964         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8965         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8966         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8967         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8968 
 8969         storageDone.link(&amp;m_jit);
 8970         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8971             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8972             SpeculateDoubleOperand value(this, element);
 8973             FPRReg valueFPR = value.fpr();
 8974 
 8975             m_jit.storeDouble(valueFPR, MacroAssembler::Address(bufferGPR, sizeof(double) * elementIndex));
 8976             value.use();
 8977         }
 8978 
 8979         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8980 
<span class="line-modified"> 8981         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushDoubleMultiple, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
 8982 
 8983         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8984         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8985 
 8986         base.use();
 8987         storage.use();
 8988 
 8989         fastPath.link(&amp;m_jit);
 8990         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8991         return;
 8992     }
 8993 
 8994     case Array::ArrayStorage: {
 8995         // This ensures that the result of ArrayPush is Int32 in AI.
 8996         int32_t largestPositiveInt32Length = 0x7fffffff - elementCount;
 8997         if (elementCount == 1) {
 8998             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8999             JSValueOperand value(this, element);
 9000             JSValueRegs valueRegs = value.jsValueRegs();
 9001 
 9002             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
 9003 
 9004             // Refuse to handle bizarre lengths.
 9005             speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::Above, storageLengthGPR, TrustedImm32(largestPositiveInt32Length)));
 9006 
 9007             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
 9008 
 9009             m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
 9010 
 9011             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 9012             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
 9013             m_jit.add32(TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 9014             m_jit.boxInt32(storageLengthGPR, resultRegs);
 9015 
 9016             addSlowPathGenerator(
<span class="line-modified"> 9017                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, baseGPR));</span>
 9018 
 9019             jsValueResult(resultRegs, node);
 9020             return;
 9021         }
 9022 
 9023         GPRTemporary buffer(this);
 9024         GPRReg bufferGPR = buffer.gpr();
 9025 
 9026         m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
 9027 
 9028         // Refuse to handle bizarre lengths.
 9029         speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::Above, storageLengthGPR, TrustedImm32(largestPositiveInt32Length)));
 9030 
 9031         m_jit.move(storageLengthGPR, bufferGPR);
 9032         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 9033         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
 9034 
 9035         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
 9036         getStorageBufferAddress(storageGPR, storageLengthGPR, ArrayStorage::vectorOffset(), bufferGPR);
 9037         m_jit.add32(TrustedImm32(elementCount), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
</pre>
<hr />
<pre>
 9043 
 9044         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 9045         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 9046         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 9047         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 9048         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 9049 
 9050         storageDone.link(&amp;m_jit);
 9051         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 9052             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 9053             JSValueOperand value(this, element);
 9054             JSValueRegs valueRegs = value.jsValueRegs();
 9055 
 9056             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 9057             value.use();
 9058         }
 9059 
 9060         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 9061 
 9062         addSlowPathGenerator(
<span class="line-modified"> 9063             slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
 9064 
 9065         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 9066         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 9067 
 9068         base.use();
 9069         storage.use();
 9070 
 9071         fastPath.link(&amp;m_jit);
 9072         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 9073         return;
 9074     }
 9075 
 9076     default:
 9077         RELEASE_ASSERT_NOT_REACHED();
 9078     }
 9079 }
 9080 
 9081 void SpeculativeJIT::compileNotifyWrite(Node* node)
 9082 {
 9083     WatchpointSet* set = node-&gt;watchpointSet();
 9084 
 9085     JITCompiler::Jump slowCase = m_jit.branch8(
 9086         JITCompiler::NotEqual,
 9087         JITCompiler::AbsoluteAddress(set-&gt;addressOfState()),
 9088         TrustedImm32(IsInvalidated));
 9089 
 9090     addSlowPathGenerator(
<span class="line-modified"> 9091         slowPathCall(slowCase, this, operationNotifyWrite, NeedToSpill, ExceptionCheckRequirement::CheckNotNeeded, NoResult, &amp;vm(), set));</span>
 9092 
 9093     noResult(node);
 9094 }
 9095 
 9096 void SpeculativeJIT::compileIsObject(Node* node)
 9097 {
 9098     JSValueOperand value(this, node-&gt;child1());
 9099     GPRTemporary result(this, Reuse, value, TagWord);
 9100 
 9101     JSValueRegs valueRegs = value.jsValueRegs();
 9102     GPRReg resultGPR = result.gpr();
 9103 
 9104     JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 9105 
 9106     m_jit.compare8(JITCompiler::AboveOrEqual,
 9107         JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()),
 9108         TrustedImm32(ObjectType),
 9109         resultGPR);
 9110     JITCompiler::Jump done = m_jit.jump();
 9111 
</pre>
<hr />
<pre>
 9318     }
 9319 }
 9320 
 9321 void SpeculativeJIT::compileAllocatePropertyStorage(Node* node)
 9322 {
 9323     ASSERT(!node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity());
 9324     ASSERT(initialOutOfLineCapacity == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity());
 9325 
 9326     size_t size = initialOutOfLineCapacity * sizeof(JSValue);
 9327 
 9328     Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists);
 9329 
 9330     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9331         SpeculateCellOperand base(this, node-&gt;child1());
 9332 
 9333         GPRReg baseGPR = base.gpr();
 9334 
 9335         flushRegisters();
 9336 
 9337         GPRFlushedCallResult result(this);
<span class="line-modified"> 9338         callOperation(operationAllocateComplexPropertyStorageWithInitialCapacity, result.gpr(), &amp;vm(), baseGPR);</span>
 9339         m_jit.exceptionCheck();
 9340 
 9341         storageResult(result.gpr(), node);
 9342         return;
 9343     }
 9344 
 9345     GPRTemporary scratch1(this);
 9346     GPRTemporary scratch2(this);
 9347     GPRTemporary scratch3(this);
 9348 
 9349     GPRReg scratchGPR1 = scratch1.gpr();
 9350     GPRReg scratchGPR2 = scratch2.gpr();
 9351     GPRReg scratchGPR3 = scratch3.gpr();
 9352 
 9353     JITCompiler::JumpList slowPath;
 9354     m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
 9355     m_jit.addPtr(JITCompiler::TrustedImm32(size + sizeof(IndexingHeader)), scratchGPR1);
 9356 
 9357     addSlowPathGenerator(
<span class="line-modified"> 9358         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorageWithInitialCapacity, scratchGPR1, &amp;vm()));</span>
 9359 
 9360     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(size); offset += sizeof(void*))
 9361         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9362 
 9363     storageResult(scratchGPR1, node);
 9364 }
 9365 
 9366 void SpeculativeJIT::compileReallocatePropertyStorage(Node* node)
 9367 {
 9368     size_t oldSize = node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity() * sizeof(JSValue);
 9369     size_t newSize = oldSize * outOfLineGrowthFactor;
 9370     ASSERT(newSize == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity() * sizeof(JSValue));
 9371 
 9372     Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(newSize, AllocatorForMode::AllocatorIfExists);
 9373 
 9374     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9375         SpeculateCellOperand base(this, node-&gt;child1());
 9376 
 9377         GPRReg baseGPR = base.gpr();
 9378 
 9379         flushRegisters();
 9380 
 9381         GPRFlushedCallResult result(this);
<span class="line-modified"> 9382         callOperation(operationAllocateComplexPropertyStorage, result.gpr(), &amp;vm(), baseGPR, newSize / sizeof(JSValue));</span>
 9383         m_jit.exceptionCheck();
 9384 
 9385         storageResult(result.gpr(), node);
 9386         return;
 9387     }
 9388 
 9389     StorageOperand oldStorage(this, node-&gt;child2());
 9390     GPRTemporary scratch1(this);
 9391     GPRTemporary scratch2(this);
 9392     GPRTemporary scratch3(this);
 9393 
 9394     GPRReg oldStorageGPR = oldStorage.gpr();
 9395     GPRReg scratchGPR1 = scratch1.gpr();
 9396     GPRReg scratchGPR2 = scratch2.gpr();
 9397     GPRReg scratchGPR3 = scratch3.gpr();
 9398 
 9399     JITCompiler::JumpList slowPath;
 9400     m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
 9401 
 9402     m_jit.addPtr(JITCompiler::TrustedImm32(newSize + sizeof(IndexingHeader)), scratchGPR1);
 9403 
 9404     addSlowPathGenerator(
<span class="line-modified"> 9405         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorage, scratchGPR1, &amp;vm(), newSize / sizeof(JSValue)));</span>
 9406 
 9407     for (ptrdiff_t offset = oldSize; offset &lt; static_cast&lt;ptrdiff_t&gt;(newSize); offset += sizeof(void*))
 9408         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9409 
 9410     // We have scratchGPR1 = new storage, scratchGPR2 = scratch
 9411     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(oldSize); offset += sizeof(void*)) {
 9412         m_jit.loadPtr(JITCompiler::Address(oldStorageGPR, -(offset + sizeof(JSValue) + sizeof(void*))), scratchGPR2);
 9413         m_jit.storePtr(scratchGPR2, JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9414     }
 9415 
 9416     storageResult(scratchGPR1, node);
 9417 }
 9418 
 9419 void SpeculativeJIT::compileNukeStructureAndSetButterfly(Node* node)
 9420 {
 9421     SpeculateCellOperand base(this, node-&gt;child1());
 9422     StorageOperand storage(this, node-&gt;child2());
 9423 
 9424     GPRReg baseGPR = base.gpr();
 9425     GPRReg storageGPR = storage.gpr();
</pre>
<hr />
<pre>
 9503                 break;
 9504             case SpecInt32Only:
 9505                 appendInt32(edge);
 9506                 break;
 9507             case SpecBoolean:
 9508                 appendBoolean(edge);
 9509                 break;
 9510             default:
 9511                 RELEASE_ASSERT_NOT_REACHED();
 9512                 break;
 9513             }
 9514         }
 9515         ++index;
 9516     });
 9517 
 9518     JSValueRegsTemporary result(this);
 9519     JSValueRegs resultRegs = result.regs();
 9520 
 9521     flushRegisters();
 9522 
<span class="line-added"> 9523     // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added"> 9524     // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
 9525     auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);
 9526     unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
 9527     switch (argumentCountIncludingThis) {
 9528     case 1:
<span class="line-modified"> 9529         callOperation(reinterpret_cast&lt;J_JITOperation_GP&gt;(function.get()), extractResult(resultRegs), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), regs[0]);</span>
 9530         break;
 9531     case 2:
<span class="line-modified"> 9532         callOperation(reinterpret_cast&lt;J_JITOperation_GPP&gt;(function.get()), extractResult(resultRegs), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), regs[0], regs[1]);</span>
 9533         break;
 9534     case 3:
<span class="line-modified"> 9535         callOperation(reinterpret_cast&lt;J_JITOperation_GPPP&gt;(function.get()), extractResult(resultRegs), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), regs[0], regs[1], regs[2]);</span>
 9536         break;
 9537     default:
 9538         RELEASE_ASSERT_NOT_REACHED();
 9539         break;
 9540     }
 9541 
 9542     m_jit.exceptionCheck();
 9543     jsValueResult(resultRegs, node);
 9544 }
 9545 
 9546 void SpeculativeJIT::compileCallDOMGetter(Node* node)
 9547 {
 9548     DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
 9549     if (!snippet) {
 9550         FunctionPtr&lt;OperationPtrTag&gt; getter = node-&gt;callDOMGetterData()-&gt;customAccessorGetter;
 9551         SpeculateCellOperand base(this, node-&gt;child1());
 9552         JSValueRegsTemporary result(this);
 9553 
 9554         JSValueRegs resultRegs = result.regs();
 9555         GPRReg baseGPR = base.gpr();
 9556 
 9557         flushRegisters();
<span class="line-modified"> 9558         m_jit.setupArguments&lt;J_JITOperation_GJI&gt;(TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;callDOMGetterData()-&gt;identifierNumber));</span>
 9559         m_jit.storePtr(GPRInfo::callFrameRegister, &amp;vm().topCallFrame);
 9560         m_jit.emitStoreCodeOrigin(m_currentNode-&gt;origin.semantic);
 9561         m_jit.appendCall(getter.retagged&lt;CFunctionPtrTag&gt;());
 9562         m_jit.setupResults(resultRegs);
 9563 
 9564         m_jit.exceptionCheck();
 9565         jsValueResult(resultRegs, node);
 9566         return;
 9567     }
 9568 
 9569     Vector&lt;GPRReg&gt; gpScratch;
 9570     Vector&lt;FPRReg&gt; fpScratch;
 9571     Vector&lt;SnippetParams::Value&gt; regs;
 9572 
 9573     JSValueRegsTemporary result(this);
 9574     regs.append(result.regs());
 9575 
 9576     Edge&amp; baseEdge = node-&gt;child1();
 9577     SpeculateCellOperand base(this, baseEdge);
 9578     regs.append(SnippetParams::Value(base.gpr(), m_state.forNode(baseEdge).value()));
</pre>
<hr />
<pre>
 9647     temporary.adopt(realTemporary);
 9648     return temporary.gpr();
 9649 }
 9650 
 9651 void SpeculativeJIT::compileToStringOrCallStringConstructorOrStringValueOf(Node* node)
 9652 {
 9653     ASSERT(node-&gt;op() != StringValueOf || node-&gt;child1().useKind() == UntypedUse);
 9654     switch (node-&gt;child1().useKind()) {
 9655     case NotCellUse: {
 9656         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 9657         JSValueRegs op1Regs = op1.jsValueRegs();
 9658 
 9659         GPRFlushedCallResult result(this);
 9660         GPRReg resultGPR = result.gpr();
 9661 
 9662         speculateNotCell(node-&gt;child1(), op1Regs);
 9663 
 9664         flushRegisters();
 9665 
 9666         if (node-&gt;op() == ToString)
<span class="line-modified"> 9667             callOperation(operationToString, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 9668         else {
 9669             ASSERT(node-&gt;op() == CallStringConstructor);
<span class="line-modified"> 9670             callOperation(operationCallStringConstructor, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 9671         }
 9672         m_jit.exceptionCheck();
 9673         cellResult(resultGPR, node);
 9674         return;
 9675     }
 9676 
 9677     case UntypedUse: {
 9678         JSValueOperand op1(this, node-&gt;child1());
 9679         JSValueRegs op1Regs = op1.jsValueRegs();
 9680         GPRReg op1PayloadGPR = op1Regs.payloadGPR();
 9681 
 9682         GPRFlushedCallResult result(this);
 9683         GPRReg resultGPR = result.gpr();
 9684 
 9685         flushRegisters();
 9686 
 9687         JITCompiler::Jump done;
 9688         if (node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 9689             JITCompiler::Jump slowPath1 = m_jit.branchIfNotCell(op1.jsValueRegs());
 9690             JITCompiler::Jump slowPath2 = m_jit.branchIfNotString(op1PayloadGPR);
 9691             m_jit.move(op1PayloadGPR, resultGPR);
 9692             done = m_jit.jump();
 9693             slowPath1.link(&amp;m_jit);
 9694             slowPath2.link(&amp;m_jit);
 9695         }
 9696         if (node-&gt;op() == ToString)
<span class="line-modified"> 9697             callOperation(operationToString, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 9698         else if (node-&gt;op() == StringValueOf)
<span class="line-modified"> 9699             callOperation(operationStringValueOf, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 9700         else {
 9701             ASSERT(node-&gt;op() == CallStringConstructor);
<span class="line-modified"> 9702             callOperation(operationCallStringConstructor, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 9703         }
 9704         m_jit.exceptionCheck();
 9705         if (done.isSet())
 9706             done.link(&amp;m_jit);
 9707         cellResult(resultGPR, node);
 9708         return;
 9709     }
 9710 
 9711     case Int32Use:
 9712     case Int52RepUse:
 9713     case DoubleRepUse:
 9714         compileNumberToStringWithValidRadixConstant(node, 10);
 9715         return;
 9716 
 9717     default:
 9718         break;
 9719     }
 9720 
 9721     SpeculateCellOperand op1(this, node-&gt;child1());
 9722     GPRReg op1GPR = op1.gpr();
</pre>
<hr />
<pre>
 9753         cellResult(resultGPR, node);
 9754         break;
 9755     }
 9756 
 9757     case CellUse: {
 9758         GPRFlushedCallResult result(this);
 9759         GPRReg resultGPR = result.gpr();
 9760 
 9761         // We flush registers instead of silent spill/fill because in this mode we
 9762         // believe that most likely the input is not a string, and we need to take
 9763         // slow path.
 9764         flushRegisters();
 9765         JITCompiler::Jump done;
 9766         if (node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 9767             JITCompiler::Jump needCall = m_jit.branchIfNotString(op1GPR);
 9768             m_jit.move(op1GPR, resultGPR);
 9769             done = m_jit.jump();
 9770             needCall.link(&amp;m_jit);
 9771         }
 9772         if (node-&gt;op() == ToString)
<span class="line-modified"> 9773             callOperation(operationToStringOnCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1GPR);</span>
 9774         else {
 9775             ASSERT(node-&gt;op() == CallStringConstructor);
<span class="line-modified"> 9776             callOperation(operationCallStringConstructorOnCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1GPR);</span>
 9777         }
 9778         m_jit.exceptionCheck();
 9779         if (done.isSet())
 9780             done.link(&amp;m_jit);
 9781         cellResult(resultGPR, node);
 9782         break;
 9783     }
 9784 
 9785     default:
 9786         RELEASE_ASSERT_NOT_REACHED();
 9787     }
 9788 }
 9789 
 9790 void SpeculativeJIT::compileNumberToStringWithValidRadixConstant(Node* node)
 9791 {
 9792     compileNumberToStringWithValidRadixConstant(node, node-&gt;validRadixConstant());
 9793 }
 9794 
 9795 void SpeculativeJIT::compileNumberToStringWithValidRadixConstant(Node* node, int32_t radix)
 9796 {
 9797     auto callToString = [&amp;] (auto operation, GPRReg resultGPR, auto valueReg) {
 9798         flushRegisters();
<span class="line-modified"> 9799         callOperation(operation, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueReg, TrustedImm32(radix));</span>
 9800         m_jit.exceptionCheck();
 9801         cellResult(resultGPR, node);
 9802     };
 9803 
 9804     switch (node-&gt;child1().useKind()) {
 9805     case Int32Use: {
 9806         SpeculateStrictInt32Operand value(this, node-&gt;child1());
 9807         GPRFlushedCallResult result(this);
 9808         callToString(operationInt32ToStringWithValidRadix, result.gpr(), value.gpr());
 9809         break;
 9810     }
 9811 
 9812 #if USE(JSVALUE64)
 9813     case Int52RepUse: {
 9814         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 9815         GPRFlushedCallResult result(this);
 9816         callToString(operationInt52ToStringWithValidRadix, result.gpr(), value.gpr());
 9817         break;
 9818     }
 9819 #endif
</pre>
<hr />
<pre>
 9824         callToString(operationDoubleToStringWithValidRadix, result.gpr(), value.fpr());
 9825         break;
 9826     }
 9827 
 9828     default:
 9829         RELEASE_ASSERT_NOT_REACHED();
 9830     }
 9831 }
 9832 
 9833 void SpeculativeJIT::compileNumberToStringWithRadix(Node* node)
 9834 {
 9835     bool validRadixIsGuaranteed = false;
 9836     if (node-&gt;child2()-&gt;isInt32Constant()) {
 9837         int32_t radix = node-&gt;child2()-&gt;asInt32();
 9838         if (radix &gt;= 2 &amp;&amp; radix &lt;= 36)
 9839             validRadixIsGuaranteed = true;
 9840     }
 9841 
 9842     auto callToString = [&amp;] (auto operation, GPRReg resultGPR, auto valueReg, GPRReg radixGPR) {
 9843         flushRegisters();
<span class="line-modified"> 9844         callOperation(operation, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueReg, radixGPR);</span>
 9845         m_jit.exceptionCheck();
 9846         cellResult(resultGPR, node);
 9847     };
 9848 
 9849     switch (node-&gt;child1().useKind()) {
 9850     case Int32Use: {
 9851         SpeculateStrictInt32Operand value(this, node-&gt;child1());
 9852         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9853         GPRFlushedCallResult result(this);
 9854         callToString(validRadixIsGuaranteed ? operationInt32ToStringWithValidRadix : operationInt32ToString, result.gpr(), value.gpr(), radix.gpr());
 9855         break;
 9856     }
 9857 
 9858 #if USE(JSVALUE64)
 9859     case Int52RepUse: {
 9860         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 9861         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9862         GPRFlushedCallResult result(this);
 9863         callToString(validRadixIsGuaranteed ? operationInt52ToStringWithValidRadix : operationInt52ToString, result.gpr(), value.gpr(), radix.gpr());
 9864         break;
</pre>
<hr />
<pre>
 9899         slowPath);
 9900 
 9901     m_jit.storePtr(
 9902         TrustedImmPtr(StringObject::info()),
 9903         JITCompiler::Address(resultGPR, JSDestructibleObject::classInfoOffset()));
 9904 #if USE(JSVALUE64)
 9905     m_jit.store64(
 9906         operandGPR, JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset()));
 9907 #else
 9908     m_jit.store32(
 9909         TrustedImm32(JSValue::CellTag),
 9910         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 9911     m_jit.store32(
 9912         operandGPR,
 9913         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 9914 #endif
 9915 
 9916     m_jit.mutatorFence(vm());
 9917 
 9918     addSlowPathGenerator(slowPathCall(
<span class="line-modified"> 9919         slowPath, this, operationNewStringObject, resultGPR, &amp;vm(), operandGPR, node-&gt;structure()));</span>
 9920 
 9921     cellResult(resultGPR, node);
 9922 }
 9923 
 9924 void SpeculativeJIT::compileNewSymbol(Node* node)
 9925 {
 9926     if (!node-&gt;child1()) {
 9927         flushRegisters();
 9928         GPRFlushedCallResult result(this);
 9929         GPRReg resultGPR = result.gpr();
<span class="line-modified"> 9930         callOperation(operationNewSymbol, resultGPR, &amp;vm());</span>
 9931         m_jit.exceptionCheck();
 9932         cellResult(resultGPR, node);
 9933         return;
 9934     }
 9935 
 9936 
 9937     ASSERT(node-&gt;child1().useKind() == KnownStringUse);
 9938     SpeculateCellOperand operand(this, node-&gt;child1());
 9939 
 9940     GPRReg stringGPR = operand.gpr();
 9941 
 9942     flushRegisters();
 9943     GPRFlushedCallResult result(this);
 9944     GPRReg resultGPR = result.gpr();
<span class="line-modified"> 9945     callOperation(operationNewSymbolWithDescription, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR);</span>
 9946     m_jit.exceptionCheck();
 9947     cellResult(resultGPR, node);
 9948 }
 9949 
 9950 void SpeculativeJIT::compileNewTypedArrayWithSize(Node* node)
 9951 {
 9952     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 9953     auto typedArrayType = node-&gt;typedArrayType();
 9954     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType));
 9955     RELEASE_ASSERT(structure.get());
 9956 
 9957     SpeculateInt32Operand size(this, node-&gt;child1());
 9958     GPRReg sizeGPR = size.gpr();
 9959 
 9960     GPRTemporary result(this);
 9961     GPRTemporary storage(this);
 9962     GPRTemporary scratch(this);
 9963     GPRTemporary scratch2(this);
 9964     GPRReg resultGPR = result.gpr();
 9965     GPRReg storageGPR = storage.gpr();
</pre>
<hr />
<pre>
 9992             if (elementSize(typedArrayType) &gt; 1)
 9993                 m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType)), scratchGPR);
 9994             m_jit.add32(TrustedImm32(3), scratchGPR);
 9995             m_jit.urshift32(TrustedImm32(2), scratchGPR);
 9996         }
 9997     }
 9998     MacroAssembler::Label loop = m_jit.label();
 9999     m_jit.sub32(TrustedImm32(1), scratchGPR);
10000     m_jit.store32(
10001         TrustedImm32(0),
10002         MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesFour));
10003     m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
10004     done.link(&amp;m_jit);
10005 #if CPU(ARM64E)
10006     // sizeGPR is still boxed as a number and there is no 32-bit variant of the PAC instructions.
10007     m_jit.zeroExtend32ToPtr(sizeGPR, scratchGPR);
10008     m_jit.tagArrayPtr(scratchGPR, storageGPR);
10009 #endif
10010 
10011     auto butterfly = TrustedImmPtr(nullptr);
<span class="line-modified">10012     switch (typedArrayType) {</span>
<span class="line-modified">10013 #define TYPED_ARRAY_TYPE_CASE(name) \</span>
<span class="line-modified">10014     case Type ## name: \</span>
<span class="line-added">10015         emitAllocateJSObject&lt;JS##name##Array&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2, slowCases); \</span>
<span class="line-added">10016         break;</span>
<span class="line-added">10017     FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(TYPED_ARRAY_TYPE_CASE)</span>
<span class="line-added">10018 #undef TYPED_ARRAY_TYPE_CASE</span>
<span class="line-added">10019     case TypeDataView:</span>
<span class="line-added">10020         emitAllocateJSObject&lt;JSDataView&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2, slowCases);</span>
<span class="line-added">10021         break;</span>
<span class="line-added">10022     default:</span>
<span class="line-added">10023         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">10024         break;</span>
<span class="line-added">10025     }</span>
10026 
10027     m_jit.storePtr(
10028         storageGPR,
10029         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfVector()));
10030     m_jit.store32(
10031         sizeGPR,
10032         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfLength()));
10033     m_jit.store32(
10034         TrustedImm32(FastTypedArray),
10035         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfMode()));
10036 
10037     m_jit.mutatorFence(vm());
10038 
10039     addSlowPathGenerator(slowPathCall(
10040         slowCases, this, operationNewTypedArrayWithSizeForType(typedArrayType),
<span class="line-modified">10041         resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), structure, sizeGPR, storageGPR));</span>
10042 
10043     cellResult(resultGPR, node);
10044 }
10045 
10046 void SpeculativeJIT::compileNewRegexp(Node* node)
10047 {
10048     RegExp* regexp = node-&gt;castOperand&lt;RegExp*&gt;();
10049 
10050     GPRTemporary result(this);
10051     GPRTemporary scratch1(this);
10052     GPRTemporary scratch2(this);
10053     JSValueOperand lastIndex(this, node-&gt;child1());
10054 
10055     GPRReg resultGPR = result.gpr();
10056     GPRReg scratch1GPR = scratch1.gpr();
10057     GPRReg scratch2GPR = scratch2.gpr();
10058     JSValueRegs lastIndexRegs = lastIndex.jsValueRegs();
10059 
10060     JITCompiler::JumpList slowPath;
10061 
10062     auto structure = m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
10063     auto butterfly = TrustedImmPtr(nullptr);
10064     emitAllocateJSObject&lt;RegExpObject&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath);
10065 
10066     m_jit.storePtr(
10067         TrustedImmPtr(node-&gt;cellOperand()),
10068         CCallHelpers::Address(resultGPR, RegExpObject::offsetOfRegExpAndLastIndexIsNotWritableFlag()));
10069     m_jit.storeValue(lastIndexRegs, CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndex()));
10070     m_jit.mutatorFence(vm());
10071 
<span class="line-modified">10072     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewRegexpWithLastIndex, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), regexp, lastIndexRegs));</span>
10073 
10074     cellResult(resultGPR, node);
10075 }
10076 
10077 void SpeculativeJIT::speculateCellTypeWithoutTypeFiltering(
10078     Edge edge, GPRReg cellGPR, JSType jsType)
10079 {
10080     speculationCheck(
10081         BadType, JSValueSource::unboxedCell(cellGPR), edge,
10082         m_jit.branchIfNotType(cellGPR, jsType));
10083 }
10084 
10085 void SpeculativeJIT::speculateCellType(
10086     Edge edge, GPRReg cellGPR, SpeculatedType specType, JSType jsType)
10087 {
10088     DFG_TYPE_CHECK(
10089         JSValueSource::unboxedCell(cellGPR), edge, specType,
10090         m_jit.branchIfNotType(cellGPR, jsType));
10091 }
10092 
</pre>
<hr />
<pre>
10276         return;
10277 
10278     SpeculateCellOperand operand(this, edge);
10279     speculateProxyObject(edge, operand.gpr());
10280 }
10281 
10282 void SpeculativeJIT::speculateDerivedArray(Edge edge, GPRReg cell)
10283 {
10284     speculateCellType(edge, cell, SpecDerivedArray, DerivedArrayType);
10285 }
10286 
10287 void SpeculativeJIT::speculateDerivedArray(Edge edge)
10288 {
10289     if (!needsTypeCheck(edge, SpecDerivedArray))
10290         return;
10291 
10292     SpeculateCellOperand operand(this, edge);
10293     speculateDerivedArray(edge, operand.gpr());
10294 }
10295 
<span class="line-added">10296 void SpeculativeJIT::speculatePromiseObject(Edge edge, GPRReg cell)</span>
<span class="line-added">10297 {</span>
<span class="line-added">10298     speculateCellType(edge, cell, SpecPromiseObject, JSPromiseType);</span>
<span class="line-added">10299 }</span>
<span class="line-added">10300 </span>
<span class="line-added">10301 void SpeculativeJIT::speculatePromiseObject(Edge edge)</span>
<span class="line-added">10302 {</span>
<span class="line-added">10303     if (!needsTypeCheck(edge, SpecPromiseObject))</span>
<span class="line-added">10304         return;</span>
<span class="line-added">10305 </span>
<span class="line-added">10306     SpeculateCellOperand operand(this, edge);</span>
<span class="line-added">10307     speculatePromiseObject(edge, operand.gpr());</span>
<span class="line-added">10308 }</span>
<span class="line-added">10309 </span>
<span class="line-added">10310 void SpeculativeJIT::speculateDateObject(Edge edge, GPRReg cell)</span>
<span class="line-added">10311 {</span>
<span class="line-added">10312     speculateCellType(edge, cell, SpecDateObject, JSDateType);</span>
<span class="line-added">10313 }</span>
<span class="line-added">10314 </span>
<span class="line-added">10315 void SpeculativeJIT::speculateDateObject(Edge edge)</span>
<span class="line-added">10316 {</span>
<span class="line-added">10317     if (!needsTypeCheck(edge, SpecDateObject))</span>
<span class="line-added">10318         return;</span>
<span class="line-added">10319 </span>
<span class="line-added">10320     SpeculateCellOperand operand(this, edge);</span>
<span class="line-added">10321     speculateDateObject(edge, operand.gpr());</span>
<span class="line-added">10322 }</span>
<span class="line-added">10323 </span>
10324 void SpeculativeJIT::speculateMapObject(Edge edge, GPRReg cell)
10325 {
10326     speculateCellType(edge, cell, SpecMapObject, JSMapType);
10327 }
10328 
10329 void SpeculativeJIT::speculateMapObject(Edge edge)
10330 {
10331     if (!needsTypeCheck(edge, SpecMapObject))
10332         return;
10333 
10334     SpeculateCellOperand operand(this, edge);
10335     speculateMapObject(edge, operand.gpr());
10336 }
10337 
10338 void SpeculativeJIT::speculateSetObject(Edge edge, GPRReg cell)
10339 {
10340     speculateCellType(edge, cell, SpecSetObject, JSSetType);
10341 }
10342 
10343 void SpeculativeJIT::speculateSetObject(Edge edge)
</pre>
<hr />
<pre>
10618 
10619     GPRTemporary temp(this);
10620     GPRReg tempGPR = temp.gpr();
10621     speculateOther(edge, regs, tempGPR);
10622 }
10623 
10624 void SpeculativeJIT::speculateOther(Edge edge)
10625 {
10626     if (!needsTypeCheck(edge, SpecOther))
10627         return;
10628 
10629     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10630     speculateOther(edge, operand.jsValueRegs());
10631 }
10632 
10633 void SpeculativeJIT::speculateMisc(Edge edge, JSValueRegs regs)
10634 {
10635 #if USE(JSVALUE64)
10636     DFG_TYPE_CHECK(
10637         regs, edge, SpecMisc,
<span class="line-modified">10638         m_jit.branch64(MacroAssembler::Above, regs.gpr(), MacroAssembler::TrustedImm64(JSValue::MiscTag)));</span>
10639 #else
10640     IGNORE_WARNINGS_BEGIN(&quot;enum-compare&quot;)
10641     static_assert(JSValue::Int32Tag &gt;= JSValue::UndefinedTag, &quot;Int32Tag is included in &gt;= JSValue::UndefinedTag range.&quot;);
10642     IGNORE_WARNINGS_END
10643     DFG_TYPE_CHECK(
10644         regs, edge, ~SpecInt32Only,
10645         m_jit.branchIfInt32(regs.tagGPR()));
10646     DFG_TYPE_CHECK(
10647         regs, edge, SpecMisc,
10648         m_jit.branch32(MacroAssembler::Below, regs.tagGPR(), MacroAssembler::TrustedImm32(JSValue::UndefinedTag)));
10649 #endif
10650 }
10651 
10652 void SpeculativeJIT::speculateMisc(Edge edge)
10653 {
10654     if (!needsTypeCheck(edge, SpecMisc))
10655         return;
10656 
10657     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10658     speculateMisc(edge, operand.jsValueRegs());
</pre>
<hr />
<pre>
10700         speculateCell(edge);
10701         break;
10702     case CellOrOtherUse:
10703         speculateCellOrOther(edge);
10704         break;
10705     case ObjectUse:
10706         speculateObject(edge);
10707         break;
10708     case FunctionUse:
10709         speculateFunction(edge);
10710         break;
10711     case ArrayUse:
10712         speculateArray(edge);
10713         break;
10714     case FinalObjectUse:
10715         speculateFinalObject(edge);
10716         break;
10717     case RegExpObjectUse:
10718         speculateRegExpObject(edge);
10719         break;
<span class="line-added">10720     case PromiseObjectUse:</span>
<span class="line-added">10721         speculatePromiseObject(edge);</span>
<span class="line-added">10722         break;</span>
10723     case ProxyObjectUse:
10724         speculateProxyObject(edge);
10725         break;
10726     case DerivedArrayUse:
10727         speculateDerivedArray(edge);
10728         break;
<span class="line-added">10729     case DateObjectUse:</span>
<span class="line-added">10730         speculateDateObject(edge);</span>
<span class="line-added">10731         break;</span>
10732     case MapObjectUse:
10733         speculateMapObject(edge);
10734         break;
10735     case SetObjectUse:
10736         speculateSetObject(edge);
10737         break;
10738     case WeakMapObjectUse:
10739         speculateWeakMapObject(edge);
10740         break;
10741     case WeakSetObjectUse:
10742         speculateWeakSetObject(edge);
10743         break;
10744     case DataViewObjectUse:
10745         speculateDataViewObject(edge);
10746         break;
10747     case ObjectOrOtherUse:
10748         speculateObjectOrOther(edge);
10749         break;
10750     case StringIdentUse:
10751         speculateStringIdent(edge);
</pre>
<hr />
<pre>
10812         SpeculateInt32Operand value(this, node-&gt;child1());
10813         GPRTemporary temp(this);
10814         emitSwitchIntJump(data, value.gpr(), temp.gpr());
10815         noResult(node);
10816         break;
10817     }
10818 
10819     case UntypedUse: {
10820         JSValueOperand value(this, node-&gt;child1());
10821         GPRTemporary temp(this);
10822         JSValueRegs valueRegs = value.jsValueRegs();
10823         GPRReg scratch = temp.gpr();
10824 
10825         value.use();
10826 
10827         auto notInt32 = m_jit.branchIfNotInt32(valueRegs);
10828         emitSwitchIntJump(data, valueRegs.payloadGPR(), scratch);
10829         notInt32.link(&amp;m_jit);
10830         addBranch(m_jit.branchIfNotNumber(valueRegs, scratch), data-&gt;fallThrough.block);
10831         silentSpillAllRegisters(scratch);
<span class="line-modified">10832         callOperation(operationFindSwitchImmTargetForDouble, scratch, &amp;vm(), valueRegs, data-&gt;switchTableIndex);</span>
10833         silentFillAllRegisters();
10834 
10835         m_jit.farJump(scratch, JSSwitchPtrTag);
10836         noResult(node, UseChildrenCalledExplicitly);
10837         break;
10838     }
10839 
10840     default:
10841         RELEASE_ASSERT_NOT_REACHED();
10842         break;
10843     }
10844 }
10845 
<span class="line-modified">10846 void SpeculativeJIT::emitSwitchCharStringJump(Node* node, SwitchData* data, GPRReg value, GPRReg scratch)</span>

10847 {
10848     m_jit.loadPtr(MacroAssembler::Address(value, JSString::offsetOfValue()), scratch);
10849     auto isRope = m_jit.branchIfRopeStringImpl(scratch);
<span class="line-added">10850     addSlowPathGenerator(slowPathCall(isRope, this, operationResolveRope, scratch, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), value));</span>
10851 
10852     addBranch(
10853         m_jit.branch32(
10854             MacroAssembler::NotEqual,
10855             MacroAssembler::Address(scratch, StringImpl::lengthMemoryOffset()),
10856             TrustedImm32(1)),
10857         data-&gt;fallThrough.block);
10858 


10859     m_jit.loadPtr(MacroAssembler::Address(scratch, StringImpl::dataOffset()), value);
10860 
10861     JITCompiler::Jump is8Bit = m_jit.branchTest32(
10862         MacroAssembler::NonZero,
10863         MacroAssembler::Address(scratch, StringImpl::flagsOffset()),
10864         TrustedImm32(StringImpl::flagIs8Bit()));
10865 
10866     m_jit.load16(MacroAssembler::Address(value), scratch);
10867 
10868     JITCompiler::Jump ready = m_jit.jump();
10869 
10870     is8Bit.link(&amp;m_jit);
10871     m_jit.load8(MacroAssembler::Address(value), scratch);
10872 
10873     ready.link(&amp;m_jit);
10874     emitSwitchIntJump(data, scratch, value);
10875 }
10876 
10877 void SpeculativeJIT::emitSwitchChar(Node* node, SwitchData* data)
10878 {
10879     switch (node-&gt;child1().useKind()) {
10880     case StringUse: {
10881         SpeculateCellOperand op1(this, node-&gt;child1());
10882         GPRTemporary temp(this);
10883 
10884         GPRReg op1GPR = op1.gpr();
10885         GPRReg tempGPR = temp.gpr();
10886 
10887         op1.use();
10888 
10889         speculateString(node-&gt;child1(), op1GPR);
<span class="line-modified">10890         emitSwitchCharStringJump(node, data, op1GPR, tempGPR);</span>
10891         noResult(node, UseChildrenCalledExplicitly);
10892         break;
10893     }
10894 
10895     case UntypedUse: {
10896         JSValueOperand op1(this, node-&gt;child1());
10897         GPRTemporary temp(this);
10898 
10899         JSValueRegs op1Regs = op1.jsValueRegs();
10900         GPRReg tempGPR = temp.gpr();
10901 
10902         op1.use();
10903 
10904         addBranch(m_jit.branchIfNotCell(op1Regs), data-&gt;fallThrough.block);
10905 
10906         addBranch(m_jit.branchIfNotString(op1Regs.payloadGPR()), data-&gt;fallThrough.block);
10907 
<span class="line-modified">10908         emitSwitchCharStringJump(node, data, op1Regs.payloadGPR(), tempGPR);</span>
10909         noResult(node, UseChildrenCalledExplicitly);
10910         break;
10911     }
10912 
10913     default:
10914         RELEASE_ASSERT_NOT_REACHED();
10915         break;
10916     }
10917 }
10918 
10919 namespace {
10920 
10921 struct CharacterCase {
10922     bool operator&lt;(const CharacterCase&amp; other) const
10923     {
10924         return character &lt; other.character;
10925     }
10926 
10927     LChar character;
10928     unsigned begin;
10929     unsigned end;
10930 };
10931 
10932 } // anonymous namespace
10933 
10934 void SpeculativeJIT::emitBinarySwitchStringRecurse(
10935     SwitchData* data, const Vector&lt;SpeculativeJIT::StringSwitchCase&gt;&amp; cases,
10936     unsigned numChecked, unsigned begin, unsigned end, GPRReg buffer, GPRReg length,
10937     GPRReg temp, unsigned alreadyCheckedLength, bool checkedExactLength)
10938 {
<span class="line-modified">10939     static constexpr bool verbose = false;</span>
10940 
10941     if (verbose) {
10942         dataLog(&quot;We&#39;re down to the following cases, alreadyCheckedLength = &quot;, alreadyCheckedLength, &quot;:\n&quot;);
10943         for (unsigned i = begin; i &lt; end; ++i) {
10944             dataLog(&quot;    &quot;, cases[i].string, &quot;\n&quot;);
10945         }
10946     }
10947 
10948     if (begin == end) {
10949         jump(data-&gt;fallThrough.block, ForceJump);
10950         return;
10951     }
10952 
10953     unsigned minLength = cases[begin].string-&gt;length();
10954     unsigned commonChars = minLength;
10955     bool allLengthsEqual = true;
10956     for (unsigned i = begin + 1; i &lt; end; ++i) {
10957         unsigned myCommonChars = numChecked;
10958         for (unsigned j = numChecked;
10959             j &lt; std::min(cases[begin].string-&gt;length(), cases[i].string-&gt;length());
</pre>
<hr />
<pre>
10980 
10981     if (verbose)
10982         dataLog(&quot;length = &quot;, minLength, &quot;, commonChars = &quot;, commonChars, &quot;, allLengthsEqual = &quot;, allLengthsEqual, &quot;\n&quot;);
10983 
10984     if (!allLengthsEqual &amp;&amp; alreadyCheckedLength &lt; minLength)
10985         branch32(MacroAssembler::Below, length, Imm32(minLength), data-&gt;fallThrough.block);
10986     if (allLengthsEqual &amp;&amp; (alreadyCheckedLength &lt; minLength || !checkedExactLength))
10987         branch32(MacroAssembler::NotEqual, length, Imm32(minLength), data-&gt;fallThrough.block);
10988 
10989     for (unsigned i = numChecked; i &lt; commonChars; ++i) {
10990         branch8(
10991             MacroAssembler::NotEqual, MacroAssembler::Address(buffer, i),
10992             TrustedImm32(cases[begin].string-&gt;at(i)), data-&gt;fallThrough.block);
10993     }
10994 
10995     if (minLength == commonChars) {
10996         // This is the case where one of the cases is a prefix of all of the other cases.
10997         // We&#39;ve already checked that the input string is a prefix of all of the cases,
10998         // so we just check length to jump to that case.
10999 
<span class="line-modified">11000         if (ASSERT_ENABLED) {</span>
11001             ASSERT(cases[begin].string-&gt;length() == commonChars);
11002             for (unsigned i = begin + 1; i &lt; end; ++i)
11003                 ASSERT(cases[i].string-&gt;length() &gt; commonChars);
11004         }
11005 
11006         if (allLengthsEqual) {
11007             RELEASE_ASSERT(end == begin + 1);
11008             jump(cases[begin].target, ForceJump);
11009             return;
11010         }
11011 
11012         branch32(MacroAssembler::Equal, length, Imm32(commonChars), cases[begin].target);
11013 
11014         // We&#39;ve checked if the length is &gt;= minLength, and then we checked if the
11015         // length is == commonChars. We get to this point if it is &gt;= minLength but not
11016         // == commonChars. Hence we know that it now must be &gt; minLength, i.e., that
11017         // it&#39;s &gt;= minLength + 1.
11018         emitBinarySwitchStringRecurse(
11019             data, cases, commonChars, begin + 1, end, buffer, length, temp, minLength + 1, false);
11020         return;
</pre>
<hr />
<pre>
11045         } else
11046             currentCase.end = i + 1;
11047     }
11048     characterCases.append(currentCase);
11049 
11050     Vector&lt;int64_t&gt; characterCaseValues;
11051     for (unsigned i = 0; i &lt; characterCases.size(); ++i)
11052         characterCaseValues.append(characterCases[i].character);
11053 
11054     BinarySwitch binarySwitch(temp, characterCaseValues, BinarySwitch::Int32);
11055     while (binarySwitch.advance(m_jit)) {
11056         const CharacterCase&amp; myCase = characterCases[binarySwitch.caseIndex()];
11057         emitBinarySwitchStringRecurse(
11058             data, cases, commonChars + 1, myCase.begin, myCase.end, buffer, length,
11059             temp, minLength, allLengthsEqual);
11060     }
11061 
11062     addBranch(binarySwitch.fallThrough(), data-&gt;fallThrough.block);
11063 }
11064 
<span class="line-modified">11065 void SpeculativeJIT::emitSwitchStringOnString(Node* node, SwitchData* data, GPRReg string)</span>
11066 {
11067     data-&gt;didUseJumpTable = true;
11068 
11069     bool canDoBinarySwitch = true;
11070     unsigned totalLength = 0;
11071 
11072     for (unsigned i = data-&gt;cases.size(); i--;) {
11073         StringImpl* string = data-&gt;cases[i].value.stringImpl();
11074         if (!string-&gt;is8Bit()) {
11075             canDoBinarySwitch = false;
11076             break;
11077         }
11078         if (string-&gt;length() &gt; Options::maximumBinaryStringSwitchCaseLength()) {
11079             canDoBinarySwitch = false;
11080             break;
11081         }
11082         totalLength += string-&gt;length();
11083     }
11084 
11085     if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
11086         flushRegisters();
11087         callOperation(
<span class="line-modified">11088             operationSwitchString, string, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);</span>
11089         m_jit.exceptionCheck();
11090         m_jit.farJump(string, JSSwitchPtrTag);
11091         return;
11092     }
11093 
11094     GPRTemporary length(this);
11095     GPRTemporary temp(this);
11096 
11097     GPRReg lengthGPR = length.gpr();
11098     GPRReg tempGPR = temp.gpr();
11099 
11100     MacroAssembler::JumpList slowCases;
11101     m_jit.loadPtr(MacroAssembler::Address(string, JSString::offsetOfValue()), tempGPR);
11102     slowCases.append(m_jit.branchIfRopeStringImpl(tempGPR));
11103     m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
11104 
11105     slowCases.append(m_jit.branchTest32(
11106         MacroAssembler::Zero,
11107         MacroAssembler::Address(tempGPR, StringImpl::flagsOffset()),
11108         TrustedImm32(StringImpl::flagIs8Bit())));
11109 
11110     m_jit.loadPtr(MacroAssembler::Address(tempGPR, StringImpl::dataOffset()), string);
11111 
11112     Vector&lt;StringSwitchCase&gt; cases;
11113     for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
11114         cases.append(
11115             StringSwitchCase(data-&gt;cases[i].value.stringImpl(), data-&gt;cases[i].target.block));
11116     }
11117 
11118     std::sort(cases.begin(), cases.end());
11119 
11120     emitBinarySwitchStringRecurse(
11121         data, cases, 0, 0, cases.size(), string, lengthGPR, tempGPR, 0, false);
11122 
11123     slowCases.link(&amp;m_jit);
11124     silentSpillAllRegisters(string);
<span class="line-modified">11125     callOperation(operationSwitchString, string, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);</span>
11126     silentFillAllRegisters();
11127     m_jit.exceptionCheck();
11128     m_jit.farJump(string, JSSwitchPtrTag);
11129 }
11130 
11131 void SpeculativeJIT::emitSwitchString(Node* node, SwitchData* data)
11132 {
11133     switch (node-&gt;child1().useKind()) {
11134     case StringIdentUse: {
11135         SpeculateCellOperand op1(this, node-&gt;child1());
11136         GPRTemporary temp(this);
11137 
11138         GPRReg op1GPR = op1.gpr();
11139         GPRReg tempGPR = temp.gpr();
11140 
11141         speculateString(node-&gt;child1(), op1GPR);
11142         speculateStringIdentAndLoadStorage(node-&gt;child1(), op1GPR, tempGPR);
11143 
11144         Vector&lt;int64_t&gt; identifierCaseValues;
11145         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
</pre>
<hr />
<pre>
11147                 static_cast&lt;int64_t&gt;(bitwise_cast&lt;intptr_t&gt;(data-&gt;cases[i].value.stringImpl())));
11148         }
11149 
11150         BinarySwitch binarySwitch(tempGPR, identifierCaseValues, BinarySwitch::IntPtr);
11151         while (binarySwitch.advance(m_jit))
11152             jump(data-&gt;cases[binarySwitch.caseIndex()].target.block, ForceJump);
11153         addBranch(binarySwitch.fallThrough(), data-&gt;fallThrough.block);
11154 
11155         noResult(node);
11156         break;
11157     }
11158 
11159     case StringUse: {
11160         SpeculateCellOperand op1(this, node-&gt;child1());
11161 
11162         GPRReg op1GPR = op1.gpr();
11163 
11164         op1.use();
11165 
11166         speculateString(node-&gt;child1(), op1GPR);
<span class="line-modified">11167         emitSwitchStringOnString(node, data, op1GPR);</span>
11168         noResult(node, UseChildrenCalledExplicitly);
11169         break;
11170     }
11171 
11172     case UntypedUse: {
11173         JSValueOperand op1(this, node-&gt;child1());
11174 
11175         JSValueRegs op1Regs = op1.jsValueRegs();
11176 
11177         op1.use();
11178 
11179         addBranch(m_jit.branchIfNotCell(op1Regs), data-&gt;fallThrough.block);
11180 
11181         addBranch(m_jit.branchIfNotString(op1Regs.payloadGPR()), data-&gt;fallThrough.block);
11182 
<span class="line-modified">11183         emitSwitchStringOnString(node, data, op1Regs.payloadGPR());</span>
11184         noResult(node, UseChildrenCalledExplicitly);
11185         break;
11186     }
11187 
11188     default:
11189         RELEASE_ASSERT_NOT_REACHED();
11190         break;
11191     }
11192 }
11193 
11194 void SpeculativeJIT::emitSwitch(Node* node)
11195 {
11196     SwitchData* data = node-&gt;switchData();
11197     switch (data-&gt;kind) {
11198     case SwitchImm: {
11199         emitSwitchImm(node, data);
11200         return;
11201     }
11202     case SwitchChar: {
11203         emitSwitchChar(node, data);
</pre>
<hr />
<pre>
11234 
11235     SpeculateCellOperand base(this, node-&gt;child1());
11236     GPRTemporary scratch1(this);
11237 
11238     GPRReg baseGPR = base.gpr();
11239     GPRReg scratch1GPR = scratch1.gpr();
11240 
11241     JITCompiler::JumpList ok;
11242 
11243     if (isFenced) {
11244         ok.append(m_jit.barrierBranch(vm(), baseGPR, scratch1GPR));
11245 
11246         JITCompiler::Jump noFence = m_jit.jumpIfMutatorFenceNotNeeded(vm());
11247         m_jit.memoryFence();
11248         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
11249         noFence.link(&amp;m_jit);
11250     } else
11251         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
11252 
11253     silentSpillAllRegisters(InvalidGPRReg);
<span class="line-modified">11254     callOperation(operationWriteBarrierSlowPath, &amp;vm(), baseGPR);</span>
11255     silentFillAllRegisters();
11256 
11257     ok.link(&amp;m_jit);
11258 
11259     noResult(node);
11260 }
11261 
11262 void SpeculativeJIT::compilePutAccessorById(Node* node)
11263 {
11264     SpeculateCellOperand base(this, node-&gt;child1());
11265     SpeculateCellOperand accessor(this, node-&gt;child2());
11266 
11267     GPRReg baseGPR = base.gpr();
11268     GPRReg accessorGPR = accessor.gpr();
11269 
11270     flushRegisters();
<span class="line-modified">11271     callOperation(node-&gt;op() == PutGetterById ? operationPutGetterById : operationPutSetterById, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), accessorGPR);</span>
11272     m_jit.exceptionCheck();
11273 
11274     noResult(node);
11275 }
11276 
11277 void SpeculativeJIT::compilePutGetterSetterById(Node* node)
11278 {
11279     SpeculateCellOperand base(this, node-&gt;child1());
11280     JSValueOperand getter(this, node-&gt;child2());
11281     JSValueOperand setter(this, node-&gt;child3());
11282 
11283 #if USE(JSVALUE64)
11284     GPRReg baseGPR = base.gpr();
11285     GPRReg getterGPR = getter.gpr();
11286     GPRReg setterGPR = setter.gpr();
11287 
11288     flushRegisters();
<span class="line-modified">11289     callOperation(operationPutGetterSetter, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterGPR, setterGPR);</span>
11290 #else
11291     // These JSValues may be JSUndefined OR JSFunction*.
11292     // At that time,
11293     // 1. If the JSValue is JSUndefined, its payload becomes nullptr.
11294     // 2. If the JSValue is JSFunction*, its payload becomes JSFunction*.
11295     // So extract payload and pass it to operationPutGetterSetter. This hack is used as the same way in baseline JIT.
11296     GPRReg baseGPR = base.gpr();
11297     JSValueRegs getterRegs = getter.jsValueRegs();
11298     JSValueRegs setterRegs = setter.jsValueRegs();
11299 
11300     flushRegisters();
<span class="line-modified">11301     callOperation(operationPutGetterSetter, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterRegs.payloadGPR(), setterRegs.payloadGPR());</span>
11302 #endif
11303     m_jit.exceptionCheck();
11304 
11305     noResult(node);
11306 }
11307 
11308 void SpeculativeJIT::compileResolveScope(Node* node)
11309 {
11310     SpeculateCellOperand scope(this, node-&gt;child1());
11311     GPRReg scopeGPR = scope.gpr();
11312     GPRFlushedCallResult result(this);
11313     GPRReg resultGPR = result.gpr();
11314     flushRegisters();
<span class="line-modified">11315     callOperation(operationResolveScope, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scopeGPR, identifierUID(node-&gt;identifierNumber()));</span>
11316     m_jit.exceptionCheck();
11317     cellResult(resultGPR, node);
11318 }
11319 
11320 void SpeculativeJIT::compileResolveScopeForHoistingFuncDeclInEval(Node* node)
11321 {
11322     SpeculateCellOperand scope(this, node-&gt;child1());
11323     GPRReg scopeGPR = scope.gpr();
11324     flushRegisters();
11325     JSValueRegsFlushedCallResult result(this);
11326     JSValueRegs resultRegs = result.regs();
<span class="line-modified">11327     callOperation(operationResolveScopeForHoistingFuncDeclInEval, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scopeGPR, identifierUID(node-&gt;identifierNumber()));</span>
11328     m_jit.exceptionCheck();
11329     jsValueResult(resultRegs, node);
11330 }
11331 
11332 void SpeculativeJIT::compileGetGlobalVariable(Node* node)
11333 {
11334     JSValueRegsTemporary result(this);
11335     JSValueRegs resultRegs = result.regs();
11336     m_jit.loadValue(node-&gt;variablePointer(), resultRegs);
11337     jsValueResult(resultRegs, node);
11338 }
11339 
11340 void SpeculativeJIT::compilePutGlobalVariable(Node* node)
11341 {
11342     JSValueOperand value(this, node-&gt;child2());
11343     JSValueRegs valueRegs = value.jsValueRegs();
11344     m_jit.storeValue(valueRegs, node-&gt;variablePointer());
11345     noResult(node);
11346 }
11347 
11348 void SpeculativeJIT::compileGetDynamicVar(Node* node)
11349 {
11350     SpeculateCellOperand scope(this, node-&gt;child1());
11351     GPRReg scopeGPR = scope.gpr();
11352     flushRegisters();
11353     JSValueRegsFlushedCallResult result(this);
11354     JSValueRegs resultRegs = result.regs();
<span class="line-modified">11355     callOperation(operationGetDynamicVar, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scopeGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
11356     m_jit.exceptionCheck();
11357     jsValueResult(resultRegs, node);
11358 }
11359 
11360 void SpeculativeJIT::compilePutDynamicVar(Node* node)
11361 {
11362     SpeculateCellOperand scope(this, node-&gt;child1());
11363     JSValueOperand value(this, node-&gt;child2());
11364 
11365     GPRReg scopeGPR = scope.gpr();
11366     JSValueRegs valueRegs = value.jsValueRegs();
11367 
11368     flushRegisters();
<span class="line-modified">11369     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scopeGPR, valueRegs, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
11370     m_jit.exceptionCheck();
11371     noResult(node);
11372 }
11373 
11374 void SpeculativeJIT::compileGetClosureVar(Node* node)
11375 {
11376     SpeculateCellOperand base(this, node-&gt;child1());
11377     JSValueRegsTemporary result(this);
11378 
11379     GPRReg baseGPR = base.gpr();
11380     JSValueRegs resultRegs = result.regs();
11381 
11382     m_jit.loadValue(JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())), resultRegs);
11383     jsValueResult(resultRegs, node);
11384 }
11385 
11386 void SpeculativeJIT::compilePutClosureVar(Node* node)
11387 {
11388     SpeculateCellOperand base(this, node-&gt;child1());
11389     JSValueOperand value(this, node-&gt;child2());
11390 
11391     GPRReg baseGPR = base.gpr();
11392     JSValueRegs valueRegs = value.jsValueRegs();
11393 
11394     m_jit.storeValue(valueRegs, JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())));
11395     noResult(node);
11396 }
11397 
<span class="line-added">11398 void SpeculativeJIT::compileGetInternalField(Node* node)</span>
<span class="line-added">11399 {</span>
<span class="line-added">11400     SpeculateCellOperand base(this, node-&gt;child1());</span>
<span class="line-added">11401     JSValueRegsTemporary result(this);</span>
<span class="line-added">11402 </span>
<span class="line-added">11403     GPRReg baseGPR = base.gpr();</span>
<span class="line-added">11404     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">11405 </span>
<span class="line-added">11406     m_jit.loadValue(JITCompiler::Address(baseGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(node-&gt;internalFieldIndex())), resultRegs);</span>
<span class="line-added">11407     jsValueResult(resultRegs, node);</span>
<span class="line-added">11408 }</span>
<span class="line-added">11409 </span>
<span class="line-added">11410 void SpeculativeJIT::compilePutInternalField(Node* node)</span>
<span class="line-added">11411 {</span>
<span class="line-added">11412     SpeculateCellOperand base(this, node-&gt;child1());</span>
<span class="line-added">11413     JSValueOperand value(this, node-&gt;child2());</span>
<span class="line-added">11414 </span>
<span class="line-added">11415     GPRReg baseGPR = base.gpr();</span>
<span class="line-added">11416     JSValueRegs valueRegs = value.jsValueRegs();</span>
<span class="line-added">11417 </span>
<span class="line-added">11418     m_jit.storeValue(valueRegs, JITCompiler::Address(baseGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(node-&gt;internalFieldIndex())));</span>
<span class="line-added">11419     noResult(node);</span>
<span class="line-added">11420 }</span>
<span class="line-added">11421 </span>
11422 void SpeculativeJIT::compilePutAccessorByVal(Node* node)
11423 {
11424     SpeculateCellOperand base(this, node-&gt;child1());
11425     JSValueOperand subscript(this, node-&gt;child2());
11426     SpeculateCellOperand accessor(this, node-&gt;child3());
11427 
11428     auto operation = node-&gt;op() == PutGetterByVal ? operationPutGetterByVal : operationPutSetterByVal;
11429 
11430     GPRReg baseGPR = base.gpr();
11431     JSValueRegs subscriptRegs = subscript.jsValueRegs();
11432     GPRReg accessorGPR = accessor.gpr();
11433 
11434     flushRegisters();
<span class="line-modified">11435     callOperation(operation, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, subscriptRegs, node-&gt;accessorAttributes(), accessorGPR);</span>
11436     m_jit.exceptionCheck();
11437 
11438     noResult(node);
11439 }
11440 
11441 void SpeculativeJIT::compileGetRegExpObjectLastIndex(Node* node)
11442 {
11443     SpeculateCellOperand regExp(this, node-&gt;child1());
11444     JSValueRegsTemporary result(this);
11445     GPRReg regExpGPR = regExp.gpr();
11446     JSValueRegs resultRegs = result.regs();
11447     speculateRegExpObject(node-&gt;child1(), regExpGPR);
11448     m_jit.loadValue(JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()), resultRegs);
11449     jsValueResult(resultRegs, node);
11450 }
11451 
11452 void SpeculativeJIT::compileSetRegExpObjectLastIndex(Node* node)
11453 {
11454     SpeculateCellOperand regExp(this, node-&gt;child1());
11455     JSValueOperand value(this, node-&gt;child2());
</pre>
<hr />
<pre>
11592 {
11593     ASSERT(node-&gt;op() == StringReplace || node-&gt;op() == StringReplaceRegExp);
11594     bool sample = false;
11595     if (sample)
11596         m_jit.incrementSuperSamplerCount();
11597 
11598     if (node-&gt;child1().useKind() == StringUse
11599         &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
11600         &amp;&amp; node-&gt;child3().useKind() == StringUse) {
11601         if (JSString* replace = node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
11602             if (!replace-&gt;length()) {
11603                 SpeculateCellOperand string(this, node-&gt;child1());
11604                 SpeculateCellOperand regExp(this, node-&gt;child2());
11605                 GPRReg stringGPR = string.gpr();
11606                 GPRReg regExpGPR = regExp.gpr();
11607                 speculateString(node-&gt;child1(), stringGPR);
11608                 speculateRegExpObject(node-&gt;child2(), regExpGPR);
11609 
11610                 flushRegisters();
11611                 GPRFlushedCallResult result(this);
<span class="line-modified">11612                 callOperation(operationStringProtoFuncReplaceRegExpEmptyStr, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, regExpGPR);</span>
11613                 m_jit.exceptionCheck();
11614                 cellResult(result.gpr(), node);
11615                 if (sample)
11616                     m_jit.decrementSuperSamplerCount();
11617                 return;
11618             }
11619         }
11620 
11621         SpeculateCellOperand string(this, node-&gt;child1());
11622         SpeculateCellOperand regExp(this, node-&gt;child2());
11623         SpeculateCellOperand replace(this, node-&gt;child3());
11624         GPRReg stringGPR = string.gpr();
11625         GPRReg regExpGPR = regExp.gpr();
11626         GPRReg replaceGPR = replace.gpr();
11627         speculateString(node-&gt;child1(), stringGPR);
11628         speculateRegExpObject(node-&gt;child2(), regExpGPR);
11629         speculateString(node-&gt;child3(), replaceGPR);
11630 
11631         flushRegisters();
11632         GPRFlushedCallResult result(this);
<span class="line-modified">11633         callOperation(operationStringProtoFuncReplaceRegExpString, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, regExpGPR, replaceGPR);</span>
11634         m_jit.exceptionCheck();
11635         cellResult(result.gpr(), node);
11636         if (sample)
11637             m_jit.decrementSuperSamplerCount();
11638         return;
11639     }
11640 
11641     // If we fixed up the edge of child2, we inserted a Check(@child2, String).
11642     OperandSpeculationMode child2SpeculationMode = AutomaticOperandSpeculation;
11643     if (node-&gt;child2().useKind() == StringUse)
11644         child2SpeculationMode = ManualOperandSpeculation;
11645 
11646     JSValueOperand string(this, node-&gt;child1());
11647     JSValueOperand search(this, node-&gt;child2(), child2SpeculationMode);
11648     JSValueOperand replace(this, node-&gt;child3());
11649     JSValueRegs stringRegs = string.jsValueRegs();
11650     JSValueRegs searchRegs = search.jsValueRegs();
11651     JSValueRegs replaceRegs = replace.jsValueRegs();
11652 
11653     flushRegisters();
11654     GPRFlushedCallResult result(this);
<span class="line-modified">11655     callOperation(operationStringProtoFuncReplaceGeneric, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringRegs, searchRegs, replaceRegs);</span>
11656     m_jit.exceptionCheck();
11657     cellResult(result.gpr(), node);
11658     if (sample)
11659         m_jit.decrementSuperSamplerCount();
11660 }
11661 
11662 void SpeculativeJIT::compileRegExpExecNonGlobalOrSticky(Node* node)
11663 {
11664     SpeculateCellOperand globalObject(this, node-&gt;child1());
11665     SpeculateCellOperand argument(this, node-&gt;child2());
11666     GPRReg globalObjectGPR = globalObject.gpr();
11667     GPRReg argumentGPR = argument.gpr();
11668 
11669     speculateString(node-&gt;child2(), argumentGPR);
11670 
11671     flushRegisters();
11672     JSValueRegsFlushedCallResult result(this);
11673     JSValueRegs resultRegs = result.regs();
11674     callOperation(
11675         operationRegExpExecNonGlobalOrSticky, resultRegs,
</pre>
<hr />
<pre>
11858 
11859     SpeculateCellOperand base(this, m_jit.graph().varArgChild(node, 0));
11860     GPRReg baseGPR = base.gpr();
11861 
11862     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
11863     JSValueRegs valueRegs = value.jsValueRegs();
11864 
11865     SpeculateInt32Operand attributes(this, m_jit.graph().varArgChild(node, 3));
11866     GPRReg attributesGPR = attributes.gpr();
11867 
11868     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
11869     switch (propertyEdge.useKind()) {
11870     case StringUse: {
11871         SpeculateCellOperand property(this, propertyEdge);
11872         GPRReg propertyGPR = property.gpr();
11873         speculateString(propertyEdge, propertyGPR);
11874 
11875         useChildren(node);
11876 
11877         flushRegisters();
<span class="line-modified">11878         callOperation(operationDefineDataPropertyString, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR, valueRegs, attributesGPR);</span>
11879         m_jit.exceptionCheck();
11880         break;
11881     }
11882     case StringIdentUse: {
11883         SpeculateCellOperand property(this, propertyEdge);
11884         GPRTemporary ident(this);
11885 
11886         GPRReg propertyGPR = property.gpr();
11887         GPRReg identGPR = ident.gpr();
11888 
11889         speculateString(propertyEdge, propertyGPR);
11890         speculateStringIdentAndLoadStorage(propertyEdge, propertyGPR, identGPR);
11891 
11892         useChildren(node);
11893 
11894         flushRegisters();
<span class="line-modified">11895         callOperation(operationDefineDataPropertyStringIdent, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identGPR, valueRegs, attributesGPR);</span>
11896         m_jit.exceptionCheck();
11897         break;
11898     }
11899     case SymbolUse: {
11900         SpeculateCellOperand property(this, propertyEdge);
11901         GPRReg propertyGPR = property.gpr();
11902         speculateSymbol(propertyEdge, propertyGPR);
11903 
11904         useChildren(node);
11905 
11906         flushRegisters();
<span class="line-modified">11907         callOperation(operationDefineDataPropertySymbol, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR, valueRegs, attributesGPR);</span>
11908         m_jit.exceptionCheck();
11909         break;
11910     }
11911     case UntypedUse: {
11912         JSValueOperand property(this, propertyEdge);
11913         JSValueRegs propertyRegs = property.jsValueRegs();
11914 
11915         useChildren(node);
11916 
11917         flushRegisters();
<span class="line-modified">11918         callOperation(operationDefineDataProperty, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs, valueRegs, attributesGPR);</span>
11919         m_jit.exceptionCheck();
11920         break;
11921     }
11922     default:
11923         RELEASE_ASSERT_NOT_REACHED();
11924     }
11925 
11926     noResult(node, UseChildrenCalledExplicitly);
11927 }
11928 
11929 void SpeculativeJIT::compileDefineAccessorProperty(Node* node)
11930 {
11931 #if USE(JSVALUE64)
11932     static_assert(GPRInfo::numberOfRegisters &gt;= 5, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11933 #else
11934     static_assert(GPRInfo::numberOfRegisters &gt;= 6, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11935 #endif
11936 
11937     SpeculateCellOperand base(this, m_jit.graph().varArgChild(node, 0));
11938     GPRReg baseGPR = base.gpr();
11939 
11940     SpeculateCellOperand getter(this, m_jit.graph().varArgChild(node, 2));
11941     GPRReg getterGPR = getter.gpr();
11942 
11943     SpeculateCellOperand setter(this, m_jit.graph().varArgChild(node, 3));
11944     GPRReg setterGPR = setter.gpr();
11945 
11946     SpeculateInt32Operand attributes(this, m_jit.graph().varArgChild(node, 4));
11947     GPRReg attributesGPR = attributes.gpr();
11948 
11949     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
11950     switch (propertyEdge.useKind()) {
11951     case StringUse: {
11952         SpeculateCellOperand property(this, propertyEdge);
11953         GPRReg propertyGPR = property.gpr();
11954         speculateString(propertyEdge, propertyGPR);
11955 
11956         useChildren(node);
11957 
11958         flushRegisters();
<span class="line-modified">11959         callOperation(operationDefineAccessorPropertyString, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);</span>
11960         m_jit.exceptionCheck();
11961         break;
11962     }
11963     case StringIdentUse: {
11964         SpeculateCellOperand property(this, propertyEdge);
11965         GPRTemporary ident(this);
11966 
11967         GPRReg propertyGPR = property.gpr();
11968         GPRReg identGPR = ident.gpr();
11969 
11970         speculateString(propertyEdge, propertyGPR);
11971         speculateStringIdentAndLoadStorage(propertyEdge, propertyGPR, identGPR);
11972 
11973         useChildren(node);
11974 
11975         flushRegisters();
<span class="line-modified">11976         callOperation(operationDefineAccessorPropertyStringIdent, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identGPR, getterGPR, setterGPR, attributesGPR);</span>
11977         m_jit.exceptionCheck();
11978         break;
11979     }
11980     case SymbolUse: {
11981         SpeculateCellOperand property(this, propertyEdge);
11982         GPRReg propertyGPR = property.gpr();
11983         speculateSymbol(propertyEdge, propertyGPR);
11984 
11985         useChildren(node);
11986 
11987         flushRegisters();
<span class="line-modified">11988         callOperation(operationDefineAccessorPropertySymbol, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);</span>
11989         m_jit.exceptionCheck();
11990         break;
11991     }
11992     case UntypedUse: {
11993         JSValueOperand property(this, propertyEdge);
11994         JSValueRegs propertyRegs = property.jsValueRegs();
11995 
11996         useChildren(node);
11997 
11998         flushRegisters();
<span class="line-modified">11999         callOperation(operationDefineAccessorProperty, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs, getterGPR, setterGPR, attributesGPR);</span>
12000         m_jit.exceptionCheck();
12001         break;
12002     }
12003     default:
12004         RELEASE_ASSERT_NOT_REACHED();
12005     }
12006 
12007     noResult(node, UseChildrenCalledExplicitly);
12008 }
12009 
12010 void SpeculativeJIT::emitAllocateButterfly(GPRReg storageResultGPR, GPRReg sizeGPR, GPRReg scratch1, GPRReg scratch2, GPRReg scratch3, MacroAssembler::JumpList&amp; slowCases)
12011 {
12012     RELEASE_ASSERT(RegisterSet(storageResultGPR, sizeGPR, scratch1, scratch2, scratch3).numberOfSetGPRs() == 5);
12013     ASSERT((1 &lt;&lt; 3) == sizeof(JSValue));
12014     m_jit.zeroExtend32ToPtr(sizeGPR, scratch1);
12015     m_jit.lshift32(TrustedImm32(3), scratch1);
12016     m_jit.add32(TrustedImm32(sizeof(IndexingHeader)), scratch1, scratch2);
<span class="line-modified">12017 #if ASSERT_ENABLED</span>
12018     MacroAssembler::Jump didNotOverflow = m_jit.branch32(MacroAssembler::AboveOrEqual, scratch2, sizeGPR);
12019     m_jit.abortWithReason(UncheckedOverflow);
12020     didNotOverflow.link(&amp;m_jit);
12021 #endif
12022     m_jit.emitAllocateVariableSized(
12023         storageResultGPR, vm().jsValueGigacageAuxiliarySpace, scratch2, scratch1, scratch3, slowCases);
12024     m_jit.addPtr(TrustedImm32(sizeof(IndexingHeader)), storageResultGPR);
12025 
12026     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfPublicLength()));
12027     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfVectorLength()));
12028 }
12029 
12030 void SpeculativeJIT::compileNormalizeMapKey(Node* node)
12031 {
12032     ASSERT(node-&gt;child1().useKind() == UntypedUse);
12033     JSValueOperand key(this, node-&gt;child1());
12034     JSValueRegsTemporary result(this, Reuse, key);
12035     GPRTemporary scratch(this);
12036     FPRTemporary doubleValue(this);
12037     FPRTemporary temp(this);
</pre>
<hr />
<pre>
12167     done.link(&amp;m_jit);
12168 #else
12169     auto isEmpty = m_jit.branchIfEmpty(valueRegs.tagGPR());
12170     m_jit.moveValueRegs(valueRegs, resultRegs);
12171     auto done = m_jit.jump();
12172 
12173     isEmpty.link(&amp;m_jit);
12174     m_jit.moveValue(jsUndefined(), resultRegs);
12175 
12176     done.link(&amp;m_jit);
12177 #endif
12178 
12179     jsValueResult(resultRegs, node, DataFormatJS);
12180 }
12181 
12182 void SpeculativeJIT::compileThrow(Node* node)
12183 {
12184     JSValueOperand value(this, node-&gt;child1());
12185     JSValueRegs valueRegs = value.jsValueRegs();
12186     flushRegisters();
<span class="line-modified">12187     callOperation(operationThrowDFG, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs);</span>
12188     m_jit.exceptionCheck();
12189     m_jit.breakpoint();
12190     noResult(node);
12191 }
12192 
12193 void SpeculativeJIT::compileThrowStaticError(Node* node)
12194 {
12195     SpeculateCellOperand message(this, node-&gt;child1());
12196     GPRReg messageGPR = message.gpr();
12197     speculateString(node-&gt;child1(), messageGPR);
12198     flushRegisters();
<span class="line-modified">12199     callOperation(operationThrowStaticError, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), messageGPR, node-&gt;errorType());</span>
12200     m_jit.exceptionCheck();
12201     m_jit.breakpoint();
12202     noResult(node);
12203 }
12204 
12205 void SpeculativeJIT::compileGetEnumerableLength(Node* node)
12206 {
12207     SpeculateCellOperand enumerator(this, node-&gt;child1());
12208     GPRFlushedCallResult result(this);
12209     GPRReg resultGPR = result.gpr();
12210 
12211     m_jit.load32(MacroAssembler::Address(enumerator.gpr(), JSPropertyNameEnumerator::indexedLengthOffset()), resultGPR);
12212     int32Result(resultGPR, node);
12213 }
12214 
12215 void SpeculativeJIT::compileHasGenericProperty(Node* node)
12216 {
12217     JSValueOperand base(this, node-&gt;child1());
12218     SpeculateCellOperand property(this, node-&gt;child2());
12219 
12220     JSValueRegs baseRegs = base.jsValueRegs();
12221     GPRReg propertyGPR = property.gpr();
12222 
12223     flushRegisters();
12224     JSValueRegsFlushedCallResult result(this);
12225     JSValueRegs resultRegs = result.regs();
<span class="line-modified">12226     callOperation(operationHasGenericProperty, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, propertyGPR);</span>
12227     m_jit.exceptionCheck();
12228     blessedBooleanResult(resultRegs.payloadGPR(), node);
12229 }
12230 
12231 void SpeculativeJIT::compileToIndexString(Node* node)
12232 {
12233     SpeculateInt32Operand index(this, node-&gt;child1());
12234     GPRReg indexGPR = index.gpr();
12235 
12236     flushRegisters();
12237     GPRFlushedCallResult result(this);
12238     GPRReg resultGPR = result.gpr();
<span class="line-modified">12239     callOperation(operationToIndexString, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), indexGPR);</span>
12240     m_jit.exceptionCheck();
12241     cellResult(resultGPR, node);
12242 }
12243 
12244 void SpeculativeJIT::compilePutByIdFlush(Node* node)
12245 {
12246     SpeculateCellOperand base(this, node-&gt;child1());
12247     JSValueOperand value(this, node-&gt;child2());
12248     GPRTemporary scratch(this);
12249 
12250     GPRReg baseGPR = base.gpr();
12251     JSValueRegs valueRegs = value.jsValueRegs();
12252     GPRReg scratchGPR = scratch.gpr();
12253     flushRegisters();
12254 
12255     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), NotDirect, MacroAssembler::Jump(), DontSpill);
12256 
12257     noResult(node);
12258 }
12259 
</pre>
<hr />
<pre>
12281     GPRReg baseGPR = base.gpr();
12282     JSValueRegs valueRegs = value.jsValueRegs();
12283     GPRReg scratchGPR = scratch.gpr();
12284 
12285     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), Direct);
12286 
12287     noResult(node);
12288 }
12289 
12290 void SpeculativeJIT::compilePutByIdWithThis(Node* node)
12291 {
12292     JSValueOperand base(this, node-&gt;child1());
12293     JSValueRegs baseRegs = base.jsValueRegs();
12294     JSValueOperand thisValue(this, node-&gt;child2());
12295     JSValueRegs thisRegs = thisValue.jsValueRegs();
12296     JSValueOperand value(this, node-&gt;child3());
12297     JSValueRegs valueRegs = value.jsValueRegs();
12298 
12299     flushRegisters();
12300     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByIdWithThisStrict : operationPutByIdWithThis,
<span class="line-modified">12301         TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, thisRegs, valueRegs, identifierUID(node-&gt;identifierNumber()));</span>
12302     m_jit.exceptionCheck();
12303 
12304     noResult(node);
12305 }
12306 
12307 void SpeculativeJIT::compileGetByOffset(Node* node)
12308 {
12309     StorageOperand storage(this, node-&gt;child1());
12310     JSValueRegsTemporary result(this, Reuse, storage);
12311 
12312     GPRReg storageGPR = storage.gpr();
12313     JSValueRegs resultRegs = result.regs();
12314 
12315     StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
12316 
12317     m_jit.loadValue(JITCompiler::Address(storageGPR, offsetRelativeToBase(storageAccessData.offset)), resultRegs);
12318 
12319     jsValueResult(resultRegs, node);
12320 }
12321 
</pre>
<hr />
<pre>
12371     JSValueRegsTemporary result(this);
12372 
12373     JSValueRegs baseRegs = base.jsValueRegs();
12374     GPRReg propertyGPR = property.gpr();
12375     JSValueRegs resultRegs = result.regs();
12376 
12377     CCallHelpers::JumpList wrongStructure;
12378 
12379     wrongStructure.append(m_jit.branchIfNotCell(baseRegs));
12380 
12381     m_jit.load32(MacroAssembler::Address(baseRegs.payloadGPR(), JSCell::structureIDOffset()), resultRegs.payloadGPR());
12382     wrongStructure.append(m_jit.branch32(MacroAssembler::NotEqual,
12383         resultRegs.payloadGPR(),
12384         MacroAssembler::Address(enumerator.gpr(), JSPropertyNameEnumerator::cachedStructureIDOffset())));
12385 
12386     moveTrueTo(resultRegs.payloadGPR());
12387     MacroAssembler::Jump done = m_jit.jump();
12388 
12389     done.link(&amp;m_jit);
12390 
<span class="line-modified">12391     addSlowPathGenerator(slowPathCall(wrongStructure, this, operationHasGenericProperty, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, propertyGPR));</span>
12392     blessedBooleanResult(resultRegs.payloadGPR(), node);
12393 }
12394 
12395 void SpeculativeJIT::compileGetPropertyEnumerator(Node* node)
12396 {
12397     if (node-&gt;child1().useKind() == CellUse) {
12398         SpeculateCellOperand base(this, node-&gt;child1());
12399         GPRReg baseGPR = base.gpr();
12400 
12401         flushRegisters();
12402         GPRFlushedCallResult result(this);
12403         GPRReg resultGPR = result.gpr();
<span class="line-modified">12404         callOperation(operationGetPropertyEnumeratorCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR);</span>
12405         m_jit.exceptionCheck();
12406         cellResult(resultGPR, node);
12407         return;
12408     }
12409 
12410     JSValueOperand base(this, node-&gt;child1());
12411     JSValueRegs baseRegs = base.jsValueRegs();
12412 
12413     flushRegisters();
12414     GPRFlushedCallResult result(this);
12415     GPRReg resultGPR = result.gpr();
<span class="line-modified">12416     callOperation(operationGetPropertyEnumerator, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs);</span>
12417     m_jit.exceptionCheck();
12418     cellResult(resultGPR, node);
12419 }
12420 
12421 void SpeculativeJIT::compileGetEnumeratorPname(Node* node)
12422 {
12423     ASSERT(node-&gt;op() == GetEnumeratorStructurePname || node-&gt;op() == GetEnumeratorGenericPname);
12424     SpeculateCellOperand enumerator(this, node-&gt;child1());
12425     SpeculateStrictInt32Operand index(this, node-&gt;child2());
12426     GPRTemporary scratch(this);
12427     JSValueRegsTemporary result(this);
12428 
12429     GPRReg enumeratorGPR = enumerator.gpr();
12430     GPRReg indexGPR = index.gpr();
12431     GPRReg scratchGPR = scratch.gpr();
12432     JSValueRegs resultRegs = result.regs();
12433 
12434     MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, indexGPR,
12435         MacroAssembler::Address(enumeratorGPR, (node-&gt;op() == GetEnumeratorStructurePname)
12436             ? JSPropertyNameEnumerator::endStructurePropertyIndexOffset()
</pre>
<hr />
<pre>
12441     MacroAssembler::Jump done = m_jit.jump();
12442     inBounds.link(&amp;m_jit);
12443 
12444     m_jit.loadPtr(MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedPropertyNamesVectorOffset()), scratchGPR);
12445     m_jit.loadPtr(MacroAssembler::BaseIndex(scratchGPR, indexGPR, MacroAssembler::ScalePtr), resultRegs.payloadGPR());
12446 #if USE(JSVALUE32_64)
12447     m_jit.move(MacroAssembler::TrustedImm32(JSValue::CellTag), resultRegs.tagGPR());
12448 #endif
12449 
12450     done.link(&amp;m_jit);
12451     jsValueResult(resultRegs, node);
12452 }
12453 
12454 void SpeculativeJIT::compileGetExecutable(Node* node)
12455 {
12456     SpeculateCellOperand function(this, node-&gt;child1());
12457     GPRTemporary result(this, Reuse, function);
12458     GPRReg functionGPR = function.gpr();
12459     GPRReg resultGPR = result.gpr();
12460     speculateCellType(node-&gt;child1(), functionGPR, SpecFunction, JSFunctionType);
<span class="line-modified">12461     m_jit.loadPtr(JITCompiler::Address(functionGPR, JSFunction::offsetOfExecutableOrRareData()), resultGPR);</span>
<span class="line-added">12462     auto hasExecutable = m_jit.branchTestPtr(CCallHelpers::Zero, resultGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag));</span>
<span class="line-added">12463     m_jit.loadPtr(CCallHelpers::Address(resultGPR, FunctionRareData::offsetOfExecutable() - JSFunction::rareDataTag), resultGPR);</span>
<span class="line-added">12464     hasExecutable.link(&amp;m_jit);</span>
12465     cellResult(resultGPR, node);
12466 }
12467 
12468 void SpeculativeJIT::compileGetGetter(Node* node)
12469 {
12470     SpeculateCellOperand op1(this, node-&gt;child1());
12471     GPRTemporary result(this, Reuse, op1);
12472 
12473     GPRReg op1GPR = op1.gpr();
12474     GPRReg resultGPR = result.gpr();
12475 
12476     m_jit.loadPtr(JITCompiler::Address(op1GPR, GetterSetter::offsetOfGetter()), resultGPR);
12477 
12478     cellResult(resultGPR, node);
12479 }
12480 
12481 void SpeculativeJIT::compileGetSetter(Node* node)
12482 {
12483     SpeculateCellOperand op1(this, node-&gt;child1());
12484     GPRTemporary result(this, Reuse, op1);
</pre>
<hr />
<pre>
12495 {
12496     GPRTemporary result(this);
12497     m_jit.loadPtr(JITCompiler::payloadFor(CallFrameSlot::callee), result.gpr());
12498     cellResult(result.gpr(), node);
12499 }
12500 
12501 void SpeculativeJIT::compileSetCallee(Node* node)
12502 {
12503     SpeculateCellOperand callee(this, node-&gt;child1());
12504     m_jit.storeCell(callee.gpr(), JITCompiler::payloadFor(CallFrameSlot::callee));
12505     noResult(node);
12506 }
12507 
12508 void SpeculativeJIT::compileGetArgumentCountIncludingThis(Node* node)
12509 {
12510     GPRTemporary result(this);
12511     VirtualRegister argumentCountRegister;
12512     if (InlineCallFrame* inlineCallFrame = node-&gt;argumentsInlineCallFrame())
12513         argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
12514     else
<span class="line-modified">12515         argumentCountRegister = CallFrameSlot::argumentCountIncludingThis;</span>
12516     m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), result.gpr());
12517     int32Result(result.gpr(), node);
12518 }
12519 
12520 void SpeculativeJIT::compileSetArgumentCountIncludingThis(Node* node)
12521 {
<span class="line-modified">12522     m_jit.store32(TrustedImm32(node-&gt;argumentCountIncludingThis()), JITCompiler::payloadFor(CallFrameSlot::argumentCountIncludingThis));</span>
12523     noResult(node);
12524 }
12525 
12526 void SpeculativeJIT::compileStrCat(Node* node)
12527 {
12528     JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
12529     JSValueOperand op2(this, node-&gt;child2(), ManualOperandSpeculation);
12530     JSValueOperand op3(this, node-&gt;child3(), ManualOperandSpeculation);
12531 
12532     JSValueRegs op1Regs = op1.jsValueRegs();
12533     JSValueRegs op2Regs = op2.jsValueRegs();
12534     JSValueRegs op3Regs;
12535 
12536     if (node-&gt;child3())
12537         op3Regs = op3.jsValueRegs();
12538 
12539     flushRegisters();
12540 
12541     GPRFlushedCallResult result(this);
12542     if (node-&gt;child3())
<span class="line-modified">12543         callOperation(operationStrCat3, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs, op2Regs, op3Regs);</span>
12544     else
<span class="line-modified">12545         callOperation(operationStrCat2, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs, op2Regs);</span>
12546     m_jit.exceptionCheck();
12547 
12548     cellResult(result.gpr(), node);
12549 }
12550 
12551 void SpeculativeJIT::compileNewArrayBuffer(Node* node)
12552 {
12553     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12554     auto* array = node-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
12555 
12556     IndexingType indexingMode = node-&gt;indexingMode();
12557     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode));
12558 
12559     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(indexingMode)) {
12560         GPRTemporary result(this);
12561         GPRTemporary scratch1(this);
12562         GPRTemporary scratch2(this);
12563 
12564         GPRReg resultGPR = result.gpr();
12565         GPRReg scratch1GPR = scratch1.gpr();
12566         GPRReg scratch2GPR = scratch2.gpr();
12567 
12568         MacroAssembler::JumpList slowCases;
12569 
12570         emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), TrustedImmPtr(array-&gt;toButterfly()), scratch1GPR, scratch2GPR, slowCases);
12571 
<span class="line-modified">12572         addSlowPathGenerator(slowPathCall(slowCases, this, operationNewArrayBuffer, result.gpr(), &amp;vm(), structure, array));</span>
12573 
12574         DFG_ASSERT(m_jit.graph(), node, indexingMode &amp; IsArray, indexingMode);
12575         cellResult(resultGPR, node);
12576         return;
12577     }
12578 
12579     flushRegisters();
12580     GPRFlushedCallResult result(this);
12581 
<span class="line-modified">12582     callOperation(operationNewArrayBuffer, result.gpr(), &amp;vm(), structure, TrustedImmPtr(node-&gt;cellOperand()));</span>
12583     m_jit.exceptionCheck();
12584 
12585     cellResult(result.gpr(), node);
12586 }
12587 
12588 void SpeculativeJIT::compileNewArrayWithSize(Node* node)
12589 {
12590     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12591     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingType())) {
12592         SpeculateStrictInt32Operand size(this, node-&gt;child1());
12593         GPRTemporary result(this);
12594 
12595         GPRReg sizeGPR = size.gpr();
12596         GPRReg resultGPR = result.gpr();
12597 
12598         compileAllocateNewArrayWithSize(globalObject, resultGPR, sizeGPR, node-&gt;indexingType());
12599         cellResult(resultGPR, node);
12600         return;
12601     }
12602 
12603     SpeculateStrictInt32Operand size(this, node-&gt;child1());
12604     GPRReg sizeGPR = size.gpr();
12605     flushRegisters();
12606     GPRFlushedCallResult result(this);
12607     GPRReg resultGPR = result.gpr();
12608     GPRReg structureGPR = AssemblyHelpers::selectScratchGPR(sizeGPR);
12609     MacroAssembler::Jump bigLength = m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
12610     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()))), structureGPR);
12611     MacroAssembler::Jump done = m_jit.jump();
12612     bigLength.link(&amp;m_jit);
12613     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))), structureGPR);
12614     done.link(&amp;m_jit);
<span class="line-modified">12615     callOperation(operationNewArrayWithSize, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), structureGPR, sizeGPR, nullptr);</span>
12616     m_jit.exceptionCheck();
12617     cellResult(resultGPR, node);
12618 }
12619 
12620 void SpeculativeJIT::compileNewTypedArray(Node* node)
12621 {
12622     switch (node-&gt;child1().useKind()) {
12623     case Int32Use:
12624         compileNewTypedArrayWithSize(node);
12625         break;
12626     case UntypedUse: {
12627         JSValueOperand argument(this, node-&gt;child1());
12628         JSValueRegs argumentRegs = argument.jsValueRegs();
12629 
12630         flushRegisters();
12631 
12632         GPRFlushedCallResult result(this);
12633         GPRReg resultGPR = result.gpr();
12634 
12635         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12636         callOperation(
12637             operationNewTypedArrayWithOneArgumentForType(node-&gt;typedArrayType()),
<span class="line-modified">12638             resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), m_jit.graph().registerStructure(globalObject-&gt;typedArrayStructureConcurrently(node-&gt;typedArrayType())), argumentRegs);</span>
12639         m_jit.exceptionCheck();
12640 
12641         cellResult(resultGPR, node);
12642         break;
12643     }
12644     default:
12645         RELEASE_ASSERT_NOT_REACHED();
12646         break;
12647     }
12648 }
12649 
12650 void SpeculativeJIT::compileToThis(Node* node)
12651 {
12652     ASSERT(node-&gt;child1().useKind() == UntypedUse);
12653     JSValueOperand thisValue(this, node-&gt;child1());
12654     JSValueRegsTemporary temp(this);
12655 
12656     JSValueRegs thisValueRegs = thisValue.jsValueRegs();
12657     JSValueRegs tempRegs = temp.regs();
12658 
12659     MacroAssembler::JumpList slowCases;
12660     slowCases.append(m_jit.branchIfNotCell(thisValueRegs));
12661     slowCases.append(
12662         m_jit.branchTest8(
12663             MacroAssembler::NonZero,
12664             MacroAssembler::Address(thisValueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
12665             MacroAssembler::TrustedImm32(OverridesToThis)));
12666     m_jit.moveValueRegs(thisValueRegs, tempRegs);
12667 
<span class="line-modified">12668     J_JITOperation_GJ function;</span>
12669     if (m_jit.isStrictModeFor(node-&gt;origin.semantic))
12670         function = operationToThisStrict;
12671     else
12672         function = operationToThis;
<span class="line-modified">12673     addSlowPathGenerator(slowPathCall(slowCases, this, function, tempRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), thisValueRegs));</span>
12674 
12675     jsValueResult(tempRegs, node);
12676 }
12677 
12678 void SpeculativeJIT::compileObjectKeys(Node* node)
12679 {
12680     switch (node-&gt;child1().useKind()) {
12681     case ObjectUse: {
12682         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
12683             SpeculateCellOperand object(this, node-&gt;child1());
12684             GPRTemporary structure(this);
12685             GPRTemporary scratch(this);
12686             GPRTemporary scratch2(this);
12687             GPRTemporary scratch3(this);
12688             GPRTemporary result(this);
12689 
12690             GPRReg objectGPR = object.gpr();
12691             GPRReg structureGPR = structure.gpr();
12692             GPRReg scratchGPR = scratch.gpr();
12693             GPRReg scratch2GPR = scratch2.gpr();
</pre>
<hr />
<pre>
12697             speculateObject(node-&gt;child1(), objectGPR);
12698 
12699             CCallHelpers::JumpList slowCases;
12700             m_jit.emitLoadStructure(vm(), objectGPR, structureGPR, scratchGPR);
12701             m_jit.loadPtr(CCallHelpers::Address(structureGPR, Structure::previousOrRareDataOffset()), scratchGPR);
12702 
12703             slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, scratchGPR));
12704             slowCases.append(m_jit.branch32(CCallHelpers::Equal, CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()), TrustedImm32(bitwise_cast&lt;int32_t&gt;(vm().structureStructure-&gt;structureID()))));
12705 
12706             m_jit.loadPtr(CCallHelpers::Address(scratchGPR, StructureRareData::offsetOfCachedOwnKeys()), scratchGPR);
12707 
12708             ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
12709             slowCases.append(m_jit.branchPtr(CCallHelpers::BelowOrEqual, scratchGPR, TrustedImmPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))));
12710 
12711             MacroAssembler::JumpList slowButArrayBufferCases;
12712 
12713             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12714             RegisteredStructure arrayStructure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
12715 
12716             m_jit.move(scratchGPR, scratch3GPR);
<span class="line-modified">12717             m_jit.addPtr(TrustedImm32(JSImmutableButterfly::offsetOfData()), scratchGPR);</span>
12718 
12719             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(arrayStructure), scratchGPR, structureGPR, scratch2GPR, slowButArrayBufferCases);
12720 
<span class="line-modified">12721             addSlowPathGenerator(slowPathCall(slowButArrayBufferCases, this, operationNewArrayBuffer, resultGPR, &amp;vm(), arrayStructure, scratch3GPR));</span>
12722 
<span class="line-modified">12723             addSlowPathGenerator(slowPathCall(slowCases, this, operationObjectKeysObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectGPR));</span>
12724 
12725             cellResult(resultGPR, node);
12726             break;
12727         }
12728 
12729         SpeculateCellOperand object(this, node-&gt;child1());
12730 
12731         GPRReg objectGPR = object.gpr();
12732 
12733         speculateObject(node-&gt;child1(), objectGPR);
12734 
12735         flushRegisters();
12736         GPRFlushedCallResult result(this);
12737         GPRReg resultGPR = result.gpr();
<span class="line-modified">12738         callOperation(operationObjectKeysObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectGPR);</span>
12739         m_jit.exceptionCheck();
12740 
12741         cellResult(resultGPR, node);
12742         break;
12743     }
12744 
12745     case UntypedUse: {
12746         JSValueOperand object(this, node-&gt;child1());
12747 
12748         JSValueRegs objectRegs = object.jsValueRegs();
12749 
12750         flushRegisters();
12751         GPRFlushedCallResult result(this);
12752         GPRReg resultGPR = result.gpr();
<span class="line-modified">12753         callOperation(operationObjectKeys, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectRegs);</span>
12754         m_jit.exceptionCheck();
12755 
12756         cellResult(resultGPR, node);
12757         break;
12758     }
12759 
12760     default:
12761         RELEASE_ASSERT_NOT_REACHED();
12762         break;
12763     }
12764 }
12765 
12766 void SpeculativeJIT::compileObjectCreate(Node* node)
12767 {
12768     switch (node-&gt;child1().useKind()) {
12769     case ObjectUse: {
12770         SpeculateCellOperand prototype(this, node-&gt;child1());
12771 
12772         GPRReg prototypeGPR = prototype.gpr();
12773 
12774         speculateObject(node-&gt;child1(), prototypeGPR);
12775 
12776         flushRegisters();
12777         GPRFlushedCallResult result(this);
12778         GPRReg resultGPR = result.gpr();
<span class="line-modified">12779         callOperation(operationObjectCreateObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), prototypeGPR);</span>
12780         m_jit.exceptionCheck();
12781 
12782         cellResult(resultGPR, node);
12783         break;
12784     }
12785 
12786     case UntypedUse: {
12787         JSValueOperand prototype(this, node-&gt;child1());
12788 
12789         JSValueRegs prototypeRegs = prototype.jsValueRegs();
12790 
12791         flushRegisters();
12792         GPRFlushedCallResult result(this);
12793         GPRReg resultGPR = result.gpr();
<span class="line-modified">12794         callOperation(operationObjectCreate, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), prototypeRegs);</span>
12795         m_jit.exceptionCheck();
12796 
12797         cellResult(resultGPR, node);
12798         break;
12799     }
12800 
12801     default:
12802         RELEASE_ASSERT_NOT_REACHED();
12803         break;
12804     }
12805 }
12806 
12807 void SpeculativeJIT::compileCreateThis(Node* node)
12808 {
12809     // Note that there is not so much profit to speculate here. The only things we
12810     // speculate on are (1) that it&#39;s a cell, since that eliminates cell checks
12811     // later if the proto is reused, and (2) if we have a FinalObject prediction
12812     // then we speculate because we want to get recompiled if it isn&#39;t (since
12813     // otherwise we&#39;d start taking slow path a lot).
12814 
12815     SpeculateCellOperand callee(this, node-&gt;child1());
12816     GPRTemporary result(this);
12817     GPRTemporary allocator(this);
12818     GPRTemporary structure(this);
12819     GPRTemporary scratch(this);
12820 
12821     GPRReg calleeGPR = callee.gpr();
12822     GPRReg resultGPR = result.gpr();
12823     GPRReg allocatorGPR = allocator.gpr();
12824     GPRReg structureGPR = structure.gpr();
12825     GPRReg scratchGPR = scratch.gpr();
12826     // Rare data is only used to access the allocator &amp; structure
12827     // We can avoid using an additional GPR this way
12828     GPRReg rareDataGPR = structureGPR;
12829     GPRReg inlineCapacityGPR = rareDataGPR;
12830 
12831     MacroAssembler::JumpList slowPath;
12832 
12833     slowPath.append(m_jit.branchIfNotFunction(calleeGPR));
<span class="line-modified">12834     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfExecutableOrRareData()), rareDataGPR);</span>
<span class="line-modified">12835     slowPath.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag)));</span>
<span class="line-modified">12836     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator() - JSFunction::rareDataTag), allocatorGPR);</span>
<span class="line-modified">12837     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure() - JSFunction::rareDataTag), structureGPR);</span>
12838 
12839     auto butterfly = TrustedImmPtr(nullptr);
12840     emitAllocateJSObject(resultGPR, JITAllocator::variable(), allocatorGPR, structureGPR, butterfly, scratchGPR, slowPath);
12841 
12842     m_jit.load8(JITCompiler::Address(structureGPR, Structure::inlineCapacityOffset()), inlineCapacityGPR);
12843     m_jit.emitInitializeInlineStorage(resultGPR, inlineCapacityGPR);
12844     m_jit.mutatorFence(vm());
12845 
<span class="line-modified">12846     addSlowPathGenerator(slowPathCall(slowPath, this, operationCreateThis, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), calleeGPR, node-&gt;inlineCapacity()));</span>
<span class="line-added">12847 </span>
<span class="line-added">12848     cellResult(resultGPR, node);</span>
<span class="line-added">12849 }</span>
<span class="line-added">12850 </span>
<span class="line-added">12851 void SpeculativeJIT::compileCreatePromise(Node* node)</span>
<span class="line-added">12852 {</span>
<span class="line-added">12853     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added">12854 </span>
<span class="line-added">12855     SpeculateCellOperand callee(this, node-&gt;child1());</span>
<span class="line-added">12856     GPRTemporary result(this);</span>
<span class="line-added">12857     GPRTemporary structure(this);</span>
<span class="line-added">12858     GPRTemporary scratch1(this);</span>
<span class="line-added">12859     GPRTemporary scratch2(this);</span>
<span class="line-added">12860 </span>
<span class="line-added">12861     GPRReg calleeGPR = callee.gpr();</span>
<span class="line-added">12862     GPRReg resultGPR = result.gpr();</span>
<span class="line-added">12863     GPRReg structureGPR = structure.gpr();</span>
<span class="line-added">12864     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="line-added">12865     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="line-added">12866     // Rare data is only used to access the allocator &amp; structure</span>
<span class="line-added">12867     // We can avoid using an additional GPR this way</span>
<span class="line-added">12868     GPRReg rareDataGPR = structureGPR;</span>
<span class="line-added">12869 </span>
<span class="line-added">12870     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure())), structureGPR);</span>
<span class="line-added">12871     auto fastPromisePath = m_jit.branchPtr(CCallHelpers::Equal, calleeGPR, TrustedImmPtr::weakPointer(m_jit.graph(), node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor()));</span>
<span class="line-added">12872 </span>
<span class="line-added">12873     MacroAssembler::JumpList slowCases;</span>
<span class="line-added">12874 </span>
<span class="line-added">12875     slowCases.append(m_jit.branchIfNotFunction(calleeGPR));</span>
<span class="line-added">12876     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfExecutableOrRareData()), rareDataGPR);</span>
<span class="line-added">12877     slowCases.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag)));</span>
<span class="line-added">12878     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfInternalFunctionAllocationProfile() + InternalFunctionAllocationProfile::offsetOfStructure() - JSFunction::rareDataTag), structureGPR);</span>
<span class="line-added">12879     slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, structureGPR));</span>
<span class="line-added">12880     m_jit.move(TrustedImmPtr(node-&gt;isInternalPromise() ? JSInternalPromise::info() : JSPromise::info()), scratch1GPR);</span>
<span class="line-added">12881     slowCases.append(m_jit.branchPtr(CCallHelpers::NotEqual, scratch1GPR, CCallHelpers::Address(structureGPR, Structure::classInfoOffset())));</span>
<span class="line-added">12882     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), globalObject), scratch1GPR);</span>
<span class="line-added">12883     slowCases.append(m_jit.branchPtr(CCallHelpers::NotEqual, scratch1GPR, CCallHelpers::Address(structureGPR, Structure::globalObjectOffset())));</span>
<span class="line-added">12884 </span>
<span class="line-added">12885     fastPromisePath.link(&amp;m_jit);</span>
<span class="line-added">12886     auto butterfly = TrustedImmPtr(nullptr);</span>
<span class="line-added">12887     if (node-&gt;isInternalPromise())</span>
<span class="line-added">12888         emitAllocateJSObjectWithKnownSize&lt;JSInternalPromise&gt;(resultGPR, structureGPR, butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSInternalPromise));</span>
<span class="line-added">12889     else</span>
<span class="line-added">12890         emitAllocateJSObjectWithKnownSize&lt;JSPromise&gt;(resultGPR, structureGPR, butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSPromise));</span>
<span class="line-added">12891     m_jit.storeTrustedValue(jsNumber(static_cast&lt;unsigned&gt;(JSPromise::Status::Pending)), CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(static_cast&lt;unsigned&gt;(JSPromise::Field::Flags))));</span>
<span class="line-added">12892     m_jit.storeTrustedValue(jsUndefined(), CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(static_cast&lt;unsigned&gt;(JSPromise::Field::ReactionsOrResult))));</span>
<span class="line-added">12893     m_jit.mutatorFence(m_jit.vm());</span>
<span class="line-added">12894 </span>
<span class="line-added">12895     addSlowPathGenerator(slowPathCall(slowCases, this, node-&gt;isInternalPromise() ? operationCreateInternalPromise : operationCreatePromise, resultGPR, TrustedImmPtr::weakPointer(m_jit.graph(), globalObject), calleeGPR));</span>
12896 
12897     cellResult(resultGPR, node);
12898 }
12899 
<span class="line-added">12900 </span>
<span class="line-added">12901 template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added">12902 void SpeculativeJIT::compileCreateInternalFieldObject(Node* node, Operation operation)</span>
<span class="line-added">12903 {</span>
<span class="line-added">12904     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added">12905 </span>
<span class="line-added">12906     SpeculateCellOperand callee(this, node-&gt;child1());</span>
<span class="line-added">12907     GPRTemporary result(this);</span>
<span class="line-added">12908     GPRTemporary structure(this);</span>
<span class="line-added">12909     GPRTemporary scratch1(this);</span>
<span class="line-added">12910     GPRTemporary scratch2(this);</span>
<span class="line-added">12911 </span>
<span class="line-added">12912     GPRReg calleeGPR = callee.gpr();</span>
<span class="line-added">12913     GPRReg resultGPR = result.gpr();</span>
<span class="line-added">12914     GPRReg structureGPR = structure.gpr();</span>
<span class="line-added">12915     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="line-added">12916     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="line-added">12917     // Rare data is only used to access the allocator &amp; structure</span>
<span class="line-added">12918     // We can avoid using an additional GPR this way</span>
<span class="line-added">12919     GPRReg rareDataGPR = structureGPR;</span>
<span class="line-added">12920 </span>
<span class="line-added">12921     MacroAssembler::JumpList slowCases;</span>
<span class="line-added">12922 </span>
<span class="line-added">12923     slowCases.append(m_jit.branchIfNotFunction(calleeGPR));</span>
<span class="line-added">12924     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfExecutableOrRareData()), rareDataGPR);</span>
<span class="line-added">12925     slowCases.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag)));</span>
<span class="line-added">12926     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfInternalFunctionAllocationProfile() + InternalFunctionAllocationProfile::offsetOfStructure() - JSFunction::rareDataTag), structureGPR);</span>
<span class="line-added">12927     slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, structureGPR));</span>
<span class="line-added">12928     m_jit.move(TrustedImmPtr(JSClass::info()), scratch1GPR);</span>
<span class="line-added">12929     slowCases.append(m_jit.branchPtr(CCallHelpers::NotEqual, scratch1GPR, CCallHelpers::Address(structureGPR, Structure::classInfoOffset())));</span>
<span class="line-added">12930     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), globalObject), scratch1GPR);</span>
<span class="line-added">12931     slowCases.append(m_jit.branchPtr(CCallHelpers::NotEqual, scratch1GPR, CCallHelpers::Address(structureGPR, Structure::globalObjectOffset())));</span>
<span class="line-added">12932 </span>
<span class="line-added">12933     auto butterfly = TrustedImmPtr(nullptr);</span>
<span class="line-added">12934     emitAllocateJSObjectWithKnownSize&lt;JSClass&gt;(resultGPR, structureGPR, butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSClass));</span>
<span class="line-added">12935     auto initialValues = JSClass::initialValues();</span>
<span class="line-added">12936     ASSERT(initialValues.size() == JSClass::numberOfInternalFields);</span>
<span class="line-added">12937     for (unsigned index = 0; index &lt; initialValues.size(); ++index)</span>
<span class="line-added">12938         m_jit.storeTrustedValue(initialValues[index], CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index)));</span>
<span class="line-added">12939     m_jit.mutatorFence(m_jit.vm());</span>
<span class="line-added">12940 </span>
<span class="line-added">12941     addSlowPathGenerator(slowPathCall(slowCases, this, operation, resultGPR, TrustedImmPtr::weakPointer(m_jit.graph(), globalObject), calleeGPR));</span>
<span class="line-added">12942 </span>
<span class="line-added">12943     cellResult(resultGPR, node);</span>
<span class="line-added">12944 }</span>
<span class="line-added">12945 </span>
<span class="line-added">12946 void SpeculativeJIT::compileCreateGenerator(Node* node)</span>
<span class="line-added">12947 {</span>
<span class="line-added">12948     compileCreateInternalFieldObject&lt;JSGenerator&gt;(node, operationCreateGenerator);</span>
<span class="line-added">12949 }</span>
<span class="line-added">12950 </span>
<span class="line-added">12951 void SpeculativeJIT::compileCreateAsyncGenerator(Node* node)</span>
<span class="line-added">12952 {</span>
<span class="line-added">12953     compileCreateInternalFieldObject&lt;JSAsyncGenerator&gt;(node, operationCreateAsyncGenerator);</span>
<span class="line-added">12954 }</span>
<span class="line-added">12955 </span>
12956 void SpeculativeJIT::compileNewObject(Node* node)
12957 {
12958     GPRTemporary result(this);
12959     GPRTemporary allocator(this);
12960     GPRTemporary scratch(this);
12961 
12962     GPRReg resultGPR = result.gpr();
12963     GPRReg allocatorGPR = allocator.gpr();
12964     GPRReg scratchGPR = scratch.gpr();
12965 
12966     MacroAssembler::JumpList slowPath;
12967 
12968     RegisteredStructure structure = node-&gt;structure();
12969     size_t allocationSize = JSFinalObject::allocationSize(structure-&gt;inlineCapacity());
12970     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm(), allocationSize, AllocatorForMode::AllocatorIfExists);
12971     if (!allocatorValue)
12972         slowPath.append(m_jit.jump());
12973     else {
12974         auto butterfly = TrustedImmPtr(nullptr);
12975         emitAllocateJSObject(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(structure), butterfly, scratchGPR, slowPath);
12976         m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
12977         m_jit.mutatorFence(vm());
12978     }
12979 
<span class="line-modified">12980     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewObject, resultGPR, &amp;vm(), structure));</span>
<span class="line-added">12981 </span>
<span class="line-added">12982     cellResult(resultGPR, node);</span>
<span class="line-added">12983 }</span>
<span class="line-added">12984 </span>
<span class="line-added">12985 void SpeculativeJIT::compileNewPromise(Node* node)</span>
<span class="line-added">12986 {</span>
<span class="line-added">12987     GPRTemporary result(this);</span>
<span class="line-added">12988     GPRTemporary scratch1(this);</span>
<span class="line-added">12989     GPRTemporary scratch2(this);</span>
<span class="line-added">12990 </span>
<span class="line-added">12991     GPRReg resultGPR = result.gpr();</span>
<span class="line-added">12992     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="line-added">12993     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="line-added">12994 </span>
<span class="line-added">12995     MacroAssembler::JumpList slowCases;</span>
<span class="line-added">12996 </span>
<span class="line-added">12997     FrozenValue* structure = m_graph.freezeStrong(node-&gt;structure().get());</span>
<span class="line-added">12998     auto butterfly = TrustedImmPtr(nullptr);</span>
<span class="line-added">12999     if (node-&gt;isInternalPromise())</span>
<span class="line-added">13000         emitAllocateJSObjectWithKnownSize&lt;JSInternalPromise&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSInternalPromise));</span>
<span class="line-added">13001     else</span>
<span class="line-added">13002         emitAllocateJSObjectWithKnownSize&lt;JSPromise&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSPromise));</span>
<span class="line-added">13003     m_jit.storeTrustedValue(jsNumber(static_cast&lt;unsigned&gt;(JSPromise::Status::Pending)), CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(static_cast&lt;unsigned&gt;(JSPromise::Field::Flags))));</span>
<span class="line-added">13004     m_jit.storeTrustedValue(jsUndefined(), CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(static_cast&lt;unsigned&gt;(JSPromise::Field::ReactionsOrResult))));</span>
<span class="line-added">13005     m_jit.mutatorFence(m_jit.vm());</span>
<span class="line-added">13006 </span>
<span class="line-added">13007     addSlowPathGenerator(slowPathCall(slowCases, this, node-&gt;isInternalPromise() ? operationNewInternalPromise : operationNewPromise, resultGPR, TrustedImmPtr(&amp;vm()), TrustedImmPtr(structure)));</span>
13008 
13009     cellResult(resultGPR, node);
13010 }
13011 
<span class="line-added">13012 template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added">13013 void SpeculativeJIT::compileNewInternalFieldObject(Node* node, Operation operation)</span>
<span class="line-added">13014 {</span>
<span class="line-added">13015     GPRTemporary result(this);</span>
<span class="line-added">13016     GPRTemporary scratch1(this);</span>
<span class="line-added">13017     GPRTemporary scratch2(this);</span>
<span class="line-added">13018 </span>
<span class="line-added">13019     GPRReg resultGPR = result.gpr();</span>
<span class="line-added">13020     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="line-added">13021     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="line-added">13022 </span>
<span class="line-added">13023     MacroAssembler::JumpList slowCases;</span>
<span class="line-added">13024 </span>
<span class="line-added">13025     FrozenValue* structure = m_graph.freezeStrong(node-&gt;structure().get());</span>
<span class="line-added">13026     auto butterfly = TrustedImmPtr(nullptr);</span>
<span class="line-added">13027     emitAllocateJSObjectWithKnownSize&lt;JSClass&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSClass));</span>
<span class="line-added">13028     auto initialValues = JSClass::initialValues();</span>
<span class="line-added">13029     static_assert(initialValues.size() == JSClass::numberOfInternalFields);</span>
<span class="line-added">13030     for (unsigned index = 0; index &lt; initialValues.size(); ++index)</span>
<span class="line-added">13031         m_jit.storeTrustedValue(initialValues[index], CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index)));</span>
<span class="line-added">13032     m_jit.mutatorFence(m_jit.vm());</span>
<span class="line-added">13033 </span>
<span class="line-added">13034     addSlowPathGenerator(slowPathCall(slowCases, this, operation, resultGPR, &amp;vm(), TrustedImmPtr(structure)));</span>
<span class="line-added">13035 </span>
<span class="line-added">13036     cellResult(resultGPR, node);</span>
<span class="line-added">13037 }</span>
<span class="line-added">13038 </span>
<span class="line-added">13039 void SpeculativeJIT::compileNewGenerator(Node* node)</span>
<span class="line-added">13040 {</span>
<span class="line-added">13041     compileNewInternalFieldObject&lt;JSGenerator&gt;(node, operationNewGenerator);</span>
<span class="line-added">13042 }</span>
<span class="line-added">13043 </span>
<span class="line-added">13044 void SpeculativeJIT::compileNewAsyncGenerator(Node* node)</span>
<span class="line-added">13045 {</span>
<span class="line-added">13046     compileNewInternalFieldObject&lt;JSAsyncGenerator&gt;(node, operationNewAsyncGenerator);</span>
<span class="line-added">13047 }</span>
<span class="line-added">13048 </span>
<span class="line-added">13049 void SpeculativeJIT::compileNewArrayIterator(Node* node)</span>
<span class="line-added">13050 {</span>
<span class="line-added">13051     compileNewInternalFieldObject&lt;JSArrayIterator&gt;(node, operationNewArrayIterator);</span>
<span class="line-added">13052 }</span>
<span class="line-added">13053 </span>
13054 void SpeculativeJIT::compileToPrimitive(Node* node)
13055 {
13056     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
13057     JSValueOperand argument(this, node-&gt;child1());
13058     JSValueRegsTemporary result(this, Reuse, argument);
13059 
13060     JSValueRegs argumentRegs = argument.jsValueRegs();
13061     JSValueRegs resultRegs = result.regs();
13062 
13063     argument.use();
13064 
13065     MacroAssembler::Jump alreadyPrimitive = m_jit.branchIfNotCell(argumentRegs);
13066     MacroAssembler::Jump notPrimitive = m_jit.branchIfObject(argumentRegs.payloadGPR());
13067 
13068     alreadyPrimitive.link(&amp;m_jit);
13069     m_jit.moveValueRegs(argumentRegs, resultRegs);
13070 
<span class="line-modified">13071     addSlowPathGenerator(slowPathCall(notPrimitive, this, operationToPrimitive, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs));</span>
13072 
13073     jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
13074 }
13075 
<span class="line-added">13076 void SpeculativeJIT::compileToPropertyKey(Node* node)</span>
<span class="line-added">13077 {</span>
<span class="line-added">13078     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());</span>
<span class="line-added">13079     JSValueOperand argument(this, node-&gt;child1());</span>
<span class="line-added">13080     JSValueRegsTemporary result(this, Reuse, argument);</span>
<span class="line-added">13081 </span>
<span class="line-added">13082     JSValueRegs argumentRegs = argument.jsValueRegs();</span>
<span class="line-added">13083     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">13084 </span>
<span class="line-added">13085     argument.use();</span>
<span class="line-added">13086 </span>
<span class="line-added">13087     MacroAssembler::JumpList slowCases;</span>
<span class="line-added">13088     slowCases.append(m_jit.branchIfNotCell(argumentRegs));</span>
<span class="line-added">13089     MacroAssembler::Jump alreadyPropertyKey = m_jit.branchIfSymbol(argumentRegs.payloadGPR());</span>
<span class="line-added">13090     slowCases.append(m_jit.branchIfNotString(argumentRegs.payloadGPR()));</span>
<span class="line-added">13091 </span>
<span class="line-added">13092     alreadyPropertyKey.link(&amp;m_jit);</span>
<span class="line-added">13093     m_jit.moveValueRegs(argumentRegs, resultRegs);</span>
<span class="line-added">13094 </span>
<span class="line-added">13095     addSlowPathGenerator(slowPathCall(slowCases, this, operationToPropertyKey, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs));</span>
<span class="line-added">13096 </span>
<span class="line-added">13097     jsValueResult(resultRegs, node, DataFormatJSCell, UseChildrenCalledExplicitly);</span>
<span class="line-added">13098 }</span>
<span class="line-added">13099 </span>
<span class="line-added">13100 void SpeculativeJIT::compileToNumeric(Node* node)</span>
<span class="line-added">13101 {</span>
<span class="line-added">13102     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());</span>
<span class="line-added">13103     JSValueOperand argument(this, node-&gt;child1());</span>
<span class="line-added">13104     JSValueRegsTemporary result(this);</span>
<span class="line-added">13105     GPRTemporary temp(this);</span>
<span class="line-added">13106 </span>
<span class="line-added">13107     JSValueRegs argumentRegs = argument.jsValueRegs();</span>
<span class="line-added">13108     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">13109     GPRReg scratch = temp.gpr();</span>
<span class="line-added">13110 </span>
<span class="line-added">13111     MacroAssembler::JumpList slowCases;</span>
<span class="line-added">13112 </span>
<span class="line-added">13113     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(argumentRegs);</span>
<span class="line-added">13114     slowCases.append(m_jit.branchIfNotBigInt(argumentRegs.payloadGPR()));</span>
<span class="line-added">13115     MacroAssembler::Jump isBigInt = m_jit.jump();</span>
<span class="line-added">13116 </span>
<span class="line-added">13117     notCell.link(&amp;m_jit);</span>
<span class="line-added">13118     slowCases.append(m_jit.branchIfNotNumber(argumentRegs, scratch));</span>
<span class="line-added">13119 </span>
<span class="line-added">13120     isBigInt.link(&amp;m_jit);</span>
<span class="line-added">13121     m_jit.moveValueRegs(argumentRegs, resultRegs);</span>
<span class="line-added">13122 </span>
<span class="line-added">13123     addSlowPathGenerator(slowPathCall(slowCases, this, operationToNumeric, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs));</span>
<span class="line-added">13124 </span>
<span class="line-added">13125     jsValueResult(resultRegs, node, DataFormatJS);</span>
<span class="line-added">13126 }</span>
<span class="line-added">13127 </span>
13128 void SpeculativeJIT::compileLogShadowChickenPrologue(Node* node)
13129 {
13130     flushRegisters();
13131     prepareForExternalCall();
13132     m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
13133 
13134     GPRTemporary scratch1(this, GPRInfo::nonArgGPR0); // This must be a non-argument GPR.
13135     GPRReg scratch1Reg = scratch1.gpr();
13136     GPRTemporary scratch2(this);
13137     GPRReg scratch2Reg = scratch2.gpr();
13138     GPRTemporary shadowPacket(this);
13139     GPRReg shadowPacketReg = shadowPacket.gpr();
13140 
13141     m_jit.ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
13142 
13143     SpeculateCellOperand scope(this, node-&gt;child1());
13144     GPRReg scopeReg = scope.gpr();
13145 
13146     m_jit.logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, scopeReg);
13147     noResult(node);
</pre>
<hr />
<pre>
13169 
13170     m_jit.logShadowChickenTailPacket(shadowPacketReg, thisRegs, scopeReg, m_jit.codeBlock(), callSiteIndex);
13171     noResult(node);
13172 }
13173 
13174 void SpeculativeJIT::compileSetAdd(Node* node)
13175 {
13176     SpeculateCellOperand set(this, node-&gt;child1());
13177     JSValueOperand key(this, node-&gt;child2());
13178     SpeculateInt32Operand hash(this, node-&gt;child3());
13179 
13180     GPRReg setGPR = set.gpr();
13181     JSValueRegs keyRegs = key.jsValueRegs();
13182     GPRReg hashGPR = hash.gpr();
13183 
13184     speculateSetObject(node-&gt;child1(), setGPR);
13185 
13186     flushRegisters();
13187     GPRFlushedCallResult result(this);
13188     GPRReg resultGPR = result.gpr();
<span class="line-modified">13189     callOperation(operationSetAdd, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), setGPR, keyRegs, hashGPR);</span>
13190     m_jit.exceptionCheck();
13191     cellResult(resultGPR, node);
13192 }
13193 
13194 void SpeculativeJIT::compileMapSet(Node* node)
13195 {
13196     SpeculateCellOperand map(this, m_jit.graph().varArgChild(node, 0));
13197     JSValueOperand key(this, m_jit.graph().varArgChild(node, 1));
13198     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
13199     SpeculateInt32Operand hash(this, m_jit.graph().varArgChild(node, 3));
13200 
13201     GPRReg mapGPR = map.gpr();
13202     JSValueRegs keyRegs = key.jsValueRegs();
13203     JSValueRegs valueRegs = value.jsValueRegs();
13204     GPRReg hashGPR = hash.gpr();
13205 
13206     speculateMapObject(m_jit.graph().varArgChild(node, 0), mapGPR);
13207 
13208     flushRegisters();
13209     GPRFlushedCallResult result(this);
13210     GPRReg resultGPR = result.gpr();
<span class="line-modified">13211     callOperation(operationMapSet, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyRegs, valueRegs, hashGPR);</span>
13212     m_jit.exceptionCheck();
13213     cellResult(resultGPR, node);
13214 }
13215 
13216 void SpeculativeJIT::compileWeakMapGet(Node* node)
13217 {
13218     GPRTemporary mask(this);
13219     GPRTemporary buffer(this);
13220     JSValueRegsTemporary result(this);
13221 
13222     GPRReg maskGPR = mask.gpr();
13223     GPRReg bufferGPR = buffer.gpr();
13224     JSValueRegs resultRegs = result.regs();
13225 
13226     GPRTemporary index;
13227     GPRReg indexGPR { InvalidGPRReg };
13228     {
13229         SpeculateInt32Operand hash(this, node-&gt;child3());
13230         GPRReg hashGPR = hash.gpr();
13231         index = GPRTemporary(this, Reuse, hash);
</pre>
<hr />
<pre>
13308         m_jit.loadValue(MacroAssembler::Address(bucketGPR, WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfValue()), resultRegs);
13309 #endif
13310 
13311     jsValueResult(resultRegs, node);
13312 }
13313 
13314 void SpeculativeJIT::compileWeakSetAdd(Node* node)
13315 {
13316     SpeculateCellOperand set(this, node-&gt;child1());
13317     SpeculateCellOperand key(this, node-&gt;child2());
13318     SpeculateInt32Operand hash(this, node-&gt;child3());
13319 
13320     GPRReg setGPR = set.gpr();
13321     GPRReg keyGPR = key.gpr();
13322     GPRReg hashGPR = hash.gpr();
13323 
13324     speculateWeakSetObject(node-&gt;child1(), setGPR);
13325     speculateObject(node-&gt;child2(), keyGPR);
13326 
13327     flushRegisters();
<span class="line-modified">13328     callOperation(operationWeakSetAdd, &amp;vm(), setGPR, keyGPR, hashGPR);</span>
13329     m_jit.exceptionCheck();
13330     noResult(node);
13331 }
13332 
13333 void SpeculativeJIT::compileWeakMapSet(Node* node)
13334 {
13335     SpeculateCellOperand map(this, m_jit.graph().varArgChild(node, 0));
13336     SpeculateCellOperand key(this, m_jit.graph().varArgChild(node, 1));
13337     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
13338     SpeculateInt32Operand hash(this, m_jit.graph().varArgChild(node, 3));
13339 
13340     GPRReg mapGPR = map.gpr();
13341     GPRReg keyGPR = key.gpr();
13342     JSValueRegs valueRegs = value.jsValueRegs();
13343     GPRReg hashGPR = hash.gpr();
13344 
13345     speculateWeakMapObject(m_jit.graph().varArgChild(node, 0), mapGPR);
13346     speculateObject(m_jit.graph().varArgChild(node, 1), keyGPR);
13347 
13348     flushRegisters();
<span class="line-modified">13349     callOperation(operationWeakMapSet, &amp;vm(), mapGPR, keyGPR, valueRegs, hashGPR);</span>
13350     m_jit.exceptionCheck();
13351     noResult(node);
13352 }
13353 
13354 void SpeculativeJIT::compileGetPrototypeOf(Node* node)
13355 {
13356     switch (node-&gt;child1().useKind()) {
13357     case ArrayUse:
13358     case FunctionUse:
13359     case FinalObjectUse: {
13360         SpeculateCellOperand object(this, node-&gt;child1());
13361         GPRTemporary temp(this);
13362         GPRTemporary temp2(this);
13363 
13364         GPRReg objectGPR = object.gpr();
13365         GPRReg tempGPR = temp.gpr();
13366         GPRReg temp2GPR = temp2.gpr();
13367 
13368         switch (node-&gt;child1().useKind()) {
13369         case ArrayUse:
</pre>
<hr />
<pre>
13428         m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + TagOffset), temp2GPR);
13429         m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + PayloadOffset), tempGPR);
13430         auto hasMonoProto = m_jit.branchIfNotEmpty(temp2GPR);
13431         m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + TagOffset), temp2GPR);
13432         m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), tempGPR);
13433         hasMonoProto.link(&amp;m_jit);
13434         jsValueResult(temp2GPR, tempGPR, node);
13435 #endif
13436         return;
13437     }
13438     case ObjectUse: {
13439         SpeculateCellOperand value(this, node-&gt;child1());
13440         JSValueRegsTemporary result(this);
13441 
13442         GPRReg valueGPR = value.gpr();
13443         JSValueRegs resultRegs = result.regs();
13444 
13445         speculateObject(node-&gt;child1(), valueGPR);
13446 
13447         flushRegisters();
<span class="line-modified">13448         callOperation(operationGetPrototypeOfObject, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueGPR);</span>
13449         m_jit.exceptionCheck();
13450         jsValueResult(resultRegs, node);
13451         return;
13452     }
13453     default: {
13454         JSValueOperand value(this, node-&gt;child1());
13455         JSValueRegsTemporary result(this);
13456 
13457         JSValueRegs valueRegs = value.jsValueRegs();
13458         JSValueRegs resultRegs = result.regs();
13459 
13460         flushRegisters();
<span class="line-modified">13461         callOperation(operationGetPrototypeOf, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs);</span>
13462         m_jit.exceptionCheck();
13463         jsValueResult(resultRegs, node);
13464         return;
13465     }
13466     }
13467 }
13468 
13469 void SpeculativeJIT::compileIdentity(Node* node)
13470 {
13471     speculate(node, node-&gt;child1());
13472     switch (node-&gt;child1().useKind()) {
13473 #if USE(JSVALUE64)
13474     case DoubleRepAnyIntUse:
13475 #endif
13476     case DoubleRepUse:
13477     case DoubleRepRealUse: {
13478         SpeculateDoubleOperand op(this, node-&gt;child1());
13479         FPRTemporary scratch(this, op);
13480         m_jit.moveDouble(op.fpr(), scratch.fpr());
13481         doubleResult(scratch.fpr(), node);
</pre>
<hr />
<pre>
13533     m_jit.storeValue(emptyValueRegs, MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesEight));
13534     m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
13535     done.link(&amp;m_jit);
13536 }
13537 
13538 void SpeculativeJIT::compileAllocateNewArrayWithSize(JSGlobalObject* globalObject, GPRReg resultGPR, GPRReg sizeGPR, IndexingType indexingType, bool shouldConvertLargeSizeToArrayStorage)
13539 {
13540     GPRTemporary storage(this);
13541     GPRTemporary scratch(this);
13542     GPRTemporary scratch2(this);
13543 
13544     GPRReg storageGPR = storage.gpr();
13545     GPRReg scratchGPR = scratch.gpr();
13546     GPRReg scratch2GPR = scratch2.gpr();
13547 
13548     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
13549 
13550     MacroAssembler::JumpList slowCases;
13551     if (shouldConvertLargeSizeToArrayStorage)
13552         slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));
<span class="line-modified">13553 #if ASSERT_ENABLED</span>
13554     else {
13555         MacroAssembler::Jump lengthIsWithinLimits;
13556         lengthIsWithinLimits = m_jit.branch32(MacroAssembler::Below, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
13557         m_jit.abortWithReason(UncheckedOverflow);
13558         lengthIsWithinLimits.link(&amp;m_jit);
13559     }
<span class="line-modified">13560 #endif // ASSERT_ENABLED</span>
13561 
13562     // We can use resultGPR as a scratch right now.
13563     emitAllocateButterfly(storageGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
13564 
13565 #if USE(JSVALUE64)
13566     JSValueRegs emptyValueRegs(scratchGPR);
13567     if (hasDouble(indexingType))
13568         m_jit.move(TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), emptyValueRegs.gpr());
13569     else
13570         m_jit.move(TrustedImm64(JSValue::encode(JSValue())), emptyValueRegs.gpr());
13571 #else
13572     JSValueRegs emptyValueRegs(scratchGPR, scratch2GPR);
13573     if (hasDouble(indexingType))
13574         m_jit.moveValue(JSValue(JSValue::EncodeAsDouble, PNaN), emptyValueRegs);
13575     else
13576         m_jit.moveValue(JSValue(), emptyValueRegs);
13577 #endif
13578     emitInitializeButterfly(storageGPR, sizeGPR, emptyValueRegs, resultGPR);
13579 
13580     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType));
13581 
13582     emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), storageGPR, scratchGPR, scratch2GPR, slowCases);
13583 
13584     m_jit.mutatorFence(vm());
13585 
13586     addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableSizeSlowPathGenerator&gt;(
13587         slowCases, this, operationNewArrayWithSize, resultGPR,
<span class="line-added">13588         TrustedImmPtr::weakPointer(m_graph, globalObject),</span>
13589         structure,
13590         shouldConvertLargeSizeToArrayStorage ? m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage)) : structure,
13591         sizeGPR, storageGPR));
13592 }
13593 
13594 void SpeculativeJIT::compileHasIndexedProperty(Node* node)
13595 {
13596     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
13597     SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
13598     GPRTemporary result(this);
13599 
13600     GPRReg baseGPR = base.gpr();
13601     GPRReg indexGPR = index.gpr();
13602     GPRReg resultGPR = result.gpr();
13603 
13604     MacroAssembler::JumpList slowCases;
13605     ArrayMode mode = node-&gt;arrayMode();
13606     switch (mode.type()) {
13607     case Array::Int32:
13608     case Array::Contiguous: {
</pre>
<hr />
<pre>
13660             speculationCheck(OutOfBounds, JSValueRegs(), nullptr, outOfBounds);
13661         else
13662             slowCases.append(outOfBounds);
13663 
13664 #if USE(JSVALUE64)
13665         m_jit.load64(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), scratchGPR);
13666         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13667 #else
13668         m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), scratchGPR);
13669         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13670 #endif
13671         m_jit.move(TrustedImm32(1), resultGPR);
13672         break;
13673     }
13674     default: {
13675         slowCases.append(m_jit.jump());
13676         break;
13677     }
13678     }
13679 
<span class="line-modified">13680     addSlowPathGenerator(slowPathCall(slowCases, this, operationHasIndexedPropertyByInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, indexGPR, static_cast&lt;int32_t&gt;(node-&gt;internalMethodType())));</span>
13681 
13682     unblessedBooleanResult(resultGPR, node);
13683 }
13684 
13685 void SpeculativeJIT::compileGetDirectPname(Node* node)
13686 {
13687     Edge&amp; baseEdge = m_jit.graph().varArgChild(node, 0);
13688     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
13689     Edge&amp; indexEdge = m_jit.graph().varArgChild(node, 2);
13690 
13691     SpeculateCellOperand base(this, baseEdge);
13692     SpeculateCellOperand property(this, propertyEdge);
13693     GPRReg baseGPR = base.gpr();
13694     GPRReg propertyGPR = property.gpr();
13695 










13696     Edge&amp; enumeratorEdge = m_jit.graph().varArgChild(node, 3);
13697     SpeculateStrictInt32Operand index(this, indexEdge);
13698     SpeculateCellOperand enumerator(this, enumeratorEdge);
13699     GPRTemporary scratch(this);
13700     JSValueRegsTemporary result(this);
13701 
13702     GPRReg indexGPR = index.gpr();
13703     GPRReg enumeratorGPR = enumerator.gpr();
13704     GPRReg scratchGPR = scratch.gpr();
13705     JSValueRegs resultRegs = result.regs();
13706 
13707     MacroAssembler::JumpList slowPath;
13708 
13709     // Check the structure
13710     m_jit.load32(MacroAssembler::Address(baseGPR, JSCell::structureIDOffset()), scratchGPR);
13711     slowPath.append(
13712         m_jit.branch32(
13713             MacroAssembler::NotEqual,
13714             scratchGPR,
13715             MacroAssembler::Address(
</pre>
<hr />
<pre>
13719     // If index is less than the enumerator&#39;s cached inline storage, then it&#39;s an inline access
13720     MacroAssembler::Jump outOfLineAccess = m_jit.branch32(MacroAssembler::AboveOrEqual,
13721         indexGPR, MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()));
13722 
13723     m_jit.loadValue(MacroAssembler::BaseIndex(baseGPR, indexGPR, MacroAssembler::TimesEight, JSObject::offsetOfInlineStorage()), resultRegs);
13724 
13725     MacroAssembler::Jump done = m_jit.jump();
13726 
13727     // Otherwise it&#39;s out of line
13728     outOfLineAccess.link(&amp;m_jit);
13729     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), resultRegs.payloadGPR());
13730     m_jit.move(indexGPR, scratchGPR);
13731     m_jit.sub32(MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()), scratchGPR);
13732     m_jit.neg32(scratchGPR);
13733     m_jit.signExtend32ToPtr(scratchGPR, scratchGPR);
13734     int32_t offsetOfFirstProperty = static_cast&lt;int32_t&gt;(offsetInButterfly(firstOutOfLineOffset)) * sizeof(EncodedJSValue);
13735     m_jit.loadValue(MacroAssembler::BaseIndex(resultRegs.payloadGPR(), scratchGPR, MacroAssembler::TimesEight, offsetOfFirstProperty), resultRegs);
13736 
13737     done.link(&amp;m_jit);
13738 
<span class="line-modified">13739     addSlowPathGenerator(slowPathCall(slowPath, this, operationGetByValCell, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, CCallHelpers::CellValue(propertyGPR)));</span>
13740 
13741     jsValueResult(resultRegs, node);

13742 }
13743 
13744 void SpeculativeJIT::compileExtractCatchLocal(Node* node)
13745 {
13746     JSValueRegsTemporary result(this);
13747     JSValueRegs resultRegs = result.regs();
13748 
13749     JSValue* ptr = &amp;reinterpret_cast&lt;JSValue*&gt;(m_jit.jitCode()-&gt;common.catchOSREntryBuffer-&gt;dataBuffer())[node-&gt;catchOSREntryIndex()];
13750     m_jit.loadValue(ptr, resultRegs);
13751     jsValueResult(resultRegs, node);
13752 }
13753 
13754 void SpeculativeJIT::compileClearCatchLocals(Node* node)
13755 {
13756     ScratchBuffer* scratchBuffer = m_jit.jitCode()-&gt;common.catchOSREntryBuffer;
13757     ASSERT(scratchBuffer);
13758     GPRTemporary scratch(this);
13759     GPRReg scratchGPR = scratch.gpr();
13760     m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratchGPR);
13761     m_jit.storePtr(TrustedImmPtr(nullptr), scratchGPR);
</pre>
<hr />
<pre>
13808     m_jit.storeValue(valueRegs, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::valueOffset()));
13809 
13810     // Store the structureID of the cell if valueRegs is a cell, otherwise, store 0 on the log entry.
13811     MacroAssembler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
13812     m_jit.load32(MacroAssembler::Address(valueRegs.payloadGPR(), JSCell::structureIDOffset()), scratch3GPR);
13813     m_jit.store32(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13814     MacroAssembler::Jump skipIsCell = m_jit.jump();
13815     isNotCell.link(&amp;m_jit);
13816     m_jit.store32(TrustedImm32(0), MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13817     skipIsCell.link(&amp;m_jit);
13818 
13819     // Store the typeLocation on the log entry.
13820     m_jit.move(TrustedImmPtr(cachedTypeLocation), scratch3GPR);
13821     m_jit.storePtr(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::locationOffset()));
13822 
13823     // Increment the current log entry.
13824     m_jit.addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), scratch1GPR);
13825     m_jit.storePtr(scratch1GPR, MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()));
13826     MacroAssembler::Jump clearLog = m_jit.branchPtr(MacroAssembler::Equal, scratch1GPR, TrustedImmPtr(cachedTypeProfilerLog-&gt;logEndPtr()));
13827     addSlowPathGenerator(
<span class="line-modified">13828         slowPathCall(clearLog, this, operationProcessTypeProfilerLogDFG, NoResult, TrustedImmPtr(&amp;vm())));</span>
13829 
13830     jumpToEnd.link(&amp;m_jit);
13831 
13832     noResult(node);
13833 }
13834 
13835 void SpeculativeJIT::cachedPutById(CodeOrigin codeOrigin, GPRReg baseGPR, JSValueRegs valueRegs, GPRReg scratchGPR, unsigned identifierNumber, PutKind putKind, JITCompiler::Jump slowPathTarget, SpillRegistersMode spillMode)
13836 {
13837     RegisterSet usedRegisters = this-&gt;usedRegisters();
13838     if (spillMode == DontSpill) {
13839         // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
13840         usedRegisters.set(baseGPR, false);
13841         usedRegisters.set(valueRegs, false);
13842     }
13843     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
13844     JITPutByIdGenerator gen(
13845         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters,
13846         JSValueRegs::payloadOnly(baseGPR), valueRegs,
13847         scratchGPR, m_jit.ecmaModeFor(codeOrigin), putKind);
13848 
13849     gen.generateFastPath(m_jit);
13850 
13851     JITCompiler::JumpList slowCases;
13852     if (slowPathTarget.isSet())
13853         slowCases.append(slowPathTarget);
13854     slowCases.append(gen.slowPathJump());
13855 
13856     auto slowPath = slowPathCall(
<span class="line-modified">13857         slowCases, this, gen.slowPathFunction(), NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), valueRegs,</span>
13858         CCallHelpers::CellValue(baseGPR), identifierUID(identifierNumber));
13859 
13860     m_jit.addPutById(gen, slowPath.get());
13861     addSlowPathGenerator(WTFMove(slowPath));
13862 }
13863 
<span class="line-modified">13864 void SpeculativeJIT::nonSpeculativeNonPeepholeCompare(Node* node, MacroAssembler::RelationalCondition cond, S_JITOperation_GJJ helperFunction)</span>
13865 {
13866     ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
13867     JSValueOperand arg1(this, node-&gt;child1());
13868     JSValueOperand arg2(this, node-&gt;child2());
13869 
13870     JSValueRegs arg1Regs = arg1.jsValueRegs();
13871     JSValueRegs arg2Regs = arg2.jsValueRegs();
13872 
13873     JITCompiler::JumpList slowPath;
13874 
13875     if (isKnownNotInteger(node-&gt;child1().node()) || isKnownNotInteger(node-&gt;child2().node())) {
13876         GPRFlushedCallResult result(this);
13877         GPRReg resultGPR = result.gpr();
13878 
13879         arg1.use();
13880         arg2.use();
13881 
13882         flushRegisters();
<span class="line-modified">13883         callOperation(helperFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
13884         m_jit.exceptionCheck();
13885 
13886         unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13887         return;
13888     }
13889 
13890     GPRTemporary result(this, Reuse, arg1, TagWord);
13891     GPRReg resultGPR = result.gpr();
13892 
13893     arg1.use();
13894     arg2.use();
13895 
13896     if (!isKnownInteger(node-&gt;child1().node()))
13897         slowPath.append(m_jit.branchIfNotInt32(arg1Regs));
13898     if (!isKnownInteger(node-&gt;child2().node()))
13899         slowPath.append(m_jit.branchIfNotInt32(arg2Regs));
13900 
13901     m_jit.compare32(cond, arg1Regs.payloadGPR(), arg2Regs.payloadGPR(), resultGPR);
13902 
13903     if (!isKnownInteger(node-&gt;child1().node()) || !isKnownInteger(node-&gt;child2().node()))
<span class="line-modified">13904         addSlowPathGenerator(slowPathCall(slowPath, this, helperFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs));</span>
13905 
13906     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13907 }
13908 
<span class="line-modified">13909 void SpeculativeJIT::nonSpeculativePeepholeBranch(Node* node, Node* branchNode, MacroAssembler::RelationalCondition cond, S_JITOperation_GJJ helperFunction)</span>
13910 {
13911     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
13912     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
13913 
13914     JITCompiler::ResultCondition callResultCondition = JITCompiler::NonZero;
13915 
13916     // The branch instruction will branch to the taken block.
13917     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
13918     if (taken == nextBlock()) {
13919         cond = JITCompiler::invert(cond);
13920         callResultCondition = JITCompiler::Zero;
13921         BasicBlock* tmp = taken;
13922         taken = notTaken;
13923         notTaken = tmp;
13924     }
13925 
13926     JSValueOperand arg1(this, node-&gt;child1());
13927     JSValueOperand arg2(this, node-&gt;child2());
13928     JSValueRegs arg1Regs = arg1.jsValueRegs();
13929     JSValueRegs arg2Regs = arg2.jsValueRegs();
13930 
13931     JITCompiler::JumpList slowPath;
13932 
13933     if (isKnownNotInteger(node-&gt;child1().node()) || isKnownNotInteger(node-&gt;child2().node())) {
13934         GPRFlushedCallResult result(this);
13935         GPRReg resultGPR = result.gpr();
13936 
13937         arg1.use();
13938         arg2.use();
13939 
13940         flushRegisters();
<span class="line-modified">13941         callOperation(helperFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
13942         m_jit.exceptionCheck();
13943 
13944         branchTest32(callResultCondition, resultGPR, taken);
13945     } else {
13946         GPRTemporary result(this, Reuse, arg2, TagWord);
13947         GPRReg resultGPR = result.gpr();
13948 
13949         arg1.use();
13950         arg2.use();
13951 
13952         if (!isKnownInteger(node-&gt;child1().node()))
13953             slowPath.append(m_jit.branchIfNotInt32(arg1Regs));
13954         if (!isKnownInteger(node-&gt;child2().node()))
13955             slowPath.append(m_jit.branchIfNotInt32(arg2Regs));
13956 
13957         branch32(cond, arg1Regs.payloadGPR(), arg2Regs.payloadGPR(), taken);
13958 
13959         if (!isKnownInteger(node-&gt;child1().node()) || !isKnownInteger(node-&gt;child2().node())) {
13960             jump(notTaken, ForceJump);
13961 
13962             slowPath.link(&amp;m_jit);
13963 
13964             silentSpillAllRegisters(resultGPR);
<span class="line-modified">13965             callOperation(helperFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
13966             silentFillAllRegisters();
13967             m_jit.exceptionCheck();
13968 
13969             branchTest32(callResultCondition, resultGPR, taken);
13970         }
13971     }
13972 
13973     jump(notTaken);
13974 
13975     m_indexInBlock = m_block-&gt;size() - 1;
13976     m_currentNode = branchNode;
13977 }
13978 
13979 void SpeculativeJIT::compileBigIntEquality(Node* node)
13980 {
13981     // FIXME: [ESNext][BigInt] Create specialized version of strict equals for BigIntUse
13982     // https://bugs.webkit.org/show_bug.cgi?id=182895
13983     SpeculateCellOperand left(this, node-&gt;child1());
13984     SpeculateCellOperand right(this, node-&gt;child2());
13985     GPRTemporary result(this, Reuse, left);
13986     GPRReg leftGPR = left.gpr();
13987     GPRReg rightGPR = right.gpr();
13988     GPRReg resultGPR = result.gpr();
13989 
13990     left.use();
13991     right.use();
13992 
13993     speculateBigInt(node-&gt;child1(), leftGPR);
13994     speculateBigInt(node-&gt;child2(), rightGPR);
13995 
13996     JITCompiler::Jump notEqualCase = m_jit.branchPtr(JITCompiler::NotEqual, leftGPR, rightGPR);
13997 
13998     m_jit.move(JITCompiler::TrustedImm32(1), resultGPR);
13999 
14000     JITCompiler::Jump done = m_jit.jump();
14001 
14002     notEqualCase.link(&amp;m_jit);
14003 
14004     silentSpillAllRegisters(resultGPR);
<span class="line-modified">14005     callOperation(operationCompareStrictEqCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
14006     silentFillAllRegisters();
14007 
14008     done.link(&amp;m_jit);
14009 
14010     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
14011 }
14012 
14013 void SpeculativeJIT::compileMakeRope(Node* node)
14014 {
14015     ASSERT(node-&gt;child1().useKind() == KnownStringUse);
14016     ASSERT(node-&gt;child2().useKind() == KnownStringUse);
14017     ASSERT(!node-&gt;child3() || node-&gt;child3().useKind() == KnownStringUse);
14018 
14019     SpeculateCellOperand op1(this, node-&gt;child1());
14020     SpeculateCellOperand op2(this, node-&gt;child2());
14021     SpeculateCellOperand op3(this, node-&gt;child3());
14022     GPRReg opGPRs[3];
14023     unsigned numOpGPRs;
14024     opGPRs[0] = op1.gpr();
14025     opGPRs[1] = op2.gpr();
</pre>
<hr />
<pre>
14061         } else {
14062             bool needsRopeCase = canBeRope(edges[0]);
14063             m_jit.loadPtr(CCallHelpers::Address(opGPRs[0], JSString::offsetOfValue()), scratch2GPR);
14064             CCallHelpers::Jump isRope;
14065             if (needsRopeCase)
14066                 isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
14067 
14068             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);
14069             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR);
14070 
14071             if (needsRopeCase) {
14072                 auto done = m_jit.jump();
14073 
14074                 isRope.link(&amp;m_jit);
14075                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfFlags()), scratchGPR);
14076                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfLength()), allocatorGPR);
14077                 done.link(&amp;m_jit);
14078             }
14079         }
14080 
<span class="line-modified">14081         if (ASSERT_ENABLED) {</span>
14082             CCallHelpers::Jump ok = m_jit.branch32(
14083                 CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
14084             m_jit.abortWithReason(DFGNegativeStringLength);
14085             ok.link(&amp;m_jit);
14086         }
14087     }
14088 
14089     for (unsigned i = 1; i &lt; numOpGPRs; ++i) {
14090         if (JSString* string = edges[i]-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
14091             m_jit.and32(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
14092             speculationCheck(
14093                 Uncountable, JSValueSource(), nullptr,
14094                 m_jit.branchAdd32(
14095                     CCallHelpers::Overflow,
14096                     TrustedImm32(string-&gt;length()), allocatorGPR));
14097         } else {
14098             bool needsRopeCase = canBeRope(edges[i]);
14099             m_jit.loadPtr(CCallHelpers::Address(opGPRs[i], JSString::offsetOfValue()), scratch2GPR);
14100             CCallHelpers::Jump isRope;
14101             if (needsRopeCase)
</pre>
<hr />
<pre>
14105             speculationCheck(
14106                 Uncountable, JSValueSource(), nullptr,
14107                 m_jit.branchAdd32(
14108                     CCallHelpers::Overflow,
14109                     CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR));
14110             if (needsRopeCase) {
14111                 auto done = m_jit.jump();
14112 
14113                 isRope.link(&amp;m_jit);
14114                 m_jit.and32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfFlags()), scratchGPR);
14115                 m_jit.load32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfLength()), scratch2GPR);
14116                 speculationCheck(
14117                     Uncountable, JSValueSource(), nullptr,
14118                     m_jit.branchAdd32(
14119                         CCallHelpers::Overflow, scratch2GPR, allocatorGPR));
14120                 done.link(&amp;m_jit);
14121             }
14122         }
14123     }
14124 
<span class="line-modified">14125     if (ASSERT_ENABLED) {</span>
14126         CCallHelpers::Jump ok = m_jit.branch32(
14127             CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
14128         m_jit.abortWithReason(DFGNegativeStringLength);
14129         ok.link(&amp;m_jit);
14130     }
14131 
14132     static_assert(StringImpl::flagIs8Bit() == JSRopeString::is8BitInPointer, &quot;&quot;);
14133     m_jit.and32(TrustedImm32(StringImpl::flagIs8Bit()), scratchGPR);
14134     m_jit.orPtr(opGPRs[0], scratchGPR);
14135     m_jit.orPtr(TrustedImmPtr(JSString::isRopeInPointer), scratchGPR);
14136     m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));
14137 
14138     m_jit.move(opGPRs[1], scratchGPR);
14139     m_jit.lshiftPtr(TrustedImm32(32), scratchGPR);
14140     m_jit.orPtr(allocatorGPR, scratchGPR);
14141     m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber1()));
14142 
14143     if (numOpGPRs == 2) {
14144         m_jit.move(opGPRs[1], scratchGPR);
14145         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);
14146         m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2()));
14147     } else {
14148         m_jit.move(opGPRs[1], scratchGPR);
14149         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);
14150         m_jit.move(opGPRs[2], scratch2GPR);
14151         m_jit.lshiftPtr(TrustedImm32(16), scratch2GPR);
14152         m_jit.orPtr(scratch2GPR, scratchGPR);
14153         m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2()));
14154     }
14155 
14156     auto isNonEmptyString = m_jit.branchTest32(CCallHelpers::NonZero, allocatorGPR);
14157 
14158     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.graph().m_vm)), resultGPR);
14159 
14160     isNonEmptyString.link(&amp;m_jit);
14161     m_jit.mutatorFence(vm());
14162 
14163     switch (numOpGPRs) {
14164     case 2:
14165         addSlowPathGenerator(slowPathCall(
<span class="line-modified">14166             slowPath, this, operationMakeRope2, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), opGPRs[0], opGPRs[1]));</span>
14167         break;
14168     case 3:
14169         addSlowPathGenerator(slowPathCall(
<span class="line-modified">14170             slowPath, this, operationMakeRope3, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), opGPRs[0], opGPRs[1], opGPRs[2]));</span>
14171         break;
14172     default:
14173         RELEASE_ASSERT_NOT_REACHED();
14174         break;
14175     }
14176 
14177     cellResult(resultGPR, node);
14178 #else
14179     flushRegisters();
14180     GPRFlushedCallResult result(this);
14181     GPRReg resultGPR = result.gpr();
14182     switch (numOpGPRs) {
14183     case 2:
<span class="line-modified">14184         callOperation(operationMakeRope2, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), opGPRs[0], opGPRs[1]);</span>
14185         m_jit.exceptionCheck();
14186         break;
14187     case 3:
<span class="line-modified">14188         callOperation(operationMakeRope3, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), opGPRs[0], opGPRs[1], opGPRs[2]);</span>
14189         m_jit.exceptionCheck();
14190         break;
14191     default:
14192         RELEASE_ASSERT_NOT_REACHED();
14193         break;
14194     }
14195 
14196     cellResult(resultGPR, node);
14197 #endif
14198 }
14199 
14200 } } // namespace JSC::DFG
14201 
14202 #endif
</pre>
</td>
</tr>
</table>
<center><a href="DFGSlowPathGenerator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/CSSFilter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011-2017 Apple Inc. All rights reserved.
  3  * Copyright (C) 2013 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;CSSFilter.h&quot;
 29 
 30 #include &quot;CachedSVGDocument.h&quot;
 31 #include &quot;CachedSVGDocumentReference.h&quot;
 32 #include &quot;ElementIterator.h&quot;
 33 #include &quot;FEColorMatrix.h&quot;
 34 #include &quot;FEComponentTransfer.h&quot;
 35 #include &quot;FEDropShadow.h&quot;
 36 #include &quot;FEGaussianBlur.h&quot;
 37 #include &quot;FEMerge.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;RenderLayer.h&quot;
 40 #include &quot;SVGElement.h&quot;
 41 #include &quot;SVGFilterBuilder.h&quot;
 42 #include &quot;SVGFilterPrimitiveStandardAttributes.h&quot;
 43 #include &quot;SourceAlpha.h&quot;
 44 #include &quot;SourceGraphic.h&quot;
 45 #include &lt;algorithm&gt;
 46 #include &lt;wtf/MathExtras.h&gt;
 47 
 48 #if USE(DIRECT2D)
 49 #include &lt;d2d1.h&gt;
 50 #endif
 51 
 52 namespace WebCore {
 53 
 54 static inline void endMatrixRow(Vector&lt;float&gt;&amp; parameters)
 55 {
 56     parameters.append(0);
 57     parameters.append(0);
 58 }
 59 
 60 static inline void lastMatrixRow(Vector&lt;float&gt;&amp; parameters)
 61 {
 62     parameters.append(0);
 63     parameters.append(0);
 64     parameters.append(0);
 65     parameters.append(1);
 66     parameters.append(0);
 67 }
 68 
 69 Ref&lt;CSSFilter&gt; CSSFilter::create()
 70 {
 71     return adoptRef(*new CSSFilter);
 72 }
 73 
 74 CSSFilter::CSSFilter()
 75     : Filter(FloatSize { 1, 1 })
 76     , m_sourceGraphic(SourceGraphic::create(*this))
 77 {
 78 }
 79 
 80 CSSFilter::~CSSFilter() = default;
 81 
 82 GraphicsContext* CSSFilter::inputContext()
 83 {
 84     return sourceImage() ? &amp;sourceImage()-&gt;context() : nullptr;
 85 }
 86 
 87 RefPtr&lt;FilterEffect&gt; CSSFilter::buildReferenceFilter(RenderElement&amp; renderer, FilterEffect&amp; previousEffect, ReferenceFilterOperation&amp; filterOperation)
 88 {
 89     auto* cachedSVGDocumentReference = filterOperation.cachedSVGDocumentReference();
 90     auto* cachedSVGDocument = cachedSVGDocumentReference ? cachedSVGDocumentReference-&gt;document() : nullptr;
 91 
 92     // If we have an SVG document, this is an external reference. Otherwise
 93     // we look up the referenced node in the current document.
 94     Document* document;
 95     if (!cachedSVGDocument)
 96         document = &amp;renderer.document();
 97     else {
 98         document = cachedSVGDocument-&gt;document();
 99         if (!document)
100             return nullptr;
101     }
102 
103     auto* filter = document-&gt;getElementById(filterOperation.fragment());
104     if (!filter) {
105         // Although we did not find the referenced filter, it might exist later in the document.
106         // FIXME: This skips anonymous RenderObjects. &lt;https://webkit.org/b/131085&gt;
107         if (auto* element = renderer.element())
108             document-&gt;accessSVGExtensions().addPendingResource(filterOperation.fragment(), *element);
109         return nullptr;
110     }
111 
112     RefPtr&lt;FilterEffect&gt; effect;
113 
114     auto builder = makeUnique&lt;SVGFilterBuilder&gt;(&amp;previousEffect);
115     m_sourceAlpha = builder-&gt;getEffectById(SourceAlpha::effectName());
116 
117     for (auto&amp; effectElement : childrenOfType&lt;SVGFilterPrimitiveStandardAttributes&gt;(*filter)) {
118         effect = effectElement.build(builder.get(), *this);
119         if (!effect)
120             continue;
121 
122         effectElement.setStandardAttributes(effect.get());
123         if (effectElement.renderer())
<a name="1" id="anc1"></a><span class="line-modified">124             effect-&gt;setOperatingColorSpace(effectElement.renderer()-&gt;style().svgStyle().colorInterpolationFilters() == ColorInterpolation::LinearRGB ? ColorSpace::LinearRGB : ColorSpace::SRGB);</span>
125 
126         builder-&gt;add(effectElement.result(), effect);
127         m_effects.append(*effect);
128     }
129     return effect;
130 }
131 
132 bool CSSFilter::build(RenderElement&amp; renderer, const FilterOperations&amp; operations, FilterConsumer consumer)
133 {
134     m_hasFilterThatMovesPixels = operations.hasFilterThatMovesPixels();
135     m_hasFilterThatShouldBeRestrictedBySecurityOrigin = operations.hasFilterThatShouldBeRestrictedBySecurityOrigin();
<a name="2" id="anc2"></a>

136 
137     m_effects.clear();
<a name="3" id="anc3"></a><span class="line-added">138     m_outsets = { };</span>
139 
140     RefPtr&lt;FilterEffect&gt; previousEffect = m_sourceGraphic.ptr();
141     for (auto&amp; operation : operations.operations()) {
142         RefPtr&lt;FilterEffect&gt; effect;
143         auto&amp; filterOperation = *operation;
144         switch (filterOperation.type()) {
145         case FilterOperation::REFERENCE: {
146             auto&amp; referenceOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
147             effect = buildReferenceFilter(renderer, *previousEffect, referenceOperation);
148             break;
149         }
150         case FilterOperation::GRAYSCALE: {
151             auto&amp; colorMatrixOperation = downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation);
152             Vector&lt;float&gt; inputParameters;
153             double oneMinusAmount = clampTo(1 - colorMatrixOperation.amount(), 0.0, 1.0);
154 
155             // See https://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html#grayscaleEquivalent
156             // for information on parameters.
157 
158             inputParameters.append(narrowPrecisionToFloat(0.2126 + 0.7874 * oneMinusAmount));
159             inputParameters.append(narrowPrecisionToFloat(0.7152 - 0.7152 * oneMinusAmount));
160             inputParameters.append(narrowPrecisionToFloat(0.0722 - 0.0722 * oneMinusAmount));
161             endMatrixRow(inputParameters);
162 
163             inputParameters.append(narrowPrecisionToFloat(0.2126 - 0.2126 * oneMinusAmount));
164             inputParameters.append(narrowPrecisionToFloat(0.7152 + 0.2848 * oneMinusAmount));
165             inputParameters.append(narrowPrecisionToFloat(0.0722 - 0.0722 * oneMinusAmount));
166             endMatrixRow(inputParameters);
167 
168             inputParameters.append(narrowPrecisionToFloat(0.2126 - 0.2126 * oneMinusAmount));
169             inputParameters.append(narrowPrecisionToFloat(0.7152 - 0.7152 * oneMinusAmount));
170             inputParameters.append(narrowPrecisionToFloat(0.0722 + 0.9278 * oneMinusAmount));
171             endMatrixRow(inputParameters);
172 
173             lastMatrixRow(inputParameters);
174 
175             effect = FEColorMatrix::create(*this, FECOLORMATRIX_TYPE_MATRIX, inputParameters);
176             break;
177         }
178         case FilterOperation::SEPIA: {
179             auto&amp; colorMatrixOperation = downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation);
180             Vector&lt;float&gt; inputParameters;
181             double oneMinusAmount = clampTo(1 - colorMatrixOperation.amount(), 0.0, 1.0);
182 
183             // See https://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html#sepiaEquivalent
184             // for information on parameters.
185 
186             inputParameters.append(narrowPrecisionToFloat(0.393 + 0.607 * oneMinusAmount));
187             inputParameters.append(narrowPrecisionToFloat(0.769 - 0.769 * oneMinusAmount));
188             inputParameters.append(narrowPrecisionToFloat(0.189 - 0.189 * oneMinusAmount));
189             endMatrixRow(inputParameters);
190 
191             inputParameters.append(narrowPrecisionToFloat(0.349 - 0.349 * oneMinusAmount));
192             inputParameters.append(narrowPrecisionToFloat(0.686 + 0.314 * oneMinusAmount));
193             inputParameters.append(narrowPrecisionToFloat(0.168 - 0.168 * oneMinusAmount));
194             endMatrixRow(inputParameters);
195 
196             inputParameters.append(narrowPrecisionToFloat(0.272 - 0.272 * oneMinusAmount));
197             inputParameters.append(narrowPrecisionToFloat(0.534 - 0.534 * oneMinusAmount));
198             inputParameters.append(narrowPrecisionToFloat(0.131 + 0.869 * oneMinusAmount));
199             endMatrixRow(inputParameters);
200 
201             lastMatrixRow(inputParameters);
202 
203             effect = FEColorMatrix::create(*this, FECOLORMATRIX_TYPE_MATRIX, inputParameters);
204             break;
205         }
206         case FilterOperation::SATURATE: {
207             auto&amp; colorMatrixOperation = downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation);
208             Vector&lt;float&gt; inputParameters;
209             inputParameters.append(narrowPrecisionToFloat(colorMatrixOperation.amount()));
210             effect = FEColorMatrix::create(*this, FECOLORMATRIX_TYPE_SATURATE, inputParameters);
211             break;
212         }
213         case FilterOperation::HUE_ROTATE: {
214             auto&amp; colorMatrixOperation = downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation);
215             Vector&lt;float&gt; inputParameters;
216             inputParameters.append(narrowPrecisionToFloat(colorMatrixOperation.amount()));
217             effect = FEColorMatrix::create(*this, FECOLORMATRIX_TYPE_HUEROTATE, inputParameters);
218             break;
219         }
220         case FilterOperation::INVERT: {
221             auto&amp; componentTransferOperation = downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation);
222             ComponentTransferFunction transferFunction;
223             transferFunction.type = FECOMPONENTTRANSFER_TYPE_TABLE;
224             Vector&lt;float&gt; transferParameters;
225             transferParameters.append(narrowPrecisionToFloat(componentTransferOperation.amount()));
226             transferParameters.append(narrowPrecisionToFloat(1 - componentTransferOperation.amount()));
227             transferFunction.tableValues = transferParameters;
228 
229             ComponentTransferFunction nullFunction;
230             effect = FEComponentTransfer::create(*this, transferFunction, transferFunction, transferFunction, nullFunction);
231             break;
232         }
233         case FilterOperation::APPLE_INVERT_LIGHTNESS:
234             ASSERT_NOT_REACHED(); // APPLE_INVERT_LIGHTNESS is only used in -apple-color-filter.
235             break;
236         case FilterOperation::OPACITY: {
237             auto&amp; componentTransferOperation = downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation);
238             ComponentTransferFunction transferFunction;
239             transferFunction.type = FECOMPONENTTRANSFER_TYPE_TABLE;
240             Vector&lt;float&gt; transferParameters;
241             transferParameters.append(0);
242             transferParameters.append(narrowPrecisionToFloat(componentTransferOperation.amount()));
243             transferFunction.tableValues = transferParameters;
244 
245             ComponentTransferFunction nullFunction;
246             effect = FEComponentTransfer::create(*this, nullFunction, nullFunction, nullFunction, transferFunction);
247             break;
248         }
249         case FilterOperation::BRIGHTNESS: {
250             auto&amp; componentTransferOperation = downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation);
251             ComponentTransferFunction transferFunction;
252             transferFunction.type = FECOMPONENTTRANSFER_TYPE_LINEAR;
253             transferFunction.slope = narrowPrecisionToFloat(componentTransferOperation.amount());
254             transferFunction.intercept = 0;
255 
256             ComponentTransferFunction nullFunction;
257             effect = FEComponentTransfer::create(*this, transferFunction, transferFunction, transferFunction, nullFunction);
258             break;
259         }
260         case FilterOperation::CONTRAST: {
261             auto&amp; componentTransferOperation = downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation);
262             ComponentTransferFunction transferFunction;
263             transferFunction.type = FECOMPONENTTRANSFER_TYPE_LINEAR;
264             float amount = narrowPrecisionToFloat(componentTransferOperation.amount());
265             transferFunction.slope = amount;
266             transferFunction.intercept = -0.5 * amount + 0.5;
267 
268             ComponentTransferFunction nullFunction;
269             effect = FEComponentTransfer::create(*this, transferFunction, transferFunction, transferFunction, nullFunction);
270             break;
271         }
272         case FilterOperation::BLUR: {
273             auto&amp; blurOperation = downcast&lt;BlurFilterOperation&gt;(filterOperation);
274             float stdDeviation = floatValueForLength(blurOperation.stdDeviation(), 0);
275             effect = FEGaussianBlur::create(*this, stdDeviation, stdDeviation, consumer == FilterConsumer::FilterProperty ? EDGEMODE_NONE : EDGEMODE_DUPLICATE);
276             break;
277         }
278         case FilterOperation::DROP_SHADOW: {
279             auto&amp; dropShadowOperation = downcast&lt;DropShadowFilterOperation&gt;(filterOperation);
280             effect = FEDropShadow::create(*this, dropShadowOperation.stdDeviation(), dropShadowOperation.stdDeviation(),
281                 dropShadowOperation.x(), dropShadowOperation.y(), dropShadowOperation.color(), 1);
282             break;
283         }
284         default:
285             break;
286         }
287 
288         if (effect) {
289             // Unlike SVG Filters and CSSFilterImages, filter functions on the filter
290             // property applied here should not clip to their primitive subregions.
291             effect-&gt;setClipsToBounds(consumer == FilterConsumer::FilterFunction);
<a name="4" id="anc4"></a><span class="line-modified">292             effect-&gt;setOperatingColorSpace(ColorSpace::SRGB);</span>
293 
294             if (filterOperation.type() != FilterOperation::REFERENCE) {
295                 effect-&gt;inputEffects().append(WTFMove(previousEffect));
296                 m_effects.append(*effect);
297             }
298             previousEffect = WTFMove(effect);
299         }
300     }
301 
302     // If we didn&#39;t make any effects, tell our caller we are not valid.
303     if (m_effects.isEmpty())
304         return false;
305 
306     setMaxEffectRects(m_sourceDrawingRegion);
307     return true;
308 }
309 
310 bool CSSFilter::updateBackingStoreRect(const FloatRect&amp; filterRect)
311 {
312     if (filterRect.isEmpty() || ImageBuffer::sizeNeedsClamping(filterRect.size()))
313         return false;
314 
315     if (filterRect == sourceImageRect())
316         return false;
317 
318     setSourceImageRect(filterRect);
319     return true;
320 }
321 
322 void CSSFilter::allocateBackingStoreIfNeeded(const GraphicsContext&amp; targetContext)
323 {
324     // At this point the effect chain has been built, and the
325     // source image sizes set. We just need to attach the graphic
326     // buffer if we have not yet done so.
327 
328     if (m_graphicsBufferAttached)
329         return;
330 
331     IntSize logicalSize { m_sourceDrawingRegion.size() };
332     if (!sourceImage() || sourceImage()-&gt;logicalSize() != logicalSize) {
333 #if USE(DIRECT2D)
334         setSourceImage(ImageBuffer::create(logicalSize, renderingMode(), &amp;targetContext, filterScale()));
335 #else
336         UNUSED_PARAM(targetContext);
337         setSourceImage(ImageBuffer::create(logicalSize, renderingMode(), filterScale()));
338 #endif
339     }
340     m_graphicsBufferAttached = true;
341 }
342 
343 void CSSFilter::determineFilterPrimitiveSubregion()
344 {
345     auto&amp; lastEffect = m_effects.last().get();
346     lastEffect.determineFilterPrimitiveSubregion();
347     FloatRect subRegion = lastEffect.maxEffectRect();
348     // At least one FilterEffect has a too big image size, recalculate the effect sizes with new scale factors.
349     FloatSize scale;
350     if (ImageBuffer::sizeNeedsClamping(subRegion.size(), scale)) {
351         setFilterResolution(scale);
352         lastEffect.determineFilterPrimitiveSubregion();
353     }
354 }
355 
356 void CSSFilter::clearIntermediateResults()
357 {
358     m_sourceGraphic-&gt;clearResult();
359     if (m_sourceAlpha)
360         m_sourceAlpha-&gt;clearResult();
361     for (auto&amp; effect : m_effects)
362         effect-&gt;clearResult();
363 }
364 
365 void CSSFilter::apply()
366 {
367     auto&amp; effect = m_effects.last().get();
368     effect.apply();
<a name="5" id="anc5"></a><span class="line-modified">369     effect.transformResultColorSpace(ColorSpace::SRGB);</span>
370 }
371 
372 LayoutRect CSSFilter::computeSourceImageRectForDirtyRect(const LayoutRect&amp; filterBoxRect, const LayoutRect&amp; dirtyRect)
373 {
374     // The result of this function is the area in the &quot;filterBoxRect&quot; that needs to be repainted, so that we fully cover the &quot;dirtyRect&quot;.
375     auto rectForRepaint = dirtyRect;
<a name="6" id="anc6"></a><span class="line-modified">376     if (hasFilterThatMovesPixels())</span>
<span class="line-modified">377         rectForRepaint += outsets();</span>




378     rectForRepaint.intersect(filterBoxRect);
379     return rectForRepaint;
380 }
381 
382 ImageBuffer* CSSFilter::output() const
383 {
384     return m_effects.last()-&gt;imageBufferResult();
385 }
386 
387 void CSSFilter::setSourceImageRect(const FloatRect&amp; sourceImageRect)
388 {
389     m_sourceDrawingRegion = sourceImageRect;
390     setMaxEffectRects(sourceImageRect);
391     setFilterRegion(sourceImageRect);
392     m_graphicsBufferAttached = false;
393 }
394 
<a name="7" id="anc7"></a>
395 void CSSFilter::setMaxEffectRects(const FloatRect&amp; effectRect)
396 {
397     for (auto&amp; effect : m_effects)
398         effect-&gt;setMaxEffectRect(effectRect);
399 }
400 
401 IntRect CSSFilter::outputRect() const
402 {
403     auto&amp; lastEffect = m_effects.last().get();
404     if (!lastEffect.hasResult())
405         return { };
406     return lastEffect.requestedRegionOfInputImageData(IntRect { m_filterRegion });
407 }
408 
<a name="8" id="anc8"></a><span class="line-added">409 IntOutsets CSSFilter::outsets() const</span>
<span class="line-added">410 {</span>
<span class="line-added">411     if (!m_hasFilterThatMovesPixels)</span>
<span class="line-added">412         return { };</span>
<span class="line-added">413 </span>
<span class="line-added">414     if (!m_outsets.isZero())</span>
<span class="line-added">415         return m_outsets;</span>
<span class="line-added">416 </span>
<span class="line-added">417     for (auto&amp; effect : m_effects)</span>
<span class="line-added">418         m_outsets += effect-&gt;outsets();</span>
<span class="line-added">419     return m_outsets;</span>
<span class="line-added">420 }</span>
<span class="line-added">421 </span>
422 } // namespace WebCore
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannelProviderImpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MessagePortChannelProvider.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MessagePortChannelProviderImpl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannelProviderImpl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MessagePortChannelProviderImpl.h&quot;
 28 
 29 #include &quot;MessagePort.h&quot;
<span class="line-removed"> 30 #include &lt;wtf/CompletionHandler.h&gt;</span>
 31 #include &lt;wtf/MainThread.h&gt;
 32 #include &lt;wtf/RunLoop.h&gt;
 33 
 34 namespace WebCore {
 35 








 36 MessagePortChannelProviderImpl::MessagePortChannelProviderImpl()
<span class="line-modified"> 37     : m_registry(*this)</span>
 38 {
 39 }
 40 
 41 MessagePortChannelProviderImpl::~MessagePortChannelProviderImpl()
 42 {
 43     ASSERT_NOT_REACHED();
 44 }
 45 
 46 void MessagePortChannelProviderImpl::performActionOnMainThread(Function&lt;void()&gt;&amp;&amp; action)
 47 {
 48     if (isMainThread())
 49         action();
 50     else
 51         callOnMainThread(WTFMove(action));
 52 }
 53 
 54 void MessagePortChannelProviderImpl::createNewMessagePortChannel(const MessagePortIdentifier&amp; local, const MessagePortIdentifier&amp; remote)
 55 {
 56     performActionOnMainThread([registry = &amp;m_registry, local, remote] {
 57         registry-&gt;didCreateMessagePortChannel(local, remote);
</pre>
<hr />
<pre>
 70     performActionOnMainThread([registry = &amp;m_registry, local] {
 71         registry-&gt;didDisentangleMessagePort(local);
 72     });
 73 }
 74 
 75 void MessagePortChannelProviderImpl::messagePortClosed(const MessagePortIdentifier&amp; local)
 76 {
 77     performActionOnMainThread([registry = &amp;m_registry, local] {
 78         registry-&gt;didCloseMessagePort(local);
 79     });
 80 }
 81 
 82 void MessagePortChannelProviderImpl::postMessageToRemote(MessageWithMessagePorts&amp;&amp; message, const MessagePortIdentifier&amp; remoteTarget)
 83 {
 84     performActionOnMainThread([registry = &amp;m_registry, message = WTFMove(message), remoteTarget]() mutable {
 85         if (registry-&gt;didPostMessageToRemote(WTFMove(message), remoteTarget))
 86             MessagePort::notifyMessageAvailable(remoteTarget);
 87     });
 88 }
 89 
<span class="line-modified"> 90 void MessagePortChannelProviderImpl::takeAllMessagesForPort(const MessagePortIdentifier&amp; port, Function&lt;void(Vector&lt;MessageWithMessagePorts&gt;&amp;&amp;, Function&lt;void()&gt;&amp;&amp;)&gt;&amp;&amp; outerCallback)</span>
 91 {
 92     // It is the responsibility of outerCallback to get itself to the appropriate thread (e.g. WebWorker thread)
<span class="line-modified"> 93     auto callback = [outerCallback = WTFMove(outerCallback)](Vector&lt;MessageWithMessagePorts&gt;&amp;&amp; messages, Function&lt;void()&gt;&amp;&amp; messageDeliveryCallback) {</span>
 94         ASSERT(isMainThread());
 95         outerCallback(WTFMove(messages), WTFMove(messageDeliveryCallback));
 96     };
 97 
 98     performActionOnMainThread([registry = &amp;m_registry, port, callback = WTFMove(callback)]() mutable {
 99         registry-&gt;takeAllMessagesForPort(port, WTFMove(callback));
100     });
101 }
102 
<span class="line-modified">103 void MessagePortChannelProviderImpl::checkRemotePortForActivity(const MessagePortIdentifier&amp; remoteTarget, Function&lt;void(HasActivity)&gt;&amp;&amp; outerCallback)</span>
104 {
105     auto callback = Function&lt;void(HasActivity)&gt; { [outerCallback = WTFMove(outerCallback)](HasActivity hasActivity) mutable {
106         ASSERT(isMainThread());
107         outerCallback(hasActivity);
108     } };
109 
110     performActionOnMainThread([registry = &amp;m_registry, remoteTarget, callback = WTFMove(callback)]() mutable {
111         registry-&gt;checkRemotePortForActivity(remoteTarget, WTFMove(callback));
112     });
113 }
114 
<span class="line-removed">115 void MessagePortChannelProviderImpl::checkProcessLocalPortForActivity(const MessagePortIdentifier&amp; identifier, ProcessIdentifier, CompletionHandler&lt;void(HasActivity)&gt;&amp;&amp; callback)</span>
<span class="line-removed">116 {</span>
<span class="line-removed">117     ASSERT(isMainThread());</span>
<span class="line-removed">118 </span>
<span class="line-removed">119     callback(MessagePort::isExistingMessagePortLocallyReachable(identifier) ? HasActivity::Yes : HasActivity::No);</span>
<span class="line-removed">120 }</span>
<span class="line-removed">121 </span>
<span class="line-removed">122 </span>
123 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MessagePortChannelProviderImpl.h&quot;
 28 
 29 #include &quot;MessagePort.h&quot;

 30 #include &lt;wtf/MainThread.h&gt;
 31 #include &lt;wtf/RunLoop.h&gt;
 32 
 33 namespace WebCore {
 34 
<span class="line-added"> 35 static inline MessagePortChannelRegistry::CheckProcessLocalPortForActivityCallback checkActivityCallback()</span>
<span class="line-added"> 36 {</span>
<span class="line-added"> 37     return [](auto&amp; messagePortIdentifier, auto, auto&amp;&amp; callback) {</span>
<span class="line-added"> 38         ASSERT(isMainThread());</span>
<span class="line-added"> 39         callback(MessagePort::isExistingMessagePortLocallyReachable(messagePortIdentifier) ? MessagePortChannelProvider::HasActivity::Yes : MessagePortChannelProvider::HasActivity::No);</span>
<span class="line-added"> 40     };</span>
<span class="line-added"> 41 }</span>
<span class="line-added"> 42 </span>
 43 MessagePortChannelProviderImpl::MessagePortChannelProviderImpl()
<span class="line-modified"> 44     : m_registry(checkActivityCallback())</span>
 45 {
 46 }
 47 
 48 MessagePortChannelProviderImpl::~MessagePortChannelProviderImpl()
 49 {
 50     ASSERT_NOT_REACHED();
 51 }
 52 
 53 void MessagePortChannelProviderImpl::performActionOnMainThread(Function&lt;void()&gt;&amp;&amp; action)
 54 {
 55     if (isMainThread())
 56         action();
 57     else
 58         callOnMainThread(WTFMove(action));
 59 }
 60 
 61 void MessagePortChannelProviderImpl::createNewMessagePortChannel(const MessagePortIdentifier&amp; local, const MessagePortIdentifier&amp; remote)
 62 {
 63     performActionOnMainThread([registry = &amp;m_registry, local, remote] {
 64         registry-&gt;didCreateMessagePortChannel(local, remote);
</pre>
<hr />
<pre>
 77     performActionOnMainThread([registry = &amp;m_registry, local] {
 78         registry-&gt;didDisentangleMessagePort(local);
 79     });
 80 }
 81 
 82 void MessagePortChannelProviderImpl::messagePortClosed(const MessagePortIdentifier&amp; local)
 83 {
 84     performActionOnMainThread([registry = &amp;m_registry, local] {
 85         registry-&gt;didCloseMessagePort(local);
 86     });
 87 }
 88 
 89 void MessagePortChannelProviderImpl::postMessageToRemote(MessageWithMessagePorts&amp;&amp; message, const MessagePortIdentifier&amp; remoteTarget)
 90 {
 91     performActionOnMainThread([registry = &amp;m_registry, message = WTFMove(message), remoteTarget]() mutable {
 92         if (registry-&gt;didPostMessageToRemote(WTFMove(message), remoteTarget))
 93             MessagePort::notifyMessageAvailable(remoteTarget);
 94     });
 95 }
 96 
<span class="line-modified"> 97 void MessagePortChannelProviderImpl::takeAllMessagesForPort(const MessagePortIdentifier&amp; port, CompletionHandler&lt;void(Vector&lt;MessageWithMessagePorts&gt;&amp;&amp;, Function&lt;void()&gt;&amp;&amp;)&gt;&amp;&amp; outerCallback)</span>
 98 {
 99     // It is the responsibility of outerCallback to get itself to the appropriate thread (e.g. WebWorker thread)
<span class="line-modified">100     auto callback = [outerCallback = WTFMove(outerCallback)](Vector&lt;MessageWithMessagePorts&gt;&amp;&amp; messages, Function&lt;void()&gt;&amp;&amp; messageDeliveryCallback) mutable {</span>
101         ASSERT(isMainThread());
102         outerCallback(WTFMove(messages), WTFMove(messageDeliveryCallback));
103     };
104 
105     performActionOnMainThread([registry = &amp;m_registry, port, callback = WTFMove(callback)]() mutable {
106         registry-&gt;takeAllMessagesForPort(port, WTFMove(callback));
107     });
108 }
109 
<span class="line-modified">110 void MessagePortChannelProviderImpl::checkRemotePortForActivity(const MessagePortIdentifier&amp; remoteTarget, CompletionHandler&lt;void(HasActivity)&gt;&amp;&amp; outerCallback)</span>
111 {
112     auto callback = Function&lt;void(HasActivity)&gt; { [outerCallback = WTFMove(outerCallback)](HasActivity hasActivity) mutable {
113         ASSERT(isMainThread());
114         outerCallback(hasActivity);
115     } };
116 
117     performActionOnMainThread([registry = &amp;m_registry, remoteTarget, callback = WTFMove(callback)]() mutable {
118         registry-&gt;checkRemotePortForActivity(remoteTarget, WTFMove(callback));
119     });
120 }
121 








122 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="MessagePortChannelProvider.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MessagePortChannelProviderImpl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
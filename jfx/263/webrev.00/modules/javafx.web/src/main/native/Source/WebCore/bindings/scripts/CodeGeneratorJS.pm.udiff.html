<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CodeGenerator.pm.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDLAttributes.json.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,11 +1,11 @@</span>
  #
  # Copyright (C) 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  # Copyright (C) 2006 Anders Carlsson &lt;andersca@mac.com&gt;
  # Copyright (C) 2006, 2007 Samuel Weinig &lt;sam@webkit.org&gt;
  # Copyright (C) 2006 Alexey Proskuryakov &lt;ap@webkit.org&gt;
<span class="udiff-line-modified-removed">- # Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+ # Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
  # Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
  # Copyright (C) Research In Motion Limited 2010. All rights reserved.
  # Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  # Copyright (C) 2011 Patrick Gansterer &lt;paroga@webkit.org&gt;
  # Copyright (C) 2012 Ericsson AB. All rights reserved.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -623,20 +623,20 @@</span>
  {
      my ($outputArray, $interface, $className) = @_;
      
      return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
      
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlot(JSObject* object, ExecState* state, PropertyName propertyName, PropertySlot&amp; slot)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlot(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PropertySlot&amp; slot)\n&quot;);</span>
      push(@$outputArray, &quot;{\n&quot;);
      push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
      push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
      
      my $namedGetterOperation = GetNamedGetterOperation($interface);
      my $indexedGetterOperation = GetIndexedGetterOperation($interface);
      
      if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);</span>
      }
      
      # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
      # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
      
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -666,11 +666,11 @@</span>
          
          # 1.3. Set ignoreNamedProps to true.
          # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
          #       rather than going through the paces of having an actual ignoreNamedProps update.
          if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlot(object, state, propertyName, slot);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlot(object, lexicalGlobalObject, propertyName, slot);\n&quot;);</span>
          }
          push(@$outputArray, &quot;    }\n&quot;);
      }
      
      # 2. If O supports named properties, the result of running the named property visibility
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -686,11 +686,11 @@</span>
          push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
          
          GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
          
          my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*state, *thisObject, propertyName, getterFunctor)) {\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*lexicalGlobalObject, *thisObject, propertyName, getterFunctor)) {\n&quot;);</span>
          
          # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
          
          my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
          
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -702,16 +702,16 @@</span>
          push(@$outputArray, &quot;    }\n&quot;);
      }
  
      if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
          AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, state, propertyName, slot))\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot))\n&quot;);</span>
          push(@$outputArray, &quot;        return true;\n&quot;);
      }
  
      # 3. Return OrdinaryGetOwnProperty(O, P).
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlot(object, state, propertyName, slot);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlot(object, lexicalGlobalObject, propertyName, slot);\n&quot;);</span>
      
      push(@$outputArray, &quot;}\n\n&quot;);
  }
  
  # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -732,14 +732,14 @@</span>
      };
      
      my $namedGetterOperation = GetNamedGetterOperation($interface);
      my $indexedGetterOperation = GetIndexedGetterOperation($interface);
      
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlotByIndex(JSObject* object, ExecState* state, unsigned index, PropertySlot&amp; slot)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* lexicalGlobalObject, unsigned index, PropertySlot&amp; slot)\n&quot;);</span>
      push(@$outputArray, &quot;{\n&quot;);
      if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin} || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
      }
      push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
      push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
      
      if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -775,11 +775,11 @@</span>
          
          # 1.3. Set ignoreNamedProps to true.
          # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
          #       rather than going through the paces of having an actual ignoreNamedProps update.
          if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlotByIndex(object, state, index, slot);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlotByIndex(object, lexicalGlobalObject, index, slot);\n&quot;);</span>
          }
          push(@$outputArray, &quot;    }\n&quot;);
      }
      
      # 2. If O supports named properties, the result of running the named property visibility
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -797,11 +797,11 @@</span>
          push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
          
          GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
          
          my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*state, *thisObject, propertyName, getterFunctor)) {\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*lexicalGlobalObject, *thisObject, propertyName, getterFunctor)) {\n&quot;);</span>
          
          # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
          
          my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -815,16 +815,16 @@</span>
      
      if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
          &amp;$propertyNameGeneration();
  
          AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, state, propertyName, slot))\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot))\n&quot;);</span>
          push(@$outputArray, &quot;        return true;\n&quot;);
      }
  
      # 3. Return OrdinaryGetOwnProperty(O, P).
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlotByIndex(object, state, index, slot);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlotByIndex(object, lexicalGlobalObject, index, slot);\n&quot;);</span>
      
      push(@$outputArray, &quot;}\n\n&quot;);
  }
  
  # https://heycam.github.io/webidl/#legacy-platform-object-property-enumeration
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -835,14 +835,14 @@</span>
      return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames};
      
      my $namedGetterOperation = GetNamedGetterOperation($interface);
      my $indexedGetterOperation = GetIndexedGetterOperation($interface);
      
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;void ${className}::getOwnPropertyNames(JSObject* object, ExecState* state, PropertyNameArray&amp; propertyNames, EnumerationMode mode)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;void ${className}::getOwnPropertyNames(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)\n&quot;);</span>
      push(@$outputArray, &quot;{\n&quot;);
      if ($indexedGetterOperation || $namedGetterOperation) {
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
      }
      push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
      push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(object, info());\n&quot;);
      
      # 1. If the object supports indexed properties, then the object’s supported
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -870,44 +870,44 @@</span>
          }
      }
      
      # 3. Finally, any enumerable own properties or properties from the object’s
      #    prototype chain are then enumerated, in no defined order.
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    JSObject::getOwnPropertyNames(object, state, propertyNames, mode);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    JSObject::getOwnPropertyNames(object, lexicalGlobalObject, propertyNames, mode);\n&quot;);</span>
      push(@$outputArray, &quot;}\n\n&quot;);
  }
  
  # https://heycam.github.io/webidl/#invoke-indexed-setter
  sub GenerateInvokeIndexedPropertySetter
  {
      my ($outputArray, $indent, $interface, $indexedSetterOperation, $indexExpression, $value) = @_;
      
      # The second argument of the indexed setter operation is the argument being converted.
      my $argument = @{$indexedSetterOperation-&gt;arguments}[1];
<span class="udiff-line-modified-removed">-     my $nativeValue = JSValueToNative($interface, $argument, $value, $indexedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;state&quot;, &quot;*state&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);</span>
<span class="udiff-line-modified-added">+     my $nativeValue = JSValueToNative($interface, $argument, $value, $indexedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;lexicalGlobalObject&quot;, &quot;*lexicalGlobalObject&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);</span>
      
<span class="udiff-line-modified-removed">-     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);</span>
      push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
      push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
      
      my $indexedSetterFunctionName = $indexedSetterOperation-&gt;name || &quot;setItem&quot;;
      my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
      my $functionString = &quot;thisObject-&gt;wrapped().${indexedSetterFunctionName}(${indexExpression}, ${nativeValuePassExpression})&quot;;
<span class="udiff-line-modified-removed">-     $functionString = &quot;propagateException(*state, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($indexedSetterOperation);</span>
<span class="udiff-line-modified-added">+     $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($indexedSetterOperation);</span>
      
      push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
  }
  
  # https://heycam.github.io/webidl/#invoke-named-setter
  sub GenerateInvokeNamedPropertySetter
  {
      my ($outputArray, $indent, $interface, $namedSetterOperation, $value) = @_;
      
      my $argument = @{$namedSetterOperation-&gt;arguments}[1];
<span class="udiff-line-modified-removed">-     my $nativeValue = JSValueToNative($interface, $argument, $value, $namedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;state&quot;, &quot;*state&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);</span>
<span class="udiff-line-modified-added">+     my $nativeValue = JSValueToNative($interface, $argument, $value, $namedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;lexicalGlobalObject&quot;, &quot;*lexicalGlobalObject&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);</span>
      
<span class="udiff-line-modified-removed">-     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);</span>
      push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
      push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
  
      push(@$outputArray, $indent . &quot;bool isPropertySupported = true;\n&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -918,11 +918,11 @@</span>
      push(@arguments, &quot;propertyNameToString(propertyName)&quot;);
      push(@arguments, $nativeValuePassExpression);
      push(@arguments, &quot;isPropertySupported&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
  
      my $functionString = &quot;thisObject-&gt;wrapped().${namedSetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
<span class="udiff-line-modified-removed">-     $functionString = &quot;propagateException(*state, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($namedSetterOperation);</span>
<span class="udiff-line-modified-added">+     $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($namedSetterOperation);</span>
  
      push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
  }
  
  sub GeneratePut
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -932,22 +932,22 @@</span>
      return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
      
      my $namedSetterOperation = GetNamedSetterOperation($interface);
      my $indexedSetterOperation = GetIndexedSetterOperation($interface);
      
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;bool ${className}::put(JSCell* cell, ExecState* state, PropertyName propertyName, JSValue value, PutPropertySlot&amp; putPropertySlot)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;bool ${className}::put(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; putPropertySlot)\n&quot;);</span>
      push(@$outputArray, &quot;{\n&quot;);
      push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
      push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
  
      assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
          &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
      if ($namedSetterOperation) {
<span class="udiff-line-modified-removed">-         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);</span>
<span class="udiff-line-modified-added">+         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*lexicalGlobalObject&quot;);</span>
      }
      if ($indexedSetterOperation) {
<span class="udiff-line-modified-removed">-         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);</span>
<span class="udiff-line-modified-added">+         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*lexicalGlobalObject&quot;);</span>
      }
      
      if ($indexedSetterOperation) {
          push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
          
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -964,19 +964,19 @@</span>
          my $additionalIndent = &quot;&quot;;
          
          my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
          if (!$overrideBuiltins) {
              push(@$outputArray, &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;        JSValue prototype = thisObject-&gt;getPrototypeDirect(state-&gt;vm());\n&quot;);</span>
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;        if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(state, propertyName, slot))) {\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;        JSValue prototype = thisObject-&gt;getPrototypeDirect(JSC::getVM(lexicalGlobalObject));\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;        if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(lexicalGlobalObject, propertyName, slot))) {\n&quot;);</span>
              $additionalIndent .= &quot;    &quot;;
          }
  
          GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
          if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
              push(@$outputArray, $additionalIndent . &quot;        if (!isPropertySupported)\n&quot;);
<span class="udiff-line-modified-removed">-             push(@$outputArray, $additionalIndent . &quot;            return JSObject::put(thisObject, state, propertyName, value, putPropertySlot);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, $additionalIndent . &quot;            return JSObject::put(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot);\n&quot;);</span>
          }
          push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
  
          if (!$overrideBuiltins) {
              push(@$outputArray, &quot;        }\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -988,15 +988,15 @@</span>
      assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
      if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
          AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
  
          push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, state, propertyName, value, putPropertySlot, putResult))\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot, putResult))\n&quot;);</span>
          push(@$outputArray, &quot;        return putResult;\n\n&quot;);
      }
  
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    return JSObject::put(thisObject, state, propertyName, value, putPropertySlot);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    return JSObject::put(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot);\n&quot;);</span>
      push(@$outputArray, &quot;}\n\n&quot;);
  }
  
  sub GeneratePutByIndex
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1008,25 +1008,25 @@</span>
      my $indexedSetterOperation = GetIndexedSetterOperation($interface);
      
      my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
      my $ellidesCallsToBase = ($namedSetterOperation &amp;&amp; $overrideBuiltins) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin} &amp;&amp; !$namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
      
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;bool ${className}::putByIndex(JSCell* cell, ExecState* state, unsigned index, JSValue value, bool&quot; . (!$ellidesCallsToBase ? &quot; shouldThrow&quot; : &quot;&quot;) . &quot;)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;bool ${className}::putByIndex(JSCell* cell, JSGlobalObject* lexicalGlobalObject, unsigned index, JSValue value, bool&quot; . (!$ellidesCallsToBase ? &quot; shouldThrow&quot; : &quot;&quot;) . &quot;)\n&quot;);</span>
      push(@$outputArray, &quot;{\n&quot;);
      if ($namedSetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
      }
      push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
      push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
  
      assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
          &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
      if ($namedSetterOperation) {
<span class="udiff-line-modified-removed">-         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);</span>
<span class="udiff-line-modified-added">+         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*lexicalGlobalObject&quot;);</span>
      }
      if ($indexedSetterOperation) {
<span class="udiff-line-modified-removed">-         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);</span>
<span class="udiff-line-modified-added">+         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*lexicalGlobalObject&quot;);</span>
      }
      
      if ($indexedSetterOperation) {
          push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
          
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1041,18 +1041,18 @@</span>
                  
          my $additionalIndent = &quot;&quot;;
          if (!$overrideBuiltins) {
              push(@$outputArray, &quot;    PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
              push(@$outputArray, &quot;    JSValue prototype = thisObject-&gt;getPrototypeDirect(vm);\n&quot;);
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(state, propertyName, slot))) {\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(lexicalGlobalObject, propertyName, slot))) {\n&quot;);</span>
              $additionalIndent .= &quot;    &quot;;
          }
          
          GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;    &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
          if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
              push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
<span class="udiff-line-modified-removed">-             push(@$outputArray, $additionalIndent . &quot;        return JSObject::putByIndex(cell, state, index, value, shouldThrow);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, $additionalIndent . &quot;        return JSObject::putByIndex(cell, lexicalGlobalObject, index, value, shouldThrow);\n&quot;);</span>
          }
          push(@$outputArray, $additionalIndent . &quot;    return true;\n&quot;);
          
          if (!$overrideBuiltins) {
              push(@$outputArray, &quot;    }\n\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1063,16 +1063,16 @@</span>
      if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
          AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
          push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
          push(@$outputArray, &quot;    PutPropertySlot putPropertySlot(thisObject, shouldThrow);\n&quot;);
          push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, state, propertyName, value, putPropertySlot, putResult))\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot, putResult))\n&quot;);</span>
          push(@$outputArray, &quot;        return putResult;\n\n&quot;);
      }
  
      if (!$ellidesCallsToBase) {
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    return JSObject::putByIndex(cell, state, index, value, shouldThrow);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    return JSObject::putByIndex(cell, lexicalGlobalObject, index, value, shouldThrow);\n&quot;);</span>
      }
      
      push(@$outputArray, &quot;}\n\n&quot;);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1111,22 +1111,22 @@</span>
      my $namedSetterOperation = GetNamedSetterOperation($interface);
      my $indexedSetterOperation = GetIndexedSetterOperation($interface);
      
      return if !$namedSetterOperation &amp;&amp; !$indexedSetterOperation;
      
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;bool ${className}::defineOwnProperty(JSObject* object, ExecState* state, PropertyName propertyName, const PropertyDescriptor&amp; propertyDescriptor, bool shouldThrow)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;bool ${className}::defineOwnProperty(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, const PropertyDescriptor&amp; propertyDescriptor, bool shouldThrow)\n&quot;);</span>
      push(@$outputArray, &quot;{\n&quot;);
      push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
      push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
  
      assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
          &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
      if ($namedSetterOperation) {
<span class="udiff-line-modified-removed">-         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);</span>
<span class="udiff-line-modified-added">+         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*lexicalGlobalObject&quot;);</span>
      }
      if ($indexedSetterOperation) {
<span class="udiff-line-modified-removed">-         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);</span>
<span class="udiff-line-modified-added">+         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*lexicalGlobalObject&quot;);</span>
      }
      
      # 1. If O supports indexed properties and P is an array index property name, then:
      if (GetIndexedGetterOperation($interface)) {
          # NOTE: The numbers are out of order because there is no reason doing steps 1, 3, and 4 if there
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1150,13 +1150,13 @@</span>
              push(@$outputArray, &quot;        return true;\n&quot;);
              push(@$outputArray, &quot;    }\n\n&quot;);
          }
      }
      
<span class="udiff-line-modified-removed">-     # 2. If O supports named properties, O does not implement an interface with the [Global] or [PrimaryGlobal]</span>
<span class="udiff-line-modified-added">+     # 2. If O supports named properties, O does not implement an interface with the [Global]</span>
      #    extended attribute and P is not an unforgeable property name of O, then:
<span class="udiff-line-modified-removed">-     if (GetNamedGetterOperation($interface) &amp;&amp; !IsGlobalOrPrimaryGlobalInterface($interface)) {</span>
<span class="udiff-line-modified-added">+     if (GetNamedGetterOperation($interface) &amp;&amp; !IsGlobalInterface($interface)) {</span>
          # FIMXE: We need a more comprehensive story for Symbols.
          push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
          
          my $additionalIndent = &quot;&quot;;
          
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1175,11 +1175,11 @@</span>
          if (!$overrideBuiltins) {
              # FIXME: Is JSObject::getOwnPropertySlot the right function to call? Is there a function that will
              #        only look at the actual properties, and not call into our implementation of the
              #        [[GetOwnProperty]] hook?
              push(@$outputArray, $additionalIndent. &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
<span class="udiff-line-modified-removed">-             push(@$outputArray, $additionalIndent. &quot;        if (!JSObject::getOwnPropertySlot(thisObject, state, propertyName, slot)) {\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, $additionalIndent. &quot;        if (!JSObject::getOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot)) {\n&quot;);</span>
              $additionalIndent .= &quot;    &quot;;
          }
          if (!$namedSetterOperation) {
              # 2.1. If creating is false and O does not implement an interface with a named property setter, then return false.
              push(@$outputArray, $additionalIndent . &quot;        if (thisObject-&gt;wrapped().isSupportedPropertyName(propertyNameToString(propertyName)))\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1193,11 +1193,11 @@</span>
              
              # 2.2.2. Invoke the named property setter with P and Desc.[[Value]].
              GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;propertyDescriptor.value()&quot;);
              if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
                  push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
<span class="udiff-line-modified-removed">-                 push(@$outputArray, $additionalIndent . &quot;        return JSObject::defineOwnProperty(object, state, propertyName, propertyDescriptor, shouldThrow);\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@$outputArray, $additionalIndent . &quot;        return JSObject::defineOwnProperty(object, lexicalGlobalObject, propertyName, propertyDescriptor, shouldThrow);\n&quot;);</span>
              }
              # 2.2.3. Return true.
              push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
          }
          
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1213,19 +1213,19 @@</span>
          push(@$outputArray, &quot;    }\n\n&quot;);
      }
      
      push(@$outputArray, &quot;    PropertyDescriptor newPropertyDescriptor = propertyDescriptor;\n&quot;);
          
<span class="udiff-line-modified-removed">-     # 3. If O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute,</span>
<span class="udiff-line-modified-added">+     # 3. If O does not implement an interface with the [Global] extended attribute,</span>
      #    then set Desc.[[Configurable]] to true.
<span class="udiff-line-modified-removed">-     if (!IsGlobalOrPrimaryGlobalInterface($interface)) {</span>
<span class="udiff-line-modified-added">+     if (!IsGlobalInterface($interface)) {</span>
          push(@$outputArray, &quot;    newPropertyDescriptor.setConfigurable(true);\n&quot;);
      }
      
      # 4. Return OrdinaryDefineOwnProperty(O, P, Desc).
      # FIXME: Does this do the same thing?
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    return JSObject::defineOwnProperty(object, state, propertyName, newPropertyDescriptor, shouldThrow);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    return JSObject::defineOwnProperty(object, lexicalGlobalObject, propertyName, newPropertyDescriptor, shouldThrow);\n&quot;);</span>
      
      push(@$outputArray, &quot;}\n\n&quot;);
  }
  
  sub GenerateDeletePropertyCommon
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1234,21 +1234,20 @@</span>
      
      # This implements step 2 of https://heycam.github.io/webidl/#legacy-platform-object-delete
      # so it can be shared between the generation of deleteProperty and deletePropertyByIndex.
  
      # 2. If O supports named properties, O does not implement an interface with the
<span class="udiff-line-modified-removed">-     #    [Global] or [PrimaryGlobal] extended attribute and the result of calling the</span>
<span class="udiff-line-modified-removed">-     #    named property visibility algorithm with property name P and object O is true,</span>
<span class="udiff-line-removed">-     #    then:</span>
<span class="udiff-line-modified-added">+     #    [Global] extended attribute and the result of calling the named</span>
<span class="udiff-line-modified-added">+     #    property visibility algorithm with property name P and object O is true, then:</span>
      assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
<span class="udiff-line-modified-removed">-     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalOrPrimaryGlobalInterface($interface);</span>
<span class="udiff-line-modified-added">+     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalInterface($interface);</span>
  
      AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;, $conditional);
      my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    if (isVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*state, thisObject, propertyName)) {\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    if (isVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*lexicalGlobalObject, thisObject, propertyName)) {\n&quot;);</span>
  
<span class="udiff-line-modified-removed">-     GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*state&quot;);</span>
<span class="udiff-line-modified-added">+     GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*lexicalGlobalObject&quot;);</span>
  
      # 2.1. If O does not implement an interface with a named property deleter, then return false.
      # 2.2. Let operation be the operation used to declare the named property deleter.
      # NOTE: We only add a deleteProperty implementation of we have a named property deleter.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1271,12 +1270,12 @@</span>
      #       boolean, we return that value, otherwise it is ignored (as per section 4.2).
  
      if ($operation-&gt;extendedAttributes-&gt;{MayThrowException}) {
          push(@$outputArray, &quot;        auto result = ${functionCall};\n&quot;);
          push(@$outputArray, &quot;        if (result.hasException()) {\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;            auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);</span>
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;            propagateException(*state, throwScope, result.releaseException());\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;            auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;            propagateException(*lexicalGlobalObject, throwScope, result.releaseException());\n&quot;);</span>
          push(@$outputArray, &quot;            return true;\n&quot;);
          push(@$outputArray, &quot;        }\n\n&quot;);
  
          if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
              push(@$outputArray, &quot;        return result.releaseReturnValue();\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1300,11 +1299,11 @@</span>
      my ($outputArray, $interface, $className, $operation, $conditional) = @_;
  
      # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
      # for the deleteProperty override hook.
  
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;bool ${className}::deleteProperty(JSCell* cell, ExecState* state, PropertyName propertyName)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;bool ${className}::deleteProperty(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName)\n&quot;);</span>
      push(@$outputArray, &quot;{\n&quot;);
  
      push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
      push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1320,22 +1319,22 @@</span>
      # GenerateDeletePropertyCommon implements step 2.
      GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
  
      # FIXME: Instead of calling down JSObject::deleteProperty, perhaps we should implement
      # the remained of the algorithm ourselves.
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    return JSObject::deleteProperty(cell, state, propertyName);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    return JSObject::deleteProperty(cell, lexicalGlobalObject, propertyName);\n&quot;);</span>
      push(@$outputArray, &quot;}\n\n&quot;);
  }
  
  sub GenerateDeletePropertyByIndex
  {
      my ($outputArray, $interface, $className, $operation, $conditional) = @_;
  
      # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
      # for the deletePropertyByIndex override hook.
  
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;bool ${className}::deletePropertyByIndex(JSCell* cell, ExecState* state, unsigned index)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;bool ${className}::deletePropertyByIndex(JSCell* cell, JSGlobalObject* lexicalGlobalObject, unsigned index)\n&quot;);</span>
      push(@$outputArray, &quot;{\n&quot;);
  
      push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
      push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1348,11 +1347,11 @@</span>
      #       is all that needs to be done, no need to generate the .
  
      if (GetIndexedGetterOperation($interface)) {
          push(@$outputArray, &quot;    return !impl.isSupportedPropertyIndex(index);\n&quot;);
      } else {
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
          push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
  
          # GenerateDeletePropertyCommon implements step 2.
          GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1362,11 +1361,11 @@</span>
          # 3. If O has an own property with name P, then:
          #    1. If the property is not configurable, then return false.
          #    2. Otherwise, remove the property from O.
          # 3. Return true.
          
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    return JSObject::deletePropertyByIndex(cell, state, index);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    return JSObject::deletePropertyByIndex(cell, lexicalGlobalObject, index);\n&quot;);</span>
      }
  
      push(@$outputArray, &quot;}\n\n&quot;);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1381,11 +1380,11 @@</span>
      
      # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete using
      # the deleteProperty and deletePropertyByIndex override hooks.
  
      assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
<span class="udiff-line-modified-removed">-     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalOrPrimaryGlobalInterface($interface);</span>
<span class="udiff-line-modified-added">+     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalInterface($interface);</span>
  
      my $conditional = $namedDeleterOperation-&gt;extendedAttributes-&gt;{Conditional};
      if ($conditional) {
          my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
          push(@$outputArray, &quot;#if ${conditionalString}\n\n&quot;);;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1505,31 +1504,31 @@</span>
      my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
      my $typeName = GetTypeNameForDisplayInException($argument-&gt;type);
  
      if ($codeGenerator-&gt;IsCallbackInterface($argument-&gt;type) || $codeGenerator-&gt;IsCallbackFunction($argument-&gt;type)) {
          # FIXME: We should have specialized messages for callback interfaces vs. callback functions.
<span class="udiff-line-modified-removed">-         return &quot;throwArgumentMustBeFunctionError(state, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName});&quot;;</span>
<span class="udiff-line-modified-added">+         return &quot;throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName});&quot;;</span>
      }
  
      if ($codeGenerator-&gt;IsWrapperType($argument-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($argument-&gt;type)) {
<span class="udiff-line-modified-removed">-         return &quot;throwArgumentTypeError(state, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, \&quot;${typeName}\&quot;);&quot;;</span>
<span class="udiff-line-modified-added">+         return &quot;throwArgumentTypeError(lexicalGlobalObject, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, \&quot;${typeName}\&quot;);&quot;;</span>
      }
  
      if ($codeGenerator-&gt;IsEnumType($argument-&gt;type)) {
          my $className = GetEnumerationClassName($argument-&gt;type, $interface);
<span class="udiff-line-modified-removed">-         return &quot;throwArgumentMustBeEnumError(state, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, expectedEnumerationValues&lt;${className}&gt;());&quot;;</span>
<span class="udiff-line-modified-added">+         return &quot;throwArgumentMustBeEnumError(lexicalGlobalObject, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, expectedEnumerationValues&lt;${className}&gt;());&quot;;</span>
      }
  
      return undef;
  }
  
  sub GetArgumentExceptionThrower
  {
      my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
  
      my $functionCall = GetArgumentExceptionFunction($interface, $argument, $argumentIndex, $quotedFunctionName);
<span class="udiff-line-modified-removed">-     return &quot;[](JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;</span>
<span class="udiff-line-modified-added">+     return &quot;[](JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;</span>
  }
  
  sub GetAttributeExceptionFunction
  {
      my ($interface, $attribute) = @_;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1537,20 +1536,20 @@</span>
      my $name = $attribute-&gt;name;
      my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
      my $typeName = GetTypeNameForDisplayInException($attribute-&gt;type);
  
      if ($codeGenerator-&gt;IsWrapperType($attribute-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($attribute-&gt;type)) {
<span class="udiff-line-modified-removed">-         return &quot;throwAttributeTypeError(state, scope, \&quot;${visibleInterfaceName}\&quot;, \&quot;${name}\&quot;, \&quot;${typeName}\&quot;);&quot;;</span>
<span class="udiff-line-modified-added">+         return &quot;throwAttributeTypeError(lexicalGlobalObject, scope, \&quot;${visibleInterfaceName}\&quot;, \&quot;${name}\&quot;, \&quot;${typeName}\&quot;);&quot;;</span>
      }
  }
  
  sub GetAttributeExceptionThrower
  {
      my ($interface, $attribute) = @_;
  
      my $functionCall = GetAttributeExceptionFunction($interface, $attribute);
<span class="udiff-line-modified-removed">-     return &quot;[](JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;</span>
<span class="udiff-line-modified-added">+     return &quot;[](JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;</span>
  
  }
  
  sub PassArgumentExpression
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1617,23 +1616,30 @@</span>
      
      if ($property-&gt;isMapLike) {
          return &quot;forward&quot; . $codeGenerator-&gt;WK_ucfirst($property-&gt;name) . &quot;ToMapLike&quot;;
      }
      
<span class="udiff-line-added">+     if ($property-&gt;isSetLike) {</span>
<span class="udiff-line-added">+         return &quot;forward&quot; . $codeGenerator-&gt;WK_ucfirst($property-&gt;name) . &quot;ToSetLike&quot;;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      return &quot;${implExpression}.${implementationName}&quot;;
  }
  
  sub AddAdditionalArgumentsForImplementationCall
  {
<span class="udiff-line-modified-removed">-     my ($arguments, $interface, $property, $implExpression, $stateExpression, $thisObjectExpression) = @_;</span>
<span class="udiff-line-modified-added">+     my ($arguments, $interface, $property, $implExpression, $globalObject, $callFrame, $thisObjectExpression) = @_;</span>
      
      if ($property-&gt;extendedAttributes-&gt;{ImplementedBy} &amp;&amp; !$property-&gt;isStatic) {
          unshift(@$arguments, $implExpression);
      }
      
<span class="udiff-line-modified-removed">-     if ($property-&gt;isMapLike) {</span>
<span class="udiff-line-modified-removed">-         push(@$arguments, $stateExpression);</span>
<span class="udiff-line-modified-added">+     if ($property-&gt;isMapLike or $property-&gt;isSetLike) {</span>
<span class="udiff-line-modified-added">+         push(@$arguments, $globalObject);</span>
<span class="udiff-line-added">+         if (ref($property) eq &quot;IDLOperation&quot;) {</span>
<span class="udiff-line-added">+             push(@$arguments, $callFrame);</span>
<span class="udiff-line-added">+         }</span>
          push(@$arguments, $thisObjectExpression);
      }
  }
  
  sub GetSpecialAccessorOperationForType
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1650,23 +1656,23 @@</span>
      }
  
      return 0;
  }
  
<span class="udiff-line-modified-removed">- sub IsGlobalOrPrimaryGlobalInterface</span>
<span class="udiff-line-modified-added">+ sub IsGlobalInterface</span>
  {
      my $interface = shift;
  
<span class="udiff-line-modified-removed">-     return $interface-&gt;extendedAttributes-&gt;{Global} || $interface-&gt;extendedAttributes-&gt;{PrimaryGlobal};</span>
<span class="udiff-line-modified-added">+     return $interface-&gt;extendedAttributes-&gt;{Global};</span>
  }
  
  sub AttributeShouldBeOnInstance
  {
      my $interface = shift;
      my $attribute = shift;
  
<span class="udiff-line-modified-removed">-     return 1 if IsGlobalOrPrimaryGlobalInterface($interface);</span>
<span class="udiff-line-modified-added">+     return 1 if IsGlobalInterface($interface);</span>
      return 1 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
  
      # [Unforgeable] attributes should be on the instance.
      # https://heycam.github.io/webidl/#Unforgeable
      return 1 if IsUnforgeable($interface, $attribute);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1727,11 +1733,11 @@</span>
  # https://heycam.github.io/webidl/#es-operations
  sub OperationShouldBeOnInstance
  {
      my ($interface, $operation) = @_;
  
<span class="udiff-line-modified-removed">-     return 1 if IsGlobalOrPrimaryGlobalInterface($interface);</span>
<span class="udiff-line-modified-added">+     return 1 if IsGlobalInterface($interface);</span>
  
      # [Unforgeable] operations should be on the instance. https://heycam.github.io/webidl/#Unforgeable
      if (IsUnforgeable($interface, $operation)) {
          assert(&quot;The bindings generator does not support putting runtime-enabled operations on the instance yet (except for global objects):[&quot; . $interface-&gt;type-&gt;name . &quot;::&quot; . $operation-&gt;name . &quot;]&quot;) if NeedsRuntimeCheck($interface, $operation);
          return 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1762,10 +1768,11 @@</span>
      return 0 if $interface-&gt;extendedAttributes-&gt;{ImplicitThis};
      return 0 if $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject};
  
      return 0 if $attribute-&gt;isStatic;
      return 0 if $attribute-&gt;isMapLike;
<span class="udiff-line-added">+     return 0 if $attribute-&gt;isSetLike;</span>
      return 0 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
      return 0 if IsJSBuiltin($interface, $attribute);
      return 0 if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
      return 0 if $codeGenerator-&gt;IsPromiseType($attribute-&gt;type);
      return 0 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1842,10 +1849,11 @@</span>
          $count++ if !$operation-&gt;isStatic &amp;&amp; !OperationShouldBeOnInstance($interface, $operation);
      }
  
      $count += scalar @{$interface-&gt;iterable-&gt;operations} if $interface-&gt;iterable;
      $count += scalar @{$interface-&gt;mapLike-&gt;operations} if $interface-&gt;mapLike;
<span class="udiff-line-added">+     $count += scalar @{$interface-&gt;setLike-&gt;operations} if $interface-&gt;setLike;</span>
      $count += scalar @{$interface-&gt;serializable-&gt;operations} if $interface-&gt;serializable;
  
      return $count;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2091,22 +2099,22 @@</span>
      $result .= &quot;    ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));\n&quot;;
      $result .= &quot;    return values[static_cast&lt;size_t&gt;(enumerationValue)];\n&quot;;
      $result .= &quot;}\n\n&quot;;
  
  
<span class="udiff-line-modified-removed">-     # FIXME: Change to take VM&amp; instead of ExecState*.</span>
<span class="udiff-line-modified-removed">-     $result .= &quot;template&lt;&gt; JSString* convertEnumerationToJS(ExecState&amp; state, $className enumerationValue)\n&quot;;</span>
<span class="udiff-line-modified-added">+     # FIXME: Change to take VM&amp; instead of JSGlobalObject*.</span>
<span class="udiff-line-modified-added">+     $result .= &quot;template&lt;&gt; JSString* convertEnumerationToJS(JSGlobalObject&amp; lexicalGlobalObject, $className enumerationValue)\n&quot;;</span>
      $result .= &quot;{\n&quot;;
<span class="udiff-line-modified-removed">-     $result .= &quot;    return jsStringWithCache(&amp;state, convertEnumerationToString(enumerationValue));\n&quot;;</span>
<span class="udiff-line-modified-added">+     $result .= &quot;    return jsStringWithCache(&amp;lexicalGlobalObject, convertEnumerationToString(enumerationValue));\n&quot;;</span>
      $result .= &quot;}\n\n&quot;;
  
<span class="udiff-line-modified-removed">-     # FIXME: Change to take VM&amp; instead of ExecState&amp;.</span>
<span class="udiff-line-modified-added">+     # FIXME: Change to take VM&amp; instead of JSGlobalObject&amp;.</span>
      # FIXME: Consider using toStringOrNull to make exception checking faster.
      # FIXME: Consider finding a more efficient way to match against all the strings quickly.
<span class="udiff-line-modified-removed">-     $result .= &quot;template&lt;&gt; Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(ExecState&amp; state, JSValue value)\n&quot;;</span>
<span class="udiff-line-modified-added">+     $result .= &quot;template&lt;&gt; Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)\n&quot;;</span>
      $result .= &quot;{\n&quot;;
<span class="udiff-line-modified-removed">-     $result .= &quot;    auto stringValue = value.toWTFString(&amp;state);\n&quot;;</span>
<span class="udiff-line-modified-added">+     $result .= &quot;    auto stringValue = value.toWTFString(&amp;lexicalGlobalObject);\n&quot;;</span>
      foreach my $value (@{$enumeration-&gt;values}) {
          my $enumerationValueName = GetEnumerationValueName($value);
          if ($value eq &quot;&quot;) {
              $result .= &quot;    if (stringValue.isEmpty())\n&quot;;
          } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2152,12 +2160,12 @@</span>
      $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
  
      my $exportMacro = GetExportMacroForJSClass($enumeration);
  
      $result .= &quot;${exportMacro}String convertEnumerationToString($className);\n&quot;;
<span class="udiff-line-modified-removed">-     $result .= &quot;template&lt;&gt; ${exportMacro}JSC::JSString* convertEnumerationToJS(JSC::ExecState&amp;, $className);\n\n&quot;;</span>
<span class="udiff-line-modified-removed">-     $result .= &quot;template&lt;&gt; ${exportMacro}Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(JSC::ExecState&amp;, JSC::JSValue);\n&quot;;</span>
<span class="udiff-line-modified-added">+     $result .= &quot;template&lt;&gt; ${exportMacro}JSC::JSString* convertEnumerationToJS(JSC::JSGlobalObject&amp;, $className);\n\n&quot;;</span>
<span class="udiff-line-modified-added">+     $result .= &quot;template&lt;&gt; ${exportMacro}Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(JSC::JSGlobalObject&amp;, JSC::JSValue);\n&quot;;</span>
      $result .= &quot;template&lt;&gt; ${exportMacro}const char* expectedEnumerationValues&lt;$className&gt;();\n\n&quot;;
      $result .= &quot;#endif\n\n&quot; if $conditionalString;
      
      return $result;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2223,11 +2231,11 @@</span>
      if ($defaultValue eq &quot;null&quot;) {
          if ($type-&gt;isUnion) {
              return &quot;WTF::nullopt&quot; if $type-&gt;isNullable;
  
              my $IDLType = GetIDLType($typeScope, $type);
<span class="udiff-line-modified-removed">-             return &quot;convert&lt;${IDLType}&gt;(state, jsNull());&quot;;</span>
<span class="udiff-line-modified-added">+             return &quot;convert&lt;${IDLType}&gt;(lexicalGlobalObject, jsNull());&quot;;</span>
          }
  
          return &quot;jsNull()&quot; if $type-&gt;name eq &quot;any&quot;;
          return &quot;nullptr&quot; if $codeGenerator-&gt;IsWrapperType($type) || $codeGenerator-&gt;IsBufferSourceType($type);
          return &quot;String()&quot; if $codeGenerator-&gt;IsStringType($type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2253,14 +2261,14 @@</span>
  
      my $exportMacro = GetExportMacroForJSClass($dictionary);
  
      my $result = &quot;&quot;;
      $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
<span class="udiff-line-modified-removed">-     $result .= &quot;template&lt;&gt; ${exportMacro}${className} convertDictionary&lt;${className}&gt;(JSC::ExecState&amp;, JSC::JSValue);\n\n&quot;;</span>
<span class="udiff-line-modified-added">+     $result .= &quot;template&lt;&gt; ${exportMacro}${className} convertDictionary&lt;${className}&gt;(JSC::JSGlobalObject&amp;, JSC::JSValue);\n\n&quot;;</span>
  
      if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
<span class="udiff-line-modified-removed">-         $result .= &quot;${exportMacro}JSC::JSObject* convertDictionaryToJS(JSC::ExecState&amp;, JSDOMGlobalObject&amp;, const ${className}&amp;);\n\n&quot;;</span>
<span class="udiff-line-modified-added">+         $result .= &quot;${exportMacro}JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject&amp;, JSDOMGlobalObject&amp;, const ${className}&amp;);\n\n&quot;;</span>
      }
  
      $result .= &quot;#endif\n\n&quot; if $conditionalString;
      return $result;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2299,20 +2307,20 @@</span>
      # FIXME: A little ugly to have this be a side effect instead of a return value.
      AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
      AddToImplIncludes(&quot;JSDOMConvertDictionary.h&quot;);
  
      # https://heycam.github.io/webidl/#es-dictionary
<span class="udiff-line-modified-removed">-     $result .= &quot;template&lt;&gt; $className convertDictionary&lt;$className&gt;(ExecState&amp; state, JSValue value)\n&quot;;</span>
<span class="udiff-line-modified-added">+     $result .= &quot;template&lt;&gt; $className convertDictionary&lt;$className&gt;(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)\n&quot;;</span>
      $result .= &quot;{\n&quot;;
<span class="udiff-line-modified-removed">-     $result .= &quot;    VM&amp; vm = state.vm();\n&quot;;</span>
<span class="udiff-line-modified-added">+     $result .= &quot;    VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n&quot;;</span>
      $result .= &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;;
      $result .= &quot;    bool isNullOrUndefined = value.isUndefinedOrNull();\n&quot;;
      $result .= &quot;    auto* object = isNullOrUndefined ? nullptr : value.getObject();\n&quot;;
  
      # 1. If Type(V) is not Undefined, Null or Object, then throw a TypeError.
      $result .= &quot;    if (UNLIKELY(!isNullOrUndefined &amp;&amp; !object)) {\n&quot;;
<span class="udiff-line-modified-removed">-     $result .= &quot;        throwTypeError(&amp;state, throwScope);\n&quot;;</span>
<span class="udiff-line-modified-added">+     $result .= &quot;        throwTypeError(&amp;lexicalGlobalObject, throwScope);\n&quot;;</span>
      $result .= &quot;        return { };\n&quot;;
      $result .= &quot;    }\n&quot;;
  
      # 2. Let dict be an empty dictionary value of type D; every dictionary member is initially considered to be not present.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2355,20 +2363,20 @@</span>
              # 4.2. Let value be an ECMAScript value, depending on Type(V):
              $result .= &quot;    JSValue ${key}Value;\n&quot;;
              $result .= &quot;    if (isNullOrUndefined)\n&quot;;
              $result .= &quot;        ${key}Value = jsUndefined();\n&quot;;
              $result .= &quot;    else {\n&quot;;
<span class="udiff-line-modified-removed">-             $result .= &quot;        ${key}Value = object-&gt;get(&amp;state, Identifier::fromString(vm, \&quot;${key}\&quot;));\n&quot;;</span>
<span class="udiff-line-modified-added">+             $result .= &quot;        ${key}Value = object-&gt;get(&amp;lexicalGlobalObject, Identifier::fromString(vm, \&quot;${key}\&quot;));\n&quot;;</span>
              $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
              $result .= &quot;    }\n&quot;;
  
              my $IDLType = GetIDLType($typeScope, $type);
  
              # 4.3. If value is not undefined, then:
              $result .= &quot;    if (!${key}Value.isUndefined()) {\n&quot;;
  
<span class="udiff-line-modified-removed">-             my $nativeValue = JSValueToNative($typeScope, $member, &quot;${key}Value&quot;, $member-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;state&quot;, &quot;state&quot;, &quot;&quot;, &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot;);</span>
<span class="udiff-line-modified-added">+             my $nativeValue = JSValueToNative($typeScope, $member, &quot;${key}Value&quot;, $member-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;lexicalGlobalObject&quot;, &quot;lexicalGlobalObject&quot;, &quot;&quot;, &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)&quot;);</span>
              $result .= &quot;        result.$implementedAsKey = $nativeValue;\n&quot;;
              $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
  
              # Value is undefined.
              # 4.4. Otherwise, if value is undefined but the dictionary member has a default value, then:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2376,11 +2384,11 @@</span>
                  $result .= &quot;    } else\n&quot;;
                  $result .= &quot;        result.$implementedAsKey = &quot; . GenerateDefaultValue($typeScope, $member, $member-&gt;type, $member-&gt;default) . &quot;;\n&quot;;
              } elsif ($member-&gt;isRequired) {
                  # 4.5. Otherwise, if value is undefined and the dictionary member is a required dictionary member, then throw a TypeError.
                  $result .= &quot;    } else {\n&quot;;
<span class="udiff-line-modified-removed">-                 $result .= &quot;        throwRequiredMemberTypeError(state, throwScope, \&quot;&quot;. $member-&gt;name .&quot;\&quot;, \&quot;$name\&quot;, \&quot;&quot;. GetTypeNameForDisplayInException($type) .&quot;\&quot;);\n&quot;;</span>
<span class="udiff-line-modified-added">+                 $result .= &quot;        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, \&quot;&quot;. $member-&gt;name .&quot;\&quot;, \&quot;$name\&quot;, \&quot;&quot;. GetTypeNameForDisplayInException($type) .&quot;\&quot;);\n&quot;;</span>
                  $result .= &quot;        return { };\n&quot;;
                  $result .= &quot;    }\n&quot;;
              } else {
                  $result .= &quot;    }\n&quot;;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2395,16 +2403,16 @@</span>
  
      if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
          AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;);
          AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
  
<span class="udiff-line-modified-removed">-         $result .= &quot;JSC::JSObject* convertDictionaryToJS(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const ${className}&amp; dictionary)\n&quot;;</span>
<span class="udiff-line-modified-added">+         $result .= &quot;JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const ${className}&amp; dictionary)\n&quot;;</span>
          $result .= &quot;{\n&quot;;
<span class="udiff-line-modified-removed">-         $result .= &quot;    auto&amp; vm = state.vm();\n\n&quot;;</span>
<span class="udiff-line-modified-added">+         $result .= &quot;    auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n\n&quot;;</span>
  
          # 1. Let O be ! ObjectCreate(%ObjectPrototype%).
<span class="udiff-line-modified-removed">-         $result .= &quot;    auto result = constructEmptyObject(&amp;state, globalObject.objectPrototype());\n\n&quot;;</span>
<span class="udiff-line-modified-added">+         $result .= &quot;    auto result = constructEmptyObject(&amp;lexicalGlobalObject, globalObject.objectPrototype());\n\n&quot;;</span>
  
          # 2. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries,
          #    in order from least to most derived.
          #    NOTE: This was done above.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2430,11 +2438,11 @@</span>
                      # 3. Perform ! CreateDataProperty(O, key, value).
  
                  my $needsRuntimeCheck = NeedsRuntimeCheck($dictionary, $member);
                  my $indent = &quot;&quot;;
                  if ($needsRuntimeCheck) {
<span class="udiff-line-modified-removed">-                     my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($dictionary, $member, &quot;true&quot;);</span>
<span class="udiff-line-modified-added">+                     my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($dictionary, $member, &quot;&amp;globalObject&quot;);</span>
                      $result .= &quot;    if (${runtimeEnableConditionalString}) {\n&quot;;
                      $indent = &quot;    &quot;;
                  }
  
                  if (!$member-&gt;isRequired &amp;&amp; not defined $member-&gt;default) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2612,12 +2620,10 @@</span>
          push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
          push(@headerContent, &quot;        return ptr;\n&quot;);
          push(@headerContent, &quot;    }\n\n&quot;);
      }
  
<span class="udiff-line-removed">-     push(@headerContent, &quot;    static const bool needsDestruction = false;\n\n&quot;) if IsDOMGlobalObject($interface);</span>
<span class="udiff-line-removed">- </span>
      $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1 if InstancePropertyCount($interface) &gt; 0;
      $structureFlags{&quot;JSC::NewImpurePropertyFiresWatchpoints&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{NewImpurePropertyFiresWatchpoints};
      $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObject};
      $structureFlags{&quot;JSC::MasqueradesAsUndefined&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined};
      $structureFlags{&quot;JSC::ImplementsHasInstance | JSC::ImplementsDefaultHasInstance&quot;} = 1 if $interfaceName eq &quot;DOMWindow&quot;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2631,11 +2637,11 @@</span>
      # JSValue to implementation type
      if (ShouldGenerateToWrapped($hasParent, $interface)) {
          # FIXME: Add extended attribute for this.
          my @toWrappedArguments = ();
          push(@toWrappedArguments, &quot;JSC::VM&amp;&quot;);
<span class="udiff-line-modified-removed">-         push(@toWrappedArguments, &quot;JSC::ExecState&amp;&quot;) if $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot;;</span>
<span class="udiff-line-modified-added">+         push(@toWrappedArguments, &quot;JSC::JSGlobalObject&amp;&quot;) if $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot;;</span>
          push(@toWrappedArguments, &quot;JSC::JSValue&quot;);
  
          my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
  
          my $export = &quot;&quot;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2658,56 +2664,60 @@</span>
      }
      
      # ClassInfo MethodTable declarations.
      
      if (InstanceOverridesGetOwnPropertySlot($interface)) {
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static bool getOwnPropertySlot(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, JSC::PropertySlot&amp;);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static bool getOwnPropertySlot(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::PropertySlot&amp;);\n&quot;);</span>
          $structureFlags{&quot;JSC::OverridesGetOwnPropertySlot&quot;} = 1;
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static bool getOwnPropertySlotByIndex(JSC::JSObject*, JSC::ExecState*, unsigned propertyName, JSC::PropertySlot&amp;);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static bool getOwnPropertySlotByIndex(JSC::JSObject*, JSC::JSGlobalObject*, unsigned propertyName, JSC::PropertySlot&amp;);\n&quot;);</span>
          $structureFlags{&quot;JSC::InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero&quot;} = 1;
      }
  
      if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static void doPutPropertySecurityCheck(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, JSC::PutPropertySlot&amp;);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static void doPutPropertySecurityCheck(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::PutPropertySlot&amp;);\n&quot;);</span>
          $structureFlags{&quot;JSC::HasPutPropertySecurityCheck&quot;} = 1;
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if ($interface-&gt;extendedAttributes-&gt;{Plugin} || GetNamedSetterOperation($interface)) {</span>
<span class="udiff-line-added">+         $structureFlags{&quot;JSC::ProhibitsPropertyCaching&quot;} = 1;</span>
<span class="udiff-line-added">+     }</span>
      
      if (InstanceOverridesGetOwnPropertyNames($interface)) {
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static void getOwnPropertyNames(JSC::JSObject*, JSC::ExecState*, JSC::PropertyNameArray&amp;, JSC::EnumerationMode = JSC::EnumerationMode());\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static void getOwnPropertyNames(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyNameArray&amp;, JSC::EnumerationMode = JSC::EnumerationMode());\n&quot;);</span>
          $structureFlags{&quot;JSC::OverridesGetPropertyNames&quot;} = 1;
      }
      
      if (InstanceOverridesPut($interface)) {
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static bool put(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);</span>
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static bool putByIndex(JSC::JSCell*, JSC::ExecState*, unsigned propertyName, JSC::JSValue, bool shouldThrow);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static bool put(JSC::JSCell*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static bool putByIndex(JSC::JSCell*, JSC::JSGlobalObject*, unsigned propertyName, JSC::JSValue, bool shouldThrow);\n&quot;);</span>
      }
      
      if (InstanceOverridesDefineOwnProperty($interface)) {
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);</span>
      }
  
      if (InstanceOverridesDeleteProperty($interface)) {
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static bool deleteProperty(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName);\n&quot;);</span>
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static bool deletePropertyByIndex(JSC::JSCell*, JSC::ExecState*, unsigned);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static bool deleteProperty(JSC::JSCell*, JSC::JSGlobalObject*, JSC::PropertyName);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static bool deletePropertyByIndex(JSC::JSCell*, JSC::JSGlobalObject*, unsigned);\n&quot;);</span>
      }
  
      if (InstanceOverridesGetCallData($interface)) {
          push(@headerContent, &quot;    static JSC::CallType getCallData(JSC::JSCell*, JSC::CallData&amp;);\n\n&quot;);
          $headerIncludes{&quot;&lt;JavaScriptCore/CallData.h&gt;&quot;} = 1;
          $structureFlags{&quot;JSC::OverridesGetCallData&quot;} = 1;
      }
      
      if ($interface-&gt;extendedAttributes-&gt;{CustomGetPrototype}) {
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static JSC::JSValue getPrototype(JSC::JSObject*, JSC::ExecState*);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static JSC::JSValue getPrototype(JSC::JSObject*, JSC::JSGlobalObject*);\n&quot;);</span>
      }
      
      if ($interface-&gt;extendedAttributes-&gt;{CustomToStringName}) {
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static String toStringName(const JSC::JSObject*, JSC::ExecState*);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static String toStringName(const JSC::JSObject*, JSC::JSGlobalObject*);\n&quot;);</span>
      }
      
      if ($interface-&gt;extendedAttributes-&gt;{CustomPreventExtensions}) {
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static bool preventExtensions(JSC::JSObject*, JSC::ExecState*);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static bool preventExtensions(JSC::JSObject*, JSC::JSGlobalObject*);\n&quot;);</span>
      }
  
      if (InstanceNeedsEstimatedSize($interface)) {
          push(@headerContent, &quot;    static size_t estimatedSize(JSCell*, JSC::VM&amp;);\n&quot;);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2743,22 +2753,22 @@</span>
      }
      push(@headerContent, &quot;    }\n\n&quot;);
  
      # Custom pushEventHandlerScope function
      if ($interface-&gt;extendedAttributes-&gt;{CustomPushEventHandlerScope}) {
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    JSC::JSScope* pushEventHandlerScope(JSC::ExecState*, JSC::JSScope*) const;\n\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    JSC::JSScope* pushEventHandlerScope(JSC::JSGlobalObject*, JSC::JSScope*) const;\n\n&quot;);</span>
      }
      
      # Constructor object getter
      unless ($interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
          push(@headerContent, &quot;    static JSC::JSValue getConstructor(JSC::VM&amp;, const JSC::JSGlobalObject*);\n&quot;);
          push(@headerContent, &quot;    static JSC::JSValue getNamedConstructor(JSC::VM&amp;, JSC::JSGlobalObject*);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
      }
  
      # Serializer function.
      if ($interface-&gt;serializable) {
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static JSC::JSObject* serialize(JSC::ExecState&amp;, ${className}&amp; thisObject, JSDOMGlobalObject&amp;, JSC::ThrowScope&amp;);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static JSC::JSObject* serialize(JSC::JSGlobalObject&amp;, ${className}&amp; thisObject, JSDOMGlobalObject&amp;, JSC::ThrowScope&amp;);\n&quot;);</span>
      }
      
      my $numCustomOperations = 0;
      my $numCustomAttributes = 0;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2783,10 +2793,17 @@</span>
  
              $hasForwardDeclaringAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
          }
      }
  
<span class="udiff-line-added">+     # FIXME: We put this unconditionally to put all the WebCore JS wrappers in each IsoSubspace.</span>
<span class="udiff-line-added">+     # https://bugs.webkit.org/show_bug.cgi?id=205107</span>
<span class="udiff-line-added">+     if (IsDOMGlobalObject($interface)) {</span>
<span class="udiff-line-added">+         push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::IsoSubspace* subspaceFor(JSC::VM&amp; vm) { return subspaceForImpl(vm); }\n&quot;);</span>
<span class="udiff-line-added">+         push(@headerContent, &quot;    static JSC::IsoSubspace* subspaceForImpl(JSC::VM&amp; vm);\n&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      # visit function
      if ($needsVisitChildren) {
          push(@headerContent, &quot;    static void visitChildren(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
          push(@headerContent, &quot;    void visitAdditionalChildren(JSC::SlotVisitor&amp;);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
          push(@headerContent, &quot;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2802,12 +2819,13 @@</span>
              # outputConstraintSubspace. visitOutputConstraints is the name JSC uses for the method
              # that the GC calls to ask an object is it would like to mark anything else after the
              # program resumed since the last call to visitChildren or visitOutputConstraints. Since
              # this just calls visitAdditionalChildren, you usually don&#39;t have to worry about this.
              push(@headerContent, &quot;    static void visitOutputConstraints(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
<span class="udiff-line-modified-removed">-             my $subspaceFunc = IsDOMGlobalObject($interface) ? &quot;globalObjectOutputConstraintSubspaceFor&quot; : &quot;outputConstraintSubspaceFor&quot;;</span>
<span class="udiff-line-modified-removed">-             push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::CompleteSubspace* subspaceFor(JSC::VM&amp; vm) { return $subspaceFunc(vm); }\n&quot;);</span>
<span class="udiff-line-modified-added">+             if (!IsDOMGlobalObject($interface)) {</span>
<span class="udiff-line-modified-added">+                 push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::CompleteSubspace* subspaceFor(JSC::VM&amp; vm) { return outputConstraintSubspaceFor(vm); }\n&quot;);</span>
<span class="udiff-line-added">+             }</span>
          }
      }
  
      if (NeedsImplementationClass($interface)) {
          push(@headerContent, &quot;    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&amp;);\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2819,16 +2837,16 @@</span>
          foreach my $attribute (@{$interface-&gt;attributes}) {
              my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
              if (HasCustomGetter($attribute)) {
                  push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
                  my $methodName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;name);
<span class="udiff-line-modified-removed">-                 push(@headerContent, &quot;    JSC::JSValue &quot; . $methodName . &quot;(JSC::ExecState&amp;) const;\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@headerContent, &quot;    JSC::JSValue &quot; . $methodName . &quot;(JSC::JSGlobalObject&amp;) const;\n&quot;);</span>
                  push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
              }
              if (HasCustomSetter($attribute) &amp;&amp; !IsReadonly($attribute)) {
                  push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
<span class="udiff-line-modified-removed">-                 push(@headerContent, &quot;    void set&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . &quot;(JSC::ExecState&amp;, JSC::JSValue);\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@headerContent, &quot;    void set&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . &quot;(JSC::JSGlobalObject&amp;, JSC::JSValue);\n&quot;);</span>
                  push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2858,11 +2876,12 @@</span>
              push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
  
              my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
  
              my @functionArguments = ();
<span class="udiff-line-modified-removed">-             push(@functionArguments, &quot;JSC::ExecState&amp;&quot;);</span>
<span class="udiff-line-modified-added">+             push(@functionArguments, &quot;JSC::JSGlobalObject&amp;&quot;);</span>
<span class="udiff-line-added">+             push(@functionArguments, &quot;JSC::CallFrame&amp;&quot;);</span>
              push(@functionArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp;&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
  
              push(@headerContent, &quot;    &quot; . ($operation-&gt;isStatic ? &quot;static &quot; : &quot;&quot;) . &quot;JSC::JSValue &quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @functionArguments) . &quot;);\n&quot;);
  
              push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2880,11 +2899,11 @@</span>
      }
  
      # structure flags
      if (%structureFlags) {
          push(@headerContent, &quot;public:\n&quot;);
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;    static const unsigned StructureFlags = Base::StructureFlags&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;    static constexpr unsigned StructureFlags = Base::StructureFlags&quot;);</span>
          foreach my $structureFlag (sort (keys %structureFlags)) {
              push(@headerContent, &quot; | &quot; . $structureFlag);
          }
          push(@headerContent, &quot;;\n&quot;);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2939,18 +2958,18 @@</span>
      }
      if (ShouldGenerateToJSDeclaration($hasParent, $interface)) {
          # Node and NodeList have custom inline implementations which thus cannot be exported.
          # FIXME: The special case for Node and NodeList should probably be implemented via an IDL attribute.
          if ($implType eq &quot;Node&quot; or $implType eq &quot;NodeList&quot;) {
<span class="udiff-line-modified-removed">-             push(@headerContent, &quot;JSC::JSValue toJS(JSC::ExecState*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@headerContent, &quot;JSC::JSValue toJS(JSC::JSGlobalObject*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);</span>
          } else {
<span class="udiff-line-modified-removed">-             push(@headerContent, $exportMacro.&quot;JSC::JSValue toJS(JSC::ExecState*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@headerContent, $exportMacro.&quot;JSC::JSValue toJS(JSC::JSGlobalObject*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);</span>
          }
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;inline JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, $implType* impl) { return impl ? toJS(state, globalObject, *impl) : JSC::jsNull(); }\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, $implType* impl) { return impl ? toJS(lexicalGlobalObject, globalObject, *impl) : JSC::jsNull(); }\n&quot;);</span>
  
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::ExecState*, JSDOMGlobalObject*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);</span>
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;inline JSC::JSValue toJSNewlyCreated(JSC::ExecState* state, JSDOMGlobalObject* globalObject, RefPtr&lt;$implType&gt;&amp;&amp; impl) { return impl ? toJSNewlyCreated(state, globalObject, impl.releaseNonNull()) : JSC::jsNull(); }\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;inline JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, RefPtr&lt;$implType&gt;&amp;&amp; impl) { return impl ? toJSNewlyCreated(lexicalGlobalObject, globalObject, impl.releaseNonNull()) : JSC::jsNull(); }\n&quot;);</span>
     }
  
      push(@headerContent, &quot;\n&quot;);
  
      GeneratePrototypeDeclaration(\@headerContent, $className, $interface) if HeaderNeedsPrototypeDeclaration($interface);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2974,11 +2993,11 @@</span>
  
              my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
              my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
              push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
              my $functionName = GetFunctionName($interface, $className, $operation);
<span class="udiff-line-modified-removed">-             push(@headerContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState*);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@headerContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::JSGlobalObject*, JSC::CallFrame*);\n&quot;);</span>
              push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
          }
  
          push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
          push(@headerContent,&quot;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2990,14 +3009,14 @@</span>
              next unless $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
  
              my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
              push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
              my $getter = GetAttributeGetterName($interface, $className, $attribute);
<span class="udiff-line-modified-removed">-             push(@headerContent, &quot;JSC::EncodedJSValue ${getter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@headerContent, &quot;JSC::EncodedJSValue ${getter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);</span>
              if (!IsReadonly($attribute)) {
                  my $setter = GetAttributeSetterName($interface, $className, $attribute);
<span class="udiff-line-modified-removed">-                 push(@headerContent, &quot;bool ${setter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@headerContent, &quot;bool ${setter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);</span>
              }
              push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3026,11 +3045,11 @@</span>
          }
      }
  
      if (HasCustomConstructor($interface)) {
          push(@headerContent, &quot;// Custom constructor\n&quot;);
<span class="udiff-line-modified-removed">-         push(@headerContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL construct${className}(JSC::ExecState&amp;);\n\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@headerContent, &quot;JSC::EncodedJSValue construct${className}(JSC::JSGlobalObject*, JSC::CallFrame&amp;);\n\n&quot;);</span>
      }
  
      if (NeedsImplementationClass($interface)) {
          my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
          $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3098,10 +3117,11 @@</span>
  
      return 0 if !$propertyCount;
  
      my @attributes = @{$interface-&gt;attributes};
      push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
<span class="udiff-line-added">+     push(@attributes, @{$interface-&gt;setLike-&gt;attributes}) if $interface-&gt;setLike;</span>
  
      foreach my $attribute (@attributes) {
          next if ($attribute-&gt;isStatic);
          next if AttributeShouldBeOnInstance($interface, $attribute) != $isInstance;
          next if ($attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $attribute-&gt;extendedAttributes-&gt;{PublicIdentifier});
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3135,18 +3155,26 @@</span>
          my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
          $conditionals-&gt;{$name} = $conditional if $conditional;
          my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
          $readWriteConditionals-&gt;{$name} = $readWriteConditional if $readWriteConditional;
  
<span class="udiff-line-modified-removed">-         if (NeedsRuntimeCheck($interface, $attribute)) {</span>
<span class="udiff-line-modified-added">+         my $needsRuntimeCheck = NeedsRuntimeCheck($interface, $attribute);</span>
<span class="udiff-line-added">+         my $needsRuntimeReadWriteCheck = $attribute-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite};</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if ($needsRuntimeCheck &amp;&amp; $needsRuntimeReadWriteCheck) {</span>
<span class="udiff-line-added">+             die &quot;Being both runtime enabled and runtime conditionally read-write is not yet supported (used on the &#39;${name}&#39; attribute of &#39;${interfaceName}&#39;).\n&quot;;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if ($needsRuntimeCheck || $needsRuntimeReadWriteCheck) {</span>
              push(@$runtimeEnabledAttributes, $attribute);
          }
      }
  
      my @operations = @{$interface-&gt;operations};
      push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
      push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
<span class="udiff-line-added">+     push(@operations, @{$interface-&gt;setLike-&gt;operations}) if $interface-&gt;setLike;</span>
      push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
      foreach my $operation (@operations) {
          next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
          next if ($operation-&gt;isStatic);
          next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3438,19 +3466,19 @@</span>
          return $type-&gt;name eq &quot;any&quot;;
      };
  
      my $maxArgCount = LengthOfLongestOperationParameterList($operation-&gt;{overloads});
  
<span class="udiff-line-modified-removed">-     push(@implContent, &quot;    size_t argsCount = std::min&lt;size_t&gt;(${maxArgCount}, state-&gt;argumentCount());\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@implContent, &quot;    size_t argsCount = std::min&lt;size_t&gt;(${maxArgCount}, callFrame-&gt;argumentCount());\n&quot;);</span>
  
      for my $length ( sort keys %allSets ) {
          push(@implContent, &quot;    if (argsCount == ${length}) {\n&quot;);
  
          my $S = $allSets{$length};
          if (scalar(@$S) &gt; 1) {
              my $d = GetDistinguishingArgumentIndex($operation, $S);
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;        JSValue distinguishingArg = state-&gt;uncheckedArgument($d);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;        JSValue distinguishingArg = callFrame-&gt;uncheckedArgument($d);\n&quot;);</span>
  
              my $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isOptionalParameter);
              &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefined()&quot;);
  
              $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isNullableOrDictionaryOrRecordOrUnionContainingOne);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3485,11 +3513,11 @@</span>
              $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrCallbackFunctionParameter);
              &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isFunction(vm)&quot;);
  
              # FIXME: Avoid invoking GetMethod(object, Symbol.iterator) again in convert&lt;IDLSequence&lt;T&gt;&gt;(...).
              $overload = GetOverloadThatMatches($S, $d, \&amp;$isSequenceOrFrozenArrayParameter);
<span class="udiff-line-modified-removed">-             &amp;$generateOverloadCallIfNecessary($overload, &quot;hasIteratorMethod(*state, distinguishingArg)&quot;, &quot;&lt;JavaScriptCore/IteratorOperations.h&gt;&quot;);</span>
<span class="udiff-line-modified-added">+             &amp;$generateOverloadCallIfNecessary($overload, &quot;hasIteratorMethod(lexicalGlobalObject, distinguishingArg)&quot;, &quot;&lt;JavaScriptCore/IteratorOperations.h&gt;&quot;);</span>
  
              $overload = GetOverloadThatMatches($S, $d, \&amp;$isDictionaryOrRecordOrObjectOrCallbackInterfaceParameter);
              &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject()&quot;);
  
              my $booleanOverload = GetOverloadThatMatches($S, $d, \&amp;$isBooleanParameter);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3519,13 +3547,13 @@</span>
      }
  END
      }
      my $minArgCount = GetFunctionLength($operation);
      if ($minArgCount &gt; 0) {
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;    return argsCount &lt; $minArgCount ? throwVMError(state, throwScope, createNotEnoughArgumentsError(state)) : throwVMTypeError(state, throwScope);\n&quot;)</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;    return argsCount &lt; $minArgCount ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;)</span>
      } else {
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;    return throwVMTypeError(state, throwScope);\n&quot;)</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;    return throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;)</span>
      }
  }
  
  # As per Web IDL specification, the length of a function Object is its number of mandatory parameters.
  sub GetFunctionLength
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3675,10 +3703,11 @@</span>
      my $param = shift;
      my $ret = lcfirst($param);
      $ret =~ s/cSS/css/ if $ret =~ /^cSS/;
      $ret =~ s/dOM/dom/ if $ret =~ /^dOM/;
      $ret =~ s/hTML/html/ if $ret =~ /^hTML/;
<span class="udiff-line-added">+     $ret =~ s/hDR/hdr/ if $ret =~ /^hDR/;</span>
      $ret =~ s/jS/js/ if $ret =~ /^jS/;
      $ret =~ s/uRL/url/ if $ret =~ /^uRL/;
      $ret =~ s/xML/xml/ if $ret =~ /^xML/;
      $ret =~ s/xSLT/xslt/ if $ret =~ /^xSLT/;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3727,11 +3756,11 @@</span>
  sub GenerateRuntimeEnableConditionalString
  {
      my ($interface, $context, $globalObjectIsParam) = @_;
  
      my @conjuncts;
<span class="udiff-line-modified-removed">-     my $globalObjectPtr = $globalObjectIsParam ? &quot;&amp;globalObject&quot; : &quot;globalObject()&quot;;</span>
<span class="udiff-line-modified-added">+     my $globalObjectPtr = $globalObjectIsParam ? $globalObjectIsParam : &quot;globalObject()&quot;;</span>
      
      if ($context-&gt;extendedAttributes-&gt;{SecureContext}) {
          AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
  
          if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3807,19 +3836,39 @@</span>
          foreach my $flag (@flags) {
              push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
          }
      }
  
<span class="udiff-line-added">+     if ($context-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite}) {</span>
<span class="udiff-line-added">+         assert(&quot;Must specify value for RuntimeConditionallyReadWrite.&quot;) if $context-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite} eq &quot;VALUE_IS_MISSING&quot;;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         AddToImplIncludes(&quot;RuntimeEnabledFeatures.h&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite});</span>
<span class="udiff-line-added">+         foreach my $flag (@flags) {</span>
<span class="udiff-line-added">+             push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      if ($context-&gt;extendedAttributes-&gt;{EnabledForContext}) {
          assert(&quot;Must not specify value for EnabledForContext.&quot;) unless $context-&gt;extendedAttributes-&gt;{EnabledForContext} eq &quot;VALUE_IS_MISSING&quot;;
          assert(&quot;EnabledForContext must be an interface or constructor attribute.&quot;) unless $codeGenerator-&gt;IsConstructorType($context-&gt;type);
  
          my $contextRef = &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()&quot;;
          my $name = $context-&gt;name;
          push(@conjuncts,  &quot;${name}::enabledForContext(&quot; . $contextRef . &quot;)&quot;);
      }
  
<span class="udiff-line-added">+     if ($context-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting}) {</span>
<span class="udiff-line-added">+         assert(&quot;Must specify value for ConstructorEnabledBySetting.&quot;) if $context-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting} eq &quot;VALUE_IS_MISSING&quot;;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         my @settings = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting});</span>
<span class="udiff-line-added">+         foreach my $setting (@settings) {</span>
<span class="udiff-line-added">+             push(@conjuncts, &quot;downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;settings().&quot; . ToMethodName($setting) . &quot;Enabled()&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      my $result = join(&quot; &amp;&amp; &quot;, @conjuncts);
      $result = &quot;($result)&quot; if @conjuncts &gt; 1;
      return $result;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3840,11 +3889,11 @@</span>
          push(@unscopables, $operationOrAttribute-&gt;name) if $operationOrAttribute-&gt;extendedAttributes-&gt;{Unscopable};
      }
      return if scalar(@unscopables) == 0;
  
      AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
<span class="udiff-line-modified-removed">-     push(@implContent, &quot;    JSObject&amp; unscopables = *constructEmptyObject(globalObject()-&gt;globalExec(), globalObject()-&gt;nullPrototypeObjectStructure());\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@implContent, &quot;    JSObject&amp; unscopables = *constructEmptyObject(globalObject()-&gt;vm(), globalObject()-&gt;nullPrototypeObjectStructure());\n&quot;);</span>
      foreach my $unscopable (@unscopables) {
          push(@implContent, &quot;    unscopables.putDirect(vm, Identifier::fromString(vm, \&quot;$unscopable\&quot;), jsBoolean(true));\n&quot;);
      }
      push(@implContent, &quot;    putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, &amp;unscopables, JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);\n&quot;);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3885,11 +3934,11 @@</span>
  # https://heycam.github.io/webidl/#es-iterator
  sub InterfaceNeedsIterator
  {
      my ($interface) = @_;
  
<span class="udiff-line-modified-removed">-     # FIXME: This should return 1 for setlike once we support it.</span>
<span class="udiff-line-modified-added">+     return 1 if $interface-&gt;setLike;</span>
      return 1 if $interface-&gt;mapLike;
      return 1 if $interface-&gt;iterable;
  
      if (GetIndexedGetterOperation($interface)) {
          my $lengthAttribute = GetAttributeWithName($interface, &quot;length&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3922,10 +3971,11 @@</span>
      AddToImplIncludes(&quot;JSDOMWrapperCache.h&quot;);
      AddToImplIncludes(&quot;&lt;wtf/GetPtr.h&gt;&quot;);
      AddToImplIncludes(&quot;&lt;wtf/PointerPreparations.h&gt;&quot;);
      AddToImplIncludes(&quot;&lt;JavaScriptCore/PropertyNameArray.h&gt;&quot;) if $indexedGetterOperation;
      AddToImplIncludes(&quot;JSDOMMapLike.h&quot;) if $interface-&gt;mapLike;
<span class="udiff-line-added">+     AddToImplIncludes(&quot;JSDOMSetLike.h&quot;) if $interface-&gt;setLike;</span>
      AddJSBuiltinIncludesIfNeeded($interface);
  
      my $implType = GetImplClassName($interface);
  
      @implContent = ();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3937,14 +3987,16 @@</span>
      push(@implContent, GenerateDictionariesImplementationContent($interface, $dictionaries));
  
      my @operations = @{$interface-&gt;operations};
      push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
      push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
<span class="udiff-line-added">+     push(@operations, @{$interface-&gt;setLike-&gt;operations}) if $interface-&gt;setLike;</span>
      push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
  
      my @attributes = @{$interface-&gt;attributes};
      push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
<span class="udiff-line-added">+     push(@attributes, @{$interface-&gt;setLike-&gt;attributes}) if $interface-&gt;setLike;</span>
  
      my $numConstants = @{$interface-&gt;constants};
      my $numOperations = @operations;
      my $numAttributes = @attributes;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3968,15 +4020,15 @@</span>
  
              my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
              my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
              push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
              my $functionName = GetFunctionName($interface, $className, $operation);
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState*);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::JSGlobalObject*, JSC::CallFrame*);\n&quot;);</span>
              if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
                  $implIncludes{&quot;DOMJITIDLType.h&quot;} = 1;
                  my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;
<span class="udiff-line-modified-removed">-                 my $functionSignature = &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::ExecState*, $className*&quot;;</span>
<span class="udiff-line-modified-added">+                 my $functionSignature = &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::JSGlobalObject*, $className*&quot;;</span>
                  foreach my $argument (@{$operation-&gt;arguments}) {
                      my $type = $argument-&gt;type;
                      my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);
                      $functionSignature .= &quot;, ${argumentType}&quot;;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3992,32 +4044,32 @@</span>
      if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
          push(@implContent, &quot;// Attributes\n\n&quot;);
  
          if (NeedsConstructorProperty($interface)) {
              my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;JSC::EncodedJSValue ${constructorGetter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;JSC::EncodedJSValue ${constructorGetter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);</span>
  
              my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;bool ${constructorSetter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;bool ${constructorSetter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);</span>
          }
  
          foreach my $attribute (@attributes) {
              next if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
              next if IsJSBuiltin($interface, $attribute);
  
              my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
              push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
              my $getter = GetAttributeGetterName($interface, $className, $attribute);
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;JSC::EncodedJSValue ${getter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;JSC::EncodedJSValue ${getter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);</span>
              if (!IsReadonly($attribute)) {
                  my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
                  if ($readWriteConditional) {
                      my $readWriteConditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
                      push(@implContent, &quot;#if ${readWriteConditionalString}\n&quot;);
                  }
                  my $setter = GetAttributeSetterName($interface, $className, $attribute);
<span class="udiff-line-modified-removed">-                 push(@implContent, &quot;bool ${setter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@implContent, &quot;bool ${setter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);</span>
                  push(@implContent, &quot;#endif\n&quot;) if $readWriteConditional;
              }
              push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4248,11 +4300,11 @@</span>
          push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
      } else {
          push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, &amp;${className}PrototypeTable, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
      }
  
<span class="udiff-line-modified-removed">-     if (PrototypeHasStaticPropertyTable($interface) &amp;&amp; !IsGlobalOrPrimaryGlobalInterface($interface)) {</span>
<span class="udiff-line-modified-added">+     if (PrototypeHasStaticPropertyTable($interface) &amp;&amp; !IsGlobalInterface($interface)) {</span>
          push(@implContent, &quot;void ${className}Prototype::finishCreation(VM&amp; vm)\n&quot;);
          push(@implContent, &quot;{\n&quot;);
          push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
          push(@implContent, &quot;    reifyStaticProperties(vm, ${className}::info(), ${className}PrototypeTableValues, *this);\n&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4270,15 +4322,34 @@</span>
              my $name = $operationOrAttribute-&gt;name;
              push(@implContent, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
              push(@implContent, &quot;        hasDisabledRuntimeProperties = true;\n&quot;);
              push(@implContent, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);
              push(@implContent, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;        JSObject::deleteProperty(this, globalObject()-&gt;globalExec(), propertyName);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;        JSObject::deleteProperty(this, globalObject(), propertyName);\n&quot;);</span>
              push(@implContent, &quot;    }\n&quot;);
              push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
          }
  
<span class="udiff-line-added">+         foreach my $attribute (@runtimeEnabledAttributes) {</span>
<span class="udiff-line-added">+             if ($attribute-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite}) {</span>
<span class="udiff-line-added">+                 AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);</span>
<span class="udiff-line-added">+                 my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $attribute);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 my $attributeName = $attribute-&gt;name;</span>
<span class="udiff-line-added">+                 my $getter = GetAttributeGetterName($interface, $className, $attribute);</span>
<span class="udiff-line-added">+                 my $setter = &quot;nullptr&quot;;</span>
<span class="udiff-line-added">+                 my $jscAttributes = GetJSCAttributesForAttribute($interface, $attribute);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);</span>
<span class="udiff-line-added">+                 push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;</span>
<span class="udiff-line-added">+                 push(@implContent, &quot;    // Adding back attribute, but as readonly, after removing the read-write variant above. \n&quot;);</span>
<span class="udiff-line-added">+                 push(@implContent, &quot;    if (!${runtimeEnableConditionalString})\n&quot;);</span>
<span class="udiff-line-added">+                 push(@implContent, &quot;        putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PublicName(), CustomGetterSetter::create(vm, $getter, $setter), attributesForStructure($jscAttributes));\n&quot;);</span>
<span class="udiff-line-added">+                 push(@implContent, &quot;#endif\n&quot;) if $conditionalString;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          if (@runtimeEnabledProperties) {
              push(@implContent, &quot;    if (hasDisabledRuntimeProperties &amp;&amp; structure()-&gt;isDictionary())\n&quot;);
              push(@implContent, &quot;        flattenDictionaryObject(vm);\n&quot;);
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4291,11 +4362,11 @@</span>
              push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
          }
  
          if (InterfaceNeedsIterator($interface)) {
              AddToImplIncludes(&quot;&lt;JavaScriptCore/BuiltinNames.h&gt;&quot;);
<span class="udiff-line-modified-removed">-             if (IsKeyValueIterableInterface($interface) or $interface-&gt;mapLike) {</span>
<span class="udiff-line-modified-added">+             if (IsKeyValueIterableInterface($interface) or $interface-&gt;mapLike or $interface-&gt;setLike) {</span>
                  push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
              } else {
                  AddToImplIncludes(&quot;&lt;JavaScriptCore/ArrayPrototype.h&gt;&quot;);
                  push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject()-&gt;arrayPrototype()-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4364,19 +4435,24 @@</span>
          push(@implContent, &quot;{\n&quot;);
          push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
          push(@implContent, &quot;    ASSERT(inherits(vm, info()));\n\n&quot;);
      }
  
<span class="udiff-line-added">+     if (!$codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;JSBuiltin&quot;)) {</span>
<span class="udiff-line-added">+         AddToImplIncludes(&quot;ActiveDOMObject.h&quot;);</span>
<span class="udiff-line-added">+         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;ActiveDOMObject&quot;)) {</span>
<span class="udiff-line-added">+             push(@implContent, &quot;    static_assert(std::is_base_of&lt;ActiveDOMObject, ${implType}&gt;::value, \&quot;Interface is marked as [ActiveDOMObject] but implementation class does not subclass ActiveDOMObject.\&quot;);\n\n&quot;);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             push(@implContent, &quot;    static_assert(!std::is_base_of&lt;ActiveDOMObject, ${implType}&gt;::value, \&quot;Interface is not marked as [ActiveDOMObject] even though implementation class subclasses ActiveDOMObject.\&quot;);\n\n&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      if ($interfaceName eq &quot;Location&quot;) {
          push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;valueOf, globalObject()-&gt;objectProtoValueOfFunction(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
          push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;toPrimitiveSymbol, jsUndefined(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
      }
  
<span class="udiff-line-removed">-     if ($interface-&gt;mapLike) {</span>
<span class="udiff-line-removed">-         push(@implContent, &quot;    synchronizeBackingMap(*globalObject()-&gt;globalExec(), *globalObject(), *this);\n&quot;);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      # Support for RuntimeEnabled attributes on instances.
      foreach my $attribute (@{$interface-&gt;attributes}) {
          next unless NeedsRuntimeCheck($interface, $attribute);
          next unless AttributeShouldBeOnInstance($interface, $attribute);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4505,68 +4581,68 @@</span>
          AddToImplIncludes(&quot;JSDOMAttribute.h&quot;);
  
          my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
          # FIXME: Remove ImplicitThis keyword as it is no longer defined by WebIDL spec and is only used in DOMWindow.
          if ($interface-&gt;extendedAttributes-&gt;{ImplicitThis}) {
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(ExecState&amp; state, EncodedJSValue thisValue)\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, EncodedJSValue thisValue)\n&quot;);</span>
              push(@implContent, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;    VM&amp; vm = state.vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;    VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n&quot;);</span>
              push(@implContent, &quot;    auto decodedThisValue = JSValue::decode(thisValue);\n&quot;);
              push(@implContent, &quot;    if (decodedThisValue.isUndefinedOrNull())\n&quot;);
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;        decodedThisValue = state.thisValue().toThis(&amp;state, NotStrictMode);\n&quot;);</span>
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;    return $castingFunction(vm, decodedThisValue);&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;        decodedThisValue = JSValue(&amp;lexicalGlobalObject).toThis(&amp;lexicalGlobalObject, NotStrictMode);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;    return $castingFunction(vm, decodedThisValue);\n&quot;);</span>
              push(@implContent, &quot;}\n\n&quot;);
          } else {
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(ExecState&amp; state, EncodedJSValue thisValue)\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, EncodedJSValue thisValue)\n&quot;);</span>
              push(@implContent, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;    return $castingFunction(state.vm(), JSValue::decode(thisValue));\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;    return $castingFunction(JSC::getVM(&amp;lexicalGlobalObject), JSValue::decode(thisValue));\n&quot;);</span>
              push(@implContent, &quot;}\n\n&quot;);
          }
      }
  
      if ($numOperations &gt; 0 &amp;&amp; $interfaceName ne &quot;EventTarget&quot;) {
          AddToImplIncludes(&quot;JSDOMOperation.h&quot;);
  
          # FIXME: Make consistent IDLAttribute&lt;&gt;::cast and IDLOperation&lt;&gt;::cast in case of CustomProxyToJSObject.
          my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
<span class="udiff-line-modified-removed">-         my $thisValue = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;state.thisValue().toThis(&amp;state, NotStrictMode)&quot; : &quot;state.thisValue()&quot;;</span>
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLOperation&lt;${className}&gt;::cast(ExecState&amp; state)\n&quot;);</span>
<span class="udiff-line-modified-added">+         my $thisValue = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;callFrame.thisValue().toThis(&amp;lexicalGlobalObject, NotStrictMode)&quot; : &quot;callFrame.thisValue()&quot;;</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLOperation&lt;${className}&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)\n&quot;);</span>
          push(@implContent, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;    return $castingFunction(state.vm(), $thisValue);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;    return $castingFunction(JSC::getVM(&amp;lexicalGlobalObject), $thisValue);\n&quot;);</span>
          push(@implContent, &quot;}\n\n&quot;);
      }
  
      if (NeedsConstructorProperty($interface)) {
          my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
  
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;EncodedJSValue ${constructorGetter}(ExecState* state, EncodedJSValue thisValue, PropertyName)\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;EncodedJSValue ${constructorGetter}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName)\n&quot;);</span>
          push(@implContent, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
          push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
          push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
          push(@implContent, &quot;    if (UNLIKELY(!prototype))\n&quot;);
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;        return throwVMTypeError(state, throwScope);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;        return throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;);</span>
  
          if (!$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;    return JSValue::encode(${className}::getConstructor(state-&gt;vm(), prototype-&gt;globalObject()));\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;    return JSValue::encode(${className}::getConstructor(JSC::getVM(lexicalGlobalObject), prototype-&gt;globalObject()));\n&quot;);</span>
          } else {
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;    JSValue constructor = ${className}Constructor::create(state-&gt;vm(), ${className}Constructor::createStructure(state-&gt;vm(), *prototype-&gt;globalObject(), prototype-&gt;globalObject()-&gt;objectPrototype()), *jsCast&lt;JSDOMGlobalObject*&gt;(prototype-&gt;globalObject()));\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;    JSValue constructor = ${className}Constructor::create(JSC::getVM(lexicalGlobalObject), ${className}Constructor::createStructure(JSC::getVM(lexicalGlobalObject), *prototype-&gt;globalObject(), prototype-&gt;globalObject()-&gt;objectPrototype()), *jsCast&lt;JSDOMGlobalObject*&gt;(prototype-&gt;globalObject()));\n&quot;);</span>
              push(@implContent, &quot;    // Shadowing constructor property to ensure reusing the same constructor object\n&quot;);
              push(@implContent, &quot;    prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, constructor, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
              push(@implContent, &quot;    return JSValue::encode(constructor);\n&quot;);
          }
          push(@implContent, &quot;}\n\n&quot;);
  
          my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
  
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;bool ${constructorSetter}(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;bool ${constructorSetter}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);</span>
          push(@implContent, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
          push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
          push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
          push(@implContent, &quot;    if (UNLIKELY(!prototype)) {\n&quot;);
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;        throwVMTypeError(state, throwScope);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;        throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;);</span>
          push(@implContent, &quot;        return false;\n&quot;);
          push(@implContent, &quot;    }\n&quot;);
          push(@implContent, &quot;    // Shadowing a built-in constructor\n&quot;);
          push(@implContent, &quot;    return prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, JSValue::decode(encodedValue));\n&quot;);
          push(@implContent, &quot;}\n\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4583,10 +4659,18 @@</span>
      }
      
      GenerateIterableDefinition($interface) if $interface-&gt;iterable;
      GenerateSerializerDefinition($interface, $className) if $interface-&gt;serializable;
  
<span class="udiff-line-added">+     if (IsDOMGlobalObject($interface)) {</span>
<span class="udiff-line-added">+         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);</span>
<span class="udiff-line-added">+         push(@implContent, &quot;JSC::IsoSubspace* ${className}::subspaceForImpl(JSC::VM&amp; vm)\n&quot;);</span>
<span class="udiff-line-added">+         push(@implContent, &quot;{\n&quot;);</span>
<span class="udiff-line-added">+         push(@implContent, &quot;    return &amp;static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;subspaceFor${className}();\n&quot;);</span>
<span class="udiff-line-added">+         push(@implContent, &quot;}\n\n&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      if ($needsVisitChildren) {
          push(@implContent, &quot;void ${className}::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
          push(@implContent, &quot;{\n&quot;);
          push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
          push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4790,20 +4874,20 @@</span>
  #endif
  #endif
  
  END
  
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::ExecState*, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);</span>
          push(@implContent, &quot;{\n&quot;);
          push(@implContent, &lt;&lt;END) if $vtableNameGnu;
  
  #if ENABLE(BINDING_INTEGRITY)
<span class="udiff-line-modified-removed">-     void* actualVTablePointer = *(reinterpret_cast&lt;void**&gt;(impl.ptr()));</span>
<span class="udiff-line-modified-added">+     void* actualVTablePointer = getVTablePointer(impl.ptr());</span>
  #if PLATFORM(WIN)
<span class="udiff-line-modified-removed">-     void* expectedVTablePointer = WTF_PREPARE_VTBL_POINTER_FOR_INSPECTION(${vtableRefWin});</span>
<span class="udiff-line-modified-added">+     void* expectedVTablePointer = ${vtableRefWin};</span>
  #else
<span class="udiff-line-modified-removed">-     void* expectedVTablePointer = WTF_PREPARE_VTBL_POINTER_FOR_INSPECTION(${vtableRefGnu});</span>
<span class="udiff-line-modified-added">+     void* expectedVTablePointer = ${vtableRefGnu};</span>
  #endif
  
      // If this fails ${implType} does not have a vtable, so you need to add the
      // ImplementationLacksVTable attribute to the interface definition
      static_assert(std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is not polymorphic&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4827,13 +4911,13 @@</span>
  END
  
          push(@implContent, &quot;    return createWrapper&lt;${implType}&gt;(globalObject, WTFMove(impl));\n&quot;);
          push(@implContent, &quot;}\n\n&quot;);
  
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, ${implType}&amp; impl)\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, ${implType}&amp; impl)\n&quot;);</span>
          push(@implContent, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;    return wrap(state, globalObject, impl);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;    return wrap(lexicalGlobalObject, globalObject, impl);\n&quot;);</span>
          push(@implContent, &quot;}\n\n&quot;);
      }
  
      if (ShouldGenerateToWrapped($hasParent, $interface) and !$interface-&gt;extendedAttributes-&gt;{JSCustomToNativeObject}) {
          push(@implContent, &quot;${implType}* ${className}::toWrapped(JSC::VM&amp; vm, JSC::JSValue value)\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4853,34 +4937,34 @@</span>
  sub GenerateAttributeGetterBodyDefinition
  {
      my ($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional) = @_;
      
      my @signatureArguments = ();
<span class="udiff-line-modified-removed">-     push(@signatureArguments, &quot;ExecState&amp; state&quot;);</span>
<span class="udiff-line-modified-added">+     push(@signatureArguments, &quot;JSGlobalObject&amp; lexicalGlobalObject&quot;);</span>
      push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
      push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
      
      push(@$outputArray, &quot;static inline JSValue ${attributeGetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
      push(@$outputArray, &quot;{\n&quot;);
      push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);</span>
  
      if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp;
          !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp;
          !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter}) {
          AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
          if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped(), ThrowSecurityError))\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped(), ThrowSecurityError))\n&quot;);</span>
          } else {
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);</span>
          }
          push(@$outputArray, &quot;        return jsUndefined();\n&quot;);
      }
      
      if (HasCustomGetter($attribute)) {
          my $implGetterFunctionName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;extendedAttributes-&gt;{ImplementedAs} || $attribute-&gt;name);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    return thisObject.${implGetterFunctionName}(state);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    return thisObject.${implGetterFunctionName}(lexicalGlobalObject);\n&quot;);</span>
      } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
          $implIncludes{&quot;EventNames.h&quot;} = 1;
          my $getter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;windowEventHandlerAttribute&quot;
              : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;documentEventHandlerAttribute&quot;
              : &quot;eventHandlerAttribute&quot;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4892,14 +4976,14 @@</span>
          # When Constructor attribute is used by DOMWindow.idl, it&#39;s correct to pass thisObject as the global object
          # When JSDOMWrappers have a back-pointer to the globalObject we can pass thisObject-&gt;globalObject()
          if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
              my $named = ($constructorType =~ /Named$/) ? &quot;Named&quot; : &quot;&quot;;
              $constructorType =~ s/Named$//;
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::get${named}Constructor(state.vm(), &amp;thisObject);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::get${named}Constructor(JSC::getVM(&amp;lexicalGlobalObject), &amp;thisObject);\n&quot;);</span>
          } else {
              AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::getConstructor(state.vm(), thisObject.globalObject());\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::getConstructor(JSC::getVM(&amp;lexicalGlobalObject), thisObject.globalObject());\n&quot;);</span>
          }
      } else {
          if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
              push(@$outputArray, &quot;    if (JSValue cachedValue = thisObject.m_&quot; . $attribute-&gt;name . &quot;.get())\n&quot;);
              push(@$outputArray, &quot;        return cachedValue;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4907,28 +4991,28 @@</span>
          
          my @callWithArgs = GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;jsUndefined()&quot;, &quot;thisObject&quot;);
          
          my ($baseFunctionName, @arguments) = $codeGenerator-&gt;GetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
          my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
<span class="udiff-line-modified-removed">-         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;state&quot;, &quot;thisObject&quot;);</span>
<span class="udiff-line-modified-added">+         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;lexicalGlobalObject&quot;, &quot;&quot;, &quot;thisObject&quot;);</span>
          
          unshift(@arguments, @callWithArgs);
  
<span class="udiff-line-modified-removed">-         my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot; : &quot;*thisObject.globalObject()&quot;;</span>
<span class="udiff-line-modified-added">+         my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)&quot; : &quot;*thisObject.globalObject()&quot;;</span>
          my $toJSExpression = NativeToJSValueUsingReferences($attribute, $interface, &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;, $globalObjectReference);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) unless $attribute-&gt;isStatic or $attribute-&gt;isMapLike;</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) unless $attribute-&gt;isStatic or $attribute-&gt;isMapLike or $attribute-&gt;isSetLike;</span>
  
          if (!IsReadonly($attribute)) {
              my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
              if ($callTracingCallback) {
                  my @callTracerArguments = ();
                  GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, &quot;    &quot;);
              }
          }
  
          push(@$outputArray, &quot;    JSValue result = ${toJSExpression};\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    thisObject.m_&quot; . $attribute-&gt;name . &quot;.set(state.vm(), &amp;thisObject, result);\n&quot;) if $attribute-&gt;extendedAttributes-&gt;{CachedAttribute};</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    thisObject.m_&quot; . $attribute-&gt;name . &quot;.set(JSC::getVM(&amp;lexicalGlobalObject), &amp;thisObject, result);\n&quot;) if $attribute-&gt;extendedAttributes-&gt;{CachedAttribute};</span>
          push(@$outputArray, &quot;    return result;\n&quot;);
      }
      push(@$outputArray, &quot;}\n\n&quot;);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4949,13 +5033,13 @@</span>
          push(@templateParameters, &quot;CastedThisErrorBehavior::RejectPromise&quot;)
      } elsif (IsAcceleratedDOMAttribute($interface, $attribute)) {
          push(@templateParameters, &quot;CastedThisErrorBehavior::Assert&quot;);
      }
      
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;EncodedJSValue ${attributeGetterName}(ExecState* state, EncodedJSValue thisValue, PropertyName)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;EncodedJSValue ${attributeGetterName}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName)\n&quot;);</span>
      push(@$outputArray, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeGetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*state, thisValue, \&quot;&quot; . $attribute-&gt;name .  &quot;\&quot;);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeGetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*lexicalGlobalObject, thisValue, \&quot;&quot; . $attribute-&gt;name .  &quot;\&quot;);\n&quot;);</span>
      push(@$outputArray, &quot;}\n\n&quot;);
  }
  
  sub GenerateAttributeGetterDefinition
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4981,53 +5065,53 @@</span>
  sub GenerateAttributeSetterBodyDefinition
  {
      my ($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional) = @_;
  
      my @signatureArguments = ();
<span class="udiff-line-modified-removed">-     push(@signatureArguments, &quot;ExecState&amp; state&quot;);</span>
<span class="udiff-line-modified-added">+     push(@signatureArguments, &quot;JSGlobalObject&amp; lexicalGlobalObject&quot;);</span>
      push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
      push(@signatureArguments, &quot;JSValue value&quot;);
      push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
      
      push(@$outputArray, &quot;static inline bool ${attributeSetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
      push(@$outputArray, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);</span>
      if ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) || $attribute-&gt;extendedAttributes-&gt;{Replaceable} || $attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
          push(@$outputArray, &quot;    VM&amp; vm = throwScope.vm();\n&quot;);
      } else {
          push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
      }
  
<span class="udiff-line-modified-removed">-     GenerateCustomElementReactionsStackIfNeeded($outputArray, $attribute, &quot;state&quot;);</span>
<span class="udiff-line-modified-added">+     GenerateCustomElementReactionsStackIfNeeded($outputArray, $attribute, &quot;lexicalGlobalObject&quot;);</span>
  
      if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnSetter}) {
          AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
          if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped(), ThrowSecurityError))\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped(), ThrowSecurityError))\n&quot;);</span>
          } else {
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);</span>
          }
          push(@$outputArray, &quot;        return false;\n&quot;);
      }
      
      if (HasCustomSetter($attribute)) {
          my $implSetterFunctionName = $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    thisObject.set${implSetterFunctionName}(state, value);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    thisObject.set${implSetterFunctionName}(lexicalGlobalObject, value);\n&quot;);</span>
          push(@$outputArray, &quot;    return true;\n&quot;);
      } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
          AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
          my $eventName = EventHandlerAttributeEventName($attribute);
          # FIXME: Find a way to do this special case without hardcoding the class and attribute names here.
          if (($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot; or $interface-&gt;type-&gt;name eq &quot;WorkerGlobalScope&quot;) and $attribute-&gt;name eq &quot;onerror&quot;) {
              AddToImplIncludes(&quot;JSErrorHandler.h&quot;, $conditional);
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    thisObject.wrapped().setAttributeEventListener($eventName, createJSErrorHandler(state, value, thisObject), worldForDOMObject(thisObject));\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    thisObject.wrapped().setAttributeEventListener($eventName, createJSErrorHandler(lexicalGlobalObject, value, thisObject), worldForDOMObject(thisObject));\n&quot;);</span>
          } else {
              AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
              my $setter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;setWindowEventHandlerAttribute&quot;
                  : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;setDocumentEventHandlerAttribute&quot;
                  : &quot;setEventHandlerAttribute&quot;;
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    $setter(state, thisObject, thisObject.wrapped(), ${eventName}, value);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    $setter(lexicalGlobalObject, thisObject, thisObject.wrapped(), ${eventName}, value);\n&quot;);</span>
          }
          push(@$outputArray, &quot;    return true;\n&quot;);
      } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
          my $constructorType = $attribute-&gt;type-&gt;name;
          $constructorType =~ s/Constructor$//;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5052,16 +5136,16 @@</span>
          assert(&quot;[PutForwards] is not compatible with static attributes&quot;) if $attribute-&gt;isStatic;
          
          # 3.5.9.1. Let Q be ? Get(O, id).
          my $id = $attribute-&gt;name;
          push(@$outputArray, &quot;    auto id = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;));\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    auto valueToForwardTo = thisObject.get(&amp;state, id);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    auto valueToForwardTo = thisObject.get(&amp;lexicalGlobalObject, id);\n&quot;);</span>
          push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
          
          # 3.5.9.2. If Type(Q) is not Object, then throw a TypeError.
          push(@$outputArray, &quot;    if (UNLIKELY(!valueToForwardTo.isObject())) {\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;        throwTypeError(&amp;state, throwScope);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;        throwTypeError(&amp;lexicalGlobalObject, throwScope);\n&quot;);</span>
          push(@$outputArray, &quot;        return false;\n&quot;);
          push(@$outputArray, &quot;    }\n&quot;);
          
          # 3.5.9.3. Let forwardId be the identifier argument of the [PutForwards] extended attribute.
          my $forwardId = $attribute-&gt;extendedAttributes-&gt;{PutForwards};
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5069,40 +5153,40 @@</span>
          
          # 3.5.9.4. Perform ? Set(Q, forwardId, V).
          # FIXME: What should the second value to the PutPropertySlot be?
          # (https://github.com/heycam/webidl/issues/368)
          push(@$outputArray, &quot;    PutPropertySlot slot(valueToForwardTo, false);\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    asObject(valueToForwardTo)-&gt;methodTable(vm)-&gt;put(asObject(valueToForwardTo), &amp;state, forwardId, value, slot);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    asObject(valueToForwardTo)-&gt;methodTable(vm)-&gt;put(asObject(valueToForwardTo), &amp;lexicalGlobalObject, forwardId, value, slot);\n&quot;);</span>
          push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
          
          push(@$outputArray, &quot;    return true;\n&quot;);
      } else {
          push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) if !$attribute-&gt;isStatic;
         
          if ($codeGenerator-&gt;IsEnumType($attribute-&gt;type)) {
              # As per section 3.5.6 of https://heycam.github.io/webidl/#dfn-attribute-setter, enumerations do not use
              # the standard conversion, but rather silently fail on invalid enumeration values.
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    auto optionalNativeValue = parseEnumeration&lt;&quot; . GetEnumerationClassName($attribute-&gt;type, $interface) . &quot;&gt;(state, value);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    auto optionalNativeValue = parseEnumeration&lt;&quot; . GetEnumerationClassName($attribute-&gt;type, $interface) . &quot;&gt;(lexicalGlobalObject, value);\n&quot;);</span>
              push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
              push(@$outputArray, &quot;    if (UNLIKELY(!optionalNativeValue))\n&quot;);
              push(@$outputArray, &quot;        return false;\n&quot;);
              push(@$outputArray, &quot;    auto nativeValue = optionalNativeValue.value();\n&quot;);
          } else {
<span class="udiff-line-modified-removed">-             my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*thisObject.globalObject()&quot;;</span>
<span class="udiff-line-modified-added">+             my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot; : &quot;*thisObject.globalObject()&quot;;</span>
              my $exceptionThrower = GetAttributeExceptionThrower($interface, $attribute);
  
<span class="udiff-line-modified-removed">-             my $toNativeExpression = JSValueToNative($interface, $attribute, &quot;value&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;state&quot;, &quot;state&quot;, &quot;thisObject&quot;, $globalObjectReference, $exceptionThrower);</span>
<span class="udiff-line-modified-added">+             my $toNativeExpression = JSValueToNative($interface, $attribute, &quot;value&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;lexicalGlobalObject&quot;, &quot;lexicalGlobalObject&quot;, &quot;thisObject&quot;, $globalObjectReference, $exceptionThrower);</span>
              push(@$outputArray, &quot;    auto nativeValue = ${toNativeExpression};\n&quot;);
              push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
          }
  
          my ($baseFunctionName, @arguments) = $codeGenerator-&gt;SetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
  
          push(@arguments, PassArgumentExpression(&quot;nativeValue&quot;, $attribute));
  
          my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
<span class="udiff-line-modified-removed">-         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;state&quot;, &quot;thisObject&quot;);</span>
<span class="udiff-line-modified-added">+         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;lexicalGlobalObject&quot;, &quot;&quot;, &quot;thisObject&quot;);</span>
  
          unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{SetterCallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
          unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
  
          my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5111,11 +5195,11 @@</span>
              my @callTracerArguments = (&quot;nativeValue&quot;);
              GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, $indent);
          }
  
          my $functionString = &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    AttributeSetter::call(state, throwScope, [&amp;] {\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    AttributeSetter::call(lexicalGlobalObject, throwScope, [&amp;] {\n&quot;);</span>
          push(@$outputArray, &quot;        return $functionString;\n&quot;);
          push(@$outputArray, &quot;    });\n&quot;);
          push(@$outputArray, &quot;    return true;\n&quot;);
      }
      push(@$outputArray, &quot;}\n\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5132,13 +5216,13 @@</span>
      
      my @templateParameters = ();
      push(@templateParameters, $attributeSetterBodyName);
      push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;) if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
      
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;bool ${attributeSetterName}(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;bool ${attributeSetterName}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);</span>
      push(@$outputArray, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeSetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*state, thisValue, encodedValue, \&quot;&quot; . $attribute-&gt;name . &quot;\&quot;);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeSetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*lexicalGlobalObject, thisValue, encodedValue, \&quot;&quot; . $attribute-&gt;name . &quot;\&quot;);\n&quot;);</span>
      push(@$outputArray, &quot;}\n\n&quot;);
  }
  
  sub GenerateAttributeSetterDefinition
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5181,72 +5265,76 @@</span>
      $callFunctionName .= &quot;Static&quot; if $operation-&gt;isStatic;
      $callFunctionName .= &quot;ReturningOwnPromise&quot; if $hasPromiseReturnType &amp;&amp; $operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
  
      my @callFunctionTemplateArguments = ();
      push(@callFunctionTemplateArguments, $functionBodyName);
<span class="udiff-line-removed">-     push(@callFunctionTemplateArguments, &quot;PromiseExecutionScope::${exposureScope}&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};</span>
      push(@callFunctionTemplateArguments, &quot;CastedThisErrorBehavior::Assert&quot;) if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
  
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${functionName}(ExecState* state)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${functionName}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
      push(@$outputArray, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    return ${idlOperationType}&lt;${className}&gt;::${callFunctionName}&lt;&quot; . join(&quot;, &quot;, @callFunctionTemplateArguments) . &quot;&gt;(*state, \&quot;&quot; . $operation-&gt;name . &quot;\&quot;);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    return ${idlOperationType}&lt;${className}&gt;::${callFunctionName}&lt;&quot; . join(&quot;, &quot;, @callFunctionTemplateArguments) . &quot;&gt;(*lexicalGlobalObject, *callFrame, \&quot;&quot; . $operation-&gt;name . &quot;\&quot;);\n&quot;);</span>
      push(@$outputArray, &quot;}\n\n&quot;);
  }
  
  sub GenerateOperationBodyDefinition
  {
<span class="udiff-line-modified-removed">-     my ($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName, $generatingOverloadDispatcher) = @_;</span>
<span class="udiff-line-modified-added">+     my ($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName, $isOverloaded, $generatingOverloadDispatcher) = @_;</span>
  
      my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
      my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
      my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
  
      my @signatureArguments = ();
<span class="udiff-line-modified-removed">-     push(@signatureArguments, &quot;JSC::ExecState* state&quot;);</span>
<span class="udiff-line-modified-added">+     push(@signatureArguments, &quot;JSC::JSGlobalObject* lexicalGlobalObject&quot;);</span>
<span class="udiff-line-added">+     push(@signatureArguments, &quot;JSC::CallFrame* callFrame&quot;);</span>
      push(@signatureArguments, &quot;typename ${idlOperationType}&lt;${className}&gt;::ClassParameter castedThis&quot;) if !$operation-&gt;isStatic;
      push(@signatureArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp; promise&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
      push(@signatureArguments, &quot;JSC::ThrowScope&amp; throwScope&quot;);
  
      push(@$outputArray, &quot;static inline JSC::EncodedJSValue ${functionBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
      push(@$outputArray, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);</span>
<span class="udiff-line-added">+     push(@$outputArray, &quot;    UNUSED_PARAM(callFrame);\n&quot;);</span>
      push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
  
<span class="udiff-line-modified-removed">-     if (!$generatingOverloadDispatcher) {</span>
<span class="udiff-line-removed">-         GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*state&quot;);</span>
<span class="udiff-line-modified-added">+     GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*lexicalGlobalObject&quot;) unless $generatingOverloadDispatcher;</span>
  
<span class="udiff-line-added">+     # For overloads, we generate the security check in the overload dispatcher, instead of the body of each overload, as per specification:</span>
<span class="udiff-line-added">+     # https://heycam.github.io/webidl/#dfn-create-operation-function</span>
<span class="udiff-line-added">+     if (!$isOverloaded || $generatingOverloadDispatcher) {</span>
          if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} and !$operation-&gt;extendedAttributes-&gt;{DoNotCheckSecurity}) {
              assert(&quot;Security checks are not supported for static operations.&quot;) if $operation-&gt;isStatic;
              
              AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
              if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
<span class="udiff-line-modified-removed">-                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(state, castedThis-&gt;wrapped(), ThrowSecurityError))\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, castedThis-&gt;wrapped(), ThrowSecurityError))\n&quot;);</span>
                  push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
              } else {
<span class="udiff-line-modified-removed">-                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(state, castedThis-&gt;wrapped().window(), ThrowSecurityError))\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, castedThis-&gt;wrapped().window(), ThrowSecurityError))\n&quot;);</span>
                  push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
              }
          }
      }
  
      my $indent = &quot;    &quot;;
  
      if ($generatingOverloadDispatcher) {
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
          push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
  
          my @argumentsToForward = ();
<span class="udiff-line-modified-removed">-         push(@argumentsToForward, &quot;state&quot;);</span>
<span class="udiff-line-modified-added">+         push(@argumentsToForward, &quot;lexicalGlobalObject&quot;);</span>
<span class="udiff-line-added">+         push(@argumentsToForward, &quot;callFrame&quot;);</span>
          push(@argumentsToForward, &quot;castedThis&quot;) if !$operation-&gt;isStatic;
          push(@argumentsToForward, &quot;WTFMove(promise)&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
          push(@argumentsToForward, &quot;throwScope&quot;);
  
          GenerateOverloadDispatcher($operation, $interface, $functionName, &quot;Body&quot;, join(&quot;, &quot;, @argumentsToForward));
      } elsif (HasCustomMethod($operation)) {
          GenerateImplementationCustomFunctionCall($outputArray, $operation, $interface, $className, $functionImplementationName, $indent);
      } else {
<span class="udiff-line-modified-removed">-         if (!$operation-&gt;isMapLike &amp;&amp; !$operation-&gt;isStatic) {</span>
<span class="udiff-line-modified-added">+         if (!$operation-&gt;isMapLike &amp;&amp; !$operation-&gt;isSetLike &amp;&amp; !$operation-&gt;isStatic) {</span>
              push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
          }
  
          GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
          my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5302,11 +5390,11 @@</span>
  
      my $functionName = GetFunctionName($interface, $className, $operation);
      my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
      my $functionBodyName = ($isOverloaded ? $functionName . $operation-&gt;{overloadIndex} : $functionName) . &quot;Body&quot;;
  
<span class="udiff-line-modified-removed">-     GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName);</span>
<span class="udiff-line-modified-added">+     GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName, $isOverloaded);</span>
  
      # Overloaded operations don&#39;t generate a trampoline for each overload, and instead have a single dispatch trampoline
      # that gets generated after the last overload body has been generated.
      unless ($isOverloaded) {
          GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $functionBodyName);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5319,11 +5407,11 @@</span>
          my $overloadsConditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
          my $overloadsConditionalString = $overloadsConditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($overloadsConditionalAttribute) : undef;
          push(@$outputArray, &quot;#if ${overloadsConditionalString}\n\n&quot;) if $overloadsConditionalString;
  
          my $overloadDispatcherFunctionBodyName = $functionName . &quot;OverloadDispatcher&quot;;
<span class="udiff-line-modified-removed">-         GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $overloadDispatcherFunctionBodyName, 1);</span>
<span class="udiff-line-modified-added">+         GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $overloadDispatcherFunctionBodyName, $isOverloaded, 1);</span>
          GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $overloadDispatcherFunctionBodyName);
      
          push(@$outputArray, &quot;#endif\n\n&quot;) if $overloadsConditionalString;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5334,31 +5422,34 @@</span>
              push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
          }
  
          AddToImplIncludes(&quot;&lt;JavaScriptCore/FrameTracers.h&gt;&quot;, $conditional);
          my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::ExecState* state, $className* castedThis&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::JSGlobalObject* lexicalGlobalObject, $className* castedThis&quot;);</span>
          foreach my $argument (@{$operation-&gt;arguments}) {
              my $type = $argument-&gt;type;
              my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);
              my $name = $argument-&gt;name;
              my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
              push(@$outputArray, &quot;, ${argumentType} ${encodedName}&quot;);
          }
          push(@$outputArray, &quot;)\n&quot;);
          push(@$outputArray, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);</span>
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    JSC::NativeCallFrameTracer tracer(vm, state);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    IGNORE_WARNINGS_BEGIN(\&quot;frame-address\&quot;)\n&quot;);</span>
<span class="udiff-line-added">+         push(@$outputArray, &quot;    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);\n&quot;);</span>
<span class="udiff-line-added">+         push(@$outputArray, &quot;    IGNORE_WARNINGS_END\n&quot;);</span>
<span class="udiff-line-added">+         push(@$outputArray, &quot;    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);\n&quot;);</span>
          push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
          push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
          push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
          
          my $implFunctionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
          
          my @arguments = ();
<span class="udiff-line-modified-removed">-         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*state&quot;, &quot;*castedThis&quot;);</span>
<span class="udiff-line-modified-added">+         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*lexicalGlobalObject&quot;, &quot;*callFrame&quot;, &quot;*castedThis&quot;);</span>
          
          foreach my $argument (@{$operation-&gt;arguments}) {
              my $value = &quot;&quot;;
              my $type = $argument-&gt;type;
              my $name = $argument-&gt;name;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5374,11 +5465,11 @@</span>
                  $value = &quot;*$name&quot;;
              }
              push(@arguments, $value);
          }
          my $functionString = &quot;$implFunctionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
<span class="udiff-line-modified-removed">-         $functionString = &quot;propagateException(*state, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);</span>
<span class="udiff-line-modified-added">+         $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);</span>
          push(@$outputArray, &quot;    return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, &quot;*castedThis-&gt;globalObject()&quot;) . &quot;);\n&quot;);
          push(@$outputArray, &quot;}\n\n&quot;);
  
          push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5424,40 +5515,40 @@</span>
      my $serializerFunctionName = &quot;toJSON&quot;;
      my $serializerNativeFunctionName = $codeGenerator-&gt;WK_lcfirst($className) . &quot;PrototypeFunction&quot; . $codeGenerator-&gt;WK_ucfirst($serializerFunctionName);
  
      AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
  
<span class="udiff-line-modified-removed">-     push(@implContent, &quot;JSC::JSObject* JS${interfaceName}::serialize(ExecState&amp; state, ${className}&amp; thisObject, JSDOMGlobalObject&amp; globalObject, ThrowScope&amp; throwScope)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@implContent, &quot;JSC::JSObject* JS${interfaceName}::serialize(JSGlobalObject&amp; lexicalGlobalObject, ${className}&amp; thisObject, JSDOMGlobalObject&amp; globalObject, ThrowScope&amp; throwScope)\n&quot;);</span>
      push(@implContent, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-     push(@implContent, &quot;    auto&amp; vm = state.vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@implContent, &quot;    auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n&quot;);</span>
  
      if ($interface-&gt;serializable-&gt;hasInherit) {
          my $parentSerializerInterfaceName = $parentSerializerInterface-&gt;type-&gt;name;
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;    auto* result = JS${parentSerializerInterfaceName}::serialize(state, thisObject, globalObject, throwScope);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;    auto* result = JS${parentSerializerInterfaceName}::serialize(lexicalGlobalObject, thisObject, globalObject, throwScope);\n&quot;);</span>
      } else {
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;    auto* result = constructEmptyObject(&amp;state, globalObject.objectPrototype());\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;    auto* result = constructEmptyObject(&amp;lexicalGlobalObject, globalObject.objectPrototype());\n&quot;);</span>
      }
      push(@implContent, &quot;\n&quot;);
  
      foreach my $attribute (@serializedAttributes) {
          # FIXME: Attributes that throw exceptions are not supported with serializers yet.
  
          my $name = $attribute-&gt;name;
          my $getFunctionName = GetAttributeGetterName($interface, $className, $attribute);
<span class="udiff-line-modified-removed">-         push(@implContent, &quot;    auto ${name}Value = ${getFunctionName}Getter(state, thisObject, throwScope);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@implContent, &quot;    auto ${name}Value = ${getFunctionName}Getter(lexicalGlobalObject, thisObject, throwScope);\n&quot;);</span>
          push(@implContent, &quot;    throwScope.assertNoException();\n&quot;);
  
          if ($codeGenerator-&gt;IsInterfaceType($attribute-&gt;type)) {
              my $attributeInterfaceName = $attribute-&gt;type-&gt;name;
              if ($attribute-&gt;type-&gt;isNullable) {
                  push(@implContent, &quot;    if (!${name}Value.isNull()) {\n&quot;);
<span class="udiff-line-modified-removed">-                 push(@implContent, &quot;        auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(state, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@implContent, &quot;        auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(lexicalGlobalObject, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);</span>
                  push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);
                  push(@implContent, &quot;    } else\n&quot;);
                  push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);
              } else {
<span class="udiff-line-modified-removed">-                 push(@implContent, &quot;    auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(state, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@implContent, &quot;    auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(lexicalGlobalObject, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);</span>
                  push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);
              }
          } else {
              push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5467,18 +5558,18 @@</span>
  
      push(@implContent, &quot;    return result;\n&quot;);
      push(@implContent, &quot;}\n&quot;);
      push(@implContent, &quot;\n&quot;);
  
<span class="udiff-line-modified-removed">-     push(@implContent, &quot;static inline EncodedJSValue ${serializerNativeFunctionName}Body(ExecState* state, ${className}* thisObject, JSC::ThrowScope&amp; throwScope)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@implContent, &quot;static inline EncodedJSValue ${serializerNativeFunctionName}Body(JSGlobalObject* lexicalGlobalObject, CallFrame*, ${className}* thisObject, JSC::ThrowScope&amp; throwScope)\n&quot;);</span>
      push(@implContent, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-     push(@implContent, &quot;    return JSValue::encode(JS${interfaceName}::serialize(*state, *thisObject, *thisObject-&gt;globalObject(), throwScope));\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@implContent, &quot;    return JSValue::encode(JS${interfaceName}::serialize(*lexicalGlobalObject, *thisObject, *thisObject-&gt;globalObject(), throwScope));\n&quot;);</span>
      push(@implContent, &quot;}\n&quot;);
      push(@implContent, &quot;\n&quot;);
<span class="udiff-line-modified-removed">-     push(@implContent, &quot;EncodedJSValue JSC_HOST_CALL ${serializerNativeFunctionName}(ExecState* state)\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@implContent, &quot;EncodedJSValue JSC_HOST_CALL ${serializerNativeFunctionName}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
      push(@implContent, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-     push(@implContent, &quot;    return IDLOperation&lt;JS${interfaceName}&gt;::call&lt;${serializerNativeFunctionName}Body&gt;(*state, \&quot;${serializerFunctionName}\&quot;);\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@implContent, &quot;    return IDLOperation&lt;JS${interfaceName}&gt;::call&lt;${serializerNativeFunctionName}Body&gt;(*lexicalGlobalObject, *callFrame, \&quot;${serializerFunctionName}\&quot;);\n&quot;);</span>
      push(@implContent, &quot;}\n&quot;);
      push(@implContent, &quot;\n&quot;);
  }
  
  sub GenerateGetCallData
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5520,17 +5611,17 @@</span>
              GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCaller);
          }
  
          my $overloadFunctionPrefix = &quot;call${className}&quot;;
  
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${overloadFunctionPrefix}(ExecState* state)\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${overloadFunctionPrefix}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
          push(@$outputArray, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);</span>
          push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
          push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
  
<span class="udiff-line-modified-removed">-         GenerateOverloadDispatcher($legacyCallers[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;state&quot;);</span>
<span class="udiff-line-modified-added">+         GenerateOverloadDispatcher($legacyCallers[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;lexicalGlobalObject, callFrame&quot;);</span>
  
          push(@$outputArray, &quot;}\n\n&quot;);
      } else {
          GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCallers[0]);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5547,24 +5638,24 @@</span>
  {
      my ($outputArray, $interface, $className, $operation) = @_;
  
      my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
      if ($isOverloaded) {
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;static inline EncodedJSValue call${className}$operation-&gt;{overloadIndex}(ExecState* state)\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;static inline EncodedJSValue call${className}$operation-&gt;{overloadIndex}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
      } else {
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;static EncodedJSValue JSC_HOST_CALL call${className}(ExecState* state)\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;static EncodedJSValue JSC_HOST_CALL call${className}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
      }
  
      push(@$outputArray, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);</span>
      push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
      push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
  
      my $indent = &quot;    &quot;;
      GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
  
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${className}*&gt;(state-&gt;jsCallee());\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${className}*&gt;(callFrame-&gt;jsCallee());\n&quot;);</span>
      push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
      push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
  
      my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;legacyCallerOperationFromBindings&quot;;
      my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5576,53 +5667,58 @@</span>
  
  sub GenerateCallWithUsingReferences
  {
      my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
  
<span class="udiff-line-modified-removed">-     my $statePointer = &quot;&amp;state&quot;;</span>
<span class="udiff-line-modified-removed">-     my $stateReference = &quot;state&quot;;</span>
<span class="udiff-line-modified-removed">-     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot;;</span>
<span class="udiff-line-modified-added">+     my $callFramePointer = &quot;callFrame&quot;;</span>
<span class="udiff-line-modified-added">+     my $callFrameReference = &quot;*callFrame&quot;;</span>
<span class="udiff-line-modified-added">+     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)&quot;;</span>
  
<span class="udiff-line-modified-removed">-     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $statePointer, $stateReference, $globalObject, $globalObject, $thisReference, $indent);</span>
<span class="udiff-line-modified-added">+     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $callFramePointer, $callFrameReference, $globalObject, $globalObject, $thisReference, $indent);</span>
  }
  
  # FIXME: We should remove GenerateCallWithUsingPointers and combine GenerateCallWithUsingReferences and GenerateCallWith
  sub GenerateCallWithUsingPointers
  {
      my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
  
<span class="udiff-line-modified-removed">-     my $statePointer = &quot;state&quot;;</span>
<span class="udiff-line-modified-removed">-     my $stateReference = &quot;*state&quot;;</span>
<span class="udiff-line-modified-removed">-     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot;;</span>
<span class="udiff-line-modified-added">+     my $callFramePointer = &quot;callFrame&quot;;</span>
<span class="udiff-line-modified-added">+     my $callFrameReference = &quot;*callFrame&quot;;</span>
<span class="udiff-line-modified-added">+     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot;;</span>
  
<span class="udiff-line-modified-removed">-     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $statePointer, $stateReference, $globalObject, $globalObject, $thisReference, $indent);</span>
<span class="udiff-line-modified-added">+     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $callFramePointer, $callFrameReference, $globalObject, $globalObject, $thisReference, $indent);</span>
  }
  
  sub GenerateConstructorCallWithUsingPointers
  {
      my ($callWith, $outputArray, $visibleInterfaceName, $thisReference, $indent) = @_;
  
<span class="udiff-line-modified-removed">-     my $statePointer = &quot;state&quot;;</span>
<span class="udiff-line-modified-removed">-     my $stateReference = &quot;*state&quot;;</span>
<span class="udiff-line-modified-added">+     my $callFramePointer = &quot;callFrame&quot;;</span>
<span class="udiff-line-modified-added">+     my $callFrameReference = &quot;*callFrame&quot;;</span>
      my $globalObject = &quot;castedThis-&gt;globalObject()&quot;;
<span class="udiff-line-modified-removed">-     my $contextMissing = &quot;throwConstructorScriptExecutionContextUnavailableError(*state, throwScope, \&quot;${visibleInterfaceName}\&quot;)&quot;;</span>
<span class="udiff-line-modified-added">+     my $contextMissing = &quot;throwConstructorScriptExecutionContextUnavailableError(*lexicalGlobalObject, throwScope, \&quot;${visibleInterfaceName}\&quot;)&quot;;</span>
      my $scriptExecutionContextAccessor = &quot;castedThis&quot;;
  
<span class="udiff-line-modified-removed">-     return GenerateCallWith($callWith, $outputArray, &quot;&quot;, $contextMissing, $statePointer, $stateReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent);</span>
<span class="udiff-line-modified-added">+     return GenerateCallWith($callWith, $outputArray, &quot;&quot;, $contextMissing, $callFramePointer, $callFrameReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent);</span>
  }
  
  sub GenerateCallWith
  {
<span class="udiff-line-modified-removed">-     my ($callWith, $outputArray, $returnValue, $contextMissing, $statePointer, $stateReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent) = @_;</span>
<span class="udiff-line-modified-added">+     my ($callWith, $outputArray, $returnValue, $contextMissing, $callFramePointer, $callFrameReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent) = @_;</span>
  
      return () unless $callWith;
  
      $indent ||= &quot;    &quot;;
  
      my @callWithArgs;
<span class="udiff-line-modified-removed">-     push(@callWithArgs, $stateReference) if $codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ExecState&quot;);</span>
<span class="udiff-line-modified-removed">-     push(@callWithArgs, &quot;*${globalObject}&quot;) if $codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;GlobalObject&quot;);</span>
<span class="udiff-line-modified-added">+     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ExecState&quot;)) {</span>
<span class="udiff-line-modified-added">+         push(@callWithArgs, &quot;*${globalObject}&quot;);</span>
<span class="udiff-line-added">+         push(@callWithArgs, $callFrameReference);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;GlobalObject&quot;)) {</span>
<span class="udiff-line-added">+         push(@callWithArgs, &quot;*${globalObject}&quot;);</span>
<span class="udiff-line-added">+     }</span>
      if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ScriptExecutionContext&quot;)) {
          push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
          push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
          push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
          push(@callWithArgs, &quot;*context&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5637,34 +5733,34 @@</span>
          push(@callWithArgs, &quot;document&quot;);
      }
      if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentDocument&quot;)) {
          AddToImplIncludes(&quot;DOMWindow.h&quot;);
          AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, $indent . &quot;auto* incumbentDocument = incumbentDOMWindow($stateReference).document();\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, $indent . &quot;auto* incumbentDocument = incumbentDOMWindow(*$globalObject, $callFrameReference).document();\n&quot;);</span>
          push(@$outputArray, $indent . &quot;if (!incumbentDocument)\n&quot;);
          push(@$outputArray, $indent . &quot;    return&quot; . ($returnValue ? &quot; &quot; . $returnValue : &quot;&quot;) . &quot;;\n&quot;);
          push(@callWithArgs, &quot;*incumbentDocument&quot;);
      }
      if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ResponsibleDocument&quot;)) {
          AddToImplIncludes(&quot;DOMWindow.h&quot;);
          AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="udiff-line-modified-removed">-         push(@callWithArgs, &quot;responsibleDocument($stateReference)&quot;);</span>
<span class="udiff-line-modified-added">+         push(@callWithArgs, &quot;responsibleDocument(${globalObject}-&gt;vm(), $callFrameReference)&quot;);</span>
      }
      if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ActiveWindow&quot;)) {
          AddToImplIncludes(&quot;DOMWindow.h&quot;);
          AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="udiff-line-modified-removed">-         push(@callWithArgs, &quot;activeDOMWindow($stateReference)&quot;);</span>
<span class="udiff-line-modified-added">+         push(@callWithArgs, &quot;activeDOMWindow(*$globalObject)&quot;);</span>
      }
      if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;FirstWindow&quot;)) {
          AddToImplIncludes(&quot;DOMWindow.h&quot;);
          AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="udiff-line-modified-removed">-         push(@callWithArgs, &quot;firstDOMWindow($stateReference)&quot;);</span>
<span class="udiff-line-modified-added">+         push(@callWithArgs, &quot;firstDOMWindow(*$globalObject)&quot;);</span>
      }
      if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentWindow&quot;)) {
          AddToImplIncludes(&quot;DOMWindow.h&quot;);
          AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="udiff-line-modified-removed">-         push(@callWithArgs, &quot;incumbentDOMWindow($stateReference)&quot;);</span>
<span class="udiff-line-modified-added">+         push(@callWithArgs, &quot;incumbentDOMWindow(*$globalObject, $callFrameReference)&quot;);</span>
      }
      if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;RuntimeFlags&quot;)) {
          push(@callWithArgs, &quot;${globalObject}-&gt;runtimeFlags()&quot;);
      }
      if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;World&quot;)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5689,12 +5785,12 @@</span>
          } else {
              last;
          }
      }
      if ($numMandatoryArguments &gt;= 1) {
<span class="udiff-line-modified-removed">-         push(@$outputArray, $indent . &quot;if (UNLIKELY(state-&gt;argumentCount() &lt; $numMandatoryArguments))\n&quot;);</span>
<span class="udiff-line-modified-removed">-         push(@$outputArray, $indent . &quot;    return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, $indent . &quot;if (UNLIKELY(callFrame-&gt;argumentCount() &lt; $numMandatoryArguments))\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, $indent . &quot;    return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));\n&quot;);</span>
      }
  }
  
  my %automaticallyGeneratedDefaultValues = (
      &quot;any&quot; =&gt; &quot;undefined&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5757,11 +5853,11 @@</span>
      my $isConstructor = $operation-&gt;extendedAttributes-&gt;{Constructor} || $operation-&gt;extendedAttributes-&gt;{NamedConstructor};
  
      my $functionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
      
      my @arguments = ();
<span class="udiff-line-modified-removed">-     AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*state&quot;, &quot;*castedThis&quot;);</span>
<span class="udiff-line-modified-added">+     AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*lexicalGlobalObject&quot;, &quot;*callFrame&quot;, &quot;*castedThis&quot;);</span>
      
      my $quotedFunctionName;
      if (!$isConstructor) {
          my $name = $operation-&gt;name;
          $quotedFunctionName = &quot;\&quot;$name\&quot;&quot;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5805,11 +5901,11 @@</span>
              AddToImplIncludes(&quot;JSDOMConvertVariadic.h&quot;, $conditional);
              AddToImplIncludesForIDLType($type, $conditional);
          
              my $IDLType = GetIDLType($interface, $type);
  
<span class="udiff-line-modified-removed">-             push(@$outputArray, $indent . &quot;auto ${name} = convertVariadicArguments&lt;${IDLType}&gt;(*state, ${argumentIndex});\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, $indent . &quot;auto ${name} = convertVariadicArguments&lt;${IDLType}&gt;(*lexicalGlobalObject, *callFrame, ${argumentIndex});\n&quot;);</span>
              push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
  
              $value = &quot;WTFMove(${name})&quot;;
          } else {
              my $argumentLookupForConversion;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5819,15 +5915,15 @@</span>
              if ($argument-&gt;isOptional) {
                  assert(&quot;[ReturnValue] is not supported for optional arguments&quot;) if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
  
                  if (defined($argument-&gt;default)) {
                      if (WillConvertUndefinedToDefaultParameterValue($type, $argument-&gt;default)) {
<span class="udiff-line-modified-removed">-                         $argumentLookupForConversion = &quot;state-&gt;argument($argumentIndex)&quot;;</span>
<span class="udiff-line-modified-added">+                         $argumentLookupForConversion = &quot;callFrame-&gt;argument($argumentIndex)&quot;;</span>
                      } else {
                          my $defaultValue = GenerateDefaultValue($interface, $argument, $argument-&gt;type, $argument-&gt;default);
<span class="udiff-line-modified-removed">-                         $optionalCheck = &quot;state-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;</span>
<span class="udiff-line-modified-removed">-                         $argumentLookupForConversion = &quot;state-&gt;uncheckedArgument($argumentIndex)&quot;</span>
<span class="udiff-line-modified-added">+                         $optionalCheck = &quot;callFrame-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;</span>
<span class="udiff-line-modified-added">+                         $argumentLookupForConversion = &quot;callFrame-&gt;uncheckedArgument($argumentIndex)&quot;</span>
                      }
                  } else {
                      my $argumentIDLType = GetIDLType($interface, $argument-&gt;type);
  
                      my $defaultValue;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5836,26 +5932,26 @@</span>
                      } else {
                          $defaultValue = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;()&quot;;
                          $nativeValueCastFunction = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;&quot;;
                      }
  
<span class="udiff-line-modified-removed">-                     $optionalCheck = &quot;state-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;</span>
<span class="udiff-line-modified-removed">-                     $argumentLookupForConversion = &quot;state-&gt;uncheckedArgument($argumentIndex)&quot;;</span>
<span class="udiff-line-modified-added">+                     $optionalCheck = &quot;callFrame-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;</span>
<span class="udiff-line-modified-added">+                     $argumentLookupForConversion = &quot;callFrame-&gt;uncheckedArgument($argumentIndex)&quot;;</span>
                  }
              } else {
                  if ($argument-&gt;extendedAttributes-&gt;{ReturnValue}) {
<span class="udiff-line-modified-removed">-                     push(@$outputArray, $indent . &quot;auto returnValue = state-&gt;uncheckedArgument($argumentIndex);\n&quot;);</span>
<span class="udiff-line-modified-added">+                     push(@$outputArray, $indent . &quot;auto returnValue = callFrame-&gt;uncheckedArgument($argumentIndex);\n&quot;);</span>
                      $argumentLookupForConversion = &quot;returnValue&quot;;
                  } else {
<span class="udiff-line-modified-removed">-                     $argumentLookupForConversion = &quot;state-&gt;uncheckedArgument($argumentIndex)&quot;;</span>
<span class="udiff-line-modified-added">+                     $argumentLookupForConversion = &quot;callFrame-&gt;uncheckedArgument($argumentIndex)&quot;;</span>
                  }
              }
  
<span class="udiff-line-modified-removed">-             my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*castedThis-&gt;globalObject()&quot;;</span>
<span class="udiff-line-modified-added">+             my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot; : &quot;*castedThis-&gt;globalObject()&quot;;</span>
              my $argumentExceptionThrower = GetArgumentExceptionThrower($interface, $argument, $argumentIndex, $quotedFunctionName);
  
<span class="udiff-line-modified-removed">-             my $nativeValue = JSValueToNative($interface, $argument, $argumentLookupForConversion, $conditional, &quot;state&quot;, &quot;*state&quot;, &quot;*castedThis&quot;, $globalObjectReference, $argumentExceptionThrower);</span>
<span class="udiff-line-modified-added">+             my $nativeValue = JSValueToNative($interface, $argument, $argumentLookupForConversion, $conditional, &quot;lexicalGlobalObject&quot;, &quot;*lexicalGlobalObject&quot;, &quot;*castedThis&quot;, $globalObjectReference, $argumentExceptionThrower);</span>
  
              $nativeValue = &quot;${nativeValueCastFunction}(&quot; . $nativeValue . &quot;)&quot; if defined $nativeValueCastFunction;
              $nativeValue = $optionalCheck . $nativeValue if defined $optionalCheck;
  
              push(@$outputArray, $indent . &quot;auto $name = ${nativeValue};\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5869,11 +5965,11 @@</span>
      }
  
      push(@arguments, &quot;WTFMove(promise)&quot;) if $operation-&gt;type &amp;&amp; $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy};
  
      my $functionString = &quot;$functionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
<span class="udiff-line-modified-removed">-     $functionString = &quot;propagateException(*state, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);</span>
<span class="udiff-line-modified-added">+     $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);</span>
  
      return $functionString;
  }
  
  sub GenerateDictionaryHeader
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6231,11 +6327,11 @@</span>
              push(@$contentRef, &quot;    Ref&lt;$className&gt; protectedThis(*this);\n\n&quot;);
              push(@$contentRef, &quot;    auto&amp; globalObject = *m_data-&gt;globalObject();\n&quot;);
              push(@$contentRef, &quot;    auto&amp; vm = globalObject.vm();\n\n&quot;);
              push(@$contentRef, &quot;    JSLockHolder lock(vm);\n&quot;);
  
<span class="udiff-line-modified-removed">-             push(@$contentRef, &quot;    auto&amp; state = *globalObject.globalExec();\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$contentRef, &quot;    auto&amp; lexicalGlobalObject = globalObject;\n&quot;);</span>
  
              push(@$contentRef, &quot;    JSValue thisValue = ${thisValue};\n&quot;);
              push(@$contentRef, &quot;    MarkedArgumentBuffer args;\n&quot;);
  
              foreach my $argument (@{$operation-&gt;arguments}) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6261,21 +6357,21 @@</span>
  
              $includesRef-&gt;{&quot;JSDOMExceptionHandling.h&quot;} = 1;
              push(@$contentRef, &quot;    if (returnedException) {\n&quot;);
              if ($operation-&gt;extendedAttributes-&gt;{RethrowException}) {
                  push(@$contentRef, &quot;        auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
<span class="udiff-line-modified-removed">-                 push(@$contentRef, &quot;        throwException(&amp;state, throwScope, returnedException);\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@$contentRef, &quot;        throwException(&amp;lexicalGlobalObject, throwScope, returnedException);\n&quot;);</span>
              } else {
<span class="udiff-line-modified-removed">-                 push(@$contentRef, &quot;        reportException(&amp;state, returnedException);\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@$contentRef, &quot;        reportException(&amp;lexicalGlobalObject, returnedException);\n&quot;);</span>
              }
              push(@$contentRef, &quot;        return CallbackResultType::ExceptionThrown;\n&quot;);
              push(@$contentRef, &quot;     }\n\n&quot;);
  
              if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
                  push(@$contentRef, &quot;    return { };\n&quot;);
              } else {
<span class="udiff-line-modified-removed">-                 my $nativeValue = JSValueToNative($interfaceOrCallback, $operation, &quot;jsResult&quot;, &quot;&quot;, &quot;&amp;state&quot;, &quot;state&quot;);</span>
<span class="udiff-line-modified-added">+                 my $nativeValue = JSValueToNative($interfaceOrCallback, $operation, &quot;jsResult&quot;, &quot;&quot;, &quot;&amp;lexicalGlobalObject&quot;, &quot;lexicalGlobalObject&quot;);</span>
              
                  push(@$contentRef, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
                  push(@$contentRef, &quot;    auto returnValue = ${nativeValue};\n&quot;);
                  push(@$contentRef, &quot;    RETURN_IF_EXCEPTION(throwScope, CallbackResultType::ExceptionThrown);\n&quot;);
                  push(@$contentRef, &quot;    return returnValue;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6315,21 +6411,22 @@</span>
          push(@$outputArray, $indent . &quot;return JSValue::encode(returnValue);\n&quot;);
      } elsif ($operation-&gt;type-&gt;name eq &quot;void&quot; || ($codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy})) {
          push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
          push(@$outputArray, $indent . &quot;return JSValue::encode(jsUndefined());\n&quot;);
      } else {
<span class="udiff-line-modified-removed">-         my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*castedThis-&gt;globalObject()&quot;;</span>
<span class="udiff-line-modified-added">+         my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot; : &quot;*castedThis-&gt;globalObject()&quot;;</span>
          push(@$outputArray, $indent . &quot;return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, $globalObjectReference) . &quot;);\n&quot;);
      }
  }
  
  sub GenerateImplementationCustomFunctionCall
  {
      my ($outputArray, $operation, $interface, $className, $functionImplementationName, $indent) = @_;
  
      my @customFunctionArguments = ();
<span class="udiff-line-modified-removed">-     push(@customFunctionArguments, &quot;*state&quot;);</span>
<span class="udiff-line-modified-added">+     push(@customFunctionArguments, &quot;*lexicalGlobalObject&quot;);</span>
<span class="udiff-line-added">+     push(@customFunctionArguments, &quot;*callFrame&quot;);</span>
      push(@customFunctionArguments, &quot;WTFMove(promise)&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
  
      if ($operation-&gt;isStatic) {
          push(@$outputArray, $indent . &quot;return JSValue::encode(${className}::&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6373,10 +6470,13 @@</span>
      my $iteratorTraitsName = &quot;${interfaceName}IteratorTraits&quot;;
      my $iteratorTraitsType = $interface-&gt;iterable-&gt;isKeyValue ? &quot;JSDOMIteratorType::Map&quot; : &quot;JSDOMIteratorType::Set&quot;;
      my $iteratorTraitsKeyType = $interface-&gt;iterable-&gt;isKeyValue ? GetIDLType($interface, $interface-&gt;iterable-&gt;keyType) : &quot;void&quot;;
      my $iteratorTraitsValueType = GetIDLType($interface, $interface-&gt;iterable-&gt;valueType);
  
<span class="udiff-line-added">+     AddToImplIncludesForIDLType($interface-&gt;iterable-&gt;keyType) if $interface-&gt;iterable-&gt;isKeyValue;</span>
<span class="udiff-line-added">+     AddToImplIncludesForIDLType($interface-&gt;iterable-&gt;valueType);</span>
<span class="udiff-line-added">+ </span>
      push(@implContent,  &lt;&lt;END);
  struct ${iteratorTraitsName} {
      static constexpr JSDOMIteratorType type = ${iteratorTraitsType};
      using KeyType = ${iteratorTraitsKeyType};
      using ValueType = ${iteratorTraitsValueType};
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6399,35 +6499,35 @@</span>
  
          next if $propertyName eq &quot;[Symbol.Iterator]&quot;;
  
          if ($propertyName eq &quot;forEach&quot;) {
              push(@implContent,  &lt;&lt;END);
<span class="udiff-line-modified-removed">- static inline EncodedJSValue ${functionName}Caller(ExecState* state, JS$interfaceName* thisObject, JSC::ThrowScope&amp; throwScope)</span>
<span class="udiff-line-modified-added">+ static inline EncodedJSValue ${functionName}Caller(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame, JS$interfaceName* thisObject, JSC::ThrowScope&amp; throwScope)</span>
  {
<span class="udiff-line-modified-removed">-     return JSValue::encode(iteratorForEach&lt;${iteratorName}&gt;(*state, *thisObject, throwScope));</span>
<span class="udiff-line-modified-added">+     return JSValue::encode(iteratorForEach&lt;${iteratorName}&gt;(*lexicalGlobalObject, *callFrame, *thisObject, throwScope));</span>
  }
  
  END
          } else {
<span class="udiff-line-modified-removed">-             my $iterationKind = &quot;KeyValue&quot;;</span>
<span class="udiff-line-modified-removed">-             $iterationKind = &quot;Key&quot; if $propertyName eq &quot;keys&quot;;</span>
<span class="udiff-line-modified-removed">-             $iterationKind = &quot;Value&quot; if $propertyName eq &quot;values&quot;;</span>
<span class="udiff-line-modified-removed">-             $iterationKind = &quot;Value&quot; if $propertyName eq &quot;entries&quot; and not $interface-&gt;iterable-&gt;isKeyValue;</span>
<span class="udiff-line-modified-added">+             my $iterationKind = &quot;Entries&quot;;</span>
<span class="udiff-line-modified-added">+             $iterationKind = &quot;Keys&quot; if $propertyName eq &quot;keys&quot;;</span>
<span class="udiff-line-modified-added">+             $iterationKind = &quot;Values&quot; if $propertyName eq &quot;values&quot;;</span>
<span class="udiff-line-modified-added">+             $iterationKind = &quot;Values&quot; if $propertyName eq &quot;entries&quot; and not $interface-&gt;iterable-&gt;isKeyValue;</span>
  
              push(@implContent,  &lt;&lt;END);
<span class="udiff-line-modified-removed">- static inline EncodedJSValue ${functionName}Caller(ExecState*, JS$interfaceName* thisObject, JSC::ThrowScope&amp;)</span>
<span class="udiff-line-modified-added">+ static inline EncodedJSValue ${functionName}Caller(JSGlobalObject*, CallFrame*, JS$interfaceName* thisObject, JSC::ThrowScope&amp;)</span>
  {
      return JSValue::encode(iteratorCreate&lt;${iteratorName}&gt;(*thisObject, IterationKind::${iterationKind}));
  }
  
  END
          }
  
          push(@implContent,  &lt;&lt;END);
<span class="udiff-line-modified-removed">- JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState* state)</span>
<span class="udiff-line-modified-added">+ JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)</span>
  {
<span class="udiff-line-modified-removed">-     return IDLOperation&lt;${className}&gt;::call&lt;${functionName}Caller&gt;(*state, &quot;${propertyName}&quot;);</span>
<span class="udiff-line-modified-added">+     return IDLOperation&lt;${className}&gt;::call&lt;${functionName}Caller&gt;(*lexicalGlobalObject, *callFrame, &quot;${propertyName}&quot;);</span>
  }
  
  END
      }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6614,10 +6714,11 @@</span>
  {
      my $type = shift;
  
      return 1 if $codeGenerator-&gt;IsCallbackInterface($type);
      return 1 if $codeGenerator-&gt;IsCallbackFunction($type);
<span class="udiff-line-added">+     return JSValueToNativeDOMConvertNeedsGlobalObject(@{$type-&gt;subtypes}[1]) if $codeGenerator-&gt;IsRecordType($type);</span>
      return 1 if $type-&gt;name eq &quot;ScheduledAction&quot;;
      return 0;
  }
  
  sub IsValidContextForJSValueToNative
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6626,47 +6727,47 @@</span>
      return (ref($context) eq &quot;IDLAttribute&quot; &amp;&amp; !$codeGenerator-&gt;IsEnumType($context-&gt;type)) || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
  }
  
  sub JSValueToNative
  {
<span class="udiff-line-modified-removed">-     my ($interface, $context, $value, $conditional, $statePointer, $stateReference, $thisObjectReference, $globalObjectReference, $exceptionThrower) = @_;</span>
<span class="udiff-line-modified-added">+     my ($interface, $context, $value, $conditional, $lexicalGlobalObjectPointer, $lexicalGlobalObjectReference, $thisObjectReference, $globalObjectReference, $exceptionThrower) = @_;</span>
  
      assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
  
      my $type = $context-&gt;type;
  
      # FIXME: Remove these 3 variables when all JSValueToNative use references.
<span class="udiff-line-modified-removed">-     $statePointer = &quot;state&quot; unless $statePointer;</span>
<span class="udiff-line-modified-removed">-     $stateReference = &quot;*state&quot; unless $stateReference;</span>
<span class="udiff-line-modified-added">+     $lexicalGlobalObjectPointer = &quot;lexicalGlobalObject&quot; unless $lexicalGlobalObjectPointer;</span>
<span class="udiff-line-modified-added">+     $lexicalGlobalObjectReference = &quot;*lexicalGlobalObject&quot; unless $lexicalGlobalObjectReference;</span>
      $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
  
      AddToImplIncludesForIDLType($type, $conditional);
      AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
  
      my $IDLType = GetIDLType($interface, $type);
  
      my @conversionArguments = ();
<span class="udiff-line-modified-removed">-     push(@conversionArguments, $stateReference);</span>
<span class="udiff-line-modified-added">+     push(@conversionArguments, $lexicalGlobalObjectReference);</span>
      push(@conversionArguments, $value);
      push(@conversionArguments, $thisObjectReference) if JSValueToNativeDOMConvertNeedsThisObject($type);
      push(@conversionArguments, $globalObjectReference) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
      push(@conversionArguments, $exceptionThrower) if $exceptionThrower;
  
      return &quot;convert&lt;$IDLType&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
  }
  
  sub ToNativeForFunctionWithoutTypeCheck
  {
<span class="udiff-line-modified-removed">-     my ($interface, $context, $value, $conditional, $statePointer, $stateReference, $thisObjectReference) = @_;</span>
<span class="udiff-line-modified-added">+     my ($interface, $context, $value, $conditional, $lexicalGlobalObjectPointer, $lexicalGlobalObjectReference, $thisObjectReference) = @_;</span>
  
      assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
  
      my $type = $context-&gt;type;
  
      # FIXME: Remove these 3 variables when all JSValueToNative use references.
<span class="udiff-line-modified-removed">-     $statePointer = &quot;state&quot; unless $statePointer;</span>
<span class="udiff-line-modified-removed">-     $stateReference = &quot;*state&quot; unless $stateReference;</span>
<span class="udiff-line-modified-added">+     $lexicalGlobalObjectPointer = &quot;lexicalGlobalObject&quot; unless $lexicalGlobalObjectPointer;</span>
<span class="udiff-line-modified-added">+     $lexicalGlobalObjectReference = &quot;*lexicalGlobalObject&quot; unless $lexicalGlobalObjectReference;</span>
      $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
  
      AddToImplIncludesForIDLType($type, $conditional);
  
      # FIXME: Support more types.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6674,11 +6775,11 @@</span>
      AddToImplIncludes(&quot;DOMJITIDLConvert.h&quot;);
  
      my $IDLType = GetIDLType($interface, $type);
  
      my @conversionArguments = ();
<span class="udiff-line-modified-removed">-     push(@conversionArguments, &quot;$stateReference&quot;);</span>
<span class="udiff-line-modified-added">+     push(@conversionArguments, &quot;$lexicalGlobalObjectReference&quot;);</span>
      push(@conversionArguments, &quot;$value&quot;);
  
      return (&quot;DOMJIT::DirectConverter&lt;$IDLType&gt;::directConvert(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;, 1);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6686,21 +6787,21 @@</span>
  {
      my ($type) = @_;
  
      # FIXME: We need a more robust way to specify this requirement so as not
      # to require specializing each type. Perhaps just requiring all override
<span class="udiff-line-modified-removed">-     # types to take both state and the global object would work?</span>
<span class="udiff-line-modified-added">+     # types to take both lexicalGlobalObject and the global object would work?</span>
      if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
          my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
          return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
          return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
          return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
  
          return 0;
      }
  
<span class="udiff-line-modified-removed">-     # FIXME: This should actually check if all the sub-objects of the union need the state.</span>
<span class="udiff-line-modified-added">+     # FIXME: This should actually check if all the sub-objects of the union need the lexicalGlobalObject.</span>
      return 1 if $type-&gt;isUnion;
      return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
      return 1 if $codeGenerator-&gt;IsRecordType($type);
      return 1 if $codeGenerator-&gt;IsStringType($type);
      return 1 if $codeGenerator-&gt;IsEnumType($type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6720,11 +6821,11 @@</span>
  {
      my ($type) = @_;
      
      # FIXME: We need a more robust way to specify this requirement so as not
      # to require specializing each type. Perhaps just requiring all override
<span class="udiff-line-modified-removed">-     # types to take both state and the global object would work?</span>
<span class="udiff-line-modified-added">+     # types to take both lexicalGlobalObject and the global object would work?</span>
      if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
          my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
          return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
          return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
          return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6748,19 +6849,19 @@</span>
  
  sub NativeToJSValueUsingReferences
  {
      my ($context, $interface, $value, $globalObjectReference) = @_;
  
<span class="udiff-line-modified-removed">-     return NativeToJSValue($context, $interface, $value, &quot;state&quot;, $globalObjectReference);</span>
<span class="udiff-line-modified-added">+     return NativeToJSValue($context, $interface, $value, &quot;lexicalGlobalObject&quot;, $globalObjectReference);</span>
  }
  
  # FIXME: We should remove NativeToJSValueUsingPointers and combine NativeToJSValueUsingReferences and NativeToJSValue
  sub NativeToJSValueUsingPointers
  {
      my ($context, $interface, $value, $globalObjectReference) = @_;
  
<span class="udiff-line-modified-removed">-     return NativeToJSValue($context, $interface, $value, &quot;*state&quot;, $globalObjectReference);</span>
<span class="udiff-line-modified-added">+     return NativeToJSValue($context, $interface, $value, &quot;*lexicalGlobalObject&quot;, $globalObjectReference);</span>
  }
  
  sub IsValidContextForNativeToJSValue
  {
      my $context = shift;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6768,11 +6869,11 @@</span>
      return ref($context) eq &quot;IDLAttribute&quot; || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
  }
  
  sub NativeToJSValue
  {
<span class="udiff-line-modified-removed">-     my ($context, $interface, $value, $stateReference, $globalObjectReference) = @_;</span>
<span class="udiff-line-modified-added">+     my ($context, $interface, $value, $lexicalGlobalObjectReference, $globalObjectReference) = @_;</span>
  
      assert(&quot;Invalid context type&quot;) if !IsValidContextForNativeToJSValue($context);
  
      my $conditional = $context-&gt;extendedAttributes-&gt;{Conditional};
      my $type = $context-&gt;type;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6788,17 +6889,17 @@</span>
      AddToImplIncludesForIDLType($type, $conditional);
      AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
  
      if ($context-&gt;extendedAttributes-&gt;{CheckSecurityForNode}) {
          AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
<span class="udiff-line-modified-removed">-         $value = &quot;BindingSecurity::checkSecurityForNode($stateReference, $value)&quot;;</span>
<span class="udiff-line-modified-added">+         $value = &quot;BindingSecurity::checkSecurityForNode($lexicalGlobalObjectReference, $value)&quot;;</span>
      }
  
      my $IDLType = GetIDLType($interface, $type);
  
      my @conversionArguments = ();
<span class="udiff-line-modified-removed">-     push(@conversionArguments, $stateReference) if NativeToJSValueDOMConvertNeedsState($type) || $mayThrowException;</span>
<span class="udiff-line-modified-added">+     push(@conversionArguments, $lexicalGlobalObjectReference) if NativeToJSValueDOMConvertNeedsState($type) || $mayThrowException;</span>
      push(@conversionArguments, $globalObjectReference) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
      push(@conversionArguments, &quot;throwScope&quot;) if $mayThrowException;
      push(@conversionArguments, $value);
  
      my $functionName = $context-&gt;extendedAttributes-&gt;{NewObject} ? &quot;toJSNewlyCreated&quot; : &quot;toJS&quot;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7111,42 +7212,43 @@</span>
      push(@$outputArray, &quot;        : JSC::JSNonFinalObject(vm, structure)\n&quot;);
      push(@$outputArray, &quot;    {\n&quot;);
      push(@$outputArray, &quot;    }\n&quot;);
  
      if (PrototypeHasStaticPropertyTable($interface)) {
<span class="udiff-line-modified-removed">-         if (IsGlobalOrPrimaryGlobalInterface($interface)) {</span>
<span class="udiff-line-modified-added">+         if (IsGlobalInterface($interface)) {</span>
              $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1;
          } else {
              push(@$outputArray, &quot;\n&quot;);
              push(@$outputArray, &quot;    void finishCreation(JSC::VM&amp;);\n&quot;);
          }
      }
  
      # FIXME: Should this override putByIndex as well?
      if ($interface-&gt;extendedAttributes-&gt;{CustomPutOnPrototype}) {
          push(@$outputArray, &quot;\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    static bool put(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    static bool put(JSC::JSCell*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);</span>
      }
  
      if ($interface-&gt;extendedAttributes-&gt;{CustomDefineOwnPropertyOnPrototype}) {
          push(@$outputArray, &quot;\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);</span>
      }
  
      $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObjectOnPrototype};
  
      # structure flags
      if (%structureFlags) {
          push(@$outputArray, &quot;public:\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;    static const unsigned StructureFlags = Base::StructureFlags&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;    static constexpr unsigned StructureFlags = Base::StructureFlags&quot;);</span>
          foreach my $structureFlag (sort (keys %structureFlags)) {
              push(@$outputArray, &quot; | &quot; . $structureFlag);
          }
          push(@$outputArray, &quot;;\n&quot;);
      }
  
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;};\n\n&quot;);</span>
<span class="udiff-line-modified-added">+     push(@$outputArray, &quot;};\n&quot;);</span>
<span class="udiff-line-added">+     push(@$outputArray, &quot;STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(${prototypeClassName}, ${prototypeClassName}::Base);\n\n&quot;);</span>
  }
  
  sub GetConstructorTemplateClassName
  {
      my $interface = shift;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7183,17 +7285,17 @@</span>
                  GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructor);
              }
  
              my $overloadFunctionPrefix = &quot;construct${className}&quot;;
  
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${className}Constructor::construct(ExecState* state)\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${className}Constructor::construct(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
              push(@implContent, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-             push(@implContent, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@implContent, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);</span>
              push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
              push(@implContent, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
  
<span class="udiff-line-modified-removed">-             GenerateOverloadDispatcher(@{$interface-&gt;constructors}[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;state&quot;);</span>
<span class="udiff-line-modified-added">+             GenerateOverloadDispatcher(@{$interface-&gt;constructors}[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;lexicalGlobalObject, callFrame&quot;);</span>
  
              push(@implContent, &quot;}\n\n&quot;);
          } elsif (@constructors == 1) {
              GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructors[0]);
          } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7213,30 +7315,38 @@</span>
      my $interfaceName = $interface-&gt;type-&gt;name;
      my $constructorClassName = $generatingNamedConstructor ? &quot;${className}NamedConstructor&quot; : &quot;${className}Constructor&quot;;
  
      if (IsConstructable($interface)) {
          if ($interface-&gt;extendedAttributes-&gt;{CustomConstructor}) {
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;template&lt;&gt; JSC::EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(JSC::ExecState* exec)\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;template&lt;&gt; JSC::EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)\n&quot;);</span>
              push(@$outputArray, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    ASSERT(exec);\n&quot;);</span>
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    return construct${className}(*exec);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    ASSERT(callFrame);\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    return construct${className}(lexicalGlobalObject, *callFrame);\n&quot;);</span>
              push(@$outputArray, &quot;}\n\n&quot;);
           } elsif (!HasCustomConstructor($interface) &amp;&amp; (!$interface-&gt;extendedAttributes-&gt;{NamedConstructor} || $generatingNamedConstructor)) {
              my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
              if ($isOverloaded) {
<span class="udiff-line-modified-removed">-                 push(@$outputArray, &quot;static inline EncodedJSValue construct${className}$operation-&gt;{overloadIndex}(ExecState* state)\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@$outputArray, &quot;static inline EncodedJSValue construct${className}$operation-&gt;{overloadIndex}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
              } else {
<span class="udiff-line-modified-removed">-                 push(@$outputArray, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(ExecState* state)\n&quot;);</span>
<span class="udiff-line-modified-added">+                 push(@$outputArray, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
              }
  
              push(@$outputArray, &quot;{\n&quot;);
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);</span>
              push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
              push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
<span class="udiff-line-modified-removed">-             push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${constructorClassName}*&gt;(state-&gt;jsCallee());\n&quot;);</span>
<span class="udiff-line-modified-added">+             push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${constructorClassName}*&gt;(callFrame-&gt;jsCallee());\n&quot;);</span>
              push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
  
<span class="udiff-line-added">+              if ($interface-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting}) {</span>
<span class="udiff-line-added">+                  my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operation, &quot;lexicalGlobalObject&quot;);</span>
<span class="udiff-line-added">+                  push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);</span>
<span class="udiff-line-added">+                  push(@$outputArray, &quot;        throwTypeError(lexicalGlobalObject, throwScope, \&quot;Illegal constructor\&quot;_s);\n&quot;);</span>
<span class="udiff-line-added">+                  push(@$outputArray, &quot;        return JSValue::encode(jsNull());\n&quot;);</span>
<span class="udiff-line-added">+                  push(@$outputArray, &quot;    }\n&quot;);</span>
<span class="udiff-line-added">+              }</span>
<span class="udiff-line-added">+ </span>
              GenerateArgumentsCountCheck($outputArray, $operation, $interface, &quot;    &quot;);
  
              my $functionImplementationName = $generatingNamedConstructor ? &quot;createForJSConstructor&quot; : &quot;create&quot;;
              my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, &quot;    &quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7246,11 +7356,11 @@</span>
              my $IDLType = GetIDLType($interface, $interface-&gt;type);
  
              AddToImplIncludes(&quot;JSDOMConvertInterface.h&quot;);
  
              my @constructionConversionArguments = ();
<span class="udiff-line-modified-removed">-             push(@constructionConversionArguments, &quot;*state&quot;);</span>
<span class="udiff-line-modified-added">+             push(@constructionConversionArguments, &quot;*lexicalGlobalObject&quot;);</span>
              push(@constructionConversionArguments, &quot;*castedThis-&gt;globalObject()&quot;);
              push(@constructionConversionArguments, &quot;throwScope&quot;) if $interface-&gt;extendedAttributes-&gt;{ConstructorMayThrowException};
              push(@constructionConversionArguments, &quot;WTFMove(object)&quot;);
  
              push(@$outputArray, &quot;    return JSValue::encode(toJSNewlyCreated&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @constructionConversionArguments) . &quot;));\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7286,10 +7396,11 @@</span>
  
      my @runtimeEnabledProperties = ();
  
      my @attributes = @{$interface-&gt;attributes};
      push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
<span class="udiff-line-added">+     push(@attributes, @{$interface-&gt;setLike-&gt;attributes}) if $interface-&gt;setLike;</span>
  
      foreach my $attribute (@attributes) {
          next if AttributeShouldBeOnInstance($interface, $attribute) != 0;
          next if not $attribute-&gt;isStatic;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7299,10 +7410,11 @@</span>
      }
  
      my @operations = @{$interface-&gt;operations};
      push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
      push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
<span class="udiff-line-added">+     push(@operations, @{$interface-&gt;setLike-&gt;operations}) if $interface-&gt;setLike;</span>
      push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
      foreach my $operation (@operations) {
          next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
          next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
          next if OperationShouldBeOnInstance($interface, $operation) != 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7366,11 +7478,20 @@</span>
      } else {
          push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, ${className}::prototype(vm, globalObject), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
      }
  
      push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;name, jsNontrivialString(vm, String(\&quot;$visibleInterfaceName\&quot;_s)), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
<span class="udiff-line-modified-removed">-     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(${leastConstructorLength}), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;) if defined $leastConstructorLength;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     if ($interface-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting}) {</span>
<span class="udiff-line-added">+         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $interface, &quot;&amp;globalObject&quot;);</span>
<span class="udiff-line-added">+         push(@$outputArray, &quot;    int constructorLength = ${leastConstructorLength};\n&quot;);</span>
<span class="udiff-line-added">+         push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString})\n&quot;);</span>
<span class="udiff-line-added">+         push(@$outputArray, &quot;        constructorLength = 0;\n&quot;);</span>
<span class="udiff-line-added">+         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(constructorLength), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(${leastConstructorLength}), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);</span>
<span class="udiff-line-added">+     }</span>
  
      my $classForThis = &quot;${className}::info()&quot;;
      if ($interface-&gt;isCallback) {
          $classForThis = &quot;nullptr&quot;;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7379,16 +7500,16 @@</span>
      my @runtimeEnabledProperties = GetRuntimeEnabledStaticProperties($interface);
  
      foreach my $operationOrAttribute (@runtimeEnabledProperties) {
          my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
          push(@$outputArray, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
<span class="udiff-line-modified-removed">-         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute, &quot;true&quot;);</span>
<span class="udiff-line-modified-added">+         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute, &quot;&amp;globalObject&quot;);</span>
          my $name = $operationOrAttribute-&gt;name;
          push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
          push(@$outputArray, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);
          push(@$outputArray, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
<span class="udiff-line-modified-removed">-         push(@$outputArray, &quot;        JSObject::deleteProperty(this, globalObject.globalExec(), propertyName);\n&quot;);</span>
<span class="udiff-line-modified-added">+         push(@$outputArray, &quot;        JSObject::deleteProperty(this, &amp;globalObject, propertyName);\n&quot;);</span>
          push(@$outputArray, &quot;    }\n&quot;);
          push(@$outputArray, &quot;#endif\n&quot;) if $conditionalString;
      }
  
      push(@$outputArray, &quot;}\n\n&quot;);
</pre>
<center><a href="CodeGenerator.pm.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDLAttributes.json.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
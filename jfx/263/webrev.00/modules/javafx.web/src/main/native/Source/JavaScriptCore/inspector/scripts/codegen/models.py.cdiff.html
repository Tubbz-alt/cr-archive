<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/models.py</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="generator.py.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="objc_generator_templates.py.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/models.py</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 36,10 ***</span>
<span class="line-new-header">--- 36,28 ---</span>
  
  def find_duplicates(l):
      return [key for key, count in list(collections.Counter(l).items()) if count &gt; 1]
  
  
<span class="line-added">+ def validate_target_types(debuggable_types, target_types):</span>
<span class="line-added">+     for target_type in target_types:</span>
<span class="line-added">+         required_debuggable_types = set()</span>
<span class="line-added">+         if target_type == &#39;javascript&#39;:</span>
<span class="line-added">+             if not &#39;javascript&#39; in debuggable_types:</span>
<span class="line-added">+                 return False</span>
<span class="line-added">+         elif target_type == &#39;page&#39; or target_type == &#39;worker&#39;:</span>
<span class="line-added">+             if not &#39;page&#39; in debuggable_types:</span>
<span class="line-added">+                 return False</span>
<span class="line-added">+         elif target_type == &#39;service-worker&#39;:</span>
<span class="line-added">+             if not &#39;service-worker&#39; in debuggable_types:</span>
<span class="line-added">+                 return False</span>
<span class="line-added">+         elif target_type == &#39;web-page&#39;:</span>
<span class="line-added">+             if not &#39;web-page&#39; in debuggable_types:</span>
<span class="line-added">+                 return False</span>
<span class="line-added">+     return True</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  _FRAMEWORK_CONFIG_MAP = {
      &quot;Global&quot;: {
      },
      &quot;JavaScriptCore&quot;: {
          &quot;cpp_protocol_group&quot;: &quot;Inspector&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,10 ***</span>
<span class="line-new-header">--- 82,13 ---</span>
          &quot;objc_protocol_group&quot;: &quot;Test&quot;,
          &quot;objc_prefix&quot;: &quot;Test&quot;,
      }
  }
  
<span class="line-added">+ _ALLOWED_DEBUGGABLE_TYPE_STRINGS = frozenset([&#39;javascript&#39;, &#39;page&#39;, &#39;service-worker&#39;, &#39;web-page&#39;])</span>
<span class="line-added">+ _ALLOWED_TARGET_TYPE_STRINGS = frozenset([&#39;javascript&#39;, &#39;page&#39;, &#39;service-worker&#39;, &#39;web-page&#39;, &#39;worker&#39;])</span>
<span class="line-added">+ </span>
  
  class ParseException(Exception):
      pass
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 366,15 ***</span>
<span class="line-new-header">--- 387,40 ---</span>
  
      def parse_domain(self, json, isSupplemental):
          check_for_required_properties([&#39;domain&#39;], json, &quot;domain&quot;)
          log.debug(&quot;parse domain &quot; + json[&#39;domain&#39;])
  
<span class="line-added">+         debuggable_types = None</span>
<span class="line-added">+         target_types = None</span>
          version = None
          types = []
          commands = []
          events = []
  
<span class="line-added">+         if &#39;debuggableTypes&#39; in json:</span>
<span class="line-added">+             if not isinstance(json[&#39;debuggableTypes&#39;], list):</span>
<span class="line-added">+                 raise ParseException(&quot;Malformed domain specification: debuggableTypes for domain %s is not an array&quot; % json[&#39;domain&#39;])</span>
<span class="line-added">+ </span>
<span class="line-added">+             for debuggable_types in json[&#39;debuggableTypes&#39;]:</span>
<span class="line-added">+                 if debuggable_types not in _ALLOWED_DEBUGGABLE_TYPE_STRINGS:</span>
<span class="line-added">+                     raise ParseException(&#39;Malformed domain specification: debuggableTypes for domain %s is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;domain&#39;], json[&#39;debuggableTypes&#39;], &#39;, &#39;.join(_ALLOWED_DEBUGGABLE_TYPE_STRINGS)))</span>
<span class="line-added">+ </span>
<span class="line-added">+             debuggable_types = json.get(&#39;debuggableTypes&#39;)</span>
<span class="line-added">+ </span>
<span class="line-added">+         if &#39;targetTypes&#39; in json:</span>
<span class="line-added">+             if not isinstance(json[&#39;targetTypes&#39;], list):</span>
<span class="line-added">+                 raise ParseException(&quot;Malformed domain specification: targetTypes for domain %s is not an array&quot; % json[&#39;domain&#39;])</span>
<span class="line-added">+ </span>
<span class="line-added">+             for target_types in json[&#39;targetTypes&#39;]:</span>
<span class="line-added">+                 if target_types not in _ALLOWED_TARGET_TYPE_STRINGS:</span>
<span class="line-added">+                     raise ParseException(&#39;Malformed domain specification: targetTypes for domain %s is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;domain&#39;], json[&#39;targetTypes&#39;], &#39;, &#39;.join(_ALLOWED_TARGET_TYPE_STRINGS)))</span>
<span class="line-added">+ </span>
<span class="line-added">+             target_types = json.get(&#39;targetTypes&#39;)</span>
<span class="line-added">+ </span>
<span class="line-added">+             if debuggable_types and not validate_target_types(debuggable_types, target_types):</span>
<span class="line-added">+                 raise ParseException(&#39;Malformed domain specification: domain %s has an item in targetTypes &quot;%s&quot; that is not supported by any value in debuggableTypes &quot;%s&quot;.&#39; % (json[&#39;domain&#39;], target_types, debuggable_types))</span>
<span class="line-added">+ </span>
          if &#39;version&#39; in json:
              if not isinstance(json[&#39;version&#39;], int):
                  raise ParseException(&quot;Malformed domain specification: version is not a number or string&quot;)
              version = json[&#39;version&#39;]
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,26 ***</span>
              types.extend([self.parse_type_declaration(declaration) for declaration in json[&#39;types&#39;]])
  
          if &#39;commands&#39; in json:
              if not isinstance(json[&#39;commands&#39;], list):
                  raise ParseException(&quot;Malformed domain specification: commands is not an array&quot;)
<span class="line-modified">!             commands.extend([self.parse_command(command) for command in json[&#39;commands&#39;]])</span>
  
          if &#39;events&#39; in json:
              if not isinstance(json[&#39;events&#39;], list):
                  raise ParseException(&quot;Malformed domain specification: events is not an array&quot;)
<span class="line-modified">!             events.extend([self.parse_event(event) for event in json[&#39;events&#39;]])</span>
  
<span class="line-modified">!         if &#39;availability&#39; in json:</span>
<span class="line-removed">-             if not isinstance(json[&#39;availability&#39;], list):</span>
<span class="line-removed">-                 raise ParseException(&quot;Malformed domain specification: availability is not an array&quot;)</span>
<span class="line-removed">-             allowed_activation_strings = set([&#39;javascript&#39;, &#39;web&#39;, &#39;worker&#39;, &#39;service-worker&#39;])</span>
<span class="line-removed">-             for availability_type in json[&#39;availability&#39;]:</span>
<span class="line-removed">-                 if availability_type not in allowed_activation_strings:</span>
<span class="line-removed">-                     raise ParseException(&#39;Malformed domain specification: availability is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;availability&#39;], &#39;, &#39;.join(allowed_activation_strings)))</span>
<span class="line-removed">- </span>
<span class="line-removed">-         self.domains.append(Domain(json[&#39;domain&#39;], json.get(&#39;description&#39;, &#39;&#39;), json.get(&#39;featureGuard&#39;), json.get(&#39;availability&#39;), isSupplemental, version, types, commands, events))</span>
  
      def parse_type_declaration(self, json):
          check_for_required_properties([&#39;id&#39;, &#39;type&#39;], json, &quot;type&quot;)
          log.debug(&quot;parse type %s&quot; % json[&#39;id&#39;])
  
<span class="line-new-header">--- 430,18 ---</span>
              types.extend([self.parse_type_declaration(declaration) for declaration in json[&#39;types&#39;]])
  
          if &#39;commands&#39; in json:
              if not isinstance(json[&#39;commands&#39;], list):
                  raise ParseException(&quot;Malformed domain specification: commands is not an array&quot;)
<span class="line-modified">!             commands.extend([self.parse_command(command, debuggable_types) for command in json[&#39;commands&#39;]])</span>
  
          if &#39;events&#39; in json:
              if not isinstance(json[&#39;events&#39;], list):
                  raise ParseException(&quot;Malformed domain specification: events is not an array&quot;)
<span class="line-modified">!             events.extend([self.parse_event(event, debuggable_types) for event in json[&#39;events&#39;]])</span>
  
<span class="line-modified">!         self.domains.append(Domain(json[&#39;domain&#39;], json.get(&#39;description&#39;, &#39;&#39;), json.get(&#39;featureGuard&#39;), debuggable_types, target_types, isSupplemental, version, types, commands, events))</span>
  
      def parse_type_declaration(self, json):
          check_for_required_properties([&#39;id&#39;, &#39;type&#39;], json, &quot;type&quot;)
          log.debug(&quot;parse type %s&quot; % json[&#39;id&#39;])
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,17 ***</span>
          log.debug(&quot;parse type member %s&quot; % json[&#39;name&#39;])
  
          type_ref = TypeReference(json.get(&#39;type&#39;), json.get(&#39;$ref&#39;), json.get(&#39;enum&#39;), json.get(&#39;items&#39;))
          return TypeMember(json[&#39;name&#39;], type_ref, json.get(&#39;optional&#39;, False), json.get(&#39;description&#39;, &quot;&quot;))
  
<span class="line-modified">!     def parse_command(self, json):</span>
          check_for_required_properties([&#39;name&#39;], json, &quot;command&quot;)
          log.debug(&quot;parse command %s&quot; % json[&#39;name&#39;])
  
          call_parameters = []
          return_parameters = []
  
          if &#39;parameters&#39; in json:
              if not isinstance(json[&#39;parameters&#39;], list):
                  raise ParseException(&quot;Malformed command specification: parameters is not an array&quot;)
              call_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;parameters&#39;]])
  
<span class="line-new-header">--- 465,34 ---</span>
          log.debug(&quot;parse type member %s&quot; % json[&#39;name&#39;])
  
          type_ref = TypeReference(json.get(&#39;type&#39;), json.get(&#39;$ref&#39;), json.get(&#39;enum&#39;), json.get(&#39;items&#39;))
          return TypeMember(json[&#39;name&#39;], type_ref, json.get(&#39;optional&#39;, False), json.get(&#39;description&#39;, &quot;&quot;))
  
<span class="line-modified">!     def parse_command(self, json, debuggable_types):</span>
          check_for_required_properties([&#39;name&#39;], json, &quot;command&quot;)
          log.debug(&quot;parse command %s&quot; % json[&#39;name&#39;])
  
<span class="line-added">+         target_types = None</span>
          call_parameters = []
          return_parameters = []
  
<span class="line-added">+         if &#39;targetTypes&#39; in json:</span>
<span class="line-added">+             if not isinstance(json[&#39;targetTypes&#39;], list):</span>
<span class="line-added">+                 raise ParseException(&quot;Malformed domain specification: targetTypes list for command %s is not an array&quot; % json[&#39;name&#39;])</span>
<span class="line-added">+             target_types = json[&#39;targetTypes&#39;]</span>
<span class="line-added">+ </span>
<span class="line-added">+             for target_type in target_types:</span>
<span class="line-added">+                 if target_type not in _ALLOWED_TARGET_TYPE_STRINGS:</span>
<span class="line-added">+                     raise ParseException(&#39;Malformed domain specification: targetTypes list for command %s is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;name&#39;], json[&#39;targetTypes&#39;], &#39;, &#39;.join(_ALLOWED_TARGET_TYPE_STRINGS)))</span>
<span class="line-added">+ </span>
<span class="line-added">+             duplicate_types = find_duplicates(target_types)</span>
<span class="line-added">+             if len(duplicate_types) &gt; 0:</span>
<span class="line-added">+                 raise ParseException(&quot;Malformed domain specification: targetTypes list for command %s has duplicate items&quot; % json[&#39;name&#39;])</span>
<span class="line-added">+ </span>
<span class="line-added">+             if debuggable_types and not validate_target_types(debuggable_types, target_types):</span>
<span class="line-added">+                 raise ParseException(&#39;Malformed domain specification: command %s has an item in targetTypes &quot;%s&quot; that is not supported by any value in debuggableTypes &quot;%s&quot;.&#39; % (json[&#39;name&#39;], target_types, debuggable_types))</span>
<span class="line-added">+ </span>
          if &#39;parameters&#39; in json:
              if not isinstance(json[&#39;parameters&#39;], list):
                  raise ParseException(&quot;Malformed command specification: parameters is not an array&quot;)
              call_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;parameters&#39;]])
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 453,29 ***</span>
              duplicate_names = find_duplicates([param.parameter_name for param in return_parameters])
              if len(duplicate_names) &gt; 0:
                  raise ParseException(&quot;Malformed domain specification: return parameter list for command %s has duplicate parameter names&quot; % json[&#39;name&#39;])
  
          platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
<span class="line-modified">!         return Command(json[&#39;name&#39;], call_parameters, return_parameters, json.get(&#39;description&#39;, &quot;&quot;), platform, json.get(&#39;async&#39;, False))</span>
  
<span class="line-modified">!     def parse_event(self, json):</span>
          check_for_required_properties([&#39;name&#39;], json, &quot;event&quot;)
          log.debug(&quot;parse event %s&quot; % json[&#39;name&#39;])
  
          event_parameters = []
  
          if &#39;parameters&#39; in json:
              if not isinstance(json[&#39;parameters&#39;], list):
                  raise ParseException(&quot;Malformed event specification: parameters is not an array&quot;)
              event_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;parameters&#39;]])
  
              duplicate_names = find_duplicates([param.parameter_name for param in event_parameters])
              if len(duplicate_names) &gt; 0:
                  raise ParseException(&quot;Malformed domain specification: parameter list for event %s has duplicate parameter names&quot; % json[&#39;name&#39;])
  
          platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
<span class="line-modified">!         return Event(json[&#39;name&#39;], event_parameters, json.get(&#39;description&#39;, &quot;&quot;), platform)</span>
  
      def parse_call_or_return_parameter(self, json):
          check_for_required_properties([&#39;name&#39;], json, &quot;parameter&quot;)
          log.debug(&quot;parse parameter %s&quot; % json[&#39;name&#39;])
  
<span class="line-new-header">--- 508,46 ---</span>
              duplicate_names = find_duplicates([param.parameter_name for param in return_parameters])
              if len(duplicate_names) &gt; 0:
                  raise ParseException(&quot;Malformed domain specification: return parameter list for command %s has duplicate parameter names&quot; % json[&#39;name&#39;])
  
          platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
<span class="line-modified">!         return Command(json[&#39;name&#39;], target_types, call_parameters, return_parameters, json.get(&#39;description&#39;, &quot;&quot;), platform, json.get(&#39;async&#39;, False))</span>
  
<span class="line-modified">!     def parse_event(self, json, debuggable_types):</span>
          check_for_required_properties([&#39;name&#39;], json, &quot;event&quot;)
          log.debug(&quot;parse event %s&quot; % json[&#39;name&#39;])
  
<span class="line-added">+         target_types = None</span>
          event_parameters = []
  
<span class="line-added">+         if &#39;targetTypes&#39; in json:</span>
<span class="line-added">+             if not isinstance(json[&#39;targetTypes&#39;], list):</span>
<span class="line-added">+                 raise ParseException(&quot;Malformed domain specification: targetTypes for event %s is not an array&quot; % json[&#39;name&#39;])</span>
<span class="line-added">+             target_types = json[&#39;targetTypes&#39;]</span>
<span class="line-added">+ </span>
<span class="line-added">+             for target_type in target_types:</span>
<span class="line-added">+                 if target_type not in _ALLOWED_TARGET_TYPE_STRINGS:</span>
<span class="line-added">+                     raise ParseException(&#39;Malformed domain specification: targetTypes for event %s is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;name&#39;], json[&#39;targetTypes&#39;], &#39;, &#39;.join(_ALLOWED_TARGET_TYPE_STRINGS)))</span>
<span class="line-added">+ </span>
<span class="line-added">+             duplicate_types = find_duplicates(target_types)</span>
<span class="line-added">+             if len(duplicate_types) &gt; 0:</span>
<span class="line-added">+                 raise ParseException(&quot;Malformed domain specification: targetTypes list for event %s has duplicate items&quot; % json[&#39;name&#39;])</span>
<span class="line-added">+ </span>
<span class="line-added">+             if debuggable_types and not validate_target_types(debuggable_types, target_types):</span>
<span class="line-added">+                 raise ParseException(&#39;Malformed domain specification: event %s has an item in targetTypes &quot;%s&quot; that is not supported by any value in debuggableTypes &quot;%s&quot;.&#39; % (json[&#39;name&#39;], target_types, debuggable_types))</span>
<span class="line-added">+ </span>
          if &#39;parameters&#39; in json:
              if not isinstance(json[&#39;parameters&#39;], list):
                  raise ParseException(&quot;Malformed event specification: parameters is not an array&quot;)
              event_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;parameters&#39;]])
  
              duplicate_names = find_duplicates([param.parameter_name for param in event_parameters])
              if len(duplicate_names) &gt; 0:
                  raise ParseException(&quot;Malformed domain specification: parameter list for event %s has duplicate parameter names&quot; % json[&#39;name&#39;])
  
          platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
<span class="line-modified">!         return Event(json[&#39;name&#39;], target_types, event_parameters, json.get(&#39;description&#39;, &quot;&quot;), platform)</span>
  
      def parse_call_or_return_parameter(self, json):
          check_for_required_properties([&#39;name&#39;], json, &quot;parameter&quot;)
          log.debug(&quot;parse parameter %s&quot; % json[&#39;name&#39;])
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 569,15 ***</span>
  
          raise TypecheckException(&quot;Lookup failed for type reference: %s (referenced from domain: %s)&quot; % (type_ref.referenced_name(), domain.domain_name))
  
  
  class Domain:
<span class="line-modified">!     def __init__(self, domain_name, description, feature_guard, availability, isSupplemental, version, type_declarations, commands, events):</span>
          self.domain_name = domain_name
          self.description = description
          self.feature_guard = feature_guard
<span class="line-modified">!         self.availability = availability</span>
          self.is_supplemental = isSupplemental
          self._version = version
          self._type_declarations = type_declarations
          self._commands = commands
          self._events = events
<span class="line-new-header">--- 641,16 ---</span>
  
          raise TypecheckException(&quot;Lookup failed for type reference: %s (referenced from domain: %s)&quot; % (type_ref.referenced_name(), domain.domain_name))
  
  
  class Domain:
<span class="line-modified">!     def __init__(self, domain_name, description, feature_guard, debuggable_types, target_types, isSupplemental, version, type_declarations, commands, events):</span>
          self.domain_name = domain_name
          self.description = description
          self.feature_guard = feature_guard
<span class="line-modified">!         self.debuggable_types = debuggable_types</span>
<span class="line-added">+         self.target_types = target_types</span>
          self.is_supplemental = isSupplemental
          self._version = version
          self._type_declarations = type_declarations
          self._commands = commands
          self._events = events
</pre>
<hr />
<pre>
<span class="line-old-header">*** 607,11 ***</span>
          for event in self._events:
              event.resolve_type_references(protocol, self)
  
  
  class Domains:
<span class="line-modified">!     GLOBAL = Domain(&quot;&quot;, &quot;The global domain, in which primitive types are implicitly declared.&quot;, None, None, False, None, [], [], [])</span>
  
  
  class TypeDeclaration:
      def __init__(self, type_name, type_ref, description, platform, type_members):
          self.type_name = type_name
<span class="line-new-header">--- 680,11 ---</span>
          for event in self._events:
              event.resolve_type_references(protocol, self)
  
  
  class Domains:
<span class="line-modified">!     GLOBAL = Domain(&quot;&quot;, &quot;The global domain, in which primitive types are implicitly declared.&quot;, None, None, None, False, None, [], [], [])</span>
  
  
  class TypeDeclaration:
      def __init__(self, type_name, type_ref, description, platform, type_members):
          self.type_name = type_name
</pre>
<hr />
<pre>
<span class="line-old-header">*** 659,12 ***</span>
          log.debug(&quot;&gt;&gt;&gt; Resolving type references for parameter: %s&quot; % self.parameter_name)
          self.type = protocol.lookup_type_reference(self.type_ref, domain)
  
  
  class Command:
<span class="line-modified">!     def __init__(self, command_name, call_parameters, return_parameters, description, platform, is_async):</span>
          self.command_name = command_name
          self.call_parameters = call_parameters
          self.return_parameters = return_parameters
          self.description = description
          self.platform = platform
          self.is_async = is_async
<span class="line-new-header">--- 732,13 ---</span>
          log.debug(&quot;&gt;&gt;&gt; Resolving type references for parameter: %s&quot; % self.parameter_name)
          self.type = protocol.lookup_type_reference(self.type_ref, domain)
  
  
  class Command:
<span class="line-modified">!     def __init__(self, command_name, target_types, call_parameters, return_parameters, description, platform, is_async):</span>
          self.command_name = command_name
<span class="line-added">+         self.target_types = target_types</span>
          self.call_parameters = call_parameters
          self.return_parameters = return_parameters
          self.description = description
          self.platform = platform
          self.is_async = is_async
</pre>
<hr />
<pre>
<span class="line-old-header">*** 678,12 ***</span>
          for parameter in self.return_parameters:
              parameter.resolve_type_references(protocol, domain)
  
  
  class Event:
<span class="line-modified">!     def __init__(self, event_name, event_parameters, description, platform):</span>
          self.event_name = event_name
          self.event_parameters = event_parameters
          self.description = description
          self.platform = platform
  
      def resolve_type_references(self, protocol, domain):
<span class="line-new-header">--- 752,13 ---</span>
          for parameter in self.return_parameters:
              parameter.resolve_type_references(protocol, domain)
  
  
  class Event:
<span class="line-modified">!     def __init__(self, event_name, target_types, event_parameters, description, platform):</span>
          self.event_name = event_name
<span class="line-added">+         self.target_types = target_types</span>
          self.event_parameters = event_parameters
          self.description = description
          self.platform = platform
  
      def resolve_type_references(self, protocol, domain):
</pre>
<center><a href="generator.py.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="objc_generator_templates.py.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
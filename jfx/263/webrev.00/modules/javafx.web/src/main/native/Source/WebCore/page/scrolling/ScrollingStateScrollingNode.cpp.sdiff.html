<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingStateScrollingNode.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScrollingStateNode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollingStateScrollingNode.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingStateScrollingNode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 
 29 #if ENABLE(ASYNC_SCROLLING)
 30 
 31 #include &quot;ScrollingStateTree.h&quot;
 32 #include &lt;wtf/text/TextStream.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 ScrollingStateScrollingNode::ScrollingStateScrollingNode(ScrollingStateTree&amp; stateTree, ScrollingNodeType nodeType, ScrollingNodeID nodeID)
 37     : ScrollingStateNode(nodeType, stateTree, nodeID)
 38 {
 39 }
 40 
 41 ScrollingStateScrollingNode::ScrollingStateScrollingNode(const ScrollingStateScrollingNode&amp; stateNode, ScrollingStateTree&amp; adoptiveTree)
 42     : ScrollingStateNode(stateNode, adoptiveTree)
 43     , m_scrollableAreaSize(stateNode.scrollableAreaSize())
 44     , m_totalContentsSize(stateNode.totalContentsSize())
 45     , m_reachableContentsSize(stateNode.reachableContentsSize())
 46     , m_parentRelativeScrollableRect(stateNode.parentRelativeScrollableRect())
 47     , m_scrollPosition(stateNode.scrollPosition())
<span class="line-removed"> 48     , m_requestedScrollPosition(stateNode.requestedScrollPosition())</span>
 49     , m_scrollOrigin(stateNode.scrollOrigin())
 50 #if ENABLE(CSS_SCROLL_SNAP)
 51     , m_snapOffsetsInfo(stateNode.m_snapOffsetsInfo)
 52 #endif
 53 #if PLATFORM(MAC)
 54     , m_verticalScrollerImp(stateNode.verticalScrollerImp())
 55     , m_horizontalScrollerImp(stateNode.horizontalScrollerImp())
 56 #endif
 57     , m_scrollableAreaParameters(stateNode.scrollableAreaParameters())
<span class="line-modified"> 58     , m_requestedScrollPositionRepresentsProgrammaticScroll(stateNode.requestedScrollPositionRepresentsProgrammaticScroll())</span>
<span class="line-modified"> 59     , m_expectsWheelEventTestTrigger(stateNode.expectsWheelEventTestTrigger())</span>
 60 {
 61     if (hasChangedProperty(ScrollContainerLayer))
 62         setScrollContainerLayer(stateNode.scrollContainerLayer().toRepresentation(adoptiveTree.preferredLayerRepresentation()));
 63 
 64     if (hasChangedProperty(ScrolledContentsLayer))
 65         setScrolledContentsLayer(stateNode.scrolledContentsLayer().toRepresentation(adoptiveTree.preferredLayerRepresentation()));
 66 
 67     if (hasChangedProperty(VerticalScrollbarLayer))
 68         setVerticalScrollbarLayer(stateNode.verticalScrollbarLayer().toRepresentation(adoptiveTree.preferredLayerRepresentation()));
 69 
 70     if (hasChangedProperty(HorizontalScrollbarLayer))
 71         setHorizontalScrollbarLayer(stateNode.horizontalScrollbarLayer().toRepresentation(adoptiveTree.preferredLayerRepresentation()));
 72 }
 73 
 74 ScrollingStateScrollingNode::~ScrollingStateScrollingNode() = default;
 75 
 76 void ScrollingStateScrollingNode::setPropertyChangedBitsAfterReattach()
 77 {
 78     setPropertyChangedBit(ScrollableAreaSize);
 79     setPropertyChangedBit(TotalContentsSize);
 80     setPropertyChangedBit(ReachableContentsSize);
 81     setPropertyChangedBit(ParentRelativeScrollableRect);
 82     setPropertyChangedBit(ScrollPosition);
 83     setPropertyChangedBit(ScrollOrigin);
 84     setPropertyChangedBit(ScrollableAreaParams);
 85 #if ENABLE(CSS_SCROLL_SNAP)
 86     setPropertyChangedBit(HorizontalSnapOffsets);
 87     setPropertyChangedBit(VerticalSnapOffsets);
 88     setPropertyChangedBit(HorizontalSnapOffsetRanges);
 89     setPropertyChangedBit(VerticalSnapOffsetRanges);
 90     setPropertyChangedBit(CurrentHorizontalSnapOffsetIndex);
 91     setPropertyChangedBit(CurrentVerticalSnapOffsetIndex);
 92 #endif
<span class="line-modified"> 93     setPropertyChangedBit(ExpectsWheelEventTestTrigger);</span>
 94     setPropertyChangedBit(ScrollContainerLayer);
 95     setPropertyChangedBit(ScrolledContentsLayer);
 96     setPropertyChangedBit(HorizontalScrollbarLayer);
 97     setPropertyChangedBit(VerticalScrollbarLayer);
 98     setPropertyChangedBit(PainterForScrollbar);
 99 
100     ScrollingStateNode::setPropertyChangedBitsAfterReattach();
101 }
102 
103 void ScrollingStateScrollingNode::setScrollableAreaSize(const FloatSize&amp; size)
104 {
105     if (m_scrollableAreaSize == size)
106         return;
107 
108     m_scrollableAreaSize = size;
109     setPropertyChanged(ScrollableAreaSize);
110 }
111 
112 void ScrollingStateScrollingNode::setTotalContentsSize(const FloatSize&amp; totalContentsSize)
113 {
</pre>
<hr />
<pre>
202 
203 void ScrollingStateScrollingNode::setCurrentVerticalSnapPointIndex(unsigned index)
204 {
205     if (m_currentVerticalSnapPointIndex == index)
206         return;
207 
208     m_currentVerticalSnapPointIndex = index;
209     setPropertyChanged(CurrentVerticalSnapOffsetIndex);
210 }
211 #endif
212 
213 void ScrollingStateScrollingNode::setScrollableAreaParameters(const ScrollableAreaParameters&amp; parameters)
214 {
215     if (m_scrollableAreaParameters == parameters)
216         return;
217 
218     m_scrollableAreaParameters = parameters;
219     setPropertyChanged(ScrollableAreaParams);
220 }
221 
<span class="line-modified">222 void ScrollingStateScrollingNode::setRequestedScrollPosition(const FloatPoint&amp; requestedScrollPosition, bool representsProgrammaticScroll)</span>
223 {
<span class="line-modified">224     m_requestedScrollPosition = requestedScrollPosition;</span>
<span class="line-modified">225     m_requestedScrollPositionRepresentsProgrammaticScroll = representsProgrammaticScroll;</span>
226     setPropertyChanged(RequestedScrollPosition);
227 }
228 
<span class="line-modified">229 void ScrollingStateScrollingNode::setExpectsWheelEventTestTrigger(bool expectsTestTrigger)</span>
230 {
<span class="line-modified">231     if (expectsTestTrigger == m_expectsWheelEventTestTrigger)</span>
232         return;
233 
<span class="line-modified">234     m_expectsWheelEventTestTrigger = expectsTestTrigger;</span>
<span class="line-modified">235     setPropertyChanged(ExpectsWheelEventTestTrigger);</span>
236 }
237 
238 void ScrollingStateScrollingNode::setScrollContainerLayer(const LayerRepresentation&amp; layerRepresentation)
239 {
240     if (layerRepresentation == m_scrollContainerLayer)
241         return;
242 
243     m_scrollContainerLayer = layerRepresentation;
244     setPropertyChanged(ScrollContainerLayer);
245 }
246 
247 void ScrollingStateScrollingNode::setScrolledContentsLayer(const LayerRepresentation&amp; layerRepresentation)
248 {
249     if (layerRepresentation == m_scrolledContentsLayer)
250         return;
251 
252     m_scrolledContentsLayer = layerRepresentation;
253     setPropertyChanged(ScrolledContentsLayer);
254 }
255 
</pre>
<hr />
<pre>
288             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_scrollPosition.y());
289     }
290 
291     if (!m_scrollableAreaSize.isEmpty()) {
292         TextStream::GroupScope scope(ts);
293         ts &lt;&lt; &quot;scrollable area size &quot;
294             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_scrollableAreaSize.width()) &lt;&lt; &quot; &quot;
295             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_scrollableAreaSize.height());
296     }
297 
298     if (!m_totalContentsSize.isEmpty()) {
299         TextStream::GroupScope scope(ts);
300         ts &lt;&lt; &quot;contents size &quot;
301             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_totalContentsSize.width()) &lt;&lt; &quot; &quot;
302             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_totalContentsSize.height());
303     }
304 
305     if (m_reachableContentsSize != m_totalContentsSize)
306         ts.dumpProperty(&quot;reachable contents size&quot;, m_reachableContentsSize);
307 
<span class="line-modified">308     if (m_requestedScrollPosition != IntPoint()) {</span>
309         TextStream::GroupScope scope(ts);
310         ts &lt;&lt; &quot;requested scroll position &quot;
<span class="line-modified">311             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_requestedScrollPosition.x()) &lt;&lt; &quot; &quot;</span>
<span class="line-modified">312             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_requestedScrollPosition.y());</span>
313     }
<span class="line-modified">314     if (m_requestedScrollPositionRepresentsProgrammaticScroll)</span>
<span class="line-modified">315         ts.dumpProperty(&quot;requested scroll position represents programmatic scroll&quot;, m_requestedScrollPositionRepresentsProgrammaticScroll);</span>



316 
317     if (!m_parentRelativeScrollableRect.isEmpty())
318         ts.dumpProperty(&quot;parent relative scrollable rect&quot;, m_parentRelativeScrollableRect);
319 
320     if (m_scrollOrigin != IntPoint())
321         ts.dumpProperty(&quot;scroll origin&quot;, m_scrollOrigin);
322 
323 #if ENABLE(CSS_SCROLL_SNAP)
324     if (m_snapOffsetsInfo.horizontalSnapOffsets.size())
325         ts.dumpProperty(&quot;horizontal snap offsets&quot;, m_snapOffsetsInfo.horizontalSnapOffsets);
326 
327     if (m_snapOffsetsInfo.verticalSnapOffsets.size())
328         ts.dumpProperty(&quot;vertical snap offsets&quot;, m_snapOffsetsInfo.verticalSnapOffsets);
329 
330     if (m_currentHorizontalSnapPointIndex)
331         ts.dumpProperty(&quot;current horizontal snap point index&quot;, m_currentHorizontalSnapPointIndex);
332 
333     if (m_currentVerticalSnapPointIndex)
334         ts.dumpProperty(&quot;current vertical snap point index&quot;, m_currentVerticalSnapPointIndex);
335 #endif
336 
337     ts.dumpProperty(&quot;scrollable area parameters&quot;, m_scrollableAreaParameters);
338 
<span class="line-modified">339     if (m_expectsWheelEventTestTrigger)</span>
<span class="line-modified">340         ts.dumpProperty(&quot;expects wheel event test trigger&quot;, m_expectsWheelEventTestTrigger);</span>
341 
342     if (behavior &amp; ScrollingStateTreeAsTextBehaviorIncludeLayerIDs) {
343         if (m_scrollContainerLayer.layerID())
344             ts.dumpProperty(&quot;scroll container layer&quot;, m_scrollContainerLayer.layerID());
345         if (m_scrolledContentsLayer.layerID())
346             ts.dumpProperty(&quot;scrolled contents layer&quot;, m_scrolledContentsLayer.layerID());
347     }
348 }
349 
350 } // namespace WebCore
351 
352 #endif // ENABLE(ASYNC_SCROLLING)
</pre>
</td>
<td>
<hr />
<pre>
 28 
 29 #if ENABLE(ASYNC_SCROLLING)
 30 
 31 #include &quot;ScrollingStateTree.h&quot;
 32 #include &lt;wtf/text/TextStream.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 ScrollingStateScrollingNode::ScrollingStateScrollingNode(ScrollingStateTree&amp; stateTree, ScrollingNodeType nodeType, ScrollingNodeID nodeID)
 37     : ScrollingStateNode(nodeType, stateTree, nodeID)
 38 {
 39 }
 40 
 41 ScrollingStateScrollingNode::ScrollingStateScrollingNode(const ScrollingStateScrollingNode&amp; stateNode, ScrollingStateTree&amp; adoptiveTree)
 42     : ScrollingStateNode(stateNode, adoptiveTree)
 43     , m_scrollableAreaSize(stateNode.scrollableAreaSize())
 44     , m_totalContentsSize(stateNode.totalContentsSize())
 45     , m_reachableContentsSize(stateNode.reachableContentsSize())
 46     , m_parentRelativeScrollableRect(stateNode.parentRelativeScrollableRect())
 47     , m_scrollPosition(stateNode.scrollPosition())

 48     , m_scrollOrigin(stateNode.scrollOrigin())
 49 #if ENABLE(CSS_SCROLL_SNAP)
 50     , m_snapOffsetsInfo(stateNode.m_snapOffsetsInfo)
 51 #endif
 52 #if PLATFORM(MAC)
 53     , m_verticalScrollerImp(stateNode.verticalScrollerImp())
 54     , m_horizontalScrollerImp(stateNode.horizontalScrollerImp())
 55 #endif
 56     , m_scrollableAreaParameters(stateNode.scrollableAreaParameters())
<span class="line-modified"> 57     , m_requestedScrollData(stateNode.requestedScrollData())</span>
<span class="line-modified"> 58     , m_isMonitoringWheelEvents(stateNode.isMonitoringWheelEvents())</span>
 59 {
 60     if (hasChangedProperty(ScrollContainerLayer))
 61         setScrollContainerLayer(stateNode.scrollContainerLayer().toRepresentation(adoptiveTree.preferredLayerRepresentation()));
 62 
 63     if (hasChangedProperty(ScrolledContentsLayer))
 64         setScrolledContentsLayer(stateNode.scrolledContentsLayer().toRepresentation(adoptiveTree.preferredLayerRepresentation()));
 65 
 66     if (hasChangedProperty(VerticalScrollbarLayer))
 67         setVerticalScrollbarLayer(stateNode.verticalScrollbarLayer().toRepresentation(adoptiveTree.preferredLayerRepresentation()));
 68 
 69     if (hasChangedProperty(HorizontalScrollbarLayer))
 70         setHorizontalScrollbarLayer(stateNode.horizontalScrollbarLayer().toRepresentation(adoptiveTree.preferredLayerRepresentation()));
 71 }
 72 
 73 ScrollingStateScrollingNode::~ScrollingStateScrollingNode() = default;
 74 
 75 void ScrollingStateScrollingNode::setPropertyChangedBitsAfterReattach()
 76 {
 77     setPropertyChangedBit(ScrollableAreaSize);
 78     setPropertyChangedBit(TotalContentsSize);
 79     setPropertyChangedBit(ReachableContentsSize);
 80     setPropertyChangedBit(ParentRelativeScrollableRect);
 81     setPropertyChangedBit(ScrollPosition);
 82     setPropertyChangedBit(ScrollOrigin);
 83     setPropertyChangedBit(ScrollableAreaParams);
 84 #if ENABLE(CSS_SCROLL_SNAP)
 85     setPropertyChangedBit(HorizontalSnapOffsets);
 86     setPropertyChangedBit(VerticalSnapOffsets);
 87     setPropertyChangedBit(HorizontalSnapOffsetRanges);
 88     setPropertyChangedBit(VerticalSnapOffsetRanges);
 89     setPropertyChangedBit(CurrentHorizontalSnapOffsetIndex);
 90     setPropertyChangedBit(CurrentVerticalSnapOffsetIndex);
 91 #endif
<span class="line-modified"> 92     setPropertyChangedBit(IsMonitoringWheelEvents);</span>
 93     setPropertyChangedBit(ScrollContainerLayer);
 94     setPropertyChangedBit(ScrolledContentsLayer);
 95     setPropertyChangedBit(HorizontalScrollbarLayer);
 96     setPropertyChangedBit(VerticalScrollbarLayer);
 97     setPropertyChangedBit(PainterForScrollbar);
 98 
 99     ScrollingStateNode::setPropertyChangedBitsAfterReattach();
100 }
101 
102 void ScrollingStateScrollingNode::setScrollableAreaSize(const FloatSize&amp; size)
103 {
104     if (m_scrollableAreaSize == size)
105         return;
106 
107     m_scrollableAreaSize = size;
108     setPropertyChanged(ScrollableAreaSize);
109 }
110 
111 void ScrollingStateScrollingNode::setTotalContentsSize(const FloatSize&amp; totalContentsSize)
112 {
</pre>
<hr />
<pre>
201 
202 void ScrollingStateScrollingNode::setCurrentVerticalSnapPointIndex(unsigned index)
203 {
204     if (m_currentVerticalSnapPointIndex == index)
205         return;
206 
207     m_currentVerticalSnapPointIndex = index;
208     setPropertyChanged(CurrentVerticalSnapOffsetIndex);
209 }
210 #endif
211 
212 void ScrollingStateScrollingNode::setScrollableAreaParameters(const ScrollableAreaParameters&amp; parameters)
213 {
214     if (m_scrollableAreaParameters == parameters)
215         return;
216 
217     m_scrollableAreaParameters = parameters;
218     setPropertyChanged(ScrollableAreaParams);
219 }
220 
<span class="line-modified">221 void ScrollingStateScrollingNode::setRequestedScrollData(const RequestedScrollData&amp; scrollData)</span>
222 {
<span class="line-modified">223     // Scroll position requests are imperative, not stateful, so we can&#39;t early return here.</span>
<span class="line-modified">224     m_requestedScrollData = scrollData;</span>
225     setPropertyChanged(RequestedScrollPosition);
226 }
227 
<span class="line-modified">228 void ScrollingStateScrollingNode::setIsMonitoringWheelEvents(bool isMonitoringWheelEvents)</span>
229 {
<span class="line-modified">230     if (isMonitoringWheelEvents == m_isMonitoringWheelEvents)</span>
231         return;
232 
<span class="line-modified">233     m_isMonitoringWheelEvents = isMonitoringWheelEvents;</span>
<span class="line-modified">234     setPropertyChanged(IsMonitoringWheelEvents);</span>
235 }
236 
237 void ScrollingStateScrollingNode::setScrollContainerLayer(const LayerRepresentation&amp; layerRepresentation)
238 {
239     if (layerRepresentation == m_scrollContainerLayer)
240         return;
241 
242     m_scrollContainerLayer = layerRepresentation;
243     setPropertyChanged(ScrollContainerLayer);
244 }
245 
246 void ScrollingStateScrollingNode::setScrolledContentsLayer(const LayerRepresentation&amp; layerRepresentation)
247 {
248     if (layerRepresentation == m_scrolledContentsLayer)
249         return;
250 
251     m_scrolledContentsLayer = layerRepresentation;
252     setPropertyChanged(ScrolledContentsLayer);
253 }
254 
</pre>
<hr />
<pre>
287             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_scrollPosition.y());
288     }
289 
290     if (!m_scrollableAreaSize.isEmpty()) {
291         TextStream::GroupScope scope(ts);
292         ts &lt;&lt; &quot;scrollable area size &quot;
293             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_scrollableAreaSize.width()) &lt;&lt; &quot; &quot;
294             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_scrollableAreaSize.height());
295     }
296 
297     if (!m_totalContentsSize.isEmpty()) {
298         TextStream::GroupScope scope(ts);
299         ts &lt;&lt; &quot;contents size &quot;
300             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_totalContentsSize.width()) &lt;&lt; &quot; &quot;
301             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_totalContentsSize.height());
302     }
303 
304     if (m_reachableContentsSize != m_totalContentsSize)
305         ts.dumpProperty(&quot;reachable contents size&quot;, m_reachableContentsSize);
306 
<span class="line-modified">307     if (!m_requestedScrollData.scrollPosition.isZero()) {</span>
308         TextStream::GroupScope scope(ts);
309         ts &lt;&lt; &quot;requested scroll position &quot;
<span class="line-modified">310             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_requestedScrollData.scrollPosition.x()) &lt;&lt; &quot; &quot;</span>
<span class="line-modified">311             &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_requestedScrollData.scrollPosition.y());</span>
312     }
<span class="line-modified">313     if (m_requestedScrollData.scrollType == ScrollType::Programmatic)</span>
<span class="line-modified">314         ts.dumpProperty(&quot;requested scroll position represents programmatic scroll&quot;, true);</span>
<span class="line-added">315 </span>
<span class="line-added">316     if (m_requestedScrollData.clamping == ScrollClamping::Unclamped)</span>
<span class="line-added">317         ts.dumpProperty(&quot;requested scroll position clamping&quot;, m_requestedScrollData.clamping);</span>
318 
319     if (!m_parentRelativeScrollableRect.isEmpty())
320         ts.dumpProperty(&quot;parent relative scrollable rect&quot;, m_parentRelativeScrollableRect);
321 
322     if (m_scrollOrigin != IntPoint())
323         ts.dumpProperty(&quot;scroll origin&quot;, m_scrollOrigin);
324 
325 #if ENABLE(CSS_SCROLL_SNAP)
326     if (m_snapOffsetsInfo.horizontalSnapOffsets.size())
327         ts.dumpProperty(&quot;horizontal snap offsets&quot;, m_snapOffsetsInfo.horizontalSnapOffsets);
328 
329     if (m_snapOffsetsInfo.verticalSnapOffsets.size())
330         ts.dumpProperty(&quot;vertical snap offsets&quot;, m_snapOffsetsInfo.verticalSnapOffsets);
331 
332     if (m_currentHorizontalSnapPointIndex)
333         ts.dumpProperty(&quot;current horizontal snap point index&quot;, m_currentHorizontalSnapPointIndex);
334 
335     if (m_currentVerticalSnapPointIndex)
336         ts.dumpProperty(&quot;current vertical snap point index&quot;, m_currentVerticalSnapPointIndex);
337 #endif
338 
339     ts.dumpProperty(&quot;scrollable area parameters&quot;, m_scrollableAreaParameters);
340 
<span class="line-modified">341     if (m_isMonitoringWheelEvents)</span>
<span class="line-modified">342         ts.dumpProperty(&quot;expects wheel event test trigger&quot;, m_isMonitoringWheelEvents);</span>
343 
344     if (behavior &amp; ScrollingStateTreeAsTextBehaviorIncludeLayerIDs) {
345         if (m_scrollContainerLayer.layerID())
346             ts.dumpProperty(&quot;scroll container layer&quot;, m_scrollContainerLayer.layerID());
347         if (m_scrolledContentsLayer.layerID())
348             ts.dumpProperty(&quot;scrolled contents layer&quot;, m_scrolledContentsLayer.layerID());
349     }
350 }
351 
352 } // namespace WebCore
353 
354 #endif // ENABLE(ASYNC_SCROLLING)
</pre>
</td>
</tr>
</table>
<center><a href="ScrollingStateNode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollingStateScrollingNode.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
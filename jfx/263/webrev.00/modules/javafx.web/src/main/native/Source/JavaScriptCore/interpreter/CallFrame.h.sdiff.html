<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/CallFrame.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallFrame.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallFrameInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/CallFrame.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">  4  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Library General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Library General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Library General Public License
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;AbstractPC.h&quot;
 26 #include &quot;CalleeBits.h&quot;
 27 #include &quot;MacroAssemblerCodeRef.h&quot;
 28 #include &quot;Register.h&quot;
 29 #include &quot;StackVisitor.h&quot;
 30 #include &quot;VM.h&quot;
 31 #include &quot;VMEntryRecord.h&quot;

 32 
 33 namespace JSC  {
 34 
 35     class Arguments;
<span class="line-modified"> 36     class ExecState;</span>
 37     class Interpreter;
 38     class JSCallee;
 39     class JSScope;
 40     class SourceOrigin;
 41 
 42     struct Instruction;
 43 
<span class="line-removed"> 44     typedef ExecState CallFrame;</span>
<span class="line-removed"> 45 </span>
 46     class CallSiteIndex {
 47     public:
 48         CallSiteIndex() = default;
 49 





 50         explicit CallSiteIndex(uint32_t bits)
 51             : m_bits(bits)
 52         { }
<span class="line-removed"> 53 #if USE(JSVALUE32_64)</span>
<span class="line-removed"> 54         explicit CallSiteIndex(const Instruction* instruction)</span>
<span class="line-removed"> 55             : m_bits(bitwise_cast&lt;uint32_t&gt;(instruction))</span>
<span class="line-removed"> 56         { }</span>
<span class="line-removed"> 57 #endif</span>
 58 
<span class="line-modified"> 59         explicit operator bool() const { return m_bits != UINT_MAX; }</span>
 60         bool operator==(const CallSiteIndex&amp; other) const { return m_bits == other.m_bits; }
 61 
<span class="line-modified"> 62         inline uint32_t bits() const { return m_bits; }</span>



 63 
 64     private:
<span class="line-modified"> 65         uint32_t m_bits { UINT_MAX };</span>
 66     };
 67 
 68     class DisposableCallSiteIndex : public CallSiteIndex {
 69     public:
 70         DisposableCallSiteIndex() = default;
 71 
 72         explicit DisposableCallSiteIndex(uint32_t bits)
 73             : CallSiteIndex(bits)
 74         {
 75         }
 76 
 77         static DisposableCallSiteIndex fromCallSiteIndex(CallSiteIndex callSiteIndex)
 78         {
 79             return DisposableCallSiteIndex(callSiteIndex.bits());
 80         }
 81     };
 82 
 83     // arm64_32 expects caller frame and return pc to use 8 bytes
 84     struct CallerFrameAndPC {
 85         alignas(CPURegister) CallFrame* callerFrame;
<span class="line-modified"> 86         alignas(CPURegister) const Instruction* returnPC;</span>
<span class="line-modified"> 87         static const int sizeInRegisters = 2 * sizeof(CPURegister) / sizeof(Register);</span>
 88     };
 89     static_assert(CallerFrameAndPC::sizeInRegisters == sizeof(CallerFrameAndPC) / sizeof(Register), &quot;CallerFrameAndPC::sizeInRegisters is incorrect.&quot;);
 90 
<span class="line-modified"> 91     struct CallFrameSlot {</span>
<span class="line-modified"> 92         static const int codeBlock = CallerFrameAndPC::sizeInRegisters;</span>
<span class="line-modified"> 93         static const int callee = codeBlock + 1;</span>
<span class="line-modified"> 94         static const int argumentCount = callee + 1;</span>
<span class="line-modified"> 95         static const int thisArgument = argumentCount + 1;</span>
<span class="line-modified"> 96         static const int firstArgument = thisArgument + 1;</span>
 97     };
 98 



 99     // Represents the current state of script execution.
100     // Passed as the first argument to most functions.
<span class="line-modified">101     class ExecState : private Register {</span>
102     public:
<span class="line-modified">103         static const int headerSizeInRegisters = CallFrameSlot::argumentCount + 1;</span>
104 
105         // This function should only be called in very specific circumstances
106         // when you&#39;ve guaranteed the callee can&#39;t be a Wasm callee, and can
107         // be an arbitrary JSValue. This function should basically never be used.
108         // Its only use right now is when we are making a call, and we&#39;re not
109         // yet sure if the callee is a cell. In general, a JS callee is guaranteed
110         // to be a cell, however, there is a brief window where we need to check
111         // to see if it&#39;s a cell, and if it&#39;s not, we throw an exception.
<span class="line-modified">112         JSValue guaranteedJSValueCallee() const</span>
<span class="line-modified">113         {</span>
<span class="line-modified">114             ASSERT(!callee().isWasm());</span>
<span class="line-modified">115             return this[CallFrameSlot::callee].jsValue();</span>
<span class="line-modified">116         }</span>
<span class="line-modified">117         JSObject* jsCallee() const</span>
<span class="line-modified">118         {</span>
<span class="line-modified">119             ASSERT(!callee().isWasm());</span>
<span class="line-removed">120             return this[CallFrameSlot::callee].object();</span>
<span class="line-removed">121         }</span>
<span class="line-removed">122         CalleeBits callee() const { return CalleeBits(this[CallFrameSlot::callee].pointer()); }</span>
<span class="line-removed">123         SUPPRESS_ASAN CalleeBits unsafeCallee() const { return CalleeBits(this[CallFrameSlot::callee].asanUnsafePointer()); }</span>
<span class="line-removed">124         CodeBlock* codeBlock() const { return this[CallFrameSlot::codeBlock].Register::codeBlock(); }</span>
<span class="line-removed">125         CodeBlock** addressOfCodeBlock() const { return bitwise_cast&lt;CodeBlock**&gt;(this + CallFrameSlot::codeBlock); }</span>
<span class="line-removed">126         SUPPRESS_ASAN CodeBlock* unsafeCodeBlock() const { return this[CallFrameSlot::codeBlock].Register::asanUnsafeCodeBlock(); }</span>
<span class="line-removed">127         JSScope* scope(int scopeRegisterOffset) const</span>
<span class="line-removed">128         {</span>
<span class="line-removed">129             ASSERT(this[scopeRegisterOffset].Register::scope());</span>
<span class="line-removed">130             return this[scopeRegisterOffset].Register::scope();</span>
<span class="line-removed">131         }</span>
<span class="line-removed">132 </span>
<span class="line-removed">133         JSGlobalObject* wasmAwareLexicalGlobalObject(VM&amp;);</span>
134 
<span class="line-modified">135         bool isAnyWasmCallee();</span>
136 
137         // Global object in which the currently executing code was defined.
<span class="line-modified">138         // Differs from VM::vmEntryGlobalObject() during function calls across web browser frames.</span>
<span class="line-modified">139         JSGlobalObject* lexicalGlobalObject() const;</span>
140 
<span class="line-modified">141         // Differs from lexicalGlobalObject because this will have DOM window shell rather than</span>
<span class="line-modified">142         // the actual DOM window, which can&#39;t be &quot;this&quot; for security reasons.</span>
<span class="line-modified">143         JSObject* globalThisValue() const;</span>
<span class="line-removed">144 </span>
<span class="line-removed">145         VM&amp; vm() const;</span>
146 
147         static CallFrame* create(Register* callFrameBase) { return static_cast&lt;CallFrame*&gt;(callFrameBase); }
148         Register* registers() { return this; }
149         const Register* registers() const { return this; }
150 
151         CallFrame&amp; operator=(const Register&amp; r) { *static_cast&lt;Register*&gt;(this) = r; return *this; }
152 
153         CallFrame* callerFrame() const { return static_cast&lt;CallFrame*&gt;(callerFrameOrEntryFrame()); }
154         void* callerFrameOrEntryFrame() const { return callerFrameAndPC().callerFrame; }
155         SUPPRESS_ASAN void* unsafeCallerFrameOrEntryFrame() const { return unsafeCallerFrameAndPC().callerFrame; }
156 
157         CallFrame* unsafeCallerFrame(EntryFrame*&amp;) const;
158         JS_EXPORT_PRIVATE CallFrame* callerFrame(EntryFrame*&amp;) const;
159 
<span class="line-modified">160         JS_EXPORT_PRIVATE SourceOrigin callerSourceOrigin();</span>
161 
162         static ptrdiff_t callerFrameOffset() { return OBJECT_OFFSETOF(CallerFrameAndPC, callerFrame); }
163 
164         ReturnAddressPtr returnPC() const { return ReturnAddressPtr(callerFrameAndPC().returnPC); }
165         bool hasReturnPC() const { return !!callerFrameAndPC().returnPC; }
166         void clearReturnPC() { callerFrameAndPC().returnPC = 0; }
167         static ptrdiff_t returnPCOffset() { return OBJECT_OFFSETOF(CallerFrameAndPC, returnPC); }
168         AbstractPC abstractReturnPC(VM&amp; vm) { return AbstractPC(vm, this); }
169 
170         bool callSiteBitsAreBytecodeOffset() const;
171         bool callSiteBitsAreCodeOriginIndex() const;
172 
173         unsigned callSiteAsRawBits() const;
174         unsigned unsafeCallSiteAsRawBits() const;
175         CallSiteIndex callSiteIndex() const;
176         CallSiteIndex unsafeCallSiteIndex() const;
177     private:
178         unsigned callSiteBitsAsBytecodeOffset() const;



179     public:
180 
181         // This will try to get you the bytecode offset, but you should be aware that
182         // this bytecode offset may be bogus in the presence of inlining. This will
183         // also return 0 if the call frame has no notion of bytecode offsets (for
184         // example if it&#39;s native code).
185         // https://bugs.webkit.org/show_bug.cgi?id=121754
<span class="line-modified">186         unsigned bytecodeOffset();</span>
187 
188         // This will get you a CodeOrigin. It will always succeed. May return
<span class="line-modified">189         // CodeOrigin(0) if we&#39;re in native code.</span>
190         JS_EXPORT_PRIVATE CodeOrigin codeOrigin();
191 
<span class="line-modified">192         Register* topOfFrame()</span>
<span class="line-removed">193         {</span>
<span class="line-removed">194             if (!codeBlock())</span>
<span class="line-removed">195                 return registers();</span>
<span class="line-removed">196             return topOfFrameInternal();</span>
<span class="line-removed">197         }</span>
198 
199         const Instruction* currentVPC() const; // This only makes sense in the LLInt and baseline.
200         void setCurrentVPC(const Instruction*);
201 
202         void setCallerFrame(CallFrame* frame) { callerFrameAndPC().callerFrame = frame; }
<span class="line-modified">203         void setScope(int scopeRegisterOffset, JSScope* scope) { static_cast&lt;Register*&gt;(this)[scopeRegisterOffset] = scope; }</span>
204 
<span class="line-modified">205         static void initGlobalExec(ExecState* globalExec, JSCallee* globalCallee);</span>
206 
207         // Read a register from the codeframe (or constant from the CodeBlock).
<span class="line-removed">208         Register&amp; r(int);</span>
209         Register&amp; r(VirtualRegister);
<span class="line-modified">210         // Read a register for a non-constant</span>
<span class="line-removed">211         Register&amp; uncheckedR(int);</span>
212         Register&amp; uncheckedR(VirtualRegister);
213 
214         // Access to arguments as passed. (After capture, arguments may move to a different location.)
215         size_t argumentCount() const { return argumentCountIncludingThis() - 1; }
<span class="line-modified">216         size_t argumentCountIncludingThis() const { return this[CallFrameSlot::argumentCount].payload(); }</span>
217         static int argumentOffset(int argument) { return (CallFrameSlot::firstArgument + argument); }
218         static int argumentOffsetIncludingThis(int argument) { return (CallFrameSlot::thisArgument + argument); }
219 
220         // In the following (argument() and setArgument()), the &#39;argument&#39;
221         // parameter is the index of the arguments of the target function of
222         // this frame. The index starts at 0 for the first arg, 1 for the
223         // second, etc.
224         //
225         // The arguments (in this case) do not include the &#39;this&#39; value.
226         // arguments(0) will not fetch the &#39;this&#39; value. To get/set &#39;this&#39;,
227         // use thisValue() and setThisValue() below.
228 
229         JSValue* addressOfArgumentsStart() const { return bitwise_cast&lt;JSValue*&gt;(this + argumentOffset(0)); }
230         JSValue argument(size_t argument)
231         {
232             if (argument &gt;= argumentCount())
233                  return jsUndefined();
234             return getArgumentUnsafe(argument);
235         }
236         JSValue uncheckedArgument(size_t argument)
</pre>
<hr />
<pre>
245 
246         JSValue getArgumentUnsafe(size_t argIndex)
247         {
248             // User beware! This method does not verify that there is a valid
249             // argument at the specified argIndex. This is used for debugging
250             // and verification code only. The caller is expected to know what
251             // he/she is doing when calling this method.
252             return this[argumentOffset(argIndex)].jsValue();
253         }
254 
255         static int thisArgumentOffset() { return argumentOffsetIncludingThis(0); }
256         JSValue thisValue() { return this[thisArgumentOffset()].jsValue(); }
257         void setThisValue(JSValue value) { this[thisArgumentOffset()] = value; }
258 
259         // Under the constructor implemented in C++, thisValue holds the newTarget instead of the automatically constructed value.
260         // The result of this function is only effective under the &quot;construct&quot; context.
261         JSValue newTarget() { return thisValue(); }
262 
263         JSValue argumentAfterCapture(size_t argument);
264 
<span class="line-modified">265         static int offsetFor(size_t argumentCountIncludingThis) { return argumentCountIncludingThis + CallFrameSlot::thisArgument - 1; }</span>
266 
267         static CallFrame* noCaller() { return nullptr; }
<span class="line-modified">268         bool isGlobalExec() const</span>
269         {
270             return callerFrameAndPC().callerFrame == noCaller() &amp;&amp; callerFrameAndPC().returnPC == nullptr;
271         }
272 
273         void convertToStackOverflowFrame(VM&amp;, CodeBlock* codeBlockToKeepAliveUntilFrameIsUnwound);
274         bool isStackOverflowFrame() const;
275         bool isWasmFrame() const;
276 
<span class="line-modified">277         void setArgumentCountIncludingThis(int count) { static_cast&lt;Register*&gt;(this)[CallFrameSlot::argumentCount].payload() = count; }</span>
<span class="line-modified">278         void setCallee(JSObject* callee) { static_cast&lt;Register*&gt;(this)[CallFrameSlot::callee] = callee; }</span>
<span class="line-modified">279         void setCodeBlock(CodeBlock* codeBlock) { static_cast&lt;Register*&gt;(this)[CallFrameSlot::codeBlock] = codeBlock; }</span>
<span class="line-modified">280         void setReturnPC(void* value) { callerFrameAndPC().returnPC = reinterpret_cast&lt;const Instruction*&gt;(value); }</span>
281 
282         String friendlyFunctionName();
283 
284         // CallFrame::iterate() expects a Functor that implements the following method:
285         //     StackVisitor::Status operator()(StackVisitor&amp;) const;
286         // FIXME: This method is improper. We rely on the fact that we can call it with a null
287         // receiver. We should always be using StackVisitor directly.
288         // It&#39;s only valid to call this from a non-wasm top frame.
<span class="line-modified">289         template &lt;StackVisitor::EmptyEntryFrameAction action = StackVisitor::ContinueIfTopEntryFrameIsEmpty, typename Functor&gt; void iterate(const Functor&amp; functor)</span>
290         {
<span class="line-removed">291             VM* vm;</span>
292             void* rawThis = this;
<span class="line-modified">293             if (!!rawThis) {</span>
294                 RELEASE_ASSERT(callee().isCell());
<span class="line-removed">295                 vm = &amp;this-&gt;vm();</span>
<span class="line-removed">296             } else</span>
<span class="line-removed">297                 vm = nullptr;</span>
298             StackVisitor::visit&lt;action, Functor&gt;(this, vm, functor);
299         }
300 
301         void dump(PrintStream&amp;);
302         JS_EXPORT_PRIVATE const char* describeFrame();
303 
304     private:
305 
<span class="line-modified">306         ExecState();</span>
<span class="line-modified">307         ~ExecState();</span>
308 
309         Register* topOfFrameInternal();
310 
311         // The following are for internal use in debugging and verification
312         // code only and not meant as an API for general usage:
313 
314         size_t argIndexForRegister(Register* reg)
315         {
316             // The register at &#39;offset&#39; number of slots from the frame pointer
317             // i.e.
318             //       reg = frame[offset];
319             //   ==&gt; reg = frame + offset;
320             //   ==&gt; offset = reg - frame;
321             int offset = reg - this-&gt;registers();
322 
323             // The offset is defined (based on argumentOffset()) to be:
324             //       offset = CallFrameSlot::firstArgument - argIndex;
325             // Hence:
326             //       argIndex = CallFrameSlot::firstArgument - offset;
327             size_t argIndex = offset - CallFrameSlot::firstArgument;
328             return argIndex;
329         }
330 
331         CallerFrameAndPC&amp; callerFrameAndPC() { return *reinterpret_cast&lt;CallerFrameAndPC*&gt;(this); }
332         const CallerFrameAndPC&amp; callerFrameAndPC() const { return *reinterpret_cast&lt;const CallerFrameAndPC*&gt;(this); }
333         SUPPRESS_ASAN const CallerFrameAndPC&amp; unsafeCallerFrameAndPC() const { return *reinterpret_cast&lt;const CallerFrameAndPC*&gt;(this); }
334     };
335 













336 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">  4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Library General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Library General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Library General Public License
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;AbstractPC.h&quot;
 26 #include &quot;CalleeBits.h&quot;
 27 #include &quot;MacroAssemblerCodeRef.h&quot;
 28 #include &quot;Register.h&quot;
 29 #include &quot;StackVisitor.h&quot;
 30 #include &quot;VM.h&quot;
 31 #include &quot;VMEntryRecord.h&quot;
<span class="line-added"> 32 #include &lt;wtf/EnumClassOperatorOverloads.h&gt;</span>
 33 
 34 namespace JSC  {
 35 
 36     class Arguments;
<span class="line-modified"> 37     class CallFrame;</span>
 38     class Interpreter;
 39     class JSCallee;
 40     class JSScope;
 41     class SourceOrigin;
 42 
 43     struct Instruction;
 44 


 45     class CallSiteIndex {
 46     public:
 47         CallSiteIndex() = default;
 48 
<span class="line-added"> 49         explicit CallSiteIndex(BytecodeIndex bytecodeIndex)</span>
<span class="line-added"> 50             : m_bits(bytecodeIndex.offset())</span>
<span class="line-added"> 51         {</span>
<span class="line-added"> 52             ASSERT(!bytecodeIndex.checkpoint());</span>
<span class="line-added"> 53         }</span>
 54         explicit CallSiteIndex(uint32_t bits)
 55             : m_bits(bits)
 56         { }





 57 
<span class="line-modified"> 58         explicit operator bool() const { return !!m_bits; }</span>
 59         bool operator==(const CallSiteIndex&amp; other) const { return m_bits == other.m_bits; }
 60 
<span class="line-modified"> 61         uint32_t bits() const { return m_bits; }</span>
<span class="line-added"> 62         static CallSiteIndex fromBits(uint32_t bits) { return CallSiteIndex(bits); }</span>
<span class="line-added"> 63 </span>
<span class="line-added"> 64         BytecodeIndex bytecodeIndex() const { return BytecodeIndex(bits()); }</span>
 65 
 66     private:
<span class="line-modified"> 67         uint32_t m_bits { BytecodeIndex().offset() };</span>
 68     };
 69 
 70     class DisposableCallSiteIndex : public CallSiteIndex {
 71     public:
 72         DisposableCallSiteIndex() = default;
 73 
 74         explicit DisposableCallSiteIndex(uint32_t bits)
 75             : CallSiteIndex(bits)
 76         {
 77         }
 78 
 79         static DisposableCallSiteIndex fromCallSiteIndex(CallSiteIndex callSiteIndex)
 80         {
 81             return DisposableCallSiteIndex(callSiteIndex.bits());
 82         }
 83     };
 84 
 85     // arm64_32 expects caller frame and return pc to use 8 bytes
 86     struct CallerFrameAndPC {
 87         alignas(CPURegister) CallFrame* callerFrame;
<span class="line-modified"> 88         alignas(CPURegister) void* returnPC;</span>
<span class="line-modified"> 89         static constexpr int sizeInRegisters = 2 * sizeof(CPURegister) / sizeof(Register);</span>
 90     };
 91     static_assert(CallerFrameAndPC::sizeInRegisters == sizeof(CallerFrameAndPC) / sizeof(Register), &quot;CallerFrameAndPC::sizeInRegisters is incorrect.&quot;);
 92 
<span class="line-modified"> 93     enum class CallFrameSlot : int {</span>
<span class="line-modified"> 94         codeBlock = CallerFrameAndPC::sizeInRegisters,</span>
<span class="line-modified"> 95         callee = codeBlock + 1,</span>
<span class="line-modified"> 96         argumentCountIncludingThis = callee + 1,</span>
<span class="line-modified"> 97         thisArgument = argumentCountIncludingThis + 1,</span>
<span class="line-modified"> 98         firstArgument = thisArgument + 1,</span>
 99     };
100 
<span class="line-added">101     OVERLOAD_MATH_OPERATORS_FOR_ENUM_CLASS_WITH_INTEGRALS(CallFrameSlot)</span>
<span class="line-added">102     OVERLOAD_RELATIONAL_OPERATORS_FOR_ENUM_CLASS_WITH_INTEGRALS(CallFrameSlot)</span>
<span class="line-added">103 </span>
104     // Represents the current state of script execution.
105     // Passed as the first argument to most functions.
<span class="line-modified">106     class CallFrame : private Register {</span>
107     public:
<span class="line-modified">108         static constexpr int headerSizeInRegisters = static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis) + 1;</span>
109 
110         // This function should only be called in very specific circumstances
111         // when you&#39;ve guaranteed the callee can&#39;t be a Wasm callee, and can
112         // be an arbitrary JSValue. This function should basically never be used.
113         // Its only use right now is when we are making a call, and we&#39;re not
114         // yet sure if the callee is a cell. In general, a JS callee is guaranteed
115         // to be a cell, however, there is a brief window where we need to check
116         // to see if it&#39;s a cell, and if it&#39;s not, we throw an exception.
<span class="line-modified">117         inline JSValue guaranteedJSValueCallee() const;</span>
<span class="line-modified">118         inline JSObject* jsCallee() const;</span>
<span class="line-modified">119         CalleeBits callee() const { return CalleeBits(this[static_cast&lt;int&gt;(CallFrameSlot::callee)].pointer()); }</span>
<span class="line-modified">120         SUPPRESS_ASAN CalleeBits unsafeCallee() const { return CalleeBits(this[static_cast&lt;int&gt;(CallFrameSlot::callee)].asanUnsafePointer()); }</span>
<span class="line-modified">121         CodeBlock* codeBlock() const;</span>
<span class="line-modified">122         CodeBlock** addressOfCodeBlock() const { return bitwise_cast&lt;CodeBlock**&gt;(this + static_cast&lt;int&gt;(CallFrameSlot::codeBlock)); }</span>
<span class="line-modified">123         inline SUPPRESS_ASAN CodeBlock* unsafeCodeBlock() const;</span>
<span class="line-modified">124         inline JSScope* scope(int scopeRegisterOffset) const;</span>














125 
<span class="line-modified">126         JS_EXPORT_PRIVATE bool isAnyWasmCallee();</span>
127 
128         // Global object in which the currently executing code was defined.
<span class="line-modified">129         // Differs from VM::deprecatedVMEntryGlobalObject() during function calls across web browser frames.</span>
<span class="line-modified">130         JSGlobalObject* lexicalGlobalObject(VM&amp;) const;</span>
131 
<span class="line-modified">132         // FIXME: Remove this function</span>
<span class="line-modified">133         // https://bugs.webkit.org/show_bug.cgi?id=203272</span>
<span class="line-modified">134         VM&amp; deprecatedVM() const;</span>


135 
136         static CallFrame* create(Register* callFrameBase) { return static_cast&lt;CallFrame*&gt;(callFrameBase); }
137         Register* registers() { return this; }
138         const Register* registers() const { return this; }
139 
140         CallFrame&amp; operator=(const Register&amp; r) { *static_cast&lt;Register*&gt;(this) = r; return *this; }
141 
142         CallFrame* callerFrame() const { return static_cast&lt;CallFrame*&gt;(callerFrameOrEntryFrame()); }
143         void* callerFrameOrEntryFrame() const { return callerFrameAndPC().callerFrame; }
144         SUPPRESS_ASAN void* unsafeCallerFrameOrEntryFrame() const { return unsafeCallerFrameAndPC().callerFrame; }
145 
146         CallFrame* unsafeCallerFrame(EntryFrame*&amp;) const;
147         JS_EXPORT_PRIVATE CallFrame* callerFrame(EntryFrame*&amp;) const;
148 
<span class="line-modified">149         JS_EXPORT_PRIVATE SourceOrigin callerSourceOrigin(VM&amp;);</span>
150 
151         static ptrdiff_t callerFrameOffset() { return OBJECT_OFFSETOF(CallerFrameAndPC, callerFrame); }
152 
153         ReturnAddressPtr returnPC() const { return ReturnAddressPtr(callerFrameAndPC().returnPC); }
154         bool hasReturnPC() const { return !!callerFrameAndPC().returnPC; }
155         void clearReturnPC() { callerFrameAndPC().returnPC = 0; }
156         static ptrdiff_t returnPCOffset() { return OBJECT_OFFSETOF(CallerFrameAndPC, returnPC); }
157         AbstractPC abstractReturnPC(VM&amp; vm) { return AbstractPC(vm, this); }
158 
159         bool callSiteBitsAreBytecodeOffset() const;
160         bool callSiteBitsAreCodeOriginIndex() const;
161 
162         unsigned callSiteAsRawBits() const;
163         unsigned unsafeCallSiteAsRawBits() const;
164         CallSiteIndex callSiteIndex() const;
165         CallSiteIndex unsafeCallSiteIndex() const;
166     private:
167         unsigned callSiteBitsAsBytecodeOffset() const;
<span class="line-added">168 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">169         JS_EXPORT_PRIVATE JSGlobalObject* lexicalGlobalObjectFromWasmCallee(VM&amp;) const;</span>
<span class="line-added">170 #endif</span>
171     public:
172 
173         // This will try to get you the bytecode offset, but you should be aware that
174         // this bytecode offset may be bogus in the presence of inlining. This will
175         // also return 0 if the call frame has no notion of bytecode offsets (for
176         // example if it&#39;s native code).
177         // https://bugs.webkit.org/show_bug.cgi?id=121754
<span class="line-modified">178         BytecodeIndex bytecodeIndex();</span>
179 
180         // This will get you a CodeOrigin. It will always succeed. May return
<span class="line-modified">181         // CodeOrigin(BytecodeIndex(0)) if we&#39;re in native code.</span>
182         JS_EXPORT_PRIVATE CodeOrigin codeOrigin();
183 
<span class="line-modified">184         inline Register* topOfFrame();</span>





185 
186         const Instruction* currentVPC() const; // This only makes sense in the LLInt and baseline.
187         void setCurrentVPC(const Instruction*);
188 
189         void setCallerFrame(CallFrame* frame) { callerFrameAndPC().callerFrame = frame; }
<span class="line-modified">190         inline void setScope(int scopeRegisterOffset, JSScope*);</span>
191 
<span class="line-modified">192         static void initDeprecatedCallFrameForDebugger(CallFrame* globalExec, JSCallee* globalCallee);</span>
193 
194         // Read a register from the codeframe (or constant from the CodeBlock).

195         Register&amp; r(VirtualRegister);
<span class="line-modified">196         // Read a register for a known non-constant</span>

197         Register&amp; uncheckedR(VirtualRegister);
198 
199         // Access to arguments as passed. (After capture, arguments may move to a different location.)
200         size_t argumentCount() const { return argumentCountIncludingThis() - 1; }
<span class="line-modified">201         size_t argumentCountIncludingThis() const { return this[static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis)].payload(); }</span>
202         static int argumentOffset(int argument) { return (CallFrameSlot::firstArgument + argument); }
203         static int argumentOffsetIncludingThis(int argument) { return (CallFrameSlot::thisArgument + argument); }
204 
205         // In the following (argument() and setArgument()), the &#39;argument&#39;
206         // parameter is the index of the arguments of the target function of
207         // this frame. The index starts at 0 for the first arg, 1 for the
208         // second, etc.
209         //
210         // The arguments (in this case) do not include the &#39;this&#39; value.
211         // arguments(0) will not fetch the &#39;this&#39; value. To get/set &#39;this&#39;,
212         // use thisValue() and setThisValue() below.
213 
214         JSValue* addressOfArgumentsStart() const { return bitwise_cast&lt;JSValue*&gt;(this + argumentOffset(0)); }
215         JSValue argument(size_t argument)
216         {
217             if (argument &gt;= argumentCount())
218                  return jsUndefined();
219             return getArgumentUnsafe(argument);
220         }
221         JSValue uncheckedArgument(size_t argument)
</pre>
<hr />
<pre>
230 
231         JSValue getArgumentUnsafe(size_t argIndex)
232         {
233             // User beware! This method does not verify that there is a valid
234             // argument at the specified argIndex. This is used for debugging
235             // and verification code only. The caller is expected to know what
236             // he/she is doing when calling this method.
237             return this[argumentOffset(argIndex)].jsValue();
238         }
239 
240         static int thisArgumentOffset() { return argumentOffsetIncludingThis(0); }
241         JSValue thisValue() { return this[thisArgumentOffset()].jsValue(); }
242         void setThisValue(JSValue value) { this[thisArgumentOffset()] = value; }
243 
244         // Under the constructor implemented in C++, thisValue holds the newTarget instead of the automatically constructed value.
245         // The result of this function is only effective under the &quot;construct&quot; context.
246         JSValue newTarget() { return thisValue(); }
247 
248         JSValue argumentAfterCapture(size_t argument);
249 
<span class="line-modified">250         static int offsetFor(size_t argumentCountIncludingThis) { return CallFrameSlot::thisArgument + argumentCountIncludingThis - 1; }</span>
251 
252         static CallFrame* noCaller() { return nullptr; }
<span class="line-modified">253         bool isDeprecatedCallFrameForDebugger() const</span>
254         {
255             return callerFrameAndPC().callerFrame == noCaller() &amp;&amp; callerFrameAndPC().returnPC == nullptr;
256         }
257 
258         void convertToStackOverflowFrame(VM&amp;, CodeBlock* codeBlockToKeepAliveUntilFrameIsUnwound);
259         bool isStackOverflowFrame() const;
260         bool isWasmFrame() const;
261 
<span class="line-modified">262         void setArgumentCountIncludingThis(int count) { static_cast&lt;Register*&gt;(this)[static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis)].payload() = count; }</span>
<span class="line-modified">263         inline void setCallee(JSObject*);</span>
<span class="line-modified">264         inline void setCodeBlock(CodeBlock*);</span>
<span class="line-modified">265         void setReturnPC(void* value) { callerFrameAndPC().returnPC = value; }</span>
266 
267         String friendlyFunctionName();
268 
269         // CallFrame::iterate() expects a Functor that implements the following method:
270         //     StackVisitor::Status operator()(StackVisitor&amp;) const;
271         // FIXME: This method is improper. We rely on the fact that we can call it with a null
272         // receiver. We should always be using StackVisitor directly.
273         // It&#39;s only valid to call this from a non-wasm top frame.
<span class="line-modified">274         template &lt;StackVisitor::EmptyEntryFrameAction action = StackVisitor::ContinueIfTopEntryFrameIsEmpty, typename Functor&gt; void iterate(VM&amp; vm, const Functor&amp; functor)</span>
275         {

276             void* rawThis = this;
<span class="line-modified">277             if (!!rawThis)</span>
278                 RELEASE_ASSERT(callee().isCell());



279             StackVisitor::visit&lt;action, Functor&gt;(this, vm, functor);
280         }
281 
282         void dump(PrintStream&amp;);
283         JS_EXPORT_PRIVATE const char* describeFrame();
284 
285     private:
286 
<span class="line-modified">287         CallFrame();</span>
<span class="line-modified">288         ~CallFrame();</span>
289 
290         Register* topOfFrameInternal();
291 
292         // The following are for internal use in debugging and verification
293         // code only and not meant as an API for general usage:
294 
295         size_t argIndexForRegister(Register* reg)
296         {
297             // The register at &#39;offset&#39; number of slots from the frame pointer
298             // i.e.
299             //       reg = frame[offset];
300             //   ==&gt; reg = frame + offset;
301             //   ==&gt; offset = reg - frame;
302             int offset = reg - this-&gt;registers();
303 
304             // The offset is defined (based on argumentOffset()) to be:
305             //       offset = CallFrameSlot::firstArgument - argIndex;
306             // Hence:
307             //       argIndex = CallFrameSlot::firstArgument - offset;
308             size_t argIndex = offset - CallFrameSlot::firstArgument;
309             return argIndex;
310         }
311 
312         CallerFrameAndPC&amp; callerFrameAndPC() { return *reinterpret_cast&lt;CallerFrameAndPC*&gt;(this); }
313         const CallerFrameAndPC&amp; callerFrameAndPC() const { return *reinterpret_cast&lt;const CallerFrameAndPC*&gt;(this); }
314         SUPPRESS_ASAN const CallerFrameAndPC&amp; unsafeCallerFrameAndPC() const { return *reinterpret_cast&lt;const CallerFrameAndPC*&gt;(this); }
315     };
316 
<span class="line-added">317 JS_EXPORT_PRIVATE bool isFromJSCode(void* returnAddress);</span>
<span class="line-added">318 </span>
<span class="line-added">319 #if USE(BUILTIN_FRAME_ADDRESS)</span>
<span class="line-added">320 #define DECLARE_CALL_FRAME(vm) \</span>
<span class="line-added">321     ({ \</span>
<span class="line-added">322         ASSERT(JSC::isFromJSCode(removeCodePtrTag&lt;void*&gt;(__builtin_return_address(0)))); \</span>
<span class="line-added">323         bitwise_cast&lt;JSC::CallFrame*&gt;(__builtin_frame_address(1)); \</span>
<span class="line-added">324     })</span>
<span class="line-added">325 #else</span>
<span class="line-added">326 #define DECLARE_CALL_FRAME(vm) ((vm).topCallFrame)</span>
<span class="line-added">327 #endif</span>
<span class="line-added">328 </span>
<span class="line-added">329 </span>
330 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="CallFrame.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallFrameInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
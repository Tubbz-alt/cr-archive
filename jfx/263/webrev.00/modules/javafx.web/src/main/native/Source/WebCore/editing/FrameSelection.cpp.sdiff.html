<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/FrameSelection.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FontAttributeChanges.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InsertListCommand.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/FrameSelection.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 360 
 361     m_selection = newSelection;
 362 
 363     // Selection offsets should increase when LF is inserted before the caret in InsertLineBreakCommand. See &lt;https://webkit.org/b/56061&gt;.
 364     if (HTMLTextFormControlElement* textControl = enclosingTextFormControl(newSelection.start()))
 365         textControl-&gt;selectionChanged(options.contains(FireSelectEvent));
 366 
 367     if (!didMutateSelection)
 368         return false;
 369 
 370     setCaretRectNeedsUpdate();
 371 
 372     if (!newSelection.isNone() &amp;&amp; !(options &amp; DoNotSetFocus))
 373         setFocusedElementIfNeeded();
 374 
 375     // Always clear the x position used for vertical arrow navigation.
 376     // It will be restored by the vertical arrow navigation code if necessary.
 377     m_xPosForVerticalArrowNavigation = NoXPosForVerticalArrowNavigation();
 378     selectFrameElementInParentIfFullySelected();
 379     m_frame-&gt;editor().respondToChangedSelection(oldSelection, options);
<span class="line-modified"> 380     m_frame-&gt;document()-&gt;enqueueDocumentEvent(Event::create(eventNames().selectionchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>


 381 
 382     return true;
 383 }
 384 
 385 void FrameSelection::setSelection(const VisibleSelection&amp; selection, OptionSet&lt;SetSelectionOption&gt; options, AXTextStateChangeIntent intent, CursorAlignOnScroll align, TextGranularity granularity)
 386 {
 387     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
 388     if (!setSelectionWithoutUpdatingAppearance(selection, options, align, granularity))
 389         return;
 390 
 391     Document* document = m_frame-&gt;document();
 392     if (!document)
 393         return;
 394 
 395     if (options &amp; RevealSelectionUpToMainFrame)
 396         m_selectionRevealMode = SelectionRevealMode::RevealUpToMainFrame;
 397     else if (options &amp; RevealSelection)
 398         m_selectionRevealMode = SelectionRevealMode::Reveal;
 399     else
 400         m_selectionRevealMode = SelectionRevealMode::DoNotReveal;
</pre>
<hr />
<pre>
2047 
2048     document-&gt;updateStyleIfNeeded();
2049 
2050 #if USE(UIKIT_EDITING)
2051     // Caret blinking (blinks | does not blink)
2052     if (activeAndFocused)
2053         setSelectionFromNone();
2054     setCaretVisible(activeAndFocused);
2055 #else
2056     // Because RenderObject::selectionBackgroundColor() and
2057     // RenderObject::selectionForegroundColor() check if the frame is active,
2058     // we have to update places those colors were painted.
2059     if (RenderView* view = document-&gt;renderView())
2060         view-&gt;selection().repaint();
2061 
2062     // Caret appears in the active frame.
2063     if (activeAndFocused)
2064         setSelectionFromNone();
2065     setCaretVisibility(activeAndFocused ? Visible : Hidden);
2066 
<span class="line-modified">2067     // Because StyleResolver::checkOneSelector() and</span>
2068     // RenderTheme::isFocused() check if the frame is active, we have to
2069     // update style and theme state that depended on those.
2070     if (Element* element = document-&gt;focusedElement()) {
2071         element-&gt;invalidateStyleForSubtree();
2072         if (RenderObject* renderer = element-&gt;renderer())
2073             if (renderer &amp;&amp; renderer-&gt;style().hasAppearance())
2074                 renderer-&gt;theme().stateChanged(*renderer, ControlStates::FocusState);
2075     }
2076 #endif
2077 }
2078 
2079 void FrameSelection::pageActivationChanged()
2080 {
2081     focusedOrActiveStateChanged();
2082 }
2083 
2084 void FrameSelection::setFocused(bool flag)
2085 {
2086     if (m_focused == flag)
2087         return;
</pre>
</td>
<td>
<hr />
<pre>
 360 
 361     m_selection = newSelection;
 362 
 363     // Selection offsets should increase when LF is inserted before the caret in InsertLineBreakCommand. See &lt;https://webkit.org/b/56061&gt;.
 364     if (HTMLTextFormControlElement* textControl = enclosingTextFormControl(newSelection.start()))
 365         textControl-&gt;selectionChanged(options.contains(FireSelectEvent));
 366 
 367     if (!didMutateSelection)
 368         return false;
 369 
 370     setCaretRectNeedsUpdate();
 371 
 372     if (!newSelection.isNone() &amp;&amp; !(options &amp; DoNotSetFocus))
 373         setFocusedElementIfNeeded();
 374 
 375     // Always clear the x position used for vertical arrow navigation.
 376     // It will be restored by the vertical arrow navigation code if necessary.
 377     m_xPosForVerticalArrowNavigation = NoXPosForVerticalArrowNavigation();
 378     selectFrameElementInParentIfFullySelected();
 379     m_frame-&gt;editor().respondToChangedSelection(oldSelection, options);
<span class="line-modified"> 380     // https://www.w3.org/TR/selection-api/#selectionchange-event</span>
<span class="line-added"> 381     // FIXME: Spec doesn&#39;t specify which task source to use.</span>
<span class="line-added"> 382     m_frame-&gt;document()-&gt;queueTaskToDispatchEvent(TaskSource::UserInteraction, Event::create(eventNames().selectionchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
 383 
 384     return true;
 385 }
 386 
 387 void FrameSelection::setSelection(const VisibleSelection&amp; selection, OptionSet&lt;SetSelectionOption&gt; options, AXTextStateChangeIntent intent, CursorAlignOnScroll align, TextGranularity granularity)
 388 {
 389     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
 390     if (!setSelectionWithoutUpdatingAppearance(selection, options, align, granularity))
 391         return;
 392 
 393     Document* document = m_frame-&gt;document();
 394     if (!document)
 395         return;
 396 
 397     if (options &amp; RevealSelectionUpToMainFrame)
 398         m_selectionRevealMode = SelectionRevealMode::RevealUpToMainFrame;
 399     else if (options &amp; RevealSelection)
 400         m_selectionRevealMode = SelectionRevealMode::Reveal;
 401     else
 402         m_selectionRevealMode = SelectionRevealMode::DoNotReveal;
</pre>
<hr />
<pre>
2049 
2050     document-&gt;updateStyleIfNeeded();
2051 
2052 #if USE(UIKIT_EDITING)
2053     // Caret blinking (blinks | does not blink)
2054     if (activeAndFocused)
2055         setSelectionFromNone();
2056     setCaretVisible(activeAndFocused);
2057 #else
2058     // Because RenderObject::selectionBackgroundColor() and
2059     // RenderObject::selectionForegroundColor() check if the frame is active,
2060     // we have to update places those colors were painted.
2061     if (RenderView* view = document-&gt;renderView())
2062         view-&gt;selection().repaint();
2063 
2064     // Caret appears in the active frame.
2065     if (activeAndFocused)
2066         setSelectionFromNone();
2067     setCaretVisibility(activeAndFocused ? Visible : Hidden);
2068 
<span class="line-modified">2069     // Because Style::Resolver::checkOneSelector() and</span>
2070     // RenderTheme::isFocused() check if the frame is active, we have to
2071     // update style and theme state that depended on those.
2072     if (Element* element = document-&gt;focusedElement()) {
2073         element-&gt;invalidateStyleForSubtree();
2074         if (RenderObject* renderer = element-&gt;renderer())
2075             if (renderer &amp;&amp; renderer-&gt;style().hasAppearance())
2076                 renderer-&gt;theme().stateChanged(*renderer, ControlStates::FocusState);
2077     }
2078 #endif
2079 }
2080 
2081 void FrameSelection::pageActivationChanged()
2082 {
2083     focusedOrActiveStateChanged();
2084 }
2085 
2086 void FrameSelection::setFocused(bool flag)
2087 {
2088     if (m_focused == flag)
2089         return;
</pre>
</td>
</tr>
</table>
<center><a href="FontAttributeChanges.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InsertListCommand.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
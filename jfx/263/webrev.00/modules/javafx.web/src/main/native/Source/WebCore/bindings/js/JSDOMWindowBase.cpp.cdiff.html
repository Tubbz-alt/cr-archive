<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMPromiseDeferred.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMWindowBase.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 22,15 ***</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;JSDOMWindowBase.h&quot;
  
<span class="line-removed">- #include &quot;ActiveDOMCallbackMicrotask.h&quot;</span>
  #include &quot;Chrome.h&quot;
  #include &quot;CommonVM.h&quot;
  #include &quot;DOMWindow.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;FetchResponse.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;InspectorController.h&quot;
  #include &quot;JSDOMBindingSecurity.h&quot;
  #include &quot;JSDOMGlobalObjectTask.h&quot;
<span class="line-new-header">--- 22,15 ---</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;JSDOMWindowBase.h&quot;
  
  #include &quot;Chrome.h&quot;
  #include &quot;CommonVM.h&quot;
  #include &quot;DOMWindow.h&quot;
  #include &quot;Document.h&quot;
<span class="line-added">+ #include &quot;EventLoop.h&quot;</span>
  #include &quot;FetchResponse.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;InspectorController.h&quot;
  #include &quot;JSDOMBindingSecurity.h&quot;
  #include &quot;JSDOMGlobalObjectTask.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 47,14 ***</span>
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;WebCoreJSClientData.h&quot;
  #include &lt;JavaScriptCore/CodeBlock.h&gt;
  #include &lt;JavaScriptCore/JSInternalPromise.h&gt;
<span class="line-removed">- #include &lt;JavaScriptCore/JSInternalPromiseDeferred.h&gt;</span>
  #include &lt;JavaScriptCore/JSWebAssembly.h&gt;
  #include &lt;JavaScriptCore/Microtask.h&gt;
<span class="line-modified">! #include &lt;JavaScriptCore/PromiseDeferredTimer.h&gt;</span>
  #include &lt;JavaScriptCore/StrongInlines.h&gt;
  #include &lt;wtf/Language.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  
  #if PLATFORM(IOS_FAMILY)
<span class="line-new-header">--- 47,13 ---</span>
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;WebCoreJSClientData.h&quot;
  #include &lt;JavaScriptCore/CodeBlock.h&gt;
  #include &lt;JavaScriptCore/JSInternalPromise.h&gt;
  #include &lt;JavaScriptCore/JSWebAssembly.h&gt;
  #include &lt;JavaScriptCore/Microtask.h&gt;
<span class="line-modified">! #include &lt;JavaScriptCore/PromiseTimer.h&gt;</span>
  #include &lt;JavaScriptCore/StrongInlines.h&gt;
  #include &lt;wtf/Language.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  
  #if PLATFORM(IOS_FAMILY)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,11 ***</span>
  
  const GlobalObjectMethodTable JSDOMWindowBase::s_globalObjectMethodTable = {
      &amp;supportsRichSourceInfo,
      &amp;shouldInterruptScript,
      &amp;javaScriptRuntimeFlags,
<span class="line-modified">!     &amp;queueTaskToEventLoop,</span>
      &amp;shouldInterruptScriptBeforeTimeout,
      &amp;moduleLoaderImportModule,
      &amp;moduleLoaderResolve,
      &amp;moduleLoaderFetch,
      &amp;moduleLoaderCreateImportMetaProperties,
<span class="line-new-header">--- 68,11 ---</span>
  
  const GlobalObjectMethodTable JSDOMWindowBase::s_globalObjectMethodTable = {
      &amp;supportsRichSourceInfo,
      &amp;shouldInterruptScript,
      &amp;javaScriptRuntimeFlags,
<span class="line-modified">!     &amp;queueMicrotaskToEventLoop,</span>
      &amp;shouldInterruptScriptBeforeTimeout,
      &amp;moduleLoaderImportModule,
      &amp;moduleLoaderResolve,
      &amp;moduleLoaderFetch,
      &amp;moduleLoaderCreateImportMetaProperties,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,15 ***</span>
  {
      // Since &quot;document&quot; property is defined as { configurable: false, writable: false, enumerable: true },
      // users cannot change its attributes further.
      // Reaching here, the attributes of &quot;document&quot; property should be never changed.
      ASSERT(m_wrapped-&gt;document());
<span class="line-modified">!     ExecState* exec = globalExec();</span>
      bool shouldThrowReadOnlyError = false;
      bool ignoreReadOnlyErrors = true;
      bool putResult = false;
<span class="line-modified">!     symbolTablePutTouchWatchpointSet(this, exec, static_cast&lt;JSVMClientData*&gt;(exec-&gt;vm().clientData)-&gt;builtinNames().documentPublicName(), toJS(exec, this, m_wrapped-&gt;document()), shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
  }
  
  ScriptExecutionContext* JSDOMWindowBase::scriptExecutionContext() const
  {
      return m_wrapped-&gt;document();
<span class="line-new-header">--- 123,15 ---</span>
  {
      // Since &quot;document&quot; property is defined as { configurable: false, writable: false, enumerable: true },
      // users cannot change its attributes further.
      // Reaching here, the attributes of &quot;document&quot; property should be never changed.
      ASSERT(m_wrapped-&gt;document());
<span class="line-modified">!     JSGlobalObject* lexicalGlobalObject = this;</span>
      bool shouldThrowReadOnlyError = false;
      bool ignoreReadOnlyErrors = true;
      bool putResult = false;
<span class="line-modified">!     symbolTablePutTouchWatchpointSet(this, lexicalGlobalObject, static_cast&lt;JSVMClientData*&gt;(lexicalGlobalObject-&gt;vm().clientData)-&gt;builtinNames().documentPublicName(), toJS(lexicalGlobalObject, this, m_wrapped-&gt;document()), shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
  }
  
  ScriptExecutionContext* JSDOMWindowBase::scriptExecutionContext() const
  {
      return m_wrapped-&gt;document();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,11 ***</span>
  }
  
  static inline bool shouldInterruptScriptToPreventInfiniteRecursionWhenClosingPage(Page* page)
  {
      // See &lt;rdar://problem/5479443&gt;. We don&#39;t think that page can ever be NULL
<span class="line-modified">!     // in this case, but if it is, we&#39;ve gotten into a state where we may have</span>
      // hung the UI, with no way to ask the client whether to cancel execution.
      // For now, our solution is just to cancel execution no matter what,
      // ensuring that we never hang. We might want to consider other solutions
      // if we discover problems with this one.
      ASSERT(page);
<span class="line-new-header">--- 159,11 ---</span>
  }
  
  static inline bool shouldInterruptScriptToPreventInfiniteRecursionWhenClosingPage(Page* page)
  {
      // See &lt;rdar://problem/5479443&gt;. We don&#39;t think that page can ever be NULL
<span class="line-modified">!     // in this case, but if it is, we&#39;ve gotten into a lexicalGlobalObject where we may have</span>
      // hung the UI, with no way to ask the client whether to cancel execution.
      // For now, our solution is just to cancel execution no matter what,
      // ensuring that we never hang. We might want to consider other solutions
      // if we discover problems with this one.
      ASSERT(page);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,20 ***</span>
      if (!frame)
          return RuntimeFlags();
      return frame-&gt;settings().javaScriptRuntimeFlags();
  }
  
<span class="line-modified">! void JSDOMWindowBase::queueTaskToEventLoop(JSGlobalObject&amp; object, Ref&lt;JSC::Microtask&gt;&amp;&amp; task)</span>
  {
      JSDOMWindowBase&amp; thisObject = static_cast&lt;JSDOMWindowBase&amp;&gt;(object);
  
      auto callback = JSMicrotaskCallback::create(thisObject, WTFMove(task));
<span class="line-modified">!     auto microtask = makeUnique&lt;ActiveDOMCallbackMicrotask&gt;(MicrotaskQueue::mainThreadQueue(), *thisObject.scriptExecutionContext(), [callback = WTFMove(callback)]() mutable {</span>
          callback-&gt;call();
      });
<span class="line-removed">- </span>
<span class="line-removed">-     MicrotaskQueue::mainThreadQueue().append(WTFMove(microtask));</span>
  }
  
  void JSDOMWindowBase::willRemoveFromWindowProxy()
  {
      setCurrentEvent(0);
<span class="line-new-header">--- 202,19 ---</span>
      if (!frame)
          return RuntimeFlags();
      return frame-&gt;settings().javaScriptRuntimeFlags();
  }
  
<span class="line-modified">! void JSDOMWindowBase::queueMicrotaskToEventLoop(JSGlobalObject&amp; object, Ref&lt;JSC::Microtask&gt;&amp;&amp; task)</span>
  {
      JSDOMWindowBase&amp; thisObject = static_cast&lt;JSDOMWindowBase&amp;&gt;(object);
  
      auto callback = JSMicrotaskCallback::create(thisObject, WTFMove(task));
<span class="line-modified">!     auto&amp; eventLoop = thisObject.scriptExecutionContext()-&gt;eventLoop();</span>
<span class="line-added">+     eventLoop.queueMicrotask([callback = WTFMove(callback)]() mutable {</span>
          callback-&gt;call();
      });
  }
  
  void JSDOMWindowBase::willRemoveFromWindowProxy()
  {
      setCurrentEvent(0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 225,16 ***</span>
  JSWindowProxy* JSDOMWindowBase::proxy() const
  {
      return m_proxy;
  }
  
<span class="line-modified">! JSValue toJS(ExecState* state, DOMWindow&amp; domWindow)</span>
  {
      auto* frame = domWindow.frame();
      if (!frame)
          return jsNull();
<span class="line-modified">!     return toJS(state, frame-&gt;windowProxy());</span>
  }
  
  JSDOMWindow* toJSDOMWindow(Frame&amp; frame, DOMWrapperWorld&amp; world)
  {
      return frame.script().globalObject(world);
<span class="line-new-header">--- 223,16 ---</span>
  JSWindowProxy* JSDOMWindowBase::proxy() const
  {
      return m_proxy;
  }
  
<span class="line-modified">! JSValue toJS(JSGlobalObject* lexicalGlobalObject, DOMWindow&amp; domWindow)</span>
  {
      auto* frame = domWindow.frame();
      if (!frame)
          return jsNull();
<span class="line-modified">!     return toJS(lexicalGlobalObject, frame-&gt;windowProxy());</span>
  }
  
  JSDOMWindow* toJSDOMWindow(Frame&amp; frame, DOMWrapperWorld&amp; world)
  {
      return frame.script().globalObject(world);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 255,34 ***</span>
          value = object-&gt;getPrototypeDirect(vm);
      }
      return nullptr;
  }
  
<span class="line-modified">! DOMWindow&amp; incumbentDOMWindow(ExecState&amp; state)</span>
  {
<span class="line-modified">!     return asJSDOMWindow(&amp;callerGlobalObject(state))-&gt;wrapped();</span>
  }
  
<span class="line-modified">! DOMWindow&amp; activeDOMWindow(ExecState&amp; state)</span>
  {
<span class="line-modified">!     return asJSDOMWindow(state.lexicalGlobalObject())-&gt;wrapped();</span>
  }
  
<span class="line-modified">! DOMWindow&amp; firstDOMWindow(ExecState&amp; state)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
<span class="line-modified">!     return asJSDOMWindow(vm.vmEntryGlobalObject(&amp;state))-&gt;wrapped();</span>
  }
  
<span class="line-modified">! Document* responsibleDocument(ExecState&amp; state)</span>
  {
      CallerFunctor functor;
<span class="line-modified">!     state.iterate(functor);</span>
      auto* callerFrame = functor.callerFrame();
      if (!callerFrame)
          return nullptr;
<span class="line-modified">!     return asJSDOMWindow(callerFrame-&gt;lexicalGlobalObject())-&gt;wrapped().document();</span>
  }
  
  void JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(DOMWindow* window)
  {
      JSC::VM&amp; vm = commonVM();
<span class="line-new-header">--- 253,34 ---</span>
          value = object-&gt;getPrototypeDirect(vm);
      }
      return nullptr;
  }
  
<span class="line-modified">! DOMWindow&amp; incumbentDOMWindow(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)</span>
  {
<span class="line-modified">!     return asJSDOMWindow(&amp;callerGlobalObject(lexicalGlobalObject, callFrame))-&gt;wrapped();</span>
  }
  
<span class="line-modified">! DOMWindow&amp; activeDOMWindow(JSGlobalObject&amp; lexicalGlobalObject)</span>
  {
<span class="line-modified">!     return asJSDOMWindow(&amp;lexicalGlobalObject)-&gt;wrapped();</span>
  }
  
<span class="line-modified">! DOMWindow&amp; firstDOMWindow(JSGlobalObject&amp; lexicalGlobalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
<span class="line-modified">!     return asJSDOMWindow(vm.deprecatedVMEntryGlobalObject(&amp;lexicalGlobalObject))-&gt;wrapped();</span>
  }
  
<span class="line-modified">! Document* responsibleDocument(VM&amp; vm, CallFrame&amp; callFrame)</span>
  {
      CallerFunctor functor;
<span class="line-modified">!     callFrame.iterate(vm, functor);</span>
      auto* callerFrame = functor.callerFrame();
      if (!callerFrame)
          return nullptr;
<span class="line-modified">!     return asJSDOMWindow(callerFrame-&gt;lexicalGlobalObject(vm))-&gt;wrapped().document();</span>
  }
  
  void JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(DOMWindow* window)
  {
      JSC::VM&amp; vm = commonVM();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,176 ***</span>
          JSDOMWindowBase* jsWindow = JSC::jsCast&lt;JSDOMWindowBase*&gt;(wrapper);
          jsWindow-&gt;m_windowCloseWatchpoints.fireAll(vm, &quot;Frame cleared&quot;);
      }
  }
  
<span class="line-modified">! JSC::Identifier JSDOMWindowBase::moduleLoaderResolve(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleName, JSC::JSValue importerModuleKey, JSC::JSValue scriptFetcher)</span>
  {
      JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
      if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">!         return document-&gt;moduleLoader().resolve(globalObject, exec, moduleLoader, moduleName, importerModuleKey, scriptFetcher);</span>
      return { };
  }
  
<span class="line-modified">! JSC::JSInternalPromise* JSDOMWindowBase::moduleLoaderFetch(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSValue parameters, JSC::JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
      if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, document-&gt;moduleLoader().fetch(globalObject, exec, moduleLoader, moduleKey, parameters, scriptFetcher));</span>
<span class="line-modified">!     JSC::JSInternalPromiseDeferred* deferred = JSC::JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-modified">!     RELEASE_AND_RETURN(scope, deferred-&gt;reject(exec, jsUndefined()));</span>
  }
  
<span class="line-modified">! JSC::JSValue JSDOMWindowBase::moduleLoaderEvaluate(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSValue moduleRecord, JSC::JSValue scriptFetcher)</span>
  {
      JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
      if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">!         return document-&gt;moduleLoader().evaluate(globalObject, exec, moduleLoader, moduleKey, moduleRecord, scriptFetcher);</span>
      return JSC::jsUndefined();
  }
  
<span class="line-modified">! JSC::JSInternalPromise* JSDOMWindowBase::moduleLoaderImportModule(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSModuleLoader* moduleLoader, JSC::JSString* moduleName, JSC::JSValue parameters, const JSC::SourceOrigin&amp; sourceOrigin)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
      if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, document-&gt;moduleLoader().importModule(globalObject, exec, moduleLoader, moduleName, parameters, sourceOrigin));</span>
<span class="line-modified">!     JSC::JSInternalPromiseDeferred* deferred = JSC::JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-modified">!     RELEASE_AND_RETURN(scope, deferred-&gt;reject(exec, jsUndefined()));</span>
  }
  
<span class="line-modified">! JSC::JSObject* JSDOMWindowBase::moduleLoaderCreateImportMetaProperties(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSModuleRecord* moduleRecord, JSC::JSValue scriptFetcher)</span>
  {
      JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
      if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">!         return document-&gt;moduleLoader().createImportMetaProperties(globalObject, exec, moduleLoader, moduleKey, moduleRecord, scriptFetcher);</span>
<span class="line-modified">!     return constructEmptyObject(exec, globalObject-&gt;nullPrototypeObjectStructure());</span>
  }
  
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">! static Optional&lt;Vector&lt;uint8_t&gt;&gt; tryAllocate(JSC::ExecState* exec, JSC::JSPromiseDeferred* promise, const char* data, size_t byteSize)</span>
  {
      Vector&lt;uint8_t&gt; arrayBuffer;
      if (!arrayBuffer.tryReserveCapacity(byteSize)) {
<span class="line-modified">!         promise-&gt;reject(exec, createOutOfMemoryError(exec));</span>
          return WTF::nullopt;
      }
  
      arrayBuffer.grow(byteSize);
      memcpy(arrayBuffer.data(), data, byteSize);
  
      return arrayBuffer;
  }
  
<span class="line-modified">! static bool isResponseCorrect(JSC::ExecState* exec, FetchResponse* inputResponse, JSC::JSPromiseDeferred* promise)</span>
  {
      bool isResponseCorsSameOrigin = inputResponse-&gt;type() == ResourceResponse::Type::Basic || inputResponse-&gt;type() == ResourceResponse::Type::Cors || inputResponse-&gt;type() == ResourceResponse::Type::Default;
  
      if (!isResponseCorsSameOrigin) {
<span class="line-modified">!         promise-&gt;reject(exec, createTypeError(exec, &quot;Response is not CORS-same-origin&quot;_s));</span>
          return false;
      }
  
      if (!inputResponse-&gt;ok()) {
<span class="line-modified">!         promise-&gt;reject(exec, createTypeError(exec, &quot;Response has not returned OK status&quot;_s));</span>
          return false;
      }
  
      auto contentType = inputResponse-&gt;headers().fastGet(HTTPHeaderName::ContentType);
      if (!equalLettersIgnoringASCIICase(contentType, &quot;application/wasm&quot;)) {
<span class="line-modified">!         promise-&gt;reject(exec, createTypeError(exec, &quot;Unexpected response MIME type. Expected &#39;application/wasm&#39;&quot;_s));</span>
          return false;
      }
  
      return true;
  }
  
<span class="line-modified">! static void handleResponseOnStreamingAction(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, FetchResponse* inputResponse, JSC::JSPromiseDeferred* promise, Function&lt;void(JSC::ExecState* exec, const char* data, size_t byteSize)&gt;&amp;&amp; actionCallback)</span>
  {
<span class="line-modified">!     if (!isResponseCorrect(exec, inputResponse, promise))</span>
          return;
  
      if (inputResponse-&gt;isBodyReceivedByChunk()) {
          inputResponse-&gt;consumeBodyReceivedByChunk([promise, callback = WTFMove(actionCallback), globalObject, data = SharedBuffer::create()] (auto&amp;&amp; result) mutable {
<span class="line-removed">-             ExecState* exec = globalObject-&gt;globalExec();</span>
              if (result.hasException()) {
<span class="line-modified">!                 promise-&gt;reject(exec, createTypeError(exec, result.exception().message()));</span>
                  return;
              }
  
              if (auto chunk = result.returnValue())
                  data-&gt;append(reinterpret_cast&lt;const char*&gt;(chunk-&gt;data), chunk-&gt;size);
              else {
<span class="line-modified">!                 VM&amp; vm = exec-&gt;vm();</span>
                  JSLockHolder lock(vm);
  
<span class="line-modified">!                 callback(exec, data-&gt;data(), data-&gt;size());</span>
              }
          });
          return;
      }
  
      auto body = inputResponse-&gt;consumeBody();
      WTF::switchOn(body, [&amp;] (Ref&lt;FormData&gt;&amp; formData) {
          if (auto buffer = formData-&gt;asSharedBuffer()) {
<span class="line-modified">!             VM&amp; vm = exec-&gt;vm();</span>
              JSLockHolder lock(vm);
  
<span class="line-modified">!             actionCallback(exec, buffer-&gt;data(), buffer-&gt;size());</span>
              return;
          }
          // FIXME: http://webkit.org/b/184886&gt; Implement loading for the Blob type
<span class="line-modified">!         promise-&gt;reject(exec, createTypeError(exec, &quot;Unexpected Response&#39;s Content-type&quot;_s));</span>
      }, [&amp;] (Ref&lt;SharedBuffer&gt;&amp; buffer) {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          JSLockHolder lock(vm);
  
<span class="line-modified">!         actionCallback(exec, buffer-&gt;data(), buffer-&gt;size());</span>
      }, [&amp;] (std::nullptr_t&amp;) {
<span class="line-modified">!         promise-&gt;reject(exec, createTypeError(exec, &quot;Unexpected Response&#39;s Content-type&quot;_s));</span>
      });
  }
  
<span class="line-modified">! void JSDOMWindowBase::compileStreaming(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSPromiseDeferred* promise, JSC::JSValue source)</span>
  {
      ASSERT(source);
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
<span class="line-modified">!     ASSERT(vm.promiseDeferredTimer-&gt;hasPendingPromise(promise));</span>
<span class="line-modified">!     ASSERT(vm.promiseDeferredTimer-&gt;hasDependancyInPendingPromise(promise, globalObject));</span>
  
      if (auto inputResponse = JSFetchResponse::toWrapped(vm, source)) {
<span class="line-modified">!         handleResponseOnStreamingAction(globalObject, exec, inputResponse, promise, [promise] (JSC::ExecState* exec, const char* data, size_t byteSize) mutable {</span>
<span class="line-modified">!             if (auto arrayBuffer = tryAllocate(exec, promise, data, byteSize))</span>
<span class="line-modified">!                 JSC::JSWebAssembly::webAssemblyModuleValidateAsync(exec, promise, WTFMove(*arrayBuffer));</span>
          });
      } else
<span class="line-modified">!         promise-&gt;reject(exec, createTypeError(exec, &quot;first argument must be an Response or Promise for Response&quot;_s));</span>
  }
  
<span class="line-modified">! void JSDOMWindowBase::instantiateStreaming(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSPromiseDeferred* promise, JSC::JSValue source, JSC::JSObject* importedObject)</span>
  {
      ASSERT(source);
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
<span class="line-modified">!     ASSERT(vm.promiseDeferredTimer-&gt;hasPendingPromise(promise));</span>
<span class="line-modified">!     ASSERT(vm.promiseDeferredTimer-&gt;hasDependancyInPendingPromise(promise, globalObject));</span>
<span class="line-modified">!     ASSERT(vm.promiseDeferredTimer-&gt;hasDependancyInPendingPromise(promise, importedObject));</span>
  
      if (auto inputResponse = JSFetchResponse::toWrapped(vm, source)) {
<span class="line-modified">!         handleResponseOnStreamingAction(globalObject, exec, inputResponse, promise, [promise, importedObject] (JSC::ExecState* exec, const char* data, size_t byteSize) mutable {</span>
<span class="line-modified">!             if (auto arrayBuffer = tryAllocate(exec, promise, data, byteSize))</span>
<span class="line-modified">!                 JSC::JSWebAssembly::webAssemblyModuleInstantinateAsync(exec, promise, WTFMove(*arrayBuffer), importedObject);</span>
          });
      } else
<span class="line-modified">!         promise-&gt;reject(exec, createTypeError(exec, &quot;first argument must be an Response or Promise for Response&quot;_s));</span>
  }
  #endif
  
  } // namespace WebCore
<span class="line-new-header">--- 298,177 ---</span>
          JSDOMWindowBase* jsWindow = JSC::jsCast&lt;JSDOMWindowBase*&gt;(wrapper);
          jsWindow-&gt;m_windowCloseWatchpoints.fireAll(vm, &quot;Frame cleared&quot;);
      }
  }
  
<span class="line-modified">! JSC::Identifier JSDOMWindowBase::moduleLoaderResolve(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleName, JSC::JSValue importerModuleKey, JSC::JSValue scriptFetcher)</span>
  {
      JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
      if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">!         return document-&gt;moduleLoader().resolve(globalObject, moduleLoader, moduleName, importerModuleKey, scriptFetcher);</span>
      return { };
  }
  
<span class="line-modified">! JSC::JSInternalPromise* JSDOMWindowBase::moduleLoaderFetch(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSValue parameters, JSC::JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
      if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, document-&gt;moduleLoader().fetch(globalObject, moduleLoader, moduleKey, parameters, scriptFetcher));</span>
<span class="line-modified">!     JSC::JSInternalPromise* promise = JSC::JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-modified">!     scope.release();</span>
<span class="line-modified">!     promise-&gt;reject(globalObject, jsUndefined());</span>
<span class="line-added">+     return promise;</span>
  }
  
<span class="line-modified">! JSC::JSValue JSDOMWindowBase::moduleLoaderEvaluate(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSValue moduleRecord, JSC::JSValue scriptFetcher)</span>
  {
      JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
      if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">!         return document-&gt;moduleLoader().evaluate(globalObject, moduleLoader, moduleKey, moduleRecord, scriptFetcher);</span>
      return JSC::jsUndefined();
  }
  
<span class="line-modified">! JSC::JSInternalPromise* JSDOMWindowBase::moduleLoaderImportModule(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSString* moduleName, JSC::JSValue parameters, const JSC::SourceOrigin&amp; sourceOrigin)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
      if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, document-&gt;moduleLoader().importModule(globalObject, moduleLoader, moduleName, parameters, sourceOrigin));</span>
<span class="line-modified">!     JSC::JSInternalPromise* promise = JSC::JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-modified">!     scope.release();</span>
<span class="line-modified">!     promise-&gt;reject(globalObject, jsUndefined());</span>
<span class="line-added">+     return promise;</span>
  }
  
<span class="line-modified">! JSC::JSObject* JSDOMWindowBase::moduleLoaderCreateImportMetaProperties(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSModuleRecord* moduleRecord, JSC::JSValue scriptFetcher)</span>
  {
      JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
      if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">!         return document-&gt;moduleLoader().createImportMetaProperties(globalObject, moduleLoader, moduleKey, moduleRecord, scriptFetcher);</span>
<span class="line-modified">!     return constructEmptyObject(globalObject-&gt;vm(), globalObject-&gt;nullPrototypeObjectStructure());</span>
  }
  
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">! static Optional&lt;Vector&lt;uint8_t&gt;&gt; tryAllocate(JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSPromise* promise, const char* data, size_t byteSize)</span>
  {
      Vector&lt;uint8_t&gt; arrayBuffer;
      if (!arrayBuffer.tryReserveCapacity(byteSize)) {
<span class="line-modified">!         promise-&gt;reject(lexicalGlobalObject, createOutOfMemoryError(lexicalGlobalObject));</span>
          return WTF::nullopt;
      }
  
      arrayBuffer.grow(byteSize);
      memcpy(arrayBuffer.data(), data, byteSize);
  
      return arrayBuffer;
  }
  
<span class="line-modified">! static bool isResponseCorrect(JSC::JSGlobalObject* lexicalGlobalObject, FetchResponse* inputResponse, JSC::JSPromise* promise)</span>
  {
      bool isResponseCorsSameOrigin = inputResponse-&gt;type() == ResourceResponse::Type::Basic || inputResponse-&gt;type() == ResourceResponse::Type::Cors || inputResponse-&gt;type() == ResourceResponse::Type::Default;
  
      if (!isResponseCorsSameOrigin) {
<span class="line-modified">!         promise-&gt;reject(lexicalGlobalObject, createTypeError(lexicalGlobalObject, &quot;Response is not CORS-same-origin&quot;_s));</span>
          return false;
      }
  
      if (!inputResponse-&gt;ok()) {
<span class="line-modified">!         promise-&gt;reject(lexicalGlobalObject, createTypeError(lexicalGlobalObject, &quot;Response has not returned OK status&quot;_s));</span>
          return false;
      }
  
      auto contentType = inputResponse-&gt;headers().fastGet(HTTPHeaderName::ContentType);
      if (!equalLettersIgnoringASCIICase(contentType, &quot;application/wasm&quot;)) {
<span class="line-modified">!         promise-&gt;reject(lexicalGlobalObject, createTypeError(lexicalGlobalObject, &quot;Unexpected response MIME type. Expected &#39;application/wasm&#39;&quot;_s));</span>
          return false;
      }
  
      return true;
  }
  
<span class="line-modified">! static void handleResponseOnStreamingAction(JSC::JSGlobalObject* globalObject, FetchResponse* inputResponse, JSC::JSPromise* promise, Function&lt;void(JSC::JSGlobalObject* lexicalGlobalObject, const char* data, size_t byteSize)&gt;&amp;&amp; actionCallback)</span>
  {
<span class="line-modified">!     if (!isResponseCorrect(globalObject, inputResponse, promise))</span>
          return;
  
      if (inputResponse-&gt;isBodyReceivedByChunk()) {
          inputResponse-&gt;consumeBodyReceivedByChunk([promise, callback = WTFMove(actionCallback), globalObject, data = SharedBuffer::create()] (auto&amp;&amp; result) mutable {
              if (result.hasException()) {
<span class="line-modified">!                 promise-&gt;reject(globalObject, createTypeError(globalObject, result.exception().message()));</span>
                  return;
              }
  
              if (auto chunk = result.returnValue())
                  data-&gt;append(reinterpret_cast&lt;const char*&gt;(chunk-&gt;data), chunk-&gt;size);
              else {
<span class="line-modified">!                 VM&amp; vm = globalObject-&gt;vm();</span>
                  JSLockHolder lock(vm);
  
<span class="line-modified">!                 callback(globalObject, data-&gt;data(), data-&gt;size());</span>
              }
          });
          return;
      }
  
      auto body = inputResponse-&gt;consumeBody();
      WTF::switchOn(body, [&amp;] (Ref&lt;FormData&gt;&amp; formData) {
          if (auto buffer = formData-&gt;asSharedBuffer()) {
<span class="line-modified">!             VM&amp; vm = globalObject-&gt;vm();</span>
              JSLockHolder lock(vm);
  
<span class="line-modified">!             actionCallback(globalObject, buffer-&gt;data(), buffer-&gt;size());</span>
              return;
          }
          // FIXME: http://webkit.org/b/184886&gt; Implement loading for the Blob type
<span class="line-modified">!         promise-&gt;reject(globalObject, createTypeError(globalObject, &quot;Unexpected Response&#39;s Content-type&quot;_s));</span>
      }, [&amp;] (Ref&lt;SharedBuffer&gt;&amp; buffer) {
<span class="line-modified">!         VM&amp; vm = globalObject-&gt;vm();</span>
          JSLockHolder lock(vm);
  
<span class="line-modified">!         actionCallback(globalObject, buffer-&gt;data(), buffer-&gt;size());</span>
      }, [&amp;] (std::nullptr_t&amp;) {
<span class="line-modified">!         promise-&gt;reject(globalObject, createTypeError(globalObject, &quot;Unexpected Response&#39;s Content-type&quot;_s));</span>
      });
  }
  
<span class="line-modified">! void JSDOMWindowBase::compileStreaming(JSC::JSGlobalObject* globalObject, JSC::JSPromise* promise, JSC::JSValue source)</span>
  {
      ASSERT(source);
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
<span class="line-modified">!     ASSERT(vm.promiseTimer-&gt;hasPendingPromise(promise));</span>
<span class="line-modified">!     ASSERT(vm.promiseTimer-&gt;hasDependancyInPendingPromise(promise, globalObject));</span>
  
      if (auto inputResponse = JSFetchResponse::toWrapped(vm, source)) {
<span class="line-modified">!         handleResponseOnStreamingAction(globalObject, inputResponse, promise, [promise] (JSC::JSGlobalObject* lexicalGlobalObject, const char* data, size_t byteSize) mutable {</span>
<span class="line-modified">!             if (auto arrayBuffer = tryAllocate(lexicalGlobalObject, promise, data, byteSize))</span>
<span class="line-modified">!                 JSC::JSWebAssembly::webAssemblyModuleValidateAsync(lexicalGlobalObject, promise, WTFMove(*arrayBuffer));</span>
          });
      } else
<span class="line-modified">!         promise-&gt;reject(globalObject, createTypeError(globalObject, &quot;first argument must be an Response or Promise for Response&quot;_s));</span>
  }
  
<span class="line-modified">! void JSDOMWindowBase::instantiateStreaming(JSC::JSGlobalObject* globalObject, JSC::JSPromise* promise, JSC::JSValue source, JSC::JSObject* importedObject)</span>
  {
      ASSERT(source);
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
<span class="line-modified">!     ASSERT(vm.promiseTimer-&gt;hasPendingPromise(promise));</span>
<span class="line-modified">!     ASSERT(vm.promiseTimer-&gt;hasDependancyInPendingPromise(promise, globalObject));</span>
<span class="line-modified">!     ASSERT(vm.promiseTimer-&gt;hasDependancyInPendingPromise(promise, importedObject));</span>
  
      if (auto inputResponse = JSFetchResponse::toWrapped(vm, source)) {
<span class="line-modified">!         handleResponseOnStreamingAction(globalObject, inputResponse, promise, [promise, importedObject] (JSC::JSGlobalObject* lexicalGlobalObject, const char* data, size_t byteSize) mutable {</span>
<span class="line-modified">!             if (auto arrayBuffer = tryAllocate(lexicalGlobalObject, promise, data, byteSize))</span>
<span class="line-modified">!                 JSC::JSWebAssembly::webAssemblyModuleInstantinateAsync(lexicalGlobalObject, promise, WTFMove(*arrayBuffer), importedObject);</span>
          });
      } else
<span class="line-modified">!         promise-&gt;reject(globalObject, createTypeError(globalObject, &quot;first argument must be an Response or Promise for Response&quot;_s));</span>
  }
  #endif
  
  } // namespace WebCore
</pre>
<center><a href="JSDOMPromiseDeferred.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMWindowBase.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
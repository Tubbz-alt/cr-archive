<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorTimelineAgent.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorTimelineAgent.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorWorkerAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorTimelineAgent.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 69     TimeStamp,
 70     Time,
 71     TimeEnd,
 72 
 73     FunctionCall,
 74     ProbeSample,
 75     ConsoleProfile,
 76 
 77     RequestAnimationFrame,
 78     CancelAnimationFrame,
 79     FireAnimationFrame,
 80 
 81     ObserverCallback,
 82 };
 83 
 84 class InspectorTimelineAgent final : public InspectorAgentBase , public Inspector::TimelineBackendDispatcherHandler , public Inspector::ScriptDebugListener {
 85     WTF_MAKE_NONCOPYABLE(InspectorTimelineAgent);
 86     WTF_MAKE_FAST_ALLOCATED;
 87 public:
 88     InspectorTimelineAgent(PageAgentContext&amp;);
<span class="line-modified"> 89     virtual ~InspectorTimelineAgent();</span>
 90 
 91     // InspectorAgentBase
<span class="line-modified"> 92     void didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*);</span>
<span class="line-modified"> 93     void willDestroyFrontendAndBackend(Inspector::DisconnectReason);</span>
 94 
 95     // TimelineBackendDispatcherHandler
<span class="line-modified"> 96     void enable(ErrorString&amp;);</span>
<span class="line-modified"> 97     void disable(ErrorString&amp;);</span>
<span class="line-modified"> 98     void start(ErrorString&amp;, const int* maxCallStackDepth = nullptr);</span>
<span class="line-modified"> 99     void stop(ErrorString&amp;);</span>
<span class="line-modified">100     void setAutoCaptureEnabled(ErrorString&amp;, bool);</span>
<span class="line-modified">101     void setInstruments(ErrorString&amp;, const JSON::Array&amp;);</span>
102 
103     // ScriptDebugListener
<span class="line-modified">104     void didParseSource(JSC::SourceID, const Script&amp;) { }</span>
<span class="line-modified">105     void failedToParseSource(const String&amp;, const String&amp;, int, int, const String&amp;) { }</span>
<span class="line-modified">106     void willRunMicrotask() { }</span>
<span class="line-modified">107     void didRunMicrotask() { }</span>
<span class="line-modified">108     void didPause(JSC::ExecState&amp;, JSC::JSValue, JSC::JSValue) { }</span>
<span class="line-modified">109     void didContinue() { }</span>
<span class="line-modified">110     void breakpointActionLog(JSC::ExecState&amp;, const String&amp;) { }</span>
<span class="line-modified">111     void breakpointActionSound(int) { }</span>
<span class="line-modified">112     void breakpointActionProbe(JSC::ExecState&amp;, const Inspector::ScriptBreakpointAction&amp;, unsigned batchId, unsigned sampleId, JSC::JSValue result);</span>
113 
114     // InspectorInstrumentation
115     void didInstallTimer(int timerId, Seconds timeout, bool singleShot, Frame*);
116     void didRemoveTimer(int timerId, Frame*);
117     void willFireTimer(int timerId, Frame*);
118     void didFireTimer();
119     void willCallFunction(const String&amp; scriptName, int scriptLine, int scriptColumn, Frame*);
120     void didCallFunction(Frame*);
121     void willDispatchEvent(const Event&amp;, Frame*);
122     void didDispatchEvent(bool defaultPrevented);
123     void willEvaluateScript(const String&amp;, int lineNumber, int columnNumber, Frame&amp;);
124     void didEvaluateScript(Frame&amp;);
125     void didInvalidateLayout(Frame&amp;);
126     void willLayout(Frame&amp;);
127     void didLayout(RenderObject&amp;);
128     void willComposite(Frame&amp;);
129     void didComposite();
130     void willPaint(Frame&amp;);
131     void didPaint(RenderObject&amp;, const LayoutRect&amp;);
132     void willRecalculateStyle(Frame*);
133     void didRecalculateStyle();
134     void didScheduleStyleRecalculation(Frame*);
135     void didTimeStamp(Frame&amp;, const String&amp;);
136     void didRequestAnimationFrame(int callbackId, Frame*);
137     void didCancelAnimationFrame(int callbackId, Frame*);
138     void willFireAnimationFrame(int callbackId, Frame*);
139     void didFireAnimationFrame();
140     void willFireObserverCallback(const String&amp; callbackType, Frame*);
141     void didFireObserverCallback();
142     void time(Frame&amp;, const String&amp;);
143     void timeEnd(Frame&amp;, const String&amp;);
144     void mainFrameStartedLoading();
145     void mainFrameNavigated();
146 
147     // Console
<span class="line-modified">148     void startFromConsole(JSC::ExecState*, const String&amp; title);</span>
<span class="line-modified">149     void stopFromConsole(JSC::ExecState*, const String&amp; title);</span>
<span class="line-removed">150 </span>
<span class="line-removed">151     int id() const { return m_id; }</span>
152 
153 private:
154     void startProgrammaticCapture();
155     void stopProgrammaticCapture();
156 
157     enum class InstrumentState { Start, Stop };
158     void toggleInstruments(InstrumentState);
159     void toggleScriptProfilerInstrument(InstrumentState);
160     void toggleHeapInstrument(InstrumentState);
161     void toggleCPUInstrument(InstrumentState);
162     void toggleMemoryInstrument(InstrumentState);
163     void toggleTimelineInstrument(InstrumentState);

164     void disableBreakpoints();
165     void enableBreakpoints();
166 
167     friend class TimelineRecordStack;
168 
169     struct TimelineRecordEntry {
170         TimelineRecordEntry()
171             : type(TimelineRecordType::EventDispatch) { }
172         TimelineRecordEntry(RefPtr&lt;JSON::Object&gt;&amp;&amp; record, RefPtr&lt;JSON::Object&gt;&amp;&amp; data, RefPtr&lt;JSON::Array&gt;&amp;&amp; children, TimelineRecordType type)
173             : record(WTFMove(record))
174             , data(WTFMove(data))
175             , children(WTFMove(children))
176             , type(type)
177         {
178         }
179 
180         RefPtr&lt;JSON::Object&gt; record;
181         RefPtr&lt;JSON::Object&gt; data;
182         RefPtr&lt;JSON::Array&gt; children;
183         TimelineRecordType type;
184     };
185 
186     void internalStart(const int* maxCallStackDepth = nullptr);
187     void internalStop();
188     double timestamp();
189 
190     void sendEvent(RefPtr&lt;JSON::Object&gt;&amp;&amp;);
191     void appendRecord(RefPtr&lt;JSON::Object&gt;&amp;&amp; data, TimelineRecordType, bool captureCallStack, Frame*);
192     void pushCurrentRecord(RefPtr&lt;JSON::Object&gt;&amp;&amp;, TimelineRecordType, bool captureCallStack, Frame*);
193     void pushCurrentRecord(const TimelineRecordEntry&amp; record) { m_recordStack.append(record); }
194 
195     TimelineRecordEntry createRecordEntry(RefPtr&lt;JSON::Object&gt;&amp;&amp; data, TimelineRecordType, bool captureCallStack, Frame*);
196 
197     void setFrameIdentifier(JSON::Object* record, Frame*);
198 
199     void didCompleteRecordEntry(const TimelineRecordEntry&amp;);
200     void didCompleteCurrentRecord(TimelineRecordType);
201 
202     void addRecordToTimeline(RefPtr&lt;JSON::Object&gt;&amp;&amp;, TimelineRecordType);
<span class="line-removed">203     void clearRecordStack();</span>
204 
205     void localToPageQuad(const RenderObject&amp;, const LayoutRect&amp;, FloatQuad*);
206 
207     std::unique_ptr&lt;Inspector::TimelineFrontendDispatcher&gt; m_frontendDispatcher;
208     RefPtr&lt;Inspector::TimelineBackendDispatcher&gt; m_backendDispatcher;
209     Page&amp; m_inspectedPage;
210 
211     Vector&lt;TimelineRecordEntry&gt; m_recordStack;
212     Vector&lt;TimelineRecordEntry&gt; m_pendingConsoleProfileRecords;
213 
<span class="line-removed">214     int m_id { 1 };</span>
215     int m_maxCallStackDepth { 5 };
216 
217     bool m_tracking { false };
218     bool m_trackingFromFrontend { false };
219     bool m_programmaticCaptureRestoreBreakpointActiveValue { false };
220 
221     bool m_autoCaptureEnabled { false };
222     enum class AutoCapturePhase { None, BeforeLoad, FirstNavigation, AfterFirstNavigation };
223     AutoCapturePhase m_autoCapturePhase { AutoCapturePhase::None };
224     Vector&lt;Inspector::Protocol::Timeline::Instrument&gt; m_instruments;
225 
226 #if PLATFORM(COCOA)
227     std::unique_ptr&lt;WebCore::RunLoopObserver&gt; m_frameStartObserver;
228     std::unique_ptr&lt;WebCore::RunLoopObserver&gt; m_frameStopObserver;
229 #endif
230     int m_runLoopNestingLevel { 0 };
231     bool m_startedComposite { false };
232 };
233 
234 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 69     TimeStamp,
 70     Time,
 71     TimeEnd,
 72 
 73     FunctionCall,
 74     ProbeSample,
 75     ConsoleProfile,
 76 
 77     RequestAnimationFrame,
 78     CancelAnimationFrame,
 79     FireAnimationFrame,
 80 
 81     ObserverCallback,
 82 };
 83 
 84 class InspectorTimelineAgent final : public InspectorAgentBase , public Inspector::TimelineBackendDispatcherHandler , public Inspector::ScriptDebugListener {
 85     WTF_MAKE_NONCOPYABLE(InspectorTimelineAgent);
 86     WTF_MAKE_FAST_ALLOCATED;
 87 public:
 88     InspectorTimelineAgent(PageAgentContext&amp;);
<span class="line-modified"> 89     ~InspectorTimelineAgent() override;</span>
 90 
 91     // InspectorAgentBase
<span class="line-modified"> 92     void didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*) override;</span>
<span class="line-modified"> 93     void willDestroyFrontendAndBackend(Inspector::DisconnectReason) override;</span>
 94 
 95     // TimelineBackendDispatcherHandler
<span class="line-modified"> 96     void enable(ErrorString&amp;) override;</span>
<span class="line-modified"> 97     void disable(ErrorString&amp;) override;</span>
<span class="line-modified"> 98     void start(ErrorString&amp;, const int* maxCallStackDepth = nullptr) override;</span>
<span class="line-modified"> 99     void stop(ErrorString&amp;) override;</span>
<span class="line-modified">100     void setAutoCaptureEnabled(ErrorString&amp;, bool) override;</span>
<span class="line-modified">101     void setInstruments(ErrorString&amp;, const JSON::Array&amp;) override;</span>
102 
103     // ScriptDebugListener
<span class="line-modified">104     void didParseSource(JSC::SourceID, const Script&amp;) override { }</span>
<span class="line-modified">105     void failedToParseSource(const String&amp;, const String&amp;, int, int, const String&amp;) override { }</span>
<span class="line-modified">106     void willRunMicrotask() override { }</span>
<span class="line-modified">107     void didRunMicrotask() override { }</span>
<span class="line-modified">108     void didPause(JSC::JSGlobalObject*, JSC::JSValue, JSC::JSValue) override { }</span>
<span class="line-modified">109     void didContinue() override { }</span>
<span class="line-modified">110     void breakpointActionLog(JSC::JSGlobalObject*, const String&amp;) override { }</span>
<span class="line-modified">111     void breakpointActionSound(int) override { }</span>
<span class="line-modified">112     void breakpointActionProbe(JSC::JSGlobalObject*, const Inspector::ScriptBreakpointAction&amp;, unsigned batchId, unsigned sampleId, JSC::JSValue result) override;</span>
113 
114     // InspectorInstrumentation
115     void didInstallTimer(int timerId, Seconds timeout, bool singleShot, Frame*);
116     void didRemoveTimer(int timerId, Frame*);
117     void willFireTimer(int timerId, Frame*);
118     void didFireTimer();
119     void willCallFunction(const String&amp; scriptName, int scriptLine, int scriptColumn, Frame*);
120     void didCallFunction(Frame*);
121     void willDispatchEvent(const Event&amp;, Frame*);
122     void didDispatchEvent(bool defaultPrevented);
123     void willEvaluateScript(const String&amp;, int lineNumber, int columnNumber, Frame&amp;);
124     void didEvaluateScript(Frame&amp;);
125     void didInvalidateLayout(Frame&amp;);
126     void willLayout(Frame&amp;);
127     void didLayout(RenderObject&amp;);
128     void willComposite(Frame&amp;);
129     void didComposite();
130     void willPaint(Frame&amp;);
131     void didPaint(RenderObject&amp;, const LayoutRect&amp;);
132     void willRecalculateStyle(Frame*);
133     void didRecalculateStyle();
134     void didScheduleStyleRecalculation(Frame*);
135     void didTimeStamp(Frame&amp;, const String&amp;);
136     void didRequestAnimationFrame(int callbackId, Frame*);
137     void didCancelAnimationFrame(int callbackId, Frame*);
138     void willFireAnimationFrame(int callbackId, Frame*);
139     void didFireAnimationFrame();
140     void willFireObserverCallback(const String&amp; callbackType, Frame*);
141     void didFireObserverCallback();
142     void time(Frame&amp;, const String&amp;);
143     void timeEnd(Frame&amp;, const String&amp;);
144     void mainFrameStartedLoading();
145     void mainFrameNavigated();
146 
147     // Console
<span class="line-modified">148     void startFromConsole(JSC::JSGlobalObject*, const String&amp; title);</span>
<span class="line-modified">149     void stopFromConsole(JSC::JSGlobalObject*, const String&amp; title);</span>


150 
151 private:
152     void startProgrammaticCapture();
153     void stopProgrammaticCapture();
154 
155     enum class InstrumentState { Start, Stop };
156     void toggleInstruments(InstrumentState);
157     void toggleScriptProfilerInstrument(InstrumentState);
158     void toggleHeapInstrument(InstrumentState);
159     void toggleCPUInstrument(InstrumentState);
160     void toggleMemoryInstrument(InstrumentState);
161     void toggleTimelineInstrument(InstrumentState);
<span class="line-added">162     void toggleAnimationInstrument(InstrumentState);</span>
163     void disableBreakpoints();
164     void enableBreakpoints();
165 
166     friend class TimelineRecordStack;
167 
168     struct TimelineRecordEntry {
169         TimelineRecordEntry()
170             : type(TimelineRecordType::EventDispatch) { }
171         TimelineRecordEntry(RefPtr&lt;JSON::Object&gt;&amp;&amp; record, RefPtr&lt;JSON::Object&gt;&amp;&amp; data, RefPtr&lt;JSON::Array&gt;&amp;&amp; children, TimelineRecordType type)
172             : record(WTFMove(record))
173             , data(WTFMove(data))
174             , children(WTFMove(children))
175             , type(type)
176         {
177         }
178 
179         RefPtr&lt;JSON::Object&gt; record;
180         RefPtr&lt;JSON::Object&gt; data;
181         RefPtr&lt;JSON::Array&gt; children;
182         TimelineRecordType type;
183     };
184 
185     void internalStart(const int* maxCallStackDepth = nullptr);
186     void internalStop();
187     double timestamp();
188 
189     void sendEvent(RefPtr&lt;JSON::Object&gt;&amp;&amp;);
190     void appendRecord(RefPtr&lt;JSON::Object&gt;&amp;&amp; data, TimelineRecordType, bool captureCallStack, Frame*);
191     void pushCurrentRecord(RefPtr&lt;JSON::Object&gt;&amp;&amp;, TimelineRecordType, bool captureCallStack, Frame*);
192     void pushCurrentRecord(const TimelineRecordEntry&amp; record) { m_recordStack.append(record); }
193 
194     TimelineRecordEntry createRecordEntry(RefPtr&lt;JSON::Object&gt;&amp;&amp; data, TimelineRecordType, bool captureCallStack, Frame*);
195 
196     void setFrameIdentifier(JSON::Object* record, Frame*);
197 
198     void didCompleteRecordEntry(const TimelineRecordEntry&amp;);
199     void didCompleteCurrentRecord(TimelineRecordType);
200 
201     void addRecordToTimeline(RefPtr&lt;JSON::Object&gt;&amp;&amp;, TimelineRecordType);

202 
203     void localToPageQuad(const RenderObject&amp;, const LayoutRect&amp;, FloatQuad*);
204 
205     std::unique_ptr&lt;Inspector::TimelineFrontendDispatcher&gt; m_frontendDispatcher;
206     RefPtr&lt;Inspector::TimelineBackendDispatcher&gt; m_backendDispatcher;
207     Page&amp; m_inspectedPage;
208 
209     Vector&lt;TimelineRecordEntry&gt; m_recordStack;
210     Vector&lt;TimelineRecordEntry&gt; m_pendingConsoleProfileRecords;
211 

212     int m_maxCallStackDepth { 5 };
213 
214     bool m_tracking { false };
215     bool m_trackingFromFrontend { false };
216     bool m_programmaticCaptureRestoreBreakpointActiveValue { false };
217 
218     bool m_autoCaptureEnabled { false };
219     enum class AutoCapturePhase { None, BeforeLoad, FirstNavigation, AfterFirstNavigation };
220     AutoCapturePhase m_autoCapturePhase { AutoCapturePhase::None };
221     Vector&lt;Inspector::Protocol::Timeline::Instrument&gt; m_instruments;
222 
223 #if PLATFORM(COCOA)
224     std::unique_ptr&lt;WebCore::RunLoopObserver&gt; m_frameStartObserver;
225     std::unique_ptr&lt;WebCore::RunLoopObserver&gt; m_frameStopObserver;
226 #endif
227     int m_runLoopNestingLevel { 0 };
228     bool m_startedComposite { false };
229 };
230 
231 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InspectorTimelineAgent.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorWorkerAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
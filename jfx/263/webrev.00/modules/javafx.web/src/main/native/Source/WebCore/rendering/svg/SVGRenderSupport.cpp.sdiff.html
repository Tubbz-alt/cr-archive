<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGPathData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGRenderTreeAsText.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderSupport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SVGRenderSupport.h&quot;
 28 
 29 #include &quot;NodeRenderStyle.h&quot;
 30 #include &quot;RenderChildIterator.h&quot;
 31 #include &quot;RenderElement.h&quot;
 32 #include &quot;RenderGeometryMap.h&quot;
 33 #include &quot;RenderIterator.h&quot;
 34 #include &quot;RenderLayer.h&quot;
 35 #include &quot;RenderSVGImage.h&quot;
 36 #include &quot;RenderSVGResourceClipper.h&quot;
 37 #include &quot;RenderSVGResourceFilter.h&quot;
 38 #include &quot;RenderSVGResourceMarker.h&quot;
 39 #include &quot;RenderSVGResourceMasker.h&quot;
 40 #include &quot;RenderSVGRoot.h&quot;
 41 #include &quot;RenderSVGText.h&quot;
 42 #include &quot;RenderSVGTransformableContainer.h&quot;
 43 #include &quot;RenderSVGViewportContainer.h&quot;

 44 #include &quot;SVGResources.h&quot;
 45 #include &quot;SVGResourcesCache.h&quot;
 46 #include &quot;TransformState.h&quot;
 47 
 48 namespace WebCore {
 49 
 50 LayoutRect SVGRenderSupport::clippedOverflowRectForRepaint(const RenderElement&amp; renderer, const RenderLayerModelObject* repaintContainer)
 51 {
 52     // Return early for any cases where we don&#39;t actually paint
 53     if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !renderer.enclosingLayer()-&gt;hasVisibleContent())
 54         return LayoutRect();
 55 
 56     // Pass our local paint rect to computeFloatVisibleRectInContainer() which will
 57     // map to parent coords and recurse up the parent chain.
 58     FloatRect repaintRect = renderer.repaintRectInLocalCoordinates();
 59     const SVGRenderStyle&amp; svgStyle = renderer.style().svgStyle();
 60     if (const ShadowData* shadow = svgStyle.shadow())
 61         shadow-&gt;adjustRectForShadow(repaintRect);
 62     return enclosingLayoutRect(renderer.computeFloatRectForRepaint(repaintRect, repaintContainer));
 63 }
 64 
 65 Optional&lt;FloatRect&gt; SVGRenderSupport::computeFloatVisibleRectInContainer(const RenderElement&amp; renderer, const FloatRect&amp; rect, const RenderLayerModelObject* container, RenderObject::VisibleRectContext context)
 66 {






 67     FloatRect adjustedRect = rect;
 68     const SVGRenderStyle&amp; svgStyle = renderer.style().svgStyle();
 69     if (const ShadowData* shadow = svgStyle.shadow())
 70         shadow-&gt;adjustRectForShadow(adjustedRect);
 71     adjustedRect.inflate(renderer.style().outlineWidth());
 72 
 73     // Translate to coords in our parent renderer, and then call computeFloatVisibleRectInContainer() on our parent.
 74     adjustedRect = renderer.localToParentTransform().mapRect(adjustedRect);
<span class="line-modified"> 75     return renderer.parent()-&gt;computeFloatVisibleRectInContainer(adjustedRect, container, context);</span>

 76 }
 77 
 78 const RenderElement&amp; SVGRenderSupport::localToParentTransform(const RenderElement&amp; renderer, AffineTransform &amp;transform)
 79 {
 80     ASSERT(renderer.parent());
 81     auto&amp; parent = *renderer.parent();
 82 
 83     // At the SVG/HTML boundary (aka RenderSVGRoot), we apply the localToBorderBoxTransform
 84     // to map an element from SVG viewport coordinates to CSS box coordinates.
 85     if (is&lt;RenderSVGRoot&gt;(parent))
 86         transform = downcast&lt;RenderSVGRoot&gt;(parent).localToBorderBoxTransform() * renderer.localToParentTransform();
 87     else
 88         transform = renderer.localToParentTransform();
 89 
 90     return parent;
 91 }
 92 
 93 void SVGRenderSupport::mapLocalToContainer(const RenderElement&amp; renderer, const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, bool* wasFixed)
 94 {
 95     AffineTransform transform;
</pre>
<hr />
<pre>
399 {
400     ClipPathOperation* clipPathOperation = renderer.style().clipPath();
401     if (is&lt;ShapeClipPathOperation&gt;(clipPathOperation) || is&lt;BoxClipPathOperation&gt;(clipPathOperation))
402         return isPointInCSSClippingArea(renderer, point);
403 
404     // We just take clippers into account to determine if a point is on the node. The Specification may
405     // change later and we also need to check maskers.
406     auto* resources = SVGResourcesCache::cachedResourcesForRenderer(renderer);
407     if (!resources)
408         return true;
409 
410     if (RenderSVGResourceClipper* clipper = resources-&gt;clipper())
411         return clipper-&gt;hitTestClipContent(renderer.objectBoundingBox(), point);
412 
413     return true;
414 }
415 
416 void SVGRenderSupport::applyStrokeStyleToContext(GraphicsContext* context, const RenderStyle&amp; style, const RenderElement&amp; renderer)
417 {
418     ASSERT(context);
<span class="line-modified">419     ASSERT(renderer.element());</span>
<span class="line-modified">420     ASSERT(renderer.element()-&gt;isSVGElement());</span>




421 
422     const SVGRenderStyle&amp; svgStyle = style.svgStyle();
423 
424     SVGLengthContext lengthContext(downcast&lt;SVGElement&gt;(renderer.element()));
425     context-&gt;setStrokeThickness(lengthContext.valueForLength(style.strokeWidth()));
426     context-&gt;setLineCap(style.capStyle());
427     context-&gt;setLineJoin(style.joinStyle());
428     if (style.joinStyle() == MiterJoin)
429         context-&gt;setMiterLimit(style.strokeMiterLimit());
430 
431     const Vector&lt;SVGLengthValue&gt;&amp; dashes = svgStyle.strokeDashArray();
432     if (dashes.isEmpty())
433         context-&gt;setStrokeStyle(SolidStroke);
434     else {
435         DashArray dashArray;
436         dashArray.reserveInitialCapacity(dashes.size());
437         bool canSetLineDash = false;








438 
439         for (auto&amp; dash : dashes) {
<span class="line-modified">440             dashArray.uncheckedAppend(dash.value(lengthContext));</span>
441             if (dashArray.last() &gt; 0)
442                 canSetLineDash = true;
443         }
444 
445         if (canSetLineDash)
<span class="line-modified">446             context-&gt;setLineDash(dashArray, lengthContext.valueForLength(svgStyle.strokeDashOffset()));</span>
447         else
448             context-&gt;setStrokeStyle(SolidStroke);
449     }
450 }
451 
452 void SVGRenderSupport::styleChanged(RenderElement&amp; renderer, const RenderStyle* oldStyle)
453 {
454 #if ENABLE(CSS_COMPOSITING)
455     if (renderer.element() &amp;&amp; renderer.element()-&gt;isSVGElement() &amp;&amp; (!oldStyle || renderer.style().hasBlendMode() != oldStyle-&gt;hasBlendMode()))
456         SVGRenderSupport::updateMaskedAncestorShouldIsolateBlending(renderer);
457 #else
458     UNUSED_PARAM(renderer);
459     UNUSED_PARAM(oldStyle);
460 #endif
461 }
462 
463 #if ENABLE(CSS_COMPOSITING)
464 bool SVGRenderSupport::isolatesBlending(const RenderStyle&amp; style)
465 {
466     return style.svgStyle().isolatesBlending() || style.hasFilter() || style.hasBlendMode() || style.opacity() &lt; 1.0f;
</pre>
</td>
<td>
<hr />
<pre>
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SVGRenderSupport.h&quot;
 28 
 29 #include &quot;NodeRenderStyle.h&quot;
 30 #include &quot;RenderChildIterator.h&quot;
 31 #include &quot;RenderElement.h&quot;
 32 #include &quot;RenderGeometryMap.h&quot;
 33 #include &quot;RenderIterator.h&quot;
 34 #include &quot;RenderLayer.h&quot;
 35 #include &quot;RenderSVGImage.h&quot;
 36 #include &quot;RenderSVGResourceClipper.h&quot;
 37 #include &quot;RenderSVGResourceFilter.h&quot;
 38 #include &quot;RenderSVGResourceMarker.h&quot;
 39 #include &quot;RenderSVGResourceMasker.h&quot;
 40 #include &quot;RenderSVGRoot.h&quot;
 41 #include &quot;RenderSVGText.h&quot;
 42 #include &quot;RenderSVGTransformableContainer.h&quot;
 43 #include &quot;RenderSVGViewportContainer.h&quot;
<span class="line-added"> 44 #include &quot;SVGGeometryElement.h&quot;</span>
 45 #include &quot;SVGResources.h&quot;
 46 #include &quot;SVGResourcesCache.h&quot;
 47 #include &quot;TransformState.h&quot;
 48 
 49 namespace WebCore {
 50 
 51 LayoutRect SVGRenderSupport::clippedOverflowRectForRepaint(const RenderElement&amp; renderer, const RenderLayerModelObject* repaintContainer)
 52 {
 53     // Return early for any cases where we don&#39;t actually paint
 54     if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !renderer.enclosingLayer()-&gt;hasVisibleContent())
 55         return LayoutRect();
 56 
 57     // Pass our local paint rect to computeFloatVisibleRectInContainer() which will
 58     // map to parent coords and recurse up the parent chain.
 59     FloatRect repaintRect = renderer.repaintRectInLocalCoordinates();
 60     const SVGRenderStyle&amp; svgStyle = renderer.style().svgStyle();
 61     if (const ShadowData* shadow = svgStyle.shadow())
 62         shadow-&gt;adjustRectForShadow(repaintRect);
 63     return enclosingLayoutRect(renderer.computeFloatRectForRepaint(repaintRect, repaintContainer));
 64 }
 65 
 66 Optional&lt;FloatRect&gt; SVGRenderSupport::computeFloatVisibleRectInContainer(const RenderElement&amp; renderer, const FloatRect&amp; rect, const RenderLayerModelObject* container, RenderObject::VisibleRectContext context)
 67 {
<span class="line-added"> 68     // Ensure our parent is an SVG object.</span>
<span class="line-added"> 69     ASSERT(renderer.parent());</span>
<span class="line-added"> 70     auto&amp; parent = *renderer.parent();</span>
<span class="line-added"> 71     if (!is&lt;SVGElement&gt;(parent.element()))</span>
<span class="line-added"> 72         return FloatRect();</span>
<span class="line-added"> 73 </span>
 74     FloatRect adjustedRect = rect;
 75     const SVGRenderStyle&amp; svgStyle = renderer.style().svgStyle();
 76     if (const ShadowData* shadow = svgStyle.shadow())
 77         shadow-&gt;adjustRectForShadow(adjustedRect);
 78     adjustedRect.inflate(renderer.style().outlineWidth());
 79 
 80     // Translate to coords in our parent renderer, and then call computeFloatVisibleRectInContainer() on our parent.
 81     adjustedRect = renderer.localToParentTransform().mapRect(adjustedRect);
<span class="line-modified"> 82 </span>
<span class="line-added"> 83     return parent.computeFloatVisibleRectInContainer(adjustedRect, container, context);</span>
 84 }
 85 
 86 const RenderElement&amp; SVGRenderSupport::localToParentTransform(const RenderElement&amp; renderer, AffineTransform &amp;transform)
 87 {
 88     ASSERT(renderer.parent());
 89     auto&amp; parent = *renderer.parent();
 90 
 91     // At the SVG/HTML boundary (aka RenderSVGRoot), we apply the localToBorderBoxTransform
 92     // to map an element from SVG viewport coordinates to CSS box coordinates.
 93     if (is&lt;RenderSVGRoot&gt;(parent))
 94         transform = downcast&lt;RenderSVGRoot&gt;(parent).localToBorderBoxTransform() * renderer.localToParentTransform();
 95     else
 96         transform = renderer.localToParentTransform();
 97 
 98     return parent;
 99 }
100 
101 void SVGRenderSupport::mapLocalToContainer(const RenderElement&amp; renderer, const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, bool* wasFixed)
102 {
103     AffineTransform transform;
</pre>
<hr />
<pre>
407 {
408     ClipPathOperation* clipPathOperation = renderer.style().clipPath();
409     if (is&lt;ShapeClipPathOperation&gt;(clipPathOperation) || is&lt;BoxClipPathOperation&gt;(clipPathOperation))
410         return isPointInCSSClippingArea(renderer, point);
411 
412     // We just take clippers into account to determine if a point is on the node. The Specification may
413     // change later and we also need to check maskers.
414     auto* resources = SVGResourcesCache::cachedResourcesForRenderer(renderer);
415     if (!resources)
416         return true;
417 
418     if (RenderSVGResourceClipper* clipper = resources-&gt;clipper())
419         return clipper-&gt;hitTestClipContent(renderer.objectBoundingBox(), point);
420 
421     return true;
422 }
423 
424 void SVGRenderSupport::applyStrokeStyleToContext(GraphicsContext* context, const RenderStyle&amp; style, const RenderElement&amp; renderer)
425 {
426     ASSERT(context);
<span class="line-modified">427 </span>
<span class="line-modified">428     Element* element = renderer.element();</span>
<span class="line-added">429     if (!is&lt;SVGElement&gt;(element)) {</span>
<span class="line-added">430         ASSERT_NOT_REACHED();</span>
<span class="line-added">431         return;</span>
<span class="line-added">432     }</span>
433 
434     const SVGRenderStyle&amp; svgStyle = style.svgStyle();
435 
436     SVGLengthContext lengthContext(downcast&lt;SVGElement&gt;(renderer.element()));
437     context-&gt;setStrokeThickness(lengthContext.valueForLength(style.strokeWidth()));
438     context-&gt;setLineCap(style.capStyle());
439     context-&gt;setLineJoin(style.joinStyle());
440     if (style.joinStyle() == MiterJoin)
441         context-&gt;setMiterLimit(style.strokeMiterLimit());
442 
443     const Vector&lt;SVGLengthValue&gt;&amp; dashes = svgStyle.strokeDashArray();
444     if (dashes.isEmpty())
445         context-&gt;setStrokeStyle(SolidStroke);
446     else {
447         DashArray dashArray;
448         dashArray.reserveInitialCapacity(dashes.size());
449         bool canSetLineDash = false;
<span class="line-added">450         float scaleFactor = 1;</span>
<span class="line-added">451 </span>
<span class="line-added">452         if (is&lt;SVGGeometryElement&gt;(element)) {</span>
<span class="line-added">453             ASSERT(renderer.isSVGShape());</span>
<span class="line-added">454             // FIXME: A value of zero is valid. Need to differentiate this case from being unspecified.</span>
<span class="line-added">455             if (float pathLength = downcast&lt;SVGGeometryElement&gt;(element)-&gt;pathLength())</span>
<span class="line-added">456                 scaleFactor = downcast&lt;RenderSVGShape&gt;(renderer).getTotalLength() / pathLength;</span>
<span class="line-added">457         }</span>
458 
459         for (auto&amp; dash : dashes) {
<span class="line-modified">460             dashArray.uncheckedAppend(dash.value(lengthContext) * scaleFactor);</span>
461             if (dashArray.last() &gt; 0)
462                 canSetLineDash = true;
463         }
464 
465         if (canSetLineDash)
<span class="line-modified">466             context-&gt;setLineDash(dashArray, lengthContext.valueForLength(svgStyle.strokeDashOffset()) * scaleFactor);</span>
467         else
468             context-&gt;setStrokeStyle(SolidStroke);
469     }
470 }
471 
472 void SVGRenderSupport::styleChanged(RenderElement&amp; renderer, const RenderStyle* oldStyle)
473 {
474 #if ENABLE(CSS_COMPOSITING)
475     if (renderer.element() &amp;&amp; renderer.element()-&gt;isSVGElement() &amp;&amp; (!oldStyle || renderer.style().hasBlendMode() != oldStyle-&gt;hasBlendMode()))
476         SVGRenderSupport::updateMaskedAncestorShouldIsolateBlending(renderer);
477 #else
478     UNUSED_PARAM(renderer);
479     UNUSED_PARAM(oldStyle);
480 #endif
481 }
482 
483 #if ENABLE(CSS_COMPOSITING)
484 bool SVGRenderSupport::isolatesBlending(const RenderStyle&amp; style)
485 {
486     return style.svgStyle().isolatesBlending() || style.hasFilter() || style.hasBlendMode() || style.opacity() &lt; 1.0f;
</pre>
</td>
</tr>
</table>
<center><a href="SVGPathData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGRenderTreeAsText.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContextGeometry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FormattingContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FormattingContextQuirks.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContextGeometry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,14 ***</span>
  #include &quot;FormattingContext.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
  #include &quot;FloatingState.h&quot;
<span class="line-removed">- #include &quot;FormattingState.h&quot;</span>
  #include &quot;InlineFormattingState.h&quot;
  #include &quot;TableFormattingState.h&quot;
<span class="line-removed">- #include &quot;TableGrid.h&quot;</span>
  
  namespace WebCore {
  namespace Layout {
  
  static inline bool isHeightAuto(const Box&amp; layoutBox)
<span class="line-new-header">--- 27,14 ---</span>
  #include &quot;FormattingContext.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
  #include &quot;FloatingState.h&quot;
  #include &quot;InlineFormattingState.h&quot;
<span class="line-added">+ #include &quot;LayoutContext.h&quot;</span>
<span class="line-added">+ #include &quot;Logging.h&quot;</span>
  #include &quot;TableFormattingState.h&quot;
  
  namespace WebCore {
  namespace Layout {
  
  static inline bool isHeightAuto(const Box&amp; layoutBox)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,41 ***</span>
      }
  
      return false;
  }
  
<span class="line-modified">! Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedHeightValue(const LayoutState&amp; layoutState, const Box&amp; layoutBox, HeightType heightType)</span>
  {
      auto&amp; style = layoutBox.style();
      auto height = heightType == HeightType::Normal ? style.logicalHeight() : heightType == HeightType::Min ? style.logicalMinHeight() : style.logicalMaxHeight();
      if (height.isUndefined() || height.isAuto())
          return { };
  
      if (height.isFixed())
<span class="line-modified">!         return LayoutUnit(height.value());</span>
  
<span class="line-modified">!     Optional&lt;LayoutUnit&gt; containingBlockHeightValue;</span>
<span class="line-removed">-     if (layoutBox.isOutOfFlowPositioned()) {</span>
          // Containing block&#39;s height is already computed since we layout the out-of-flow boxes as the last step.
<span class="line-modified">!         containingBlockHeightValue = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).height();</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         if (layoutState.inQuirksMode())</span>
<span class="line-removed">-             containingBlockHeightValue = FormattingContext::Quirks::heightValueOfNearestContainingBlockWithFixedHeight(layoutState, layoutBox);</span>
          else {
<span class="line-modified">!             auto containingBlockHeight = layoutBox.containingBlock()-&gt;style().logicalHeight();</span>
<span class="line-modified">!             if (containingBlockHeight.isFixed())</span>
<span class="line-modified">!                 containingBlockHeightValue = LayoutUnit(containingBlockHeight.value());</span>
          }
      }
  
<span class="line-modified">!     if (!containingBlockHeightValue)</span>
          return { };
  
<span class="line-modified">!     return valueForLength(height, *containingBlockHeightValue);</span>
  }
  
<span class="line-modified">! LayoutUnit FormattingContext::Geometry::contentHeightForFormattingContextRoot(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  {
      ASSERT(isHeightAuto(layoutBox) &amp;&amp; (layoutBox.establishesFormattingContext() || layoutBox.isDocumentBox()));
  
      // 10.6.7 &#39;Auto&#39; heights for block formatting context roots
  
<span class="line-new-header">--- 57,61 ---</span>
      }
  
      return false;
  }
  
<span class="line-modified">! Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedHeightValue(const Box&amp; layoutBox, HeightType heightType, Optional&lt;LayoutUnit&gt; containingBlockHeight) const</span>
  {
      auto&amp; style = layoutBox.style();
      auto height = heightType == HeightType::Normal ? style.logicalHeight() : heightType == HeightType::Min ? style.logicalMinHeight() : style.logicalMaxHeight();
      if (height.isUndefined() || height.isAuto())
          return { };
  
      if (height.isFixed())
<span class="line-modified">!         return LayoutUnit { height.value() };</span>
  
<span class="line-modified">!     if (!containingBlockHeight) {</span>
          // Containing block&#39;s height is already computed since we layout the out-of-flow boxes as the last step.
<span class="line-modified">!         ASSERT(!layoutBox.isOutOfFlowPositioned());</span>
<span class="line-modified">!         if (layoutState().inQuirksMode())</span>
<span class="line-modified">!             containingBlockHeight = formattingContext().quirks().heightValueOfNearestContainingBlockWithFixedHeight(layoutBox);</span>
          else {
<span class="line-modified">!             auto containingBlockHeightFromStyle = layoutBox.containingBlock()-&gt;style().logicalHeight();</span>
<span class="line-modified">!             if (containingBlockHeightFromStyle.isFixed())</span>
<span class="line-modified">!                 containingBlockHeight = LayoutUnit { containingBlockHeightFromStyle.value() };</span>
          }
      }
  
<span class="line-modified">!     if (!containingBlockHeight)</span>
          return { };
  
<span class="line-modified">!     return valueForLength(height, *containingBlockHeight);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedContentHeight(const Box&amp; layoutBox, Optional&lt;LayoutUnit&gt; containingBlockHeight) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto height = computedHeightValue(layoutBox, HeightType::Normal, containingBlockHeight)) {</span>
<span class="line-added">+         if (layoutBox.style().boxSizing() == BoxSizing::ContentBox)</span>
<span class="line-added">+             return height;</span>
<span class="line-added">+         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);</span>
<span class="line-added">+         return *height - (boxGeometry.verticalBorder() + boxGeometry.verticalPadding().valueOr(0));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return { };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedContentWidth(const Box&amp; layoutBox, LayoutUnit containingBlockWidth) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto width = computedValueIfNotAuto(layoutBox.style().logicalWidth(), containingBlockWidth)) {</span>
<span class="line-added">+         if (layoutBox.style().boxSizing() == BoxSizing::ContentBox)</span>
<span class="line-added">+             return width;</span>
<span class="line-added">+         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);</span>
<span class="line-added">+         return *width - (boxGeometry.horizontalBorder() + boxGeometry.horizontalPadding().valueOr(0));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return { };</span>
  }
  
<span class="line-modified">! LayoutUnit FormattingContext::Geometry::contentHeightForFormattingContextRoot(const Box&amp; layoutBox) const</span>
  {
      ASSERT(isHeightAuto(layoutBox) &amp;&amp; (layoutBox.establishesFormattingContext() || layoutBox.isDocumentBox()));
  
      // 10.6.7 &#39;Auto&#39; heights for block formatting context roots
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,38 ***</span>
      // then the height is increased to include those edges. Only floats that participate in this block formatting context are taken
      // into account, e.g., floats inside absolutely positioned descendants or other floats are not.
      if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
          return { };
  
<span class="line-modified">!     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">!     auto borderAndPaddingTop = displayBox.borderTop() + displayBox.paddingTop().valueOr(0);</span>
      auto top = borderAndPaddingTop;
      auto bottom = borderAndPaddingTop;
      auto&amp; formattingRootContainer = downcast&lt;Container&gt;(layoutBox);
      if (formattingRootContainer.establishesInlineFormattingContext()) {
<span class="line-modified">!         auto&amp; lineBoxes = downcast&lt;InlineFormattingState&gt;(layoutState.establishedFormattingState(layoutBox)).lineBoxes();</span>
          // Even empty containers generate one line.
          ASSERT(!lineBoxes.isEmpty());
<span class="line-modified">!         top = lineBoxes.first().logicalTop();</span>
<span class="line-modified">!         bottom = lineBoxes.last().logicalBottom();</span>
<span class="line-modified">!     } else if (formattingRootContainer.establishesBlockFormattingContext() || layoutBox.isDocumentBox()) {</span>
          if (formattingRootContainer.hasInFlowChild()) {
<span class="line-modified">!             auto&amp; firstDisplayBox = layoutState.displayBoxForLayoutBox(*formattingRootContainer.firstInFlowChild());</span>
<span class="line-modified">!             auto&amp; lastDisplayBox = layoutState.displayBoxForLayoutBox(*formattingRootContainer.lastInFlowChild());</span>
<span class="line-modified">!             top = firstDisplayBox.rectWithMargin().top();</span>
<span class="line-modified">!             bottom = lastDisplayBox.rectWithMargin().bottom();</span>
          }
<span class="line-removed">-     } else if (formattingRootContainer.establishesTableFormattingContext()) {</span>
<span class="line-removed">-         auto&amp; rowList = downcast&lt;TableFormattingState&gt;(layoutState.establishedFormattingState(formattingRootContainer)).tableGrid().rows();</span>
<span class="line-removed">-         ASSERT(!rowList.isEmpty());</span>
<span class="line-removed">-         top += rowList.first().logicalTop();</span>
<span class="line-removed">-         auto&amp; lastRow = rowList.last();</span>
<span class="line-removed">-         bottom += lastRow.logicalBottom();</span>
      } else
          ASSERT_NOT_REACHED();
  
<span class="line-modified">!     auto* formattingContextRoot = &amp;layoutBox;</span>
      // TODO: The document renderer is not a formatting context root by default at all. Need to find out what it is.
      if (!layoutBox.establishesFormattingContext()) {
          ASSERT(layoutBox.isDocumentBox());
          formattingContextRoot = &amp;layoutBox.formattingContextRoot();
      }
<span class="line-new-header">--- 123,34 ---</span>
      // then the height is increased to include those edges. Only floats that participate in this block formatting context are taken
      // into account, e.g., floats inside absolutely positioned descendants or other floats are not.
      if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
          return { };
  
<span class="line-modified">!     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified">!     auto&amp; formattingContext = this-&gt;formattingContext();</span>
<span class="line-added">+     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-added">+     auto borderAndPaddingTop = boxGeometry.borderTop() + boxGeometry.paddingTop().valueOr(0);</span>
      auto top = borderAndPaddingTop;
      auto bottom = borderAndPaddingTop;
      auto&amp; formattingRootContainer = downcast&lt;Container&gt;(layoutBox);
      if (formattingRootContainer.establishesInlineFormattingContext()) {
<span class="line-modified">!         auto&amp; lineBoxes = layoutState.establishedInlineFormattingState(formattingRootContainer).displayInlineContent()-&gt;lineBoxes;</span>
          // Even empty containers generate one line.
          ASSERT(!lineBoxes.isEmpty());
<span class="line-modified">!         top = lineBoxes.first().top();</span>
<span class="line-modified">!         bottom = lineBoxes.last().bottom();</span>
<span class="line-modified">!     } else if (formattingRootContainer.establishesBlockFormattingContext() || formattingRootContainer.establishesTableFormattingContext() || formattingRootContainer.isDocumentBox()) {</span>
          if (formattingRootContainer.hasInFlowChild()) {
<span class="line-modified">!             auto&amp; firstBoxGeometry = formattingContext.geometryForBox(*formattingRootContainer.firstInFlowChild(), EscapeReason::NeedsGeometryFromEstablishedFormattingContext);</span>
<span class="line-modified">!             auto&amp; lastBoxGeometry = formattingContext.geometryForBox(*formattingRootContainer.lastInFlowChild(), EscapeReason::NeedsGeometryFromEstablishedFormattingContext);</span>
<span class="line-modified">!             top = firstBoxGeometry.rectWithMargin().top();</span>
<span class="line-modified">!             bottom = lastBoxGeometry.rectWithMargin().bottom();</span>
          }
      } else
          ASSERT_NOT_REACHED();
  
<span class="line-modified">!     auto* formattingContextRoot = &amp;formattingRootContainer;</span>
      // TODO: The document renderer is not a formatting context root by default at all. Need to find out what it is.
      if (!layoutBox.establishesFormattingContext()) {
          ASSERT(layoutBox.isDocumentBox());
          formattingContextRoot = &amp;layoutBox.formattingContextRoot();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,127 ***</span>
      auto computedHeight = bottom - top;
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height] -&gt; content height for formatting context root -&gt; height(&quot; &lt;&lt; computedHeight &lt;&lt; &quot;px) layoutBox(&quot;&lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
      return computedHeight;
  }
  
<span class="line-modified">! Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedValueIfNotAuto(const Length&amp; geometryProperty, LayoutUnit containingBlockWidth)</span>
  {
      if (geometryProperty.isUndefined())
          return WTF::nullopt;
  
      if (geometryProperty.isAuto())
          return WTF::nullopt;
  
      return valueForLength(geometryProperty, containingBlockWidth);
  }
  
<span class="line-modified">! Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::fixedValue(const Length&amp; geometryProperty)</span>
  {
      if (!geometryProperty.isFixed())
          return WTF::nullopt;
      return LayoutUnit(geometryProperty.value());
  }
  
  // https://www.w3.org/TR/CSS22/visudet.html#min-max-heights
  // Specifies a percentage for determining the used value. The percentage is calculated with respect to the height of the generated box&#39;s containing block.
  // If the height of the containing block is not specified explicitly (i.e., it depends on content height), and this element is not absolutely positioned,
  // the percentage value is treated as &#39;0&#39; (for &#39;min-height&#39;) or &#39;none&#39; (for &#39;max-height&#39;).
<span class="line-modified">! Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMaxHeight(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  {
<span class="line-modified">!     return computedHeightValue(layoutState, layoutBox, HeightType::Max);</span>
  }
  
<span class="line-modified">! Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMinHeight(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  {
<span class="line-modified">!     if (auto minHeightValue = computedHeightValue(layoutState, layoutBox, HeightType::Min))</span>
          return minHeightValue;
  
<span class="line-modified">!     return { 0 };</span>
  }
  
<span class="line-modified">! static LayoutUnit staticVerticalPositionForOutOfFlowPositioned(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned());
  
      // For the purposes of this section and the next, the term &quot;static position&quot; (of an element) refers, roughly, to the position an element would have
      // had in the normal flow. More precisely, the static position for &#39;top&#39; is the distance from the top edge of the containing block to the top margin
      // edge of a hypothetical box that would have been the first box of the element if its specified &#39;position&#39; value had been &#39;static&#39; and its specified
      // &#39;float&#39; had been &#39;none&#39; and its specified &#39;clear&#39; had been &#39;none&#39;. (Note that due to the rules in section 9.7 this might require also assuming a different
      // computed value for &#39;display&#39;.) The value is negative if the hypothetical box is above the containing block.
  
      // Start with this box&#39;s border box offset from the parent&#39;s border box.
      LayoutUnit top;
      if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
          // Add sibling offset
<span class="line-modified">!         auto&amp; previousInFlowDisplayBox = layoutState.displayBoxForLayoutBox(*previousInFlowSibling);</span>
<span class="line-modified">!         top += previousInFlowDisplayBox.bottom() + previousInFlowDisplayBox.nonCollapsedMarginAfter();</span>
      } else {
          ASSERT(layoutBox.parent());
<span class="line-modified">!         top = layoutState.displayBoxForLayoutBox(*layoutBox.parent()).contentBoxTop();</span>
      }
  
      // Resolve top all the way up to the containing block.
      auto&amp; containingBlock = *layoutBox.containingBlock();
      // Start with the parent since we pretend that this box is normal flow.
      for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {
<span class="line-modified">!         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*container);</span>
          // Display::Box::top is the border box top position in its containing block&#39;s coordinate system.
<span class="line-modified">!         top += displayBox.top();</span>
          ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
      }
      // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.
<span class="line-modified">!     auto paddingBoxTop = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxTop();</span>
<span class="line-removed">-     return top - paddingBoxTop;</span>
  }
  
<span class="line-modified">! static LayoutUnit staticHorizontalPositionForOutOfFlowPositioned(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned());
      // See staticVerticalPositionForOutOfFlowPositioned for the definition of the static position.
  
      // Start with this box&#39;s border box offset from the parent&#39;s border box.
      ASSERT(layoutBox.parent());
<span class="line-modified">!     auto left = layoutState.displayBoxForLayoutBox(*layoutBox.parent()).contentBoxLeft();</span>
  
      // Resolve left all the way up to the containing block.
      auto&amp; containingBlock = *layoutBox.containingBlock();
      // Start with the parent since we pretend that this box is normal flow.
      for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {
<span class="line-modified">!         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*container);</span>
          // Display::Box::left is the border box left position in its containing block&#39;s coordinate system.
<span class="line-modified">!         left += displayBox.left();</span>
          ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
      }
      // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.
<span class="line-modified">!     auto paddingBoxLeft = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxLeft();</span>
<span class="line-removed">-     return left - paddingBoxLeft;</span>
  }
  
<span class="line-modified">! LayoutUnit FormattingContext::Geometry::shrinkToFitWidth(LayoutState&amp; layoutState, const Box&amp; formattingRoot, UsedHorizontalValues usedValues)</span>
  {
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width] -&gt; shrink to fit -&gt; unsupported -&gt; width(&quot; &lt;&lt; LayoutUnit { } &lt;&lt; &quot;px) layoutBox: &quot; &lt;&lt; &amp;formattingRoot &lt;&lt; &quot;)&quot;);
      ASSERT(formattingRoot.establishesFormattingContext());
<span class="line-removed">-     ASSERT(usedValues.containingBlockWidth.hasValue());</span>
  
      // Calculation of the shrink-to-fit width is similar to calculating the width of a table cell using the automatic table layout algorithm.
      // Roughly: calculate the preferred width by formatting the content without breaking lines other than where explicit line breaks occur,
      // and also calculate the preferred minimum width, e.g., by trying all possible line breaks. CSS 2.2 does not define the exact algorithm.
      // Thirdly, find the available width: in this case, this is the width of the containing block minus the used values of &#39;margin-left&#39;, &#39;border-left-width&#39;,
      // &#39;padding-left&#39;, &#39;padding-right&#39;, &#39;border-right-width&#39;, &#39;margin-right&#39;, and the widths of any relevant scroll bars.
  
      // Then the shrink-to-fit width is: min(max(preferred minimum width, available width), preferred width).
<span class="line-modified">!     auto&amp; formattingStateForRoot = layoutState.createFormattingStateForFormattingRootIfNeeded(formattingRoot);</span>
<span class="line-modified">!     auto intrinsicWidthConstraints = formattingStateForRoot.intrinsicWidthConstraints();</span>
<span class="line-modified">!     if (!intrinsicWidthConstraints)</span>
<span class="line-modified">!         intrinsicWidthConstraints = layoutState.createFormattingContext(formattingRoot)-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-modified">!     auto availableWidth = *usedValues.containingBlockWidth;</span>
<span class="line-modified">!     return std::min(std::max(intrinsicWidthConstraints-&gt;minimum, availableWidth), intrinsicWidthConstraints-&gt;maximum);</span>
  }
  
<span class="line-modified">! VerticalGeometry FormattingContext::Geometry::outOfFlowNonReplacedVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
  
      // 10.6.4 Absolutely positioned, non-replaced elements
      //
      // For absolutely positioned elements, the used values of the vertical dimensions must satisfy this constraint:
      // &#39;top&#39; + &#39;margin-top&#39; + &#39;border-top-width&#39; + &#39;padding-top&#39; + &#39;height&#39; + &#39;padding-bottom&#39; + &#39;border-bottom-width&#39; + &#39;margin-bottom&#39; + &#39;bottom&#39;
<span class="line-new-header">--- 167,142 ---</span>
      auto computedHeight = bottom - top;
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height] -&gt; content height for formatting context root -&gt; height(&quot; &lt;&lt; computedHeight &lt;&lt; &quot;px) layoutBox(&quot;&lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
      return computedHeight;
  }
  
<span class="line-modified">! Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedValueIfNotAuto(const Length&amp; geometryProperty, LayoutUnit containingBlockWidth) const</span>
  {
      if (geometryProperty.isUndefined())
          return WTF::nullopt;
  
      if (geometryProperty.isAuto())
          return WTF::nullopt;
  
      return valueForLength(geometryProperty, containingBlockWidth);
  }
  
<span class="line-modified">! Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::fixedValue(const Length&amp; geometryProperty) const</span>
  {
      if (!geometryProperty.isFixed())
          return WTF::nullopt;
      return LayoutUnit(geometryProperty.value());
  }
  
  // https://www.w3.org/TR/CSS22/visudet.html#min-max-heights
  // Specifies a percentage for determining the used value. The percentage is calculated with respect to the height of the generated box&#39;s containing block.
  // If the height of the containing block is not specified explicitly (i.e., it depends on content height), and this element is not absolutely positioned,
  // the percentage value is treated as &#39;0&#39; (for &#39;min-height&#39;) or &#39;none&#39; (for &#39;max-height&#39;).
<span class="line-modified">! Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMaxHeight(const Box&amp; layoutBox, Optional&lt;LayoutUnit&gt; containingBlockHeight) const</span>
  {
<span class="line-modified">!     return computedHeightValue(layoutBox, HeightType::Max, containingBlockHeight);</span>
  }
  
<span class="line-modified">! Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMinHeight(const Box&amp; layoutBox, Optional&lt;LayoutUnit&gt; containingBlockHeight) const</span>
  {
<span class="line-modified">!     if (auto minHeightValue = computedHeightValue(layoutBox, HeightType::Min, containingBlockHeight))</span>
          return minHeightValue;
  
<span class="line-modified">!     return { LayoutUnit { } };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMinWidth(const Box&amp; layoutBox, LayoutUnit containingBlockWidth) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return computedValueIfNotAuto(layoutBox.style().logicalMinWidth(), containingBlockWidth);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMaxWidth(const Box&amp; layoutBox, LayoutUnit containingBlockWidth) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return computedValueIfNotAuto(layoutBox.style().logicalMaxWidth(), containingBlockWidth);</span>
  }
  
<span class="line-modified">! LayoutUnit FormattingContext::Geometry::staticVerticalPositionForOutOfFlowPositioned(const Box&amp; layoutBox, const VerticalConstraints&amp; verticalConstraints) const</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned());
  
      // For the purposes of this section and the next, the term &quot;static position&quot; (of an element) refers, roughly, to the position an element would have
      // had in the normal flow. More precisely, the static position for &#39;top&#39; is the distance from the top edge of the containing block to the top margin
      // edge of a hypothetical box that would have been the first box of the element if its specified &#39;position&#39; value had been &#39;static&#39; and its specified
      // &#39;float&#39; had been &#39;none&#39; and its specified &#39;clear&#39; had been &#39;none&#39;. (Note that due to the rules in section 9.7 this might require also assuming a different
      // computed value for &#39;display&#39;.) The value is negative if the hypothetical box is above the containing block.
  
      // Start with this box&#39;s border box offset from the parent&#39;s border box.
<span class="line-added">+     auto&amp; formattingContext = this-&gt;formattingContext();</span>
      LayoutUnit top;
      if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
          // Add sibling offset
<span class="line-modified">!         auto&amp; previousInFlowBoxGeometry = formattingContext.geometryForBox(*previousInFlowSibling, EscapeReason::OutOfFlowBoxNeedsInFlowGeometry);</span>
<span class="line-modified">!         top += previousInFlowBoxGeometry.bottom() + previousInFlowBoxGeometry.nonCollapsedMarginAfter();</span>
      } else {
          ASSERT(layoutBox.parent());
<span class="line-modified">!         top = formattingContext.geometryForBox(*layoutBox.parent(), EscapeReason::OutOfFlowBoxNeedsInFlowGeometry).contentBoxTop();</span>
      }
  
      // Resolve top all the way up to the containing block.
      auto&amp; containingBlock = *layoutBox.containingBlock();
      // Start with the parent since we pretend that this box is normal flow.
      for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {
<span class="line-modified">!         auto&amp; boxGeometry = formattingContext.geometryForBox(*container, EscapeReason::OutOfFlowBoxNeedsInFlowGeometry);</span>
          // Display::Box::top is the border box top position in its containing block&#39;s coordinate system.
<span class="line-modified">!         top += boxGeometry.top();</span>
          ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
      }
      // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.
<span class="line-modified">!     return top - verticalConstraints.logicalTop;</span>
  }
  
<span class="line-modified">! LayoutUnit FormattingContext::Geometry::staticHorizontalPositionForOutOfFlowPositioned(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned());
      // See staticVerticalPositionForOutOfFlowPositioned for the definition of the static position.
  
      // Start with this box&#39;s border box offset from the parent&#39;s border box.
<span class="line-added">+     auto&amp; formattingContext = this-&gt;formattingContext();</span>
      ASSERT(layoutBox.parent());
<span class="line-modified">!     auto left = formattingContext.geometryForBox(*layoutBox.parent(), EscapeReason::OutOfFlowBoxNeedsInFlowGeometry).contentBoxLeft();</span>
  
      // Resolve left all the way up to the containing block.
      auto&amp; containingBlock = *layoutBox.containingBlock();
      // Start with the parent since we pretend that this box is normal flow.
      for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {
<span class="line-modified">!         auto&amp; boxGeometry = formattingContext.geometryForBox(*container, EscapeReason::OutOfFlowBoxNeedsInFlowGeometry);</span>
          // Display::Box::left is the border box left position in its containing block&#39;s coordinate system.
<span class="line-modified">!         left += boxGeometry.left();</span>
          ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
      }
      // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.
<span class="line-modified">!     return left - horizontalConstraints.logicalLeft;</span>
  }
  
<span class="line-modified">! LayoutUnit FormattingContext::Geometry::shrinkToFitWidth(const Box&amp; formattingRoot, LayoutUnit availableWidth)</span>
  {
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width] -&gt; shrink to fit -&gt; unsupported -&gt; width(&quot; &lt;&lt; LayoutUnit { } &lt;&lt; &quot;px) layoutBox: &quot; &lt;&lt; &amp;formattingRoot &lt;&lt; &quot;)&quot;);
      ASSERT(formattingRoot.establishesFormattingContext());
  
      // Calculation of the shrink-to-fit width is similar to calculating the width of a table cell using the automatic table layout algorithm.
      // Roughly: calculate the preferred width by formatting the content without breaking lines other than where explicit line breaks occur,
      // and also calculate the preferred minimum width, e.g., by trying all possible line breaks. CSS 2.2 does not define the exact algorithm.
      // Thirdly, find the available width: in this case, this is the width of the containing block minus the used values of &#39;margin-left&#39;, &#39;border-left-width&#39;,
      // &#39;padding-left&#39;, &#39;padding-right&#39;, &#39;border-right-width&#39;, &#39;margin-right&#39;, and the widths of any relevant scroll bars.
  
      // Then the shrink-to-fit width is: min(max(preferred minimum width, available width), preferred width).
<span class="line-modified">!     auto intrinsicWidthConstraints = IntrinsicWidthConstraints { };</span>
<span class="line-modified">!     if (is&lt;Container&gt;(formattingRoot) &amp;&amp; downcast&lt;Container&gt;(formattingRoot).hasInFlowOrFloatingChild()) {</span>
<span class="line-modified">!         auto&amp; root = downcast&lt;Container&gt;(formattingRoot);</span>
<span class="line-modified">!         auto&amp; formattingStateForRoot = layoutState().ensureFormattingState(root);</span>
<span class="line-modified">!         auto precomputedIntrinsicWidthConstraints = formattingStateForRoot.intrinsicWidthConstraints();</span>
<span class="line-modified">!         if (!precomputedIntrinsicWidthConstraints)</span>
<span class="line-added">+             intrinsicWidthConstraints = LayoutContext::createFormattingContext(root, layoutState())-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-added">+         else</span>
<span class="line-added">+             intrinsicWidthConstraints = *precomputedIntrinsicWidthConstraints;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return std::min(std::max(intrinsicWidthConstraints.minimum, availableWidth), intrinsicWidthConstraints.maximum);</span>
  }
  
<span class="line-modified">! VerticalGeometry FormattingContext::Geometry::outOfFlowNonReplacedVerticalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
<span class="line-added">+     ASSERT(verticalConstraints.logicalHeight);</span>
  
      // 10.6.4 Absolutely positioned, non-replaced elements
      //
      // For absolutely positioned elements, the used values of the vertical dimensions must satisfy this constraint:
      // &#39;top&#39; + &#39;margin-top&#39; + &#39;border-top-width&#39; + &#39;padding-top&#39; + &#39;height&#39; + &#39;padding-bottom&#39; + &#39;border-bottom-width&#39; + &#39;margin-bottom&#39; + &#39;bottom&#39;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 293,76 ***</span>
      //     values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
      // 4. &#39;top&#39; is &#39;auto&#39;, &#39;height&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
      // 5. &#39;height&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; are set to 0 and solve for &#39;height&#39;
      // 6. &#39;bottom&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;height&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0 and solve for &#39;bottom&#39;
  
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">!     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock());</span>
<span class="line-modified">!     auto containingBlockHeight = containingBlockDisplayBox.paddingBoxHeight();</span>
<span class="line-removed">-     auto containingBlockWidth = containingBlockDisplayBox.paddingBoxWidth();</span>
  
      auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
      auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<span class="line-modified">!     auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);</span>
<span class="line-modified">!     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });</span>
      UsedVerticalMargin::NonCollapsedValues usedVerticalMargin;
<span class="line-modified">!     auto paddingTop = displayBox.paddingTop().valueOr(0);</span>
<span class="line-modified">!     auto paddingBottom = displayBox.paddingBottom().valueOr(0);</span>
<span class="line-modified">!     auto borderTop = displayBox.borderTop();</span>
<span class="line-modified">!     auto borderBottom = displayBox.borderBottom();</span>
<span class="line-removed">-     auto contentHeight = [&amp;] {</span>
<span class="line-removed">-         ASSERT(height);</span>
<span class="line-removed">-         return style.boxSizing() == BoxSizing::ContentBox ? *height : *height - (borderTop + paddingTop + paddingBottom + borderBottom);</span>
<span class="line-removed">-     };</span>
  
      if (!top &amp;&amp; !height &amp;&amp; !bottom)
<span class="line-modified">!         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);</span>
  
      if (top &amp;&amp; height &amp;&amp; bottom) {
          if (!computedVerticalMargin.before &amp;&amp; !computedVerticalMargin.after) {
<span class="line-modified">!             auto marginBeforeAndAfter = containingBlockHeight - (*top + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + *bottom);</span>
              usedVerticalMargin = { marginBeforeAndAfter / 2, marginBeforeAndAfter / 2 };
          } else if (!computedVerticalMargin.before) {
              usedVerticalMargin.after = *computedVerticalMargin.after;
<span class="line-modified">!             usedVerticalMargin.before = containingBlockHeight - (*top + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);</span>
          } else if (!computedVerticalMargin.after) {
              usedVerticalMargin.before = *computedVerticalMargin.before;
<span class="line-modified">!             usedVerticalMargin.after = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + *bottom);</span>
          } else
              usedVerticalMargin = { *computedVerticalMargin.before, *computedVerticalMargin.after };
          // Over-constrained?
<span class="line-modified">!         auto boxHeight = *top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom;</span>
          if (boxHeight != containingBlockHeight)
<span class="line-modified">!             bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
      }
  
      if (!top &amp;&amp; !height &amp;&amp; bottom) {
          // #1
<span class="line-modified">!         height = contentHeightForFormattingContextRoot(layoutState, layoutBox);</span>
          usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
          top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
      }
  
      if (!top &amp;&amp; !bottom &amp;&amp; height) {
          // #2
<span class="line-modified">!         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);</span>
          usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified">!         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
      }
  
      if (!height &amp;&amp; !bottom &amp;&amp; top) {
          // #3
<span class="line-modified">!         height = contentHeightForFormattingContextRoot(layoutState, layoutBox);</span>
          usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
          bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);
      }
  
      if (!top &amp;&amp; height &amp;&amp; bottom) {
          // #4
          usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified">!         top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);</span>
      }
  
      if (!height &amp;&amp; top &amp;&amp; bottom) {
          // #5
          usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-new-header">--- 324,72 ---</span>
      //     values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
      // 4. &#39;top&#39; is &#39;auto&#39;, &#39;height&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
      // 5. &#39;height&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; are set to 0 and solve for &#39;height&#39;
      // 6. &#39;bottom&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;height&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0 and solve for &#39;bottom&#39;
  
<span class="line-added">+     auto&amp; formattingContext = this-&gt;formattingContext();</span>
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified">!     auto containingBlockHeight = *verticalConstraints.logicalHeight;</span>
<span class="line-modified">!     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
  
      auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
      auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<span class="line-modified">!     auto height = overrideVerticalValues.height ? overrideVerticalValues.height.value() : computedContentHeight(layoutBox, containingBlockHeight);</span>
<span class="line-modified">!     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
      UsedVerticalMargin::NonCollapsedValues usedVerticalMargin;
<span class="line-modified">!     auto paddingTop = boxGeometry.paddingTop().valueOr(0);</span>
<span class="line-modified">!     auto paddingBottom = boxGeometry.paddingBottom().valueOr(0);</span>
<span class="line-modified">!     auto borderTop = boxGeometry.borderTop();</span>
<span class="line-modified">!     auto borderBottom = boxGeometry.borderBottom();</span>
  
      if (!top &amp;&amp; !height &amp;&amp; !bottom)
<span class="line-modified">!         top = staticVerticalPositionForOutOfFlowPositioned(layoutBox, verticalConstraints);</span>
  
      if (top &amp;&amp; height &amp;&amp; bottom) {
          if (!computedVerticalMargin.before &amp;&amp; !computedVerticalMargin.after) {
<span class="line-modified">!             auto marginBeforeAndAfter = containingBlockHeight - (*top + borderTop + paddingTop + *height + paddingBottom + borderBottom + *bottom);</span>
              usedVerticalMargin = { marginBeforeAndAfter / 2, marginBeforeAndAfter / 2 };
          } else if (!computedVerticalMargin.before) {
              usedVerticalMargin.after = *computedVerticalMargin.after;
<span class="line-modified">!             usedVerticalMargin.before = containingBlockHeight - (*top + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);</span>
          } else if (!computedVerticalMargin.after) {
              usedVerticalMargin.before = *computedVerticalMargin.before;
<span class="line-modified">!             usedVerticalMargin.after = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + *bottom);</span>
          } else
              usedVerticalMargin = { *computedVerticalMargin.before, *computedVerticalMargin.after };
          // Over-constrained?
<span class="line-modified">!         auto boxHeight = *top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom;</span>
          if (boxHeight != containingBlockHeight)
<span class="line-modified">!             bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
      }
  
      if (!top &amp;&amp; !height &amp;&amp; bottom) {
          // #1
<span class="line-modified">!         height = contentHeightForFormattingContextRoot(layoutBox);</span>
          usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
          top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
      }
  
      if (!top &amp;&amp; !bottom &amp;&amp; height) {
          // #2
<span class="line-modified">!         top = staticVerticalPositionForOutOfFlowPositioned(layoutBox, verticalConstraints);</span>
          usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified">!         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
      }
  
      if (!height &amp;&amp; !bottom &amp;&amp; top) {
          // #3
<span class="line-modified">!         height = contentHeightForFormattingContextRoot(layoutBox);</span>
          usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
          bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);
      }
  
      if (!top &amp;&amp; height &amp;&amp; bottom) {
          // #4
          usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified">!         top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);</span>
      }
  
      if (!height &amp;&amp; top &amp;&amp; bottom) {
          // #5
          usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,28 ***</span>
      }
  
      if (!bottom &amp;&amp; top &amp;&amp; height) {
          // #6
          usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified">!         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
      }
  
      ASSERT(top);
      ASSERT(bottom);
      ASSERT(height);
  
      // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
      // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified">!     auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxTop();</span>
      *top += containingBlockPaddingVerticalEdge;
      *bottom += containingBlockPaddingVerticalEdge;
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow non-replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot;  &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified">!     return { *top, *bottom, { contentHeight(), usedVerticalMargin } };</span>
  }
  
<span class="line-modified">! HorizontalGeometry FormattingContext::Geometry::outOfFlowNonReplacedHorizontalGeometry(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
  
      // 10.3.7 Absolutely positioned, non-replaced elements
      //
<span class="line-new-header">--- 397,28 ---</span>
      }
  
      if (!bottom &amp;&amp; top &amp;&amp; height) {
          // #6
          usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified">!         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
      }
  
      ASSERT(top);
      ASSERT(bottom);
      ASSERT(height);
  
      // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
      // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified">!     auto containingBlockPaddingVerticalEdge = verticalConstraints.logicalTop;</span>
      *top += containingBlockPaddingVerticalEdge;
      *bottom += containingBlockPaddingVerticalEdge;
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow non-replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot;  &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified">!     return { *top, *bottom, { *height, usedVerticalMargin } };</span>
  }
  
<span class="line-modified">! HorizontalGeometry FormattingContext::Geometry::outOfFlowNonReplacedHorizontalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
  
      // 10.3.7 Absolutely positioned, non-replaced elements
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 417,38 ***</span>
      // 3. &#39;width&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;left&#39; is not &#39;auto&#39;, then the width is shrink-to-fit . Then solve for &#39;right&#39;
      // 4. &#39;left&#39; is &#39;auto&#39;, &#39;width&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;left&#39;
      // 5. &#39;width&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;width&#39;
      // 6. &#39;right&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;width&#39; are not &#39;auto&#39;, then solve for &#39;right&#39;
  
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">!     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
<span class="line-modified">!     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(containingBlock);</span>
<span class="line-removed">-     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
<span class="line-removed">-     auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();</span>
  
      auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
      auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<span class="line-modified">!     auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : style.logicalWidth(), containingBlockWidth);</span>
<span class="line-modified">!     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
      UsedHorizontalMargin usedHorizontalMargin;
<span class="line-modified">!     auto paddingLeft = displayBox.paddingLeft().valueOr(0);</span>
<span class="line-modified">!     auto paddingRight = displayBox.paddingRight().valueOr(0);</span>
<span class="line-modified">!     auto borderLeft = displayBox.borderLeft();</span>
<span class="line-modified">!     auto borderRight = displayBox.borderRight();</span>
<span class="line-removed">-     auto contentWidth = [&amp;] {</span>
<span class="line-removed">-         ASSERT(width);</span>
<span class="line-removed">-         return style.boxSizing() == BoxSizing::ContentBox ? *width : *width - (borderLeft + paddingLeft + paddingRight + borderRight);</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
      if (!left &amp;&amp; !width &amp;&amp; !right) {
          // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
          // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
          // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
          usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
  
<span class="line-modified">!         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);</span>
          if (isLeftToRightDirection)
              left = staticHorizontalPosition;
          else
              right = staticHorizontalPosition;
      } else if (left &amp;&amp; width &amp;&amp; right) {
<span class="line-new-header">--- 444,32 ---</span>
      // 3. &#39;width&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;left&#39; is not &#39;auto&#39;, then the width is shrink-to-fit . Then solve for &#39;right&#39;
      // 4. &#39;left&#39; is &#39;auto&#39;, &#39;width&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;left&#39;
      // 5. &#39;width&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;width&#39;
      // 6. &#39;right&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;width&#39; are not &#39;auto&#39;, then solve for &#39;right&#39;
  
<span class="line-added">+     auto&amp; formattingContext = this-&gt;formattingContext();</span>
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified">!     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
<span class="line-modified">!     auto isLeftToRightDirection = layoutBox.containingBlock()-&gt;style().isLeftToRightDirection();</span>
  
      auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
      auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<span class="line-modified">!     auto width = overrideHorizontalValues.width ? overrideHorizontalValues.width : computedContentWidth(layoutBox, containingBlockWidth);</span>
<span class="line-modified">!     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
      UsedHorizontalMargin usedHorizontalMargin;
<span class="line-modified">!     auto paddingLeft = boxGeometry.paddingLeft().valueOr(0);</span>
<span class="line-modified">!     auto paddingRight = boxGeometry.paddingRight().valueOr(0);</span>
<span class="line-modified">!     auto borderLeft = boxGeometry.borderLeft();</span>
<span class="line-modified">!     auto borderRight = boxGeometry.borderRight();</span>
      if (!left &amp;&amp; !width &amp;&amp; !right) {
          // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
          // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
          // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
          usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
  
<span class="line-modified">!         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutBox, horizontalConstraints);</span>
          if (isLeftToRightDirection)
              left = staticHorizontalPosition;
          else
              right = staticHorizontalPosition;
      } else if (left &amp;&amp; width &amp;&amp; right) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 456,35 ***</span>
          // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
          // solve for &#39;margin-right&#39; (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;, solve the equation for that value.
          // If the values are over-constrained, ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or &#39;right&#39;
          // (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
          if (!computedHorizontalMargin.start &amp;&amp; !computedHorizontalMargin.end) {
<span class="line-modified">!             auto marginStartAndEnd = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);</span>
              if (marginStartAndEnd &gt;= 0)
                  usedHorizontalMargin = { marginStartAndEnd / 2, marginStartAndEnd / 2 };
              else {
                  if (isLeftToRightDirection) {
                      usedHorizontalMargin.start = 0_lu;
<span class="line-modified">!                     usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);</span>
                  } else {
                      usedHorizontalMargin.end = 0_lu;
<span class="line-modified">!                     usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
                  }
              }
          } else if (!computedHorizontalMargin.start) {
              usedHorizontalMargin.end = *computedHorizontalMargin.end;
<span class="line-modified">!             usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
          } else if (!computedHorizontalMargin.end) {
              usedHorizontalMargin.start = *computedHorizontalMargin.start;
<span class="line-modified">!             usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);</span>
          } else {
              usedHorizontalMargin = { *computedHorizontalMargin.start, *computedHorizontalMargin.end };
              // Overconstrained? Ignore right (left).
              if (isLeftToRightDirection)
<span class="line-modified">!                 right = containingBlockWidth - (usedHorizontalMargin.start + *left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
              else
<span class="line-modified">!                 left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
          }
      } else {
          // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
          usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
      }
<span class="line-new-header">--- 477,35 ---</span>
          // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
          // solve for &#39;margin-right&#39; (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;, solve the equation for that value.
          // If the values are over-constrained, ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or &#39;right&#39;
          // (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
          if (!computedHorizontalMargin.start &amp;&amp; !computedHorizontalMargin.end) {
<span class="line-modified">!             auto marginStartAndEnd = containingBlockWidth - (*left + borderLeft + paddingLeft + *width + paddingRight + borderRight + *right);</span>
              if (marginStartAndEnd &gt;= 0)
                  usedHorizontalMargin = { marginStartAndEnd / 2, marginStartAndEnd / 2 };
              else {
                  if (isLeftToRightDirection) {
                      usedHorizontalMargin.start = 0_lu;
<span class="line-modified">!                     usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + *right);</span>
                  } else {
                      usedHorizontalMargin.end = 0_lu;
<span class="line-modified">!                     usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
                  }
              }
          } else if (!computedHorizontalMargin.start) {
              usedHorizontalMargin.end = *computedHorizontalMargin.end;
<span class="line-modified">!             usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
          } else if (!computedHorizontalMargin.end) {
              usedHorizontalMargin.start = *computedHorizontalMargin.start;
<span class="line-modified">!             usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + *right);</span>
          } else {
              usedHorizontalMargin = { *computedHorizontalMargin.start, *computedHorizontalMargin.end };
              // Overconstrained? Ignore right (left).
              if (isLeftToRightDirection)
<span class="line-modified">!                 right = containingBlockWidth - (usedHorizontalMargin.start + *left + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
              else
<span class="line-modified">!                 left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
          }
      } else {
          // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
          usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 492,57 ***</span>
      if (!left &amp;&amp; !width &amp;&amp; right) {
          // #1
          // Calculate the available width by solving for &#39;width&#39; after setting &#39;left&#39; (in case 1) to 0
          left = LayoutUnit { 0 };
          auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
<span class="line-modified">!         width = shrinkToFitWidth(layoutState, layoutBox, UsedHorizontalValues { availableWidth, usedValues.width, usedValues.margin });</span>
          left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight  + borderRight + usedHorizontalMargin.end + *right);
      } else if (!left &amp;&amp; !right &amp;&amp; width) {
          // #2
<span class="line-modified">!         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);</span>
          if (isLeftToRightDirection) {
              left = staticHorizontalPosition;
<span class="line-modified">!             right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
          } else {
              right = staticHorizontalPosition;
<span class="line-modified">!             left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
          }
      } else if (!width &amp;&amp; !right &amp;&amp; left) {
          // #3
          // Calculate the available width by solving for &#39;width&#39; after setting &#39;right&#39; (in case 3) to 0
          right = LayoutUnit { 0 };
          auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
<span class="line-modified">!         width = shrinkToFitWidth(layoutState, layoutBox, UsedHorizontalValues { availableWidth, usedValues.width, usedValues.margin });</span>
          right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);
      } else if (!left &amp;&amp; width &amp;&amp; right) {
          // #4
<span class="line-modified">!         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
      } else if (!width &amp;&amp; left &amp;&amp; right) {
          // #5
          width = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
      } else if (!right &amp;&amp; left &amp;&amp; width) {
          // #6
<span class="line-modified">!         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
      }
  
      ASSERT(left);
      ASSERT(right);
      ASSERT(width);
  
      // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
      // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified">!     auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxLeft();</span>
      *left += containingBlockPaddingVerticalEdge;
      *right += containingBlockPaddingVerticalEdge;
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow non-replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontalMargin.start &lt;&lt; &quot;px, &quot;  &lt;&lt; usedHorizontalMargin.end &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified">!     return { *left, *right, { contentWidth(), usedHorizontalMargin, computedHorizontalMargin } };</span>
  }
  
<span class="line-modified">! VerticalGeometry FormattingContext::Geometry::outOfFlowReplacedVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
  
      // 10.6.5 Absolutely positioned, replaced elements
      //
      // The used value of &#39;height&#39; is determined as for inline replaced elements.
      // If &#39;margin-top&#39; or &#39;margin-bottom&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
<span class="line-new-header">--- 513,58 ---</span>
      if (!left &amp;&amp; !width &amp;&amp; right) {
          // #1
          // Calculate the available width by solving for &#39;width&#39; after setting &#39;left&#39; (in case 1) to 0
          left = LayoutUnit { 0 };
          auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
<span class="line-modified">!         width = shrinkToFitWidth(layoutBox, availableWidth);</span>
          left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight  + borderRight + usedHorizontalMargin.end + *right);
      } else if (!left &amp;&amp; !right &amp;&amp; width) {
          // #2
<span class="line-modified">!         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutBox, horizontalConstraints);</span>
          if (isLeftToRightDirection) {
              left = staticHorizontalPosition;
<span class="line-modified">!             right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
          } else {
              right = staticHorizontalPosition;
<span class="line-modified">!             left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
          }
      } else if (!width &amp;&amp; !right &amp;&amp; left) {
          // #3
          // Calculate the available width by solving for &#39;width&#39; after setting &#39;right&#39; (in case 3) to 0
          right = LayoutUnit { 0 };
          auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
<span class="line-modified">!         width = shrinkToFitWidth(layoutBox, availableWidth);</span>
          right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);
      } else if (!left &amp;&amp; width &amp;&amp; right) {
          // #4
<span class="line-modified">!         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
      } else if (!width &amp;&amp; left &amp;&amp; right) {
          // #5
          width = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
      } else if (!right &amp;&amp; left &amp;&amp; width) {
          // #6
<span class="line-modified">!         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
      }
  
      ASSERT(left);
      ASSERT(right);
      ASSERT(width);
  
      // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
      // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified">!     auto containingBlockPaddingVerticalEdge = horizontalConstraints.logicalLeft;</span>
      *left += containingBlockPaddingVerticalEdge;
      *right += containingBlockPaddingVerticalEdge;
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow non-replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontalMargin.start &lt;&lt; &quot;px, &quot;  &lt;&lt; usedHorizontalMargin.end &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified">!     return { *left, *right, { *width, usedHorizontalMargin, computedHorizontalMargin } };</span>
  }
  
<span class="line-modified">! VerticalGeometry FormattingContext::Geometry::outOfFlowReplacedVerticalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
<span class="line-added">+     ASSERT(verticalConstraints.logicalHeight);</span>
  
      // 10.6.5 Absolutely positioned, replaced elements
      //
      // The used value of &#39;height&#39; is determined as for inline replaced elements.
      // If &#39;margin-top&#39; or &#39;margin-bottom&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 550,30 ***</span>
      // 2. If &#39;bottom&#39; is &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-top&#39; or &#39;margin-bottom&#39; with &#39;0&#39;.
      // 3. If at this point both &#39;margin-top&#39; and &#39;margin-bottom&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values.
      // 4. If at this point there is only one &#39;auto&#39; left, solve the equation for that value.
      // 5. If at this point the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
  
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">!     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock());</span>
<span class="line-modified">!     auto containingBlockHeight = containingBlockDisplayBox.paddingBoxHeight();</span>
<span class="line-removed">-     auto containingBlockWidth = containingBlockDisplayBox.paddingBoxWidth();</span>
  
      auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
      auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<span class="line-modified">!     auto height = inlineReplacedHeightAndMargin(layoutState, layoutBox, usedValues).height;</span>
<span class="line-modified">!     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });</span>
      Optional&lt;LayoutUnit&gt; usedMarginBefore = computedVerticalMargin.before;
      Optional&lt;LayoutUnit&gt; usedMarginAfter = computedVerticalMargin.after;
<span class="line-modified">!     auto paddingTop = displayBox.paddingTop().valueOr(0);</span>
<span class="line-modified">!     auto paddingBottom = displayBox.paddingBottom().valueOr(0);</span>
<span class="line-modified">!     auto borderTop = displayBox.borderTop();</span>
<span class="line-modified">!     auto borderBottom = displayBox.borderBottom();</span>
  
      if (!top &amp;&amp; !bottom) {
          // #1
<span class="line-modified">!         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);</span>
      }
  
      if (!bottom) {
          // #2
          usedMarginBefore = computedVerticalMargin.before.valueOr(0);
<span class="line-new-header">--- 572,30 ---</span>
      // 2. If &#39;bottom&#39; is &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-top&#39; or &#39;margin-bottom&#39; with &#39;0&#39;.
      // 3. If at this point both &#39;margin-top&#39; and &#39;margin-bottom&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values.
      // 4. If at this point there is only one &#39;auto&#39; left, solve the equation for that value.
      // 5. If at this point the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
  
<span class="line-added">+     auto&amp; formattingContext = this-&gt;formattingContext();</span>
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified">!     auto containingBlockHeight = *verticalConstraints.logicalHeight;</span>
<span class="line-modified">!     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
  
      auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
      auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<span class="line-modified">!     auto height = inlineReplacedHeightAndMargin(layoutBox, horizontalConstraints, verticalConstraints, overrideVerticalValues).contentHeight;</span>
<span class="line-modified">!     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
      Optional&lt;LayoutUnit&gt; usedMarginBefore = computedVerticalMargin.before;
      Optional&lt;LayoutUnit&gt; usedMarginAfter = computedVerticalMargin.after;
<span class="line-modified">!     auto paddingTop = boxGeometry.paddingTop().valueOr(0);</span>
<span class="line-modified">!     auto paddingBottom = boxGeometry.paddingBottom().valueOr(0);</span>
<span class="line-modified">!     auto borderTop = boxGeometry.borderTop();</span>
<span class="line-modified">!     auto borderBottom = boxGeometry.borderBottom();</span>
  
      if (!top &amp;&amp; !bottom) {
          // #1
<span class="line-modified">!         top = staticVerticalPositionForOutOfFlowPositioned(layoutBox, verticalConstraints);</span>
      }
  
      if (!bottom) {
          // #2
          usedMarginBefore = computedVerticalMargin.before.valueOr(0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 605,11 ***</span>
      if (boxHeight &gt; containingBlockHeight)
          bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
  
      // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
      // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified">!     auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxTop();</span>
      *top += containingBlockPaddingVerticalEdge;
      *bottom += containingBlockPaddingVerticalEdge;
  
      ASSERT(top);
      ASSERT(bottom);
<span class="line-new-header">--- 627,11 ---</span>
      if (boxHeight &gt; containingBlockHeight)
          bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
  
      // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
      // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified">!     auto containingBlockPaddingVerticalEdge = verticalConstraints.logicalTop;</span>
      *top += containingBlockPaddingVerticalEdge;
      *bottom += containingBlockPaddingVerticalEdge;
  
      ASSERT(top);
      ASSERT(bottom);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 617,11 ***</span>
      ASSERT(usedMarginAfter);
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginBefore &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginAfter &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
      return { *top, *bottom, { height, { *usedMarginBefore, *usedMarginAfter } } };
  }
  
<span class="line-modified">! HorizontalGeometry FormattingContext::Geometry::outOfFlowReplacedHorizontalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
  
      // 10.3.8 Absolutely positioned, replaced elements
      // In this case, section 10.3.7 applies up through and including the constraint equation, but the rest of section 10.3.7 is replaced by the following rules:
<span class="line-new-header">--- 639,11 ---</span>
      ASSERT(usedMarginAfter);
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginBefore &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginAfter &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
      return { *top, *bottom, { height, { *usedMarginBefore, *usedMarginAfter } } };
  }
  
<span class="line-modified">! HorizontalGeometry FormattingContext::Geometry::outOfFlowReplacedHorizontalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
  
      // 10.3.8 Absolutely positioned, replaced elements
      // In this case, section 10.3.7 applies up through and including the constraint equation, but the rest of section 10.3.7 is replaced by the following rules:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 635,30 ***</span>
      //   solve for &#39;margin-right&#39; (&#39;margin-left&#39;).
      // 4. If at this point there is an &#39;auto&#39; left, solve the equation for that value.
      // 5. If at this point the values are over-constrained, ignore the value for either &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or
      //   &#39;right&#39; (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
  
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">!     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
<span class="line-modified">!     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
<span class="line-removed">-     auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();</span>
  
      auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
      auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<span class="line-modified">!     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
      Optional&lt;LayoutUnit&gt; usedMarginStart = computedHorizontalMargin.start;
      Optional&lt;LayoutUnit&gt; usedMarginEnd = computedHorizontalMargin.end;
<span class="line-modified">!     auto width = inlineReplacedWidthAndMargin(layoutState, layoutBox, usedValues).width;</span>
<span class="line-modified">!     auto paddingLeft = displayBox.paddingLeft().valueOr(0);</span>
<span class="line-modified">!     auto paddingRight = displayBox.paddingRight().valueOr(0);</span>
<span class="line-modified">!     auto borderLeft = displayBox.borderLeft();</span>
<span class="line-modified">!     auto borderRight = displayBox.borderRight();</span>
  
      if (!left &amp;&amp; !right) {
          // #1
<span class="line-modified">!         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);</span>
          if (isLeftToRightDirection)
              left = staticHorizontalPosition;
          else
              right = staticHorizontalPosition;
      }
<span class="line-new-header">--- 657,30 ---</span>
      //   solve for &#39;margin-right&#39; (&#39;margin-left&#39;).
      // 4. If at this point there is an &#39;auto&#39; left, solve the equation for that value.
      // 5. If at this point the values are over-constrained, ignore the value for either &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or
      //   &#39;right&#39; (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
  
<span class="line-added">+     auto&amp; formattingContext = this-&gt;formattingContext();</span>
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified">!     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
<span class="line-modified">!     auto isLeftToRightDirection = layoutBox.containingBlock()-&gt;style().isLeftToRightDirection();</span>
  
      auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
      auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<span class="line-modified">!     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
      Optional&lt;LayoutUnit&gt; usedMarginStart = computedHorizontalMargin.start;
      Optional&lt;LayoutUnit&gt; usedMarginEnd = computedHorizontalMargin.end;
<span class="line-modified">!     auto width = inlineReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues).contentWidth;</span>
<span class="line-modified">!     auto paddingLeft = boxGeometry.paddingLeft().valueOr(0);</span>
<span class="line-modified">!     auto paddingRight = boxGeometry.paddingRight().valueOr(0);</span>
<span class="line-modified">!     auto borderLeft = boxGeometry.borderLeft();</span>
<span class="line-modified">!     auto borderRight = boxGeometry.borderRight();</span>
  
      if (!left &amp;&amp; !right) {
          // #1
<span class="line-modified">!         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutBox, horizontalConstraints);</span>
          if (isLeftToRightDirection)
              left = staticHorizontalPosition;
          else
              right = staticHorizontalPosition;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 713,133 ***</span>
      ASSERT(usedMarginStart);
      ASSERT(usedMarginEnd);
  
      // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
      // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified">!     auto containingBlockPaddingVerticalEdge = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxLeft();</span>
      *left += containingBlockPaddingVerticalEdge;
      *right += containingBlockPaddingVerticalEdge;
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginStart &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginEnd &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
      return { *left, *right, { width, { *usedMarginStart, *usedMarginEnd }, computedHorizontalMargin } };
  }
  
<span class="line-modified">! HeightAndMargin FormattingContext::Geometry::complicatedCases(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues, UsedHorizontalValues usedHorizontalValues)</span>
  {
      ASSERT(!layoutBox.replaced());
      // TODO: Use complicated-case for document renderer for now (see BlockFormattingContext::Geometry::inFlowHeightAndMargin).
<span class="line-modified">!     ASSERT((layoutBox.isBlockLevelBox() &amp;&amp; layoutBox.isInFlow() &amp;&amp; !layoutBox.isOverflowVisible()) || layoutBox.isInlineBlockBox() || layoutBox.isFloatingPositioned() || layoutBox.isDocumentBox());</span>
  
      // 10.6.6 Complicated cases
      //
      // Block-level, non-replaced elements in normal flow when &#39;overflow&#39; does not compute to &#39;visible&#39; (except if the &#39;overflow&#39; property&#39;s value has been propagated to the viewport).
      // &#39;Inline-block&#39;, non-replaced elements.
      // Floating, non-replaced elements.
      //
      // 1. If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
      // 2. If &#39;height&#39; is &#39;auto&#39;, the height depends on the element&#39;s descendants per 10.6.7.
  
<span class="line-modified">!     auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);</span>
<span class="line-modified">!     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, usedHorizontalValues);</span>
      // #1
      auto usedVerticalMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
      // #2
      if (!height) {
          ASSERT(isHeightAuto(layoutBox));
<span class="line-modified">!         height = contentHeightForFormattingContextRoot(layoutState, layoutBox);</span>
      }
  
      ASSERT(height);
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating non-replaced -&gt; height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified">!     return HeightAndMargin { *height, usedVerticalMargin };</span>
  }
  
<span class="line-modified">! WidthAndMargin FormattingContext::Geometry::floatingNonReplacedWidthAndMargin(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; !layoutBox.replaced());
  
      // 10.3.5 Floating, non-replaced elements
      //
      // 1. If &#39;margin-left&#39;, or &#39;margin-right&#39; are computed as &#39;auto&#39;, their used value is &#39;0&#39;.
      // 2. If &#39;width&#39; is computed as &#39;auto&#39;, the used value is the &quot;shrink-to-fit&quot; width.
  
<span class="line-modified">!     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
  
      // #1
      auto usedHorizontallMargin = UsedHorizontalMargin { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
      // #2
<span class="line-modified">!     auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : layoutBox.style().logicalWidth(), usedValues.containingBlockWidth.valueOr(0));</span>
      if (!width)
<span class="line-modified">!         width = shrinkToFitWidth(layoutState, layoutBox, usedValues);</span>
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; floating non-replaced -&gt; width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontallMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; usedHorizontallMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified">!     return WidthAndMargin { *width, usedHorizontallMargin, computedHorizontalMargin };</span>
  }
  
<span class="line-modified">! HeightAndMargin FormattingContext::Geometry::floatingReplacedHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
  {
      ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; layoutBox.replaced());
  
      // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39;
      // replaced elements in normal flow and floating replaced elements
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating replaced -&gt; redirected to inline replaced&quot;);
<span class="line-modified">!     return inlineReplacedHeightAndMargin(layoutState, layoutBox, usedValues);</span>
  }
  
<span class="line-modified">! WidthAndMargin FormattingContext::Geometry::floatingReplacedWidthAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; layoutBox.replaced());
  
      // 10.3.6 Floating, replaced elements
      //
      // 1. If &#39;margin-left&#39; or &#39;margin-right&#39; are computed as &#39;auto&#39;, their used value is &#39;0&#39;.
      // 2. The used value of &#39;width&#39; is determined as for inline replaced elements.
<span class="line-modified">!     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating replaced -&gt; redirected to inline replaced&quot;);
<span class="line-modified">!     return inlineReplacedWidthAndMargin(layoutState, layoutBox, UsedHorizontalValues { usedValues.containingBlockWidth.valueOr(0),</span>
<span class="line-modified">!         usedValues.width, UsedHorizontalMargin { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) } });</span>
  }
  
<span class="line-modified">! VerticalGeometry FormattingContext::Geometry::outOfFlowVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned());
  
      if (!layoutBox.replaced())
<span class="line-modified">!         return outOfFlowNonReplacedVerticalGeometry(layoutState, layoutBox, usedValues);</span>
<span class="line-modified">!     return outOfFlowReplacedVerticalGeometry(layoutState, layoutBox, usedValues);</span>
  }
  
<span class="line-modified">! HorizontalGeometry FormattingContext::Geometry::outOfFlowHorizontalGeometry(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned());
  
      if (!layoutBox.replaced())
<span class="line-modified">!         return outOfFlowNonReplacedHorizontalGeometry(layoutState, layoutBox, usedValues);</span>
<span class="line-modified">!     return outOfFlowReplacedHorizontalGeometry(layoutState, layoutBox, usedValues);</span>
  }
  
<span class="line-modified">! HeightAndMargin FormattingContext::Geometry::floatingHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedVerticalValues, UsedHorizontalValues usedHorizontalValues)</span>
  {
      ASSERT(layoutBox.isFloatingPositioned());
  
      if (!layoutBox.replaced())
<span class="line-modified">!         return complicatedCases(layoutState, layoutBox, usedVerticalValues, usedHorizontalValues);</span>
<span class="line-modified">!     return floatingReplacedHeightAndMargin(layoutState, layoutBox, usedVerticalValues);</span>
  }
  
<span class="line-modified">! WidthAndMargin FormattingContext::Geometry::floatingWidthAndMargin(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      ASSERT(layoutBox.isFloatingPositioned());
  
      if (!layoutBox.replaced())
<span class="line-modified">!         return floatingNonReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
<span class="line-modified">!     return floatingReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
  }
  
<span class="line-modified">! HeightAndMargin FormattingContext::Geometry::inlineReplacedHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
  {
      ASSERT((layoutBox.isOutOfFlowPositioned() || layoutBox.isFloatingPositioned() || layoutBox.isInFlow()) &amp;&amp; layoutBox.replaced());
  
      // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39; replaced elements in normal flow and floating replaced elements
      //
<span class="line-new-header">--- 735,133 ---</span>
      ASSERT(usedMarginStart);
      ASSERT(usedMarginEnd);
  
      // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
      // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified">!     auto containingBlockPaddingVerticalEdge = horizontalConstraints.logicalLeft;</span>
      *left += containingBlockPaddingVerticalEdge;
      *right += containingBlockPaddingVerticalEdge;
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginStart &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginEnd &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
      return { *left, *right, { width, { *usedMarginStart, *usedMarginEnd }, computedHorizontalMargin } };
  }
  
<span class="line-modified">! ContentHeightAndMargin FormattingContext::Geometry::complicatedCases(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
  {
      ASSERT(!layoutBox.replaced());
      // TODO: Use complicated-case for document renderer for now (see BlockFormattingContext::Geometry::inFlowHeightAndMargin).
<span class="line-modified">!     ASSERT((layoutBox.isBlockLevelBox() &amp;&amp; layoutBox.isInFlow() &amp;&amp; !layoutBox.isOverflowVisible()) || layoutBox.isInlineBlockBox() || layoutBox.isFloatingPositioned() || layoutBox.isDocumentBox() || layoutBox.isTableBox());</span>
  
      // 10.6.6 Complicated cases
      //
      // Block-level, non-replaced elements in normal flow when &#39;overflow&#39; does not compute to &#39;visible&#39; (except if the &#39;overflow&#39; property&#39;s value has been propagated to the viewport).
      // &#39;Inline-block&#39;, non-replaced elements.
      // Floating, non-replaced elements.
      //
      // 1. If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
      // 2. If &#39;height&#39; is &#39;auto&#39;, the height depends on the element&#39;s descendants per 10.6.7.
  
<span class="line-modified">!     auto height = overrideVerticalValues.height ? overrideVerticalValues.height.value() : computedContentHeight(layoutBox);</span>
<span class="line-modified">!     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
      // #1
      auto usedVerticalMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
      // #2
      if (!height) {
          ASSERT(isHeightAuto(layoutBox));
<span class="line-modified">!         height = contentHeightForFormattingContextRoot(layoutBox);</span>
      }
  
      ASSERT(height);
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating non-replaced -&gt; height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified">!     return ContentHeightAndMargin { *height, usedVerticalMargin };</span>
  }
  
<span class="line-modified">! ContentWidthAndMargin FormattingContext::Geometry::floatingNonReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
  {
      ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; !layoutBox.replaced());
  
      // 10.3.5 Floating, non-replaced elements
      //
      // 1. If &#39;margin-left&#39;, or &#39;margin-right&#39; are computed as &#39;auto&#39;, their used value is &#39;0&#39;.
      // 2. If &#39;width&#39; is computed as &#39;auto&#39;, the used value is the &quot;shrink-to-fit&quot; width.
  
<span class="line-modified">!     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
  
      // #1
      auto usedHorizontallMargin = UsedHorizontalMargin { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
      // #2
<span class="line-modified">!     auto width = overrideHorizontalValues.width ? overrideHorizontalValues.width : computedContentWidth(layoutBox, horizontalConstraints.logicalWidth);</span>
      if (!width)
<span class="line-modified">!         width = shrinkToFitWidth(layoutBox, horizontalConstraints.logicalWidth);</span>
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; floating non-replaced -&gt; width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontallMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; usedHorizontallMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified">!     return ContentWidthAndMargin { *width, usedHorizontallMargin, computedHorizontalMargin };</span>
  }
  
<span class="line-modified">! ContentHeightAndMargin FormattingContext::Geometry::floatingReplacedHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
  {
      ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; layoutBox.replaced());
  
      // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39;
      // replaced elements in normal flow and floating replaced elements
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating replaced -&gt; redirected to inline replaced&quot;);
<span class="line-modified">!     return inlineReplacedHeightAndMargin(layoutBox, horizontalConstraints, { }, overrideVerticalValues);</span>
  }
  
<span class="line-modified">! ContentWidthAndMargin FormattingContext::Geometry::floatingReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
  {
      ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; layoutBox.replaced());
  
      // 10.3.6 Floating, replaced elements
      //
      // 1. If &#39;margin-left&#39; or &#39;margin-right&#39; are computed as &#39;auto&#39;, their used value is &#39;0&#39;.
      // 2. The used value of &#39;width&#39; is determined as for inline replaced elements.
<span class="line-modified">!     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating replaced -&gt; redirected to inline replaced&quot;);
<span class="line-modified">!     auto usedMargin = UsedHorizontalMargin { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };</span>
<span class="line-modified">!     return inlineReplacedWidthAndMargin(layoutBox, horizontalConstraints, { overrideHorizontalValues.width, usedMargin });</span>
  }
  
<span class="line-modified">! VerticalGeometry FormattingContext::Geometry::outOfFlowVerticalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned());
  
      if (!layoutBox.replaced())
<span class="line-modified">!         return outOfFlowNonReplacedVerticalGeometry(layoutBox, horizontalConstraints, verticalConstraints, overrideVerticalValues);</span>
<span class="line-modified">!     return outOfFlowReplacedVerticalGeometry(layoutBox, horizontalConstraints, verticalConstraints, overrideVerticalValues);</span>
  }
  
<span class="line-modified">! HorizontalGeometry FormattingContext::Geometry::outOfFlowHorizontalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
  {
      ASSERT(layoutBox.isOutOfFlowPositioned());
  
      if (!layoutBox.replaced())
<span class="line-modified">!         return outOfFlowNonReplacedHorizontalGeometry(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
<span class="line-modified">!     return outOfFlowReplacedHorizontalGeometry(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
  }
  
<span class="line-modified">! ContentHeightAndMargin FormattingContext::Geometry::floatingHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
  {
      ASSERT(layoutBox.isFloatingPositioned());
  
      if (!layoutBox.replaced())
<span class="line-modified">!         return complicatedCases(layoutBox, horizontalConstraints, overrideVerticalValues);</span>
<span class="line-modified">!     return floatingReplacedHeightAndMargin(layoutBox, horizontalConstraints, overrideVerticalValues);</span>
  }
  
<span class="line-modified">! ContentWidthAndMargin FormattingContext::Geometry::floatingWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
  {
      ASSERT(layoutBox.isFloatingPositioned());
  
      if (!layoutBox.replaced())
<span class="line-modified">!         return floatingNonReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
<span class="line-modified">!     return floatingReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
  }
  
<span class="line-modified">! ContentHeightAndMargin FormattingContext::Geometry::inlineReplacedHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, Optional&lt;VerticalConstraints&gt; verticalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
  {
      ASSERT((layoutBox.isOutOfFlowPositioned() || layoutBox.isFloatingPositioned() || layoutBox.isInFlow()) &amp;&amp; layoutBox.replaced());
  
      // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39; replaced elements in normal flow and floating replaced elements
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 850,26 ***</span>
      // 4. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic height, then that intrinsic height is the used value of &#39;height&#39;.
      // 5. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;height&#39; must be set to
      //    the height of the largest rectangle that has a 2:1 ratio, has a height not greater than 150px, and has a width not greater than the device width.
  
      // #1
<span class="line-modified">!     auto containingBlockWidth = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth();</span>
<span class="line-modified">!     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });</span>
      auto usedVerticalMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
      auto&amp; style = layoutBox.style();
      auto replaced = layoutBox.replaced();
  
<span class="line-modified">!     auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);</span>
<span class="line-modified">!     auto heightIsAuto = !usedValues.height &amp;&amp; isHeightAuto(layoutBox);</span>
      auto widthIsAuto = style.logicalWidth().isAuto();
  
      if (heightIsAuto &amp;&amp; widthIsAuto &amp;&amp; replaced-&gt;hasIntrinsicHeight()) {
          // #2
          height = replaced-&gt;intrinsicHeight();
      } else if (heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicRatio()) {
          // #3
<span class="line-modified">!         auto usedWidth = layoutState.displayBoxForLayoutBox(layoutBox).width();</span>
          height = usedWidth / replaced-&gt;intrinsicRatio();
      } else if (heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicHeight()) {
          // #4
          height = replaced-&gt;intrinsicHeight();
      } else if (heightIsAuto) {
<span class="line-new-header">--- 872,26 ---</span>
      // 4. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic height, then that intrinsic height is the used value of &#39;height&#39;.
      // 5. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;height&#39; must be set to
      //    the height of the largest rectangle that has a 2:1 ratio, has a height not greater than 150px, and has a width not greater than the device width.
  
      // #1
<span class="line-modified">!     auto&amp; formattingContext = this-&gt;formattingContext();</span>
<span class="line-modified">!     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
      auto usedVerticalMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
      auto&amp; style = layoutBox.style();
      auto replaced = layoutBox.replaced();
  
<span class="line-modified">!     auto height = overrideVerticalValues.height ? overrideVerticalValues.height.value() : computedContentHeight(layoutBox, verticalConstraints ? verticalConstraints-&gt;logicalHeight : WTF::nullopt);</span>
<span class="line-modified">!     auto heightIsAuto = !overrideVerticalValues.height &amp;&amp; isHeightAuto(layoutBox);</span>
      auto widthIsAuto = style.logicalWidth().isAuto();
  
      if (heightIsAuto &amp;&amp; widthIsAuto &amp;&amp; replaced-&gt;hasIntrinsicHeight()) {
          // #2
          height = replaced-&gt;intrinsicHeight();
      } else if (heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicRatio()) {
          // #3
<span class="line-modified">!         auto usedWidth = formattingContext.geometryForBox(layoutBox).width();</span>
          height = usedWidth / replaced-&gt;intrinsicRatio();
      } else if (heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicHeight()) {
          // #4
          height = replaced-&gt;intrinsicHeight();
      } else if (heightIsAuto) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 881,11 ***</span>
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; inflow replaced -&gt; height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
      return { *height, usedVerticalMargin };
  }
  
<span class="line-modified">! WidthAndMargin FormattingContext::Geometry::inlineReplacedWidthAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      ASSERT((layoutBox.isOutOfFlowPositioned() || layoutBox.isFloatingPositioned() || layoutBox.isInFlow()) &amp;&amp; layoutBox.replaced());
  
      // 10.3.2 Inline, replaced elements
      //
<span class="line-new-header">--- 903,11 ---</span>
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; inflow replaced -&gt; height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
      return { *height, usedVerticalMargin };
  }
  
<span class="line-modified">! ContentWidthAndMargin FormattingContext::Geometry::inlineReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
  {
      ASSERT((layoutBox.isOutOfFlowPositioned() || layoutBox.isFloatingPositioned() || layoutBox.isInFlow()) &amp;&amp; layoutBox.replaced());
  
      // 10.3.2 Inline, replaced elements
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 904,32 ***</span>
      // 4. Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
      //
      // 5. Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;width&#39; becomes 300px.
      //    If 300px is too wide to fit the device, UAs should use the width of the largest rectangle that has a 2:1 ratio and fits the device instead.
  
<span class="line-modified">!     auto&amp; style = layoutBox.style();</span>
<span class="line-removed">-     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
<span class="line-removed">-     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
  
      auto usedMarginStart = [&amp;] {
<span class="line-modified">!         if (usedValues.margin)</span>
<span class="line-modified">!             return usedValues.margin-&gt;start;</span>
          return computedHorizontalMargin.start.valueOr(0_lu);
      };
  
      auto usedMarginEnd = [&amp;] {
<span class="line-modified">!         if (usedValues.margin)</span>
<span class="line-modified">!             return usedValues.margin-&gt;end;</span>
          return computedHorizontalMargin.end.valueOr(0_lu);
      };
  
      auto replaced = layoutBox.replaced();
      ASSERT(replaced);
  
<span class="line-modified">!     auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : style.logicalWidth(), containingBlockWidth);</span>
      auto heightIsAuto = isHeightAuto(layoutBox);
<span class="line-modified">!     auto height = computedHeightValue(layoutState, layoutBox, HeightType::Normal);</span>
  
      if (!width &amp;&amp; heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicWidth()) {
          // #1
          width = replaced-&gt;intrinsicWidth();
      } else if ((!width &amp;&amp; heightIsAuto &amp;&amp; !replaced-&gt;hasIntrinsicWidth() &amp;&amp; replaced-&gt;hasIntrinsicHeight() &amp;&amp; replaced-&gt;hasIntrinsicRatio())
<span class="line-new-header">--- 926,30 ---</span>
      // 4. Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
      //
      // 5. Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;width&#39; becomes 300px.
      //    If 300px is too wide to fit the device, UAs should use the width of the largest rectangle that has a 2:1 ratio and fits the device instead.
  
<span class="line-modified">!     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
  
      auto usedMarginStart = [&amp;] {
<span class="line-modified">!         if (overrideHorizontalValues.margin)</span>
<span class="line-modified">!             return overrideHorizontalValues.margin-&gt;start;</span>
          return computedHorizontalMargin.start.valueOr(0_lu);
      };
  
      auto usedMarginEnd = [&amp;] {
<span class="line-modified">!         if (overrideHorizontalValues.margin)</span>
<span class="line-modified">!             return overrideHorizontalValues.margin-&gt;end;</span>
          return computedHorizontalMargin.end.valueOr(0_lu);
      };
  
      auto replaced = layoutBox.replaced();
      ASSERT(replaced);
  
<span class="line-modified">!     auto width = overrideHorizontalValues.width ? overrideHorizontalValues.width : computedContentWidth(layoutBox, horizontalConstraints.logicalWidth);</span>
      auto heightIsAuto = isHeightAuto(layoutBox);
<span class="line-modified">!     auto height = computedContentHeight(layoutBox);</span>
  
      if (!width &amp;&amp; heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicWidth()) {
          // #1
          width = replaced-&gt;intrinsicWidth();
      } else if ((!width &amp;&amp; heightIsAuto &amp;&amp; !replaced-&gt;hasIntrinsicWidth() &amp;&amp; replaced-&gt;hasIntrinsicHeight() &amp;&amp; replaced-&gt;hasIntrinsicRatio())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 952,11 ***</span>
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow replaced -&gt; width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedMarginStart() &lt;&lt; &quot;px, &quot; &lt;&lt; usedMarginEnd() &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
      return { *width, { usedMarginStart(), usedMarginEnd() }, computedHorizontalMargin };
  }
  
<span class="line-modified">! LayoutSize FormattingContext::Geometry::inFlowPositionedPositionOffset(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  {
      ASSERT(layoutBox.isInFlowPositioned());
  
      // 9.4.3 Relative positioning
      //
<span class="line-new-header">--- 972,11 ---</span>
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow replaced -&gt; width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedMarginStart() &lt;&lt; &quot;px, &quot; &lt;&lt; usedMarginEnd() &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
      return { *width, { usedMarginStart(), usedMarginEnd() }, computedHorizontalMargin };
  }
  
<span class="line-modified">! LayoutSize FormattingContext::Geometry::inFlowPositionedPositionOffset(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
  {
      ASSERT(layoutBox.isInFlowPositioned());
  
      // 9.4.3 Relative positioning
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 966,12 ***</span>
      // 1. If both are &#39;auto&#39;, their used values are both &#39;0&#39;.
      // 2. If one of them is &#39;auto&#39;, it becomes the negative of the other.
      // 3. If neither is &#39;auto&#39;, &#39;bottom&#39; is ignored (i.e., the used value of &#39;bottom&#39; will be minus the value of &#39;top&#39;).
  
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
<span class="line-removed">-     auto containingBlockWidth = layoutState.displayBoxForLayoutBox(containingBlock).contentBoxWidth();</span>
  
      auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
      auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
  
      if (!top &amp;&amp; !bottom) {
<span class="line-new-header">--- 986,11 ---</span>
      // 1. If both are &#39;auto&#39;, their used values are both &#39;0&#39;.
      // 2. If one of them is &#39;auto&#39;, it becomes the negative of the other.
      // 3. If neither is &#39;auto&#39;, &#39;bottom&#39; is ignored (i.e., the used value of &#39;bottom&#39; will be minus the value of &#39;top&#39;).
  
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
  
      auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
      auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
  
      if (!top &amp;&amp; !bottom) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1011,11 ***</span>
      } else if (!right) {
          // #3
          right = -*left;
      } else {
          // #4
<span class="line-modified">!         auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();</span>
          if (isLeftToRightDirection)
              right = -*left;
          else
              left = WTF::nullopt;
      }
<span class="line-new-header">--- 1030,11 ---</span>
      } else if (!right) {
          // #3
          right = -*left;
      } else {
          // #4
<span class="line-modified">!         auto isLeftToRightDirection = layoutBox.containingBlock()-&gt;style().isLeftToRightDirection();</span>
          if (isLeftToRightDirection)
              right = -*left;
          else
              left = WTF::nullopt;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1028,49 ***</span>
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position] -&gt; positioned inflow -&gt; top offset(&quot; &lt;&lt; topPositionOffset &lt;&lt; &quot;px) left offset(&quot; &lt;&lt; leftPositionOffset &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
      return { leftPositionOffset, topPositionOffset };
  }
  
<span class="line-modified">! Edges FormattingContext::Geometry::computedBorder(const Box&amp; layoutBox)</span>
  {
      auto&amp; style = layoutBox.style();
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Border] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
      return {
          { LayoutUnit(style.borderLeft().boxModelWidth()), LayoutUnit(style.borderRight().boxModelWidth()) },
          { LayoutUnit(style.borderTop().boxModelWidth()), LayoutUnit(style.borderBottom().boxModelWidth()) }
      };
  }
  
<span class="line-modified">! Optional&lt;Edges&gt; FormattingContext::Geometry::computedPadding(const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      if (!layoutBox.isPaddingApplicable())
          return WTF::nullopt;
  
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Padding] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
      return Edges {
          { valueForLength(style.paddingLeft(), containingBlockWidth), valueForLength(style.paddingRight(), containingBlockWidth) },
          { valueForLength(style.paddingTop(), containingBlockWidth), valueForLength(style.paddingBottom(), containingBlockWidth) }
      };
  }
  
<span class="line-modified">! ComputedHorizontalMargin FormattingContext::Geometry::computedHorizontalMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
      return { computedValueIfNotAuto(style.marginStart(), containingBlockWidth), computedValueIfNotAuto(style.marginEnd(), containingBlockWidth) };
  }
  
<span class="line-modified">! ComputedVerticalMargin FormattingContext::Geometry::computedVerticalMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
      return { computedValueIfNotAuto(style.marginBefore(), containingBlockWidth), computedValueIfNotAuto(style.marginAfter(), containingBlockWidth) };
  }
  
<span class="line-modified">! FormattingContext::IntrinsicWidthConstraints FormattingContext::Geometry::constrainByMinMaxWidth(const Box&amp; layoutBox, IntrinsicWidthConstraints intrinsicWidth)</span>
  {
      auto&amp; style = layoutBox.style();
      auto minWidth = fixedValue(style.logicalMinWidth());
      auto maxWidth = fixedValue(style.logicalMaxWidth());
      if (!minWidth &amp;&amp; !maxWidth)
<span class="line-new-header">--- 1047,49 ---</span>
  
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position] -&gt; positioned inflow -&gt; top offset(&quot; &lt;&lt; topPositionOffset &lt;&lt; &quot;px) left offset(&quot; &lt;&lt; leftPositionOffset &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
      return { leftPositionOffset, topPositionOffset };
  }
  
<span class="line-modified">! Edges FormattingContext::Geometry::computedBorder(const Box&amp; layoutBox) const</span>
  {
      auto&amp; style = layoutBox.style();
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Border] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
      return {
          { LayoutUnit(style.borderLeft().boxModelWidth()), LayoutUnit(style.borderRight().boxModelWidth()) },
          { LayoutUnit(style.borderTop().boxModelWidth()), LayoutUnit(style.borderBottom().boxModelWidth()) }
      };
  }
  
<span class="line-modified">! Optional&lt;Edges&gt; FormattingContext::Geometry::computedPadding(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
  {
      if (!layoutBox.isPaddingApplicable())
          return WTF::nullopt;
  
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Padding] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
      return Edges {
          { valueForLength(style.paddingLeft(), containingBlockWidth), valueForLength(style.paddingRight(), containingBlockWidth) },
          { valueForLength(style.paddingTop(), containingBlockWidth), valueForLength(style.paddingBottom(), containingBlockWidth) }
      };
  }
  
<span class="line-modified">! ComputedHorizontalMargin FormattingContext::Geometry::computedHorizontalMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
  {
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
      return { computedValueIfNotAuto(style.marginStart(), containingBlockWidth), computedValueIfNotAuto(style.marginEnd(), containingBlockWidth) };
  }
  
<span class="line-modified">! ComputedVerticalMargin FormattingContext::Geometry::computedVerticalMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
  {
      auto&amp; style = layoutBox.style();
<span class="line-modified">!     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
      return { computedValueIfNotAuto(style.marginBefore(), containingBlockWidth), computedValueIfNotAuto(style.marginAfter(), containingBlockWidth) };
  }
  
<span class="line-modified">! FormattingContext::IntrinsicWidthConstraints FormattingContext::Geometry::constrainByMinMaxWidth(const Box&amp; layoutBox, IntrinsicWidthConstraints intrinsicWidth) const</span>
  {
      auto&amp; style = layoutBox.style();
      auto minWidth = fixedValue(style.logicalMinWidth());
      auto maxWidth = fixedValue(style.logicalMaxWidth());
      if (!minWidth &amp;&amp; !maxWidth)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1088,8 ***</span>
<span class="line-new-header">--- 1107,28 ---</span>
  
      ASSERT(intrinsicWidth.minimum &lt;= intrinsicWidth.maximum);
      return intrinsicWidth;
  }
  
<span class="line-added">+ HorizontalConstraints FormattingContext::Geometry::horizontalConstraintsForOutOfFlow(const Display::Box&amp; containingBlockGeometry)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return HorizontalConstraints { containingBlockGeometry.paddingBoxLeft(), containingBlockGeometry.paddingBoxWidth() };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ VerticalConstraints FormattingContext::Geometry::verticalConstraintsForOutOfFlow(const Display::Box&amp; containingBlockGeometry)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return VerticalConstraints { containingBlockGeometry.paddingBoxTop(), containingBlockGeometry.paddingBoxHeight() };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ HorizontalConstraints FormattingContext::Geometry::horizontalConstraintsForInFlow(const Display::Box&amp; containingBlockGeometry)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return HorizontalConstraints { containingBlockGeometry.contentBoxLeft(), containingBlockGeometry.contentBoxWidth() };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ VerticalConstraints FormattingContext::Geometry::verticalConstraintsForInFlow(const Display::Box&amp; containingBlockGeometry)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return VerticalConstraints { containingBlockGeometry.contentBoxTop(), { } };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  }
  }
  #endif
</pre>
<center><a href="FormattingContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FormattingContextQuirks.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGConstantFoldingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGCompilationKey.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGDesiredGlobalProperties.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGConstantFoldingPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGConstantFoldingPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;DFGAbstractInterpreterInlines.h&quot;
  33 #include &quot;DFGArgumentsUtilities.h&quot;
  34 #include &quot;DFGBasicBlockInlines.h&quot;
  35 #include &quot;DFGGraph.h&quot;
  36 #include &quot;DFGInPlaceAbstractState.h&quot;
  37 #include &quot;DFGInsertionSet.h&quot;
  38 #include &quot;DFGPhase.h&quot;
<span class="line-modified">  39 #include &quot;GetByIdStatus.h&quot;</span>
  40 #include &quot;JSCInlines.h&quot;
  41 #include &quot;PutByIdStatus.h&quot;
  42 #include &quot;StructureCache.h&quot;
  43 
  44 namespace JSC { namespace DFG {
  45 
  46 class ConstantFoldingPhase : public Phase {
  47 public:
  48     ConstantFoldingPhase(Graph&amp; graph)
  49         : Phase(graph, &quot;constant folding&quot;)
  50         , m_state(graph)
  51         , m_interpreter(graph, m_state)
  52         , m_insertionSet(graph)
  53     {
  54     }
  55 
  56     bool run()
  57     {
  58         bool changed = false;
  59 
  60         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
<span class="line-modified">  61             if (block-&gt;cfaFoundConstants)</span>
  62                 changed |= foldConstants(block);
  63         }
  64 
  65         if (changed &amp;&amp; m_graph.m_form == SSA) {
  66             // It&#39;s now possible that we have Upsilons pointed at JSConstants. Fix that.
  67             for (BasicBlock* block : m_graph.blocksInNaturalOrder())
  68                 fixUpsilons(block);
  69         }
  70 
  71         if (m_graph.m_form == SSA) {
  72             // It&#39;s now possible to simplify basic blocks by placing an Unreachable terminator right
  73             // after anything that invalidates AI.
  74             bool didClipBlock = false;
  75             Vector&lt;Node*&gt; nodesToDelete;
  76             for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
  77                 m_state.beginBasicBlock(block);
  78                 for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
  79                     if (block-&gt;at(nodeIndex)-&gt;isTerminal()) {
  80                         // It&#39;s possible that we have something after the terminal. It could be a
  81                         // no-op Check node, for example. We don&#39;t want the logic below to turn that
</pre>
<hr />
<pre>
 259                     bool allGood = true;
 260                     phiChildren-&gt;forAllTransitiveIncomingValues(
 261                         node,
 262                         [&amp;] (Node* incoming) {
 263                             if (Structure* structure = incoming-&gt;dynamicCastConstant&lt;Structure*&gt;(m_graph.m_vm)) {
 264                                 if (set.contains(m_graph.registerStructure(structure)))
 265                                     return;
 266                             }
 267                             allGood = false;
 268                         });
 269                     if (allGood) {
 270                         m_interpreter.execute(indexInBlock);
 271                         node-&gt;remove(m_graph);
 272                         eliminated = true;
 273                         break;
 274                     }
 275                 }
 276                 break;
 277             }
 278 













 279             case CheckArray:
 280             case Arrayify: {
 281                 if (!node-&gt;arrayMode().alreadyChecked(m_graph, node, m_state.forNode(node-&gt;child1())))
 282                     break;
 283                 node-&gt;remove(m_graph);
 284                 eliminated = true;
 285                 break;
 286             }
 287 
 288             case PutStructure: {
 289                 if (m_state.forNode(node-&gt;child1()).m_structure.onlyStructure() != node-&gt;transition()-&gt;next)
 290                     break;
 291 
 292                 node-&gt;remove(m_graph);
 293                 eliminated = true;
 294                 break;
 295             }
 296 
 297             case CheckCell: {
 298                 if (m_state.forNode(node-&gt;child1()).value() != node-&gt;cellOperand()-&gt;value())
 299                     break;
 300                 node-&gt;remove(m_graph);
 301                 eliminated = true;
 302                 break;
 303             }
 304 
 305             case AssertNotEmpty:
 306             case CheckNotEmpty: {
 307                 if (m_state.forNode(node-&gt;child1()).m_type &amp; SpecEmpty)
 308                     break;
 309                 node-&gt;remove(m_graph);
 310                 eliminated = true;
 311                 break;
 312             }
 313 
<span class="line-modified"> 314             case CheckStringIdent: {</span>
 315                 UniquedStringImpl* uid = node-&gt;uidOperand();
 316                 const UniquedStringImpl* constantUid = nullptr;
 317 
 318                 JSValue childConstant = m_state.forNode(node-&gt;child1()).value();
 319                 if (childConstant) {
 320                     if (childConstant.isString()) {
 321                         if (const auto* impl = asString(childConstant)-&gt;tryGetValueImpl()) {
 322                             // Edge filtering requires that a value here should be StringIdent.
 323                             // However, a constant value propagated in DFG is not filtered.
 324                             // So here, we check the propagated value is actually an atomic string.
 325                             // And if it&#39;s not, we just ignore.
 326                             if (impl-&gt;isAtom())
 327                                 constantUid = static_cast&lt;const UniquedStringImpl*&gt;(impl);
 328                         }



 329                     }
 330                 }
 331 
 332                 if (constantUid == uid) {
 333                     node-&gt;remove(m_graph);
 334                     eliminated = true;
 335                 }
 336                 break;
 337             }
 338 
 339             case CheckInBounds: {
 340                 JSValue left = m_state.forNode(node-&gt;child1()).value();
 341                 JSValue right = m_state.forNode(node-&gt;child2()).value();
 342                 if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()
 343                     &amp;&amp; static_cast&lt;uint32_t&gt;(left.asInt32()) &lt; static_cast&lt;uint32_t&gt;(right.asInt32())) {
 344 
 345                     Node* zero = m_insertionSet.insertConstant(indexInBlock, node-&gt;origin, jsNumber(0));
 346                     node-&gt;convertToIdentityOn(zero);
 347                     eliminated = true;
 348                     break;
</pre>
<hr />
<pre>
 363                     break;
 364 
 365                 unsigned index = checkedIndex.unsafeGet();
 366                 Node* arguments = node-&gt;child1().node();
 367                 InlineCallFrame* inlineCallFrame = arguments-&gt;origin.semantic.inlineCallFrame();
 368 
 369                 // Don&#39;t try to do anything if the index is known to be outside our static bounds. Note
 370                 // that our static bounds are usually strictly larger than the dynamic bounds. The
 371                 // exception is something like this, assuming foo() is not inlined:
 372                 //
 373                 // function foo() { return arguments[5]; }
 374                 //
 375                 // Here the static bound on number of arguments is 0, and we&#39;re accessing index 5. We
 376                 // will not strength-reduce this to GetStack because GetStack is otherwise assumed by the
 377                 // compiler to access those variables that are statically accounted for; for example if
 378                 // we emitted a GetStack on arg6 we would have out-of-bounds access crashes anywhere that
 379                 // uses an Operands&lt;&gt; map. There is not much cost to continuing to use a
 380                 // GetMyArgumentByVal in such statically-out-of-bounds accesses; we just lose CFA unless
 381                 // GCSE removes the access entirely.
 382                 if (inlineCallFrame) {
<span class="line-modified"> 383                     if (index &gt;= inlineCallFrame-&gt;argumentCountIncludingThis - 1)</span>
 384                         break;
 385                 } else {
 386                     if (index &gt;= m_state.numberOfArguments() - 1)
 387                         break;
 388                 }
 389 
 390                 m_interpreter.execute(indexInBlock); // Push CFA over this node after we get the state before.
 391 
 392                 StackAccessData* data;
 393                 if (inlineCallFrame) {
 394                     data = m_graph.m_stackAccessData.add(
 395                         VirtualRegister(
 396                             inlineCallFrame-&gt;stackOffset +
 397                             CallFrame::argumentOffset(index)),
 398                         FlushedJSValue);
 399                 } else {
 400                     data = m_graph.m_stackAccessData.add(
<span class="line-modified"> 401                         virtualRegisterForArgument(index + 1), FlushedJSValue);</span>
 402                 }
 403 
<span class="line-modified"> 404                 if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs() &amp;&amp; index &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1) {</span>
 405                     node-&gt;convertToGetStack(data);
 406                     eliminated = true;
 407                     break;
 408                 }
 409 
 410                 if (node-&gt;op() == GetMyArgumentByValOutOfBounds)
 411                     break;
 412 
 413                 Node* length = emitCodeToGetArgumentsArrayLength(
 414                     m_insertionSet, arguments, indexInBlock, node-&gt;origin);
 415                 Node* check = m_insertionSet.insertNode(
 416                     indexInBlock, SpecNone, CheckInBounds, node-&gt;origin,
 417                     node-&gt;child2(), Edge(length, Int32Use));
 418                 node-&gt;convertToGetStack(data);
 419                 node-&gt;child1() = Edge(check, UntypedUse);
 420                 eliminated = true;
 421                 break;
 422             }
 423 
 424             case MultiGetByOffset: {
</pre>
<hr />
<pre>
 529                 break;
 530             }
 531 
 532             case GetByIdDirect:
 533             case GetByIdDirectFlush:
 534             case GetById:
 535             case GetByIdFlush: {
 536                 Edge childEdge = node-&gt;child1();
 537                 Node* child = childEdge.node();
 538                 unsigned identifierNumber = node-&gt;identifierNumber();
 539 
 540                 AbstractValue baseValue = m_state.forNode(child);
 541 
 542                 m_interpreter.execute(indexInBlock); // Push CFA over this node after we get the state before.
 543                 alreadyHandled = true; // Don&#39;t allow the default constant folder to do things to this.
 544 
 545                 if (!baseValue.m_structure.isFinite()
 546                     || (node-&gt;child1().useKind() == UntypedUse || (baseValue.m_type &amp; ~SpecCell)))
 547                     break;
 548 
<span class="line-modified"> 549                 GetByIdStatus status = GetByIdStatus::computeFor(</span>
 550                     baseValue.m_structure.toStructureSet(), m_graph.identifiers()[identifierNumber]);
 551                 if (!status.isSimple())
 552                     break;
 553 
 554                 for (unsigned i = status.numVariants(); i--;) {
 555                     if (!status[i].conditionSet().isEmpty()) {
 556                         // FIXME: We could handle prototype cases.
 557                         // https://bugs.webkit.org/show_bug.cgi?id=110386
 558                         break;
 559                     }
 560                 }
 561 
 562                 auto addFilterStatus = [&amp;] () {
 563                     m_insertionSet.insertNode(
<span class="line-modified"> 564                         indexInBlock, SpecNone, FilterGetByIdStatus, node-&gt;origin,</span>
<span class="line-modified"> 565                         OpInfo(m_graph.m_plan.recordedStatuses().addGetByIdStatus(node-&gt;origin.semantic, status)),</span>
 566                         Edge(child));
 567                 };
 568 
 569                 if (status.numVariants() == 1) {
 570                     addFilterStatus();
 571                     emitGetByOffset(indexInBlock, node, baseValue, status[0], identifierNumber);
 572                     changed = true;
 573                     break;
 574                 }
 575 
 576                 if (!m_graph.m_plan.isFTL())
 577                     break;
 578 
 579                 addFilterStatus();
 580                 MultiGetByOffsetData* data = m_graph.m_multiGetByOffsetData.add();
 581                 for (const GetByIdVariant&amp; variant : status.variants()) {
 582                     data-&gt;cases.append(
 583                         MultiGetByOffsetCase(
 584                             *m_graph.addStructureSet(variant.structureSet()),
 585                             GetByOffsetMethod::load(variant.offset())));
 586                 }
 587                 data-&gt;identifierNumber = identifierNumber;
 588                 node-&gt;convertToMultiGetByOffset(data);
 589                 changed = true;
 590                 break;
 591             }
 592 
 593             case PutById:
 594             case PutByIdDirect:
 595             case PutByIdFlush: {
 596                 NodeOrigin origin = node-&gt;origin;
 597                 Edge childEdge = node-&gt;child1();
 598                 Node* child = childEdge.node();
 599                 unsigned identifierNumber = node-&gt;identifierNumber();
 600 
 601                 ASSERT(childEdge.useKind() == CellUse);
 602 
 603                 AbstractValue baseValue = m_state.forNode(child);
 604                 AbstractValue valueValue = m_state.forNode(node-&gt;child2());
 605 
<span class="line-removed"> 606                 m_interpreter.execute(indexInBlock); // Push CFA over this node after we get the state before.</span>
<span class="line-removed"> 607                 alreadyHandled = true; // Don&#39;t allow the default constant folder to do things to this.</span>
<span class="line-removed"> 608 </span>
 609                 if (!baseValue.m_structure.isFinite())
 610                     break;
 611 
 612                 PutByIdStatus status = PutByIdStatus::computeFor(
 613                     m_graph.globalObjectFor(origin.semantic),
 614                     baseValue.m_structure.toStructureSet(),
 615                     m_graph.identifiers()[identifierNumber],
 616                     node-&gt;op() == PutByIdDirect);
 617 
 618                 if (!status.isSimple())
 619                     break;
 620 
 621                 ASSERT(status.numVariants());
 622 
 623                 if (status.numVariants() &gt; 1 &amp;&amp; !m_graph.m_plan.isFTL())
 624                     break;
 625 
 626                 changed = true;
 627 
 628                 bool allGood = true;


 629                 for (const PutByIdVariant&amp; variant : status.variants()) {
<span class="line-removed"> 630                     if (!allGood)</span>
<span class="line-removed"> 631                         break;</span>
 632                     for (const ObjectPropertyCondition&amp; condition : variant.conditionSet()) {
 633                         if (m_graph.watchCondition(condition))
 634                             continue;
 635 
 636                         Structure* structure = condition.object()-&gt;structure(m_graph.m_vm);
 637                         if (!condition.structureEnsuresValidity(structure)) {
 638                             allGood = false;
 639                             break;
 640                         }
 641 
 642                         m_insertionSet.insertNode(
 643                             indexInBlock, SpecNone, CheckStructure, node-&gt;origin,
 644                             OpInfo(m_graph.addStructureSet(structure)),
 645                             m_insertionSet.insertConstantForUse(
 646                                 indexInBlock, node-&gt;origin, condition.object(), KnownCellUse));
 647                     }














 648                 }
 649 
 650                 if (!allGood)
 651                     break;
 652 








 653                 m_insertionSet.insertNode(
 654                     indexInBlock, SpecNone, FilterPutByIdStatus, node-&gt;origin,
 655                     OpInfo(m_graph.m_plan.recordedStatuses().addPutByIdStatus(node-&gt;origin.semantic, status)),
 656                     Edge(child));
 657 
 658                 if (status.numVariants() == 1) {
 659                     emitPutByOffset(indexInBlock, node, baseValue, status[0], identifierNumber);
 660                     break;
 661                 }
 662 
 663                 ASSERT(m_graph.m_plan.isFTL());
 664 
 665                 MultiPutByOffsetData* data = m_graph.m_multiPutByOffsetData.add();
 666                 data-&gt;variants = status.variants();
 667                 data-&gt;identifierNumber = identifierNumber;
 668                 node-&gt;convertToMultiPutByOffset(data);
 669                 break;
 670             }
 671 
 672             case InByVal: {
</pre>
<hr />
<pre>
 678                         if (impl &amp;&amp; impl-&gt;isAtom()) {
 679                             unsigned identifierNumber = m_graph.identifiers().ensure(const_cast&lt;UniquedStringImpl*&gt;(static_cast&lt;const UniquedStringImpl*&gt;(impl)));
 680                             node-&gt;convertToInById(identifierNumber);
 681                             changed = true;
 682                             break;
 683                         }
 684                     }
 685                 }
 686                 break;
 687             }
 688 
 689             case ToPrimitive: {
 690                 if (m_state.forNode(node-&gt;child1()).m_type &amp; ~(SpecFullNumber | SpecBoolean | SpecString | SpecSymbol | SpecBigInt))
 691                     break;
 692 
 693                 node-&gt;convertToIdentity();
 694                 changed = true;
 695                 break;
 696             }
 697 









 698             case ToThis: {
 699                 ToThisResult result = isToThisAnIdentity(m_graph.m_vm, m_graph.isStrictModeFor(node-&gt;origin.semantic), m_state.forNode(node-&gt;child1()));
 700                 if (result == ToThisResult::Identity) {
 701                     node-&gt;convertToIdentity();
 702                     changed = true;
 703                     break;
 704                 }
 705                 if (result == ToThisResult::GlobalThis) {
 706                     node-&gt;convertToGetGlobalThis();
 707                     changed = true;
 708                     break;
 709                 }
 710                 break;
 711             }
 712 
 713             case CreateThis: {
 714                 if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {
 715                     if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {
 716                         if (FunctionRareData* rareData = function-&gt;rareData()) {
 717                             if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {
</pre>
<hr />
<pre>
 732                                         NodeOrigin origin = node-&gt;origin.withInvalidExit();
 733                                         Node* prototypeNode = m_insertionSet.insertConstant(
 734                                             indexInBlock + 1, origin, m_graph.freeze(prototype));
 735 
 736                                         ASSERT(isInlineOffset(knownPolyProtoOffset));
 737                                         m_insertionSet.insertNode(
 738                                             indexInBlock + 1, SpecNone, PutByOffset, origin, OpInfo(data),
 739                                             Edge(node, KnownCellUse), Edge(node, KnownCellUse), Edge(prototypeNode, UntypedUse));
 740                                     }
 741                                     changed = true;
 742                                     break;
 743 
 744                                 }
 745                             }
 746                         }
 747                     }
 748                 }
 749                 break;
 750             }
 751 




































































 752             case ObjectCreate: {
 753                 if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {
 754                     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
 755                     Structure* structure = nullptr;
 756                     if (base.isNull())
 757                         structure = globalObject-&gt;nullPrototypeObjectStructure();
 758                     else if (base.isObject())
 759                         structure = globalObject-&gt;vm().structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());
 760 
 761                     if (structure) {
 762                         node-&gt;convertToNewObject(m_graph.registerStructure(structure));
 763                         changed = true;
 764                         break;
 765                     }
 766                 }
 767                 break;
 768             }
 769 
 770             case ObjectKeys: {
 771                 if (node-&gt;child1().useKind() == ObjectUse) {
 772                     auto&amp; structureSet = m_state.forNode(node-&gt;child1()).m_structure;
 773                     if (structureSet.isFinite() &amp;&amp; structureSet.size() == 1) {
 774                         RegisteredStructure structure = structureSet.onlyStructure();
 775                         if (auto* rareData = structure-&gt;rareDataConcurrently()) {
 776                             if (auto* immutableButterfly = rareData-&gt;cachedOwnKeysConcurrently()) {
 777                                 if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
 778                                     node-&gt;convertToNewArrayBuffer(m_graph.freeze(immutableButterfly));
 779                                     changed = true;
 780                                     break;
 781                                 }
 782                             }
 783                         }
 784                     }
 785                 }
 786                 break;
 787             }
 788 




















 789             case ToNumber: {
 790                 if (m_state.forNode(node-&gt;child1()).m_type &amp; ~SpecBytecodeNumber)
 791                     break;
 792 
 793                 node-&gt;convertToIdentity();
 794                 changed = true;
 795                 break;
 796             }
 797 









 798             case NormalizeMapKey: {
 799                 SpeculatedType typeMaybeNormalized = (SpecFullNumber &amp; ~SpecInt32Only);
 800                 if (m_state.forNode(node-&gt;child1()).m_type &amp; typeMaybeNormalized)
 801                     break;
 802 
 803                 node-&gt;convertToIdentity();
 804                 changed = true;
 805                 break;
 806             }
 807 
 808             case ParseInt: {
 809                 AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
 810                 if (!value.m_type || (value.m_type &amp; ~SpecInt32Only))
 811                     break;
 812 
 813                 JSValue radix;
 814                 if (!node-&gt;child2())
 815                     radix = jsNumber(0);
 816                 else
 817                     radix = m_state.forNode(node-&gt;child2()).m_value;
</pre>
<hr />
<pre>
 938                 if (abstractValue.m_structure.isFinite()) {
 939                     bool ok = true;
 940                     abstractValue.m_structure.forEach([&amp;] (RegisteredStructure structure) {
 941                         ok &amp;= (structure-&gt;typeInfo().inlineTypeFlags() &amp; bits) == bits;
 942                     });
 943                     if (ok) {
 944                         eliminated = true;
 945                         node-&gt;remove(m_graph);
 946                         break;
 947                     }
 948                 }
 949 
 950                 break;
 951             }
 952 
 953             case PhantomNewObject:
 954             case PhantomNewFunction:
 955             case PhantomNewGeneratorFunction:
 956             case PhantomNewAsyncGeneratorFunction:
 957             case PhantomNewAsyncFunction:

 958             case PhantomCreateActivation:
 959             case PhantomDirectArguments:
 960             case PhantomClonedArguments:
 961             case PhantomCreateRest:
 962             case PhantomSpread:
 963             case PhantomNewArrayWithSpread:
 964             case PhantomNewArrayBuffer:
 965             case PhantomNewRegexp:
 966             case BottomValue:
 967                 alreadyHandled = true;
 968                 break;
 969 
 970             default:
 971                 break;
 972             }
 973 
 974             if (eliminated) {
 975                 changed = true;
 976                 continue;
 977             }
</pre>
</td>
<td>
<hr />
<pre>
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGConstantFoldingPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;DFGAbstractInterpreterInlines.h&quot;
  33 #include &quot;DFGArgumentsUtilities.h&quot;
  34 #include &quot;DFGBasicBlockInlines.h&quot;
  35 #include &quot;DFGGraph.h&quot;
  36 #include &quot;DFGInPlaceAbstractState.h&quot;
  37 #include &quot;DFGInsertionSet.h&quot;
  38 #include &quot;DFGPhase.h&quot;
<span class="line-modified">  39 #include &quot;GetByStatus.h&quot;</span>
  40 #include &quot;JSCInlines.h&quot;
  41 #include &quot;PutByIdStatus.h&quot;
  42 #include &quot;StructureCache.h&quot;
  43 
  44 namespace JSC { namespace DFG {
  45 
  46 class ConstantFoldingPhase : public Phase {
  47 public:
  48     ConstantFoldingPhase(Graph&amp; graph)
  49         : Phase(graph, &quot;constant folding&quot;)
  50         , m_state(graph)
  51         , m_interpreter(graph, m_state)
  52         , m_insertionSet(graph)
  53     {
  54     }
  55 
  56     bool run()
  57     {
  58         bool changed = false;
  59 
  60         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
<span class="line-modified">  61             if (block-&gt;cfaThinksShouldTryConstantFolding)</span>
  62                 changed |= foldConstants(block);
  63         }
  64 
  65         if (changed &amp;&amp; m_graph.m_form == SSA) {
  66             // It&#39;s now possible that we have Upsilons pointed at JSConstants. Fix that.
  67             for (BasicBlock* block : m_graph.blocksInNaturalOrder())
  68                 fixUpsilons(block);
  69         }
  70 
  71         if (m_graph.m_form == SSA) {
  72             // It&#39;s now possible to simplify basic blocks by placing an Unreachable terminator right
  73             // after anything that invalidates AI.
  74             bool didClipBlock = false;
  75             Vector&lt;Node*&gt; nodesToDelete;
  76             for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
  77                 m_state.beginBasicBlock(block);
  78                 for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
  79                     if (block-&gt;at(nodeIndex)-&gt;isTerminal()) {
  80                         // It&#39;s possible that we have something after the terminal. It could be a
  81                         // no-op Check node, for example. We don&#39;t want the logic below to turn that
</pre>
<hr />
<pre>
 259                     bool allGood = true;
 260                     phiChildren-&gt;forAllTransitiveIncomingValues(
 261                         node,
 262                         [&amp;] (Node* incoming) {
 263                             if (Structure* structure = incoming-&gt;dynamicCastConstant&lt;Structure*&gt;(m_graph.m_vm)) {
 264                                 if (set.contains(m_graph.registerStructure(structure)))
 265                                     return;
 266                             }
 267                             allGood = false;
 268                         });
 269                     if (allGood) {
 270                         m_interpreter.execute(indexInBlock);
 271                         node-&gt;remove(m_graph);
 272                         eliminated = true;
 273                         break;
 274                     }
 275                 }
 276                 break;
 277             }
 278 
<span class="line-added"> 279             case CheckArrayOrEmpty: {</span>
<span class="line-added"> 280                 const AbstractValue&amp; value = m_state.forNode(node-&gt;child1());</span>
<span class="line-added"> 281                 if (!(value.m_type &amp; SpecEmpty)) {</span>
<span class="line-added"> 282                     node-&gt;convertCheckArrayOrEmptyToCheckArray();</span>
<span class="line-added"> 283                     changed = true;</span>
<span class="line-added"> 284                 }</span>
<span class="line-added"> 285                 // Even if the input includes SpecEmpty, we can fall through to CheckArray and remove the node.</span>
<span class="line-added"> 286                 // CheckArrayOrEmpty can be removed when arrayMode meets the requirement. In that case, CellUse&#39;s</span>
<span class="line-added"> 287                 // check just remains, and it works as CheckArrayOrEmpty without ArrayMode checking.</span>
<span class="line-added"> 288                 ASSERT(typeFilterFor(node-&gt;child1().useKind()) &amp; SpecEmpty);</span>
<span class="line-added"> 289                 FALLTHROUGH;</span>
<span class="line-added"> 290             }</span>
<span class="line-added"> 291 </span>
 292             case CheckArray:
 293             case Arrayify: {
 294                 if (!node-&gt;arrayMode().alreadyChecked(m_graph, node, m_state.forNode(node-&gt;child1())))
 295                     break;
 296                 node-&gt;remove(m_graph);
 297                 eliminated = true;
 298                 break;
 299             }
 300 
 301             case PutStructure: {
 302                 if (m_state.forNode(node-&gt;child1()).m_structure.onlyStructure() != node-&gt;transition()-&gt;next)
 303                     break;
 304 
 305                 node-&gt;remove(m_graph);
 306                 eliminated = true;
 307                 break;
 308             }
 309 
 310             case CheckCell: {
 311                 if (m_state.forNode(node-&gt;child1()).value() != node-&gt;cellOperand()-&gt;value())
 312                     break;
 313                 node-&gt;remove(m_graph);
 314                 eliminated = true;
 315                 break;
 316             }
 317 
 318             case AssertNotEmpty:
 319             case CheckNotEmpty: {
 320                 if (m_state.forNode(node-&gt;child1()).m_type &amp; SpecEmpty)
 321                     break;
 322                 node-&gt;remove(m_graph);
 323                 eliminated = true;
 324                 break;
 325             }
 326 
<span class="line-modified"> 327             case CheckIdent: {</span>
 328                 UniquedStringImpl* uid = node-&gt;uidOperand();
 329                 const UniquedStringImpl* constantUid = nullptr;
 330 
 331                 JSValue childConstant = m_state.forNode(node-&gt;child1()).value();
 332                 if (childConstant) {
 333                     if (childConstant.isString()) {
 334                         if (const auto* impl = asString(childConstant)-&gt;tryGetValueImpl()) {
 335                             // Edge filtering requires that a value here should be StringIdent.
 336                             // However, a constant value propagated in DFG is not filtered.
 337                             // So here, we check the propagated value is actually an atomic string.
 338                             // And if it&#39;s not, we just ignore.
 339                             if (impl-&gt;isAtom())
 340                                 constantUid = static_cast&lt;const UniquedStringImpl*&gt;(impl);
 341                         }
<span class="line-added"> 342                     } else if (childConstant.isSymbol()) {</span>
<span class="line-added"> 343                         Symbol* symbol = jsCast&lt;Symbol*&gt;(childConstant);</span>
<span class="line-added"> 344                         constantUid = &amp;symbol-&gt;uid();</span>
 345                     }
 346                 }
 347 
 348                 if (constantUid == uid) {
 349                     node-&gt;remove(m_graph);
 350                     eliminated = true;
 351                 }
 352                 break;
 353             }
 354 
 355             case CheckInBounds: {
 356                 JSValue left = m_state.forNode(node-&gt;child1()).value();
 357                 JSValue right = m_state.forNode(node-&gt;child2()).value();
 358                 if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()
 359                     &amp;&amp; static_cast&lt;uint32_t&gt;(left.asInt32()) &lt; static_cast&lt;uint32_t&gt;(right.asInt32())) {
 360 
 361                     Node* zero = m_insertionSet.insertConstant(indexInBlock, node-&gt;origin, jsNumber(0));
 362                     node-&gt;convertToIdentityOn(zero);
 363                     eliminated = true;
 364                     break;
</pre>
<hr />
<pre>
 379                     break;
 380 
 381                 unsigned index = checkedIndex.unsafeGet();
 382                 Node* arguments = node-&gt;child1().node();
 383                 InlineCallFrame* inlineCallFrame = arguments-&gt;origin.semantic.inlineCallFrame();
 384 
 385                 // Don&#39;t try to do anything if the index is known to be outside our static bounds. Note
 386                 // that our static bounds are usually strictly larger than the dynamic bounds. The
 387                 // exception is something like this, assuming foo() is not inlined:
 388                 //
 389                 // function foo() { return arguments[5]; }
 390                 //
 391                 // Here the static bound on number of arguments is 0, and we&#39;re accessing index 5. We
 392                 // will not strength-reduce this to GetStack because GetStack is otherwise assumed by the
 393                 // compiler to access those variables that are statically accounted for; for example if
 394                 // we emitted a GetStack on arg6 we would have out-of-bounds access crashes anywhere that
 395                 // uses an Operands&lt;&gt; map. There is not much cost to continuing to use a
 396                 // GetMyArgumentByVal in such statically-out-of-bounds accesses; we just lose CFA unless
 397                 // GCSE removes the access entirely.
 398                 if (inlineCallFrame) {
<span class="line-modified"> 399                     if (index &gt;= static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1))</span>
 400                         break;
 401                 } else {
 402                     if (index &gt;= m_state.numberOfArguments() - 1)
 403                         break;
 404                 }
 405 
 406                 m_interpreter.execute(indexInBlock); // Push CFA over this node after we get the state before.
 407 
 408                 StackAccessData* data;
 409                 if (inlineCallFrame) {
 410                     data = m_graph.m_stackAccessData.add(
 411                         VirtualRegister(
 412                             inlineCallFrame-&gt;stackOffset +
 413                             CallFrame::argumentOffset(index)),
 414                         FlushedJSValue);
 415                 } else {
 416                     data = m_graph.m_stackAccessData.add(
<span class="line-modified"> 417                         virtualRegisterForArgumentIncludingThis(index + 1), FlushedJSValue);</span>
 418                 }
 419 
<span class="line-modified"> 420                 if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs() &amp;&amp; index &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1)) {</span>
 421                     node-&gt;convertToGetStack(data);
 422                     eliminated = true;
 423                     break;
 424                 }
 425 
 426                 if (node-&gt;op() == GetMyArgumentByValOutOfBounds)
 427                     break;
 428 
 429                 Node* length = emitCodeToGetArgumentsArrayLength(
 430                     m_insertionSet, arguments, indexInBlock, node-&gt;origin);
 431                 Node* check = m_insertionSet.insertNode(
 432                     indexInBlock, SpecNone, CheckInBounds, node-&gt;origin,
 433                     node-&gt;child2(), Edge(length, Int32Use));
 434                 node-&gt;convertToGetStack(data);
 435                 node-&gt;child1() = Edge(check, UntypedUse);
 436                 eliminated = true;
 437                 break;
 438             }
 439 
 440             case MultiGetByOffset: {
</pre>
<hr />
<pre>
 545                 break;
 546             }
 547 
 548             case GetByIdDirect:
 549             case GetByIdDirectFlush:
 550             case GetById:
 551             case GetByIdFlush: {
 552                 Edge childEdge = node-&gt;child1();
 553                 Node* child = childEdge.node();
 554                 unsigned identifierNumber = node-&gt;identifierNumber();
 555 
 556                 AbstractValue baseValue = m_state.forNode(child);
 557 
 558                 m_interpreter.execute(indexInBlock); // Push CFA over this node after we get the state before.
 559                 alreadyHandled = true; // Don&#39;t allow the default constant folder to do things to this.
 560 
 561                 if (!baseValue.m_structure.isFinite()
 562                     || (node-&gt;child1().useKind() == UntypedUse || (baseValue.m_type &amp; ~SpecCell)))
 563                     break;
 564 
<span class="line-modified"> 565                 GetByStatus status = GetByStatus::computeFor(</span>
 566                     baseValue.m_structure.toStructureSet(), m_graph.identifiers()[identifierNumber]);
 567                 if (!status.isSimple())
 568                     break;
 569 
 570                 for (unsigned i = status.numVariants(); i--;) {
 571                     if (!status[i].conditionSet().isEmpty()) {
 572                         // FIXME: We could handle prototype cases.
 573                         // https://bugs.webkit.org/show_bug.cgi?id=110386
 574                         break;
 575                     }
 576                 }
 577 
 578                 auto addFilterStatus = [&amp;] () {
 579                     m_insertionSet.insertNode(
<span class="line-modified"> 580                         indexInBlock, SpecNone, FilterGetByStatus, node-&gt;origin,</span>
<span class="line-modified"> 581                         OpInfo(m_graph.m_plan.recordedStatuses().addGetByStatus(node-&gt;origin.semantic, status)),</span>
 582                         Edge(child));
 583                 };
 584 
 585                 if (status.numVariants() == 1) {
 586                     addFilterStatus();
 587                     emitGetByOffset(indexInBlock, node, baseValue, status[0], identifierNumber);
 588                     changed = true;
 589                     break;
 590                 }
 591 
 592                 if (!m_graph.m_plan.isFTL())
 593                     break;
 594 
 595                 addFilterStatus();
 596                 MultiGetByOffsetData* data = m_graph.m_multiGetByOffsetData.add();
 597                 for (const GetByIdVariant&amp; variant : status.variants()) {
 598                     data-&gt;cases.append(
 599                         MultiGetByOffsetCase(
 600                             *m_graph.addStructureSet(variant.structureSet()),
 601                             GetByOffsetMethod::load(variant.offset())));
 602                 }
 603                 data-&gt;identifierNumber = identifierNumber;
 604                 node-&gt;convertToMultiGetByOffset(data);
 605                 changed = true;
 606                 break;
 607             }
 608 
 609             case PutById:
 610             case PutByIdDirect:
 611             case PutByIdFlush: {
 612                 NodeOrigin origin = node-&gt;origin;
 613                 Edge childEdge = node-&gt;child1();
 614                 Node* child = childEdge.node();
 615                 unsigned identifierNumber = node-&gt;identifierNumber();
 616 
 617                 ASSERT(childEdge.useKind() == CellUse);
 618 
 619                 AbstractValue baseValue = m_state.forNode(child);
 620                 AbstractValue valueValue = m_state.forNode(node-&gt;child2());
 621 



 622                 if (!baseValue.m_structure.isFinite())
 623                     break;
 624 
 625                 PutByIdStatus status = PutByIdStatus::computeFor(
 626                     m_graph.globalObjectFor(origin.semantic),
 627                     baseValue.m_structure.toStructureSet(),
 628                     m_graph.identifiers()[identifierNumber],
 629                     node-&gt;op() == PutByIdDirect);
 630 
 631                 if (!status.isSimple())
 632                     break;
 633 
 634                 ASSERT(status.numVariants());
 635 
 636                 if (status.numVariants() &gt; 1 &amp;&amp; !m_graph.m_plan.isFTL())
 637                     break;
 638 
 639                 changed = true;
 640 
 641                 bool allGood = true;
<span class="line-added"> 642                 RegisteredStructureSet newSet;</span>
<span class="line-added"> 643                 TransitionVector transitions;</span>
 644                 for (const PutByIdVariant&amp; variant : status.variants()) {


 645                     for (const ObjectPropertyCondition&amp; condition : variant.conditionSet()) {
 646                         if (m_graph.watchCondition(condition))
 647                             continue;
 648 
 649                         Structure* structure = condition.object()-&gt;structure(m_graph.m_vm);
 650                         if (!condition.structureEnsuresValidity(structure)) {
 651                             allGood = false;
 652                             break;
 653                         }
 654 
 655                         m_insertionSet.insertNode(
 656                             indexInBlock, SpecNone, CheckStructure, node-&gt;origin,
 657                             OpInfo(m_graph.addStructureSet(structure)),
 658                             m_insertionSet.insertConstantForUse(
 659                                 indexInBlock, node-&gt;origin, condition.object(), KnownCellUse));
 660                     }
<span class="line-added"> 661 </span>
<span class="line-added"> 662                     if (!allGood)</span>
<span class="line-added"> 663                         break;</span>
<span class="line-added"> 664 </span>
<span class="line-added"> 665                     if (variant.kind() == PutByIdVariant::Transition) {</span>
<span class="line-added"> 666                         RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());</span>
<span class="line-added"> 667                         transitions.append(</span>
<span class="line-added"> 668                             Transition(</span>
<span class="line-added"> 669                                 m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));</span>
<span class="line-added"> 670                         newSet.add(newStructure);</span>
<span class="line-added"> 671                     } else {</span>
<span class="line-added"> 672                         ASSERT(variant.kind() == PutByIdVariant::Replace);</span>
<span class="line-added"> 673                         newSet.merge(*m_graph.addStructureSet(variant.oldStructure()));</span>
<span class="line-added"> 674                     }</span>
 675                 }
 676 
 677                 if (!allGood)
 678                     break;
 679 
<span class="line-added"> 680                 // Push CFA over this node after we get the state before.</span>
<span class="line-added"> 681                 m_interpreter.didFoldClobberWorld();</span>
<span class="line-added"> 682                 m_interpreter.observeTransitions(indexInBlock, transitions);</span>
<span class="line-added"> 683                 if (m_state.forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)</span>
<span class="line-added"> 684                     m_state.setIsValid(false);</span>
<span class="line-added"> 685 </span>
<span class="line-added"> 686                 alreadyHandled = true; // Don&#39;t allow the default constant folder to do things to this.</span>
<span class="line-added"> 687 </span>
 688                 m_insertionSet.insertNode(
 689                     indexInBlock, SpecNone, FilterPutByIdStatus, node-&gt;origin,
 690                     OpInfo(m_graph.m_plan.recordedStatuses().addPutByIdStatus(node-&gt;origin.semantic, status)),
 691                     Edge(child));
 692 
 693                 if (status.numVariants() == 1) {
 694                     emitPutByOffset(indexInBlock, node, baseValue, status[0], identifierNumber);
 695                     break;
 696                 }
 697 
 698                 ASSERT(m_graph.m_plan.isFTL());
 699 
 700                 MultiPutByOffsetData* data = m_graph.m_multiPutByOffsetData.add();
 701                 data-&gt;variants = status.variants();
 702                 data-&gt;identifierNumber = identifierNumber;
 703                 node-&gt;convertToMultiPutByOffset(data);
 704                 break;
 705             }
 706 
 707             case InByVal: {
</pre>
<hr />
<pre>
 713                         if (impl &amp;&amp; impl-&gt;isAtom()) {
 714                             unsigned identifierNumber = m_graph.identifiers().ensure(const_cast&lt;UniquedStringImpl*&gt;(static_cast&lt;const UniquedStringImpl*&gt;(impl)));
 715                             node-&gt;convertToInById(identifierNumber);
 716                             changed = true;
 717                             break;
 718                         }
 719                     }
 720                 }
 721                 break;
 722             }
 723 
 724             case ToPrimitive: {
 725                 if (m_state.forNode(node-&gt;child1()).m_type &amp; ~(SpecFullNumber | SpecBoolean | SpecString | SpecSymbol | SpecBigInt))
 726                     break;
 727 
 728                 node-&gt;convertToIdentity();
 729                 changed = true;
 730                 break;
 731             }
 732 
<span class="line-added"> 733             case ToPropertyKey: {</span>
<span class="line-added"> 734                 if (m_state.forNode(node-&gt;child1()).m_type &amp; ~(SpecString | SpecSymbol))</span>
<span class="line-added"> 735                     break;</span>
<span class="line-added"> 736 </span>
<span class="line-added"> 737                 node-&gt;convertToIdentity();</span>
<span class="line-added"> 738                 changed = true;</span>
<span class="line-added"> 739                 break;</span>
<span class="line-added"> 740             }</span>
<span class="line-added"> 741 </span>
 742             case ToThis: {
 743                 ToThisResult result = isToThisAnIdentity(m_graph.m_vm, m_graph.isStrictModeFor(node-&gt;origin.semantic), m_state.forNode(node-&gt;child1()));
 744                 if (result == ToThisResult::Identity) {
 745                     node-&gt;convertToIdentity();
 746                     changed = true;
 747                     break;
 748                 }
 749                 if (result == ToThisResult::GlobalThis) {
 750                     node-&gt;convertToGetGlobalThis();
 751                     changed = true;
 752                     break;
 753                 }
 754                 break;
 755             }
 756 
 757             case CreateThis: {
 758                 if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {
 759                     if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {
 760                         if (FunctionRareData* rareData = function-&gt;rareData()) {
 761                             if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {
</pre>
<hr />
<pre>
 776                                         NodeOrigin origin = node-&gt;origin.withInvalidExit();
 777                                         Node* prototypeNode = m_insertionSet.insertConstant(
 778                                             indexInBlock + 1, origin, m_graph.freeze(prototype));
 779 
 780                                         ASSERT(isInlineOffset(knownPolyProtoOffset));
 781                                         m_insertionSet.insertNode(
 782                                             indexInBlock + 1, SpecNone, PutByOffset, origin, OpInfo(data),
 783                                             Edge(node, KnownCellUse), Edge(node, KnownCellUse), Edge(prototypeNode, UntypedUse));
 784                                     }
 785                                     changed = true;
 786                                     break;
 787 
 788                                 }
 789                             }
 790                         }
 791                     }
 792                 }
 793                 break;
 794             }
 795 
<span class="line-added"> 796             case CreatePromise: {</span>
<span class="line-added"> 797                 JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added"> 798                 if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {</span>
<span class="line-added"> 799                     if (base == (node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor())) {</span>
<span class="line-added"> 800                         node-&gt;convertToNewPromise(m_graph.registerStructure(node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure()));</span>
<span class="line-added"> 801                         changed = true;</span>
<span class="line-added"> 802                         break;</span>
<span class="line-added"> 803                     }</span>
<span class="line-added"> 804                     if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {</span>
<span class="line-added"> 805                         if (FunctionRareData* rareData = function-&gt;rareData()) {</span>
<span class="line-added"> 806                             if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added"> 807                                 Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="line-added"> 808                                 if (structure</span>
<span class="line-added"> 809                                     &amp;&amp; structure-&gt;classInfo() == (node-&gt;isInternalPromise() ? JSInternalPromise::info() : JSPromise::info())</span>
<span class="line-added"> 810                                     &amp;&amp; structure-&gt;globalObject() == globalObject</span>
<span class="line-added"> 811                                     &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added"> 812                                     m_graph.freeze(rareData);</span>
<span class="line-added"> 813                                     m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-added"> 814                                     node-&gt;convertToNewPromise(m_graph.registerStructure(structure));</span>
<span class="line-added"> 815                                     changed = true;</span>
<span class="line-added"> 816                                     break;</span>
<span class="line-added"> 817                                 }</span>
<span class="line-added"> 818                             }</span>
<span class="line-added"> 819                         }</span>
<span class="line-added"> 820                     }</span>
<span class="line-added"> 821                 }</span>
<span class="line-added"> 822                 break;</span>
<span class="line-added"> 823             }</span>
<span class="line-added"> 824 </span>
<span class="line-added"> 825             case CreateGenerator:</span>
<span class="line-added"> 826             case CreateAsyncGenerator: {</span>
<span class="line-added"> 827                 auto foldConstant = [&amp;] (NodeType newOp, const ClassInfo* classInfo) {</span>
<span class="line-added"> 828                     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added"> 829                     if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {</span>
<span class="line-added"> 830                         if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {</span>
<span class="line-added"> 831                             if (FunctionRareData* rareData = function-&gt;rareData()) {</span>
<span class="line-added"> 832                                 if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added"> 833                                     Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="line-added"> 834                                     if (structure</span>
<span class="line-added"> 835                                         &amp;&amp; structure-&gt;classInfo() == classInfo</span>
<span class="line-added"> 836                                         &amp;&amp; structure-&gt;globalObject() == globalObject</span>
<span class="line-added"> 837                                         &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added"> 838                                         m_graph.freeze(rareData);</span>
<span class="line-added"> 839                                         m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-added"> 840                                         node-&gt;convertToNewInternalFieldObject(newOp, m_graph.registerStructure(structure));</span>
<span class="line-added"> 841                                         changed = true;</span>
<span class="line-added"> 842                                         return;</span>
<span class="line-added"> 843                                     }</span>
<span class="line-added"> 844                                 }</span>
<span class="line-added"> 845                             }</span>
<span class="line-added"> 846                         }</span>
<span class="line-added"> 847                     }</span>
<span class="line-added"> 848                 };</span>
<span class="line-added"> 849 </span>
<span class="line-added"> 850                 switch (node-&gt;op()) {</span>
<span class="line-added"> 851                 case CreateGenerator:</span>
<span class="line-added"> 852                     foldConstant(NewGenerator, JSGenerator::info());</span>
<span class="line-added"> 853                     break;</span>
<span class="line-added"> 854                 case CreateAsyncGenerator:</span>
<span class="line-added"> 855                     foldConstant(NewAsyncGenerator, JSAsyncGenerator::info());</span>
<span class="line-added"> 856                     break;</span>
<span class="line-added"> 857                 default:</span>
<span class="line-added"> 858                     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 859                     break;</span>
<span class="line-added"> 860                 }</span>
<span class="line-added"> 861                 break;</span>
<span class="line-added"> 862             }</span>
<span class="line-added"> 863 </span>
 864             case ObjectCreate: {
 865                 if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {
 866                     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
 867                     Structure* structure = nullptr;
 868                     if (base.isNull())
 869                         structure = globalObject-&gt;nullPrototypeObjectStructure();
 870                     else if (base.isObject())
 871                         structure = globalObject-&gt;vm().structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());
 872 
 873                     if (structure) {
 874                         node-&gt;convertToNewObject(m_graph.registerStructure(structure));
 875                         changed = true;
 876                         break;
 877                     }
 878                 }
 879                 break;
 880             }
 881 
 882             case ObjectKeys: {
 883                 if (node-&gt;child1().useKind() == ObjectUse) {
 884                     auto&amp; structureSet = m_state.forNode(node-&gt;child1()).m_structure;
 885                     if (structureSet.isFinite() &amp;&amp; structureSet.size() == 1) {
 886                         RegisteredStructure structure = structureSet.onlyStructure();
 887                         if (auto* rareData = structure-&gt;rareDataConcurrently()) {
 888                             if (auto* immutableButterfly = rareData-&gt;cachedOwnKeysConcurrently()) {
 889                                 if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
 890                                     node-&gt;convertToNewArrayBuffer(m_graph.freeze(immutableButterfly));
 891                                     changed = true;
 892                                     break;
 893                                 }
 894                             }
 895                         }
 896                     }
 897                 }
 898                 break;
 899             }
 900 
<span class="line-added"> 901             case NewArrayWithSpread: {</span>
<span class="line-added"> 902                 if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {</span>
<span class="line-added"> 903                     BitVector* bitVector = node-&gt;bitVector();</span>
<span class="line-added"> 904                     if (node-&gt;numChildren() == 1 &amp;&amp; bitVector-&gt;get(0)) {</span>
<span class="line-added"> 905                         Edge use = m_graph.varArgChild(node, 0);</span>
<span class="line-added"> 906                         if (use-&gt;op() == PhantomSpread) {</span>
<span class="line-added"> 907                             if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {</span>
<span class="line-added"> 908                                 auto* immutableButterfly = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();</span>
<span class="line-added"> 909                                 if (hasContiguous(immutableButterfly-&gt;indexingType())) {</span>
<span class="line-added"> 910                                     node-&gt;convertToNewArrayBuffer(m_graph.freeze(immutableButterfly));</span>
<span class="line-added"> 911                                     changed = true;</span>
<span class="line-added"> 912                                     break;</span>
<span class="line-added"> 913                                 }</span>
<span class="line-added"> 914                             }</span>
<span class="line-added"> 915                         }</span>
<span class="line-added"> 916                     }</span>
<span class="line-added"> 917                 }</span>
<span class="line-added"> 918                 break;</span>
<span class="line-added"> 919             }</span>
<span class="line-added"> 920 </span>
 921             case ToNumber: {
 922                 if (m_state.forNode(node-&gt;child1()).m_type &amp; ~SpecBytecodeNumber)
 923                     break;
 924 
 925                 node-&gt;convertToIdentity();
 926                 changed = true;
 927                 break;
 928             }
 929 
<span class="line-added"> 930             case ToNumeric: {</span>
<span class="line-added"> 931                 if (m_state.forNode(node-&gt;child1()).m_type &amp; ~(SpecBytecodeNumber | SpecBigInt))</span>
<span class="line-added"> 932                     break;</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934                 node-&gt;convertToIdentity();</span>
<span class="line-added"> 935                 changed = true;</span>
<span class="line-added"> 936                 break;</span>
<span class="line-added"> 937             }</span>
<span class="line-added"> 938 </span>
 939             case NormalizeMapKey: {
 940                 SpeculatedType typeMaybeNormalized = (SpecFullNumber &amp; ~SpecInt32Only);
 941                 if (m_state.forNode(node-&gt;child1()).m_type &amp; typeMaybeNormalized)
 942                     break;
 943 
 944                 node-&gt;convertToIdentity();
 945                 changed = true;
 946                 break;
 947             }
 948 
 949             case ParseInt: {
 950                 AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
 951                 if (!value.m_type || (value.m_type &amp; ~SpecInt32Only))
 952                     break;
 953 
 954                 JSValue radix;
 955                 if (!node-&gt;child2())
 956                     radix = jsNumber(0);
 957                 else
 958                     radix = m_state.forNode(node-&gt;child2()).m_value;
</pre>
<hr />
<pre>
1079                 if (abstractValue.m_structure.isFinite()) {
1080                     bool ok = true;
1081                     abstractValue.m_structure.forEach([&amp;] (RegisteredStructure structure) {
1082                         ok &amp;= (structure-&gt;typeInfo().inlineTypeFlags() &amp; bits) == bits;
1083                     });
1084                     if (ok) {
1085                         eliminated = true;
1086                         node-&gt;remove(m_graph);
1087                         break;
1088                     }
1089                 }
1090 
1091                 break;
1092             }
1093 
1094             case PhantomNewObject:
1095             case PhantomNewFunction:
1096             case PhantomNewGeneratorFunction:
1097             case PhantomNewAsyncGeneratorFunction:
1098             case PhantomNewAsyncFunction:
<span class="line-added">1099             case PhantomNewArrayIterator:</span>
1100             case PhantomCreateActivation:
1101             case PhantomDirectArguments:
1102             case PhantomClonedArguments:
1103             case PhantomCreateRest:
1104             case PhantomSpread:
1105             case PhantomNewArrayWithSpread:
1106             case PhantomNewArrayBuffer:
1107             case PhantomNewRegexp:
1108             case BottomValue:
1109                 alreadyHandled = true;
1110                 break;
1111 
1112             default:
1113                 break;
1114             }
1115 
1116             if (eliminated) {
1117                 changed = true;
1118                 continue;
1119             }
</pre>
</td>
</tr>
</table>
<center><a href="DFGCompilationKey.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGDesiredGlobalProperties.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayoutState.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayerModelObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayoutState.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayoutState.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderLayoutState.h&quot;
 28 
 29 #include &quot;RenderFragmentedFlow.h&quot;
 30 #include &quot;RenderInline.h&quot;
 31 #include &quot;RenderLayer.h&quot;
 32 #include &quot;RenderMultiColumnFlow.h&quot;
 33 #include &quot;RenderView.h&quot;
 34 #include &lt;wtf/WeakPtr.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 RenderLayoutState::RenderLayoutState(RenderElement&amp; renderer, IsPaginated isPaginated)
 39     : m_clipped(false)
 40     , m_isPaginated(isPaginated == IsPaginated::Yes)
 41     , m_pageLogicalHeightChanged(false)
<span class="line-modified"> 42 #if !ASSERT_DISABLED</span>
 43     , m_layoutDeltaXSaturated(false)
 44     , m_layoutDeltaYSaturated(false)
<span class="line-removed"> 45 #endif</span>
<span class="line-removed"> 46 #ifndef NDEBUG</span>
 47     , m_renderer(&amp;renderer)
 48 #endif
 49 {
 50     if (RenderElement* container = renderer.container()) {
 51         FloatPoint absContentPoint = container-&gt;localToAbsolute(FloatPoint(), UseTransforms);
 52         m_paintOffset = LayoutSize(absContentPoint.x(), absContentPoint.y());
 53 
 54         if (container-&gt;hasOverflowClip()) {
 55             m_clipped = true;
 56             auto&amp; containerBox = downcast&lt;RenderBox&gt;(*container);
 57             m_clipRect = LayoutRect(toLayoutPoint(m_paintOffset), containerBox.cachedSizeForOverflowClip());
 58             m_paintOffset -= toLayoutSize(containerBox.scrollPosition());
 59         }
 60     }
 61     if (m_isPaginated) {
 62         // This is just a flag for known page height (see RenderBlockFlow::checkForPaginationLogicalHeightChange).
 63         m_pageLogicalHeight = 1;
 64     }
 65 }
 66 
 67 RenderLayoutState::RenderLayoutState(const FrameViewLayoutContext::LayoutStateStack&amp; layoutStateStack, RenderBox&amp; renderer, const LayoutSize&amp; offset, LayoutUnit pageLogicalHeight, bool pageLogicalHeightChanged)
 68     : m_clipped(false)
 69     , m_isPaginated(false)
 70     , m_pageLogicalHeightChanged(false)
<span class="line-modified"> 71 #if !ASSERT_DISABLED</span>
 72     , m_layoutDeltaXSaturated(false)
 73     , m_layoutDeltaYSaturated(false)
<span class="line-removed"> 74 #endif</span>
<span class="line-removed"> 75 #ifndef NDEBUG</span>
 76     , m_renderer(&amp;renderer)
 77 #endif
 78 {
 79     if (!layoutStateStack.isEmpty()) {
 80         auto&amp; ancestor = *layoutStateStack.last().get();
 81         computeOffsets(ancestor, renderer, offset);
 82         computeClipRect(ancestor, renderer);
 83     }
 84     computePaginationInformation(layoutStateStack, renderer, pageLogicalHeight, pageLogicalHeightChanged);
 85 }
 86 
 87 void RenderLayoutState::computeOffsets(const RenderLayoutState&amp; ancestor, RenderBox&amp; renderer, LayoutSize offset)
 88 {
 89     bool fixed = renderer.isFixedPositioned();
 90     if (fixed) {
 91         FloatPoint fixedOffset = renderer.view().localToAbsolute(FloatPoint(), IsFixed);
 92         m_paintOffset = LayoutSize(fixedOffset.x(), fixedOffset.y()) + offset;
 93     } else
 94         m_paintOffset = ancestor.paintOffset() + offset;
 95 
 96     if (renderer.isOutOfFlowPositioned() &amp;&amp; !fixed) {
 97         if (auto* container = renderer.container()) {
 98             if (container-&gt;isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(*container))
 99                 m_paintOffset += downcast&lt;RenderInline&gt;(*container).offsetForInFlowPositionedInline(&amp;renderer);
100         }
101     }
102 
103     m_layoutOffset = m_paintOffset;
104 
105     if (renderer.isInFlowPositioned() &amp;&amp; renderer.hasLayer())
106         m_paintOffset += renderer.layer()-&gt;offsetForInFlowPosition();
107 
108     if (renderer.hasOverflowClip())
109         m_paintOffset -= toLayoutSize(renderer.scrollPosition());
110 
111     m_layoutDelta = ancestor.layoutDelta();
<span class="line-modified">112 #if !ASSERT_DISABLED</span>
113     m_layoutDeltaXSaturated = ancestor.m_layoutDeltaXSaturated;
114     m_layoutDeltaYSaturated = ancestor.m_layoutDeltaYSaturated;
115 #endif
116 }
117 
118 void RenderLayoutState::computeClipRect(const RenderLayoutState&amp; ancestor, RenderBox&amp; renderer)
119 {
120     m_clipped = !renderer.isFixedPositioned() &amp;&amp; ancestor.isClipped();
121     if (m_clipped)
122         m_clipRect = ancestor.clipRect();
123     if (!renderer.hasOverflowClip())
124         return;
125 
126     auto paintOffsetForClipRect = toLayoutPoint(m_paintOffset + toLayoutSize(renderer.scrollPosition()));
127     LayoutRect clipRect(paintOffsetForClipRect + renderer.view().frameView().layoutContext().layoutDelta(), renderer.cachedSizeForOverflowClip());
128     if (m_clipped)
129         m_clipRect.intersect(clipRect);
130     else
131         m_clipRect = clipRect;
132     m_clipped = true;
</pre>
<hr />
<pre>
243                 continue;
244             currentGrid = currentState.lineGrid();
245             if (!currentGrid)
246                 break;
247             if (currentGrid-&gt;style().lineGrid() == renderer.style().lineGrid()) {
248                 m_lineGrid = makeWeakPtr(currentGrid);
249                 m_lineGridOffset = currentState.m_lineGridOffset;
250                 return;
251             }
252         }
253     }
254 
255     // We didn&#39;t find an already-established grid with this identifier. Our render object establishes the grid.
256     m_lineGrid = makeWeakPtr(renderer);
257     m_lineGridOffset = m_layoutOffset;
258 }
259 
260 void RenderLayoutState::addLayoutDelta(LayoutSize delta)
261 {
262     m_layoutDelta += delta;
<span class="line-modified">263 #if !ASSERT_DISABLED</span>
264     m_layoutDeltaXSaturated |= m_layoutDelta.width() == LayoutUnit::max() || m_layoutDelta.width() == LayoutUnit::min();
265     m_layoutDeltaYSaturated |= m_layoutDelta.height() == LayoutUnit::max() || m_layoutDelta.height() == LayoutUnit::min();
266 #endif
267 }
268 
<span class="line-modified">269 #if !ASSERT_DISABLED</span>
270 bool RenderLayoutState::layoutDeltaMatches(LayoutSize delta) const
271 {
272     return (delta.width() == m_layoutDelta.width() || m_layoutDeltaXSaturated) &amp;&amp; (delta.height() == m_layoutDelta.height() || m_layoutDeltaYSaturated);
273 }
274 #endif
275 
276 LayoutStateMaintainer::LayoutStateMaintainer(RenderBox&amp; root, LayoutSize offset, bool disablePaintOffsetCache, LayoutUnit pageHeight, bool pageHeightChanged)
277     : m_context(root.view().frameView().layoutContext())
278     , m_paintOffsetCacheIsDisabled(disablePaintOffsetCache)
279 {
280     m_didPushLayoutState = m_context.pushLayoutState(root, offset, pageHeight, pageHeightChanged);
281     if (m_didPushLayoutState &amp;&amp; m_paintOffsetCacheIsDisabled)
282         m_context.disablePaintOffsetCache();
283 }
284 
285 LayoutStateMaintainer::~LayoutStateMaintainer()
286 {
287     if (!m_didPushLayoutState)
288         return;
289     m_context.popLayoutState();
</pre>
</td>
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderLayoutState.h&quot;
 28 
 29 #include &quot;RenderFragmentedFlow.h&quot;
 30 #include &quot;RenderInline.h&quot;
 31 #include &quot;RenderLayer.h&quot;
 32 #include &quot;RenderMultiColumnFlow.h&quot;
 33 #include &quot;RenderView.h&quot;
 34 #include &lt;wtf/WeakPtr.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 RenderLayoutState::RenderLayoutState(RenderElement&amp; renderer, IsPaginated isPaginated)
 39     : m_clipped(false)
 40     , m_isPaginated(isPaginated == IsPaginated::Yes)
 41     , m_pageLogicalHeightChanged(false)
<span class="line-modified"> 42 #if ASSERT_ENABLED</span>
 43     , m_layoutDeltaXSaturated(false)
 44     , m_layoutDeltaYSaturated(false)


 45     , m_renderer(&amp;renderer)
 46 #endif
 47 {
 48     if (RenderElement* container = renderer.container()) {
 49         FloatPoint absContentPoint = container-&gt;localToAbsolute(FloatPoint(), UseTransforms);
 50         m_paintOffset = LayoutSize(absContentPoint.x(), absContentPoint.y());
 51 
 52         if (container-&gt;hasOverflowClip()) {
 53             m_clipped = true;
 54             auto&amp; containerBox = downcast&lt;RenderBox&gt;(*container);
 55             m_clipRect = LayoutRect(toLayoutPoint(m_paintOffset), containerBox.cachedSizeForOverflowClip());
 56             m_paintOffset -= toLayoutSize(containerBox.scrollPosition());
 57         }
 58     }
 59     if (m_isPaginated) {
 60         // This is just a flag for known page height (see RenderBlockFlow::checkForPaginationLogicalHeightChange).
 61         m_pageLogicalHeight = 1;
 62     }
 63 }
 64 
 65 RenderLayoutState::RenderLayoutState(const FrameViewLayoutContext::LayoutStateStack&amp; layoutStateStack, RenderBox&amp; renderer, const LayoutSize&amp; offset, LayoutUnit pageLogicalHeight, bool pageLogicalHeightChanged)
 66     : m_clipped(false)
 67     , m_isPaginated(false)
 68     , m_pageLogicalHeightChanged(false)
<span class="line-modified"> 69 #if ASSERT_ENABLED</span>
 70     , m_layoutDeltaXSaturated(false)
 71     , m_layoutDeltaYSaturated(false)


 72     , m_renderer(&amp;renderer)
 73 #endif
 74 {
 75     if (!layoutStateStack.isEmpty()) {
 76         auto&amp; ancestor = *layoutStateStack.last().get();
 77         computeOffsets(ancestor, renderer, offset);
 78         computeClipRect(ancestor, renderer);
 79     }
 80     computePaginationInformation(layoutStateStack, renderer, pageLogicalHeight, pageLogicalHeightChanged);
 81 }
 82 
 83 void RenderLayoutState::computeOffsets(const RenderLayoutState&amp; ancestor, RenderBox&amp; renderer, LayoutSize offset)
 84 {
 85     bool fixed = renderer.isFixedPositioned();
 86     if (fixed) {
 87         FloatPoint fixedOffset = renderer.view().localToAbsolute(FloatPoint(), IsFixed);
 88         m_paintOffset = LayoutSize(fixedOffset.x(), fixedOffset.y()) + offset;
 89     } else
 90         m_paintOffset = ancestor.paintOffset() + offset;
 91 
 92     if (renderer.isOutOfFlowPositioned() &amp;&amp; !fixed) {
 93         if (auto* container = renderer.container()) {
 94             if (container-&gt;isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(*container))
 95                 m_paintOffset += downcast&lt;RenderInline&gt;(*container).offsetForInFlowPositionedInline(&amp;renderer);
 96         }
 97     }
 98 
 99     m_layoutOffset = m_paintOffset;
100 
101     if (renderer.isInFlowPositioned() &amp;&amp; renderer.hasLayer())
102         m_paintOffset += renderer.layer()-&gt;offsetForInFlowPosition();
103 
104     if (renderer.hasOverflowClip())
105         m_paintOffset -= toLayoutSize(renderer.scrollPosition());
106 
107     m_layoutDelta = ancestor.layoutDelta();
<span class="line-modified">108 #if ASSERT_ENABLED</span>
109     m_layoutDeltaXSaturated = ancestor.m_layoutDeltaXSaturated;
110     m_layoutDeltaYSaturated = ancestor.m_layoutDeltaYSaturated;
111 #endif
112 }
113 
114 void RenderLayoutState::computeClipRect(const RenderLayoutState&amp; ancestor, RenderBox&amp; renderer)
115 {
116     m_clipped = !renderer.isFixedPositioned() &amp;&amp; ancestor.isClipped();
117     if (m_clipped)
118         m_clipRect = ancestor.clipRect();
119     if (!renderer.hasOverflowClip())
120         return;
121 
122     auto paintOffsetForClipRect = toLayoutPoint(m_paintOffset + toLayoutSize(renderer.scrollPosition()));
123     LayoutRect clipRect(paintOffsetForClipRect + renderer.view().frameView().layoutContext().layoutDelta(), renderer.cachedSizeForOverflowClip());
124     if (m_clipped)
125         m_clipRect.intersect(clipRect);
126     else
127         m_clipRect = clipRect;
128     m_clipped = true;
</pre>
<hr />
<pre>
239                 continue;
240             currentGrid = currentState.lineGrid();
241             if (!currentGrid)
242                 break;
243             if (currentGrid-&gt;style().lineGrid() == renderer.style().lineGrid()) {
244                 m_lineGrid = makeWeakPtr(currentGrid);
245                 m_lineGridOffset = currentState.m_lineGridOffset;
246                 return;
247             }
248         }
249     }
250 
251     // We didn&#39;t find an already-established grid with this identifier. Our render object establishes the grid.
252     m_lineGrid = makeWeakPtr(renderer);
253     m_lineGridOffset = m_layoutOffset;
254 }
255 
256 void RenderLayoutState::addLayoutDelta(LayoutSize delta)
257 {
258     m_layoutDelta += delta;
<span class="line-modified">259 #if ASSERT_ENABLED</span>
260     m_layoutDeltaXSaturated |= m_layoutDelta.width() == LayoutUnit::max() || m_layoutDelta.width() == LayoutUnit::min();
261     m_layoutDeltaYSaturated |= m_layoutDelta.height() == LayoutUnit::max() || m_layoutDelta.height() == LayoutUnit::min();
262 #endif
263 }
264 
<span class="line-modified">265 #if ASSERT_ENABLED</span>
266 bool RenderLayoutState::layoutDeltaMatches(LayoutSize delta) const
267 {
268     return (delta.width() == m_layoutDelta.width() || m_layoutDeltaXSaturated) &amp;&amp; (delta.height() == m_layoutDelta.height() || m_layoutDeltaYSaturated);
269 }
270 #endif
271 
272 LayoutStateMaintainer::LayoutStateMaintainer(RenderBox&amp; root, LayoutSize offset, bool disablePaintOffsetCache, LayoutUnit pageHeight, bool pageHeightChanged)
273     : m_context(root.view().frameView().layoutContext())
274     , m_paintOffsetCacheIsDisabled(disablePaintOffsetCache)
275 {
276     m_didPushLayoutState = m_context.pushLayoutState(root, offset, pageHeight, pageHeightChanged);
277     if (m_didPushLayoutState &amp;&amp; m_paintOffsetCacheIsDisabled)
278         m_context.disablePaintOffsetCache();
279 }
280 
281 LayoutStateMaintainer::~LayoutStateMaintainer()
282 {
283     if (!m_didPushLayoutState)
284         return;
285     m_context.popLayoutState();
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayerModelObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayoutState.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTrackElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011, 2013 Google Inc. All rights reserved.
  3  * Copyright (C) 2011-2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;HTMLTrackElement.h&quot;
 29 
 30 #if ENABLE(VIDEO_TRACK)
 31 
 32 #include &quot;ContentSecurityPolicy.h&quot;
 33 #include &quot;Event.h&quot;
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;HTMLMediaElement.h&quot;
 36 #include &quot;HTMLNames.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &lt;wtf/IsoMallocInlines.h&gt;
 39 #include &lt;wtf/text/CString.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLTrackElement);
 44 
 45 using namespace HTMLNames;
 46 
 47 #if !LOG_DISABLED
 48 
 49 static String urlForLoggingTrack(const URL&amp; url)
 50 {
 51     static const unsigned maximumURLLengthForLogging = 128;
 52 
 53     if (url.string().length() &lt; maximumURLLengthForLogging)
 54         return url.string();
 55     return url.string().substring(0, maximumURLLengthForLogging) + &quot;...&quot;;
 56 }
 57 
 58 #endif
 59 
 60 inline HTMLTrackElement::HTMLTrackElement(const QualifiedName&amp; tagName, Document&amp; document)
 61     : HTMLElement(tagName, document)
 62     , m_loadTimer(*this, &amp;HTMLTrackElement::loadTimerFired)
 63 {
 64     LOG(Media, &quot;HTMLTrackElement::HTMLTrackElement - %p&quot;, this);
 65     ASSERT(hasTagName(trackTag));
 66 }
 67 
 68 HTMLTrackElement::~HTMLTrackElement()
 69 {
 70     if (m_track) {
 71         m_track-&gt;clearElement();
 72         m_track-&gt;clearClient();
 73     }
 74 }
 75 
 76 Ref&lt;HTMLTrackElement&gt; HTMLTrackElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 77 {
 78     return adoptRef(*new HTMLTrackElement(tagName, document));
 79 }
 80 
 81 Node::InsertedIntoAncestorResult HTMLTrackElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 82 {
 83     HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 84 
 85     if (parentNode() == &amp;parentOfInsertedTree &amp;&amp; is&lt;HTMLMediaElement&gt;(parentOfInsertedTree)) {
 86         downcast&lt;HTMLMediaElement&gt;(parentOfInsertedTree).didAddTextTrack(*this);
 87         scheduleLoad();
 88     }
 89 
 90     return InsertedIntoAncestorResult::Done;
 91 }
 92 
 93 void HTMLTrackElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
 94 {
 95     HTMLElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
 96 
 97     if (!parentNode() &amp;&amp; is&lt;HTMLMediaElement&gt;(oldParentOfRemovedTree))
 98         downcast&lt;HTMLMediaElement&gt;(oldParentOfRemovedTree).didRemoveTextTrack(*this);
 99 }
100 
101 void HTMLTrackElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
102 {
103     if (name == srcAttr) {
104         scheduleLoad();
105 
106     // 4.8.10.12.3 Sourcing out-of-band text tracks
107     // As the kind, label, and srclang attributes are set, changed, or removed, the text track must update accordingly...
108     } else if (name == kindAttr)
109         track().setKindKeywordIgnoringASCIICase(value.string());
110     else if (name == labelAttr)
111         track().setLabel(value);
112     else if (name == srclangAttr)
113         track().setLanguage(value);
114     else if (name == defaultAttr)
115         track().setIsDefault(!value.isNull());
116 
117     HTMLElement::parseAttribute(name, value);
118 }
119 
120 const AtomString&amp; HTMLTrackElement::kind()
121 {
122     return track().kindKeyword();
123 }
124 
125 void HTMLTrackElement::setKind(const AtomString&amp; kind)
126 {
127     setAttributeWithoutSynchronization(kindAttr, kind);
128 }
129 
130 const AtomString&amp; HTMLTrackElement::srclang() const
131 {
132     return attributeWithoutSynchronization(srclangAttr);
133 }
134 
135 const AtomString&amp; HTMLTrackElement::label() const
136 {
137     return attributeWithoutSynchronization(labelAttr);
138 }
139 
140 bool HTMLTrackElement::isDefault() const
141 {
142     return hasAttributeWithoutSynchronization(defaultAttr);
143 }
144 
145 LoadableTextTrack&amp; HTMLTrackElement::track()
146 {
147     // FIXME: There is no practical value in lazily initializing this.
148     // Instead this should be created in the constructor.
149     if (!m_track) {
150         // The kind attribute is an enumerated attribute, limited only to known values. It defaults to &#39;subtitles&#39; if missing or invalid.
151         String kind = attributeWithoutSynchronization(kindAttr).convertToASCIILowercase();
152         if (!TextTrack::isValidKindKeyword(kind))
153             kind = TextTrack::subtitlesKeyword();
154         m_track = LoadableTextTrack::create(*this, kind, label(), srclang());
155     }
156     ASSERT(m_track-&gt;trackElement() == this);
157 
158     return *m_track;
159 }
160 
161 bool HTMLTrackElement::isURLAttribute(const Attribute&amp; attribute) const
162 {
163     return attribute.name() == srcAttr || HTMLElement::isURLAttribute(attribute);
164 }
165 
166 void HTMLTrackElement::scheduleLoad()
167 {
168     // 1. If another occurrence of this algorithm is already running for this text track and its track element,
169     // abort these steps, letting that other algorithm take care of this element.
170     if (m_loadTimer.isActive())
171         return;
172 
173     // 2. If the text track&#39;s text track mode is not set to one of hidden or showing, abort these steps.
174     if (track().mode() != TextTrack::Mode::Hidden &amp;&amp; track().mode() != TextTrack::Mode::Showing)
175         return;
176 
177     // 3. If the text track&#39;s track element does not have a media element as a parent, abort these steps.
178     if (!mediaElement())
179         return;
180 
181     // 4. Run the remainder of these steps asynchronously, allowing whatever caused these steps to run to continue.
182     m_loadTimer.startOneShot(0_s);
183 }
184 
185 void HTMLTrackElement::loadTimerFired()
186 {
187     if (!hasAttributeWithoutSynchronization(srcAttr)) {
188         track().removeAllCues();
189         return;
190     }
191 
192     // 6. Set the text track readiness state to loading.
193     setReadyState(HTMLTrackElement::LOADING);
194 
195     // 7. Let URL be the track URL of the track element.
196     URL url = getNonEmptyURLAttribute(srcAttr);
197 
198     // ... if URL is the empty string, then queue a task to first change the text track readiness state
199     // to failed to load and then fire an event named error at the track element.
200     // 8. If the track element&#39;s parent is a media element then let CORS mode be the state of the parent media
201     // element&#39;s crossorigin content attribute. Otherwise, let CORS mode be No CORS.
202     if (url.isEmpty() || !canLoadURL(url)) {
203         track().removeAllCues();
204         didCompleteLoad(HTMLTrackElement::Failure);
205         return;
206     }
207 
208     track().scheduleLoad(url);
209 }
210 
211 bool HTMLTrackElement::canLoadURL(const URL&amp; url)
212 {
213     auto parent = mediaElement();
214     if (!parent)
215         return false;
216 
217     // 4.8.10.12.3 Sourcing out-of-band text tracks
218 
219     // 4. Download: If URL is not the empty string, perform a potentially CORS-enabled fetch of URL, with the
220     // mode being the state of the media element&#39;s crossorigin content attribute, the origin being the
221     // origin of the media element&#39;s Document, and the default origin behaviour set to fail.
222     if (url.isEmpty())
223         return false;
224 
225     ASSERT(document().contentSecurityPolicy());
226     // Elements in user agent show tree should load whatever the embedding document policy is.
227     if (!isInUserAgentShadowTree() &amp;&amp; !document().contentSecurityPolicy()-&gt;allowMediaFromSource(url)) {
228         LOG(Media, &quot;HTMLTrackElement::canLoadURL(%s) -&gt; rejected by Content Security Policy&quot;, urlForLoggingTrack(url).utf8().data());
229         return false;
230     }
231 
232     return dispatchBeforeLoadEvent(url.string());
233 }
234 
235 void HTMLTrackElement::didCompleteLoad(LoadStatus status)
236 {
237     // 4.8.10.12.3 Sourcing out-of-band text tracks (continued)
238 
239     // 4. Download: ...
240     // If the fetching algorithm fails for any reason (network error, the server returns an error
241     // code, a cross-origin check fails, etc), or if URL is the empty string or has the wrong origin
242     // as determined by the condition at the start of this step, or if the fetched resource is not in
243     // a supported format, then queue a task to first change the text track readiness state to failed
244     // to load and then fire a simple event named error at the track element; and then, once that task
245     // is queued, move on to the step below labeled monitoring.
246 
247     if (status == Failure) {
248         setReadyState(HTMLTrackElement::TRACK_ERROR);
249         dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
250         return;
251     }
252 
253     // If the fetching algorithm does not fail, then the final task that is queued by the networking
254     // task source must run the following steps:
255     //     1. Change the text track readiness state to loaded.
256     setReadyState(HTMLTrackElement::LOADED);
257 
258     //     2. If the file was successfully processed, fire a simple event named load at the
259     //        track element.
260     dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
261 }
262 
263 // NOTE: The values in the TextTrack::ReadinessState enum must stay in sync with those in HTMLTrackElement::ReadyState.
264 COMPILE_ASSERT(HTMLTrackElement::NONE == static_cast&lt;HTMLTrackElement::ReadyState&gt;(TextTrack::NotLoaded), TextTrackEnumNotLoaded_Is_Wrong_Should_Be_HTMLTrackElementEnumNONE);
265 COMPILE_ASSERT(HTMLTrackElement::LOADING == static_cast&lt;HTMLTrackElement::ReadyState&gt;(TextTrack::Loading), TextTrackEnumLoadingIsWrong_ShouldBe_HTMLTrackElementEnumLOADING);
266 COMPILE_ASSERT(HTMLTrackElement::LOADED == static_cast&lt;HTMLTrackElement::ReadyState&gt;(TextTrack::Loaded), TextTrackEnumLoaded_Is_Wrong_Should_Be_HTMLTrackElementEnumLOADED);
267 COMPILE_ASSERT(HTMLTrackElement::TRACK_ERROR == static_cast&lt;HTMLTrackElement::ReadyState&gt;(TextTrack::FailedToLoad), TextTrackEnumFailedToLoad_Is_Wrong_Should_Be_HTMLTrackElementEnumTRACK_ERROR);
268 
269 void HTMLTrackElement::setReadyState(ReadyState state)
270 {
271     track().setReadinessState(static_cast&lt;TextTrack::ReadinessState&gt;(state));
272     if (auto parent = mediaElement())
273         parent-&gt;textTrackReadyStateChanged(m_track.get());
274 }
275 
276 HTMLTrackElement::ReadyState HTMLTrackElement::readyState()
277 {
278     return static_cast&lt;ReadyState&gt;(track().readinessState());
279 }
280 
281 const AtomString&amp; HTMLTrackElement::mediaElementCrossOriginAttribute() const
282 {
283     if (auto parent = mediaElement())
284         return parent-&gt;attributeWithoutSynchronization(HTMLNames::crossoriginAttr);
285     return nullAtom();
286 }
287 
288 void HTMLTrackElement::textTrackKindChanged(TextTrack&amp; track)
289 {
290     if (auto parent = mediaElement())
291         parent-&gt;textTrackKindChanged(track);
292 }
293 
294 void HTMLTrackElement::textTrackModeChanged(TextTrack&amp; track)
295 {
296     // Since we&#39;ve moved to a new parent, we may now be able to load.
297     if (readyState() == HTMLTrackElement::NONE)
298         scheduleLoad();
299 
300     if (auto parent = mediaElement())
301         parent-&gt;textTrackModeChanged(track);
302 }
303 
304 void HTMLTrackElement::textTrackAddCues(TextTrack&amp; track, const TextTrackCueList&amp; cues)
305 {
306     if (auto parent = mediaElement())
307         parent-&gt;textTrackAddCues(track, cues);
308 }
309 
310 void HTMLTrackElement::textTrackRemoveCues(TextTrack&amp; track, const TextTrackCueList&amp; cues)
311 {
312     if (auto parent = mediaElement())
313         parent-&gt;textTrackRemoveCues(track, cues);
314 }
315 
316 void HTMLTrackElement::textTrackAddCue(TextTrack&amp; track, TextTrackCue&amp; cue)
317 {
318     if (auto parent = mediaElement())
319         parent-&gt;textTrackAddCue(track, cue);
320 }
321 
322 void HTMLTrackElement::textTrackRemoveCue(TextTrack&amp; track, TextTrackCue&amp; cue)
323 {
324     if (auto parent = mediaElement())
325         parent-&gt;textTrackRemoveCue(track, cue);
326 }
327 
328 RefPtr&lt;HTMLMediaElement&gt; HTMLTrackElement::mediaElement() const
329 {
330     auto parent = makeRefPtr(parentElement());
331     if (!is&lt;HTMLMediaElement&gt;(parent))
332         return nullptr;
333     return downcast&lt;HTMLMediaElement&gt;(parent.get());
334 }
335 
336 }
337 
338 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertNumbers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMConvertNullable.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertNumbers.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertNumbers.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 42,22 ***</span>
  static String rangeErrorString(double value, double min, double max)
  {
      return makeString(&quot;Value &quot;, value, &quot; is outside the range [&quot;, min, &quot;, &quot;, max, &#39;]&#39;);
  }
  
<span class="line-modified">! static double enforceRange(ExecState&amp; state, double x, double minimum, double maximum)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (std::isnan(x) || std::isinf(x)) {
<span class="line-modified">!         throwTypeError(&amp;state, scope, rangeErrorString(x, minimum, maximum));</span>
          return 0;
      }
      x = trunc(x);
      if (x &lt; minimum || x &gt; maximum) {
<span class="line-modified">!         throwTypeError(&amp;state, scope, rangeErrorString(x, minimum, maximum));</span>
          return 0;
      }
      return x;
  }
  
<span class="line-new-header">--- 42,22 ---</span>
  static String rangeErrorString(double value, double min, double max)
  {
      return makeString(&quot;Value &quot;, value, &quot; is outside the range [&quot;, min, &quot;, &quot;, max, &#39;]&#39;);
  }
  
<span class="line-modified">! static double enforceRange(JSGlobalObject&amp; lexicalGlobalObject, double x, double minimum, double maximum)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (std::isnan(x) || std::isinf(x)) {
<span class="line-modified">!         throwTypeError(&amp;lexicalGlobalObject, scope, rangeErrorString(x, minimum, maximum));</span>
          return 0;
      }
      x = trunc(x);
      if (x &lt; minimum || x &gt; maximum) {
<span class="line-modified">!         throwTypeError(&amp;lexicalGlobalObject, scope, rangeErrorString(x, minimum, maximum));</span>
          return 0;
      }
      return x;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,13 ***</span>
  };
  
  }
  
  template &lt;typename T, IntegerConversionConfiguration configuration&gt;
<span class="line-modified">! static inline T toSmallerInt(ExecState&amp; state, JSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      static_assert(std::is_signed&lt;T&gt;::value &amp;&amp; std::is_integral&lt;T&gt;::value, &quot;Should only be used for signed integral types&quot;);
  
      typedef IntTypeLimits&lt;T&gt; LimitsTrait;
<span class="line-new-header">--- 94,13 ---</span>
  };
  
  }
  
  template &lt;typename T, IntegerConversionConfiguration configuration&gt;
<span class="line-modified">! static inline T toSmallerInt(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      static_assert(std::is_signed&lt;T&gt;::value &amp;&amp; std::is_integral&lt;T&gt;::value, &quot;Should only be used for signed integral types&quot;);
  
      typedef IntTypeLimits&lt;T&gt; LimitsTrait;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,27 ***</span>
              return static_cast&lt;T&gt;(d);
          switch (configuration) {
          case IntegerConversionConfiguration::Normal:
              break;
          case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">!             throwTypeError(&amp;state, scope);</span>
              return 0;
          case IntegerConversionConfiguration::Clamp:
              return d &lt; LimitsTrait::minValue ? LimitsTrait::minValue : LimitsTrait::maxValue;
          }
          d %= LimitsTrait::numberOfValues;
          return static_cast&lt;T&gt;(d &gt; LimitsTrait::maxValue ? d - LimitsTrait::numberOfValues : d);
      }
  
<span class="line-modified">!     double x = value.toNumber(&amp;state);</span>
      RETURN_IF_EXCEPTION(scope, 0);
  
      switch (configuration) {
      case IntegerConversionConfiguration::Normal:
          break;
      case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">!         return enforceRange(state, x, LimitsTrait::minValue, LimitsTrait::maxValue);</span>
      case IntegerConversionConfiguration::Clamp:
          return std::isnan(x) ? 0 : clampTo&lt;T&gt;(x);
      }
  
      if (std::isnan(x) || std::isinf(x) || !x)
<span class="line-new-header">--- 111,27 ---</span>
              return static_cast&lt;T&gt;(d);
          switch (configuration) {
          case IntegerConversionConfiguration::Normal:
              break;
          case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">!             throwTypeError(&amp;lexicalGlobalObject, scope);</span>
              return 0;
          case IntegerConversionConfiguration::Clamp:
              return d &lt; LimitsTrait::minValue ? LimitsTrait::minValue : LimitsTrait::maxValue;
          }
          d %= LimitsTrait::numberOfValues;
          return static_cast&lt;T&gt;(d &gt; LimitsTrait::maxValue ? d - LimitsTrait::numberOfValues : d);
      }
  
<span class="line-modified">!     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
      RETURN_IF_EXCEPTION(scope, 0);
  
      switch (configuration) {
      case IntegerConversionConfiguration::Normal:
          break;
      case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">!         return enforceRange(lexicalGlobalObject, x, LimitsTrait::minValue, LimitsTrait::maxValue);</span>
      case IntegerConversionConfiguration::Clamp:
          return std::isnan(x) ? 0 : clampTo&lt;T&gt;(x);
      }
  
      if (std::isnan(x) || std::isinf(x) || !x)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,13 ***</span>
  
      return static_cast&lt;T&gt;(x &gt; LimitsTrait::maxValue ? x - LimitsTrait::numberOfValues : x);
  }
  
  template &lt;typename T, IntegerConversionConfiguration configuration&gt;
<span class="line-modified">! static inline T toSmallerUInt(ExecState&amp; state, JSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      static_assert(std::is_unsigned&lt;T&gt;::value &amp;&amp; std::is_integral&lt;T&gt;::value, &quot;Should only be used for unsigned integral types&quot;);
  
      typedef IntTypeLimits&lt;T&gt; LimitsTrait;
<span class="line-new-header">--- 142,13 ---</span>
  
      return static_cast&lt;T&gt;(x &gt; LimitsTrait::maxValue ? x - LimitsTrait::numberOfValues : x);
  }
  
  template &lt;typename T, IntegerConversionConfiguration configuration&gt;
<span class="line-modified">! static inline T toSmallerUInt(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      static_assert(std::is_unsigned&lt;T&gt;::value &amp;&amp; std::is_integral&lt;T&gt;::value, &quot;Should only be used for unsigned integral types&quot;);
  
      typedef IntTypeLimits&lt;T&gt; LimitsTrait;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 159,25 ***</span>
              return static_cast&lt;T&gt;(d);
          switch (configuration) {
          case IntegerConversionConfiguration::Normal:
              return static_cast&lt;T&gt;(d);
          case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">!             throwTypeError(&amp;state, scope);</span>
              return 0;
          case IntegerConversionConfiguration::Clamp:
              return LimitsTrait::maxValue;
          }
      }
  
<span class="line-modified">!     double x = value.toNumber(&amp;state);</span>
      RETURN_IF_EXCEPTION(scope, 0);
  
      switch (configuration) {
      case IntegerConversionConfiguration::Normal:
          break;
      case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">!         return enforceRange(state, x, 0, LimitsTrait::maxValue);</span>
      case IntegerConversionConfiguration::Clamp:
          return std::isnan(x) ? 0 : clampTo&lt;T&gt;(x);
      }
  
      if (std::isnan(x) || std::isinf(x) || !x)
<span class="line-new-header">--- 159,25 ---</span>
              return static_cast&lt;T&gt;(d);
          switch (configuration) {
          case IntegerConversionConfiguration::Normal:
              return static_cast&lt;T&gt;(d);
          case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">!             throwTypeError(&amp;lexicalGlobalObject, scope);</span>
              return 0;
          case IntegerConversionConfiguration::Clamp:
              return LimitsTrait::maxValue;
          }
      }
  
<span class="line-modified">!     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
      RETURN_IF_EXCEPTION(scope, 0);
  
      switch (configuration) {
      case IntegerConversionConfiguration::Normal:
          break;
      case IntegerConversionConfiguration::EnforceRange:
<span class="line-modified">!         return enforceRange(lexicalGlobalObject, x, 0, LimitsTrait::maxValue);</span>
      case IntegerConversionConfiguration::Clamp:
          return std::isnan(x) ? 0 : clampTo&lt;T&gt;(x);
      }
  
      if (std::isnan(x) || std::isinf(x) || !x)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,187 ***</span>
  
      x = x &lt; 0 ? -floor(fabs(x)) : floor(fabs(x));
      return static_cast&lt;T&gt;(fmod(x, LimitsTrait::numberOfValues));
  }
  
<span class="line-modified">! template&lt;&gt; int8_t convertToIntegerEnforceRange&lt;int8_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerInt&lt;int8_t, IntegerConversionConfiguration::EnforceRange&gt;(state, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint8_t convertToIntegerEnforceRange&lt;uint8_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerUInt&lt;uint8_t, IntegerConversionConfiguration::EnforceRange&gt;(state, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int8_t convertToIntegerClamp&lt;int8_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerInt&lt;int8_t, IntegerConversionConfiguration::Clamp&gt;(state, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint8_t convertToIntegerClamp&lt;uint8_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerUInt&lt;uint8_t, IntegerConversionConfiguration::Clamp&gt;(state, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int8_t convertToInteger&lt;int8_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerInt&lt;int8_t, IntegerConversionConfiguration::Normal&gt;(state, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint8_t convertToInteger&lt;uint8_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerUInt&lt;uint8_t, IntegerConversionConfiguration::Normal&gt;(state, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int16_t convertToIntegerEnforceRange&lt;int16_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerInt&lt;int16_t, IntegerConversionConfiguration::EnforceRange&gt;(state, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint16_t convertToIntegerEnforceRange&lt;uint16_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerUInt&lt;uint16_t, IntegerConversionConfiguration::EnforceRange&gt;(state, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int16_t convertToIntegerClamp&lt;int16_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerInt&lt;int16_t, IntegerConversionConfiguration::Clamp&gt;(state, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint16_t convertToIntegerClamp&lt;uint16_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerUInt&lt;uint16_t, IntegerConversionConfiguration::Clamp&gt;(state, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int16_t convertToInteger&lt;int16_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerInt&lt;int16_t, IntegerConversionConfiguration::Normal&gt;(state, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint16_t convertToInteger&lt;uint16_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerUInt&lt;uint16_t, IntegerConversionConfiguration::Normal&gt;(state, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int32_t convertToIntegerEnforceRange&lt;int32_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
      if (value.isInt32())
          return value.asInt32();
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     double x = value.toNumber(&amp;state);</span>
      RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">!     return enforceRange(state, x, kMinInt32, kMaxInt32);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint32_t convertToIntegerEnforceRange&lt;uint32_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
      if (value.isUInt32())
          return value.asUInt32();
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     double x = value.toNumber(&amp;state);</span>
      RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">!     return enforceRange(state, x, 0, kMaxUInt32);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int32_t convertToIntegerClamp&lt;int32_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
      if (value.isInt32())
          return value.asInt32();
  
<span class="line-modified">!     double x = value.toNumber(&amp;state);</span>
      return std::isnan(x) ? 0 : clampTo&lt;int32_t&gt;(x);
  }
  
<span class="line-modified">! template&lt;&gt; uint32_t convertToIntegerClamp&lt;uint32_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
      if (value.isUInt32())
          return value.asUInt32();
  
<span class="line-modified">!     double x = value.toNumber(&amp;state);</span>
      return std::isnan(x) ? 0 : clampTo&lt;uint32_t&gt;(x);
  }
  
<span class="line-modified">! template&lt;&gt; int32_t convertToInteger&lt;int32_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return value.toInt32(&amp;state);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint32_t convertToInteger&lt;uint32_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return value.toUInt32(&amp;state);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int64_t convertToIntegerEnforceRange&lt;int64_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
      if (value.isInt32())
          return value.asInt32();
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     double x = value.toNumber(&amp;state);</span>
      RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">!     return enforceRange(state, x, -kJSMaxInteger, kJSMaxInteger);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint64_t convertToIntegerEnforceRange&lt;uint64_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
      if (value.isUInt32())
          return value.asUInt32();
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     double x = value.toNumber(&amp;state);</span>
      RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">!     return enforceRange(state, x, 0, kJSMaxInteger);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int64_t convertToIntegerClamp&lt;int64_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
      if (value.isInt32())
          return value.asInt32();
  
<span class="line-modified">!     double x = value.toNumber(&amp;state);</span>
      return std::isnan(x) ? 0 : static_cast&lt;int64_t&gt;(std::min&lt;double&gt;(std::max&lt;double&gt;(x, -kJSMaxInteger), kJSMaxInteger));
  }
  
<span class="line-modified">! template&lt;&gt; uint64_t convertToIntegerClamp&lt;uint64_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
      if (value.isUInt32())
          return value.asUInt32();
  
<span class="line-modified">!     double x = value.toNumber(&amp;state);</span>
      return std::isnan(x) ? 0 : static_cast&lt;uint64_t&gt;(std::min&lt;double&gt;(std::max&lt;double&gt;(x, 0), kJSMaxInteger));
  }
  
<span class="line-modified">! template&lt;&gt; int64_t convertToInteger&lt;int64_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
      if (value.isInt32())
          return value.asInt32();
  
<span class="line-modified">!     double x = value.toNumber(&amp;state);</span>
  
      // Map NaNs and +/-Infinity to 0; convert finite values modulo 2^64.
      unsigned long long n;
      doubleToInteger(x, n);
      return n;
  }
  
<span class="line-modified">! template&lt;&gt; uint64_t convertToInteger&lt;uint64_t&gt;(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
      if (value.isUInt32())
          return value.asUInt32();
  
<span class="line-modified">!     double x = value.toNumber(&amp;state);</span>
  
      // Map NaNs and +/-Infinity to 0; convert finite values modulo 2^64.
      unsigned long long n;
      doubleToInteger(x, n);
      return n;
<span class="line-new-header">--- 185,187 ---</span>
  
      x = x &lt; 0 ? -floor(fabs(x)) : floor(fabs(x));
      return static_cast&lt;T&gt;(fmod(x, LimitsTrait::numberOfValues));
  }
  
<span class="line-modified">! template&lt;&gt; int8_t convertToIntegerEnforceRange&lt;int8_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerInt&lt;int8_t, IntegerConversionConfiguration::EnforceRange&gt;(lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint8_t convertToIntegerEnforceRange&lt;uint8_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerUInt&lt;uint8_t, IntegerConversionConfiguration::EnforceRange&gt;(lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int8_t convertToIntegerClamp&lt;int8_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerInt&lt;int8_t, IntegerConversionConfiguration::Clamp&gt;(lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint8_t convertToIntegerClamp&lt;uint8_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerUInt&lt;uint8_t, IntegerConversionConfiguration::Clamp&gt;(lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int8_t convertToInteger&lt;int8_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerInt&lt;int8_t, IntegerConversionConfiguration::Normal&gt;(lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint8_t convertToInteger&lt;uint8_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerUInt&lt;uint8_t, IntegerConversionConfiguration::Normal&gt;(lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int16_t convertToIntegerEnforceRange&lt;int16_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerInt&lt;int16_t, IntegerConversionConfiguration::EnforceRange&gt;(lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint16_t convertToIntegerEnforceRange&lt;uint16_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerUInt&lt;uint16_t, IntegerConversionConfiguration::EnforceRange&gt;(lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int16_t convertToIntegerClamp&lt;int16_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerInt&lt;int16_t, IntegerConversionConfiguration::Clamp&gt;(lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint16_t convertToIntegerClamp&lt;uint16_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerUInt&lt;uint16_t, IntegerConversionConfiguration::Clamp&gt;(lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int16_t convertToInteger&lt;int16_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerInt&lt;int16_t, IntegerConversionConfiguration::Normal&gt;(lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint16_t convertToInteger&lt;uint16_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return toSmallerUInt&lt;uint16_t, IntegerConversionConfiguration::Normal&gt;(lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int32_t convertToIntegerEnforceRange&lt;int32_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
      if (value.isInt32())
          return value.asInt32();
  
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
      RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">!     return enforceRange(lexicalGlobalObject, x, kMinInt32, kMaxInt32);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint32_t convertToIntegerEnforceRange&lt;uint32_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
      if (value.isUInt32())
          return value.asUInt32();
  
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
      RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">!     return enforceRange(lexicalGlobalObject, x, 0, kMaxUInt32);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int32_t convertToIntegerClamp&lt;int32_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
      if (value.isInt32())
          return value.asInt32();
  
<span class="line-modified">!     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
      return std::isnan(x) ? 0 : clampTo&lt;int32_t&gt;(x);
  }
  
<span class="line-modified">! template&lt;&gt; uint32_t convertToIntegerClamp&lt;uint32_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
      if (value.isUInt32())
          return value.asUInt32();
  
<span class="line-modified">!     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
      return std::isnan(x) ? 0 : clampTo&lt;uint32_t&gt;(x);
  }
  
<span class="line-modified">! template&lt;&gt; int32_t convertToInteger&lt;int32_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return value.toInt32(&amp;lexicalGlobalObject);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint32_t convertToInteger&lt;uint32_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     return value.toUInt32(&amp;lexicalGlobalObject);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int64_t convertToIntegerEnforceRange&lt;int64_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
      if (value.isInt32())
          return value.asInt32();
  
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
      RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">!     return enforceRange(lexicalGlobalObject, x, -kJSMaxInteger, kJSMaxInteger);</span>
  }
  
<span class="line-modified">! template&lt;&gt; uint64_t convertToIntegerEnforceRange&lt;uint64_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
      if (value.isUInt32())
          return value.asUInt32();
  
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
      RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">!     return enforceRange(lexicalGlobalObject, x, 0, kJSMaxInteger);</span>
  }
  
<span class="line-modified">! template&lt;&gt; int64_t convertToIntegerClamp&lt;int64_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
      if (value.isInt32())
          return value.asInt32();
  
<span class="line-modified">!     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
      return std::isnan(x) ? 0 : static_cast&lt;int64_t&gt;(std::min&lt;double&gt;(std::max&lt;double&gt;(x, -kJSMaxInteger), kJSMaxInteger));
  }
  
<span class="line-modified">! template&lt;&gt; uint64_t convertToIntegerClamp&lt;uint64_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
      if (value.isUInt32())
          return value.asUInt32();
  
<span class="line-modified">!     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
      return std::isnan(x) ? 0 : static_cast&lt;uint64_t&gt;(std::min&lt;double&gt;(std::max&lt;double&gt;(x, 0), kJSMaxInteger));
  }
  
<span class="line-modified">! template&lt;&gt; int64_t convertToInteger&lt;int64_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
      if (value.isInt32())
          return value.asInt32();
  
<span class="line-modified">!     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
  
      // Map NaNs and +/-Infinity to 0; convert finite values modulo 2^64.
      unsigned long long n;
      doubleToInteger(x, n);
      return n;
  }
  
<span class="line-modified">! template&lt;&gt; uint64_t convertToInteger&lt;uint64_t&gt;(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
      if (value.isUInt32())
          return value.asUInt32();
  
<span class="line-modified">!     double x = value.toNumber(&amp;lexicalGlobalObject);</span>
  
      // Map NaNs and +/-Infinity to 0; convert finite values modulo 2^64.
      unsigned long long n;
      doubleToInteger(x, n);
      return n;
</pre>
<center><a href="JSDOMConvertNullable.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertNumbers.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
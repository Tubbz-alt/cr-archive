<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderText.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderTableSection.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderText.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderText.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 35,11 ---</span>
  #include &quot;Frame.h&quot;
  #include &quot;FrameView.h&quot;
  #include &quot;HTMLParserIdioms.h&quot;
  #include &quot;Hyphenation.h&quot;
  #include &quot;InlineTextBox.h&quot;
<span class="line-added">+ #include &quot;LineLayoutTraversal.h&quot;</span>
  #include &quot;Range.h&quot;
  #include &quot;RenderBlock.h&quot;
  #include &quot;RenderCombineText.h&quot;
  #include &quot;RenderInline.h&quot;
  #include &quot;RenderLayer.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,27 ***</span>
      setInlineWrapperForDisplayContents(nullptr);
  
      RenderObject::willBeDestroyed();
  }
  
<span class="line-removed">- void RenderText::deleteLineBoxesBeforeSimpleLineLayout()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_lineBoxes.deleteAll();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  String RenderText::originalText() const
  {
      return m_originalTextDiffersFromRendered ? originalTextMap().get(this) : m_text;
  }
  
  void RenderText::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
  {
<span class="line-modified">!     if (auto* layout = simpleLineLayout()) {</span>
<span class="line-modified">!         rects.appendVector(SimpleLineLayout::collectAbsoluteRects(*this, *layout, accumulatedOffset));</span>
<span class="line-modified">!         return;</span>
      }
<span class="line-removed">-     rects.appendVector(m_lineBoxes.absoluteRects(accumulatedOffset));</span>
  }
  
  Vector&lt;IntRect&gt; RenderText::absoluteRectsForRange(unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const
  {
      const_cast&lt;RenderText&amp;&gt;(*this).ensureLineBoxes();
<span class="line-new-header">--- 305,21 ---</span>
      setInlineWrapperForDisplayContents(nullptr);
  
      RenderObject::willBeDestroyed();
  }
  
  String RenderText::originalText() const
  {
      return m_originalTextDiffersFromRendered ? originalTextMap().get(this) : m_text;
  }
  
  void RenderText::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
  {
<span class="line-modified">!     for (auto&amp; box : LineLayoutTraversal::textBoxesFor(*this)) {</span>
<span class="line-modified">!         auto rect = box.rect();</span>
<span class="line-modified">!         rects.append(enclosingIntRect(FloatRect(accumulatedOffset + rect.location(), rect.size())));</span>
      }
  }
  
  Vector&lt;IntRect&gt; RenderText::absoluteRectsForRange(unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const
  {
      const_cast&lt;RenderText&amp;&gt;(*this).ensureLineBoxes();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 358,15 ***</span>
      start = std::min(start, static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()));
      end = std::min(end, static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()));
  
      for (InlineTextBox* box = firstTextBox(); box; box = box-&gt;nextTextBox()) {
          LayoutRect rect;
<span class="line-modified">!         // Note, box-&gt;end() returns the index of the last character, not the index past it.</span>
<span class="line-removed">-         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt; end)</span>
              rect = box-&gt;localSelectionRect(start, end);
          else {
<span class="line-modified">!             unsigned realEnd = std::min(box-&gt;end() + 1, end);</span>
              rect = box-&gt;localSelectionRect(start, realEnd);
              if (rect.isEmpty())
                  continue;
          }
  
<span class="line-new-header">--- 353,14 ---</span>
      start = std::min(start, static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()));
      end = std::min(end, static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()));
  
      for (InlineTextBox* box = firstTextBox(); box; box = box-&gt;nextTextBox()) {
          LayoutRect rect;
<span class="line-modified">!         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt;= end)</span>
              rect = box-&gt;localSelectionRect(start, end);
          else {
<span class="line-modified">!             unsigned realEnd = std::min(box-&gt;end(), end);</span>
              rect = box-&gt;localSelectionRect(start, realEnd);
              if (rect.isEmpty())
                  continue;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 396,12 ***</span>
          bool isFirstOnLine = !box-&gt;previousOnLineExists();
          bool isLastOnLine = !box-&gt;nextOnLineExists();
          if (containingBlock-&gt;isRubyBase() || containingBlock-&gt;isRubyText())
              isLastOnLine = !containingBlock-&gt;containingBlock()-&gt;inlineBoxWrapper()-&gt;nextOnLineExists();
  
<span class="line-modified">!         bool containsStart = box-&gt;start() &lt;= start &amp;&amp; box-&gt;end() + 1 &gt;= start;</span>
<span class="line-modified">!         bool containsEnd = box-&gt;start() &lt;= end &amp;&amp; box-&gt;end() + 1 &gt;= end;</span>
  
          bool isFixed = false;
          IntRect absRect = localToAbsoluteQuad(FloatRect(rect), UseTransforms, &amp;isFixed).enclosingBoundingBox();
          bool boxIsHorizontal = !box-&gt;isSVGInlineTextBox() ? box-&gt;isHorizontal() : !style().isVerticalWritingMode();
          // If the containing block is an inline element, we want to check the inlineBoxWrapper orientation
<span class="line-new-header">--- 390,12 ---</span>
          bool isFirstOnLine = !box-&gt;previousOnLineExists();
          bool isLastOnLine = !box-&gt;nextOnLineExists();
          if (containingBlock-&gt;isRubyBase() || containingBlock-&gt;isRubyText())
              isLastOnLine = !containingBlock-&gt;containingBlock()-&gt;inlineBoxWrapper()-&gt;nextOnLineExists();
  
<span class="line-modified">!         bool containsStart = box-&gt;start() &lt;= start &amp;&amp; box-&gt;end() &gt;= start;</span>
<span class="line-modified">!         bool containsEnd = box-&gt;start() &lt;= end &amp;&amp; box-&gt;end() &gt;= end;</span>
  
          bool isFixed = false;
          IntRect absRect = localToAbsoluteQuad(FloatRect(rect), UseTransforms, &amp;isFixed).enclosingBoundingBox();
          bool boxIsHorizontal = !box-&gt;isSVGInlineTextBox() ? box-&gt;isHorizontal() : !style().isVerticalWritingMode();
          // If the containing block is an inline element, we want to check the inlineBoxWrapper orientation
</pre>
<hr />
<pre>
<span class="line-old-header">*** 417,29 ***</span>
          rects.append(SelectionRect(absRect, box-&gt;direction(), extentsRect.x(), extentsRect.maxX(), extentsRect.maxY(), 0, box-&gt;isLineBreak(), isFirstOnLine, isLastOnLine, containsStart, containsEnd, boxIsHorizontal, isFixed, containingBlock-&gt;isRubyText(), view().pageNumberForBlockProgressionOffset(absRect.x())));
      }
  }
  #endif
  
  Vector&lt;FloatQuad&gt; RenderText::absoluteQuadsClippedToEllipsis() const
  {
<span class="line-modified">!     if (auto* layout = simpleLineLayout()) {</span>
          ASSERT(style().textOverflow() != TextOverflow::Ellipsis);
<span class="line-modified">!         return SimpleLineLayout::collectAbsoluteQuads(*this, *layout, nullptr);</span>
      }
      return m_lineBoxes.absoluteQuads(*this, nullptr, RenderTextLineBoxes::ClipToEllipsis);
  }
  
  void RenderText::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
  {
<span class="line-modified">!     if (auto* layout = simpleLineLayout()) {</span>
<span class="line-modified">!         quads.appendVector(SimpleLineLayout::collectAbsoluteQuads(*this, *layout, wasFixed));</span>
          return;
      }
      quads.appendVector(m_lineBoxes.absoluteQuads(*this, wasFixed, RenderTextLineBoxes::NoClipping));
  }
  
<span class="line-modified">! Vector&lt;FloatQuad&gt; RenderText::absoluteQuadsForRange(unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const</span>
  {
      // Work around signed/unsigned issues. This function takes unsigneds, and is often passed UINT_MAX
      // to mean &quot;all the way to the end&quot;. InlineTextBox coordinates are unsigneds, so changing this
      // function to take ints causes various internal mismatches. But selectionRect takes ints, and
      // passing UINT_MAX to it causes trouble. Ideally we&#39;d change selectionRect to take unsigneds, but
<span class="line-new-header">--- 411,40 ---</span>
          rects.append(SelectionRect(absRect, box-&gt;direction(), extentsRect.x(), extentsRect.maxX(), extentsRect.maxY(), 0, box-&gt;isLineBreak(), isFirstOnLine, isLastOnLine, containsStart, containsEnd, boxIsHorizontal, isFixed, containingBlock-&gt;isRubyText(), view().pageNumberForBlockProgressionOffset(absRect.x())));
      }
  }
  #endif
  
<span class="line-added">+ static Vector&lt;FloatQuad&gt; collectAbsoluteQuadsForNonComplexPaths(const RenderText&amp; textRenderer, bool* wasFixed)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // FIXME: This generic function doesn&#39;t currently cover everything that is needed for the complex line layout path.</span>
<span class="line-added">+     ASSERT(!textRenderer.usesComplexLineLayoutPath());</span>
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;FloatQuad&gt; quads;</span>
<span class="line-added">+     for (auto&amp; box : LineLayoutTraversal::textBoxesFor(textRenderer))</span>
<span class="line-added">+         quads.append(textRenderer.localToAbsoluteQuad(FloatQuad(box.rect()), UseTransforms, wasFixed));</span>
<span class="line-added">+     return quads;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  Vector&lt;FloatQuad&gt; RenderText::absoluteQuadsClippedToEllipsis() const
  {
<span class="line-modified">!     if (!usesComplexLineLayoutPath()) {</span>
          ASSERT(style().textOverflow() != TextOverflow::Ellipsis);
<span class="line-modified">!         return collectAbsoluteQuadsForNonComplexPaths(*this, nullptr);</span>
      }
      return m_lineBoxes.absoluteQuads(*this, nullptr, RenderTextLineBoxes::ClipToEllipsis);
  }
  
  void RenderText::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
  {
<span class="line-modified">!     if (!usesComplexLineLayoutPath()) {</span>
<span class="line-modified">!         quads.appendVector(collectAbsoluteQuadsForNonComplexPaths(*this, wasFixed));</span>
          return;
      }
      quads.appendVector(m_lineBoxes.absoluteQuads(*this, wasFixed, RenderTextLineBoxes::NoClipping));
  }
  
<span class="line-modified">! Vector&lt;FloatQuad&gt; RenderText::absoluteQuadsForRange(unsigned start, unsigned end, bool useSelectionHeight, bool ignoreEmptyTextSelections, bool* wasFixed) const</span>
  {
      // Work around signed/unsigned issues. This function takes unsigneds, and is often passed UINT_MAX
      // to mean &quot;all the way to the end&quot;. InlineTextBox coordinates are unsigneds, so changing this
      // function to take ints causes various internal mismatches. But selectionRect takes ints, and
      // passing UINT_MAX to it causes trouble. Ideally we&#39;d change selectionRect to take unsigneds, but
</pre>
<hr />
<pre>
<span class="line-old-header">*** 447,13 ***</span>
      ASSERT(end == UINT_MAX || end &lt;= INT_MAX);
      ASSERT(start &lt;= INT_MAX);
      start = std::min(start, static_cast&lt;unsigned&gt;(INT_MAX));
      end = std::min(end, static_cast&lt;unsigned&gt;(INT_MAX));
      if (simpleLineLayout() &amp;&amp; !useSelectionHeight)
<span class="line-modified">!         return collectAbsoluteQuadsForRange(*this, start, end, *simpleLineLayout(), wasFixed);</span>
      const_cast&lt;RenderText&amp;&gt;(*this).ensureLineBoxes();
<span class="line-modified">!     return m_lineBoxes.absoluteQuadsForRange(*this, start, end, useSelectionHeight, wasFixed);</span>
  }
  
  Position RenderText::positionForPoint(const LayoutPoint&amp; point)
  {
      if (simpleLineLayout() &amp;&amp; parent()-&gt;firstChild() == parent()-&gt;lastChild()) {
<span class="line-new-header">--- 452,13 ---</span>
      ASSERT(end == UINT_MAX || end &lt;= INT_MAX);
      ASSERT(start &lt;= INT_MAX);
      start = std::min(start, static_cast&lt;unsigned&gt;(INT_MAX));
      end = std::min(end, static_cast&lt;unsigned&gt;(INT_MAX));
      if (simpleLineLayout() &amp;&amp; !useSelectionHeight)
<span class="line-modified">!         return collectAbsoluteQuadsForRange(*this, start, end, *simpleLineLayout(), ignoreEmptyTextSelections, wasFixed);</span>
      const_cast&lt;RenderText&amp;&gt;(*this).ensureLineBoxes();
<span class="line-modified">!     return m_lineBoxes.absoluteQuadsForRange(*this, start, end, useSelectionHeight, ignoreEmptyTextSelections, wasFixed);</span>
  }
  
  Position RenderText::positionForPoint(const LayoutPoint&amp; point)
  {
      if (simpleLineLayout() &amp;&amp; parent()-&gt;firstChild() == parent()-&gt;lastChild()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1079,14 ***</span>
      return draggedContentRanges;
  }
  
  IntPoint RenderText::firstRunLocation() const
  {
<span class="line-modified">!     if (auto* layout = simpleLineLayout())</span>
<span class="line-modified">!         return SimpleLineLayout::computeFirstRunLocation(*this, *layout);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return m_lineBoxes.firstRunLocation();</span>
  }
  
  void RenderText::setSelectionState(SelectionState state)
  {
      if (state != SelectionNone)
<span class="line-new-header">--- 1084,14 ---</span>
      return draggedContentRanges;
  }
  
  IntPoint RenderText::firstRunLocation() const
  {
<span class="line-modified">!     auto first = LineLayoutTraversal::firstTextBoxFor(*this);</span>
<span class="line-modified">!     if (!first)</span>
<span class="line-modified">!         return { };</span>
<span class="line-modified">!     return IntPoint(first-&gt;rect().location());</span>
  }
  
  void RenderText::setSelectionState(SelectionState state)
  {
      if (state != SelectionNone)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1107,11 ***</span>
  {
      if (!force &amp;&amp; text() == newText)
          return;
  
      int delta = newText.length() - text().length();
<span class="line-modified">!     unsigned end = length ? offset + length - 1 : offset;</span>
  
      m_linesDirty = simpleLineLayout() || m_lineBoxes.dirtyRange(*this, offset, end, delta);
  
      setText(newText, force || m_linesDirty);
  }
<span class="line-new-header">--- 1112,11 ---</span>
  {
      if (!force &amp;&amp; text() == newText)
          return;
  
      int delta = newText.length() - text().length();
<span class="line-modified">!     unsigned end = offset + length;</span>
  
      m_linesDirty = simpleLineLayout() || m_lineBoxes.dirtyRange(*this, offset, end, delta);
  
      setText(newText, force || m_linesDirty);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1333,10 ***</span>
<span class="line-new-header">--- 1338,30 ---</span>
      if (!is&lt;RenderBlockFlow&gt;(*parent()))
          return nullptr;
      return downcast&lt;RenderBlockFlow&gt;(*parent()).simpleLineLayout();
  }
  
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+ const LayoutIntegration::LineLayout* RenderText::layoutFormattingContextLineLayout() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!is&lt;RenderBlockFlow&gt;(*parent()))</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     return downcast&lt;RenderBlockFlow&gt;(*parent()).layoutFormattingContextLineLayout();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool RenderText::usesComplexLineLayoutPath() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (simpleLineLayout())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+     if (layoutFormattingContextLineLayout())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  float RenderText::width(unsigned from, unsigned len, float xPos, bool firstLine, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
  {
      if (from &gt;= text().length())
          return 0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1381,14 ***</span>
      return w;
  }
  
  IntRect RenderText::linesBoundingBox() const
  {
<span class="line-modified">!     if (auto* layout = simpleLineLayout())</span>
<span class="line-modified">!         return SimpleLineLayout::computeBoundingBox(*this, *layout);</span>
  
<span class="line-modified">!     return m_lineBoxes.boundingBox(*this);</span>
  }
  
  LayoutRect RenderText::linesVisualOverflowBoundingBox() const
  {
      ASSERT(!simpleLineLayout());
<span class="line-new-header">--- 1406,19 ---</span>
      return w;
  }
  
  IntRect RenderText::linesBoundingBox() const
  {
<span class="line-modified">!     auto first = LineLayoutTraversal::firstTextBoxFor(*this);</span>
<span class="line-modified">!     if (!first)</span>
<span class="line-added">+         return { };</span>
  
<span class="line-modified">!     auto boundingBox = first-&gt;rect();</span>
<span class="line-added">+     for (auto box = first; ++box;)</span>
<span class="line-added">+         boundingBox.uniteEvenIfEmpty(box-&gt;rect());</span>
<span class="line-added">+ </span>
<span class="line-added">+     return enclosingIntRect(boundingBox);</span>
  }
  
  LayoutRect RenderText::linesVisualOverflowBoundingBox() const
  {
      ASSERT(!simpleLineLayout());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1421,33 ***</span>
      if (!containingBlock())
          return LayoutRect();
  
      // Now calculate startPos and endPos for painting selection.
      // We include a selection while endPos &gt; 0
<span class="line-modified">!     unsigned startPos;</span>
<span class="line-modified">!     unsigned endPos;</span>
      if (selectionState() == SelectionInside) {
          // We are fully selected.
<span class="line-modified">!         startPos = 0;</span>
<span class="line-modified">!         endPos = text().length();</span>
      } else {
<span class="line-modified">!         startPos = view().selection().startPosition();</span>
<span class="line-modified">!         endPos = view().selection().endPosition();</span>
          if (selectionState() == SelectionStart)
<span class="line-modified">!             endPos = text().length();</span>
          else if (selectionState() == SelectionEnd)
<span class="line-modified">!             startPos = 0;</span>
      }
  
<span class="line-modified">!     if (startPos == endPos)</span>
          return IntRect();
  
      LayoutRect resultRect;
      if (!rects)
<span class="line-modified">!         resultRect = m_lineBoxes.selectionRectForRange(startPos, endPos);</span>
      else {
<span class="line-modified">!         m_lineBoxes.collectSelectionRectsForRange(startPos, endPos, *rects);</span>
          for (auto&amp; rect : *rects) {
              resultRect.unite(rect);
              rect = localToContainerQuad(FloatRect(rect), repaintContainer).enclosingBoundingBox();
          }
      }
<span class="line-new-header">--- 1451,33 ---</span>
      if (!containingBlock())
          return LayoutRect();
  
      // Now calculate startPos and endPos for painting selection.
      // We include a selection while endPos &gt; 0
<span class="line-modified">!     unsigned startOffset;</span>
<span class="line-modified">!     unsigned endOffset;</span>
      if (selectionState() == SelectionInside) {
          // We are fully selected.
<span class="line-modified">!         startOffset = 0;</span>
<span class="line-modified">!         endOffset = text().length();</span>
      } else {
<span class="line-modified">!         startOffset = view().selection().startOffset();</span>
<span class="line-modified">!         endOffset = view().selection().endOffset();</span>
          if (selectionState() == SelectionStart)
<span class="line-modified">!             endOffset = text().length();</span>
          else if (selectionState() == SelectionEnd)
<span class="line-modified">!             startOffset = 0;</span>
      }
  
<span class="line-modified">!     if (startOffset == endOffset)</span>
          return IntRect();
  
      LayoutRect resultRect;
      if (!rects)
<span class="line-modified">!         resultRect = m_lineBoxes.selectionRectForRange(startOffset, endOffset);</span>
      else {
<span class="line-modified">!         m_lineBoxes.collectSelectionRectsForRange(startOffset, endOffset, *rects);</span>
          for (auto&amp; rect : *rects) {
              resultRect.unite(rect);
              rect = localToContainerQuad(FloatRect(rect), repaintContainer).enclosingBoundingBox();
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1467,47 ***</span>
      return collectSelectionRectsForLineBoxes(repaintContainer, clipToVisibleContent, nullptr);
  }
  
  int RenderText::caretMinOffset() const
  {
<span class="line-modified">!     if (auto* layout = simpleLineLayout())</span>
<span class="line-modified">!         return SimpleLineLayout::findCaretMinimumOffset(*this, *layout);</span>
<span class="line-modified">!     return m_lineBoxes.caretMinOffset();</span>
  }
  
  int RenderText::caretMaxOffset() const
  {
<span class="line-modified">!     if (auto* layout = simpleLineLayout())</span>
<span class="line-modified">!         return SimpleLineLayout::findCaretMaximumOffset(*this, *layout);</span>
<span class="line-modified">!     return m_lineBoxes.caretMaxOffset(*this);</span>
  }
  
  unsigned RenderText::countRenderedCharacterOffsetsUntil(unsigned offset) const
  {
<span class="line-modified">!     ASSERT(!simpleLineLayout());</span>
<span class="line-modified">!     return m_lineBoxes.countCharacterOffsetsUntil(offset);</span>
  }
  
  bool RenderText::containsRenderedCharacterOffset(unsigned offset) const
  {
<span class="line-modified">!     if (auto* layout = simpleLineLayout())</span>
<span class="line-removed">-         return SimpleLineLayout::containsOffset(*this, *layout, offset, SimpleLineLayout::OffsetType::CharacterOffset);</span>
<span class="line-removed">-     return m_lineBoxes.containsOffset(*this, offset, RenderTextLineBoxes::CharacterOffset);</span>
  }
  
  bool RenderText::containsCaretOffset(unsigned offset) const
  {
<span class="line-modified">!     if (auto* layout = simpleLineLayout())</span>
<span class="line-removed">-         return SimpleLineLayout::containsOffset(*this, *layout, offset, SimpleLineLayout::OffsetType::CaretOffset);</span>
<span class="line-removed">-     return m_lineBoxes.containsOffset(*this, offset, RenderTextLineBoxes::CaretOffset);</span>
  }
  
  bool RenderText::hasRenderedText() const
  {
<span class="line-modified">!     if (auto* layout = simpleLineLayout())</span>
<span class="line-modified">!         return SimpleLineLayout::isTextRendered(*this, *layout);</span>
<span class="line-modified">!     return m_lineBoxes.hasRenderedText();</span>
  }
  
  int RenderText::previousOffset(int current) const
  {
      if (m_isAllASCII || text().is8Bit())
<span class="line-new-header">--- 1497,88 ---</span>
      return collectSelectionRectsForLineBoxes(repaintContainer, clipToVisibleContent, nullptr);
  }
  
  int RenderText::caretMinOffset() const
  {
<span class="line-modified">!     auto first = LineLayoutTraversal::firstTextBoxFor(*this);</span>
<span class="line-modified">!     if (!first)</span>
<span class="line-modified">!         return 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     int minOffset = first-&gt;localStartOffset();</span>
<span class="line-added">+     for (auto box = first; ++box;)</span>
<span class="line-added">+         minOffset = std::min&lt;int&gt;(minOffset, box-&gt;localStartOffset());</span>
<span class="line-added">+ </span>
<span class="line-added">+     return minOffset;</span>
  }
  
  int RenderText::caretMaxOffset() const
  {
<span class="line-modified">!     auto first = LineLayoutTraversal::firstTextBoxFor(*this);</span>
<span class="line-modified">!     if (!first)</span>
<span class="line-modified">!         return text().length();</span>
<span class="line-added">+ </span>
<span class="line-added">+     int maxOffset = first-&gt;localEndOffset();</span>
<span class="line-added">+     for (auto box = first; ++box;)</span>
<span class="line-added">+         maxOffset = std::max&lt;int&gt;(maxOffset, box-&gt;localEndOffset());</span>
<span class="line-added">+ </span>
<span class="line-added">+     return maxOffset;</span>
  }
  
  unsigned RenderText::countRenderedCharacterOffsetsUntil(unsigned offset) const
  {
<span class="line-modified">!     unsigned result = 0;</span>
<span class="line-modified">!     for (auto&amp; box : LineLayoutTraversal::textBoxesFor(*this)) {</span>
<span class="line-added">+         auto start = box.localStartOffset();</span>
<span class="line-added">+         auto length = box.length();</span>
<span class="line-added">+         if (offset &lt; start)</span>
<span class="line-added">+             return result;</span>
<span class="line-added">+         if (offset &lt;= start + length) {</span>
<span class="line-added">+             result += offset - start;</span>
<span class="line-added">+             return result;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         result += length;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ enum class OffsetType { Character, Caret };</span>
<span class="line-added">+ static bool containsOffset(const RenderText&amp; text, unsigned offset, OffsetType type)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (auto box = LineLayoutTraversal::firstTextBoxInTextOrderFor(text); box; box.traverseNextInTextOrder()) {</span>
<span class="line-added">+         auto start = box-&gt;localStartOffset();</span>
<span class="line-added">+         if (offset &lt; start)</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         unsigned end = box-&gt;localEndOffset();</span>
<span class="line-added">+         if (offset &gt;= start &amp;&amp; offset &lt;= end) {</span>
<span class="line-added">+             if (offset == end &amp;&amp; (type == OffsetType::Character || box-&gt;isLineBreak()))</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             if (type == OffsetType::Character)</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             // Return false for offsets inside composed characters.</span>
<span class="line-added">+             return !offset || offset == static_cast&lt;unsigned&gt;(text.nextOffset(text.previousOffset(offset)));</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return false;</span>
  }
  
  bool RenderText::containsRenderedCharacterOffset(unsigned offset) const
  {
<span class="line-modified">!     return containsOffset(*this, offset, OffsetType::Character);</span>
  }
  
  bool RenderText::containsCaretOffset(unsigned offset) const
  {
<span class="line-modified">!     return containsOffset(*this, offset, OffsetType::Caret);</span>
  }
  
  bool RenderText::hasRenderedText() const
  {
<span class="line-modified">!     for (auto&amp; box : LineLayoutTraversal::textBoxesFor(*this)) {</span>
<span class="line-modified">!         if (box.length())</span>
<span class="line-modified">!             return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return false;</span>
  }
  
  int RenderText::previousOffset(int current) const
  {
      if (m_isAllASCII || text().is8Bit())
</pre>
<center><a href="RenderTableSection.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderText.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
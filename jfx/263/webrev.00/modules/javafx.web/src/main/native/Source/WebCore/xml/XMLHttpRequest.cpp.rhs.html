<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 2004-2016 Apple Inc. All rights reserved.
   3  *  Copyright (C) 2005-2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   4  *  Copyright (C) 2007, 2008 Julien Chaffraix &lt;jchaffraix@webkit.org&gt;
   5  *  Copyright (C) 2008, 2011 Google Inc. All rights reserved.
   6  *  Copyright (C) 2012 Intel Corporation
   7  *
   8  *  This library is free software; you can redistribute it and/or
   9  *  modify it under the terms of the GNU Lesser General Public
  10  *  License as published by the Free Software Foundation; either
  11  *  version 2 of the License, or (at your option) any later version.
  12  *
  13  *  This library is distributed in the hope that it will be useful,
  14  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  *  Lesser General Public License for more details.
  17  *
  18  *  You should have received a copy of the GNU Lesser General Public
  19  *  License along with this library; if not, write to the Free Software
  20  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;XMLHttpRequest.h&quot;
  25 
  26 #include &quot;Blob.h&quot;
  27 #include &quot;CachedResourceRequestInitiators.h&quot;
  28 #include &quot;ContentSecurityPolicy.h&quot;
  29 #include &quot;CrossOriginAccessControl.h&quot;
  30 #include &quot;DOMFormData.h&quot;
  31 #include &quot;DOMWindow.h&quot;
  32 #include &quot;Event.h&quot;
  33 #include &quot;EventNames.h&quot;
  34 #include &quot;File.h&quot;
  35 #include &quot;HTMLDocument.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  36 #include &quot;HTMLIFrameElement.h&quot;</span>
  37 #include &quot;HTTPHeaderNames.h&quot;
  38 #include &quot;HTTPHeaderValues.h&quot;
  39 #include &quot;HTTPParsers.h&quot;
  40 #include &quot;InspectorInstrumentation.h&quot;
  41 #include &quot;JSDOMBinding.h&quot;
  42 #include &quot;JSDOMWindow.h&quot;
  43 #include &quot;MIMETypeRegistry.h&quot;
  44 #include &quot;MemoryCache.h&quot;
  45 #include &quot;ParsedContentType.h&quot;
  46 #include &quot;ResourceError.h&quot;
  47 #include &quot;ResourceRequest.h&quot;
  48 #include &quot;RuntimeApplicationChecks.h&quot;
  49 #include &quot;SecurityOriginPolicy.h&quot;
  50 #include &quot;Settings.h&quot;
  51 #include &quot;SharedBuffer.h&quot;
  52 #include &quot;StringAdaptors.h&quot;
  53 #include &quot;TextResourceDecoder.h&quot;
  54 #include &quot;ThreadableLoader.h&quot;
  55 #include &quot;XMLDocument.h&quot;
  56 #include &quot;XMLHttpRequestProgressEvent.h&quot;
  57 #include &quot;XMLHttpRequestUpload.h&quot;
  58 #include &quot;markup.h&quot;
  59 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
  60 #include &lt;JavaScriptCore/ArrayBufferView.h&gt;
  61 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  62 #include &lt;JavaScriptCore/JSLock.h&gt;
  63 #include &lt;wtf/IsoMallocInlines.h&gt;
  64 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  65 #include &lt;wtf/StdLibExtras.h&gt;
  66 #include &lt;wtf/text/CString.h&gt;
  67 
  68 namespace WebCore {
  69 
  70 static const Seconds maximumIntervalForUserGestureForwarding { 10_s };
  71 
  72 WTF_MAKE_ISO_ALLOCATED_IMPL(XMLHttpRequest);
  73 
  74 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, xmlHttpRequestCounter, (&quot;XMLHttpRequest&quot;));
  75 
  76 // Histogram enum to see when we can deprecate xhr.send(ArrayBuffer).
  77 enum XMLHttpRequestSendArrayBufferOrView {
  78     XMLHttpRequestSendArrayBuffer,
  79     XMLHttpRequestSendArrayBufferView,
  80     XMLHttpRequestSendArrayBufferOrViewMax,
  81 };
  82 
  83 static void replaceCharsetInMediaTypeIfNeeded(String&amp; mediaType)
  84 {
  85     auto parsedContentType = ParsedContentType::create(mediaType);
  86     if (!parsedContentType || parsedContentType-&gt;charset().isEmpty() || equalIgnoringASCIICase(parsedContentType-&gt;charset(), &quot;UTF-8&quot;))
  87         return;
  88 
  89     parsedContentType-&gt;setCharset(&quot;UTF-8&quot;);
  90     mediaType = parsedContentType-&gt;serialize();
  91 }
  92 
  93 static void logConsoleError(ScriptExecutionContext* context, const String&amp; message)
  94 {
  95     if (!context)
  96         return;
  97     // FIXME: It&#39;s not good to report the bad usage without indicating what source line it came from.
  98     // We should pass additional parameters so we can tell the console where the mistake occurred.
  99     context-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, message);
 100 }
 101 
 102 Ref&lt;XMLHttpRequest&gt; XMLHttpRequest::create(ScriptExecutionContext&amp; context)
 103 {
 104     auto xmlHttpRequest = adoptRef(*new XMLHttpRequest(context));
 105     xmlHttpRequest-&gt;suspendIfNeeded();
 106     return xmlHttpRequest;
 107 }
 108 
 109 XMLHttpRequest::XMLHttpRequest(ScriptExecutionContext&amp; context)
 110     : ActiveDOMObject(&amp;context)
 111     , m_async(true)
 112     , m_includeCredentials(false)
 113     , m_sendFlag(false)
 114     , m_createdDocument(false)
 115     , m_error(false)
 116     , m_uploadListenerFlag(false)
 117     , m_uploadComplete(false)
 118     , m_wasAbortedByClient(false)
 119     , m_responseCacheIsValid(false)
<a name="2" id="anc2"></a>
 120     , m_readyState(static_cast&lt;unsigned&gt;(UNSENT))
 121     , m_responseType(static_cast&lt;unsigned&gt;(ResponseType::EmptyString))
<a name="3" id="anc3"></a><span class="line-modified"> 122     , m_progressEventThrottle(*this)</span>

 123     , m_networkErrorTimer(*this, &amp;XMLHttpRequest::networkErrorTimerFired)
 124     , m_timeoutTimer(*this, &amp;XMLHttpRequest::didReachTimeout)
 125     , m_maximumIntervalForUserGestureForwarding(maximumIntervalForUserGestureForwarding)
 126 {
 127 #ifndef NDEBUG
 128     xmlHttpRequestCounter.increment();
 129 #endif
 130 }
 131 
 132 XMLHttpRequest::~XMLHttpRequest()
 133 {
 134 #ifndef NDEBUG
 135     xmlHttpRequestCounter.decrement();
 136 #endif
 137 }
 138 
 139 Document* XMLHttpRequest::document() const
 140 {
 141     ASSERT(scriptExecutionContext());
 142     return downcast&lt;Document&gt;(scriptExecutionContext());
 143 }
 144 
 145 SecurityOrigin* XMLHttpRequest::securityOrigin() const
 146 {
 147     return scriptExecutionContext()-&gt;securityOrigin();
 148 }
 149 
 150 ExceptionOr&lt;OwnedString&gt; XMLHttpRequest::responseText()
 151 {
 152     if (responseType() != ResponseType::EmptyString &amp;&amp; responseType() != ResponseType::Text)
 153         return Exception { InvalidStateError };
 154     return OwnedString { responseTextIgnoringResponseType() };
 155 }
 156 
 157 void XMLHttpRequest::didCacheResponse()
 158 {
 159     ASSERT(doneWithoutErrors());
 160     m_responseCacheIsValid = true;
 161     m_responseBuilder.clear();
 162 }
 163 
 164 ExceptionOr&lt;Document*&gt; XMLHttpRequest::responseXML()
 165 {
 166     ASSERT(scriptExecutionContext()-&gt;isDocument());
 167 
 168     if (responseType() != ResponseType::EmptyString &amp;&amp; responseType() != ResponseType::Document)
 169         return Exception { InvalidStateError };
 170 
 171     if (!doneWithoutErrors())
 172         return nullptr;
 173 
 174     if (!m_createdDocument) {
<a name="4" id="anc4"></a><span class="line-modified"> 175         auto&amp; context = downcast&lt;Document&gt;(*scriptExecutionContext());</span>
 176 
 177         String mimeType = responseMIMEType();
 178         bool isHTML = equalLettersIgnoringASCIICase(mimeType, &quot;text/html&quot;);
 179 
 180         // The W3C spec requires the final MIME type to be some valid XML type, or text/html.
 181         // If it is text/html, then the responseType of &quot;document&quot; must have been supplied explicitly.
 182         if ((m_response.isHTTP() &amp;&amp; !responseIsXML() &amp;&amp; !isHTML)
 183             || (isHTML &amp;&amp; responseType() == ResponseType::EmptyString)) {
 184             m_responseDocument = nullptr;
 185         } else {
 186             if (isHTML)
<a name="5" id="anc5"></a><span class="line-modified"> 187                 m_responseDocument = HTMLDocument::create(nullptr, m_response.url());</span>
 188             else
<a name="6" id="anc6"></a><span class="line-modified"> 189                 m_responseDocument = XMLDocument::create(nullptr, m_response.url());</span>
 190             m_responseDocument-&gt;overrideLastModified(m_response.lastModified());
 191             m_responseDocument-&gt;setContent(m_responseBuilder.toStringPreserveCapacity());
<a name="7" id="anc7"></a><span class="line-modified"> 192             m_responseDocument-&gt;setContextDocument(context);</span>
 193             m_responseDocument-&gt;setSecurityOriginPolicy(context.securityOriginPolicy());
 194             m_responseDocument-&gt;overrideMIMEType(mimeType);
 195 
 196             if (!m_responseDocument-&gt;wellFormed())
 197                 m_responseDocument = nullptr;
 198         }
 199         m_createdDocument = true;
 200     }
 201 
 202     return m_responseDocument.get();
 203 }
 204 
 205 Ref&lt;Blob&gt; XMLHttpRequest::createResponseBlob()
 206 {
 207     ASSERT(responseType() == ResponseType::Blob);
 208     ASSERT(doneWithoutErrors());
 209 
 210     // FIXME: We just received the data from NetworkProcess, and are sending it back. This is inefficient.
 211     Vector&lt;uint8_t&gt; data;
 212     if (m_binaryResponseBuilder)
 213         data.append(m_binaryResponseBuilder-&gt;data(), m_binaryResponseBuilder-&gt;size());
 214     m_binaryResponseBuilder = nullptr;
 215     String normalizedContentType = Blob::normalizedContentType(responseMIMEType()); // responseMIMEType defaults to text/xml which may be incorrect.
<a name="8" id="anc8"></a><span class="line-modified"> 216     return Blob::create(WTFMove(data), normalizedContentType);</span>
 217 }
 218 
 219 RefPtr&lt;ArrayBuffer&gt; XMLHttpRequest::createResponseArrayBuffer()
 220 {
 221     ASSERT(responseType() == ResponseType::Arraybuffer);
 222     ASSERT(doneWithoutErrors());
 223 
 224     auto result = m_binaryResponseBuilder ? m_binaryResponseBuilder-&gt;tryCreateArrayBuffer() : ArrayBuffer::create(nullptr, 0);
 225     m_binaryResponseBuilder = nullptr;
 226     return result;
 227 }
 228 
 229 ExceptionOr&lt;void&gt; XMLHttpRequest::setTimeout(unsigned timeout)
 230 {
 231     if (scriptExecutionContext()-&gt;isDocument() &amp;&amp; !m_async) {
 232         logConsoleError(scriptExecutionContext(), &quot;XMLHttpRequest.timeout cannot be set for synchronous HTTP(S) requests made from the window context.&quot;);
 233         return Exception { InvalidAccessError };
 234     }
 235     m_timeoutMilliseconds = timeout;
 236     if (!m_timeoutTimer.isActive())
 237         return { };
 238 
 239     // If timeout is zero, we should use the default network timeout. But we disabled it so let&#39;s mimic it with a 60 seconds timeout value.
 240     Seconds interval = Seconds { m_timeoutMilliseconds ? m_timeoutMilliseconds / 1000. : 60. } - (MonotonicTime::now() - m_sendingTime);
 241     m_timeoutTimer.startOneShot(std::max(interval, 0_s));
 242     return { };
 243 }
 244 
 245 ExceptionOr&lt;void&gt; XMLHttpRequest::setResponseType(ResponseType type)
 246 {
 247     if (!scriptExecutionContext()-&gt;isDocument() &amp;&amp; type == ResponseType::Document)
 248         return { };
 249 
 250     if (readyState() &gt;= LOADING)
 251         return Exception { InvalidStateError };
 252 
 253     // Newer functionality is not available to synchronous requests in window contexts, as a spec-mandated
 254     // attempt to discourage synchronous XHR use. responseType is one such piece of functionality.
 255     // We&#39;ll only disable this functionality for HTTP(S) requests since sync requests for local protocols
 256     // such as file: and data: still make sense to allow.
 257     if (!m_async &amp;&amp; scriptExecutionContext()-&gt;isDocument() &amp;&amp; m_url.protocolIsInHTTPFamily()) {
 258         logConsoleError(scriptExecutionContext(), &quot;XMLHttpRequest.responseType cannot be changed for synchronous HTTP(S) requests made from the window context.&quot;);
 259         return Exception { InvalidAccessError };
 260     }
 261 
 262     m_responseType = static_cast&lt;unsigned&gt;(type);
 263     return { };
 264 }
 265 
 266 String XMLHttpRequest::responseURL() const
 267 {
 268     URL responseURL(m_response.url());
 269     responseURL.removeFragmentIdentifier();
 270 
 271     return responseURL.string();
 272 }
 273 
 274 XMLHttpRequestUpload&amp; XMLHttpRequest::upload()
 275 {
 276     if (!m_upload)
 277         m_upload = makeUnique&lt;XMLHttpRequestUpload&gt;(*this);
 278     return *m_upload;
 279 }
 280 
 281 void XMLHttpRequest::changeState(State newState)
 282 {
 283     if (readyState() != newState) {
 284         m_readyState = static_cast&lt;State&gt;(newState);
 285         if (readyState() == DONE) {
 286             // The XHR object itself holds on to the responseText, and
 287             // thus has extra cost even independent of any
 288             // responseText or responseXML objects it has handed
 289             // out. But it is protected from GC while loading, so this
 290             // can&#39;t be recouped until the load is done, so only
 291             // report the extra cost at that point.
 292             if (auto* context = scriptExecutionContext()) {
 293                 JSC::VM&amp; vm = context-&gt;vm();
 294                 JSC::JSLockHolder lock(vm);
 295                 vm.heap.reportExtraMemoryAllocated(memoryCost());
 296             }
 297         }
 298         callReadyStateChangeListener();
 299     }
 300 }
 301 
 302 void XMLHttpRequest::callReadyStateChangeListener()
 303 {
 304     if (!scriptExecutionContext())
 305         return;
 306 
 307     // Check whether sending load and loadend events before sending readystatechange event, as it may change m_error/m_readyState values.
 308     bool shouldSendLoadEvent = (readyState() == DONE &amp;&amp; !m_error);
 309 
 310     if (m_async || (readyState() &lt;= OPENED || readyState() == DONE)) {
 311         m_progressEventThrottle.dispatchReadyStateChangeEvent(Event::create(eventNames().readystatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No),
 312             readyState() == DONE ? FlushProgressEvent : DoNotFlushProgressEvent);
 313     }
 314 
 315     if (shouldSendLoadEvent) {
 316         m_progressEventThrottle.dispatchProgressEvent(eventNames().loadEvent);
 317         m_progressEventThrottle.dispatchProgressEvent(eventNames().loadendEvent);
 318     }
 319 }
 320 
 321 ExceptionOr&lt;void&gt; XMLHttpRequest::setWithCredentials(bool value)
 322 {
 323     if (readyState() &gt; OPENED || m_sendFlag)
 324         return Exception { InvalidStateError };
 325 
 326     m_includeCredentials = value;
 327     return { };
 328 }
 329 
 330 ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const String&amp; url)
 331 {
 332     // If the async argument is omitted, set async to true.
 333     return open(method, scriptExecutionContext()-&gt;completeURL(url), true);
 334 }
 335 
 336 ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const URL&amp; url, bool async)
 337 {
<a name="9" id="anc9"></a><span class="line-added"> 338     auto* context = scriptExecutionContext();</span>
<span class="line-added"> 339     bool contextIsDocument = is&lt;Document&gt;(*context);</span>
<span class="line-added"> 340     if (contextIsDocument &amp;&amp; !downcast&lt;Document&gt;(*context).isFullyActive())</span>
<span class="line-added"> 341         return Exception { InvalidStateError, &quot;Document is not fully active&quot;_s };</span>
<span class="line-added"> 342 </span>
 343     if (!isValidHTTPToken(method))
 344         return Exception { SyntaxError };
 345 
 346     if (isForbiddenMethod(method))
 347         return Exception { SecurityError };
 348 
 349     if (!url.isValid())
 350         return Exception { SyntaxError };
 351 
<a name="10" id="anc10"></a><span class="line-modified"> 352     if (!async &amp;&amp; contextIsDocument) {</span>
 353         // Newer functionality is not available to synchronous requests in window contexts, as a spec-mandated
 354         // attempt to discourage synchronous XHR use. responseType is one such piece of functionality.
 355         // We&#39;ll only disable this functionality for HTTP(S) requests since sync requests for local protocols
 356         // such as file: and data: still make sense to allow.
 357         if (url.protocolIsInHTTPFamily() &amp;&amp; responseType() != ResponseType::EmptyString) {
<a name="11" id="anc11"></a><span class="line-modified"> 358             logConsoleError(context, &quot;Synchronous HTTP(S) requests made from the window context cannot have XMLHttpRequest.responseType set.&quot;);</span>
 359             return Exception { InvalidAccessError };
 360         }
 361 
 362         // Similarly, timeouts are disabled for synchronous requests as well.
 363         if (m_timeoutMilliseconds &gt; 0) {
<a name="12" id="anc12"></a><span class="line-modified"> 364             logConsoleError(context, &quot;Synchronous XMLHttpRequests must not have a timeout value set.&quot;);</span>
 365             return Exception { InvalidAccessError };
 366         }
 367     }
 368 
 369     if (!internalAbort())
 370         return { };
 371 
 372     m_sendFlag = false;
 373     m_uploadListenerFlag = false;
 374     m_method = normalizeHTTPMethod(method);
 375     m_error = false;
 376     m_uploadComplete = false;
 377     m_wasAbortedByClient = false;
 378 
 379     // clear stuff from possible previous load
 380     clearResponse();
 381     clearRequest();
 382 
 383     m_url = url;
<a name="13" id="anc13"></a><span class="line-modified"> 384     context-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(m_url, ContentSecurityPolicy::InsecureRequestType::Load);</span>
 385 
 386     m_async = async;
 387 
 388     ASSERT(!m_loader);
 389 
 390     changeState(OPENED);
 391 
 392     return { };
 393 }
 394 
 395 ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const String&amp; url, bool async, const String&amp; user, const String&amp; password)
 396 {
 397     URL urlWithCredentials = scriptExecutionContext()-&gt;completeURL(url);
 398     if (!user.isNull())
 399         urlWithCredentials.setUser(user);
 400     if (!password.isNull())
 401         urlWithCredentials.setPass(password);
 402 
 403     return open(method, urlWithCredentials, async);
 404 }
 405 
 406 Optional&lt;ExceptionOr&lt;void&gt;&gt; XMLHttpRequest::prepareToSend()
 407 {
 408     // A return value other than WTF::nullopt means we should not try to send, and we should return that value to the caller.
 409     // WTF::nullopt means we are ready to send and should continue with the send algorithm.
 410 
 411     if (!scriptExecutionContext())
 412         return ExceptionOr&lt;void&gt; { };
 413 
 414     auto&amp; context = *scriptExecutionContext();
 415 
<a name="14" id="anc14"></a><span class="line-added"> 416     if (is&lt;Document&gt;(context) &amp;&amp; downcast&lt;Document&gt;(context).shouldIgnoreSyncXHRs()) {</span>
<span class="line-added"> 417         logConsoleError(scriptExecutionContext(), makeString(&quot;Ignoring XMLHttpRequest.send() call for &#39;&quot;, m_url.string(), &quot;&#39; because the maximum number of synchronous failures was reached.&quot;));</span>
<span class="line-added"> 418         return ExceptionOr&lt;void&gt; { };</span>
<span class="line-added"> 419     }</span>
<span class="line-added"> 420 </span>
 421     if (readyState() != OPENED || m_sendFlag)
 422         return ExceptionOr&lt;void&gt; { Exception { InvalidStateError } };
 423     ASSERT(!m_loader);
 424 
 425     // FIXME: Convert this to check the isolated world&#39;s Content Security Policy once webkit.org/b/104520 is solved.
 426     if (!context.shouldBypassMainWorldContentSecurityPolicy() &amp;&amp; !context.contentSecurityPolicy()-&gt;allowConnectToSource(m_url)) {
 427         if (!m_async)
 428             return ExceptionOr&lt;void&gt; { Exception { NetworkError } };
 429         setPendingActivity(*this);
 430         m_timeoutTimer.stop();
 431         m_networkErrorTimer.startOneShot(0_s);
 432         return ExceptionOr&lt;void&gt; { };
 433     }
 434 
 435     m_error = false;
 436     return WTF::nullopt;
 437 }
 438 
 439 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Optional&lt;SendTypes&gt;&amp;&amp; sendType)
 440 {
 441     InspectorInstrumentation::willSendXMLHttpRequest(scriptExecutionContext(), url());
 442     m_userGestureToken = UserGestureIndicator::currentUserGesture();
 443 
 444     ExceptionOr&lt;void&gt; result;
 445     if (!sendType)
 446         result = send();
 447     else {
 448         result = WTF::switchOn(sendType.value(),
 449             [this] (const RefPtr&lt;Document&gt;&amp; document) -&gt; ExceptionOr&lt;void&gt; { return send(*document); },
 450             [this] (const RefPtr&lt;Blob&gt;&amp; blob) -&gt; ExceptionOr&lt;void&gt; { return send(*blob); },
 451             [this] (const RefPtr&lt;JSC::ArrayBufferView&gt;&amp; arrayBufferView) -&gt; ExceptionOr&lt;void&gt; { return send(*arrayBufferView); },
 452             [this] (const RefPtr&lt;JSC::ArrayBuffer&gt;&amp; arrayBuffer) -&gt; ExceptionOr&lt;void&gt; { return send(*arrayBuffer); },
 453             [this] (const RefPtr&lt;DOMFormData&gt;&amp; formData) -&gt; ExceptionOr&lt;void&gt; { return send(*formData); },
 454             [this] (const String&amp; string) -&gt; ExceptionOr&lt;void&gt; { return send(string); }
 455         );
 456     }
 457 
 458     return result;
 459 }
 460 
 461 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Document&amp; document)
 462 {
 463     if (auto result = prepareToSend())
 464         return WTFMove(result.value());
 465 
 466     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {
 467         if (!m_requestHeaders.contains(HTTPHeaderName::ContentType)) {
 468             // FIXME: this should include the charset used for encoding.
 469             m_requestHeaders.set(HTTPHeaderName::ContentType, document.isHTMLDocument() ? &quot;text/html;charset=UTF-8&quot;_s : &quot;application/xml;charset=UTF-8&quot;_s);
 470         } else {
 471             String contentType = m_requestHeaders.get(HTTPHeaderName::ContentType);
 472             replaceCharsetInMediaTypeIfNeeded(contentType);
 473             m_requestHeaders.set(HTTPHeaderName::ContentType, contentType);
 474         }
 475 
 476         // FIXME: According to XMLHttpRequest Level 2, this should use the Document.innerHTML algorithm
 477         // from the HTML5 specification to serialize the document.
 478         m_requestEntityBody = FormData::create(UTF8Encoding().encode(serializeFragment(document, SerializedNodes::SubtreeIncludingNode), UnencodableHandling::Entities));
 479         if (m_upload)
 480             m_requestEntityBody-&gt;setAlwaysStream(true);
 481     }
 482 
 483     return createRequest();
 484 }
 485 
 486 ExceptionOr&lt;void&gt; XMLHttpRequest::send(const String&amp; body)
 487 {
 488     if (auto result = prepareToSend())
 489         return WTFMove(result.value());
 490 
 491     if (!body.isNull() &amp;&amp; m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {
 492         String contentType = m_requestHeaders.get(HTTPHeaderName::ContentType);
 493         if (contentType.isNull()) {
 494             m_requestHeaders.set(HTTPHeaderName::ContentType, HTTPHeaderValues::textPlainContentType());
 495         } else {
 496             replaceCharsetInMediaTypeIfNeeded(contentType);
 497             m_requestHeaders.set(HTTPHeaderName::ContentType, contentType);
 498         }
 499 
 500         m_requestEntityBody = FormData::create(UTF8Encoding().encode(body, UnencodableHandling::Entities));
 501         if (m_upload)
 502             m_requestEntityBody-&gt;setAlwaysStream(true);
 503     }
 504 
 505     return createRequest();
 506 }
 507 
 508 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Blob&amp; body)
 509 {
 510     if (auto result = prepareToSend())
 511         return WTFMove(result.value());
 512 
 513     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {
 514         if (!m_url.protocolIsInHTTPFamily()) {
 515             // FIXME: We would like to support posting Blobs to non-http URLs (e.g. custom URL schemes)
 516             // but because of the architecture of blob-handling that will require a fair amount of work.
 517 
 518             ASCIILiteral consoleMessage { &quot;POST of a Blob to non-HTTP protocols in XMLHttpRequest.send() is currently unsupported.&quot;_s };
 519             scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, consoleMessage);
 520 
 521             return createRequest();
 522         }
 523 
 524         if (!m_requestHeaders.contains(HTTPHeaderName::ContentType)) {
 525             const String&amp; blobType = body.type();
 526             if (!blobType.isEmpty() &amp;&amp; isValidContentType(blobType))
 527                 m_requestHeaders.set(HTTPHeaderName::ContentType, blobType);
 528             else {
 529                 // From FileAPI spec, whenever media type cannot be determined, empty string must be returned.
 530                 m_requestHeaders.set(HTTPHeaderName::ContentType, emptyString());
 531             }
 532         }
 533 
 534         m_requestEntityBody = FormData::create();
 535         m_requestEntityBody-&gt;appendBlob(body.url());
 536     }
 537 
 538     return createRequest();
 539 }
 540 
 541 ExceptionOr&lt;void&gt; XMLHttpRequest::send(DOMFormData&amp; body)
 542 {
 543     if (auto result = prepareToSend())
 544         return WTFMove(result.value());
 545 
 546     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {
 547         m_requestEntityBody = FormData::createMultiPart(body);
 548         if (!m_requestHeaders.contains(HTTPHeaderName::ContentType))
 549             m_requestHeaders.set(HTTPHeaderName::ContentType, makeString(&quot;multipart/form-data; boundary=&quot;, m_requestEntityBody-&gt;boundary().data()));
 550     }
 551 
 552     return createRequest();
 553 }
 554 
 555 ExceptionOr&lt;void&gt; XMLHttpRequest::send(ArrayBuffer&amp; body)
 556 {
 557     ASCIILiteral consoleMessage { &quot;ArrayBuffer is deprecated in XMLHttpRequest.send(). Use ArrayBufferView instead.&quot;_s };
 558     scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, consoleMessage);
 559     return sendBytesData(body.data(), body.byteLength());
 560 }
 561 
 562 ExceptionOr&lt;void&gt; XMLHttpRequest::send(ArrayBufferView&amp; body)
 563 {
 564     return sendBytesData(body.baseAddress(), body.byteLength());
 565 }
 566 
 567 ExceptionOr&lt;void&gt; XMLHttpRequest::sendBytesData(const void* data, size_t length)
 568 {
 569     if (auto result = prepareToSend())
 570         return WTFMove(result.value());
 571 
 572     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {
 573         m_requestEntityBody = FormData::create(data, length);
 574         if (m_upload)
 575             m_requestEntityBody-&gt;setAlwaysStream(true);
 576     }
 577 
 578     return createRequest();
 579 }
 580 
 581 ExceptionOr&lt;void&gt; XMLHttpRequest::createRequest()
 582 {
 583     // Only GET request is supported for blob URL.
 584     if (!m_async &amp;&amp; m_url.protocolIsBlob() &amp;&amp; m_method != &quot;GET&quot;)
 585         return Exception { NetworkError };
 586 
 587     if (m_async &amp;&amp; m_upload &amp;&amp; m_upload-&gt;hasEventListeners())
 588         m_uploadListenerFlag = true;
 589 
 590     ResourceRequest request(m_url);
 591     request.setRequester(ResourceRequest::Requester::XHR);
 592     request.setInitiatorIdentifier(scriptExecutionContext()-&gt;resourceRequestIdentifier());
 593     request.setHTTPMethod(m_method);
 594 
 595     if (m_requestEntityBody) {
 596         ASSERT(m_method != &quot;GET&quot;);
 597         ASSERT(m_method != &quot;HEAD&quot;);
 598         request.setHTTPBody(WTFMove(m_requestEntityBody));
 599     }
 600 
 601     if (!m_requestHeaders.isEmpty())
 602         request.setHTTPHeaderFields(m_requestHeaders);
 603 
 604     ThreadableLoaderOptions options;
 605     options.sendLoadCallbacks = SendCallbackPolicy::SendCallbacks;
 606     // The presence of upload event listeners forces us to use preflighting because POSTing to an URL that does not
 607     // permit cross origin requests should look exactly like POSTing to an URL that does not respond at all.
 608     options.preflightPolicy = m_uploadListenerFlag ? PreflightPolicy::Force : PreflightPolicy::Consider;
 609     options.credentials = m_includeCredentials ? FetchOptions::Credentials::Include : FetchOptions::Credentials::SameOrigin;
 610     options.mode = FetchOptions::Mode::Cors;
 611     options.contentSecurityPolicyEnforcement = scriptExecutionContext()-&gt;shouldBypassMainWorldContentSecurityPolicy() ? ContentSecurityPolicyEnforcement::DoNotEnforce : ContentSecurityPolicyEnforcement::EnforceConnectSrcDirective;
 612     options.initiator = cachedResourceRequestInitiators().xmlhttprequest;
 613     options.sameOriginDataURLFlag = SameOriginDataURLFlag::Set;
 614     options.filteringPolicy = ResponseFilteringPolicy::Enable;
 615     options.sniffContentEncoding = ContentEncodingSniffingPolicy::DoNotSniff;
 616 
 617     if (m_timeoutMilliseconds) {
 618         if (!m_async)
 619             request.setTimeoutInterval(m_timeoutMilliseconds / 1000.0);
 620         else {
 621             request.setTimeoutInterval(std::numeric_limits&lt;double&gt;::infinity());
 622             m_sendingTime = MonotonicTime::now();
 623             m_timeoutTimer.startOneShot(1_ms * m_timeoutMilliseconds);
 624         }
 625     }
 626 
 627     m_exceptionCode = WTF::nullopt;
 628     m_error = false;
 629     m_uploadComplete = !request.httpBody();
 630     m_sendFlag = true;
 631 
 632     if (m_async) {
 633         m_progressEventThrottle.dispatchProgressEvent(eventNames().loadstartEvent);
 634         if (!m_uploadComplete &amp;&amp; m_uploadListenerFlag)
<a name="15" id="anc15"></a><span class="line-modified"> 635             m_upload-&gt;dispatchProgressEvent(eventNames().loadstartEvent, 0, request.httpBody()-&gt;lengthInBytes());</span>
 636 
 637         if (readyState() != OPENED || !m_sendFlag || m_loader)
 638             return { };
 639 
 640         // ThreadableLoader::create can return null here, for example if we&#39;re no longer attached to a page or if a content blocker blocks the load.
 641         // This is true while running onunload handlers.
 642         // FIXME: Maybe we need to be able to send XMLHttpRequests from onunload, &lt;http://bugs.webkit.org/show_bug.cgi?id=10904&gt;.
 643         m_loader = ThreadableLoader::create(*scriptExecutionContext(), *this, WTFMove(request), options);
 644 
 645         // Either loader is null or some error was synchronously sent to us.
 646         ASSERT(m_loader || !m_sendFlag);
 647 
 648         // Neither this object nor the JavaScript wrapper should be deleted while
 649         // a request is in progress because we need to keep the listeners alive,
 650         // and they are referenced by the JavaScript wrapper.
 651         if (m_loader)
 652             setPendingActivity(*this);
 653     } else {
<a name="16" id="anc16"></a><span class="line-added"> 654         if (scriptExecutionContext()-&gt;isDocument() &amp;&amp; !isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::SyncXHR, *document()))</span>
<span class="line-added"> 655             return Exception { NetworkError };</span>
<span class="line-added"> 656 </span>
 657         request.setDomainForCachePartition(scriptExecutionContext()-&gt;domainForCachePartition());
 658         InspectorInstrumentation::willLoadXHRSynchronously(scriptExecutionContext());
 659         ThreadableLoader::loadResourceSynchronously(*scriptExecutionContext(), WTFMove(request), *this, options);
 660         InspectorInstrumentation::didLoadXHRSynchronously(scriptExecutionContext());
 661     }
 662 
 663     if (m_exceptionCode)
 664         return Exception { m_exceptionCode.value() };
 665     if (m_error)
 666         return Exception { NetworkError };
 667     return { };
 668 }
 669 
 670 void XMLHttpRequest::abort()
 671 {
 672     // internalAbort() calls unsetPendingActivity(this), which may release the last reference.
 673     Ref&lt;XMLHttpRequest&gt; protectedThis(*this);
 674 
 675     m_wasAbortedByClient = true;
 676     if (!internalAbort())
 677         return;
 678 
 679     clearResponseBuffers();
 680 
 681     m_requestHeaders.clear();
 682     if ((readyState() == OPENED &amp;&amp; m_sendFlag) || readyState() == HEADERS_RECEIVED || readyState() == LOADING) {
 683         ASSERT(!m_loader);
 684         m_sendFlag = false;
 685         changeState(DONE);
 686         dispatchErrorEvents(eventNames().abortEvent);
 687     }
 688     if (readyState() == DONE)
 689         m_readyState = static_cast&lt;State&gt;(UNSENT);
 690 }
 691 
 692 bool XMLHttpRequest::internalAbort()
 693 {
 694     m_error = true;
 695 
 696     // FIXME: when we add the support for multi-part XHR, we will have to think be careful with this initialization.
 697     m_receivedLength = 0;
 698 
 699     m_decoder = nullptr;
 700 
 701     m_timeoutTimer.stop();
 702 
 703     if (!m_loader)
 704         return true;
 705 
 706     // Cancelling m_loader may trigger a window.onload callback which can call open() on the same xhr.
 707     // This would create internalAbort reentrant call.
 708     // m_loader is set to null before being cancelled to exit early in any reentrant internalAbort() call.
 709     auto loader = WTFMove(m_loader);
 710     loader-&gt;cancel();
 711 
 712     // If window.onload callback calls open() and send() on the same xhr, m_loader is now set to a new value.
 713     // The function calling internalAbort() should abort to let the open() and send() calls continue properly.
 714     // We ask the function calling internalAbort() to exit by returning false.
 715     // Save this information to a local variable since we are going to drop protection.
 716     bool newLoadStarted = m_loader;
 717 
 718     unsetPendingActivity(*this);
 719 
 720     return !newLoadStarted;
 721 }
 722 
 723 void XMLHttpRequest::clearResponse()
 724 {
 725     m_response = ResourceResponse();
 726     clearResponseBuffers();
 727 }
 728 
 729 void XMLHttpRequest::clearResponseBuffers()
 730 {
 731     m_responseBuilder.clear();
 732     m_responseEncoding = String();
 733     m_createdDocument = false;
 734     m_responseDocument = nullptr;
 735     m_binaryResponseBuilder = nullptr;
 736     m_responseCacheIsValid = false;
 737 }
 738 
 739 void XMLHttpRequest::clearRequest()
 740 {
 741     m_requestHeaders.clear();
 742     m_requestEntityBody = nullptr;
 743 }
 744 
 745 void XMLHttpRequest::genericError()
 746 {
 747     clearResponse();
 748     clearRequest();
 749     m_sendFlag = false;
 750     m_error = true;
 751 
 752     changeState(DONE);
 753 }
 754 
 755 void XMLHttpRequest::networkError()
 756 {
 757     genericError();
 758     dispatchErrorEvents(eventNames().errorEvent);
 759     internalAbort();
 760 }
 761 
 762 void XMLHttpRequest::networkErrorTimerFired()
 763 {
 764     networkError();
 765     unsetPendingActivity(*this);
 766 }
 767 
 768 void XMLHttpRequest::abortError()
 769 {
 770     ASSERT(m_wasAbortedByClient);
 771     genericError();
 772     dispatchErrorEvents(eventNames().abortEvent);
 773 }
 774 
 775 size_t XMLHttpRequest::memoryCost() const
 776 {
 777     if (readyState() == DONE)
 778         return m_responseBuilder.length() * 2;
 779     return 0;
 780 }
 781 
 782 ExceptionOr&lt;void&gt; XMLHttpRequest::overrideMimeType(const String&amp; mimeType)
 783 {
 784     if (readyState() == LOADING || readyState() == DONE)
 785         return Exception { InvalidStateError };
 786 
 787     m_mimeTypeOverride = &quot;application/octet-stream&quot;_s;
 788     if (isValidContentType(mimeType))
 789         m_mimeTypeOverride = mimeType;
 790 
 791     return { };
 792 }
 793 
 794 ExceptionOr&lt;void&gt; XMLHttpRequest::setRequestHeader(const String&amp; name, const String&amp; value)
 795 {
 796     if (readyState() != OPENED || m_sendFlag)
 797         return Exception { InvalidStateError };
 798 
 799     String normalizedValue = stripLeadingAndTrailingHTTPSpaces(value);
 800     if (!isValidHTTPToken(name) || !isValidHTTPHeaderValue(normalizedValue))
 801         return Exception { SyntaxError };
 802 
 803     bool allowUnsafeHeaderField = false;
 804     // FIXME: The allowSettingAnyXHRHeaderFromFileURLs setting currently only applies to Documents, not workers.
 805     if (securityOrigin()-&gt;canLoadLocalResources() &amp;&amp; scriptExecutionContext()-&gt;isDocument() &amp;&amp; document()-&gt;settings().allowSettingAnyXHRHeaderFromFileURLs())
 806         allowUnsafeHeaderField = true;
 807     if (!allowUnsafeHeaderField &amp;&amp; isForbiddenHeaderName(name)) {
 808         logConsoleError(scriptExecutionContext(), &quot;Refused to set unsafe header \&quot;&quot; + name + &quot;\&quot;&quot;);
 809         return { };
 810     }
 811 
 812     m_requestHeaders.add(name, normalizedValue);
 813     return { };
 814 }
 815 
 816 String XMLHttpRequest::getAllResponseHeaders() const
 817 {
 818     if (readyState() &lt; HEADERS_RECEIVED || m_error)
 819         return emptyString();
 820 
 821     if (!m_allResponseHeaders) {
 822         Vector&lt;String&gt; headers;
 823         headers.reserveInitialCapacity(m_response.httpHeaderFields().size());
 824 
 825         for (auto&amp; header : m_response.httpHeaderFields()) {
 826             StringBuilder stringBuilder;
 827             stringBuilder.append(header.key.convertToASCIILowercase());
 828             stringBuilder.appendLiteral(&quot;: &quot;);
 829             stringBuilder.append(header.value);
 830             stringBuilder.appendLiteral(&quot;\r\n&quot;);
 831             headers.uncheckedAppend(stringBuilder.toString());
 832         }
 833         std::sort(headers.begin(), headers.end(), WTF::codePointCompareLessThan);
 834 
 835         StringBuilder stringBuilder;
 836         for (auto&amp; header : headers)
 837             stringBuilder.append(header);
 838         m_allResponseHeaders = stringBuilder.toString();
 839     }
 840 
 841     return m_allResponseHeaders;
 842 }
 843 
 844 String XMLHttpRequest::getResponseHeader(const String&amp; name) const
 845 {
 846     if (readyState() &lt; HEADERS_RECEIVED || m_error)
 847         return String();
 848 
 849     return m_response.httpHeaderField(name);
 850 }
 851 
 852 String XMLHttpRequest::responseMIMEType() const
 853 {
 854     String mimeType = extractMIMETypeFromMediaType(m_mimeTypeOverride);
 855     if (mimeType.isEmpty()) {
 856         String contentType;
 857         if (m_response.isHTTP())
 858             contentType = m_response.httpHeaderField(HTTPHeaderName::ContentType);
 859         else
 860             contentType = m_response.mimeType();
 861         if (auto parsedContentType = ParsedContentType::create(contentType))
 862             return parsedContentType-&gt;mimeType();
 863         return &quot;text/xml&quot;_s;
 864     }
 865     return mimeType;
 866 }
 867 
 868 bool XMLHttpRequest::responseIsXML() const
 869 {
 870     return MIMETypeRegistry::isXMLMIMEType(responseMIMEType());
 871 }
 872 
 873 int XMLHttpRequest::status() const
 874 {
 875     if (readyState() == UNSENT || readyState() == OPENED || m_error)
 876         return 0;
 877 
 878     return m_response.httpStatusCode();
 879 }
 880 
 881 String XMLHttpRequest::statusText() const
 882 {
 883     if (readyState() == UNSENT || readyState() == OPENED || m_error)
 884         return String();
 885 
 886     return m_response.httpStatusText();
 887 }
 888 
 889 void XMLHttpRequest::didFail(const ResourceError&amp; error)
 890 {
 891     // If we are already in an error state, for instance we called abort(), bail out early.
 892     if (m_error)
 893         return;
 894 
 895     // The XHR specification says we should only fire an abort event if the cancelation was requested by the client.
 896     if (m_wasAbortedByClient &amp;&amp; error.isCancellation()) {
 897         m_exceptionCode = AbortError;
 898         abortError();
 899         return;
 900     }
 901 
 902     // In case of worker sync timeouts.
 903     if (error.isTimeout()) {
 904         didReachTimeout();
 905         return;
 906     }
 907 
 908     // In case didFail is called synchronously on an asynchronous XHR call, let&#39;s dispatch network error asynchronously
 909     if (m_async &amp;&amp; m_sendFlag &amp;&amp; !m_loader) {
 910         m_sendFlag = false;
 911         setPendingActivity(*this);
 912         m_timeoutTimer.stop();
 913         m_networkErrorTimer.startOneShot(0_s);
 914         return;
 915     }
 916     m_exceptionCode = NetworkError;
 917     networkError();
 918 }
 919 
 920 void XMLHttpRequest::didFinishLoading(unsigned long)
 921 {
 922     if (m_error)
 923         return;
 924 
 925     if (readyState() &lt; HEADERS_RECEIVED)
 926         changeState(HEADERS_RECEIVED);
 927 
 928     if (m_decoder)
 929         m_responseBuilder.append(m_decoder-&gt;flush());
 930 
 931     m_responseBuilder.shrinkToFit();
 932 
 933     bool hadLoader = m_loader;
 934     m_loader = nullptr;
 935 
 936     m_sendFlag = false;
 937     changeState(DONE);
 938     m_responseEncoding = String();
 939     m_decoder = nullptr;
 940 
 941     m_timeoutTimer.stop();
 942 
 943     if (hadLoader)
 944         unsetPendingActivity(*this);
 945 }
 946 
 947 void XMLHttpRequest::didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
 948 {
 949     if (!m_upload)
 950         return;
 951 
 952     if (m_uploadListenerFlag)
 953         m_upload-&gt;dispatchProgressEvent(eventNames().progressEvent, bytesSent, totalBytesToBeSent);
 954 
 955     if (bytesSent == totalBytesToBeSent &amp;&amp; !m_uploadComplete) {
 956         m_uploadComplete = true;
 957         if (m_uploadListenerFlag) {
 958             m_upload-&gt;dispatchProgressEvent(eventNames().loadEvent, bytesSent, totalBytesToBeSent);
 959             m_upload-&gt;dispatchProgressEvent(eventNames().loadendEvent, bytesSent, totalBytesToBeSent);
 960         }
 961     }
 962 }
 963 
 964 void XMLHttpRequest::didReceiveResponse(unsigned long, const ResourceResponse&amp; response)
 965 {
 966     m_response = response;
 967 }
 968 
 969 static inline bool shouldDecodeResponse(XMLHttpRequest::ResponseType type)
 970 {
 971     switch (type) {
 972     case XMLHttpRequest::ResponseType::EmptyString:
 973     case XMLHttpRequest::ResponseType::Document:
 974     case XMLHttpRequest::ResponseType::Json:
 975     case XMLHttpRequest::ResponseType::Text:
 976         return true;
 977     case XMLHttpRequest::ResponseType::Arraybuffer:
 978     case XMLHttpRequest::ResponseType::Blob:
 979         return false;
 980     }
 981     ASSERT_NOT_REACHED();
 982     return true;
 983 }
 984 
 985 // https://xhr.spec.whatwg.org/#final-charset
 986 TextEncoding XMLHttpRequest::finalResponseCharset() const
 987 {
 988     String label = m_responseEncoding;
 989 
 990     String overrideResponseCharset = extractCharsetFromMediaType(m_mimeTypeOverride);
 991     if (!overrideResponseCharset.isEmpty())
 992         label = overrideResponseCharset;
 993 
 994     return TextEncoding(label);
 995 }
 996 
 997 Ref&lt;TextResourceDecoder&gt; XMLHttpRequest::createDecoder() const
 998 {
 999     TextEncoding finalResponseCharset = this-&gt;finalResponseCharset();
1000     if (finalResponseCharset.isValid())
1001         return TextResourceDecoder::create(&quot;text/plain&quot;, finalResponseCharset);
1002 
1003     switch (responseType()) {
1004     case ResponseType::EmptyString:
1005         if (responseIsXML()) {
1006             auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;);
1007             // Don&#39;t stop on encoding errors, unlike it is done for other kinds of XML resources. This matches the behavior of previous WebKit versions, Firefox and Opera.
1008             decoder-&gt;useLenientXMLDecoding();
1009             return decoder;
1010         }
1011         FALLTHROUGH;
1012     case ResponseType::Text:
1013     case ResponseType::Json:
1014         return TextResourceDecoder::create(&quot;text/plain&quot;, &quot;UTF-8&quot;);
1015     case ResponseType::Document: {
1016         if (equalLettersIgnoringASCIICase(responseMIMEType(), &quot;text/html&quot;))
1017             return TextResourceDecoder::create(&quot;text/html&quot;, &quot;UTF-8&quot;);
1018         auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;);
1019         // Don&#39;t stop on encoding errors, unlike it is done for other kinds of XML resources. This matches the behavior of previous WebKit versions, Firefox and Opera.
1020         decoder-&gt;useLenientXMLDecoding();
1021         return decoder;
1022     }
1023     case ResponseType::Arraybuffer:
1024     case ResponseType::Blob:
1025         ASSERT_NOT_REACHED();
1026         break;
1027     }
1028     return TextResourceDecoder::create(&quot;text/plain&quot;, &quot;UTF-8&quot;);
1029 }
1030 
1031 void XMLHttpRequest::didReceiveData(const char* data, int len)
1032 {
1033     if (m_error)
1034         return;
1035 
1036     if (readyState() &lt; HEADERS_RECEIVED)
1037         changeState(HEADERS_RECEIVED);
1038 
1039     if (!m_mimeTypeOverride.isEmpty())
1040         m_responseEncoding = extractCharsetFromMediaType(m_mimeTypeOverride);
1041     if (m_responseEncoding.isEmpty())
1042         m_responseEncoding = m_response.textEncodingName();
1043 
1044     bool useDecoder = shouldDecodeResponse(responseType());
1045 
1046     if (useDecoder &amp;&amp; !m_decoder)
1047         m_decoder = createDecoder();
1048 
1049     if (!len)
1050         return;
1051 
1052     if (len == -1)
1053         len = strlen(data);
1054 
1055     if (useDecoder)
1056         m_responseBuilder.append(m_decoder-&gt;decode(data, len));
1057     else {
1058         // Buffer binary data.
1059         if (!m_binaryResponseBuilder)
1060             m_binaryResponseBuilder = SharedBuffer::create();
1061         m_binaryResponseBuilder-&gt;append(data, len);
1062     }
1063 
1064     if (!m_error) {
1065         m_receivedLength += len;
1066 
1067         if (readyState() != LOADING)
1068             changeState(LOADING);
1069         else {
1070             // Firefox calls readyStateChanged every time it receives data, 4449442
1071             callReadyStateChangeListener();
1072         }
1073 
1074         if (m_async) {
1075             long long expectedLength = m_response.expectedContentLength();
1076             bool lengthComputable = expectedLength &gt; 0 &amp;&amp; m_receivedLength &lt;= expectedLength;
1077             unsigned long long total = lengthComputable ? expectedLength : 0;
1078             m_progressEventThrottle.dispatchThrottledProgressEvent(lengthComputable, m_receivedLength, total);
1079         }
1080     }
1081 }
1082 
1083 void XMLHttpRequest::dispatchEvent(Event&amp; event)
1084 {
<a name="17" id="anc17"></a><span class="line-added">1085     RELEASE_ASSERT(!scriptExecutionContext()-&gt;activeDOMObjectsAreSuspended());</span>
<span class="line-added">1086 </span>
1087     if (m_userGestureToken &amp;&amp; m_userGestureToken-&gt;hasExpired(m_maximumIntervalForUserGestureForwarding))
1088         m_userGestureToken = nullptr;
1089 
1090     if (readyState() != DONE || !m_userGestureToken || !m_userGestureToken-&gt;processingUserGesture()) {
1091         EventTarget::dispatchEvent(event);
1092         return;
1093     }
1094 
1095     UserGestureIndicator gestureIndicator(m_userGestureToken, UserGestureToken::GestureScope::MediaOnly);
1096     EventTarget::dispatchEvent(event);
1097 }
1098 
1099 void XMLHttpRequest::dispatchErrorEvents(const AtomString&amp; type)
1100 {
1101     if (!m_uploadComplete) {
1102         m_uploadComplete = true;
1103         if (m_upload &amp;&amp; m_uploadListenerFlag) {
1104             m_upload-&gt;dispatchProgressEvent(type, 0, 0);
1105             m_upload-&gt;dispatchProgressEvent(eventNames().loadendEvent, 0, 0);
1106         }
1107     }
1108     m_progressEventThrottle.dispatchProgressEvent(type);
1109     m_progressEventThrottle.dispatchProgressEvent(eventNames().loadendEvent);
1110 }
1111 
1112 void XMLHttpRequest::didReachTimeout()
1113 {
1114     // internalAbort() calls unsetPendingActivity(this), which may release the last reference.
1115     Ref&lt;XMLHttpRequest&gt; protectedThis(*this);
1116     if (!internalAbort())
1117         return;
1118 
1119     clearResponse();
1120     clearRequest();
1121 
1122     m_sendFlag = false;
1123     m_error = true;
1124     m_exceptionCode = TimeoutError;
1125 
1126     if (!m_async) {
1127         m_readyState = static_cast&lt;State&gt;(DONE);
1128         m_exceptionCode = TimeoutError;
1129         return;
1130     }
1131 
1132     changeState(DONE);
1133 
1134     dispatchErrorEvents(eventNames().timeoutEvent);
1135 }
1136 
<a name="18" id="anc18"></a>







1137 const char* XMLHttpRequest::activeDOMObjectName() const
1138 {
1139     return &quot;XMLHttpRequest&quot;;
1140 }
1141 
<a name="19" id="anc19"></a><span class="line-modified">1142 void XMLHttpRequest::suspend(ReasonForSuspension)</span>
1143 {
1144     m_progressEventThrottle.suspend();
<a name="20" id="anc20"></a>














1145 }
1146 
1147 void XMLHttpRequest::resume()
1148 {
1149     m_progressEventThrottle.resume();
<a name="21" id="anc21"></a>











1150 }
1151 
1152 void XMLHttpRequest::stop()
1153 {
1154     internalAbort();
1155 }
1156 
1157 void XMLHttpRequest::contextDestroyed()
1158 {
1159     ASSERT(!m_loader);
1160     ActiveDOMObject::contextDestroyed();
1161 }
1162 
1163 void XMLHttpRequest::setMaximumIntervalForUserGestureForwarding(double interval)
1164 {
1165     m_maximumIntervalForUserGestureForwarding = Seconds(interval);
1166 }
1167 
1168 } // namespace WebCore
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
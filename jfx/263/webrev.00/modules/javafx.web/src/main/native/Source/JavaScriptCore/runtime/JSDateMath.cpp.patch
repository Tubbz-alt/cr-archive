diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDateMath.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDateMath.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDateMath.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDateMath.cpp
@@ -98,34 +98,10 @@
 #include <sys/timeb.h>
 #endif
 
 namespace JSC {
 
-using namespace WTF;
-
-static inline double timeToMS(double hour, double min, double sec, double ms)
-{
-    return (((hour * minutesPerHour + min) * secondsPerMinute + sec) * msPerSecond + ms);
-}
-
-static inline int msToSeconds(double ms)
-{
-    double result = fmod(floor(ms / msPerSecond), secondsPerMinute);
-    if (result < 0)
-        result += secondsPerMinute;
-    return static_cast<int>(result);
-}
-
-// 0: Sunday, 1: Monday, etc.
-static inline int msToWeekDay(double ms)
-{
-    int wd = (static_cast<int>(msToDays(ms)) + 4) % 7;
-    if (wd < 0)
-        wd += 7;
-    return wd;
-}
-
 // Get the combined UTC + DST offset for the time passed in.
 //
 // NOTE: The implementation relies on the fact that no time zones have
 // more than one daylight savings offset change per month.
 // If this function is called with NaN it returns NaN.
@@ -150,22 +126,22 @@
             if (cache.offset == endOffset) {
                 // If the offset at the end of the new interval still matches
                 // the offset in the cache, we grow the cached time interval
                 // and return the offset.
                 cache.end = newEnd;
-                cache.increment = msPerMonth;
+                cache.increment = WTF::msPerMonth;
                 return endOffset;
             }
             LocalTimeOffset offset = calculateLocalTimeOffset(ms, inputTimeType);
             if (offset == endOffset) {
                 // The offset at the given time is equal to the offset at the
                 // new end of the interval, so that means that we've just skipped
                 // the point in time where the DST offset change occurred. Updated
                 // the interval to reflect this and reset the increment.
                 cache.start = ms;
                 cache.end = newEnd;
-                cache.increment = msPerMonth;
+                cache.increment = WTF::msPerMonth;
             } else {
                 // The interval contains a DST offset change and the given time is
                 // before it. Adjust the increment to avoid a linear search for
                 // the offset change point and change the end of the interval.
                 cache.increment /= 3;
@@ -182,21 +158,26 @@
     // computations for the same time.
     LocalTimeOffset offset = calculateLocalTimeOffset(ms, inputTimeType);
     cache.offset = offset;
     cache.start = ms;
     cache.end = ms;
-    cache.increment = msPerMonth;
+    cache.increment = WTF::msPerMonth;
     return offset;
 }
 
+static inline double timeToMS(double hour, double min, double sec, double ms)
+{
+    return (((hour * WTF::minutesPerHour + min) * WTF::secondsPerMinute + sec) * WTF::msPerSecond + ms);
+}
+
 double gregorianDateTimeToMS(VM& vm, const GregorianDateTime& t, double milliSeconds, WTF::TimeType inputTimeType)
 {
     double day = dateToDaysFrom1970(t.year(), t.month(), t.monthDay());
     double ms = timeToMS(t.hour(), t.minute(), t.second(), milliSeconds);
     double localTimeResult = (day * WTF::msPerDay) + ms;
 
-    double localToUTCTimeOffset = inputTimeType == LocalTime
+    double localToUTCTimeOffset = inputTimeType == WTF::LocalTime
         ? localTimeOffset(vm, localTimeResult, inputTimeType).offset : 0;
 
     return localTimeResult - localToUTCTimeOffset;
 }
 
@@ -206,59 +187,44 @@
     LocalTimeOffset localTime;
     if (outputTimeType == WTF::LocalTime) {
         localTime = localTimeOffset(vm, ms);
         ms += localTime.offset;
     }
-
-    const int year = msToYear(ms);
-    tm.setSecond(msToSeconds(ms));
-    tm.setMinute(msToMinutes(ms));
-    tm.setHour(msToHours(ms));
-    tm.setWeekDay(msToWeekDay(ms));
-    tm.setYearDay(dayInYear(ms, year));
-    tm.setMonthDay(dayInMonthFromDayInYear(tm.yearDay(), isLeapYear(year)));
-    tm.setMonth(monthFromDayInYear(tm.yearDay(), isLeapYear(year)));
-    tm.setYear(year);
-    tm.setIsDST(localTime.isDST);
-    tm.setUtcOffset(localTime.offset / WTF::msPerSecond);
+    tm = GregorianDateTime(ms, localTime);
 }
 
-double parseDateFromNullTerminatedCharacters(VM& vm, const char* dateString)
+static double parseDate(VM& vm, const char* dateString)
 {
-    bool haveTZ;
-    int offset;
-    double localTimeMS = WTF::parseDateFromNullTerminatedCharacters(dateString, haveTZ, offset);
-    if (std::isnan(localTimeMS))
-        return std::numeric_limits<double>::quiet_NaN();
+    bool isLocalTime;
+    double value = WTF::parseES5DateFromNullTerminatedCharacters(dateString, isLocalTime);
+    if (std::isnan(value))
+        value = WTF::parseDateFromNullTerminatedCharacters(dateString, isLocalTime);
 
-    // fall back to local timezone.
-    if (!haveTZ)
-        offset = localTimeOffset(vm, localTimeMS, WTF::LocalTime).offset / WTF::msPerMinute;
+    if (isLocalTime)
+        value -= localTimeOffset(vm, value, WTF::LocalTime).offset;
 
-    return localTimeMS - (offset * WTF::msPerMinute);
+    return value;
 }
 
-double parseDate(ExecState* exec, VM& vm, const String& date)
+double parseDate(JSGlobalObject* globalObject, VM& vm, const String& date)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (date == vm.cachedDateString)
         return vm.cachedDateStringValue;
     auto expectedString = date.tryGetUtf8();
     if (!expectedString) {
         if (expectedString.error() == UTF8ConversionError::OutOfMemory)
-            throwOutOfMemoryError(exec, scope);
+            throwOutOfMemoryError(globalObject, scope);
         // https://tc39.github.io/ecma262/#sec-date-objects section 20.3.3.2 states that:
         // "Unrecognizable Strings or dates containing illegal element values in the
         // format String shall cause Date.parse to return NaN."
         return std::numeric_limits<double>::quiet_NaN();
     }
 
     auto dateUtf8 = expectedString.value();
-    double value = parseES5DateFromNullTerminatedCharacters(dateUtf8.data());
-    if (std::isnan(value))
-        value = parseDateFromNullTerminatedCharacters(vm, dateUtf8.data());
+    double value = parseDate(vm, dateUtf8.data());
     vm.cachedDateString = date;
     vm.cachedDateStringValue = value;
     return value;
 }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../builtins/TypedArrayPrototype.js.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessCase.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2017-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,10 ***</span>
<span class="line-new-header">--- 27,11 ---</span>
  #include &quot;AccessCase.h&quot;
  
  #if ENABLE(JIT)
  
  #include &quot;CCallHelpers.h&quot;
<span class="line-added">+ #include &quot;CacheableIdentifierInlines.h&quot;</span>
  #include &quot;CallLinkInfo.h&quot;
  #include &quot;DOMJITGetterSetter.h&quot;
  #include &quot;DirectArguments.h&quot;
  #include &quot;GetterSetter.h&quot;
  #include &quot;GetterSetterAccessCase.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 49,23 ***</span>
  #include &quot;ThunkGenerators.h&quot;
  
  namespace JSC {
  
  namespace AccessCaseInternal {
<span class="line-modified">! static const bool verbose = false;</span>
  }
  
<span class="line-modified">! AccessCase::AccessCase(VM&amp; vm, JSCell* owner, AccessType type, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)</span>
      : m_type(type)
      , m_offset(offset)
      , m_polyProtoAccessChain(WTFMove(prototypeAccessChain))
  {
      m_structure.setMayBeNull(vm, owner, structure);
      m_conditionSet = conditionSet;
  }
  
<span class="line-modified">! std::unique_ptr&lt;AccessCase&gt; AccessCase::create(VM&amp; vm, JSCell* owner, AccessType type, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)</span>
  {
      switch (type) {
      case InHit:
      case InMiss:
          break;
<span class="line-new-header">--- 50,27 ---</span>
  #include &quot;ThunkGenerators.h&quot;
  
  namespace JSC {
  
  namespace AccessCaseInternal {
<span class="line-modified">! static constexpr bool verbose = false;</span>
  }
  
<span class="line-modified">! DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(AccessCase);</span>
<span class="line-added">+ </span>
<span class="line-added">+ AccessCase::AccessCase(VM&amp; vm, JSCell* owner, AccessType type, CacheableIdentifier identifier, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)</span>
      : m_type(type)
      , m_offset(offset)
      , m_polyProtoAccessChain(WTFMove(prototypeAccessChain))
<span class="line-added">+     , m_identifier(identifier)</span>
  {
      m_structure.setMayBeNull(vm, owner, structure);
      m_conditionSet = conditionSet;
<span class="line-added">+     RELEASE_ASSERT(m_conditionSet.isValid());</span>
  }
  
<span class="line-modified">! std::unique_ptr&lt;AccessCase&gt; AccessCase::create(VM&amp; vm, JSCell* owner, AccessType type, CacheableIdentifier identifier, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)</span>
  {
      switch (type) {
      case InHit:
      case InMiss:
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,21 ***</span>
      case DirectArgumentsLength:
      case ScopedArgumentsLength:
      case ModuleNamespaceLoad:
      case Replace:
      case InstanceOfGeneric:
          RELEASE_ASSERT(!prototypeAccessChain);
          break;
      default:
          RELEASE_ASSERT_NOT_REACHED();
      };
  
<span class="line-modified">!     return std::unique_ptr&lt;AccessCase&gt;(new AccessCase(vm, owner, type, offset, structure, conditionSet, WTFMove(prototypeAccessChain)));</span>
  }
  
  std::unique_ptr&lt;AccessCase&gt; AccessCase::create(
<span class="line-modified">!     VM&amp; vm, JSCell* owner, PropertyOffset offset, Structure* oldStructure, Structure* newStructure,</span>
      const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)
  {
      RELEASE_ASSERT(oldStructure == newStructure-&gt;previousID());
  
      // Skip optimizing the case where we need a realloc, if we don&#39;t have
<span class="line-new-header">--- 79,37 ---</span>
      case DirectArgumentsLength:
      case ScopedArgumentsLength:
      case ModuleNamespaceLoad:
      case Replace:
      case InstanceOfGeneric:
<span class="line-added">+     case IndexedInt32Load:</span>
<span class="line-added">+     case IndexedDoubleLoad:</span>
<span class="line-added">+     case IndexedContiguousLoad:</span>
<span class="line-added">+     case IndexedArrayStorageLoad:</span>
<span class="line-added">+     case IndexedScopedArgumentsLoad:</span>
<span class="line-added">+     case IndexedDirectArgumentsLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">+     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">+     case IndexedStringLoad:</span>
          RELEASE_ASSERT(!prototypeAccessChain);
          break;
      default:
          RELEASE_ASSERT_NOT_REACHED();
      };
  
<span class="line-modified">!     return std::unique_ptr&lt;AccessCase&gt;(new AccessCase(vm, owner, type, identifier, offset, structure, conditionSet, WTFMove(prototypeAccessChain)));</span>
  }
  
  std::unique_ptr&lt;AccessCase&gt; AccessCase::create(
<span class="line-modified">!     VM&amp; vm, JSCell* owner, CacheableIdentifier identifier, PropertyOffset offset, Structure* oldStructure, Structure* newStructure,</span>
      const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)
  {
      RELEASE_ASSERT(oldStructure == newStructure-&gt;previousID());
  
      // Skip optimizing the case where we need a realloc, if we don&#39;t have
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,35 ***</span>
          &amp;&amp; oldStructure-&gt;outOfLineCapacity() != newStructure-&gt;outOfLineCapacity()
          &amp;&amp; oldStructure-&gt;outOfLineCapacity()) {
          return nullptr;
      }
  
<span class="line-modified">!     return std::unique_ptr&lt;AccessCase&gt;(new AccessCase(vm, owner, Transition, offset, newStructure, conditionSet, WTFMove(prototypeAccessChain)));</span>
  }
  
  AccessCase::~AccessCase()
  {
  }
  
  std::unique_ptr&lt;AccessCase&gt; AccessCase::fromStructureStubInfo(
<span class="line-modified">!     VM&amp; vm, JSCell* owner, StructureStubInfo&amp; stubInfo)</span>
  {
<span class="line-modified">!     switch (stubInfo.cacheType) {</span>
      case CacheType::GetByIdSelf:
<span class="line-modified">!         return ProxyableAccessCase::create(vm, owner, Load, stubInfo.u.byIdSelf.offset, stubInfo.u.byIdSelf.baseObjectStructure.get());</span>
  
      case CacheType::PutByIdReplace:
<span class="line-modified">!         return AccessCase::create(vm, owner, Replace, stubInfo.u.byIdSelf.offset, stubInfo.u.byIdSelf.baseObjectStructure.get());</span>
  
      case CacheType::InByIdSelf:
<span class="line-modified">!         return AccessCase::create(vm, owner, InHit, stubInfo.u.byIdSelf.offset, stubInfo.u.byIdSelf.baseObjectStructure.get());</span>
  
      case CacheType::ArrayLength:
<span class="line-modified">!         return AccessCase::create(vm, owner, AccessCase::ArrayLength);</span>
  
      case CacheType::StringLength:
<span class="line-modified">!         return AccessCase::create(vm, owner, AccessCase::StringLength);</span>
  
      default:
          return nullptr;
      }
  }
<span class="line-new-header">--- 118,44 ---</span>
          &amp;&amp; oldStructure-&gt;outOfLineCapacity() != newStructure-&gt;outOfLineCapacity()
          &amp;&amp; oldStructure-&gt;outOfLineCapacity()) {
          return nullptr;
      }
  
<span class="line-modified">!     return std::unique_ptr&lt;AccessCase&gt;(new AccessCase(vm, owner, Transition, identifier, offset, newStructure, conditionSet, WTFMove(prototypeAccessChain)));</span>
  }
  
  AccessCase::~AccessCase()
  {
  }
  
  std::unique_ptr&lt;AccessCase&gt; AccessCase::fromStructureStubInfo(
<span class="line-modified">!     VM&amp; vm, JSCell* owner, CacheableIdentifier identifier, StructureStubInfo&amp; stubInfo)</span>
  {
<span class="line-modified">!     switch (stubInfo.cacheType()) {</span>
      case CacheType::GetByIdSelf:
<span class="line-modified">!         RELEASE_ASSERT(stubInfo.hasConstantIdentifier);</span>
<span class="line-added">+         return ProxyableAccessCase::create(vm, owner, Load, identifier, stubInfo.u.byIdSelf.offset, stubInfo.u.byIdSelf.baseObjectStructure.get());</span>
  
      case CacheType::PutByIdReplace:
<span class="line-modified">!         RELEASE_ASSERT(stubInfo.hasConstantIdentifier);</span>
<span class="line-added">+         ASSERT(!identifier.isCell());</span>
<span class="line-added">+         return AccessCase::create(vm, owner, Replace, identifier, stubInfo.u.byIdSelf.offset, stubInfo.u.byIdSelf.baseObjectStructure.get());</span>
  
      case CacheType::InByIdSelf:
<span class="line-modified">!         RELEASE_ASSERT(stubInfo.hasConstantIdentifier);</span>
<span class="line-added">+         ASSERT(!identifier.isCell());</span>
<span class="line-added">+         return AccessCase::create(vm, owner, InHit, identifier, stubInfo.u.byIdSelf.offset, stubInfo.u.byIdSelf.baseObjectStructure.get());</span>
  
      case CacheType::ArrayLength:
<span class="line-modified">!         RELEASE_ASSERT(stubInfo.hasConstantIdentifier);</span>
<span class="line-added">+         ASSERT(!identifier.isCell());</span>
<span class="line-added">+         return AccessCase::create(vm, owner, AccessCase::ArrayLength, identifier);</span>
  
      case CacheType::StringLength:
<span class="line-modified">!         RELEASE_ASSERT(stubInfo.hasConstantIdentifier);</span>
<span class="line-added">+         ASSERT(!identifier.isCell());</span>
<span class="line-added">+         return AccessCase::create(vm, owner, AccessCase::StringLength, identifier);</span>
  
      default:
          return nullptr;
      }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 145,25 ***</span>
      std::unique_ptr&lt;AccessCase&gt; result(new AccessCase(*this));
      result-&gt;resetState();
      return result;
  }
  
<span class="line-modified">! Vector&lt;WatchpointSet*, 2&gt; AccessCase::commit(VM&amp; vm, const Identifier&amp; ident)</span>
  {
      // It&#39;s fine to commit something that is already committed. That arises when we switch to using
      // newly allocated watchpoints. When it happens, it&#39;s not efficient - but we think that&#39;s OK
      // because most AccessCases have no extra watchpoints anyway.
      RELEASE_ASSERT(m_state == Primordial || m_state == Committed);
  
      Vector&lt;WatchpointSet*, 2&gt; result;
      Structure* structure = this-&gt;structure();
  
<span class="line-modified">!     if (!ident.isNull()) {</span>
          if ((structure &amp;&amp; structure-&gt;needImpurePropertyWatchpoint())
              || m_conditionSet.needImpurePropertyWatchpoint()
<span class="line-modified">!             || (m_polyProtoAccessChain &amp;&amp; m_polyProtoAccessChain-&gt;needImpurePropertyWatchpoint()))</span>
<span class="line-modified">!             result.append(vm.ensureWatchpointSetForImpureProperty(ident));</span>
      }
  
      if (additionalSet())
          result.append(additionalSet());
  
<span class="line-new-header">--- 175,25 ---</span>
      std::unique_ptr&lt;AccessCase&gt; result(new AccessCase(*this));
      result-&gt;resetState();
      return result;
  }
  
<span class="line-modified">! Vector&lt;WatchpointSet*, 2&gt; AccessCase::commit(VM&amp; vm)</span>
  {
      // It&#39;s fine to commit something that is already committed. That arises when we switch to using
      // newly allocated watchpoints. When it happens, it&#39;s not efficient - but we think that&#39;s OK
      // because most AccessCases have no extra watchpoints anyway.
      RELEASE_ASSERT(m_state == Primordial || m_state == Committed);
  
      Vector&lt;WatchpointSet*, 2&gt; result;
      Structure* structure = this-&gt;structure();
  
<span class="line-modified">!     if (m_identifier) {</span>
          if ((structure &amp;&amp; structure-&gt;needImpurePropertyWatchpoint())
              || m_conditionSet.needImpurePropertyWatchpoint()
<span class="line-modified">!             || (m_polyProtoAccessChain &amp;&amp; m_polyProtoAccessChain-&gt;needImpurePropertyWatchpoint(vm)))</span>
<span class="line-modified">!             result.append(vm.ensureWatchpointSetForImpureProperty(m_identifier.uid()));</span>
      }
  
      if (additionalSet())
          result.append(additionalSet());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 178,11 ***</span>
      m_state = Committed;
  
      return result;
  }
  
<span class="line-modified">! bool AccessCase::guardedByStructureCheck() const</span>
  {
      if (viaProxy())
          return false;
  
      if (m_polyProtoAccessChain)
<span class="line-new-header">--- 208,18 ---</span>
      m_state = Committed;
  
      return result;
  }
  
<span class="line-modified">! bool AccessCase::guardedByStructureCheck(const StructureStubInfo&amp; stubInfo) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     return guardedByStructureCheckSkippingConstantIdentifierCheck();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool AccessCase::guardedByStructureCheckSkippingConstantIdentifierCheck() const</span>
  {
      if (viaProxy())
          return false;
  
      if (m_polyProtoAccessChain)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,85 ***</span>
      case ScopedArgumentsLength:
      case ModuleNamespaceLoad:
      case InstanceOfHit:
      case InstanceOfMiss:
      case InstanceOfGeneric:
          return false;
      default:
          return true;
      }
  }
  
<span class="line-modified">! bool AccessCase::doesCalls(Vector&lt;JSCell*&gt;* cellsToMark) const</span>
  {
<span class="line-modified">!     switch (type()) {</span>
      case Getter:
      case Setter:
      case CustomValueGetter:
      case CustomAccessorGetter:
      case CustomValueSetter:
      case CustomAccessorSetter:
          return true;
      case Transition:
<span class="line-modified">!         if (newStructure()-&gt;outOfLineCapacity() != structure()-&gt;outOfLineCapacity()</span>
<span class="line-modified">!             &amp;&amp; structure()-&gt;couldHaveIndexingHeader()) {</span>
<span class="line-modified">!             if (cellsToMark)</span>
<span class="line-modified">!                 cellsToMark-&gt;append(newStructure());</span>
<span class="line-modified">!             return true;</span>
<span class="line-modified">!         }</span>
          return false;
<span class="line-modified">!     default:</span>
          return false;
      }
  }
  
  bool AccessCase::couldStillSucceed() const
  {
<span class="line-modified">!     return m_conditionSet.structuresEnsureValidityAssumingImpurePropertyWatchpoint();</span>
  }
  
  bool AccessCase::canReplace(const AccessCase&amp; other) const
  {
      // This puts in a good effort to try to figure out if &#39;other&#39; is made superfluous by &#39;*this&#39;.
      // It&#39;s fine for this to return false if it&#39;s in doubt.
      //
      // Note that if A-&gt;guardedByStructureCheck() &amp;&amp; B-&gt;guardedByStructureCheck() then
      // A-&gt;canReplace(B) == B-&gt;canReplace(A).
  
      switch (type()) {
      case ArrayLength:
      case StringLength:
      case DirectArgumentsLength:
      case ScopedArgumentsLength:
          return other.type() == type();
      case ModuleNamespaceLoad: {
          if (other.type() != type())
              return false;
          auto&amp; thisCase = this-&gt;as&lt;ModuleNamespaceAccessCase&gt;();
          auto&amp; otherCase = this-&gt;as&lt;ModuleNamespaceAccessCase&gt;();
          return thisCase.moduleNamespaceObject() == otherCase.moduleNamespaceObject();
      }
      case InstanceOfHit:
      case InstanceOfMiss: {
          if (other.type() != type())
              return false;
  
          if (this-&gt;as&lt;InstanceOfAccessCase&gt;().prototype() != other.as&lt;InstanceOfAccessCase&gt;().prototype())
              return false;
  
          return structure() == other.structure();
      }
      case InstanceOfGeneric:
          switch (other.type()) {
          case InstanceOfGeneric:
          case InstanceOfHit:
          case InstanceOfMiss:
              return true;
          default:
              return false;
          }
<span class="line-modified">!     default:</span>
          if (other.type() != type())
              return false;
  
          if (m_polyProtoAccessChain) {
              if (!other.m_polyProtoAccessChain)
<span class="line-new-header">--- 232,402 ---</span>
      case ScopedArgumentsLength:
      case ModuleNamespaceLoad:
      case InstanceOfHit:
      case InstanceOfMiss:
      case InstanceOfGeneric:
<span class="line-added">+     case IndexedInt32Load:</span>
<span class="line-added">+     case IndexedDoubleLoad:</span>
<span class="line-added">+     case IndexedContiguousLoad:</span>
<span class="line-added">+     case IndexedArrayStorageLoad:</span>
<span class="line-added">+     case IndexedScopedArgumentsLoad:</span>
<span class="line-added">+     case IndexedDirectArgumentsLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">+     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">+     case IndexedStringLoad:</span>
          return false;
      default:
          return true;
      }
  }
  
<span class="line-modified">! bool AccessCase::requiresIdentifierNameMatch() const</span>
  {
<span class="line-modified">!     switch (m_type) {</span>
<span class="line-added">+     case Load:</span>
<span class="line-added">+     // We don&#39;t currently have a by_val for these puts, but we do care about the identifier.</span>
<span class="line-added">+     case Transition:</span>
<span class="line-added">+     case Replace:</span>
<span class="line-added">+     case Miss:</span>
<span class="line-added">+     case GetGetter:</span>
      case Getter:
      case Setter:
      case CustomValueGetter:
      case CustomAccessorGetter:
      case CustomValueSetter:
      case CustomAccessorSetter:
<span class="line-added">+     case IntrinsicGetter:</span>
<span class="line-added">+     case InHit:</span>
<span class="line-added">+     case InMiss:</span>
<span class="line-added">+     case ArrayLength:</span>
<span class="line-added">+     case StringLength:</span>
<span class="line-added">+     case DirectArgumentsLength:</span>
<span class="line-added">+     case ScopedArgumentsLength:</span>
<span class="line-added">+     case ModuleNamespaceLoad:</span>
          return true;
<span class="line-added">+     case InstanceOfHit:</span>
<span class="line-added">+     case InstanceOfMiss:</span>
<span class="line-added">+     case InstanceOfGeneric:</span>
<span class="line-added">+     case IndexedInt32Load:</span>
<span class="line-added">+     case IndexedDoubleLoad:</span>
<span class="line-added">+     case IndexedContiguousLoad:</span>
<span class="line-added">+     case IndexedArrayStorageLoad:</span>
<span class="line-added">+     case IndexedScopedArgumentsLoad:</span>
<span class="line-added">+     case IndexedDirectArgumentsLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">+     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">+     case IndexedStringLoad:</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool AccessCase::requiresInt32PropertyCheck() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (m_type) {</span>
<span class="line-added">+     case Load:</span>
      case Transition:
<span class="line-modified">!     case Replace:</span>
<span class="line-modified">!     case Miss:</span>
<span class="line-modified">!     case GetGetter:</span>
<span class="line-modified">!     case Getter:</span>
<span class="line-modified">!     case Setter:</span>
<span class="line-modified">!     case CustomValueGetter:</span>
<span class="line-added">+     case CustomAccessorGetter:</span>
<span class="line-added">+     case CustomValueSetter:</span>
<span class="line-added">+     case CustomAccessorSetter:</span>
<span class="line-added">+     case IntrinsicGetter:</span>
<span class="line-added">+     case InHit:</span>
<span class="line-added">+     case InMiss:</span>
<span class="line-added">+     case ArrayLength:</span>
<span class="line-added">+     case StringLength:</span>
<span class="line-added">+     case DirectArgumentsLength:</span>
<span class="line-added">+     case ScopedArgumentsLength:</span>
<span class="line-added">+     case ModuleNamespaceLoad:</span>
<span class="line-added">+     case InstanceOfHit:</span>
<span class="line-added">+     case InstanceOfMiss:</span>
<span class="line-added">+     case InstanceOfGeneric:</span>
          return false;
<span class="line-modified">!     case IndexedInt32Load:</span>
<span class="line-added">+     case IndexedDoubleLoad:</span>
<span class="line-added">+     case IndexedContiguousLoad:</span>
<span class="line-added">+     case IndexedArrayStorageLoad:</span>
<span class="line-added">+     case IndexedScopedArgumentsLoad:</span>
<span class="line-added">+     case IndexedDirectArgumentsLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">+     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">+     case IndexedStringLoad:</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool AccessCase::needsScratchFPR() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (m_type) {</span>
<span class="line-added">+     case Load:</span>
<span class="line-added">+     case Transition:</span>
<span class="line-added">+     case Replace:</span>
<span class="line-added">+     case Miss:</span>
<span class="line-added">+     case GetGetter:</span>
<span class="line-added">+     case Getter:</span>
<span class="line-added">+     case Setter:</span>
<span class="line-added">+     case CustomValueGetter:</span>
<span class="line-added">+     case CustomAccessorGetter:</span>
<span class="line-added">+     case CustomValueSetter:</span>
<span class="line-added">+     case CustomAccessorSetter:</span>
<span class="line-added">+     case IntrinsicGetter:</span>
<span class="line-added">+     case InHit:</span>
<span class="line-added">+     case InMiss:</span>
<span class="line-added">+     case ArrayLength:</span>
<span class="line-added">+     case StringLength:</span>
<span class="line-added">+     case DirectArgumentsLength:</span>
<span class="line-added">+     case ScopedArgumentsLength:</span>
<span class="line-added">+     case ModuleNamespaceLoad:</span>
<span class="line-added">+     case InstanceOfHit:</span>
<span class="line-added">+     case InstanceOfMiss:</span>
<span class="line-added">+     case InstanceOfGeneric:</span>
<span class="line-added">+     case IndexedInt32Load:</span>
<span class="line-added">+     case IndexedContiguousLoad:</span>
<span class="line-added">+     case IndexedArrayStorageLoad:</span>
<span class="line-added">+     case IndexedScopedArgumentsLoad:</span>
<span class="line-added">+     case IndexedDirectArgumentsLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">+     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">+     case IndexedStringLoad:</span>
          return false;
<span class="line-added">+     case IndexedDoubleLoad:</span>
<span class="line-added">+     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename Functor&gt;</span>
<span class="line-added">+ void AccessCase::forEachDependentCell(VM&amp; vm, const Functor&amp; functor) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_conditionSet.forEachDependentCell(functor);</span>
<span class="line-added">+     if (m_structure)</span>
<span class="line-added">+         functor(m_structure.get());</span>
<span class="line-added">+     if (m_polyProtoAccessChain) {</span>
<span class="line-added">+         for (StructureID structureID : m_polyProtoAccessChain-&gt;chain())</span>
<span class="line-added">+             functor(vm.getStructure(structureID));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     switch (type()) {</span>
<span class="line-added">+     case Getter:</span>
<span class="line-added">+     case Setter: {</span>
<span class="line-added">+         auto&amp; accessor = this-&gt;as&lt;GetterSetterAccessCase&gt;();</span>
<span class="line-added">+         if (accessor.callLinkInfo())</span>
<span class="line-added">+             accessor.callLinkInfo()-&gt;forEachDependentCell(functor);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case CustomValueGetter:</span>
<span class="line-added">+     case CustomValueSetter: {</span>
<span class="line-added">+         auto&amp; accessor = this-&gt;as&lt;GetterSetterAccessCase&gt;();</span>
<span class="line-added">+         if (accessor.customSlotBase())</span>
<span class="line-added">+             functor(accessor.customSlotBase());</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case IntrinsicGetter: {</span>
<span class="line-added">+         auto&amp; intrinsic = this-&gt;as&lt;IntrinsicGetterAccessCase&gt;();</span>
<span class="line-added">+         if (intrinsic.intrinsicFunction())</span>
<span class="line-added">+             functor(intrinsic.intrinsicFunction());</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case ModuleNamespaceLoad: {</span>
<span class="line-added">+         auto&amp; accessCase = this-&gt;as&lt;ModuleNamespaceAccessCase&gt;();</span>
<span class="line-added">+         if (accessCase.moduleNamespaceObject())</span>
<span class="line-added">+             functor(accessCase.moduleNamespaceObject());</span>
<span class="line-added">+         if (accessCase.moduleEnvironment())</span>
<span class="line-added">+             functor(accessCase.moduleEnvironment());</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case InstanceOfHit:</span>
<span class="line-added">+     case InstanceOfMiss:</span>
<span class="line-added">+         if (as&lt;InstanceOfAccessCase&gt;().prototype())</span>
<span class="line-added">+             functor(as&lt;InstanceOfAccessCase&gt;().prototype());</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case CustomAccessorGetter:</span>
<span class="line-added">+     case CustomAccessorSetter:</span>
<span class="line-added">+     case Load:</span>
<span class="line-added">+     case Transition:</span>
<span class="line-added">+     case Replace:</span>
<span class="line-added">+     case Miss:</span>
<span class="line-added">+     case GetGetter:</span>
<span class="line-added">+     case InHit:</span>
<span class="line-added">+     case InMiss:</span>
<span class="line-added">+     case ArrayLength:</span>
<span class="line-added">+     case StringLength:</span>
<span class="line-added">+     case DirectArgumentsLength:</span>
<span class="line-added">+     case ScopedArgumentsLength:</span>
<span class="line-added">+     case InstanceOfGeneric:</span>
<span class="line-added">+     case IndexedInt32Load:</span>
<span class="line-added">+     case IndexedDoubleLoad:</span>
<span class="line-added">+     case IndexedContiguousLoad:</span>
<span class="line-added">+     case IndexedArrayStorageLoad:</span>
<span class="line-added">+     case IndexedScopedArgumentsLoad:</span>
<span class="line-added">+     case IndexedDirectArgumentsLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">+     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">+     case IndexedStringLoad:</span>
<span class="line-added">+         break;</span>
      }
  }
  
<span class="line-added">+ bool AccessCase::doesCalls(VM&amp; vm, Vector&lt;JSCell*&gt;* cellsToMarkIfDoesCalls) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     bool doesCalls = false;</span>
<span class="line-added">+     switch (type()) {</span>
<span class="line-added">+     case Transition:</span>
<span class="line-added">+         doesCalls = newStructure()-&gt;outOfLineCapacity() != structure()-&gt;outOfLineCapacity() &amp;&amp; structure()-&gt;couldHaveIndexingHeader();</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case Getter:</span>
<span class="line-added">+     case Setter:</span>
<span class="line-added">+     case CustomValueGetter:</span>
<span class="line-added">+     case CustomAccessorGetter:</span>
<span class="line-added">+     case CustomValueSetter:</span>
<span class="line-added">+     case CustomAccessorSetter:</span>
<span class="line-added">+         doesCalls = true;</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case Load:</span>
<span class="line-added">+     case Replace:</span>
<span class="line-added">+     case Miss:</span>
<span class="line-added">+     case GetGetter:</span>
<span class="line-added">+     case IntrinsicGetter:</span>
<span class="line-added">+     case InHit:</span>
<span class="line-added">+     case InMiss:</span>
<span class="line-added">+     case ArrayLength:</span>
<span class="line-added">+     case StringLength:</span>
<span class="line-added">+     case DirectArgumentsLength:</span>
<span class="line-added">+     case ScopedArgumentsLength:</span>
<span class="line-added">+     case ModuleNamespaceLoad:</span>
<span class="line-added">+     case InstanceOfHit:</span>
<span class="line-added">+     case InstanceOfMiss:</span>
<span class="line-added">+     case InstanceOfGeneric:</span>
<span class="line-added">+     case IndexedInt32Load:</span>
<span class="line-added">+     case IndexedDoubleLoad:</span>
<span class="line-added">+     case IndexedContiguousLoad:</span>
<span class="line-added">+     case IndexedArrayStorageLoad:</span>
<span class="line-added">+     case IndexedScopedArgumentsLoad:</span>
<span class="line-added">+     case IndexedDirectArgumentsLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">+     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">+     case IndexedStringLoad:</span>
<span class="line-added">+         doesCalls = false;</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (doesCalls &amp;&amp; cellsToMarkIfDoesCalls) {</span>
<span class="line-added">+         forEachDependentCell(vm, [&amp;](JSCell* cell) {</span>
<span class="line-added">+             cellsToMarkIfDoesCalls-&gt;append(cell);</span>
<span class="line-added">+         });</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return doesCalls;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool AccessCase::couldStillSucceed() const
  {
<span class="line-modified">!     for (const ObjectPropertyCondition&amp; condition : m_conditionSet) {</span>
<span class="line-added">+         if (condition.condition().kind() == PropertyCondition::Equivalence) {</span>
<span class="line-added">+             if (!condition.isWatchableAssumingImpurePropertyWatchpoint(PropertyCondition::WatchabilityEffort::EnsureWatchability))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             if (!condition.structureEnsuresValidityAssumingImpurePropertyWatchpoint())</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return true;</span>
  }
  
  bool AccessCase::canReplace(const AccessCase&amp; other) const
  {
      // This puts in a good effort to try to figure out if &#39;other&#39; is made superfluous by &#39;*this&#39;.
      // It&#39;s fine for this to return false if it&#39;s in doubt.
      //
      // Note that if A-&gt;guardedByStructureCheck() &amp;&amp; B-&gt;guardedByStructureCheck() then
      // A-&gt;canReplace(B) == B-&gt;canReplace(A).
  
<span class="line-added">+     if (m_identifier != other.m_identifier)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      switch (type()) {
<span class="line-added">+     case IndexedInt32Load:</span>
<span class="line-added">+     case IndexedDoubleLoad:</span>
<span class="line-added">+     case IndexedContiguousLoad:</span>
<span class="line-added">+     case IndexedArrayStorageLoad:</span>
      case ArrayLength:
      case StringLength:
      case DirectArgumentsLength:
      case ScopedArgumentsLength:
<span class="line-added">+     case IndexedScopedArgumentsLoad:</span>
<span class="line-added">+     case IndexedDirectArgumentsLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">+     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">+     case IndexedStringLoad:</span>
          return other.type() == type();
<span class="line-added">+ </span>
      case ModuleNamespaceLoad: {
          if (other.type() != type())
              return false;
          auto&amp; thisCase = this-&gt;as&lt;ModuleNamespaceAccessCase&gt;();
          auto&amp; otherCase = this-&gt;as&lt;ModuleNamespaceAccessCase&gt;();
          return thisCase.moduleNamespaceObject() == otherCase.moduleNamespaceObject();
      }
<span class="line-added">+ </span>
      case InstanceOfHit:
      case InstanceOfMiss: {
          if (other.type() != type())
              return false;
  
          if (this-&gt;as&lt;InstanceOfAccessCase&gt;().prototype() != other.as&lt;InstanceOfAccessCase&gt;().prototype())
              return false;
  
          return structure() == other.structure();
      }
<span class="line-added">+ </span>
      case InstanceOfGeneric:
          switch (other.type()) {
          case InstanceOfGeneric:
          case InstanceOfHit:
          case InstanceOfMiss:
              return true;
          default:
              return false;
          }
<span class="line-modified">! </span>
<span class="line-added">+     case Load:</span>
<span class="line-added">+     case Transition:</span>
<span class="line-added">+     case Replace:</span>
<span class="line-added">+     case Miss:</span>
<span class="line-added">+     case GetGetter:</span>
<span class="line-added">+     case Getter:</span>
<span class="line-added">+     case Setter:</span>
<span class="line-added">+     case CustomValueGetter:</span>
<span class="line-added">+     case CustomAccessorGetter:</span>
<span class="line-added">+     case CustomValueSetter:</span>
<span class="line-added">+     case CustomAccessorSetter:</span>
<span class="line-added">+     case IntrinsicGetter:</span>
<span class="line-added">+     case InHit:</span>
<span class="line-added">+     case InMiss:</span>
          if (other.type() != type())
              return false;
  
          if (m_polyProtoAccessChain) {
              if (!other.m_polyProtoAccessChain)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,29 ***</span>
              // this to check the base structure.
              return structure() == other.structure()
                  &amp;&amp; *m_polyProtoAccessChain == *other.m_polyProtoAccessChain;
          }
  
<span class="line-modified">!         if (!guardedByStructureCheck() || !other.guardedByStructureCheck())</span>
              return false;
  
          return structure() == other.structure();
      }
  }
  
  void AccessCase::dump(PrintStream&amp; out) const
  {
      out.print(&quot;\n&quot;, m_type, &quot;:(&quot;);
  
      CommaPrinter comma;
  
      out.print(comma, m_state);
  
      if (isValidOffset(m_offset))
          out.print(comma, &quot;offset = &quot;, m_offset);
<span class="line-removed">-     if (!m_conditionSet.isEmpty())</span>
<span class="line-removed">-         out.print(comma, &quot;conditions = &quot;, m_conditionSet);</span>
  
      if (m_polyProtoAccessChain) {
          out.print(comma, &quot;prototype access chain = &quot;);
          m_polyProtoAccessChain-&gt;dump(structure(), out);
      } else {
<span class="line-new-header">--- 637,29 ---</span>
              // this to check the base structure.
              return structure() == other.structure()
                  &amp;&amp; *m_polyProtoAccessChain == *other.m_polyProtoAccessChain;
          }
  
<span class="line-modified">!         if (!guardedByStructureCheckSkippingConstantIdentifierCheck() || !other.guardedByStructureCheckSkippingConstantIdentifierCheck())</span>
              return false;
  
          return structure() == other.structure();
      }
<span class="line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
  }
  
  void AccessCase::dump(PrintStream&amp; out) const
  {
      out.print(&quot;\n&quot;, m_type, &quot;:(&quot;);
  
      CommaPrinter comma;
  
      out.print(comma, m_state);
  
<span class="line-added">+     out.print(comma, &quot;ident = &#39;&quot;, m_identifier, &quot;&#39;&quot;);</span>
      if (isValidOffset(m_offset))
          out.print(comma, &quot;offset = &quot;, m_offset);
  
      if (m_polyProtoAccessChain) {
          out.print(comma, &quot;prototype access chain = &quot;);
          m_polyProtoAccessChain-&gt;dump(structure(), out);
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 313,60 ***</span>
              out.print(comma, &quot;structure = &quot;, pointerDump(structure()), &quot; -&gt; &quot;, pointerDump(newStructure()));
          else if (m_structure)
              out.print(comma, &quot;structure = &quot;, pointerDump(m_structure.get()));
      }
  
      dumpImpl(out, comma);
      out.print(&quot;)&quot;);
  }
  
  bool AccessCase::visitWeak(VM&amp; vm) const
  {
<span class="line-removed">-     if (m_structure &amp;&amp; !vm.heap.isMarked(m_structure.get()))</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     if (m_polyProtoAccessChain) {</span>
<span class="line-removed">-         for (Structure* structure : m_polyProtoAccessChain-&gt;chain()) {</span>
<span class="line-removed">-             if (!vm.heap.isMarked(structure))</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (!m_conditionSet.areStillLive(vm))</span>
<span class="line-removed">-         return false;</span>
      if (isAccessor()) {
          auto&amp; accessor = this-&gt;as&lt;GetterSetterAccessCase&gt;();
          if (accessor.callLinkInfo())
              accessor.callLinkInfo()-&gt;visitWeak(vm);
<span class="line-removed">-         if (accessor.customSlotBase() &amp;&amp; !vm.heap.isMarked(accessor.customSlotBase()))</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-     } else if (type() == IntrinsicGetter) {</span>
<span class="line-removed">-         auto&amp; intrinsic = this-&gt;as&lt;IntrinsicGetterAccessCase&gt;();</span>
<span class="line-removed">-         if (intrinsic.intrinsicFunction() &amp;&amp; !vm.heap.isMarked(intrinsic.intrinsicFunction()))</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-     } else if (type() == ModuleNamespaceLoad) {</span>
<span class="line-removed">-         auto&amp; accessCase = this-&gt;as&lt;ModuleNamespaceAccessCase&gt;();</span>
<span class="line-removed">-         if (accessCase.moduleNamespaceObject() &amp;&amp; !vm.heap.isMarked(accessCase.moduleNamespaceObject()))</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         if (accessCase.moduleEnvironment() &amp;&amp; !vm.heap.isMarked(accessCase.moduleEnvironment()))</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-     } else if (type() == InstanceOfHit || type() == InstanceOfMiss) {</span>
<span class="line-removed">-         if (as&lt;InstanceOfAccessCase&gt;().prototype() &amp;&amp; !vm.heap.isMarked(as&lt;InstanceOfAccessCase&gt;().prototype()))</span>
<span class="line-removed">-             return false;</span>
      }
  
<span class="line-modified">!     return true;</span>
  }
  
  bool AccessCase::propagateTransitions(SlotVisitor&amp; visitor) const
  {
      bool result = true;
  
      if (m_structure)
          result &amp;= m_structure-&gt;markIfCheap(visitor);
  
      if (m_polyProtoAccessChain) {
<span class="line-modified">!         for (Structure* structure : m_polyProtoAccessChain-&gt;chain())</span>
<span class="line-modified">!             result &amp;= structure-&gt;markIfCheap(visitor);</span>
      }
  
      switch (m_type) {
      case Transition:
          if (visitor.vm().heap.isMarked(m_structure-&gt;previousID()))
<span class="line-new-header">--- 667,42 ---</span>
              out.print(comma, &quot;structure = &quot;, pointerDump(structure()), &quot; -&gt; &quot;, pointerDump(newStructure()));
          else if (m_structure)
              out.print(comma, &quot;structure = &quot;, pointerDump(m_structure.get()));
      }
  
<span class="line-added">+     if (!m_conditionSet.isEmpty())</span>
<span class="line-added">+         out.print(comma, &quot;conditions = &quot;, m_conditionSet);</span>
<span class="line-added">+ </span>
      dumpImpl(out, comma);
      out.print(&quot;)&quot;);
  }
  
  bool AccessCase::visitWeak(VM&amp; vm) const
  {
      if (isAccessor()) {
          auto&amp; accessor = this-&gt;as&lt;GetterSetterAccessCase&gt;();
          if (accessor.callLinkInfo())
              accessor.callLinkInfo()-&gt;visitWeak(vm);
      }
  
<span class="line-modified">!     bool isValid = true;</span>
<span class="line-added">+     forEachDependentCell(vm, [&amp;](JSCell* cell) {</span>
<span class="line-added">+         isValid &amp;= vm.heap.isMarked(cell);</span>
<span class="line-added">+     });</span>
<span class="line-added">+     return isValid;</span>
  }
  
  bool AccessCase::propagateTransitions(SlotVisitor&amp; visitor) const
  {
      bool result = true;
  
      if (m_structure)
          result &amp;= m_structure-&gt;markIfCheap(visitor);
  
      if (m_polyProtoAccessChain) {
<span class="line-modified">!         for (StructureID structureID : m_polyProtoAccessChain-&gt;chain())</span>
<span class="line-modified">!             result &amp;= visitor.vm().getStructure(structureID)-&gt;markIfCheap(visitor);</span>
      }
  
      switch (m_type) {
      case Transition:
          if (visitor.vm().heap.isMarked(m_structure-&gt;previousID()))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 379,33 ***</span>
      }
  
      return result;
  }
  
  void AccessCase::generateWithGuard(
      AccessGenerationState&amp; state, CCallHelpers::JumpList&amp; fallThrough)
  {
      SuperSamplerScope superSamplerScope(false);
  
      RELEASE_ASSERT(m_state == Committed);
      m_state = Generated;
  
      CCallHelpers&amp; jit = *state.jit;
      StructureStubInfo&amp; stubInfo = *state.stubInfo;
      VM&amp; vm = state.m_vm;
      JSValueRegs valueRegs = state.valueRegs;
      GPRReg baseGPR = state.baseGPR;
<span class="line-removed">-     GPRReg thisGPR = state.thisGPR != InvalidGPRReg ? state.thisGPR : baseGPR;</span>
      GPRReg scratchGPR = state.scratchGPR;
  
<span class="line-modified">!     UNUSED_PARAM(vm);</span>
  
      auto emitDefaultGuard = [&amp;] () {
          if (m_polyProtoAccessChain) {
              GPRReg baseForAccessGPR = state.scratchGPR;
              jit.move(state.baseGPR, baseForAccessGPR);
<span class="line-modified">!             m_polyProtoAccessChain-&gt;forEach(structure(), [&amp;] (Structure* structure, bool atEnd) {</span>
                  fallThrough.append(
                      jit.branchStructure(
                          CCallHelpers::NotEqual,
                          CCallHelpers::Address(baseForAccessGPR, JSCell::structureIDOffset()),
                          structure));
<span class="line-new-header">--- 715,49 ---</span>
      }
  
      return result;
  }
  
<span class="line-added">+ void AccessCase::visitAggregate(SlotVisitor&amp; visitor) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_identifier.visitAggregate(visitor);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void AccessCase::generateWithGuard(
      AccessGenerationState&amp; state, CCallHelpers::JumpList&amp; fallThrough)
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="line-added">+     checkConsistency(*state.stubInfo);</span>
<span class="line-added">+ </span>
      RELEASE_ASSERT(m_state == Committed);
      m_state = Generated;
  
      CCallHelpers&amp; jit = *state.jit;
      StructureStubInfo&amp; stubInfo = *state.stubInfo;
      VM&amp; vm = state.m_vm;
      JSValueRegs valueRegs = state.valueRegs;
      GPRReg baseGPR = state.baseGPR;
      GPRReg scratchGPR = state.scratchGPR;
  
<span class="line-modified">!     if (requiresIdentifierNameMatch() &amp;&amp; !stubInfo.hasConstantIdentifier) {</span>
<span class="line-added">+         RELEASE_ASSERT(m_identifier);</span>
<span class="line-added">+         GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added">+         // non-rope string check done inside polymorphic access.</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (uid()-&gt;isSymbol())</span>
<span class="line-added">+             jit.loadPtr(MacroAssembler::Address(propertyGPR, Symbol::offsetOfSymbolImpl()), scratchGPR);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             jit.loadPtr(MacroAssembler::Address(propertyGPR, JSString::offsetOfValue()), scratchGPR);</span>
<span class="line-added">+         fallThrough.append(jit.branchPtr(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImmPtr(uid())));</span>
<span class="line-added">+     }</span>
  
      auto emitDefaultGuard = [&amp;] () {
          if (m_polyProtoAccessChain) {
              GPRReg baseForAccessGPR = state.scratchGPR;
              jit.move(state.baseGPR, baseForAccessGPR);
<span class="line-modified">!             m_polyProtoAccessChain-&gt;forEach(vm, structure(), [&amp;] (Structure* structure, bool atEnd) {</span>
                  fallThrough.append(
                      jit.branchStructure(
                          CCallHelpers::NotEqual,
                          CCallHelpers::Address(baseForAccessGPR, JSCell::structureIDOffset()),
                          structure));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 415,11 ***</span>
                          // Transitions must do this because they need to verify there isn&#39;t a setter in the chain.
                          // Miss/InMiss need to do this to ensure there isn&#39;t a new item at the end of the chain that
                          // has the property.
  #if USE(JSVALUE64)
                          jit.load64(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset)), baseForAccessGPR);
<span class="line-modified">!                         fallThrough.append(jit.branch64(CCallHelpers::NotEqual, baseForAccessGPR, CCallHelpers::TrustedImm64(ValueNull)));</span>
  #else
                          jit.load32(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), baseForAccessGPR);
                          fallThrough.append(jit.branchTestPtr(CCallHelpers::NonZero, baseForAccessGPR));
  #endif
                      }
<span class="line-new-header">--- 767,11 ---</span>
                          // Transitions must do this because they need to verify there isn&#39;t a setter in the chain.
                          // Miss/InMiss need to do this to ensure there isn&#39;t a new item at the end of the chain that
                          // has the property.
  #if USE(JSVALUE64)
                          jit.load64(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset)), baseForAccessGPR);
<span class="line-modified">!                         fallThrough.append(jit.branch64(CCallHelpers::NotEqual, baseForAccessGPR, CCallHelpers::TrustedImm64(JSValue::ValueNull)));</span>
  #else
                          jit.load32(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), baseForAccessGPR);
                          fallThrough.append(jit.branchTestPtr(CCallHelpers::NonZero, baseForAccessGPR));
  #endif
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,11 ***</span>
                          jit.move(CCallHelpers::TrustedImmPtr(asObject(prototype)), baseForAccessGPR);
                      } else {
                          RELEASE_ASSERT(structure-&gt;isObject()); // Primitives must have a stored prototype. We use prototypeForLookup for them.
  #if USE(JSVALUE64)
                          jit.load64(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset)), baseForAccessGPR);
<span class="line-modified">!                         fallThrough.append(jit.branch64(CCallHelpers::Equal, baseForAccessGPR, CCallHelpers::TrustedImm64(ValueNull)));</span>
  #else
                          jit.load32(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), baseForAccessGPR);
                          fallThrough.append(jit.branchTestPtr(CCallHelpers::Zero, baseForAccessGPR));
  #endif
                      }
<span class="line-new-header">--- 782,11 ---</span>
                          jit.move(CCallHelpers::TrustedImmPtr(asObject(prototype)), baseForAccessGPR);
                      } else {
                          RELEASE_ASSERT(structure-&gt;isObject()); // Primitives must have a stored prototype. We use prototypeForLookup for them.
  #if USE(JSVALUE64)
                          jit.load64(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset)), baseForAccessGPR);
<span class="line-modified">!                         fallThrough.append(jit.branch64(CCallHelpers::Equal, baseForAccessGPR, CCallHelpers::TrustedImm64(JSValue::ValueNull)));</span>
  #else
                          jit.load32(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), baseForAccessGPR);
                          fallThrough.append(jit.branchTestPtr(CCallHelpers::Zero, baseForAccessGPR));
  #endif
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 504,19 ***</span>
      case ScopedArgumentsLength: {
          ASSERT(!viaProxy());
          fallThrough.append(
              jit.branchIfNotType(baseGPR, ScopedArgumentsType));
  
<span class="line-removed">-         jit.loadPtr(</span>
<span class="line-removed">-             CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfStorage()),</span>
<span class="line-removed">-             scratchGPR);</span>
          fallThrough.append(
              jit.branchTest8(
                  CCallHelpers::NonZero,
<span class="line-modified">!                 CCallHelpers::Address(scratchGPR, ScopedArguments::offsetOfOverrodeThingsInStorage())));</span>
          jit.load32(
<span class="line-modified">!             CCallHelpers::Address(scratchGPR, ScopedArguments::offsetOfTotalLengthInStorage()),</span>
              valueRegs.payloadGPR());
          jit.boxInt32(valueRegs.payloadGPR(), valueRegs);
          state.succeed();
          return;
      }
<span class="line-new-header">--- 856,16 ---</span>
      case ScopedArgumentsLength: {
          ASSERT(!viaProxy());
          fallThrough.append(
              jit.branchIfNotType(baseGPR, ScopedArgumentsType));
  
          fallThrough.append(
              jit.branchTest8(
                  CCallHelpers::NonZero,
<span class="line-modified">!                 CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfOverrodeThings())));</span>
          jit.load32(
<span class="line-modified">!             CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfTotalLength()),</span>
              valueRegs.payloadGPR());
          jit.boxInt32(valueRegs.payloadGPR(), valueRegs);
          state.succeed();
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 524,35 ***</span>
      case ModuleNamespaceLoad: {
          this-&gt;as&lt;ModuleNamespaceAccessCase&gt;().emit(state, fallThrough);
          return;
      }
  
      case InstanceOfHit:
      case InstanceOfMiss:
          emitDefaultGuard();
  
          fallThrough.append(
              jit.branchPtr(
<span class="line-modified">!                 CCallHelpers::NotEqual, thisGPR,</span>
                  CCallHelpers::TrustedImmPtr(as&lt;InstanceOfAccessCase&gt;().prototype())));
          break;
  
      case InstanceOfGeneric: {
<span class="line-modified">!         // Legend: value = `base instanceof this`.</span>
  
          GPRReg valueGPR = valueRegs.payloadGPR();
  
<span class="line-modified">!         ScratchRegisterAllocator allocator(stubInfo.patch.usedRegisters);</span>
<span class="line-modified">!         allocator.lock(baseGPR);</span>
<span class="line-modified">!         allocator.lock(valueGPR);</span>
<span class="line-modified">!         allocator.lock(thisGPR);</span>
          allocator.lock(scratchGPR);
  
          GPRReg scratch2GPR = allocator.allocateScratchGPR();
  
          if (!state.stubInfo-&gt;prototypeIsKnownObject)
<span class="line-modified">!             state.failAndIgnore.append(jit.branchIfNotObject(thisGPR));</span>
  
          ScratchRegisterAllocator::PreservedState preservedState =
              allocator.preserveReusedRegistersByPushing(
                  jit,
                  ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);
<span class="line-new-header">--- 873,375 ---</span>
      case ModuleNamespaceLoad: {
          this-&gt;as&lt;ModuleNamespaceAccessCase&gt;().emit(state, fallThrough);
          return;
      }
  
<span class="line-added">+     case IndexedScopedArgumentsLoad: {</span>
<span class="line-added">+         // This code is written such that the result could alias with the base or the property.</span>
<span class="line-added">+         GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.load8(CCallHelpers::Address(baseGPR, JSCell::typeInfoTypeOffset()), scratchGPR);</span>
<span class="line-added">+         fallThrough.append(jit.branch32(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImm32(ScopedArgumentsType)));</span>
<span class="line-added">+ </span>
<span class="line-added">+         ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-added">+         allocator.lock(stubInfo.baseRegs());</span>
<span class="line-added">+         allocator.lock(valueRegs);</span>
<span class="line-added">+         allocator.lock(stubInfo.propertyRegs());</span>
<span class="line-added">+         allocator.lock(scratchGPR);</span>
<span class="line-added">+ </span>
<span class="line-added">+         GPRReg scratch2GPR = allocator.allocateScratchGPR();</span>
<span class="line-added">+         GPRReg scratch3GPR = allocator.allocateScratchGPR();</span>
<span class="line-added">+ </span>
<span class="line-added">+         ScratchRegisterAllocator::PreservedState preservedState = allocator.preserveReusedRegistersByPushing(</span>
<span class="line-added">+             jit, ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);</span>
<span class="line-added">+ </span>
<span class="line-added">+         CCallHelpers::JumpList failAndIgnore;</span>
<span class="line-added">+ </span>
<span class="line-added">+         failAndIgnore.append(jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfTotalLength())));</span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.loadPtr(CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfTable()), scratchGPR);</span>
<span class="line-added">+         jit.load32(CCallHelpers::Address(scratchGPR, ScopedArgumentsTable::offsetOfLength()), scratch2GPR);</span>
<span class="line-added">+         auto overflowCase = jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, scratch2GPR);</span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.loadPtr(CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfScope()), scratch2GPR);</span>
<span class="line-added">+         jit.loadPtr(CCallHelpers::Address(scratchGPR, ScopedArgumentsTable::offsetOfArguments()), scratchGPR);</span>
<span class="line-added">+         jit.zeroExtend32ToPtr(propertyGPR, scratch3GPR);</span>
<span class="line-added">+         jit.load32(CCallHelpers::BaseIndex(scratchGPR, scratch3GPR, CCallHelpers::TimesFour), scratchGPR);</span>
<span class="line-added">+         failAndIgnore.append(jit.branch32(CCallHelpers::Equal, scratchGPR, CCallHelpers::TrustedImm32(ScopeOffset::invalidOffset)));</span>
<span class="line-added">+         jit.loadValue(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesEight, JSLexicalEnvironment::offsetOfVariables()), valueRegs);</span>
<span class="line-added">+         auto done = jit.jump();</span>
<span class="line-added">+ </span>
<span class="line-added">+         overflowCase.link(&amp;jit);</span>
<span class="line-added">+         jit.sub32(propertyGPR, scratch2GPR);</span>
<span class="line-added">+         jit.neg32(scratch2GPR);</span>
<span class="line-added">+         jit.loadPtr(CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfStorage()), scratch3GPR);</span>
<span class="line-added">+ #if USE(JSVALUE64)</span>
<span class="line-added">+         jit.loadValue(CCallHelpers::BaseIndex(scratch3GPR, scratch2GPR, CCallHelpers::TimesEight), JSValueRegs(scratchGPR));</span>
<span class="line-added">+         failAndIgnore.append(jit.branchIfEmpty(scratchGPR));</span>
<span class="line-added">+         jit.move(scratchGPR, valueRegs.payloadGPR());</span>
<span class="line-added">+ #else</span>
<span class="line-added">+         jit.loadValue(CCallHelpers::BaseIndex(scratch3GPR, scratch2GPR, CCallHelpers::TimesEight), JSValueRegs(scratch2GPR, scratchGPR));</span>
<span class="line-added">+         failAndIgnore.append(jit.branchIfEmpty(scratch2GPR));</span>
<span class="line-added">+         jit.move(scratchGPR, valueRegs.payloadGPR());</span>
<span class="line-added">+         jit.move(scratch2GPR, valueRegs.tagGPR());</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+         done.link(&amp;jit);</span>
<span class="line-added">+ </span>
<span class="line-added">+         allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added">+         state.succeed();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (allocator.didReuseRegisters()) {</span>
<span class="line-added">+             failAndIgnore.link(&amp;jit);</span>
<span class="line-added">+             allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added">+             state.failAndIgnore.append(jit.jump());</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             state.failAndIgnore.append(failAndIgnore);</span>
<span class="line-added">+ </span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case IndexedDirectArgumentsLoad: {</span>
<span class="line-added">+         // This code is written such that the result could alias with the base or the property.</span>
<span class="line-added">+         GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added">+         jit.load8(CCallHelpers::Address(baseGPR, JSCell::typeInfoTypeOffset()), scratchGPR);</span>
<span class="line-added">+         fallThrough.append(jit.branch32(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImm32(DirectArgumentsType)));</span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.load32(CCallHelpers::Address(baseGPR, DirectArguments::offsetOfLength()), scratchGPR);</span>
<span class="line-added">+         state.failAndRepatch.append(jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, scratchGPR));</span>
<span class="line-added">+         state.failAndRepatch.append(jit.branchTestPtr(CCallHelpers::NonZero, CCallHelpers::Address(baseGPR, DirectArguments::offsetOfMappedArguments())));</span>
<span class="line-added">+         jit.zeroExtend32ToPtr(propertyGPR, scratchGPR);</span>
<span class="line-added">+         jit.loadValue(CCallHelpers::BaseIndex(baseGPR, scratchGPR, CCallHelpers::TimesEight, DirectArguments::storageOffset()), valueRegs);</span>
<span class="line-added">+         state.succeed();</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">+     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat64Load: {</span>
<span class="line-added">+         // This code is written such that the result could alias with the base or the property.</span>
<span class="line-added">+ </span>
<span class="line-added">+         TypedArrayType type = toTypedArrayType(m_type);</span>
<span class="line-added">+ </span>
<span class="line-added">+         GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.load8(CCallHelpers::Address(baseGPR, JSCell::typeInfoTypeOffset()), scratchGPR);</span>
<span class="line-added">+         fallThrough.append(jit.branch32(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImm32(typeForTypedArrayType(type))));</span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.load32(CCallHelpers::Address(baseGPR, JSArrayBufferView::offsetOfLength()), scratchGPR);</span>
<span class="line-added">+         state.failAndRepatch.append(jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, scratchGPR));</span>
<span class="line-added">+ </span>
<span class="line-added">+         ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-added">+         allocator.lock(stubInfo.baseRegs());</span>
<span class="line-added">+         allocator.lock(valueRegs);</span>
<span class="line-added">+         allocator.lock(stubInfo.propertyRegs());</span>
<span class="line-added">+         allocator.lock(scratchGPR);</span>
<span class="line-added">+         GPRReg scratch2GPR = allocator.allocateScratchGPR();</span>
<span class="line-added">+ </span>
<span class="line-added">+         ScratchRegisterAllocator::PreservedState preservedState = allocator.preserveReusedRegistersByPushing(</span>
<span class="line-added">+             jit, ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);</span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.loadPtr(CCallHelpers::Address(baseGPR, JSArrayBufferView::offsetOfVector()), scratch2GPR);</span>
<span class="line-added">+         jit.cageConditionally(Gigacage::Primitive, scratch2GPR, scratchGPR, scratchGPR);</span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.signExtend32ToPtr(propertyGPR, scratchGPR);</span>
<span class="line-added">+         if (isInt(type)) {</span>
<span class="line-added">+             switch (elementSize(type)) {</span>
<span class="line-added">+             case 1:</span>
<span class="line-added">+                 if (JSC::isSigned(type))</span>
<span class="line-added">+                     jit.load8SignedExtendTo32(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesOne), valueRegs.payloadGPR());</span>
<span class="line-added">+                 else</span>
<span class="line-added">+                     jit.load8(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesOne), valueRegs.payloadGPR());</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 2:</span>
<span class="line-added">+                 if (JSC::isSigned(type))</span>
<span class="line-added">+                     jit.load16SignedExtendTo32(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesTwo), valueRegs.payloadGPR());</span>
<span class="line-added">+                 else</span>
<span class="line-added">+                     jit.load16(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesTwo), valueRegs.payloadGPR());</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 4:</span>
<span class="line-added">+                 jit.load32(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesFour), valueRegs.payloadGPR());</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 CRASH();</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             CCallHelpers::Jump done;</span>
<span class="line-added">+             if (type == TypeUint32) {</span>
<span class="line-added">+                 RELEASE_ASSERT(state.scratchFPR != InvalidFPRReg);</span>
<span class="line-added">+                 auto canBeInt = jit.branch32(CCallHelpers::GreaterThanOrEqual, valueRegs.payloadGPR(), CCallHelpers::TrustedImm32(0));</span>
<span class="line-added">+ </span>
<span class="line-added">+                 jit.convertInt32ToDouble(valueRegs.payloadGPR(), state.scratchFPR);</span>
<span class="line-added">+                 jit.addDouble(CCallHelpers::AbsoluteAddress(&amp;CCallHelpers::twoToThe32), state.scratchFPR);</span>
<span class="line-added">+                 jit.boxDouble(state.scratchFPR, valueRegs);</span>
<span class="line-added">+                 done = jit.jump();</span>
<span class="line-added">+                 canBeInt.link(&amp;jit);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             jit.boxInt32(valueRegs.payloadGPR(), valueRegs);</span>
<span class="line-added">+             if (done.isSet())</span>
<span class="line-added">+                 done.link(&amp;jit);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             ASSERT(isFloat(type));</span>
<span class="line-added">+             RELEASE_ASSERT(state.scratchFPR != InvalidFPRReg);</span>
<span class="line-added">+             switch (elementSize(type)) {</span>
<span class="line-added">+             case 4:</span>
<span class="line-added">+                 jit.loadFloat(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesFour), state.scratchFPR);</span>
<span class="line-added">+                 jit.convertFloatToDouble(state.scratchFPR, state.scratchFPR);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 8: {</span>
<span class="line-added">+                 jit.loadDouble(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesEight), state.scratchFPR);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 CRASH();</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             jit.purifyNaN(state.scratchFPR);</span>
<span class="line-added">+             jit.boxDouble(state.scratchFPR, valueRegs);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added">+         state.succeed();</span>
<span class="line-added">+ </span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case IndexedStringLoad: {</span>
<span class="line-added">+         // This code is written such that the result could alias with the base or the property.</span>
<span class="line-added">+         GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added">+ </span>
<span class="line-added">+         fallThrough.append(jit.branchIfNotString(baseGPR));</span>
<span class="line-added">+ </span>
<span class="line-added">+         ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-added">+         allocator.lock(stubInfo.baseRegs());</span>
<span class="line-added">+         allocator.lock(valueRegs);</span>
<span class="line-added">+         allocator.lock(stubInfo.propertyRegs());</span>
<span class="line-added">+         allocator.lock(scratchGPR);</span>
<span class="line-added">+         GPRReg scratch2GPR = allocator.allocateScratchGPR();</span>
<span class="line-added">+ </span>
<span class="line-added">+         CCallHelpers::JumpList failAndIgnore;</span>
<span class="line-added">+ </span>
<span class="line-added">+         ScratchRegisterAllocator::PreservedState preservedState = allocator.preserveReusedRegistersByPushing(</span>
<span class="line-added">+             jit, ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);</span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.loadPtr(CCallHelpers::Address(baseGPR, JSString::offsetOfValue()), scratch2GPR);</span>
<span class="line-added">+         failAndIgnore.append(jit.branchIfRopeStringImpl(scratch2GPR));</span>
<span class="line-added">+         jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), scratchGPR);</span>
<span class="line-added">+ </span>
<span class="line-added">+         failAndIgnore.append(jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, scratchGPR));</span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);</span>
<span class="line-added">+         jit.loadPtr(CCallHelpers::Address(scratch2GPR, StringImpl::dataOffset()), scratch2GPR);</span>
<span class="line-added">+         auto is16Bit = jit.branchTest32(CCallHelpers::Zero, scratchGPR, CCallHelpers::TrustedImm32(StringImpl::flagIs8Bit()));</span>
<span class="line-added">+         jit.zeroExtend32ToPtr(propertyGPR, scratchGPR);</span>
<span class="line-added">+         jit.load8(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesOne, 0), scratch2GPR);</span>
<span class="line-added">+         auto is8BitLoadDone = jit.jump();</span>
<span class="line-added">+         is16Bit.link(&amp;jit);</span>
<span class="line-added">+         jit.zeroExtend32ToPtr(propertyGPR, scratchGPR);</span>
<span class="line-added">+         jit.load16(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesTwo, 0), scratch2GPR);</span>
<span class="line-added">+         is8BitLoadDone.link(&amp;jit);</span>
<span class="line-added">+ </span>
<span class="line-added">+         failAndIgnore.append(jit.branch32(CCallHelpers::Above, scratch2GPR, CCallHelpers::TrustedImm32(maxSingleCharacterString)));</span>
<span class="line-added">+         jit.move(CCallHelpers::TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), scratchGPR);</span>
<span class="line-added">+         jit.loadPtr(CCallHelpers::BaseIndex(scratchGPR, scratch2GPR, CCallHelpers::ScalePtr, 0), valueRegs.payloadGPR());</span>
<span class="line-added">+         jit.boxCell(valueRegs.payloadGPR(), valueRegs);</span>
<span class="line-added">+         allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added">+         state.succeed();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (allocator.didReuseRegisters()) {</span>
<span class="line-added">+             failAndIgnore.link(&amp;jit);</span>
<span class="line-added">+             allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added">+             state.failAndIgnore.append(jit.jump());</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             state.failAndIgnore.append(failAndIgnore);</span>
<span class="line-added">+ </span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case IndexedInt32Load:</span>
<span class="line-added">+     case IndexedDoubleLoad:</span>
<span class="line-added">+     case IndexedContiguousLoad:</span>
<span class="line-added">+     case IndexedArrayStorageLoad: {</span>
<span class="line-added">+         // This code is written such that the result could alias with the base or the property.</span>
<span class="line-added">+         GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // int32 check done in polymorphic access.</span>
<span class="line-added">+         jit.load8(CCallHelpers::Address(baseGPR, JSCell::indexingTypeAndMiscOffset()), scratchGPR);</span>
<span class="line-added">+         jit.and32(CCallHelpers::TrustedImm32(IndexingShapeMask), scratchGPR);</span>
<span class="line-added">+ </span>
<span class="line-added">+         CCallHelpers::Jump isOutOfBounds;</span>
<span class="line-added">+         CCallHelpers::Jump isEmpty;</span>
<span class="line-added">+ </span>
<span class="line-added">+         ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-added">+         allocator.lock(stubInfo.baseRegs());</span>
<span class="line-added">+         allocator.lock(valueRegs);</span>
<span class="line-added">+         allocator.lock(stubInfo.propertyRegs());</span>
<span class="line-added">+         allocator.lock(scratchGPR);</span>
<span class="line-added">+         GPRReg scratch2GPR = allocator.allocateScratchGPR();</span>
<span class="line-added">+ #if USE(JSVALUE32_64)</span>
<span class="line-added">+         GPRReg scratch3GPR = allocator.allocateScratchGPR();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         ScratchRegisterAllocator::PreservedState preservedState;</span>
<span class="line-added">+ </span>
<span class="line-added">+         CCallHelpers::JumpList failAndIgnore;</span>
<span class="line-added">+         auto preserveReusedRegisters = [&amp;] {</span>
<span class="line-added">+             preservedState = allocator.preserveReusedRegistersByPushing(jit, ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (m_type == IndexedArrayStorageLoad) {</span>
<span class="line-added">+             jit.add32(CCallHelpers::TrustedImm32(-ArrayStorageShape), scratchGPR, scratchGPR);</span>
<span class="line-added">+             fallThrough.append(jit.branch32(CCallHelpers::Above, scratchGPR, CCallHelpers::TrustedImm32(SlowPutArrayStorageShape - ArrayStorageShape)));</span>
<span class="line-added">+ </span>
<span class="line-added">+             preserveReusedRegisters();</span>
<span class="line-added">+ </span>
<span class="line-added">+             jit.loadPtr(CCallHelpers::Address(baseGPR, JSObject::butterflyOffset()), scratchGPR);</span>
<span class="line-added">+             isOutOfBounds = jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, CCallHelpers::Address(scratchGPR, ArrayStorage::vectorLengthOffset()));</span>
<span class="line-added">+ </span>
<span class="line-added">+             jit.zeroExtend32ToPtr(propertyGPR, scratch2GPR);</span>
<span class="line-added">+ #if USE(JSVALUE64)</span>
<span class="line-added">+             jit.loadValue(CCallHelpers::BaseIndex(scratchGPR, scratch2GPR, CCallHelpers::TimesEight, ArrayStorage::vectorOffset()), JSValueRegs(scratchGPR));</span>
<span class="line-added">+             isEmpty = jit.branchIfEmpty(scratchGPR);</span>
<span class="line-added">+             jit.move(scratchGPR, valueRegs.payloadGPR());</span>
<span class="line-added">+ #else</span>
<span class="line-added">+             jit.loadValue(CCallHelpers::BaseIndex(scratchGPR, scratch2GPR, CCallHelpers::TimesEight, ArrayStorage::vectorOffset()), JSValueRegs(scratch3GPR, scratchGPR));</span>
<span class="line-added">+             isEmpty = jit.branchIfEmpty(scratch3GPR);</span>
<span class="line-added">+             jit.move(scratchGPR, valueRegs.payloadGPR());</span>
<span class="line-added">+             jit.move(scratch3GPR, valueRegs.tagGPR());</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             IndexingType expectedShape;</span>
<span class="line-added">+             switch (m_type) {</span>
<span class="line-added">+             case IndexedInt32Load:</span>
<span class="line-added">+                 expectedShape = Int32Shape;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case IndexedDoubleLoad:</span>
<span class="line-added">+                 expectedShape = DoubleShape;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case IndexedContiguousLoad:</span>
<span class="line-added">+                 expectedShape = ContiguousShape;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             fallThrough.append(jit.branch32(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImm32(expectedShape)));</span>
<span class="line-added">+ </span>
<span class="line-added">+             preserveReusedRegisters();</span>
<span class="line-added">+ </span>
<span class="line-added">+             jit.loadPtr(CCallHelpers::Address(baseGPR, JSObject::butterflyOffset()), scratchGPR);</span>
<span class="line-added">+             isOutOfBounds = jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, CCallHelpers::Address(scratchGPR, Butterfly::offsetOfPublicLength()));</span>
<span class="line-added">+             jit.zeroExtend32ToPtr(propertyGPR, scratch2GPR);</span>
<span class="line-added">+             if (m_type == IndexedDoubleLoad) {</span>
<span class="line-added">+                 RELEASE_ASSERT(state.scratchFPR != InvalidFPRReg);</span>
<span class="line-added">+                 jit.loadDouble(CCallHelpers::BaseIndex(scratchGPR, scratch2GPR, CCallHelpers::TimesEight), state.scratchFPR);</span>
<span class="line-added">+                 isEmpty = jit.branchIfNaN(state.scratchFPR);</span>
<span class="line-added">+                 jit.boxDouble(state.scratchFPR, valueRegs);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+ #if USE(JSVALUE64)</span>
<span class="line-added">+                 jit.loadValue(CCallHelpers::BaseIndex(scratchGPR, scratch2GPR, CCallHelpers::TimesEight), JSValueRegs(scratchGPR));</span>
<span class="line-added">+                 isEmpty = jit.branchIfEmpty(scratchGPR);</span>
<span class="line-added">+                 jit.move(scratchGPR, valueRegs.payloadGPR());</span>
<span class="line-added">+ #else</span>
<span class="line-added">+                 jit.loadValue(CCallHelpers::BaseIndex(scratchGPR, scratch2GPR, CCallHelpers::TimesEight), JSValueRegs(scratch3GPR, scratchGPR));</span>
<span class="line-added">+                 isEmpty = jit.branchIfEmpty(scratch3GPR);</span>
<span class="line-added">+                 jit.move(scratchGPR, valueRegs.payloadGPR());</span>
<span class="line-added">+                 jit.move(scratch3GPR, valueRegs.tagGPR());</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added">+         state.succeed();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (allocator.didReuseRegisters()) {</span>
<span class="line-added">+             isOutOfBounds.link(&amp;jit);</span>
<span class="line-added">+             isEmpty.link(&amp;jit);</span>
<span class="line-added">+             allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added">+             state.failAndIgnore.append(jit.jump());</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             state.failAndIgnore.append(isOutOfBounds);</span>
<span class="line-added">+             state.failAndIgnore.append(isEmpty);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case InstanceOfHit:
      case InstanceOfMiss:
          emitDefaultGuard();
  
          fallThrough.append(
              jit.branchPtr(
<span class="line-modified">!                 CCallHelpers::NotEqual, state.u.prototypeGPR,</span>
                  CCallHelpers::TrustedImmPtr(as&lt;InstanceOfAccessCase&gt;().prototype())));
          break;
  
      case InstanceOfGeneric: {
<span class="line-modified">!         GPRReg prototypeGPR = state.u.prototypeGPR;</span>
<span class="line-added">+         // Legend: value = `base instanceof prototypeGPR`.</span>
  
          GPRReg valueGPR = valueRegs.payloadGPR();
  
<span class="line-modified">!         ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-modified">!         allocator.lock(stubInfo.baseRegs());</span>
<span class="line-modified">!         allocator.lock(valueRegs);</span>
<span class="line-modified">!         allocator.lock(stubInfo.propertyRegs());</span>
          allocator.lock(scratchGPR);
  
          GPRReg scratch2GPR = allocator.allocateScratchGPR();
  
          if (!state.stubInfo-&gt;prototypeIsKnownObject)
<span class="line-modified">!             state.failAndIgnore.append(jit.branchIfNotObject(prototypeGPR));</span>
  
          ScratchRegisterAllocator::PreservedState preservedState =
              allocator.preserveReusedRegistersByPushing(
                  jit,
                  ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 586,11 ***</span>
              scratch2GPR);
          hasMonoProto.link(&amp;jit);
  #endif
          jit.move(scratch2GPR, valueGPR);
  
<span class="line-modified">!         CCallHelpers::Jump isInstance = jit.branchPtr(CCallHelpers::Equal, valueGPR, thisGPR);</span>
  
  #if USE(JSVALUE64)
          jit.branchIfCell(JSValueRegs(valueGPR)).linkTo(loop, &amp;jit);
  #else
          jit.branchTestPtr(CCallHelpers::NonZero, valueGPR).linkTo(loop, &amp;jit);
<span class="line-new-header">--- 1275,11 ---</span>
              scratch2GPR);
          hasMonoProto.link(&amp;jit);
  #endif
          jit.move(scratch2GPR, valueGPR);
  
<span class="line-modified">!         CCallHelpers::Jump isInstance = jit.branchPtr(CCallHelpers::Equal, valueGPR, prototypeGPR);</span>
  
  #if USE(JSVALUE64)
          jit.branchIfCell(JSValueRegs(valueGPR)).linkTo(loop, &amp;jit);
  #else
          jit.branchTestPtr(CCallHelpers::NonZero, valueGPR).linkTo(loop, &amp;jit);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,12 ***</span>
<span class="line-new-header">--- 1312,15 ---</span>
  }
  
  void AccessCase::generate(AccessGenerationState&amp; state)
  {
      RELEASE_ASSERT(m_state == Committed);
<span class="line-added">+     RELEASE_ASSERT(state.stubInfo-&gt;hasConstantIdentifier);</span>
      m_state = Generated;
  
<span class="line-added">+     checkConsistency(*state.stubInfo);</span>
<span class="line-added">+ </span>
      generateImpl(state);
  }
  
  void AccessCase::generateImpl(AccessGenerationState&amp; state)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 640,38 ***</span>
  
      CCallHelpers&amp; jit = *state.jit;
      VM&amp; vm = state.m_vm;
      CodeBlock* codeBlock = jit.codeBlock();
      StructureStubInfo&amp; stubInfo = *state.stubInfo;
<span class="line-removed">-     const Identifier&amp; ident = *state.ident;</span>
      JSValueRegs valueRegs = state.valueRegs;
      GPRReg baseGPR = state.baseGPR;
<span class="line-modified">!     GPRReg thisGPR = state.thisGPR != InvalidGPRReg ? state.thisGPR : baseGPR;</span>
      GPRReg scratchGPR = state.scratchGPR;
  
<span class="line-removed">-     ASSERT(m_conditionSet.structuresEnsureValidityAssumingImpurePropertyWatchpoint());</span>
<span class="line-removed">- </span>
      for (const ObjectPropertyCondition&amp; condition : m_conditionSet) {
          RELEASE_ASSERT(!m_polyProtoAccessChain);
  
<span class="line-modified">!         Structure* structure = condition.object()-&gt;structure(vm);</span>
<span class="line-modified">! </span>
<span class="line-removed">-         if (condition.isWatchableAssumingImpurePropertyWatchpoint()) {</span>
<span class="line-removed">-             structure-&gt;addTransitionWatchpoint(state.addWatchpoint(condition));</span>
              continue;
          }
  
<span class="line-modified">!         if (!condition.structureEnsuresValidityAssumingImpurePropertyWatchpoint(structure)) {</span>
              // The reason why this cannot happen is that we require that PolymorphicAccess calls
              // AccessCase::generate() only after it has verified that
              // AccessCase::couldStillSucceed() returned true.
  
              dataLog(&quot;This condition is no longer met: &quot;, condition, &quot;\n&quot;);
              RELEASE_ASSERT_NOT_REACHED();
          }
  
          // We will emit code that has a weak reference that isn&#39;t otherwise listed anywhere.
          state.weakReferences.append(WriteBarrier&lt;JSCell&gt;(vm, codeBlock, structure));
  
          jit.move(CCallHelpers::TrustedImmPtr(condition.object()), scratchGPR);
          state.failAndRepatch.append(
              jit.branchStructure(
<span class="line-new-header">--- 1332,37 ---</span>
  
      CCallHelpers&amp; jit = *state.jit;
      VM&amp; vm = state.m_vm;
      CodeBlock* codeBlock = jit.codeBlock();
      StructureStubInfo&amp; stubInfo = *state.stubInfo;
      JSValueRegs valueRegs = state.valueRegs;
      GPRReg baseGPR = state.baseGPR;
<span class="line-modified">!     GPRReg thisGPR = stubInfo.thisValueIsInThisGPR() ? state.u.thisGPR : baseGPR;</span>
      GPRReg scratchGPR = state.scratchGPR;
  
      for (const ObjectPropertyCondition&amp; condition : m_conditionSet) {
          RELEASE_ASSERT(!m_polyProtoAccessChain);
  
<span class="line-modified">!         if (condition.isWatchableAssumingImpurePropertyWatchpoint(PropertyCondition::WatchabilityEffort::EnsureWatchability)) {</span>
<span class="line-modified">!             state.installWatchpoint(condition);</span>
              continue;
          }
  
<span class="line-modified">!         // For now, we only allow equivalence when it&#39;s watchable.</span>
<span class="line-added">+         RELEASE_ASSERT(condition.condition().kind() != PropertyCondition::Equivalence);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!condition.structureEnsuresValidityAssumingImpurePropertyWatchpoint()) {</span>
              // The reason why this cannot happen is that we require that PolymorphicAccess calls
              // AccessCase::generate() only after it has verified that
              // AccessCase::couldStillSucceed() returned true.
  
              dataLog(&quot;This condition is no longer met: &quot;, condition, &quot;\n&quot;);
              RELEASE_ASSERT_NOT_REACHED();
          }
  
          // We will emit code that has a weak reference that isn&#39;t otherwise listed anywhere.
<span class="line-added">+         Structure* structure = condition.object()-&gt;structure(vm);</span>
          state.weakReferences.append(WriteBarrier&lt;JSCell&gt;(vm, codeBlock, structure));
  
          jit.move(CCallHelpers::TrustedImmPtr(condition.object()), scratchGPR);
          state.failAndRepatch.append(
              jit.branchStructure(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 827,11 ***</span>
              state.restoreLiveRegistersFromStackForCall(spillState, dontRestore);
          };
  
          jit.store32(
              CCallHelpers::TrustedImm32(state.callSiteIndexForExceptionHandlingOrOriginal().bits()),
<span class="line-modified">!             CCallHelpers::tagFor(static_cast&lt;VirtualRegister&gt;(CallFrameSlot::argumentCount)));</span>
  
          if (m_type == Getter || m_type == Setter) {
              auto&amp; access = this-&gt;as&lt;GetterSetterAccessCase&gt;();
              ASSERT(baseGPR != loadedValueGPR);
              ASSERT(m_type != Setter || valueRegsPayloadGPR != loadedValueGPR);
<span class="line-new-header">--- 1518,11 ---</span>
              state.restoreLiveRegistersFromStackForCall(spillState, dontRestore);
          };
  
          jit.store32(
              CCallHelpers::TrustedImm32(state.callSiteIndexForExceptionHandlingOrOriginal().bits()),
<span class="line-modified">!             CCallHelpers::tagFor(CallFrameSlot::argumentCountIncludingThis));</span>
  
          if (m_type == Getter || m_type == Setter) {
              auto&amp; access = this-&gt;as&lt;GetterSetterAccessCase&gt;();
              ASSERT(baseGPR != loadedValueGPR);
              ASSERT(m_type != Setter || valueRegsPayloadGPR != loadedValueGPR);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 851,24 ***</span>
              // shrink it after.
  
              state.setSpillStateForJSGetterSetter(spillState);
  
              RELEASE_ASSERT(!access.callLinkInfo());
<span class="line-modified">!             access.m_callLinkInfo = makeUnique&lt;CallLinkInfo&gt;();</span>
  
              // FIXME: If we generated a polymorphic call stub that jumped back to the getter
              // stub, which then jumped back to the main code, then we&#39;d have a reachability
              // situation that the GC doesn&#39;t know about. The GC would ensure that the polymorphic
              // call stub stayed alive, and it would ensure that the main code stayed alive, but
              // it wouldn&#39;t know that the getter stub was alive. Ideally JIT stub routines would
              // be GC objects, and then we&#39;d be able to say that the polymorphic call stub has a
              // reference to the getter stub.
              // https://bugs.webkit.org/show_bug.cgi?id=148914
<span class="line-modified">!             access.callLinkInfo()-&gt;disallowStubs();</span>
  
<span class="line-modified">!             access.callLinkInfo()-&gt;setUpCall(</span>
<span class="line-removed">-                 CallLinkInfo::Call, stubInfo.codeOrigin, loadedValueGPR);</span>
  
              CCallHelpers::JumpList done;
  
              // There is a &quot;this&quot; argument.
              unsigned numberOfParameters = 1;
<span class="line-new-header">--- 1542,24 ---</span>
              // shrink it after.
  
              state.setSpillStateForJSGetterSetter(spillState);
  
              RELEASE_ASSERT(!access.callLinkInfo());
<span class="line-modified">!             CallLinkInfo* callLinkInfo = state.m_callLinkInfos.add();</span>
<span class="line-added">+             access.m_callLinkInfo = callLinkInfo;</span>
  
              // FIXME: If we generated a polymorphic call stub that jumped back to the getter
              // stub, which then jumped back to the main code, then we&#39;d have a reachability
              // situation that the GC doesn&#39;t know about. The GC would ensure that the polymorphic
              // call stub stayed alive, and it would ensure that the main code stayed alive, but
              // it wouldn&#39;t know that the getter stub was alive. Ideally JIT stub routines would
              // be GC objects, and then we&#39;d be able to say that the polymorphic call stub has a
              // reference to the getter stub.
              // https://bugs.webkit.org/show_bug.cgi?id=148914
<span class="line-modified">!             callLinkInfo-&gt;disallowStubs();</span>
  
<span class="line-modified">!             callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, stubInfo.codeOrigin, loadedValueGPR);</span>
  
              CCallHelpers::JumpList done;
  
              // There is a &quot;this&quot; argument.
              unsigned numberOfParameters = 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 888,11 ***</span>
              }
  
              CCallHelpers::Jump returnUndefined = jit.branchTestPtr(
                  CCallHelpers::Zero, loadedValueGPR);
  
<span class="line-modified">!             unsigned numberOfRegsForCall = CallFrame::headerSizeInRegisters + numberOfParameters;</span>
              unsigned numberOfBytesForCall = numberOfRegsForCall * sizeof(Register) - sizeof(CallerFrameAndPC);
  
              unsigned alignedNumberOfBytesForCall =
              WTF::roundUpToMultipleOf(stackAlignmentBytes(), numberOfBytesForCall);
  
<span class="line-new-header">--- 1579,12 ---</span>
              }
  
              CCallHelpers::Jump returnUndefined = jit.branchTestPtr(
                  CCallHelpers::Zero, loadedValueGPR);
  
<span class="line-modified">!             unsigned numberOfRegsForCall = CallFrame::headerSizeInRegisters + roundArgumentCountToAlignFrame(numberOfParameters);</span>
<span class="line-added">+             ASSERT(!(numberOfRegsForCall % stackAlignmentRegisters()));</span>
              unsigned numberOfBytesForCall = numberOfRegsForCall * sizeof(Register) - sizeof(CallerFrameAndPC);
  
              unsigned alignedNumberOfBytesForCall =
              WTF::roundUpToMultipleOf(stackAlignmentBytes(), numberOfBytesForCall);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 904,24 ***</span>
                  CCallHelpers::stackPointerRegister,
                  -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));
  
              jit.store32(
                  CCallHelpers::TrustedImm32(numberOfParameters),
<span class="line-modified">!                 calleeFrame.withOffset(CallFrameSlot::argumentCount * sizeof(Register) + PayloadOffset));</span>
  
              jit.storeCell(
                  loadedValueGPR, calleeFrame.withOffset(CallFrameSlot::callee * sizeof(Register)));
  
              jit.storeCell(
                  thisGPR,
<span class="line-modified">!                 calleeFrame.withOffset(virtualRegisterForArgument(0).offset() * sizeof(Register)));</span>
  
              if (m_type == Setter) {
                  jit.storeValue(
                      valueRegs,
                      calleeFrame.withOffset(
<span class="line-modified">!                         virtualRegisterForArgument(1).offset() * sizeof(Register)));</span>
              }
  
              CCallHelpers::Jump slowCase = jit.branchPtrWithPatch(
                  CCallHelpers::NotEqual, loadedValueGPR, addressOfLinkFunctionCheck,
                  CCallHelpers::TrustedImmPtr(nullptr));
<span class="line-new-header">--- 1596,24 ---</span>
                  CCallHelpers::stackPointerRegister,
                  -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));
  
              jit.store32(
                  CCallHelpers::TrustedImm32(numberOfParameters),
<span class="line-modified">!                 calleeFrame.withOffset(CallFrameSlot::argumentCountIncludingThis * sizeof(Register) + PayloadOffset));</span>
  
              jit.storeCell(
                  loadedValueGPR, calleeFrame.withOffset(CallFrameSlot::callee * sizeof(Register)));
  
              jit.storeCell(
                  thisGPR,
<span class="line-modified">!                 calleeFrame.withOffset(virtualRegisterForArgumentIncludingThis(0).offset() * sizeof(Register)));</span>
  
              if (m_type == Setter) {
                  jit.storeValue(
                      valueRegs,
                      calleeFrame.withOffset(
<span class="line-modified">!                         virtualRegisterForArgumentIncludingThis(1).offset() * sizeof(Register)));</span>
              }
  
              CCallHelpers::Jump slowCase = jit.branchPtrWithPatch(
                  CCallHelpers::NotEqual, loadedValueGPR, addressOfLinkFunctionCheck,
                  CCallHelpers::TrustedImmPtr(nullptr));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 929,17 ***</span>
<span class="line-new-header">--- 1621,20 ---</span>
              fastPathCall = jit.nearCall();
              if (m_type == Getter)
                  jit.setupResults(valueRegs);
              done.append(jit.jump());
  
<span class="line-added">+             // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added">+             // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
              slowCase.link(&amp;jit);
              jit.move(loadedValueGPR, GPRInfo::regT0);
  #if USE(JSVALUE32_64)
              // We *always* know that the getter/setter, if non-null, is a cell.
              jit.move(CCallHelpers::TrustedImm32(JSValue::CellTag), GPRInfo::regT1);
  #endif
              jit.move(CCallHelpers::TrustedImmPtr(access.callLinkInfo()), GPRInfo::regT2);
<span class="line-added">+             jit.move(CCallHelpers::TrustedImmPtr(state.m_globalObject), GPRInfo::regT3);</span>
              slowPathCall = jit.nearCall();
              if (m_type == Getter)
                  jit.setupResults(valueRegs);
              done.append(jit.jump());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 973,22 ***</span>
              jit.makeSpaceOnStackForCCall();
  
              // Check if it is a super access
              GPRReg baseForCustomGetGPR = baseGPR != thisGPR ? thisGPR : baseForGetGPR;
  
<span class="line-modified">!             // getter: EncodedJSValue (*GetValueFunc)(ExecState*, EncodedJSValue thisValue, PropertyName);</span>
<span class="line-modified">!             // setter: void (*PutValueFunc)(ExecState*, EncodedJSValue thisObject, EncodedJSValue value);</span>
              // Custom values are passed the slotBase (the property holder), custom accessors are passed the thisVaule (reciever).
              // FIXME: Remove this differences in custom values and custom accessors.
              // https://bugs.webkit.org/show_bug.cgi?id=158014
              GPRReg baseForCustom = m_type == CustomValueGetter || m_type == CustomValueSetter ? baseForAccessGPR : baseForCustomGetGPR;
              if (m_type == CustomValueGetter || m_type == CustomAccessorGetter) {
                  jit.setupArguments&lt;PropertySlot::GetValueFunc&gt;(
                      CCallHelpers::CellValue(baseForCustom),
<span class="line-modified">!                     CCallHelpers::TrustedImmPtr(ident.impl()));</span>
              } else {
                  jit.setupArguments&lt;PutPropertySlot::PutValueFunc&gt;(
                      CCallHelpers::CellValue(baseForCustom),
                      valueRegs);
              }
              jit.storePtr(GPRInfo::callFrameRegister, &amp;vm.topCallFrame);
  
<span class="line-new-header">--- 1668,27 ---</span>
              jit.makeSpaceOnStackForCCall();
  
              // Check if it is a super access
              GPRReg baseForCustomGetGPR = baseGPR != thisGPR ? thisGPR : baseForGetGPR;
  
<span class="line-modified">!             // getter: EncodedJSValue (*GetValueFunc)(JSGlobalObject*, EncodedJSValue thisValue, PropertyName);</span>
<span class="line-modified">!             // setter: void (*PutValueFunc)(JSGlobalObject*, EncodedJSValue thisObject, EncodedJSValue value);</span>
              // Custom values are passed the slotBase (the property holder), custom accessors are passed the thisVaule (reciever).
              // FIXME: Remove this differences in custom values and custom accessors.
              // https://bugs.webkit.org/show_bug.cgi?id=158014
              GPRReg baseForCustom = m_type == CustomValueGetter || m_type == CustomValueSetter ? baseForAccessGPR : baseForCustomGetGPR;
<span class="line-added">+             // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added">+             // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
              if (m_type == CustomValueGetter || m_type == CustomAccessorGetter) {
<span class="line-added">+                 RELEASE_ASSERT(m_identifier);</span>
                  jit.setupArguments&lt;PropertySlot::GetValueFunc&gt;(
<span class="line-added">+                     CCallHelpers::TrustedImmPtr(codeBlock-&gt;globalObject()),</span>
                      CCallHelpers::CellValue(baseForCustom),
<span class="line-modified">!                     CCallHelpers::TrustedImmPtr(uid()));</span>
              } else {
                  jit.setupArguments&lt;PutPropertySlot::PutValueFunc&gt;(
<span class="line-added">+                     CCallHelpers::TrustedImmPtr(codeBlock-&gt;globalObject()),</span>
                      CCallHelpers::CellValue(baseForCustom),
                      valueRegs);
              }
              jit.storePtr(GPRInfo::callFrameRegister, &amp;vm.topCallFrame);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1042,15 ***</span>
          // exactly when this would make calls.
          bool allocating = newStructure()-&gt;outOfLineCapacity() != structure()-&gt;outOfLineCapacity();
          bool reallocating = allocating &amp;&amp; structure()-&gt;outOfLineCapacity();
          bool allocatingInline = allocating &amp;&amp; !structure()-&gt;couldHaveIndexingHeader();
  
<span class="line-modified">!         ScratchRegisterAllocator allocator(stubInfo.patch.usedRegisters);</span>
<span class="line-modified">!         allocator.lock(baseGPR);</span>
<span class="line-removed">- #if USE(JSVALUE32_64)</span>
<span class="line-removed">-         allocator.lock(stubInfo.patch.baseTagGPR);</span>
<span class="line-removed">- #endif</span>
          allocator.lock(valueRegs);
          allocator.lock(scratchGPR);
  
          GPRReg scratchGPR2 = InvalidGPRReg;
          GPRReg scratchGPR3 = InvalidGPRReg;
<span class="line-new-header">--- 1742,12 ---</span>
          // exactly when this would make calls.
          bool allocating = newStructure()-&gt;outOfLineCapacity() != structure()-&gt;outOfLineCapacity();
          bool reallocating = allocating &amp;&amp; structure()-&gt;outOfLineCapacity();
          bool allocatingInline = allocating &amp;&amp; !structure()-&gt;couldHaveIndexingHeader();
  
<span class="line-modified">!         ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-modified">!         allocator.lock(stubInfo.baseRegs());</span>
          allocator.lock(valueRegs);
          allocator.lock(scratchGPR);
  
          GPRReg scratchGPR2 = InvalidGPRReg;
          GPRReg scratchGPR3 = InvalidGPRReg;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1111,28 ***</span>
                  AccessGenerationState::SpillState spillState = state.preserveLiveRegistersToStackForCall(extraRegistersToPreserve);
  
                  jit.store32(
                      CCallHelpers::TrustedImm32(
                          state.callSiteIndexForExceptionHandlingOrOriginal().bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(static_cast&lt;VirtualRegister&gt;(CallFrameSlot::argumentCount)));</span>
  
                  jit.makeSpaceOnStackForCCall();
  
                  if (!reallocating) {
<span class="line-modified">!                     jit.setupArguments&lt;decltype(operationReallocateButterflyToHavePropertyStorageWithInitialCapacity)&gt;(baseGPR);</span>
  
                      CCallHelpers::Call operationCall = jit.call(OperationPtrTag);
                      jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
                          linkBuffer.link(
                              operationCall,
                              FunctionPtr&lt;OperationPtrTag&gt;(operationReallocateButterflyToHavePropertyStorageWithInitialCapacity));
                      });
                  } else {
                      // Handle the case where we are reallocating (i.e. the old structure/butterfly
                      // already had out-of-line property storage).
<span class="line-modified">!                     jit.setupArguments&lt;decltype(operationReallocateButterflyToGrowPropertyStorage)&gt;(</span>
<span class="line-modified">!                         baseGPR, CCallHelpers::TrustedImm32(newSize / sizeof(JSValue)));</span>
  
                      CCallHelpers::Call operationCall = jit.call(OperationPtrTag);
                      jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
                          linkBuffer.link(
                              operationCall,
<span class="line-new-header">--- 1808,29 ---</span>
                  AccessGenerationState::SpillState spillState = state.preserveLiveRegistersToStackForCall(extraRegistersToPreserve);
  
                  jit.store32(
                      CCallHelpers::TrustedImm32(
                          state.callSiteIndexForExceptionHandlingOrOriginal().bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(CallFrameSlot::argumentCountIncludingThis));</span>
  
                  jit.makeSpaceOnStackForCCall();
  
                  if (!reallocating) {
<span class="line-modified">!                     jit.setupArguments&lt;decltype(operationReallocateButterflyToHavePropertyStorageWithInitialCapacity)&gt;(CCallHelpers::TrustedImmPtr(&amp;vm), baseGPR);</span>
<span class="line-added">+                     jit.prepareCallOperation(vm);</span>
  
                      CCallHelpers::Call operationCall = jit.call(OperationPtrTag);
                      jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
                          linkBuffer.link(
                              operationCall,
                              FunctionPtr&lt;OperationPtrTag&gt;(operationReallocateButterflyToHavePropertyStorageWithInitialCapacity));
                      });
                  } else {
                      // Handle the case where we are reallocating (i.e. the old structure/butterfly
                      // already had out-of-line property storage).
<span class="line-modified">!                     jit.setupArguments&lt;decltype(operationReallocateButterflyToGrowPropertyStorage)&gt;(CCallHelpers::TrustedImmPtr(&amp;vm), baseGPR, CCallHelpers::TrustedImm32(newSize / sizeof(JSValue)));</span>
<span class="line-modified">!                     jit.prepareCallOperation(vm);</span>
  
                      CCallHelpers::Call operationCall = jit.call(OperationPtrTag);
                      jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
                          linkBuffer.link(
                              operationCall,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1243,17 ***</span>
<span class="line-new-header">--- 1941,71 ---</span>
  
      case DirectArgumentsLength:
      case ScopedArgumentsLength:
      case ModuleNamespaceLoad:
      case InstanceOfGeneric:
<span class="line-added">+     case IndexedInt32Load:</span>
<span class="line-added">+     case IndexedDoubleLoad:</span>
<span class="line-added">+     case IndexedContiguousLoad:</span>
<span class="line-added">+     case IndexedArrayStorageLoad:</span>
<span class="line-added">+     case IndexedScopedArgumentsLoad:</span>
<span class="line-added">+     case IndexedDirectArgumentsLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">+     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">+     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">+     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">+     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">+     case IndexedStringLoad:</span>
          // These need to be handled by generateWithGuard(), since the guard is part of the
          // algorithm. We can be sure that nobody will call generate() directly for these since they
          // are not guarded by structure checks.
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-added">+ TypedArrayType AccessCase::toTypedArrayType(AccessType accessType)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (accessType) {</span>
<span class="line-added">+     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">+         return TypeInt8;</span>
<span class="line-added">+     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">+         return TypeUint8;</span>
<span class="line-added">+     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">+         return TypeUint8Clamped;</span>
<span class="line-added">+     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">+         return TypeInt16;</span>
<span class="line-added">+     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">+         return TypeUint16;</span>
<span class="line-added">+     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">+         return TypeInt32;</span>
<span class="line-added">+     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">+         return TypeUint32;</span>
<span class="line-added">+     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">+         return TypeFloat32;</span>
<span class="line-added">+     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">+         return TypeFloat64;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ASSERT_ENABLED</span>
<span class="line-added">+ void AccessCase::checkConsistency(StructureStubInfo&amp; stubInfo)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     RELEASE_ASSERT(!(requiresInt32PropertyCheck() &amp;&amp; requiresIdentifierNameMatch()));</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stubInfo.hasConstantIdentifier) {</span>
<span class="line-added">+         RELEASE_ASSERT(!requiresInt32PropertyCheck());</span>
<span class="line-added">+         RELEASE_ASSERT(requiresIdentifierNameMatch());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif // ASSERT_ENABLED</span>
<span class="line-added">+ </span>
  } // namespace JSC
  
  #endif
</pre>
<center><a href="../builtins/TypedArrayPrototype.js.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessCase.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
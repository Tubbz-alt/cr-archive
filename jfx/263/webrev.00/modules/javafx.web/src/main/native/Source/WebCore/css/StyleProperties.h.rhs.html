<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * (C) 1999-2003 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2004, 2005, 2006, 2008, 2012, 2013 Apple Inc. All rights reserved.
  4  * Copyright (C) 2013 Intel Corporation. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CSSParserContext.h&quot;
 25 #include &quot;CSSParserTokenRange.h&quot;
 26 #include &quot;CSSProperty.h&quot;
 27 #include &quot;CSSValueKeywords.h&quot;
 28 #include &lt;memory&gt;
 29 #include &lt;wtf/Function.h&gt;
 30 #include &lt;wtf/TypeCasts.h&gt;
 31 #include &lt;wtf/Vector.h&gt;
 32 #include &lt;wtf/text/WTFString.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 class CSSDeferredParser;
 37 class CSSStyleDeclaration;
 38 class CachedResource;
 39 class Color;
 40 class ImmutableStyleProperties;
 41 class MutableStyleProperties;
 42 class PropertySetCSSStyleDeclaration;
 43 class StyledElement;
 44 class StylePropertyShorthand;
 45 class StyleSheetContents;
 46 
 47 enum StylePropertiesType { ImmutablePropertiesType, MutablePropertiesType, DeferredPropertiesType };
 48 
 49 class StylePropertiesBase : public RefCounted&lt;StylePropertiesBase&gt; {
 50 public:
 51     // Override RefCounted&#39;s deref() to ensure operator delete is called on
 52     // the appropriate subclass type.
<a name="1" id="anc1"></a><span class="line-modified"> 53     void deref() const;</span>
 54 
 55     StylePropertiesType type() const { return static_cast&lt;StylePropertiesType&gt;(m_type); }
 56 
 57     CSSParserMode cssParserMode() const { return static_cast&lt;CSSParserMode&gt;(m_cssParserMode); }
 58 
 59 protected:
 60     StylePropertiesBase(CSSParserMode cssParserMode, StylePropertiesType type)
 61         : m_cssParserMode(cssParserMode)
 62         , m_type(type)
 63         , m_arraySize(0)
 64     { }
 65 
 66     StylePropertiesBase(CSSParserMode cssParserMode, unsigned immutableArraySize)
 67         : m_cssParserMode(cssParserMode)
 68         , m_type(ImmutablePropertiesType)
 69         , m_arraySize(immutableArraySize)
 70     { }
 71 
 72     unsigned m_cssParserMode : 3;
 73     mutable unsigned m_type : 2;
 74     unsigned m_arraySize : 27;
 75 };
 76 
<a name="2" id="anc2"></a><span class="line-added"> 77 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleProperties);</span>
 78 class StyleProperties : public StylePropertiesBase {
<a name="3" id="anc3"></a><span class="line-added"> 79     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(StyleProperties);</span>
 80     friend class PropertyReference;
 81 public:
 82     class PropertyReference {
 83     public:
 84         PropertyReference(const StylePropertyMetadata&amp; metadata, const CSSValue* value)
 85             : m_metadata(metadata)
 86             , m_value(value)
 87         { }
 88 
 89         CSSPropertyID id() const { return static_cast&lt;CSSPropertyID&gt;(m_metadata.m_propertyID); }
 90         CSSPropertyID shorthandID() const { return m_metadata.shorthandID(); }
 91 
 92         bool isImportant() const { return m_metadata.m_important; }
 93         bool isInherited() const { return m_metadata.m_inherited; }
 94         bool isImplicit() const { return m_metadata.m_implicit; }
 95 
 96         String cssName() const;
 97         String cssText() const;
 98 
 99         const CSSValue* value() const { return m_value; }
100         // FIXME: We should try to remove this mutable overload.
101         CSSValue* value() { return const_cast&lt;CSSValue*&gt;(m_value); }
102 
103         // FIXME: Remove this.
104         CSSProperty toCSSProperty() const { return CSSProperty(id(), const_cast&lt;CSSValue*&gt;(m_value), isImportant(), m_metadata.m_isSetFromShorthand, m_metadata.m_indexInShorthandsVector, isImplicit()); }
105 
106     private:
107         const StylePropertyMetadata&amp; m_metadata;
108         const CSSValue* m_value;
109     };
110 
111     unsigned propertyCount() const;
112     bool isEmpty() const { return !propertyCount(); }
113     PropertyReference propertyAt(unsigned) const;
114 
115     WEBCORE_EXPORT RefPtr&lt;CSSValue&gt; getPropertyCSSValue(CSSPropertyID) const;
116     WEBCORE_EXPORT String getPropertyValue(CSSPropertyID) const;
117 
118     WEBCORE_EXPORT Optional&lt;Color&gt; propertyAsColor(CSSPropertyID) const;
119     WEBCORE_EXPORT CSSValueID propertyAsValueID(CSSPropertyID) const;
120 
121     bool propertyIsImportant(CSSPropertyID) const;
122     String getPropertyShorthand(CSSPropertyID) const;
123     bool isPropertyImplicit(CSSPropertyID) const;
124 
125     RefPtr&lt;CSSValue&gt; getCustomPropertyCSSValue(const String&amp; propertyName) const;
126     String getCustomPropertyValue(const String&amp; propertyName) const;
127     bool customPropertyIsImportant(const String&amp; propertyName) const;
128 
129     Ref&lt;MutableStyleProperties&gt; copyBlockProperties() const;
130 
131     WEBCORE_EXPORT Ref&lt;MutableStyleProperties&gt; mutableCopy() const;
132     Ref&lt;ImmutableStyleProperties&gt; immutableCopyIfNeeded() const;
133 
134     Ref&lt;MutableStyleProperties&gt; copyPropertiesInSet(const CSSPropertyID* set, unsigned length) const;
135 
136     String asText() const;
137 
138     bool hasCSSOMWrapper() const;
139     bool isMutable() const { return type() == MutablePropertiesType; }
140 
141     bool traverseSubresources(const WTF::Function&lt;bool (const CachedResource&amp;)&gt;&amp; handler) const;
142 
143     static unsigned averageSizeInBytes();
144 
145 #ifndef NDEBUG
146     void showStyle();
147 #endif
148 
149     bool propertyMatches(CSSPropertyID, const CSSValue*) const;
150 
151 protected:
152     StyleProperties(CSSParserMode cssParserMode, StylePropertiesType type)
153         : StylePropertiesBase(cssParserMode, type)
154     { }
155 
156     StyleProperties(CSSParserMode cssParserMode, unsigned immutableArraySize)
157         : StylePropertiesBase(cssParserMode, immutableArraySize)
158     { }
159 
160     int findPropertyIndex(CSSPropertyID) const;
161     int findCustomPropertyIndex(const String&amp; propertyName) const;
162 
163 private:
<a name="4" id="anc4"></a><span class="line-modified">164     String getGridShorthandValue(const StylePropertyShorthand&amp;) const;</span>
<span class="line-added">165     String getShorthandValue(const StylePropertyShorthand&amp;, const char* separator = &quot; &quot;) const;</span>
166     String getCommonValue(const StylePropertyShorthand&amp;) const;
167     String getAlignmentShorthandValue(const StylePropertyShorthand&amp;) const;
168     String borderPropertyValue(const StylePropertyShorthand&amp;, const StylePropertyShorthand&amp;, const StylePropertyShorthand&amp;) const;
169     String pageBreakPropertyValue(const StylePropertyShorthand&amp;) const;
170     String getLayeredShorthandValue(const StylePropertyShorthand&amp;) const;
171     String get2Values(const StylePropertyShorthand&amp;) const;
172     String get4Values(const StylePropertyShorthand&amp;) const;
173     String borderSpacingValue(const StylePropertyShorthand&amp;) const;
174     String fontValue() const;
175     void appendFontLonghandValueIfExplicit(CSSPropertyID, StringBuilder&amp; result, String&amp; value) const;
176 
177     RefPtr&lt;CSSValue&gt; getPropertyCSSValueInternal(CSSPropertyID) const;
178 
179     friend class PropertySetCSSStyleDeclaration;
180 };
181 
<a name="5" id="anc5"></a><span class="line-added">182 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ImmutableStyleProperties);</span>
183 class ImmutableStyleProperties final : public StyleProperties {
<a name="6" id="anc6"></a><span class="line-added">184     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(ImmutableStyleProperties);</span>
185 public:
186     WEBCORE_EXPORT ~ImmutableStyleProperties();
187     static Ref&lt;ImmutableStyleProperties&gt; create(const CSSProperty* properties, unsigned count, CSSParserMode);
188 
189     unsigned propertyCount() const { return m_arraySize; }
190     bool isEmpty() const { return !propertyCount(); }
191     PropertyReference propertyAt(unsigned index) const;
192 
<a name="7" id="anc7"></a>

193     int findPropertyIndex(CSSPropertyID) const;
194     int findCustomPropertyIndex(const String&amp; propertyName) const;
195 
196     void* m_storage;
197 
198 private:
<a name="8" id="anc8"></a><span class="line-added">199     PackedPtr&lt;const CSSValue&gt;* valueArray() const;</span>
<span class="line-added">200     const StylePropertyMetadata* metadataArray() const;</span>
201     ImmutableStyleProperties(const CSSProperty*, unsigned count, CSSParserMode);
202 };
203 
<a name="9" id="anc9"></a><span class="line-modified">204 inline PackedPtr&lt;const CSSValue&gt;* ImmutableStyleProperties::valueArray() const</span>
205 {
<a name="10" id="anc10"></a><span class="line-modified">206     return bitwise_cast&lt;PackedPtr&lt;const CSSValue&gt;*&gt;(bitwise_cast&lt;const uint8_t*&gt;(metadataArray()) + (m_arraySize * sizeof(StylePropertyMetadata)));</span>
207 }
208 
209 inline const StylePropertyMetadata* ImmutableStyleProperties::metadataArray() const
210 {
<a name="11" id="anc11"></a><span class="line-modified">211     return reinterpret_cast&lt;const StylePropertyMetadata*&gt;(const_cast&lt;const void**&gt;((&amp;(this-&gt;m_storage))));</span>
212 }
213 
<a name="12" id="anc12"></a><span class="line-added">214 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MutableStyleProperties);</span>
215 class MutableStyleProperties final : public StyleProperties {
<a name="13" id="anc13"></a><span class="line-added">216     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(MutableStyleProperties);</span>
217 public:
218     WEBCORE_EXPORT static Ref&lt;MutableStyleProperties&gt; create(CSSParserMode = HTMLQuirksMode);
<a name="14" id="anc14"></a><span class="line-modified">219     static Ref&lt;MutableStyleProperties&gt; create(Vector&lt;CSSProperty&gt;&amp;&amp;);</span>
220 
221     WEBCORE_EXPORT ~MutableStyleProperties();
222 
223     unsigned propertyCount() const { return m_propertyVector.size(); }
224     bool isEmpty() const { return !propertyCount(); }
225     PropertyReference propertyAt(unsigned index) const;
226 
227     PropertySetCSSStyleDeclaration* cssStyleDeclaration();
228 
229     bool addParsedProperties(const ParsedPropertyVector&amp;);
230     bool addParsedProperty(const CSSProperty&amp;);
231 
232     // These expand shorthand properties into multiple properties.
233     bool setProperty(CSSPropertyID, const String&amp; value, bool important, CSSParserContext);
234     bool setProperty(CSSPropertyID, const String&amp; value, bool important = false);
235     void setProperty(CSSPropertyID, RefPtr&lt;CSSValue&gt;&amp;&amp;, bool important = false);
236 
237     // These do not. FIXME: This is too messy, we can do better.
238     bool setProperty(CSSPropertyID, CSSValueID identifier, bool important = false);
239     bool setProperty(CSSPropertyID, CSSPropertyID identifier, bool important = false);
240     bool setProperty(const CSSProperty&amp;, CSSProperty* slot = nullptr);
241 
242     bool removeProperty(CSSPropertyID, String* returnText = nullptr);
243     void removeBlockProperties();
244     bool removePropertiesInSet(const CSSPropertyID* set, unsigned length);
245 
246     void mergeAndOverrideOnConflict(const StyleProperties&amp;);
247 
248     void clear();
249     bool parseDeclaration(const String&amp; styleDeclaration, CSSParserContext);
250 
251     WEBCORE_EXPORT CSSStyleDeclaration&amp; ensureCSSStyleDeclaration();
252     CSSStyleDeclaration&amp; ensureInlineCSSStyleDeclaration(StyledElement&amp; parentElement);
253 
254     int findPropertyIndex(CSSPropertyID) const;
255     int findCustomPropertyIndex(const String&amp; propertyName) const;
256 
257     Vector&lt;CSSProperty, 4&gt; m_propertyVector;
258 
259     // Methods for querying and altering CSS custom properties.
260     bool setCustomProperty(const Document*, const String&amp; propertyName, const String&amp; value, bool important, CSSParserContext);
261     bool removeCustomProperty(const String&amp; propertyName, String* returnText = nullptr);
262 
263 private:
264     explicit MutableStyleProperties(CSSParserMode);
265     explicit MutableStyleProperties(const StyleProperties&amp;);
<a name="15" id="anc15"></a><span class="line-modified">266     MutableStyleProperties(Vector&lt;CSSProperty&gt;&amp;&amp;);</span>
267 
268     bool removeShorthandProperty(CSSPropertyID);
269     CSSProperty* findCSSPropertyWithID(CSSPropertyID);
270     CSSProperty* findCustomCSSPropertyWithName(const String&amp;);
271     std::unique_ptr&lt;PropertySetCSSStyleDeclaration&gt; m_cssomWrapper;
272 
273     friend class StyleProperties;
274 };
275 
276 class DeferredStyleProperties final : public StylePropertiesBase {
277 public:
278     WEBCORE_EXPORT ~DeferredStyleProperties();
279     static Ref&lt;DeferredStyleProperties&gt; create(const CSSParserTokenRange&amp;, CSSDeferredParser&amp;);
280 
281     Ref&lt;ImmutableStyleProperties&gt; parseDeferredProperties();
282 
283 private:
284     DeferredStyleProperties(const CSSParserTokenRange&amp;, CSSDeferredParser&amp;);
285 
286     Vector&lt;CSSParserToken&gt; m_tokens;
287     Ref&lt;CSSDeferredParser&gt; m_parser;
288 };
289 
290 inline ImmutableStyleProperties::PropertyReference ImmutableStyleProperties::propertyAt(unsigned index) const
291 {
<a name="16" id="anc16"></a><span class="line-modified">292     return PropertyReference(metadataArray()[index], valueArray()[index].get());</span>
293 }
294 
295 inline MutableStyleProperties::PropertyReference MutableStyleProperties::propertyAt(unsigned index) const
296 {
297     const CSSProperty&amp; property = m_propertyVector[index];
298     return PropertyReference(property.metadata(), property.value());
299 }
300 
301 inline StyleProperties::PropertyReference StyleProperties::propertyAt(unsigned index) const
302 {
303     if (is&lt;MutableStyleProperties&gt;(*this))
304         return downcast&lt;MutableStyleProperties&gt;(*this).propertyAt(index);
305     return downcast&lt;ImmutableStyleProperties&gt;(*this).propertyAt(index);
306 }
307 
308 inline unsigned StyleProperties::propertyCount() const
309 {
310     if (is&lt;MutableStyleProperties&gt;(*this))
311         return downcast&lt;MutableStyleProperties&gt;(*this).propertyCount();
312     return downcast&lt;ImmutableStyleProperties&gt;(*this).propertyCount();
313 }
314 
<a name="17" id="anc17"></a><span class="line-modified">315 inline void StylePropertiesBase::deref() const</span>
316 {
317     if (!derefBase())
318         return;
319 
320     if (is&lt;MutableStyleProperties&gt;(*this))
321         delete downcast&lt;MutableStyleProperties&gt;(this);
322     else if (is&lt;ImmutableStyleProperties&gt;(*this))
323         delete downcast&lt;ImmutableStyleProperties&gt;(this);
324     else
325         delete downcast&lt;DeferredStyleProperties&gt;(this);
326 }
327 
328 inline int StyleProperties::findPropertyIndex(CSSPropertyID propertyID) const
329 {
330     if (is&lt;MutableStyleProperties&gt;(*this))
331         return downcast&lt;MutableStyleProperties&gt;(*this).findPropertyIndex(propertyID);
332     return downcast&lt;ImmutableStyleProperties&gt;(*this).findPropertyIndex(propertyID);
333 }
334 
335 inline int StyleProperties::findCustomPropertyIndex(const String&amp; propertyName) const
336 {
337     if (is&lt;MutableStyleProperties&gt;(*this))
338         return downcast&lt;MutableStyleProperties&gt;(*this).findCustomPropertyIndex(propertyName);
339     return downcast&lt;ImmutableStyleProperties&gt;(*this).findCustomPropertyIndex(propertyName);
340 }
341 
342 } // namespace WebCore
343 
344 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::StyleProperties)
345     static bool isType(const WebCore::StylePropertiesBase&amp; set) { return set.type() != WebCore::DeferredPropertiesType; }
346 SPECIALIZE_TYPE_TRAITS_END()
347 
348 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::MutableStyleProperties)
349     static bool isType(const WebCore::StylePropertiesBase&amp; set) { return set.type() == WebCore::MutablePropertiesType; }
350 SPECIALIZE_TYPE_TRAITS_END()
351 
352 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ImmutableStyleProperties)
353     static bool isType(const WebCore::StylePropertiesBase&amp; set) { return set.type() == WebCore::ImmutablePropertiesType; }
354 SPECIALIZE_TYPE_TRAITS_END()
355 
356 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::DeferredStyleProperties)
357     static bool isType(const WebCore::StylePropertiesBase&amp; set) { return set.type() == WebCore::DeferredPropertiesType; }
358 SPECIALIZE_TYPE_TRAITS_END()
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
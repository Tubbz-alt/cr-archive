<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityNodeObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 61,21 ***</span>
  #include &quot;MathMLNames.h&quot;
  #include &quot;NodeList.h&quot;
  #include &quot;NodeTraversal.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;RenderImage.h&quot;
  #include &quot;RenderLayer.h&quot;
  #include &quot;RenderListItem.h&quot;
  #include &quot;RenderListMarker.h&quot;
  #include &quot;RenderMenuList.h&quot;
  #include &quot;RenderText.h&quot;
  #include &quot;RenderTextControl.h&quot;
  #include &quot;RenderTheme.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;RenderWidget.h&quot;
  #include &quot;RenderedPosition.h&quot;
<span class="line-removed">- #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  #include &quot;Settings.h&quot;
  #include &quot;TextCheckerClient.h&quot;
  #include &quot;TextCheckingHelper.h&quot;
  #include &quot;TextIterator.h&quot;
  #include &quot;UserGestureIndicator.h&quot;
<span class="line-new-header">--- 61,21 ---</span>
  #include &quot;MathMLNames.h&quot;
  #include &quot;NodeList.h&quot;
  #include &quot;NodeTraversal.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;RenderImage.h&quot;
<span class="line-added">+ #include &quot;RenderInline.h&quot;</span>
  #include &quot;RenderLayer.h&quot;
  #include &quot;RenderListItem.h&quot;
  #include &quot;RenderListMarker.h&quot;
  #include &quot;RenderMenuList.h&quot;
  #include &quot;RenderText.h&quot;
  #include &quot;RenderTextControl.h&quot;
  #include &quot;RenderTheme.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;RenderWidget.h&quot;
  #include &quot;RenderedPosition.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;TextCheckerClient.h&quot;
  #include &quot;TextCheckingHelper.h&quot;
  #include &quot;TextIterator.h&quot;
  #include &quot;UserGestureIndicator.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,23 ***</span>
  AccessibilityObject::~AccessibilityObject()
  {
      ASSERT(isDetached());
  }
  
<span class="line-modified">! void AccessibilityObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)</span>
  {
      // Menu close events need to notify the platform. No element is used in the notification because it&#39;s a destruction event.
<span class="line-modified">!     if (detachmentType == AccessibilityDetachmentType::ElementDestroyed &amp;&amp; roleValue() == AccessibilityRole::Menu &amp;&amp; cache)</span>
<span class="line-modified">!         cache-&gt;postNotification(nullptr, &amp;cache-&gt;document(), AXObjectCache::AXMenuClosed);</span>
  
      // Clear any children and call detachFromParent on them so that
      // no children are left with dangling pointers to their parent.
      clearChildren();
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(ACCESSIBILITY)</span>
<span class="line-removed">-     setWrapper(nullptr);</span>
<span class="line-removed">- #endif</span>
  }
  
  bool AccessibilityObject::isDetached() const
  {
  #if ENABLE(ACCESSIBILITY)
<span class="line-new-header">--- 94,21 ---</span>
  AccessibilityObject::~AccessibilityObject()
  {
      ASSERT(isDetached());
  }
  
<span class="line-modified">! void AccessibilityObject::detachRemoteParts(AccessibilityDetachmentType detachmentType)</span>
  {
      // Menu close events need to notify the platform. No element is used in the notification because it&#39;s a destruction event.
<span class="line-modified">!     if (detachmentType == AccessibilityDetachmentType::ElementDestroyed &amp;&amp; roleValue() == AccessibilityRole::Menu) {</span>
<span class="line-modified">!         if (auto* cache = axObjectCache())</span>
<span class="line-added">+             cache-&gt;postNotification(nullptr, &amp;cache-&gt;document(), AXObjectCache::AXMenuClosed);</span>
<span class="line-added">+     }</span>
  
      // Clear any children and call detachFromParent on them so that
      // no children are left with dangling pointers to their parent.
      clearChildren();
  }
  
  bool AccessibilityObject::isDetached() const
  {
  #if ENABLE(ACCESSIBILITY)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,193 ***</span>
  #else
      return true;
  #endif
  }
  
<span class="line-removed">- bool AccessibilityObject::isAccessibilityObjectSearchMatchAtIndex(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria, size_t index)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     switch (criteria-&gt;searchKeys[index]) {</span>
<span class="line-removed">-     // The AccessibilitySearchKey::AnyType matches any non-null AccessibilityObject.</span>
<span class="line-removed">-     case AccessibilitySearchKey::AnyType:</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Article:</span>
<span class="line-removed">-         return axObject-&gt;roleValue() == AccessibilityRole::DocumentArticle;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::BlockquoteSameLevel:</span>
<span class="line-removed">-         return criteria-&gt;startObject</span>
<span class="line-removed">-             &amp;&amp; axObject-&gt;isBlockquote()</span>
<span class="line-removed">-             &amp;&amp; axObject-&gt;blockquoteLevel() == criteria-&gt;startObject-&gt;blockquoteLevel();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Blockquote:</span>
<span class="line-removed">-         return axObject-&gt;isBlockquote();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::BoldFont:</span>
<span class="line-removed">-         return axObject-&gt;hasBoldFont();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Button:</span>
<span class="line-removed">-         return axObject-&gt;isButton();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::CheckBox:</span>
<span class="line-removed">-         return axObject-&gt;isCheckbox();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Control:</span>
<span class="line-removed">-         return axObject-&gt;isControl();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::DifferentType:</span>
<span class="line-removed">-         return criteria-&gt;startObject</span>
<span class="line-removed">-             &amp;&amp; axObject-&gt;roleValue() != criteria-&gt;startObject-&gt;roleValue();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::FontChange:</span>
<span class="line-removed">-         return criteria-&gt;startObject</span>
<span class="line-removed">-             &amp;&amp; !axObject-&gt;hasSameFont(criteria-&gt;startObject-&gt;renderer());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::FontColorChange:</span>
<span class="line-removed">-         return criteria-&gt;startObject</span>
<span class="line-removed">-             &amp;&amp; !axObject-&gt;hasSameFontColor(criteria-&gt;startObject-&gt;renderer());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Frame:</span>
<span class="line-removed">-         return axObject-&gt;isWebArea();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Graphic:</span>
<span class="line-removed">-         return axObject-&gt;isImage();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::HeadingLevel1:</span>
<span class="line-removed">-         return axObject-&gt;headingLevel() == 1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::HeadingLevel2:</span>
<span class="line-removed">-         return axObject-&gt;headingLevel() == 2;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::HeadingLevel3:</span>
<span class="line-removed">-         return axObject-&gt;headingLevel() == 3;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::HeadingLevel4:</span>
<span class="line-removed">-         return axObject-&gt;headingLevel() == 4;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::HeadingLevel5:</span>
<span class="line-removed">-         return axObject-&gt;headingLevel() == 5;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::HeadingLevel6:</span>
<span class="line-removed">-         return axObject-&gt;headingLevel() == 6;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::HeadingSameLevel:</span>
<span class="line-removed">-         return criteria-&gt;startObject</span>
<span class="line-removed">-             &amp;&amp; axObject-&gt;isHeading()</span>
<span class="line-removed">-             &amp;&amp; axObject-&gt;headingLevel() == criteria-&gt;startObject-&gt;headingLevel();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Heading:</span>
<span class="line-removed">-         return axObject-&gt;isHeading();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Highlighted:</span>
<span class="line-removed">-         return axObject-&gt;hasHighlighting();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::KeyboardFocusable:</span>
<span class="line-removed">-         return axObject-&gt;isKeyboardFocusable();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::ItalicFont:</span>
<span class="line-removed">-         return axObject-&gt;hasItalicFont();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Landmark:</span>
<span class="line-removed">-         return axObject-&gt;isLandmark();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Link: {</span>
<span class="line-removed">-         bool isLink = axObject-&gt;isLink();</span>
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">-         if (!isLink)</span>
<span class="line-removed">-             isLink = axObject-&gt;isDescendantOfRole(AccessibilityRole::WebCoreLink);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-         return isLink;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::List:</span>
<span class="line-removed">-         return axObject-&gt;isList();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::LiveRegion:</span>
<span class="line-removed">-         return axObject-&gt;supportsLiveRegion();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::MisspelledWord:</span>
<span class="line-removed">-         return axObject-&gt;hasMisspelling();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Outline:</span>
<span class="line-removed">-         return axObject-&gt;isTree();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::PlainText:</span>
<span class="line-removed">-         return axObject-&gt;hasPlainText();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::RadioGroup:</span>
<span class="line-removed">-         return axObject-&gt;isRadioGroup();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::SameType:</span>
<span class="line-removed">-         return criteria-&gt;startObject</span>
<span class="line-removed">-             &amp;&amp; axObject-&gt;roleValue() == criteria-&gt;startObject-&gt;roleValue();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::StaticText:</span>
<span class="line-removed">-         return axObject-&gt;isStaticText();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::StyleChange:</span>
<span class="line-removed">-         return criteria-&gt;startObject</span>
<span class="line-removed">-             &amp;&amp; !axObject-&gt;hasSameStyle(criteria-&gt;startObject-&gt;renderer());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::TableSameLevel:</span>
<span class="line-removed">-         return criteria-&gt;startObject</span>
<span class="line-removed">-             &amp;&amp; is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility()</span>
<span class="line-removed">-             &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).tableLevel() == criteria-&gt;startObject-&gt;tableLevel();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Table:</span>
<span class="line-removed">-         return is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::TextField:</span>
<span class="line-removed">-         return axObject-&gt;isTextControl();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::Underline:</span>
<span class="line-removed">-         return axObject-&gt;hasUnderline();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::UnvisitedLink:</span>
<span class="line-removed">-         return axObject-&gt;isUnvisited();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case AccessibilitySearchKey::VisitedLink:</span>
<span class="line-removed">-         return axObject-&gt;isVisited();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool AccessibilityObject::isAccessibilityObjectSearchMatch(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!axObject || !criteria)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     size_t length = criteria-&gt;searchKeys.size();</span>
<span class="line-removed">-     for (size_t i = 0; i &lt; length; ++i) {</span>
<span class="line-removed">-         if (isAccessibilityObjectSearchMatchAtIndex(axObject, criteria, i)) {</span>
<span class="line-removed">-             if (criteria-&gt;visibleOnly &amp;&amp; !axObject-&gt;isOnscreen())</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool AccessibilityObject::isAccessibilityTextSearchMatch(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!axObject || !criteria)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return axObject-&gt;accessibilityObjectContainsText(&amp;criteria-&gt;searchText);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool AccessibilityObject::accessibilityObjectContainsText(String* text) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // If text is null or empty we return true.</span>
<span class="line-removed">-     return !text</span>
<span class="line-removed">-         || text-&gt;isEmpty()</span>
<span class="line-removed">-         || findPlainText(title(), *text, CaseInsensitive)</span>
<span class="line-removed">-         || findPlainText(accessibilityDescription(), *text, CaseInsensitive)</span>
<span class="line-removed">-         || findPlainText(stringValue(), *text, CaseInsensitive);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // ARIA marks elements as having their accessible name derive from either their contents, or their author provide name.
  bool AccessibilityObject::accessibleNameDerivesFromContent() const
  {
      // First check for objects specifically identified by ARIA.
      switch (ariaRoleAttribute()) {
<span class="line-new-header">--- 116,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 461,10 ***</span>
<span class="line-new-header">--- 276,59 ---</span>
          isMisspelled = true;
  
      return isMisspelled;
  }
  
<span class="line-added">+ RefPtr&lt;Range&gt; AccessibilityObject::getMisspellingRange(RefPtr&lt;Range&gt; const&amp; start, AccessibilitySearchDirection direction) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto node = this-&gt;node();</span>
<span class="line-added">+     if (!node)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Frame* frame = node-&gt;document().frame();</span>
<span class="line-added">+     if (!frame)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!unifiedTextCheckerEnabled(frame))</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Editor&amp; editor = frame-&gt;editor();</span>
<span class="line-added">+ </span>
<span class="line-added">+     TextCheckerClient* textChecker = editor.textChecker();</span>
<span class="line-added">+     if (!textChecker)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;TextCheckingResult&gt; misspellings;</span>
<span class="line-added">+     checkTextOfParagraph(*textChecker, stringValue(), TextCheckingType::Spelling, misspellings, frame-&gt;selection().selection());</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The returned misspellings are assumed to be ordered in the document</span>
<span class="line-added">+     // logical order, which should be matched by Range::compareBoundaryPoints.</span>
<span class="line-added">+     // So iterate forward or backwards depending on the desired search</span>
<span class="line-added">+     // direction to find the closest misspelling in that direction.</span>
<span class="line-added">+     if (direction == AccessibilitySearchDirection::Next) {</span>
<span class="line-added">+         for (const auto&amp; misspelling : misspellings) {</span>
<span class="line-added">+             auto misspellingRange = editor.rangeForTextCheckingResult(misspelling);</span>
<span class="line-added">+             if (!misspellingRange)</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (misspellingRange-&gt;compareBoundaryPoints(Range::END_TO_END, *start).releaseReturnValue() &gt; 0)</span>
<span class="line-added">+                 return misspellingRange;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     } else if (direction == AccessibilitySearchDirection::Previous) {</span>
<span class="line-added">+         for (auto rit = misspellings.rbegin(); rit != misspellings.rend(); ++rit) {</span>
<span class="line-added">+             auto misspellingRange = editor.rangeForTextCheckingResult(*rit);</span>
<span class="line-added">+             if (!misspellingRange)</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (misspellingRange-&gt;compareBoundaryPoints(Range::START_TO_START, *start).releaseReturnValue() &lt; 0)</span>
<span class="line-added">+                 return misspellingRange;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  unsigned AccessibilityObject::blockquoteLevel() const
  {
      unsigned level = 0;
      for (Node* elementNode = node(); elementNode; elementNode = elementNode-&gt;parentNode()) {
          if (elementNode-&gt;hasTagName(blockquoteTag))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 472,15 ***</span>
      }
  
      return level;
  }
  
<span class="line-modified">! AccessibilityObject* AccessibilityObject::parentObjectUnignored() const</span>
  {
<span class="line-modified">!     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {</span>
          return !object.accessibilityIsIgnored();
<span class="line-modified">!     }));</span>
  }
  
  AccessibilityObject* AccessibilityObject::previousSiblingUnignored(int limit) const
  {
      AccessibilityObject* previous;
<span class="line-new-header">--- 336,15 ---</span>
      }
  
      return level;
  }
  
<span class="line-modified">! AXCoreObject* AccessibilityObject::parentObjectUnignored() const</span>
  {
<span class="line-modified">!     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [] (const AccessibilityObject&amp; object) {</span>
          return !object.accessibilityIsIgnored();
<span class="line-modified">!     });</span>
  }
  
  AccessibilityObject* AccessibilityObject::previousSiblingUnignored(int limit) const
  {
      AccessibilityObject* previous;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 570,16 ***</span>
      return accessibleObject;
  }
  
  bool AccessibilityObject::isDescendantOfRole(AccessibilityRole role) const
  {
<span class="line-modified">!     return AccessibilityObject::matchedParent(*this, false, [&amp;role] (const AccessibilityObject&amp; object) {</span>
          return object.roleValue() == role;
      }) != nullptr;
  }
  
<span class="line-modified">! static void appendAccessibilityObject(AccessibilityObject* object, AccessibilityObject::AccessibilityChildrenVector&amp; results)</span>
  {
      // Find the next descendant of this attachment object so search can continue through frames.
      if (object-&gt;isAttachment()) {
          Widget* widget = object-&gt;widgetForAttachmentView();
          if (!is&lt;FrameView&gt;(widget))
<span class="line-new-header">--- 434,16 ---</span>
      return accessibleObject;
  }
  
  bool AccessibilityObject::isDescendantOfRole(AccessibilityRole role) const
  {
<span class="line-modified">!     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [&amp;role] (const AccessibilityObject&amp; object) {</span>
          return object.roleValue() == role;
      }) != nullptr;
  }
  
<span class="line-modified">! static void appendAccessibilityObject(AXCoreObject* object, AccessibilityObject::AccessibilityChildrenVector&amp; results)</span>
  {
      // Find the next descendant of this attachment object so search can continue through frames.
      if (object-&gt;isAttachment()) {
          Widget* widget = object-&gt;widgetForAttachmentView();
          if (!is&lt;FrameView&gt;(widget))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 594,11 ***</span>
  
      if (object)
          results.append(object);
  }
  
<span class="line-modified">! void AccessibilityObject::insertChild(AccessibilityObject* child, unsigned index)</span>
  {
      if (!child)
          return;
  
      // If the parent is asking for this child&#39;s children, then either it&#39;s the first time (and clearing is a no-op),
<span class="line-new-header">--- 458,11 ---</span>
  
      if (object)
          results.append(object);
  }
  
<span class="line-modified">! void AccessibilityObject::insertChild(AXCoreObject* child, unsigned index)</span>
  {
      if (!child)
          return;
  
      // If the parent is asking for this child&#39;s children, then either it&#39;s the first time (and clearing is a no-op),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 634,16 ***</span>
  
      // Reset the child&#39;s m_isIgnoredFromParentData since we are done adding that child and its children.
      child-&gt;clearIsIgnoredFromParentData();
  }
  
<span class="line-modified">! void AccessibilityObject::addChild(AccessibilityObject* child)</span>
  {
      insertChild(child, m_children.size());
  }
  
<span class="line-modified">! static void appendChildrenToArray(AccessibilityObject* object, bool isForward, AccessibilityObject* startObject, AccessibilityObject::AccessibilityChildrenVector&amp; results)</span>
  {
      // A table&#39;s children includes elements whose own children are also the table&#39;s children (due to the way the Mac exposes tables).
      // The rows from the table should be queried, since those are direct descendants of the table, and they contain content.
      const auto&amp; searchChildren = is&lt;AccessibilityTable&gt;(*object) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*object).isExposableThroughAccessibility() ? downcast&lt;AccessibilityTable&gt;(*object).rows() : object-&gt;children();
  
<span class="line-new-header">--- 498,16 ---</span>
  
      // Reset the child&#39;s m_isIgnoredFromParentData since we are done adding that child and its children.
      child-&gt;clearIsIgnoredFromParentData();
  }
  
<span class="line-modified">! void AccessibilityObject::addChild(AXCoreObject* child)</span>
  {
      insertChild(child, m_children.size());
  }
  
<span class="line-modified">! static void appendChildrenToArray(AXCoreObject* object, bool isForward, AXCoreObject* startObject, AccessibilityObject::AccessibilityChildrenVector&amp; results)</span>
  {
      // A table&#39;s children includes elements whose own children are also the table&#39;s children (due to the way the Mac exposes tables).
      // The rows from the table should be queried, since those are direct descendants of the table, and they contain content.
      const auto&amp; searchChildren = is&lt;AccessibilityTable&gt;(*object) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*object).isExposableThroughAccessibility() ? downcast&lt;AccessibilityTable&gt;(*object).rows() : object-&gt;children();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 652,11 ***</span>
      size_t startIndex = isForward ? childrenSize : 0;
      size_t endIndex = isForward ? 0 : childrenSize;
  
      // If the startObject is ignored, we should use an accessible sibling as a start element instead.
      if (startObject &amp;&amp; startObject-&gt;accessibilityIsIgnored() &amp;&amp; startObject-&gt;isDescendantOfObject(object)) {
<span class="line-modified">!         AccessibilityObject* parentObject = startObject-&gt;parentObject();</span>
          // Go up the parent chain to find the highest ancestor that&#39;s also being ignored.
          while (parentObject &amp;&amp; parentObject-&gt;accessibilityIsIgnored()) {
              if (parentObject == object)
                  break;
              startObject = parentObject;
<span class="line-new-header">--- 516,11 ---</span>
      size_t startIndex = isForward ? childrenSize : 0;
      size_t endIndex = isForward ? 0 : childrenSize;
  
      // If the startObject is ignored, we should use an accessible sibling as a start element instead.
      if (startObject &amp;&amp; startObject-&gt;accessibilityIsIgnored() &amp;&amp; startObject-&gt;isDescendantOfObject(object)) {
<span class="line-modified">!         AXCoreObject* parentObject = startObject-&gt;parentObject();</span>
          // Go up the parent chain to find the highest ancestor that&#39;s also being ignored.
          while (parentObject &amp;&amp; parentObject-&gt;accessibilityIsIgnored()) {
              if (parentObject == object)
                  break;
              startObject = parentObject;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 684,83 ***</span>
          for (size_t i = startIndex; i &lt; endIndex; i++)
              appendAccessibilityObject(searchChildren.at(i).get(), results);
      }
  }
  
<span class="line-removed">- // Returns true if the number of results is now &gt;= the number of results desired.</span>
<span class="line-removed">- bool AccessibilityObject::objectMatchesSearchCriteriaWithResultLimit(AccessibilityObject* object, AccessibilitySearchCriteria* criteria, AccessibilityChildrenVector&amp; results)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (isAccessibilityObjectSearchMatch(object, criteria) &amp;&amp; isAccessibilityTextSearchMatch(object, criteria)) {</span>
<span class="line-removed">-         results.append(object);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Enough results were found to stop searching.</span>
<span class="line-removed">-         if (results.size() &gt;= criteria-&gt;resultsLimit)</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void AccessibilityObject::findMatchingObjects(AccessibilitySearchCriteria* criteria, AccessibilityChildrenVector&amp; results)
  {
      ASSERT(criteria);
<span class="line-removed">- </span>
      if (!criteria)
          return;
  
      if (AXObjectCache* cache = axObjectCache())
          cache-&gt;startCachingComputedObjectAttributesUntilTreeMutates();
  
<span class="line-modified">!     // This search mechanism only searches the elements before/after the starting object.</span>
<span class="line-modified">!     // It does this by stepping up the parent chain and at each level doing a DFS.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // If there&#39;s no start object, it means we want to search everything.</span>
<span class="line-removed">-     AccessibilityObject* startObject = criteria-&gt;startObject;</span>
<span class="line-removed">-     if (!startObject)</span>
<span class="line-removed">-         startObject = this;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bool isForward = criteria-&gt;searchDirection == AccessibilitySearchDirection::Next;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // The first iteration of the outer loop will examine the children of the start object for matches. However, when</span>
<span class="line-removed">-     // iterating backwards, the start object children should not be considered, so the loop is skipped ahead. We make an</span>
<span class="line-removed">-     // exception when no start object was specified because we want to search everything regardless of search direction.</span>
<span class="line-removed">-     AccessibilityObject* previousObject = nullptr;</span>
<span class="line-removed">-     if (!isForward &amp;&amp; startObject != this) {</span>
<span class="line-removed">-         previousObject = startObject;</span>
<span class="line-removed">-         startObject = startObject-&gt;parentObjectUnignored();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // The outer loop steps up the parent chain each time (unignored is important here because otherwise elements would be searched twice)</span>
<span class="line-removed">-     for (AccessibilityObject* stopSearchElement = parentObjectUnignored(); startObject &amp;&amp; startObject != stopSearchElement; startObject = startObject-&gt;parentObjectUnignored()) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Only append the children after/before the previous element, so that the search does not check elements that are</span>
<span class="line-removed">-         // already behind/ahead of start element.</span>
<span class="line-removed">-         AccessibilityChildrenVector searchStack;</span>
<span class="line-removed">-         if (!criteria-&gt;immediateDescendantsOnly || startObject == this)</span>
<span class="line-removed">-             appendChildrenToArray(startObject, isForward, previousObject, searchStack);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // This now does a DFS at the current level of the parent.</span>
<span class="line-removed">-         while (!searchStack.isEmpty()) {</span>
<span class="line-removed">-             AccessibilityObject* searchObject = searchStack.last().get();</span>
<span class="line-removed">-             searchStack.removeLast();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (objectMatchesSearchCriteriaWithResultLimit(searchObject, criteria, results))</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (!criteria-&gt;immediateDescendantsOnly)</span>
<span class="line-removed">-                 appendChildrenToArray(searchObject, isForward, 0, searchStack);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (results.size() &gt;= criteria-&gt;resultsLimit)</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // When moving backwards, the parent object needs to be checked, because technically it&#39;s &quot;before&quot; the starting element.</span>
<span class="line-removed">-         if (!isForward &amp;&amp; startObject != this &amp;&amp; objectMatchesSearchCriteriaWithResultLimit(startObject, criteria, results))</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         previousObject = startObject;</span>
<span class="line-removed">-     }</span>
  }
  
  // Returns the range that is fewer positions away from the reference range.
  // NOTE: The after range is expected to ACTUALLY be after the reference range and the before
  // range is expected to ACTUALLY be before. These are not checked for performance reasons.
<span class="line-new-header">--- 548,21 ---</span>
          for (size_t i = startIndex; i &lt; endIndex; i++)
              appendAccessibilityObject(searchChildren.at(i).get(), results);
      }
  }
  
  void AccessibilityObject::findMatchingObjects(AccessibilitySearchCriteria* criteria, AccessibilityChildrenVector&amp; results)
  {
      ASSERT(criteria);
      if (!criteria)
          return;
  
      if (AXObjectCache* cache = axObjectCache())
          cache-&gt;startCachingComputedObjectAttributesUntilTreeMutates();
  
<span class="line-modified">!     criteria-&gt;anchorObject = this;</span>
<span class="line-modified">!     Accessibility::findMatchingObjects(*criteria, results);</span>
  }
  
  // Returns the range that is fewer positions away from the reference range.
  // NOTE: The after range is expected to ACTUALLY be after the reference range and the before
  // range is expected to ACTUALLY be before. These are not checked for performance reasons.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 931,11 ***</span>
  
      Frame* frame = this-&gt;frame();
      if (!frame)
          return result;
  
<span class="line-modified">!     for (auto textRange : operation.textRanges) {</span>
          if (!frame-&gt;selection().setSelectedRange(textRange.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes))
              continue;
  
          String text = textRange-&gt;text();
          String replacementString = operation.replacementText;
<span class="line-new-header">--- 733,11 ---</span>
  
      Frame* frame = this-&gt;frame();
      if (!frame)
          return result;
  
<span class="line-modified">!     for (const auto&amp; textRange : operation.textRanges) {</span>
          if (!frame-&gt;selection().setSelectedRange(textRange.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes))
              continue;
  
          String text = textRange-&gt;text();
          String replacementString = operation.replacementText;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1383,10 ***</span>
<span class="line-new-header">--- 1185,13 ---</span>
  RefPtr&lt;Range&gt; AccessibilityObject::rangeForPlainTextRange(const PlainTextRange&amp; range) const
  {
      unsigned textLength = getLengthForTextRange();
      if (range.start + range.length &gt; textLength)
          return nullptr;
<span class="line-added">+     // Avoid setting selection to uneditable parent node in FrameSelection::setSelectedRange. See webkit.org/b/206093.</span>
<span class="line-added">+     if (range.isNull() &amp;&amp; !textLength)</span>
<span class="line-added">+         return nullptr;</span>
  
      if (AXObjectCache* cache = axObjectCache()) {
          CharacterOffset start = cache-&gt;characterOffsetForIndex(range.start, this);
          CharacterOffset end = cache-&gt;characterOffsetForIndex(range.start + range.length, this);
          return cache-&gt;rangeForUnorderedCharacterOffsets(start, end);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1888,11 ***</span>
  }
  #endif
  
  const AccessibilityScrollView* AccessibilityObject::ancestorAccessibilityScrollView(bool includeSelf) const
  {
<span class="line-modified">!     return downcast&lt;AccessibilityScrollView&gt;(AccessibilityObject::matchedParent(*this, includeSelf, [] (const auto&amp; object) {</span>
          return is&lt;AccessibilityScrollView&gt;(object);
      }));
  }
  
  ScrollView* AccessibilityObject::scrollViewAncestor() const
<span class="line-new-header">--- 1693,11 ---</span>
  }
  #endif
  
  const AccessibilityScrollView* AccessibilityObject::ancestorAccessibilityScrollView(bool includeSelf) const
  {
<span class="line-modified">!     return downcast&lt;AccessibilityScrollView&gt;(Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, includeSelf, [] (const auto&amp; object) {</span>
          return is&lt;AccessibilityScrollView&gt;(object);
      }));
  }
  
  ScrollView* AccessibilityObject::scrollViewAncestor() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1943,12 ***</span>
<span class="line-new-header">--- 1748,14 ---</span>
  #endif
  
  void AccessibilityObject::updateChildrenIfNecessary()
  {
      if (!hasChildren()) {
<span class="line-added">+ #if HAVE(ACCESSIBILITY)</span>
          // Enable the cache in case we end up adding a lot of children, we don&#39;t want to recompute axIsIgnored each time.
          AXAttributeCacheEnabler enableCache(axObjectCache());
<span class="line-added">+ #endif</span>
          addChildren();
      }
  }
  
  void AccessibilityObject::clearChildren()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1988,23 ***</span>
      if (!renderObject)
          return nullptr;
  
      AccessibilityObject* axObject = renderObject-&gt;document().axObjectCache()-&gt;getOrCreate(renderObject);
  
<span class="line-modified">!     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*axObject, true, [] (const AccessibilityObject&amp; object) {</span>
          return object.roleValue() == AccessibilityRole::Heading;
<span class="line-modified">!     }));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- const AccessibilityObject* AccessibilityObject::matchedParent(const AccessibilityObject&amp; object, bool includeSelf, const WTF::Function&lt;bool(const AccessibilityObject&amp;)&gt;&amp; matches)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     const AccessibilityObject* parent = includeSelf ? &amp;object : object.parentObject();</span>
<span class="line-removed">-     for (; parent; parent = parent-&gt;parentObject()) {</span>
<span class="line-removed">-         if (matches(*parent))</span>
<span class="line-removed">-             return parent;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return nullptr;</span>
  }
  
  void AccessibilityObject::ariaTreeRows(AccessibilityChildrenVector&amp; result)
  {
      for (const auto&amp; child : children()) {
<span class="line-new-header">--- 1795,13 ---</span>
      if (!renderObject)
          return nullptr;
  
      AccessibilityObject* axObject = renderObject-&gt;document().axObjectCache()-&gt;getOrCreate(renderObject);
  
<span class="line-modified">!     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*axObject, true, [] (const AccessibilityObject&amp; object) {</span>
          return object.roleValue() == AccessibilityRole::Heading;
<span class="line-modified">!     });</span>
  }
  
  void AccessibilityObject::ariaTreeRows(AccessibilityChildrenVector&amp; result)
  {
      for (const auto&amp; child : children()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2054,11 ***</span>
          return nullAtom();
      }
  }
  
  #if ENABLE(ACCESSIBILITY)
<span class="line-modified">! const String&amp; AccessibilityObject::actionVerb() const</span>
  {
  #if !PLATFORM(IOS_FAMILY)
      // FIXME: Need to add verbs for select elements.
      static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
      static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
<span class="line-new-header">--- 1851,11 ---</span>
          return nullAtom();
      }
  }
  
  #if ENABLE(ACCESSIBILITY)
<span class="line-modified">! String AccessibilityObject::actionVerb() const</span>
  {
  #if !PLATFORM(IOS_FAMILY)
      // FIXME: Need to add verbs for select elements.
      static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
      static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2310,21 ***</span>
          return AccessibilityOrientation::Vertical;
  
      return AccessibilityOrientation::Undefined;
  }
  
<span class="line-modified">! bool AccessibilityObject::isDescendantOfObject(const AccessibilityObject* axObject) const</span>
  {
      if (!axObject || !axObject-&gt;hasChildren())
          return false;
  
<span class="line-modified">!     return AccessibilityObject::matchedParent(*this, false, [axObject] (const AccessibilityObject&amp; object) {</span>
          return &amp;object == axObject;
      }) != nullptr;
  }
  
<span class="line-modified">! bool AccessibilityObject::isAncestorOfObject(const AccessibilityObject* axObject) const</span>
  {
      if (!axObject)
          return false;
  
      return this == axObject || axObject-&gt;isDescendantOfObject(this);
<span class="line-new-header">--- 2107,21 ---</span>
          return AccessibilityOrientation::Vertical;
  
      return AccessibilityOrientation::Undefined;
  }
  
<span class="line-modified">! bool AccessibilityObject::isDescendantOfObject(const AXCoreObject* axObject) const</span>
  {
      if (!axObject || !axObject-&gt;hasChildren())
          return false;
  
<span class="line-modified">!     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [axObject] (const AccessibilityObject&amp; object) {</span>
          return &amp;object == axObject;
      }) != nullptr;
  }
  
<span class="line-modified">! bool AccessibilityObject::isAncestorOfObject(const AXCoreObject* axObject) const</span>
  {
      if (!axObject)
          return false;
  
      return this == axObject || axObject-&gt;isDescendantOfObject(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2561,13 ***</span>
      }
  
      return false;
  }
  
  String AccessibilityObject::roleDescription() const
  {
<span class="line-modified">!     return stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_roledescriptionAttr));</span>
  }
  
  bool nodeHasPresentationRole(Node* node)
  {
      return nodeHasRole(node, &quot;presentation&quot;) || nodeHasRole(node, &quot;none&quot;);
<span class="line-new-header">--- 2358,90 ---</span>
      }
  
      return false;
  }
  
<span class="line-added">+ #if !PLATFORM(MAC)</span>
<span class="line-added">+ String AccessibilityObject::rolePlatformString() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // FIXME: implement in other platforms.</span>
<span class="line-added">+     return String();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ String AccessibilityObject::rolePlatformDescription() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // FIXME: implement in other platforms.</span>
<span class="line-added">+     return String();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ String AccessibilityObject::ariaLandmarkRoleDescription() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (roleValue()) {</span>
<span class="line-added">+     case AccessibilityRole::LandmarkBanner:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIALandmarkBanner&quot;);</span>
<span class="line-added">+     case AccessibilityRole::LandmarkComplementary:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIALandmarkComplementary&quot;);</span>
<span class="line-added">+     case AccessibilityRole::LandmarkContentInfo:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIALandmarkContentInfo&quot;);</span>
<span class="line-added">+     case AccessibilityRole::LandmarkMain:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIALandmarkMain&quot;);</span>
<span class="line-added">+     case AccessibilityRole::LandmarkNavigation:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIALandmarkNavigation&quot;);</span>
<span class="line-added">+     case AccessibilityRole::LandmarkDocRegion:</span>
<span class="line-added">+     case AccessibilityRole::LandmarkRegion:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIALandmarkRegion&quot;);</span>
<span class="line-added">+     case AccessibilityRole::LandmarkSearch:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIALandmarkSearch&quot;);</span>
<span class="line-added">+     case AccessibilityRole::ApplicationAlert:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIAApplicationAlert&quot;);</span>
<span class="line-added">+     case AccessibilityRole::ApplicationAlertDialog:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIAApplicationAlertDialog&quot;);</span>
<span class="line-added">+     case AccessibilityRole::ApplicationDialog:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIAApplicationDialog&quot;);</span>
<span class="line-added">+     case AccessibilityRole::ApplicationLog:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIAApplicationLog&quot;);</span>
<span class="line-added">+     case AccessibilityRole::ApplicationMarquee:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIAApplicationMarquee&quot;);</span>
<span class="line-added">+     case AccessibilityRole::ApplicationStatus:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIAApplicationStatus&quot;);</span>
<span class="line-added">+     case AccessibilityRole::ApplicationTimer:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIAApplicationTimer&quot;);</span>
<span class="line-added">+     case AccessibilityRole::Document:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIADocument&quot;);</span>
<span class="line-added">+     case AccessibilityRole::DocumentArticle:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIADocumentArticle&quot;);</span>
<span class="line-added">+     case AccessibilityRole::DocumentMath:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIADocumentMath&quot;);</span>
<span class="line-added">+     case AccessibilityRole::DocumentNote:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIADocumentNote&quot;);</span>
<span class="line-added">+     case AccessibilityRole::UserInterfaceTooltip:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIAUserInterfaceTooltip&quot;);</span>
<span class="line-added">+     case AccessibilityRole::TabPanel:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIATabPanel&quot;);</span>
<span class="line-added">+     case AccessibilityRole::WebApplication:</span>
<span class="line-added">+         return AXARIAContentGroupText(&quot;ARIAWebApplication&quot;);</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         return String();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  String AccessibilityObject::roleDescription() const
  {
<span class="line-modified">!     // aria-roledescription takes precedence over any other rule.</span>
<span class="line-added">+     String roleDescription = stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_roledescriptionAttr));</span>
<span class="line-added">+     if (!roleDescription.isEmpty())</span>
<span class="line-added">+         return roleDescription;</span>
<span class="line-added">+ </span>
<span class="line-added">+     roleDescription = rolePlatformDescription();</span>
<span class="line-added">+     if (!roleDescription.isEmpty())</span>
<span class="line-added">+         return roleDescription;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (roleValue() == AccessibilityRole::Figure)</span>
<span class="line-added">+         return AXFigureText();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return roleDescription;</span>
  }
  
  bool nodeHasPresentationRole(Node* node)
  {
      return nodeHasRole(node, &quot;presentation&quot;) || nodeHasRole(node, &quot;none&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2606,20 ***</span>
  bool AccessibilityObject::supportsDatetimeAttribute() const
  {
      return hasTagName(insTag) || hasTagName(delTag) || hasTagName(timeTag);
  }
  
<span class="line-modified">! const AtomString&amp; AccessibilityObject::datetimeAttributeValue() const</span>
  {
      return getAttribute(datetimeAttr);
  }
  
<span class="line-modified">! const AtomString&amp; AccessibilityObject::linkRelValue() const</span>
  {
      return getAttribute(relAttr);
  }
  
  const String AccessibilityObject::keyShortcutsValue() const
  {
      return getAttribute(aria_keyshortcutsAttr);
  }
  
<span class="line-new-header">--- 2480,25 ---</span>
  bool AccessibilityObject::supportsDatetimeAttribute() const
  {
      return hasTagName(insTag) || hasTagName(delTag) || hasTagName(timeTag);
  }
  
<span class="line-modified">! String AccessibilityObject::datetimeAttributeValue() const</span>
  {
      return getAttribute(datetimeAttr);
  }
  
<span class="line-modified">! String AccessibilityObject::linkRelValue() const</span>
  {
      return getAttribute(relAttr);
  }
  
<span class="line-added">+ bool AccessibilityObject::isInlineText() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return is&lt;RenderInline&gt;(renderer());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  const String AccessibilityObject::keyShortcutsValue() const
  {
      return getAttribute(aria_keyshortcutsAttr);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2681,13 ***</span>
      return liveRegionAncestor(excludeIfOff);
  }
  
  AccessibilityObject* AccessibilityObject::liveRegionAncestor(bool excludeIfOff) const
  {
<span class="line-modified">!     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [excludeIfOff] (const AccessibilityObject&amp; object) {</span>
          return object.supportsLiveRegion(excludeIfOff);
<span class="line-modified">!     }));</span>
  }
  
  bool AccessibilityObject::supportsARIAAttributes() const
  {
      // This returns whether the element supports any global ARIA attributes.
<span class="line-new-header">--- 2560,13 ---</span>
      return liveRegionAncestor(excludeIfOff);
  }
  
  AccessibilityObject* AccessibilityObject::liveRegionAncestor(bool excludeIfOff) const
  {
<span class="line-modified">!     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [excludeIfOff] (const AccessibilityObject&amp; object) {</span>
          return object.supportsLiveRegion(excludeIfOff);
<span class="line-modified">!     });</span>
  }
  
  bool AccessibilityObject::supportsARIAAttributes() const
  {
      // This returns whether the element supports any global ARIA attributes.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2720,11 ***</span>
  {
      const AtomString&amp; liveRegionStatusValue = liveRegionStatus();
      return excludeIfOff ? liveRegionStatusIsEnabled(liveRegionStatusValue) : !liveRegionStatusValue.isEmpty();
  }
  
<span class="line-modified">! AccessibilityObjectInterface* AccessibilityObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
  {
      // Send the hit test back into the sub-frame if necessary.
      if (isAttachment()) {
          Widget* widget = widgetForAttachmentView();
          // Normalize the point for the widget&#39;s bounds.
<span class="line-new-header">--- 2599,11 ---</span>
  {
      const AtomString&amp; liveRegionStatusValue = liveRegionStatus();
      return excludeIfOff ? liveRegionStatusIsEnabled(liveRegionStatusValue) : !liveRegionStatusValue.isEmpty();
  }
  
<span class="line-modified">! AXCoreObject* AccessibilityObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
  {
      // Send the hit test back into the sub-frame if necessary.
      if (isAttachment()) {
          Widget* widget = widgetForAttachmentView();
          // Normalize the point for the widget&#39;s bounds.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2747,14 ***</span>
  {
      auto* document = this-&gt;document();
      return document ? document-&gt;axObjectCache() : nullptr;
  }
  
<span class="line-modified">! AccessibilityObjectInterface* AccessibilityObject::focusedUIElement() const</span>
  {
      auto* page = this-&gt;page();
<span class="line-modified">!     return page ? AXObjectCache::focusedUIElementForPage(page) : nullptr;</span>
  }
  
  AccessibilitySortDirection AccessibilityObject::sortDirection() const
  {
      AccessibilityRole role = roleValue();
<span class="line-new-header">--- 2626,15 ---</span>
  {
      auto* document = this-&gt;document();
      return document ? document-&gt;axObjectCache() : nullptr;
  }
  
<span class="line-modified">! AXCoreObject* AccessibilityObject::focusedUIElement() const</span>
  {
      auto* page = this-&gt;page();
<span class="line-modified">!     auto* axObjectCache = this-&gt;axObjectCache();</span>
<span class="line-added">+     return page &amp;&amp; axObjectCache ? axObjectCache-&gt;focusedUIElementForPage(page) : nullptr;</span>
  }
  
  AccessibilitySortDirection AccessibilityObject::sortDirection() const
  {
      AccessibilityRole role = roleValue();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2850,11 ***</span>
  int AccessibilityObject::posInSet() const
  {
      return getAttribute(aria_posinsetAttr).toInt();
  }
  
<span class="line-modified">! const AtomString&amp; AccessibilityObject::identifierAttribute() const</span>
  {
      return getAttribute(idAttr);
  }
  
  void AccessibilityObject::classList(Vector&lt;String&gt;&amp; classList) const
<span class="line-new-header">--- 2730,11 ---</span>
  int AccessibilityObject::posInSet() const
  {
      return getAttribute(aria_posinsetAttr).toInt();
  }
  
<span class="line-modified">! String AccessibilityObject::identifierAttribute() const</span>
  {
      return getAttribute(idAttr);
  }
  
  void AccessibilityObject::classList(Vector&lt;String&gt;&amp; classList) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2900,11 ***</span>
      if (is&lt;HTMLDetailsElement&gt;(node()))
          return downcast&lt;HTMLDetailsElement&gt;(node())-&gt;isOpen();
  
      // Summary element should use its details parent&#39;s expanded status.
      if (isSummary()) {
<span class="line-modified">!         if (const AccessibilityObject* parent = AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {</span>
              return is&lt;HTMLDetailsElement&gt;(object.node());
          }))
              return parent-&gt;isExpanded();
      }
  
<span class="line-new-header">--- 2780,11 ---</span>
      if (is&lt;HTMLDetailsElement&gt;(node()))
          return downcast&lt;HTMLDetailsElement&gt;(node())-&gt;isOpen();
  
      // Summary element should use its details parent&#39;s expanded status.
      if (isSummary()) {
<span class="line-modified">!         if (const AccessibilityObject* parent = Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [] (const AccessibilityObject&amp; object) {</span>
              return is&lt;HTMLDetailsElement&gt;(object.node());
          }))
              return parent-&gt;isExpanded();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3045,11 ***</span>
  
      // Center the object in the viewport.
      return (objectMin + objectMax - viewportMin - viewportMax) / 2;
  }
  
<span class="line-modified">! bool AccessibilityObject::isOnscreen() const</span>
  {
      bool isOnscreen = true;
  
      // To figure out if the element is onscreen, we start by building of a stack starting with the
      // element, and then include every scrollable parent in the hierarchy.
<span class="line-new-header">--- 2925,11 ---</span>
  
      // Center the object in the viewport.
      return (objectMin + objectMax - viewportMin - viewportMax) / 2;
  }
  
<span class="line-modified">! bool AccessibilityObject::isOnScreen() const</span>
  {
      bool isOnscreen = true;
  
      // To figure out if the element is onscreen, we start by building of a stack starting with the
      // element, and then include every scrollable parent in the hierarchy.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3367,11 ***</span>
  
  // ARIA component of hidden definition.
  // http://www.w3.org/TR/wai-aria/terms#def_hidden
  bool AccessibilityObject::isAXHidden() const
  {
<span class="line-modified">!     return AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {</span>
          return equalLettersIgnoringASCIICase(object.getAttribute(aria_hiddenAttr), &quot;true&quot;);
      }) != nullptr;
  }
  
  // DOM component of hidden definition.
<span class="line-new-header">--- 3247,11 ---</span>
  
  // ARIA component of hidden definition.
  // http://www.w3.org/TR/wai-aria/terms#def_hidden
  bool AccessibilityObject::isAXHidden() const
  {
<span class="line-modified">!     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [] (const AccessibilityObject&amp; object) {</span>
          return equalLettersIgnoringASCIICase(object.getAttribute(aria_hiddenAttr), &quot;true&quot;);
      }) != nullptr;
  }
  
  // DOM component of hidden definition.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3422,11 ***</span>
      AXObjectCache* cache = axObjectCache();
      if (cache)
          attributeCache = cache-&gt;computedObjectAttributeCache();
  
      if (attributeCache) {
<span class="line-modified">!         AccessibilityObjectInclusion ignored = attributeCache-&gt;getIgnored(axObjectID());</span>
          switch (ignored) {
          case AccessibilityObjectInclusion::IgnoreObject:
              return true;
          case AccessibilityObjectInclusion::IncludeObject:
              return false;
<span class="line-new-header">--- 3302,11 ---</span>
      AXObjectCache* cache = axObjectCache();
      if (cache)
          attributeCache = cache-&gt;computedObjectAttributeCache();
  
      if (attributeCache) {
<span class="line-modified">!         AccessibilityObjectInclusion ignored = attributeCache-&gt;getIgnored(objectID());</span>
          switch (ignored) {
          case AccessibilityObjectInclusion::IgnoreObject:
              return true;
          case AccessibilityObjectInclusion::IncludeObject:
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3437,11 ***</span>
  
      bool result = computeAccessibilityIsIgnored();
  
      // In case computing axIsIgnored disables attribute caching, we should refetch the object to see if it exists.
      if (cache &amp;&amp; (attributeCache = cache-&gt;computedObjectAttributeCache()))
<span class="line-modified">!         attributeCache-&gt;setIgnored(axObjectID(), result ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject);</span>
  
      return result;
  }
  
  void AccessibilityObject::elementsFromAttribute(Vector&lt;Element*&gt;&amp; elements, const QualifiedName&amp; attribute) const
<span class="line-new-header">--- 3317,11 ---</span>
  
      bool result = computeAccessibilityIsIgnored();
  
      // In case computing axIsIgnored disables attribute caching, we should refetch the object to see if it exists.
      if (cache &amp;&amp; (attributeCache = cache-&gt;computedObjectAttributeCache()))
<span class="line-modified">!         attributeCache-&gt;setIgnored(objectID(), result ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject);</span>
  
      return result;
  }
  
  void AccessibilityObject::elementsFromAttribute(Vector&lt;Element*&gt;&amp; elements, const QualifiedName&amp; attribute) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3480,20 ***</span>
  }
  #endif
  
  AccessibilityObject* AccessibilityObject::focusableAncestor()
  {
<span class="line-modified">!     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {</span>
          return object.canSetFocusAttribute();
<span class="line-modified">!     }));</span>
  }
  
  AccessibilityObject* AccessibilityObject::editableAncestor()
  {
<span class="line-modified">!     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {</span>
          return object.isTextControl();
<span class="line-modified">!     }));</span>
  }
  
  AccessibilityObject* AccessibilityObject::highestEditableAncestor()
  {
      AccessibilityObject* editableAncestor = this-&gt;editableAncestor();
<span class="line-new-header">--- 3360,20 ---</span>
  }
  #endif
  
  AccessibilityObject* AccessibilityObject::focusableAncestor()
  {
<span class="line-modified">!     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [] (const AccessibilityObject&amp; object) {</span>
          return object.canSetFocusAttribute();
<span class="line-modified">!     });</span>
  }
  
  AccessibilityObject* AccessibilityObject::editableAncestor()
  {
<span class="line-modified">!     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [] (const AccessibilityObject&amp; object) {</span>
          return object.isTextControl();
<span class="line-modified">!     });</span>
  }
  
  AccessibilityObject* AccessibilityObject::highestEditableAncestor()
  {
      AccessibilityObject* editableAncestor = this-&gt;editableAncestor();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3512,13 ***</span>
      return previousEditableAncestor;
  }
  
  AccessibilityObject* AccessibilityObject::radioGroupAncestor() const
  {
<span class="line-modified">!     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {</span>
          return object.isRadioGroup();
<span class="line-modified">!     }));</span>
  }
  
  bool AccessibilityObject::isStyleFormatGroup() const
  {
      Node* node = this-&gt;node();
<span class="line-new-header">--- 3392,44 ---</span>
      return previousEditableAncestor;
  }
  
  AccessibilityObject* AccessibilityObject::radioGroupAncestor() const
  {
<span class="line-modified">!     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [] (const AccessibilityObject&amp; object) {</span>
          return object.isRadioGroup();
<span class="line-modified">!     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ String AccessibilityObject::documentURI() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto* document = this-&gt;document())</span>
<span class="line-added">+         return document-&gt;documentURI();</span>
<span class="line-added">+     return String();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ String AccessibilityObject::documentEncoding() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto* document = this-&gt;document())</span>
<span class="line-added">+         return document-&gt;encoding();</span>
<span class="line-added">+     return String();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ uint64_t AccessibilityObject::sessionID() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto* document = topDocument()) {</span>
<span class="line-added">+         if (auto* page = document-&gt;page())</span>
<span class="line-added">+             return page-&gt;sessionID().toUInt64();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ String AccessibilityObject::tagName() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (Element* element = this-&gt;element())</span>
<span class="line-added">+         return element-&gt;localName();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return String();</span>
  }
  
  bool AccessibilityObject::isStyleFormatGroup() const
  {
      Node* node = this-&gt;node();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3562,11 ***</span>
  
      Element* element = node-&gt;shadowHost();
      return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*element).isPasswordField();
  }
  
<span class="line-modified">! AccessibilityObject* AccessibilityObject::selectedListItem()</span>
  {
      for (const auto&amp; child : children()) {
          if (child-&gt;isListItem() &amp;&amp; (child-&gt;isSelected() || child-&gt;isActiveDescendantOfFocusedContainer()))
              return child.get();
      }
<span class="line-new-header">--- 3473,11 ---</span>
  
      Element* element = node-&gt;shadowHost();
      return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*element).isPasswordField();
  }
  
<span class="line-modified">! AXCoreObject* AccessibilityObject::selectedListItem()</span>
  {
      for (const auto&amp; child : children()) {
          if (child-&gt;isListItem() &amp;&amp; (child-&gt;isSelected() || child-&gt;isActiveDescendantOfFocusedContainer()))
              return child.get();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3694,11 ***</span>
  void AccessibilityObject::ariaOwnsReferencingElements(AccessibilityChildrenVector&amp; owners) const
  {
      ariaElementsReferencedByAttribute(owners, aria_ownsAttr);
  }
  
<span class="line-modified">! void AccessibilityObject::setIsIgnoredFromParentDataForChild(AccessibilityObject* child)</span>
  {
      if (!child)
          return;
  
      if (child-&gt;parentObject() != this) {
<span class="line-new-header">--- 3605,11 ---</span>
  void AccessibilityObject::ariaOwnsReferencingElements(AccessibilityChildrenVector&amp; owners) const
  {
      ariaElementsReferencedByAttribute(owners, aria_ownsAttr);
  }
  
<span class="line-modified">! void AccessibilityObject::setIsIgnoredFromParentDataForChild(AXCoreObject* child)</span>
  {
      if (!child)
          return;
  
      if (child-&gt;parentObject() != this) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3718,6 ***</span>
<span class="line-new-header">--- 3629,217 ---</span>
      }
  
      child-&gt;setIsIgnoredFromParentData(result);
  }
  
<span class="line-added">+ namespace Accessibility {</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if !PLATFORM(MAC)</span>
<span class="line-added">+ // FIXME: implement in other platforms.</span>
<span class="line-added">+ PlatformRoleMap createPlatformRoleMap() { return PlatformRoleMap(); }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ String roleToPlatformString(AccessibilityRole role)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static NeverDestroyed&lt;PlatformRoleMap&gt; roleMap = createPlatformRoleMap();</span>
<span class="line-added">+     return roleMap-&gt;get(static_cast&lt;unsigned&gt;(role));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool isAccessibilityObjectSearchMatchAtIndex(AXCoreObject* axObject, AccessibilitySearchCriteria const&amp; criteria, size_t index)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (criteria.searchKeys[index]) {</span>
<span class="line-added">+     case AccessibilitySearchKey::AnyType:</span>
<span class="line-added">+         // The AccessibilitySearchKey::AnyType matches any non-null AccessibilityObject.</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     case AccessibilitySearchKey::Article:</span>
<span class="line-added">+         return axObject-&gt;roleValue() == AccessibilityRole::DocumentArticle;</span>
<span class="line-added">+     case AccessibilitySearchKey::BlockquoteSameLevel:</span>
<span class="line-added">+         return criteria.startObject</span>
<span class="line-added">+             &amp;&amp; axObject-&gt;isBlockquote()</span>
<span class="line-added">+             &amp;&amp; axObject-&gt;blockquoteLevel() == criteria.startObject-&gt;blockquoteLevel();</span>
<span class="line-added">+     case AccessibilitySearchKey::Blockquote:</span>
<span class="line-added">+         return axObject-&gt;isBlockquote();</span>
<span class="line-added">+     case AccessibilitySearchKey::BoldFont:</span>
<span class="line-added">+         return axObject-&gt;hasBoldFont();</span>
<span class="line-added">+     case AccessibilitySearchKey::Button:</span>
<span class="line-added">+         return axObject-&gt;isButton();</span>
<span class="line-added">+     case AccessibilitySearchKey::CheckBox:</span>
<span class="line-added">+         return axObject-&gt;isCheckbox();</span>
<span class="line-added">+     case AccessibilitySearchKey::Control:</span>
<span class="line-added">+         return axObject-&gt;isControl();</span>
<span class="line-added">+     case AccessibilitySearchKey::DifferentType:</span>
<span class="line-added">+         return criteria.startObject</span>
<span class="line-added">+             &amp;&amp; axObject-&gt;roleValue() != criteria.startObject-&gt;roleValue();</span>
<span class="line-added">+     case AccessibilitySearchKey::FontChange:</span>
<span class="line-added">+         return criteria.startObject</span>
<span class="line-added">+             &amp;&amp; !axObject-&gt;hasSameFont(criteria.startObject-&gt;renderer());</span>
<span class="line-added">+     case AccessibilitySearchKey::FontColorChange:</span>
<span class="line-added">+         return criteria.startObject</span>
<span class="line-added">+             &amp;&amp; !axObject-&gt;hasSameFontColor(criteria.startObject-&gt;renderer());</span>
<span class="line-added">+     case AccessibilitySearchKey::Frame:</span>
<span class="line-added">+         return axObject-&gt;isWebArea();</span>
<span class="line-added">+     case AccessibilitySearchKey::Graphic:</span>
<span class="line-added">+         return axObject-&gt;isImage();</span>
<span class="line-added">+     case AccessibilitySearchKey::HeadingLevel1:</span>
<span class="line-added">+         return axObject-&gt;headingLevel() == 1;</span>
<span class="line-added">+     case AccessibilitySearchKey::HeadingLevel2:</span>
<span class="line-added">+         return axObject-&gt;headingLevel() == 2;</span>
<span class="line-added">+     case AccessibilitySearchKey::HeadingLevel3:</span>
<span class="line-added">+         return axObject-&gt;headingLevel() == 3;</span>
<span class="line-added">+     case AccessibilitySearchKey::HeadingLevel4:</span>
<span class="line-added">+         return axObject-&gt;headingLevel() == 4;</span>
<span class="line-added">+     case AccessibilitySearchKey::HeadingLevel5:</span>
<span class="line-added">+         return axObject-&gt;headingLevel() == 5;</span>
<span class="line-added">+     case AccessibilitySearchKey::HeadingLevel6:</span>
<span class="line-added">+         return axObject-&gt;headingLevel() == 6;</span>
<span class="line-added">+     case AccessibilitySearchKey::HeadingSameLevel:</span>
<span class="line-added">+         return criteria.startObject</span>
<span class="line-added">+             &amp;&amp; axObject-&gt;isHeading()</span>
<span class="line-added">+             &amp;&amp; axObject-&gt;headingLevel() == criteria.startObject-&gt;headingLevel();</span>
<span class="line-added">+     case AccessibilitySearchKey::Heading:</span>
<span class="line-added">+         return axObject-&gt;isHeading();</span>
<span class="line-added">+     case AccessibilitySearchKey::Highlighted:</span>
<span class="line-added">+         return axObject-&gt;hasHighlighting();</span>
<span class="line-added">+     case AccessibilitySearchKey::KeyboardFocusable:</span>
<span class="line-added">+         return axObject-&gt;isKeyboardFocusable();</span>
<span class="line-added">+     case AccessibilitySearchKey::ItalicFont:</span>
<span class="line-added">+         return axObject-&gt;hasItalicFont();</span>
<span class="line-added">+     case AccessibilitySearchKey::Landmark:</span>
<span class="line-added">+         return axObject-&gt;isLandmark();</span>
<span class="line-added">+     case AccessibilitySearchKey::Link: {</span>
<span class="line-added">+         bool isLink = axObject-&gt;isLink();</span>
<span class="line-added">+ #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">+         if (!isLink)</span>
<span class="line-added">+             isLink = axObject-&gt;isDescendantOfRole(AccessibilityRole::WebCoreLink);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         return isLink;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case AccessibilitySearchKey::List:</span>
<span class="line-added">+         return axObject-&gt;isList();</span>
<span class="line-added">+     case AccessibilitySearchKey::LiveRegion:</span>
<span class="line-added">+         return axObject-&gt;supportsLiveRegion();</span>
<span class="line-added">+     case AccessibilitySearchKey::MisspelledWord:</span>
<span class="line-added">+         return axObject-&gt;hasMisspelling();</span>
<span class="line-added">+     case AccessibilitySearchKey::Outline:</span>
<span class="line-added">+         return axObject-&gt;isTree();</span>
<span class="line-added">+     case AccessibilitySearchKey::PlainText:</span>
<span class="line-added">+         return axObject-&gt;hasPlainText();</span>
<span class="line-added">+     case AccessibilitySearchKey::RadioGroup:</span>
<span class="line-added">+         return axObject-&gt;isRadioGroup();</span>
<span class="line-added">+     case AccessibilitySearchKey::SameType:</span>
<span class="line-added">+         return criteria.startObject</span>
<span class="line-added">+             &amp;&amp; axObject-&gt;roleValue() == criteria.startObject-&gt;roleValue();</span>
<span class="line-added">+     case AccessibilitySearchKey::StaticText:</span>
<span class="line-added">+         return axObject-&gt;isStaticText();</span>
<span class="line-added">+     case AccessibilitySearchKey::StyleChange:</span>
<span class="line-added">+         return criteria.startObject</span>
<span class="line-added">+             &amp;&amp; !axObject-&gt;hasSameStyle(criteria.startObject-&gt;renderer());</span>
<span class="line-added">+     case AccessibilitySearchKey::TableSameLevel:</span>
<span class="line-added">+         return criteria.startObject</span>
<span class="line-added">+             &amp;&amp; is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility()</span>
<span class="line-added">+             &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).tableLevel() == criteria.startObject-&gt;tableLevel();</span>
<span class="line-added">+     case AccessibilitySearchKey::Table:</span>
<span class="line-added">+         return is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility();</span>
<span class="line-added">+     case AccessibilitySearchKey::TextField:</span>
<span class="line-added">+         return axObject-&gt;isTextControl();</span>
<span class="line-added">+     case AccessibilitySearchKey::Underline:</span>
<span class="line-added">+         return axObject-&gt;hasUnderline();</span>
<span class="line-added">+     case AccessibilitySearchKey::UnvisitedLink:</span>
<span class="line-added">+         return axObject-&gt;isUnvisited();</span>
<span class="line-added">+     case AccessibilitySearchKey::VisitedLink:</span>
<span class="line-added">+         return axObject-&gt;isVisited();</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool isAccessibilityObjectSearchMatch(AXCoreObject* axObject, AccessibilitySearchCriteria const&amp; criteria)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!axObject)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     size_t length = criteria.searchKeys.size();</span>
<span class="line-added">+     for (size_t i = 0; i &lt; length; ++i) {</span>
<span class="line-added">+         if (isAccessibilityObjectSearchMatchAtIndex(axObject, criteria, i)) {</span>
<span class="line-added">+             if (criteria.visibleOnly &amp;&amp; !axObject-&gt;isOnScreen())</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool isAccessibilityTextSearchMatch(AXCoreObject* axObject, AccessibilitySearchCriteria const&amp; criteria)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!axObject)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     return axObject-&gt;containsText(criteria.searchText);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool objectMatchesSearchCriteriaWithResultLimit(AXCoreObject* object, AccessibilitySearchCriteria const&amp; criteria, AXCoreObject::AccessibilityChildrenVector&amp; results)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (isAccessibilityObjectSearchMatch(object, criteria) &amp;&amp; isAccessibilityTextSearchMatch(object, criteria)) {</span>
<span class="line-added">+         results.append(object);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Enough results were found to stop searching.</span>
<span class="line-added">+         if (results.size() &gt;= criteria.resultsLimit)</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void findMatchingObjects(AccessibilitySearchCriteria const&amp; criteria, AXCoreObject::AccessibilityChildrenVector&amp; results)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // This search algorithm only searches the elements before/after the starting object.</span>
<span class="line-added">+     // It does this by stepping up the parent chain and at each level doing a DFS.</span>
<span class="line-added">+ </span>
<span class="line-added">+     // If there&#39;s no start object, it means we want to search everything.</span>
<span class="line-added">+     AXCoreObject* startObject = criteria.startObject;</span>
<span class="line-added">+     if (!startObject)</span>
<span class="line-added">+         startObject = criteria.anchorObject;</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool isForward = criteria.searchDirection == AccessibilitySearchDirection::Next;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The first iteration of the outer loop will examine the children of the start object for matches. However, when</span>
<span class="line-added">+     // iterating backwards, the start object children should not be considered, so the loop is skipped ahead. We make an</span>
<span class="line-added">+     // exception when no start object was specified because we want to search everything regardless of search direction.</span>
<span class="line-added">+     AXCoreObject* previousObject = nullptr;</span>
<span class="line-added">+     if (!isForward &amp;&amp; startObject != criteria.anchorObject) {</span>
<span class="line-added">+         previousObject = startObject;</span>
<span class="line-added">+         startObject = startObject-&gt;parentObjectUnignored();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The outer loop steps up the parent chain each time (unignored is important here because otherwise elements would be searched twice)</span>
<span class="line-added">+     for (auto* stopSearchElement = criteria.anchorObject-&gt;parentObjectUnignored(); startObject &amp;&amp; startObject != stopSearchElement; startObject = startObject-&gt;parentObjectUnignored()) {</span>
<span class="line-added">+         // Only append the children after/before the previous element, so that the search does not check elements that are</span>
<span class="line-added">+         // already behind/ahead of start element.</span>
<span class="line-added">+         AXCoreObject::AccessibilityChildrenVector searchStack;</span>
<span class="line-added">+         if (!criteria.immediateDescendantsOnly || startObject == criteria.anchorObject)</span>
<span class="line-added">+             appendChildrenToArray(startObject, isForward, previousObject, searchStack);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // This now does a DFS at the current level of the parent.</span>
<span class="line-added">+         while (!searchStack.isEmpty()) {</span>
<span class="line-added">+             AXCoreObject* searchObject = searchStack.last().get();</span>
<span class="line-added">+             searchStack.removeLast();</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (objectMatchesSearchCriteriaWithResultLimit(searchObject, criteria, results))</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (!criteria.immediateDescendantsOnly)</span>
<span class="line-added">+                 appendChildrenToArray(searchObject, isForward, 0, searchStack);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (results.size() &gt;= criteria.resultsLimit)</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // When moving backwards, the parent object needs to be checked, because technically it&#39;s &quot;before&quot; the starting element.</span>
<span class="line-added">+         if (!isForward &amp;&amp; startObject != criteria.anchorObject &amp;&amp; objectMatchesSearchCriteriaWithResultLimit(startObject, criteria, results))</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         previousObject = startObject;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ } // namespace Accessibility</span>
<span class="line-added">+ </span>
  } // namespace WebCore
</pre>
<center><a href="AccessibilityNodeObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
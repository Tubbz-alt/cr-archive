<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSSourceCode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSString.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 62,15 ***</span>
      ASSERT(string-&gt;length() == m_length);
      m_strings.clear();
      m_strings.append(string);
  }
  
<span class="line-removed">- void JSString::destroy(JSCell* cell)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     static_cast&lt;JSString*&gt;(cell)-&gt;JSString::~JSString();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void JSString::dumpToStream(const JSCell* cell, PrintStream&amp; out)
  {
      VM&amp; vm = cell-&gt;vm();
      const JSString* thisObject = jsCast&lt;const JSString*&gt;(cell);
      out.printf(&quot;&lt;%p, %s, [%u], &quot;, thisObject, thisObject-&gt;className(vm), thisObject-&gt;length());
<span class="line-new-header">--- 62,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,17 ***</span>
          }
      }
      out.printf(&quot;&gt;&quot;);
  }
  
<span class="line-modified">! bool JSString::equalSlowCase(ExecState* exec, JSString* other) const</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     String str1 = value(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!     String str2 = other-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
      return WTF::equal(*str1.impl(), *str2.impl());
  }
  
  size_t JSString::estimatedSize(JSCell* cell, VM&amp; vm)
<span class="line-new-header">--- 84,17 ---</span>
          }
      }
      out.printf(&quot;&gt;&quot;);
  }
  
<span class="line-modified">! bool JSString::equalSlowCase(JSGlobalObject* globalObject, JSString* other) const</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     String str1 = value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!     String str2 = other-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
      return WTF::equal(*str1.impl(), *str2.impl());
  }
  
  size_t JSString::estimatedSize(JSCell* cell, VM&amp; vm)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 147,62 ***</span>
      }
      if (StringImpl* impl = bitwise_cast&lt;StringImpl*&gt;(pointer))
          visitor.reportExtraMemoryVisited(impl-&gt;costDuringGC());
  }
  
<span class="line-modified">! static const unsigned maxLengthForOnStackResolve = 2048;</span>
  
  void JSRopeString::resolveRopeInternal8(LChar* buffer) const
  {
      if (isSubstring()) {
          StringImpl::copyCharacters(buffer, substringBase()-&gt;valueInternal().characters8() + substringOffset(), length());
          return;
      }
  
<span class="line-modified">!     resolveRopeInternal8NoSubstring(buffer);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JSRopeString::resolveRopeInternal8NoSubstring(LChar* buffer) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {</span>
<span class="line-removed">-         if (fiber(i)-&gt;isRope()) {</span>
<span class="line-removed">-             resolveRopeSlowCase8(buffer);</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     LChar* position = buffer;</span>
<span class="line-removed">-     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {</span>
<span class="line-removed">-         const StringImpl&amp; fiberString = *fiber(i)-&gt;valueInternal().impl();</span>
<span class="line-removed">-         unsigned length = fiberString.length();</span>
<span class="line-removed">-         StringImpl::copyCharacters(position, fiberString.characters8(), length);</span>
<span class="line-removed">-         position += length;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     ASSERT((buffer + length()) == position);</span>
  }
  
  void JSRopeString::resolveRopeInternal16(UChar* buffer) const
  {
      if (isSubstring()) {
          StringImpl::copyCharacters(
              buffer, substringBase()-&gt;valueInternal().characters16() + substringOffset(), length());
          return;
      }
  
<span class="line-modified">!     resolveRopeInternal16NoSubstring(buffer);</span>
  }
  
<span class="line-modified">! void JSRopeString::resolveRopeInternal16NoSubstring(UChar* buffer) const</span>
  {
      for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {
          if (fiber(i)-&gt;isRope()) {
              resolveRopeSlowCase(buffer);
              return;
          }
      }
  
<span class="line-modified">!     UChar* position = buffer;</span>
      for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {
          const StringImpl&amp; fiberString = *fiber(i)-&gt;valueInternal().impl();
          unsigned length = fiberString.length();
          if (fiberString.is8Bit())
              StringImpl::copyCharacters(position, fiberString.characters8(), length);
<span class="line-new-header">--- 142,44 ---</span>
      }
      if (StringImpl* impl = bitwise_cast&lt;StringImpl*&gt;(pointer))
          visitor.reportExtraMemoryVisited(impl-&gt;costDuringGC());
  }
  
<span class="line-modified">! static constexpr unsigned maxLengthForOnStackResolve = 2048;</span>
  
  void JSRopeString::resolveRopeInternal8(LChar* buffer) const
  {
      if (isSubstring()) {
          StringImpl::copyCharacters(buffer, substringBase()-&gt;valueInternal().characters8() + substringOffset(), length());
          return;
      }
  
<span class="line-modified">!     resolveRopeInternalNoSubstring(buffer);</span>
  }
  
  void JSRopeString::resolveRopeInternal16(UChar* buffer) const
  {
      if (isSubstring()) {
          StringImpl::copyCharacters(
              buffer, substringBase()-&gt;valueInternal().characters16() + substringOffset(), length());
          return;
      }
  
<span class="line-modified">!     resolveRopeInternalNoSubstring(buffer);</span>
  }
  
<span class="line-modified">! template&lt;typename CharacterType&gt;</span>
<span class="line-added">+ void JSRopeString::resolveRopeInternalNoSubstring(CharacterType* buffer) const</span>
  {
      for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {
          if (fiber(i)-&gt;isRope()) {
              resolveRopeSlowCase(buffer);
              return;
          }
      }
  
<span class="line-modified">!     CharacterType* position = buffer;</span>
      for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {
          const StringImpl&amp; fiberString = *fiber(i)-&gt;valueInternal().impl();
          unsigned length = fiberString.length();
          if (fiberString.is8Bit())
              StringImpl::copyCharacters(position, fiberString.characters8(), length);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 211,18 ***</span>
          position += length;
      }
      ASSERT((buffer + length()) == position);
  }
  
<span class="line-modified">! AtomString JSRopeString::resolveRopeToAtomString(ExecState* exec) const</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (length() &gt; maxLengthForOnStackResolve) {
          scope.release();
<span class="line-modified">!         return resolveRopeWithFunction(exec, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
              return AtomStringImpl::add(newImpl.ptr());
          });
      }
  
      if (is8Bit()) {
<span class="line-new-header">--- 188,18 ---</span>
          position += length;
      }
      ASSERT((buffer + length()) == position);
  }
  
<span class="line-modified">! AtomString JSRopeString::resolveRopeToAtomString(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (length() &gt; maxLengthForOnStackResolve) {
          scope.release();
<span class="line-modified">!         return resolveRopeWithFunction(globalObject, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
              return AtomStringImpl::add(newImpl.ptr());
          });
      }
  
      if (is8Bit()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 251,18 ***</span>
      static_assert(sizeof(String) == sizeof(RefPtr&lt;StringImpl&gt;), &quot;JSString&#39;s String initialization must be done in one pointer move.&quot;);
      // We do not clear the trailing fibers and length information (fiber1 and fiber2) because we could be reading the length concurrently.
      ASSERT(!JSString::isRope());
  }
  
<span class="line-modified">! RefPtr&lt;AtomStringImpl&gt; JSRopeString::resolveRopeToExistingAtomString(ExecState* exec) const</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (length() &gt; maxLengthForOnStackResolve) {
          RefPtr&lt;AtomStringImpl&gt; existingAtomString;
<span class="line-modified">!         resolveRopeWithFunction(exec, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) -&gt; Ref&lt;StringImpl&gt; {</span>
              existingAtomString = AtomStringImpl::lookUp(newImpl.ptr());
              if (existingAtomString)
                  return makeRef(*existingAtomString);
              return WTFMove(newImpl);
          });
<span class="line-new-header">--- 228,18 ---</span>
      static_assert(sizeof(String) == sizeof(RefPtr&lt;StringImpl&gt;), &quot;JSString&#39;s String initialization must be done in one pointer move.&quot;);
      // We do not clear the trailing fibers and length information (fiber1 and fiber2) because we could be reading the length concurrently.
      ASSERT(!JSString::isRope());
  }
  
<span class="line-modified">! RefPtr&lt;AtomStringImpl&gt; JSRopeString::resolveRopeToExistingAtomString(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (length() &gt; maxLengthForOnStackResolve) {
          RefPtr&lt;AtomStringImpl&gt; existingAtomString;
<span class="line-modified">!         resolveRopeWithFunction(globalObject, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) -&gt; Ref&lt;StringImpl&gt; {</span>
              existingAtomString = AtomStringImpl::lookUp(newImpl.ptr());
              if (existingAtomString)
                  return makeRef(*existingAtomString);
              return WTFMove(newImpl);
          });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 288,11 ***</span>
  
      return nullptr;
  }
  
  template&lt;typename Function&gt;
<span class="line-modified">! const String&amp; JSRopeString::resolveRopeWithFunction(ExecState* nullOrExecForOOM, Function&amp;&amp; function) const</span>
  {
      ASSERT(isRope());
  
      VM&amp; vm = this-&gt;vm();
      if (isSubstring()) {
<span class="line-new-header">--- 265,11 ---</span>
  
      return nullptr;
  }
  
  template&lt;typename Function&gt;
<span class="line-modified">! const String&amp; JSRopeString::resolveRopeWithFunction(JSGlobalObject* nullOrGlobalObjectForOOM, Function&amp;&amp; function) const</span>
  {
      ASSERT(isRope());
  
      VM&amp; vm = this-&gt;vm();
      if (isSubstring()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,36 ***</span>
  
      if (is8Bit()) {
          LChar* buffer;
          auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
          if (!newImpl) {
<span class="line-modified">!             outOfMemory(nullOrExecForOOM);</span>
              return nullString();
          }
          vm.heap.reportExtraMemoryAllocated(newImpl-&gt;cost());
  
<span class="line-modified">!         resolveRopeInternal8NoSubstring(buffer);</span>
          convertToNonRope(function(newImpl.releaseNonNull()));
          return valueInternal();
      }
  
      UChar* buffer;
      auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
      if (!newImpl) {
<span class="line-modified">!         outOfMemory(nullOrExecForOOM);</span>
          return nullString();
      }
      vm.heap.reportExtraMemoryAllocated(newImpl-&gt;cost());
  
<span class="line-modified">!     resolveRopeInternal16NoSubstring(buffer);</span>
      convertToNonRope(function(newImpl.releaseNonNull()));
      return valueInternal();
  }
  
<span class="line-modified">! const String&amp; JSRopeString::resolveRope(ExecState* nullOrExecForOOM) const</span>
  {
<span class="line-modified">!     return resolveRopeWithFunction(nullOrExecForOOM, [] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
          return WTFMove(newImpl);
      });
  }
  
  // Overview: These functions convert a JSString from holding a string in rope form
<span class="line-new-header">--- 281,36 ---</span>
  
      if (is8Bit()) {
          LChar* buffer;
          auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
          if (!newImpl) {
<span class="line-modified">!             outOfMemory(nullOrGlobalObjectForOOM);</span>
              return nullString();
          }
          vm.heap.reportExtraMemoryAllocated(newImpl-&gt;cost());
  
<span class="line-modified">!         resolveRopeInternalNoSubstring(buffer);</span>
          convertToNonRope(function(newImpl.releaseNonNull()));
          return valueInternal();
      }
  
      UChar* buffer;
      auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
      if (!newImpl) {
<span class="line-modified">!         outOfMemory(nullOrGlobalObjectForOOM);</span>
          return nullString();
      }
      vm.heap.reportExtraMemoryAllocated(newImpl-&gt;cost());
  
<span class="line-modified">!     resolveRopeInternalNoSubstring(buffer);</span>
      convertToNonRope(function(newImpl.releaseNonNull()));
      return valueInternal();
  }
  
<span class="line-modified">! const String&amp; JSRopeString::resolveRope(JSGlobalObject* nullOrGlobalObjectForOOM) const</span>
  {
<span class="line-modified">!     return resolveRopeWithFunction(nullOrGlobalObjectForOOM, [] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
          return WTFMove(newImpl);
      });
  }
  
  // Overview: These functions convert a JSString from holding a string in rope form
</pre>
<hr />
<pre>
<span class="line-old-header">*** 344,49 ***</span>
  // in this fashion should minimize work queue size.  (If we built the queue forwards
  // we would likely have to place all of the constituent StringImpls into the
  // Vector before performing any concatenation, but by working backwards we likely
  // only fill the queue with the number of substrings at any given level in a
  // rope-of-ropes.)
<span class="line-modified">! void JSRopeString::resolveRopeSlowCase8(LChar* buffer) const</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     LChar* position = buffer + length(); // We will be working backwards over the rope.</span>
<span class="line-removed">-     Vector&lt;JSString*, 32, UnsafeVectorOverflow&gt; workQueue; // Putting strings into a Vector is only OK because there are no GC points in this method.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i)</span>
<span class="line-removed">-         workQueue.append(fiber(i));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     while (!workQueue.isEmpty()) {</span>
<span class="line-removed">-         JSString* currentFiber = workQueue.last();</span>
<span class="line-removed">-         workQueue.removeLast();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         const LChar* characters;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (currentFiber-&gt;isRope()) {</span>
<span class="line-removed">-             JSRopeString* currentFiberAsRope = static_cast&lt;JSRopeString*&gt;(currentFiber);</span>
<span class="line-removed">-             if (!currentFiberAsRope-&gt;isSubstring()) {</span>
<span class="line-removed">-                 for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; currentFiberAsRope-&gt;fiber(i); ++i)</span>
<span class="line-removed">-                     workQueue.append(currentFiberAsRope-&gt;fiber(i));</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             ASSERT(!currentFiberAsRope-&gt;substringBase()-&gt;isRope());</span>
<span class="line-removed">-             characters =</span>
<span class="line-removed">-                 currentFiberAsRope-&gt;substringBase()-&gt;valueInternal().characters8() +</span>
<span class="line-removed">-                 currentFiberAsRope-&gt;substringOffset();</span>
<span class="line-removed">-         } else</span>
<span class="line-removed">-             characters = currentFiber-&gt;valueInternal().characters8();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         unsigned length = currentFiber-&gt;length();</span>
<span class="line-removed">-         position -= length;</span>
<span class="line-removed">-         StringImpl::copyCharacters(position, characters, length);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(buffer == position);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JSRopeString::resolveRopeSlowCase(UChar* buffer) const</span>
  {
<span class="line-modified">!     UChar* position = buffer + length(); // We will be working backwards over the rope.</span>
      Vector&lt;JSString*, 32, UnsafeVectorOverflow&gt; workQueue; // These strings are kept alive by the parent rope, so using a Vector is OK.
  
      for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i)
          workQueue.append(fiber(i));
  
<span class="line-new-header">--- 321,14 ---</span>
  // in this fashion should minimize work queue size.  (If we built the queue forwards
  // we would likely have to place all of the constituent StringImpls into the
  // Vector before performing any concatenation, but by working backwards we likely
  // only fill the queue with the number of substrings at any given level in a
  // rope-of-ropes.)
<span class="line-modified">! template&lt;typename CharacterType&gt;</span>
<span class="line-modified">! void JSRopeString::resolveRopeSlowCase(CharacterType* buffer) const</span>
  {
<span class="line-modified">!     CharacterType* position = buffer + length(); // We will be working backwards over the rope.</span>
      Vector&lt;JSString*, 32, UnsafeVectorOverflow&gt; workQueue; // These strings are kept alive by the parent rope, so using a Vector is OK.
  
      for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i)
          workQueue.append(fiber(i));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,41 ***</span>
      }
  
      ASSERT(buffer == position);
  }
  
<span class="line-modified">! void JSRopeString::outOfMemory(ExecState* nullOrExecForOOM) const</span>
  {
      ASSERT(isRope());
<span class="line-modified">!     if (nullOrExecForOOM) {</span>
<span class="line-modified">!         VM&amp; vm = nullOrExecForOOM-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(nullOrExecForOOM, scope);</span>
      }
  }
  
<span class="line-modified">! JSValue JSString::toPrimitive(ExecState*, PreferredPrimitiveType) const</span>
  {
      return const_cast&lt;JSString*&gt;(this);
  }
  
<span class="line-modified">! bool JSString::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; result) const</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     StringView view = unsafeView(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
      result = this;
      number = jsToNumber(view);
      return false;
  }
  
<span class="line-modified">! double JSString::toNumber(ExecState* exec) const</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     StringView view = unsafeView(exec);</span>
      RETURN_IF_EXCEPTION(scope, 0);
      return jsToNumber(view);
  }
  
  inline StringObject* StringObject::create(VM&amp; vm, JSGlobalObject* globalObject, JSString* string)
<span class="line-new-header">--- 366,41 ---</span>
      }
  
      ASSERT(buffer == position);
  }
  
<span class="line-modified">! void JSRopeString::outOfMemory(JSGlobalObject* nullOrGlobalObjectForOOM) const</span>
  {
      ASSERT(isRope());
<span class="line-modified">!     if (nullOrGlobalObjectForOOM) {</span>
<span class="line-modified">!         VM&amp; vm = nullOrGlobalObjectForOOM-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(nullOrGlobalObjectForOOM, scope);</span>
      }
  }
  
<span class="line-modified">! JSValue JSString::toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const</span>
  {
      return const_cast&lt;JSString*&gt;(this);
  }
  
<span class="line-modified">! bool JSString::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; result) const</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     StringView view = unsafeView(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
      result = this;
      number = jsToNumber(view);
      return false;
  }
  
<span class="line-modified">! double JSString::toNumber(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     StringView view = unsafeView(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, 0);
      return jsToNumber(view);
  }
  
  inline StringObject* StringObject::create(VM&amp; vm, JSGlobalObject* globalObject, JSString* string)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 466,33 ***</span>
      StringObject* object = new (NotNull, allocateCell&lt;StringObject&gt;(vm.heap)) StringObject(vm, globalObject-&gt;stringObjectStructure());
      object-&gt;finishCreation(vm, string);
      return object;
  }
  
<span class="line-modified">! JSObject* JSString::toObject(ExecState* exec, JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     return StringObject::create(exec-&gt;vm(), globalObject, const_cast&lt;JSString*&gt;(this));</span>
  }
  
<span class="line-modified">! JSValue JSString::toThis(JSCell* cell, ExecState* exec, ECMAMode ecmaMode)</span>
  {
      if (ecmaMode == StrictMode)
          return cell;
<span class="line-modified">!     return StringObject::create(exec-&gt;vm(), exec-&gt;lexicalGlobalObject(), asString(cell));</span>
  }
  
<span class="line-modified">! bool JSString::getStringPropertyDescriptor(ExecState* exec, PropertyName propertyName, PropertyDescriptor&amp; descriptor)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      if (propertyName == vm.propertyNames-&gt;length) {
          descriptor.setDescriptor(jsNumber(length()), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
          return true;
      }
  
      Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
      if (index &amp;&amp; index.value() &lt; length()) {
<span class="line-modified">!         descriptor.setDescriptor(getIndex(exec, index.value()), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);</span>
          return true;
      }
  
      return false;
  }
<span class="line-new-header">--- 408,33 ---</span>
      StringObject* object = new (NotNull, allocateCell&lt;StringObject&gt;(vm.heap)) StringObject(vm, globalObject-&gt;stringObjectStructure());
      object-&gt;finishCreation(vm, string);
      return object;
  }
  
<span class="line-modified">! JSObject* JSString::toObject(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     return StringObject::create(globalObject-&gt;vm(), globalObject, const_cast&lt;JSString*&gt;(this));</span>
  }
  
<span class="line-modified">! JSValue JSString::toThis(JSCell* cell, JSGlobalObject* globalObject, ECMAMode ecmaMode)</span>
  {
      if (ecmaMode == StrictMode)
          return cell;
<span class="line-modified">!     return StringObject::create(globalObject-&gt;vm(), globalObject, asString(cell));</span>
  }
  
<span class="line-modified">! bool JSString::getStringPropertyDescriptor(JSGlobalObject* globalObject, PropertyName propertyName, PropertyDescriptor&amp; descriptor)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      if (propertyName == vm.propertyNames-&gt;length) {
          descriptor.setDescriptor(jsNumber(length()), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
          return true;
      }
  
      Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
      if (index &amp;&amp; index.value() &lt; length()) {
<span class="line-modified">!         descriptor.setDescriptor(getIndex(globalObject, index.value()), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);</span>
          return true;
      }
  
      return false;
  }
</pre>
<center><a href="JSSourceCode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSString.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLEntryPointScaffolding.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLMetalCodeGenerator.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -61,11 +61,61 @@</span>
          stringBuilder.append(typeNamer.mangledNameForType(*functionDeclaration.parameters()[i]-&gt;type()));
      }
      stringBuilder.append(&quot;);\n&quot;);
  }
  
<span class="udiff-line-added">+ struct Variable {</span>
<span class="udiff-line-added">+     MangledVariableName name;</span>
<span class="udiff-line-added">+     MangledTypeName type;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  class FunctionDefinitionWriter : public Visitor {
<span class="udiff-line-added">+     class HoistedVariableCollector : public Visitor {</span>
<span class="udiff-line-added">+         public:</span>
<span class="udiff-line-added">+         HoistedVariableCollector(FunctionDefinitionWriter&amp; functionDefinitionWriter)</span>
<span class="udiff-line-added">+             : functionDefinitionWriter(functionDefinitionWriter)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         void visit(AST::CallExpression&amp; callExpression) override</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             Vector&lt;Variable&gt; variables;</span>
<span class="udiff-line-added">+             size_t size = callExpression.arguments().size();</span>
<span class="udiff-line-added">+             bool isVoid = matches(callExpression.resolvedType(), functionDefinitionWriter.m_intrinsics.voidType());</span>
<span class="udiff-line-added">+             if (!isVoid)</span>
<span class="udiff-line-added">+                 ++size;</span>
<span class="udiff-line-added">+             variables.reserveInitialCapacity(size);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             for (auto&amp; argument : callExpression.arguments()) {</span>
<span class="udiff-line-added">+                 auto type = functionDefinitionWriter.m_typeNamer.mangledNameForType(argument-&gt;resolvedType());</span>
<span class="udiff-line-added">+                 auto name = functionDefinitionWriter.generateNextVariableName();</span>
<span class="udiff-line-added">+                 variables.uncheckedAppend(Variable { name, type });</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (!isVoid)</span>
<span class="udiff-line-added">+                 variables.uncheckedAppend(Variable { functionDefinitionWriter.generateNextVariableName(), functionDefinitionWriter.m_typeNamer.mangledNameForType(callExpression.resolvedType()) });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             toHoist.add(&amp;callExpression, WTFMove(variables));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             Visitor::visit(callExpression);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         void visit(AST::ReadModifyWriteExpression&amp; readModifyWrite) override</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             Vector&lt;Variable&gt; variables;</span>
<span class="udiff-line-added">+             variables.append(Variable { functionDefinitionWriter.generateNextVariableName(), functionDefinitionWriter.m_typeNamer.mangledNameForType(*readModifyWrite.oldValue().type()) });</span>
<span class="udiff-line-added">+             variables.append(Variable { functionDefinitionWriter.generateNextVariableName(), functionDefinitionWriter.m_typeNamer.mangledNameForType(*readModifyWrite.newValue().type()) });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             toHoist.add(&amp;readModifyWrite, WTFMove(variables));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             Visitor::visit(readModifyWrite);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         FunctionDefinitionWriter&amp; functionDefinitionWriter;</span>
<span class="udiff-line-added">+         HashMap&lt;AST::Expression*, Vector&lt;Variable&gt;&gt; toHoist;</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
  public:
      FunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, Layout&amp; layout)
          : m_stringBuilder(stringBuilder)
          , m_intrinsics(intrinsics)
          , m_typeNamer(typeNamer)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98,18 +148,16 @@</span>
      void visit(AST::VariableDeclarationsStatement&amp;) override;
      void visit(AST::WhileLoop&amp;) override;
      void visit(AST::IntegerLiteral&amp;) override;
      void visit(AST::UnsignedIntegerLiteral&amp;) override;
      void visit(AST::FloatLiteral&amp;) override;
<span class="udiff-line-removed">-     void visit(AST::NullLiteral&amp;) override;</span>
      void visit(AST::BooleanLiteral&amp;) override;
      void visit(AST::EnumerationMemberLiteral&amp;) override;
      void visit(AST::Expression&amp;) override;
<span class="udiff-line-removed">-     void visit(AST::DotExpression&amp;) override;</span>
      void visit(AST::GlobalVariableReference&amp;) override;
<span class="udiff-line-added">+     void visit(AST::DotExpression&amp;) override;</span>
      void visit(AST::IndexExpression&amp;) override;
<span class="udiff-line-removed">-     void visit(AST::PropertyAccessExpression&amp;) override;</span>
      void visit(AST::VariableDeclaration&amp;) override;
      void visit(AST::AssignmentExpression&amp;) override;
      void visit(AST::CallExpression&amp;) override;
      void visit(AST::CommaExpression&amp;) override;
      void visit(AST::DereferenceExpression&amp;) override;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -129,69 +177,10 @@</span>
  
      void emitConstantExpressionString(AST::ConstantExpression&amp;);
  
      MangledVariableName generateNextVariableName() { return { m_variableCount++ }; }
  
<span class="udiff-line-removed">-     enum class Nullability : uint8_t {</span>
<span class="udiff-line-removed">-         NotNull,</span>
<span class="udiff-line-removed">-         CanBeNull</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     struct StackItem {</span>
<span class="udiff-line-removed">-         MangledVariableName value;</span>
<span class="udiff-line-removed">-         MangledVariableName leftValue;</span>
<span class="udiff-line-removed">-         Nullability valueNullability;</span>
<span class="udiff-line-removed">-         Nullability leftValueNullability;</span>
<span class="udiff-line-removed">-         std::function&lt;MangledVariableName()&gt; generateLeftValue;</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     struct StackValue {</span>
<span class="udiff-line-removed">-         MangledVariableName value;</span>
<span class="udiff-line-removed">-         Nullability nullability;</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // This is the important data flow step where we can take the nullability of an lvalue</span>
<span class="udiff-line-removed">-     // and transfer it into the nullability of an rvalue. This is conveyed in MakePointerExpression</span>
<span class="udiff-line-removed">-     // and DereferenceExpression. MakePointerExpression will try to produce rvalues which are</span>
<span class="udiff-line-removed">-     // non-null, and DereferenceExpression will take a non-null rvalue and try to produce</span>
<span class="udiff-line-removed">-     // a non-null lvalue.</span>
<span class="udiff-line-removed">-     void appendRightValueWithNullability(AST::Expression&amp;, MangledVariableName value, Nullability nullability)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         m_stack.append({ WTFMove(value), { }, nullability, Nullability::CanBeNull, { } });</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     void appendRightValue(AST::Expression&amp; expression, MangledVariableName value)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         appendRightValueWithNullability(expression, WTFMove(value), Nullability::CanBeNull);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     void appendLeftValue(AST::Expression&amp; expression, MangledVariableName value, MangledVariableName leftValue, Nullability nullability, std::function&lt;MangledVariableName()&gt; generateLeftValue = { })</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         ASSERT_UNUSED(expression, expression.typeAnnotation().leftAddressSpace());</span>
<span class="udiff-line-removed">-         ASSERT(leftValue || generateLeftValue);</span>
<span class="udiff-line-removed">-         m_stack.append({ WTFMove(value), WTFMove(leftValue), Nullability::CanBeNull, nullability, WTFMove(generateLeftValue) });</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     MangledVariableName takeLastValue()</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         return m_stack.takeLast().value;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     StackValue takeLastValueAndNullability()</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         auto last = m_stack.takeLast();</span>
<span class="udiff-line-removed">-         return { last.value, last.valueNullability };</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     StackValue takeLastLeftValue()</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         auto last = m_stack.takeLast();</span>
<span class="udiff-line-removed">-         if (!last.leftValue)</span>
<span class="udiff-line-removed">-             last.leftValue = last.generateLeftValue();</span>
<span class="udiff-line-removed">-         return { last.leftValue, last.leftValueNullability };</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      enum class BreakContext {
          Loop,
          Switch
      };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -201,25 +190,39 @@</span>
      Intrinsics&amp; m_intrinsics;
      TypeNamer&amp; m_typeNamer;
      HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; m_functionMapping;
      HashMap&lt;AST::VariableDeclaration*, MangledVariableName&gt; m_variableMapping;
  
<span class="udiff-line-removed">-     Vector&lt;StackItem&gt; m_stack;</span>
      std::unique_ptr&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;
      Layout&amp; m_layout;
      unsigned m_variableCount { 0 };
      Optional&lt;MangledVariableName&gt; m_breakOutOfCurrentLoopEarlyVariable;
      Indentation&lt;4&gt; m_indent { 0 };
<span class="udiff-line-added">+     HashMap&lt;AST::Expression*, Vector&lt;Variable&gt;&gt; m_hoistedVariables;</span>
  };
  
  void FunctionDefinitionWriter::visit(AST::NativeFunctionDeclaration&amp;)
  {
      // We inline native function calls.
  }
  
  void FunctionDefinitionWriter::visit(AST::FunctionDefinition&amp; functionDefinition)
  {
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         HoistedVariableCollector collector(*this);</span>
<span class="udiff-line-added">+         collector.Visitor::visit(functionDefinition);</span>
<span class="udiff-line-added">+         m_hoistedVariables = WTFMove(collector.toHoist);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto defineHoistedVariables = [&amp;] {</span>
<span class="udiff-line-added">+         for (const auto&amp; vector : m_hoistedVariables.values()) {</span>
<span class="udiff-line-added">+             for (auto variable : vector)</span>
<span class="udiff-line-added">+                 m_stringBuilder.append(m_indent, variable.type, &#39; &#39;, variable.name, &quot;;\n&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
      auto iterator = m_functionMapping.find(&amp;functionDefinition);
      ASSERT(iterator != m_functionMapping.end());
      if (functionDefinition.entryPointType()) {
          auto entryPointScaffolding = createEntryPointScaffolding(functionDefinition);
          if (!entryPointScaffolding)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -236,31 +239,38 @@</span>
  
              for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
                  auto addResult = m_variableMapping.add(&amp;functionDefinition.parameters()[i], m_entryPointScaffolding-&gt;parameterVariables()[i]);
                  ASSERT_UNUSED(addResult, addResult.isNewEntry);
              }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             defineHoistedVariables();</span>
<span class="udiff-line-added">+ </span>
              checkErrorAndVisit(functionDefinition.block());
<span class="udiff-line-removed">-             ASSERT(m_stack.isEmpty());</span>
          }
          m_stringBuilder.append(&quot;}\n\n&quot;);
  
          m_entryPointScaffolding = nullptr;
      } else {
          ASSERT(m_entryPointScaffolding == nullptr);
          m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
          for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
<span class="udiff-line-removed">-             auto&amp; parameter = functionDefinition.parameters()[i];</span>
              if (i)
                  m_stringBuilder.append(&quot;, &quot;);
<span class="udiff-line-added">+             auto&amp; parameter = functionDefinition.parameters()[i];</span>
              auto parameterName = generateNextVariableName();
              auto addResult = m_variableMapping.add(&amp;parameter, parameterName);
              ASSERT_UNUSED(addResult, addResult.isNewEntry);
              m_stringBuilder.append(m_typeNamer.mangledNameForType(*parameter-&gt;type()), &#39; &#39;, parameterName);
          }
          m_stringBuilder.append(&quot;)\n&quot;);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         m_stringBuilder.append(&quot;{\n&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         defineHoistedVariables();</span>
<span class="udiff-line-added">+ </span>
          checkErrorAndVisit(functionDefinition.block());
<span class="udiff-line-modified-removed">-         ASSERT(m_stack.isEmpty());</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(&quot;}\n&quot;);</span>
          m_stringBuilder.append(&#39;\n&#39;);
      }
  }
  
  void FunctionDefinitionWriter::visit(AST::FunctionDeclaration&amp;)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -307,12 +317,13 @@</span>
      m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
  }
  
  void FunctionDefinitionWriter::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)
  {
<span class="udiff-line-added">+     m_stringBuilder.append(m_indent);</span>
      checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());
<span class="udiff-line-modified-removed">-     takeLastValue(); // The statement is already effectful, so we don&#39;t need to do anything with the result.</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&quot;;\n&quot;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::Fallthrough&amp;)
  {
      m_stringBuilder.append(m_indent, &quot;[[clang::fallthrough]];\n&quot;); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195808 Make sure this is okay. Alternatively, we could do nothing and just return here instead.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -328,14 +339,16 @@</span>
      );
      {
          IndentationScope whileScope(m_indent);
  
          if (loopConditionLocation == LoopConditionLocation::BeforeBody &amp;&amp; conditionExpression) {
<span class="udiff-line-added">+             m_stringBuilder.append(</span>
<span class="udiff-line-added">+                 m_indent, &quot;if (!(&quot;);</span>
              checkErrorAndVisit(*conditionExpression);
              m_stringBuilder.append(
<span class="udiff-line-modified-removed">-                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,</span>
<span class="udiff-line-modified-removed">-                 m_indent, &quot;    break;\n&quot;);</span>
<span class="udiff-line-modified-added">+                 &quot;))\n&quot;,</span>
<span class="udiff-line-modified-added">+                 &quot;    break;\n&quot;);</span>
          }
  
          m_stringBuilder.append(m_indent, &quot;do {\n&quot;);
          SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Loop);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -348,21 +361,22 @@</span>
          m_stringBuilder.append(
              m_indent, &quot;if (&quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot;)\n&quot;,
              m_indent, &quot;    break;\n&quot;);
  
          if (increment) {
<span class="udiff-line-added">+             m_stringBuilder.append(&quot;(&quot;);</span>
              checkErrorAndVisit(*increment);
<span class="udiff-line-modified-removed">-             // Expression results get pushed to m_stack. We don&#39;t use the result</span>
<span class="udiff-line-removed">-             // of increment, so we dispense of that now.</span>
<span class="udiff-line-removed">-             takeLastValue();</span>
<span class="udiff-line-modified-added">+             m_stringBuilder.append(&quot;);\n&quot;);</span>
          }
  
          if (loopConditionLocation == LoopConditionLocation::AfterBody &amp;&amp; conditionExpression) {
<span class="udiff-line-added">+             m_stringBuilder.append(</span>
<span class="udiff-line-added">+                 m_indent, &quot;if (!(&quot;);</span>
              checkErrorAndVisit(*conditionExpression);
              m_stringBuilder.append(
<span class="udiff-line-modified-removed">-                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,</span>
<span class="udiff-line-modified-removed">-                 m_indent, &quot;    break;\n&quot;);</span>
<span class="udiff-line-modified-added">+                 &quot;))\n&quot;,</span>
<span class="udiff-line-modified-added">+                 &quot;    break;\n&quot;);</span>
          }
      }
  
      m_stringBuilder.append(m_indent, &quot;} \n&quot;);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -388,46 +402,54 @@</span>
      m_stringBuilder.append(m_indent, &quot;}\n&quot;);
  }
  
  void FunctionDefinitionWriter::visit(AST::IfStatement&amp; ifStatement)
  {
<span class="udiff-line-added">+     m_stringBuilder.append(m_indent, &quot;if (&quot;);</span>
      checkErrorAndVisit(ifStatement.conditional());
<span class="udiff-line-modified-removed">-     m_stringBuilder.append(m_indent, &quot;if (&quot;, takeLastValue(), &quot;) {\n&quot;);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&quot;) {\n&quot;);</span>
<span class="udiff-line-added">+ </span>
      {
          IndentationScope ifScope(m_indent);
          checkErrorAndVisit(ifStatement.body());
      }
<span class="udiff-line-added">+ </span>
      if (ifStatement.elseBody()) {
          m_stringBuilder.append(m_indent, &quot;} else {\n&quot;);
          {
              IndentationScope elseScope(m_indent);
              checkErrorAndVisit(*ifStatement.elseBody());
          }
      }
<span class="udiff-line-added">+ </span>
      m_stringBuilder.append(m_indent, &quot;}\n&quot;);
  }
  
  void FunctionDefinitionWriter::visit(AST::Return&amp; returnStatement)
  {
      if (returnStatement.value()) {
<span class="udiff-line-added">+         auto tempReturnName = generateNextVariableName();</span>
<span class="udiff-line-added">+         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(returnStatement.value()-&gt;resolvedType()), &#39; &#39;, tempReturnName, &quot; = &quot;);</span>
          checkErrorAndVisit(*returnStatement.value());
<span class="udiff-line-added">+         m_stringBuilder.append(&quot;;\n&quot;);</span>
  
          if (m_entryPointScaffolding) {
              auto variableName = generateNextVariableName();
<span class="udiff-line-modified-removed">-             m_entryPointScaffolding-&gt;emitPack(m_stringBuilder, takeLastValue(), variableName, m_indent);</span>
<span class="udiff-line-modified-added">+             m_entryPointScaffolding-&gt;emitPack(m_stringBuilder, tempReturnName, variableName, m_indent);</span>
              m_stringBuilder.append(m_indent, &quot;return &quot;, variableName, &quot;;\n&quot;);
          } else
<span class="udiff-line-modified-removed">-             m_stringBuilder.append(m_indent, &quot;return &quot;, takeLastValue(), &quot;;\n&quot;);</span>
<span class="udiff-line-modified-added">+             m_stringBuilder.append(m_indent, &quot;return &quot;, tempReturnName, &quot;;\n&quot;);</span>
      } else
          m_stringBuilder.append(m_indent, &quot;return;\n&quot;);
  }
  
  void FunctionDefinitionWriter::visit(AST::SwitchStatement&amp; switchStatement)
  {
<span class="udiff-line-added">+     m_stringBuilder.append(m_indent, &quot;switch (&quot;);</span>
      checkErrorAndVisit(switchStatement.value());
<span class="udiff-line-added">+     m_stringBuilder.append(&quot;) {&quot;);</span>
  
<span class="udiff-line-removed">-     m_stringBuilder.append(m_indent, &quot;switch (&quot;, takeLastValue(), &quot;) {&quot;);</span>
      {
          IndentationScope switchScope(m_indent);
          for (auto&amp; switchCase : switchStatement.switchCases())
              checkErrorAndVisit(switchCase);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -452,315 +474,327 @@</span>
      Visitor::visit(variableDeclarationsStatement);
  }
  
  void FunctionDefinitionWriter::visit(AST::IntegerLiteral&amp; integerLiteral)
  {
<span class="udiff-line-removed">-     auto variableName = generateNextVariableName();</span>
      auto mangledTypeName = m_typeNamer.mangledNameForType(integerLiteral.resolvedType());
<span class="udiff-line-modified-removed">-     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;);\n&quot;);</span>
<span class="udiff-line-removed">-     appendRightValue(integerLiteral, variableName);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;)&quot;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
  {
<span class="udiff-line-removed">-     auto variableName = generateNextVariableName();</span>
      auto mangledTypeName = m_typeNamer.mangledNameForType(unsignedIntegerLiteral.resolvedType());
<span class="udiff-line-modified-removed">-     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;);\n&quot;);</span>
<span class="udiff-line-removed">-     appendRightValue(unsignedIntegerLiteral, variableName);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;)&quot;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::FloatLiteral&amp; floatLiteral)
  {
<span class="udiff-line-removed">-     auto variableName = generateNextVariableName();</span>
      auto mangledTypeName = m_typeNamer.mangledNameForType(floatLiteral.resolvedType());
<span class="udiff-line-modified-removed">-     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;);\n&quot;);</span>
<span class="udiff-line-removed">-     appendRightValue(floatLiteral, variableName);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void FunctionDefinitionWriter::visit(AST::NullLiteral&amp; nullLiteral)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     auto&amp; unifyNode = nullLiteral.resolvedType().unifyNode();</span>
<span class="udiff-line-removed">-     auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="udiff-line-removed">-     bool isArrayReferenceType = is&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     auto variableName = generateNextVariableName();</span>
<span class="udiff-line-removed">-     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(nullLiteral.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;);</span>
<span class="udiff-line-removed">-     if (isArrayReferenceType)</span>
<span class="udiff-line-removed">-         m_stringBuilder.append(&quot;{ nullptr, 0 };\n&quot;);</span>
<span class="udiff-line-removed">-     else</span>
<span class="udiff-line-removed">-         m_stringBuilder.append(&quot;nullptr;\n&quot;);</span>
<span class="udiff-line-removed">-     appendRightValue(nullLiteral, variableName);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;)&quot;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::BooleanLiteral&amp; booleanLiteral)
  {
<span class="udiff-line-removed">-     auto variableName = generateNextVariableName();</span>
      auto mangledTypeName = m_typeNamer.mangledNameForType(booleanLiteral.resolvedType());
<span class="udiff-line-modified-removed">-     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;);\n&quot;);</span>
<span class="udiff-line-removed">-     appendRightValue(booleanLiteral, variableName);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;)&quot;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
  {
      ASSERT(enumerationMemberLiteral.enumerationDefinition());
      ASSERT(enumerationMemberLiteral.enumerationDefinition());
<span class="udiff-line-removed">-     auto variableName = generateNextVariableName();</span>
      auto mangledTypeName = m_typeNamer.mangledNameForType(enumerationMemberLiteral.resolvedType());
<span class="udiff-line-modified-removed">-     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, mangledTypeName, &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()), &quot;;\n&quot;);</span>
<span class="udiff-line-removed">-     appendRightValue(enumerationMemberLiteral, variableName);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(mangledTypeName, &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::Expression&amp; expression)
  {
      Visitor::visit(expression);
  }
  
<span class="udiff-line-removed">- void FunctionDefinitionWriter::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     // This should be lowered already.</span>
<span class="udiff-line-removed">-     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="udiff-line-removed">-     notImplemented();</span>
<span class="udiff-line-removed">-     appendRightValue(dotExpression, generateNextVariableName());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void FunctionDefinitionWriter::visit(AST::GlobalVariableReference&amp; globalVariableReference)
  {
<span class="udiff-line-modified-removed">-     auto valueName = generateNextVariableName();</span>
<span class="udiff-line-modified-removed">-     MangledTypeName mangledTypeName = m_typeNamer.mangledNameForType(globalVariableReference.resolvedType());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+     MangledStructureElementName mangledFieldName = m_typeNamer.mangledNameForStructureElement(globalVariableReference.structField());</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;(&#39;);</span>
      checkErrorAndVisit(globalVariableReference.base());
<span class="udiff-line-modified-removed">-     MangledVariableName structVariable = takeLastValue();</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&quot;)-&gt;&quot;, mangledFieldName);</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     MangledStructureElementName mangledFieldName = m_typeNamer.mangledNameForStructureElement(globalVariableReference.structField());</span>
<span class="udiff-line-modified-added">+ void FunctionDefinitionWriter::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto&amp; type = dotExpression.base().resolvedType().unifyNode();</span>
  
<span class="udiff-line-modified-removed">-     m_stringBuilder.append(</span>
<span class="udiff-line-modified-removed">-         m_indent, mangledTypeName, &#39; &#39;, valueName, &quot; = &quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);</span>
<span class="udiff-line-modified-added">+     if (is&lt;AST::StructureDefinition&gt;(type)) {</span>
<span class="udiff-line-modified-added">+         auto&amp; structureDefinition = downcast&lt;AST::StructureDefinition&gt;(type);</span>
<span class="udiff-line-added">+         auto* structureElement = structureDefinition.find(dotExpression.fieldName());</span>
<span class="udiff-line-added">+         ASSERT(structureElement);</span>
<span class="udiff-line-added">+         auto elementName = m_typeNamer.mangledNameForStructureElement(*structureElement);</span>
  
<span class="udiff-line-modified-removed">-     appendLeftValue(globalVariableReference, valueName, { }, Nullability::NotNull,</span>
<span class="udiff-line-modified-removed">-         [this, mangledTypeName, structVariable, mangledFieldName] {</span>
<span class="udiff-line-modified-removed">-             auto pointerName = generateNextVariableName();</span>
<span class="udiff-line-modified-removed">-             m_stringBuilder.append(</span>
<span class="udiff-line-modified-removed">-                 m_indent, &quot;thread &quot;, mangledTypeName, &quot;* &quot;, pointerName, &quot; = &amp;&quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);</span>
<span class="udiff-line-modified-removed">-             return pointerName;</span>
<span class="udiff-line-modified-removed">-         });</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(&#39;(&#39;);</span>
<span class="udiff-line-modified-added">+         checkErrorAndVisit(dotExpression.base());</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(&quot;).&quot;, elementName);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+         String elementName = dotExpression.fieldName();</span>
<span class="udiff-line-modified-added">+         if (elementName == &quot;length&quot; &amp;&amp; (is&lt;AST::ArrayReferenceType&gt;(type) || is&lt;AST::ArrayType&gt;(type) || (is&lt;AST::NativeTypeDeclaration&gt;(type) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(type).isVector()))) {</span>
<span class="udiff-line-modified-added">+             if (is&lt;AST::ArrayReferenceType&gt;(type)) {</span>
<span class="udiff-line-added">+                 m_stringBuilder.append(&#39;(&#39;);</span>
<span class="udiff-line-added">+                 checkErrorAndVisit(dotExpression.base());</span>
<span class="udiff-line-added">+                 m_stringBuilder.append(&quot;).length&quot;);</span>
<span class="udiff-line-added">+             } else if (is&lt;AST::ArrayType&gt;(type)) {</span>
<span class="udiff-line-added">+                 m_stringBuilder.append(&#39;(&#39;);</span>
<span class="udiff-line-added">+                 checkErrorAndVisit(dotExpression.base());</span>
<span class="udiff-line-added">+                 m_stringBuilder.append(&quot;, &quot;, downcast&lt;AST::ArrayType&gt;(type).numElements(), &quot;)&quot;);</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 m_stringBuilder.append(&#39;(&#39;);</span>
<span class="udiff-line-added">+                 checkErrorAndVisit(dotExpression.base());</span>
<span class="udiff-line-added">+                 m_stringBuilder.append(&quot;, &quot;, downcast&lt;AST::NativeTypeDeclaration&gt;(type).vectorSize(), &quot;)&quot;);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             m_stringBuilder.append(&#39;(&#39;);</span>
<span class="udiff-line-added">+             checkErrorAndVisit(dotExpression.base());</span>
<span class="udiff-line-added">+             m_stringBuilder.append(&quot;).&quot;, elementName);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::IndexExpression&amp; indexExpression)
  {
<span class="udiff-line-modified-removed">-     // This should be lowered already.</span>
<span class="udiff-line-modified-removed">-     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="udiff-line-modified-removed">-     notImplemented();</span>
<span class="udiff-line-modified-removed">-     appendRightValue(indexExpression, generateNextVariableName());</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- void FunctionDefinitionWriter::visit(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-modified-removed">-     // This should be lowered already.</span>
<span class="udiff-line-modified-removed">-     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="udiff-line-modified-removed">-     notImplemented();</span>
<span class="udiff-line-modified-removed">-     appendRightValue(propertyAccessExpression, generateNextVariableName());</span>
<span class="udiff-line-modified-added">+     auto&amp; type = indexExpression.base().resolvedType().unifyNode();</span>
<span class="udiff-line-modified-added">+     if (is&lt;AST::ArrayReferenceType&gt;(type)) {</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(&#39;(&#39;);</span>
<span class="udiff-line-modified-added">+         checkErrorAndVisit(indexExpression.base());</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(&quot;).pointer[(&quot;);</span>
<span class="udiff-line-modified-added">+         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(&quot;) &lt; (&quot;);</span>
<span class="udiff-line-modified-added">+         checkErrorAndVisit(indexExpression.base());</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(&quot;).length ? &quot;);</span>
<span class="udiff-line-modified-added">+         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(&quot; : 0]&quot;);</span>
<span class="udiff-line-modified-added">+     } else if (is&lt;AST::ArrayType&gt;(type)) {</span>
<span class="udiff-line-added">+         m_stringBuilder.append(&#39;(&#39;);</span>
<span class="udiff-line-added">+         checkErrorAndVisit(indexExpression.base());</span>
<span class="udiff-line-added">+         m_stringBuilder.append(&quot;).data()[(&quot;);</span>
<span class="udiff-line-added">+         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="udiff-line-added">+         m_stringBuilder.append(&quot;) &lt; &quot;, downcast&lt;AST::ArrayType&gt;(type).numElements(), &quot; ? &quot;);</span>
<span class="udiff-line-added">+         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="udiff-line-added">+         m_stringBuilder.append(&quot; : 0]&quot;);</span>
<span class="udiff-line-added">+     } else if (is&lt;AST::NativeTypeDeclaration&gt;(type)) {</span>
<span class="udiff-line-added">+         auto&amp; nativeType = downcast&lt;AST::NativeTypeDeclaration&gt;(type);</span>
<span class="udiff-line-added">+         unsigned size;</span>
<span class="udiff-line-added">+         if (nativeType.isMatrix())</span>
<span class="udiff-line-added">+             size = nativeType.numberOfMatrixColumns();</span>
<span class="udiff-line-added">+         else if (nativeType.isVector())</span>
<span class="udiff-line-added">+             size = nativeType.vectorSize();</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         m_stringBuilder.append(&#39;(&#39;);</span>
<span class="udiff-line-added">+         checkErrorAndVisit(indexExpression.base());</span>
<span class="udiff-line-added">+         m_stringBuilder.append(&quot;)[(&quot;);</span>
<span class="udiff-line-added">+         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="udiff-line-added">+         m_stringBuilder.append(&quot; &lt; &quot;, size, &quot;) ? (&quot;);</span>
<span class="udiff-line-added">+         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="udiff-line-added">+         m_stringBuilder.append(&quot;) : 0]&quot;);</span>
<span class="udiff-line-added">+     } else</span>
<span class="udiff-line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::VariableDeclaration&amp; variableDeclaration)
  {
      ASSERT(variableDeclaration.type());
      auto variableName = generateNextVariableName();
      auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);
      ASSERT_UNUSED(addResult, addResult.isNewEntry);
      // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198160 Implement qualifiers.
      if (variableDeclaration.initializer()) {
<span class="udiff-line-added">+         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;);</span>
          checkErrorAndVisit(*variableDeclaration.initializer());
<span class="udiff-line-modified-removed">-         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;, takeLastValue(), &quot;;\n&quot;);</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(&quot;;\n&quot;);</span>
      } else
          m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = { };\n&quot;);
  }
  
  void FunctionDefinitionWriter::visit(AST::AssignmentExpression&amp; assignmentExpression)
  {
<span class="udiff-line-added">+     m_stringBuilder.append(&#39;(&#39;);</span>
      checkErrorAndVisit(assignmentExpression.left());
<span class="udiff-line-modified-removed">-     auto [pointerName, nullability] = takeLastLeftValue();</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;)&#39;);</span>
<span class="udiff-line-added">+     m_stringBuilder.append(&quot; = (&quot;);</span>
      checkErrorAndVisit(assignmentExpression.right());
<span class="udiff-line-modified-removed">-     auto [rightName, rightNullability] = takeLastValueAndNullability();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (nullability == Nullability::CanBeNull)</span>
<span class="udiff-line-removed">-         m_stringBuilder.append(</span>
<span class="udiff-line-removed">-             m_indent, &quot;if (&quot;, pointerName, &quot;)\n&quot;,</span>
<span class="udiff-line-removed">-             m_indent, &quot;    *&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);</span>
<span class="udiff-line-removed">-     else</span>
<span class="udiff-line-removed">-         m_stringBuilder.append(m_indent, &quot;*&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);</span>
<span class="udiff-line-removed">-     appendRightValueWithNullability(assignmentExpression, rightName, rightNullability);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;)&#39;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::CallExpression&amp; callExpression)
  {
<span class="udiff-line-added">+     auto iter = m_hoistedVariables.find(&amp;callExpression);</span>
<span class="udiff-line-added">+     RELEASE_ASSERT(iter != m_hoistedVariables.end());</span>
<span class="udiff-line-added">+     auto&amp; variables = iter-&gt;value;</span>
<span class="udiff-line-added">+     RELEASE_ASSERT(callExpression.arguments().size() &lt;= variables.size());</span>
      Vector&lt;MangledVariableName&gt; argumentNames;
<span class="udiff-line-removed">-     for (auto&amp; argument : callExpression.arguments()) {</span>
<span class="udiff-line-removed">-         checkErrorAndVisit(argument);</span>
<span class="udiff-line-removed">-         argumentNames.append(takeLastValue());</span>
<span class="udiff-line-removed">-     }</span>
  
<span class="udiff-line-modified-removed">-     bool isVoid = matches(callExpression.resolvedType(), m_intrinsics.voidType());</span>
<span class="udiff-line-modified-removed">-     MangledVariableName returnName;</span>
<span class="udiff-line-modified-removed">-     if (!isVoid) {</span>
<span class="udiff-line-modified-removed">-         returnName = generateNextVariableName();</span>
<span class="udiff-line-modified-removed">-         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(callExpression.resolvedType()), &#39; &#39;, returnName, &quot;;\n&quot;);</span>
<span class="udiff-line-modified-added">+     MangledVariableName resultName;</span>
<span class="udiff-line-modified-added">+     if (!matches(callExpression.resolvedType(), m_intrinsics.voidType()))</span>
<span class="udiff-line-modified-added">+         resultName = variables.last().name;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;(&#39;);</span>
<span class="udiff-line-added">+     for (size_t i = 0; i &lt; callExpression.arguments().size(); ++i) {</span>
<span class="udiff-line-added">+         argumentNames.append(variables[i].name);</span>
<span class="udiff-line-added">+         m_stringBuilder.append(variables[i].name, &quot; = (&quot;);</span>
<span class="udiff-line-added">+         checkErrorAndVisit(callExpression.arguments()[i]);</span>
<span class="udiff-line-added">+         m_stringBuilder.append(&quot;), &quot;);</span>
      }
  
      if (is&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function())) {
<span class="udiff-line-modified-removed">-         auto generateNextVariableName = [this]() -&gt; MangledVariableName {</span>
<span class="udiff-line-removed">-             return this-&gt;generateNextVariableName();</span>
<span class="udiff-line-removed">-         };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="udiff-line-removed">-         inlineNativeFunction(m_stringBuilder, downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()), returnName, argumentNames, m_intrinsics, m_typeNamer, WTFMove(generateNextVariableName), m_indent);</span>
<span class="udiff-line-removed">-         m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="udiff-line-modified-added">+         inlineNativeFunction(m_stringBuilder, downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()), argumentNames, resultName, m_typeNamer);</span>
      } else {
<span class="udiff-line-removed">-         m_stringBuilder.append(m_indent);</span>
<span class="udiff-line-removed">- </span>
          auto iterator = m_functionMapping.find(&amp;callExpression.function());
          ASSERT(iterator != m_functionMapping.end());
<span class="udiff-line-removed">-         if (!isVoid)</span>
<span class="udiff-line-removed">-             m_stringBuilder.append(returnName, &quot; = &quot;);</span>
          m_stringBuilder.append(iterator-&gt;value, &#39;(&#39;);
<span class="udiff-line-modified-removed">-         for (size_t i = 0; i &lt; argumentNames.size(); ++i) {</span>
<span class="udiff-line-modified-added">+         for (size_t i = 0; i &lt; callExpression.arguments().size(); ++i) {</span>
              if (i)
                  m_stringBuilder.append(&quot;, &quot;);
<span class="udiff-line-modified-removed">-             m_stringBuilder.append(argumentNames[i]);</span>
<span class="udiff-line-modified-added">+             m_stringBuilder.append(variables[i].name);</span>
          }
<span class="udiff-line-modified-removed">-         m_stringBuilder.append(&quot;);\n&quot;);</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(&#39;)&#39;);</span>
      }
  
<span class="udiff-line-modified-removed">-     appendRightValue(callExpression, returnName);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;)&#39;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::CommaExpression&amp; commaExpression)
  {
<span class="udiff-line-modified-removed">-     Optional&lt;MangledVariableName&gt; result;</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;(&#39;);</span>
<span class="udiff-line-added">+     bool ranOnce = false;</span>
      for (auto&amp; expression : commaExpression.list()) {
<span class="udiff-line-added">+         if (ranOnce)</span>
<span class="udiff-line-added">+             m_stringBuilder.append(&quot;, &quot;);</span>
<span class="udiff-line-added">+         ranOnce = true;</span>
          checkErrorAndVisit(expression);
<span class="udiff-line-removed">-         result = takeLastValue();</span>
      }
<span class="udiff-line-modified-removed">-     ASSERT(result);</span>
<span class="udiff-line-removed">-     appendRightValue(commaExpression, *result);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;)&#39;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::DereferenceExpression&amp; dereferenceExpression)
  {
<span class="udiff-line-added">+     m_stringBuilder.append(&quot;*(&quot;);</span>
      checkErrorAndVisit(dereferenceExpression.pointer());
<span class="udiff-line-modified-removed">-     auto [inputPointer, nullability] = takeLastValueAndNullability();</span>
<span class="udiff-line-removed">-     auto resultValue = generateNextVariableName();</span>
<span class="udiff-line-removed">-     auto resultType = m_typeNamer.mangledNameForType(dereferenceExpression.resolvedType());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (nullability == Nullability::CanBeNull) {</span>
<span class="udiff-line-removed">-         m_stringBuilder.append(</span>
<span class="udiff-line-removed">-             m_indent, resultType , &#39; &#39;, resultValue, &quot; = &quot;, inputPointer, &quot; ? &quot;, &#39;*&#39;, inputPointer, &quot; : &quot;, resultType, &quot;{ };\n&quot;);</span>
<span class="udiff-line-removed">-     } else</span>
<span class="udiff-line-removed">-         m_stringBuilder.append(m_indent, resultValue, &quot; = *&quot;, inputPointer, &quot;;\n&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     appendLeftValue(dereferenceExpression, resultValue, inputPointer, nullability);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;)&#39;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::LogicalExpression&amp; logicalExpression)
  {
<span class="udiff-line-added">+     m_stringBuilder.append(&quot;((&quot;);</span>
      checkErrorAndVisit(logicalExpression.left());
<span class="udiff-line-modified-removed">-     auto left = takeLastValue();</span>
<span class="udiff-line-removed">-     checkErrorAndVisit(logicalExpression.right());</span>
<span class="udiff-line-removed">-     auto right = takeLastValue();</span>
<span class="udiff-line-removed">-     auto variableName = generateNextVariableName();</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;)&#39;);</span>
  
<span class="udiff-line-removed">-     m_stringBuilder.append(</span>
<span class="udiff-line-removed">-         m_indent, m_typeNamer.mangledNameForType(logicalExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, left);</span>
      switch (logicalExpression.type()) {
      case AST::LogicalExpression::Type::And:
          m_stringBuilder.append(&quot; &amp;&amp; &quot;);
          break;
<span class="udiff-line-modified-removed">-     default:</span>
<span class="udiff-line-removed">-         ASSERT(logicalExpression.type() == AST::LogicalExpression::Type::Or);</span>
<span class="udiff-line-modified-added">+     case AST::LogicalExpression::Type::Or:</span>
          m_stringBuilder.append(&quot; || &quot;);
          break;
      }
<span class="udiff-line-modified-removed">-     m_stringBuilder.append(right, &quot;;\n&quot;);</span>
<span class="udiff-line-modified-removed">-     appendRightValue(logicalExpression, variableName);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;(&#39;);</span>
<span class="udiff-line-added">+     checkErrorAndVisit(logicalExpression.right());</span>
<span class="udiff-line-added">+     m_stringBuilder.append(&quot;))&quot;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
  {
<span class="udiff-line-added">+     m_stringBuilder.append(&quot;!(&quot;);</span>
      checkErrorAndVisit(logicalNotExpression.operand());
<span class="udiff-line-modified-removed">-     auto operand = takeLastValue();</span>
<span class="udiff-line-removed">-     auto variableName = generateNextVariableName();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     m_stringBuilder.append(</span>
<span class="udiff-line-removed">-         m_indent, m_typeNamer.mangledNameForType(logicalNotExpression.resolvedType()), &#39; &#39;, variableName, &quot; = !&quot;, operand, &quot;;\n&quot;);</span>
<span class="udiff-line-removed">-     appendRightValue(logicalNotExpression, variableName);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;)&#39;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
  {
<span class="udiff-line-removed">-     checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
      // FIXME: This needs to be made to work. It probably should be using the last leftValue too.
      // https://bugs.webkit.org/show_bug.cgi?id=198838
<span class="udiff-line-removed">-     auto variableName = generateNextVariableName();</span>
<span class="udiff-line-removed">- </span>
      auto mangledTypeName = m_typeNamer.mangledNameForType(makeArrayReferenceExpression.resolvedType());
      if (is&lt;AST::PointerType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
<span class="udiff-line-modified-removed">-         auto ptrValue = takeLastValue();</span>
<span class="udiff-line-modified-removed">-         m_stringBuilder.append(</span>
<span class="udiff-line-modified-removed">-             m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, ptrValue, &quot; ? &quot;, mangledTypeName, &quot;{ &quot;, ptrValue, &quot;, 1 } : &quot;, mangledTypeName, &quot;{ nullptr, 0 };\n&quot;);</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(mangledTypeName, &quot;{ &quot;);</span>
<span class="udiff-line-modified-added">+         checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(&quot;, 1 }&quot;);</span>
      } else if (is&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
<span class="udiff-line-removed">-         auto lValue = takeLastLeftValue().value;</span>
          auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType());
<span class="udiff-line-modified-removed">-         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;-&gt;data(), &quot;, arrayType.numElements(), &quot; };\n&quot;);</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(mangledTypeName, &quot; { &quot;);</span>
<span class="udiff-line-added">+         checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
<span class="udiff-line-added">+         m_stringBuilder.append(&quot;.data(), &quot;, arrayType.numElements(), &quot; }&quot;);</span>
      } else {
<span class="udiff-line-modified-removed">-         auto lValue = takeLastLeftValue().value;</span>
<span class="udiff-line-modified-removed">-         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;, 1 };\n&quot;);</span>
<span class="udiff-line-modified-added">+         m_stringBuilder.append(mangledTypeName, &quot; { &amp;&quot;);</span>
<span class="udiff-line-modified-added">+         checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
<span class="udiff-line-added">+         m_stringBuilder.append(&quot;, 1 }&quot;);</span>
      }
<span class="udiff-line-removed">-     appendRightValue(makeArrayReferenceExpression, variableName);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::MakePointerExpression&amp; makePointerExpression)
  {
<span class="udiff-line-added">+     m_stringBuilder.append(&quot;&amp;(&quot;);</span>
      checkErrorAndVisit(makePointerExpression.leftValue());
<span class="udiff-line-modified-removed">-     auto [pointer, nullability] = takeLastLeftValue();</span>
<span class="udiff-line-removed">-     auto variableName = generateNextVariableName();</span>
<span class="udiff-line-removed">-     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(makePointerExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, pointer, &quot;;\n&quot;);</span>
<span class="udiff-line-removed">-     appendRightValueWithNullability(makePointerExpression, variableName, nullability);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;)&#39;);</span>
  }
  
<span class="udiff-line-modified-removed">- void FunctionDefinitionWriter::visit(AST::ReadModifyWriteExpression&amp;)</span>
<span class="udiff-line-modified-added">+ void FunctionDefinitionWriter::visit(AST::ReadModifyWriteExpression&amp; readModifyWrite)</span>
  {
<span class="udiff-line-modified-removed">-     // This should be lowered already.</span>
<span class="udiff-line-modified-removed">-     ASSERT_NOT_REACHED();</span>
<span class="udiff-line-modified-added">+     /*</span>
<span class="udiff-line-modified-added">+      *  1. Evaluate m_leftValue</span>
<span class="udiff-line-added">+      *  2. Assign the result to m_oldValue</span>
<span class="udiff-line-added">+      *  3. Evaluate m_newValueExpression</span>
<span class="udiff-line-added">+      *  4. Assign the result to m_newValue</span>
<span class="udiff-line-added">+      *  5. Assign the result to m_leftValue</span>
<span class="udiff-line-added">+      *  6. Evaluate m_resultExpression</span>
<span class="udiff-line-added">+      *  7. Return the result</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto iter = m_hoistedVariables.find(&amp;readModifyWrite);</span>
<span class="udiff-line-added">+     RELEASE_ASSERT(iter != m_hoistedVariables.end());</span>
<span class="udiff-line-added">+     auto&amp; variables = iter-&gt;value;</span>
<span class="udiff-line-added">+     RELEASE_ASSERT(variables.size() == 2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     MangledVariableName oldValueVariable = variables[0].name;</span>
<span class="udiff-line-added">+     MangledVariableName newValueVariable = variables[1].name;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_variableMapping.add(&amp;readModifyWrite.oldValue(), oldValueVariable);</span>
<span class="udiff-line-added">+     m_variableMapping.add(&amp;readModifyWrite.newValue(), newValueVariable);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_stringBuilder.append(&#39;(&#39;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_stringBuilder.append(oldValueVariable, &quot; = &quot;);</span>
<span class="udiff-line-added">+     checkErrorAndVisit(readModifyWrite.leftValue());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_stringBuilder.append(&quot;, &quot;, newValueVariable, &quot; = &quot;);</span>
<span class="udiff-line-added">+     checkErrorAndVisit(readModifyWrite.newValueExpression());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_stringBuilder.append(&quot;, &quot;);</span>
<span class="udiff-line-added">+     checkErrorAndVisit(readModifyWrite.leftValue());</span>
<span class="udiff-line-added">+     m_stringBuilder.append(&quot; = &quot;, newValueVariable, &quot;, &quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     checkErrorAndVisit(readModifyWrite.resultExpression());</span>
<span class="udiff-line-added">+     m_stringBuilder.append(&#39;)&#39;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::TernaryExpression&amp; ternaryExpression)
  {
<span class="udiff-line-added">+     m_stringBuilder.append(&#39;(&#39;);</span>
      checkErrorAndVisit(ternaryExpression.predicate());
<span class="udiff-line-modified-removed">-     auto check = takeLastValue();</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&quot;) ? (&quot;);</span>
      checkErrorAndVisit(ternaryExpression.bodyExpression());
<span class="udiff-line-modified-removed">-     auto body = takeLastValue();</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&quot;) : (&quot;);</span>
      checkErrorAndVisit(ternaryExpression.elseExpression());
<span class="udiff-line-modified-removed">-     auto elseBody = takeLastValue();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     auto variableName = generateNextVariableName();</span>
<span class="udiff-line-removed">-     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(ternaryExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, check, &quot; ? &quot;, body, &quot; : &quot;, elseBody, &quot;;\n&quot;);</span>
<span class="udiff-line-removed">-     appendRightValue(ternaryExpression, variableName);</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(&#39;)&#39;);</span>
  }
  
  void FunctionDefinitionWriter::visit(AST::VariableReference&amp; variableReference)
  {
      ASSERT(variableReference.variable());
      auto iterator = m_variableMapping.find(variableReference.variable());
      ASSERT(iterator != m_variableMapping.end());
  
      MangledVariableName variableName = iterator-&gt;value;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     appendLeftValue(variableReference, variableName, { }, Nullability::NotNull,</span>
<span class="udiff-line-removed">-         [this, &amp;variableReference, variableName] {</span>
<span class="udiff-line-removed">-             auto pointerName = generateNextVariableName();</span>
<span class="udiff-line-removed">-             m_stringBuilder.append(m_indent, &quot;thread &quot;, m_typeNamer.mangledNameForType(variableReference.resolvedType()), &quot;* &quot;, pointerName, &quot; = &amp;&quot;, variableName, &quot;;\n&quot;);</span>
<span class="udiff-line-removed">-             return pointerName;</span>
<span class="udiff-line-removed">-         });</span>
<span class="udiff-line-modified-added">+     m_stringBuilder.append(variableName);</span>
  }
  
  void FunctionDefinitionWriter::emitConstantExpressionString(AST::ConstantExpression&amp; constantExpression)
  {
      constantExpression.visit(WTF::makeVisitor(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -771,13 +805,10 @@</span>
              m_stringBuilder.append(unsignedIntegerLiteral.value());
          },
          [&amp;](AST::FloatLiteral&amp; floatLiteral) {
              m_stringBuilder.append(floatLiteral.value());
          },
<span class="udiff-line-removed">-         [&amp;](AST::NullLiteral&amp;) {</span>
<span class="udiff-line-removed">-             m_stringBuilder.append(&quot;nullptr&quot;);</span>
<span class="udiff-line-removed">-         },</span>
          [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {
              if (booleanLiteral.value())
                  m_stringBuilder.append(&quot;true&quot;);
              else
                  m_stringBuilder.append(&quot;false&quot;);
</pre>
<center><a href="WHLSLEntryPointScaffolding.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLMetalCodeGenerator.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
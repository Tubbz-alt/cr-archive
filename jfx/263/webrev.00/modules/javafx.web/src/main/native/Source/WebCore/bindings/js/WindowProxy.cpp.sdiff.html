<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WindowProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebCoreTypedArrayController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WindowProxy.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WindowProxy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;WindowProxy.h&quot;
 23 
 24 #include &quot;CommonVM.h&quot;
 25 #include &quot;Frame.h&quot;
 26 #include &quot;GCController.h&quot;
 27 #include &quot;JSWindowProxy.h&quot;
 28 #include &quot;Page.h&quot;
 29 #include &quot;PageConsoleClient.h&quot;
 30 #include &quot;PageGroup.h&quot;
 31 #include &quot;RemoteFrame.h&quot;
 32 #include &quot;ScriptController.h&quot;
 33 #include &quot;runtime_root.h&quot;
 34 #include &lt;JavaScriptCore/JSLock.h&gt;

 35 #include &lt;JavaScriptCore/WeakGCMapInlines.h&gt;
 36 #include &lt;wtf/MemoryPressureHandler.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 using namespace JSC;
 41 
 42 static void collectGarbageAfterWindowProxyDestruction()
 43 {
 44     // Make sure to GC Extra Soon(tm) during memory pressure conditions
 45     // to soften high peaks of memory usage during navigation.
 46     if (MemoryPressureHandler::singleton().isUnderMemoryPressure()) {
 47         // NOTE: We do the collection on next runloop to ensure that there&#39;s no pointer
 48         //       to the window object on the stack.
 49         GCController::singleton().garbageCollectOnNextRunLoop();
 50     } else
 51         GCController::singleton().garbageCollectSoon();
 52 }
 53 
 54 WindowProxy::WindowProxy(AbstractFrame&amp; frame)
 55     : m_frame(&amp;frame)

 56 {
 57 }
 58 
 59 WindowProxy::~WindowProxy()
 60 {
 61     ASSERT(!m_frame);
<span class="line-modified"> 62     ASSERT(m_jsWindowProxies.isEmpty());</span>
 63 }
 64 
 65 void WindowProxy::detachFromFrame()
 66 {
 67     ASSERT(m_frame);
 68 
 69     m_frame = nullptr;
 70 
 71     // It&#39;s likely that destroying windowProxies will create a lot of garbage.
<span class="line-modified"> 72     if (!m_jsWindowProxies.isEmpty()) {</span>
<span class="line-modified"> 73         while (!m_jsWindowProxies.isEmpty()) {</span>
<span class="line-modified"> 74             auto it = m_jsWindowProxies.begin();</span>
 75             it-&gt;value-&gt;window()-&gt;setConsoleClient(nullptr);
 76             destroyJSWindowProxy(*it-&gt;key);
 77         }
 78         collectGarbageAfterWindowProxyDestruction();
 79     }
 80 }
 81 
 82 void WindowProxy::destroyJSWindowProxy(DOMWrapperWorld&amp; world)
 83 {
<span class="line-modified"> 84     ASSERT(m_jsWindowProxies.contains(&amp;world));</span>
<span class="line-modified"> 85     m_jsWindowProxies.remove(&amp;world);</span>
 86     world.didDestroyWindowProxy(this);
 87 }
 88 
 89 JSWindowProxy&amp; WindowProxy::createJSWindowProxy(DOMWrapperWorld&amp; world)
 90 {
 91     ASSERT(m_frame);
 92 
<span class="line-modified"> 93     ASSERT(!m_jsWindowProxies.contains(&amp;world));</span>
 94     ASSERT(m_frame-&gt;window());
 95 
 96     VM&amp; vm = world.vm();
 97 
 98     Strong&lt;JSWindowProxy&gt; jsWindowProxy(vm, &amp;JSWindowProxy::create(vm, *m_frame-&gt;window(), world));
 99     Strong&lt;JSWindowProxy&gt; jsWindowProxy2(jsWindowProxy);
<span class="line-modified">100     m_jsWindowProxies.add(&amp;world, jsWindowProxy);</span>
101     world.didCreateWindowProxy(this);
102     return *jsWindowProxy.get();
103 }
104 
105 Vector&lt;JSC::Strong&lt;JSWindowProxy&gt;&gt; WindowProxy::jsWindowProxiesAsVector() const
106 {
<span class="line-modified">107     return copyToVector(m_jsWindowProxies.values());</span>
108 }
109 
110 JSDOMGlobalObject* WindowProxy::globalObject(DOMWrapperWorld&amp; world)
111 {
112     if (auto* windowProxy = jsWindowProxy(world))
113         return windowProxy-&gt;window();
114     return nullptr;
115 }
116 
117 JSWindowProxy&amp; WindowProxy::createJSWindowProxyWithInitializedScript(DOMWrapperWorld&amp; world)
118 {
119     ASSERT(m_frame);
120 
121     JSLockHolder lock(world.vm());
122     auto&amp; windowProxy = createJSWindowProxy(world);
123     if (is&lt;Frame&gt;(*m_frame))
124         downcast&lt;Frame&gt;(*m_frame).script().initScriptForWindowProxy(windowProxy);
125     return windowProxy;
126 }
127 
<span class="line-modified">128 void WindowProxy::clearJSWindowProxiesNotMatchingDOMWindow(AbstractDOMWindow* newDOMWindow, bool goingIntoPageCache)</span>
129 {
<span class="line-modified">130     if (m_jsWindowProxies.isEmpty())</span>
131         return;
132 
133     JSLockHolder lock(commonVM());
134 
135     for (auto&amp; windowProxy : jsWindowProxiesAsVector()) {
136         if (&amp;windowProxy-&gt;wrapped() == newDOMWindow)
137             continue;
138 
139         // Clear the debugger and console from the current window before setting the new window.
140         windowProxy-&gt;attachDebugger(nullptr);
141         windowProxy-&gt;window()-&gt;setConsoleClient(nullptr);
142         if (auto* jsDOMWindow = jsDynamicCast&lt;JSDOMWindowBase*&gt;(windowProxy-&gt;vm(), windowProxy-&gt;window()))
143             jsDOMWindow-&gt;willRemoveFromWindowProxy();
144     }
145 
146     // It&#39;s likely that resetting our windows created a lot of garbage, unless
147     // it went in a back/forward cache.
<span class="line-modified">148     if (!goingIntoPageCache)</span>
149         collectGarbageAfterWindowProxyDestruction();
150 }
151 
152 void WindowProxy::setDOMWindow(AbstractDOMWindow* newDOMWindow)
153 {
154     ASSERT(newDOMWindow);
155 
<span class="line-modified">156     if (m_jsWindowProxies.isEmpty())</span>
157         return;
158 
159     ASSERT(m_frame);
160 
161     JSLockHolder lock(commonVM());
162 
163     for (auto&amp; windowProxy : jsWindowProxiesAsVector()) {
164         if (&amp;windowProxy-&gt;wrapped() == newDOMWindow)
165             continue;
166 
167         windowProxy-&gt;setWindow(*newDOMWindow);
168 
169         ScriptController* scriptController = nullptr;
170         Page* page = nullptr;
171         if (is&lt;Frame&gt;(*m_frame)) {
172             auto&amp; frame = downcast&lt;Frame&gt;(*m_frame);
173             scriptController = &amp;frame.script();
174             page = frame.page();
175         }
176 
177         // ScriptController&#39;s m_cacheableBindingRootObject persists between page navigations
178         // so needs to know about the new JSDOMWindow.
179         if (auto* cacheableBindingRootObject = scriptController ? scriptController-&gt;existingCacheableBindingRootObject() : nullptr)
180             cacheableBindingRootObject-&gt;updateGlobalObject(windowProxy-&gt;window());
181 
182         windowProxy-&gt;attachDebugger(page ? page-&gt;debugger() : nullptr);
183         if (page)
184             windowProxy-&gt;window()-&gt;setProfileGroup(page-&gt;group().identifier());
185         windowProxy-&gt;window()-&gt;setConsoleClient(page ? &amp;page-&gt;console() : nullptr);
186     }
187 }
188 
189 void WindowProxy::attachDebugger(JSC::Debugger* debugger)
190 {
<span class="line-modified">191     for (auto&amp; windowProxy : m_jsWindowProxies.values())</span>
192         windowProxy-&gt;attachDebugger(debugger);
193 }
194 
195 AbstractDOMWindow* WindowProxy::window() const
196 {
197     return m_frame ? m_frame-&gt;window() : nullptr;
198 }
199 















200 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;WindowProxy.h&quot;
 23 
 24 #include &quot;CommonVM.h&quot;
 25 #include &quot;Frame.h&quot;
 26 #include &quot;GCController.h&quot;
 27 #include &quot;JSWindowProxy.h&quot;
 28 #include &quot;Page.h&quot;
 29 #include &quot;PageConsoleClient.h&quot;
 30 #include &quot;PageGroup.h&quot;
 31 #include &quot;RemoteFrame.h&quot;
 32 #include &quot;ScriptController.h&quot;
 33 #include &quot;runtime_root.h&quot;
 34 #include &lt;JavaScriptCore/JSLock.h&gt;
<span class="line-added"> 35 #include &lt;JavaScriptCore/StrongInlines.h&gt;</span>
 36 #include &lt;JavaScriptCore/WeakGCMapInlines.h&gt;
 37 #include &lt;wtf/MemoryPressureHandler.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 using namespace JSC;
 42 
 43 static void collectGarbageAfterWindowProxyDestruction()
 44 {
 45     // Make sure to GC Extra Soon(tm) during memory pressure conditions
 46     // to soften high peaks of memory usage during navigation.
 47     if (MemoryPressureHandler::singleton().isUnderMemoryPressure()) {
 48         // NOTE: We do the collection on next runloop to ensure that there&#39;s no pointer
 49         //       to the window object on the stack.
 50         GCController::singleton().garbageCollectOnNextRunLoop();
 51     } else
 52         GCController::singleton().garbageCollectSoon();
 53 }
 54 
 55 WindowProxy::WindowProxy(AbstractFrame&amp; frame)
 56     : m_frame(&amp;frame)
<span class="line-added"> 57     , m_jsWindowProxies(makeUniqueRef&lt;ProxyMap&gt;())</span>
 58 {
 59 }
 60 
 61 WindowProxy::~WindowProxy()
 62 {
 63     ASSERT(!m_frame);
<span class="line-modified"> 64     ASSERT(m_jsWindowProxies-&gt;isEmpty());</span>
 65 }
 66 
 67 void WindowProxy::detachFromFrame()
 68 {
 69     ASSERT(m_frame);
 70 
 71     m_frame = nullptr;
 72 
 73     // It&#39;s likely that destroying windowProxies will create a lot of garbage.
<span class="line-modified"> 74     if (!m_jsWindowProxies-&gt;isEmpty()) {</span>
<span class="line-modified"> 75         while (!m_jsWindowProxies-&gt;isEmpty()) {</span>
<span class="line-modified"> 76             auto it = m_jsWindowProxies-&gt;begin();</span>
 77             it-&gt;value-&gt;window()-&gt;setConsoleClient(nullptr);
 78             destroyJSWindowProxy(*it-&gt;key);
 79         }
 80         collectGarbageAfterWindowProxyDestruction();
 81     }
 82 }
 83 
 84 void WindowProxy::destroyJSWindowProxy(DOMWrapperWorld&amp; world)
 85 {
<span class="line-modified"> 86     ASSERT(m_jsWindowProxies-&gt;contains(&amp;world));</span>
<span class="line-modified"> 87     m_jsWindowProxies-&gt;remove(&amp;world);</span>
 88     world.didDestroyWindowProxy(this);
 89 }
 90 
 91 JSWindowProxy&amp; WindowProxy::createJSWindowProxy(DOMWrapperWorld&amp; world)
 92 {
 93     ASSERT(m_frame);
 94 
<span class="line-modified"> 95     ASSERT(!m_jsWindowProxies-&gt;contains(&amp;world));</span>
 96     ASSERT(m_frame-&gt;window());
 97 
 98     VM&amp; vm = world.vm();
 99 
100     Strong&lt;JSWindowProxy&gt; jsWindowProxy(vm, &amp;JSWindowProxy::create(vm, *m_frame-&gt;window(), world));
101     Strong&lt;JSWindowProxy&gt; jsWindowProxy2(jsWindowProxy);
<span class="line-modified">102     m_jsWindowProxies-&gt;add(&amp;world, jsWindowProxy);</span>
103     world.didCreateWindowProxy(this);
104     return *jsWindowProxy.get();
105 }
106 
107 Vector&lt;JSC::Strong&lt;JSWindowProxy&gt;&gt; WindowProxy::jsWindowProxiesAsVector() const
108 {
<span class="line-modified">109     return copyToVector(m_jsWindowProxies-&gt;values());</span>
110 }
111 
112 JSDOMGlobalObject* WindowProxy::globalObject(DOMWrapperWorld&amp; world)
113 {
114     if (auto* windowProxy = jsWindowProxy(world))
115         return windowProxy-&gt;window();
116     return nullptr;
117 }
118 
119 JSWindowProxy&amp; WindowProxy::createJSWindowProxyWithInitializedScript(DOMWrapperWorld&amp; world)
120 {
121     ASSERT(m_frame);
122 
123     JSLockHolder lock(world.vm());
124     auto&amp; windowProxy = createJSWindowProxy(world);
125     if (is&lt;Frame&gt;(*m_frame))
126         downcast&lt;Frame&gt;(*m_frame).script().initScriptForWindowProxy(windowProxy);
127     return windowProxy;
128 }
129 
<span class="line-modified">130 void WindowProxy::clearJSWindowProxiesNotMatchingDOMWindow(AbstractDOMWindow* newDOMWindow, bool goingIntoBackForwardCache)</span>
131 {
<span class="line-modified">132     if (m_jsWindowProxies-&gt;isEmpty())</span>
133         return;
134 
135     JSLockHolder lock(commonVM());
136 
137     for (auto&amp; windowProxy : jsWindowProxiesAsVector()) {
138         if (&amp;windowProxy-&gt;wrapped() == newDOMWindow)
139             continue;
140 
141         // Clear the debugger and console from the current window before setting the new window.
142         windowProxy-&gt;attachDebugger(nullptr);
143         windowProxy-&gt;window()-&gt;setConsoleClient(nullptr);
144         if (auto* jsDOMWindow = jsDynamicCast&lt;JSDOMWindowBase*&gt;(windowProxy-&gt;vm(), windowProxy-&gt;window()))
145             jsDOMWindow-&gt;willRemoveFromWindowProxy();
146     }
147 
148     // It&#39;s likely that resetting our windows created a lot of garbage, unless
149     // it went in a back/forward cache.
<span class="line-modified">150     if (!goingIntoBackForwardCache)</span>
151         collectGarbageAfterWindowProxyDestruction();
152 }
153 
154 void WindowProxy::setDOMWindow(AbstractDOMWindow* newDOMWindow)
155 {
156     ASSERT(newDOMWindow);
157 
<span class="line-modified">158     if (m_jsWindowProxies-&gt;isEmpty())</span>
159         return;
160 
161     ASSERT(m_frame);
162 
163     JSLockHolder lock(commonVM());
164 
165     for (auto&amp; windowProxy : jsWindowProxiesAsVector()) {
166         if (&amp;windowProxy-&gt;wrapped() == newDOMWindow)
167             continue;
168 
169         windowProxy-&gt;setWindow(*newDOMWindow);
170 
171         ScriptController* scriptController = nullptr;
172         Page* page = nullptr;
173         if (is&lt;Frame&gt;(*m_frame)) {
174             auto&amp; frame = downcast&lt;Frame&gt;(*m_frame);
175             scriptController = &amp;frame.script();
176             page = frame.page();
177         }
178 
179         // ScriptController&#39;s m_cacheableBindingRootObject persists between page navigations
180         // so needs to know about the new JSDOMWindow.
181         if (auto* cacheableBindingRootObject = scriptController ? scriptController-&gt;existingCacheableBindingRootObject() : nullptr)
182             cacheableBindingRootObject-&gt;updateGlobalObject(windowProxy-&gt;window());
183 
184         windowProxy-&gt;attachDebugger(page ? page-&gt;debugger() : nullptr);
185         if (page)
186             windowProxy-&gt;window()-&gt;setProfileGroup(page-&gt;group().identifier());
187         windowProxy-&gt;window()-&gt;setConsoleClient(page ? &amp;page-&gt;console() : nullptr);
188     }
189 }
190 
191 void WindowProxy::attachDebugger(JSC::Debugger* debugger)
192 {
<span class="line-modified">193     for (auto&amp; windowProxy : m_jsWindowProxies-&gt;values())</span>
194         windowProxy-&gt;attachDebugger(debugger);
195 }
196 
197 AbstractDOMWindow* WindowProxy::window() const
198 {
199     return m_frame ? m_frame-&gt;window() : nullptr;
200 }
201 
<span class="line-added">202 WindowProxy::ProxyMap::ValuesConstIteratorRange WindowProxy::jsWindowProxies() const</span>
<span class="line-added">203 {</span>
<span class="line-added">204     return m_jsWindowProxies-&gt;values();</span>
<span class="line-added">205 }</span>
<span class="line-added">206 </span>
<span class="line-added">207 WindowProxy::ProxyMap WindowProxy::releaseJSWindowProxies()</span>
<span class="line-added">208 {</span>
<span class="line-added">209     return std::exchange(m_jsWindowProxies, makeUniqueRef&lt;ProxyMap&gt;());</span>
<span class="line-added">210 }</span>
<span class="line-added">211 </span>
<span class="line-added">212 void WindowProxy::setJSWindowProxies(ProxyMap&amp;&amp; windowProxies)</span>
<span class="line-added">213 {</span>
<span class="line-added">214     m_jsWindowProxies = makeUniqueRef&lt;ProxyMap&gt;(WTFMove(windowProxies));</span>
<span class="line-added">215 }</span>
<span class="line-added">216 </span>
217 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="WebCoreTypedArrayController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WindowProxy.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
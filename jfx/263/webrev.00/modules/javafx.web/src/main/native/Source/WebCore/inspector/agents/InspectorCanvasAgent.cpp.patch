diff a/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp b/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp
@@ -24,47 +24,59 @@
  */
 
 #include "config.h"
 #include "InspectorCanvasAgent.h"
 
-#include "ActiveDOMCallbackMicrotask.h"
 #include "CanvasRenderingContext.h"
 #include "CanvasRenderingContext2D.h"
 #include "Document.h"
 #include "Element.h"
+#include "EventLoop.h"
 #include "Frame.h"
 #include "HTMLCanvasElement.h"
+#include "ImageBitmap.h"
 #include "ImageBitmapRenderingContext.h"
 #include "InspectorDOMAgent.h"
+#include "InspectorShaderProgram.h"
 #include "InstrumentingAgents.h"
-#include "JSCanvasRenderingContext2D.h"
 #include "JSExecState.h"
-#include "JSImageBitmapRenderingContext.h"
-#include "Microtasks.h"
-#include "OffscreenCanvas.h"
 #include "ScriptState.h"
 #include "StringAdaptors.h"
 #include <JavaScriptCore/IdentifiersFactory.h>
 #include <JavaScriptCore/InjectedScript.h>
 #include <JavaScriptCore/InjectedScriptManager.h>
 #include <JavaScriptCore/InspectorProtocolObjects.h>
 #include <JavaScriptCore/JSCInlines.h>
+#include <wtf/HashMap.h>
 #include <wtf/HashSet.h>
 #include <wtf/Lock.h>
+#include <wtf/Optional.h>
+#include <wtf/RefPtr.h>
+#include <wtf/Vector.h>
+#include <wtf/text/WTFString.h>
+
+#if ENABLE(OFFSCREEN_CANVAS)
+#include "OffscreenCanvas.h"
+#endif
 
 #if ENABLE(WEBGL)
-#include "JSWebGLRenderingContext.h"
 #include "WebGLProgram.h"
-#include "WebGLShader.h"
+#include "WebGLRenderingContext.h"
+#include "WebGLRenderingContextBase.h"
 #endif
 
 #if ENABLE(WEBGL2)
-#include "JSWebGL2RenderingContext.h"
+#include "WebGL2RenderingContext.h"
 #endif
 
 #if ENABLE(WEBGPU)
-#include "JSGPUCanvasContext.h"
+#include "GPUCanvasContext.h"
+#include "WebGPUComputePipeline.h"
+#include "WebGPUDevice.h"
+#include "WebGPUPipeline.h"
+#include "WebGPURenderPipeline.h"
+#include "WebGPUSwapChain.h"
 #endif
 
 namespace WebCore {
 
 using namespace Inspector;
@@ -74,10 +86,11 @@
     , m_frontendDispatcher(makeUnique<Inspector::CanvasFrontendDispatcher>(context.frontendRouter))
     , m_backendDispatcher(Inspector::CanvasBackendDispatcher::create(context.backendDispatcher, this))
     , m_injectedScriptManager(context.injectedScriptManager)
     , m_inspectedPage(context.inspectedPage)
     , m_canvasDestroyedTimer(*this, &InspectorCanvasAgent::canvasDestroyedTimerFired)
+    , m_programDestroyedTimer(*this, &InspectorCanvasAgent::programDestroyedTimerFired)
 {
 }
 
 InspectorCanvasAgent::~InspectorCanvasAgent() = default;
 
@@ -91,57 +104,79 @@
     disable(ignored);
 }
 
 void InspectorCanvasAgent::discardAgent()
 {
-    clearCanvasData();
+    reset();
 }
 
 void InspectorCanvasAgent::enable(ErrorString&)
 {
     if (m_instrumentingAgents.inspectorCanvasAgent() == this)
         return;
 
     m_instrumentingAgents.setInspectorCanvasAgent(this);
 
-    const auto canvasExistsInCurrentPage = [&] (CanvasRenderingContext* canvasRenderingContext) {
-        if (!canvasRenderingContext)
-            return false;
-
-        auto* scriptExecutionContext = canvasRenderingContext->canvasBase().scriptExecutionContext();
+    const auto existsInCurrentPage = [&] (ScriptExecutionContext* scriptExecutionContext) {
         if (!is<Document>(scriptExecutionContext))
             return false;
 
         // FIXME: <https://webkit.org/b/168475> Web Inspector: Correctly display iframe's WebSockets
         auto* document = downcast<Document>(scriptExecutionContext);
         return document->page() == &m_inspectedPage;
     };
 
     {
         LockHolder lock(CanvasRenderingContext::instancesMutex());
-        for (auto* canvasRenderingContext : CanvasRenderingContext::instances(lock)) {
-            if (canvasExistsInCurrentPage(canvasRenderingContext))
-                bindCanvas(*canvasRenderingContext, false);
+        for (auto* context : CanvasRenderingContext::instances(lock)) {
+#if ENABLE(WEBGPU)
+            // The actual "context" for WebGPU is the `WebGPUDevice`, not the <canvas>.
+            if (is<GPUCanvasContext>(context))
+                continue;
+#endif
+
+            if (existsInCurrentPage(context->canvasBase().scriptExecutionContext()))
+                bindCanvas(*context, false);
         }
     }
 
+#if ENABLE(WEBGPU)
+    {
+        LockHolder lock(WebGPUDevice::instancesMutex());
+        for (auto* device : WebGPUDevice::instances(lock)) {
+            if (existsInCurrentPage(device->scriptExecutionContext()))
+                bindCanvas(*device, false);
+        }
+    }
+#endif
+
 #if ENABLE(WEBGL)
     {
         LockHolder lock(WebGLProgram::instancesMutex());
-        for (auto& entry : WebGLProgram::instances(lock)) {
-            if (canvasExistsInCurrentPage(entry.value))
-                didCreateProgram(*entry.value, *entry.key);
+        for (auto& [program, contextWebGLBase] : WebGLProgram::instances(lock)) {
+            if (contextWebGLBase && existsInCurrentPage(contextWebGLBase->canvasBase().scriptExecutionContext()))
+                didCreateWebGLProgram(*contextWebGLBase, *program);
+        }
+    }
+#endif
+
+#if ENABLE(WEBGPU)
+    {
+        LockHolder lock(WebGPUPipeline::instancesMutex());
+        for (auto& [pipeline, device] : WebGPUPipeline::instances(lock)) {
+            if (device && existsInCurrentPage(device->scriptExecutionContext()) && pipeline->isValid())
+                didCreateWebGPUPipeline(*device, *pipeline);
         }
     }
 #endif
 }
 
 void InspectorCanvasAgent::disable(ErrorString&)
 {
     m_instrumentingAgents.setInspectorCanvasAgent(nullptr);
 
-    clearCanvasData();
+    reset();
 
     m_recordingAutoCaptureFrameCount = WTF::nullopt;
 }
 
 void InspectorCanvasAgent::requestNode(ErrorString& errorString, const String& canvasId, int* nodeId)
@@ -172,58 +207,41 @@
         return;
 
     *content = inspectorCanvas->getCanvasContentAsDataURL(errorString);
 }
 
-void InspectorCanvasAgent::requestCSSCanvasClientNodes(ErrorString& errorString, const String& canvasId, RefPtr<JSON::ArrayOf<int>>& result)
+void InspectorCanvasAgent::requestClientNodes(ErrorString& errorString, const String& canvasId, RefPtr<JSON::ArrayOf<int>>& clientNodeIds)
 {
+    auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
+    if (!domAgent) {
+        errorString = "DOM domain must be enabled"_s;
+        return;
+    }
+
     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
     if (!inspectorCanvas)
         return;
 
-    result = JSON::ArrayOf<int>::create();
-    for (auto* client : inspectorCanvas->context().canvasBase().cssCanvasClients()) {
-        if (int documentNodeId = m_instrumentingAgents.inspectorDOMAgent()->boundNodeId(&client->document()))
-            result->addItem(m_instrumentingAgents.inspectorDOMAgent()->pushNodeToFrontend(errorString, documentNodeId, client));
+    clientNodeIds = JSON::ArrayOf<int>::create();
+    for (auto& clientNode : inspectorCanvas->clientNodes()) {
+        if (auto documentNodeId = domAgent->boundNodeId(&clientNode->document()))
+            clientNodeIds->addItem(domAgent->pushNodeToFrontend(errorString, documentNodeId, clientNode));
     }
 }
 
-static JSC::JSValue contextAsScriptValue(JSC::ExecState& state, CanvasRenderingContext& context)
-{
-    JSC::JSLockHolder lock(&state);
-
-    if (is<CanvasRenderingContext2D>(context))
-        return toJS(&state, deprecatedGlobalObjectForPrototype(&state), downcast<CanvasRenderingContext2D>(context));
-#if ENABLE(WEBGL)
-    if (is<WebGLRenderingContext>(context))
-        return toJS(&state, deprecatedGlobalObjectForPrototype(&state), downcast<WebGLRenderingContext>(context));
-#endif
-#if ENABLE(WEBGL2)
-    if (is<WebGL2RenderingContext>(context))
-        return toJS(&state, deprecatedGlobalObjectForPrototype(&state), downcast<WebGL2RenderingContext>(context));
-#endif
-#if ENABLE(WEBGPU)
-    if (is<GPUCanvasContext>(context))
-        return toJS(&state, deprecatedGlobalObjectForPrototype(&state), downcast<GPUCanvasContext>(context));
-#endif
-    if (is<ImageBitmapRenderingContext>(context))
-        return toJS(&state, deprecatedGlobalObjectForPrototype(&state), downcast<ImageBitmapRenderingContext>(context));
-
-    return { };
-}
-
-void InspectorCanvasAgent::resolveCanvasContext(ErrorString& errorString, const String& canvasId, const String* objectGroup, RefPtr<Inspector::Protocol::Runtime::RemoteObject>& result)
+void InspectorCanvasAgent::resolveContext(ErrorString& errorString, const String& canvasId, const String* objectGroup, RefPtr<Inspector::Protocol::Runtime::RemoteObject>& result)
 {
     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
     if (!inspectorCanvas)
         return;
 
-    auto& state = *inspectorCanvas->context().canvasBase().scriptExecutionContext()->execState();
-    auto injectedScript = m_injectedScriptManager.injectedScriptFor(&state);
+    auto* state = inspectorCanvas->scriptExecutionContext()->execState();
+    auto injectedScript = m_injectedScriptManager.injectedScriptFor(state);
     ASSERT(!injectedScript.hasNoValue());
 
-    JSC::JSValue value = contextAsScriptValue(state, inspectorCanvas->context());
+    JSC::JSValue value = inspectorCanvas->resolveContext(state);
+
     if (!value) {
         ASSERT_NOT_REACHED();
         errorString = "Internal error: unknown context of canvas for given canvasId"_s;
         return;
     }
@@ -244,11 +262,17 @@
 {
     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
     if (!inspectorCanvas)
         return;
 
-    if (inspectorCanvas->context().callTracingActive()) {
+    // FIXME: <https://webkit.org/b/201651> Web Inspector: Canvas: support canvas recordings for WebGPUDevice
+
+    auto* context = inspectorCanvas->canvasContext();
+    if (!context)
+        return;
+
+    if (context->callTracingActive()) {
         errorString = "Already recording canvas"_s;
         return;
     }
 
     RecordingOptions recordingOptions;
@@ -263,105 +287,83 @@
 {
     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
     if (!inspectorCanvas)
         return;
 
-    if (!inspectorCanvas->context().callTracingActive()) {
+    // FIXME: <https://webkit.org/b/201651> Web Inspector: Canvas: support canvas recordings for WebGPUDevice
+
+    auto* context = inspectorCanvas->canvasContext();
+    if (!context)
+        return;
+
+    if (!context->callTracingActive()) {
         errorString = "Not recording canvas"_s;
         return;
     }
 
-    didFinishRecordingCanvasFrame(inspectorCanvas->context(), true);
+    didFinishRecordingCanvasFrame(*context, true);
 }
 
-void InspectorCanvasAgent::requestShaderSource(ErrorString& errorString, const String& programId, const String& shaderType, String* content)
+void InspectorCanvasAgent::requestShaderSource(ErrorString& errorString, const String& programId, const String& shaderTypeString, String* outSource)
 {
-#if ENABLE(WEBGL)
     auto inspectorProgram = assertInspectorProgram(errorString, programId);
     if (!inspectorProgram)
         return;
 
-    auto* shader = inspectorProgram->shaderForType(shaderType);
-    if (!shader) {
-        errorString = "Missing shader for given shaderType"_s;
+    auto shaderType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString<Inspector::Protocol::Canvas::ShaderType>(shaderTypeString);
+    if (!shaderType) {
+        errorString = makeString("Unknown shaderType: "_s, shaderTypeString);
         return;
     }
 
-    *content = shader->getSource();
-#else
-    UNUSED_PARAM(programId);
-    UNUSED_PARAM(shaderType);
-    UNUSED_PARAM(content);
-    errorString = "Not supported"_s;
-#endif
+    auto source = inspectorProgram->requestShaderSource(shaderType.value());
+    if (!source) {
+        errorString = "Missing shader of given shaderType for given programId"_s;
+        return;
+    }
+
+    *outSource = source;
 }
 
-void InspectorCanvasAgent::updateShader(ErrorString& errorString, const String& programId, const String& shaderType, const String& source)
+void InspectorCanvasAgent::updateShader(ErrorString& errorString, const String& programId, const String& shaderTypeString, const String& source)
 {
-#if ENABLE(WEBGL)
     auto inspectorProgram = assertInspectorProgram(errorString, programId);
     if (!inspectorProgram)
         return;
 
-    auto* shader = inspectorProgram->shaderForType(shaderType);
-    if (!shader) {
-        errorString = "Missing shader for given shaderType"_s;
+    auto shaderType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString<Inspector::Protocol::Canvas::ShaderType>(shaderTypeString);
+    if (!shaderType) {
+        errorString = makeString("Unknown shaderType: "_s, shaderTypeString);
         return;
     }
 
-    WebGLRenderingContextBase& contextWebGL = inspectorProgram->context();
-    contextWebGL.shaderSource(shader, source);
-    contextWebGL.compileShader(shader);
-
-    if (!shader->isValid()) {
-        errorString = "Failed to update shader"_s;
-        return;
-    }
-
-    contextWebGL.linkProgramWithoutInvalidatingAttribLocations(&inspectorProgram->program());
-#else
-    UNUSED_PARAM(programId);
-    UNUSED_PARAM(shaderType);
-    UNUSED_PARAM(source);
-    errorString = "Not supported"_s;
-#endif
+    if (!inspectorProgram->updateShader(shaderType.value(), source))
+        errorString = "Failed to update shader of given shaderType for given programId"_s;
 }
 
 void InspectorCanvasAgent::setShaderProgramDisabled(ErrorString& errorString, const String& programId, bool disabled)
 {
-#if ENABLE(WEBGL)
     auto inspectorProgram = assertInspectorProgram(errorString, programId);
     if (!inspectorProgram)
         return;
 
     inspectorProgram->setDisabled(disabled);
-#else
-    UNUSED_PARAM(programId);
-    UNUSED_PARAM(disabled);
-    errorString = "Not supported"_s;
-#endif
 }
 
 void InspectorCanvasAgent::setShaderProgramHighlighted(ErrorString& errorString, const String& programId, bool highlighted)
 {
-#if ENABLE(WEBGL)
     auto inspectorProgram = assertInspectorProgram(errorString, programId);
     if (!inspectorProgram)
         return;
 
     inspectorProgram->setHighlighted(highlighted);
-#else
-    UNUSED_PARAM(programId);
-    UNUSED_PARAM(highlighted);
-    errorString = "Not supported"_s;
-#endif
 }
 
 void InspectorCanvasAgent::frameNavigated(Frame& frame)
 {
     if (frame.isMainFrame()) {
-        clearCanvasData();
+        reset();
         return;
     }
 
     Vector<InspectorCanvas*> inspectorCanvases;
     for (auto& inspectorCanvas : m_identifierToInspectorCanvas.values()) {
@@ -369,14 +371,12 @@
             if (canvasElement->document().frame() == &frame)
                 inspectorCanvases.append(inspectorCanvas.get());
         }
     }
 
-    for (auto* inspectorCanvas : inspectorCanvases) {
-        String identifier = unbindCanvas(*inspectorCanvas);
-        m_frontendDispatcher->canvasRemoved(identifier);
-    }
+    for (auto* inspectorCanvas : inspectorCanvases)
+        unbindCanvas(*inspectorCanvas);
 }
 
 void InspectorCanvasAgent::didChangeCSSCanvasClientNodes(CanvasBase& canvasBase)
 {
     auto* context = canvasBase.renderingContext();
@@ -388,11 +388,11 @@
     auto inspectorCanvas = findInspectorCanvas(*context);
     ASSERT(inspectorCanvas);
     if (!inspectorCanvas)
         return;
 
-    m_frontendDispatcher->cssCanvasClientNodesChanged(inspectorCanvas->identifier());
+    m_frontendDispatcher->clientNodesChanged(inspectorCanvas->identifier());
 }
 
 void InspectorCanvasAgent::didCreateCanvasRenderingContext(CanvasRenderingContext& context)
 {
     if (findInspectorCanvas(context)) {
@@ -409,11 +409,26 @@
     }
 }
 
 void InspectorCanvasAgent::didChangeCanvasMemory(CanvasRenderingContext& context)
 {
-    auto inspectorCanvas = findInspectorCanvas(context);
+    RefPtr<InspectorCanvas> inspectorCanvas;
+
+#if ENABLE(WEBGPU)
+    if (is<GPUCanvasContext>(context)) {
+        for (auto& item : m_identifierToInspectorCanvas.values()) {
+            if (item->isDeviceForCanvasContext(context)) {
+                inspectorCanvas = item;
+                break;
+            }
+        }
+    }
+#endif
+
+    if (!inspectorCanvas)
+        inspectorCanvas = findInspectorCanvas(context);
+
     ASSERT(inspectorCanvas);
     if (!inspectorCanvas)
         return;
 
     // FIXME: <https://webkit.org/b/180833> Web Inspector: support OffscreenCanvas for Canvas related operations
@@ -431,31 +446,44 @@
 
     ASSERT(canvasRenderingContext.callTracingActive());
     if (!canvasRenderingContext.callTracingActive())
         return;
 
-    // Only enqueue a microtask for the first action of each frame. Any subsequent actions will be
-    // covered by the initial microtask until the next frame.
-    if (!inspectorCanvas->currentFrameHasData()) {
-        if (auto* scriptExecutionContext = inspectorCanvas->context().canvasBase().scriptExecutionContext()) {
-            auto& queue = MicrotaskQueue::mainThreadQueue();
-            queue.append(makeUnique<ActiveDOMCallbackMicrotask>(queue, *scriptExecutionContext, [&, protectedInspectorCanvas = inspectorCanvas.copyRef()] {
-                if (auto* canvasElement = protectedInspectorCanvas->canvasElement()) {
-                    if (canvasElement->isDescendantOf(canvasElement->document()))
-                        return;
+    // Only enqueue one microtask for all actively recording canvases.
+    if (m_recordingCanvasIdentifiers.isEmpty()) {
+        if (auto* scriptExecutionContext = inspectorCanvas->scriptExecutionContext()) {
+            scriptExecutionContext->eventLoop().queueMicrotask([weakThis = makeWeakPtr(*this)] {
+                if (!weakThis)
+                    return;
+
+                auto& canvasAgent = *weakThis;
+
+                auto identifiers = copyToVector(canvasAgent.m_recordingCanvasIdentifiers);
+                for (auto& identifier : identifiers) {
+                    auto inspectorCanvas = canvasAgent.m_identifierToInspectorCanvas.get(identifier);
+                    if (!inspectorCanvas)
+                        continue;
+
+                    auto* canvasRenderingContext = inspectorCanvas->canvasContext();
+                    ASSERT(canvasRenderingContext);
+                    // FIXME: <https://webkit.org/b/201651> Web Inspector: Canvas: support canvas recordings for WebGPUDevice
+
+                    if (canvasRenderingContext->callTracingActive())
+                        canvasAgent.didFinishRecordingCanvasFrame(*canvasRenderingContext);
                 }
 
-                if (protectedInspectorCanvas->context().callTracingActive())
-                    didFinishRecordingCanvasFrame(protectedInspectorCanvas->context());
-            }));
+                canvasAgent.m_recordingCanvasIdentifiers.clear();
+            });
         }
     }
 
+    m_recordingCanvasIdentifiers.add(inspectorCanvas->identifier());
+
     inspectorCanvas->recordAction(name, WTFMove(parameters));
 
     if (!inspectorCanvas->hasBufferSpace())
-        didFinishRecordingCanvasFrame(inspectorCanvas->context(), true);
+        didFinishRecordingCanvasFrame(canvasRenderingContext, true);
 }
 
 void InspectorCanvasAgent::canvasChanged(CanvasBase& canvasBase, const FloatRect&)
 {
     auto* context = canvasBase.renderingContext();
@@ -479,35 +507,28 @@
     auto inspectorCanvas = findInspectorCanvas(*context);
     ASSERT(inspectorCanvas);
     if (!inspectorCanvas)
         return;
 
-    String identifier = unbindCanvas(*inspectorCanvas);
-
-    // WebCore::CanvasObserver::canvasDestroyed is called in response to the GC destroying the CanvasBase.
-    // Due to the single-process model used in WebKit1, the event must be dispatched from a timer to prevent
-    // the frontend from making JS allocations while the GC is still active.
-    m_removedCanvasIdentifiers.append(identifier);
-
-    if (!m_canvasDestroyedTimer.isActive())
-        m_canvasDestroyedTimer.startOneShot(0_s);
+    unbindCanvas(*inspectorCanvas);
 }
 
 void InspectorCanvasAgent::didFinishRecordingCanvasFrame(CanvasRenderingContext& context, bool forceDispatch)
 {
+    if (!context.callTracingActive())
+        return;
+
     auto inspectorCanvas = findInspectorCanvas(context);
     ASSERT(inspectorCanvas);
     if (!inspectorCanvas)
         return;
 
-    if (!inspectorCanvas->context().callTracingActive())
-        return;
-
     if (!inspectorCanvas->hasRecordingData()) {
         if (forceDispatch) {
             m_frontendDispatcher->recordingFinished(inspectorCanvas->identifier(), nullptr);
             inspectorCanvas->resetRecordingData();
+            ASSERT(!m_recordingCanvasIdentifiers.contains(inspectorCanvas->identifier()));
         }
         return;
     }
 
     if (forceDispatch)
@@ -519,13 +540,15 @@
 
     if (!forceDispatch && !inspectorCanvas->overFrameCount())
         return;
 
     m_frontendDispatcher->recordingFinished(inspectorCanvas->identifier(), inspectorCanvas->releaseObjectForRecording());
+
+    m_recordingCanvasIdentifiers.remove(inspectorCanvas->identifier());
 }
 
-void InspectorCanvasAgent::consoleStartRecordingCanvas(CanvasRenderingContext& context, JSC::ExecState& exec, JSC::JSObject* options)
+void InspectorCanvasAgent::consoleStartRecordingCanvas(CanvasRenderingContext& context, JSC::JSGlobalObject& exec, JSC::JSObject* options)
 {
     auto inspectorCanvas = findInspectorCanvas(context);
     ASSERT(inspectorCanvas);
     if (!inspectorCanvas)
         return;
@@ -543,10 +566,15 @@
             recordingOptions.name = optionName.toWTFString(&exec);
     }
     startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Console, WTFMove(recordingOptions));
 }
 
+void InspectorCanvasAgent::consoleStopRecordingCanvas(CanvasRenderingContext& context)
+{
+    didFinishRecordingCanvasFrame(context, true);
+}
+
 #if ENABLE(WEBGL)
 void InspectorCanvasAgent::didEnableExtension(WebGLRenderingContextBase& context, const String& extension)
 {
     auto inspectorCanvas = findInspectorCanvas(context);
     ASSERT(inspectorCanvas);
@@ -554,79 +582,144 @@
         return;
 
     m_frontendDispatcher->extensionEnabled(inspectorCanvas->identifier(), extension);
 }
 
-void InspectorCanvasAgent::didCreateProgram(WebGLRenderingContextBase& context, WebGLProgram& program)
+void InspectorCanvasAgent::didCreateWebGLProgram(WebGLRenderingContextBase& context, WebGLProgram& program)
 {
     auto inspectorCanvas = findInspectorCanvas(context);
     ASSERT(inspectorCanvas);
     if (!inspectorCanvas)
         return;
 
-    auto inspectorProgram = InspectorShaderProgram::create(program, *inspectorCanvas);
-    String programIdentifier = inspectorProgram->identifier();
-    m_identifierToInspectorProgram.set(programIdentifier, WTFMove(inspectorProgram));
-    m_frontendDispatcher->programCreated(inspectorCanvas->identifier(), programIdentifier);
+    auto inspectorProgramRef = InspectorShaderProgram::create(program, *inspectorCanvas);
+    auto& inspectorProgram = inspectorProgramRef.get();
+    m_identifierToInspectorProgram.set(inspectorProgram.identifier(), WTFMove(inspectorProgramRef));
+    m_frontendDispatcher->programCreated(inspectorProgram.buildObjectForShaderProgram());
 }
 
-void InspectorCanvasAgent::willDeleteProgram(WebGLProgram& program)
+void InspectorCanvasAgent::willDestroyWebGLProgram(WebGLProgram& program)
 {
     auto inspectorProgram = findInspectorProgram(program);
     if (!inspectorProgram)
         return;
 
-    String identifier = unbindProgram(*inspectorProgram);
-    m_frontendDispatcher->programDeleted(identifier);
+    unbindProgram(*inspectorProgram);
 }
 
-bool InspectorCanvasAgent::isShaderProgramDisabled(WebGLProgram& program)
+bool InspectorCanvasAgent::isWebGLProgramDisabled(WebGLProgram& program)
 {
     auto inspectorProgram = findInspectorProgram(program);
     ASSERT(inspectorProgram);
     if (!inspectorProgram)
         return false;
 
     return inspectorProgram->disabled();
 }
 
-bool InspectorCanvasAgent::isShaderProgramHighlighted(WebGLProgram& program)
+bool InspectorCanvasAgent::isWebGLProgramHighlighted(WebGLProgram& program)
 {
     auto inspectorProgram = findInspectorProgram(program);
     ASSERT(inspectorProgram);
     if (!inspectorProgram)
         return false;
 
     return inspectorProgram->highlighted();
 }
 #endif
 
+#if ENABLE(WEBGPU)
+void InspectorCanvasAgent::didCreateWebGPUDevice(WebGPUDevice& device)
+{
+    if (findInspectorCanvas(device)) {
+        ASSERT_NOT_REACHED();
+        return;
+    }
+
+    bindCanvas(device, true);
+}
+
+void InspectorCanvasAgent::willDestroyWebGPUDevice(WebGPUDevice& device)
+{
+    auto inspectorCanvas = findInspectorCanvas(device);
+    ASSERT(inspectorCanvas);
+    if (!inspectorCanvas)
+        return;
+
+    unbindCanvas(*inspectorCanvas);
+}
+
+void InspectorCanvasAgent::willConfigureSwapChain(GPUCanvasContext& contextGPU, WebGPUSwapChain& newSwapChain)
+{
+    auto notifyDeviceForSwapChain = [&] (WebGPUSwapChain& webGPUSwapChain) {
+        for (auto& inspectorCanvas : m_identifierToInspectorCanvas.values()) {
+            if (auto* device = inspectorCanvas->deviceContext()) {
+                if (device->device().swapChain() == webGPUSwapChain.swapChain())
+                    m_frontendDispatcher->clientNodesChanged(inspectorCanvas->identifier());
+            }
+        }
+    };
+
+    if (auto* existingSwapChain = contextGPU.swapChain())
+        notifyDeviceForSwapChain(*existingSwapChain);
+
+    notifyDeviceForSwapChain(newSwapChain);
+}
+
+void InspectorCanvasAgent::didCreateWebGPUPipeline(WebGPUDevice& device, WebGPUPipeline& pipeline)
+{
+    auto inspectorCanvas = findInspectorCanvas(device);
+    ASSERT(inspectorCanvas);
+    if (!inspectorCanvas)
+        return;
+
+    ASSERT(pipeline.isValid());
+
+    auto inspectorProgramRef = InspectorShaderProgram::create(pipeline, *inspectorCanvas);
+    auto& inspectorProgram = inspectorProgramRef.get();
+    m_identifierToInspectorProgram.set(inspectorProgram.identifier(), WTFMove(inspectorProgramRef));
+    m_frontendDispatcher->programCreated(inspectorProgram.buildObjectForShaderProgram());
+}
+
+void InspectorCanvasAgent::willDestroyWebGPUPipeline(WebGPUPipeline& pipeline)
+{
+    auto inspectorProgram = findInspectorProgram(pipeline);
+    if (!inspectorProgram)
+        return;
+
+    unbindProgram(*inspectorProgram);
+}
+#endif
+
 void InspectorCanvasAgent::startRecording(InspectorCanvas& inspectorCanvas, Inspector::Protocol::Recording::Initiator initiator, RecordingOptions&& recordingOptions)
 {
-    auto& canvasRenderingContext = inspectorCanvas.context();
+    auto* context = inspectorCanvas.canvasContext();
+    ASSERT(context);
+    // FIXME: <https://webkit.org/b/201651> Web Inspector: Canvas: support canvas recordings for WebGPUDevice
 
-    if (!is<CanvasRenderingContext2D>(canvasRenderingContext)
+    if (!is<CanvasRenderingContext2D>(context)
+        && !is<ImageBitmapRenderingContext>(context)
 #if ENABLE(WEBGL)
-        && !is<WebGLRenderingContext>(canvasRenderingContext)
+        && !is<WebGLRenderingContext>(context)
 #endif
 #if ENABLE(WEBGL2)
-        && !is<WebGL2RenderingContext>(canvasRenderingContext)
+        && !is<WebGL2RenderingContext>(context)
 #endif
-        && !is<ImageBitmapRenderingContext>(canvasRenderingContext))
+    )
         return;
 
-    if (canvasRenderingContext.callTracingActive())
+    if (context->callTracingActive())
         return;
 
     inspectorCanvas.resetRecordingData();
     if (recordingOptions.frameCount)
         inspectorCanvas.setFrameCount(recordingOptions.frameCount.value());
     if (recordingOptions.memoryLimit)
         inspectorCanvas.setBufferLimit(recordingOptions.memoryLimit.value());
     if (recordingOptions.name)
         inspectorCanvas.setRecordingName(recordingOptions.name.value());
-    canvasRenderingContext.setCallTracingActive(true);
+    context->setCallTracingActive(true);
 
     m_frontendDispatcher->recordingStarted(inspectorCanvas.identifier(), initiator);
 }
 
 void InspectorCanvasAgent::canvasDestroyedTimerFired()
@@ -638,37 +731,53 @@
         m_frontendDispatcher->canvasRemoved(identifier);
 
     m_removedCanvasIdentifiers.clear();
 }
 
-void InspectorCanvasAgent::clearCanvasData()
+void InspectorCanvasAgent::programDestroyedTimerFired()
+{
+    if (!m_removedProgramIdentifiers.size())
+        return;
+
+    for (auto& identifier : m_removedProgramIdentifiers)
+        m_frontendDispatcher->programDeleted(identifier);
+
+    m_removedProgramIdentifiers.clear();
+}
+
+void InspectorCanvasAgent::reset()
 {
-    for (auto& inspectorCanvas : m_identifierToInspectorCanvas.values())
-        inspectorCanvas->context().canvasBase().removeObserver(*this);
+    for (auto& inspectorCanvas : m_identifierToInspectorCanvas.values()) {
+        if (auto* context = inspectorCanvas->canvasContext())
+            context->canvasBase().removeObserver(*this);
+    }
 
     m_identifierToInspectorCanvas.clear();
-#if ENABLE(WEBGL)
-    m_identifierToInspectorProgram.clear();
     m_removedCanvasIdentifiers.clear();
-#endif
-
     if (m_canvasDestroyedTimer.isActive())
         m_canvasDestroyedTimer.stop();
+
+    m_identifierToInspectorProgram.clear();
+    m_removedProgramIdentifiers.clear();
+    if (m_programDestroyedTimer.isActive())
+        m_programDestroyedTimer.stop();
+
+    m_recordingCanvasIdentifiers.clear();
 }
 
 InspectorCanvas& InspectorCanvasAgent::bindCanvas(CanvasRenderingContext& context, bool captureBacktrace)
 {
     auto inspectorCanvas = InspectorCanvas::create(context);
     m_identifierToInspectorCanvas.set(inspectorCanvas->identifier(), inspectorCanvas.copyRef());
 
-    inspectorCanvas->context().canvasBase().addObserver(*this);
+    context.canvasBase().addObserver(*this);
 
     m_frontendDispatcher->canvasAdded(inspectorCanvas->buildObjectForCanvas(captureBacktrace));
 
 #if ENABLE(WEBGL)
-    if (is<WebGLRenderingContextBase>(inspectorCanvas->context())) {
-        WebGLRenderingContextBase& contextWebGL = downcast<WebGLRenderingContextBase>(inspectorCanvas->context());
+    if (is<WebGLRenderingContextBase>(context)) {
+        auto& contextWebGL = downcast<WebGLRenderingContextBase>(context);
         if (Optional<Vector<String>> extensions = contextWebGL.getSupportedExtensions()) {
             for (const String& extension : *extensions) {
                 if (contextWebGL.extensionIsEnabled(extension))
                     m_frontendDispatcher->extensionEnabled(inspectorCanvas->identifier(), extension);
             }
@@ -677,11 +786,23 @@
 #endif
 
     return inspectorCanvas;
 }
 
-String InspectorCanvasAgent::unbindCanvas(InspectorCanvas& inspectorCanvas)
+#if ENABLE(WEBGPU)
+InspectorCanvas& InspectorCanvasAgent::bindCanvas(WebGPUDevice& device, bool captureBacktrace)
+{
+    auto inspectorCanvas = InspectorCanvas::create(device);
+    m_identifierToInspectorCanvas.set(inspectorCanvas->identifier(), inspectorCanvas.copyRef());
+
+    m_frontendDispatcher->canvasAdded(inspectorCanvas->buildObjectForCanvas(captureBacktrace));
+
+    return inspectorCanvas;
+}
+#endif
+
+void InspectorCanvasAgent::unbindCanvas(InspectorCanvas& inspectorCanvas)
 {
 #if ENABLE(WEBGL)
     Vector<InspectorShaderProgram*> programsToRemove;
     for (auto& inspectorProgram : m_identifierToInspectorProgram.values()) {
         if (&inspectorProgram->canvas() == &inspectorCanvas)
@@ -690,16 +811,23 @@
 
     for (auto* inspectorProgram : programsToRemove)
         unbindProgram(*inspectorProgram);
 #endif
 
-    inspectorCanvas.context().canvasBase().removeObserver(*this);
+    if (auto* context = inspectorCanvas.canvasContext())
+        context->canvasBase().removeObserver(*this);
 
     String identifier = inspectorCanvas.identifier();
     m_identifierToInspectorCanvas.remove(identifier);
 
-    return identifier;
+    // This can be called in response to GC. Due to the single-process model used in WebKit1, the
+    // event must be dispatched from a timer to prevent the frontend from making JS allocations
+    // while the GC is still active.
+    m_removedCanvasIdentifiers.append(identifier);
+
+    if (!m_canvasDestroyedTimer.isActive())
+        m_canvasDestroyedTimer.startOneShot(0_s);
 }
 
 RefPtr<InspectorCanvas> InspectorCanvasAgent::assertInspectorCanvas(ErrorString& errorString, const String& canvasId)
 {
     auto inspectorCanvas = m_identifierToInspectorCanvas.get(canvasId);
@@ -711,23 +839,39 @@
 }
 
 RefPtr<InspectorCanvas> InspectorCanvasAgent::findInspectorCanvas(CanvasRenderingContext& context)
 {
     for (auto& inspectorCanvas : m_identifierToInspectorCanvas.values()) {
-        if (&inspectorCanvas->context() == &context)
+        if (inspectorCanvas->canvasContext() == &context)
             return inspectorCanvas;
     }
     return nullptr;
 }
 
-#if ENABLE(WEBGL)
-String InspectorCanvasAgent::unbindProgram(InspectorShaderProgram& inspectorProgram)
+#if ENABLE(WEBGPU)
+RefPtr<InspectorCanvas> InspectorCanvasAgent::findInspectorCanvas(WebGPUDevice& device)
+{
+    for (auto& inspectorCanvas : m_identifierToInspectorCanvas.values()) {
+        if (inspectorCanvas->deviceContext() == &device)
+            return inspectorCanvas;
+    }
+    return nullptr;
+}
+#endif
+
+void InspectorCanvasAgent::unbindProgram(InspectorShaderProgram& inspectorProgram)
 {
     String identifier = inspectorProgram.identifier();
     m_identifierToInspectorProgram.remove(identifier);
 
-    return identifier;
+    // This can be called in response to GC. Due to the single-process model used in WebKit1, the
+    // event must be dispatched from a timer to prevent the frontend from making JS allocations
+    // while the GC is still active.
+    m_removedProgramIdentifiers.append(identifier);
+
+    if (!m_programDestroyedTimer.isActive())
+        m_programDestroyedTimer.startOneShot(0_s);
 }
 
 RefPtr<InspectorShaderProgram> InspectorCanvasAgent::assertInspectorProgram(ErrorString& errorString, const String& programId)
 {
     auto inspectorProgram = m_identifierToInspectorProgram.get(programId);
@@ -736,14 +880,26 @@
         return nullptr;
     }
     return inspectorProgram;
 }
 
+#if ENABLE(WEBGL)
 RefPtr<InspectorShaderProgram> InspectorCanvasAgent::findInspectorProgram(WebGLProgram& program)
 {
     for (auto& inspectorProgram : m_identifierToInspectorProgram.values()) {
-        if (&inspectorProgram->program() == &program)
+        if (inspectorProgram->program() == &program)
+            return inspectorProgram;
+    }
+    return nullptr;
+}
+#endif
+
+#if ENABLE(WEBGPU)
+RefPtr<InspectorShaderProgram> InspectorCanvasAgent::findInspectorProgram(WebGPUPipeline& pipeline)
+{
+    for (auto& inspectorProgram : m_identifierToInspectorProgram.values()) {
+        if (inspectorProgram->pipeline() == &pipeline)
             return inspectorProgram;
     }
     return nullptr;
 }
 #endif

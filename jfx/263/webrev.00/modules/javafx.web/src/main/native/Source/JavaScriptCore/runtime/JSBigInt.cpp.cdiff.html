<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSAsyncGeneratorFunction.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBigInt.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
   * Copyright (C) 2017 Caio Lima &lt;ticaiolima@gmail.com&gt;
<span class="line-modified">!  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (C) 2017 Caio Lima &lt;ticaiolima@gmail.com&gt;
<span class="line-modified">!  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,15 ***</span>
  
  namespace JSC {
  
  const ClassInfo JSBigInt::s_info = { &quot;BigInt&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSBigInt) };
  
<span class="line-modified">! JSBigInt::JSBigInt(VM&amp; vm, Structure* structure, unsigned length)</span>
      : Base(vm, structure)
      , m_length(length)
  { }
  
  void JSBigInt::initialize(InitializationType initType)
  {
      if (initType == InitializationType::WithZero)
          memset(dataStorage(), 0, length() * sizeof(Digit));
  }
<span class="line-new-header">--- 59,21 ---</span>
  
  namespace JSC {
  
  const ClassInfo JSBigInt::s_info = { &quot;BigInt&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSBigInt) };
  
<span class="line-modified">! JSBigInt::JSBigInt(VM&amp; vm, Structure* structure, Digit* data, unsigned length)</span>
      : Base(vm, structure)
      , m_length(length)
<span class="line-added">+     , m_data(data, length)</span>
  { }
  
<span class="line-added">+ void JSBigInt::destroy(JSCell* thisCell)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static_cast&lt;JSBigInt*&gt;(thisCell)-&gt;~JSBigInt();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JSBigInt::initialize(InitializationType initType)
  {
      if (initType == InitializationType::WithZero)
          memset(dataStorage(), 0, length() * sizeof(Digit));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,23 ***</span>
  {
      JSBigInt* zeroBigInt = createWithLengthUnchecked(vm, 0);
      return zeroBigInt;
  }
  
<span class="line-modified">! inline size_t JSBigInt::allocationSize(unsigned length)</span>
  {
<span class="line-modified">!     size_t sizeWithPadding = WTF::roundUpToMultipleOf&lt;sizeof(size_t)&gt;(sizeof(JSBigInt));</span>
<span class="line-removed">-     return sizeWithPadding + length * sizeof(Digit);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JSBigInt* JSBigInt::tryCreateWithLength(ExecState* exec, unsigned length)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (UNLIKELY(length &gt; maxLength)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
  
      scope.release();
  
<span class="line-new-header">--- 87,17 ---</span>
  {
      JSBigInt* zeroBigInt = createWithLengthUnchecked(vm, 0);
      return zeroBigInt;
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::tryCreateWithLength(JSGlobalObject* globalObject, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (UNLIKELY(length &gt; maxLength)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      scope.release();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,11 ***</span>
  }
  
  JSBigInt* JSBigInt::createWithLengthUnchecked(VM&amp; vm, unsigned length)
  {
      ASSERT(length &lt;= maxLength);
<span class="line-modified">!     JSBigInt* bigInt = new (NotNull, allocateCell&lt;JSBigInt&gt;(vm.heap, allocationSize(length))) JSBigInt(vm, vm.bigIntStructure.get(), length);</span>
      bigInt-&gt;finishCreation(vm);
      return bigInt;
  }
  
  JSBigInt* JSBigInt::createFrom(VM&amp; vm, int32_t value)
<span class="line-new-header">--- 105,12 ---</span>
  }
  
  JSBigInt* JSBigInt::createWithLengthUnchecked(VM&amp; vm, unsigned length)
  {
      ASSERT(length &lt;= maxLength);
<span class="line-modified">!     void* data = Gigacage::malloc(Gigacage::Primitive, length * sizeof(Digit));</span>
<span class="line-added">+     JSBigInt* bigInt = new (NotNull, allocateCell&lt;JSBigInt&gt;(vm.heap)) JSBigInt(vm, vm.bigIntStructure.get(), reinterpret_cast&lt;Digit*&gt;(data), length);</span>
      bigInt-&gt;finishCreation(vm);
      return bigInt;
  }
  
  JSBigInt* JSBigInt::createFrom(VM&amp; vm, int32_t value)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,11 ***</span>
      JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
      bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
      return bigInt;
  }
  
<span class="line-modified">! JSValue JSBigInt::toPrimitive(ExecState*, PreferredPrimitiveType) const</span>
  {
      return const_cast&lt;JSBigInt*&gt;(this);
  }
  
  Optional&lt;uint8_t&gt; JSBigInt::singleDigitValueForString()
<span class="line-new-header">--- 181,11 ---</span>
      JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
      bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
      return bigInt;
  }
  
<span class="line-modified">! JSValue JSBigInt::toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const</span>
  {
      return const_cast&lt;JSBigInt*&gt;(this);
  }
  
  Optional&lt;uint8_t&gt; JSBigInt::singleDigitValueForString()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,38 ***</span>
              return static_cast&lt;uint8_t&gt;(rDigit);
      }
      return { };
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::parseInt(ExecState* exec, StringView s, ErrorParseMode parserMode)</span>
  {
      if (s.is8Bit())
<span class="line-modified">!         return parseInt(exec, s.characters8(), s.length(), parserMode);</span>
<span class="line-modified">!     return parseInt(exec, s.characters16(), s.length(), parserMode);</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::parseInt(ExecState* exec, VM&amp; vm, StringView s, uint8_t radix, ErrorParseMode parserMode, ParseIntSign sign)</span>
  {
      if (s.is8Bit())
<span class="line-modified">!         return parseInt(exec, vm, s.characters8(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);</span>
<span class="line-modified">!     return parseInt(exec, vm, s.characters16(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::stringToBigInt(ExecState* exec, StringView s)</span>
  {
<span class="line-modified">!     return parseInt(exec, s, ErrorParseMode::IgnoreExceptions);</span>
  }
  
<span class="line-modified">! String JSBigInt::toString(ExecState* exec, unsigned radix)</span>
  {
      if (this-&gt;isZero())
<span class="line-modified">!         return exec-&gt;vm().smallStrings.singleCharacterStringRep(&#39;0&#39;);</span>
  
      if (hasOneBitSet(radix))
<span class="line-modified">!         return toStringBasePowerOfTwo(exec-&gt;vm(), exec, this, radix);</span>
  
<span class="line-modified">!     return toStringGeneric(exec-&gt;vm(), exec, this, radix);</span>
  }
  
  String JSBigInt::tryGetString(VM&amp; vm, JSBigInt* bigInt, unsigned radix)
  {
      if (bigInt-&gt;isZero())
<span class="line-new-header">--- 199,38 ---</span>
              return static_cast&lt;uint8_t&gt;(rDigit);
      }
      return { };
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, StringView s, ErrorParseMode parserMode)</span>
  {
      if (s.is8Bit())
<span class="line-modified">!         return parseInt(globalObject, s.characters8(), s.length(), parserMode);</span>
<span class="line-modified">!     return parseInt(globalObject, s.characters16(), s.length(), parserMode);</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, VM&amp; vm, StringView s, uint8_t radix, ErrorParseMode parserMode, ParseIntSign sign)</span>
  {
      if (s.is8Bit())
<span class="line-modified">!         return parseInt(globalObject, vm, s.characters8(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);</span>
<span class="line-modified">!     return parseInt(globalObject, vm, s.characters16(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::stringToBigInt(JSGlobalObject* globalObject, StringView s)</span>
  {
<span class="line-modified">!     return parseInt(globalObject, s, ErrorParseMode::IgnoreExceptions);</span>
  }
  
<span class="line-modified">! String JSBigInt::toString(JSGlobalObject* globalObject, unsigned radix)</span>
  {
      if (this-&gt;isZero())
<span class="line-modified">!         return globalObject-&gt;vm().smallStrings.singleCharacterStringRep(&#39;0&#39;);</span>
  
      if (hasOneBitSet(radix))
<span class="line-modified">!         return toStringBasePowerOfTwo(globalObject-&gt;vm(), globalObject, this, radix);</span>
  
<span class="line-modified">!     return toStringGeneric(globalObject-&gt;vm(), globalObject, this, radix);</span>
  }
  
  String JSBigInt::tryGetString(VM&amp; vm, JSBigInt* bigInt, unsigned radix)
  {
      if (bigInt-&gt;isZero())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,17 ***</span>
  void JSBigInt::inplaceMultiplyAdd(Digit factor, Digit summand)
  {
      internalMultiplyAdd(this, factor, summand, length(), this);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::exponentiate(ExecState* exec, JSBigInt* base, JSBigInt* exponent)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (exponent-&gt;sign()) {
<span class="line-modified">!         throwRangeError(exec, scope, &quot;Negative exponent is not allowed&quot;_s);</span>
          return nullptr;
      }
  
      // 2. If base is 0n and exponent is 0n, return 1n.
      if (exponent-&gt;isZero())
<span class="line-new-header">--- 246,17 ---</span>
  void JSBigInt::inplaceMultiplyAdd(Digit factor, Digit summand)
  {
      internalMultiplyAdd(this, factor, summand, length(), this);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::exponentiate(JSGlobalObject* globalObject, JSBigInt* base, JSBigInt* exponent)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (exponent-&gt;sign()) {
<span class="line-modified">!         throwRangeError(globalObject, scope, &quot;Negative exponent is not allowed&quot;_s);</span>
          return nullptr;
      }
  
      // 2. If base is 0n and exponent is 0n, return 1n.
      if (exponent-&gt;isZero())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,28 ***</span>
  
      // For all bases &gt;= 2, very large exponents would lead to unrepresentable
      // results.
      static_assert(maxLengthBits &lt; std::numeric_limits&lt;Digit&gt;::max(), &quot;maxLengthBits needs to be less than digit::max()&quot;);
      if (exponent-&gt;length() &gt; 1) {
<span class="line-modified">!         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
          return nullptr;
      }
  
      Digit expValue = exponent-&gt;digit(0);
      if (expValue == 1)
          return base;
      if (expValue &gt;= maxLengthBits) {
<span class="line-modified">!         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
          return nullptr;
      }
  
      static_assert(maxLengthBits &lt;= maxInt, &quot;maxLengthBits needs to be &lt;= maxInt&quot;);
      int n = static_cast&lt;int&gt;(expValue);
      if (base-&gt;length() == 1 &amp;&amp; base-&gt;digit(0) == 2) {
          // Fast path for 2^n.
          int neededDigits = 1 + (n / digitBits);
<span class="line-modified">!         JSBigInt* result = JSBigInt::tryCreateWithLength(exec, neededDigits);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
  
          result-&gt;initialize(InitializationType::WithZero);
          // All bits are zero. Now set the n-th bit.
          Digit msd = static_cast&lt;Digit&gt;(1) &lt;&lt; (n % digitBits);
<span class="line-new-header">--- 278,28 ---</span>
  
      // For all bases &gt;= 2, very large exponents would lead to unrepresentable
      // results.
      static_assert(maxLengthBits &lt; std::numeric_limits&lt;Digit&gt;::max(), &quot;maxLengthBits needs to be less than digit::max()&quot;);
      if (exponent-&gt;length() &gt; 1) {
<span class="line-modified">!         throwRangeError(globalObject, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
          return nullptr;
      }
  
      Digit expValue = exponent-&gt;digit(0);
      if (expValue == 1)
          return base;
      if (expValue &gt;= maxLengthBits) {
<span class="line-modified">!         throwRangeError(globalObject, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
          return nullptr;
      }
  
      static_assert(maxLengthBits &lt;= maxInt, &quot;maxLengthBits needs to be &lt;= maxInt&quot;);
      int n = static_cast&lt;int&gt;(expValue);
      if (base-&gt;length() == 1 &amp;&amp; base-&gt;digit(0) == 2) {
          // Fast path for 2^n.
          int neededDigits = 1 + (n / digitBits);
<span class="line-modified">!         JSBigInt* result = JSBigInt::tryCreateWithLength(globalObject, neededDigits);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
  
          result-&gt;initialize(InitializationType::WithZero);
          // All bits are zero. Now set the n-th bit.
          Digit msd = static_cast&lt;Digit&gt;(1) &lt;&lt; (n % digitBits);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 317,57 ***</span>
      if (n &amp; 1)
          result = base;
  
      n &gt;&gt;= 1;
      for (; n; n &gt;&gt;= 1) {
<span class="line-modified">!         JSBigInt* maybeResult = JSBigInt::multiply(exec, runningSquare, runningSquare);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
          runningSquare = maybeResult;
          if (n &amp; 1) {
              if (!result)
                  result = runningSquare;
              else {
<span class="line-modified">!                 maybeResult = JSBigInt::multiply(exec, result, runningSquare);</span>
                  RETURN_IF_EXCEPTION(scope, nullptr);
                  result = maybeResult;
              }
          }
      }
  
      return result;
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::multiply(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (x-&gt;isZero())
          return x;
      if (y-&gt;isZero())
          return y;
  
      unsigned resultLength = x-&gt;length() + y-&gt;length();
<span class="line-modified">!     JSBigInt* result = JSBigInt::tryCreateWithLength(exec, resultLength);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      result-&gt;initialize(InitializationType::WithZero);
  
      for (unsigned i = 0; i &lt; x-&gt;length(); i++)
          multiplyAccumulate(y, x-&gt;digit(i), result, i);
  
      result-&gt;setSign(x-&gt;sign() != y-&gt;sign());
      return result-&gt;rightTrim(vm);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::divide(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
  {
      // 1. If y is 0n, throw a RangeError exception.
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (y-&gt;isZero()) {
<span class="line-modified">!         throwRangeError(exec, scope, &quot;0 is an invalid divisor value.&quot;_s);</span>
          return nullptr;
      }
  
      // 2. Let quotient be the mathematical value of x divided by y.
      // 3. Return a BigInt representing quotient rounded towards 0 to the next
<span class="line-new-header">--- 318,57 ---</span>
      if (n &amp; 1)
          result = base;
  
      n &gt;&gt;= 1;
      for (; n; n &gt;&gt;= 1) {
<span class="line-modified">!         JSBigInt* maybeResult = JSBigInt::multiply(globalObject, runningSquare, runningSquare);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
          runningSquare = maybeResult;
          if (n &amp; 1) {
              if (!result)
                  result = runningSquare;
              else {
<span class="line-modified">!                 maybeResult = JSBigInt::multiply(globalObject, result, runningSquare);</span>
                  RETURN_IF_EXCEPTION(scope, nullptr);
                  result = maybeResult;
              }
          }
      }
  
      return result;
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::multiply(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (x-&gt;isZero())
          return x;
      if (y-&gt;isZero())
          return y;
  
      unsigned resultLength = x-&gt;length() + y-&gt;length();
<span class="line-modified">!     JSBigInt* result = JSBigInt::tryCreateWithLength(globalObject, resultLength);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      result-&gt;initialize(InitializationType::WithZero);
  
      for (unsigned i = 0; i &lt; x-&gt;length(); i++)
          multiplyAccumulate(y, x-&gt;digit(i), result, i);
  
      result-&gt;setSign(x-&gt;sign() != y-&gt;sign());
      return result-&gt;rightTrim(vm);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::divide(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
  {
      // 1. If y is 0n, throw a RangeError exception.
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (y-&gt;isZero()) {
<span class="line-modified">!         throwRangeError(globalObject, scope, &quot;0 is an invalid divisor value.&quot;_s);</span>
          return nullptr;
      }
  
      // 2. Let quotient be the mathematical value of x divided by y.
      // 3. Return a BigInt representing quotient rounded towards 0 to the next
</pre>
<hr />
<pre>
<span class="line-old-header">*** 383,11 ***</span>
              return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
  
          Digit remainder;
          absoluteDivWithDigitDivisor(vm, x, divisor, &amp;quotient, remainder);
      } else {
<span class="line-modified">!         absoluteDivWithBigIntDivisor(exec, x, y, &amp;quotient, nullptr);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
      }
  
      quotient-&gt;setSign(resultSign);
      return quotient-&gt;rightTrim(vm);
<span class="line-new-header">--- 384,11 ---</span>
              return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
  
          Digit remainder;
          absoluteDivWithDigitDivisor(vm, x, divisor, &amp;quotient, remainder);
      } else {
<span class="line-modified">!         absoluteDivWithBigIntDivisor(globalObject, x, y, &amp;quotient, nullptr);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
      }
  
      quotient-&gt;setSign(resultSign);
      return quotient-&gt;rightTrim(vm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,18 ***</span>
      JSBigInt* result = copy(vm, x);
      result-&gt;setSign(!x-&gt;sign());
      return result;
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::remainder(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
  {
      // 1. If y is 0n, throw a RangeError exception.
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (y-&gt;isZero()) {
<span class="line-modified">!         throwRangeError(exec, scope, &quot;0 is an invalid divisor value.&quot;_s);</span>
          return nullptr;
      }
  
      // 2. Return the JSBigInt representing x modulo y.
      // See https://github.com/tc39/proposal-bigint/issues/84 though.
<span class="line-new-header">--- 412,18 ---</span>
      JSBigInt* result = copy(vm, x);
      result-&gt;setSign(!x-&gt;sign());
      return result;
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::remainder(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
  {
      // 1. If y is 0n, throw a RangeError exception.
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (y-&gt;isZero()) {
<span class="line-modified">!         throwRangeError(globalObject, scope, &quot;0 is an invalid divisor value.&quot;_s);</span>
          return nullptr;
      }
  
      // 2. Return the JSBigInt representing x modulo y.
      // See https://github.com/tc39/proposal-bigint/issues/84 though.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 441,58 ***</span>
              return createZero(vm);
  
          remainder = createWithLengthUnchecked(vm, 1);
          remainder-&gt;setDigit(0, remainderDigit);
      } else {
<span class="line-modified">!         absoluteDivWithBigIntDivisor(exec, x, y, nullptr, &amp;remainder);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
      }
  
      remainder-&gt;setSign(x-&gt;sign());
      return remainder-&gt;rightTrim(vm);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::add(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      bool xSign = x-&gt;sign();
  
      // x + y == x + y
      // -x + -y == -(x + y)
      if (xSign == y-&gt;sign())
<span class="line-modified">!         return absoluteAdd(exec, x, y, xSign);</span>
  
      // x + -y == x - y == -(y - x)
      // -x + y == y - x == -(x - y)
      ComparisonResult comparisonResult = absoluteCompare(x, y);
      if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
          return absoluteSub(vm, x, y, xSign);
  
      return absoluteSub(vm, y, x, !xSign);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::sub(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      bool xSign = x-&gt;sign();
      if (xSign != y-&gt;sign()) {
          // x - (-y) == x + y
          // (-x) - y == -(x + y)
<span class="line-modified">!         return absoluteAdd(exec, x, y, xSign);</span>
      }
      // x - y == -(y - x)
      // (-x) - (-y) == y - x == -(x - y)
      ComparisonResult comparisonResult = absoluteCompare(x, y);
      if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
          return absoluteSub(vm, x, y, xSign);
  
      return absoluteSub(vm, y, x, !xSign);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::bitwiseAnd(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
          scope.release();
          return absoluteAnd(vm, x, y);
<span class="line-new-header">--- 442,72 ---</span>
              return createZero(vm);
  
          remainder = createWithLengthUnchecked(vm, 1);
          remainder-&gt;setDigit(0, remainderDigit);
      } else {
<span class="line-modified">!         absoluteDivWithBigIntDivisor(globalObject, x, y, nullptr, &amp;remainder);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
      }
  
      remainder-&gt;setSign(x-&gt;sign());
      return remainder-&gt;rightTrim(vm);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::inc(JSGlobalObject* globalObject, JSBigInt* x)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // FIXME: we can probably do something a fair bit more efficient here</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     return add(globalObject, x, vm.bigIntConstantOne.get());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JSBigInt* JSBigInt::dec(JSGlobalObject* globalObject, JSBigInt* x)</span>
  {
<span class="line-modified">!     // FIXME: we can probably do something a fair bit more efficient here</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     return sub(globalObject, x, vm.bigIntConstantOne.get());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JSBigInt* JSBigInt::add(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      bool xSign = x-&gt;sign();
  
      // x + y == x + y
      // -x + -y == -(x + y)
      if (xSign == y-&gt;sign())
<span class="line-modified">!         return absoluteAdd(globalObject, x, y, xSign);</span>
  
      // x + -y == x - y == -(y - x)
      // -x + y == y - x == -(x - y)
      ComparisonResult comparisonResult = absoluteCompare(x, y);
      if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
          return absoluteSub(vm, x, y, xSign);
  
      return absoluteSub(vm, y, x, !xSign);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::sub(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      bool xSign = x-&gt;sign();
      if (xSign != y-&gt;sign()) {
          // x - (-y) == x + y
          // (-x) - y == -(x + y)
<span class="line-modified">!         return absoluteAdd(globalObject, x, y, xSign);</span>
      }
      // x - y == -(y - x)
      // (-x) - (-y) == y - x == -(x - y)
      ComparisonResult comparisonResult = absoluteCompare(x, y);
      if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
          return absoluteSub(vm, x, y, xSign);
  
      return absoluteSub(vm, y, x, !xSign);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::bitwiseAnd(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
          scope.release();
          return absoluteAnd(vm, x, y);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 500,34 ***</span>
  
      if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
          int resultLength = std::max(x-&gt;length(), y-&gt;length()) + 1;
          // (-x) &amp; (-y) == ~(x-1) &amp; ~(y-1) == ~((x-1) | (y-1))
          // == -(((x-1) | (y-1)) + 1)
<span class="line-modified">!         JSBigInt* result = absoluteSubOne(exec, x, resultLength);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
  
<span class="line-modified">!         JSBigInt* y1 = absoluteSubOne(exec, y, y-&gt;length());</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
          result = absoluteOr(vm, result, y1);
          scope.release();
<span class="line-modified">!         return absoluteAddOne(exec, result, SignOption::Signed);</span>
      }
  
      ASSERT(x-&gt;sign() != y-&gt;sign());
      // Assume that x is the positive BigInt.
      if (x-&gt;sign())
          std::swap(x, y);
  
      // x &amp; (-y) == x &amp; ~(y-1) == x &amp; ~(y-1)
<span class="line-modified">!     JSBigInt* y1 = absoluteSubOne(exec, y, y-&gt;length());</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      return absoluteAndNot(vm, x, y1);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::bitwiseOr(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned resultLength = std::max(x-&gt;length(), y-&gt;length());
  
      if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
<span class="line-new-header">--- 515,34 ---</span>
  
      if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
          int resultLength = std::max(x-&gt;length(), y-&gt;length()) + 1;
          // (-x) &amp; (-y) == ~(x-1) &amp; ~(y-1) == ~((x-1) | (y-1))
          // == -(((x-1) | (y-1)) + 1)
<span class="line-modified">!         JSBigInt* result = absoluteSubOne(globalObject, x, resultLength);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
  
<span class="line-modified">!         JSBigInt* y1 = absoluteSubOne(globalObject, y, y-&gt;length());</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
          result = absoluteOr(vm, result, y1);
          scope.release();
<span class="line-modified">!         return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
      }
  
      ASSERT(x-&gt;sign() != y-&gt;sign());
      // Assume that x is the positive BigInt.
      if (x-&gt;sign())
          std::swap(x, y);
  
      // x &amp; (-y) == x &amp; ~(y-1) == x &amp; ~(y-1)
<span class="line-modified">!     JSBigInt* y1 = absoluteSubOne(globalObject, y, y-&gt;length());</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      return absoluteAndNot(vm, x, y1);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::bitwiseOr(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned resultLength = std::max(x-&gt;length(), y-&gt;length());
  
      if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 536,39 ***</span>
      }
  
      if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
          // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) &amp; (y-1))
          // == -(((x-1) &amp; (y-1)) + 1)
<span class="line-modified">!         JSBigInt* result = absoluteSubOne(exec, x, resultLength);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         JSBigInt* y1 = absoluteSubOne(exec, y, y-&gt;length());</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
          result = absoluteAnd(vm, result, y1);
          RETURN_IF_EXCEPTION(scope, nullptr);
  
          scope.release();
<span class="line-modified">!         return absoluteAddOne(exec, result, SignOption::Signed);</span>
      }
  
      ASSERT(x-&gt;sign() != y-&gt;sign());
  
      // Assume that x is the positive BigInt.
      if (x-&gt;sign())
          std::swap(x, y);
  
      // x | (-y) == x | ~(y-1) == ~((y-1) &amp;~ x) == -(((y-1) &amp;~ x) + 1)
<span class="line-modified">!     JSBigInt* result = absoluteSubOne(exec, y, resultLength);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      result = absoluteAndNot(vm, result, x);
  
      scope.release();
<span class="line-modified">!     return absoluteAddOne(exec, result, SignOption::Signed);</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::bitwiseXor(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
          scope.release();
          return absoluteXor(vm, x, y);
<span class="line-new-header">--- 551,39 ---</span>
      }
  
      if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
          // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) &amp; (y-1))
          // == -(((x-1) &amp; (y-1)) + 1)
<span class="line-modified">!         JSBigInt* result = absoluteSubOne(globalObject, x, resultLength);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         JSBigInt* y1 = absoluteSubOne(globalObject, y, y-&gt;length());</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
          result = absoluteAnd(vm, result, y1);
          RETURN_IF_EXCEPTION(scope, nullptr);
  
          scope.release();
<span class="line-modified">!         return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
      }
  
      ASSERT(x-&gt;sign() != y-&gt;sign());
  
      // Assume that x is the positive BigInt.
      if (x-&gt;sign())
          std::swap(x, y);
  
      // x | (-y) == x | ~(y-1) == ~((y-1) &amp;~ x) == -(((y-1) &amp;~ x) + 1)
<span class="line-modified">!     JSBigInt* result = absoluteSubOne(globalObject, y, resultLength);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      result = absoluteAndNot(vm, result, x);
  
      scope.release();
<span class="line-modified">!     return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::bitwiseXor(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
          scope.release();
          return absoluteXor(vm, x, y);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,13 ***</span>
  
      if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
          int resultLength = std::max(x-&gt;length(), y-&gt;length());
  
          // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)
<span class="line-modified">!         JSBigInt* result = absoluteSubOne(exec, x, resultLength);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         JSBigInt* y1 = absoluteSubOne(exec, y, y-&gt;length());</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
  
          scope.release();
          return absoluteXor(vm, result, y1);
      }
<span class="line-new-header">--- 591,13 ---</span>
  
      if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
          int resultLength = std::max(x-&gt;length(), y-&gt;length());
  
          // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)
<span class="line-modified">!         JSBigInt* result = absoluteSubOne(globalObject, x, resultLength);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         JSBigInt* y1 = absoluteSubOne(globalObject, y, y-&gt;length());</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
  
          scope.release();
          return absoluteXor(vm, result, y1);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 592,48 ***</span>
      // Assume that x is the positive BigInt.
      if (x-&gt;sign())
          std::swap(x, y);
  
      // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)
<span class="line-modified">!     JSBigInt* result = absoluteSubOne(exec, y, resultLength);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      result = absoluteXor(vm, result, x);
      scope.release();
<span class="line-modified">!     return absoluteAddOne(exec, result, SignOption::Signed);</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::leftShift(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
  {
      if (y-&gt;isZero() || x-&gt;isZero())
          return x;
  
      if (y-&gt;sign())
<span class="line-modified">!         return rightShiftByAbsolute(exec, x, y);</span>
  
<span class="line-modified">!     return leftShiftByAbsolute(exec, x, y);</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::signedRightShift(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
  {
      if (y-&gt;isZero() || x-&gt;isZero())
          return x;
  
      if (y-&gt;sign())
<span class="line-modified">!         return leftShiftByAbsolute(exec, x, y);</span>
  
<span class="line-modified">!     return rightShiftByAbsolute(exec, x, y);</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::bitwiseNot(ExecState* exec, JSBigInt* x)</span>
  {
      if (x-&gt;sign()) {
          // ~(-x) == ~(~(x-1)) == x-1
<span class="line-modified">!         return absoluteSubOne(exec, x, x-&gt;length());</span>
      }
      // ~x == -x-1 == -(x+1)
<span class="line-modified">!     return absoluteAddOne(exec, x, SignOption::Signed);</span>
  }
  
  #if USE(JSVALUE32_64)
  #define HAVE_TWO_DIGIT 1
  typedef uint64_t TwoDigit;
<span class="line-new-header">--- 607,48 ---</span>
      // Assume that x is the positive BigInt.
      if (x-&gt;sign())
          std::swap(x, y);
  
      // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)
<span class="line-modified">!     JSBigInt* result = absoluteSubOne(globalObject, y, resultLength);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      result = absoluteXor(vm, result, x);
      scope.release();
<span class="line-modified">!     return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::leftShift(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
  {
      if (y-&gt;isZero() || x-&gt;isZero())
          return x;
  
      if (y-&gt;sign())
<span class="line-modified">!         return rightShiftByAbsolute(globalObject, x, y);</span>
  
<span class="line-modified">!     return leftShiftByAbsolute(globalObject, x, y);</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::signedRightShift(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
  {
      if (y-&gt;isZero() || x-&gt;isZero())
          return x;
  
      if (y-&gt;sign())
<span class="line-modified">!         return leftShiftByAbsolute(globalObject, x, y);</span>
  
<span class="line-modified">!     return rightShiftByAbsolute(globalObject, x, y);</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::bitwiseNot(JSGlobalObject* globalObject, JSBigInt* x)</span>
  {
      if (x-&gt;sign()) {
          // ~(-x) == ~(~(x-1)) == x-1
<span class="line-modified">!         return absoluteSubOne(globalObject, x, x-&gt;length());</span>
      }
      // ~x == -x-1 == -(x+1)
<span class="line-modified">!     return absoluteAddOne(globalObject, x, SignOption::Signed);</span>
  }
  
  #if USE(JSVALUE32_64)
  #define HAVE_TWO_DIGIT 1
  typedef uint64_t TwoDigit;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 925,26 ***</span>
          return ComparisonResult::Equal;
  
      return x-&gt;digit(i) &gt; y-&gt;digit(i) ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::absoluteAdd(ExecState* exec, JSBigInt* x, JSBigInt* y, bool resultSign)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      if (x-&gt;length() &lt; y-&gt;length())
<span class="line-modified">!         return absoluteAdd(exec, y, x, resultSign);</span>
  
      if (x-&gt;isZero()) {
          ASSERT(y-&gt;isZero());
          return x;
      }
  
      if (y-&gt;isZero())
          return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
  
<span class="line-modified">!     JSBigInt* result = JSBigInt::tryCreateWithLength(exec, x-&gt;length() + 1);</span>
      if (!result)
          return nullptr;
      Digit carry = 0;
      unsigned i = 0;
      for (; i &lt; y-&gt;length(); i++) {
<span class="line-new-header">--- 940,26 ---</span>
          return ComparisonResult::Equal;
  
      return x-&gt;digit(i) &gt; y-&gt;digit(i) ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::absoluteAdd(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y, bool resultSign)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      if (x-&gt;length() &lt; y-&gt;length())
<span class="line-modified">!         return absoluteAdd(globalObject, y, x, resultSign);</span>
  
      if (x-&gt;isZero()) {
          ASSERT(y-&gt;isZero());
          return x;
      }
  
      if (y-&gt;isZero())
          return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
  
<span class="line-modified">!     JSBigInt* result = JSBigInt::tryCreateWithLength(globalObject, x-&gt;length() + 1);</span>
      if (!result)
          return nullptr;
      Digit carry = 0;
      unsigned i = 0;
      for (; i &lt; y-&gt;length(); i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1047,15 ***</span>
  // {remainder}. Mathematically, the contract is:
  // quotient = (dividend - remainder) / divisor, with 0 &lt;= remainder &lt; divisor.
  // Both {quotient} and {remainder} are optional, for callers that are only
  // interested in one of them.
  // See Knuth, Volume 2, section 4.3.1, Algorithm D.
<span class="line-modified">! void JSBigInt::absoluteDivWithBigIntDivisor(ExecState* exec, JSBigInt* dividend, JSBigInt* divisor, JSBigInt** quotient, JSBigInt** remainder)</span>
  {
      ASSERT(divisor-&gt;length() &gt;= 2);
      ASSERT(dividend-&gt;length() &gt;= divisor-&gt;length());
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // The unusual variable names inside this function are consistent with
      // Knuth&#39;s book, as well as with Go&#39;s implementation of this algorithm.
      // Maintaining this consistency is probably more useful than trying to
<span class="line-new-header">--- 1062,15 ---</span>
  // {remainder}. Mathematically, the contract is:
  // quotient = (dividend - remainder) / divisor, with 0 &lt;= remainder &lt; divisor.
  // Both {quotient} and {remainder} are optional, for callers that are only
  // interested in one of them.
  // See Knuth, Volume 2, section 4.3.1, Algorithm D.
<span class="line-modified">! void JSBigInt::absoluteDivWithBigIntDivisor(JSGlobalObject* globalObject, JSBigInt* dividend, JSBigInt* divisor, JSBigInt** quotient, JSBigInt** remainder)</span>
  {
      ASSERT(divisor-&gt;length() &gt;= 2);
      ASSERT(dividend-&gt;length() &gt;= divisor-&gt;length());
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // The unusual variable names inside this function are consistent with
      // Knuth&#39;s book, as well as with Go&#39;s implementation of this algorithm.
      // Maintaining this consistency is probably more useful than trying to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1064,15 ***</span>
      unsigned m = dividend-&gt;length() - n;
  
      // The quotient to be computed.
      JSBigInt* q = nullptr;
      if (quotient != nullptr)
<span class="line-modified">!         q = createWithLengthUnchecked(exec-&gt;vm(), m + 1);</span>
  
      // In each iteration, {qhatv} holds {divisor} * {current quotient digit}.
      // &quot;v&quot; is the book&#39;s name for {divisor}, &quot;qhat&quot; the current quotient digit.
<span class="line-modified">!     JSBigInt* qhatv = tryCreateWithLength(exec, n + 1);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      // D1.
      // Left-shift inputs so that the divisor&#39;s MSB is set. This is necessary
      // to prevent the digit-wise divisions (see digit_div call below) from
<span class="line-new-header">--- 1079,15 ---</span>
      unsigned m = dividend-&gt;length() - n;
  
      // The quotient to be computed.
      JSBigInt* q = nullptr;
      if (quotient != nullptr)
<span class="line-modified">!         q = createWithLengthUnchecked(globalObject-&gt;vm(), m + 1);</span>
  
      // In each iteration, {qhatv} holds {divisor} * {current quotient digit}.
      // &quot;v&quot; is the book&#39;s name for {divisor}, &quot;qhat&quot; the current quotient digit.
<span class="line-modified">!     JSBigInt* qhatv = tryCreateWithLength(globalObject, n + 1);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      // D1.
      // Left-shift inputs so that the divisor&#39;s MSB is set. This is necessary
      // to prevent the digit-wise divisions (see digit_div call below) from
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1080,17 ***</span>
      // result).
      Digit lastDigit = divisor-&gt;digit(n - 1);
      unsigned shift = clz(lastDigit);
  
      if (shift &gt; 0) {
<span class="line-modified">!         divisor = absoluteLeftShiftAlwaysCopy(exec, divisor, shift, LeftShiftMode::SameSizeResult);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
  
      // Holds the (continuously updated) remaining part of the dividend, which
      // eventually becomes the remainder.
<span class="line-modified">!     JSBigInt* u = absoluteLeftShiftAlwaysCopy(exec, dividend, shift, LeftShiftMode::AlwaysAddOneDigit);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      // D2.
      // Iterate over the dividend&#39;s digit (like the &quot;grad school&quot; algorithm).
      // {vn1} is the divisor&#39;s most significant digit.
<span class="line-new-header">--- 1095,17 ---</span>
      // result).
      Digit lastDigit = divisor-&gt;digit(n - 1);
      unsigned shift = clz(lastDigit);
  
      if (shift &gt; 0) {
<span class="line-modified">!         divisor = absoluteLeftShiftAlwaysCopy(globalObject, divisor, shift, LeftShiftMode::SameSizeResult);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
  
      // Holds the (continuously updated) remaining part of the dividend, which
      // eventually becomes the remainder.
<span class="line-modified">!     JSBigInt* u = absoluteLeftShiftAlwaysCopy(globalObject, dividend, shift, LeftShiftMode::AlwaysAddOneDigit);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      // D2.
      // Iterate over the dividend&#39;s digit (like the &quot;grad school&quot; algorithm).
      // {vn1} is the divisor&#39;s most significant digit.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1215,18 ***</span>
      }
      setDigit(last, carry);
  }
  
  // Always copies the input, even when {shift} == 0.
<span class="line-modified">! JSBigInt* JSBigInt::absoluteLeftShiftAlwaysCopy(ExecState* exec, JSBigInt* x, unsigned shift, LeftShiftMode mode)</span>
  {
      ASSERT(shift &lt; digitBits);
      ASSERT(!x-&gt;isZero());
  
      unsigned n = x-&gt;length();
      unsigned resultLength = mode == LeftShiftMode::AlwaysAddOneDigit ? n + 1 : n;
<span class="line-modified">!     JSBigInt* result = tryCreateWithLength(exec, resultLength);</span>
      if (!result)
          return nullptr;
  
      if (!shift) {
          for (unsigned i = 0; i &lt; n; i++)
<span class="line-new-header">--- 1230,18 ---</span>
      }
      setDigit(last, carry);
  }
  
  // Always copies the input, even when {shift} == 0.
<span class="line-modified">! JSBigInt* JSBigInt::absoluteLeftShiftAlwaysCopy(JSGlobalObject* globalObject, JSBigInt* x, unsigned shift, LeftShiftMode mode)</span>
  {
      ASSERT(shift &lt; digitBits);
      ASSERT(!x-&gt;isZero());
  
      unsigned n = x-&gt;length();
      unsigned resultLength = mode == LeftShiftMode::AlwaysAddOneDigit ? n + 1 : n;
<span class="line-modified">!     JSBigInt* result = tryCreateWithLength(globalObject, resultLength);</span>
      if (!result)
          return nullptr;
  
      if (!shift) {
          for (unsigned i = 0; i &lt; n; i++)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1329,11 ***</span>
          return a ^ b;
      };
      return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::Symmetric, digitOperation);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::absoluteAddOne(ExecState* exec, JSBigInt* x, SignOption signOption)</span>
  {
      unsigned inputLength = x-&gt;length();
      // The addition will overflow into a new digit if all existing digits are
      // at maximum.
      bool willOverflow = true;
<span class="line-new-header">--- 1344,11 ---</span>
          return a ^ b;
      };
      return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::Symmetric, digitOperation);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::absoluteAddOne(JSGlobalObject* globalObject, JSBigInt* x, SignOption signOption)</span>
  {
      unsigned inputLength = x-&gt;length();
      // The addition will overflow into a new digit if all existing digits are
      // at maximum.
      bool willOverflow = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1343,11 ***</span>
              break;
          }
      }
  
      unsigned resultLength = inputLength + willOverflow;
<span class="line-modified">!     JSBigInt* result = tryCreateWithLength(exec, resultLength);</span>
      if (!result)
          return nullptr;
  
      Digit carry = 1;
      for (unsigned i = 0; i &lt; inputLength; i++) {
<span class="line-new-header">--- 1358,11 ---</span>
              break;
          }
      }
  
      unsigned resultLength = inputLength + willOverflow;
<span class="line-modified">!     JSBigInt* result = tryCreateWithLength(globalObject, resultLength);</span>
      if (!result)
          return nullptr;
  
      Digit carry = 1;
      for (unsigned i = 0; i &lt; inputLength; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1359,21 ***</span>
          result-&gt;setDigit(inputLength, carry);
      else
          ASSERT(!carry);
  
      result-&gt;setSign(signOption == SignOption::Signed);
<span class="line-modified">!     return result-&gt;rightTrim(exec-&gt;vm());</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::absoluteSubOne(ExecState* exec, JSBigInt* x, unsigned resultLength)</span>
  {
      ASSERT(!x-&gt;isZero());
      ASSERT(resultLength &gt;= x-&gt;length());
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSBigInt* result = tryCreateWithLength(exec, resultLength);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      unsigned length = x-&gt;length();
      Digit borrow = 1;
      for (unsigned i = 0; i &lt; length; i++) {
<span class="line-new-header">--- 1374,21 ---</span>
          result-&gt;setDigit(inputLength, carry);
      else
          ASSERT(!carry);
  
      result-&gt;setSign(signOption == SignOption::Signed);
<span class="line-modified">!     return result-&gt;rightTrim(globalObject-&gt;vm());</span>
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::absoluteSubOne(JSGlobalObject* globalObject, JSBigInt* x, unsigned resultLength)</span>
  {
      ASSERT(!x-&gt;isZero());
      ASSERT(resultLength &gt;= x-&gt;length());
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSBigInt* result = tryCreateWithLength(globalObject, resultLength);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      unsigned length = x-&gt;length();
      Digit borrow = 1;
      for (unsigned i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1386,33 ***</span>
          result-&gt;setDigit(i, borrow);
  
      return result-&gt;rightTrim(vm);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::leftShiftByAbsolute(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto optionalShift = toShiftAmount(y);
      if (!optionalShift) {
<span class="line-modified">!         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
          return nullptr;
      }
  
      Digit shift = *optionalShift;
      unsigned digitShift = static_cast&lt;unsigned&gt;(shift / digitBits);
      unsigned bitsShift = static_cast&lt;unsigned&gt;(shift % digitBits);
      unsigned length = x-&gt;length();
      bool grow = bitsShift &amp;&amp; (x-&gt;digit(length - 1) &gt;&gt; (digitBits - bitsShift));
      int resultLength = length + digitShift + grow;
      if (static_cast&lt;unsigned&gt;(resultLength) &gt; maxLength) {
<span class="line-modified">!         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
          return nullptr;
      }
  
<span class="line-modified">!     JSBigInt* result = tryCreateWithLength(exec, resultLength);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!bitsShift) {
          unsigned i = 0;
          for (; i &lt; digitShift; i++)
              result-&gt;setDigit(i, 0ul);
<span class="line-new-header">--- 1401,33 ---</span>
          result-&gt;setDigit(i, borrow);
  
      return result-&gt;rightTrim(vm);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::leftShiftByAbsolute(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto optionalShift = toShiftAmount(y);
      if (!optionalShift) {
<span class="line-modified">!         throwRangeError(globalObject, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
          return nullptr;
      }
  
      Digit shift = *optionalShift;
      unsigned digitShift = static_cast&lt;unsigned&gt;(shift / digitBits);
      unsigned bitsShift = static_cast&lt;unsigned&gt;(shift % digitBits);
      unsigned length = x-&gt;length();
      bool grow = bitsShift &amp;&amp; (x-&gt;digit(length - 1) &gt;&gt; (digitBits - bitsShift));
      int resultLength = length + digitShift + grow;
      if (static_cast&lt;unsigned&gt;(resultLength) &gt; maxLength) {
<span class="line-modified">!         throwRangeError(globalObject, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
          return nullptr;
      }
  
<span class="line-modified">!     JSBigInt* result = tryCreateWithLength(globalObject, resultLength);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!bitsShift) {
          unsigned i = 0;
          for (; i &lt; digitShift; i++)
              result-&gt;setDigit(i, 0ul);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1438,13 ***</span>
  
      result-&gt;setSign(x-&gt;sign());
      return result-&gt;rightTrim(vm);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::rightShiftByAbsolute(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      unsigned length = x-&gt;length();
      bool sign = x-&gt;sign();
      auto optionalShift = toShiftAmount(y);
      if (!optionalShift)
          return rightShiftByMaximum(vm, sign);
<span class="line-new-header">--- 1453,13 ---</span>
  
      result-&gt;setSign(x-&gt;sign());
      return result-&gt;rightTrim(vm);
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::rightShiftByAbsolute(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      unsigned length = x-&gt;length();
      bool sign = x-&gt;sign();
      auto optionalShift = toShiftAmount(y);
      if (!optionalShift)
          return rightShiftByMaximum(vm, sign);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1504,11 ***</span>
          result-&gt;setSign(true);
          if (mustRoundDown) {
              // Since the result is negative, rounding down means adding one to
              // its absolute value. This cannot overflow.
              result = result-&gt;rightTrim(vm);
<span class="line-modified">!             return absoluteAddOne(exec, result, SignOption::Signed);</span>
          }
      }
  
      return result-&gt;rightTrim(vm);
  }
<span class="line-new-header">--- 1519,11 ---</span>
          result-&gt;setSign(true);
          if (mustRoundDown) {
              // Since the result is negative, rounding down means adding one to
              // its absolute value. This cannot overflow.
              result = result-&gt;rightTrim(vm);
<span class="line-modified">!             return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
          }
      }
  
      return result-&gt;rightTrim(vm);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1562,11 ***</span>
      maximumCharactersRequired += sign;
  
      return maximumCharactersRequired;
  }
  
<span class="line-modified">! String JSBigInt::toStringBasePowerOfTwo(VM&amp; vm, ExecState* exec, JSBigInt* x, unsigned radix)</span>
  {
      ASSERT(hasOneBitSet(radix));
      ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 32);
      ASSERT(!x-&gt;isZero());
  
<span class="line-new-header">--- 1577,11 ---</span>
      maximumCharactersRequired += sign;
  
      return maximumCharactersRequired;
  }
  
<span class="line-modified">! String JSBigInt::toStringBasePowerOfTwo(VM&amp; vm, JSGlobalObject* globalObject, JSBigInt* x, unsigned radix)</span>
  {
      ASSERT(hasOneBitSet(radix));
      ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 32);
      ASSERT(!x-&gt;isZero());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1582,13 ***</span>
  
      const size_t bitLength = length * digitBits - msdLeadingZeros;
      const size_t charsRequired = (bitLength + bitsPerChar - 1) / bitsPerChar + sign;
  
      if (charsRequired &gt; JSString::MaxLength) {
<span class="line-modified">!         if (exec) {</span>
              auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!             throwOutOfMemoryError(exec, scope);</span>
          }
          return String();
      }
  
      Vector&lt;LChar&gt; resultString(charsRequired);
<span class="line-new-header">--- 1597,13 ---</span>
  
      const size_t bitLength = length * digitBits - msdLeadingZeros;
      const size_t charsRequired = (bitLength + bitsPerChar - 1) / bitsPerChar + sign;
  
      if (charsRequired &gt; JSString::MaxLength) {
<span class="line-modified">!         if (globalObject) {</span>
              auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!             throwOutOfMemoryError(globalObject, scope);</span>
          }
          return String();
      }
  
      Vector&lt;LChar&gt; resultString(charsRequired);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1624,11 ***</span>
  
      ASSERT(pos == -1);
      return StringImpl::adopt(WTFMove(resultString));
  }
  
<span class="line-modified">! String JSBigInt::toStringGeneric(VM&amp; vm, ExecState* exec, JSBigInt* x, unsigned radix)</span>
  {
      // FIXME: [JSC] Revisit usage of Vector into JSBigInt::toString
      // https://bugs.webkit.org/show_bug.cgi?id=18067
      Vector&lt;LChar&gt; resultString;
  
<span class="line-new-header">--- 1639,11 ---</span>
  
      ASSERT(pos == -1);
      return StringImpl::adopt(WTFMove(resultString));
  }
  
<span class="line-modified">! String JSBigInt::toStringGeneric(VM&amp; vm, JSGlobalObject* globalObject, JSBigInt* x, unsigned radix)</span>
  {
      // FIXME: [JSC] Revisit usage of Vector into JSBigInt::toString
      // https://bugs.webkit.org/show_bug.cgi?id=18067
      Vector&lt;LChar&gt; resultString;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1640,13 ***</span>
  
      uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
      uint64_t maximumCharactersRequired = calculateMaximumCharactersRequired(length, radix, x-&gt;digit(length - 1), sign);
  
      if (maximumCharactersRequired &gt; JSString::MaxLength) {
<span class="line-modified">!         if (exec) {</span>
              auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!             throwOutOfMemoryError(exec, scope);</span>
          }
          return String();
      }
  
      Digit lastDigit;
<span class="line-new-header">--- 1655,13 ---</span>
  
      uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
      uint64_t maximumCharactersRequired = calculateMaximumCharactersRequired(length, radix, x-&gt;digit(length - 1), sign);
  
      if (maximumCharactersRequired &gt; JSString::MaxLength) {
<span class="line-modified">!         if (globalObject) {</span>
              auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!             throwOutOfMemoryError(globalObject, scope);</span>
          }
          return String();
      }
  
      Digit lastDigit;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1735,11 ***</span>
      trimmedBigInt-&gt;setSign(this-&gt;sign());
  
      return trimmedBigInt;
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::allocateFor(ExecState* exec, VM&amp; vm, unsigned radix, unsigned charcount)</span>
  {
      ASSERT(2 &lt;= radix &amp;&amp; radix &lt;= 36);
  
      size_t bitsPerChar = maxBitsPerCharTable[radix];
      size_t chars = charcount;
<span class="line-new-header">--- 1750,11 ---</span>
      trimmedBigInt-&gt;setSign(this-&gt;sign());
  
      return trimmedBigInt;
  }
  
<span class="line-modified">! JSBigInt* JSBigInt::allocateFor(JSGlobalObject* globalObject, VM&amp; vm, unsigned radix, unsigned charcount)</span>
  {
      ASSERT(2 &lt;= radix &amp;&amp; radix &lt;= 36);
  
      size_t bitsPerChar = maxBitsPerCharTable[radix];
      size_t chars = charcount;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1757,56 ***</span>
                  return result;
              }
          }
      }
  
<span class="line-modified">!     if (exec) {</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
      }
      return nullptr;
  }
  
  size_t JSBigInt::estimatedSize(JSCell* cell, VM&amp; vm)
  {
      return Base::estimatedSize(cell, vm) + jsCast&lt;JSBigInt*&gt;(cell)-&gt;m_length * sizeof(Digit);
  }
  
<span class="line-modified">! double JSBigInt::toNumber(ExecState* exec) const</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     throwTypeError(exec, scope, &quot;Conversion from &#39;BigInt&#39; to &#39;number&#39; is not allowed.&quot;_s);</span>
      return 0.0;
  }
  
<span class="line-modified">! bool JSBigInt::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; result) const</span>
  {
      result = this;
<span class="line-modified">!     number = toNumber(exec);</span>
      return true;
  }
  
  template &lt;typename CharType&gt;
<span class="line-modified">! JSBigInt* JSBigInt::parseInt(ExecState* exec, CharType*  data, unsigned length, ErrorParseMode errorParseMode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      unsigned p = 0;
      while (p &lt; length &amp;&amp; isStrWhiteSpace(data[p]))
          ++p;
  
      // Check Radix from frist characters
      if (static_cast&lt;unsigned&gt;(p) + 1 &lt; static_cast&lt;unsigned&gt;(length) &amp;&amp; data[p] == &#39;0&#39;) {
          if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;b&#39;))
<span class="line-modified">!             return parseInt(exec, vm, data, length, p + 2, 2, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
  
          if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;x&#39;))
<span class="line-modified">!             return parseInt(exec, vm, data, length, p + 2, 16, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
  
          if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;o&#39;))
<span class="line-modified">!             return parseInt(exec, vm, data, length, p + 2, 8, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
      }
  
      ParseIntSign sign = ParseIntSign::Unsigned;
      if (p &lt; length) {
          if (data[p] == &#39;+&#39;)
<span class="line-new-header">--- 1772,56 ---</span>
                  return result;
              }
          }
      }
  
<span class="line-modified">!     if (globalObject) {</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
      }
      return nullptr;
  }
  
  size_t JSBigInt::estimatedSize(JSCell* cell, VM&amp; vm)
  {
      return Base::estimatedSize(cell, vm) + jsCast&lt;JSBigInt*&gt;(cell)-&gt;m_length * sizeof(Digit);
  }
  
<span class="line-modified">! double JSBigInt::toNumber(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     throwTypeError(globalObject, scope, &quot;Conversion from &#39;BigInt&#39; to &#39;number&#39; is not allowed.&quot;_s);</span>
      return 0.0;
  }
  
<span class="line-modified">! bool JSBigInt::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; result) const</span>
  {
      result = this;
<span class="line-modified">!     number = toNumber(globalObject);</span>
      return true;
  }
  
  template &lt;typename CharType&gt;
<span class="line-modified">! JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, CharType*  data, unsigned length, ErrorParseMode errorParseMode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      unsigned p = 0;
      while (p &lt; length &amp;&amp; isStrWhiteSpace(data[p]))
          ++p;
  
      // Check Radix from frist characters
      if (static_cast&lt;unsigned&gt;(p) + 1 &lt; static_cast&lt;unsigned&gt;(length) &amp;&amp; data[p] == &#39;0&#39;) {
          if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;b&#39;))
<span class="line-modified">!             return parseInt(globalObject, vm, data, length, p + 2, 2, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
  
          if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;x&#39;))
<span class="line-modified">!             return parseInt(globalObject, vm, data, length, p + 2, 16, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
  
          if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;o&#39;))
<span class="line-modified">!             return parseInt(globalObject, vm, data, length, p + 2, 8, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
      }
  
      ParseIntSign sign = ParseIntSign::Unsigned;
      if (p &lt; length) {
          if (data[p] == &#39;+&#39;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1815,30 ***</span>
              sign = ParseIntSign::Signed;
              ++p;
          }
      }
  
<span class="line-modified">!     JSBigInt* result = parseInt(exec, vm, data, length, p, 10, errorParseMode, sign);</span>
  
      if (result &amp;&amp; !result-&gt;isZero())
          result-&gt;setSign(sign == ParseIntSign::Signed);
  
      return result;
  }
  
  template &lt;typename CharType&gt;
<span class="line-modified">! JSBigInt* JSBigInt::parseInt(ExecState* exec, VM&amp; vm, CharType* data, unsigned length, unsigned startIndex, unsigned radix, ErrorParseMode errorParseMode, ParseIntSign sign, ParseIntMode parseMode)</span>
  {
      ASSERT(length &gt;= 0);
      unsigned p = startIndex;
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (parseMode != ParseIntMode::AllowEmptyString &amp;&amp; startIndex == length) {
<span class="line-modified">!         ASSERT(exec);</span>
          if (errorParseMode == ErrorParseMode::ThrowExceptions)
<span class="line-modified">!             throwVMError(exec, scope, createSyntaxError(exec, &quot;Failed to parse String to BigInt&quot;));</span>
          return nullptr;
      }
  
      // Skipping leading zeros
      while (p &lt; length &amp;&amp; data[p] == &#39;0&#39;)
<span class="line-new-header">--- 1830,30 ---</span>
              sign = ParseIntSign::Signed;
              ++p;
          }
      }
  
<span class="line-modified">!     JSBigInt* result = parseInt(globalObject, vm, data, length, p, 10, errorParseMode, sign);</span>
  
      if (result &amp;&amp; !result-&gt;isZero())
          result-&gt;setSign(sign == ParseIntSign::Signed);
  
      return result;
  }
  
  template &lt;typename CharType&gt;
<span class="line-modified">! JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, VM&amp; vm, CharType* data, unsigned length, unsigned startIndex, unsigned radix, ErrorParseMode errorParseMode, ParseIntSign sign, ParseIntMode parseMode)</span>
  {
      ASSERT(length &gt;= 0);
      unsigned p = startIndex;
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (parseMode != ParseIntMode::AllowEmptyString &amp;&amp; startIndex == length) {
<span class="line-modified">!         ASSERT(globalObject);</span>
          if (errorParseMode == ErrorParseMode::ThrowExceptions)
<span class="line-modified">!             throwVMError(globalObject, scope, createSyntaxError(globalObject, &quot;Failed to parse String to BigInt&quot;));</span>
          return nullptr;
      }
  
      // Skipping leading zeros
      while (p &lt; length &amp;&amp; data[p] == &#39;0&#39;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1856,12 ***</span>
  
      unsigned limit0 = &#39;0&#39; + (radix &lt; 10 ? radix : 10);
      unsigned limita = &#39;a&#39; + (radix - 10);
      unsigned limitA = &#39;A&#39; + (radix - 10);
  
<span class="line-modified">!     JSBigInt* result = allocateFor(exec, vm, radix, length - p);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      result-&gt;initialize(InitializationType::WithZero);
  
      for (unsigned i = p; i &lt; length; i++, p++) {
          uint32_t digit;
<span class="line-new-header">--- 1871,15 ---</span>
  
      unsigned limit0 = &#39;0&#39; + (radix &lt; 10 ? radix : 10);
      unsigned limita = &#39;a&#39; + (radix - 10);
      unsigned limitA = &#39;A&#39; + (radix - 10);
  
<span class="line-modified">!     JSBigInt* result = allocateFor(globalObject, vm, radix, length - p);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-added">+     // result can still be null if we don&#39;t have access to global object, as allocateFor cannot throw an exception in that case.</span>
<span class="line-added">+     if (!result)</span>
<span class="line-added">+         return nullptr;</span>
  
      result-&gt;initialize(InitializationType::WithZero);
  
      for (unsigned i = p; i &lt; length; i++, p++) {
          uint32_t digit;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1879,13 ***</span>
  
      result-&gt;setSign(sign == ParseIntSign::Signed ? true : false);
      if (p == length)
          return result-&gt;rightTrim(vm);
  
<span class="line-modified">!     ASSERT(exec);</span>
      if (errorParseMode == ErrorParseMode::ThrowExceptions)
<span class="line-modified">!         throwVMError(exec, scope, createSyntaxError(exec, &quot;Failed to parse String to BigInt&quot;));</span>
  
      return nullptr;
  }
  
  inline JSBigInt::Digit JSBigInt::digit(unsigned n)
<span class="line-new-header">--- 1897,13 ---</span>
  
      result-&gt;setSign(sign == ParseIntSign::Signed ? true : false);
      if (p == length)
          return result-&gt;rightTrim(vm);
  
<span class="line-modified">!     ASSERT(globalObject);</span>
      if (errorParseMode == ErrorParseMode::ThrowExceptions)
<span class="line-modified">!         throwVMError(globalObject, scope, createSyntaxError(globalObject, &quot;Failed to parse String to BigInt&quot;));</span>
  
      return nullptr;
  }
  
  inline JSBigInt::Digit JSBigInt::digit(unsigned n)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1898,13 ***</span>
  {
      ASSERT(n &lt; length());
      dataStorage()[n] = value;
  }
  
<span class="line-modified">! JSObject* JSBigInt::toObject(ExecState* exec, JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     return BigIntObject::create(exec-&gt;vm(), globalObject, const_cast&lt;JSBigInt*&gt;(this));</span>
  }
  
  bool JSBigInt::equalsToNumber(JSValue numValue)
  {
      ASSERT(numValue.isNumber());
<span class="line-new-header">--- 1916,13 ---</span>
  {
      ASSERT(n &lt; length());
      dataStorage()[n] = value;
  }
  
<span class="line-modified">! JSObject* JSBigInt::toObject(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     return BigIntObject::create(globalObject-&gt;vm(), globalObject, const_cast&lt;JSBigInt*&gt;(this));</span>
  }
  
  bool JSBigInt::equalsToNumber(JSValue numValue)
  {
      ASSERT(numValue.isNumber());
</pre>
<center><a href="JSAsyncGeneratorFunction.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBigInt.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
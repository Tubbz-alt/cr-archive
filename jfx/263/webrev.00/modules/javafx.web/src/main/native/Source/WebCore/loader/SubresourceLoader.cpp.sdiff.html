<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/SubresourceLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SubresourceIntegrity.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SubresourceLoader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/SubresourceLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 47 #include &quot;ResourceLoadObserver.h&quot;
 48 #include &quot;ResourceTiming.h&quot;
 49 #include &quot;RuntimeEnabledFeatures.h&quot;
 50 #include &quot;Settings.h&quot;
 51 #include &lt;wtf/CompletionHandler.h&gt;
 52 #include &lt;wtf/Ref.h&gt;
 53 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 54 #include &lt;wtf/StdLibExtras.h&gt;
 55 #include &lt;wtf/SystemTracing.h&gt;
 56 #include &lt;wtf/text/CString.h&gt;
 57 
 58 #if PLATFORM(IOS_FAMILY)
 59 #include &lt;RuntimeApplicationChecks.h&gt;
 60 #endif
 61 
 62 #if ENABLE(CONTENT_EXTENSIONS)
 63 #include &quot;ResourceLoadInfo.h&quot;
 64 #endif
 65 
 66 #if USE(QUICK_LOOK)

 67 #include &quot;PreviewConverter.h&quot;
<span class="line-removed"> 68 #include &quot;PreviewLoader.h&quot;</span>
 69 #endif
 70 
 71 #undef RELEASE_LOG_IF_ALLOWED
 72 #undef RELEASE_LOG_ERROR_IF_ALLOWED
 73 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ResourceLoading, &quot;%p - SubresourceLoader::&quot; fmt, this, ##__VA_ARGS__)
 74 #define RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(isAlwaysOnLoggingAllowed(), ResourceLoading, &quot;%p - SubresourceLoader::&quot; fmt, this, ##__VA_ARGS__)
 75 
 76 namespace WebCore {
 77 
 78 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, subresourceLoaderCounter, (&quot;SubresourceLoader&quot;));
 79 
 80 SubresourceLoader::RequestCountTracker::RequestCountTracker(CachedResourceLoader&amp; cachedResourceLoader, const CachedResource&amp; resource)
 81     : m_cachedResourceLoader(cachedResourceLoader)
 82     , m_resource(resource)
 83 {
 84     m_cachedResourceLoader.incrementRequestCount(m_resource);
 85 }
 86 
 87 SubresourceLoader::RequestCountTracker::~RequestCountTracker()
 88 {
</pre>
<hr />
<pre>
178 }
179 
180 bool SubresourceLoader::isSubresourceLoader() const
181 {
182     return true;
183 }
184 
185 void SubresourceLoader::willSendRequestInternal(ResourceRequest&amp;&amp; newRequest, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
186 {
187     // Store the previous URL because the call to ResourceLoader::willSendRequest will modify it.
188     URL previousURL = request().url();
189     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
190 
191     if (!newRequest.url().isValid()) {
192         cancel(cannotShowURLError());
193         return completionHandler(WTFMove(newRequest));
194     }
195 
196     if (newRequest.requester() != ResourceRequestBase::Requester::Main) {
197         tracePoint(SubresourceLoadWillStart);
<span class="line-modified">198         ResourceLoadObserver::shared().logSubresourceLoading(m_frame.get(), newRequest, redirectResponse);</span>

199     }
200 
201     auto continueWillSendRequest = [this, protectedThis = makeRef(*this), redirectResponse] (CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler, ResourceRequest&amp;&amp; newRequest) mutable {
202         if (newRequest.isNull() || reachedTerminalState())
203             return completionHandler(WTFMove(newRequest));
204 
205         ResourceLoader::willSendRequestInternal(WTFMove(newRequest), redirectResponse, [this, protectedThis = WTFMove(protectedThis), completionHandler = WTFMove(completionHandler), redirectResponse] (ResourceRequest&amp;&amp; request) mutable {
206             if (reachedTerminalState())
207                 return completionHandler(WTFMove(request));
208 
209             if (request.isNull()) {
210                 cancel();
211                 return completionHandler(WTFMove(request));
212             }
213 
214             if (m_resource-&gt;type() == CachedResource::Type::MainResource &amp;&amp; !redirectResponse.isNull())
215                 m_documentLoader-&gt;willContinueMainResourceLoadAfterRedirect(request);
216             completionHandler(WTFMove(request));
217         });
218     };
</pre>
<hr />
<pre>
221     if (!redirectResponse.isNull()) {
222         if (options().redirect != FetchOptions::Redirect::Follow) {
223             if (options().redirect == FetchOptions::Redirect::Error) {
224                 ResourceError error { errorDomainWebKitInternal, 0, request().url(), makeString(&quot;Not allowed to follow a redirection while loading &quot;, request().url().string()), ResourceError::Type::AccessControl };
225 
226                 if (m_frame &amp;&amp; m_frame-&gt;document())
227                     m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, error.localizedDescription());
228 
229                 RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because not allowed to follow a redirect (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
230 
231                 cancel(error);
232                 return completionHandler(WTFMove(newRequest));
233             }
234 
235             ResourceResponse opaqueRedirectedResponse = redirectResponse;
236             opaqueRedirectedResponse.setType(ResourceResponse::Type::Opaqueredirect);
237             opaqueRedirectedResponse.setTainting(ResourceResponse::Tainting::Opaqueredirect);
238             m_resource-&gt;responseReceived(opaqueRedirectedResponse);
239             if (reachedTerminalState()) {
240                 RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: reached terminal state (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
<span class="line-modified">241                 return;</span>
242             }
243 
244             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load completed (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
245 
246             NetworkLoadMetrics emptyMetrics;
247             didFinishLoading(emptyMetrics);
248             return completionHandler(WTFMove(newRequest));
249         } else if (m_redirectCount++ &gt;= options().maxRedirectCount) {
250             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because too many redirects (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
251             cancel(ResourceError(String(), 0, request().url(), &quot;Too many redirections&quot;_s, ResourceError::Type::General));
252             return completionHandler(WTFMove(newRequest));
253         }
254 
255         // CachedResources are keyed off their original request URL.
256         // Requesting the same original URL a second time can redirect to a unique second resource.
257         // Therefore, if a redirect to a different destination URL occurs, we should no longer consider this a revalidation of the first resource.
258         // Doing so would have us reusing the resource from the first request if the second request&#39;s revalidation succeeds.
259         if (newRequest.isConditional() &amp;&amp; m_resource-&gt;resourceToRevalidate() &amp;&amp; newRequest.url() != m_resource-&gt;resourceToRevalidate()-&gt;response().url()) {
260             newRequest.makeUnconditional();
261             MemoryCache::singleton().revalidationFailed(*m_resource);
</pre>
<hr />
<pre>
297 void SubresourceLoader::didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
298 {
299     ASSERT(m_state == Initialized);
300     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
301     m_resource-&gt;didSendData(bytesSent, totalBytesToBeSent);
302 }
303 
304 #if USE(QUICK_LOOK)
305 
306 bool SubresourceLoader::shouldCreatePreviewLoaderForResponse(const ResourceResponse&amp; response) const
307 {
308     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
309         return false;
310 
311     if (m_previewLoader)
312         return false;
313 
314     return PreviewConverter::supportsMIMEType(response.mimeType());
315 }
316 









317 #endif
318 






319 void SubresourceLoader::didReceiveResponse(const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; policyCompletionHandler)
320 {
321     ASSERT(!response.isNull());
322     ASSERT(m_state == Initialized);
323 
324     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(policyCompletionHandler));
325 
326 #if USE(QUICK_LOOK)
327     if (shouldCreatePreviewLoaderForResponse(response)) {
<span class="line-modified">328         m_previewLoader = PreviewLoader::create(*this, response);</span>
329         if (m_previewLoader-&gt;didReceiveResponse(response))
330             return;
331     }
332 #endif
333 #if ENABLE(SERVICE_WORKER)
334     // Implementing step 10 of https://fetch.spec.whatwg.org/#main-fetch for service worker responses.
335     if (response.source() == ResourceResponse::Source::ServiceWorker &amp;&amp; response.url() != request().url()) {
336         auto&amp; loader = m_documentLoader-&gt;cachedResourceLoader();
337         if (!loader.allowedByContentSecurityPolicy(m_resource-&gt;type(), response.url(), options(), ContentSecurityPolicy::RedirectResponseReceived::Yes)) {
338             RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because not allowed by content policy (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
339             cancel(ResourceError({ }, 0, response.url(), { }, ResourceError::Type::General));
340             return;
341         }
342     }
343 #endif
344 






345     // We want redirect responses to be processed through willSendRequestInternal. Exceptions are
346     // redirection with no Location headers and fetch in manual redirect mode. Or in rare circumstances,
347     // cases of too many redirects from CFNetwork (&lt;rdar://problem/30610988&gt;).
348 #if !PLATFORM(COCOA)
349     ASSERT(response.httpStatusCode() &lt; 300 || response.httpStatusCode() &gt;= 400 || response.httpStatusCode() == 304 || !response.httpHeaderField(HTTPHeaderName::Location) || response.type() == ResourceResponse::Type::Opaqueredirect);
350 #endif
351 
352     // Reference the object in this method since the additional processing can do
353     // anything including removing the last reference to this object; one example of this is 3266216.
354     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
355 
356     if (shouldIncludeCertificateInfo())
357         response.includeCertificateInfo();
358 
359     if (m_resource-&gt;resourceToRevalidate()) {
360         if (response.httpStatusCode() == 304) {
361             // 304 Not modified / Use local copy
362             // Existing resource is ok, just use it updating the expiration time.
363             ResourceResponse revalidationResponse = response;
364             revalidationResponse.setSource(ResourceResponse::Source::MemoryCacheAfterValidation);
</pre>
<hr />
<pre>
368                 m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultPass, ShouldSample::Yes);
369             if (!reachedTerminalState())
370                 ResourceLoader::didReceiveResponse(revalidationResponse, [completionHandlerCaller = WTFMove(completionHandlerCaller)] { });
371             return;
372         }
373         // Did not get 304 response, continue as a regular resource load.
374         MemoryCache::singleton().revalidationFailed(*m_resource);
375         if (m_frame &amp;&amp; m_frame-&gt;page())
376             m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultFail, ShouldSample::Yes);
377     }
378 
379     String errorDescription;
380     if (!checkResponseCrossOriginAccessControl(response, errorDescription)) {
381         if (m_frame &amp;&amp; m_frame-&gt;document())
382             m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, errorDescription);
383         RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because of cross origin access control (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
384         cancel(ResourceError(String(), 0, request().url(), errorDescription, ResourceError::Type::AccessControl));
385         return;
386     }
387 
















388     m_resource-&gt;responseReceived(response);
389     if (reachedTerminalState())
390         return;
391 
392     bool isResponseMultipart = response.isMultipart();
393     if (options().mode != FetchOptions::Mode::Navigate)
394         LinkLoader::loadLinksFromHeader(response.httpHeaderField(HTTPHeaderName::Link), m_documentLoader-&gt;url(), *m_frame-&gt;document(), LinkLoader::MediaAttributeCheck::SkipMediaAttributeCheck);
395     ResourceLoader::didReceiveResponse(response, [this, protectedThis = WTFMove(protectedThis), isResponseMultipart, completionHandlerCaller = WTFMove(completionHandlerCaller)]() mutable {
396         if (reachedTerminalState())
397             return;
398 
399         // FIXME: Main resources have a different set of rules for multipart than images do.
400         // Hopefully we can merge those 2 paths.
401         if (isResponseMultipart &amp;&amp; m_resource-&gt;type() != CachedResource::Type::MainResource) {
402             m_loadingMultipartContent = true;
403 
404             // We don&#39;t count multiParts in a CachedResourceLoader&#39;s request count
405             m_requestCountTracker = WTF::nullopt;
406             if (!m_resource-&gt;isImage()) {
407                 RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because something about a multi-part non-image (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
</pre>
<hr />
<pre>
559         return response.tainting() != ResourceResponse::Tainting::Opaque;
560 #endif
561 
562     ASSERT(m_origin);
563 
564     return passesAccessControlCheck(response, options().credentials == FetchOptions::Credentials::Include ? StoredCredentialsPolicy::Use : StoredCredentialsPolicy::DoNotUse, *m_origin, errorDescription);
565 }
566 
567 bool SubresourceLoader::checkRedirectionCrossOriginAccessControl(const ResourceRequest&amp; previousRequest, const ResourceResponse&amp; redirectResponse, ResourceRequest&amp; newRequest, String&amp; errorMessage)
568 {
569     bool crossOriginFlag = m_resource-&gt;isCrossOrigin();
570     bool isNextRequestCrossOrigin = m_origin &amp;&amp; !m_origin-&gt;canRequest(newRequest.url());
571 
572     if (isNextRequestCrossOrigin)
573         m_resource-&gt;setCrossOrigin();
574 
575     ASSERT(options().mode != FetchOptions::Mode::SameOrigin || !m_resource-&gt;isCrossOrigin());
576 
577     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 7 &amp; 8.
578     if (options().mode == FetchOptions::Mode::Cors) {
<span class="line-modified">579         if (m_resource-&gt;isCrossOrigin() &amp;&amp; !isValidCrossOriginRedirectionURL(newRequest.url())) {</span>
<span class="line-modified">580             errorMessage = &quot;URL is either a non-HTTP URL or contains credentials.&quot;_s;</span>
<span class="line-modified">581             return false;</span>


582         }
583 
584         ASSERT(m_origin);
585         if (crossOriginFlag &amp;&amp; !passesAccessControlCheck(redirectResponse, options().storedCredentialsPolicy, *m_origin, errorMessage))
586             return false;
587     }
588 
589     bool redirectingToNewOrigin = false;
590     if (m_resource-&gt;isCrossOrigin()) {
591         if (!crossOriginFlag &amp;&amp; isNextRequestCrossOrigin)
592             redirectingToNewOrigin = true;
593         else
594             redirectingToNewOrigin = !protocolHostAndPortAreEqual(previousRequest.url(), newRequest.url());
595     }
596 
597     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 10.
598     if (crossOriginFlag &amp;&amp; redirectingToNewOrigin)
599         m_origin = SecurityOrigin::createUnique();
600 
601     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 14.
</pre>
</td>
<td>
<hr />
<pre>
 47 #include &quot;ResourceLoadObserver.h&quot;
 48 #include &quot;ResourceTiming.h&quot;
 49 #include &quot;RuntimeEnabledFeatures.h&quot;
 50 #include &quot;Settings.h&quot;
 51 #include &lt;wtf/CompletionHandler.h&gt;
 52 #include &lt;wtf/Ref.h&gt;
 53 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 54 #include &lt;wtf/StdLibExtras.h&gt;
 55 #include &lt;wtf/SystemTracing.h&gt;
 56 #include &lt;wtf/text/CString.h&gt;
 57 
 58 #if PLATFORM(IOS_FAMILY)
 59 #include &lt;RuntimeApplicationChecks.h&gt;
 60 #endif
 61 
 62 #if ENABLE(CONTENT_EXTENSIONS)
 63 #include &quot;ResourceLoadInfo.h&quot;
 64 #endif
 65 
 66 #if USE(QUICK_LOOK)
<span class="line-added"> 67 #include &quot;LegacyPreviewLoader.h&quot;</span>
 68 #include &quot;PreviewConverter.h&quot;

 69 #endif
 70 
 71 #undef RELEASE_LOG_IF_ALLOWED
 72 #undef RELEASE_LOG_ERROR_IF_ALLOWED
 73 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ResourceLoading, &quot;%p - SubresourceLoader::&quot; fmt, this, ##__VA_ARGS__)
 74 #define RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(isAlwaysOnLoggingAllowed(), ResourceLoading, &quot;%p - SubresourceLoader::&quot; fmt, this, ##__VA_ARGS__)
 75 
 76 namespace WebCore {
 77 
 78 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, subresourceLoaderCounter, (&quot;SubresourceLoader&quot;));
 79 
 80 SubresourceLoader::RequestCountTracker::RequestCountTracker(CachedResourceLoader&amp; cachedResourceLoader, const CachedResource&amp; resource)
 81     : m_cachedResourceLoader(cachedResourceLoader)
 82     , m_resource(resource)
 83 {
 84     m_cachedResourceLoader.incrementRequestCount(m_resource);
 85 }
 86 
 87 SubresourceLoader::RequestCountTracker::~RequestCountTracker()
 88 {
</pre>
<hr />
<pre>
178 }
179 
180 bool SubresourceLoader::isSubresourceLoader() const
181 {
182     return true;
183 }
184 
185 void SubresourceLoader::willSendRequestInternal(ResourceRequest&amp;&amp; newRequest, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
186 {
187     // Store the previous URL because the call to ResourceLoader::willSendRequest will modify it.
188     URL previousURL = request().url();
189     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
190 
191     if (!newRequest.url().isValid()) {
192         cancel(cannotShowURLError());
193         return completionHandler(WTFMove(newRequest));
194     }
195 
196     if (newRequest.requester() != ResourceRequestBase::Requester::Main) {
197         tracePoint(SubresourceLoadWillStart);
<span class="line-modified">198         ResourceLoadObserver::shared().logSubresourceLoading(m_frame.get(), newRequest, redirectResponse,</span>
<span class="line-added">199             (isScriptLikeDestination(options().destination) ? ResourceLoadObserver::FetchDestinationIsScriptLike::Yes : ResourceLoadObserver::FetchDestinationIsScriptLike::No));</span>
200     }
201 
202     auto continueWillSendRequest = [this, protectedThis = makeRef(*this), redirectResponse] (CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler, ResourceRequest&amp;&amp; newRequest) mutable {
203         if (newRequest.isNull() || reachedTerminalState())
204             return completionHandler(WTFMove(newRequest));
205 
206         ResourceLoader::willSendRequestInternal(WTFMove(newRequest), redirectResponse, [this, protectedThis = WTFMove(protectedThis), completionHandler = WTFMove(completionHandler), redirectResponse] (ResourceRequest&amp;&amp; request) mutable {
207             if (reachedTerminalState())
208                 return completionHandler(WTFMove(request));
209 
210             if (request.isNull()) {
211                 cancel();
212                 return completionHandler(WTFMove(request));
213             }
214 
215             if (m_resource-&gt;type() == CachedResource::Type::MainResource &amp;&amp; !redirectResponse.isNull())
216                 m_documentLoader-&gt;willContinueMainResourceLoadAfterRedirect(request);
217             completionHandler(WTFMove(request));
218         });
219     };
</pre>
<hr />
<pre>
222     if (!redirectResponse.isNull()) {
223         if (options().redirect != FetchOptions::Redirect::Follow) {
224             if (options().redirect == FetchOptions::Redirect::Error) {
225                 ResourceError error { errorDomainWebKitInternal, 0, request().url(), makeString(&quot;Not allowed to follow a redirection while loading &quot;, request().url().string()), ResourceError::Type::AccessControl };
226 
227                 if (m_frame &amp;&amp; m_frame-&gt;document())
228                     m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, error.localizedDescription());
229 
230                 RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because not allowed to follow a redirect (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
231 
232                 cancel(error);
233                 return completionHandler(WTFMove(newRequest));
234             }
235 
236             ResourceResponse opaqueRedirectedResponse = redirectResponse;
237             opaqueRedirectedResponse.setType(ResourceResponse::Type::Opaqueredirect);
238             opaqueRedirectedResponse.setTainting(ResourceResponse::Tainting::Opaqueredirect);
239             m_resource-&gt;responseReceived(opaqueRedirectedResponse);
240             if (reachedTerminalState()) {
241                 RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: reached terminal state (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
<span class="line-modified">242                 return completionHandler(WTFMove(newRequest));</span>
243             }
244 
245             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load completed (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
246 
247             NetworkLoadMetrics emptyMetrics;
248             didFinishLoading(emptyMetrics);
249             return completionHandler(WTFMove(newRequest));
250         } else if (m_redirectCount++ &gt;= options().maxRedirectCount) {
251             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because too many redirects (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
252             cancel(ResourceError(String(), 0, request().url(), &quot;Too many redirections&quot;_s, ResourceError::Type::General));
253             return completionHandler(WTFMove(newRequest));
254         }
255 
256         // CachedResources are keyed off their original request URL.
257         // Requesting the same original URL a second time can redirect to a unique second resource.
258         // Therefore, if a redirect to a different destination URL occurs, we should no longer consider this a revalidation of the first resource.
259         // Doing so would have us reusing the resource from the first request if the second request&#39;s revalidation succeeds.
260         if (newRequest.isConditional() &amp;&amp; m_resource-&gt;resourceToRevalidate() &amp;&amp; newRequest.url() != m_resource-&gt;resourceToRevalidate()-&gt;response().url()) {
261             newRequest.makeUnconditional();
262             MemoryCache::singleton().revalidationFailed(*m_resource);
</pre>
<hr />
<pre>
298 void SubresourceLoader::didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
299 {
300     ASSERT(m_state == Initialized);
301     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
302     m_resource-&gt;didSendData(bytesSent, totalBytesToBeSent);
303 }
304 
305 #if USE(QUICK_LOOK)
306 
307 bool SubresourceLoader::shouldCreatePreviewLoaderForResponse(const ResourceResponse&amp; response) const
308 {
309     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
310         return false;
311 
312     if (m_previewLoader)
313         return false;
314 
315     return PreviewConverter::supportsMIMEType(response.mimeType());
316 }
317 
<span class="line-added">318 void SubresourceLoader::didReceivePreviewResponse(const ResourceResponse&amp; response)</span>
<span class="line-added">319 {</span>
<span class="line-added">320     ASSERT(m_state == Initialized);</span>
<span class="line-added">321     ASSERT(!response.isNull());</span>
<span class="line-added">322     ASSERT(m_resource);</span>
<span class="line-added">323     m_resource-&gt;previewResponseReceived(response);</span>
<span class="line-added">324     ResourceLoader::didReceivePreviewResponse(response);</span>
<span class="line-added">325 }</span>
<span class="line-added">326 </span>
327 #endif
328 
<span class="line-added">329 static bool isLocationURLFailure(const ResourceResponse&amp; response)</span>
<span class="line-added">330 {</span>
<span class="line-added">331     auto locationString = response.httpHeaderField(HTTPHeaderName::Location);</span>
<span class="line-added">332     return !locationString.isNull() &amp;&amp; locationString.isEmpty();</span>
<span class="line-added">333 }</span>
<span class="line-added">334 </span>
335 void SubresourceLoader::didReceiveResponse(const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; policyCompletionHandler)
336 {
337     ASSERT(!response.isNull());
338     ASSERT(m_state == Initialized);
339 
340     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(policyCompletionHandler));
341 
342 #if USE(QUICK_LOOK)
343     if (shouldCreatePreviewLoaderForResponse(response)) {
<span class="line-modified">344         m_previewLoader = makeUnique&lt;LegacyPreviewLoader&gt;(*this, response);</span>
345         if (m_previewLoader-&gt;didReceiveResponse(response))
346             return;
347     }
348 #endif
349 #if ENABLE(SERVICE_WORKER)
350     // Implementing step 10 of https://fetch.spec.whatwg.org/#main-fetch for service worker responses.
351     if (response.source() == ResourceResponse::Source::ServiceWorker &amp;&amp; response.url() != request().url()) {
352         auto&amp; loader = m_documentLoader-&gt;cachedResourceLoader();
353         if (!loader.allowedByContentSecurityPolicy(m_resource-&gt;type(), response.url(), options(), ContentSecurityPolicy::RedirectResponseReceived::Yes)) {
354             RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because not allowed by content policy (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
355             cancel(ResourceError({ }, 0, response.url(), { }, ResourceError::Type::General));
356             return;
357         }
358     }
359 #endif
360 
<span class="line-added">361     if (auto error = validateRangeRequestedFlag(request(), response)) {</span>
<span class="line-added">362         RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because receiving a range requested response for a non-range request (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());</span>
<span class="line-added">363         cancel(WTFMove(*error));</span>
<span class="line-added">364         return;</span>
<span class="line-added">365     }</span>
<span class="line-added">366 </span>
367     // We want redirect responses to be processed through willSendRequestInternal. Exceptions are
368     // redirection with no Location headers and fetch in manual redirect mode. Or in rare circumstances,
369     // cases of too many redirects from CFNetwork (&lt;rdar://problem/30610988&gt;).
370 #if !PLATFORM(COCOA)
371     ASSERT(response.httpStatusCode() &lt; 300 || response.httpStatusCode() &gt;= 400 || response.httpStatusCode() == 304 || !response.httpHeaderField(HTTPHeaderName::Location) || response.type() == ResourceResponse::Type::Opaqueredirect);
372 #endif
373 
374     // Reference the object in this method since the additional processing can do
375     // anything including removing the last reference to this object; one example of this is 3266216.
376     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
377 
378     if (shouldIncludeCertificateInfo())
379         response.includeCertificateInfo();
380 
381     if (m_resource-&gt;resourceToRevalidate()) {
382         if (response.httpStatusCode() == 304) {
383             // 304 Not modified / Use local copy
384             // Existing resource is ok, just use it updating the expiration time.
385             ResourceResponse revalidationResponse = response;
386             revalidationResponse.setSource(ResourceResponse::Source::MemoryCacheAfterValidation);
</pre>
<hr />
<pre>
390                 m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultPass, ShouldSample::Yes);
391             if (!reachedTerminalState())
392                 ResourceLoader::didReceiveResponse(revalidationResponse, [completionHandlerCaller = WTFMove(completionHandlerCaller)] { });
393             return;
394         }
395         // Did not get 304 response, continue as a regular resource load.
396         MemoryCache::singleton().revalidationFailed(*m_resource);
397         if (m_frame &amp;&amp; m_frame-&gt;page())
398             m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultFail, ShouldSample::Yes);
399     }
400 
401     String errorDescription;
402     if (!checkResponseCrossOriginAccessControl(response, errorDescription)) {
403         if (m_frame &amp;&amp; m_frame-&gt;document())
404             m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, errorDescription);
405         RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because of cross origin access control (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
406         cancel(ResourceError(String(), 0, request().url(), errorDescription, ResourceError::Type::AccessControl));
407         return;
408     }
409 
<span class="line-added">410     if (response.isRedirection()) {</span>
<span class="line-added">411         if (options().redirect == FetchOptions::Redirect::Follow &amp;&amp; isLocationURLFailure(response)) {</span>
<span class="line-added">412             // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 3</span>
<span class="line-added">413             cancel();</span>
<span class="line-added">414             return;</span>
<span class="line-added">415         }</span>
<span class="line-added">416         if (options().redirect == FetchOptions::Redirect::Manual) {</span>
<span class="line-added">417             ResourceResponse opaqueRedirectedResponse = response;</span>
<span class="line-added">418             opaqueRedirectedResponse.setType(ResourceResponse::Type::Opaqueredirect);</span>
<span class="line-added">419             opaqueRedirectedResponse.setTainting(ResourceResponse::Tainting::Opaqueredirect);</span>
<span class="line-added">420             m_resource-&gt;responseReceived(opaqueRedirectedResponse);</span>
<span class="line-added">421             if (!reachedTerminalState())</span>
<span class="line-added">422                 ResourceLoader::didReceiveResponse(opaqueRedirectedResponse, [completionHandlerCaller = WTFMove(completionHandlerCaller)] { });</span>
<span class="line-added">423             return;</span>
<span class="line-added">424         }</span>
<span class="line-added">425     }</span>
426     m_resource-&gt;responseReceived(response);
427     if (reachedTerminalState())
428         return;
429 
430     bool isResponseMultipart = response.isMultipart();
431     if (options().mode != FetchOptions::Mode::Navigate)
432         LinkLoader::loadLinksFromHeader(response.httpHeaderField(HTTPHeaderName::Link), m_documentLoader-&gt;url(), *m_frame-&gt;document(), LinkLoader::MediaAttributeCheck::SkipMediaAttributeCheck);
433     ResourceLoader::didReceiveResponse(response, [this, protectedThis = WTFMove(protectedThis), isResponseMultipart, completionHandlerCaller = WTFMove(completionHandlerCaller)]() mutable {
434         if (reachedTerminalState())
435             return;
436 
437         // FIXME: Main resources have a different set of rules for multipart than images do.
438         // Hopefully we can merge those 2 paths.
439         if (isResponseMultipart &amp;&amp; m_resource-&gt;type() != CachedResource::Type::MainResource) {
440             m_loadingMultipartContent = true;
441 
442             // We don&#39;t count multiParts in a CachedResourceLoader&#39;s request count
443             m_requestCountTracker = WTF::nullopt;
444             if (!m_resource-&gt;isImage()) {
445                 RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because something about a multi-part non-image (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
</pre>
<hr />
<pre>
597         return response.tainting() != ResourceResponse::Tainting::Opaque;
598 #endif
599 
600     ASSERT(m_origin);
601 
602     return passesAccessControlCheck(response, options().credentials == FetchOptions::Credentials::Include ? StoredCredentialsPolicy::Use : StoredCredentialsPolicy::DoNotUse, *m_origin, errorDescription);
603 }
604 
605 bool SubresourceLoader::checkRedirectionCrossOriginAccessControl(const ResourceRequest&amp; previousRequest, const ResourceResponse&amp; redirectResponse, ResourceRequest&amp; newRequest, String&amp; errorMessage)
606 {
607     bool crossOriginFlag = m_resource-&gt;isCrossOrigin();
608     bool isNextRequestCrossOrigin = m_origin &amp;&amp; !m_origin-&gt;canRequest(newRequest.url());
609 
610     if (isNextRequestCrossOrigin)
611         m_resource-&gt;setCrossOrigin();
612 
613     ASSERT(options().mode != FetchOptions::Mode::SameOrigin || !m_resource-&gt;isCrossOrigin());
614 
615     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 7 &amp; 8.
616     if (options().mode == FetchOptions::Mode::Cors) {
<span class="line-modified">617         if (m_resource-&gt;isCrossOrigin()) {</span>
<span class="line-modified">618             auto locationString = redirectResponse.httpHeaderField(HTTPHeaderName::Location);</span>
<span class="line-modified">619             errorMessage = validateCrossOriginRedirectionURL(URL(redirectResponse.url(), locationString));</span>
<span class="line-added">620             if (!errorMessage.isNull())</span>
<span class="line-added">621                 return false;</span>
622         }
623 
624         ASSERT(m_origin);
625         if (crossOriginFlag &amp;&amp; !passesAccessControlCheck(redirectResponse, options().storedCredentialsPolicy, *m_origin, errorMessage))
626             return false;
627     }
628 
629     bool redirectingToNewOrigin = false;
630     if (m_resource-&gt;isCrossOrigin()) {
631         if (!crossOriginFlag &amp;&amp; isNextRequestCrossOrigin)
632             redirectingToNewOrigin = true;
633         else
634             redirectingToNewOrigin = !protocolHostAndPortAreEqual(previousRequest.url(), newRequest.url());
635     }
636 
637     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 10.
638     if (crossOriginFlag &amp;&amp; redirectingToNewOrigin)
639         m_origin = SecurityOrigin::createUnique();
640 
641     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 14.
</pre>
</td>
</tr>
</table>
<center><a href="SubresourceIntegrity.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SubresourceLoader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLSemanticMatcher.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLSemanticMatcher.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLSemanticMatcher.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLSemanticMatcher.cpp
@@ -59,13 +59,11 @@
 }
 
 static Optional<HashMap<Binding*, size_t>> matchResources(Vector<EntryPointItem>& entryPointItems, Layout& layout, ShaderStage shaderStage)
 {
     HashMap<Binding*, size_t> result;
-    HashSet<size_t> itemIndices;
-    if (entryPointItems.size() == std::numeric_limits<size_t>::max())
-        return WTF::nullopt; // Work around the fact that HashSet's keys are restricted.
+    HashSet<size_t, DefaultHash<size_t>::Hash, WTF::UnsignedWithZeroKeyHashTraits<size_t>> itemIndices;
     for (auto& bindGroup : layout) {
         auto space = bindGroup.name;
         for (auto& binding : bindGroup.bindings) {
             if (!binding.visibility.contains(shaderStage))
                 continue;
@@ -80,21 +78,21 @@
                 if (binding.externalName != resourceSemantic.index())
                     continue;
                 if (space != resourceSemantic.space())
                     continue;
                 result.add(&binding, i);
-                itemIndices.add(i + 1); // Work around the fact that HashSet's keys are restricted.
+                itemIndices.add(i);
             }
         }
     }
 
     for (size_t i = 0; i < entryPointItems.size(); ++i) {
         auto& item = entryPointItems[i];
         auto& semantic = *item.semantic;
         if (!WTF::holds_alternative<AST::ResourceSemantic>(semantic))
             continue;
-        if (!itemIndices.contains(i + 1))
+        if (!itemIndices.contains(i))
             return WTF::nullopt;
     }
 
     return result;
 }
@@ -140,13 +138,11 @@
 }
 
 static Optional<HashMap<VertexAttribute*, size_t>> matchVertexAttributes(Vector<EntryPointItem>& vertexInputs, VertexAttributes& vertexAttributes, Intrinsics& intrinsics)
 {
     HashMap<VertexAttribute*, size_t> result;
-    HashSet<size_t> itemIndices;
-    if (vertexInputs.size() == std::numeric_limits<size_t>::max())
-        return WTF::nullopt; // Work around the fact that HashSet's keys are restricted.
+    HashSet<size_t, DefaultHash<size_t>::Hash, WTF::UnsignedWithZeroKeyHashTraits<size_t>> itemIndices;
     for (auto& vertexAttribute : vertexAttributes) {
         for (size_t i = 0; i < vertexInputs.size(); ++i) {
             auto& item = vertexInputs[i];
             auto& semantic = *item.semantic;
             if (!WTF::holds_alternative<AST::StageInOutSemantic>(semantic))
@@ -155,20 +151,20 @@
             if (stageInOutSemantic.index() != vertexAttribute.shaderLocation)
                 continue;
             if (!isAcceptableFormat(vertexAttribute.vertexFormat, *item.unnamedType, intrinsics))
                 return WTF::nullopt;
             result.add(&vertexAttribute, i);
-            itemIndices.add(i + 1); // Work around the fact that HashSet's keys are restricted.
+            itemIndices.add(i);
         }
     }
 
     for (size_t i = 0; i < vertexInputs.size(); ++i) {
         auto& item = vertexInputs[i];
         auto& semantic = *item.semantic;
         if (!WTF::holds_alternative<AST::StageInOutSemantic>(semantic))
             continue;
-        if (!itemIndices.contains(i + 1))
+        if (!itemIndices.contains(i))
             return WTF::nullopt;
     }
 
     return result;
 }
@@ -228,13 +224,11 @@
 }
 
 static Optional<HashMap<AttachmentDescriptor*, size_t>> matchColorAttachments(Vector<EntryPointItem>& fragmentOutputs, Vector<AttachmentDescriptor>& attachmentDescriptors, Intrinsics& intrinsics)
 {
     HashMap<AttachmentDescriptor*, size_t> result;
-    HashSet<size_t> itemIndices;
-    if (attachmentDescriptors.size() == std::numeric_limits<size_t>::max())
-        return WTF::nullopt; // Work around the fact that HashSet's keys are restricted.
+    HashSet<size_t, DefaultHash<size_t>::Hash, WTF::UnsignedWithZeroKeyHashTraits<size_t>> itemIndices;
     for (auto& attachmentDescriptor : attachmentDescriptors) {
         for (size_t i = 0; i < fragmentOutputs.size(); ++i) {
             auto& item = fragmentOutputs[i];
             auto& semantic = *item.semantic;
             if (!WTF::holds_alternative<AST::StageInOutSemantic>(semantic))
@@ -243,20 +237,20 @@
             if (stageInOutSemantic.index() != attachmentDescriptor.name)
                 continue;
             if (!isAcceptableFormat(attachmentDescriptor.textureFormat, *item.unnamedType, intrinsics, true))
                 return WTF::nullopt;
             result.add(&attachmentDescriptor, i);
-            itemIndices.add(i + 1); // Work around the fact that HashSet's keys are restricted.
+            itemIndices.add(i);
         }
     }
 
     for (size_t i = 0; i < fragmentOutputs.size(); ++i) {
         auto& item = fragmentOutputs[i];
         auto& semantic = *item.semantic;
         if (!WTF::holds_alternative<AST::StageInOutSemantic>(semantic))
             continue;
-        if (!itemIndices.contains(i + 1))
+        if (!itemIndices.contains(i))
             return WTF::nullopt;
     }
 
     return result;
 }

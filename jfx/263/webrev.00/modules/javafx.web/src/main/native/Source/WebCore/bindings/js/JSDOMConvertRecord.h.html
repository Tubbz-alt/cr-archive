<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertRecord.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;IDLTypes.h&quot;
 29 #include &quot;JSDOMConvertStrings.h&quot;
 30 #include &quot;JSDOMGlobalObject.h&quot;
 31 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
 32 
 33 namespace WebCore {
 34 
 35 namespace Detail {
 36 
 37 template&lt;typename IDLStringType&gt;
 38 struct IdentifierConverter;
 39 
 40 template&lt;&gt; struct IdentifierConverter&lt;IDLDOMString&gt; {
 41     static String convert(JSC::JSGlobalObject&amp;, const JSC::Identifier&amp; identifier)
 42     {
 43         return identifier.string();
 44     }
 45 };
 46 
 47 template&lt;&gt; struct IdentifierConverter&lt;IDLByteString&gt; {
 48     static String convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, const JSC::Identifier&amp; identifier)
 49     {
 50         return identifierToByteString(lexicalGlobalObject, identifier);
 51     }
 52 };
 53 
 54 template&lt;&gt; struct IdentifierConverter&lt;IDLUSVString&gt; {
 55     static String convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, const JSC::Identifier&amp; identifier)
 56     {
 57         return identifierToUSVString(lexicalGlobalObject, identifier);
 58     }
 59 };
 60 
 61 }
 62 
 63 template&lt;typename K, typename V&gt; struct Converter&lt;IDLRecord&lt;K, V&gt;&gt; : DefaultConverter&lt;IDLRecord&lt;K, V&gt;&gt; {
 64     using ReturnType = typename IDLRecord&lt;K, V&gt;::ImplementationType;
 65     using KeyType = typename K::ImplementationType;
 66     using ValueType = typename V::ImplementationType;
 67 
 68     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, JSDOMGlobalObject&amp; globalObject)
 69     {
 70         return convertRecord&lt;JSDOMGlobalObject&amp;&gt;(lexicalGlobalObject, value, globalObject);
 71     }
 72 
 73     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)
 74     {
 75         return convertRecord(lexicalGlobalObject, value);
 76     }
 77 
 78 private:
 79     template&lt;class...Args&gt;
 80     static ReturnType convertRecord(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, Args ... args)
 81     {
 82         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);
 83         auto scope = DECLARE_THROW_SCOPE(vm);
 84 
 85         // 1. Let result be a new empty instance of record&lt;K, V&gt;.
 86         // 2. If Type(O) is Undefined or Null, return result.
 87         if (value.isUndefinedOrNull())
 88             return { };
 89 
 90         // 3. If Type(O) is not Object, throw a TypeError.
 91         if (!value.isObject()) {
 92             throwTypeError(&amp;lexicalGlobalObject, scope);
 93             return { };
 94         }
 95 
 96         JSC::JSObject* object = JSC::asObject(value);
 97 
 98         ReturnType result;
 99 
100         // 4. Let keys be ? O.[[OwnPropertyKeys]]().
101         JSC::PropertyNameArray keys(vm, JSC::PropertyNameMode::Strings, JSC::PrivateSymbolMode::Exclude);
102         object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, &amp;lexicalGlobalObject, keys, JSC::EnumerationMode(JSC::DontEnumPropertiesMode::Include));
103 
104         RETURN_IF_EXCEPTION(scope, { });
105 
106         // 5. Repeat, for each element key of keys in List order:
107         for (auto&amp; key : keys) {
108             // 1. Let desc be ? O.[[GetOwnProperty]](key).
109             JSC::PropertyDescriptor descriptor;
110             bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(&amp;lexicalGlobalObject, key, descriptor);
111             RETURN_IF_EXCEPTION(scope, { });
112 
113             // 2. If desc is not undefined and desc.[[Enumerable]] is true:
114 
115             // It&#39;s necessary to filter enumerable here rather than using the default EnumerationMode,
116             // to prevent an observable extra [[GetOwnProperty]] operation in the case of ProxyObject records.
117             if (didGetDescriptor &amp;&amp; descriptor.enumerable()) {
118                 // 1. Let typedKey be key converted to an IDL value of type K.
119                 auto typedKey = Detail::IdentifierConverter&lt;K&gt;::convert(lexicalGlobalObject, key);
120                 RETURN_IF_EXCEPTION(scope, { });
121 
122                 // 2. Let value be ? Get(O, key).
123                 auto subValue = object-&gt;get(&amp;lexicalGlobalObject, key);
124                 RETURN_IF_EXCEPTION(scope, { });
125 
126                 // 3. Let typedValue be value converted to an IDL value of type V.
127                 auto typedValue = Converter&lt;V&gt;::convert(lexicalGlobalObject, subValue, args...);
128                 RETURN_IF_EXCEPTION(scope, { });
129 
130                 // 4. If typedKey is already a key in result, set its value to typedValue.
131                 // Note: This can happen when O is a proxy object.
132                 // FIXME: Handle this case.
133 
134                 // 5. Otherwise, append to result a mapping (typedKey, typedValue).
135                 result.append({ typedKey, typedValue });
136             }
137         }
138 
139         // 6. Return result.
140         return result;
141     }
142 };
143 
144 template&lt;typename K, typename V&gt; struct JSConverter&lt;IDLRecord&lt;K, V&gt;&gt; {
145     static constexpr bool needsState = true;
146     static constexpr bool needsGlobalObject = true;
147 
148     template&lt;typename MapType&gt;
149     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const MapType&amp; map)
150     {
151         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);
152 
153         // 1. Let result be ! ObjectCreate(%ObjectPrototype%).
154         auto result = constructEmptyObject(&amp;lexicalGlobalObject, globalObject.objectPrototype());
155 
156         // 2. Repeat, for each mapping (key, value) in D:
157         for (const auto&amp; keyValuePair : map) {
158             // 1. Let esKey be key converted to an ECMAScript value.
159             // Note, this step is not required, as we need the key to be
160             // an Identifier, not a JSValue.
161 
162             // 2. Let esValue be value converted to an ECMAScript value.
163             auto esValue = toJS&lt;V&gt;(lexicalGlobalObject, globalObject, keyValuePair.value);
164 
165             // 3. Let created be ! CreateDataProperty(result, esKey, esValue).
166             bool created = result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, keyValuePair.key), esValue);
167 
168             // 4. Assert: created is true.
169             ASSERT_UNUSED(created, created);
170         }
171 
172         // 3. Return result.
173         return result;
174     }
175 };
176 
177 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTheme.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderTextLineBoxes.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTheme.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTheme.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 76,30 ***</span>
  
  RenderTheme::RenderTheme()
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* element, bool UAHasAppearance, const BorderData&amp; border, const FillLayer&amp; background, const Color&amp; backgroundColor)</span>
  {
      // Force inline and table display styles to be inline-block (except for table- which is block)
      ControlPart part = style.appearance();
      if (style.display() == DisplayType::Inline || style.display() == DisplayType::InlineTable || style.display() == DisplayType::TableRowGroup
          || style.display() == DisplayType::TableHeaderGroup || style.display() == DisplayType::TableFooterGroup
          || style.display() == DisplayType::TableRow || style.display() == DisplayType::TableColumnGroup || style.display() == DisplayType::TableColumn
          || style.display() == DisplayType::TableCell || style.display() == DisplayType::TableCaption)
          style.setDisplay(DisplayType::InlineBlock);
<span class="line-modified">!     else if (style.display() == DisplayType::Compact || style.display() == DisplayType::ListItem || style.display() == DisplayType::Table)</span>
          style.setDisplay(DisplayType::Block);
  
<span class="line-modified">!     if (UAHasAppearance &amp;&amp; isControlStyled(style, border, background, backgroundColor)) {</span>
          switch (part) {
          case MenulistPart:
              style.setAppearance(MenulistButtonPart);
              part = MenulistButtonPart;
              break;
          case TextFieldPart:
<span class="line-modified">!             adjustTextFieldStyle(styleResolver, style, element);</span>
              FALLTHROUGH;
          default:
              style.setAppearance(NoControlPart);
              break;
          }
<span class="line-new-header">--- 76,30 ---</span>
  
  RenderTheme::RenderTheme()
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustStyle(RenderStyle&amp; style, const Element* element, const RenderStyle* userAgentAppearanceStyle)</span>
  {
      // Force inline and table display styles to be inline-block (except for table- which is block)
      ControlPart part = style.appearance();
      if (style.display() == DisplayType::Inline || style.display() == DisplayType::InlineTable || style.display() == DisplayType::TableRowGroup
          || style.display() == DisplayType::TableHeaderGroup || style.display() == DisplayType::TableFooterGroup
          || style.display() == DisplayType::TableRow || style.display() == DisplayType::TableColumnGroup || style.display() == DisplayType::TableColumn
          || style.display() == DisplayType::TableCell || style.display() == DisplayType::TableCaption)
          style.setDisplay(DisplayType::InlineBlock);
<span class="line-modified">!     else if (style.display() == DisplayType::ListItem || style.display() == DisplayType::Table)</span>
          style.setDisplay(DisplayType::Block);
  
<span class="line-modified">!     if (userAgentAppearanceStyle &amp;&amp; isControlStyled(style, *userAgentAppearanceStyle)) {</span>
          switch (part) {
          case MenulistPart:
              style.setAppearance(MenulistButtonPart);
              part = MenulistButtonPart;
              break;
          case TextFieldPart:
<span class="line-modified">!             adjustTextFieldStyle(style, element);</span>
              FALLTHROUGH;
          default:
              style.setAppearance(NoControlPart);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,87 ***</span>
  
      // Call the appropriate style adjustment method based off the appearance value.
      switch (style.appearance()) {
  #if !USE(NEW_THEME)
      case CheckboxPart:
<span class="line-modified">!         return adjustCheckboxStyle(styleResolver, style, element);</span>
      case RadioPart:
<span class="line-modified">!         return adjustRadioStyle(styleResolver, style, element);</span>
      case PushButtonPart:
      case SquareButtonPart:
  #if ENABLE(INPUT_TYPE_COLOR)
      case ColorWellPart:
  #endif
      case DefaultButtonPart:
      case ButtonPart:
<span class="line-modified">!         return adjustButtonStyle(styleResolver, style, element);</span>
      case InnerSpinButtonPart:
<span class="line-modified">!         return adjustInnerSpinButtonStyle(styleResolver, style, element);</span>
  #endif
      case TextFieldPart:
<span class="line-modified">!         return adjustTextFieldStyle(styleResolver, style, element);</span>
      case TextAreaPart:
<span class="line-modified">!         return adjustTextAreaStyle(styleResolver, style, element);</span>
      case MenulistPart:
<span class="line-modified">!         return adjustMenuListStyle(styleResolver, style, element);</span>
      case MenulistButtonPart:
<span class="line-modified">!         return adjustMenuListButtonStyle(styleResolver, style, element);</span>
      case MediaPlayButtonPart:
      case MediaCurrentTimePart:
      case MediaTimeRemainingPart:
      case MediaEnterFullscreenButtonPart:
      case MediaExitFullscreenButtonPart:
      case MediaMuteButtonPart:
      case MediaVolumeSliderContainerPart:
<span class="line-modified">!         return adjustMediaControlStyle(styleResolver, style, element);</span>
      case MediaSliderPart:
      case MediaVolumeSliderPart:
      case MediaFullScreenVolumeSliderPart:
      case SliderHorizontalPart:
      case SliderVerticalPart:
<span class="line-modified">!         return adjustSliderTrackStyle(styleResolver, style, element);</span>
      case SliderThumbHorizontalPart:
      case SliderThumbVerticalPart:
<span class="line-modified">!         return adjustSliderThumbStyle(styleResolver, style, element);</span>
      case SearchFieldPart:
<span class="line-modified">!         return adjustSearchFieldStyle(styleResolver, style, element);</span>
      case SearchFieldCancelButtonPart:
<span class="line-modified">!         return adjustSearchFieldCancelButtonStyle(styleResolver, style, element);</span>
      case SearchFieldDecorationPart:
<span class="line-modified">!         return adjustSearchFieldDecorationPartStyle(styleResolver, style, element);</span>
      case SearchFieldResultsDecorationPart:
<span class="line-modified">!         return adjustSearchFieldResultsDecorationPartStyle(styleResolver, style, element);</span>
      case SearchFieldResultsButtonPart:
<span class="line-modified">!         return adjustSearchFieldResultsButtonStyle(styleResolver, style, element);</span>
      case ProgressBarPart:
<span class="line-modified">!         return adjustProgressBarStyle(styleResolver, style, element);</span>
  #if ENABLE(METER_ELEMENT)
      case MeterPart:
      case RelevancyLevelIndicatorPart:
      case ContinuousCapacityLevelIndicatorPart:
      case DiscreteCapacityLevelIndicatorPart:
      case RatingLevelIndicatorPart:
<span class="line-modified">!         return adjustMeterStyle(styleResolver, style, element);</span>
  #endif
  #if ENABLE(SERVICE_CONTROLS)
      case ImageControlsButtonPart:
          break;
  #endif
      case CapsLockIndicatorPart:
<span class="line-modified">!         return adjustCapsLockIndicatorStyle(styleResolver, style, element);</span>
  #if ENABLE(APPLE_PAY)
      case ApplePayButtonPart:
<span class="line-modified">!         return adjustApplePayButtonStyle(styleResolver, style, element);</span>
  #endif
  #if ENABLE(ATTACHMENT_ELEMENT)
      case AttachmentPart:
      case BorderlessAttachmentPart:
<span class="line-modified">!         return adjustAttachmentStyle(styleResolver, style, element);</span>
  #endif
  #if ENABLE(DATALIST_ELEMENT)
      case ListButtonPart:
<span class="line-modified">!         return adjustListButtonStyle(styleResolver, style, element);</span>
  #endif
      default:
          break;
      }
  }
<span class="line-new-header">--- 198,87 ---</span>
  
      // Call the appropriate style adjustment method based off the appearance value.
      switch (style.appearance()) {
  #if !USE(NEW_THEME)
      case CheckboxPart:
<span class="line-modified">!         return adjustCheckboxStyle(style, element);</span>
      case RadioPart:
<span class="line-modified">!         return adjustRadioStyle(style, element);</span>
      case PushButtonPart:
      case SquareButtonPart:
  #if ENABLE(INPUT_TYPE_COLOR)
      case ColorWellPart:
  #endif
      case DefaultButtonPart:
      case ButtonPart:
<span class="line-modified">!         return adjustButtonStyle(style, element);</span>
      case InnerSpinButtonPart:
<span class="line-modified">!         return adjustInnerSpinButtonStyle(style, element);</span>
  #endif
      case TextFieldPart:
<span class="line-modified">!         return adjustTextFieldStyle(style, element);</span>
      case TextAreaPart:
<span class="line-modified">!         return adjustTextAreaStyle(style, element);</span>
      case MenulistPart:
<span class="line-modified">!         return adjustMenuListStyle(style, element);</span>
      case MenulistButtonPart:
<span class="line-modified">!         return adjustMenuListButtonStyle(style, element);</span>
      case MediaPlayButtonPart:
      case MediaCurrentTimePart:
      case MediaTimeRemainingPart:
      case MediaEnterFullscreenButtonPart:
      case MediaExitFullscreenButtonPart:
      case MediaMuteButtonPart:
      case MediaVolumeSliderContainerPart:
<span class="line-modified">!         return adjustMediaControlStyle(style, element);</span>
      case MediaSliderPart:
      case MediaVolumeSliderPart:
      case MediaFullScreenVolumeSliderPart:
      case SliderHorizontalPart:
      case SliderVerticalPart:
<span class="line-modified">!         return adjustSliderTrackStyle(style, element);</span>
      case SliderThumbHorizontalPart:
      case SliderThumbVerticalPart:
<span class="line-modified">!         return adjustSliderThumbStyle(style, element);</span>
      case SearchFieldPart:
<span class="line-modified">!         return adjustSearchFieldStyle(style, element);</span>
      case SearchFieldCancelButtonPart:
<span class="line-modified">!         return adjustSearchFieldCancelButtonStyle(style, element);</span>
      case SearchFieldDecorationPart:
<span class="line-modified">!         return adjustSearchFieldDecorationPartStyle(style, element);</span>
      case SearchFieldResultsDecorationPart:
<span class="line-modified">!         return adjustSearchFieldResultsDecorationPartStyle(style, element);</span>
      case SearchFieldResultsButtonPart:
<span class="line-modified">!         return adjustSearchFieldResultsButtonStyle(style, element);</span>
      case ProgressBarPart:
<span class="line-modified">!         return adjustProgressBarStyle(style, element);</span>
  #if ENABLE(METER_ELEMENT)
      case MeterPart:
      case RelevancyLevelIndicatorPart:
      case ContinuousCapacityLevelIndicatorPart:
      case DiscreteCapacityLevelIndicatorPart:
      case RatingLevelIndicatorPart:
<span class="line-modified">!         return adjustMeterStyle(style, element);</span>
  #endif
  #if ENABLE(SERVICE_CONTROLS)
      case ImageControlsButtonPart:
          break;
  #endif
      case CapsLockIndicatorPart:
<span class="line-modified">!         return adjustCapsLockIndicatorStyle(style, element);</span>
  #if ENABLE(APPLE_PAY)
      case ApplePayButtonPart:
<span class="line-modified">!         return adjustApplePayButtonStyle(style, element);</span>
  #endif
  #if ENABLE(ATTACHMENT_ELEMENT)
      case AttachmentPart:
      case BorderlessAttachmentPart:
<span class="line-modified">!         return adjustAttachmentStyle(style, element);</span>
  #endif
  #if ENABLE(DATALIST_ELEMENT)
      case ListButtonPart:
<span class="line-modified">!         return adjustListButtonStyle(style, element);</span>
  #endif
      default:
          break;
      }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 728,11 ***</span>
      // There are more leaves than this, but we&#39;ll patch this function as we add support for
      // more controls.
      return appearance != CheckboxPart &amp;&amp; appearance != RadioPart;
  }
  
<span class="line-modified">! bool RenderTheme::isControlStyled(const RenderStyle&amp; style, const BorderData&amp; border, const FillLayer&amp; background, const Color&amp; backgroundColor) const</span>
  {
      switch (style.appearance()) {
      case PushButtonPart:
      case SquareButtonPart:
  #if ENABLE(INPUT_TYPE_COLOR)
<span class="line-new-header">--- 728,11 ---</span>
      // There are more leaves than this, but we&#39;ll patch this function as we add support for
      // more controls.
      return appearance != CheckboxPart &amp;&amp; appearance != RadioPart;
  }
  
<span class="line-modified">! bool RenderTheme::isControlStyled(const RenderStyle&amp; style, const RenderStyle&amp; userAgentStyle) const</span>
  {
      switch (style.appearance()) {
      case PushButtonPart:
      case SquareButtonPart:
  #if ENABLE(INPUT_TYPE_COLOR)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 750,13 ***</span>
      case RatingLevelIndicatorPart:
      // FIXME: SearchFieldPart should be included here when making search fields style-able.
      case TextFieldPart:
      case TextAreaPart:
          // Test the style to see if the UA border and background match.
<span class="line-modified">!         return style.border() != border</span>
<span class="line-modified">!             || style.backgroundLayers() != background</span>
<span class="line-modified">!             || !style.backgroundColorEqualsToColorIgnoringVisited(backgroundColor);</span>
      default:
          return false;
      }
  }
  
<span class="line-new-header">--- 750,13 ---</span>
      case RatingLevelIndicatorPart:
      // FIXME: SearchFieldPart should be included here when making search fields style-able.
      case TextFieldPart:
      case TextAreaPart:
          // Test the style to see if the UA border and background match.
<span class="line-modified">!         return style.border() != userAgentStyle.border()</span>
<span class="line-modified">!             || style.backgroundLayers() != userAgentStyle.backgroundLayers()</span>
<span class="line-modified">!             || !style.backgroundColorEqualsToColorIgnoringVisited(userAgentStyle.backgroundColor());</span>
      default:
          return false;
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 924,11 ***</span>
      return o.style().appearance() == DefaultButtonPart;
  }
  
  #if !USE(NEW_THEME)
  
<span class="line-modified">! void RenderTheme::adjustCheckboxStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
  {
      // A summary of the rules for checkbox designed to match WinIE:
      // width/height - honored (WinIE actually scales its control for small widths, but lets it overflow for small heights.)
      // font-size - not honored (control has no text), but we use it to decide which control size to use.
      setCheckboxSize(style);
<span class="line-new-header">--- 924,11 ---</span>
      return o.style().appearance() == DefaultButtonPart;
  }
  
  #if !USE(NEW_THEME)
  
<span class="line-modified">! void RenderTheme::adjustCheckboxStyle(RenderStyle&amp; style, const Element*) const</span>
  {
      // A summary of the rules for checkbox designed to match WinIE:
      // width/height - honored (WinIE actually scales its control for small widths, but lets it overflow for small heights.)
      // font-size - not honored (control has no text), but we use it to decide which control size to use.
      setCheckboxSize(style);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 941,11 ***</span>
      style.resetBorder();
  
      style.setBoxShadow(nullptr);
  }
  
<span class="line-modified">! void RenderTheme::adjustRadioStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
  {
      // A summary of the rules for checkbox designed to match WinIE:
      // width/height - honored (WinIE actually scales its control for small widths, but lets it overflow for small heights.)
      // font-size - not honored (control has no text), but we use it to decide which control size to use.
      setRadioSize(style);
<span class="line-new-header">--- 941,11 ---</span>
      style.resetBorder();
  
      style.setBoxShadow(nullptr);
  }
  
<span class="line-modified">! void RenderTheme::adjustRadioStyle(RenderStyle&amp; style, const Element*) const</span>
  {
      // A summary of the rules for checkbox designed to match WinIE:
      // width/height - honored (WinIE actually scales its control for small widths, but lets it overflow for small heights.)
      // font-size - not honored (control has no text), but we use it to decide which control size to use.
      setRadioSize(style);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 958,38 ***</span>
      style.resetBorder();
  
      style.setBoxShadow(nullptr);
  }
  
<span class="line-modified">! void RenderTheme::adjustButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
  {
      // Most platforms will completely honor all CSS, and so we have no need to
      // adjust the style at all by default. We will still allow the theme a crack
      // at setting up a desired vertical size.
      setButtonSize(style);
  }
  
<span class="line-modified">! void RenderTheme::adjustInnerSpinButtonStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  #endif
  
<span class="line-modified">! void RenderTheme::adjustTextFieldStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustTextAreaStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustMenuListStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
  #if ENABLE(METER_ELEMENT)
  
<span class="line-modified">! void RenderTheme::adjustMeterStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
  {
      style.setBoxShadow(nullptr);
  }
  
  IntSize RenderTheme::meterSizeForBounds(const RenderMeter&amp;, const IntRect&amp; bounds) const
<span class="line-new-header">--- 958,38 ---</span>
      style.resetBorder();
  
      style.setBoxShadow(nullptr);
  }
  
<span class="line-modified">! void RenderTheme::adjustButtonStyle(RenderStyle&amp; style, const Element*) const</span>
  {
      // Most platforms will completely honor all CSS, and so we have no need to
      // adjust the style at all by default. We will still allow the theme a crack
      // at setting up a desired vertical size.
      setButtonSize(style);
  }
  
<span class="line-modified">! void RenderTheme::adjustInnerSpinButtonStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  #endif
  
<span class="line-modified">! void RenderTheme::adjustTextFieldStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustTextAreaStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustMenuListStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
  #if ENABLE(METER_ELEMENT)
  
<span class="line-modified">! void RenderTheme::adjustMeterStyle(RenderStyle&amp; style, const Element*) const</span>
  {
      style.setBoxShadow(nullptr);
  }
  
  IntSize RenderTheme::meterSizeForBounds(const RenderMeter&amp;, const IntRect&amp; bounds) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1007,22 ***</span>
      return true;
  }
  
  #endif // METER_ELEMENT
  
<span class="line-modified">! void RenderTheme::adjustCapsLockIndicatorStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
  bool RenderTheme::paintCapsLockIndicator(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
  {
      return false;
  }
  
  #if ENABLE(ATTACHMENT_ELEMENT)
  
<span class="line-modified">! void RenderTheme::adjustAttachmentStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
  bool RenderTheme::paintAttachment(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
  {
<span class="line-new-header">--- 1007,22 ---</span>
      return true;
  }
  
  #endif // METER_ELEMENT
  
<span class="line-modified">! void RenderTheme::adjustCapsLockIndicatorStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
  bool RenderTheme::paintCapsLockIndicator(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
  {
      return false;
  }
  
  #if ENABLE(ATTACHMENT_ELEMENT)
  
<span class="line-modified">! void RenderTheme::adjustAttachmentStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
  bool RenderTheme::paintAttachment(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1047,11 ***</span>
  {
      ASSERT(RuntimeEnabledFeatures::sharedFeatures().dataListElementEnabled());
      return &quot;datalist { display: none; }&quot;_s;
  }
  
<span class="line-modified">! void RenderTheme::adjustListButtonStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
  LayoutUnit RenderTheme::sliderTickSnappingThreshold() const
  {
<span class="line-new-header">--- 1047,11 ---</span>
  {
      ASSERT(RuntimeEnabledFeatures::sharedFeatures().dataListElementEnabled());
      return &quot;datalist { display: none; }&quot;_s;
  }
  
<span class="line-modified">! void RenderTheme::adjustListButtonStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
  LayoutUnit RenderTheme::sliderTickSnappingThreshold() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1148,11 ***</span>
  Seconds RenderTheme::animationDurationForProgressBar(RenderProgress&amp;) const
  {
      return 0_s;
  }
  
<span class="line-modified">! void RenderTheme::adjustProgressBarStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
  IntRect RenderTheme::progressBarRectForBounds(const RenderObject&amp;, const IntRect&amp; bounds) const
  {
<span class="line-new-header">--- 1148,11 ---</span>
  Seconds RenderTheme::animationDurationForProgressBar(RenderProgress&amp;) const
  {
      return 0_s;
  }
  
<span class="line-modified">! void RenderTheme::adjustProgressBarStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
  IntRect RenderTheme::progressBarRectForBounds(const RenderObject&amp;, const IntRect&amp; bounds) const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1167,48 ***</span>
  bool RenderTheme::shouldHaveCapsLockIndicator(const HTMLInputElement&amp;) const
  {
      return false;
  }
  
<span class="line-modified">! void RenderTheme::adjustMenuListButtonStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustMediaControlStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSliderTrackStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSliderThumbStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element* element) const</span>
  {
      adjustSliderThumbSize(style, element);
  }
  
  void RenderTheme::adjustSliderThumbSize(RenderStyle&amp;, const Element*) const
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSearchFieldStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSearchFieldCancelButtonStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSearchFieldDecorationPartStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSearchFieldResultsDecorationPartStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSearchFieldResultsButtonStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
  {
  }
  
  void RenderTheme::purgeCaches()
  {
<span class="line-new-header">--- 1167,48 ---</span>
  bool RenderTheme::shouldHaveCapsLockIndicator(const HTMLInputElement&amp;) const
  {
      return false;
  }
  
<span class="line-modified">! void RenderTheme::adjustMenuListButtonStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustMediaControlStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSliderTrackStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSliderThumbStyle(RenderStyle&amp; style, const Element* element) const</span>
  {
      adjustSliderThumbSize(style, element);
  }
  
  void RenderTheme::adjustSliderThumbSize(RenderStyle&amp;, const Element*) const
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSearchFieldStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSearchFieldCancelButtonStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSearchFieldDecorationPartStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSearchFieldResultsDecorationPartStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
<span class="line-modified">! void RenderTheme::adjustSearchFieldResultsButtonStyle(RenderStyle&amp;, const Element*) const</span>
  {
  }
  
  void RenderTheme::purgeCaches()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1283,77 ***</span>
  
  Color RenderTheme::systemColor(CSSValueID cssValueId, OptionSet&lt;StyleColor::Options&gt; options) const
  {
      switch (cssValueId) {
      case CSSValueWebkitLink:
<span class="line-modified">!         return options.contains(StyleColor::Options::ForVisitedLink) ? 0xFF551A8B : 0xFF0000EE;</span>
      case CSSValueWebkitActivelink:
<span class="line-modified">!         return 0xFFFF0000;</span>
      case CSSValueActiveborder:
<span class="line-modified">!         return 0xFFFFFFFF;</span>
      case CSSValueActivebuttontext:
<span class="line-modified">!         return 0xFF000000;</span>
      case CSSValueActivecaption:
<span class="line-modified">!         return 0xFFCCCCCC;</span>
      case CSSValueAppworkspace:
<span class="line-modified">!         return 0xFFFFFFFF;</span>
      case CSSValueBackground:
<span class="line-modified">!         return 0xFF6363CE;</span>
      case CSSValueButtonface:
<span class="line-modified">!         return 0xFFC0C0C0;</span>
      case CSSValueButtonhighlight:
<span class="line-modified">!         return 0xFFDDDDDD;</span>
      case CSSValueButtonshadow:
<span class="line-modified">!         return 0xFF888888;</span>
      case CSSValueButtontext:
<span class="line-modified">!         return 0xFF000000;</span>
      case CSSValueCaptiontext:
<span class="line-modified">!         return 0xFF000000;</span>
      case CSSValueGraytext:
<span class="line-modified">!         return 0xFF808080;</span>
      case CSSValueHighlight:
<span class="line-modified">!         return 0xFFB5D5FF;</span>
      case CSSValueHighlighttext:
<span class="line-modified">!         return 0xFF000000;</span>
      case CSSValueInactiveborder:
<span class="line-modified">!         return 0xFFFFFFFF;</span>
      case CSSValueInactivecaption:
<span class="line-modified">!         return 0xFFFFFFFF;</span>
      case CSSValueInactivecaptiontext:
<span class="line-modified">!         return 0xFF7F7F7F;</span>
      case CSSValueInfobackground:
<span class="line-modified">!         return 0xFFFBFCC5;</span>
      case CSSValueInfotext:
<span class="line-modified">!         return 0xFF000000;</span>
      case CSSValueMenu:
<span class="line-modified">!         return 0xFFC0C0C0;</span>
      case CSSValueMenutext:
<span class="line-modified">!         return 0xFF000000;</span>
      case CSSValueScrollbar:
<span class="line-modified">!         return 0xFFFFFFFF;</span>
      case CSSValueText:
<span class="line-modified">!         return 0xFF000000;</span>
      case CSSValueThreeddarkshadow:
<span class="line-modified">!         return 0xFF666666;</span>
      case CSSValueThreedface:
<span class="line-modified">!         return 0xFFC0C0C0;</span>
      case CSSValueThreedhighlight:
<span class="line-modified">!         return 0xFFDDDDDD;</span>
      case CSSValueThreedlightshadow:
<span class="line-modified">!         return 0xFFC0C0C0;</span>
      case CSSValueThreedshadow:
<span class="line-modified">!         return 0xFF888888;</span>
      case CSSValueWindow:
<span class="line-modified">!         return 0xFFFFFFFF;</span>
      case CSSValueWindowframe:
<span class="line-modified">!         return 0xFFCCCCCC;</span>
      case CSSValueWindowtext:
<span class="line-modified">!         return 0xFF000000;</span>
      default:
<span class="line-modified">!         break;</span>
      }
<span class="line-removed">-     return Color();</span>
  }
  
  Color RenderTheme::activeTextSearchHighlightColor(OptionSet&lt;StyleColor::Options&gt; options) const
  {
      auto&amp; cache = colorCache(options);
<span class="line-new-header">--- 1283,76 ---</span>
  
  Color RenderTheme::systemColor(CSSValueID cssValueId, OptionSet&lt;StyleColor::Options&gt; options) const
  {
      switch (cssValueId) {
      case CSSValueWebkitLink:
<span class="line-modified">!         return options.contains(StyleColor::Options::ForVisitedLink) ? SimpleColor { 0xFF551A8B } : SimpleColor { 0xFF0000EE };</span>
      case CSSValueWebkitActivelink:
<span class="line-modified">!         return SimpleColor { 0xFFFF0000 };</span>
      case CSSValueActiveborder:
<span class="line-modified">!         return Color::white;</span>
      case CSSValueActivebuttontext:
<span class="line-modified">!         return Color::black;</span>
      case CSSValueActivecaption:
<span class="line-modified">!         return SimpleColor { 0xFFCCCCCC };</span>
      case CSSValueAppworkspace:
<span class="line-modified">!         return Color::white;</span>
      case CSSValueBackground:
<span class="line-modified">!         return SimpleColor { 0xFF6363CE };</span>
      case CSSValueButtonface:
<span class="line-modified">!         return Color::lightGray;</span>
      case CSSValueButtonhighlight:
<span class="line-modified">!         return SimpleColor { 0xFFDDDDDD };</span>
      case CSSValueButtonshadow:
<span class="line-modified">!         return SimpleColor { 0xFF888888 };</span>
      case CSSValueButtontext:
<span class="line-modified">!         return Color::black;</span>
      case CSSValueCaptiontext:
<span class="line-modified">!         return Color::black;</span>
      case CSSValueGraytext:
<span class="line-modified">!         return SimpleColor { 0xFF808080 };</span>
      case CSSValueHighlight:
<span class="line-modified">!         return SimpleColor { 0xFFB5D5FF };</span>
      case CSSValueHighlighttext:
<span class="line-modified">!         return Color::black;</span>
      case CSSValueInactiveborder:
<span class="line-modified">!         return Color::white;</span>
      case CSSValueInactivecaption:
<span class="line-modified">!         return Color::white;</span>
      case CSSValueInactivecaptiontext:
<span class="line-modified">!         return SimpleColor { 0xFF7F7F7F };</span>
      case CSSValueInfobackground:
<span class="line-modified">!         return SimpleColor { 0xFFFBFCC5 };</span>
      case CSSValueInfotext:
<span class="line-modified">!         return Color::black;</span>
      case CSSValueMenu:
<span class="line-modified">!         return Color::lightGray;</span>
      case CSSValueMenutext:
<span class="line-modified">!         return Color::black;</span>
      case CSSValueScrollbar:
<span class="line-modified">!         return Color::white;</span>
      case CSSValueText:
<span class="line-modified">!         return Color::black;</span>
      case CSSValueThreeddarkshadow:
<span class="line-modified">!         return SimpleColor { 0xFF666666 };</span>
      case CSSValueThreedface:
<span class="line-modified">!         return Color::lightGray;</span>
      case CSSValueThreedhighlight:
<span class="line-modified">!         return SimpleColor { 0xFFDDDDDD };</span>
      case CSSValueThreedlightshadow:
<span class="line-modified">!         return Color::lightGray;</span>
      case CSSValueThreedshadow:
<span class="line-modified">!         return SimpleColor { 0xFF888888 };</span>
      case CSSValueWindow:
<span class="line-modified">!         return Color::white;</span>
      case CSSValueWindowframe:
<span class="line-modified">!         return SimpleColor { 0xFFCCCCCC };</span>
      case CSSValueWindowtext:
<span class="line-modified">!         return Color::black;</span>
      default:
<span class="line-modified">!         return { };</span>
      }
  }
  
  Color RenderTheme::activeTextSearchHighlightColor(OptionSet&lt;StyleColor::Options&gt; options) const
  {
      auto&amp; cache = colorCache(options);
</pre>
<center><a href="RenderTextLineBoxes.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTheme.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Region.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlatformTimeRanges.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Region.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Region.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Region.h&quot;
 28 
 29 #include &lt;stdio.h&gt;
 30 #include &lt;wtf/text/TextStream.h&gt;
 31 
 32 // A region class based on the paper &quot;Scanline Coherent Shape Algebra&quot;
 33 // by Jonathan E. Steinhart from the book &quot;Graphics Gems II&quot;.
 34 //
 35 // This implementation uses two vectors instead of linked list, and
 36 // also compresses regions when possible.
 37 
 38 namespace WebCore {
 39 


 40 Region::Region()
 41 {
 42 }
 43 
 44 Region::Region(const IntRect&amp; rect)
 45     : m_bounds(rect)
 46 {
 47 }
 48 
 49 Region::Region(const Region&amp; other)
 50     : m_bounds(other.m_bounds)
 51     , m_shape(other.copyShape())
 52 {
 53 }
 54 
 55 Region::Region(Region&amp;&amp; other)
 56     : m_bounds(WTFMove(other.m_bounds))
 57     , m_shape(WTFMove(other.m_shape))
 58 {
 59 }
</pre>
<hr />
<pre>
232 
233         if (aMaxY &lt; bMaxY)
234             aSpan += 1;
235         else if (bMaxY &lt; aMaxY)
236             bSpan += 1;
237         else {
238             aSpan += 1;
239             bSpan += 1;
240         }
241     }
242 
243     if (aSpan != aSpanEnd &amp;&amp; aSpan + 1 != aSpanEnd &amp;&amp; CompareOperation::aOutsideB(result))
244         return result;
245     if (bSpan != bSpanEnd &amp;&amp; bSpan + 1 != bSpanEnd &amp;&amp; CompareOperation::bOutsideA(result))
246         return result;
247 
248     return result;
249 }
250 
251 struct Region::Shape::CompareContainsOperation {
<span class="line-modified">252     const static bool defaultResult = true;</span>
253     inline static bool aOutsideB(bool&amp; /* result */) { return false; }
254     inline static bool bOutsideA(bool&amp; result) { result = false; return true; }
255     inline static bool aOverlapsB(bool&amp; /* result */) { return false; }
256 };
257 
258 struct Region::Shape::CompareIntersectsOperation {
<span class="line-modified">259     const static bool defaultResult = false;</span>
260     inline static bool aOutsideB(bool&amp; /* result */) { return false; }
261     inline static bool bOutsideA(bool&amp; /* result */) { return false; }
262     inline static bool aOverlapsB(bool&amp; result) { result = true; return true; }
263 };
264 
265 Region::Shape::Shape(const IntRect&amp; rect)
266     : m_segments({ rect.x(), rect.maxX() })
267     , m_spans({ { rect.y(), 0 }, { rect.maxY(), 2 } })
268 {
269 }
270 
271 void Region::Shape::appendSpan(int y)
272 {
273     m_spans.append({ y, m_segments.size() });
274 }
275 
276 bool Region::Shape::canCoalesce(SegmentIterator begin, SegmentIterator end)
277 {
278     if (m_spans.isEmpty())
279         return false;
</pre>
</td>
<td>
<hr />
<pre>
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Region.h&quot;
 28 
 29 #include &lt;stdio.h&gt;
 30 #include &lt;wtf/text/TextStream.h&gt;
 31 
 32 // A region class based on the paper &quot;Scanline Coherent Shape Algebra&quot;
 33 // by Jonathan E. Steinhart from the book &quot;Graphics Gems II&quot;.
 34 //
 35 // This implementation uses two vectors instead of linked list, and
 36 // also compresses regions when possible.
 37 
 38 namespace WebCore {
 39 
<span class="line-added"> 40 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(Region);</span>
<span class="line-added"> 41 </span>
 42 Region::Region()
 43 {
 44 }
 45 
 46 Region::Region(const IntRect&amp; rect)
 47     : m_bounds(rect)
 48 {
 49 }
 50 
 51 Region::Region(const Region&amp; other)
 52     : m_bounds(other.m_bounds)
 53     , m_shape(other.copyShape())
 54 {
 55 }
 56 
 57 Region::Region(Region&amp;&amp; other)
 58     : m_bounds(WTFMove(other.m_bounds))
 59     , m_shape(WTFMove(other.m_shape))
 60 {
 61 }
</pre>
<hr />
<pre>
234 
235         if (aMaxY &lt; bMaxY)
236             aSpan += 1;
237         else if (bMaxY &lt; aMaxY)
238             bSpan += 1;
239         else {
240             aSpan += 1;
241             bSpan += 1;
242         }
243     }
244 
245     if (aSpan != aSpanEnd &amp;&amp; aSpan + 1 != aSpanEnd &amp;&amp; CompareOperation::aOutsideB(result))
246         return result;
247     if (bSpan != bSpanEnd &amp;&amp; bSpan + 1 != bSpanEnd &amp;&amp; CompareOperation::bOutsideA(result))
248         return result;
249 
250     return result;
251 }
252 
253 struct Region::Shape::CompareContainsOperation {
<span class="line-modified">254     static constexpr bool defaultResult = true;</span>
255     inline static bool aOutsideB(bool&amp; /* result */) { return false; }
256     inline static bool bOutsideA(bool&amp; result) { result = false; return true; }
257     inline static bool aOverlapsB(bool&amp; /* result */) { return false; }
258 };
259 
260 struct Region::Shape::CompareIntersectsOperation {
<span class="line-modified">261     static constexpr bool defaultResult = false;</span>
262     inline static bool aOutsideB(bool&amp; /* result */) { return false; }
263     inline static bool bOutsideA(bool&amp; /* result */) { return false; }
264     inline static bool aOverlapsB(bool&amp; result) { result = true; return true; }
265 };
266 
267 Region::Shape::Shape(const IntRect&amp; rect)
268     : m_segments({ rect.x(), rect.maxX() })
269     , m_spans({ { rect.y(), 0 }, { rect.maxY(), 2 } })
270 {
271 }
272 
273 void Region::Shape::appendSpan(int y)
274 {
275     m_spans.append({ y, m_segments.size() });
276 }
277 
278 bool Region::Shape::canCoalesce(SegmentIterator begin, SegmentIterator end)
279 {
280     if (m_spans.isEmpty())
281         return false;
</pre>
</td>
</tr>
</table>
<center><a href="PlatformTimeRanges.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Region.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
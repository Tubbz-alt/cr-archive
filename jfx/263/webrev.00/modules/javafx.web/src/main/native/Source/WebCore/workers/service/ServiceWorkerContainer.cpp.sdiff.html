<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServiceWorkerClient.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerContainer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerContainer.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 

 31 #include &quot;Document.h&quot;
 32 #include &quot;Event.h&quot;

 33 #include &quot;EventNames.h&quot;
 34 #include &quot;Exception.h&quot;
 35 #include &quot;IDLTypes.h&quot;
 36 #include &quot;JSDOMPromiseDeferred.h&quot;
 37 #include &quot;JSServiceWorkerRegistration.h&quot;

 38 #include &quot;Logging.h&quot;
 39 #include &quot;MessageEvent.h&quot;
 40 #include &quot;NavigatorBase.h&quot;

 41 #include &quot;ResourceError.h&quot;
<span class="line-removed"> 42 #include &quot;SchemeRegistry.h&quot;</span>
 43 #include &quot;ScriptExecutionContext.h&quot;
 44 #include &quot;SecurityOrigin.h&quot;
 45 #include &quot;ServiceWorker.h&quot;
 46 #include &quot;ServiceWorkerFetchResult.h&quot;
 47 #include &quot;ServiceWorkerGlobalScope.h&quot;
 48 #include &quot;ServiceWorkerJob.h&quot;
 49 #include &quot;ServiceWorkerJobData.h&quot;
 50 #include &quot;ServiceWorkerProvider.h&quot;
 51 #include &quot;ServiceWorkerThread.h&quot;

 52 #include &lt;wtf/IsoMallocInlines.h&gt;
 53 #include &lt;wtf/RunLoop.h&gt;
 54 #include &lt;wtf/Scope.h&gt;
 55 #include &lt;wtf/URL.h&gt;
 56 
 57 #define CONTAINER_RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerContainer::&quot; fmt, this, ##__VA_ARGS__)
 58 #define CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerContainer::&quot; fmt, this, ##__VA_ARGS__)
 59 
 60 namespace WebCore {
 61 





 62 WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerContainer);
 63 
 64 ServiceWorkerContainer::ServiceWorkerContainer(ScriptExecutionContext* context, NavigatorBase&amp; navigator)
 65     : ActiveDOMObject(context)
 66     , m_navigator(navigator)
 67 {
 68     suspendIfNeeded();




 69 }
 70 
 71 ServiceWorkerContainer::~ServiceWorkerContainer()
 72 {
 73 #ifndef NDEBUG
 74     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
 75 #endif
 76 }
 77 
 78 void ServiceWorkerContainer::refEventTarget()
 79 {
 80     m_navigator.ref();
 81 }
 82 
 83 void ServiceWorkerContainer::derefEventTarget()
 84 {
 85     m_navigator.deref();
 86 }
 87 
 88 auto ServiceWorkerContainer::ready() -&gt; ReadyPromise&amp;
 89 {
 90     if (!m_readyPromise) {
 91         m_readyPromise = makeUnique&lt;ReadyPromise&gt;();
 92 
<span class="line-modified"> 93         if (m_isStopped || !scriptExecutionContext()-&gt;sessionID().isValid())</span>
 94             return *m_readyPromise;
 95 
 96         auto&amp; context = *scriptExecutionContext();
<span class="line-modified"> 97         auto contextIdentifier = this-&gt;contextIdentifier();</span>
<span class="line-modified"> 98         callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context.topOrigin().isolatedCopy(), clientURL = context.url().isolatedCopy(), contextIdentifier]() mutable {</span>
<span class="line-modified"> 99             connection-&gt;whenRegistrationReady(topOrigin, clientURL, [contextIdentifier](auto&amp;&amp; registrationData) {</span>
<span class="line-modified">100                 ScriptExecutionContext::postTaskTo(contextIdentifier, [registrationData = crossThreadCopy(registrationData)](auto&amp; context) mutable {</span>
<span class="line-removed">101                     auto* serviceWorkerContainer = context.serviceWorkerContainer();</span>
<span class="line-removed">102                     if (!serviceWorkerContainer)</span>
<span class="line-removed">103                         return;</span>
<span class="line-removed">104                     if (serviceWorkerContainer-&gt;m_isStopped || !context.sessionID().isValid())</span>
<span class="line-removed">105                         return;</span>
<span class="line-removed">106 </span>
<span class="line-removed">107                     auto registration = ServiceWorkerRegistration::getOrCreate(context, *serviceWorkerContainer, WTFMove(registrationData));</span>
<span class="line-removed">108                     serviceWorkerContainer-&gt;m_readyPromise-&gt;resolve(WTFMove(registration));</span>
<span class="line-removed">109                 });</span>
110             });
111         });
112     }
113     return *m_readyPromise;
114 }
115 
116 ServiceWorker* ServiceWorkerContainer::controller() const
117 {
118     auto* context = scriptExecutionContext();
119     ASSERT_WITH_MESSAGE(!context || is&lt;Document&gt;(*context) || !context-&gt;activeServiceWorker(), &quot;Only documents can have a controller at the moment.&quot;);
120     return context ? context-&gt;activeServiceWorker() : nullptr;
121 }
122 
123 void ServiceWorkerContainer::addRegistration(const String&amp; relativeScriptURL, const RegistrationOptions&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
124 {
125     auto* context = scriptExecutionContext();
<span class="line-modified">126     if (m_isStopped || !context-&gt;sessionID().isValid()) {</span>
127         promise-&gt;reject(Exception(InvalidStateError));
128         return;
129     }
130 
131     if (relativeScriptURL.isEmpty()) {
132         promise-&gt;reject(Exception { TypeError, &quot;serviceWorker.register() cannot be called with an empty script URL&quot;_s });
133         return;
134     }
135 
136     ServiceWorkerJobData jobData(ensureSWClientConnection().serverConnectionIdentifier(), contextIdentifier());
137 
138     jobData.scriptURL = context-&gt;completeURL(relativeScriptURL);
139     if (!jobData.scriptURL.isValid()) {
140         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: Invalid scriptURL&quot;);
141         promise-&gt;reject(Exception { TypeError, &quot;serviceWorker.register() must be called with a valid relative script URL&quot;_s });
142         return;
143     }
144 
<span class="line-modified">145     if (!SchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scriptURL.protocol().toStringWithoutCopying())) {</span>
146         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: Invalid scriptURL scheme is not HTTP or HTTPS&quot;);
147         promise-&gt;reject(Exception { TypeError, &quot;serviceWorker.register() must be called with a script URL whose protocol is either HTTP or HTTPS&quot;_s });
148         return;
149     }
150 
151     String path = jobData.scriptURL.path();
152     if (path.containsIgnoringASCIICase(&quot;%2f&quot;) || path.containsIgnoringASCIICase(&quot;%5c&quot;)) {
153         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: scriptURL contains invalid character&quot;);
154         promise-&gt;reject(Exception { TypeError, &quot;serviceWorker.register() must be called with a script URL whose path does not contain &#39;%2f&#39; or &#39;%5c&#39;&quot;_s });
155         return;
156     }
157 
158     if (!options.scope.isEmpty())
159         jobData.scopeURL = context-&gt;completeURL(options.scope);
160     else
161         jobData.scopeURL = URL(jobData.scriptURL, &quot;./&quot;);
162 
<span class="line-modified">163     if (!jobData.scopeURL.isNull() &amp;&amp; !SchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scopeURL.protocol().toStringWithoutCopying())) {</span>
164         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: scopeURL scheme is not HTTP or HTTPS&quot;);
165         promise-&gt;reject(Exception { TypeError, &quot;Scope URL provided to serviceWorker.register() must be either HTTP or HTTPS&quot;_s });
166         return;
167     }
168 
169     path = jobData.scopeURL.path();
170     if (path.containsIgnoringASCIICase(&quot;%2f&quot;) || path.containsIgnoringASCIICase(&quot;%5c&quot;)) {
171         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: scopeURL contains invalid character&quot;);
172         promise-&gt;reject(Exception { TypeError, &quot;Scope URL provided to serviceWorker.register() cannot have a path that contains &#39;%2f&#39; or &#39;%5c&#39;&quot;_s });
173         return;
174     }
175 
176     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;addRegistration: Registering service worker. Job ID: %&quot; PRIu64, jobData.identifier().jobIdentifier.toUInt64());
177 
178     jobData.clientCreationURL = context-&gt;url();
179     jobData.topOrigin = context-&gt;topOrigin().data();
180     jobData.type = ServiceWorkerJobType::Register;
181     jobData.registrationOptions = options;
182 
183     scheduleJob(makeUnique&lt;ServiceWorkerJob&gt;(*this, WTFMove(promise), WTFMove(jobData)));
184 }
185 
186 void ServiceWorkerContainer::removeRegistration(const URL&amp; scopeURL, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
187 {
188     auto* context = scriptExecutionContext();
<span class="line-modified">189     if (!context || !context-&gt;sessionID().isValid()) {</span>
190         ASSERT_NOT_REACHED();
191         promise-&gt;reject(Exception(InvalidStateError));
192         return;
193     }
194 
195     if (!m_swConnection) {
196         ASSERT_NOT_REACHED();
197         promise-&gt;reject(Exception(InvalidStateError));
198         return;
199     }
200 
201     ServiceWorkerJobData jobData(m_swConnection-&gt;serverConnectionIdentifier(), contextIdentifier());
202     jobData.clientCreationURL = context-&gt;url();
203     jobData.topOrigin = context-&gt;topOrigin().data();
204     jobData.type = ServiceWorkerJobType::Unregister;
205     jobData.scopeURL = scopeURL;
206 
207     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;removeRegistration: Unregistering service worker. Job ID: %&quot; PRIu64, jobData.identifier().jobIdentifier.toUInt64());
208 
209     scheduleJob(makeUnique&lt;ServiceWorkerJob&gt;(*this, WTFMove(promise), WTFMove(jobData)));
210 }
211 
212 void ServiceWorkerContainer::updateRegistration(const URL&amp; scopeURL, const URL&amp; scriptURL, WorkerType, RefPtr&lt;DeferredPromise&gt;&amp;&amp; promise)
213 {
214     ASSERT(!m_isStopped);
215 
216     auto&amp; context = *scriptExecutionContext();
<span class="line-removed">217     ASSERT(context.sessionID().isValid());</span>
218 
219     if (!m_swConnection) {
220         ASSERT_NOT_REACHED();
221         if (promise)
222             promise-&gt;reject(Exception(InvalidStateError));
223         return;
224     }
225 
226     ServiceWorkerJobData jobData(m_swConnection-&gt;serverConnectionIdentifier(), contextIdentifier());
227     jobData.clientCreationURL = context.url();
228     jobData.topOrigin = context.topOrigin().data();
229     jobData.type = ServiceWorkerJobType::Update;
230     jobData.scopeURL = scopeURL;
231     jobData.scriptURL = scriptURL;
232 
233     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;removeRegistration: Updating service worker. Job ID: %&quot; PRIu64, jobData.identifier().jobIdentifier.toUInt64());
234 
235     scheduleJob(makeUnique&lt;ServiceWorkerJob&gt;(*this, WTFMove(promise), WTFMove(jobData)));
236 }
237 
238 void ServiceWorkerContainer::scheduleJob(std::unique_ptr&lt;ServiceWorkerJob&gt;&amp;&amp; job)
239 {
240 #ifndef NDEBUG
241     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
242 #endif
243 
244     ASSERT(m_swConnection);
245     ASSERT(!isStopped());
246 
247     auto&amp; jobData = job-&gt;data();
248     auto jobIdentifier = job-&gt;identifier();
249     ASSERT(!m_jobMap.contains(jobIdentifier));
250     m_jobMap.add(jobIdentifier, OngoingJob { WTFMove(job), makePendingActivity(*this) });
251 
<span class="line-modified">252     callOnMainThread([connection = m_swConnection, contextIdentifier = this-&gt;contextIdentifier(), jobData = jobData.isolatedCopy()] {</span>
<span class="line-removed">253         connection-&gt;scheduleJob(contextIdentifier, jobData);</span>
<span class="line-removed">254     });</span>
255 }
256 
257 void ServiceWorkerContainer::getRegistration(const String&amp; clientURL, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
258 {
<span class="line-modified">259     auto* context = scriptExecutionContext();</span>
<span class="line-removed">260     if (m_isStopped || !context-&gt;sessionID().isValid()) {</span>
261         promise-&gt;reject(Exception { InvalidStateError });
262         return;
263     }
264 
<span class="line-modified">265     URL parsedURL = context-&gt;completeURL(clientURL);</span>
<span class="line-modified">266     if (!protocolHostAndPortAreEqual(parsedURL, context-&gt;url())) {</span>

267         promise-&gt;reject(Exception { SecurityError, &quot;Origin of clientURL is not client&#39;s origin&quot;_s });
268         return;
269     }
270 
<span class="line-modified">271     uint64_t pendingPromiseIdentifier = ++m_lastPendingPromiseIdentifier;</span>
<span class="line-modified">272     auto pendingPromise = makeUnique&lt;PendingPromise&gt;(WTFMove(promise), makePendingActivity(*this));</span>
<span class="line-modified">273     m_pendingPromises.add(pendingPromiseIdentifier, WTFMove(pendingPromise));</span>
<span class="line-modified">274 </span>
<span class="line-modified">275     auto contextIdentifier = this-&gt;contextIdentifier();</span>
<span class="line-modified">276     callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context-&gt;topOrigin().data().isolatedCopy(), parsedURL = parsedURL.isolatedCopy(), contextIdentifier, pendingPromiseIdentifier]() mutable {</span>
<span class="line-modified">277         connection-&gt;matchRegistration(WTFMove(topOrigin), parsedURL, [contextIdentifier, pendingPromiseIdentifier] (auto&amp;&amp; result) mutable {</span>
<span class="line-removed">278             ScriptExecutionContext::postTaskTo(contextIdentifier, [pendingPromiseIdentifier, result = crossThreadCopy(result)](auto&amp; context) mutable {</span>
<span class="line-removed">279                 auto* serviceWorkerContainer = context.serviceWorkerContainer();</span>
<span class="line-removed">280                 if (!serviceWorkerContainer)</span>
<span class="line-removed">281                     return;</span>
<span class="line-removed">282                 if (serviceWorkerContainer-&gt;m_isStopped || !context.sessionID().isValid())</span>
<span class="line-removed">283                     return;</span>
<span class="line-removed">284 </span>
<span class="line-removed">285                 serviceWorkerContainer-&gt;didFinishGetRegistrationRequest(pendingPromiseIdentifier, WTFMove(result));</span>
<span class="line-removed">286             });</span>
287         });
288     });
289 }
290 
<span class="line-modified">291 void ServiceWorkerContainer::didFinishGetRegistrationRequest(uint64_t pendingPromiseIdentifier, Optional&lt;ServiceWorkerRegistrationData&gt;&amp;&amp; result)</span>
292 {
<span class="line-modified">293 #ifndef NDEBUG</span>
<span class="line-removed">294     ASSERT(m_creationThread.ptr() == &amp;Thread::current());</span>
<span class="line-removed">295 #endif</span>
<span class="line-removed">296 </span>
<span class="line-removed">297     auto pendingPromise = m_pendingPromises.take(pendingPromiseIdentifier);</span>
<span class="line-removed">298     if (!pendingPromise)</span>
<span class="line-removed">299         return;</span>
<span class="line-removed">300 </span>
<span class="line-removed">301     if (m_isStopped || !scriptExecutionContext()-&gt;sessionID().isValid()) {</span>
<span class="line-removed">302         pendingPromise-&gt;promise-&gt;reject(Exception { InvalidStateError });</span>
303         return;
<span class="line-removed">304     }</span>
305 
<span class="line-modified">306     if (!result) {</span>
<span class="line-modified">307         pendingPromise-&gt;promise-&gt;resolve();</span>
<span class="line-modified">308         return;</span>
<span class="line-modified">309     }</span>
310 
<span class="line-modified">311     auto registration = ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(result.value()));</span>
<span class="line-modified">312     pendingPromise-&gt;promise-&gt;resolve&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;(WTFMove(registration));</span>

313 }
314 
<span class="line-modified">315 void ServiceWorkerContainer::updateRegistrationState(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerRegistrationState state, const Optional&lt;ServiceWorkerData&gt;&amp; serviceWorkerData)</span>
316 {
317     if (m_isStopped)
318         return;
319 
<span class="line-modified">320     RefPtr&lt;ServiceWorker&gt; serviceWorker;</span>
<span class="line-modified">321     if (serviceWorkerData)</span>
<span class="line-modified">322         serviceWorker = ServiceWorker::getOrCreate(*scriptExecutionContext(), ServiceWorkerData { *serviceWorkerData });</span>
<span class="line-modified">323 </span>
<span class="line-removed">324     if (auto* registration = m_registrations.get(identifier))</span>
<span class="line-removed">325         registration-&gt;updateStateFromServer(state, WTFMove(serviceWorker));</span>
326 }
327 
328 void ServiceWorkerContainer::getRegistrations(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
329 {
<span class="line-modified">330     auto* context = scriptExecutionContext();</span>
<span class="line-removed">331     if (m_isStopped || !context-&gt;sessionID().isValid()) {</span>
332         promise-&gt;reject(Exception { InvalidStateError });
333         return;
334     }
335 
<span class="line-modified">336     uint64_t pendingPromiseIdentifier = ++m_lastPendingPromiseIdentifier;</span>
<span class="line-modified">337     auto pendingPromise = makeUnique&lt;PendingPromise&gt;(WTFMove(promise), makePendingActivity(*this));</span>
<span class="line-modified">338     m_pendingPromises.add(pendingPromiseIdentifier, WTFMove(pendingPromise));</span>
<span class="line-modified">339 </span>
<span class="line-modified">340     auto contextIdentifier = this-&gt;contextIdentifier();</span>
<span class="line-removed">341     auto contextURL = context-&gt;url();</span>
<span class="line-removed">342     callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context-&gt;topOrigin().data().isolatedCopy(), contextURL = contextURL.isolatedCopy(), contextIdentifier, pendingPromiseIdentifier]() mutable {</span>
<span class="line-removed">343         connection-&gt;getRegistrations(WTFMove(topOrigin), contextURL, [contextIdentifier, pendingPromiseIdentifier] (auto&amp;&amp; registrationDatas) mutable {</span>
<span class="line-removed">344             ScriptExecutionContext::postTaskTo(contextIdentifier, [pendingPromiseIdentifier, registrationDatas = crossThreadCopy(registrationDatas)](auto&amp; context) mutable {</span>
<span class="line-removed">345                 auto* serviceWorkerContainer = context.serviceWorkerContainer();</span>
<span class="line-removed">346                 if (!serviceWorkerContainer)</span>
<span class="line-removed">347                     return;</span>
<span class="line-removed">348                 if (serviceWorkerContainer-&gt;m_isStopped || !context.sessionID().isValid())</span>
<span class="line-removed">349                     return;</span>
<span class="line-removed">350 </span>
<span class="line-removed">351                 serviceWorkerContainer-&gt;didFinishGetRegistrationsRequest(pendingPromiseIdentifier, WTFMove(registrationDatas));</span>
352             });

353         });
354     });
355 }
356 
<span class="line-removed">357 void ServiceWorkerContainer::didFinishGetRegistrationsRequest(uint64_t pendingPromiseIdentifier, Vector&lt;ServiceWorkerRegistrationData&gt;&amp;&amp; registrationDatas)</span>
<span class="line-removed">358 {</span>
<span class="line-removed">359 #ifndef NDEBUG</span>
<span class="line-removed">360     ASSERT(m_creationThread.ptr() == &amp;Thread::current());</span>
<span class="line-removed">361 #endif</span>
<span class="line-removed">362 </span>
<span class="line-removed">363     auto pendingPromise = m_pendingPromises.take(pendingPromiseIdentifier);</span>
<span class="line-removed">364     if (!pendingPromise)</span>
<span class="line-removed">365         return;</span>
<span class="line-removed">366 </span>
<span class="line-removed">367     if (m_isStopped || !scriptExecutionContext()-&gt;sessionID().isValid()) {</span>
<span class="line-removed">368         pendingPromise-&gt;promise-&gt;reject(Exception { InvalidStateError });</span>
<span class="line-removed">369         return;</span>
<span class="line-removed">370     }</span>
<span class="line-removed">371 </span>
<span class="line-removed">372     auto registrations = WTF::map(WTFMove(registrationDatas), [&amp;] (auto&amp;&amp; registrationData) {</span>
<span class="line-removed">373         return ServiceWorkerRegistration::getOrCreate(*this-&gt;scriptExecutionContext(), *this, WTFMove(registrationData));</span>
<span class="line-removed">374     });</span>
<span class="line-removed">375 </span>
<span class="line-removed">376     pendingPromise-&gt;promise-&gt;resolve&lt;IDLSequence&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;&gt;(WTFMove(registrations));</span>
<span class="line-removed">377 }</span>
<span class="line-removed">378 </span>
379 void ServiceWorkerContainer::startMessages()
380 {




381 }
382 
383 void ServiceWorkerContainer::jobFailedWithException(ServiceWorkerJob&amp; job, const Exception&amp; exception)
384 {
385 #ifndef NDEBUG
386     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
387 #endif
388 
389     ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, &quot;Only soft updates have no promise&quot;);
390 
391     auto guard = WTF::makeScopeExit([this, &amp;job] {
392         destroyJob(job);
393     });
394 
395     CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;jobFailedWithException: Job %&quot; PRIu64 &quot; failed with error %s&quot;, job.identifier().toUInt64(), exception.message().utf8().data());
396 
397     auto promise = job.takePromise();
398     if (!promise)
399         return;
400 
<span class="line-modified">401     if (auto* context = scriptExecutionContext()) {</span>
<span class="line-modified">402         context-&gt;postTask([promise = WTFMove(promise), exception](auto&amp;) mutable {</span>
<span class="line-modified">403             promise-&gt;reject(exception);</span>
<span class="line-removed">404         });</span>
<span class="line-removed">405     }</span>
406 }
407 
<span class="line-modified">408 void ServiceWorkerContainer::fireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier identifier)</span>
409 {
410 #ifndef NDEBUG
411     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
412 #endif
413 
414     if (auto* registration = m_registrations.get(identifier))
<span class="line-modified">415         registration-&gt;fireUpdateFoundEvent();</span>
416 }
417 
418 void ServiceWorkerContainer::jobResolvedWithRegistration(ServiceWorkerJob&amp; job, ServiceWorkerRegistrationData&amp;&amp; data, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
419 {
420 #ifndef NDEBUG
421     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
422 #endif
423     ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, &quot;Only soft updates have no promise&quot;);
424 
425     if (job.data().type == ServiceWorkerJobType::Register)
426         CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Registration job %&quot; PRIu64 &quot; succeeded&quot;, job.identifier().toUInt64());
427     else {
428         ASSERT(job.data().type == ServiceWorkerJobType::Update);
429         CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Update job %&quot; PRIu64 &quot; succeeded&quot;, job.identifier().toUInt64());
430     }
431 
432     auto guard = WTF::makeScopeExit([this, &amp;job] {
433         destroyJob(job);
434     });
435 
<span class="line-modified">436     auto notifyIfExitEarly = WTF::makeScopeExit([this, &amp;data, &amp;shouldNotifyWhenResolved] {</span>
437         if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)
<span class="line-modified">438             notifyRegistrationIsSettled(data.key);</span>
439     });
440 
441     if (isStopped())
442         return;
443 
444     auto promise = job.takePromise();
445     if (!promise)
446         return;
447 
<span class="line-modified">448     notifyIfExitEarly.release();</span>

449 
<span class="line-modified">450     scriptExecutionContext()-&gt;postTask([this, protectedThis = RefPtr&lt;ServiceWorkerContainer&gt;(this), promise = WTFMove(promise), jobIdentifier = job.identifier(), data = WTFMove(data), shouldNotifyWhenResolved](ScriptExecutionContext&amp; context) mutable {</span>
<span class="line-removed">451         if (isStopped() || !context.sessionID().isValid()) {</span>
<span class="line-removed">452             if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)</span>
<span class="line-removed">453                 notifyRegistrationIsSettled(data.key);</span>
<span class="line-removed">454             return;</span>
<span class="line-removed">455         }</span>
<span class="line-removed">456 </span>
<span class="line-removed">457         auto registration = ServiceWorkerRegistration::getOrCreate(context, *this, WTFMove(data));</span>
458 
459         CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Resolving promise for job %&quot; PRIu64 &quot;. Registration ID: %&quot; PRIu64, jobIdentifier.toUInt64(), registration-&gt;identifier().toUInt64());
460 
461         if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes) {
462             m_ongoingSettledRegistrations.add(++m_lastOngoingSettledRegistrationIdentifier, registration-&gt;data().key);
463             promise-&gt;whenSettled([this, protectedThis = WTFMove(protectedThis), identifier = m_lastOngoingSettledRegistrationIdentifier] {
<span class="line-modified">464                 notifyRegistrationIsSettled(m_ongoingSettledRegistrations.take(identifier));</span>




465             });
466         }
467 
468         promise-&gt;resolve&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;(WTFMove(registration));
469     });
470 }
471 
472 void ServiceWorkerContainer::postMessage(MessageWithMessagePorts&amp;&amp; message, ServiceWorkerData&amp;&amp; sourceData, String&amp;&amp; sourceOrigin)
473 {
474     auto&amp; context = *scriptExecutionContext();
475     MessageEventSource source = RefPtr&lt;ServiceWorker&gt; { ServiceWorker::getOrCreate(context, WTFMove(sourceData)) };
476 
477     auto messageEvent = MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(message.transferredPorts)), message.message.releaseNonNull(), sourceOrigin, { }, WTFMove(source));
<span class="line-modified">478     dispatchEvent(messageEvent);</span>





479 }
480 
481 void ServiceWorkerContainer::notifyRegistrationIsSettled(const ServiceWorkerRegistrationKey&amp; registrationKey)
482 {
<span class="line-modified">483     callOnMainThread([connection = m_swConnection, registrationKey = registrationKey.isolatedCopy()] {</span>
<span class="line-removed">484         connection-&gt;didResolveRegistrationPromise(registrationKey);</span>
<span class="line-removed">485     });</span>
486 }
487 
488 void ServiceWorkerContainer::jobResolvedWithUnregistrationResult(ServiceWorkerJob&amp; job, bool unregistrationResult)
489 {
490 #ifndef NDEBUG
491     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
492 #endif
493 
494     ASSERT(job.hasPromise());
495 
496     auto guard = WTF::makeScopeExit([this, &amp;job] {
497         destroyJob(job);
498     });
499 
500     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithUnregistrationResult: Unregister job %&quot; PRIu64 &quot; finished. Success? %d&quot;, job.identifier().toUInt64(), unregistrationResult);
501 
502     auto* context = scriptExecutionContext();
503     if (!context) {
504         LOG_ERROR(&quot;ServiceWorkerContainer::jobResolvedWithUnregistrationResult called but the containers ScriptExecutionContext is gone&quot;);
505         return;
506     }
507 
<span class="line-modified">508     context-&gt;postTask([promise = job.takePromise(), unregistrationResult](auto&amp;) mutable {</span>
509         promise-&gt;resolve&lt;IDLBoolean&gt;(unregistrationResult);
510     });
511 }
512 
513 void ServiceWorkerContainer::startScriptFetchForJob(ServiceWorkerJob&amp; job, FetchOptions::Cache cachePolicy)
514 {
515 #ifndef NDEBUG
516     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
517 #endif
518 
519     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;startScriptFetchForJob: Starting script fetch for job %&quot; PRIu64, job.identifier().toUInt64());
520 
521     auto* context = scriptExecutionContext();
522     if (!context) {
523         LOG_ERROR(&quot;ServiceWorkerContainer::jobResolvedWithRegistration called but the container&#39;s ScriptExecutionContext is gone&quot;);
524         notifyFailedFetchingScript(job, { errorDomainWebKitInternal, 0, job.data().scriptURL, &quot;Attempt to fetch service worker script with no ScriptExecutionContext&quot;_s });
525         destroyJob(job);
526         return;
527     }
528 
529     job.fetchScriptWithContext(*context, cachePolicy);
530 }
531 
532 void ServiceWorkerContainer::jobFinishedLoadingScript(ServiceWorkerJob&amp; job, const String&amp; script, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, const String&amp; referrerPolicy)
533 {
534 #ifndef NDEBUG
535     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
536 #endif
537 
538     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobFinishedLoadingScript: Successfuly finished fetching script for job %&quot; PRIu64, job.identifier().toUInt64());
539 
<span class="line-modified">540     callOnMainThread([connection = m_swConnection, jobDataIdentifier = job.data().identifier(), registrationKey = job.data().registrationKey().isolatedCopy(), script = script.isolatedCopy(), contentSecurityPolicy = contentSecurityPolicy.isolatedCopy(), referrerPolicy = referrerPolicy.isolatedCopy()] {</span>
<span class="line-removed">541         connection-&gt;finishFetchingScriptInServer({ jobDataIdentifier, registrationKey, script, contentSecurityPolicy, referrerPolicy, { } });</span>
<span class="line-removed">542     });</span>
543 }
544 
545 void ServiceWorkerContainer::jobFailedLoadingScript(ServiceWorkerJob&amp; job, const ResourceError&amp; error, Exception&amp;&amp; exception)
546 {
547 #ifndef NDEBUG
548     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
549 #endif
550     ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, &quot;Only soft updates have no promise&quot;);
551 
552     CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;jobFinishedLoadingScript: Failed to fetch script for job %&quot; PRIu64 &quot;, error: %s&quot;, job.identifier().toUInt64(), error.localizedDescription().utf8().data());
553 
<span class="line-modified">554     if (auto promise = job.takePromise())</span>
<span class="line-modified">555         promise-&gt;reject(WTFMove(exception));</span>



556 
557     notifyFailedFetchingScript(job, error);
558     destroyJob(job);
559 }
560 
561 void ServiceWorkerContainer::notifyFailedFetchingScript(ServiceWorkerJob&amp; job, const ResourceError&amp; error)
562 {
<span class="line-modified">563     callOnMainThread([connection = m_swConnection, jobIdentifier = job.identifier(), registrationKey = job.data().registrationKey().isolatedCopy(), error = error.isolatedCopy()] {</span>
<span class="line-removed">564         connection-&gt;failedFetchingScript(jobIdentifier, registrationKey, error);</span>
<span class="line-removed">565     });</span>
566 }
567 
568 void ServiceWorkerContainer::destroyJob(ServiceWorkerJob&amp; job)
569 {
570 #ifndef NDEBUG
571     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
572 #endif
573 
574     ASSERT(m_jobMap.contains(job.identifier()));
575     m_jobMap.remove(job.identifier());
576 }
577 
578 const char* ServiceWorkerContainer::activeDOMObjectName() const
579 {
580     return &quot;ServiceWorkerContainer&quot;;
581 }
582 
<span class="line-removed">583 bool ServiceWorkerContainer::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">584 {</span>
<span class="line-removed">585     return !hasPendingActivity();</span>
<span class="line-removed">586 }</span>
<span class="line-removed">587 </span>
588 SWClientConnection&amp; ServiceWorkerContainer::ensureSWClientConnection()
589 {
590     ASSERT(scriptExecutionContext());
<span class="line-removed">591     ASSERT(scriptExecutionContext()-&gt;sessionID().isValid());</span>
592     if (!m_swConnection) {
<span class="line-modified">593         ASSERT(scriptExecutionContext());</span>
<span class="line-modified">594         callOnMainThreadAndWait([this, sessionID = scriptExecutionContext()-&gt;sessionID()]() {</span>
<span class="line-modified">595             m_swConnection = &amp;ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID);</span>
<span class="line-modified">596         });</span>

597     }
598     return *m_swConnection;
599 }
600 
601 void ServiceWorkerContainer::addRegistration(ServiceWorkerRegistration&amp; registration)
602 {
603 #ifndef NDEBUG
604     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
605 #endif
606 
607     ensureSWClientConnection().addServiceWorkerRegistrationInServer(registration.identifier());
608     m_registrations.add(registration.identifier(), &amp;registration);
609 }
610 
611 void ServiceWorkerContainer::removeRegistration(ServiceWorkerRegistration&amp; registration)
612 {
613 #ifndef NDEBUG
614     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
615 #endif
616 
617     m_swConnection-&gt;removeServiceWorkerRegistrationInServer(registration.identifier());
618     m_registrations.remove(registration.identifier());
619 }
620 
<span class="line-modified">621 void ServiceWorkerContainer::fireControllerChangeEvent()</span>
622 {
623 #ifndef NDEBUG
624     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
625 #endif
626 
<span class="line-modified">627     if (m_isStopped)</span>
<span class="line-removed">628         return;</span>
<span class="line-removed">629 </span>
<span class="line-removed">630     dispatchEvent(Event::create(eventNames().controllerchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
631 }
632 
633 void ServiceWorkerContainer::stop()
634 {
635     m_isStopped = true;
636     removeAllEventListeners();
<span class="line-removed">637     m_pendingPromises.clear();</span>
638     m_readyPromise = nullptr;
639     auto jobMap = WTFMove(m_jobMap);
640     for (auto&amp; ongoingJob : jobMap.values()) {
641         if (ongoingJob.job-&gt;cancelPendingLoad())
642             notifyFailedFetchingScript(*ongoingJob.job.get(), ResourceError { errorDomainWebKitInternal, 0, ongoingJob.job-&gt;data().scriptURL, &quot;Job cancelled&quot;_s, ResourceError::Type::Cancellation });
643     }
644 
645     auto registrationMap = WTFMove(m_ongoingSettledRegistrations);
646     for (auto&amp; registration : registrationMap.values())
647         notifyRegistrationIsSettled(registration);
648 }
649 
650 DocumentOrWorkerIdentifier ServiceWorkerContainer::contextIdentifier()
651 {
652 #ifndef NDEBUG
653     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
654 #endif
655 
656     ASSERT(scriptExecutionContext());
657     if (is&lt;ServiceWorkerGlobalScope&gt;(*scriptExecutionContext()))
658         return downcast&lt;ServiceWorkerGlobalScope&gt;(*scriptExecutionContext()).thread().identifier();
659     return downcast&lt;Document&gt;(*scriptExecutionContext()).identifier();
660 }
661 
662 ServiceWorkerJob* ServiceWorkerContainer::job(ServiceWorkerJobIdentifier identifier)
663 {
664     auto iterator = m_jobMap.find(identifier);
665     if (iterator == m_jobMap.end())
666         return nullptr;
667     return iterator-&gt;value.job.get();
668 }
669 
670 bool ServiceWorkerContainer::isAlwaysOnLoggingAllowed() const
671 {
672     auto* context = scriptExecutionContext();
673     if (!context)
674         return false;
675 
<span class="line-modified">676     if (is&lt;Document&gt;(*context))</span>
<span class="line-modified">677         return downcast&lt;Document&gt;(*context).sessionID().isAlwaysOnLoggingAllowed();</span>


678 
679     // FIXME: No logging inside service workers for now.
680     return false;
681 }
682 










683 } // namespace WebCore
684 
685 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerContainer.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
<span class="line-added"> 31 #include &quot;DOMPromiseProxy.h&quot;</span>
 32 #include &quot;Document.h&quot;
 33 #include &quot;Event.h&quot;
<span class="line-added"> 34 #include &quot;EventLoop.h&quot;</span>
 35 #include &quot;EventNames.h&quot;
 36 #include &quot;Exception.h&quot;
 37 #include &quot;IDLTypes.h&quot;
 38 #include &quot;JSDOMPromiseDeferred.h&quot;
 39 #include &quot;JSServiceWorkerRegistration.h&quot;
<span class="line-added"> 40 #include &quot;LegacySchemeRegistry.h&quot;</span>
 41 #include &quot;Logging.h&quot;
 42 #include &quot;MessageEvent.h&quot;
 43 #include &quot;NavigatorBase.h&quot;
<span class="line-added"> 44 #include &quot;Page.h&quot;</span>
 45 #include &quot;ResourceError.h&quot;

 46 #include &quot;ScriptExecutionContext.h&quot;
 47 #include &quot;SecurityOrigin.h&quot;
 48 #include &quot;ServiceWorker.h&quot;
 49 #include &quot;ServiceWorkerFetchResult.h&quot;
 50 #include &quot;ServiceWorkerGlobalScope.h&quot;
 51 #include &quot;ServiceWorkerJob.h&quot;
 52 #include &quot;ServiceWorkerJobData.h&quot;
 53 #include &quot;ServiceWorkerProvider.h&quot;
 54 #include &quot;ServiceWorkerThread.h&quot;
<span class="line-added"> 55 #include &quot;WorkerSWClientConnection.h&quot;</span>
 56 #include &lt;wtf/IsoMallocInlines.h&gt;
 57 #include &lt;wtf/RunLoop.h&gt;
 58 #include &lt;wtf/Scope.h&gt;
 59 #include &lt;wtf/URL.h&gt;
 60 
 61 #define CONTAINER_RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerContainer::&quot; fmt, this, ##__VA_ARGS__)
 62 #define CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerContainer::&quot; fmt, this, ##__VA_ARGS__)
 63 
 64 namespace WebCore {
 65 
<span class="line-added"> 66 static inline SWClientConnection&amp; mainThreadConnection()</span>
<span class="line-added"> 67 {</span>
<span class="line-added"> 68     return ServiceWorkerProvider::singleton().serviceWorkerConnection();</span>
<span class="line-added"> 69 }</span>
<span class="line-added"> 70 </span>
 71 WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerContainer);
 72 
 73 ServiceWorkerContainer::ServiceWorkerContainer(ScriptExecutionContext* context, NavigatorBase&amp; navigator)
 74     : ActiveDOMObject(context)
 75     , m_navigator(navigator)
 76 {
 77     suspendIfNeeded();
<span class="line-added"> 78 </span>
<span class="line-added"> 79     // We should queue messages until the DOMContentLoaded event has fired or startMessages() has been called.</span>
<span class="line-added"> 80     if (is&lt;Document&gt;(context) &amp;&amp; downcast&lt;Document&gt;(*context).parsing())</span>
<span class="line-added"> 81         m_shouldDeferMessageEvents = true;</span>
 82 }
 83 
 84 ServiceWorkerContainer::~ServiceWorkerContainer()
 85 {
 86 #ifndef NDEBUG
 87     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
 88 #endif
 89 }
 90 
 91 void ServiceWorkerContainer::refEventTarget()
 92 {
 93     m_navigator.ref();
 94 }
 95 
 96 void ServiceWorkerContainer::derefEventTarget()
 97 {
 98     m_navigator.deref();
 99 }
100 
101 auto ServiceWorkerContainer::ready() -&gt; ReadyPromise&amp;
102 {
103     if (!m_readyPromise) {
104         m_readyPromise = makeUnique&lt;ReadyPromise&gt;();
105 
<span class="line-modified">106         if (m_isStopped)</span>
107             return *m_readyPromise;
108 
109         auto&amp; context = *scriptExecutionContext();
<span class="line-modified">110         ensureSWClientConnection().whenRegistrationReady(context.topOrigin().data(), context.url(), [this, protectedThis = makeRef(*this)](auto&amp;&amp; registrationData) mutable {</span>
<span class="line-modified">111             queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, registrationData = WTFMove(registrationData)]() mutable {</span>
<span class="line-modified">112                 auto registration = ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(registrationData));</span>
<span class="line-modified">113                 m_readyPromise-&gt;resolve(WTFMove(registration));</span>









114             });
115         });
116     }
117     return *m_readyPromise;
118 }
119 
120 ServiceWorker* ServiceWorkerContainer::controller() const
121 {
122     auto* context = scriptExecutionContext();
123     ASSERT_WITH_MESSAGE(!context || is&lt;Document&gt;(*context) || !context-&gt;activeServiceWorker(), &quot;Only documents can have a controller at the moment.&quot;);
124     return context ? context-&gt;activeServiceWorker() : nullptr;
125 }
126 
127 void ServiceWorkerContainer::addRegistration(const String&amp; relativeScriptURL, const RegistrationOptions&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
128 {
129     auto* context = scriptExecutionContext();
<span class="line-modified">130     if (m_isStopped) {</span>
131         promise-&gt;reject(Exception(InvalidStateError));
132         return;
133     }
134 
135     if (relativeScriptURL.isEmpty()) {
136         promise-&gt;reject(Exception { TypeError, &quot;serviceWorker.register() cannot be called with an empty script URL&quot;_s });
137         return;
138     }
139 
140     ServiceWorkerJobData jobData(ensureSWClientConnection().serverConnectionIdentifier(), contextIdentifier());
141 
142     jobData.scriptURL = context-&gt;completeURL(relativeScriptURL);
143     if (!jobData.scriptURL.isValid()) {
144         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: Invalid scriptURL&quot;);
145         promise-&gt;reject(Exception { TypeError, &quot;serviceWorker.register() must be called with a valid relative script URL&quot;_s });
146         return;
147     }
148 
<span class="line-modified">149     if (!LegacySchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scriptURL.protocol().toStringWithoutCopying())) {</span>
150         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: Invalid scriptURL scheme is not HTTP or HTTPS&quot;);
151         promise-&gt;reject(Exception { TypeError, &quot;serviceWorker.register() must be called with a script URL whose protocol is either HTTP or HTTPS&quot;_s });
152         return;
153     }
154 
155     String path = jobData.scriptURL.path();
156     if (path.containsIgnoringASCIICase(&quot;%2f&quot;) || path.containsIgnoringASCIICase(&quot;%5c&quot;)) {
157         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: scriptURL contains invalid character&quot;);
158         promise-&gt;reject(Exception { TypeError, &quot;serviceWorker.register() must be called with a script URL whose path does not contain &#39;%2f&#39; or &#39;%5c&#39;&quot;_s });
159         return;
160     }
161 
162     if (!options.scope.isEmpty())
163         jobData.scopeURL = context-&gt;completeURL(options.scope);
164     else
165         jobData.scopeURL = URL(jobData.scriptURL, &quot;./&quot;);
166 
<span class="line-modified">167     if (!jobData.scopeURL.isNull() &amp;&amp; !LegacySchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scopeURL.protocol().toStringWithoutCopying())) {</span>
168         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: scopeURL scheme is not HTTP or HTTPS&quot;);
169         promise-&gt;reject(Exception { TypeError, &quot;Scope URL provided to serviceWorker.register() must be either HTTP or HTTPS&quot;_s });
170         return;
171     }
172 
173     path = jobData.scopeURL.path();
174     if (path.containsIgnoringASCIICase(&quot;%2f&quot;) || path.containsIgnoringASCIICase(&quot;%5c&quot;)) {
175         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: scopeURL contains invalid character&quot;);
176         promise-&gt;reject(Exception { TypeError, &quot;Scope URL provided to serviceWorker.register() cannot have a path that contains &#39;%2f&#39; or &#39;%5c&#39;&quot;_s });
177         return;
178     }
179 
180     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;addRegistration: Registering service worker. Job ID: %&quot; PRIu64, jobData.identifier().jobIdentifier.toUInt64());
181 
182     jobData.clientCreationURL = context-&gt;url();
183     jobData.topOrigin = context-&gt;topOrigin().data();
184     jobData.type = ServiceWorkerJobType::Register;
185     jobData.registrationOptions = options;
186 
187     scheduleJob(makeUnique&lt;ServiceWorkerJob&gt;(*this, WTFMove(promise), WTFMove(jobData)));
188 }
189 
190 void ServiceWorkerContainer::removeRegistration(const URL&amp; scopeURL, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
191 {
192     auto* context = scriptExecutionContext();
<span class="line-modified">193     if (!context) {</span>
194         ASSERT_NOT_REACHED();
195         promise-&gt;reject(Exception(InvalidStateError));
196         return;
197     }
198 
199     if (!m_swConnection) {
200         ASSERT_NOT_REACHED();
201         promise-&gt;reject(Exception(InvalidStateError));
202         return;
203     }
204 
205     ServiceWorkerJobData jobData(m_swConnection-&gt;serverConnectionIdentifier(), contextIdentifier());
206     jobData.clientCreationURL = context-&gt;url();
207     jobData.topOrigin = context-&gt;topOrigin().data();
208     jobData.type = ServiceWorkerJobType::Unregister;
209     jobData.scopeURL = scopeURL;
210 
211     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;removeRegistration: Unregistering service worker. Job ID: %&quot; PRIu64, jobData.identifier().jobIdentifier.toUInt64());
212 
213     scheduleJob(makeUnique&lt;ServiceWorkerJob&gt;(*this, WTFMove(promise), WTFMove(jobData)));
214 }
215 
216 void ServiceWorkerContainer::updateRegistration(const URL&amp; scopeURL, const URL&amp; scriptURL, WorkerType, RefPtr&lt;DeferredPromise&gt;&amp;&amp; promise)
217 {
218     ASSERT(!m_isStopped);
219 
220     auto&amp; context = *scriptExecutionContext();

221 
222     if (!m_swConnection) {
223         ASSERT_NOT_REACHED();
224         if (promise)
225             promise-&gt;reject(Exception(InvalidStateError));
226         return;
227     }
228 
229     ServiceWorkerJobData jobData(m_swConnection-&gt;serverConnectionIdentifier(), contextIdentifier());
230     jobData.clientCreationURL = context.url();
231     jobData.topOrigin = context.topOrigin().data();
232     jobData.type = ServiceWorkerJobType::Update;
233     jobData.scopeURL = scopeURL;
234     jobData.scriptURL = scriptURL;
235 
236     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;removeRegistration: Updating service worker. Job ID: %&quot; PRIu64, jobData.identifier().jobIdentifier.toUInt64());
237 
238     scheduleJob(makeUnique&lt;ServiceWorkerJob&gt;(*this, WTFMove(promise), WTFMove(jobData)));
239 }
240 
241 void ServiceWorkerContainer::scheduleJob(std::unique_ptr&lt;ServiceWorkerJob&gt;&amp;&amp; job)
242 {
243 #ifndef NDEBUG
244     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
245 #endif
246 
247     ASSERT(m_swConnection);
248     ASSERT(!isStopped());
249 
250     auto&amp; jobData = job-&gt;data();
251     auto jobIdentifier = job-&gt;identifier();
252     ASSERT(!m_jobMap.contains(jobIdentifier));
253     m_jobMap.add(jobIdentifier, OngoingJob { WTFMove(job), makePendingActivity(*this) });
254 
<span class="line-modified">255     m_swConnection-&gt;scheduleJob(contextIdentifier(), jobData);</span>


256 }
257 
258 void ServiceWorkerContainer::getRegistration(const String&amp; clientURL, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
259 {
<span class="line-modified">260     if (m_isStopped) {</span>

261         promise-&gt;reject(Exception { InvalidStateError });
262         return;
263     }
264 
<span class="line-modified">265     auto&amp; context = *scriptExecutionContext();</span>
<span class="line-modified">266     URL parsedURL = context.completeURL(clientURL);</span>
<span class="line-added">267     if (!protocolHostAndPortAreEqual(parsedURL, context.url())) {</span>
268         promise-&gt;reject(Exception { SecurityError, &quot;Origin of clientURL is not client&#39;s origin&quot;_s });
269         return;
270     }
271 
<span class="line-modified">272     ensureSWClientConnection().matchRegistration(SecurityOriginData { context.topOrigin().data() }, parsedURL, [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](auto&amp;&amp; result) mutable {</span>
<span class="line-modified">273         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, promise = WTFMove(promise), result = WTFMove(result)]() mutable {</span>
<span class="line-modified">274             if (!result) {</span>
<span class="line-modified">275                 promise-&gt;resolve();</span>
<span class="line-modified">276                 return;</span>
<span class="line-modified">277             }</span>
<span class="line-modified">278             promise-&gt;resolve&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;(ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(result.value())));</span>









279         });
280     });
281 }
282 
<span class="line-modified">283 void ServiceWorkerContainer::updateRegistrationState(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerRegistrationState state, const Optional&lt;ServiceWorkerData&gt;&amp; serviceWorkerData)</span>
284 {
<span class="line-modified">285     if (m_isStopped)</span>









286         return;

287 
<span class="line-modified">288     queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, identifier, state, serviceWorkerData = Optional&lt;ServiceWorkerData&gt; { serviceWorkerData }]() mutable {</span>
<span class="line-modified">289         RefPtr&lt;ServiceWorker&gt; serviceWorker;</span>
<span class="line-modified">290         if (serviceWorkerData)</span>
<span class="line-modified">291             serviceWorker = ServiceWorker::getOrCreate(*scriptExecutionContext(), WTFMove(*serviceWorkerData));</span>
292 
<span class="line-modified">293         if (auto* registration = m_registrations.get(identifier))</span>
<span class="line-modified">294             registration-&gt;updateStateFromServer(state, WTFMove(serviceWorker));</span>
<span class="line-added">295     });</span>
296 }
297 
<span class="line-modified">298 void ServiceWorkerContainer::updateWorkerState(ServiceWorkerIdentifier identifier, ServiceWorkerState state)</span>
299 {
300     if (m_isStopped)
301         return;
302 
<span class="line-modified">303     queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, identifier, state] {</span>
<span class="line-modified">304         if (auto* serviceWorker = scriptExecutionContext()-&gt;serviceWorker(identifier))</span>
<span class="line-modified">305             serviceWorker-&gt;updateState(state);</span>
<span class="line-modified">306     });</span>


307 }
308 
309 void ServiceWorkerContainer::getRegistrations(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
310 {
<span class="line-modified">311     if (m_isStopped) {</span>

312         promise-&gt;reject(Exception { InvalidStateError });
313         return;
314     }
315 
<span class="line-modified">316     auto&amp; context = *scriptExecutionContext();</span>
<span class="line-modified">317     ensureSWClientConnection().getRegistrations(SecurityOriginData { context.topOrigin().data() }, context.url(), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)] (auto&amp;&amp; registrationDatas) mutable {</span>
<span class="line-modified">318         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, promise = WTFMove(promise), registrationDatas = WTFMove(registrationDatas)]() mutable {</span>
<span class="line-modified">319             auto registrations = WTF::map(WTFMove(registrationDatas), [&amp;](auto&amp;&amp; registrationData) {</span>
<span class="line-modified">320                 return ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(registrationData));</span>











321             });
<span class="line-added">322             promise-&gt;resolve&lt;IDLSequence&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;&gt;(WTFMove(registrations));</span>
323         });
324     });
325 }
326 






















327 void ServiceWorkerContainer::startMessages()
328 {
<span class="line-added">329     m_shouldDeferMessageEvents = false;</span>
<span class="line-added">330     auto deferredMessageEvents = WTFMove(m_deferredMessageEvents);</span>
<span class="line-added">331     for (auto&amp; messageEvent : deferredMessageEvents)</span>
<span class="line-added">332         queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, WTFMove(messageEvent));</span>
333 }
334 
335 void ServiceWorkerContainer::jobFailedWithException(ServiceWorkerJob&amp; job, const Exception&amp; exception)
336 {
337 #ifndef NDEBUG
338     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
339 #endif
340 
341     ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, &quot;Only soft updates have no promise&quot;);
342 
343     auto guard = WTF::makeScopeExit([this, &amp;job] {
344         destroyJob(job);
345     });
346 
347     CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;jobFailedWithException: Job %&quot; PRIu64 &quot; failed with error %s&quot;, job.identifier().toUInt64(), exception.message().utf8().data());
348 
349     auto promise = job.takePromise();
350     if (!promise)
351         return;
352 
<span class="line-modified">353     queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), exception]() mutable {</span>
<span class="line-modified">354         promise-&gt;reject(exception);</span>
<span class="line-modified">355     });</span>


356 }
357 
<span class="line-modified">358 void ServiceWorkerContainer::queueTaskToFireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier identifier)</span>
359 {
360 #ifndef NDEBUG
361     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
362 #endif
363 
364     if (auto* registration = m_registrations.get(identifier))
<span class="line-modified">365         registration-&gt;queueTaskToFireUpdateFoundEvent();</span>
366 }
367 
368 void ServiceWorkerContainer::jobResolvedWithRegistration(ServiceWorkerJob&amp; job, ServiceWorkerRegistrationData&amp;&amp; data, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
369 {
370 #ifndef NDEBUG
371     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
372 #endif
373     ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, &quot;Only soft updates have no promise&quot;);
374 
375     if (job.data().type == ServiceWorkerJobType::Register)
376         CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Registration job %&quot; PRIu64 &quot; succeeded&quot;, job.identifier().toUInt64());
377     else {
378         ASSERT(job.data().type == ServiceWorkerJobType::Update);
379         CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Update job %&quot; PRIu64 &quot; succeeded&quot;, job.identifier().toUInt64());
380     }
381 
382     auto guard = WTF::makeScopeExit([this, &amp;job] {
383         destroyJob(job);
384     });
385 
<span class="line-modified">386     auto notifyIfExitEarly = WTF::makeScopeExit([this, protectedThis = makeRef(*this), key = data.key, shouldNotifyWhenResolved] {</span>
387         if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)
<span class="line-modified">388             notifyRegistrationIsSettled(key);</span>
389     });
390 
391     if (isStopped())
392         return;
393 
394     auto promise = job.takePromise();
395     if (!promise)
396         return;
397 
<span class="line-modified">398     queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, protectedThis = makeRef(*this), promise = WTFMove(promise), jobIdentifier = job.identifier(), data = WTFMove(data), shouldNotifyWhenResolved, notifyIfExitEarly = WTFMove(notifyIfExitEarly)]() mutable {</span>
<span class="line-added">399         notifyIfExitEarly.release();</span>
400 
<span class="line-modified">401         auto registration = ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(data));</span>







402 
403         CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Resolving promise for job %&quot; PRIu64 &quot;. Registration ID: %&quot; PRIu64, jobIdentifier.toUInt64(), registration-&gt;identifier().toUInt64());
404 
405         if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes) {
406             m_ongoingSettledRegistrations.add(++m_lastOngoingSettledRegistrationIdentifier, registration-&gt;data().key);
407             promise-&gt;whenSettled([this, protectedThis = WTFMove(protectedThis), identifier = m_lastOngoingSettledRegistrationIdentifier] {
<span class="line-modified">408                 auto iterator = m_ongoingSettledRegistrations.find(identifier);</span>
<span class="line-added">409                 if (iterator == m_ongoingSettledRegistrations.end())</span>
<span class="line-added">410                     return;</span>
<span class="line-added">411                 notifyRegistrationIsSettled(iterator-&gt;value);</span>
<span class="line-added">412                 m_ongoingSettledRegistrations.remove(iterator);</span>
413             });
414         }
415 
416         promise-&gt;resolve&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;(WTFMove(registration));
417     });
418 }
419 
420 void ServiceWorkerContainer::postMessage(MessageWithMessagePorts&amp;&amp; message, ServiceWorkerData&amp;&amp; sourceData, String&amp;&amp; sourceOrigin)
421 {
422     auto&amp; context = *scriptExecutionContext();
423     MessageEventSource source = RefPtr&lt;ServiceWorker&gt; { ServiceWorker::getOrCreate(context, WTFMove(sourceData)) };
424 
425     auto messageEvent = MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(message.transferredPorts)), message.message.releaseNonNull(), sourceOrigin, { }, WTFMove(source));
<span class="line-modified">426     if (m_shouldDeferMessageEvents)</span>
<span class="line-added">427         m_deferredMessageEvents.append(WTFMove(messageEvent));</span>
<span class="line-added">428     else {</span>
<span class="line-added">429         ASSERT(m_deferredMessageEvents.isEmpty());</span>
<span class="line-added">430         queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, WTFMove(messageEvent));</span>
<span class="line-added">431     }</span>
432 }
433 
434 void ServiceWorkerContainer::notifyRegistrationIsSettled(const ServiceWorkerRegistrationKey&amp; registrationKey)
435 {
<span class="line-modified">436     ensureSWClientConnection().didResolveRegistrationPromise(registrationKey);</span>


437 }
438 
439 void ServiceWorkerContainer::jobResolvedWithUnregistrationResult(ServiceWorkerJob&amp; job, bool unregistrationResult)
440 {
441 #ifndef NDEBUG
442     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
443 #endif
444 
445     ASSERT(job.hasPromise());
446 
447     auto guard = WTF::makeScopeExit([this, &amp;job] {
448         destroyJob(job);
449     });
450 
451     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithUnregistrationResult: Unregister job %&quot; PRIu64 &quot; finished. Success? %d&quot;, job.identifier().toUInt64(), unregistrationResult);
452 
453     auto* context = scriptExecutionContext();
454     if (!context) {
455         LOG_ERROR(&quot;ServiceWorkerContainer::jobResolvedWithUnregistrationResult called but the containers ScriptExecutionContext is gone&quot;);
456         return;
457     }
458 
<span class="line-modified">459     queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = job.takePromise(), unregistrationResult]() mutable {</span>
460         promise-&gt;resolve&lt;IDLBoolean&gt;(unregistrationResult);
461     });
462 }
463 
464 void ServiceWorkerContainer::startScriptFetchForJob(ServiceWorkerJob&amp; job, FetchOptions::Cache cachePolicy)
465 {
466 #ifndef NDEBUG
467     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
468 #endif
469 
470     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;startScriptFetchForJob: Starting script fetch for job %&quot; PRIu64, job.identifier().toUInt64());
471 
472     auto* context = scriptExecutionContext();
473     if (!context) {
474         LOG_ERROR(&quot;ServiceWorkerContainer::jobResolvedWithRegistration called but the container&#39;s ScriptExecutionContext is gone&quot;);
475         notifyFailedFetchingScript(job, { errorDomainWebKitInternal, 0, job.data().scriptURL, &quot;Attempt to fetch service worker script with no ScriptExecutionContext&quot;_s });
476         destroyJob(job);
477         return;
478     }
479 
480     job.fetchScriptWithContext(*context, cachePolicy);
481 }
482 
483 void ServiceWorkerContainer::jobFinishedLoadingScript(ServiceWorkerJob&amp; job, const String&amp; script, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, const String&amp; referrerPolicy)
484 {
485 #ifndef NDEBUG
486     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
487 #endif
488 
489     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobFinishedLoadingScript: Successfuly finished fetching script for job %&quot; PRIu64, job.identifier().toUInt64());
490 
<span class="line-modified">491     ensureSWClientConnection().finishFetchingScriptInServer({ job.data().identifier(), job.data().registrationKey(), script, contentSecurityPolicy, referrerPolicy, { } });</span>


492 }
493 
494 void ServiceWorkerContainer::jobFailedLoadingScript(ServiceWorkerJob&amp; job, const ResourceError&amp; error, Exception&amp;&amp; exception)
495 {
496 #ifndef NDEBUG
497     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
498 #endif
499     ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, &quot;Only soft updates have no promise&quot;);
500 
501     CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;jobFinishedLoadingScript: Failed to fetch script for job %&quot; PRIu64 &quot;, error: %s&quot;, job.identifier().toUInt64(), error.localizedDescription().utf8().data());
502 
<span class="line-modified">503     if (auto promise = job.takePromise()) {</span>
<span class="line-modified">504         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-added">505             promise-&gt;reject(WTFMove(exception));</span>
<span class="line-added">506         });</span>
<span class="line-added">507     }</span>
508 
509     notifyFailedFetchingScript(job, error);
510     destroyJob(job);
511 }
512 
513 void ServiceWorkerContainer::notifyFailedFetchingScript(ServiceWorkerJob&amp; job, const ResourceError&amp; error)
514 {
<span class="line-modified">515     ensureSWClientConnection().finishFetchingScriptInServer(serviceWorkerFetchError(job.data().identifier(), ServiceWorkerRegistrationKey { job.data().registrationKey() }, ResourceError { error }));</span>


516 }
517 
518 void ServiceWorkerContainer::destroyJob(ServiceWorkerJob&amp; job)
519 {
520 #ifndef NDEBUG
521     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
522 #endif
523 
524     ASSERT(m_jobMap.contains(job.identifier()));
525     m_jobMap.remove(job.identifier());
526 }
527 
528 const char* ServiceWorkerContainer::activeDOMObjectName() const
529 {
530     return &quot;ServiceWorkerContainer&quot;;
531 }
532 





533 SWClientConnection&amp; ServiceWorkerContainer::ensureSWClientConnection()
534 {
535     ASSERT(scriptExecutionContext());

536     if (!m_swConnection) {
<span class="line-modified">537         auto&amp; context = *scriptExecutionContext();</span>
<span class="line-modified">538         if (is&lt;WorkerGlobalScope&gt;(context))</span>
<span class="line-modified">539             m_swConnection = &amp;downcast&lt;WorkerGlobalScope&gt;(context).swClientConnection();</span>
<span class="line-modified">540         else</span>
<span class="line-added">541             m_swConnection = &amp;mainThreadConnection();</span>
542     }
543     return *m_swConnection;
544 }
545 
546 void ServiceWorkerContainer::addRegistration(ServiceWorkerRegistration&amp; registration)
547 {
548 #ifndef NDEBUG
549     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
550 #endif
551 
552     ensureSWClientConnection().addServiceWorkerRegistrationInServer(registration.identifier());
553     m_registrations.add(registration.identifier(), &amp;registration);
554 }
555 
556 void ServiceWorkerContainer::removeRegistration(ServiceWorkerRegistration&amp; registration)
557 {
558 #ifndef NDEBUG
559     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
560 #endif
561 
562     m_swConnection-&gt;removeServiceWorkerRegistrationInServer(registration.identifier());
563     m_registrations.remove(registration.identifier());
564 }
565 
<span class="line-modified">566 void ServiceWorkerContainer::queueTaskToDispatchControllerChangeEvent()</span>
567 {
568 #ifndef NDEBUG
569     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
570 #endif
571 
<span class="line-modified">572     queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, Event::create(eventNames().controllerchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>



573 }
574 
575 void ServiceWorkerContainer::stop()
576 {
577     m_isStopped = true;
578     removeAllEventListeners();

579     m_readyPromise = nullptr;
580     auto jobMap = WTFMove(m_jobMap);
581     for (auto&amp; ongoingJob : jobMap.values()) {
582         if (ongoingJob.job-&gt;cancelPendingLoad())
583             notifyFailedFetchingScript(*ongoingJob.job.get(), ResourceError { errorDomainWebKitInternal, 0, ongoingJob.job-&gt;data().scriptURL, &quot;Job cancelled&quot;_s, ResourceError::Type::Cancellation });
584     }
585 
586     auto registrationMap = WTFMove(m_ongoingSettledRegistrations);
587     for (auto&amp; registration : registrationMap.values())
588         notifyRegistrationIsSettled(registration);
589 }
590 
591 DocumentOrWorkerIdentifier ServiceWorkerContainer::contextIdentifier()
592 {
593 #ifndef NDEBUG
594     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
595 #endif
596 
597     ASSERT(scriptExecutionContext());
598     if (is&lt;ServiceWorkerGlobalScope&gt;(*scriptExecutionContext()))
599         return downcast&lt;ServiceWorkerGlobalScope&gt;(*scriptExecutionContext()).thread().identifier();
600     return downcast&lt;Document&gt;(*scriptExecutionContext()).identifier();
601 }
602 
603 ServiceWorkerJob* ServiceWorkerContainer::job(ServiceWorkerJobIdentifier identifier)
604 {
605     auto iterator = m_jobMap.find(identifier);
606     if (iterator == m_jobMap.end())
607         return nullptr;
608     return iterator-&gt;value.job.get();
609 }
610 
611 bool ServiceWorkerContainer::isAlwaysOnLoggingAllowed() const
612 {
613     auto* context = scriptExecutionContext();
614     if (!context)
615         return false;
616 
<span class="line-modified">617     if (is&lt;Document&gt;(*context)) {</span>
<span class="line-modified">618         auto* page = downcast&lt;Document&gt;(*context).page();</span>
<span class="line-added">619         return page &amp;&amp; page-&gt;sessionID().isAlwaysOnLoggingAllowed();</span>
<span class="line-added">620     }</span>
621 
622     // FIXME: No logging inside service workers for now.
623     return false;
624 }
625 
<span class="line-added">626 bool ServiceWorkerContainer::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; eventListener, const AddEventListenerOptions&amp; options)</span>
<span class="line-added">627 {</span>
<span class="line-added">628     // Setting the onmessage EventHandler attribute on the ServiceWorkerContainer should start the messages</span>
<span class="line-added">629     // automatically.</span>
<span class="line-added">630     if (eventListener-&gt;isAttribute() &amp;&amp; eventType == eventNames().messageEvent)</span>
<span class="line-added">631         startMessages();</span>
<span class="line-added">632 </span>
<span class="line-added">633     return EventTargetWithInlineData::addEventListener(eventType, WTFMove(eventListener), options);</span>
<span class="line-added">634 }</span>
<span class="line-added">635 </span>
636 } // namespace WebCore
637 
638 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
</tr>
</table>
<center><a href="ServiceWorkerClient.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerContainer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
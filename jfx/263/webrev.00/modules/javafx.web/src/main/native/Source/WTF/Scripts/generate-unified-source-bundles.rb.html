<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/Scripts/generate-unified-source-bundles.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 # Copyright (C) 2017 Apple Inc. All rights reserved.
  2 #
  3 # Redistribution and use in source and binary forms, with or without
  4 # modification, are permitted provided that the following conditions
  5 # are met:
  6 # 1. Redistributions of source code must retain the above copyright
  7 #    notice, this list of conditions and the following disclaimer.
  8 # 2. Redistributions in binary form must reproduce the above copyright
  9 #    notice, this list of conditions and the following disclaimer in the
 10 #    documentation and/or other materials provided with the distribution.
 11 #
 12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 22 # THE POSSIBILITY OF SUCH DAMAGE.
 23 
 24 require &#39;digest&#39;
 25 require &#39;fileutils&#39;
 26 require &#39;pathname&#39;
 27 require &#39;getoptlong&#39;
 28 
 29 SCRIPT_NAME = File.basename($0)
 30 COMMENT_REGEXP = /\/\//
 31 
 32 def usage(message)
 33     if message
 34         puts &quot;Error: #{message}&quot;
 35         puts
 36     end
 37 
 38     puts &quot;usage: #{SCRIPT_NAME} [options] &lt;sources-list-file&gt;...&quot;
 39     puts &quot;&lt;sources-list-file&gt; may be separate arguments or one semicolon separated string&quot;
 40     puts &quot;--help                          (-h) Print this message&quot;
 41     puts &quot;--verbose                       (-v) Adds extra logging to stderr.&quot;
 42     puts
 43     puts &quot;Required arguments:&quot;
 44     puts &quot;--source-tree-path              (-s) Path to the root of the source directory.&quot;
 45     puts &quot;--derived-sources-path          (-d) Path to the directory where the unified source files should be placed.&quot;
 46     puts
 47     puts &quot;Optional arguments:&quot;
 48     puts &quot;--print-bundled-sources              Print bundled sources rather than generating sources&quot;
 49     puts &quot;--print-all-sources                  Print all sources rather than generating sources&quot;
 50     puts &quot;--generate-xcfilelists               Generate .xcfilelist files&quot;
 51     puts &quot;--input-xcfilelist-path              Path of the generated input .xcfilelist file&quot;
 52     puts &quot;--output-xcfilelist-path             Path of the generated output .xcfilelist file&quot;
 53     puts &quot;--feature-flags                 (-f) Space or semicolon separated list of enabled feature flags&quot;
 54     puts
 55     puts &quot;Generation options:&quot;
 56     puts &quot;--max-cpp-bundle-count               Use global sequential numbers for cpp bundle filenames and set the limit on the number&quot;
 57     puts &quot;--max-obj-c-bundle-count             Use global sequential numbers for Obj-C bundle filenames and set the limit on the number&quot;
 58     puts &quot;--dense-bundle-filter                Densely bundle files matching the given path glob&quot;
 59     exit 1
 60 end
 61 
 62 MAX_BUNDLE_SIZE = 8
 63 MAX_DENSE_BUNDLE_SIZE = 64
 64 $derivedSourcesPath = nil
 65 $unifiedSourceOutputPath = nil
 66 $sourceTreePath = nil
 67 $featureFlags = {}
 68 $verbose = false
 69 $mode = :GenerateBundles
 70 $inputXCFilelistPath = nil
 71 $outputXCFilelistPath = nil
 72 $maxCppBundleCount = nil
 73 $maxObjCBundleCount = nil
 74 $denseBundleFilters = []
 75 
 76 def log(text)
 77     $stderr.puts text if $verbose
 78 end
 79 
 80 GetoptLong.new([&#39;--help&#39;, &#39;-h&#39;, GetoptLong::NO_ARGUMENT],
 81                [&#39;--verbose&#39;, &#39;-v&#39;, GetoptLong::NO_ARGUMENT],
 82                [&#39;--derived-sources-path&#39;, &#39;-d&#39;, GetoptLong::REQUIRED_ARGUMENT],
 83                [&#39;--source-tree-path&#39;, &#39;-s&#39;, GetoptLong::REQUIRED_ARGUMENT],
 84                [&#39;--feature-flags&#39;, &#39;-f&#39;, GetoptLong::REQUIRED_ARGUMENT],
 85                [&#39;--print-bundled-sources&#39;, GetoptLong::NO_ARGUMENT],
 86                [&#39;--print-all-sources&#39;, GetoptLong::NO_ARGUMENT],
 87                [&#39;--generate-xcfilelists&#39;, GetoptLong::NO_ARGUMENT],
 88                [&#39;--input-xcfilelist-path&#39;, GetoptLong::REQUIRED_ARGUMENT],
 89                [&#39;--output-xcfilelist-path&#39;, GetoptLong::REQUIRED_ARGUMENT],
 90                [&#39;--max-cpp-bundle-count&#39;, GetoptLong::REQUIRED_ARGUMENT],
 91                [&#39;--max-obj-c-bundle-count&#39;, GetoptLong::REQUIRED_ARGUMENT],
 92                [&#39;--dense-bundle-filter&#39;, GetoptLong::REQUIRED_ARGUMENT]).each {
 93     | opt, arg |
 94     case opt
 95     when &#39;--help&#39;
 96         usage(nil)
 97     when &#39;--verbose&#39;
 98         $verbose = true
 99     when &#39;--derived-sources-path&#39;
100         $derivedSourcesPath = Pathname.new(arg)
101     when &#39;--source-tree-path&#39;
102         $sourceTreePath = Pathname.new(arg)
103         usage(&quot;Source tree #{arg} does not exist.&quot;) if !$sourceTreePath.exist?
104     when &#39;--feature-flags&#39;
105         arg.gsub(/\s+/, &quot;;&quot;).split(&quot;;&quot;).map { |x| $featureFlags[x] = true }
106     when &#39;--print-bundled-sources&#39;
107         $mode = :PrintBundledSources
108     when &#39;--print-all-sources&#39;
109         $mode = :PrintAllSources
110     when &#39;--generate-xcfilelists&#39;
111         $mode = :GenerateXCFilelists
112     when &#39;--input-xcfilelist-path&#39;
113         $inputXCFilelistPath = arg
114     when &#39;--output-xcfilelist-path&#39;
115         $outputXCFilelistPath = arg
116     when &#39;--max-cpp-bundle-count&#39;
117         $maxCppBundleCount = arg.to_i
118     when &#39;--max-obj-c-bundle-count&#39;
119         $maxObjCBundleCount = arg.to_i
120     when &#39;--dense-bundle-filter&#39;
121         $denseBundleFilters.push(arg)
122     end
123 }
124 
125 $unifiedSourceOutputPath = $derivedSourcesPath + Pathname.new(&quot;unified-sources&quot;)
126 FileUtils.mkpath($unifiedSourceOutputPath) if !$unifiedSourceOutputPath.exist? &amp;&amp; $mode != :GenerateXCFilelists
127 
128 usage(&quot;--derived-sources-path must be specified.&quot;) if !$unifiedSourceOutputPath
129 usage(&quot;--source-tree-path must be specified.&quot;) if !$sourceTreePath
130 log(&quot;Putting unified sources in #{$unifiedSourceOutputPath}&quot;)
131 log(&quot;Active Feature flags: #{$featureFlags.keys.inspect}&quot;)
132 
133 usage(&quot;At least one source list file must be specified.&quot;) if ARGV.length == 0
134 # Even though CMake will only pass us a single semicolon separated arguemnts, we separate all the arguments for simplicity.
135 sourceListFiles = ARGV.to_a.map { | sourceFileList | sourceFileList.split(&quot;;&quot;) }.flatten
136 log(&quot;Source files: #{sourceListFiles}&quot;)
137 $generatedSources = []
138 $inputSources = []
139 $outputSources = []
140 
141 class SourceFile
142     attr_reader :unifiable, :fileIndex, :path
143     def initialize(file, fileIndex)
144         @unifiable = true
145         @fileIndex = fileIndex
146 
147         attributeStart = file =~ /@/
148         if attributeStart
149             # We want to make sure we skip the first @ so split works correctly
150             attributesText = file[(attributeStart + 1)..file.length]
151             attributesText.split(/\s*@/).each {
152                 | attribute |
153                 case attribute.strip
154                 when &quot;no-unify&quot;
155                     @unifiable = false
156                 else
157                     raise &quot;unknown attribute: #{attribute}&quot;
158                 end
159             }
160             file = file[0..(attributeStart-1)]
161         end
162 
163         @path = Pathname.new(file.strip)
164     end
165 
166     def &lt;=&gt;(other)
167         return @path.dirname &lt;=&gt; other.path.dirname if @path.dirname != other.path.dirname
168         return @path.basename &lt;=&gt; other.path.basename if @fileIndex == other.fileIndex
169         @fileIndex &lt;=&gt; other.fileIndex
170     end
171 
172     def derived?
173         return @derived if @derived != nil
174         @derived = !($sourceTreePath + self.path).exist?
175     end
176 
177     def to_s
178         if $mode == :GenerateXCFilelists
179             if derived?
180                 ($derivedSourcesPath + @path).to_s
181             else
182                 &#39;$(SRCROOT)/&#39; + @path.to_s
183             end
184         elsif $mode == :GenerateBundles || !derived?
185             @path.to_s
186         else
187             ($derivedSourcesPath + @path).to_s
188         end
189     end
190 end
191 
192 class BundleManager
193     attr_reader :bundleCount, :extension, :fileCount, :currentBundleText, :maxCount, :extraFiles
194 
195     def initialize(extension, max)
196         @extension = extension
197         @fileCount = 0
198         @bundleCount = 0
199         @currentBundleText = &quot;&quot;
200         @maxCount = max
201         @extraFiles = []
202         @currentDirectory = nil
203         @lastBundlingPrefix = nil
204     end
205 
206     def writeFile(file, text)
207         bundleFile = $unifiedSourceOutputPath + file
208         if $mode == :GenerateXCFilelists
209             $outputSources &lt;&lt; bundleFile
210             return
211         end
212         if (!bundleFile.exist? || IO::read(bundleFile) != @currentBundleText)
213             log(&quot;Writing bundle #{bundleFile} with: \n#{@currentBundleText}&quot;)
214             IO::write(bundleFile, @currentBundleText)
215         end
216     end
217 
218     def bundleFileName()
219         id =
220             if @maxCount
221                 @bundleCount.to_s
222             else
223                 # The dash makes the filenames more clear when using a hash.
224                 hash = Digest::SHA1.hexdigest(@currentDirectory.to_s)[0..7]
225                 &quot;-#{hash}-#{@bundleCount}&quot;
226             end
227         @extension == &quot;cpp&quot; ? &quot;UnifiedSource#{id}.#{extension}&quot; : &quot;UnifiedSource#{id}-#{extension}.#{extension}&quot;
228     end
229 
230     def flush
231         @bundleCount += 1
232         bundleFile = bundleFileName
233         $generatedSources &lt;&lt; $unifiedSourceOutputPath + bundleFile
234         @extraFiles &lt;&lt; bundleFile if @maxCount and @bundleCount &gt; @maxCount
235 
236         writeFile(bundleFile, @currentBundleText)
237         @currentBundleText = &quot;&quot;
238         @fileCount = 0
239     end
240 
241     def flushToMax
242         raise if !@maxCount
243         while @bundleCount &lt; @maxCount
244             flush
245         end
246     end
247 
248     def addFile(sourceFile)
249         path = sourceFile.path
250         raise &quot;wrong extension: #{path.extname} expected #{@extension}&quot; unless path.extname == &quot;.#{@extension}&quot;
251         bundlePrefix, bundleSize = BundlePrefixAndSizeForPath(path)
252         if (@lastBundlingPrefix != bundlePrefix)
253             log(&quot;Flushing because new top level directory; old: #{@currentDirectory}, new: #{path.dirname}&quot;)
254             flush
255             @lastBundlingPrefix = bundlePrefix
256             @currentDirectory = path.dirname
257             @bundleCount = 0 unless @maxCount
258         end
259         if @fileCount &gt;= bundleSize
260             log(&quot;Flushing because new bundle is full (#{@fileCount} sources)&quot;)
261             flush
262         end
263         @currentBundleText += &quot;#include \&quot;#{sourceFile}\&quot;\n&quot;
264         @fileCount += 1
265     end
266 end
267 
268 def BundlePrefixAndSizeForPath(path)
269     topLevelDirectory = TopLevelDirectoryForPath(path.dirname)
270     $denseBundleFilters.each { |filter|
271         if path.fnmatch(filter)
272             return filter, MAX_DENSE_BUNDLE_SIZE
273         end
274     }
275     return topLevelDirectory, MAX_BUNDLE_SIZE
276 end
277 
278 def TopLevelDirectoryForPath(path)
279     if !path
280         return nil
281     end
282     while path.dirname != path.dirname.dirname
283         path = path.dirname
284     end
285     return path
286 end
287 
288 def ProcessFileForUnifiedSourceGeneration(sourceFile)
289     path = sourceFile.path
290     $inputSources &lt;&lt; sourceFile.to_s
291 
292     bundle = $bundleManagers[path.extname]
293     if !bundle
294         log(&quot;No bundle for #{path.extname} files, building #{path} standalone&quot;)
295         $generatedSources &lt;&lt; sourceFile
296     elsif !sourceFile.unifiable
297         log(&quot;Not allowed to unify #{path}, building standalone&quot;)
298         $generatedSources &lt;&lt; sourceFile
299     else
300         bundle.addFile(sourceFile)
301     end
302 end
303 
304 $bundleManagers = {
305     &quot;.cpp&quot; =&gt; BundleManager.new(&quot;cpp&quot;, $maxCppBundleCount),
306     &quot;.mm&quot; =&gt; BundleManager.new(&quot;mm&quot;, $maxObjCBundleCount)
307 }
308 
309 seen = {}
310 sourceFiles = []
311 
312 sourceListFiles.each_with_index {
313     | path, sourceFileIndex |
314     log(&quot;Reading #{path}&quot;)
315     result = []
316     inDisabledLines = false
317     File.read(path).lines.each {
318         | line |
319         commentStart = line =~ COMMENT_REGEXP
320         log(&quot;Before: #{line}&quot;)
321         if commentStart != nil
322             line = line.slice(0, commentStart)
323             log(&quot;After: #{line}&quot;)
324         end
325         line.strip!
326         if line == &quot;#endif&quot;
327             inDisabledLines = false
328             next
329         end
330 
331         next if line.empty? || inDisabledLines
332 
333         if line =~ /\A#if/
334             raise &quot;malformed #if&quot; unless line =~ /\A#if\s+(\S+)/
335             inDisabledLines = !$featureFlags[$1]
336         else
337             if seen[line]
338                 next if $mode == :GenerateXCFilelists
339                 raise &quot;duplicate line: #{line} in #{path}&quot;
340             end
341             seen[line] = true
342             result &lt;&lt; SourceFile.new(line, sourceFileIndex)
343         end
344     }
345     raise &quot;Couldn&#39;t find closing \&quot;#endif\&quot;&quot; if inDisabledLines
346 
347     log(&quot;Found #{result.length} source files in #{path}&quot;)
348     sourceFiles += result
349 }
350 
351 log(&quot;Found sources: #{sourceFiles.sort}&quot;)
352 
353 sourceFiles.sort.each {
354     | sourceFile |
355     case $mode
356     when :GenerateBundles, :GenerateXCFilelists
357         ProcessFileForUnifiedSourceGeneration(sourceFile)
358     when :PrintAllSources
359         $generatedSources &lt;&lt; sourceFile
360     when :PrintBundledSources
361         $generatedSources &lt;&lt; sourceFile if $bundleManagers[sourceFile.path.extname] &amp;&amp; sourceFile.unifiable
362     end
363 }
364 
365 if $mode != :PrintAllSources
366     $bundleManagers.each_value {
367         | manager |
368         manager.flush
369 
370         maxCount = manager.maxCount
371         next if !maxCount
372 
373         manager.flushToMax
374 
375         unless manager.extraFiles.empty?
376             extension = manager.extension
377             bundleCount = manager.bundleCount
378             filesToAdd = manager.extraFiles.join(&quot;, &quot;)
379             raise &quot;number of bundles for #{extension} sources, #{bundleCount}, exceeded limit, #{maxCount}. Please add #{filesToAdd} to Xcode then update UnifiedSource#{extension.capitalize}FileCount&quot;
380         end
381     }
382 end
383 
384 if $mode == :GenerateXCFilelists
385     IO::write($inputXCFilelistPath, $inputSources.sort.join(&quot;\n&quot;) + &quot;\n&quot;) if $inputXCFilelistPath
386     IO::write($outputXCFilelistPath, $outputSources.sort.join(&quot;\n&quot;) + &quot;\n&quot;) if $outputXCFilelistPath
387 end
388 
389 # We use stdout to report our unified source list to CMake.
390 # Add trailing semicolon and avoid a trailing newline for CMake&#39;s sake.
391 
392 log($generatedSources.join(&quot;;&quot;) + &quot;;&quot;)
393 print($generatedSources.join(&quot;;&quot;) + &quot;;&quot;)
    </pre>
  </body>
</html>
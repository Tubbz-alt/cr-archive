<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CommonSlowPaths.h&quot;
  28 
  29 #include &quot;ArithProfile.h&quot;
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeStructs.h&quot;
  33 #include &quot;CallFrame.h&quot;
  34 #include &quot;ClonedArguments.h&quot;
  35 #include &quot;CodeProfiling.h&quot;
  36 #include &quot;DefinePropertyAttributes.h&quot;
  37 #include &quot;DirectArguments.h&quot;
  38 #include &quot;Error.h&quot;
  39 #include &quot;ErrorHandlingScope.h&quot;
  40 #include &quot;ExceptionFuzz.h&quot;
  41 #include &quot;FrameTracers.h&quot;
  42 #include &quot;GetterSetter.h&quot;
  43 #include &quot;HostCallReturnValue.h&quot;
  44 #include &quot;ICStats.h&quot;
  45 #include &quot;Interpreter.h&quot;
  46 #include &quot;IteratorOperations.h&quot;
  47 #include &quot;JIT.h&quot;
  48 #include &quot;JSArrayInlines.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  49 #include &quot;JSAsyncGenerator.h&quot;</span>
  50 #include &quot;JSCInlines.h&quot;
  51 #include &quot;JSCJSValue.h&quot;
<a name="2" id="anc2"></a>
  52 #include &quot;JSGlobalObjectFunctions.h&quot;
  53 #include &quot;JSImmutableButterfly.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  54 #include &quot;JSInternalPromise.h&quot;</span>
<span class="line-added">  55 #include &quot;JSInternalPromiseConstructor.h&quot;</span>
  56 #include &quot;JSLexicalEnvironment.h&quot;
<a name="4" id="anc4"></a><span class="line-added">  57 #include &quot;JSPromiseConstructor.h&quot;</span>
  58 #include &quot;JSPropertyNameEnumerator.h&quot;
  59 #include &quot;JSString.h&quot;
  60 #include &quot;JSWithScope.h&quot;
  61 #include &quot;LLIntCommon.h&quot;
  62 #include &quot;LLIntExceptions.h&quot;
  63 #include &quot;LowLevelInterpreter.h&quot;
  64 #include &quot;MathCommon.h&quot;
  65 #include &quot;ObjectConstructor.h&quot;
  66 #include &quot;OpcodeInlines.h&quot;
  67 #include &quot;ScopedArguments.h&quot;
  68 #include &quot;StructureRareDataInlines.h&quot;
  69 #include &quot;ThunkGenerators.h&quot;
  70 #include &quot;TypeProfilerLog.h&quot;
  71 #include &lt;wtf/StringPrintStream.h&gt;
  72 #include &lt;wtf/Variant.h&gt;
  73 
  74 namespace JSC {
  75 
  76 #define BEGIN_NO_SET_PC() \
<a name="5" id="anc5"></a><span class="line-modified">  77     CodeBlock* codeBlock = callFrame-&gt;codeBlock(); \</span>
<span class="line-modified">  78     JSGlobalObject* globalObject = codeBlock-&gt;globalObject(); \</span>
<span class="line-added">  79     VM&amp; vm = codeBlock-&gt;vm(); \</span>
<span class="line-added">  80     SlowPathFrameTracer tracer(vm, callFrame); \</span>
  81     auto throwScope = DECLARE_THROW_SCOPE(vm); \
  82     UNUSED_PARAM(throwScope)
  83 
  84 #ifndef NDEBUG
  85 #define SET_PC_FOR_STUBS() do { \
<a name="6" id="anc6"></a><span class="line-modified">  86         codeBlock-&gt;bytecodeOffset(pc); \</span>
<span class="line-modified">  87         callFrame-&gt;setCurrentVPC(pc); \</span>
  88     } while (false)
  89 #else
  90 #define SET_PC_FOR_STUBS() do { \
<a name="7" id="anc7"></a><span class="line-modified">  91         callFrame-&gt;setCurrentVPC(pc); \</span>
  92     } while (false)
  93 #endif
  94 
<a name="8" id="anc8"></a><span class="line-modified">  95 #define RETURN_TO_THROW(pc)   pc = LLInt::returnToThrow(vm)</span>
  96 
  97 #define BEGIN()                           \
  98     BEGIN_NO_SET_PC();                    \
  99     SET_PC_FOR_STUBS()
 100 
<a name="9" id="anc9"></a><span class="line-modified"> 101 #define GET(operand) (callFrame-&gt;uncheckedR(operand))</span>
<span class="line-modified"> 102 #define GET_C(operand) (callFrame-&gt;r(operand))</span>
 103 
 104 #define RETURN_TWO(first, second) do {       \
 105         return encodeResult(first, second);        \
 106     } while (false)
 107 
<a name="10" id="anc10"></a><span class="line-modified"> 108 #define END_IMPL() RETURN_TWO(pc, callFrame)</span>
 109 
 110 #define THROW(exceptionToThrow) do {                        \
<a name="11" id="anc11"></a><span class="line-modified"> 111         throwException(globalObject, throwScope, exceptionToThrow); \</span>
<span class="line-modified"> 112         RETURN_TO_THROW(pc);                          \</span>
 113         END_IMPL();                                         \
 114     } while (false)
 115 
 116 #define CHECK_EXCEPTION() do {                    \
<a name="12" id="anc12"></a><span class="line-modified"> 117         doExceptionFuzzingIfEnabled(globalObject, throwScope, &quot;CommonSlowPaths&quot;, pc);   \</span>
 118         if (UNLIKELY(throwScope.exception())) {   \
<a name="13" id="anc13"></a><span class="line-modified"> 119             RETURN_TO_THROW(pc);            \</span>
 120             END_IMPL();                           \
 121         }                                         \
 122     } while (false)
 123 
 124 #define END() do {                        \
 125         CHECK_EXCEPTION();                \
 126         END_IMPL();                       \
 127     } while (false)
 128 
 129 #define BRANCH(condition) do {                      \
 130         bool bCondition = (condition);                         \
 131         CHECK_EXCEPTION();                                  \
 132         if (bCondition)                                        \
 133             pc = bytecode.m_targetLabel \
 134                 ? reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + bytecode.m_targetLabel) \
<a name="14" id="anc14"></a><span class="line-modified"> 135                 : codeBlock-&gt;outOfLineJumpTarget(pc);                              \</span>
 136         else                                                      \
 137             pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + pc-&gt;size()); \
 138         END_IMPL();                                         \
 139     } while (false)
 140 
 141 #define RETURN_WITH_PROFILING_CUSTOM(result__, value__, profilingAction__) do { \
 142         JSValue returnValue__ = (value__);  \
 143         CHECK_EXCEPTION();                  \
 144         GET(result__) = returnValue__;              \
 145         profilingAction__;                  \
 146         END_IMPL();                         \
 147     } while (false)
 148 
 149 #define RETURN_WITH_PROFILING(value__, profilingAction__) RETURN_WITH_PROFILING_CUSTOM(bytecode.m_dst, value__, profilingAction__)
 150 
 151 #define RETURN(value) \
 152     RETURN_WITH_PROFILING(value, { })
 153 
 154 #define RETURN_PROFILED(value__) \
 155     RETURN_WITH_PROFILING(value__, PROFILE_VALUE(returnValue__))
 156 
 157 #define PROFILE_VALUE(value) do { \
<a name="15" id="anc15"></a><span class="line-modified"> 158         bytecode.metadata(codeBlock).m_profile.m_buckets[0] = JSValue::encode(value); \</span>
 159     } while (false)
 160 
<a name="16" id="anc16"></a><span class="line-modified"> 161 static void throwArityCheckStackOverflowError(JSGlobalObject* globalObject, ThrowScope&amp; scope)</span>










 162 {
<a name="17" id="anc17"></a><span class="line-modified"> 163     JSObject* error = createStackOverflowError(globalObject);</span>
<span class="line-modified"> 164     throwException(globalObject, scope, error);</span>
 165 #if LLINT_TRACING
 166     if (UNLIKELY(Options::traceLLIntSlowPath()))
 167         dataLog(&quot;Throwing exception &quot;, JSValue(scope.exception()), &quot;.\n&quot;);
 168 #endif
 169 }
 170 
 171 SLOW_PATH_DECL(slow_path_call_arityCheck)
 172 {
 173     BEGIN();
<a name="18" id="anc18"></a><span class="line-modified"> 174     int slotsToAdd = CommonSlowPaths::arityCheckFor(vm, callFrame, CodeForCall);</span>
 175     if (UNLIKELY(slotsToAdd &lt; 0)) {
<a name="19" id="anc19"></a><span class="line-modified"> 176         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(callFrame, CodeForCall);</span>
<span class="line-modified"> 177         callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 178         SlowPathFrameTracer tracer(vm, callFrame);</span>
 179         ErrorHandlingScope errorScope(vm);
 180         throwScope.release();
<a name="20" id="anc20"></a><span class="line-modified"> 181         throwArityCheckStackOverflowError(globalObject, throwScope);</span>
<span class="line-modified"> 182         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), callFrame);</span>
 183     }
 184     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 185 }
 186 
 187 SLOW_PATH_DECL(slow_path_construct_arityCheck)
 188 {
 189     BEGIN();
<a name="21" id="anc21"></a><span class="line-modified"> 190     int slotsToAdd = CommonSlowPaths::arityCheckFor(vm, callFrame, CodeForConstruct);</span>
 191     if (UNLIKELY(slotsToAdd &lt; 0)) {
<a name="22" id="anc22"></a><span class="line-modified"> 192         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(callFrame, CodeForConstruct);</span>
<span class="line-modified"> 193         callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 194         SlowPathFrameTracer tracer(vm, callFrame);</span>
 195         ErrorHandlingScope errorScope(vm);
<a name="23" id="anc23"></a><span class="line-modified"> 196         throwArityCheckStackOverflowError(globalObject, throwScope);</span>
<span class="line-modified"> 197         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), callFrame);</span>
 198     }
 199     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 200 }
 201 
 202 SLOW_PATH_DECL(slow_path_create_direct_arguments)
 203 {
 204     BEGIN();
 205     auto bytecode = pc-&gt;as&lt;OpCreateDirectArguments&gt;();
<a name="24" id="anc24"></a><span class="line-modified"> 206     RETURN(DirectArguments::createByCopying(globalObject, callFrame));</span>
 207 }
 208 
 209 SLOW_PATH_DECL(slow_path_create_scoped_arguments)
 210 {
 211     BEGIN();
 212     auto bytecode = pc-&gt;as&lt;OpCreateScopedArguments&gt;();
 213     JSLexicalEnvironment* scope = jsCast&lt;JSLexicalEnvironment*&gt;(GET(bytecode.m_scope).jsValue());
 214     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
<a name="25" id="anc25"></a><span class="line-modified"> 215     RETURN(ScopedArguments::createByCopying(globalObject, callFrame, table, scope));</span>
 216 }
 217 
 218 SLOW_PATH_DECL(slow_path_create_cloned_arguments)
 219 {
 220     BEGIN();
 221     auto bytecode = pc-&gt;as&lt;OpCreateClonedArguments&gt;();
<a name="26" id="anc26"></a><span class="line-modified"> 222     RETURN(ClonedArguments::createWithMachineFrame(globalObject, callFrame, ArgumentsMode::Cloned));</span>
<span class="line-added"> 223 }</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225 SLOW_PATH_DECL(slow_path_create_arguments_butterfly)</span>
<span class="line-added"> 226 {</span>
<span class="line-added"> 227     BEGIN();</span>
<span class="line-added"> 228     auto bytecode = pc-&gt;as&lt;OpCreateArgumentsButterfly&gt;();</span>
<span class="line-added"> 229     int32_t argumentCount = callFrame-&gt;argumentCount();</span>
<span class="line-added"> 230     JSImmutableButterfly* butterfly = JSImmutableButterfly::tryCreate(vm, vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), argumentCount);</span>
<span class="line-added"> 231     if (!butterfly)</span>
<span class="line-added"> 232         THROW(createOutOfMemoryError(globalObject));</span>
<span class="line-added"> 233     for (int32_t index = 0; index &lt; argumentCount; ++index)</span>
<span class="line-added"> 234         butterfly-&gt;setIndex(vm, index, callFrame-&gt;uncheckedArgument(index));</span>
<span class="line-added"> 235     RETURN(butterfly);</span>
 236 }
 237 
 238 SLOW_PATH_DECL(slow_path_create_this)
 239 {
 240     BEGIN();
 241     auto bytecode = pc-&gt;as&lt;OpCreateThis&gt;();
 242     JSObject* result;
 243     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());
<a name="27" id="anc27"></a><span class="line-modified"> 244     JSFunction* constructor = jsDynamicCast&lt;JSFunction*&gt;(vm, constructorAsObject);</span>
<span class="line-modified"> 245     if (constructor &amp;&amp; constructor-&gt;canUseAllocationProfile()) {</span>
<span class="line-modified"> 246         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(codeBlock).m_cachedCallee;</span>
 247         if (!cachedCallee)
<a name="28" id="anc28"></a><span class="line-modified"> 248             cachedCallee.set(vm, codeBlock, constructor);</span>
 249         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
 250             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
 251 
 252         size_t inlineCapacity = bytecode.m_inlineCapacity;
<a name="29" id="anc29"></a><span class="line-modified"> 253         ObjectAllocationProfileWithPrototype* allocationProfile = constructor-&gt;ensureRareDataAndAllocationProfile(globalObject, inlineCapacity)-&gt;objectAllocationProfile();</span>
 254         throwScope.releaseAssertNoException();
 255         Structure* structure = allocationProfile-&gt;structure();
<a name="30" id="anc30"></a><span class="line-modified"> 256         result = constructEmptyObject(vm, structure);</span>
 257         if (structure-&gt;hasPolyProto()) {
 258             JSObject* prototype = allocationProfile-&gt;prototype();
<a name="31" id="anc31"></a><span class="line-modified"> 259             ASSERT(prototype == constructor-&gt;prototypeForConstruction(vm, globalObject));</span>
 260             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 261             prototype-&gt;didBecomePrototype();
 262             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 263         }
 264     } else {
 265         // http://ecma-international.org/ecma-262/6.0/#sec-ordinarycreatefromconstructor
<a name="32" id="anc32"></a><span class="line-modified"> 266         JSValue proto = constructorAsObject-&gt;get(globalObject, vm.propertyNames-&gt;prototype);</span>
 267         CHECK_EXCEPTION();
 268         if (proto.isObject())
<a name="33" id="anc33"></a><span class="line-modified"> 269             result = constructEmptyObject(globalObject, asObject(proto));</span>
 270         else
<a name="34" id="anc34"></a><span class="line-modified"> 271             result = constructEmptyObject(globalObject);</span>
 272     }
 273     RETURN(result);
 274 }
 275 
<a name="35" id="anc35"></a><span class="line-added"> 276 SLOW_PATH_DECL(slow_path_create_promise)</span>
<span class="line-added"> 277 {</span>
<span class="line-added"> 278     BEGIN();</span>
<span class="line-added"> 279     auto bytecode = pc-&gt;as&lt;OpCreatePromise&gt;();</span>
<span class="line-added"> 280     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());</span>
<span class="line-added"> 281 </span>
<span class="line-added"> 282     JSPromise* result = nullptr;</span>
<span class="line-added"> 283     if (bytecode.m_isInternalPromise) {</span>
<span class="line-added"> 284         Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;internalPromiseConstructor(), constructorAsObject, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-added"> 285         CHECK_EXCEPTION();</span>
<span class="line-added"> 286         result = JSInternalPromise::create(vm, structure);</span>
<span class="line-added"> 287     } else {</span>
<span class="line-added"> 288         Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;promiseConstructor(), constructorAsObject, globalObject-&gt;promiseStructure());</span>
<span class="line-added"> 289         CHECK_EXCEPTION();</span>
<span class="line-added"> 290         result = JSPromise::create(vm, structure);</span>
<span class="line-added"> 291     }</span>
<span class="line-added"> 292 </span>
<span class="line-added"> 293     JSFunction* constructor = jsDynamicCast&lt;JSFunction*&gt;(vm, constructorAsObject);</span>
<span class="line-added"> 294     if (constructor &amp;&amp; constructor-&gt;canUseAllocationProfile()) {</span>
<span class="line-added"> 295         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(codeBlock).m_cachedCallee;</span>
<span class="line-added"> 296         if (!cachedCallee)</span>
<span class="line-added"> 297             cachedCallee.set(vm, codeBlock, constructor);</span>
<span class="line-added"> 298         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)</span>
<span class="line-added"> 299             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());</span>
<span class="line-added"> 300     }</span>
<span class="line-added"> 301     RETURN(result);</span>
<span class="line-added"> 302 }</span>
<span class="line-added"> 303 </span>
<span class="line-added"> 304 SLOW_PATH_DECL(slow_path_new_promise)</span>
<span class="line-added"> 305 {</span>
<span class="line-added"> 306     BEGIN();</span>
<span class="line-added"> 307     auto bytecode = pc-&gt;as&lt;OpNewPromise&gt;();</span>
<span class="line-added"> 308     JSPromise* result = nullptr;</span>
<span class="line-added"> 309     if (bytecode.m_isInternalPromise)</span>
<span class="line-added"> 310         result = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-added"> 311     else</span>
<span class="line-added"> 312         result = JSPromise::create(vm, globalObject-&gt;promiseStructure());</span>
<span class="line-added"> 313     RETURN(result);</span>
<span class="line-added"> 314 }</span>
<span class="line-added"> 315 </span>
<span class="line-added"> 316 template&lt;typename JSClass, typename Bytecode&gt;</span>
<span class="line-added"> 317 static JSClass* createInternalFieldObject(JSGlobalObject* globalObject, VM&amp; vm, CodeBlock* codeBlock, const Bytecode&amp; bytecode, JSObject* constructorAsObject, Structure* baseStructure)</span>
<span class="line-added"> 318 {</span>
<span class="line-added"> 319     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321     Structure* structure = InternalFunction::createSubclassStructure(globalObject, nullptr, constructorAsObject, baseStructure);</span>
<span class="line-added"> 322     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 323     JSClass* result = JSClass::create(vm, structure);</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325     JSFunction* constructor = jsDynamicCast&lt;JSFunction*&gt;(vm, constructorAsObject);</span>
<span class="line-added"> 326     if (constructor &amp;&amp; constructor-&gt;canUseAllocationProfile()) {</span>
<span class="line-added"> 327         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(codeBlock).m_cachedCallee;</span>
<span class="line-added"> 328         if (!cachedCallee)</span>
<span class="line-added"> 329             cachedCallee.set(vm, codeBlock, constructor);</span>
<span class="line-added"> 330         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)</span>
<span class="line-added"> 331             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());</span>
<span class="line-added"> 332     }</span>
<span class="line-added"> 333     RELEASE_AND_RETURN(scope, result);</span>
<span class="line-added"> 334 }</span>
<span class="line-added"> 335 </span>
<span class="line-added"> 336 SLOW_PATH_DECL(slow_path_create_generator)</span>
<span class="line-added"> 337 {</span>
<span class="line-added"> 338     BEGIN();</span>
<span class="line-added"> 339     auto bytecode = pc-&gt;as&lt;OpCreateGenerator&gt;();</span>
<span class="line-added"> 340     RETURN(createInternalFieldObject&lt;JSGenerator&gt;(globalObject, vm, codeBlock, bytecode, asObject(GET(bytecode.m_callee).jsValue()), globalObject-&gt;generatorStructure()));</span>
<span class="line-added"> 341 }</span>
<span class="line-added"> 342 </span>
<span class="line-added"> 343 SLOW_PATH_DECL(slow_path_create_async_generator)</span>
<span class="line-added"> 344 {</span>
<span class="line-added"> 345     BEGIN();</span>
<span class="line-added"> 346     auto bytecode = pc-&gt;as&lt;OpCreateAsyncGenerator&gt;();</span>
<span class="line-added"> 347     RETURN(createInternalFieldObject&lt;JSAsyncGenerator&gt;(globalObject, vm, codeBlock, bytecode, asObject(GET(bytecode.m_callee).jsValue()), globalObject-&gt;asyncGeneratorStructure()));</span>
<span class="line-added"> 348 }</span>
<span class="line-added"> 349 </span>
<span class="line-added"> 350 SLOW_PATH_DECL(slow_path_new_generator)</span>
<span class="line-added"> 351 {</span>
<span class="line-added"> 352     BEGIN();</span>
<span class="line-added"> 353     auto bytecode = pc-&gt;as&lt;OpNewGenerator&gt;();</span>
<span class="line-added"> 354     JSGenerator* result = JSGenerator::create(vm, globalObject-&gt;generatorStructure());</span>
<span class="line-added"> 355     RETURN(result);</span>
<span class="line-added"> 356 }</span>
<span class="line-added"> 357 </span>
 358 SLOW_PATH_DECL(slow_path_to_this)
 359 {
 360     BEGIN();
 361     auto bytecode = pc-&gt;as&lt;OpToThis&gt;();
<a name="36" id="anc36"></a><span class="line-modified"> 362     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
 363     JSValue v1 = GET(bytecode.m_srcDst).jsValue();
 364     if (v1.isCell()) {
 365         StructureID myStructureID = v1.asCell()-&gt;structureID();
 366         StructureID otherStructureID = metadata.m_cachedStructureID;
 367         if (myStructureID != otherStructureID) {
 368             if (otherStructureID)
 369                 metadata.m_toThisStatus = ToThisConflicted;
 370             metadata.m_cachedStructureID = myStructureID;
<a name="37" id="anc37"></a><span class="line-modified"> 371             vm.heap.writeBarrier(codeBlock, vm.getStructure(myStructureID));</span>
 372         }
 373     } else {
 374         metadata.m_toThisStatus = ToThisConflicted;
 375         metadata.m_cachedStructureID = 0;
 376     }
 377     // Note: We only need to do this value profiling here on the slow path. The fast path
 378     // just returns the input to to_this if the structure check succeeds. If the structure
 379     // check succeeds, doing value profiling here is equivalent to doing it with a potentially
 380     // different object that still has the same structure on the fast path since it&#39;ll produce
 381     // the same SpeculatedType. Therefore, we don&#39;t need to worry about value profiling on the
 382     // fast path.
<a name="38" id="anc38"></a><span class="line-modified"> 383     auto value = v1.toThis(globalObject, codeBlock-&gt;isStrictMode() ? StrictMode : NotStrictMode);</span>
 384     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, value, PROFILE_VALUE(value));
 385 }
 386 
 387 SLOW_PATH_DECL(slow_path_throw_tdz_error)
 388 {
 389     BEGIN();
<a name="39" id="anc39"></a><span class="line-modified"> 390     THROW(createTDZError(globalObject));</span>
 391 }
 392 
 393 SLOW_PATH_DECL(slow_path_check_tdz)
 394 {
 395     BEGIN();
<a name="40" id="anc40"></a><span class="line-modified"> 396     THROW(createTDZError(globalObject));</span>
 397 }
 398 
 399 SLOW_PATH_DECL(slow_path_throw_strict_mode_readonly_property_write_error)
 400 {
 401     BEGIN();
<a name="41" id="anc41"></a><span class="line-modified"> 402     THROW(createTypeError(globalObject, ReadonlyPropertyWriteError));</span>
 403 }
 404 
 405 SLOW_PATH_DECL(slow_path_not)
 406 {
 407     BEGIN();
 408     auto bytecode = pc-&gt;as&lt;OpNot&gt;();
<a name="42" id="anc42"></a><span class="line-modified"> 409     RETURN(jsBoolean(!GET_C(bytecode.m_operand).jsValue().toBoolean(globalObject)));</span>
 410 }
 411 
 412 SLOW_PATH_DECL(slow_path_eq)
 413 {
 414     BEGIN();
 415     auto bytecode = pc-&gt;as&lt;OpEq&gt;();
<a name="43" id="anc43"></a><span class="line-modified"> 416     RETURN(jsBoolean(JSValue::equal(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 417 }
 418 
 419 SLOW_PATH_DECL(slow_path_neq)
 420 {
 421     BEGIN();
 422     auto bytecode = pc-&gt;as&lt;OpNeq&gt;();
<a name="44" id="anc44"></a><span class="line-modified"> 423     RETURN(jsBoolean(!JSValue::equal(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 424 }
 425 
 426 SLOW_PATH_DECL(slow_path_stricteq)
 427 {
 428     BEGIN();
 429     auto bytecode = pc-&gt;as&lt;OpStricteq&gt;();
<a name="45" id="anc45"></a><span class="line-modified"> 430     RETURN(jsBoolean(JSValue::strictEqual(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 431 }
 432 
 433 SLOW_PATH_DECL(slow_path_nstricteq)
 434 {
 435     BEGIN();
 436     auto bytecode = pc-&gt;as&lt;OpNstricteq&gt;();
<a name="46" id="anc46"></a><span class="line-modified"> 437     RETURN(jsBoolean(!JSValue::strictEqual(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 438 }
 439 
 440 SLOW_PATH_DECL(slow_path_less)
 441 {
 442     BEGIN();
 443     auto bytecode = pc-&gt;as&lt;OpLess&gt;();
<a name="47" id="anc47"></a><span class="line-modified"> 444     RETURN(jsBoolean(jsLess&lt;true&gt;(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 445 }
 446 
 447 SLOW_PATH_DECL(slow_path_lesseq)
 448 {
 449     BEGIN();
 450     auto bytecode = pc-&gt;as&lt;OpLesseq&gt;();
<a name="48" id="anc48"></a><span class="line-modified"> 451     RETURN(jsBoolean(jsLessEq&lt;true&gt;(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 452 }
 453 
 454 SLOW_PATH_DECL(slow_path_greater)
 455 {
 456     BEGIN();
 457     auto bytecode = pc-&gt;as&lt;OpGreater&gt;();
<a name="49" id="anc49"></a><span class="line-modified"> 458     RETURN(jsBoolean(jsLess&lt;false&gt;(globalObject, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));</span>
 459 }
 460 
 461 SLOW_PATH_DECL(slow_path_greatereq)
 462 {
 463     BEGIN();
 464     auto bytecode = pc-&gt;as&lt;OpGreatereq&gt;();
<a name="50" id="anc50"></a><span class="line-modified"> 465     RETURN(jsBoolean(jsLessEq&lt;false&gt;(globalObject, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));</span>
 466 }
 467 
 468 SLOW_PATH_DECL(slow_path_inc)
 469 {
 470     BEGIN();
 471     auto bytecode = pc-&gt;as&lt;OpInc&gt;();
<a name="51" id="anc51"></a><span class="line-modified"> 472     JSValue argument = GET_C(bytecode.m_srcDst).jsValue();</span>
<span class="line-added"> 473     Variant&lt;JSBigInt*, double&gt; resultVariant = argument.toNumeric(globalObject);</span>
<span class="line-added"> 474     CHECK_EXCEPTION();</span>
<span class="line-added"> 475     JSValue result;</span>
<span class="line-added"> 476     if (WTF::holds_alternative&lt;JSBigInt*&gt;(resultVariant))</span>
<span class="line-added"> 477         result = JSBigInt::inc(globalObject, WTF::get&lt;JSBigInt*&gt;(resultVariant));</span>
<span class="line-added"> 478     else</span>
<span class="line-added"> 479         result = jsNumber(WTF::get&lt;double&gt;(resultVariant) + 1);</span>
<span class="line-added"> 480     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, result, { });</span>
 481 }
 482 
 483 SLOW_PATH_DECL(slow_path_dec)
 484 {
 485     BEGIN();
 486     auto bytecode = pc-&gt;as&lt;OpDec&gt;();
<a name="52" id="anc52"></a><span class="line-modified"> 487     JSValue argument = GET_C(bytecode.m_srcDst).jsValue();</span>
<span class="line-added"> 488     Variant&lt;JSBigInt*, double&gt; resultVariant = argument.toNumeric(globalObject);</span>
<span class="line-added"> 489     CHECK_EXCEPTION();</span>
<span class="line-added"> 490     JSValue result;</span>
<span class="line-added"> 491     if (WTF::holds_alternative&lt;JSBigInt*&gt;(resultVariant))</span>
<span class="line-added"> 492         result = JSBigInt::dec(globalObject, WTF::get&lt;JSBigInt*&gt;(resultVariant));</span>
<span class="line-added"> 493     else</span>
<span class="line-added"> 494         result = jsNumber(WTF::get&lt;double&gt;(resultVariant) - 1);</span>
<span class="line-added"> 495     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, result, { });</span>
 496 }
 497 
 498 SLOW_PATH_DECL(slow_path_to_string)
 499 {
 500     BEGIN();
 501     auto bytecode = pc-&gt;as&lt;OpToString&gt;();
<a name="53" id="anc53"></a><span class="line-modified"> 502     RETURN(GET_C(bytecode.m_operand).jsValue().toString(globalObject));</span>
 503 }
 504 
 505 #if ENABLE(JIT)
 506 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp; metadata, JSValue result, JSValue operand)
 507 {
<a name="54" id="anc54"></a><span class="line-modified"> 508     UnaryArithProfile&amp; profile = metadata.m_arithProfile;</span>
<span class="line-modified"> 509     profile.observeArg(operand);</span>
 510     ASSERT(result.isNumber() || result.isBigInt());
 511     if (result.isNumber()) {
 512         if (!result.isInt32()) {
 513             if (operand.isInt32())
 514                 profile.setObservedInt32Overflow();
 515 
 516             double doubleVal = result.asNumber();
 517             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 518                 profile.setObservedNegZeroDouble();
 519             else {
 520                 profile.setObservedNonNegZeroDouble();
 521 
 522                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 523                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 524                 // done to simplify the checking algorithm.
 525                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 526                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 527                 if (int64Val &gt;= int52OverflowPoint)
 528                     profile.setObservedInt52Overflow();
 529             }
 530         }
 531     } else if (result.isBigInt())
 532         profile.setObservedBigInt();
 533     else
 534         profile.setObservedNonNumeric();
 535 }
 536 #else
 537 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp;, JSValue, JSValue) { }
 538 #endif
 539 
 540 SLOW_PATH_DECL(slow_path_negate)
 541 {
 542     BEGIN();
 543     auto bytecode = pc-&gt;as&lt;OpNegate&gt;();
<a name="55" id="anc55"></a><span class="line-modified"> 544     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
 545     JSValue operand = GET_C(bytecode.m_operand).jsValue();
<a name="56" id="anc56"></a><span class="line-modified"> 546     JSValue primValue = operand.toPrimitive(globalObject, PreferNumber);</span>
 547     CHECK_EXCEPTION();
 548 
 549     if (primValue.isBigInt()) {
 550         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
 551         RETURN_WITH_PROFILING(result, {
 552             updateArithProfileForUnaryArithOp(metadata, result, operand);
 553         });
 554     }
 555 
<a name="57" id="anc57"></a><span class="line-modified"> 556     JSValue result = jsNumber(-primValue.toNumber(globalObject));</span>
 557     CHECK_EXCEPTION();
 558     RETURN_WITH_PROFILING(result, {
 559         updateArithProfileForUnaryArithOp(metadata, result, operand);
 560     });
 561 }
 562 
 563 #if ENABLE(DFG_JIT)
<a name="58" id="anc58"></a><span class="line-modified"> 564 static void updateArithProfileForBinaryArithOp(JSGlobalObject*, CodeBlock* codeBlock, const Instruction* pc, JSValue result, JSValue left, JSValue right)</span>
 565 {
<a name="59" id="anc59"></a><span class="line-modified"> 566     BinaryArithProfile&amp; profile = *codeBlock-&gt;binaryArithProfileForPC(pc);</span>

 567 
 568     if (result.isNumber()) {
 569         if (!result.isInt32()) {
 570             if (left.isInt32() &amp;&amp; right.isInt32())
 571                 profile.setObservedInt32Overflow();
 572 
 573             double doubleVal = result.asNumber();
 574             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 575                 profile.setObservedNegZeroDouble();
 576             else {
 577                 profile.setObservedNonNegZeroDouble();
 578 
 579                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 580                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 581                 // done to simplify the checking algorithm.
 582                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 583                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 584                 if (int64Val &gt;= int52OverflowPoint)
 585                     profile.setObservedInt52Overflow();
 586             }
 587         }
 588     } else if (result.isBigInt())
 589         profile.setObservedBigInt();
 590     else
 591         profile.setObservedNonNumeric();
 592 }
 593 #else
<a name="60" id="anc60"></a><span class="line-modified"> 594 static void updateArithProfileForBinaryArithOp(JSGlobalObject*, CodeBlock*, const Instruction*, JSValue, JSValue, JSValue) { }</span>
 595 #endif
 596 
 597 SLOW_PATH_DECL(slow_path_to_number)
 598 {
 599     BEGIN();
 600     auto bytecode = pc-&gt;as&lt;OpToNumber&gt;();
 601     JSValue argument = GET_C(bytecode.m_operand).jsValue();
<a name="61" id="anc61"></a><span class="line-modified"> 602     JSValue result = jsNumber(argument.toNumber(globalObject));</span>
<span class="line-added"> 603     RETURN_PROFILED(result);</span>
<span class="line-added"> 604 }</span>
<span class="line-added"> 605 </span>
<span class="line-added"> 606 SLOW_PATH_DECL(slow_path_to_numeric)</span>
<span class="line-added"> 607 {</span>
<span class="line-added"> 608     BEGIN();</span>
<span class="line-added"> 609     auto bytecode = pc-&gt;as&lt;OpToNumeric&gt;();</span>
<span class="line-added"> 610     JSValue argument = GET_C(bytecode.m_operand).jsValue();</span>
<span class="line-added"> 611     Variant&lt;JSBigInt*, double&gt; resultVariant = argument.toNumeric(globalObject);</span>
<span class="line-added"> 612     CHECK_EXCEPTION();</span>
<span class="line-added"> 613     JSValue result;</span>
<span class="line-added"> 614     if (WTF::holds_alternative&lt;JSBigInt*&gt;(resultVariant))</span>
<span class="line-added"> 615         result = WTF::get&lt;JSBigInt*&gt;(resultVariant);</span>
<span class="line-added"> 616     else</span>
<span class="line-added"> 617         result = jsNumber(WTF::get&lt;double&gt;(resultVariant));</span>
 618     RETURN_PROFILED(result);
 619 }
 620 
 621 SLOW_PATH_DECL(slow_path_to_object)
 622 {
 623     BEGIN();
 624     auto bytecode = pc-&gt;as&lt;OpToObject&gt;();
 625     JSValue argument = GET_C(bytecode.m_operand).jsValue();
 626     if (UNLIKELY(argument.isUndefinedOrNull())) {
<a name="62" id="anc62"></a><span class="line-modified"> 627         const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_message);</span>
 628         if (!ident.isEmpty())
<a name="63" id="anc63"></a><span class="line-modified"> 629             THROW(createTypeError(globalObject, ident.impl()));</span>
 630     }
<a name="64" id="anc64"></a><span class="line-modified"> 631     JSObject* result = argument.toObject(globalObject);</span>
 632     RETURN_PROFILED(result);
 633 }
 634 
 635 SLOW_PATH_DECL(slow_path_add)
 636 {
 637     BEGIN();
 638     auto bytecode = pc-&gt;as&lt;OpAdd&gt;();
 639     JSValue v1 = GET_C(bytecode.m_lhs).jsValue();
 640     JSValue v2 = GET_C(bytecode.m_rhs).jsValue();
 641 
<a name="65" id="anc65"></a><span class="line-modified"> 642     BinaryArithProfile&amp; arithProfile = *codeBlock-&gt;binaryArithProfileForPC(pc);</span>
 643     arithProfile.observeLHSAndRHS(v1, v2);
 644 
<a name="66" id="anc66"></a><span class="line-modified"> 645     JSValue result = jsAdd(globalObject, v1, v2);</span>
 646 
 647     RETURN_WITH_PROFILING(result, {
<a name="67" id="anc67"></a><span class="line-modified"> 648         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, v1, v2);</span>
 649     });
 650 }
 651 
 652 // The following arithmetic and bitwise operations need to be sure to run
 653 // toNumber() on their operands in order.  (A call to toNumber() is idempotent
<a name="68" id="anc68"></a><span class="line-modified"> 654 // if an exception is already set on the CallFrame.)</span>
 655 
 656 SLOW_PATH_DECL(slow_path_mul)
 657 {
 658     BEGIN();
 659     auto bytecode = pc-&gt;as&lt;OpMul&gt;();
 660     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 661     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="69" id="anc69"></a><span class="line-modified"> 662     JSValue result = jsMul(globalObject, left, right);</span>
 663     CHECK_EXCEPTION();
 664     RETURN_WITH_PROFILING(result, {
<a name="70" id="anc70"></a><span class="line-modified"> 665         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
 666     });
 667 }
 668 
 669 SLOW_PATH_DECL(slow_path_sub)
 670 {
 671     BEGIN();
 672     auto bytecode = pc-&gt;as&lt;OpSub&gt;();
 673     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 674     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="71" id="anc71"></a><span class="line-modified"> 675     auto leftNumeric = left.toNumeric(globalObject);</span>
 676     CHECK_EXCEPTION();
<a name="72" id="anc72"></a><span class="line-modified"> 677     auto rightNumeric = right.toNumeric(globalObject);</span>
 678     CHECK_EXCEPTION();
 679 
 680     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 681         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="73" id="anc73"></a><span class="line-modified"> 682             JSBigInt* result = JSBigInt::sub(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 683             CHECK_EXCEPTION();
 684             RETURN_WITH_PROFILING(result, {
<a name="74" id="anc74"></a><span class="line-modified"> 685                 updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
 686             });
 687         }
 688 
<a name="75" id="anc75"></a><span class="line-modified"> 689         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in subtraction.&quot;));</span>
 690     }
 691 
 692     JSValue result = jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
 693     RETURN_WITH_PROFILING(result, {
<a name="76" id="anc76"></a><span class="line-modified"> 694         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
 695     });
 696 }
 697 
 698 SLOW_PATH_DECL(slow_path_div)
 699 {
 700     BEGIN();
 701     auto bytecode = pc-&gt;as&lt;OpDiv&gt;();
 702     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 703     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="77" id="anc77"></a><span class="line-modified"> 704     auto leftNumeric = left.toNumeric(globalObject);</span>
 705     CHECK_EXCEPTION();
<a name="78" id="anc78"></a><span class="line-modified"> 706     auto rightNumeric = right.toNumeric(globalObject);</span>
 707     CHECK_EXCEPTION();
 708 
 709     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 710         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="79" id="anc79"></a><span class="line-modified"> 711             JSBigInt* result = JSBigInt::divide(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 712             CHECK_EXCEPTION();
 713             RETURN_WITH_PROFILING(result, {
<a name="80" id="anc80"></a><span class="line-modified"> 714                 updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
 715             });
 716         }
 717 
<a name="81" id="anc81"></a><span class="line-modified"> 718         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in division.&quot;));</span>
 719     }
 720 
 721     double a = WTF::get&lt;double&gt;(leftNumeric);
 722     double b = WTF::get&lt;double&gt;(rightNumeric);
 723     JSValue result = jsNumber(a / b);
 724     RETURN_WITH_PROFILING(result, {
<a name="82" id="anc82"></a><span class="line-modified"> 725         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
 726     });
 727 }
 728 
 729 SLOW_PATH_DECL(slow_path_mod)
 730 {
 731     BEGIN();
 732     auto bytecode = pc-&gt;as&lt;OpMod&gt;();
 733     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 734     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="83" id="anc83"></a><span class="line-modified"> 735     auto leftNumeric = left.toNumeric(globalObject);</span>
 736     CHECK_EXCEPTION();
<a name="84" id="anc84"></a><span class="line-modified"> 737     auto rightNumeric = right.toNumeric(globalObject);</span>
 738     CHECK_EXCEPTION();
 739 
 740     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 741         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="85" id="anc85"></a><span class="line-modified"> 742             JSBigInt* result = JSBigInt::remainder(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 743             CHECK_EXCEPTION();
 744             RETURN(result);
 745         }
 746 
<a name="86" id="anc86"></a><span class="line-modified"> 747         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;));</span>
 748     }
 749 
 750     double a = WTF::get&lt;double&gt;(leftNumeric);
 751     double b = WTF::get&lt;double&gt;(rightNumeric);
 752     RETURN(jsNumber(jsMod(a, b)));
 753 }
 754 
 755 SLOW_PATH_DECL(slow_path_pow)
 756 {
 757     BEGIN();
 758     auto bytecode = pc-&gt;as&lt;OpPow&gt;();
 759     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 760     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="87" id="anc87"></a><span class="line-modified"> 761     auto leftNumeric = left.toNumeric(globalObject);</span>
 762     CHECK_EXCEPTION();
<a name="88" id="anc88"></a><span class="line-modified"> 763     auto rightNumeric = right.toNumeric(globalObject);</span>
 764     CHECK_EXCEPTION();
 765 
 766     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 767         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="89" id="anc89"></a><span class="line-modified"> 768             JSBigInt* result = JSBigInt::exponentiate(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 769             CHECK_EXCEPTION();
 770             RETURN(result);
 771         }
 772 
<a name="90" id="anc90"></a><span class="line-modified"> 773         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;));</span>
 774     }
 775 
 776     double a = WTF::get&lt;double&gt;(leftNumeric);
 777     double b = WTF::get&lt;double&gt;(rightNumeric);
 778 
 779     RETURN(jsNumber(operationMathPow(a, b)));
 780 }
 781 
 782 SLOW_PATH_DECL(slow_path_lshift)
 783 {
 784     BEGIN();
 785     auto bytecode = pc-&gt;as&lt;OpLshift&gt;();
 786     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 787     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="91" id="anc91"></a><span class="line-modified"> 788     auto leftNumeric = left.toBigIntOrInt32(globalObject);</span>
 789     CHECK_EXCEPTION();
<a name="92" id="anc92"></a><span class="line-modified"> 790     auto rightNumeric = right.toBigIntOrInt32(globalObject);</span>
 791     CHECK_EXCEPTION();
 792 
 793     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 794         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="93" id="anc93"></a><span class="line-modified"> 795             JSBigInt* result = JSBigInt::leftShift(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 796             CHECK_EXCEPTION();
 797             RETURN_PROFILED(result);
 798         }
 799 
<a name="94" id="anc94"></a><span class="line-modified"> 800         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;));</span>
 801     }
 802 
 803     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &lt;&lt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));
 804 }
 805 
 806 SLOW_PATH_DECL(slow_path_rshift)
 807 {
 808     BEGIN();
 809     auto bytecode = pc-&gt;as&lt;OpRshift&gt;();
 810     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 811     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<a name="95" id="anc95"></a><span class="line-modified"> 812     auto leftNumeric = left.toBigIntOrInt32(globalObject);</span>
 813     CHECK_EXCEPTION();
<a name="96" id="anc96"></a><span class="line-modified"> 814     auto rightNumeric = right.toBigIntOrInt32(globalObject);</span>
 815     CHECK_EXCEPTION();
 816 
 817     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 818         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="97" id="anc97"></a><span class="line-modified"> 819             JSBigInt* result = JSBigInt::signedRightShift(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 820             CHECK_EXCEPTION();
<a name="98" id="anc98"></a><span class="line-modified"> 821             RETURN_PROFILED(result);</span>
 822         }
 823 
<a name="99" id="anc99"></a><span class="line-modified"> 824         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in signed right shift operation.&quot;_s));</span>
 825     }
 826 
<a name="100" id="anc100"></a><span class="line-modified"> 827     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &gt;&gt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));</span>
 828 }
 829 
 830 SLOW_PATH_DECL(slow_path_urshift)
 831 {
 832     BEGIN();
 833     auto bytecode = pc-&gt;as&lt;OpUrshift&gt;();
<a name="101" id="anc101"></a><span class="line-modified"> 834     uint32_t a = GET_C(bytecode.m_lhs).jsValue().toUInt32(globalObject);</span>
 835     if (UNLIKELY(throwScope.exception()))
 836         RETURN(JSValue());
<a name="102" id="anc102"></a><span class="line-modified"> 837     uint32_t b = GET_C(bytecode.m_rhs).jsValue().toUInt32(globalObject);</span>
 838     RETURN(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 31))));
 839 }
 840 
 841 SLOW_PATH_DECL(slow_path_unsigned)
 842 {
 843     BEGIN();
 844     auto bytecode = pc-&gt;as&lt;OpUnsigned&gt;();
<a name="103" id="anc103"></a><span class="line-modified"> 845     uint32_t a = GET_C(bytecode.m_operand).jsValue().toUInt32(globalObject);</span>
 846     RETURN(jsNumber(a));
 847 }
 848 
 849 SLOW_PATH_DECL(slow_path_bitnot)
 850 {
 851     BEGIN();
 852     auto bytecode = pc-&gt;as&lt;OpBitnot&gt;();
<a name="104" id="anc104"></a><span class="line-modified"> 853     auto operandNumeric = GET_C(bytecode.m_operand).jsValue().toBigIntOrInt32(globalObject);</span>
 854     CHECK_EXCEPTION();
 855 
 856     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric)) {
<a name="105" id="anc105"></a><span class="line-modified"> 857         JSBigInt* result = JSBigInt::bitwiseNot(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric));</span>
 858         CHECK_EXCEPTION();
 859         RETURN_PROFILED(result);
 860     }
 861 
 862     RETURN_PROFILED(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
 863 }
 864 
 865 SLOW_PATH_DECL(slow_path_bitand)
 866 {
 867     BEGIN();
 868     auto bytecode = pc-&gt;as&lt;OpBitand&gt;();
<a name="106" id="anc106"></a><span class="line-modified"> 869     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(globalObject);</span>
 870     CHECK_EXCEPTION();
<a name="107" id="anc107"></a><span class="line-modified"> 871     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(globalObject);</span>
 872     CHECK_EXCEPTION();
 873     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 874         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="108" id="anc108"></a><span class="line-modified"> 875             JSBigInt* result = JSBigInt::bitwiseAnd(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 876             CHECK_EXCEPTION();
 877             RETURN_PROFILED(result);
 878         }
 879 
<a name="109" id="anc109"></a><span class="line-modified"> 880         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;));</span>
 881     }
 882 
 883     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &amp; WTF::get&lt;int32_t&gt;(rightNumeric)));
 884 }
 885 
 886 SLOW_PATH_DECL(slow_path_bitor)
 887 {
 888     BEGIN();
 889     auto bytecode = pc-&gt;as&lt;OpBitor&gt;();
<a name="110" id="anc110"></a><span class="line-modified"> 890     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(globalObject);</span>
 891     CHECK_EXCEPTION();
<a name="111" id="anc111"></a><span class="line-modified"> 892     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(globalObject);</span>
 893     CHECK_EXCEPTION();
 894     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 895         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="112" id="anc112"></a><span class="line-modified"> 896             JSBigInt* result = JSBigInt::bitwiseOr(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 897             CHECK_EXCEPTION();
 898             RETURN_PROFILED(result);
 899         }
 900 
<a name="113" id="anc113"></a><span class="line-modified"> 901         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;));</span>
 902     }
 903 
 904     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) | WTF::get&lt;int32_t&gt;(rightNumeric)));
 905 }
 906 
 907 SLOW_PATH_DECL(slow_path_bitxor)
 908 {
 909     BEGIN();
 910     auto bytecode = pc-&gt;as&lt;OpBitxor&gt;();
<a name="114" id="anc114"></a><span class="line-modified"> 911     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(globalObject);</span>
 912     CHECK_EXCEPTION();
<a name="115" id="anc115"></a><span class="line-modified"> 913     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(globalObject);</span>
 914     CHECK_EXCEPTION();
 915     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 916         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<a name="116" id="anc116"></a><span class="line-modified"> 917             JSBigInt* result = JSBigInt::bitwiseXor(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 918             CHECK_EXCEPTION();
 919             RETURN_PROFILED(result);
 920         }
 921 
<a name="117" id="anc117"></a><span class="line-modified"> 922         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;));</span>
 923     }
 924 
 925     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) ^ WTF::get&lt;int32_t&gt;(rightNumeric)));
 926 }
 927 
 928 SLOW_PATH_DECL(slow_path_typeof)
 929 {
 930     BEGIN();
 931     auto bytecode = pc-&gt;as&lt;OpTypeof&gt;();
<a name="118" id="anc118"></a><span class="line-modified"> 932     RETURN(jsTypeStringForValue(globalObject, GET_C(bytecode.m_value).jsValue()));</span>
 933 }
 934 
 935 SLOW_PATH_DECL(slow_path_is_object_or_null)
 936 {
 937     BEGIN();
 938     auto bytecode = pc-&gt;as&lt;OpIsObjectOrNull&gt;();
<a name="119" id="anc119"></a><span class="line-modified"> 939     RETURN(jsBoolean(jsIsObjectTypeOrNull(globalObject, GET_C(bytecode.m_operand).jsValue())));</span>
 940 }
 941 
 942 SLOW_PATH_DECL(slow_path_is_function)
 943 {
 944     BEGIN();
 945     auto bytecode = pc-&gt;as&lt;OpIsFunction&gt;();
 946     RETURN(jsBoolean(GET_C(bytecode.m_operand).jsValue().isFunction(vm)));
 947 }
 948 
 949 SLOW_PATH_DECL(slow_path_in_by_val)
 950 {
 951     BEGIN();
 952     auto bytecode = pc-&gt;as&lt;OpInByVal&gt;();
<a name="120" id="anc120"></a><span class="line-modified"> 953     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified"> 954     RETURN(jsBoolean(CommonSlowPaths::opInByVal(globalObject, GET_C(bytecode.m_base).jsValue(), GET_C(bytecode.m_property).jsValue(), &amp;metadata.m_arrayProfile)));</span>
 955 }
 956 
 957 SLOW_PATH_DECL(slow_path_in_by_id)
 958 {
 959     BEGIN();
 960 
 961     auto bytecode = pc-&gt;as&lt;OpInById&gt;();
 962     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 963     if (!baseValue.isObject())
<a name="121" id="anc121"></a><span class="line-modified"> 964         THROW(createInvalidInParameterError(globalObject, baseValue));</span>
 965 
<a name="122" id="anc122"></a><span class="line-modified"> 966     RETURN(jsBoolean(asObject(baseValue)-&gt;hasProperty(globalObject, codeBlock-&gt;identifier(bytecode.m_property))));</span>
 967 }
 968 
 969 SLOW_PATH_DECL(slow_path_del_by_val)
 970 {
 971     BEGIN();
 972     auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
 973     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
<a name="123" id="anc123"></a><span class="line-modified"> 974     JSObject* baseObject = baseValue.toObject(globalObject);</span>
 975     CHECK_EXCEPTION();
 976 
 977     JSValue subscript = GET_C(bytecode.m_property).jsValue();
 978 
 979     bool couldDelete;
 980 
 981     uint32_t i;
 982     if (subscript.getUInt32(i))
<a name="124" id="anc124"></a><span class="line-modified"> 983         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, globalObject, i);</span>
 984     else {
 985         CHECK_EXCEPTION();
<a name="125" id="anc125"></a><span class="line-modified"> 986         auto property = subscript.toPropertyKey(globalObject);</span>
 987         CHECK_EXCEPTION();
<a name="126" id="anc126"></a><span class="line-modified"> 988         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, globalObject, property);</span>
 989     }
<a name="127" id="anc127"></a><span class="line-added"> 990     CHECK_EXCEPTION();</span>
 991 
<a name="128" id="anc128"></a><span class="line-modified"> 992     if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())</span>
<span class="line-modified"> 993         THROW(createTypeError(globalObject, UnableToDeletePropertyError));</span>
 994 
 995     RETURN(jsBoolean(couldDelete));
 996 }
 997 
 998 SLOW_PATH_DECL(slow_path_strcat)
 999 {
1000     BEGIN();
1001     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
<a name="129" id="anc129"></a><span class="line-modified">1002     RETURN(jsStringFromRegisterArray(globalObject, &amp;GET(bytecode.m_src), bytecode.m_count));</span>
1003 }
1004 
1005 SLOW_PATH_DECL(slow_path_to_primitive)
1006 {
1007     BEGIN();
1008     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
<a name="130" id="anc130"></a><span class="line-modified">1009     RETURN(GET_C(bytecode.m_src).jsValue().toPrimitive(globalObject));</span>
<span class="line-added">1010 }</span>
<span class="line-added">1011 </span>
<span class="line-added">1012 SLOW_PATH_DECL(slow_path_enter)</span>
<span class="line-added">1013 {</span>
<span class="line-added">1014     BEGIN();</span>
<span class="line-added">1015     Heap::heap(codeBlock)-&gt;writeBarrier(codeBlock);</span>
<span class="line-added">1016     END();</span>
<span class="line-added">1017 }</span>
<span class="line-added">1018 </span>
<span class="line-added">1019 SLOW_PATH_DECL(slow_path_to_property_key)</span>
<span class="line-added">1020 {</span>
<span class="line-added">1021     BEGIN();</span>
<span class="line-added">1022     auto bytecode = pc-&gt;as&lt;OpToPropertyKey&gt;();</span>
<span class="line-added">1023     RETURN(GET_C(bytecode.m_src).jsValue().toPropertyKeyValue(globalObject));</span>
1024 }
1025 
1026 SLOW_PATH_DECL(slow_path_get_enumerable_length)
1027 {
1028     BEGIN();
1029     auto bytecode = pc-&gt;as&lt;OpGetEnumerableLength&gt;();
1030     JSValue enumeratorValue = GET(bytecode.m_base).jsValue();
1031     if (enumeratorValue.isUndefinedOrNull())
1032         RETURN(jsNumber(0));
1033 
1034     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(enumeratorValue.asCell());
1035 
1036     RETURN(jsNumber(enumerator-&gt;indexedLength()));
1037 }
1038 
1039 SLOW_PATH_DECL(slow_path_has_indexed_property)
1040 {
1041     BEGIN();
1042     auto bytecode = pc-&gt;as&lt;OpHasIndexedProperty&gt;();
<a name="131" id="anc131"></a><span class="line-modified">1043     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">1044     JSObject* base = GET(bytecode.m_base).jsValue().toObject(globalObject);</span>
1045     CHECK_EXCEPTION();
1046     JSValue property = GET(bytecode.m_property).jsValue();
1047     metadata.m_arrayProfile.observeStructure(base-&gt;structure(vm));
1048     ASSERT(property.isUInt32AsAnyInt());
<a name="132" id="anc132"></a><span class="line-modified">1049     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, property.asUInt32AsAnyInt(), PropertySlot::InternalMethodType::GetOwnProperty)));</span>
1050 }
1051 
1052 SLOW_PATH_DECL(slow_path_has_structure_property)
1053 {
1054     BEGIN();
1055     auto bytecode = pc-&gt;as&lt;OpHasStructureProperty&gt;();
<a name="133" id="anc133"></a><span class="line-modified">1056     JSObject* base = GET(bytecode.m_base).jsValue().toObject(globalObject);</span>
1057     CHECK_EXCEPTION();
1058     JSValue property = GET(bytecode.m_property).jsValue();
1059     ASSERT(property.isString());
1060     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
1061     if (base-&gt;structure(vm)-&gt;id() == enumerator-&gt;cachedStructureID())
1062         RETURN(jsBoolean(true));
1063     JSString* string = asString(property);
<a name="134" id="anc134"></a><span class="line-modified">1064     auto propertyName = string-&gt;toIdentifier(globalObject);</span>
1065     CHECK_EXCEPTION();
<a name="135" id="anc135"></a><span class="line-modified">1066     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
1067 }
1068 
1069 SLOW_PATH_DECL(slow_path_has_generic_property)
1070 {
1071     BEGIN();
1072     auto bytecode = pc-&gt;as&lt;OpHasGenericProperty&gt;();
<a name="136" id="anc136"></a><span class="line-modified">1073     JSObject* base = GET(bytecode.m_base).jsValue().toObject(globalObject);</span>
1074     CHECK_EXCEPTION();
1075     JSValue property = GET(bytecode.m_property).jsValue();
1076     ASSERT(property.isString());
1077     JSString* string = asString(property);
<a name="137" id="anc137"></a><span class="line-modified">1078     auto propertyName = string-&gt;toIdentifier(globalObject);</span>
1079     CHECK_EXCEPTION();
<a name="138" id="anc138"></a><span class="line-modified">1080     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
1081 }
1082 
1083 SLOW_PATH_DECL(slow_path_get_direct_pname)
1084 {
1085     BEGIN();
1086     auto bytecode = pc-&gt;as&lt;OpGetDirectPname&gt;();
1087     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1088     JSValue property = GET(bytecode.m_property).jsValue();
1089     ASSERT(property.isString());
1090     JSString* string = asString(property);
<a name="139" id="anc139"></a><span class="line-modified">1091     auto propertyName = string-&gt;toIdentifier(globalObject);</span>
1092     CHECK_EXCEPTION();
<a name="140" id="anc140"></a><span class="line-modified">1093     RETURN(baseValue.get(globalObject, propertyName));</span>
1094 }
1095 
1096 SLOW_PATH_DECL(slow_path_get_property_enumerator)
1097 {
1098     BEGIN();
1099     auto bytecode = pc-&gt;as&lt;OpGetPropertyEnumerator&gt;();
1100     JSValue baseValue = GET(bytecode.m_base).jsValue();
1101     if (baseValue.isUndefinedOrNull())
1102         RETURN(vm.emptyPropertyNameEnumerator());
1103 
<a name="141" id="anc141"></a><span class="line-modified">1104     JSObject* base = baseValue.toObject(globalObject);</span>
1105     CHECK_EXCEPTION();
1106 
<a name="142" id="anc142"></a><span class="line-modified">1107     RETURN(propertyNameEnumerator(globalObject, base));</span>
1108 }
1109 
1110 SLOW_PATH_DECL(slow_path_enumerator_structure_pname)
1111 {
1112     BEGIN();
1113     auto bytecode = pc-&gt;as&lt;OpEnumeratorStructurePname&gt;();
1114     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
1115     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
1116 
1117     JSString* propertyName = nullptr;
1118     if (index &lt; enumerator-&gt;endStructurePropertyIndex())
1119         propertyName = enumerator-&gt;propertyNameAtIndex(index);
1120     RETURN(propertyName ? propertyName : jsNull());
1121 }
1122 
1123 SLOW_PATH_DECL(slow_path_enumerator_generic_pname)
1124 {
1125     BEGIN();
1126     auto bytecode = pc-&gt;as&lt;OpEnumeratorGenericPname&gt;();
1127     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
1128     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
1129 
1130     JSString* propertyName = nullptr;
1131     if (enumerator-&gt;endStructurePropertyIndex() &lt;= index &amp;&amp; index &lt; enumerator-&gt;endGenericPropertyIndex())
1132         propertyName = enumerator-&gt;propertyNameAtIndex(index);
1133     RETURN(propertyName ? propertyName : jsNull());
1134 }
1135 
1136 SLOW_PATH_DECL(slow_path_to_index_string)
1137 {
1138     BEGIN();
1139     auto bytecode = pc-&gt;as&lt;OpToIndexString&gt;();
1140     JSValue indexValue = GET(bytecode.m_index).jsValue();
1141     ASSERT(indexValue.isUInt32AsAnyInt());
1142     RETURN(jsString(vm, Identifier::from(vm, indexValue.asUInt32AsAnyInt()).string()));
1143 }
1144 
1145 SLOW_PATH_DECL(slow_path_profile_type_clear_log)
1146 {
1147     BEGIN();
1148     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;LLInt log full.&quot;_s);
1149     END();
1150 }
1151 
1152 SLOW_PATH_DECL(slow_path_unreachable)
1153 {
1154     BEGIN();
1155     UNREACHABLE_FOR_PLATFORM();
1156     END();
1157 }
1158 
1159 SLOW_PATH_DECL(slow_path_create_lexical_environment)
1160 {
1161     BEGIN();
1162     auto bytecode = pc-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
<a name="143" id="anc143"></a><span class="line-modified">1163     JSScope* currentScope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>

1164     SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(GET_C(bytecode.m_symbolTable).jsValue());
1165     JSValue initialValue = GET_C(bytecode.m_initialValue).jsValue();
1166     ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
<a name="144" id="anc144"></a><span class="line-modified">1167     JSScope* newScope = JSLexicalEnvironment::create(vm, globalObject, currentScope, symbolTable, initialValue);</span>
1168     RETURN(newScope);
1169 }
1170 
1171 SLOW_PATH_DECL(slow_path_push_with_scope)
1172 {
1173     BEGIN();
1174     auto bytecode = pc-&gt;as&lt;OpPushWithScope&gt;();
<a name="145" id="anc145"></a><span class="line-modified">1175     JSObject* newScope = GET_C(bytecode.m_newScope).jsValue().toObject(globalObject);</span>
1176     CHECK_EXCEPTION();
1177 
<a name="146" id="anc146"></a><span class="line-modified">1178     JSScope* currentScope = callFrame-&gt;uncheckedR(bytecode.m_currentScope).Register::scope();</span>
<span class="line-modified">1179     RETURN(JSWithScope::create(vm, globalObject, currentScope, newScope));</span>

1180 }
1181 
1182 SLOW_PATH_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval)
1183 {
1184     BEGIN();
1185     auto bytecode = pc-&gt;as&lt;OpResolveScopeForHoistingFuncDeclInEval&gt;();
<a name="147" id="anc147"></a><span class="line-modified">1186     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);</span>
<span class="line-modified">1187     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
<span class="line-modified">1188     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, ident);</span>
1189 
1190     CHECK_EXCEPTION();
1191 
1192     RETURN(resolvedScope);
1193 }
1194 
1195 SLOW_PATH_DECL(slow_path_resolve_scope)
1196 {
1197     BEGIN();
1198     auto bytecode = pc-&gt;as&lt;OpResolveScope&gt;();
<a name="148" id="anc148"></a><span class="line-modified">1199     auto&amp; metadata = bytecode.metadata(codeBlock);</span>

1200     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<a name="149" id="anc149"></a><span class="line-modified">1201     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
<span class="line-modified">1202     JSObject* resolvedScope = JSScope::resolve(globalObject, scope, ident);</span>
1203     // Proxy can throw an error here, e.g. Proxy in with statement&#39;s @unscopables.
1204     CHECK_EXCEPTION();
1205 
1206     ResolveType resolveType = metadata.m_resolveType;
1207 
1208     // ModuleVar does not keep the scope register value alive in DFG.
1209     ASSERT(resolveType != ModuleVar);
1210 
1211     switch (resolveType) {
1212     case GlobalProperty:
1213     case GlobalPropertyWithVarInjectionChecks:
1214     case UnresolvedProperty:
1215     case UnresolvedPropertyWithVarInjectionChecks: {
1216         if (resolvedScope-&gt;isGlobalObject()) {
1217             JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(resolvedScope);
<a name="150" id="anc150"></a><span class="line-modified">1218             bool hasProperty = globalObject-&gt;hasProperty(globalObject, ident);</span>
1219             CHECK_EXCEPTION();
1220             if (hasProperty) {
1221                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1222                 metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
1223                 metadata.m_globalObject.set(vm, codeBlock, globalObject);
1224                 metadata.m_globalLexicalBindingEpoch = globalObject-&gt;globalLexicalBindingEpoch();
1225             }
1226         } else if (resolvedScope-&gt;isGlobalLexicalEnvironment()) {
1227             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(resolvedScope);
1228             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1229             metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;
1230             metadata.m_globalLexicalEnvironment.set(vm, codeBlock, globalLexicalEnvironment);
1231         }
1232         break;
1233     }
1234     default:
1235         break;
1236     }
1237 
1238     RETURN(resolvedScope);
1239 }
1240 
1241 SLOW_PATH_DECL(slow_path_create_rest)
1242 {
1243     BEGIN();
1244     auto bytecode = pc-&gt;as&lt;OpCreateRest&gt;();
1245     unsigned arraySize = GET_C(bytecode.m_arraySize).jsValue().asUInt32();
<a name="151" id="anc151"></a>
1246     Structure* structure = globalObject-&gt;restParameterStructure();
1247     unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
<a name="152" id="anc152"></a><span class="line-modified">1248     JSValue* argumentsToCopyRegion = callFrame-&gt;addressOfArgumentsStart() + numParamsToSkip;</span>
<span class="line-modified">1249     RETURN(constructArray(globalObject, structure, argumentsToCopyRegion, arraySize));</span>
1250 }
1251 
1252 SLOW_PATH_DECL(slow_path_get_by_id_with_this)
1253 {
1254     BEGIN();
1255     auto bytecode = pc-&gt;as&lt;OpGetByIdWithThis&gt;();
<a name="153" id="anc153"></a><span class="line-modified">1256     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);</span>
1257     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1258     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1259     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
<a name="154" id="anc154"></a><span class="line-modified">1260     JSValue result = baseValue.get(globalObject, ident, slot);</span>
1261     RETURN_PROFILED(result);
1262 }
1263 
1264 SLOW_PATH_DECL(slow_path_get_by_val_with_this)
1265 {
1266     BEGIN();
1267 
1268     auto bytecode = pc-&gt;as&lt;OpGetByValWithThis&gt;();
1269     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1270     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1271     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1272 
1273     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1274         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1275         if (JSCell::canUseFastGetOwnProperty(structure)) {
<a name="155" id="anc155"></a><span class="line-modified">1276             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(globalObject);</span>
1277             CHECK_EXCEPTION();
1278             if (existingAtomString) {
1279                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
1280                     RETURN_PROFILED(result);
1281             }
1282         }
1283     }
1284 
1285     PropertySlot slot(thisValue, PropertySlot::PropertySlot::InternalMethodType::Get);
1286     if (subscript.isUInt32()) {
1287         uint32_t i = subscript.asUInt32();
1288         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
<a name="156" id="anc156"></a><span class="line-modified">1289             RETURN_PROFILED(asString(baseValue)-&gt;getIndex(globalObject, i));</span>
1290 
<a name="157" id="anc157"></a><span class="line-modified">1291         RETURN_PROFILED(baseValue.get(globalObject, i, slot));</span>
1292     }
1293 
<a name="158" id="anc158"></a><span class="line-modified">1294     baseValue.requireObjectCoercible(globalObject);</span>
1295     CHECK_EXCEPTION();
<a name="159" id="anc159"></a><span class="line-modified">1296     auto property = subscript.toPropertyKey(globalObject);</span>
1297     CHECK_EXCEPTION();
<a name="160" id="anc160"></a><span class="line-modified">1298     RETURN_PROFILED(baseValue.get(globalObject, property, slot));</span>
1299 }
1300 
1301 SLOW_PATH_DECL(slow_path_put_by_id_with_this)
1302 {
1303     BEGIN();
1304     auto bytecode = pc-&gt;as&lt;OpPutByIdWithThis&gt;();
<a name="161" id="anc161"></a>
1305     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
1306     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1307     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1308     JSValue putValue = GET_C(bytecode.m_value).jsValue();
1309     PutPropertySlot slot(thisVal, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
<a name="162" id="anc162"></a><span class="line-modified">1310     baseValue.putInline(globalObject, ident, putValue, slot);</span>
1311     END();
1312 }
1313 
1314 SLOW_PATH_DECL(slow_path_put_by_val_with_this)
1315 {
1316     BEGIN();
1317     auto bytecode = pc-&gt;as&lt;OpPutByValWithThis&gt;();
1318     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1319     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1320     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1321     JSValue value = GET_C(bytecode.m_value).jsValue();
1322 
<a name="163" id="anc163"></a><span class="line-modified">1323     auto property = subscript.toPropertyKey(globalObject);</span>
1324     CHECK_EXCEPTION();
<a name="164" id="anc164"></a><span class="line-modified">1325     PutPropertySlot slot(thisValue, codeBlock-&gt;isStrictMode());</span>
<span class="line-modified">1326     baseValue.put(globalObject, property, value, slot);</span>
1327     END();
1328 }
1329 
1330 SLOW_PATH_DECL(slow_path_define_data_property)
1331 {
1332     BEGIN();
1333     auto bytecode = pc-&gt;as&lt;OpDefineDataProperty&gt;();
1334     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1335     JSValue property = GET_C(bytecode.m_property).jsValue();
1336     JSValue value = GET_C(bytecode.m_value).jsValue();
1337     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1338     ASSERT(attributes.isInt32());
1339 
<a name="165" id="anc165"></a><span class="line-modified">1340     auto propertyName = property.toPropertyKey(globalObject);</span>
1341     CHECK_EXCEPTION();
1342     PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes.asInt32()));
1343     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
<a name="166" id="anc166"></a><span class="line-modified">1344     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
1345     END();
1346 }
1347 
1348 SLOW_PATH_DECL(slow_path_define_accessor_property)
1349 {
1350     BEGIN();
1351     auto bytecode = pc-&gt;as&lt;OpDefineAccessorProperty&gt;();
1352     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1353     JSValue property = GET_C(bytecode.m_property).jsValue();
1354     JSValue getter = GET_C(bytecode.m_getter).jsValue();
1355     JSValue setter = GET_C(bytecode.m_setter).jsValue();
1356     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1357     ASSERT(attributes.isInt32());
1358 
<a name="167" id="anc167"></a><span class="line-modified">1359     auto propertyName = property.toPropertyKey(globalObject);</span>
1360     CHECK_EXCEPTION();
1361     PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes.asInt32()));
1362     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
<a name="168" id="anc168"></a><span class="line-modified">1363     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
1364     END();
1365 }
1366 
1367 SLOW_PATH_DECL(slow_path_throw_static_error)
1368 {
1369     BEGIN();
1370     auto bytecode = pc-&gt;as&lt;OpThrowStaticError&gt;();
1371     JSValue errorMessageValue = GET_C(bytecode.m_message).jsValue();
1372     RELEASE_ASSERT(errorMessageValue.isString());
<a name="169" id="anc169"></a><span class="line-modified">1373     String errorMessage = asString(errorMessageValue)-&gt;value(globalObject);</span>
1374     ErrorType errorType = bytecode.m_errorType;
<a name="170" id="anc170"></a><span class="line-modified">1375     THROW(createError(globalObject, errorType, errorMessage));</span>
1376 }
1377 
1378 SLOW_PATH_DECL(slow_path_new_array_with_spread)
1379 {
1380     BEGIN();
1381     auto bytecode = pc-&gt;as&lt;OpNewArrayWithSpread&gt;();
1382     int numItems = bytecode.m_argc;
1383     ASSERT(numItems &gt;= 0);
<a name="171" id="anc171"></a><span class="line-modified">1384     const BitVector&amp; bitVector = codeBlock-&gt;unlinkedCodeBlock()-&gt;bitVector(bytecode.m_bitVector);</span>
1385 
1386     JSValue* values = bitwise_cast&lt;JSValue*&gt;(&amp;GET(bytecode.m_argv));
1387 
<a name="172" id="anc172"></a><span class="line-added">1388     if (numItems == 1 &amp;&amp; bitVector.get(0)) {</span>
<span class="line-added">1389         Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous);</span>
<span class="line-added">1390         if (isCopyOnWrite(structure-&gt;indexingMode())) {</span>
<span class="line-added">1391             JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, jsCast&lt;JSImmutableButterfly*&gt;(values[0]));</span>
<span class="line-added">1392             RETURN(result);</span>
<span class="line-added">1393         }</span>
<span class="line-added">1394     }</span>
<span class="line-added">1395 </span>
1396     Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
1397     for (int i = 0; i &lt; numItems; i++) {
1398         if (bitVector.get(i)) {
1399             JSValue value = values[-i];
<a name="173" id="anc173"></a><span class="line-modified">1400             JSImmutableButterfly* array = jsCast&lt;JSImmutableButterfly*&gt;(value);</span>
<span class="line-modified">1401             checkedArraySize += array-&gt;publicLength();</span>
1402         } else
1403             checkedArraySize += 1;
1404     }
1405     if (UNLIKELY(checkedArraySize.hasOverflowed()))
<a name="174" id="anc174"></a><span class="line-modified">1406         THROW(createOutOfMemoryError(globalObject));</span>
1407 
1408     unsigned arraySize = checkedArraySize.unsafeGet();
1409     if (UNLIKELY(arraySize &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH))
<a name="175" id="anc175"></a><span class="line-modified">1410         THROW(createOutOfMemoryError(globalObject));</span>
1411 
<a name="176" id="anc176"></a>
1412     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
1413 
1414     JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
1415     if (UNLIKELY(!result))
<a name="177" id="anc177"></a><span class="line-modified">1416         THROW(createOutOfMemoryError(globalObject));</span>
1417     CHECK_EXCEPTION();
1418 
1419     unsigned index = 0;
1420     for (int i = 0; i &lt; numItems; i++) {
1421         JSValue value = values[-i];
1422         if (bitVector.get(i)) {
1423             // We are spreading.
<a name="178" id="anc178"></a><span class="line-modified">1424             JSImmutableButterfly* array = jsCast&lt;JSImmutableButterfly*&gt;(value);</span>
<span class="line-modified">1425             for (unsigned i = 0; i &lt; array-&gt;publicLength(); i++) {</span>
1426                 RELEASE_ASSERT(array-&gt;get(i));
<a name="179" id="anc179"></a><span class="line-modified">1427                 result-&gt;putDirectIndex(globalObject, index, array-&gt;get(i));</span>
1428                 CHECK_EXCEPTION();
1429                 ++index;
1430             }
1431         } else {
1432             // We are not spreading.
<a name="180" id="anc180"></a><span class="line-modified">1433             result-&gt;putDirectIndex(globalObject, index, value);</span>
1434             CHECK_EXCEPTION();
1435             ++index;
1436         }
1437     }
1438 
1439     RETURN(result);
1440 }
1441 
1442 SLOW_PATH_DECL(slow_path_new_array_buffer)
1443 {
1444     BEGIN();
1445     auto bytecode = pc-&gt;as&lt;OpNewArrayBuffer&gt;();
<a name="181" id="anc181"></a><span class="line-modified">1446     ASSERT(bytecode.m_immutableButterfly.isConstant());</span>
1447     JSImmutableButterfly* immutableButterfly = bitwise_cast&lt;JSImmutableButterfly*&gt;(GET_C(bytecode.m_immutableButterfly).jsValue().asCell());
<a name="182" id="anc182"></a><span class="line-modified">1448     auto&amp; profile = bytecode.metadata(codeBlock).m_arrayAllocationProfile;</span>
1449 
1450     IndexingType indexingMode = profile.selectIndexingType();
<a name="183" id="anc183"></a><span class="line-modified">1451     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);</span>
1452     ASSERT(isCopyOnWrite(indexingMode));
1453     ASSERT(!structure-&gt;outOfLineCapacity());
1454 
1455     if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
1456         auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
1457         for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); ++i)
1458             newButterfly-&gt;setIndex(vm, i, immutableButterfly-&gt;get(i));
1459         immutableButterfly = newButterfly;
<a name="184" id="anc184"></a>
1460 
1461         // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
1462         // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
1463         // a compilation thread.
1464         WTF::storeStoreFence();
<a name="185" id="anc185"></a><span class="line-modified">1465         codeBlock-&gt;constantRegister(bytecode.m_immutableButterfly).set(vm, codeBlock, immutableButterfly);</span>
1466         WTF::storeStoreFence();
1467     }
1468 
1469     JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
<a name="186" id="anc186"></a><span class="line-modified">1470     ASSERT(isCopyOnWrite(result-&gt;indexingMode()) || globalObject-&gt;isHavingABadTime());</span>
1471     ArrayAllocationProfile::updateLastAllocationFor(&amp;profile, result);
1472     RETURN(result);
1473 }
1474 
1475 SLOW_PATH_DECL(slow_path_spread)
1476 {
1477     BEGIN();
1478 
1479     auto bytecode = pc-&gt;as&lt;OpSpread&gt;();
1480     JSValue iterable = GET_C(bytecode.m_argument).jsValue();
1481 
1482     if (iterable.isCell() &amp;&amp; isJSArray(iterable.asCell())) {
1483         JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
1484         if (array-&gt;isIteratorProtocolFastAndNonObservable()) {
<a name="187" id="anc187"></a><span class="line-modified">1485             // JSImmutableButterfly::createFromArray does not consult the prototype chain,</span>
1486             // so we must be sure that not consulting the prototype chain would
1487             // produce the same value during iteration.
<a name="188" id="anc188"></a><span class="line-modified">1488             RETURN(JSImmutableButterfly::createFromArray(globalObject, vm, array));</span>
1489         }
1490     }
1491 
<a name="189" id="anc189"></a>

1492     JSArray* array;
1493     {
1494         JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
1495         CallData callData;
1496         CallType callType = JSC::getCallData(vm, iterationFunction, callData);
1497         ASSERT(callType != CallType::None);
1498 
1499         MarkedArgumentBuffer arguments;
1500         arguments.append(iterable);
1501         ASSERT(!arguments.hasOverflowed());
<a name="190" id="anc190"></a><span class="line-modified">1502         JSValue arrayResult = call(globalObject, iterationFunction, callType, callData, jsNull(), arguments);</span>
1503         CHECK_EXCEPTION();
1504         array = jsCast&lt;JSArray*&gt;(arrayResult);
1505     }
1506 
<a name="191" id="anc191"></a><span class="line-modified">1507     RETURN(JSImmutableButterfly::createFromArray(globalObject, vm, array));</span>
1508 }
1509 
1510 } // namespace JSC
<a name="192" id="anc192"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="192" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/WeakBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Weak.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WeakBlock.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/WeakBlock.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WeakBlock.h&quot;
 28 
 29 #include &quot;CellContainerInlines.h&quot;
 30 #include &quot;Heap.h&quot;
 31 #include &quot;HeapAnalyzer.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;JSObject.h&quot;
 34 #include &quot;WeakHandleOwner.h&quot;
 35 
 36 namespace JSC {
 37 


 38 WeakBlock* WeakBlock::create(Heap&amp; heap, CellContainer container)
 39 {
 40     heap.didAllocateBlock(WeakBlock::blockSize);
<span class="line-modified"> 41     return new (NotNull, fastMalloc(blockSize)) WeakBlock(container);</span>

 42 }
 43 
 44 void WeakBlock::destroy(Heap&amp; heap, WeakBlock* block)
 45 {
 46     block-&gt;~WeakBlock();
<span class="line-modified"> 47     fastFree(block);</span>
 48     heap.didFreeBlock(WeakBlock::blockSize);
 49 }
 50 
 51 WeakBlock::WeakBlock(CellContainer container)
 52     : DoublyLinkedListNode&lt;WeakBlock&gt;()
 53     , m_container(container)
 54 {
 55     for (size_t i = 0; i &lt; weakImplCount(); ++i) {
 56         WeakImpl* weakImpl = &amp;weakImpls()[i];
 57         new (NotNull, weakImpl) WeakImpl;
 58         addToFreeList(&amp;m_sweepResult.freeList, weakImpl);
 59     }
 60 
 61     ASSERT(isEmpty());
 62 }
 63 
 64 void WeakBlock::lastChanceToFinalize()
 65 {
 66     for (size_t i = 0; i &lt; weakImplCount(); ++i) {
 67         WeakImpl* weakImpl = &amp;weakImpls()[i];
</pre>
<hr />
<pre>
124             continue;
125 
126         visitor.appendUnbarriered(jsValue);
127 
128         if (UNLIKELY(visitor.isAnalyzingHeap())) {
129             if (jsValue.isCell())
130                 visitor.heapAnalyzer()-&gt;setOpaqueRootReachabilityReasonForCell(jsValue.asCell(), *reasonPtr);
131         }
132     }
133 }
134 
135 void WeakBlock::visit(SlotVisitor&amp; visitor)
136 {
137     // If a block is completely empty, a visit won&#39;t have any effect.
138     if (isEmpty())
139         return;
140 
141     // If this WeakBlock doesn&#39;t belong to a CellContainer, we won&#39;t even be here.
142     ASSERT(m_container);
143 
<span class="line-modified">144     if (m_container.isLargeAllocation())</span>
<span class="line-modified">145         specializedVisit(m_container.largeAllocation(), visitor);</span>
146     else
147         specializedVisit(m_container.markedBlock(), visitor);
148 }
149 
150 void WeakBlock::reap()
151 {
152     // If a block is completely empty, a reaping won&#39;t have any effect.
153     if (isEmpty())
154         return;
155 
156     // If this WeakBlock doesn&#39;t belong to a CellContainer, we won&#39;t even be here.
157     ASSERT(m_container);
158 
159     HeapVersion markingVersion = m_container.heap()-&gt;objectSpace().markingVersion();
160 
161     for (size_t i = 0; i &lt; weakImplCount(); ++i) {
162         WeakImpl* weakImpl = &amp;weakImpls()[i];
163         if (weakImpl-&gt;state() &gt; WeakImpl::Dead)
164             continue;
165 
</pre>
</td>
<td>
<hr />
<pre>
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WeakBlock.h&quot;
 28 
 29 #include &quot;CellContainerInlines.h&quot;
 30 #include &quot;Heap.h&quot;
 31 #include &quot;HeapAnalyzer.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;JSObject.h&quot;
 34 #include &quot;WeakHandleOwner.h&quot;
 35 
 36 namespace JSC {
 37 
<span class="line-added"> 38 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(WeakBlock);</span>
<span class="line-added"> 39 </span>
 40 WeakBlock* WeakBlock::create(Heap&amp; heap, CellContainer container)
 41 {
 42     heap.didAllocateBlock(WeakBlock::blockSize);
<span class="line-modified"> 43     return new (NotNull, WeakBlockMalloc::malloc(blockSize)) WeakBlock(container);</span>
<span class="line-added"> 44 </span>
 45 }
 46 
 47 void WeakBlock::destroy(Heap&amp; heap, WeakBlock* block)
 48 {
 49     block-&gt;~WeakBlock();
<span class="line-modified"> 50     WeakBlockMalloc::free(block);</span>
 51     heap.didFreeBlock(WeakBlock::blockSize);
 52 }
 53 
 54 WeakBlock::WeakBlock(CellContainer container)
 55     : DoublyLinkedListNode&lt;WeakBlock&gt;()
 56     , m_container(container)
 57 {
 58     for (size_t i = 0; i &lt; weakImplCount(); ++i) {
 59         WeakImpl* weakImpl = &amp;weakImpls()[i];
 60         new (NotNull, weakImpl) WeakImpl;
 61         addToFreeList(&amp;m_sweepResult.freeList, weakImpl);
 62     }
 63 
 64     ASSERT(isEmpty());
 65 }
 66 
 67 void WeakBlock::lastChanceToFinalize()
 68 {
 69     for (size_t i = 0; i &lt; weakImplCount(); ++i) {
 70         WeakImpl* weakImpl = &amp;weakImpls()[i];
</pre>
<hr />
<pre>
127             continue;
128 
129         visitor.appendUnbarriered(jsValue);
130 
131         if (UNLIKELY(visitor.isAnalyzingHeap())) {
132             if (jsValue.isCell())
133                 visitor.heapAnalyzer()-&gt;setOpaqueRootReachabilityReasonForCell(jsValue.asCell(), *reasonPtr);
134         }
135     }
136 }
137 
138 void WeakBlock::visit(SlotVisitor&amp; visitor)
139 {
140     // If a block is completely empty, a visit won&#39;t have any effect.
141     if (isEmpty())
142         return;
143 
144     // If this WeakBlock doesn&#39;t belong to a CellContainer, we won&#39;t even be here.
145     ASSERT(m_container);
146 
<span class="line-modified">147     if (m_container.isPreciseAllocation())</span>
<span class="line-modified">148         specializedVisit(m_container.preciseAllocation(), visitor);</span>
149     else
150         specializedVisit(m_container.markedBlock(), visitor);
151 }
152 
153 void WeakBlock::reap()
154 {
155     // If a block is completely empty, a reaping won&#39;t have any effect.
156     if (isEmpty())
157         return;
158 
159     // If this WeakBlock doesn&#39;t belong to a CellContainer, we won&#39;t even be here.
160     ASSERT(m_container);
161 
162     HeapVersion markingVersion = m_container.heap()-&gt;objectSpace().markingVersion();
163 
164     for (size_t i = 0; i &lt; weakImplCount(); ++i) {
165         WeakImpl* weakImpl = &amp;weakImpls()[i];
166         if (weakImpl-&gt;state() &gt; WeakImpl::Dead)
167             continue;
168 
</pre>
</td>
</tr>
</table>
<center><a href="Weak.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WeakBlock.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
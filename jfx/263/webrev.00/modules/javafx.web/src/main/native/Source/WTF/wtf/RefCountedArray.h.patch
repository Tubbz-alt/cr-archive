diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/RefCountedArray.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/RefCountedArray.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/RefCountedArray.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/RefCountedArray.h
@@ -41,10 +41,12 @@
 //    it's used for things that aren't quite POD according to the official
 //    defintion, such as JSC::Instruction.
 
 namespace WTF {
 
+DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RefCountedArray);
+
 template<typename T, typename PtrTraits = DumbPtrTraits<T>>
 class RefCountedArray {
     enum CommonCopyConstructorTag { CommonCopyConstructor };
 
 public:
@@ -65,11 +67,11 @@
             // NOTE: JSC's LowLevelInterpreter relies on this being nullptr when the size is zero.
             PtrTraits::exchange(m_data, nullptr);
             return;
         }
 
-        T* data = (static_cast<Header*>(fastMalloc(Header::size() + sizeof(T) * size)))->payload();
+        T* data = (static_cast<Header*>(RefCountedArrayMalloc::malloc(Header::size() + sizeof(T) * size)))->payload();
         m_data = data;
         Header::fromPayload(data)->refCount = 1;
         Header::fromPayload(data)->length = size;
         ASSERT(Header::fromPayload(data)->length == size);
         VectorTypeOperations<T>::initializeIfNonPOD(begin(), end());
@@ -92,11 +94,11 @@
         if (other.isEmpty()) {
             PtrTraits::exchange(m_data, nullptr);
             return;
         }
 
-        T* data = (static_cast<Header*>(fastMalloc(Header::size() + sizeof(T) * other.size())))->payload();
+        T* data = (static_cast<Header*>(RefCountedArrayMalloc::malloc(Header::size() + sizeof(T) * other.size())))->payload();
         m_data = data;
         Header::fromPayload(data)->refCount = 1;
         Header::fromPayload(data)->length = other.size();
         ASSERT(Header::fromPayload(data)->length == other.size());
         VectorTypeOperations<T>::uninitializedCopy(other.begin(), other.end(), data);
@@ -111,19 +113,43 @@
     RefCountedArray& operator=(const RefCountedArray& other)
     {
         return assign<PtrTraits>(other);
     }
 
+    template<size_t inlineCapacity, typename OverflowHandler>
+    RefCountedArray& operator=(const Vector<T, inlineCapacity, OverflowHandler>& other)
+    {
+        T* oldData = data();
+        if (other.isEmpty())
+            PtrTraits::exchange(m_data, nullptr);
+        else {
+            T* data = (static_cast<Header*>(RefCountedArrayMalloc::malloc(Header::size() + sizeof(T) * other.size())))->payload();
+            m_data = data;
+            Header::fromPayload(data)->refCount = 1;
+            Header::fromPayload(data)->length = other.size();
+            ASSERT(Header::fromPayload(data)->length == other.size());
+            VectorTypeOperations<T>::uninitializedCopy(other.begin(), other.end(), data);
+        }
+        if (!oldData)
+            return *this;
+        if (--Header::fromPayload(oldData)->refCount)
+            return *this;
+        VectorTypeOperations<T>::destruct(oldData, oldData + Header::fromPayload(oldData)->length);
+
+        RefCountedArrayMalloc::free(Header::fromPayload(oldData));
+        return *this;
+    }
+
     ~RefCountedArray()
     {
         if (!m_data)
             return;
         T* data = this->data();
         if (--Header::fromPayload(data)->refCount)
             return;
         VectorTypeOperations<T>::destruct(begin(), end());
-        fastFree(Header::fromPayload(data));
+        RefCountedArrayMalloc::free(Header::fromPayload(data));
     }
 
     unsigned refCount() const
     {
         if (!m_data)
@@ -136,10 +162,12 @@
         if (!m_data)
             return 0;
         return Header::fromPayload(data())->length;
     }
 
+    bool isEmpty() const { return size() == 0; }
+
     size_t byteSize() const { return size() * sizeof(T); }
 
     T* data() { return PtrTraits::unwrap(m_data); }
     T* begin() { return data(); }
     T* end()
@@ -167,10 +195,15 @@
     }
 
     T& operator[](size_t i) { return at(i); }
     const T& operator[](size_t i) const { return at(i); }
 
+    T& first() { return (*this)[0]; }
+    const T& first() const { return (*this)[0]; }
+    T& last() { return (*this)[size() - 1]; }
+    const T& last() const { return (*this)[size() - 1]; }
+
     template<typename OtherTraits = PtrTraits>
     bool operator==(const RefCountedArray<T, OtherTraits>& other) const
     {
         T* data = const_cast<T*>(this->data());
         T* otherData = const_cast<T*>(other.data());
@@ -203,11 +236,12 @@
         if (!oldData)
             return *this;
         if (--Header::fromPayload(oldData)->refCount)
             return *this;
         VectorTypeOperations<T>::destruct(oldData, oldData + Header::fromPayload(oldData)->length);
-        fastFree(Header::fromPayload(oldData));
+
+        RefCountedArrayMalloc::free(Header::fromPayload(oldData));
         return *this;
     }
 
     struct Header {
         unsigned refCount;

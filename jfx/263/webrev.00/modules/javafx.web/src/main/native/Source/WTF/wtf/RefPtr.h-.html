<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WTF/wtf/RefPtr.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 2005-2019 Apple Inc. All rights reserved.
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Library General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Library General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Library General Public License
 15  *  along with this library; see the file COPYING.LIB.  If not, write to
 16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  *  Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 // RefPtr is documented at http://webkit.org/coding/RefPtr.html
 22 
 23 #pragma once
 24 
 25 #include &lt;algorithm&gt;
 26 #include &lt;utility&gt;
 27 #include &lt;wtf/FastMalloc.h&gt;
 28 #include &lt;wtf/Ref.h&gt;
 29 
 30 namespace WTF {
 31 
 32 template&lt;typename T, typename PtrTraits&gt; class RefPtr;
 33 template&lt;typename T, typename PtrTraits = DumbPtrTraits&lt;T&gt;&gt; RefPtr&lt;T, PtrTraits&gt; adoptRef(T*);
 34 
 35 template&lt;typename T&gt; ALWAYS_INLINE void refIfNotNull(T* ptr)
 36 {
 37     if (LIKELY(ptr != nullptr))
 38         ptr-&gt;ref();
 39 }
 40 
 41 template&lt;typename T&gt; ALWAYS_INLINE void derefIfNotNull(T* ptr)
 42 {
 43     if (LIKELY(ptr != nullptr))
 44         ptr-&gt;deref();
 45 }
 46 
 47 template&lt;typename T, typename PtrTraits&gt;
 48 class RefPtr {
 49     WTF_MAKE_FAST_ALLOCATED;
 50 public:
 51     typedef T ValueType;
 52     typedef ValueType* PtrType;
 53 
 54     static constexpr bool isRefPtr = true;
 55 
 56     ALWAYS_INLINE constexpr RefPtr() : m_ptr(nullptr) { }
 57     ALWAYS_INLINE RefPtr(T* ptr) : m_ptr(ptr) { refIfNotNull(ptr); }
 58     ALWAYS_INLINE RefPtr(const RefPtr&amp; o) : m_ptr(o.m_ptr) { refIfNotNull(PtrTraits::unwrap(m_ptr)); }
 59     template&lt;typename X, typename Y&gt; RefPtr(const RefPtr&lt;X, Y&gt;&amp; o) : m_ptr(o.get()) { refIfNotNull(PtrTraits::unwrap(m_ptr)); }
 60 
 61     ALWAYS_INLINE RefPtr(RefPtr&amp;&amp; o) : m_ptr(o.leakRef()) { }
 62     template&lt;typename X, typename Y&gt; RefPtr(RefPtr&lt;X, Y&gt;&amp;&amp; o) : m_ptr(o.leakRef()) { }
 63     template&lt;typename X, typename Y&gt; RefPtr(Ref&lt;X, Y&gt;&amp;&amp;);
 64 
 65     // Hash table deleted values, which are only constructed and never copied or destroyed.
 66     RefPtr(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }
 67     bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }
 68 
 69     ALWAYS_INLINE ~RefPtr() { derefIfNotNull(PtrTraits::exchange(m_ptr, nullptr)); }
 70 
 71     T* get() const { return PtrTraits::unwrap(m_ptr); }
 72 
 73     Ref&lt;T&gt; releaseNonNull() { ASSERT(m_ptr); Ref&lt;T&gt; tmp(adoptRef(*m_ptr)); m_ptr = nullptr; return tmp; }
 74     Ref&lt;const T&gt; releaseConstNonNull() { ASSERT(m_ptr); Ref&lt;const T&gt; tmp(adoptRef(*m_ptr)); m_ptr = nullptr; return tmp; }
 75 
 76     T* leakRef() WARN_UNUSED_RETURN;
 77 
 78     T&amp; operator*() const { ASSERT(m_ptr); return *PtrTraits::unwrap(m_ptr); }
 79     ALWAYS_INLINE T* operator-&gt;() const { return PtrTraits::unwrap(m_ptr); }
 80 
 81     bool operator!() const { return !m_ptr; }
 82 
 83     // This conversion operator allows implicit conversion to bool but not to other integer types.
 84     typedef T* (RefPtr::*UnspecifiedBoolType);
 85     operator UnspecifiedBoolType() const { return m_ptr ? &amp;RefPtr::m_ptr : nullptr; }
 86 
 87     explicit operator bool() const { return !!m_ptr; }
 88 
 89     RefPtr&amp; operator=(const RefPtr&amp;);
 90     RefPtr&amp; operator=(T*);
 91     RefPtr&amp; operator=(std::nullptr_t);
 92     template&lt;typename X, typename Y&gt; RefPtr&amp; operator=(const RefPtr&lt;X, Y&gt;&amp;);
 93     RefPtr&amp; operator=(RefPtr&amp;&amp;);
 94     template&lt;typename X, typename Y&gt; RefPtr&amp; operator=(RefPtr&lt;X, Y&gt;&amp;&amp;);
 95     template&lt;typename X&gt; RefPtr&amp; operator=(Ref&lt;X&gt;&amp;&amp;);
 96 
 97     template&lt;typename X, typename Y&gt; void swap(RefPtr&lt;X, Y&gt;&amp;);
 98 
 99     static T* hashTableDeletedValue() { return reinterpret_cast&lt;T*&gt;(-1); }
100 
101     RefPtr copyRef() &amp;&amp; = delete;
102     RefPtr copyRef() const &amp; WARN_UNUSED_RETURN { return RefPtr(m_ptr); }
103 
104 private:
105     friend RefPtr adoptRef&lt;T, PtrTraits&gt;(T*);
106     template&lt;typename X, typename Y&gt; friend class RefPtr;
107 
108     enum AdoptTag { Adopt };
109     RefPtr(T* ptr, AdoptTag) : m_ptr(ptr) { }
110 
111     typename PtrTraits::StorageType m_ptr;
112 };
113 
114 template&lt;typename T, typename U&gt;
115 template&lt;typename X, typename Y&gt;
116 inline RefPtr&lt;T, U&gt;::RefPtr(Ref&lt;X, Y&gt;&amp;&amp; reference)
117     : m_ptr(&amp;reference.leakRef())
118 {
119 }
120 
121 template&lt;typename T, typename U&gt;
122 inline T* RefPtr&lt;T, U&gt;::leakRef()
123 {
124     return U::exchange(m_ptr, nullptr);
125 }
126 
127 template&lt;typename T, typename U&gt;
128 inline RefPtr&lt;T, U&gt;&amp; RefPtr&lt;T, U&gt;::operator=(const RefPtr&amp; o)
129 {
130     RefPtr ptr = o;
131     swap(ptr);
132     return *this;
133 }
134 
135 template&lt;typename T, typename U&gt;
136 template&lt;typename X, typename Y&gt;
137 inline RefPtr&lt;T, U&gt;&amp; RefPtr&lt;T, U&gt;::operator=(const RefPtr&lt;X, Y&gt;&amp; o)
138 {
139     RefPtr ptr = o;
140     swap(ptr);
141     return *this;
142 }
143 
144 template&lt;typename T, typename U&gt;
145 inline RefPtr&lt;T, U&gt;&amp; RefPtr&lt;T, U&gt;::operator=(T* optr)
146 {
147     RefPtr ptr = optr;
148     swap(ptr);
149     return *this;
150 }
151 
152 template&lt;typename T, typename U&gt;
153 inline RefPtr&lt;T, U&gt;&amp; RefPtr&lt;T, U&gt;::operator=(std::nullptr_t)
154 {
155     derefIfNotNull(U::exchange(m_ptr, nullptr));
156     return *this;
157 }
158 
159 template&lt;typename T, typename U&gt;
160 inline RefPtr&lt;T, U&gt;&amp; RefPtr&lt;T, U&gt;::operator=(RefPtr&amp;&amp; o)
161 {
162     RefPtr ptr = WTFMove(o);
163     swap(ptr);
164     return *this;
165 }
166 
167 template&lt;typename T, typename U&gt;
168 template&lt;typename X, typename Y&gt;
169 inline RefPtr&lt;T, U&gt;&amp; RefPtr&lt;T, U&gt;::operator=(RefPtr&lt;X, Y&gt;&amp;&amp; o)
170 {
171     RefPtr ptr = WTFMove(o);
172     swap(ptr);
173     return *this;
174 }
175 
176 template&lt;typename T, typename V&gt;
177 template&lt;typename U&gt;
178 inline RefPtr&lt;T, V&gt;&amp; RefPtr&lt;T, V&gt;::operator=(Ref&lt;U&gt;&amp;&amp; reference)
179 {
180     RefPtr ptr = WTFMove(reference);
181     swap(ptr);
182     return *this;
183 }
184 
185 template&lt;class T, typename U&gt;
186 template&lt;typename X, typename Y&gt;
187 inline void RefPtr&lt;T, U&gt;::swap(RefPtr&lt;X, Y&gt;&amp; o)
188 {
189     U::swap(m_ptr, o.m_ptr);
190 }
191 
192 template&lt;typename T, typename U, typename X, typename Y, typename = std::enable_if_t&lt;!std::is_same&lt;U, DumbPtrTraits&lt;T&gt;&gt;::value || !std::is_same&lt;Y, DumbPtrTraits&lt;X&gt;&gt;::value&gt;&gt;
193 inline void swap(RefPtr&lt;T, U&gt;&amp; a, RefPtr&lt;X, Y&gt;&amp; b)
194 {
195     a.swap(b);
196 }
197 
198 template&lt;typename T, typename U, typename X, typename Y&gt;
199 inline bool operator==(const RefPtr&lt;T, U&gt;&amp; a, const RefPtr&lt;X, Y&gt;&amp; b)
200 {
201     return a.get() == b.get();
202 }
203 
204 template&lt;typename T, typename U, typename X&gt;
205 inline bool operator==(const RefPtr&lt;T, U&gt;&amp; a, X* b)
206 {
207     return a.get() == b;
208 }
209 
210 template&lt;typename T, typename X, typename Y&gt;
211 inline bool operator==(T* a, const RefPtr&lt;X, Y&gt;&amp; b)
212 {
213     return a == b.get();
214 }
215 
216 template&lt;typename T, typename U, typename X, typename Y&gt;
217 inline bool operator!=(const RefPtr&lt;T, U&gt;&amp; a, const RefPtr&lt;X, Y&gt;&amp; b)
218 {
219     return a.get() != b.get();
220 }
221 
222 template&lt;typename T, typename U, typename X&gt;
223 inline bool operator!=(const RefPtr&lt;T, U&gt;&amp; a, X* b)
224 {
225     return a.get() != b;
226 }
227 
228 template&lt;typename T, typename X, typename Y&gt;
229 inline bool operator!=(T* a, const RefPtr&lt;X, Y&gt;&amp; b)
230 {
231     return a != b.get();
232 }
233 
234 template&lt;typename T, typename U = DumbPtrTraits&lt;T&gt;, typename X, typename Y&gt;
235 inline RefPtr&lt;T, U&gt; static_pointer_cast(const RefPtr&lt;X, Y&gt;&amp; p)
236 {
237     return RefPtr&lt;T, U&gt;(static_cast&lt;T*&gt;(p.get()));
238 }
239 
240 template &lt;typename T, typename U&gt;
241 struct IsSmartPtr&lt;RefPtr&lt;T, U&gt;&gt; {
242     static const bool value = true;
243 };
244 
245 template&lt;typename T, typename U&gt;
246 inline RefPtr&lt;T, U&gt; adoptRef(T* p)
247 {
248     adopted(p);
249     return RefPtr&lt;T, U&gt;(p, RefPtr&lt;T, U&gt;::Adopt);
250 }
251 
252 template&lt;typename T&gt; inline RefPtr&lt;T&gt; makeRefPtr(T* pointer)
253 {
254     return pointer;
255 }
256 
257 template&lt;typename T&gt; inline RefPtr&lt;T&gt; makeRefPtr(T&amp; reference)
258 {
259     return &amp;reference;
260 }
261 
262 template&lt;typename ExpectedType, typename ArgType, typename PtrTraits&gt;
263 inline bool is(RefPtr&lt;ArgType, PtrTraits&gt;&amp; source)
264 {
265     return is&lt;ExpectedType&gt;(source.get());
266 }
267 
268 template&lt;typename ExpectedType, typename ArgType, typename PtrTraits&gt;
269 inline bool is(const RefPtr&lt;ArgType, PtrTraits&gt;&amp; source)
270 {
271     return is&lt;ExpectedType&gt;(source.get());
272 }
273 
274 } // namespace WTF
275 
276 using WTF::RefPtr;
277 using WTF::adoptRef;
278 using WTF::makeRefPtr;
279 using WTF::static_pointer_cast;
    </pre>
  </body>
</html>
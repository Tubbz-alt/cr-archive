<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Logging.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MIMETypeRegistry.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;MIMETypeRegistry.h&quot;
 29 
 30 #include &quot;MediaPlayer.h&quot;

 31 #include &lt;wtf/HashMap.h&gt;
 32 #include &lt;wtf/MainThread.h&gt;
 33 #include &lt;wtf/NeverDestroyed.h&gt;
 34 #include &lt;wtf/StdLibExtras.h&gt;
 35 
 36 #if USE(CG)
 37 #include &quot;ImageSourceCG.h&quot;
 38 #include &quot;UTIRegistry.h&quot;
 39 #include &lt;ImageIO/ImageIO.h&gt;
 40 #include &lt;wtf/RetainPtr.h&gt;
 41 #endif
 42 
 43 #if USE(CG) &amp;&amp; PLATFORM(COCOA)
 44 #include &quot;UTIUtilities.h&quot;
 45 #endif
 46 
 47 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 48 #include &quot;ArchiveFactory.h&quot;
 49 #endif
 50 
</pre>
<hr />
<pre>
 58 #endif
 59 
 60 #if USE(APPLE_INTERNAL_SDK)
 61 #include &lt;WebKitAdditions/AdditionalSystemPreviewTypes.h&gt;
 62 #else
 63 #define ADDITIONAL_SYSTEM_PREVIEW_TYPES
 64 #endif
 65 
 66 namespace WebCore {
 67 
 68 const HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; MIMETypeRegistry::supportedImageMIMETypes()
 69 {
 70     static NeverDestroyed&lt;HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&gt; supportedImageMIMETypes = std::initializer_list&lt;String&gt; {
 71 #if USE(CG)
 72         // This represents the subset of allowed image UTIs for which CoreServices has a corresponding MIME type.
 73         &quot;image/tiff&quot;_s,
 74         &quot;image/gif&quot;_s,
 75         &quot;image/jpeg&quot;_s,
 76         &quot;image/vnd.microsoft.icon&quot;_s,
 77         &quot;image/jp2&quot;_s,

 78         &quot;image/png&quot;_s,
 79         &quot;image/bmp&quot;_s,
 80 
 81         &quot;image/x-icon&quot;_s, // Favicons don&#39;t have a MIME type in the registry either.
 82         &quot;image/pjpeg&quot;_s, //  We only get one MIME type per UTI, hence our need to add these manually
 83 
 84 #if PLATFORM(IOS_FAMILY)
 85         // Add malformed image mimetype for compatibility with Mail and to handle malformed mimetypes from the net
 86         // These were removed for &lt;rdar://problem/6564538&gt; Re-enable UTI code in WebCore now that MobileCoreServices exists
 87         // But Mail relies on at least image/tif reported as being supported (should be image/tiff).
 88         // This can be removed when Mail addresses:
 89         // &lt;rdar://problem/7879510&gt; Mail should use standard image mimetypes
 90         // and we fix sniffing so that it corrects items such as image/jpg -&gt; image/jpeg.
 91 
 92         // JPEG (image/jpeg)
 93         &quot;image/jpg&quot;_s,
 94         &quot;image/jp_&quot;_s,
 95         &quot;image/jpe_&quot;_s,
 96         &quot;application/jpg&quot;_s,
 97         &quot;application/x-jpg&quot;_s,
</pre>
<hr />
<pre>
118         // BMP (image/bmp, image/x-bitmap)
119         &quot;image/x-bmp&quot;_s,
120         &quot;image/x-win-bitmap&quot;_s,
121         &quot;image/x-windows-bmp&quot;_s,
122         &quot;image/ms-bmp&quot;_s,
123         &quot;image/x-ms-bmp&quot;_s,
124         &quot;application/bmp&quot;_s,
125         &quot;application/x-bmp&quot;_s,
126         &quot;application/x-win-bitmap&quot;_s,
127 #endif
128 #else
129         // assume that all implementations at least support the following standard
130         // image types:
131         &quot;image/jpeg&quot;_s,
132         &quot;image/png&quot;_s,
133         &quot;image/gif&quot;_s,
134         &quot;image/bmp&quot;_s,
135         &quot;image/vnd.microsoft.icon&quot;_s, // ico
136         &quot;image/x-icon&quot;_s, // ico
137         &quot;image/x-xbitmap&quot;_s, // xbm



138 #if USE(OPENJPEG)
139         &quot;image/jp2&quot;_s,
140         &quot;image/jpeg2000&quot;_s,
141 #endif
142 #if USE(WEBP)
143         &quot;image/webp&quot;_s,
144 #endif
145 #endif
146     };
147 
148 #if USE(CG)
149 #ifndef NDEBUG
150     // Esnure supportedImageMIMETypes() is in sync with defaultSupportedImageTypes().
151     static std::once_flag onceFlag;
152     std::call_once(onceFlag, [] {
153         for (auto&amp; imageType : defaultSupportedImageTypes()) {
154             auto mimeType = MIMETypeForImageType(imageType);
155             ASSERT_IMPLIES(!mimeType.isEmpty(), supportedImageMIMETypes.get().contains(mimeType));
156         }
157     });
158 #endif
159 #endif
160     return supportedImageMIMETypes;
161 }
162 
163 HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; MIMETypeRegistry::additionalSupportedImageMIMETypes()
164 {
165     static NeverDestroyed&lt;HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&gt; additionalSupportedImageMIMETypes;
166     return additionalSupportedImageMIMETypes;
167 }
168 
<span class="line-removed">169 static const HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; supportedImageMIMETypesForEncoding()</span>
<span class="line-removed">170 {</span>
<span class="line-removed">171 #if PLATFORM(COCOA)</span>
<span class="line-removed">172     static const auto supportedImageMIMETypesForEncoding = makeNeverDestroyed([] {</span>
<span class="line-removed">173         RetainPtr&lt;CFArrayRef&gt; supportedTypes = adoptCF(CGImageDestinationCopyTypeIdentifiers());</span>
<span class="line-removed">174         HashSet&lt;String, ASCIICaseInsensitiveHash&gt; supportedImageMIMETypesForEncoding;</span>
<span class="line-removed">175         CFIndex count = CFArrayGetCount(supportedTypes.get());</span>
<span class="line-removed">176         for (CFIndex i = 0; i &lt; count; i++) {</span>
<span class="line-removed">177             CFStringRef supportedType = reinterpret_cast&lt;CFStringRef&gt;(CFArrayGetValueAtIndex(supportedTypes.get(), i));</span>
<span class="line-removed">178             String mimeType = MIMETypeForImageType(supportedType);</span>
<span class="line-removed">179             if (!mimeType.isEmpty())</span>
<span class="line-removed">180                 supportedImageMIMETypesForEncoding.add(mimeType);</span>
<span class="line-removed">181         }</span>
<span class="line-removed">182         return supportedImageMIMETypesForEncoding;</span>
<span class="line-removed">183     }());</span>
<span class="line-removed">184 #else</span>
<span class="line-removed">185     static NeverDestroyed&lt;HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&gt; supportedImageMIMETypesForEncoding =std::initializer_list&lt;String&gt; {</span>
<span class="line-removed">186 #if USE(CG) || USE(DIRECT2D)</span>
<span class="line-removed">187         // FIXME: Add Windows support for all the supported UTI&#39;s when a way to convert from MIMEType to UTI reliably is found.</span>
<span class="line-removed">188         // For now, only support PNG, JPEG and GIF. See &lt;rdar://problem/6095286&gt;.</span>
<span class="line-removed">189         &quot;image/png&quot;_s,</span>
<span class="line-removed">190         &quot;image/jpeg&quot;_s,</span>
<span class="line-removed">191         &quot;image/gif&quot;_s,</span>
<span class="line-removed">192 #elif PLATFORM(JAVA)</span>
<span class="line-removed">193         &quot;image/png&quot;_s,</span>
<span class="line-removed">194         &quot;image/jpeg&quot;_s,</span>
<span class="line-removed">195         &quot;image/bmp&quot;_s,</span>
<span class="line-removed">196 #elif PLATFORM(GTK)</span>
<span class="line-removed">197         &quot;image/png&quot;_s,</span>
<span class="line-removed">198         &quot;image/jpeg&quot;_s,</span>
<span class="line-removed">199         &quot;image/tiff&quot;_s,</span>
<span class="line-removed">200         &quot;image/bmp&quot;_s,</span>
<span class="line-removed">201         &quot;image/ico&quot;_s,</span>
<span class="line-removed">202 #elif USE(CAIRO)</span>
<span class="line-removed">203         &quot;image/png&quot;_s,</span>
<span class="line-removed">204 #endif</span>
<span class="line-removed">205     };</span>
<span class="line-removed">206 #endif</span>
<span class="line-removed">207     return supportedImageMIMETypesForEncoding;</span>
<span class="line-removed">208 }</span>
<span class="line-removed">209 </span>
210 static const HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; supportedJavaScriptMIMETypes()
211 {
212     static NeverDestroyed&lt;HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&gt; supportedJavaScriptMIMETypes = std::initializer_list&lt;String&gt; {
213         // https://html.spec.whatwg.org/multipage/scripting.html#javascript-mime-type
214         &quot;text/javascript&quot;_s,
215         &quot;text/ecmascript&quot;_s,
216         &quot;application/javascript&quot;_s,
217         &quot;application/ecmascript&quot;_s,
218         &quot;application/x-javascript&quot;_s,
219         &quot;application/x-ecmascript&quot;_s,
220         &quot;text/javascript1.0&quot;_s,
221         &quot;text/javascript1.1&quot;_s,
222         &quot;text/javascript1.2&quot;_s,
223         &quot;text/javascript1.3&quot;_s,
224         &quot;text/javascript1.4&quot;_s,
225         &quot;text/javascript1.5&quot;_s,
226         &quot;text/jscript&quot;_s,
227         &quot;text/livescript&quot;_s,
228         &quot;text/x-javascript&quot;_s,
229         &quot;text/x-ecmascript&quot;_s,
</pre>
<hr />
<pre>
293         &quot;text/x-calendar&quot;_s,
294         &quot;text/x-vcalendar&quot;_s,
295         &quot;text/vcalendar&quot;_s,
296         &quot;text/vcard&quot;_s,
297         &quot;text/x-vcard&quot;_s,
298         &quot;text/directory&quot;_s,
299         &quot;text/ldif&quot;_s,
300         &quot;text/qif&quot;_s,
301         &quot;text/x-qif&quot;_s,
302         &quot;text/x-csv&quot;_s,
303         &quot;text/x-vcf&quot;_s,
304 #if !PLATFORM(IOS_FAMILY)
305         &quot;text/rtf&quot;_s,
306 #else
307         &quot;text/vnd.sun.j2me.app-descriptor&quot;_s,
308 #endif
309     };
310     return unsupportedTextMIMETypes;
311 }
312 
<span class="line-modified">313 static const Vector&lt;String&gt;* typesForCommonExtension(const String&amp; extension)</span>
<span class="line-modified">314 {</span>
<span class="line-modified">315     static const auto map = makeNeverDestroyed([] {</span>
<span class="line-modified">316         struct TypeExtensionPair {</span>
<span class="line-modified">317             ASCIILiteral type;</span>
<span class="line-modified">318             ASCIILiteral extension;</span>
<span class="line-modified">319         };</span>
<span class="line-modified">320 </span>
<span class="line-modified">321         // A table of common media MIME types and file extentions used when a platform&#39;s</span>
<span class="line-modified">322         // specific MIME type lookup doesn&#39;t have a match for a media file extension.</span>
<span class="line-modified">323         static const TypeExtensionPair commonMediaTypes[] = {</span>
<span class="line-modified">324             // Ogg</span>
<span class="line-modified">325             { &quot;application/ogg&quot;_s, &quot;ogx&quot;_s },</span>
<span class="line-modified">326             { &quot;audio/ogg&quot;_s, &quot;ogg&quot;_s },</span>
<span class="line-modified">327             { &quot;audio/ogg&quot;_s, &quot;oga&quot;_s },</span>
<span class="line-modified">328             { &quot;video/ogg&quot;_s, &quot;ogv&quot;_s },</span>
<span class="line-modified">329 </span>
<span class="line-modified">330             // Annodex</span>
<span class="line-modified">331             { &quot;application/annodex&quot;_s, &quot;anx&quot;_s },</span>
<span class="line-modified">332             { &quot;audio/annodex&quot;_s, &quot;axa&quot;_s },</span>
<span class="line-modified">333             { &quot;video/annodex&quot;_s, &quot;axv&quot;_s },</span>
<span class="line-modified">334             { &quot;audio/speex&quot;_s, &quot;spx&quot;_s },</span>
<span class="line-modified">335 </span>
<span class="line-modified">336             // WebM</span>
<span class="line-modified">337             { &quot;video/webm&quot;_s, &quot;webm&quot;_s },</span>
<span class="line-modified">338             { &quot;audio/webm&quot;_s, &quot;webm&quot;_s },</span>
<span class="line-modified">339 </span>
<span class="line-modified">340             // MPEG</span>
<span class="line-modified">341             { &quot;audio/mpeg&quot;_s, &quot;m1a&quot;_s },</span>
<span class="line-modified">342             { &quot;audio/mpeg&quot;_s, &quot;m2a&quot;_s },</span>
<span class="line-modified">343             { &quot;audio/mpeg&quot;_s, &quot;m1s&quot;_s },</span>
<span class="line-modified">344             { &quot;audio/mpeg&quot;_s, &quot;mpa&quot;_s },</span>
<span class="line-modified">345             { &quot;video/mpeg&quot;_s, &quot;mpg&quot;_s },</span>
<span class="line-modified">346             { &quot;video/mpeg&quot;_s, &quot;m15&quot;_s },</span>
<span class="line-modified">347             { &quot;video/mpeg&quot;_s, &quot;m1s&quot;_s },</span>
<span class="line-modified">348             { &quot;video/mpeg&quot;_s, &quot;m1v&quot;_s },</span>
<span class="line-modified">349             { &quot;video/mpeg&quot;_s, &quot;m75&quot;_s },</span>
<span class="line-modified">350             { &quot;video/mpeg&quot;_s, &quot;mpa&quot;_s },</span>
<span class="line-modified">351             { &quot;video/mpeg&quot;_s, &quot;mpeg&quot;_s },</span>
<span class="line-modified">352             { &quot;video/mpeg&quot;_s, &quot;mpm&quot;_s },</span>
<span class="line-modified">353             { &quot;video/mpeg&quot;_s, &quot;mpv&quot;_s },</span>
<span class="line-modified">354 </span>
<span class="line-modified">355             // MPEG playlist</span>
<span class="line-modified">356             { &quot;application/vnd.apple.mpegurl&quot;_s, &quot;m3u8&quot;_s },</span>
<span class="line-modified">357             { &quot;application/mpegurl&quot;_s, &quot;m3u8&quot;_s },</span>
<span class="line-modified">358             { &quot;application/x-mpegurl&quot;_s, &quot;m3u8&quot;_s },</span>
<span class="line-modified">359             { &quot;audio/mpegurl&quot;_s, &quot;m3url&quot;_s },</span>
<span class="line-modified">360             { &quot;audio/x-mpegurl&quot;_s, &quot;m3url&quot;_s },</span>
<span class="line-modified">361             { &quot;audio/mpegurl&quot;_s, &quot;m3u&quot;_s },</span>
<span class="line-modified">362             { &quot;audio/x-mpegurl&quot;_s, &quot;m3u&quot;_s },</span>
<span class="line-modified">363 </span>
<span class="line-modified">364             // MPEG-4</span>
<span class="line-modified">365             { &quot;video/x-m4v&quot;_s, &quot;m4v&quot;_s },</span>
<span class="line-modified">366             { &quot;audio/x-m4a&quot;_s, &quot;m4a&quot;_s },</span>
<span class="line-modified">367             { &quot;audio/x-m4b&quot;_s, &quot;m4b&quot;_s },</span>
<span class="line-modified">368             { &quot;audio/x-m4p&quot;_s, &quot;m4p&quot;_s },</span>
<span class="line-modified">369             { &quot;audio/mp4&quot;_s, &quot;m4a&quot;_s },</span>
<span class="line-modified">370 </span>
<span class="line-modified">371             // MP3</span>
<span class="line-modified">372             { &quot;audio/mp3&quot;_s, &quot;mp3&quot;_s },</span>
<span class="line-modified">373             { &quot;audio/x-mp3&quot;_s, &quot;mp3&quot;_s },</span>
<span class="line-modified">374             { &quot;audio/x-mpeg&quot;_s, &quot;mp3&quot;_s },</span>
<span class="line-modified">375 </span>
<span class="line-modified">376             // MPEG-2</span>
<span class="line-modified">377             { &quot;video/x-mpeg2&quot;_s, &quot;mp2&quot;_s },</span>
<span class="line-modified">378             { &quot;video/mpeg2&quot;_s, &quot;vob&quot;_s },</span>
<span class="line-modified">379             { &quot;video/mpeg2&quot;_s, &quot;mod&quot;_s },</span>
<span class="line-modified">380             { &quot;video/m2ts&quot;_s, &quot;m2ts&quot;_s },</span>
<span class="line-modified">381             { &quot;video/x-m2ts&quot;_s, &quot;m2t&quot;_s },</span>
<span class="line-modified">382             { &quot;video/x-m2ts&quot;_s, &quot;ts&quot;_s },</span>
<span class="line-modified">383 </span>
<span class="line-modified">384             // 3GP/3GP2</span>
<span class="line-modified">385             { &quot;audio/3gpp&quot;_s, &quot;3gpp&quot;_s },</span>
<span class="line-modified">386             { &quot;audio/3gpp2&quot;_s, &quot;3g2&quot;_s },</span>
<span class="line-modified">387             { &quot;application/x-mpeg&quot;_s, &quot;amc&quot;_s },</span>
<span class="line-modified">388 </span>
<span class="line-modified">389             // AAC</span>
<span class="line-modified">390             { &quot;audio/aac&quot;_s, &quot;aac&quot;_s },</span>
<span class="line-modified">391             { &quot;audio/aac&quot;_s, &quot;adts&quot;_s },</span>
<span class="line-modified">392             { &quot;audio/x-aac&quot;_s, &quot;m4r&quot;_s },</span>
<span class="line-modified">393 </span>
<span class="line-modified">394             // CoreAudio File</span>
<span class="line-modified">395             { &quot;audio/x-caf&quot;_s, &quot;caf&quot;_s },</span>
<span class="line-modified">396             { &quot;audio/x-gsm&quot;_s, &quot;gsm&quot;_s },</span>
<span class="line-modified">397 </span>
<span class="line-modified">398             // ADPCM</span>
<span class="line-modified">399             { &quot;audio/x-wav&quot;_s, &quot;wav&quot;_s },</span>
<span class="line-modified">400             { &quot;audio/vnd.wave&quot;_s, &quot;wav&quot;_s },</span>
<span class="line-modified">401         };</span>


402 




403         HashMap&lt;String, Vector&lt;String&gt;, ASCIICaseInsensitiveHash&gt; map;
<span class="line-modified">404         for (auto&amp; pair : commonMediaTypes) {</span>
405             ASCIILiteral type = pair.type;
406             ASCIILiteral extension = pair.extension;
407             map.ensure(extension, [type, extension] {
408                 // First type in the vector must always be the one from getMIMETypeForExtension,
409                 // so we can use the map without also calling getMIMETypeForExtension each time.
410                 Vector&lt;String&gt; synonyms;
411                 String systemType = MIMETypeRegistry::getMIMETypeForExtension(extension);
412                 if (!systemType.isEmpty() &amp;&amp; type != systemType)
413                     synonyms.append(systemType);
414                 return synonyms;
415             }).iterator-&gt;value.append(type);
416         }
417         return map;
<span class="line-modified">418     }());</span>
<span class="line-modified">419     auto mapEntry = map.get().find(extension);</span>
<span class="line-modified">420     if (mapEntry == map.get().end())</span>











421         return nullptr;
422     return &amp;mapEntry-&gt;value;
423 }
424 
425 String MIMETypeRegistry::getMediaMIMETypeForExtension(const String&amp; extension)
426 {
427     auto* vector = typesForCommonExtension(extension);
428     if (vector)
429         return (*vector)[0];
430     return getMIMETypeForExtension(extension);
431 }
432 
433 Vector&lt;String&gt; MIMETypeRegistry::getMediaMIMETypesForExtension(const String&amp; extension)
434 {
435     auto* vector = typesForCommonExtension(extension);
436     if (vector)
437         return *vector;
438     String type = getMIMETypeForExtension(extension);
439     if (!type.isNull())
440         return { { type } };
</pre>
<hr />
<pre>
450         if (result.length())
451             return result;
452     }
453     return defaultMIMEType();
454 }
455 
456 bool MIMETypeRegistry::isSupportedImageMIMEType(const String&amp; mimeType)
457 {
458     if (mimeType.isEmpty())
459         return false;
460     String normalizedMIMEType = getNormalizedMIMEType(mimeType);
461     return supportedImageMIMETypes().contains(normalizedMIMEType) || additionalSupportedImageMIMETypes().contains(normalizedMIMEType);
462 }
463 
464 bool MIMETypeRegistry::isSupportedImageVideoOrSVGMIMEType(const String&amp; mimeType)
465 {
466     if (isSupportedImageMIMEType(mimeType) || equalLettersIgnoringASCIICase(mimeType, &quot;image/svg+xml&quot;))
467         return true;
468 
469 #if HAVE(AVASSETREADER)
<span class="line-modified">470     if (ImageDecoderAVFObjC::supportsContentType(ContentType(mimeType)))</span>
471         return true;
472 #endif
473 
474     return false;
475 }
476 
<span class="line-modified">477 bool MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(const String&amp; mimeType)</span>
478 {
<span class="line-modified">479     ASSERT(isMainThread());</span>



































480 


481     if (mimeType.isEmpty())
482         return false;
<span class="line-modified">483     return supportedImageMIMETypesForEncoding().contains(mimeType);</span>
484 }
485 
486 bool MIMETypeRegistry::isSupportedJavaScriptMIMEType(const String&amp; mimeType)
487 {
488     if (mimeType.isEmpty())
489         return false;
490 
491     if (!isMainThread()) {
492         bool isSupported = false;
493         callOnMainThreadAndWait([&amp;isSupported, mimeType = mimeType.isolatedCopy()] {
494             isSupported = isSupportedJavaScriptMIMEType(mimeType);
495         });
496         return isSupported;
497     }
498 
499     return supportedJavaScriptMIMETypes().contains(mimeType);
500 }
501 
502 bool MIMETypeRegistry::isSupportedStyleSheetMIMEType(const String&amp; mimeType)
503 {
</pre>
<hr />
<pre>
759 
760         HashMap&lt;String, String, ASCIICaseInsensitiveHash&gt; map;
761         for (auto&amp; pair : mimeTypeAssociations)
762             map.add(pair.first, pair.second);
763         return map;
764     }());
765 
766     auto it = mimeTypeAssociationMap.get().find(mimeType);
767     if (it != mimeTypeAssociationMap.get().end())
768         return it-&gt;value;
769     return mimeType;
770 }
771 
772 #endif
773 
774 String MIMETypeRegistry::appendFileExtensionIfNecessary(const String&amp; filename, const String&amp; mimeType)
775 {
776     if (filename.isEmpty())
777         return emptyString();
778 



779     if (filename.reverseFind(&#39;.&#39;) != notFound)
780         return filename;
781 
782     String preferredExtension = getPreferredExtensionForMIMEType(mimeType);
783     if (preferredExtension.isEmpty())
784         return filename;
785 
<span class="line-modified">786     return filename + &quot;.&quot; + preferredExtension;</span>
787 }
788 
789 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;MIMETypeRegistry.h&quot;
 29 
 30 #include &quot;MediaPlayer.h&quot;
<span class="line-added"> 31 #include &quot;ThreadGlobalData.h&quot;</span>
 32 #include &lt;wtf/HashMap.h&gt;
 33 #include &lt;wtf/MainThread.h&gt;
 34 #include &lt;wtf/NeverDestroyed.h&gt;
 35 #include &lt;wtf/StdLibExtras.h&gt;
 36 
 37 #if USE(CG)
 38 #include &quot;ImageSourceCG.h&quot;
 39 #include &quot;UTIRegistry.h&quot;
 40 #include &lt;ImageIO/ImageIO.h&gt;
 41 #include &lt;wtf/RetainPtr.h&gt;
 42 #endif
 43 
 44 #if USE(CG) &amp;&amp; PLATFORM(COCOA)
 45 #include &quot;UTIUtilities.h&quot;
 46 #endif
 47 
 48 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 49 #include &quot;ArchiveFactory.h&quot;
 50 #endif
 51 
</pre>
<hr />
<pre>
 59 #endif
 60 
 61 #if USE(APPLE_INTERNAL_SDK)
 62 #include &lt;WebKitAdditions/AdditionalSystemPreviewTypes.h&gt;
 63 #else
 64 #define ADDITIONAL_SYSTEM_PREVIEW_TYPES
 65 #endif
 66 
 67 namespace WebCore {
 68 
 69 const HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; MIMETypeRegistry::supportedImageMIMETypes()
 70 {
 71     static NeverDestroyed&lt;HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&gt; supportedImageMIMETypes = std::initializer_list&lt;String&gt; {
 72 #if USE(CG)
 73         // This represents the subset of allowed image UTIs for which CoreServices has a corresponding MIME type.
 74         &quot;image/tiff&quot;_s,
 75         &quot;image/gif&quot;_s,
 76         &quot;image/jpeg&quot;_s,
 77         &quot;image/vnd.microsoft.icon&quot;_s,
 78         &quot;image/jp2&quot;_s,
<span class="line-added"> 79         &quot;image/apng&quot;_s,</span>
 80         &quot;image/png&quot;_s,
 81         &quot;image/bmp&quot;_s,
 82 
 83         &quot;image/x-icon&quot;_s, // Favicons don&#39;t have a MIME type in the registry either.
 84         &quot;image/pjpeg&quot;_s, //  We only get one MIME type per UTI, hence our need to add these manually
 85 
 86 #if PLATFORM(IOS_FAMILY)
 87         // Add malformed image mimetype for compatibility with Mail and to handle malformed mimetypes from the net
 88         // These were removed for &lt;rdar://problem/6564538&gt; Re-enable UTI code in WebCore now that MobileCoreServices exists
 89         // But Mail relies on at least image/tif reported as being supported (should be image/tiff).
 90         // This can be removed when Mail addresses:
 91         // &lt;rdar://problem/7879510&gt; Mail should use standard image mimetypes
 92         // and we fix sniffing so that it corrects items such as image/jpg -&gt; image/jpeg.
 93 
 94         // JPEG (image/jpeg)
 95         &quot;image/jpg&quot;_s,
 96         &quot;image/jp_&quot;_s,
 97         &quot;image/jpe_&quot;_s,
 98         &quot;application/jpg&quot;_s,
 99         &quot;application/x-jpg&quot;_s,
</pre>
<hr />
<pre>
120         // BMP (image/bmp, image/x-bitmap)
121         &quot;image/x-bmp&quot;_s,
122         &quot;image/x-win-bitmap&quot;_s,
123         &quot;image/x-windows-bmp&quot;_s,
124         &quot;image/ms-bmp&quot;_s,
125         &quot;image/x-ms-bmp&quot;_s,
126         &quot;application/bmp&quot;_s,
127         &quot;application/x-bmp&quot;_s,
128         &quot;application/x-win-bitmap&quot;_s,
129 #endif
130 #else
131         // assume that all implementations at least support the following standard
132         // image types:
133         &quot;image/jpeg&quot;_s,
134         &quot;image/png&quot;_s,
135         &quot;image/gif&quot;_s,
136         &quot;image/bmp&quot;_s,
137         &quot;image/vnd.microsoft.icon&quot;_s, // ico
138         &quot;image/x-icon&quot;_s, // ico
139         &quot;image/x-xbitmap&quot;_s, // xbm
<span class="line-added">140 #if ENABLE(APNG)</span>
<span class="line-added">141         &quot;image/apng&quot;_s,</span>
<span class="line-added">142 #endif</span>
143 #if USE(OPENJPEG)
144         &quot;image/jp2&quot;_s,
145         &quot;image/jpeg2000&quot;_s,
146 #endif
147 #if USE(WEBP)
148         &quot;image/webp&quot;_s,
149 #endif
150 #endif
151     };
152 
153 #if USE(CG)
154 #ifndef NDEBUG
155     // Esnure supportedImageMIMETypes() is in sync with defaultSupportedImageTypes().
156     static std::once_flag onceFlag;
157     std::call_once(onceFlag, [] {
158         for (auto&amp; imageType : defaultSupportedImageTypes()) {
159             auto mimeType = MIMETypeForImageType(imageType);
160             ASSERT_IMPLIES(!mimeType.isEmpty(), supportedImageMIMETypes.get().contains(mimeType));
161         }
162     });
163 #endif
164 #endif
165     return supportedImageMIMETypes;
166 }
167 
168 HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; MIMETypeRegistry::additionalSupportedImageMIMETypes()
169 {
170     static NeverDestroyed&lt;HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&gt; additionalSupportedImageMIMETypes;
171     return additionalSupportedImageMIMETypes;
172 }
173 









































174 static const HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; supportedJavaScriptMIMETypes()
175 {
176     static NeverDestroyed&lt;HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&gt; supportedJavaScriptMIMETypes = std::initializer_list&lt;String&gt; {
177         // https://html.spec.whatwg.org/multipage/scripting.html#javascript-mime-type
178         &quot;text/javascript&quot;_s,
179         &quot;text/ecmascript&quot;_s,
180         &quot;application/javascript&quot;_s,
181         &quot;application/ecmascript&quot;_s,
182         &quot;application/x-javascript&quot;_s,
183         &quot;application/x-ecmascript&quot;_s,
184         &quot;text/javascript1.0&quot;_s,
185         &quot;text/javascript1.1&quot;_s,
186         &quot;text/javascript1.2&quot;_s,
187         &quot;text/javascript1.3&quot;_s,
188         &quot;text/javascript1.4&quot;_s,
189         &quot;text/javascript1.5&quot;_s,
190         &quot;text/jscript&quot;_s,
191         &quot;text/livescript&quot;_s,
192         &quot;text/x-javascript&quot;_s,
193         &quot;text/x-ecmascript&quot;_s,
</pre>
<hr />
<pre>
257         &quot;text/x-calendar&quot;_s,
258         &quot;text/x-vcalendar&quot;_s,
259         &quot;text/vcalendar&quot;_s,
260         &quot;text/vcard&quot;_s,
261         &quot;text/x-vcard&quot;_s,
262         &quot;text/directory&quot;_s,
263         &quot;text/ldif&quot;_s,
264         &quot;text/qif&quot;_s,
265         &quot;text/x-qif&quot;_s,
266         &quot;text/x-csv&quot;_s,
267         &quot;text/x-vcf&quot;_s,
268 #if !PLATFORM(IOS_FAMILY)
269         &quot;text/rtf&quot;_s,
270 #else
271         &quot;text/vnd.sun.j2me.app-descriptor&quot;_s,
272 #endif
273     };
274     return unsupportedTextMIMETypes;
275 }
276 
<span class="line-modified">277 Optional&lt;HashMap&lt;String, Vector&lt;String&gt;, ASCIICaseInsensitiveHash&gt;&gt;&amp; overriddenMimeTypesMap()</span>
<span class="line-modified">278 {</span>
<span class="line-modified">279     static NeverDestroyed&lt;Optional&lt;HashMap&lt;String, Vector&lt;String&gt;, ASCIICaseInsensitiveHash&gt;&gt;&gt; map;</span>
<span class="line-modified">280     return map;</span>
<span class="line-modified">281 }</span>
<span class="line-modified">282 </span>
<span class="line-modified">283 const std::initializer_list&lt;TypeExtensionPair&gt;&amp; commonMediaTypes()</span>
<span class="line-modified">284 {</span>
<span class="line-modified">285     // A table of common media MIME types and file extensions used when a platform&#39;s</span>
<span class="line-modified">286     // specific MIME type lookup doesn&#39;t have a match for a media file extension.</span>
<span class="line-modified">287     static std::initializer_list&lt;TypeExtensionPair&gt; commonMediaTypes = {</span>
<span class="line-modified">288         // Ogg</span>
<span class="line-modified">289         { &quot;application/ogg&quot;_s, &quot;ogx&quot;_s },</span>
<span class="line-modified">290         { &quot;audio/ogg&quot;_s, &quot;ogg&quot;_s },</span>
<span class="line-modified">291         { &quot;audio/ogg&quot;_s, &quot;oga&quot;_s },</span>
<span class="line-modified">292         { &quot;video/ogg&quot;_s, &quot;ogv&quot;_s },</span>
<span class="line-modified">293 </span>
<span class="line-modified">294         // Annodex</span>
<span class="line-modified">295         { &quot;application/annodex&quot;_s, &quot;anx&quot;_s },</span>
<span class="line-modified">296         { &quot;audio/annodex&quot;_s, &quot;axa&quot;_s },</span>
<span class="line-modified">297         { &quot;video/annodex&quot;_s, &quot;axv&quot;_s },</span>
<span class="line-modified">298         { &quot;audio/speex&quot;_s, &quot;spx&quot;_s },</span>
<span class="line-modified">299 </span>
<span class="line-modified">300         // WebM</span>
<span class="line-modified">301         { &quot;video/webm&quot;_s, &quot;webm&quot;_s },</span>
<span class="line-modified">302         { &quot;audio/webm&quot;_s, &quot;webm&quot;_s },</span>
<span class="line-modified">303 </span>
<span class="line-modified">304         // MPEG</span>
<span class="line-modified">305         { &quot;audio/mpeg&quot;_s, &quot;m1a&quot;_s },</span>
<span class="line-modified">306         { &quot;audio/mpeg&quot;_s, &quot;m2a&quot;_s },</span>
<span class="line-modified">307         { &quot;audio/mpeg&quot;_s, &quot;m1s&quot;_s },</span>
<span class="line-modified">308         { &quot;audio/mpeg&quot;_s, &quot;mpa&quot;_s },</span>
<span class="line-modified">309         { &quot;video/mpeg&quot;_s, &quot;mpg&quot;_s },</span>
<span class="line-modified">310         { &quot;video/mpeg&quot;_s, &quot;m15&quot;_s },</span>
<span class="line-modified">311         { &quot;video/mpeg&quot;_s, &quot;m1s&quot;_s },</span>
<span class="line-modified">312         { &quot;video/mpeg&quot;_s, &quot;m1v&quot;_s },</span>
<span class="line-modified">313         { &quot;video/mpeg&quot;_s, &quot;m75&quot;_s },</span>
<span class="line-modified">314         { &quot;video/mpeg&quot;_s, &quot;mpa&quot;_s },</span>
<span class="line-modified">315         { &quot;video/mpeg&quot;_s, &quot;mpeg&quot;_s },</span>
<span class="line-modified">316         { &quot;video/mpeg&quot;_s, &quot;mpm&quot;_s },</span>
<span class="line-modified">317         { &quot;video/mpeg&quot;_s, &quot;mpv&quot;_s },</span>
<span class="line-modified">318 </span>
<span class="line-modified">319         // MPEG playlist</span>
<span class="line-modified">320         { &quot;application/vnd.apple.mpegurl&quot;_s, &quot;m3u8&quot;_s },</span>
<span class="line-modified">321         { &quot;application/mpegurl&quot;_s, &quot;m3u8&quot;_s },</span>
<span class="line-modified">322         { &quot;application/x-mpegurl&quot;_s, &quot;m3u8&quot;_s },</span>
<span class="line-modified">323         { &quot;audio/mpegurl&quot;_s, &quot;m3url&quot;_s },</span>
<span class="line-modified">324         { &quot;audio/x-mpegurl&quot;_s, &quot;m3url&quot;_s },</span>
<span class="line-modified">325         { &quot;audio/mpegurl&quot;_s, &quot;m3u&quot;_s },</span>
<span class="line-modified">326         { &quot;audio/x-mpegurl&quot;_s, &quot;m3u&quot;_s },</span>
<span class="line-modified">327 </span>
<span class="line-modified">328         // MPEG-4</span>
<span class="line-modified">329         { &quot;video/x-m4v&quot;_s, &quot;m4v&quot;_s },</span>
<span class="line-modified">330         { &quot;audio/x-m4a&quot;_s, &quot;m4a&quot;_s },</span>
<span class="line-modified">331         { &quot;audio/x-m4b&quot;_s, &quot;m4b&quot;_s },</span>
<span class="line-modified">332         { &quot;audio/x-m4p&quot;_s, &quot;m4p&quot;_s },</span>
<span class="line-modified">333         { &quot;audio/mp4&quot;_s, &quot;m4a&quot;_s },</span>
<span class="line-modified">334 </span>
<span class="line-modified">335         // MP3</span>
<span class="line-modified">336         { &quot;audio/mp3&quot;_s, &quot;mp3&quot;_s },</span>
<span class="line-modified">337         { &quot;audio/x-mp3&quot;_s, &quot;mp3&quot;_s },</span>
<span class="line-modified">338         { &quot;audio/x-mpeg&quot;_s, &quot;mp3&quot;_s },</span>
<span class="line-modified">339 </span>
<span class="line-modified">340         // MPEG-2</span>
<span class="line-modified">341         { &quot;video/x-mpeg2&quot;_s, &quot;mp2&quot;_s },</span>
<span class="line-modified">342         { &quot;video/mpeg2&quot;_s, &quot;vob&quot;_s },</span>
<span class="line-modified">343         { &quot;video/mpeg2&quot;_s, &quot;mod&quot;_s },</span>
<span class="line-modified">344         { &quot;video/m2ts&quot;_s, &quot;m2ts&quot;_s },</span>
<span class="line-modified">345         { &quot;video/x-m2ts&quot;_s, &quot;m2t&quot;_s },</span>
<span class="line-modified">346         { &quot;video/x-m2ts&quot;_s, &quot;ts&quot;_s },</span>
<span class="line-modified">347 </span>
<span class="line-modified">348         // 3GP/3GP2</span>
<span class="line-modified">349         { &quot;audio/3gpp&quot;_s, &quot;3gpp&quot;_s },</span>
<span class="line-modified">350         { &quot;audio/3gpp2&quot;_s, &quot;3g2&quot;_s },</span>
<span class="line-modified">351         { &quot;application/x-mpeg&quot;_s, &quot;amc&quot;_s },</span>
<span class="line-modified">352 </span>
<span class="line-modified">353         // AAC</span>
<span class="line-modified">354         { &quot;audio/aac&quot;_s, &quot;aac&quot;_s },</span>
<span class="line-modified">355         { &quot;audio/aac&quot;_s, &quot;adts&quot;_s },</span>
<span class="line-modified">356         { &quot;audio/x-aac&quot;_s, &quot;m4r&quot;_s },</span>
<span class="line-modified">357 </span>
<span class="line-modified">358         // CoreAudio File</span>
<span class="line-modified">359         { &quot;audio/x-caf&quot;_s, &quot;caf&quot;_s },</span>
<span class="line-modified">360         { &quot;audio/x-gsm&quot;_s, &quot;gsm&quot;_s },</span>
<span class="line-modified">361 </span>
<span class="line-modified">362         // ADPCM</span>
<span class="line-modified">363         { &quot;audio/x-wav&quot;_s, &quot;wav&quot;_s },</span>
<span class="line-modified">364         { &quot;audio/vnd.wave&quot;_s, &quot;wav&quot;_s },</span>
<span class="line-modified">365     };</span>
<span class="line-added">366     return commonMediaTypes;</span>
<span class="line-added">367 }</span>
368 
<span class="line-added">369 const HashMap&lt;String, Vector&lt;String&gt;, ASCIICaseInsensitiveHash&gt;&amp; commonMimeTypesMap()</span>
<span class="line-added">370 {</span>
<span class="line-added">371     ASSERT(isMainThread());</span>
<span class="line-added">372     static NeverDestroyed&lt;HashMap&lt;String, Vector&lt;String&gt;, ASCIICaseInsensitiveHash&gt;&gt; mimeTypesMap = [] {</span>
373         HashMap&lt;String, Vector&lt;String&gt;, ASCIICaseInsensitiveHash&gt; map;
<span class="line-modified">374         for (auto&amp; pair : commonMediaTypes()) {</span>
375             ASCIILiteral type = pair.type;
376             ASCIILiteral extension = pair.extension;
377             map.ensure(extension, [type, extension] {
378                 // First type in the vector must always be the one from getMIMETypeForExtension,
379                 // so we can use the map without also calling getMIMETypeForExtension each time.
380                 Vector&lt;String&gt; synonyms;
381                 String systemType = MIMETypeRegistry::getMIMETypeForExtension(extension);
382                 if (!systemType.isEmpty() &amp;&amp; type != systemType)
383                     synonyms.append(systemType);
384                 return synonyms;
385             }).iterator-&gt;value.append(type);
386         }
387         return map;
<span class="line-modified">388     }();</span>
<span class="line-modified">389     return mimeTypesMap;</span>
<span class="line-modified">390 }</span>
<span class="line-added">391 </span>
<span class="line-added">392 static const Vector&lt;String&gt;* typesForCommonExtension(const String&amp; extension)</span>
<span class="line-added">393 {</span>
<span class="line-added">394     if (overriddenMimeTypesMap().hasValue()) {</span>
<span class="line-added">395         auto mapEntry = overriddenMimeTypesMap()-&gt;find(extension);</span>
<span class="line-added">396         if (mapEntry == overriddenMimeTypesMap()-&gt;end())</span>
<span class="line-added">397             return nullptr;</span>
<span class="line-added">398         return &amp;mapEntry-&gt;value;</span>
<span class="line-added">399     }</span>
<span class="line-added">400     auto mapEntry = commonMimeTypesMap().find(extension);</span>
<span class="line-added">401     if (mapEntry == commonMimeTypesMap().end())</span>
402         return nullptr;
403     return &amp;mapEntry-&gt;value;
404 }
405 
406 String MIMETypeRegistry::getMediaMIMETypeForExtension(const String&amp; extension)
407 {
408     auto* vector = typesForCommonExtension(extension);
409     if (vector)
410         return (*vector)[0];
411     return getMIMETypeForExtension(extension);
412 }
413 
414 Vector&lt;String&gt; MIMETypeRegistry::getMediaMIMETypesForExtension(const String&amp; extension)
415 {
416     auto* vector = typesForCommonExtension(extension);
417     if (vector)
418         return *vector;
419     String type = getMIMETypeForExtension(extension);
420     if (!type.isNull())
421         return { { type } };
</pre>
<hr />
<pre>
431         if (result.length())
432             return result;
433     }
434     return defaultMIMEType();
435 }
436 
437 bool MIMETypeRegistry::isSupportedImageMIMEType(const String&amp; mimeType)
438 {
439     if (mimeType.isEmpty())
440         return false;
441     String normalizedMIMEType = getNormalizedMIMEType(mimeType);
442     return supportedImageMIMETypes().contains(normalizedMIMEType) || additionalSupportedImageMIMETypes().contains(normalizedMIMEType);
443 }
444 
445 bool MIMETypeRegistry::isSupportedImageVideoOrSVGMIMEType(const String&amp; mimeType)
446 {
447     if (isSupportedImageMIMEType(mimeType) || equalLettersIgnoringASCIICase(mimeType, &quot;image/svg+xml&quot;))
448         return true;
449 
450 #if HAVE(AVASSETREADER)
<span class="line-modified">451     if (ImageDecoderAVFObjC::supportsContainerType(mimeType))</span>
452         return true;
453 #endif
454 
455     return false;
456 }
457 
<span class="line-modified">458 std::unique_ptr&lt;MIMETypeRegistryThreadGlobalData&gt; MIMETypeRegistry::createMIMETypeRegistryThreadGlobalData()</span>
459 {
<span class="line-modified">460 #if PLATFORM(COCOA)</span>
<span class="line-added">461     RetainPtr&lt;CFArrayRef&gt; supportedTypes = adoptCF(CGImageDestinationCopyTypeIdentifiers());</span>
<span class="line-added">462     HashSet&lt;String, ASCIICaseInsensitiveHash&gt; supportedImageMIMETypesForEncoding;</span>
<span class="line-added">463     CFIndex count = CFArrayGetCount(supportedTypes.get());</span>
<span class="line-added">464     for (CFIndex i = 0; i &lt; count; i++) {</span>
<span class="line-added">465         CFStringRef supportedType = reinterpret_cast&lt;CFStringRef&gt;(CFArrayGetValueAtIndex(supportedTypes.get(), i));</span>
<span class="line-added">466         if (isSupportedImageType(supportedType)) {</span>
<span class="line-added">467             String mimeType = MIMETypeForImageType(supportedType);</span>
<span class="line-added">468             supportedImageMIMETypesForEncoding.add(mimeType);</span>
<span class="line-added">469         }</span>
<span class="line-added">470     }</span>
<span class="line-added">471 #else</span>
<span class="line-added">472     HashSet&lt;String, ASCIICaseInsensitiveHash&gt; supportedImageMIMETypesForEncoding = std::initializer_list&lt;String&gt; {</span>
<span class="line-added">473 #if USE(CG) || USE(DIRECT2D)</span>
<span class="line-added">474         // FIXME: Add Windows support for all the supported UTI&#39;s when a way to convert from MIMEType to UTI reliably is found.</span>
<span class="line-added">475         // For now, only support PNG, JPEG and GIF. See &lt;rdar://problem/6095286&gt;.</span>
<span class="line-added">476         &quot;image/png&quot;_s,</span>
<span class="line-added">477         &quot;image/jpeg&quot;_s,</span>
<span class="line-added">478         &quot;image/gif&quot;_s,</span>
<span class="line-added">479 #elif PLATFORM(JAVA)</span>
<span class="line-added">480         &quot;image/png&quot;_s,</span>
<span class="line-added">481         &quot;image/jpeg&quot;_s,</span>
<span class="line-added">482         &quot;image/bmp&quot;_s,</span>
<span class="line-added">483 #elif PLATFORM(GTK)</span>
<span class="line-added">484         &quot;image/png&quot;_s,</span>
<span class="line-added">485         &quot;image/jpeg&quot;_s,</span>
<span class="line-added">486         &quot;image/tiff&quot;_s,</span>
<span class="line-added">487         &quot;image/bmp&quot;_s,</span>
<span class="line-added">488         &quot;image/ico&quot;_s,</span>
<span class="line-added">489 #elif USE(CAIRO)</span>
<span class="line-added">490         &quot;image/png&quot;_s,</span>
<span class="line-added">491 #endif</span>
<span class="line-added">492     };</span>
<span class="line-added">493 #endif</span>
<span class="line-added">494     return makeUnique&lt;MIMETypeRegistryThreadGlobalData&gt;(WTFMove(supportedImageMIMETypesForEncoding));</span>
<span class="line-added">495 }</span>
496 
<span class="line-added">497 bool MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(const String&amp; mimeType)</span>
<span class="line-added">498 {</span>
499     if (mimeType.isEmpty())
500         return false;
<span class="line-modified">501     return threadGlobalData().mimeTypeRegistryThreadGlobalData().supportedImageMIMETypesForEncoding().contains(mimeType);</span>
502 }
503 
504 bool MIMETypeRegistry::isSupportedJavaScriptMIMEType(const String&amp; mimeType)
505 {
506     if (mimeType.isEmpty())
507         return false;
508 
509     if (!isMainThread()) {
510         bool isSupported = false;
511         callOnMainThreadAndWait([&amp;isSupported, mimeType = mimeType.isolatedCopy()] {
512             isSupported = isSupportedJavaScriptMIMEType(mimeType);
513         });
514         return isSupported;
515     }
516 
517     return supportedJavaScriptMIMETypes().contains(mimeType);
518 }
519 
520 bool MIMETypeRegistry::isSupportedStyleSheetMIMEType(const String&amp; mimeType)
521 {
</pre>
<hr />
<pre>
777 
778         HashMap&lt;String, String, ASCIICaseInsensitiveHash&gt; map;
779         for (auto&amp; pair : mimeTypeAssociations)
780             map.add(pair.first, pair.second);
781         return map;
782     }());
783 
784     auto it = mimeTypeAssociationMap.get().find(mimeType);
785     if (it != mimeTypeAssociationMap.get().end())
786         return it-&gt;value;
787     return mimeType;
788 }
789 
790 #endif
791 
792 String MIMETypeRegistry::appendFileExtensionIfNecessary(const String&amp; filename, const String&amp; mimeType)
793 {
794     if (filename.isEmpty())
795         return emptyString();
796 
<span class="line-added">797     if (equalIgnoringASCIICase(mimeType, defaultMIMEType()))</span>
<span class="line-added">798         return filename;</span>
<span class="line-added">799 </span>
800     if (filename.reverseFind(&#39;.&#39;) != notFound)
801         return filename;
802 
803     String preferredExtension = getPreferredExtensionForMIMEType(mimeType);
804     if (preferredExtension.isEmpty())
805         return filename;
806 
<span class="line-modified">807     return makeString(filename, &#39;.&#39;, preferredExtension);</span>
808 }
809 
810 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="Logging.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MIMETypeRegistry.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
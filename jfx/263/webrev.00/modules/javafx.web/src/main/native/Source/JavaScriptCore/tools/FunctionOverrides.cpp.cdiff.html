<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/FunctionOverrides.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompilerTimingScope.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FunctionOverrides.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/FunctionOverrides.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2016 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,36 ***</span>
  
    4. A &#39;with&#39; clause is identical in form to an &#39;override&#39; clause except that
       it uses the &#39;with&#39; keyword instead of the &#39;override&#39; keyword.
   */
  
  FunctionOverrides&amp; FunctionOverrides::overrides()
  {
      static LazyNeverDestroyed&lt;FunctionOverrides&gt; overrides;
      static std::once_flag initializeListFlag;
      std::call_once(initializeListFlag, [] {
          const char* overridesFileName = Options::functionOverrides();
          overrides.construct(overridesFileName);
      });
      return overrides;
  }
  
  FunctionOverrides::FunctionOverrides(const char* overridesFileName)
  {
<span class="line-modified">!     parseOverridesInFile(overridesFileName);</span>
  }
  
  void FunctionOverrides::reinstallOverrides()
  {
      FunctionOverrides&amp; overrides = FunctionOverrides::overrides();
      const char* overridesFileName = Options::functionOverrides();
<span class="line-modified">!     overrides.clear();</span>
<span class="line-modified">!     overrides.parseOverridesInFile(overridesFileName);</span>
  }
  
  static void initializeOverrideInfo(const SourceCode&amp; origCode, const String&amp; newBody, FunctionOverrides::OverrideInfo&amp; info)
  {
      String origProviderStr = origCode.provider()-&gt;source().toString();
      unsigned origStart = origCode.startOffset();
      unsigned origFunctionStart = origProviderStr.reverseFind(&quot;function&quot;, origStart);
      unsigned origBraceStart = origProviderStr.find(&quot;{&quot;, origStart);
      unsigned headerLength = origBraceStart - origFunctionStart;
<span class="line-new-header">--- 87,47 ---</span>
  
    4. A &#39;with&#39; clause is identical in form to an &#39;override&#39; clause except that
       it uses the &#39;with&#39; keyword instead of the &#39;override&#39; keyword.
   */
  
<span class="line-added">+ struct FunctionOverridesAssertScope {</span>
<span class="line-added">+     FunctionOverridesAssertScope() { RELEASE_ASSERT(g_jscConfig.restrictedOptionsEnabled); }</span>
<span class="line-added">+     ~FunctionOverridesAssertScope() { RELEASE_ASSERT(g_jscConfig.restrictedOptionsEnabled); }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  FunctionOverrides&amp; FunctionOverrides::overrides()
  {
<span class="line-added">+     FunctionOverridesAssertScope assertScope;</span>
      static LazyNeverDestroyed&lt;FunctionOverrides&gt; overrides;
      static std::once_flag initializeListFlag;
      std::call_once(initializeListFlag, [] {
<span class="line-added">+         FunctionOverridesAssertScope assertScope;</span>
          const char* overridesFileName = Options::functionOverrides();
          overrides.construct(overridesFileName);
      });
      return overrides;
  }
  
  FunctionOverrides::FunctionOverrides(const char* overridesFileName)
  {
<span class="line-modified">!     FunctionOverridesAssertScope assertScope;</span>
<span class="line-added">+     parseOverridesInFile(holdLock(m_lock), overridesFileName);</span>
  }
  
  void FunctionOverrides::reinstallOverrides()
  {
<span class="line-added">+     FunctionOverridesAssertScope assertScope;</span>
      FunctionOverrides&amp; overrides = FunctionOverrides::overrides();
<span class="line-added">+     auto locker = holdLock(overrides.m_lock);</span>
      const char* overridesFileName = Options::functionOverrides();
<span class="line-modified">!     overrides.clear(locker);</span>
<span class="line-modified">!     overrides.parseOverridesInFile(locker, overridesFileName);</span>
  }
  
  static void initializeOverrideInfo(const SourceCode&amp; origCode, const String&amp; newBody, FunctionOverrides::OverrideInfo&amp; info)
  {
<span class="line-added">+     FunctionOverridesAssertScope assertScope;</span>
      String origProviderStr = origCode.provider()-&gt;source().toString();
      unsigned origStart = origCode.startOffset();
      unsigned origFunctionStart = origProviderStr.reverseFind(&quot;function&quot;, origStart);
      unsigned origBraceStart = origProviderStr.find(&quot;{&quot;, origStart);
      unsigned headerLength = origBraceStart - origFunctionStart;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,24 ***</span>
          SourceCode(WTFMove(newProvider), info.parametersStartOffset, info.typeProfilingEndOffset + 1, 1, 1);
  }
  
  bool FunctionOverrides::initializeOverrideFor(const SourceCode&amp; origCode, FunctionOverrides::OverrideInfo&amp; result)
  {
<span class="line-modified">!     ASSERT(Options::functionOverrides());</span>
      FunctionOverrides&amp; overrides = FunctionOverrides::overrides();
  
      String sourceString = origCode.view().toString();
      size_t sourceBodyStart = sourceString.find(&#39;{&#39;);
      if (sourceBodyStart == notFound)
          return false;
      String sourceBodyString = sourceString.substring(sourceBodyStart);
  
<span class="line-modified">!     auto it = overrides.m_entries.find(sourceBodyString);</span>
<span class="line-modified">!     if (it == overrides.m_entries.end())</span>
<span class="line-modified">!         return false;</span>
  
<span class="line-modified">!     initializeOverrideInfo(origCode, it-&gt;value, result);</span>
      return true;
  }
  
  #define SYNTAX_ERROR &quot;SYNTAX ERROR&quot;
  #define IO_ERROR &quot;IO ERROR&quot;
<span class="line-new-header">--- 151,31 ---</span>
          SourceCode(WTFMove(newProvider), info.parametersStartOffset, info.typeProfilingEndOffset + 1, 1, 1);
  }
  
  bool FunctionOverrides::initializeOverrideFor(const SourceCode&amp; origCode, FunctionOverrides::OverrideInfo&amp; result)
  {
<span class="line-modified">!     FunctionOverridesAssertScope assertScope;</span>
<span class="line-added">+     RELEASE_ASSERT(Options::functionOverrides());</span>
      FunctionOverrides&amp; overrides = FunctionOverrides::overrides();
  
      String sourceString = origCode.view().toString();
      size_t sourceBodyStart = sourceString.find(&#39;{&#39;);
      if (sourceBodyStart == notFound)
          return false;
      String sourceBodyString = sourceString.substring(sourceBodyStart);
  
<span class="line-modified">!     String newBody;</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto locker = holdLock(overrides.m_lock);</span>
<span class="line-added">+         auto it = overrides.m_entries.find(sourceBodyString.isolatedCopy());</span>
<span class="line-added">+         if (it == overrides.m_entries.end())</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         newBody = it-&gt;value.isolatedCopy();</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     initializeOverrideInfo(origCode, newBody, result);</span>
<span class="line-added">+     RELEASE_ASSERT(Options::functionOverrides());</span>
      return true;
  }
  
  #define SYNTAX_ERROR &quot;SYNTAX ERROR&quot;
  #define IO_ERROR &quot;IO ERROR&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,10 ***</span>
<span class="line-new-header">--- 199,11 ---</span>
      return false;
  }
  
  static String parseClause(const char* keyword, size_t keywordLength, FILE* file, const char* line, char* buffer, size_t bufferSize)
  {
<span class="line-added">+     FunctionOverridesAssertScope assertScope;</span>
      const char* keywordPos = strstr(line, keyword);
      if (!keywordPos)
          FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Expecting &#39;&quot;, keyword, &quot;&#39; clause:\n&quot;, line, &quot;\n&quot;));
      if (keywordPos != line)
          FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Cannot have any characters before &#39;&quot;, keyword, &quot;&#39;:\n&quot;, line, &quot;\n&quot;));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 225,12 ***</span>
      } while ((line = fgets(buffer, bufferSize, file)));
  
      FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;&#39;&quot;, keyword, &quot;&#39; clause end delimiter &#39;&quot;, delimiter, &quot;&#39; not found:\n&quot;, builder.toString(), &quot;\n&quot;, &quot;Are you missing a &#39;}&#39; before the delimiter?\n&quot;));
  }
  
<span class="line-modified">! void FunctionOverrides::parseOverridesInFile(const char* fileName)</span>
  {
      if (!fileName)
          return;
  
      FILE* file = fopen(fileName, &quot;r&quot;);
      if (!file)
<span class="line-new-header">--- 244,13 ---</span>
      } while ((line = fgets(buffer, bufferSize, file)));
  
      FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;&#39;&quot;, keyword, &quot;&#39; clause end delimiter &#39;&quot;, delimiter, &quot;&#39; not found:\n&quot;, builder.toString(), &quot;\n&quot;, &quot;Are you missing a &#39;}&#39; before the delimiter?\n&quot;));
  }
  
<span class="line-modified">! void FunctionOverrides::parseOverridesInFile(const AbstractLocker&amp;, const char* fileName)</span>
  {
<span class="line-added">+     FunctionOverridesAssertScope assertScope;</span>
      if (!fileName)
          return;
  
      FILE* file = fopen(fileName, &quot;r&quot;);
      if (!file)
</pre>
<center><a href="CompilerTimingScope.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FunctionOverrides.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
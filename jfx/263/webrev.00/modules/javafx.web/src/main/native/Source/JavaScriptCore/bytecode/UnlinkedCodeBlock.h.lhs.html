<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012-2019 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;BytecodeConventions.h&quot;
 29 #include &quot;CodeType.h&quot;
 30 #include &quot;DFGExitProfile.h&quot;
 31 #include &quot;ExpressionRangeInfo.h&quot;
 32 #include &quot;HandlerInfo.h&quot;
 33 #include &quot;Identifier.h&quot;
 34 #include &quot;InstructionStream.h&quot;
 35 #include &quot;JSCast.h&quot;
 36 #include &quot;LockDuringMarking.h&quot;
 37 #include &quot;Opcode.h&quot;
 38 #include &quot;ParserModes.h&quot;
 39 #include &quot;RegExp.h&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 40 #include &quot;SpecialPointer.h&quot;</span>
 41 #include &quot;UnlinkedFunctionExecutable.h&quot;
 42 #include &quot;UnlinkedMetadataTable.h&quot;
 43 #include &quot;VirtualRegister.h&quot;
 44 #include &lt;algorithm&gt;
 45 #include &lt;wtf/BitVector.h&gt;
 46 #include &lt;wtf/HashSet.h&gt;
<a name="2" id="anc2"></a>
 47 #include &lt;wtf/TriState.h&gt;
 48 #include &lt;wtf/Vector.h&gt;
 49 #include &lt;wtf/text/UniquedStringImpl.h&gt;
 50 
 51 namespace JSC {
 52 
<a name="3" id="anc3"></a><span class="line-removed"> 53 class BytecodeGenerator;</span>
 54 class BytecodeLivenessAnalysis;
 55 class BytecodeRewriter;
 56 class CodeBlock;
 57 class Debugger;
 58 class FunctionExecutable;
 59 class ParserError;
 60 class ScriptExecutable;
 61 class SourceCode;
 62 class SourceProvider;
 63 class UnlinkedCodeBlock;
<a name="4" id="anc4"></a>
 64 class UnlinkedFunctionCodeBlock;
 65 class UnlinkedFunctionExecutable;
 66 struct ExecutableInfo;
<a name="5" id="anc5"></a>
 67 
 68 template&lt;typename CodeBlockType&gt;
 69 class CachedCodeBlock;
 70 
 71 typedef unsigned UnlinkedValueProfile;
 72 typedef unsigned UnlinkedArrayProfile;
 73 typedef unsigned UnlinkedArrayAllocationProfile;
 74 typedef unsigned UnlinkedObjectAllocationProfile;
 75 typedef unsigned UnlinkedLLIntCallLinkInfo;
 76 using ConstantIdentifierSetEntry = std::pair&lt;IdentifierSet, unsigned&gt;;
 77 
 78 struct UnlinkedStringJumpTable {
 79     struct OffsetLocation {
 80         int32_t branchOffset;
 81     };
 82 
 83     typedef HashMap&lt;RefPtr&lt;StringImpl&gt;, OffsetLocation&gt; StringOffsetTable;
 84     StringOffsetTable offsetTable;
 85 
 86     inline int32_t offsetForValue(StringImpl* value, int32_t defaultOffset)
 87     {
 88         StringOffsetTable::const_iterator end = offsetTable.end();
 89         StringOffsetTable::const_iterator loc = offsetTable.find(value);
 90         if (loc == end)
 91             return defaultOffset;
 92         return loc-&gt;value.branchOffset;
 93     }
 94 
 95 };
 96 
 97 struct UnlinkedSimpleJumpTable {
<a name="6" id="anc6"></a><span class="line-modified"> 98     Vector&lt;int32_t&gt; branchOffsets;</span>
 99     int32_t min;
100 
101     int32_t offsetForValue(int32_t value, int32_t defaultOffset);
102     void add(int32_t key, int32_t offset)
103     {
104         if (!branchOffsets[key])
105             branchOffsets[key] = offset;
106     }
107 };
108 
109 class UnlinkedCodeBlock : public JSCell {
110 public:
111     typedef JSCell Base;
<a name="7" id="anc7"></a><span class="line-modified">112     static const unsigned StructureFlags = Base::StructureFlags;</span>
113 
<a name="8" id="anc8"></a><span class="line-modified">114     static const bool needsDestruction = true;</span>






115 
116     enum { CallFunction, ApplyFunction };
117 
118     bool isConstructor() const { return m_isConstructor; }
119     bool isStrictMode() const { return m_isStrictMode; }
120     bool usesEval() const { return m_usesEval; }
121     SourceParseMode parseMode() const { return m_parseMode; }
122     bool isArrowFunction() const { return isArrowFunctionParseMode(parseMode()); }
123     DerivedContextType derivedContextType() const { return static_cast&lt;DerivedContextType&gt;(m_derivedContextType); }
124     EvalContextType evalContextType() const { return static_cast&lt;EvalContextType&gt;(m_evalContextType); }
125     bool isArrowFunctionContext() const { return m_isArrowFunctionContext; }
126     bool isClassContext() const { return m_isClassContext; }
127     bool hasTailCalls() const { return m_hasTailCalls; }
128     void setHasTailCalls() { m_hasTailCalls = true; }
129     bool allowDirectEvalCache() const { return !(m_features &amp; NoEvalCacheFeature); }
130 
<a name="9" id="anc9"></a><span class="line-removed">131     void addExpressionInfo(unsigned instructionOffset, int divot,</span>
<span class="line-removed">132         int startOffset, int endOffset, unsigned line, unsigned column);</span>
<span class="line-removed">133 </span>
<span class="line-removed">134     void addTypeProfilerExpressionInfo(unsigned instructionOffset, unsigned startDivot, unsigned endDivot);</span>
<span class="line-removed">135 </span>
136     bool hasExpressionInfo() { return m_expressionInfo.size(); }
<a name="10" id="anc10"></a><span class="line-modified">137     const Vector&lt;ExpressionRangeInfo&gt;&amp; expressionInfo() { return m_expressionInfo; }</span>



138 
139     // Special registers
140     void setThisRegister(VirtualRegister thisRegister) { m_thisRegister = thisRegister; }
141     void setScopeRegister(VirtualRegister scopeRegister) { m_scopeRegister = scopeRegister; }
142 
143     // Parameter information
144     void setNumParameters(int newValue) { m_numParameters = newValue; }
<a name="11" id="anc11"></a><span class="line-removed">145     void addParameter() { m_numParameters++; }</span>
146     unsigned numParameters() const { return m_numParameters; }
147 
148     // Constant Pools
149 
150     size_t numberOfIdentifiers() const { return m_identifiers.size(); }
<a name="12" id="anc12"></a><span class="line-removed">151     void addIdentifier(const Identifier&amp; i) { return m_identifiers.append(i); }</span>
152     const Identifier&amp; identifier(int index) const { return m_identifiers[index]; }
<a name="13" id="anc13"></a><span class="line-modified">153     const Vector&lt;Identifier&gt;&amp; identifiers() const { return m_identifiers; }</span>
154 
155     BitVector&amp; bitVector(size_t i) { ASSERT(m_rareData); return m_rareData-&gt;m_bitVectors[i]; }
<a name="14" id="anc14"></a><span class="line-removed">156     unsigned addBitVector(BitVector&amp;&amp; bitVector)</span>
<span class="line-removed">157     {</span>
<span class="line-removed">158         createRareDataIfNecessary();</span>
<span class="line-removed">159         m_rareData-&gt;m_bitVectors.append(WTFMove(bitVector));</span>
<span class="line-removed">160         return m_rareData-&gt;m_bitVectors.size() - 1;</span>
<span class="line-removed">161     }</span>
162 
<a name="15" id="anc15"></a><span class="line-modified">163     void addSetConstant(IdentifierSet&amp; set)</span>
<span class="line-modified">164     {</span>
<span class="line-modified">165         createRareDataIfNecessary();</span>
<span class="line-modified">166         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">167         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">168         unsigned result = m_constantRegisters.size();</span>
<span class="line-removed">169         m_constantRegisters.append(WriteBarrier&lt;Unknown&gt;());</span>
<span class="line-removed">170         m_constantsSourceCodeRepresentation.append(SourceCodeRepresentation::Other);</span>
<span class="line-removed">171         m_rareData-&gt;m_constantIdentifierSets.append(ConstantIdentifierSetEntry(set, result));</span>
<span class="line-removed">172     }</span>
<span class="line-removed">173 </span>
<span class="line-removed">174     unsigned addConstant(JSValue v, SourceCodeRepresentation sourceCodeRepresentation = SourceCodeRepresentation::Other)</span>
<span class="line-removed">175     {</span>
<span class="line-removed">176         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">177         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">178         unsigned result = m_constantRegisters.size();</span>
<span class="line-removed">179         m_constantRegisters.append(WriteBarrier&lt;Unknown&gt;());</span>
<span class="line-removed">180         m_constantRegisters.last().set(vm, this, v);</span>
<span class="line-removed">181         m_constantsSourceCodeRepresentation.append(sourceCodeRepresentation);</span>
<span class="line-removed">182         return result;</span>
<span class="line-removed">183     }</span>
<span class="line-removed">184     unsigned addConstant(LinkTimeConstant type)</span>
<span class="line-removed">185     {</span>
<span class="line-removed">186         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">187         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">188         unsigned result = m_constantRegisters.size();</span>
<span class="line-removed">189         ASSERT(result);</span>
<span class="line-removed">190         unsigned index = static_cast&lt;unsigned&gt;(type);</span>
<span class="line-removed">191         ASSERT(index &lt; LinkTimeConstantCount);</span>
<span class="line-removed">192         m_linkTimeConstants[index] = result;</span>
<span class="line-removed">193         m_constantRegisters.append(WriteBarrier&lt;Unknown&gt;());</span>
<span class="line-removed">194         m_constantsSourceCodeRepresentation.append(SourceCodeRepresentation::Other);</span>
<span class="line-removed">195         return result;</span>
<span class="line-removed">196     }</span>
<span class="line-removed">197 </span>
<span class="line-removed">198     unsigned registerIndexForLinkTimeConstant(LinkTimeConstant type)</span>
<span class="line-removed">199     {</span>
<span class="line-removed">200         unsigned index = static_cast&lt;unsigned&gt;(type);</span>
<span class="line-removed">201         ASSERT(index &lt; LinkTimeConstantCount);</span>
<span class="line-removed">202         return m_linkTimeConstants[index];</span>
<span class="line-removed">203     }</span>
<span class="line-removed">204 </span>
<span class="line-removed">205     const Vector&lt;WriteBarrier&lt;Unknown&gt;&gt;&amp; constantRegisters() { return m_constantRegisters; }</span>
<span class="line-removed">206     const WriteBarrier&lt;Unknown&gt;&amp; constantRegister(int index) const { return m_constantRegisters[index - FirstConstantRegisterIndex]; }</span>
<span class="line-removed">207     ALWAYS_INLINE bool isConstantRegisterIndex(int index) const { return index &gt;= FirstConstantRegisterIndex; }</span>
<span class="line-removed">208     ALWAYS_INLINE JSValue getConstant(int index) const { return m_constantRegisters[index - FirstConstantRegisterIndex].get(); }</span>
<span class="line-removed">209     const Vector&lt;SourceCodeRepresentation&gt;&amp; constantsSourceCodeRepresentation() { return m_constantsSourceCodeRepresentation; }</span>
210 
211     unsigned numberOfConstantIdentifierSets() const { return m_rareData ? m_rareData-&gt;m_constantIdentifierSets.size() : 0; }
<a name="16" id="anc16"></a><span class="line-modified">212     const Vector&lt;ConstantIdentifierSetEntry&gt;&amp; constantIdentifierSets() { ASSERT(m_rareData); return m_rareData-&gt;m_constantIdentifierSets; }</span>
213 
214     // Jumps
215     size_t numberOfJumpTargets() const { return m_jumpTargets.size(); }
<a name="17" id="anc17"></a><span class="line-removed">216     void addJumpTarget(unsigned jumpTarget) { m_jumpTargets.append(jumpTarget); }</span>
217     unsigned jumpTarget(int index) const { return m_jumpTargets[index]; }
218     unsigned lastJumpTarget() const { return m_jumpTargets.last(); }
219 
<a name="18" id="anc18"></a><span class="line-modified">220     UnlinkedHandlerInfo* handlerForBytecodeOffset(unsigned bytecodeOffset, RequiredHandler = RequiredHandler::AnyHandler);</span>
221     UnlinkedHandlerInfo* handlerForIndex(unsigned, RequiredHandler = RequiredHandler::AnyHandler);
222 
223     bool isBuiltinFunction() const { return m_isBuiltinFunction; }
224 
225     ConstructorKind constructorKind() const { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
226     SuperBinding superBinding() const { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
227     JSParserScriptMode scriptMode() const { return static_cast&lt;JSParserScriptMode&gt;(m_scriptMode); }
228 
<a name="19" id="anc19"></a><span class="line-removed">229     void shrinkToFit();</span>
<span class="line-removed">230 </span>
<span class="line-removed">231     void setInstructions(std::unique_ptr&lt;InstructionStream&gt;);</span>
232     const InstructionStream&amp; instructions() const;
233 
234     int numCalleeLocals() const { return m_numCalleeLocals; }
235     int numVars() const { return m_numVars; }
236 
237     // Jump Tables
238 
239     size_t numberOfSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_switchJumpTables.size() : 0; }
<a name="20" id="anc20"></a><span class="line-removed">240     UnlinkedSimpleJumpTable&amp; addSwitchJumpTable() { createRareDataIfNecessary(); m_rareData-&gt;m_switchJumpTables.append(UnlinkedSimpleJumpTable()); return m_rareData-&gt;m_switchJumpTables.last(); }</span>
241     UnlinkedSimpleJumpTable&amp; switchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_switchJumpTables[tableIndex]; }
242 
243     size_t numberOfStringSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_stringSwitchJumpTables.size() : 0; }
<a name="21" id="anc21"></a><span class="line-removed">244     UnlinkedStringJumpTable&amp; addStringSwitchJumpTable() { createRareDataIfNecessary(); m_rareData-&gt;m_stringSwitchJumpTables.append(UnlinkedStringJumpTable()); return m_rareData-&gt;m_stringSwitchJumpTables.last(); }</span>
245     UnlinkedStringJumpTable&amp; stringSwitchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_stringSwitchJumpTables[tableIndex]; }
246 
<a name="22" id="anc22"></a><span class="line-removed">247     unsigned addFunctionDecl(UnlinkedFunctionExecutable* n)</span>
<span class="line-removed">248     {</span>
<span class="line-removed">249         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">250         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">251         unsigned size = m_functionDecls.size();</span>
<span class="line-removed">252         m_functionDecls.append(WriteBarrier&lt;UnlinkedFunctionExecutable&gt;());</span>
<span class="line-removed">253         m_functionDecls.last().set(vm, this, n);</span>
<span class="line-removed">254         return size;</span>
<span class="line-removed">255     }</span>
256     UnlinkedFunctionExecutable* functionDecl(int index) { return m_functionDecls[index].get(); }
257     size_t numberOfFunctionDecls() { return m_functionDecls.size(); }
<a name="23" id="anc23"></a><span class="line-removed">258     unsigned addFunctionExpr(UnlinkedFunctionExecutable* n)</span>
<span class="line-removed">259     {</span>
<span class="line-removed">260         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">261         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">262         unsigned size = m_functionExprs.size();</span>
<span class="line-removed">263         m_functionExprs.append(WriteBarrier&lt;UnlinkedFunctionExecutable&gt;());</span>
<span class="line-removed">264         m_functionExprs.last().set(vm, this, n);</span>
<span class="line-removed">265         return size;</span>
<span class="line-removed">266     }</span>
267     UnlinkedFunctionExecutable* functionExpr(int index) { return m_functionExprs[index].get(); }
268     size_t numberOfFunctionExprs() { return m_functionExprs.size(); }
269 
270     // Exception handling support
271     size_t numberOfExceptionHandlers() const { return m_rareData ? m_rareData-&gt;m_exceptionHandlers.size() : 0; }
<a name="24" id="anc24"></a><span class="line-removed">272     void addExceptionHandler(const UnlinkedHandlerInfo&amp; handler) { createRareDataIfNecessary(); return m_rareData-&gt;m_exceptionHandlers.append(handler); }</span>
273     UnlinkedHandlerInfo&amp; exceptionHandler(int index) { ASSERT(m_rareData); return m_rareData-&gt;m_exceptionHandlers[index]; }
274 
275     CodeType codeType() const { return static_cast&lt;CodeType&gt;(m_codeType); }
276 
277     VirtualRegister thisRegister() const { return m_thisRegister; }
278     VirtualRegister scopeRegister() const { return m_scopeRegister; }
279 
<a name="25" id="anc25"></a><span class="line-removed">280     void addPropertyAccessInstruction(InstructionStream::Offset propertyAccessInstruction)</span>
<span class="line-removed">281     {</span>
<span class="line-removed">282         m_propertyAccessInstructions.append(propertyAccessInstruction);</span>
<span class="line-removed">283     }</span>
<span class="line-removed">284 </span>
<span class="line-removed">285     size_t numberOfPropertyAccessInstructions() const { return m_propertyAccessInstructions.size(); }</span>
<span class="line-removed">286     const Vector&lt;InstructionStream::Offset&gt;&amp; propertyAccessInstructions() const { return m_propertyAccessInstructions; }</span>
<span class="line-removed">287 </span>
288     bool hasRareData() const { return m_rareData.get(); }
289 
<a name="26" id="anc26"></a><span class="line-modified">290     int lineNumberForBytecodeOffset(unsigned bytecodeOffset);</span>
291 
<a name="27" id="anc27"></a><span class="line-modified">292     void expressionRangeForBytecodeOffset(unsigned bytecodeOffset, int&amp; divot,</span>
293         int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const;
294 
295     bool typeProfilerExpressionInfoForBytecodeOffset(unsigned bytecodeOffset, unsigned&amp; startDivot, unsigned&amp; endDivot);
296 
297     void recordParse(CodeFeatures features, bool hasCapturedVariables, unsigned lineCount, unsigned endColumn)
298     {
299         m_features = features;
300         m_hasCapturedVariables = hasCapturedVariables;
301         m_lineCount = lineCount;
302         // For the UnlinkedCodeBlock, startColumn is always 0.
303         m_endColumn = endColumn;
304     }
305 
<a name="28" id="anc28"></a><span class="line-modified">306     const String&amp; sourceURLDirective() const { return m_sourceURLDirective; }</span>
<span class="line-modified">307     const String&amp; sourceMappingURLDirective() const { return m_sourceMappingURLDirective; }</span>
<span class="line-modified">308     void setSourceURLDirective(const String&amp; sourceURL) { m_sourceURLDirective = sourceURL; }</span>
<span class="line-modified">309     void setSourceMappingURLDirective(const String&amp; sourceMappingURL) { m_sourceMappingURLDirective = sourceMappingURL; }</span>
310 
311     CodeFeatures codeFeatures() const { return m_features; }
312     bool hasCapturedVariables() const { return m_hasCapturedVariables; }
313     unsigned lineCount() const { return m_lineCount; }
314     ALWAYS_INLINE unsigned startColumn() const { return 0; }
315     unsigned endColumn() const { return m_endColumn; }
316 
<a name="29" id="anc29"></a><span class="line-modified">317     void addOpProfileControlFlowBytecodeOffset(InstructionStream::Offset offset)</span>
<span class="line-removed">318     {</span>
<span class="line-removed">319         createRareDataIfNecessary();</span>
<span class="line-removed">320         m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets.append(offset);</span>
<span class="line-removed">321     }</span>
<span class="line-removed">322     const Vector&lt;InstructionStream::Offset&gt;&amp; opProfileControlFlowBytecodeOffsets() const</span>
323     {
324         ASSERT(m_rareData);
325         return m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets;
326     }
327     bool hasOpProfileControlFlowBytecodeOffsets() const
328     {
329         return m_rareData &amp;&amp; !m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets.isEmpty();
330     }
331 
332     void dumpExpressionRangeInfo(); // For debugging purpose only.
333 
334     bool wasCompiledWithDebuggingOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::Debugger); }
335     bool wasCompiledWithTypeProfilerOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::TypeProfiler); }
336     bool wasCompiledWithControlFlowProfilerOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::ControlFlowProfiler); }
337     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode() const { return m_codeGenerationMode; }
338 
339     TriState didOptimize() const { return static_cast&lt;TriState&gt;(m_didOptimize); }
340     void setDidOptimize(TriState didOptimize) { m_didOptimize = static_cast&lt;unsigned&gt;(didOptimize); }
341 
342     static constexpr unsigned maxAge = 7;
343 
344     unsigned age() const { return m_age; }
345     void resetAge() { m_age = 0; }
346 
<a name="30" id="anc30"></a>






347     void dump(PrintStream&amp;) const;
348 
349     BytecodeLivenessAnalysis&amp; livenessAnalysis(CodeBlock* codeBlock)
350     {
351         if (m_liveness)
352             return *m_liveness;
353         return livenessAnalysisSlow(codeBlock);
354     }
355 
356 #if ENABLE(DFG_JIT)
357     bool hasExitSite(const ConcurrentJSLocker&amp; locker, const DFG::FrequentExitSite&amp; site) const
358     {
359         return m_exitProfile.hasExitSite(locker, site);
360     }
361 
362     bool hasExitSite(const DFG::FrequentExitSite&amp; site)
363     {
364         ConcurrentJSLocker locker(m_lock);
365         return hasExitSite(locker, site);
366     }
367 
368     DFG::ExitProfile&amp; exitProfile() { return m_exitProfile; }
369 #endif
370 
371     UnlinkedMetadataTable&amp; metadata() { return m_metadata.get(); }
372 
373     size_t metadataSizeInBytes()
374     {
375         return m_metadata-&gt;sizeInBytes();
376     }
377 
378 
379 protected:
380     UnlinkedCodeBlock(VM&amp;, Structure*, CodeType, const ExecutableInfo&amp;, OptionSet&lt;CodeGenerationMode&gt;);
381 
382     template&lt;typename CodeBlockType&gt;
383     UnlinkedCodeBlock(Decoder&amp;, Structure*, const CachedCodeBlock&lt;CodeBlockType&gt;&amp;);
384 
385     ~UnlinkedCodeBlock();
386 
387     void finishCreation(VM&amp; vm)
388     {
389         Base::finishCreation(vm);
390     }
391 
392 private:
393     friend class BytecodeRewriter;
<a name="31" id="anc31"></a><span class="line-modified">394     friend class BytecodeGenerator;</span>


395 
396     template&lt;typename CodeBlockType&gt;
397     friend class CachedCodeBlock;
398 
<a name="32" id="anc32"></a><span class="line-modified">399     void applyModification(BytecodeRewriter&amp;, InstructionStreamWriter&amp;);</span>
<span class="line-removed">400 </span>
<span class="line-removed">401     void createRareDataIfNecessary()</span>
402     {
<a name="33" id="anc33"></a><span class="line-modified">403         if (!m_rareData) {</span>
<span class="line-removed">404             auto locker = lockDuringMarking(*heap(), cellLock());</span>
405             m_rareData = makeUnique&lt;RareData&gt;();
<a name="34" id="anc34"></a><span class="line-removed">406         }</span>
407     }
408 
409     void getLineAndColumn(const ExpressionRangeInfo&amp;, unsigned&amp; line, unsigned&amp; column) const;
410     BytecodeLivenessAnalysis&amp; livenessAnalysisSlow(CodeBlock*);
411 
412 
413     VirtualRegister m_thisRegister;
414     VirtualRegister m_scopeRegister;
415 
<a name="35" id="anc35"></a><span class="line-removed">416     std::array&lt;unsigned, LinkTimeConstantCount&gt; m_linkTimeConstants;</span>
<span class="line-removed">417 </span>
418     unsigned m_usesEval : 1;
419     unsigned m_isStrictMode : 1;
420     unsigned m_isConstructor : 1;
421     unsigned m_hasCapturedVariables : 1;
422     unsigned m_isBuiltinFunction : 1;
423     unsigned m_superBinding : 1;
424     unsigned m_scriptMode: 1;
425     unsigned m_isArrowFunctionContext : 1;
426     unsigned m_isClassContext : 1;
427     unsigned m_hasTailCalls : 1;
428     unsigned m_constructorKind : 2;
429     unsigned m_derivedContextType : 2;
430     unsigned m_evalContextType : 2;
431     unsigned m_codeType : 2;
432     unsigned m_didOptimize : 2;
433     unsigned m_age : 3;
434     static_assert(((1U &lt;&lt; 3) - 1) &gt;= maxAge);
<a name="36" id="anc36"></a>
435 public:
436     ConcurrentJSLock m_lock;
437 private:
438     CodeFeatures m_features { 0 };
439     SourceParseMode m_parseMode;
440     OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;
441 
442     unsigned m_lineCount { 0 };
443     unsigned m_endColumn { UINT_MAX };
444 
445     int m_numVars { 0 };
446     int m_numCalleeLocals { 0 };
447     int m_numParameters { 0 };
448 
<a name="37" id="anc37"></a><span class="line-modified">449     String m_sourceURLDirective;</span>
<span class="line-modified">450     String m_sourceMappingURLDirective;</span>
451 
<a name="38" id="anc38"></a><span class="line-modified">452     Vector&lt;InstructionStream::Offset&gt; m_jumpTargets;</span>
453     Ref&lt;UnlinkedMetadataTable&gt; m_metadata;
454     std::unique_ptr&lt;InstructionStream&gt; m_instructions;
455     std::unique_ptr&lt;BytecodeLivenessAnalysis&gt; m_liveness;
456 
457 
458 #if ENABLE(DFG_JIT)
459     DFG::ExitProfile m_exitProfile;
460 #endif
461 
<a name="39" id="anc39"></a><span class="line-removed">462 </span>
<span class="line-removed">463     Vector&lt;InstructionStream::Offset&gt; m_propertyAccessInstructions;</span>
<span class="line-removed">464 </span>
465     // Constant Pools
<a name="40" id="anc40"></a><span class="line-modified">466     Vector&lt;Identifier&gt; m_identifiers;</span>
<span class="line-modified">467     Vector&lt;WriteBarrier&lt;Unknown&gt;&gt; m_constantRegisters;</span>
<span class="line-modified">468     Vector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;</span>
<span class="line-modified">469     typedef Vector&lt;WriteBarrier&lt;UnlinkedFunctionExecutable&gt;&gt; FunctionExpressionVector;</span>
470     FunctionExpressionVector m_functionDecls;
471     FunctionExpressionVector m_functionExprs;
472 
473 public:
474     struct RareData {
475         WTF_MAKE_STRUCT_FAST_ALLOCATED;
476 
<a name="41" id="anc41"></a><span class="line-modified">477         Vector&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;</span>
478 
479         // Jump Tables
<a name="42" id="anc42"></a><span class="line-modified">480         Vector&lt;UnlinkedSimpleJumpTable&gt; m_switchJumpTables;</span>
<span class="line-modified">481         Vector&lt;UnlinkedStringJumpTable&gt; m_stringSwitchJumpTables;</span>
482 
<a name="43" id="anc43"></a><span class="line-modified">483         Vector&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;</span>
484 
485         struct TypeProfilerExpressionRange {
486             unsigned m_startDivot;
487             unsigned m_endDivot;
488         };
489         HashMap&lt;unsigned, TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
<a name="44" id="anc44"></a><span class="line-modified">490         Vector&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;</span>
<span class="line-modified">491         Vector&lt;BitVector&gt; m_bitVectors;</span>
<span class="line-modified">492         Vector&lt;ConstantIdentifierSetEntry&gt; m_constantIdentifierSets;</span>


493     };
494 
<a name="45" id="anc45"></a><span class="line-removed">495     void addOutOfLineJumpTarget(InstructionStream::Offset, int target);</span>
496     int outOfLineJumpOffset(InstructionStream::Offset);
497     int outOfLineJumpOffset(const InstructionStream::Ref&amp; instruction)
498     {
499         return outOfLineJumpOffset(instruction.offset());
500     }
501 
502 private:
503     using OutOfLineJumpTargets = HashMap&lt;InstructionStream::Offset, int&gt;;
504 
<a name="46" id="anc46"></a><span class="line-removed">505     OutOfLineJumpTargets replaceOutOfLineJumpTargets()</span>
<span class="line-removed">506     {</span>
<span class="line-removed">507         OutOfLineJumpTargets newJumpTargets;</span>
<span class="line-removed">508         std::swap(m_outOfLineJumpTargets, newJumpTargets);</span>
<span class="line-removed">509         return newJumpTargets;</span>
<span class="line-removed">510     }</span>
<span class="line-removed">511 </span>
512     OutOfLineJumpTargets m_outOfLineJumpTargets;
513     std::unique_ptr&lt;RareData&gt; m_rareData;
<a name="47" id="anc47"></a><span class="line-modified">514     Vector&lt;ExpressionRangeInfo&gt; m_expressionInfo;</span>
515 
516 protected:
517     static void visitChildren(JSCell*, SlotVisitor&amp;);
518     static size_t estimatedSize(JSCell*, VM&amp;);
519 
520 public:
521     DECLARE_INFO;
522 };
523 
524 }
<a name="48" id="anc48"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="48" type="hidden" />
</body>
</html>
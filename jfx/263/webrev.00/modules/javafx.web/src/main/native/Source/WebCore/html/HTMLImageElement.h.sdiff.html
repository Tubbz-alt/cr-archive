<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLImageElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLImageElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLInputElement.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLImageElement.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #pragma once
 25 
 26 #include &quot;DecodingOptions.h&quot;
 27 #include &quot;FormNamedItem.h&quot;
 28 #include &quot;GraphicsLayer.h&quot;
 29 #include &quot;GraphicsTypes.h&quot;
 30 #include &quot;HTMLElement.h&quot;
<span class="line-modified"> 31 #include &quot;HTMLImageLoader.h&quot;</span>

 32 
 33 namespace WebCore {
 34 


 35 class EditableImageReference;
 36 class HTMLAttachmentElement;
 37 class HTMLFormElement;

 38 class HTMLMapElement;
 39 
 40 struct ImageCandidate;
 41 
 42 class HTMLImageElement : public HTMLElement, public FormNamedItem {
 43     WTF_MAKE_ISO_ALLOCATED(HTMLImageElement);
 44     friend class HTMLFormElement;
 45 public:
 46     static Ref&lt;HTMLImageElement&gt; create(Document&amp;);
<span class="line-modified"> 47     static Ref&lt;HTMLImageElement&gt; create(const QualifiedName&amp;, Document&amp;, HTMLFormElement*);</span>
 48     static Ref&lt;HTMLImageElement&gt; createForJSConstructor(Document&amp;, Optional&lt;unsigned&gt; width, Optional&lt;unsigned&gt; height);
 49 
 50     virtual ~HTMLImageElement();
 51 
 52     WEBCORE_EXPORT unsigned width(bool ignorePendingStylesheets = false);
 53     WEBCORE_EXPORT unsigned height(bool ignorePendingStylesheets = false);
 54 
 55     WEBCORE_EXPORT int naturalWidth() const;
 56     WEBCORE_EXPORT int naturalHeight() const;
 57     const AtomString&amp; currentSrc() const { return m_currentSrc; }
 58 
 59     bool supportsFocus() const override;
 60     bool isFocusable() const override;
 61 
 62     bool isServerMap() const;
 63 
 64     const AtomString&amp; altText() const;
 65 
 66     CompositeOperator compositeOperator() const { return m_compositeOperator; }
 67 
<span class="line-modified"> 68     CachedImage* cachedImage() const { return m_imageLoader.image(); }</span>
 69 
<span class="line-modified"> 70     void setLoadManually(bool loadManually) { m_imageLoader.setLoadManually(loadManually); }</span>
 71 
 72     bool matchesUsemap(const AtomStringImpl&amp;) const;
 73     HTMLMapElement* associatedMapElement() const;
 74 
 75     WEBCORE_EXPORT const AtomString&amp; alt() const;
 76 
 77     WEBCORE_EXPORT void setHeight(unsigned);
 78 
 79     URL src() const;
 80     void setSrc(const String&amp;);
 81 
 82     WEBCORE_EXPORT void setCrossOrigin(const AtomString&amp;);
 83     WEBCORE_EXPORT String crossOrigin() const;
 84 
 85     WEBCORE_EXPORT void setWidth(unsigned);
 86 
 87     WEBCORE_EXPORT int x() const;
 88     WEBCORE_EXPORT int y() const;
 89 
 90     WEBCORE_EXPORT bool complete() const;
 91 
 92     DecodingMode decodingMode() const;
 93 
 94     WEBCORE_EXPORT void decode(Ref&lt;DeferredPromise&gt;&amp;&amp;);
 95 
 96 #if PLATFORM(IOS_FAMILY)
 97     bool willRespondToMouseClickEvents() override;
 98 #endif
 99 
100 #if ENABLE(ATTACHMENT_ELEMENT)
101     void setAttachmentElement(Ref&lt;HTMLAttachmentElement&gt;&amp;&amp;);
102     RefPtr&lt;HTMLAttachmentElement&gt; attachmentElement() const;
103     const String&amp; attachmentIdentifier() const;
104 #endif
105 
<span class="line-modified">106     bool hasPendingActivity() const { return m_imageLoader.hasPendingActivity(); }</span>
<span class="line-modified">107     size_t pendingDecodePromisesCountForTesting() const { return m_imageLoader.pendingDecodePromisesCountForTesting(); }</span>
108 
109     bool canContainRangeEndPoint() const override { return false; }
110 
111     const AtomString&amp; imageSourceURL() const override;
112 
113     bool hasShadowControls() const { return m_experimentalImageMenuEnabled; }
114 
115     HTMLPictureElement* pictureElement() const;
116     void setPictureElement(HTMLPictureElement*);
117 
118 #if USE(SYSTEM_PREVIEW)
119     WEBCORE_EXPORT bool isSystemPreviewImage() const;
120 #endif
121 
122     WEBCORE_EXPORT GraphicsLayer::EmbeddedViewID editableImageViewID() const;
123     WEBCORE_EXPORT bool hasEditableImageAttribute() const;
124 
125     void defaultEventHandler(Event&amp;) final;
126 







127 protected:
<span class="line-modified">128     HTMLImageElement(const QualifiedName&amp;, Document&amp;, HTMLFormElement* = 0);</span>
129 
130     void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument) override;
131 
132 private:
133     void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) override;
134     bool isPresentationAttribute(const QualifiedName&amp;) const override;
135     void collectStyleForPresentationAttribute(const QualifiedName&amp;, const AtomString&amp;, MutableStyleProperties&amp;) override;
136 
137     void didAttachRenderers() override;
138     RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) override;
139     void setBestFitURLAndDPRFromImageCandidate(const ImageCandidate&amp;);
140 
141     bool canStartSelection() const override;
142 
143     bool isURLAttribute(const Attribute&amp;) const override;
144     bool attributeContainsURL(const Attribute&amp;) const override;
145     String completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp;) const override;
146 
147     bool draggable() const override;
148 
</pre>
<hr />
<pre>
150 
151     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
152     void didFinishInsertingNode() override;
153     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
154 
155     bool isFormAssociatedElement() const final { return false; }
156     FormNamedItem* asFormNamedItem() final { return this; }
157     HTMLImageElement&amp; asHTMLElement() final { return *this; }
158     const HTMLImageElement&amp; asHTMLElement() const final { return *this; }
159 
160     bool isInteractiveContent() const final;
161 
162     void selectImageSource();
163 
164     ImageCandidate bestFitSourceFromPictureElement();
165 
166     void updateEditableImage();
167 
168     void copyNonAttributePropertiesFromElement(const Element&amp;) final;
169 


170 #if ENABLE(SERVICE_CONTROLS)
171     void updateImageControls();
172     void tryCreateImageControls();
173     void destroyImageControls();
174     bool hasImageControls() const;
175     bool childShouldCreateRenderer(const Node&amp;) const override;
176 #endif
177 
<span class="line-modified">178     HTMLImageLoader m_imageLoader;</span>
179     WeakPtr&lt;HTMLFormElement&gt; m_form;
180     WeakPtr&lt;HTMLFormElement&gt; m_formSetByParser;
181 
182     CompositeOperator m_compositeOperator;
183     AtomString m_bestFitImageURL;
184     AtomString m_currentSrc;
185     AtomString m_parsedUsemap;
186     float m_imageDevicePixelRatio;
187     bool m_experimentalImageMenuEnabled;
188     bool m_hadNameBeforeAttributeChanged { false }; // FIXME: We only need this because parseAttribute() can&#39;t see the old value.


189 
190     RefPtr&lt;EditableImageReference&gt; m_editableImage;
191     WeakPtr&lt;HTMLPictureElement&gt; m_pictureElement;

192 
193 #if ENABLE(ATTACHMENT_ELEMENT)
194     String m_pendingClonedAttachmentID;
195 #endif
196 
197     friend class HTMLPictureElement;
198 };
199 
200 } //namespace
</pre>
</td>
<td>
<hr />
<pre>
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #pragma once
 25 
 26 #include &quot;DecodingOptions.h&quot;
 27 #include &quot;FormNamedItem.h&quot;
 28 #include &quot;GraphicsLayer.h&quot;
 29 #include &quot;GraphicsTypes.h&quot;
 30 #include &quot;HTMLElement.h&quot;
<span class="line-modified"> 31 #include &quot;MediaQueryEvaluator.h&quot;</span>
<span class="line-added"> 32 #include &lt;wtf/WeakPtr.h&gt;</span>
 33 
 34 namespace WebCore {
 35 
<span class="line-added"> 36 class CachedImage;</span>
<span class="line-added"> 37 class DeferredPromise;</span>
 38 class EditableImageReference;
 39 class HTMLAttachmentElement;
 40 class HTMLFormElement;
<span class="line-added"> 41 class HTMLImageLoader;</span>
 42 class HTMLMapElement;
 43 
 44 struct ImageCandidate;
 45 
 46 class HTMLImageElement : public HTMLElement, public FormNamedItem {
 47     WTF_MAKE_ISO_ALLOCATED(HTMLImageElement);
 48     friend class HTMLFormElement;
 49 public:
 50     static Ref&lt;HTMLImageElement&gt; create(Document&amp;);
<span class="line-modified"> 51     static Ref&lt;HTMLImageElement&gt; create(const QualifiedName&amp;, Document&amp;, HTMLFormElement* = nullptr, bool createdByParser = false);</span>
 52     static Ref&lt;HTMLImageElement&gt; createForJSConstructor(Document&amp;, Optional&lt;unsigned&gt; width, Optional&lt;unsigned&gt; height);
 53 
 54     virtual ~HTMLImageElement();
 55 
 56     WEBCORE_EXPORT unsigned width(bool ignorePendingStylesheets = false);
 57     WEBCORE_EXPORT unsigned height(bool ignorePendingStylesheets = false);
 58 
 59     WEBCORE_EXPORT int naturalWidth() const;
 60     WEBCORE_EXPORT int naturalHeight() const;
 61     const AtomString&amp; currentSrc() const { return m_currentSrc; }
 62 
 63     bool supportsFocus() const override;
 64     bool isFocusable() const override;
 65 
 66     bool isServerMap() const;
 67 
 68     const AtomString&amp; altText() const;
 69 
 70     CompositeOperator compositeOperator() const { return m_compositeOperator; }
 71 
<span class="line-modified"> 72     WEBCORE_EXPORT CachedImage* cachedImage() const;</span>
 73 
<span class="line-modified"> 74     void setLoadManually(bool);</span>
 75 
 76     bool matchesUsemap(const AtomStringImpl&amp;) const;
 77     HTMLMapElement* associatedMapElement() const;
 78 
 79     WEBCORE_EXPORT const AtomString&amp; alt() const;
 80 
 81     WEBCORE_EXPORT void setHeight(unsigned);
 82 
 83     URL src() const;
 84     void setSrc(const String&amp;);
 85 
 86     WEBCORE_EXPORT void setCrossOrigin(const AtomString&amp;);
 87     WEBCORE_EXPORT String crossOrigin() const;
 88 
 89     WEBCORE_EXPORT void setWidth(unsigned);
 90 
 91     WEBCORE_EXPORT int x() const;
 92     WEBCORE_EXPORT int y() const;
 93 
 94     WEBCORE_EXPORT bool complete() const;
 95 
 96     DecodingMode decodingMode() const;
 97 
 98     WEBCORE_EXPORT void decode(Ref&lt;DeferredPromise&gt;&amp;&amp;);
 99 
100 #if PLATFORM(IOS_FAMILY)
101     bool willRespondToMouseClickEvents() override;
102 #endif
103 
104 #if ENABLE(ATTACHMENT_ELEMENT)
105     void setAttachmentElement(Ref&lt;HTMLAttachmentElement&gt;&amp;&amp;);
106     RefPtr&lt;HTMLAttachmentElement&gt; attachmentElement() const;
107     const String&amp; attachmentIdentifier() const;
108 #endif
109 
<span class="line-modified">110     bool hasPendingActivity() const;</span>
<span class="line-modified">111     WEBCORE_EXPORT size_t pendingDecodePromisesCountForTesting() const;</span>
112 
113     bool canContainRangeEndPoint() const override { return false; }
114 
115     const AtomString&amp; imageSourceURL() const override;
116 
117     bool hasShadowControls() const { return m_experimentalImageMenuEnabled; }
118 
119     HTMLPictureElement* pictureElement() const;
120     void setPictureElement(HTMLPictureElement*);
121 
122 #if USE(SYSTEM_PREVIEW)
123     WEBCORE_EXPORT bool isSystemPreviewImage() const;
124 #endif
125 
126     WEBCORE_EXPORT GraphicsLayer::EmbeddedViewID editableImageViewID() const;
127     WEBCORE_EXPORT bool hasEditableImageAttribute() const;
128 
129     void defaultEventHandler(Event&amp;) final;
130 
<span class="line-added">131     bool createdByParser() const { return m_createdByParser; }</span>
<span class="line-added">132 </span>
<span class="line-added">133     bool isDroppedImagePlaceholder() const { return m_isDroppedImagePlaceholder; }</span>
<span class="line-added">134     void setIsDroppedImagePlaceholder() { m_isDroppedImagePlaceholder = true; }</span>
<span class="line-added">135 </span>
<span class="line-added">136     void evaluateDynamicMediaQueryDependencies();</span>
<span class="line-added">137 </span>
138 protected:
<span class="line-modified">139     HTMLImageElement(const QualifiedName&amp;, Document&amp;, HTMLFormElement* = nullptr, bool createdByParser = false);</span>
140 
141     void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument) override;
142 
143 private:
144     void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) override;
145     bool isPresentationAttribute(const QualifiedName&amp;) const override;
146     void collectStyleForPresentationAttribute(const QualifiedName&amp;, const AtomString&amp;, MutableStyleProperties&amp;) override;
147 
148     void didAttachRenderers() override;
149     RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) override;
150     void setBestFitURLAndDPRFromImageCandidate(const ImageCandidate&amp;);
151 
152     bool canStartSelection() const override;
153 
154     bool isURLAttribute(const Attribute&amp;) const override;
155     bool attributeContainsURL(const Attribute&amp;) const override;
156     String completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp;) const override;
157 
158     bool draggable() const override;
159 
</pre>
<hr />
<pre>
161 
162     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
163     void didFinishInsertingNode() override;
164     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
165 
166     bool isFormAssociatedElement() const final { return false; }
167     FormNamedItem* asFormNamedItem() final { return this; }
168     HTMLImageElement&amp; asHTMLElement() final { return *this; }
169     const HTMLImageElement&amp; asHTMLElement() const final { return *this; }
170 
171     bool isInteractiveContent() const final;
172 
173     void selectImageSource();
174 
175     ImageCandidate bestFitSourceFromPictureElement();
176 
177     void updateEditableImage();
178 
179     void copyNonAttributePropertiesFromElement(const Element&amp;) final;
180 
<span class="line-added">181     float effectiveImageDevicePixelRatio() const;</span>
<span class="line-added">182 </span>
183 #if ENABLE(SERVICE_CONTROLS)
184     void updateImageControls();
185     void tryCreateImageControls();
186     void destroyImageControls();
187     bool hasImageControls() const;
188     bool childShouldCreateRenderer(const Node&amp;) const override;
189 #endif
190 
<span class="line-modified">191     std::unique_ptr&lt;HTMLImageLoader&gt; m_imageLoader;</span>
192     WeakPtr&lt;HTMLFormElement&gt; m_form;
193     WeakPtr&lt;HTMLFormElement&gt; m_formSetByParser;
194 
195     CompositeOperator m_compositeOperator;
196     AtomString m_bestFitImageURL;
197     AtomString m_currentSrc;
198     AtomString m_parsedUsemap;
199     float m_imageDevicePixelRatio;
200     bool m_experimentalImageMenuEnabled;
201     bool m_hadNameBeforeAttributeChanged { false }; // FIXME: We only need this because parseAttribute() can&#39;t see the old value.
<span class="line-added">202     bool m_createdByParser { false };</span>
<span class="line-added">203     bool m_isDroppedImagePlaceholder { false };</span>
204 
205     RefPtr&lt;EditableImageReference&gt; m_editableImage;
206     WeakPtr&lt;HTMLPictureElement&gt; m_pictureElement;
<span class="line-added">207     MediaQueryDynamicResults m_mediaQueryDynamicResults;</span>
208 
209 #if ENABLE(ATTACHMENT_ELEMENT)
210     String m_pendingClonedAttachmentID;
211 #endif
212 
213     friend class HTMLPictureElement;
214 };
215 
216 } //namespace
</pre>
</td>
</tr>
</table>
<center><a href="HTMLImageElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLInputElement.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/PODRedBlackTree.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PODIntervalTree.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Pasteboard.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/PODRedBlackTree.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (C) 2010 Google Inc. All rights reserved.
<span class="line-added">+  * Copyright (C) 2019-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,100 ***</span>
  //
  //   Insertion: O(lg(n))
  //   Deletion:  O(lg(n))
  //   Querying:  O(lg(n))
  //
<span class="line-removed">- // The data type T that is stored in this red-black tree must be only</span>
<span class="line-removed">- // Plain Old Data (POD), or bottom out into POD. It must _not_ rely on</span>
<span class="line-removed">- // having its destructor called. This implementation internally</span>
<span class="line-removed">- // allocates storage in large chunks and does not call the destructor</span>
<span class="line-removed">- // on each object.</span>
<span class="line-removed">- //</span>
  // Type T must supply a default constructor, a copy constructor, and
  // the &quot;&lt;&quot; and &quot;==&quot; operators.
  //
  // In debug mode, printing of the data contained in the tree is
<span class="line-modified">! // enabled. This requires the template specialization to be available:</span>
<span class="line-removed">- //</span>
<span class="line-removed">- //   template&lt;&gt; struct WebCore::ValueToString&lt;T&gt; {</span>
<span class="line-removed">- //       static String string(const T&amp; t);</span>
<span class="line-removed">- //   };</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // Note that when complex types are stored in this red/black tree, it</span>
<span class="line-removed">- // is possible that single invocations of the &quot;&lt;&quot; and &quot;==&quot; operators</span>
<span class="line-removed">- // will be insufficient to describe the ordering of elements in the</span>
<span class="line-removed">- // tree during queries. As a concrete example, consider the case where</span>
<span class="line-removed">- // intervals are stored in the tree sorted by low endpoint. The &quot;&lt;&quot;</span>
<span class="line-removed">- // operator on the Interval class only compares the low endpoint, but</span>
<span class="line-removed">- // the &quot;==&quot; operator takes into account the high endpoint as well.</span>
<span class="line-removed">- // This makes the necessary logic for querying and deletion somewhat</span>
<span class="line-removed">- // more complex. In order to properly handle such situations, the</span>
<span class="line-removed">- // property &quot;needsFullOrderingComparisons&quot; must be set to true on</span>
<span class="line-removed">- // the tree.</span>
  //
  // This red-black tree is designed to be _augmented_; subclasses can
  // add additional and summary information to each node to efficiently
  // store and index more complex data structures. A concrete example is
  // the IntervalTree, which extends each node with a summary statistic
  // to efficiently store one-dimensional intervals.
  //
  // The design of this red-black tree comes from Cormen, Leiserson,
  // and Rivest, _Introduction to Algorithms_, MIT Press, 1990.
  
<span class="line-modified">! #ifndef PODRedBlackTree_h</span>
<span class="line-removed">- #define PODRedBlackTree_h</span>
  
  #include &lt;wtf/Assertions.h&gt;
  #include &lt;wtf/Noncopyable.h&gt;
<span class="line-modified">! #include &lt;wtf/text/ValueToString.h&gt;</span>
  #ifndef NDEBUG
  #include &lt;wtf/text/StringBuilder.h&gt;
<span class="line-modified">! #include &lt;wtf/text/WTFString.h&gt;</span>
  #endif
  
  namespace WebCore {
  
<span class="line-modified">! template&lt;class T&gt;</span>
<span class="line-modified">! class PODRedBlackTree {</span>
<span class="line-removed">-     WTF_MAKE_FAST_ALLOCATED;</span>
  public:
<span class="line-modified">!     class Node;</span>
  
<span class="line-modified">!     // Visitor interface for walking all of the tree&#39;s elements.</span>
<span class="line-removed">-     class Visitor {</span>
<span class="line-removed">-     public:</span>
<span class="line-removed">-         virtual void visit(const T&amp; data) = 0;</span>
<span class="line-removed">-     protected:</span>
<span class="line-removed">-         virtual ~Visitor() = default;</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     PODRedBlackTree()</span>
<span class="line-removed">-         : m_root(0)</span>
<span class="line-removed">-         , m_needsFullOrderingComparisons(false)</span>
<span class="line-removed">- #ifndef NDEBUG</span>
<span class="line-removed">-         , m_verboseDebugging(false)</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     virtual ~PODRedBlackTree()</span>
      {
          clear();
      }
  
<span class="line-removed">-     // Clearing will delete the contents of the tree. After this call</span>
<span class="line-removed">-     // isInitialized will return false.</span>
      void clear()
      {
<span class="line-modified">!         markFree(m_root);</span>
<span class="line-modified">!         m_root = 0;</span>
      }
  
      void add(const T&amp; data)
      {
<span class="line-modified">!         Node* node = new Node(data);</span>
<span class="line-modified">!         insertNode(node);</span>
      }
  
      // Returns true if the datum was found in the tree.
      bool remove(const T&amp; data)
      {
<span class="line-new-header">--- 31,70 ---</span>
  //
  //   Insertion: O(lg(n))
  //   Deletion:  O(lg(n))
  //   Querying:  O(lg(n))
  //
  // Type T must supply a default constructor, a copy constructor, and
  // the &quot;&lt;&quot; and &quot;==&quot; operators.
  //
  // In debug mode, printing of the data contained in the tree is
<span class="line-modified">! // enabled. This makes use of WTF::TextStream.</span>
  //
  // This red-black tree is designed to be _augmented_; subclasses can
  // add additional and summary information to each node to efficiently
  // store and index more complex data structures. A concrete example is
  // the IntervalTree, which extends each node with a summary statistic
  // to efficiently store one-dimensional intervals.
  //
  // The design of this red-black tree comes from Cormen, Leiserson,
  // and Rivest, _Introduction to Algorithms_, MIT Press, 1990.
  
<span class="line-modified">! #pragma once</span>
  
  #include &lt;wtf/Assertions.h&gt;
  #include &lt;wtf/Noncopyable.h&gt;
<span class="line-modified">! </span>
  #ifndef NDEBUG
  #include &lt;wtf/text/StringBuilder.h&gt;
<span class="line-modified">! #include &lt;wtf/text/TextStream.h&gt;</span>
  #endif
  
<span class="line-added">+ // FIXME: The prefix &quot;POD&quot; here isn&#39;t correct; this tree works with non-POD types too.</span>
<span class="line-added">+ // FIXME: Extend WTF::RedBlackTree and implement this on top of it rather than keeping two quite similar class templates around.</span>
<span class="line-added">+ </span>
  namespace WebCore {
  
<span class="line-modified">! template&lt;typename T, typename NodeUpdaterType&gt; class PODRedBlackTree {</span>
<span class="line-modified">!     WTF_MAKE_NONCOPYABLE(PODRedBlackTree);</span>
  public:
<span class="line-modified">!     PODRedBlackTree() = default;</span>
  
<span class="line-modified">!     ~PODRedBlackTree()</span>
      {
          clear();
      }
  
      void clear()
      {
<span class="line-modified">!         if (!m_root)</span>
<span class="line-modified">!             return;</span>
<span class="line-added">+         Node* next;</span>
<span class="line-added">+         for (Node* node = treeMinimum(m_root); node; node = next) {</span>
<span class="line-added">+             next = treeSuccessorInPostOrder(node);</span>
<span class="line-added">+             delete node;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         m_root = nullptr;</span>
      }
  
      void add(const T&amp; data)
      {
<span class="line-modified">!         add(T { data });</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void add(T&amp;&amp; data)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         insertNode(new Node(WTFMove(data)));</span>
      }
  
      // Returns true if the datum was found in the tree.
      bool remove(const T&amp; data)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,90 ***</span>
      bool contains(const T&amp; data) const
      {
          return treeSearch(data);
      }
  
<span class="line-modified">!     void visitInorder(Visitor* visitor) const</span>
      {
<span class="line-modified">!         if (!m_root)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         visitInorderImpl(m_root, visitor);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     int size() const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         Counter counter;</span>
<span class="line-removed">-         visitInorder(&amp;counter);</span>
<span class="line-removed">-         return counter.count();</span>
      }
  
<span class="line-modified">!     // See the class documentation for an explanation of this property.</span>
<span class="line-removed">-     void setNeedsFullOrderingComparisons(bool needsFullOrderingComparisons)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         m_needsFullOrderingComparisons = needsFullOrderingComparisons;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     virtual bool checkInvariants() const</span>
      {
          int blackCount;
<span class="line-modified">!         return checkInvariantsFromNode(m_root, &amp;blackCount);</span>
      }
  
<span class="line-modified">! #ifndef NDEBUG</span>
<span class="line-removed">-     // Dumps the tree&#39;s contents to the logging info stream for</span>
<span class="line-removed">-     // debugging purposes.</span>
      void dump() const
      {
<span class="line-modified">!         dumpFromNode(m_root, 0);</span>
      }
  
      // Turns on or off verbose debugging of the tree, causing many
      // messages to be logged during insertion and other operations in
      // debug mode.
      void setVerboseDebugging(bool verboseDebugging)
      {
          m_verboseDebugging = verboseDebugging;
      }
  #endif
  
<span class="line-modified">!     enum Color {</span>
<span class="line-modified">!         Red = 1,</span>
<span class="line-removed">-         Black</span>
<span class="line-removed">-     };</span>
  
<span class="line-removed">-     // The base Node class which is stored in the tree. Nodes are only</span>
<span class="line-removed">-     // an internal concept; users of the tree deal only with the data</span>
<span class="line-removed">-     // they store in it.</span>
      class Node {
          WTF_MAKE_FAST_ALLOCATED;
          WTF_MAKE_NONCOPYABLE(Node);
      public:
<span class="line-modified">!         // Constructor. Newly-created nodes are colored red.</span>
<span class="line-modified">!         explicit Node(const T&amp; data)</span>
<span class="line-removed">-             : m_left(0)</span>
<span class="line-removed">-             , m_right(0)</span>
<span class="line-removed">-             , m_parent(0)</span>
<span class="line-removed">-             , m_color(Red)</span>
<span class="line-removed">-             , m_data(data)</span>
          {
          }
  
<span class="line-removed">-         virtual ~Node() = default;</span>
<span class="line-removed">- </span>
          Color color() const { return m_color; }
          void setColor(Color color) { m_color = color; }
  
<span class="line-removed">-         // Fetches the user data.</span>
          T&amp; data() { return m_data; }
  
<span class="line-modified">!         // Copies all user-level fields from the source node, but not</span>
<span class="line-removed">-         // internal fields. For example, the base implementation of this</span>
<span class="line-removed">-         // method copies the &quot;m_data&quot; field, but not the child or parent</span>
<span class="line-removed">-         // fields. Any augmentation information also does not need to be</span>
<span class="line-removed">-         // copied, as it will be recomputed. Subclasses must call the</span>
<span class="line-removed">-         // superclass implementation.</span>
<span class="line-removed">-         virtual void copyFrom(Node* src) { m_data = src-&gt;data(); }</span>
  
          Node* left() const { return m_left; }
          void setLeft(Node* node) { m_left = node; }
  
          Node* right() const { return m_right; }
<span class="line-new-header">--- 109,57 ---</span>
      bool contains(const T&amp; data) const
      {
          return treeSearch(data);
      }
  
<span class="line-modified">!     bool isEmpty() const</span>
      {
<span class="line-modified">!         return !m_root;</span>
      }
  
<span class="line-modified">! #ifndef NDEBUG</span>
  
<span class="line-modified">!     bool checkInvariants() const</span>
      {
          int blackCount;
<span class="line-modified">!         return checkInvariantsFromNode(m_root, blackCount);</span>
      }
  
<span class="line-modified">!     // Dumps the tree&#39;s contents to the logging info stream for debugging purposes.</span>
      void dump() const
      {
<span class="line-modified">!         dumpSubtree(m_root, 0);</span>
      }
  
      // Turns on or off verbose debugging of the tree, causing many
      // messages to be logged during insertion and other operations in
      // debug mode.
      void setVerboseDebugging(bool verboseDebugging)
      {
          m_verboseDebugging = verboseDebugging;
      }
<span class="line-added">+ </span>
  #endif
  
<span class="line-modified">! protected:</span>
<span class="line-modified">!     enum Color { Red, Black };</span>
  
      class Node {
          WTF_MAKE_FAST_ALLOCATED;
          WTF_MAKE_NONCOPYABLE(Node);
      public:
<span class="line-modified">!         explicit Node(T&amp;&amp; data)</span>
<span class="line-modified">!             : m_data(WTFMove(data))</span>
          {
          }
  
          Color color() const { return m_color; }
          void setColor(Color color) { m_color = color; }
  
          T&amp; data() { return m_data; }
  
<span class="line-modified">!         void moveDataFrom(Node&amp; src) { m_data = WTFMove(src.m_data); }</span>
  
          Node* left() const { return m_left; }
          void setLeft(Node* node) { m_left = node; }
  
          Node* right() const { return m_right; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 229,84 ***</span>
  
          Node* parent() const { return m_parent; }
          void setParent(Node* node) { m_parent = node; }
  
      private:
<span class="line-modified">!         Node* m_left;</span>
<span class="line-modified">!         Node* m_right;</span>
<span class="line-modified">!         Node* m_parent;</span>
<span class="line-modified">!         Color m_color;</span>
          T m_data;
      };
  
<span class="line-removed">- protected:</span>
      // Returns the root of the tree, which is needed by some subclasses.
      Node* root() const { return m_root; }
  
  private:
<span class="line-modified">!     // This virtual method is the hook that subclasses should use when</span>
      // augmenting the red-black tree with additional per-node summary
      // information. For example, in the case of an interval tree, this
      // is used to compute the maximum endpoint of the subtree below the
      // given node based on the values in the left and right children. It
      // is guaranteed that this will be called in the correct order to
      // properly update such summary information based only on the values
<span class="line-modified">!     // in the left and right children. This method should return true if</span>
      // the node&#39;s summary information changed.
<span class="line-modified">!     virtual bool updateNode(Node*) { return false; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     //----------------------------------------------------------------------</span>
<span class="line-removed">-     // Generic binary search tree operations</span>
<span class="line-removed">-     //</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Searches the tree for the given datum.</span>
<span class="line-removed">-     Node* treeSearch(const T&amp; data) const</span>
      {
<span class="line-modified">!         if (m_needsFullOrderingComparisons)</span>
<span class="line-removed">-             return treeSearchFullComparisons(m_root, data);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return treeSearchNormal(m_root, data);</span>
      }
  
<span class="line-modified">!     // Searches the tree using the normal comparison operations,</span>
<span class="line-removed">-     // suitable for simple data types such as numbers.</span>
<span class="line-removed">-     Node* treeSearchNormal(Node* current, const T&amp; data) const</span>
      {
<span class="line-modified">!         while (current) {</span>
              if (current-&gt;data() == data)
                  return current;
              if (data &lt; current-&gt;data())
                  current = current-&gt;left();
              else
                  current = current-&gt;right();
          }
<span class="line-modified">!         return 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Searches the tree using multiple comparison operations, required</span>
<span class="line-removed">-     // for data types with more complex behavior such as intervals.</span>
<span class="line-removed">-     Node* treeSearchFullComparisons(Node* current, const T&amp; data) const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         if (!current)</span>
<span class="line-removed">-             return 0;</span>
<span class="line-removed">-         if (data &lt; current-&gt;data())</span>
<span class="line-removed">-             return treeSearchFullComparisons(current-&gt;left(), data);</span>
<span class="line-removed">-         if (current-&gt;data() &lt; data)</span>
<span class="line-removed">-             return treeSearchFullComparisons(current-&gt;right(), data);</span>
<span class="line-removed">-         if (data == current-&gt;data())</span>
<span class="line-removed">-             return current;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // We may need to traverse both the left and right subtrees.</span>
<span class="line-removed">-         Node* result = treeSearchFullComparisons(current-&gt;left(), data);</span>
<span class="line-removed">-         if (!result)</span>
<span class="line-removed">-             result = treeSearchFullComparisons(current-&gt;right(), data);</span>
<span class="line-removed">-         return result;</span>
      }
  
      void treeInsert(Node* z)
      {
<span class="line-modified">!         Node* y = 0;</span>
          Node* x = m_root;
          while (x) {
              y = x;
              if (z-&gt;data() &lt; x-&gt;data())
                  x = x-&gt;left();
<span class="line-new-header">--- 167,51 ---</span>
  
          Node* parent() const { return m_parent; }
          void setParent(Node* node) { m_parent = node; }
  
      private:
<span class="line-modified">!         Node* m_left { nullptr };</span>
<span class="line-modified">!         Node* m_right { nullptr };</span>
<span class="line-modified">!         Node* m_parent { nullptr };</span>
<span class="line-modified">!         Color m_color { Red };</span>
          T m_data;
      };
  
      // Returns the root of the tree, which is needed by some subclasses.
      Node* root() const { return m_root; }
  
  private:
<span class="line-modified">!     // The update function is the hook that subclasses should use when</span>
      // augmenting the red-black tree with additional per-node summary
      // information. For example, in the case of an interval tree, this
      // is used to compute the maximum endpoint of the subtree below the
      // given node based on the values in the left and right children. It
      // is guaranteed that this will be called in the correct order to
      // properly update such summary information based only on the values
<span class="line-modified">!     // in the left and right children. The function should return true if</span>
      // the node&#39;s summary information changed.
<span class="line-modified">!     static bool updateNode(Node&amp; node)</span>
      {
<span class="line-modified">!         return NodeUpdaterType::update(node);</span>
      }
  
<span class="line-modified">!     Node* treeSearch(const T&amp; data) const</span>
      {
<span class="line-modified">!         for (auto* current = m_root; current; ) {</span>
              if (current-&gt;data() == data)
                  return current;
              if (data &lt; current-&gt;data())
                  current = current-&gt;left();
              else
                  current = current-&gt;right();
          }
<span class="line-modified">!         return nullptr;</span>
      }
  
      void treeInsert(Node* z)
      {
<span class="line-modified">!         Node* y = nullptr;</span>
          Node* x = m_root;
          while (x) {
              y = x;
              if (z-&gt;data() &lt; x-&gt;data())
                  x = x-&gt;left();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 324,11 ***</span>
          }
      }
  
      // Finds the node following the given one in sequential ordering of
      // their data, or null if none exists.
<span class="line-modified">!     Node* treeSuccessor(Node* x)</span>
      {
          if (x-&gt;right())
              return treeMinimum(x-&gt;right());
          Node* y = x-&gt;parent();
          while (y &amp;&amp; x == y-&gt;right()) {
<span class="line-new-header">--- 229,11 ---</span>
          }
      }
  
      // Finds the node following the given one in sequential ordering of
      // their data, or null if none exists.
<span class="line-modified">!     static Node* treeSuccessor(Node* x)</span>
      {
          if (x-&gt;right())
              return treeMinimum(x-&gt;right());
          Node* y = x-&gt;parent();
          while (y &amp;&amp; x == y-&gt;right()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 336,27 ***</span>
              y = y-&gt;parent();
          }
          return y;
      }
  
<span class="line-modified">!     // Finds the minimum element in the sub-tree rooted at the given</span>
<span class="line-modified">!     // node.</span>
<span class="line-removed">-     Node* treeMinimum(Node* x)</span>
      {
          while (x-&gt;left())
              x = x-&gt;left();
          return x;
      }
  
<span class="line-modified">!     // Helper for maintaining the augmented red-black tree.</span>
<span class="line-removed">-     void propagateUpdates(Node* start)</span>
      {
<span class="line-modified">!         bool shouldContinue = true;</span>
<span class="line-modified">!         while (start &amp;&amp; shouldContinue) {</span>
<span class="line-modified">!             shouldContinue = updateNode(start);</span>
<span class="line-modified">!             start = start-&gt;parent();</span>
<span class="line-removed">-         }</span>
      }
  
      //----------------------------------------------------------------------
      // Red-Black tree operations
      //
<span class="line-new-header">--- 241,24 ---</span>
              y = y-&gt;parent();
          }
          return y;
      }
  
<span class="line-modified">!     // Finds the minimum element in the sub-tree rooted at the given node.</span>
<span class="line-modified">!     static Node* treeMinimum(Node* x)</span>
      {
          while (x-&gt;left())
              x = x-&gt;left();
          return x;
      }
  
<span class="line-modified">!     static Node* treeSuccessorInPostOrder(Node* x)</span>
      {
<span class="line-modified">!         Node* y = x-&gt;parent();</span>
<span class="line-modified">!         if (y &amp;&amp; x == y-&gt;left() &amp;&amp; y-&gt;right())</span>
<span class="line-modified">!             return treeMinimum(y-&gt;right());</span>
<span class="line-modified">!         return y;</span>
      }
  
      //----------------------------------------------------------------------
      // Red-Black tree operations
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 387,15 ***</span>
          // Put x on y&#39;s left.
          y-&gt;setLeft(x);
          x-&gt;setParent(y);
  
          // Update nodes lowest to highest.
<span class="line-modified">!         updateNode(x);</span>
<span class="line-modified">!         updateNode(y);</span>
          return y;
      }
  
      // Right-rotates the subtree rooted at y.
      // Returns the new root of the subtree (y&#39;s left child).
      Node* rightRotate(Node* y)
      {
          // Set x.
<span class="line-new-header">--- 289,21 ---</span>
          // Put x on y&#39;s left.
          y-&gt;setLeft(x);
          x-&gt;setParent(y);
  
          // Update nodes lowest to highest.
<span class="line-modified">!         updateNode(*x);</span>
<span class="line-modified">!         updateNode(*y);</span>
          return y;
      }
  
<span class="line-added">+     static void propagateUpdates(Node* start)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         while (start &amp;&amp; updateNode(*start))</span>
<span class="line-added">+             start = start-&gt;parent();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // Right-rotates the subtree rooted at y.
      // Returns the new root of the subtree (y&#39;s left child).
      Node* rightRotate(Node* y)
      {
          // Set x.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 420,21 ***</span>
          // Put y on x&#39;s right.
          x-&gt;setRight(y);
          y-&gt;setParent(x);
  
          // Update nodes lowest to highest.
<span class="line-modified">!         updateNode(y);</span>
<span class="line-modified">!         updateNode(x);</span>
          return x;
      }
  
      // Inserts the given node into the tree.
      void insertNode(Node* x)
      {
          treeInsert(x);
          x-&gt;setColor(Red);
<span class="line-modified">!         updateNode(x);</span>
  
          logIfVerbose(&quot;  PODRedBlackTree::InsertNode&quot;);
  
          // The node from which to start propagating updates upwards.
          Node* updateStart = x-&gt;parent();
<span class="line-new-header">--- 328,21 ---</span>
          // Put y on x&#39;s right.
          x-&gt;setRight(y);
          y-&gt;setParent(x);
  
          // Update nodes lowest to highest.
<span class="line-modified">!         updateNode(*y);</span>
<span class="line-modified">!         updateNode(*x);</span>
          return x;
      }
  
      // Inserts the given node into the tree.
      void insertNode(Node* x)
      {
          treeInsert(x);
          x-&gt;setColor(Red);
<span class="line-modified">!         updateNode(*x);</span>
  
          logIfVerbose(&quot;  PODRedBlackTree::InsertNode&quot;);
  
          // The node from which to start propagating updates upwards.
          Node* updateStart = x-&gt;parent();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 446,13 ***</span>
                      // Case 1
                      logIfVerbose(&quot;  Case 1/1&quot;);
                      x-&gt;parent()-&gt;setColor(Black);
                      y-&gt;setColor(Black);
                      x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
<span class="line-modified">!                     updateNode(x-&gt;parent());</span>
                      x = x-&gt;parent()-&gt;parent();
<span class="line-modified">!                     updateNode(x);</span>
                      updateStart = x-&gt;parent();
                  } else {
                      if (x == x-&gt;parent()-&gt;right()) {
                          logIfVerbose(&quot;  Case 1/2&quot;);
                          // Case 2
<span class="line-new-header">--- 354,13 ---</span>
                      // Case 1
                      logIfVerbose(&quot;  Case 1/1&quot;);
                      x-&gt;parent()-&gt;setColor(Black);
                      y-&gt;setColor(Black);
                      x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
<span class="line-modified">!                     updateNode(*x-&gt;parent());</span>
                      x = x-&gt;parent()-&gt;parent();
<span class="line-modified">!                     updateNode(*x);</span>
                      updateStart = x-&gt;parent();
                  } else {
                      if (x == x-&gt;parent()-&gt;right()) {
                          logIfVerbose(&quot;  Case 1/2&quot;);
                          // Case 2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 473,13 ***</span>
                      // Case 1
                      logIfVerbose(&quot;  Case 2/1&quot;);
                      x-&gt;parent()-&gt;setColor(Black);
                      y-&gt;setColor(Black);
                      x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
<span class="line-modified">!                     updateNode(x-&gt;parent());</span>
                      x = x-&gt;parent()-&gt;parent();
<span class="line-modified">!                     updateNode(x);</span>
                      updateStart = x-&gt;parent();
                  } else {
                      if (x == x-&gt;parent()-&gt;left()) {
                          // Case 2
                          logIfVerbose(&quot;  Case 2/2&quot;);
<span class="line-new-header">--- 381,13 ---</span>
                      // Case 1
                      logIfVerbose(&quot;  Case 2/1&quot;);
                      x-&gt;parent()-&gt;setColor(Black);
                      y-&gt;setColor(Black);
                      x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
<span class="line-modified">!                     updateNode(*x-&gt;parent());</span>
                      x = x-&gt;parent()-&gt;parent();
<span class="line-modified">!                     updateNode(*x);</span>
                      updateStart = x-&gt;parent();
                  } else {
                      if (x == x-&gt;parent()-&gt;left()) {
                          // Case 2
                          logIfVerbose(&quot;  Case 2/2&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 500,12 ***</span>
  
          m_root-&gt;setColor(Black);
      }
  
      // Restores the red-black property to the tree after splicing out
<span class="line-modified">!     // a node. Note that x may be null, which is why xParent must be</span>
<span class="line-removed">-     // supplied.</span>
      void deleteFixup(Node* x, Node* xParent)
      {
          while (x != m_root &amp;&amp; (!x || x-&gt;color() == Black)) {
              if (x == xParent-&gt;left()) {
                  // Note: the text points out that w can not be null.
<span class="line-new-header">--- 408,11 ---</span>
  
          m_root-&gt;setColor(Black);
      }
  
      // Restores the red-black property to the tree after splicing out
<span class="line-modified">!     // a node. Note that x may be null, which is why xParent must be supplied.</span>
      void deleteFixup(Node* x, Node* xParent)
      {
          while (x != m_root &amp;&amp; (!x || x-&gt;color() == Black)) {
              if (x == xParent-&gt;left()) {
                  // Note: the text points out that w can not be null.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 625,13 ***</span>
                  y-&gt;parent()-&gt;setLeft(x);
              else
                  y-&gt;parent()-&gt;setRight(x);
          }
          if (y != z) {
<span class="line-modified">!             z-&gt;copyFrom(y);</span>
              // This node has changed location in the tree and must be updated.
<span class="line-modified">!             updateNode(z);</span>
              // The parent and its parents may now be out of date.
              propagateUpdates(z-&gt;parent());
          }
  
          // If we haven&#39;t already updated starting from xParent, do so now.
<span class="line-new-header">--- 532,13 ---</span>
                  y-&gt;parent()-&gt;setLeft(x);
              else
                  y-&gt;parent()-&gt;setRight(x);
          }
          if (y != z) {
<span class="line-modified">!             z-&gt;moveDataFrom(*y);</span>
              // This node has changed location in the tree and must be updated.
<span class="line-modified">!             updateNode(*z);</span>
              // The parent and its parents may now be out of date.
              propagateUpdates(z-&gt;parent());
          }
  
          // If we haven&#39;t already updated starting from xParent, do so now.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 641,60 ***</span>
              deleteFixup(x, xParent);
  
          delete y;
      }
  
<span class="line-removed">-     // Visits the subtree rooted at the given node in order.</span>
<span class="line-removed">-     void visitInorderImpl(Node* node, Visitor* visitor) const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         if (node-&gt;left())</span>
<span class="line-removed">-             visitInorderImpl(node-&gt;left(), visitor);</span>
<span class="line-removed">-         visitor-&gt;visit(node-&gt;data());</span>
<span class="line-removed">-         if (node-&gt;right())</span>
<span class="line-removed">-             visitInorderImpl(node-&gt;right(), visitor);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void markFree(Node *node)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         if (!node)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (node-&gt;left())</span>
<span class="line-removed">-             markFree(node-&gt;left());</span>
<span class="line-removed">-         if (node-&gt;right())</span>
<span class="line-removed">-             markFree(node-&gt;right());</span>
<span class="line-removed">-         delete node;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     //----------------------------------------------------------------------</span>
<span class="line-removed">-     // Helper class for size()</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // A Visitor which simply counts the number of visited elements.</span>
<span class="line-removed">-     class Counter : public Visitor {</span>
<span class="line-removed">-         WTF_MAKE_NONCOPYABLE(Counter);</span>
<span class="line-removed">-     public:</span>
<span class="line-removed">-         Counter()</span>
<span class="line-removed">-             : m_count(0) { }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         void visit(const T&amp;) override { ++m_count; }</span>
<span class="line-removed">-         int count() const { return m_count; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private:</span>
<span class="line-removed">-         int m_count;</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
      //----------------------------------------------------------------------
      // Verification and debugging routines
      //
  
      // Returns in the &quot;blackCount&quot; parameter the number of black
      // children along all paths to all leaves of the given node.
<span class="line-modified">!     bool checkInvariantsFromNode(Node* node, int* blackCount) const</span>
      {
          // Base case is a leaf node.
          if (!node) {
<span class="line-modified">!             *blackCount = 1;</span>
              return true;
          }
  
          // Each node is either red or black.
          if (!(node-&gt;color() == Red || node-&gt;color() == Black))
<span class="line-new-header">--- 548,23 ---</span>
              deleteFixup(x, xParent);
  
          delete y;
      }
  
      //----------------------------------------------------------------------
      // Verification and debugging routines
      //
  
<span class="line-added">+ #ifndef NDEBUG</span>
<span class="line-added">+ </span>
      // Returns in the &quot;blackCount&quot; parameter the number of black
      // children along all paths to all leaves of the given node.
<span class="line-modified">!     bool checkInvariantsFromNode(Node* node, int&amp; blackCount) const</span>
      {
          // Base case is a leaf node.
          if (!node) {
<span class="line-modified">!             blackCount = 1;</span>
              return true;
          }
  
          // Each node is either red or black.
          if (!(node-&gt;color() == Red || node-&gt;color() == Black))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 708,21 ***</span>
                  return false;
              if (!((!node-&gt;right() || node-&gt;right()-&gt;color() == Black)))
                  return false;
          }
  
<span class="line-modified">!         // Every simple path to a leaf node contains the same number of</span>
<span class="line-removed">-         // black nodes.</span>
          int leftCount = 0, rightCount = 0;
<span class="line-modified">!         bool leftValid = checkInvariantsFromNode(node-&gt;left(), &amp;leftCount);</span>
<span class="line-modified">!         bool rightValid = checkInvariantsFromNode(node-&gt;right(), &amp;rightCount);</span>
          if (!leftValid || !rightValid)
              return false;
<span class="line-modified">!         *blackCount = leftCount + (node-&gt;color() == Black ? 1 : 0);</span>
          return leftCount == rightCount;
      }
  
  #ifdef NDEBUG
      void logIfVerbose(const char*) const { }
  #else
      void logIfVerbose(const char* output) const
      {
<span class="line-new-header">--- 578,22 ---</span>
                  return false;
              if (!((!node-&gt;right() || node-&gt;right()-&gt;color() == Black)))
                  return false;
          }
  
<span class="line-modified">!         // Every simple path to a leaf node contains the same number of black nodes.</span>
          int leftCount = 0, rightCount = 0;
<span class="line-modified">!         bool leftValid = checkInvariantsFromNode(node-&gt;left(), leftCount);</span>
<span class="line-modified">!         bool rightValid = checkInvariantsFromNode(node-&gt;right(), rightCount);</span>
          if (!leftValid || !rightValid)
              return false;
<span class="line-modified">!         blackCount = leftCount + (node-&gt;color() == Black ? 1 : 0);</span>
          return leftCount == rightCount;
      }
  
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  #ifdef NDEBUG
      void logIfVerbose(const char*) const { }
  #else
      void logIfVerbose(const char* output) const
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 730,38 ***</span>
              LOG_ERROR(&quot;%s&quot;, output);
      }
  #endif
  
  #ifndef NDEBUG
<span class="line-modified">!     // Dumps the subtree rooted at the given node.</span>
<span class="line-modified">!     void dumpFromNode(Node* node, int indentation) const</span>
      {
          StringBuilder builder;
          for (int i = 0; i &lt; indentation; i++)
              builder.append(&#39; &#39;);
          builder.append(&#39;-&#39;);
          if (node) {
              builder.append(&#39; &#39;);
<span class="line-modified">!             builder.append(ValueToString&lt;T&gt;::string(node-&gt;data()));</span>
              builder.append((node-&gt;color() == Black) ? &quot; (black)&quot; : &quot; (red)&quot;);
          }
<span class="line-modified">!         LOG_ERROR(&quot;%s&quot;, builder.toString().ascii().data());</span>
          if (node) {
<span class="line-modified">!             dumpFromNode(node-&gt;left(), indentation + 2);</span>
<span class="line-modified">!             dumpFromNode(node-&gt;right(), indentation + 2);</span>
          }
      }
<span class="line-removed">- #endif</span>
  
<span class="line-modified">!     //----------------------------------------------------------------------</span>
<span class="line-removed">-     // Data members</span>
  
<span class="line-modified">!     Node* m_root;</span>
<span class="line-removed">-     bool m_needsFullOrderingComparisons;</span>
  #ifndef NDEBUG
<span class="line-modified">!     bool m_verboseDebugging;</span>
  #endif
  };
  
  } // namespace WebCore
<span class="line-removed">- </span>
<span class="line-removed">- #endif // PODRedBlackTree_h</span>
<span class="line-new-header">--- 601,35 ---</span>
              LOG_ERROR(&quot;%s&quot;, output);
      }
  #endif
  
  #ifndef NDEBUG
<span class="line-modified">! </span>
<span class="line-modified">!     void dumpSubtree(Node* node, int indentation) const</span>
      {
          StringBuilder builder;
          for (int i = 0; i &lt; indentation; i++)
              builder.append(&#39; &#39;);
          builder.append(&#39;-&#39;);
          if (node) {
              builder.append(&#39; &#39;);
<span class="line-modified">!             TextStream stream;</span>
<span class="line-added">+             stream &lt;&lt; node-&gt;data();</span>
<span class="line-added">+             builder.append(stream.release());</span>
              builder.append((node-&gt;color() == Black) ? &quot; (black)&quot; : &quot; (red)&quot;);
          }
<span class="line-modified">!         LOG_ERROR(&quot;%s&quot;, builder.toString().utf8().data());</span>
          if (node) {
<span class="line-modified">!             dumpSubtree(node-&gt;left(), indentation + 2);</span>
<span class="line-modified">!             dumpSubtree(node-&gt;right(), indentation + 2);</span>
          }
      }
  
<span class="line-modified">! #endif</span>
  
<span class="line-modified">!     Node* m_root { nullptr };</span>
  #ifndef NDEBUG
<span class="line-modified">!     bool m_verboseDebugging { false };</span>
  #endif
  };
  
  } // namespace WebCore
</pre>
<center><a href="PODIntervalTree.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Pasteboard.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
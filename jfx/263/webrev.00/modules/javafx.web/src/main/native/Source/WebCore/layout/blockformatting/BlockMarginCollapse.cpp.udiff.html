<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockMarginCollapse.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BlockFormattingState.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../displaytree/DisplayBox.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockMarginCollapse.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,10 +26,12 @@</span>
  #include &quot;config.h&quot;
  #include &quot;BlockFormattingContext.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
<span class="udiff-line-added">+ #include &quot;BlockFormattingState.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;FloatingState.h&quot;</span>
  #include &quot;InlineFormattingState.h&quot;
  #include &quot;LayoutBox.h&quot;
  #include &quot;LayoutContainer.h&quot;
  #include &quot;LayoutUnit.h&quot;
  #include &quot;RenderStyle.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -68,51 +70,52 @@</span>
  static bool hasPaddingAfter(const Box&amp; layoutBox)
  {
      return hasPadding(layoutBox.style().paddingAfter());
  }
  
<span class="udiff-line-removed">- static bool hasClearance(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     if (!layoutBox.hasFloatClear())</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">-     return layoutState.displayBoxForLayoutBox(layoutBox).hasClearance();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  static bool establishesBlockFormattingContext(const Box&amp; layoutBox)
  {
      // WebKit treats the document element renderer as a block formatting context root. It probably only impacts margin collapsing, so let&#39;s not do
      // a layout wide quirk on this for now.
      if (layoutBox.isDocumentBox())
          return true;
      return layoutBox.establishesBlockFormattingContext();
  }
  
<span class="udiff-line-modified-removed">- bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithParentMarginAfter(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ bool BlockFormattingContext::MarginCollapse::hasClearance(const Box&amp; layoutBox) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!layoutBox.hasFloatClear())</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+     // FIXME: precomputedVerticalPositionForFormattingRoot logic ends up calling into this function when the layoutBox (first inflow child) has</span>
<span class="udiff-line-added">+     // not been laid out.</span>
<span class="udiff-line-added">+     if (!layoutState().hasDisplayBox(layoutBox))</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+     return formattingContext().geometryForBox(layoutBox).hasClearance();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithParentMarginAfter(const Box&amp; layoutBox) const</span>
  {
      // 1. This is the last in-flow child and its margins collapse through and the margin after collapses with parent&#39;s margin after or
      // 2. This box&#39;s margin after collapses with the next sibling&#39;s margin before and that sibling collapses through and
      // we can get to the last in-flow child like that.
      auto* lastInFlowChild = layoutBox.parent()-&gt;lastInFlowChild();
      for (auto* currentBox = &amp;layoutBox; currentBox; currentBox = currentBox-&gt;nextInFlowSibling()) {
<span class="udiff-line-modified-removed">-         if (!marginsCollapseThrough(layoutState, *currentBox))</span>
<span class="udiff-line-modified-added">+         if (!marginsCollapseThrough(*currentBox))</span>
              return false;
          if (currentBox == lastInFlowChild)
<span class="udiff-line-modified-removed">-             return marginAfterCollapsesWithParentMarginAfter(layoutState, *currentBox);</span>
<span class="udiff-line-modified-removed">-         if (!marginAfterCollapsesWithNextSiblingMarginBefore(layoutState, *currentBox))</span>
<span class="udiff-line-modified-added">+             return marginAfterCollapsesWithParentMarginAfter(*currentBox);</span>
<span class="udiff-line-modified-added">+         if (!marginAfterCollapsesWithNextSiblingMarginBefore(*currentBox))</span>
              return false;
      }
      ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="udiff-line-modified-removed">- bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithParentMarginBefore(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithParentMarginBefore(const Box&amp; layoutBox) const</span>
  {
      // The first inflow child could propagate its top margin to parent.
      // https://www.w3.org/TR/CSS21/box.html#collapsing-margins
<span class="udiff-line-removed">-     if (layoutBox.isAnonymous())</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">- </span>
      ASSERT(layoutBox.isBlockLevelBox());
  
      // Margins between a floated box and any other box do not collapse.
      if (layoutBox.isFloatingPositioned())
          return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -139,30 +142,24 @@</span>
  
      if (hasPaddingBefore(parent))
          return false;
  
      // ...and the child has no clearance.
<span class="udiff-line-modified-removed">-     if (hasClearance(layoutState, layoutBox))</span>
<span class="udiff-line-modified-added">+     if (hasClearance(layoutBox))</span>
          return false;
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithPreviousSiblingMarginAfter(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithPreviousSiblingMarginAfter(const Box&amp; layoutBox) const</span>
  {
      ASSERT(layoutBox.isBlockLevelBox());
  
<span class="udiff-line-removed">-     if (layoutBox.isAnonymous())</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">- </span>
      if (!layoutBox.previousInFlowSibling())
          return false;
  
      auto&amp; previousInFlowSibling = *layoutBox.previousInFlowSibling();
<span class="udiff-line-removed">-     if (previousInFlowSibling.isAnonymous())</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">- </span>
      // Margins between a floated box and any other box do not collapse.
      if (layoutBox.isFloatingPositioned() || previousInFlowSibling.isFloatingPositioned())
          return false;
  
      // Margins of absolutely positioned boxes do not collapse.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -174,21 +171,18 @@</span>
      if (layoutBox.isInlineBlockBox() || previousInFlowSibling.isInlineBlockBox())
          return false;
  
      // The bottom margin of an in-flow block-level element always collapses with the top margin of
      // its next in-flow block-level sibling, unless that sibling has clearance.
<span class="udiff-line-modified-removed">-     if (hasClearance(layoutState, layoutBox))</span>
<span class="udiff-line-modified-added">+     if (hasClearance(layoutBox))</span>
          return false;
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithFirstInFlowChildMarginBefore(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithFirstInFlowChildMarginBefore(const Box&amp; layoutBox) const</span>
  {
<span class="udiff-line-removed">-     if (layoutBox.isAnonymous())</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">- </span>
      ASSERT(layoutBox.isBlockLevelBox());
      // Margins of elements that establish new block formatting contexts do not collapse with their in-flow children.
      if (establishesBlockFormattingContext(layoutBox))
          return false;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -207,59 +201,56 @@</span>
      auto&amp; firstInFlowChild = *downcast&lt;Container&gt;(layoutBox).firstInFlowChild();
      if (!firstInFlowChild.isBlockLevelBox())
          return false;
  
      // ...and the child has no clearance.
<span class="udiff-line-modified-removed">-     if (hasClearance(layoutState, firstInFlowChild))</span>
<span class="udiff-line-modified-added">+     if (hasClearance(firstInFlowChild))</span>
          return false;
  
      // Margins of inline-block boxes do not collapse.
      if (firstInFlowChild.isInlineBlockBox())
          return false;
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithSiblingMarginBeforeWithClearance(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithSiblingMarginBeforeWithClearance(const Box&amp; layoutBox) const</span>
  {
      // If the top and bottom margins of an element with clearance are adjoining, its margins collapse with the adjoining margins
      // of following siblings but that resulting margin does not collapse with the bottom margin of the parent block.
<span class="udiff-line-modified-removed">-     if (!marginsCollapseThrough(layoutState, layoutBox))</span>
<span class="udiff-line-modified-added">+     if (!marginsCollapseThrough(layoutBox))</span>
          return false;
  
      for (auto* previousSibling = layoutBox.previousInFlowSibling(); previousSibling; previousSibling = previousSibling-&gt;previousInFlowSibling()) {
<span class="udiff-line-modified-removed">-         if (!marginsCollapseThrough(layoutState, *previousSibling))</span>
<span class="udiff-line-modified-added">+         if (!marginsCollapseThrough(*previousSibling))</span>
              return false;
<span class="udiff-line-modified-removed">-         if (hasClearance(layoutState, *previousSibling))</span>
<span class="udiff-line-modified-added">+         if (hasClearance(*previousSibling))</span>
              return true;
      }
      return false;
  }
  
<span class="udiff-line-modified-removed">- bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithParentMarginBefore(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithParentMarginBefore(const Box&amp; layoutBox) const</span>
  {
      // 1. This is the first in-flow child and its margins collapse through and the margin before collapses with parent&#39;s margin before or
      // 2. This box&#39;s margin before collapses with the previous sibling&#39;s margin after and that sibling collapses through and
      // we can get to the first in-flow child like that.
      auto* firstInFlowChild = layoutBox.parent()-&gt;firstInFlowChild();
      for (auto* currentBox = &amp;layoutBox; currentBox; currentBox = currentBox-&gt;previousInFlowSibling()) {
<span class="udiff-line-modified-removed">-         if (!marginsCollapseThrough(layoutState, *currentBox))</span>
<span class="udiff-line-modified-added">+         if (!marginsCollapseThrough(*currentBox))</span>
              return false;
          if (currentBox == firstInFlowChild)
<span class="udiff-line-modified-removed">-             return marginBeforeCollapsesWithParentMarginBefore(layoutState, *currentBox);</span>
<span class="udiff-line-modified-removed">-         if (!marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, *currentBox))</span>
<span class="udiff-line-modified-added">+             return marginBeforeCollapsesWithParentMarginBefore(*currentBox);</span>
<span class="udiff-line-modified-added">+         if (!marginBeforeCollapsesWithPreviousSiblingMarginAfter(*currentBox))</span>
              return false;
      }
      ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="udiff-line-modified-removed">- bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithParentMarginAfter(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithParentMarginAfter(const Box&amp; layoutBox) const</span>
  {
<span class="udiff-line-removed">-     if (layoutBox.isAnonymous())</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">- </span>
      ASSERT(layoutBox.isBlockLevelBox());
  
      // Margins between a floated box and any other box do not collapse.
      if (layoutBox.isFloatingPositioned())
          return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -292,22 +283,22 @@</span>
      // the box has no bottom border, and
      if (hasBorderAfter(parent))
          return false;
  
      // the child&#39;s bottom margin neither collapses with a top margin that has clearance...
<span class="udiff-line-modified-removed">-     if (marginAfterCollapsesWithSiblingMarginBeforeWithClearance(layoutState, layoutBox))</span>
<span class="udiff-line-modified-added">+     if (marginAfterCollapsesWithSiblingMarginBeforeWithClearance(layoutBox))</span>
          return false;
  
      // nor (if the box&#39;s min-height is non-zero) with the box&#39;s top margin.
      auto computedMinHeight = parent.style().logicalMinHeight();
<span class="udiff-line-modified-removed">-     if (!computedMinHeight.isAuto() &amp;&amp; computedMinHeight.value() &amp;&amp; marginAfterCollapsesWithParentMarginBefore(layoutState, layoutBox))</span>
<span class="udiff-line-modified-added">+     if (!computedMinHeight.isAuto() &amp;&amp; computedMinHeight.value() &amp;&amp; marginAfterCollapsesWithParentMarginBefore(layoutBox))</span>
          return false;
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithLastInFlowChildMarginAfter(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithLastInFlowChildMarginAfter(const Box&amp; layoutBox) const</span>
  {
      ASSERT(layoutBox.isBlockLevelBox());
  
      // Margins of elements that establish new block formatting contexts do not collapse with their in-flow children.
      if (establishesBlockFormattingContext(layoutBox))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -331,37 +322,42 @@</span>
      // the box has no bottom border, and
      if (hasBorderAfter(layoutBox))
          return false;
  
      // the child&#39;s bottom margin neither collapses with a top margin that has clearance...
<span class="udiff-line-modified-removed">-     if (marginAfterCollapsesWithSiblingMarginBeforeWithClearance(layoutState, lastInFlowChild))</span>
<span class="udiff-line-modified-added">+     if (marginAfterCollapsesWithSiblingMarginBeforeWithClearance(lastInFlowChild))</span>
          return false;
  
      // nor (if the box&#39;s min-height is non-zero) with the box&#39;s top margin.
      auto computedMinHeight = layoutBox.style().logicalMinHeight();
      if (!computedMinHeight.isAuto() &amp;&amp; computedMinHeight.value()
<span class="udiff-line-modified-removed">-         &amp;&amp; (marginAfterCollapsesWithParentMarginBefore(layoutState, lastInFlowChild) || hasClearance(layoutState, lastInFlowChild)))</span>
<span class="udiff-line-modified-added">+         &amp;&amp; (marginAfterCollapsesWithParentMarginBefore(lastInFlowChild) || hasClearance(lastInFlowChild)))</span>
          return false;
  
      // Margins of inline-block boxes do not collapse.
      if (lastInFlowChild.isInlineBlockBox())
          return false;
  
<span class="udiff-line-added">+     // This is a quirk behavior: When the margin after of the last inflow child (or a previous sibling with collapsed through margins)</span>
<span class="udiff-line-added">+     // collapses with a quirk parent&#39;s the margin before, then the same margin after does not collapses with the parent&#39;s margin after.</span>
<span class="udiff-line-added">+     if (formattingContext().quirks().shouldIgnoreCollapsedQuirkMargin(layoutBox) &amp;&amp; marginAfterCollapsesWithParentMarginBefore(lastInFlowChild))</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithNextSiblingMarginBefore(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithNextSiblingMarginBefore(const Box&amp; layoutBox) const</span>
  {
      ASSERT(layoutBox.isBlockLevelBox());
  
      if (!layoutBox.nextInFlowSibling())
          return false;
  
<span class="udiff-line-modified-removed">-     return marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, *layoutBox.nextInFlowSibling());</span>
<span class="udiff-line-modified-added">+     return marginBeforeCollapsesWithPreviousSiblingMarginAfter(*layoutBox.nextInFlowSibling());</span>
  }
  
<span class="udiff-line-modified-removed">- bool BlockFormattingContext::MarginCollapse::marginsCollapseThrough(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ bool BlockFormattingContext::MarginCollapse::marginsCollapseThrough(const Box&amp; layoutBox) const</span>
  {
      ASSERT(layoutBox.isBlockLevelBox());
  
      // A box&#39;s own margins collapse if the &#39;min-height&#39; property is zero, and it has neither top or bottom borders nor top or bottom padding,
      // and it has a &#39;height&#39; of either 0 or &#39;auto&#39;, and it does not contain a line box, and all of its in-flow children&#39;s margins (if any) collapse.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -390,34 +386,44 @@</span>
      if (!downcast&lt;Container&gt;(layoutBox).hasInFlowChild())
          return !establishesBlockFormattingContext(layoutBox);
  
      if (layoutBox.establishesFormattingContext()) {
          if (layoutBox.establishesInlineFormattingContext()) {
<span class="udiff-line-added">+             auto&amp; layoutState = this-&gt;layoutState();</span>
              // If we get here through margin estimation, we don&#39;t necessarily have an actual state for this layout box since
              // we haven&#39;t started laying it out yet.
<span class="udiff-line-modified-removed">-             if (!layoutState.hasFormattingState(layoutBox))</span>
<span class="udiff-line-modified-removed">-                 return false;</span>
<span class="udiff-line-removed">-             auto&amp; formattingState = downcast&lt;InlineFormattingState&gt;(layoutState.establishedFormattingState(layoutBox));</span>
<span class="udiff-line-removed">-             if (!formattingState.inlineRuns().isEmpty())</span>
<span class="udiff-line-modified-added">+             auto&amp; layoutContainer = downcast&lt;Container&gt;(layoutBox);</span>
<span class="udiff-line-modified-added">+             if (!layoutState.hasInlineFormattingState(layoutContainer))</span>
                  return false;
<span class="udiff-line-modified-removed">-             // Any float box in this formatting context prevents collapsing through.</span>
<span class="udiff-line-modified-removed">-             auto&amp; floats = formattingState.floatingState().floats();</span>
<span class="udiff-line-modified-removed">-             for (auto&amp; floatItem : floats) {</span>
<span class="udiff-line-modified-removed">-                 if (floatItem.isDescendantOfFormattingRoot(downcast&lt;Container&gt;(layoutBox)))</span>
<span class="udiff-line-modified-removed">-                     return false;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             return true;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             auto isConsideredEmpty = [&amp;] {</span>
<span class="udiff-line-modified-added">+                 auto&amp; formattingState = layoutState.establishedInlineFormattingState(layoutContainer);</span>
<span class="udiff-line-modified-added">+                 if (auto* inlineContent = formattingState.displayInlineContent()) {</span>
<span class="udiff-line-modified-added">+                     for (auto&amp; lineBox : inlineContent-&gt;lineBoxes) {</span>
<span class="udiff-line-modified-added">+                         if (!lineBox.isConsideredEmpty())</span>
<span class="udiff-line-modified-added">+                             return false;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 // Any float box in this formatting context prevents collapsing through.</span>
<span class="udiff-line-added">+                 auto&amp; floats = formattingState.floatingState().floats();</span>
<span class="udiff-line-added">+                 for (auto&amp; floatItem : floats) {</span>
<span class="udiff-line-added">+                     if (floatItem.isDescendantOfFormattingRoot(layoutContainer))</span>
<span class="udiff-line-added">+                         return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             };</span>
<span class="udiff-line-added">+             return isConsideredEmpty();</span>
          }
  
          // A root of a non-inline formatting context (table, flex etc) with inflow descendants should not collapse through.
          return false;
      }
  
      for (auto* inflowChild = downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild(); inflowChild; inflowChild = inflowChild-&gt;nextInFlowOrFloatingSibling()) {
          if (establishesBlockFormattingContext(*inflowChild))
              return false;
<span class="udiff-line-modified-removed">-         if (!marginsCollapseThrough(layoutState, *inflowChild))</span>
<span class="udiff-line-modified-added">+         if (!marginsCollapseThrough(*inflowChild))</span>
              return false;
      }
      return true;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -456,38 +462,34 @@</span>
          return marginValues.negative;
  
      return *marginValues.positive + *marginValues.negative;
  }
  
<span class="udiff-line-modified-removed">- void BlockFormattingContext::MarginCollapse::updateMarginAfterForPreviousSibling(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ void BlockFormattingContext::MarginCollapse::updateMarginAfterForPreviousSibling(BlockFormattingContext&amp; blockFormattingContext, const MarginCollapse&amp; marginCollapse, const Box&amp; layoutBox)</span>
  {
      // 1. Get the margin before value from the next in-flow sibling. This is the same as this box&#39;s margin after value now since they are collapsed.
      // 2. Update the collapsed margin after value as well as the positive/negative cache.
      // 3. Check if the box&#39;s margins collapse through.
<span class="udiff-line-modified-removed">-     // 4. If so, update the collapsed margin before value as well as the positive/negative cache.</span>
<span class="udiff-line-modified-added">+     // 4. If so, update the positive/negative cache.</span>
      // 5. In case of collapsed through margins check if the before margin collapes with the previous inflow sibling&#39;s after margin.
      // 6. If so, jump to #2.
<span class="udiff-line-modified-removed">-     // 7. No need to propagate to parent because its margin is not computed yet (estimated at most).</span>
<span class="udiff-line-modified-added">+     // 7. No need to propagate to parent because its margin is not computed yet (pre-computed at most).</span>
      auto* currentBox = &amp;layoutBox;
<span class="udiff-line-modified-removed">-     while (marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, *currentBox)) {</span>
<span class="udiff-line-modified-added">+     auto&amp; blockFormattingState = blockFormattingContext.formattingState();</span>
<span class="udiff-line-added">+     while (marginCollapse.marginBeforeCollapsesWithPreviousSiblingMarginAfter(*currentBox)) {</span>
          auto&amp; previousSibling = *currentBox-&gt;previousInFlowSibling();
<span class="udiff-line-modified-removed">-         auto&amp; previousSiblingDisplayBox = layoutState.displayBoxForLayoutBox(previousSibling);</span>
<span class="udiff-line-modified-added">+         auto&amp; previousSiblingDisplayBox = blockFormattingState.displayBox(previousSibling);</span>
          auto previousSiblingVerticalMargin = previousSiblingDisplayBox.verticalMargin();
  
          auto collapsedVerticalMarginBefore = previousSiblingVerticalMargin.collapsedValues().before;
<span class="udiff-line-modified-removed">-         auto collapsedVerticalMarginAfter = layoutState.displayBoxForLayoutBox(*currentBox).verticalMargin().before();</span>
<span class="udiff-line-modified-added">+         auto collapsedVerticalMarginAfter = blockFormattingContext.geometryForBox(*currentBox).verticalMargin().before();</span>
  
<span class="udiff-line-modified-removed">-         auto marginsCollapseThrough = MarginCollapse::marginsCollapseThrough(layoutState, previousSibling);</span>
<span class="udiff-line-modified-added">+         auto marginsCollapseThrough = marginCollapse.marginsCollapseThrough(previousSibling);</span>
          if (marginsCollapseThrough)
              collapsedVerticalMarginBefore = collapsedVerticalMarginAfter;
  
<span class="udiff-line-removed">-         // Update collapsed vertical margin values.</span>
<span class="udiff-line-removed">-         previousSiblingVerticalMargin.setCollapsedValues({ collapsedVerticalMarginBefore, collapsedVerticalMarginAfter });</span>
<span class="udiff-line-removed">-         previousSiblingDisplayBox.setVerticalMargin(previousSiblingVerticalMargin);</span>
<span class="udiff-line-removed">- </span>
          // Update positive/negative cache.
<span class="udiff-line-removed">-         auto&amp; blockFormattingState = downcast&lt;BlockFormattingState&gt;(layoutState.formattingStateForBox(previousSibling));</span>
          auto previousSiblingPositiveNegativeMargin = blockFormattingState.positiveAndNegativeVerticalMargin(previousSibling);
          auto positiveNegativeMarginBefore = blockFormattingState.positiveAndNegativeVerticalMargin(*currentBox).before;
  
          previousSiblingPositiveNegativeMargin.after = computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, previousSiblingPositiveNegativeMargin.after);
          if (marginsCollapseThrough) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -501,46 +503,46 @@</span>
  
          currentBox = &amp;previousSibling;
      }
  }
  
<span class="udiff-line-modified-removed">- PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeValues(const LayoutState&amp; layoutState, const Box&amp; layoutBox, MarginType marginType)</span>
<span class="udiff-line-modified-added">+ PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeValues(const Box&amp; layoutBox, MarginType marginType) const</span>
  {
<span class="udiff-line-added">+     auto&amp; layoutState = this-&gt;layoutState();</span>
      auto&amp; blockFormattingState = downcast&lt;BlockFormattingState&gt;(layoutState.formattingStateForBox(layoutBox));
      if (blockFormattingState.hasPositiveAndNegativeVerticalMargin(layoutBox)) {
          auto positiveAndNegativeVerticalMargin = blockFormattingState.positiveAndNegativeVerticalMargin(layoutBox);
          return marginType == MarginType::Before ? positiveAndNegativeVerticalMargin.before : positiveAndNegativeVerticalMargin.after;
      }
<span class="udiff-line-modified-removed">-     // This is the estimate path. We don&#39;t yet have positive/negative margin computed.</span>
<span class="udiff-line-modified-removed">-     auto usedValues = UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() };</span>
<span class="udiff-line-removed">-     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, usedValues);</span>
<span class="udiff-line-modified-added">+     // This is the pre-computed path. We don&#39;t yet have positive/negative margin computed.</span>
<span class="udiff-line-modified-added">+     auto computedVerticalMargin = formattingContext().geometry().computedVerticalMargin(layoutBox, Geometry::horizontalConstraintsForInFlow(formattingContext().geometryForBox(*layoutBox.containingBlock())));</span>
      auto nonCollapsedMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
  
      if (marginType == MarginType::Before)
<span class="udiff-line-modified-removed">-         return positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedMargin);</span>
<span class="udiff-line-modified-removed">-     return positiveNegativeMarginAfter(layoutState, layoutBox, nonCollapsedMargin);</span>
<span class="udiff-line-modified-added">+         return positiveNegativeMarginBefore(layoutBox, nonCollapsedMargin);</span>
<span class="udiff-line-modified-added">+     return positiveNegativeMarginAfter(layoutBox, nonCollapsedMargin);</span>
  }
  
<span class="udiff-line-modified-removed">- PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeMarginBefore(const LayoutState&amp; layoutState, const Box&amp; layoutBox, const UsedVerticalMargin::NonCollapsedValues&amp; nonCollapsedValues)</span>
<span class="udiff-line-modified-added">+ PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeMarginBefore(const Box&amp; layoutBox, UsedVerticalMargin::NonCollapsedValues nonCollapsedValues) const</span>
  {
      auto firstChildCollapsedMarginBefore = [&amp;]() -&gt; PositiveAndNegativeVerticalMargin::Values {
<span class="udiff-line-modified-removed">-         if (!marginBeforeCollapsesWithFirstInFlowChildMarginBefore(layoutState, layoutBox))</span>
<span class="udiff-line-modified-added">+         if (!marginBeforeCollapsesWithFirstInFlowChildMarginBefore(layoutBox))</span>
              return { };
<span class="udiff-line-modified-removed">-         return positiveNegativeValues(layoutState, *downcast&lt;Container&gt;(layoutBox).firstInFlowChild(), MarginType::Before);</span>
<span class="udiff-line-modified-added">+         return positiveNegativeValues(*downcast&lt;Container&gt;(layoutBox).firstInFlowChild(), MarginType::Before);</span>
      };
  
      auto previouSiblingCollapsedMarginAfter = [&amp;]() -&gt; PositiveAndNegativeVerticalMargin::Values {
<span class="udiff-line-modified-removed">-         if (!marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, layoutBox))</span>
<span class="udiff-line-modified-added">+         if (!marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutBox))</span>
              return { };
<span class="udiff-line-modified-removed">-         return positiveNegativeValues(layoutState, *layoutBox.previousInFlowSibling(), MarginType::After);</span>
<span class="udiff-line-modified-added">+         return positiveNegativeValues(*layoutBox.previousInFlowSibling(), MarginType::After);</span>
      };
  
      // 1. Gather positive and negative margin values from first child if margins are adjoining.
      // 2. Gather positive and negative margin values from previous inflow sibling if margins are adjoining.
      // 3. Compute min/max positive and negative collapsed margin values using non-collpased computed margin before.
      auto collapsedMarginBefore = computedPositiveAndNegativeMargin(firstChildCollapsedMarginBefore(), previouSiblingCollapsedMarginAfter());
<span class="udiff-line-modified-removed">-     if (collapsedMarginBefore.isQuirk &amp;&amp; Quirks::shouldIgnoreCollapsedQuirkMargin(layoutState, layoutBox))</span>
<span class="udiff-line-modified-added">+     if (collapsedMarginBefore.isQuirk &amp;&amp; formattingContext().quirks().shouldIgnoreCollapsedQuirkMargin(layoutBox))</span>
          collapsedMarginBefore = { };
  
      PositiveAndNegativeVerticalMargin::Values nonCollapsedBefore;
      if (nonCollapsedValues.before &gt; 0)
          nonCollapsedBefore = { nonCollapsedValues.before, { }, layoutBox.style().hasMarginBeforeQuirk() };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -548,95 +550,82 @@</span>
          nonCollapsedBefore = { { }, nonCollapsedValues.before, layoutBox.style().hasMarginBeforeQuirk() };
  
      return computedPositiveAndNegativeMargin(collapsedMarginBefore, nonCollapsedBefore);
  }
  
<span class="udiff-line-modified-removed">- PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeMarginAfter(const LayoutState&amp; layoutState, const Box&amp; layoutBox, const UsedVerticalMargin::NonCollapsedValues&amp; nonCollapsedValues)</span>
<span class="udiff-line-modified-added">+ PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeMarginAfter(const Box&amp; layoutBox, UsedVerticalMargin::NonCollapsedValues nonCollapsedValues) const</span>
  {
      auto lastChildCollapsedMarginAfter = [&amp;]() -&gt; PositiveAndNegativeVerticalMargin::Values {
<span class="udiff-line-modified-removed">-         if (!marginAfterCollapsesWithLastInFlowChildMarginAfter(layoutState, layoutBox))</span>
<span class="udiff-line-modified-added">+         if (!marginAfterCollapsesWithLastInFlowChildMarginAfter(layoutBox))</span>
              return { };
<span class="udiff-line-modified-removed">-         return positiveNegativeValues(layoutState, *downcast&lt;Container&gt;(layoutBox).lastInFlowChild(), MarginType::After);</span>
<span class="udiff-line-modified-added">+         return positiveNegativeValues(*downcast&lt;Container&gt;(layoutBox).lastInFlowChild(), MarginType::After);</span>
      };
  
      // We don&#39;t know yet the margin before value of the next sibling. Let&#39;s just pretend it does not have one and
<span class="udiff-line-modified-removed">-     // update it later when we compute the next sibling&#39;s margin before. See updateCollapsedMarginAfter.</span>
<span class="udiff-line-modified-added">+     // update it later when we compute the next sibling&#39;s margin before. See updateMarginAfterForPreviousSibling.</span>
      PositiveAndNegativeVerticalMargin::Values nonCollapsedAfter;
      if (nonCollapsedValues.after &gt; 0)
          nonCollapsedAfter = { nonCollapsedValues.after, { }, layoutBox.style().hasMarginAfterQuirk() };
      else if (nonCollapsedValues.after &lt; 0)
          nonCollapsedAfter = { { }, nonCollapsedValues.after, layoutBox.style().hasMarginAfterQuirk() };
  
      return computedPositiveAndNegativeMargin(lastChildCollapsedMarginAfter(), nonCollapsedAfter);
  }
  
<span class="udiff-line-modified-removed">- EstimatedMarginBefore BlockFormattingContext::MarginCollapse::estimatedMarginBefore(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ PrecomputedMarginBefore BlockFormattingContext::MarginCollapse::precomputedMarginBefore(const Box&amp; layoutBox, UsedVerticalMargin::NonCollapsedValues usedNonCollapsedMargin)</span>
  {
<span class="udiff-line-removed">-     if (layoutBox.isAnonymous())</span>
<span class="udiff-line-removed">-         return { };</span>
<span class="udiff-line-removed">- </span>
      ASSERT(layoutBox.isBlockLevelBox());
<span class="udiff-line-modified-removed">-     // Don&#39;t estimate vertical margins for out of flow boxes.</span>
<span class="udiff-line-modified-added">+     // Don&#39;t pre-compute vertical margins for out of flow boxes.</span>
      ASSERT(layoutBox.isInFlow() || layoutBox.isFloatingPositioned());
      ASSERT(!layoutBox.replaced());
  
<span class="udiff-line-modified-removed">-     auto usedValues = UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() };</span>
<span class="udiff-line-modified-removed">-     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, usedValues);</span>
<span class="udiff-line-removed">-     auto nonCollapsedMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };</span>
<span class="udiff-line-removed">-     auto marginsCollapseThrough = MarginCollapse::marginsCollapseThrough(layoutState, layoutBox);</span>
<span class="udiff-line-removed">-     auto positiveNegativeMarginBefore = MarginCollapse::positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedMargin);</span>
<span class="udiff-line-modified-added">+     auto marginsCollapseThrough = this-&gt;marginsCollapseThrough(layoutBox);</span>
<span class="udiff-line-modified-added">+     auto positiveNegativeMarginBefore = this-&gt;positiveNegativeMarginBefore(layoutBox, usedNonCollapsedMargin);</span>
  
      auto collapsedMarginBefore = marginValue(!marginsCollapseThrough ? positiveNegativeMarginBefore
<span class="udiff-line-modified-removed">-         : computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter(layoutState, layoutBox, nonCollapsedMargin)));</span>
<span class="udiff-line-modified-added">+         : computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter(layoutBox, usedNonCollapsedMargin)));</span>
  
<span class="udiff-line-modified-removed">-     return { nonCollapsedMargin.before, collapsedMarginBefore, marginsCollapseThrough };</span>
<span class="udiff-line-modified-added">+     return { usedNonCollapsedMargin.before, collapsedMarginBefore, marginsCollapseThrough };</span>
  }
  
<span class="udiff-line-modified-removed">- LayoutUnit BlockFormattingContext::MarginCollapse::marginBeforeIgnoringCollapsingThrough(const LayoutState&amp; layoutState, const Box&amp; layoutBox, const UsedVerticalMargin::NonCollapsedValues&amp; nonCollapsedValues)</span>
<span class="udiff-line-modified-added">+ LayoutUnit BlockFormattingContext::MarginCollapse::marginBeforeIgnoringCollapsingThrough(const Box&amp; layoutBox, UsedVerticalMargin::NonCollapsedValues nonCollapsedValues)</span>
  {
<span class="udiff-line-removed">-     ASSERT(!layoutBox.isAnonymous());</span>
      ASSERT(layoutBox.isBlockLevelBox());
<span class="udiff-line-modified-removed">-     return marginValue(positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedValues)).valueOr(nonCollapsedValues.before);</span>
<span class="udiff-line-modified-added">+     return marginValue(positiveNegativeMarginBefore(layoutBox, nonCollapsedValues)).valueOr(nonCollapsedValues.before);</span>
  }
  
<span class="udiff-line-modified-removed">- void BlockFormattingContext::MarginCollapse::updatePositiveNegativeMarginValues(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
<span class="udiff-line-modified-added">+ PositiveAndNegativeVerticalMargin BlockFormattingContext::MarginCollapse::resolvedPositiveNegativeMarginValues(const Box&amp; layoutBox, const UsedVerticalMargin::NonCollapsedValues&amp; nonCollapsedValues)</span>
  {
      ASSERT(layoutBox.isBlockLevelBox());
<span class="udiff-line-modified-removed">-     auto nonCollapsedValues = layoutState.displayBoxForLayoutBox(layoutBox).verticalMargin().nonCollapsedValues();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     auto positiveNegativeMarginBefore = MarginCollapse::positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedValues);</span>
<span class="udiff-line-removed">-     auto positiveNegativeMarginAfter = MarginCollapse::positiveNegativeMarginAfter(layoutState, layoutBox, nonCollapsedValues);</span>
<span class="udiff-line-modified-added">+     auto positiveNegativeMarginBefore = this-&gt;positiveNegativeMarginBefore(layoutBox, nonCollapsedValues);</span>
<span class="udiff-line-modified-added">+     auto positiveNegativeMarginAfter = this-&gt;positiveNegativeMarginAfter(layoutBox, nonCollapsedValues);</span>
  
<span class="udiff-line-modified-removed">-     if (MarginCollapse::marginsCollapseThrough(layoutState, layoutBox)) {</span>
<span class="udiff-line-modified-added">+     if (marginsCollapseThrough(layoutBox)) {</span>
          positiveNegativeMarginBefore = computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter);
          positiveNegativeMarginAfter = positiveNegativeMarginBefore;
      }
<span class="udiff-line-modified-removed">-     auto&amp; blockFormattingState = downcast&lt;BlockFormattingState&gt;(layoutState.formattingStateForBox(layoutBox));</span>
<span class="udiff-line-removed">-     blockFormattingState.setPositiveAndNegativeVerticalMargin(layoutBox, { positiveNegativeMarginBefore, positiveNegativeMarginAfter });</span>
<span class="udiff-line-modified-added">+     return { positiveNegativeMarginBefore, positiveNegativeMarginAfter };</span>
  }
  
<span class="udiff-line-modified-removed">- UsedVerticalMargin::CollapsedValues BlockFormattingContext::MarginCollapse::collapsedVerticalValues(const LayoutState&amp; layoutState, const Box&amp; layoutBox, const UsedVerticalMargin::NonCollapsedValues&amp; nonCollapsedValues)</span>
<span class="udiff-line-modified-added">+ UsedVerticalMargin::CollapsedValues BlockFormattingContext::MarginCollapse::collapsedVerticalValues(const Box&amp; layoutBox, UsedVerticalMargin::NonCollapsedValues nonCollapsedValues)</span>
  {
<span class="udiff-line-removed">-     if (layoutBox.isAnonymous())</span>
<span class="udiff-line-removed">-         return { };</span>
<span class="udiff-line-removed">- </span>
      ASSERT(layoutBox.isBlockLevelBox());
      // 1. Get min/max margin top values from the first in-flow child if we are collapsing margin top with it.
      // 2. Get min/max margin top values from the previous in-flow sibling, if we are collapsing margin top with it.
      // 3. Get this layout box&#39;s computed margin top value.
      // 4. Update the min/max value and compute the final margin.
<span class="udiff-line-modified-removed">-     auto positiveNegativeMarginBefore = MarginCollapse::positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedValues);</span>
<span class="udiff-line-modified-removed">-     auto positiveNegativeMarginAfter = MarginCollapse::positiveNegativeMarginAfter(layoutState, layoutBox, nonCollapsedValues);</span>
<span class="udiff-line-modified-added">+     auto positiveNegativeMarginBefore = this-&gt;positiveNegativeMarginBefore(layoutBox, nonCollapsedValues);</span>
<span class="udiff-line-modified-added">+     auto positiveNegativeMarginAfter = this-&gt;positiveNegativeMarginAfter(layoutBox, nonCollapsedValues);</span>
  
<span class="udiff-line-modified-removed">-     auto marginsCollapseThrough = MarginCollapse::marginsCollapseThrough(layoutState, layoutBox);</span>
<span class="udiff-line-modified-added">+     auto marginsCollapseThrough = this-&gt;marginsCollapseThrough(layoutBox);</span>
      if (marginsCollapseThrough) {
          positiveNegativeMarginBefore = computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter);
          positiveNegativeMarginAfter = positiveNegativeMarginBefore;
      }
  
<span class="udiff-line-modified-removed">-     auto beforeMarginIsCollapsedValue = marginBeforeCollapsesWithFirstInFlowChildMarginBefore(layoutState, layoutBox) || marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, layoutBox);</span>
<span class="udiff-line-modified-removed">-     auto afterMarginIsCollapsedValue = marginAfterCollapsesWithLastInFlowChildMarginAfter(layoutState, layoutBox);</span>
<span class="udiff-line-modified-added">+     auto beforeMarginIsCollapsedValue = marginBeforeCollapsesWithFirstInFlowChildMarginBefore(layoutBox) || marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutBox);</span>
<span class="udiff-line-modified-added">+     auto afterMarginIsCollapsedValue = marginAfterCollapsesWithLastInFlowChildMarginAfter(layoutBox);</span>
  
      if ((beforeMarginIsCollapsedValue &amp;&amp; afterMarginIsCollapsedValue) || marginsCollapseThrough)
          return { marginValue(positiveNegativeMarginBefore), marginValue(positiveNegativeMarginAfter), marginsCollapseThrough };
      if (beforeMarginIsCollapsedValue)
          return { marginValue(positiveNegativeMarginBefore), { }, false };
</pre>
<center><a href="BlockFormattingState.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../displaytree/DisplayBox.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
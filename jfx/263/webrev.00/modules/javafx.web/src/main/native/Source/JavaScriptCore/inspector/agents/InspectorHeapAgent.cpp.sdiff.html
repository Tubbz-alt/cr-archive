<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorHeapAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorDebuggerAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorHeapAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorHeapAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorHeapAgent.h&quot;
 28 
 29 #include &quot;HeapProfiler.h&quot;
 30 #include &quot;HeapSnapshot.h&quot;
 31 #include &quot;InjectedScript.h&quot;
 32 #include &quot;InjectedScriptManager.h&quot;
 33 #include &quot;InspectorEnvironment.h&quot;
 34 #include &quot;JSBigInt.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 #include &quot;VM.h&quot;
 37 #include &lt;wtf/Stopwatch.h&gt;
 38 
<span class="line-removed"> 39 using namespace JSC;</span>
<span class="line-removed"> 40 </span>
 41 namespace Inspector {
 42 


 43 InspectorHeapAgent::InspectorHeapAgent(AgentContext&amp; context)
 44     : InspectorAgentBase(&quot;Heap&quot;_s)
 45     , m_injectedScriptManager(context.injectedScriptManager)
 46     , m_frontendDispatcher(makeUnique&lt;HeapFrontendDispatcher&gt;(context.frontendRouter))
 47     , m_backendDispatcher(HeapBackendDispatcher::create(context.backendDispatcher, this))
 48     , m_environment(context.environment)
 49 {
 50 }
 51 
 52 InspectorHeapAgent::~InspectorHeapAgent() = default;
 53 
 54 void InspectorHeapAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
 55 {
 56 }
 57 
 58 void InspectorHeapAgent::willDestroyFrontendAndBackend(DisconnectReason)
 59 {
 60     ErrorString ignored;
 61     disable(ignored);
 62 }
</pre>
<hr />
<pre>
 91 void InspectorHeapAgent::gc(ErrorString&amp;)
 92 {
 93     VM&amp; vm = m_environment.vm();
 94     JSLockHolder lock(vm);
 95     sanitizeStackForVM(vm);
 96     vm.heap.collectNow(Sync, CollectionScope::Full);
 97 }
 98 
 99 void InspectorHeapAgent::snapshot(ErrorString&amp;, double* timestamp, String* snapshotData)
100 {
101     VM&amp; vm = m_environment.vm();
102     JSLockHolder lock(vm);
103 
104     HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
105     snapshotBuilder.buildSnapshot();
106 
107     *timestamp = m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
108     *snapshotData = snapshotBuilder.json([&amp;] (const HeapSnapshotNode&amp; node) {
109         if (Structure* structure = node.cell-&gt;structure(vm)) {
110             if (JSGlobalObject* globalObject = structure-&gt;globalObject()) {
<span class="line-modified">111                 if (!m_environment.canAccessInspectedScriptState(globalObject-&gt;globalExec()))</span>
112                     return false;
113             }
114         }
115         return true;
116     });
117 }
118 
119 void InspectorHeapAgent::startTracking(ErrorString&amp; errorString)
120 {
121     if (m_tracking)
122         return;
123 
124     m_tracking = true;
125 
126     double timestamp;
127     String snapshotData;
128     snapshot(errorString, &amp;timestamp, &amp;snapshotData);
129 
130     m_frontendDispatcher-&gt;trackingStart(timestamp, snapshotData);
131 }
</pre>
<hr />
<pre>
189     // BigInt preview.
190     if (cell-&gt;isBigInt()) {
191         resultString = JSBigInt::tryGetString(vm, asBigInt(cell), 10);
192         return;
193     }
194 
195     // FIXME: Provide preview information for Internal Objects? CodeBlock, Executable, etc.
196 
197     Structure* structure = cell-&gt;structure(vm);
198     if (!structure) {
199         errorString = &quot;Unable to get object details - Structure&quot;_s;
200         return;
201     }
202 
203     JSGlobalObject* globalObject = structure-&gt;globalObject();
204     if (!globalObject) {
205         errorString = &quot;Unable to get object details - GlobalObject&quot;_s;
206         return;
207     }
208 
<span class="line-modified">209     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(globalObject-&gt;globalExec());</span>
210     if (injectedScript.hasNoValue()) {
211         errorString = &quot;Unable to get object details - InjectedScript&quot;_s;
212         return;
213     }
214 
215     // Function preview.
216     if (cell-&gt;inherits&lt;JSFunction&gt;(vm)) {
217         injectedScript.functionDetails(errorString, cell, functionDetails);
218         return;
219     }
220 
221     // Object preview.
222     objectPreview = injectedScript.previewValue(cell);
223 }
224 
225 void InspectorHeapAgent::getRemoteObject(ErrorString&amp; errorString, int heapObjectId, const String* optionalObjectGroup, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result)
226 {
227     // Prevent the cell from getting collected as we look it up.
228     VM&amp; vm = m_environment.vm();
229     JSLockHolder lock(vm);
230     DeferGC deferGC(vm.heap);
231 
232     unsigned heapObjectIdentifier = static_cast&lt;unsigned&gt;(heapObjectId);
233     const Optional&lt;HeapSnapshotNode&gt; optionalNode = nodeForHeapObjectIdentifier(errorString, heapObjectIdentifier);
234     if (!optionalNode)
235         return;
236 
237     JSCell* cell = optionalNode-&gt;cell;
238     Structure* structure = cell-&gt;structure(vm);
239     if (!structure) {
240         errorString = &quot;Unable to get object details - Structure&quot;_s;
241         return;
242     }
243 
244     JSGlobalObject* globalObject = structure-&gt;globalObject();
245     if (!globalObject) {
246         errorString = &quot;Unable to get object details - GlobalObject&quot;_s;
247         return;
248     }
249 
<span class="line-modified">250     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(globalObject-&gt;globalExec());</span>
251     if (injectedScript.hasNoValue()) {
252         errorString = &quot;Unable to get object details - InjectedScript&quot;_s;
253         return;
254     }
255 
256     String objectGroup = optionalObjectGroup ? *optionalObjectGroup : String();
257     result = injectedScript.wrapObject(cell, objectGroup, true);
258 }
259 
260 static Protocol::Heap::GarbageCollection::Type protocolTypeForHeapOperation(CollectionScope scope)
261 {
262     switch (scope) {
263     case CollectionScope::Full:
264         return Protocol::Heap::GarbageCollection::Type::Full;
265     case CollectionScope::Eden:
266         return Protocol::Heap::GarbageCollection::Type::Partial;
267     }
268     ASSERT_NOT_REACHED();
269     return Protocol::Heap::GarbageCollection::Type::Full;
270 }
</pre>
</td>
<td>
<hr />
<pre>
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorHeapAgent.h&quot;
 28 
 29 #include &quot;HeapProfiler.h&quot;
 30 #include &quot;HeapSnapshot.h&quot;
 31 #include &quot;InjectedScript.h&quot;
 32 #include &quot;InjectedScriptManager.h&quot;
 33 #include &quot;InspectorEnvironment.h&quot;
 34 #include &quot;JSBigInt.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 #include &quot;VM.h&quot;
 37 #include &lt;wtf/Stopwatch.h&gt;
 38 


 39 namespace Inspector {
 40 
<span class="line-added"> 41 using namespace JSC;</span>
<span class="line-added"> 42 </span>
 43 InspectorHeapAgent::InspectorHeapAgent(AgentContext&amp; context)
 44     : InspectorAgentBase(&quot;Heap&quot;_s)
 45     , m_injectedScriptManager(context.injectedScriptManager)
 46     , m_frontendDispatcher(makeUnique&lt;HeapFrontendDispatcher&gt;(context.frontendRouter))
 47     , m_backendDispatcher(HeapBackendDispatcher::create(context.backendDispatcher, this))
 48     , m_environment(context.environment)
 49 {
 50 }
 51 
 52 InspectorHeapAgent::~InspectorHeapAgent() = default;
 53 
 54 void InspectorHeapAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
 55 {
 56 }
 57 
 58 void InspectorHeapAgent::willDestroyFrontendAndBackend(DisconnectReason)
 59 {
 60     ErrorString ignored;
 61     disable(ignored);
 62 }
</pre>
<hr />
<pre>
 91 void InspectorHeapAgent::gc(ErrorString&amp;)
 92 {
 93     VM&amp; vm = m_environment.vm();
 94     JSLockHolder lock(vm);
 95     sanitizeStackForVM(vm);
 96     vm.heap.collectNow(Sync, CollectionScope::Full);
 97 }
 98 
 99 void InspectorHeapAgent::snapshot(ErrorString&amp;, double* timestamp, String* snapshotData)
100 {
101     VM&amp; vm = m_environment.vm();
102     JSLockHolder lock(vm);
103 
104     HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
105     snapshotBuilder.buildSnapshot();
106 
107     *timestamp = m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
108     *snapshotData = snapshotBuilder.json([&amp;] (const HeapSnapshotNode&amp; node) {
109         if (Structure* structure = node.cell-&gt;structure(vm)) {
110             if (JSGlobalObject* globalObject = structure-&gt;globalObject()) {
<span class="line-modified">111                 if (!m_environment.canAccessInspectedScriptState(globalObject))</span>
112                     return false;
113             }
114         }
115         return true;
116     });
117 }
118 
119 void InspectorHeapAgent::startTracking(ErrorString&amp; errorString)
120 {
121     if (m_tracking)
122         return;
123 
124     m_tracking = true;
125 
126     double timestamp;
127     String snapshotData;
128     snapshot(errorString, &amp;timestamp, &amp;snapshotData);
129 
130     m_frontendDispatcher-&gt;trackingStart(timestamp, snapshotData);
131 }
</pre>
<hr />
<pre>
189     // BigInt preview.
190     if (cell-&gt;isBigInt()) {
191         resultString = JSBigInt::tryGetString(vm, asBigInt(cell), 10);
192         return;
193     }
194 
195     // FIXME: Provide preview information for Internal Objects? CodeBlock, Executable, etc.
196 
197     Structure* structure = cell-&gt;structure(vm);
198     if (!structure) {
199         errorString = &quot;Unable to get object details - Structure&quot;_s;
200         return;
201     }
202 
203     JSGlobalObject* globalObject = structure-&gt;globalObject();
204     if (!globalObject) {
205         errorString = &quot;Unable to get object details - GlobalObject&quot;_s;
206         return;
207     }
208 
<span class="line-modified">209     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(globalObject);</span>
210     if (injectedScript.hasNoValue()) {
211         errorString = &quot;Unable to get object details - InjectedScript&quot;_s;
212         return;
213     }
214 
215     // Function preview.
216     if (cell-&gt;inherits&lt;JSFunction&gt;(vm)) {
217         injectedScript.functionDetails(errorString, cell, functionDetails);
218         return;
219     }
220 
221     // Object preview.
222     objectPreview = injectedScript.previewValue(cell);
223 }
224 
225 void InspectorHeapAgent::getRemoteObject(ErrorString&amp; errorString, int heapObjectId, const String* optionalObjectGroup, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result)
226 {
227     // Prevent the cell from getting collected as we look it up.
228     VM&amp; vm = m_environment.vm();
229     JSLockHolder lock(vm);
230     DeferGC deferGC(vm.heap);
231 
232     unsigned heapObjectIdentifier = static_cast&lt;unsigned&gt;(heapObjectId);
233     const Optional&lt;HeapSnapshotNode&gt; optionalNode = nodeForHeapObjectIdentifier(errorString, heapObjectIdentifier);
234     if (!optionalNode)
235         return;
236 
237     JSCell* cell = optionalNode-&gt;cell;
238     Structure* structure = cell-&gt;structure(vm);
239     if (!structure) {
240         errorString = &quot;Unable to get object details - Structure&quot;_s;
241         return;
242     }
243 
244     JSGlobalObject* globalObject = structure-&gt;globalObject();
245     if (!globalObject) {
246         errorString = &quot;Unable to get object details - GlobalObject&quot;_s;
247         return;
248     }
249 
<span class="line-modified">250     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(globalObject);</span>
251     if (injectedScript.hasNoValue()) {
252         errorString = &quot;Unable to get object details - InjectedScript&quot;_s;
253         return;
254     }
255 
256     String objectGroup = optionalObjectGroup ? *optionalObjectGroup : String();
257     result = injectedScript.wrapObject(cell, objectGroup, true);
258 }
259 
260 static Protocol::Heap::GarbageCollection::Type protocolTypeForHeapOperation(CollectionScope scope)
261 {
262     switch (scope) {
263     case CollectionScope::Full:
264         return Protocol::Heap::GarbageCollection::Type::Full;
265     case CollectionScope::Eden:
266         return Protocol::Heap::GarbageCollection::Type::Partial;
267     }
268     ASSERT_NOT_REACHED();
269     return Protocol::Heap::GarbageCollection::Type::Full;
270 }
</pre>
</td>
</tr>
</table>
<center><a href="InspectorDebuggerAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorHeapAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
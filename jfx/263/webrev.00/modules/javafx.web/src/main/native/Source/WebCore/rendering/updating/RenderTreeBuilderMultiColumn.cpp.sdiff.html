<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderMultiColumn.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderTreeBuilderInline.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeBuilderMultiColumn.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderMultiColumn.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;RenderTreeBuilderMultiColumn.h&quot;
 26 
 27 #include &quot;RenderBlockFlow.h&quot;
 28 #include &quot;RenderChildIterator.h&quot;
 29 #include &quot;RenderMultiColumnFlow.h&quot;
 30 #include &quot;RenderMultiColumnSet.h&quot;
 31 #include &quot;RenderMultiColumnSpannerPlaceholder.h&quot;
 32 #include &quot;RenderTreeBuilder.h&quot;
 33 #include &quot;RenderTreeBuilderBlock.h&quot;

 34 
 35 namespace WebCore {
 36 
 37 static RenderMultiColumnSet* findSetRendering(const RenderMultiColumnFlow&amp; fragmentedFlow, const RenderObject&amp; renderer)
 38 {
 39     // Find the set inside which the specified renderer would be rendered.
 40     for (auto* multicolSet = fragmentedFlow.firstMultiColumnSet(); multicolSet; multicolSet = multicolSet-&gt;nextSiblingMultiColumnSet()) {
 41         if (multicolSet-&gt;containsRendererInFragmentedFlow(renderer))
 42             return multicolSet;
 43     }
 44     return nullptr;
 45 }
 46 
 47 static RenderObject* spannerPlacehoderCandidate(const RenderObject&amp; renderer, const RenderMultiColumnFlow&amp; stayWithin)
 48 {
 49     // Spanner candidate is a next sibling/ancestor&#39;s next child within the flow thread and
 50     // it is in the same inflow/out-of-flow layout context.
 51     if (renderer.isOutOfFlowPositioned())
 52         return nullptr;
 53 
</pre>
<hr />
<pre>
264             // where it would otherwise occur (if it weren&#39;t a spanner) to becoming a sibling of the
265             // column sets.
266             RenderMultiColumnSpannerPlaceholder&amp; placeholder = downcast&lt;RenderMultiColumnSpannerPlaceholder&gt;(*descendant);
267             ASSERT(!flow.spannerMap().get(placeholder.spanner()));
268             flow.spannerMap().add(placeholder.spanner(), makeWeakPtr(downcast&lt;RenderMultiColumnSpannerPlaceholder&gt;(descendant)));
269             ASSERT(!placeholder.firstChild()); // There should be no children here, but if there are, we ought to skip them.
270         } else
271             descendant = processPossibleSpannerDescendant(flow, subtreeRoot, *descendant);
272         if (descendant)
273             descendant = descendant-&gt;nextInPreOrder(subtreeRoot);
274     }
275 }
276 
277 RenderObject* RenderTreeBuilder::MultiColumn::processPossibleSpannerDescendant(RenderMultiColumnFlow&amp; flow, RenderObject*&amp; subtreeRoot, RenderObject&amp; descendant)
278 {
279     RenderBlockFlow* multicolContainer = flow.multiColumnBlockFlow();
280     RenderObject* nextRendererInFragmentedFlow = spannerPlacehoderCandidate(descendant, flow);
281     RenderObject* insertBeforeMulticolChild = nullptr;
282     RenderObject* nextDescendant = &amp;descendant;
283 



284     if (isValidColumnSpanner(flow, descendant)) {
285         // This is a spanner (column-span:all). Such renderers are moved from where they would
286         // otherwise occur in the render tree to becoming a direct child of the multicol container,
287         // so that they live among the column sets. This simplifies the layout implementation, and
288         // basically just relies on regular block layout done by the RenderBlockFlow that
289         // establishes the multicol container.
290         RenderBlockFlow* container = downcast&lt;RenderBlockFlow&gt;(descendant.parent());
291         RenderMultiColumnSet* setToSplit = nullptr;
292         if (nextRendererInFragmentedFlow) {
293             setToSplit = findSetRendering(flow, descendant);
294             if (setToSplit) {
295                 setToSplit-&gt;setNeedsLayout();
296                 insertBeforeMulticolChild = setToSplit-&gt;nextSibling();
297             }
298         }
299         // Moving a spanner&#39;s renderer so that it becomes a sibling of the column sets requires us
300         // to insert an anonymous placeholder in the tree where the spanner&#39;s renderer otherwise
301         // would have been. This is needed for a two reasons: We need a way of separating inline
302         // content before and after the spanner, so that it becomes separate line boxes. Secondly,
303         // this placeholder serves as a break point for column sets, so that, when encountered, we
</pre>
</td>
<td>
<hr />
<pre>
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;RenderTreeBuilderMultiColumn.h&quot;
 26 
 27 #include &quot;RenderBlockFlow.h&quot;
 28 #include &quot;RenderChildIterator.h&quot;
 29 #include &quot;RenderMultiColumnFlow.h&quot;
 30 #include &quot;RenderMultiColumnSet.h&quot;
 31 #include &quot;RenderMultiColumnSpannerPlaceholder.h&quot;
 32 #include &quot;RenderTreeBuilder.h&quot;
 33 #include &quot;RenderTreeBuilderBlock.h&quot;
<span class="line-added"> 34 #include &quot;RenderView.h&quot;</span>
 35 
 36 namespace WebCore {
 37 
 38 static RenderMultiColumnSet* findSetRendering(const RenderMultiColumnFlow&amp; fragmentedFlow, const RenderObject&amp; renderer)
 39 {
 40     // Find the set inside which the specified renderer would be rendered.
 41     for (auto* multicolSet = fragmentedFlow.firstMultiColumnSet(); multicolSet; multicolSet = multicolSet-&gt;nextSiblingMultiColumnSet()) {
 42         if (multicolSet-&gt;containsRendererInFragmentedFlow(renderer))
 43             return multicolSet;
 44     }
 45     return nullptr;
 46 }
 47 
 48 static RenderObject* spannerPlacehoderCandidate(const RenderObject&amp; renderer, const RenderMultiColumnFlow&amp; stayWithin)
 49 {
 50     // Spanner candidate is a next sibling/ancestor&#39;s next child within the flow thread and
 51     // it is in the same inflow/out-of-flow layout context.
 52     if (renderer.isOutOfFlowPositioned())
 53         return nullptr;
 54 
</pre>
<hr />
<pre>
265             // where it would otherwise occur (if it weren&#39;t a spanner) to becoming a sibling of the
266             // column sets.
267             RenderMultiColumnSpannerPlaceholder&amp; placeholder = downcast&lt;RenderMultiColumnSpannerPlaceholder&gt;(*descendant);
268             ASSERT(!flow.spannerMap().get(placeholder.spanner()));
269             flow.spannerMap().add(placeholder.spanner(), makeWeakPtr(downcast&lt;RenderMultiColumnSpannerPlaceholder&gt;(descendant)));
270             ASSERT(!placeholder.firstChild()); // There should be no children here, but if there are, we ought to skip them.
271         } else
272             descendant = processPossibleSpannerDescendant(flow, subtreeRoot, *descendant);
273         if (descendant)
274             descendant = descendant-&gt;nextInPreOrder(subtreeRoot);
275     }
276 }
277 
278 RenderObject* RenderTreeBuilder::MultiColumn::processPossibleSpannerDescendant(RenderMultiColumnFlow&amp; flow, RenderObject*&amp; subtreeRoot, RenderObject&amp; descendant)
279 {
280     RenderBlockFlow* multicolContainer = flow.multiColumnBlockFlow();
281     RenderObject* nextRendererInFragmentedFlow = spannerPlacehoderCandidate(descendant, flow);
282     RenderObject* insertBeforeMulticolChild = nullptr;
283     RenderObject* nextDescendant = &amp;descendant;
284 
<span class="line-added">285     if (!multicolContainer)</span>
<span class="line-added">286         return nullptr;</span>
<span class="line-added">287 </span>
288     if (isValidColumnSpanner(flow, descendant)) {
289         // This is a spanner (column-span:all). Such renderers are moved from where they would
290         // otherwise occur in the render tree to becoming a direct child of the multicol container,
291         // so that they live among the column sets. This simplifies the layout implementation, and
292         // basically just relies on regular block layout done by the RenderBlockFlow that
293         // establishes the multicol container.
294         RenderBlockFlow* container = downcast&lt;RenderBlockFlow&gt;(descendant.parent());
295         RenderMultiColumnSet* setToSplit = nullptr;
296         if (nextRendererInFragmentedFlow) {
297             setToSplit = findSetRendering(flow, descendant);
298             if (setToSplit) {
299                 setToSplit-&gt;setNeedsLayout();
300                 insertBeforeMulticolChild = setToSplit-&gt;nextSibling();
301             }
302         }
303         // Moving a spanner&#39;s renderer so that it becomes a sibling of the column sets requires us
304         // to insert an anonymous placeholder in the tree where the spanner&#39;s renderer otherwise
305         // would have been. This is needed for a two reasons: We need a way of separating inline
306         // content before and after the spanner, so that it becomes separate line boxes. Secondly,
307         // this placeholder serves as a break point for column sets, so that, when encountered, we
</pre>
</td>
</tr>
</table>
<center><a href="RenderTreeBuilderInline.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeBuilderMultiColumn.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.h
@@ -25,14 +25,16 @@
 
 #pragma once
 
 #include "ArrayBufferSharingMode.h"
 #include "GCIncomingRefCounted.h"
+#include "Watchpoint.h"
 #include "Weak.h"
 #include <wtf/CagedPtr.h>
 #include <wtf/CheckedArithmetic.h>
-#include <wtf/Function.h>
+#include <wtf/PackedRefPtr.h>
+#include <wtf/SharedTask.h>
 #include <wtf/StdLibExtras.h>
 #include <wtf/ThreadSafeRefCounted.h>
 #include <wtf/text/WTFString.h>
 
 namespace JSC {
@@ -42,11 +44,12 @@
 class VM;
 class ArrayBuffer;
 class ArrayBufferView;
 class JSArrayBuffer;
 
-typedef Function<void(void*)> ArrayBufferDestructorFunction;
+using ArrayBufferDestructorFunction = RefPtr<SharedTask<void(void*)>>;
+using PackedArrayBufferDestructorFunction = PackedRefPtr<SharedTask<void(void*)>>;
 
 class SharedArrayBufferContents : public ThreadSafeRefCounted<SharedArrayBufferContents> {
 public:
     SharedArrayBufferContents(void* data, unsigned size, ArrayBufferDestructorFunction&&);
     ~SharedArrayBufferContents();
@@ -54,11 +57,11 @@
     void* data() const { return m_data.getMayBeNull(m_sizeInBytes); }
 
 private:
     using DataType = CagedPtr<Gigacage::Primitive, void, tagCagedPtr>;
     DataType m_data;
-    ArrayBufferDestructorFunction m_destructor;
+    PackedArrayBufferDestructorFunction m_destructor;
     unsigned m_sizeInBytes;
 };
 
 class ArrayBufferContents {
     WTF_MAKE_NONCOPYABLE(ArrayBufferContents);
@@ -96,14 +99,14 @@
     void makeShared();
     void transferTo(ArrayBufferContents&);
     void copyTo(ArrayBufferContents&);
     void shareWith(ArrayBufferContents&);
 
-    ArrayBufferDestructorFunction m_destructor;
-    RefPtr<SharedArrayBufferContents> m_shared;
     using DataType = CagedPtr<Gigacage::Primitive, void, tagCagedPtr>;
     DataType m_data;
+    PackedArrayBufferDestructorFunction m_destructor;
+    PackedRefPtr<SharedArrayBufferContents> m_shared;
     unsigned m_sizeInBytes;
 };
 
 class ArrayBuffer : public GCIncomingRefCounted<ArrayBuffer> {
 public:
@@ -130,12 +133,12 @@
     inline bool isShared() const;
     inline ArrayBufferSharingMode sharingMode() const { return isShared() ? ArrayBufferSharingMode::Shared : ArrayBufferSharingMode::Default; }
 
     inline size_t gcSizeEstimateInBytes() const;
 
-    JS_EXPORT_PRIVATE Ref<ArrayBuffer> slice(double begin, double end) const;
-    JS_EXPORT_PRIVATE Ref<ArrayBuffer> slice(double begin) const;
+    JS_EXPORT_PRIVATE RefPtr<ArrayBuffer> slice(double begin, double end) const;
+    JS_EXPORT_PRIVATE RefPtr<ArrayBuffer> slice(double begin) const;
 
     inline void pin();
     inline void unpin();
     inline void pinAndLock();
     inline bool isLocked();
@@ -146,35 +149,39 @@
     JS_EXPORT_PRIVATE bool transferTo(VM&, ArrayBufferContents&);
     JS_EXPORT_PRIVATE bool shareWith(ArrayBufferContents&);
 
     void neuter(VM&);
     bool isNeutered() { return !m_contents.m_data; }
+    InlineWatchpointSet& neuteringWatchpointSet() { return m_neuteringWatchpointSet; }
 
     static ptrdiff_t offsetOfData() { return OBJECT_OFFSETOF(ArrayBuffer, m_contents) + OBJECT_OFFSETOF(ArrayBufferContents, m_data); }
 
     ~ArrayBuffer() { }
 
+    JS_EXPORT_PRIVATE static Ref<SharedTask<void(void*)>> primitiveGigacageDestructor();
+
 private:
     static Ref<ArrayBuffer> create(unsigned numElements, unsigned elementByteSize, ArrayBufferContents::InitializationPolicy);
     static Ref<ArrayBuffer> createInternal(ArrayBufferContents&&, const void*, unsigned);
     static RefPtr<ArrayBuffer> tryCreate(unsigned numElements, unsigned elementByteSize, ArrayBufferContents::InitializationPolicy);
     ArrayBuffer(ArrayBufferContents&&);
-    Ref<ArrayBuffer> sliceImpl(unsigned begin, unsigned end) const;
+    RefPtr<ArrayBuffer> sliceImpl(unsigned begin, unsigned end) const;
     inline unsigned clampIndex(double index) const;
     static inline unsigned clampValue(double x, unsigned left, unsigned right);
 
-    void notifyIncommingReferencesOfTransfer(VM&);
+    void notifyNeutering(VM&);
 
     ArrayBufferContents m_contents;
+    InlineWatchpointSet m_neuteringWatchpointSet { IsWatched };
+public:
+    Weak<JSArrayBuffer> m_wrapper;
+private:
     Checked<unsigned> m_pinCount;
     bool m_isWasmMemory;
     // m_locked == true means that some API user fetched m_contents directly from a TypedArray object,
     // the buffer is backed by a WebAssembly.Memory, or is a SharedArrayBuffer.
     bool m_locked;
-
-public:
-    Weak<JSArrayBuffer> m_wrapper;
 };
 
 void* ArrayBuffer::data()
 {
     return m_contents.data();

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/Shape.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RectangleShape.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ShapeOutsideInfo.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/Shape.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -98,22 +98,22 @@</span>
      float boxHeight = horizontalWritingMode ? logicalBoxSize.height() : logicalBoxSize.width();
      std::unique_ptr&lt;Shape&gt; shape;
  
      switch (basicShape.type()) {
  
<span class="udiff-line-modified-removed">-     case BasicShape::BasicShapeCircleType: {</span>
<span class="udiff-line-modified-added">+     case BasicShape::Type::Circle: {</span>
          const auto&amp; circle = downcast&lt;BasicShapeCircle&gt;(basicShape);
          float centerX = floatValueForCenterCoordinate(circle.centerX(), boxWidth);
          float centerY = floatValueForCenterCoordinate(circle.centerY(), boxHeight);
          float radius = circle.floatValueForRadiusInBox(boxWidth, boxHeight);
          FloatPoint logicalCenter = physicalPointToLogical(FloatPoint(centerX, centerY), logicalBoxSize.height(), writingMode);
  
          shape = createCircleShape(logicalCenter, radius);
          break;
      }
  
<span class="udiff-line-modified-removed">-     case BasicShape::BasicShapeEllipseType: {</span>
<span class="udiff-line-modified-added">+     case BasicShape::Type::Ellipse: {</span>
          const auto&amp; ellipse = downcast&lt;BasicShapeEllipse&gt;(basicShape);
          float centerX = floatValueForCenterCoordinate(ellipse.centerX(), boxWidth);
          float centerY = floatValueForCenterCoordinate(ellipse.centerY(), boxHeight);
          float radiusX = ellipse.floatValueForRadiusInBox(ellipse.radiusX(), centerX, boxWidth);
          float radiusY = ellipse.floatValueForRadiusInBox(ellipse.radiusY(), centerY, boxHeight);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121,11 +121,11 @@</span>
  
          shape = createEllipseShape(logicalCenter, FloatSize(radiusX, radiusY));
          break;
      }
  
<span class="udiff-line-modified-removed">-     case BasicShape::BasicShapePolygonType: {</span>
<span class="udiff-line-modified-added">+     case BasicShape::Type::Polygon: {</span>
          const auto&amp; polygon = downcast&lt;BasicShapePolygon&gt;(basicShape);
          const Vector&lt;Length&gt;&amp; values = polygon.values();
          size_t valuesSize = values.size();
          ASSERT(!(valuesSize % 2));
          std::unique_ptr&lt;Vector&lt;FloatPoint&gt;&gt; vertices = makeUnique&lt;Vector&lt;FloatPoint&gt;&gt;(valuesSize / 2);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -138,11 +138,11 @@</span>
  
          shape = createPolygonShape(WTFMove(vertices), polygon.windRule());
          break;
      }
  
<span class="udiff-line-modified-removed">-     case BasicShape::BasicShapeInsetType: {</span>
<span class="udiff-line-modified-added">+     case BasicShape::Type::Inset: {</span>
          const auto&amp; inset = downcast&lt;BasicShapeInset&gt;(basicShape);
          float left = floatValueForLength(inset.left(), boxWidth);
          float top = floatValueForLength(inset.top(), boxHeight);
          FloatRect rect(left,
              top,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -179,22 +179,22 @@</span>
  
      IntRect imageRect = snappedIntRect(imageR);
      IntRect marginRect = snappedIntRect(marginR);
      auto intervals = makeUnique&lt;RasterShapeIntervals&gt;(marginRect.height(), -marginRect.y());
      // FIXME (149420): This buffer should not be unconditionally unaccelerated.
<span class="udiff-line-modified-removed">-     std::unique_ptr&lt;ImageBuffer&gt; imageBuffer = ImageBuffer::create(imageRect.size(), Unaccelerated);</span>
<span class="udiff-line-modified-added">+     std::unique_ptr&lt;ImageBuffer&gt; imageBuffer = ImageBuffer::create(imageRect.size(), RenderingMode::Unaccelerated);</span>
  
      if (imageBuffer) {
          GraphicsContext&amp; graphicsContext = imageBuffer-&gt;context();
          if (image)
              graphicsContext.drawImage(*image, IntRect(IntPoint(), imageRect.size()));
  
          RefPtr&lt;Uint8ClampedArray&gt; pixelArray = imageBuffer-&gt;getUnmultipliedImageData(IntRect(IntPoint(), imageRect.size()));
          RELEASE_ASSERT(pixelArray);
          unsigned pixelArrayLength = pixelArray-&gt;length();
          unsigned pixelArrayOffset = 3; // Each pixel is four bytes: RGBA.
<span class="udiff-line-modified-removed">-         uint8_t alphaPixelThreshold = threshold * 255;</span>
<span class="udiff-line-modified-added">+         uint8_t alphaPixelThreshold = static_cast&lt;uint8_t&gt;(lroundf(clampTo&lt;float&gt;(threshold, 0, 1) * 255.0f));</span>
  
          int minBufferY = std::max(0, marginRect.y() - imageRect.y());
          int maxBufferY = std::min(imageRect.height(), marginRect.maxY() - imageRect.y());
  
          if ((imageRect.area() * 4).unsafeGet() == pixelArrayLength) {
</pre>
<center><a href="RectangleShape.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ShapeOutsideInfo.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
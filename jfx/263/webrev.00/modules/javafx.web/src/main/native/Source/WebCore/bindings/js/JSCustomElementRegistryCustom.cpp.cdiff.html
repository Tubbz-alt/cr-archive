<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSCustomElementRegistryCustom.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCustomElementInterface.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSCustomEventCustom.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSCustomElementRegistryCustom.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 38,121 ***</span>
  
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-modified">! static JSObject* getCustomElementCallback(ExecState&amp; state, JSObject&amp; prototype, const Identifier&amp; id)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue callback = prototype.get(&amp;state, id);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (callback.isUndefined())
          return nullptr;
      if (!callback.isFunction(vm)) {
<span class="line-modified">!         throwTypeError(&amp;state, scope, &quot;A custom element callback must be a function&quot;_s);</span>
          return nullptr;
      }
      return callback.getObject();
  }
  
<span class="line-modified">! static bool validateCustomElementNameAndThrowIfNeeded(ExecState&amp; state, const AtomString&amp; name)</span>
  {
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(state.vm());</span>
      switch (Document::validateCustomElementName(name)) {
      case CustomElementNameValidationStatus::Valid:
          return true;
      case CustomElementNameValidationStatus::FirstCharacterIsNotLowercaseASCIILetter:
<span class="line-modified">!         throwDOMSyntaxError(state, scope, &quot;Custom element name must have a lowercase ASCII letter as its first character&quot;_s);</span>
          return false;
      case CustomElementNameValidationStatus::ContainsUppercaseASCIILetter:
<span class="line-modified">!         throwDOMSyntaxError(state, scope, &quot;Custom element name cannot contain an uppercase ASCII letter&quot;_s);</span>
          return false;
      case CustomElementNameValidationStatus::ContainsNoHyphen:
<span class="line-modified">!         throwDOMSyntaxError(state, scope, &quot;Custom element name must contain a hyphen&quot;_s);</span>
          return false;
      case CustomElementNameValidationStatus::ContainsDisallowedCharacter:
<span class="line-modified">!         throwDOMSyntaxError(state, scope, &quot;Custom element name contains a character that is not allowed&quot;_s);</span>
          return false;
      case CustomElementNameValidationStatus::ConflictsWithStandardElementName:
<span class="line-modified">!         throwDOMSyntaxError(state, scope, &quot;Custom element name cannot be same as one of the standard elements&quot;_s);</span>
          return false;
      }
      ASSERT_NOT_REACHED();
      return false;
  }
  
  // https://html.spec.whatwg.org/#dom-customelementregistry-define
<span class="line-modified">! JSValue JSCustomElementRegistry::define(ExecState&amp; state)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (UNLIKELY(state.argumentCount() &lt; 2))</span>
<span class="line-modified">!         return throwException(&amp;state, scope, createNotEnoughArgumentsError(&amp;state));</span>
  
<span class="line-modified">!     AtomString localName(state.uncheckedArgument(0).toString(&amp;state)-&gt;toAtomString(&amp;state));</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-modified">!     JSValue constructorValue = state.uncheckedArgument(1);</span>
      if (!constructorValue.isConstructor(vm))
<span class="line-modified">!         return throwTypeError(&amp;state, scope, &quot;The second argument must be a constructor&quot;_s);</span>
      JSObject* constructor = constructorValue.getObject();
  
<span class="line-modified">!     if (!validateCustomElementNameAndThrowIfNeeded(state, localName))</span>
          return jsUndefined();
  
      CustomElementRegistry&amp; registry = wrapped();
  
      if (registry.elementDefinitionIsRunning()) {
<span class="line-modified">!         throwNotSupportedError(state, scope, &quot;Cannot define a custom element while defining another custom element&quot;_s);</span>
          return jsUndefined();
      }
      SetForScope&lt;bool&gt; change(registry.elementDefinitionIsRunning(), true);
  
      if (registry.findInterface(localName)) {
<span class="line-modified">!         throwNotSupportedError(state, scope, &quot;Cannot define multiple custom elements with the same tag name&quot;_s);</span>
          return jsUndefined();
      }
  
      if (registry.containsConstructor(constructor)) {
<span class="line-modified">!         throwNotSupportedError(state, scope, &quot;Cannot define multiple custom elements with the same class&quot;_s);</span>
          return jsUndefined();
      }
  
<span class="line-modified">!     JSValue prototypeValue = constructor-&gt;get(&amp;state, vm.propertyNames-&gt;prototype);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
      if (!prototypeValue.isObject())
<span class="line-modified">!         return throwTypeError(&amp;state, scope, &quot;Custom element constructor&#39;s prototype must be an object&quot;_s);</span>
      JSObject&amp; prototypeObject = *asObject(prototypeValue);
  
      QualifiedName name(nullAtom(), localName, HTMLNames::xhtmlNamespaceURI);
      auto elementInterface = JSCustomElementInterface::create(name, constructor, globalObject());
  
<span class="line-modified">!     auto* connectedCallback = getCustomElementCallback(state, prototypeObject, Identifier::fromString(vm, &quot;connectedCallback&quot;));</span>
      if (connectedCallback)
          elementInterface-&gt;setConnectedCallback(connectedCallback);
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-modified">!     auto* disconnectedCallback = getCustomElementCallback(state, prototypeObject, Identifier::fromString(vm, &quot;disconnectedCallback&quot;));</span>
      if (disconnectedCallback)
          elementInterface-&gt;setDisconnectedCallback(disconnectedCallback);
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-modified">!     auto* adoptedCallback = getCustomElementCallback(state, prototypeObject, Identifier::fromString(vm, &quot;adoptedCallback&quot;));</span>
      if (adoptedCallback)
          elementInterface-&gt;setAdoptedCallback(adoptedCallback);
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-modified">!     auto* attributeChangedCallback = getCustomElementCallback(state, prototypeObject, Identifier::fromString(vm, &quot;attributeChangedCallback&quot;));</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
      if (attributeChangedCallback) {
<span class="line-modified">!         auto observedAttributesValue = constructor-&gt;get(&amp;state, Identifier::fromString(vm, &quot;observedAttributes&quot;));</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
          if (!observedAttributesValue.isUndefined()) {
<span class="line-modified">!             auto observedAttributes = convert&lt;IDLSequence&lt;IDLDOMString&gt;&gt;(state, observedAttributesValue);</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              elementInterface-&gt;setAttributeChangedCallback(attributeChangedCallback, observedAttributes);
          }
      }
  
<span class="line-new-header">--- 38,121 ---</span>
  
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-modified">! static JSObject* getCustomElementCallback(JSGlobalObject&amp; lexicalGlobalObject, JSObject&amp; prototype, const Identifier&amp; id)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue callback = prototype.get(&amp;lexicalGlobalObject, id);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (callback.isUndefined())
          return nullptr;
      if (!callback.isFunction(vm)) {
<span class="line-modified">!         throwTypeError(&amp;lexicalGlobalObject, scope, &quot;A custom element callback must be a function&quot;_s);</span>
          return nullptr;
      }
      return callback.getObject();
  }
  
<span class="line-modified">! static bool validateCustomElementNameAndThrowIfNeeded(JSGlobalObject&amp; lexicalGlobalObject, const AtomString&amp; name)</span>
  {
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(lexicalGlobalObject.vm());</span>
      switch (Document::validateCustomElementName(name)) {
      case CustomElementNameValidationStatus::Valid:
          return true;
      case CustomElementNameValidationStatus::FirstCharacterIsNotLowercaseASCIILetter:
<span class="line-modified">!         throwDOMSyntaxError(lexicalGlobalObject, scope, &quot;Custom element name must have a lowercase ASCII letter as its first character&quot;_s);</span>
          return false;
      case CustomElementNameValidationStatus::ContainsUppercaseASCIILetter:
<span class="line-modified">!         throwDOMSyntaxError(lexicalGlobalObject, scope, &quot;Custom element name cannot contain an uppercase ASCII letter&quot;_s);</span>
          return false;
      case CustomElementNameValidationStatus::ContainsNoHyphen:
<span class="line-modified">!         throwDOMSyntaxError(lexicalGlobalObject, scope, &quot;Custom element name must contain a hyphen&quot;_s);</span>
          return false;
      case CustomElementNameValidationStatus::ContainsDisallowedCharacter:
<span class="line-modified">!         throwDOMSyntaxError(lexicalGlobalObject, scope, &quot;Custom element name contains a character that is not allowed&quot;_s);</span>
          return false;
      case CustomElementNameValidationStatus::ConflictsWithStandardElementName:
<span class="line-modified">!         throwDOMSyntaxError(lexicalGlobalObject, scope, &quot;Custom element name cannot be same as one of the standard elements&quot;_s);</span>
          return false;
      }
      ASSERT_NOT_REACHED();
      return false;
  }
  
  // https://html.spec.whatwg.org/#dom-customelementregistry-define
<span class="line-modified">! JSValue JSCustomElementRegistry::define(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (UNLIKELY(callFrame.argumentCount() &lt; 2))</span>
<span class="line-modified">!         return throwException(&amp;lexicalGlobalObject, scope, createNotEnoughArgumentsError(&amp;lexicalGlobalObject));</span>
  
<span class="line-modified">!     AtomString localName(callFrame.uncheckedArgument(0).toString(&amp;lexicalGlobalObject)-&gt;toAtomString(&amp;lexicalGlobalObject));</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-modified">!     JSValue constructorValue = callFrame.uncheckedArgument(1);</span>
      if (!constructorValue.isConstructor(vm))
<span class="line-modified">!         return throwTypeError(&amp;lexicalGlobalObject, scope, &quot;The second argument must be a constructor&quot;_s);</span>
      JSObject* constructor = constructorValue.getObject();
  
<span class="line-modified">!     if (!validateCustomElementNameAndThrowIfNeeded(lexicalGlobalObject, localName))</span>
          return jsUndefined();
  
      CustomElementRegistry&amp; registry = wrapped();
  
      if (registry.elementDefinitionIsRunning()) {
<span class="line-modified">!         throwNotSupportedError(lexicalGlobalObject, scope, &quot;Cannot define a custom element while defining another custom element&quot;_s);</span>
          return jsUndefined();
      }
      SetForScope&lt;bool&gt; change(registry.elementDefinitionIsRunning(), true);
  
      if (registry.findInterface(localName)) {
<span class="line-modified">!         throwNotSupportedError(lexicalGlobalObject, scope, &quot;Cannot define multiple custom elements with the same tag name&quot;_s);</span>
          return jsUndefined();
      }
  
      if (registry.containsConstructor(constructor)) {
<span class="line-modified">!         throwNotSupportedError(lexicalGlobalObject, scope, &quot;Cannot define multiple custom elements with the same class&quot;_s);</span>
          return jsUndefined();
      }
  
<span class="line-modified">!     JSValue prototypeValue = constructor-&gt;get(&amp;lexicalGlobalObject, vm.propertyNames-&gt;prototype);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
      if (!prototypeValue.isObject())
<span class="line-modified">!         return throwTypeError(&amp;lexicalGlobalObject, scope, &quot;Custom element constructor&#39;s prototype must be an object&quot;_s);</span>
      JSObject&amp; prototypeObject = *asObject(prototypeValue);
  
      QualifiedName name(nullAtom(), localName, HTMLNames::xhtmlNamespaceURI);
      auto elementInterface = JSCustomElementInterface::create(name, constructor, globalObject());
  
<span class="line-modified">!     auto* connectedCallback = getCustomElementCallback(lexicalGlobalObject, prototypeObject, Identifier::fromString(vm, &quot;connectedCallback&quot;));</span>
      if (connectedCallback)
          elementInterface-&gt;setConnectedCallback(connectedCallback);
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-modified">!     auto* disconnectedCallback = getCustomElementCallback(lexicalGlobalObject, prototypeObject, Identifier::fromString(vm, &quot;disconnectedCallback&quot;));</span>
      if (disconnectedCallback)
          elementInterface-&gt;setDisconnectedCallback(disconnectedCallback);
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-modified">!     auto* adoptedCallback = getCustomElementCallback(lexicalGlobalObject, prototypeObject, Identifier::fromString(vm, &quot;adoptedCallback&quot;));</span>
      if (adoptedCallback)
          elementInterface-&gt;setAdoptedCallback(adoptedCallback);
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-modified">!     auto* attributeChangedCallback = getCustomElementCallback(lexicalGlobalObject, prototypeObject, Identifier::fromString(vm, &quot;attributeChangedCallback&quot;));</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
      if (attributeChangedCallback) {
<span class="line-modified">!         auto observedAttributesValue = constructor-&gt;get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;observedAttributes&quot;));</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
          if (!observedAttributesValue.isUndefined()) {
<span class="line-modified">!             auto observedAttributes = convert&lt;IDLSequence&lt;IDLDOMString&gt;&gt;(lexicalGlobalObject, observedAttributesValue);</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              elementInterface-&gt;setAttributeChangedCallback(attributeChangedCallback, observedAttributes);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,50 ***</span>
  
      return jsUndefined();
  }
  
  // https://html.spec.whatwg.org/#dom-customelementregistry-whendefined
<span class="line-modified">! static JSValue whenDefinedPromise(ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, CustomElementRegistry&amp; registry, JSPromiseDeferred&amp; promiseDeferred)</span>
  {
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(state.vm());</span>
  
<span class="line-modified">!     if (UNLIKELY(state.argumentCount() &lt; 1))</span>
<span class="line-modified">!         return throwException(&amp;state, scope, createNotEnoughArgumentsError(&amp;state));</span>
  
<span class="line-modified">!     AtomString localName(state.uncheckedArgument(0).toString(&amp;state)-&gt;toAtomString(&amp;state));</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-modified">!     if (!validateCustomElementNameAndThrowIfNeeded(state, localName)) {</span>
          EXCEPTION_ASSERT(scope.exception());
          return jsUndefined();
      }
  
      if (registry.findInterface(localName)) {
<span class="line-modified">!         DeferredPromise::create(globalObject, promiseDeferred)-&gt;resolve();</span>
<span class="line-modified">!         return promiseDeferred.promise();</span>
      }
  
      auto result = registry.promiseMap().ensure(localName, [&amp;] {
<span class="line-modified">!         return DeferredPromise::create(globalObject, promiseDeferred);</span>
      });
  
      return result.iterator-&gt;value-&gt;promise();
  }
  
<span class="line-modified">! JSValue JSCustomElementRegistry::whenDefined(ExecState&amp; state)</span>
  {
<span class="line-modified">!     auto scope = DECLARE_CATCH_SCOPE(state.vm());</span>
  
      ASSERT(globalObject());
<span class="line-modified">!     auto promiseDeferred = JSPromiseDeferred::tryCreate(&amp;state, globalObject());</span>
<span class="line-modified">!     RELEASE_ASSERT(promiseDeferred);</span>
<span class="line-removed">-     JSValue promise = whenDefinedPromise(state, *globalObject(), wrapped(), *promiseDeferred);</span>
  
      if (UNLIKELY(scope.exception())) {
<span class="line-modified">!         rejectPromiseWithExceptionIfAny(state, *globalObject(), *promiseDeferred);</span>
          scope.assertNoException();
<span class="line-modified">!         return promiseDeferred-&gt;promise();</span>
      }
  
      return promise;
  }
  
<span class="line-new-header">--- 173,49 ---</span>
  
      return jsUndefined();
  }
  
  // https://html.spec.whatwg.org/#dom-customelementregistry-whendefined
<span class="line-modified">! static JSValue whenDefinedPromise(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame, JSDOMGlobalObject&amp; globalObject, CustomElementRegistry&amp; registry, JSPromise&amp; promise)</span>
  {
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(lexicalGlobalObject.vm());</span>
  
<span class="line-modified">!     if (UNLIKELY(callFrame.argumentCount() &lt; 1))</span>
<span class="line-modified">!         return throwException(&amp;lexicalGlobalObject, scope, createNotEnoughArgumentsError(&amp;lexicalGlobalObject));</span>
  
<span class="line-modified">!     AtomString localName(callFrame.uncheckedArgument(0).toString(&amp;lexicalGlobalObject)-&gt;toAtomString(&amp;lexicalGlobalObject));</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-modified">!     if (!validateCustomElementNameAndThrowIfNeeded(lexicalGlobalObject, localName)) {</span>
          EXCEPTION_ASSERT(scope.exception());
          return jsUndefined();
      }
  
      if (registry.findInterface(localName)) {
<span class="line-modified">!         DeferredPromise::create(globalObject, promise)-&gt;resolve();</span>
<span class="line-modified">!         return &amp;promise;</span>
      }
  
      auto result = registry.promiseMap().ensure(localName, [&amp;] {
<span class="line-modified">!         return DeferredPromise::create(globalObject, promise);</span>
      });
  
      return result.iterator-&gt;value-&gt;promise();
  }
  
<span class="line-modified">! JSValue JSCustomElementRegistry::whenDefined(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)</span>
  {
<span class="line-modified">!     auto scope = DECLARE_CATCH_SCOPE(lexicalGlobalObject.vm());</span>
  
      ASSERT(globalObject());
<span class="line-modified">!     auto* result = JSPromise::create(lexicalGlobalObject.vm(), lexicalGlobalObject.promiseStructure());</span>
<span class="line-modified">!     JSValue promise = whenDefinedPromise(lexicalGlobalObject, callFrame, *globalObject(), wrapped(), *result);</span>
  
      if (UNLIKELY(scope.exception())) {
<span class="line-modified">!         rejectPromiseWithExceptionIfAny(lexicalGlobalObject, *globalObject(), *result);</span>
          scope.assertNoException();
<span class="line-modified">!         return result;</span>
      }
  
      return promise;
  }
  
</pre>
<center><a href="JSCustomElementInterface.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSCustomEventCustom.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
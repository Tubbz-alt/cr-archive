<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentLoader.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.
  3  * Copyright (C) 2011 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;CachedRawResourceClient.h&quot;
 33 #include &quot;CachedResourceHandle.h&quot;
 34 #include &quot;ContentFilterClient.h&quot;
 35 #include &quot;ContentSecurityPolicyClient.h&quot;
 36 #include &quot;DeviceOrientationOrMotionPermissionState.h&quot;
 37 #include &quot;DocumentIdentifier.h&quot;
 38 #include &quot;DocumentWriter.h&quot;
 39 #include &quot;FrameDestructionObserver.h&quot;
 40 #include &quot;LinkIcon.h&quot;
 41 #include &quot;LoadTiming.h&quot;
 42 #include &quot;NavigationAction.h&quot;
 43 #include &quot;ResourceError.h&quot;
 44 #include &quot;ResourceLoaderOptions.h&quot;
 45 #include &quot;ResourceRequest.h&quot;
 46 #include &quot;ResourceResponse.h&quot;
 47 #include &quot;SecurityPolicyViolationEvent.h&quot;
 48 #include &quot;ServiceWorkerRegistrationData.h&quot;
 49 #include &quot;StringWithDirection.h&quot;
 50 #include &quot;StyleSheetContents.h&quot;
 51 #include &quot;SubstituteData.h&quot;
 52 #include &quot;Timer.h&quot;
 53 #include &lt;wtf/HashSet.h&gt;
 54 #include &lt;wtf/OptionSet.h&gt;
 55 #include &lt;wtf/RefPtr.h&gt;
 56 #include &lt;wtf/Vector.h&gt;
 57 
 58 #if ENABLE(APPLICATION_MANIFEST)
 59 #include &quot;ApplicationManifest.h&quot;
 60 #endif
 61 
 62 #if HAVE(RUNLOOP_TIMER)
 63 #include &lt;wtf/RunLoopTimer.h&gt;
 64 #endif
 65 
 66 #if PLATFORM(COCOA)
 67 #include &lt;wtf/SchedulePair.h&gt;
 68 #endif
 69 
 70 namespace WebCore {
 71 
 72 class ApplicationCacheHost;
 73 class ApplicationManifestLoader;
 74 class Archive;
 75 class ArchiveResource;
 76 class ArchiveResourceCollection;
 77 class CachedRawResource;
 78 class CachedResourceLoader;
 79 class ContentFilter;
 80 struct CustomHeaderFields;
 81 class FormState;
 82 class Frame;
 83 class FrameLoader;
 84 class IconLoader;
 85 class Page;
 86 class PreviewConverter;
 87 class ResourceLoader;
 88 class SharedBuffer;
 89 class SWClientConnection;
 90 class SubresourceLoader;
 91 class SubstituteResource;
 92 
 93 enum class ShouldContinue;
 94 
 95 using ResourceLoaderMap = HashMap&lt;unsigned long, RefPtr&lt;ResourceLoader&gt;&gt;;
 96 
 97 enum class AutoplayPolicy : uint8_t {
 98     Default, // Uses policies specified in document settings.
 99     Allow,
100     AllowWithoutSound,
101     Deny,
102 };
103 
104 enum class AutoplayQuirk : uint8_t {
105     SynthesizedPauseEvents = 1 &lt;&lt; 0,
106     InheritedUserGestures = 1 &lt;&lt; 1,
107     ArbitraryUserGestures = 1 &lt;&lt; 2,
108     PerDocumentAutoplayBehavior = 1 &lt;&lt; 3,
109 };
110 
111 enum class PopUpPolicy : uint8_t {
112     Default, // Uses policies specified in frame settings.
113     Allow,
114     Block,
115 };
116 
117 enum class MetaViewportPolicy : uint8_t {
118     Default,
119     Respect,
120     Ignore,
121 };
122 
123 enum class MediaSourcePolicy : uint8_t {
124     Default,
125     Disable,
126     Enable
127 };
128 
129 enum class SimulatedMouseEventsDispatchPolicy : uint8_t {
130     Default,
131     Allow,
132     Deny,
133 };
134 
135 enum class LegacyOverflowScrollingTouchPolicy : uint8_t {
136     Default,
137     Disable,
138     Enable,
139 };
140 
141 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(DocumentLoader);
142 class DocumentLoader
143     : public RefCounted&lt;DocumentLoader&gt;
144     , public FrameDestructionObserver
145     , public ContentSecurityPolicyClient
146 #if ENABLE(CONTENT_FILTERING)
147     , public ContentFilterClient
148 #endif
149     , private CachedRawResourceClient {
150     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(DocumentLoader);
151     friend class ContentFilter;
152 public:
153     static Ref&lt;DocumentLoader&gt; create(const ResourceRequest&amp; request, const SubstituteData&amp; data)
154     {
155         return adoptRef(*new DocumentLoader(request, data));
156     }
157 
158     WEBCORE_EXPORT static DocumentLoader* fromTemporaryDocumentIdentifier(DocumentIdentifier);
159 
160     WEBCORE_EXPORT virtual ~DocumentLoader();
161 
162     void attachToFrame(Frame&amp;);
163 
164     WEBCORE_EXPORT virtual void detachFromFrame();
165 
166     WEBCORE_EXPORT FrameLoader* frameLoader() const;
167     WEBCORE_EXPORT SubresourceLoader* mainResourceLoader() const;
168     WEBCORE_EXPORT RefPtr&lt;SharedBuffer&gt; mainResourceData() const;
169 
170     DocumentWriter&amp; writer() const { return m_writer; }
171 
172     const ResourceRequest&amp; originalRequest() const;
173     const ResourceRequest&amp; originalRequestCopy() const;
174 
175     const ResourceRequest&amp; request() const;
176     ResourceRequest&amp; request();
177 
178     CachedResourceLoader&amp; cachedResourceLoader() { return m_cachedResourceLoader; }
179 
180     const SubstituteData&amp; substituteData() const { return m_substituteData; }
181 
182     const URL&amp; url() const;
183     const URL&amp; unreachableURL() const;
184 
185     const URL&amp; originalURL() const;
186     const URL&amp; responseURL() const;
187     const String&amp; responseMIMEType() const;
188 #if PLATFORM(IOS_FAMILY)
189     // FIXME: This method seems to violate the encapsulation of this class.
190     WEBCORE_EXPORT void setResponseMIMEType(const String&amp;);
191 #endif
192     const String&amp; currentContentType() const;
193     void replaceRequestURLForSameDocumentNavigation(const URL&amp;);
194     bool isStopping() const { return m_isStopping; }
195     void stopLoading();
196     void setCommitted(bool committed) { m_committed = committed; }
197     bool isCommitted() const { return m_committed; }
198     WEBCORE_EXPORT bool isLoading() const;
199 
200     const ResourceError&amp; mainDocumentError() const { return m_mainDocumentError; }
201 
202     const ResourceResponse&amp; response() const { return m_response; }
203 
204     // FIXME: This method seems to violate the encapsulation of this class.
205     void setResponse(const ResourceResponse&amp; response) { m_response = response; }
206 
207     bool isClientRedirect() const { return m_isClientRedirect; }
208     void setIsClientRedirect(bool isClientRedirect) { m_isClientRedirect = isClientRedirect; }
209     void dispatchOnloadEvents();
210     bool wasOnloadDispatched() { return m_wasOnloadDispatched; }
211     WEBCORE_EXPORT bool isLoadingInAPISense() const;
212     WEBCORE_EXPORT void setTitle(const StringWithDirection&amp;);
213     const String&amp; overrideEncoding() const { return m_overrideEncoding; }
214 
215 #if PLATFORM(COCOA)
216     void schedule(SchedulePair&amp;);
217     void unschedule(SchedulePair&amp;);
218 #endif
219 
220 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
221     void setArchive(Ref&lt;Archive&gt;&amp;&amp;);
222     WEBCORE_EXPORT void addAllArchiveResources(Archive&amp;);
223     WEBCORE_EXPORT void addArchiveResource(Ref&lt;ArchiveResource&gt;&amp;&amp;);
224     RefPtr&lt;Archive&gt; popArchiveForSubframe(const String&amp; frameName, const URL&amp;);
225     WEBCORE_EXPORT SharedBuffer* parsedArchiveData() const;
226 
227     WEBCORE_EXPORT bool scheduleArchiveLoad(ResourceLoader&amp;, const ResourceRequest&amp;);
228 #endif
229 
230     void scheduleSubstituteResourceLoad(ResourceLoader&amp;, SubstituteResource&amp;);
231     void scheduleCannotShowURLError(ResourceLoader&amp;);
232 
233     // Return the ArchiveResource for the URL only when loading an Archive
234     WEBCORE_EXPORT ArchiveResource* archiveResourceForURL(const URL&amp;) const;
235 
236     WEBCORE_EXPORT RefPtr&lt;ArchiveResource&gt; mainResource() const;
237 
238     // Return an ArchiveResource for the URL, either creating from live data or
239     // pulling from the ArchiveResourceCollection.
240     WEBCORE_EXPORT RefPtr&lt;ArchiveResource&gt; subresource(const URL&amp;) const;
241 
242     WEBCORE_EXPORT Vector&lt;Ref&lt;ArchiveResource&gt;&gt; subresources() const;
243 
244 #if ASSERT_ENABLED
245     bool isSubstituteLoadPending(ResourceLoader*) const;
246 #endif
247     void cancelPendingSubstituteLoad(ResourceLoader*);
248 
249     void addResponse(const ResourceResponse&amp;);
250     const Vector&lt;ResourceResponse&gt;&amp; responses() const { return m_responses; }
251 
252     const NavigationAction&amp; triggeringAction() const { return m_triggeringAction; }
253     void setTriggeringAction(NavigationAction&amp;&amp;);
254     void setOverrideEncoding(const String&amp; encoding) { m_overrideEncoding = encoding; }
255     void setLastCheckedRequest(ResourceRequest&amp;&amp; request) { m_lastCheckedRequest = WTFMove(request); }
256     const ResourceRequest&amp; lastCheckedRequest()  { return m_lastCheckedRequest; }
257 
258     void stopRecordingResponses();
259     const StringWithDirection&amp; title() const { return m_pageTitle; }
260 
261     WEBCORE_EXPORT URL urlForHistory() const;
262     WEBCORE_EXPORT bool urlForHistoryReflectsFailure() const;
263 
264     // These accessors accommodate WebCore&#39;s somewhat fickle custom of creating history
265     // items for redirects, but only sometimes. For &quot;source&quot; and &quot;destination&quot;,
266     // these accessors return the URL that would have been used if a history
267     // item were created. This allows WebKit to link history items reflecting
268     // redirects into a chain from start to finish.
269     String clientRedirectSourceForHistory() const { return m_clientRedirectSourceForHistory; } // null if no client redirect occurred.
270     String clientRedirectDestinationForHistory() const { return urlForHistory(); }
271     void setClientRedirectSourceForHistory(const String&amp; clientRedirectSourceForHistory) { m_clientRedirectSourceForHistory = clientRedirectSourceForHistory; }
272 
273     String serverRedirectSourceForHistory() const { return (urlForHistory() == url() || url() == WTF::blankURL()) ? String() : urlForHistory().string(); } // null if no server redirect occurred.
274     String serverRedirectDestinationForHistory() const { return url(); }
275 
276     bool didCreateGlobalHistoryEntry() const { return m_didCreateGlobalHistoryEntry; }
277     void setDidCreateGlobalHistoryEntry(bool didCreateGlobalHistoryEntry) { m_didCreateGlobalHistoryEntry = didCreateGlobalHistoryEntry; }
278 
279     void setDefersLoading(bool);
280     void setMainResourceDataBufferingPolicy(DataBufferingPolicy);
281 
282     void startLoadingMainResource();
283     WEBCORE_EXPORT void cancelMainResourceLoad(const ResourceError&amp;);
284     void willContinueMainResourceLoadAfterRedirect(const ResourceRequest&amp;);
285 
286     bool isLoadingMainResource() const { return m_loadingMainResource; }
287     bool isLoadingMultipartContent() const { return m_isLoadingMultipartContent; }
288 
289     void stopLoadingPlugIns();
290     void stopLoadingSubresources();
291     WEBCORE_EXPORT void stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(unsigned long identifier, const ResourceResponse&amp;);
292 
293     bool userContentExtensionsEnabled() const { return m_userContentExtensionsEnabled; }
294     void setUserContentExtensionsEnabled(bool enabled) { m_userContentExtensionsEnabled = enabled; }
295 
296 #if ENABLE(DEVICE_ORIENTATION)
297     DeviceOrientationOrMotionPermissionState deviceOrientationAndMotionAccessState() const { return m_deviceOrientationAndMotionAccessState; }
298     void setDeviceOrientationAndMotionAccessState(DeviceOrientationOrMotionPermissionState state) { m_deviceOrientationAndMotionAccessState = state; }
299 #endif
300 
301     AutoplayPolicy autoplayPolicy() const { return m_autoplayPolicy; }
302     void setAutoplayPolicy(AutoplayPolicy policy) { m_autoplayPolicy = policy; }
303 
304     void setCustomUserAgent(const String&amp; customUserAgent) { m_customUserAgent = customUserAgent; }
305     const String&amp; customUserAgent() const { return m_customUserAgent; }
306 
307     void setCustomUserAgentAsSiteSpecificQuirks(const String&amp; customUserAgent) { m_customUserAgentAsSiteSpecificQuirks = customUserAgent; }
308     const String&amp; customUserAgentAsSiteSpecificQuirks() const { return m_customUserAgentAsSiteSpecificQuirks; }
309 
310     void setCustomNavigatorPlatform(const String&amp; customNavigatorPlatform) { m_customNavigatorPlatform = customNavigatorPlatform; }
311     const String&amp; customNavigatorPlatform() const { return m_customNavigatorPlatform; }
312 
313     OptionSet&lt;AutoplayQuirk&gt; allowedAutoplayQuirks() const { return m_allowedAutoplayQuirks; }
314     void setAllowedAutoplayQuirks(OptionSet&lt;AutoplayQuirk&gt; allowedQuirks) { m_allowedAutoplayQuirks = allowedQuirks; }
315 
316     PopUpPolicy popUpPolicy() const { return m_popUpPolicy; }
317     void setPopUpPolicy(PopUpPolicy popUpPolicy) { m_popUpPolicy = popUpPolicy; }
318 
319     MetaViewportPolicy metaViewportPolicy() const { return m_metaViewportPolicy; }
320     void setMetaViewportPolicy(MetaViewportPolicy policy) { m_metaViewportPolicy = policy; }
321 
322     MediaSourcePolicy mediaSourcePolicy() const { return m_mediaSourcePolicy; }
323     void setMediaSourcePolicy(MediaSourcePolicy policy) { m_mediaSourcePolicy = policy; }
324 
325     SimulatedMouseEventsDispatchPolicy simulatedMouseEventsDispatchPolicy() const { return m_simulatedMouseEventsDispatchPolicy; }
326     void setSimulatedMouseEventsDispatchPolicy(SimulatedMouseEventsDispatchPolicy policy) { m_simulatedMouseEventsDispatchPolicy = policy; }
327 
328     LegacyOverflowScrollingTouchPolicy legacyOverflowScrollingTouchPolicy() const { return m_legacyOverflowScrollingTouchPolicy; }
329     void setLegacyOverflowScrollingTouchPolicy(LegacyOverflowScrollingTouchPolicy policy) { m_legacyOverflowScrollingTouchPolicy = policy; }
330 
331     void addSubresourceLoader(ResourceLoader*);
332     void removeSubresourceLoader(LoadCompletionType, ResourceLoader*);
333     void addPlugInStreamLoader(ResourceLoader&amp;);
334     void removePlugInStreamLoader(ResourceLoader&amp;);
335 
336     void subresourceLoaderFinishedLoadingOnePart(ResourceLoader*);
337 
338     void setDeferMainResourceDataLoad(bool defer) { m_deferMainResourceDataLoad = defer; }
339 
340     void didTellClientAboutLoad(const String&amp; url);
341     bool haveToldClientAboutLoad(const String&amp; url) { return m_resourcesClientKnowsAbout.contains(url); }
342     void recordMemoryCacheLoadForFutureClientNotification(const ResourceRequest&amp;);
343     void takeMemoryCacheLoadsForClientNotification(Vector&lt;ResourceRequest&gt;&amp; loads);
344 
345     LoadTiming&amp; timing() { return m_loadTiming; }
346     void resetTiming() { m_loadTiming = LoadTiming(); }
347 
348     // The WebKit layer calls this function when it&#39;s ready for the data to actually be added to the document.
349     WEBCORE_EXPORT void commitData(const char* bytes, size_t length);
350 
351     ApplicationCacheHost&amp; applicationCacheHost() const;
352     ApplicationCacheHost* applicationCacheHostUnlessBeingDestroyed() const;
353 
354     void checkLoadComplete();
355 
356     // The URL of the document resulting from this DocumentLoader.
357     URL documentURL() const;
358 
359 #if USE(QUICK_LOOK)
360     void setPreviewConverter(RefPtr&lt;PreviewConverter&gt;&amp;&amp;);
361     PreviewConverter* previewConverter() const;
362 #endif
363 
364 #if ENABLE(CONTENT_EXTENSIONS)
365     void addPendingContentExtensionSheet(const String&amp; identifier, StyleSheetContents&amp;);
366     void addPendingContentExtensionDisplayNoneSelector(const String&amp; identifier, const String&amp; selector, uint32_t selectorID);
367 #endif
368 
369     void setShouldOpenExternalURLsPolicy(ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy) { m_shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicy; }
370     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToPropagate() const;
371 
372 #if ENABLE(CONTENT_FILTERING)
373     ContentFilter* contentFilter() const { return m_contentFilter.get(); }
374     void ref() const final { RefCounted&lt;DocumentLoader&gt;::ref(); }
375     void deref() const final { RefCounted&lt;DocumentLoader&gt;::deref(); }
376 #endif
377 
378     bool isAlwaysOnLoggingAllowed() const;
379 
380     void startIconLoading();
381     WEBCORE_EXPORT void didGetLoadDecisionForIcon(bool decision, uint64_t loadIdentifier, uint64_t newCallbackID);
382     void finishedLoadingIcon(IconLoader&amp;, SharedBuffer*);
383 
384     const Vector&lt;LinkIcon&gt;&amp; linkIcons() const { return m_linkIcons; }
385 
386 #if ENABLE(APPLICATION_MANIFEST)
387     WEBCORE_EXPORT uint64_t loadApplicationManifest();
388     void finishedLoadingApplicationManifest(ApplicationManifestLoader&amp;);
389 #endif
390 
391     WEBCORE_EXPORT void setCustomHeaderFields(Vector&lt;CustomHeaderFields&gt;&amp;&amp;);
392     const Vector&lt;CustomHeaderFields&gt;&amp; customHeaderFields() const { return m_customHeaderFields; }
393 
394     void setAllowsWebArchiveForMainFrame(bool allowsWebArchiveForMainFrame) { m_allowsWebArchiveForMainFrame = allowsWebArchiveForMainFrame; }
395     bool allowsWebArchiveForMainFrame() const { return m_allowsWebArchiveForMainFrame; }
396 
397     void setAllowsDataURLsForMainFrame(bool allowsDataURLsForMainFrame) { m_allowsDataURLsForMainFrame = allowsDataURLsForMainFrame; }
398     bool allowsDataURLsForMainFrame() const { return m_allowsDataURLsForMainFrame; }
399 
400     void setDownloadAttribute(const String&amp; attribute) { m_downloadAttribute = attribute; }
401     const String&amp; downloadAttribute() const { return m_downloadAttribute; }
402 
403     WEBCORE_EXPORT void applyPoliciesToSettings();
404 
405     void setAllowContentChangeObserverQuirk(bool allow) { m_allowContentChangeObserverQuirk = allow; }
406     bool allowContentChangeObserverQuirk() const { return m_allowContentChangeObserverQuirk; }
407 
408 #if ENABLE(SERVICE_WORKER)
409     WEBCORE_EXPORT bool setControllingServiceWorkerRegistration(ServiceWorkerRegistrationData&amp;&amp;);
410 #endif
411 
412 protected:
413     WEBCORE_EXPORT DocumentLoader(const ResourceRequest&amp;, const SubstituteData&amp;);
414 
415     WEBCORE_EXPORT virtual void attachToFrame();
416 
417     bool m_deferMainResourceDataLoad { true };
418 
419 private:
420     Document* document() const;
421 
422 #if ENABLE(SERVICE_WORKER)
423     void matchRegistration(const URL&amp;, CompletionHandler&lt;void(Optional&lt;ServiceWorkerRegistrationData&gt;&amp;&amp;)&gt;&amp;&amp;);
424 #endif
425     void unregisterTemporaryServiceWorkerClient();
426 
427     void loadMainResource(ResourceRequest&amp;&amp;);
428 
429     void setRequest(const ResourceRequest&amp;);
430 
431     void commitIfReady();
432     void setMainDocumentError(const ResourceError&amp;);
433     void commitLoad(const char*, int);
434     void clearMainResourceLoader();
435 
436     void setupForReplace();
437     void maybeFinishLoadingMultipartContent();
438 
439     bool maybeCreateArchive();
440 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
441     void clearArchiveResources();
442 #endif
443 
444     void willSendRequest(ResourceRequest&amp;&amp;, const ResourceResponse&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;);
445     void finishedLoading();
446     void mainReceivedError(const ResourceError&amp;);
447     WEBCORE_EXPORT void redirectReceived(CachedResource&amp;, ResourceRequest&amp;&amp;, const ResourceResponse&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;) override;
448     WEBCORE_EXPORT void responseReceived(CachedResource&amp;, const ResourceResponse&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;) override;
449     WEBCORE_EXPORT void dataReceived(CachedResource&amp;, const char* data, int length) override;
450     WEBCORE_EXPORT void notifyFinished(CachedResource&amp;) override;
451 #if USE(QUICK_LOOK)
452     WEBCORE_EXPORT void previewResponseReceived(CachedResource&amp;, const ResourceResponse&amp;) override;
453 #endif
454 
455     void responseReceived(const ResourceResponse&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;);
456 
457 #if ENABLE(CONTENT_FILTERING)
458     // ContentFilterClient
459     WEBCORE_EXPORT void dataReceivedThroughContentFilter(const char*, int) final;
460     WEBCORE_EXPORT ResourceError contentFilterDidBlock(ContentFilterUnblockHandler, String&amp;&amp; unblockRequestDeniedScript) final;
461     WEBCORE_EXPORT void cancelMainResourceLoadForContentFilter(const ResourceError&amp;) final;
462     WEBCORE_EXPORT void handleProvisionalLoadFailureFromContentFilter(const URL&amp; blockedPageURL, SubstituteData&amp;) final;
463 #endif
464 
465     void dataReceived(const char* data, int length);
466 
467     bool maybeLoadEmpty();
468 
469     bool isMultipartReplacingLoad() const;
470     bool isPostOrRedirectAfterPost(const ResourceRequest&amp;, const ResourceResponse&amp;);
471 
472     bool tryLoadingRequestFromApplicationCache();
473     bool tryLoadingSubstituteData();
474     bool tryLoadingRedirectRequestFromApplicationCache(const ResourceRequest&amp;);
475     void continueAfterContentPolicy(PolicyAction);
476 
477     void stopLoadingForPolicyChange();
478     ResourceError interruptedForPolicyChangeError() const;
479 
480 #if HAVE(RUNLOOP_TIMER)
481     typedef RunLoopTimer&lt;DocumentLoader&gt; DocumentLoaderTimer;
482 #else
483     typedef Timer DocumentLoaderTimer;
484 #endif
485     void handleSubstituteDataLoadNow();
486     void startDataLoadTimer();
487 
488     void deliverSubstituteResourcesAfterDelay();
489     void substituteResourceDeliveryTimerFired();
490 
491     void clearMainResource();
492 
493     void cancelPolicyCheckIfNeeded();
494     void becomeMainResourceClient();
495 
496     void notifyFinishedLoadingIcon(uint64_t callbackIdentifier, SharedBuffer*);
497 
498 #if ENABLE(APPLICATION_MANIFEST)
499     void notifyFinishedLoadingApplicationManifest(uint64_t callbackIdentifier, Optional&lt;ApplicationManifest&gt;);
500 #endif
501 
502     // ContentSecurityPolicyClient
503     WEBCORE_EXPORT void addConsoleMessage(MessageSource, MessageLevel, const String&amp;, unsigned long requestIdentifier) final;
504     WEBCORE_EXPORT void sendCSPViolationReport(URL&amp;&amp;, Ref&lt;FormData&gt;&amp;&amp;) final;
505     WEBCORE_EXPORT void enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp;) final;
506 
507     bool disallowWebArchive() const;
508     bool disallowDataRequest() const;
509 
510     Ref&lt;CachedResourceLoader&gt; m_cachedResourceLoader;
511 
512     CachedResourceHandle&lt;CachedRawResource&gt; m_mainResource;
513     ResourceLoaderMap m_subresourceLoaders;
514     ResourceLoaderMap m_multipartSubresourceLoaders;
515     ResourceLoaderMap m_plugInStreamLoaders;
516 
517     mutable DocumentWriter m_writer;
518 
519     // A reference to actual request used to create the data source.
520     // This should only be used by the resourceLoadDelegate&#39;s
521     // identifierForInitialRequest:fromDatasource: method. It is
522     // not guaranteed to remain unchanged, as requests are mutable.
523     ResourceRequest m_originalRequest;
524 
525     SubstituteData m_substituteData;
526 
527     // A copy of the original request used to create the data source.
528     // We have to copy the request because requests are mutable.
529     ResourceRequest m_originalRequestCopy;
530 
531     // The &#39;working&#39; request. It may be mutated
532     // several times from the original request to include additional
533     // headers, cookie information, canonicalization and redirects.
534     ResourceRequest m_request;
535 
536     ResourceResponse m_response;
537 
538     ResourceError m_mainDocumentError;
539 
540     bool m_originalSubstituteDataWasValid;
541     bool m_committed { false };
542     bool m_isStopping { false };
543     bool m_gotFirstByte { false };
544     bool m_isClientRedirect { false };
545     bool m_isLoadingMultipartContent { false };
546 
547     // FIXME: Document::m_processingLoadEvent and DocumentLoader::m_wasOnloadDispatched are roughly the same
548     // and should be merged.
549     bool m_wasOnloadDispatched { false };
550 
551     StringWithDirection m_pageTitle;
552 
553     String m_overrideEncoding;
554 
555     // The action that triggered loading - we keep this around for the
556     // benefit of the various policy handlers.
557     NavigationAction m_triggeringAction;
558 
559     // The last request that we checked click policy for - kept around
560     // so we can avoid asking again needlessly.
561     ResourceRequest m_lastCheckedRequest;
562 
563     // We retain all the received responses so we can play back the
564     // WebResourceLoadDelegate messages if the item is loaded from the
565     // back/forward cache.
566     Vector&lt;ResourceResponse&gt; m_responses;
567     bool m_stopRecordingResponses { false };
568 
569     typedef HashMap&lt;RefPtr&lt;ResourceLoader&gt;, RefPtr&lt;SubstituteResource&gt;&gt; SubstituteResourceMap;
570     SubstituteResourceMap m_pendingSubstituteResources;
571     Timer m_substituteResourceDeliveryTimer;
572 
573     std::unique_ptr&lt;ArchiveResourceCollection&gt; m_archiveResourceCollection;
574 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
575     RefPtr&lt;Archive&gt; m_archive;
576     RefPtr&lt;SharedBuffer&gt; m_parsedArchiveData;
577 #endif
578 
579     HashSet&lt;String&gt; m_resourcesClientKnowsAbout;
580     Vector&lt;ResourceRequest&gt; m_resourcesLoadedFromMemoryCacheForClientNotification;
581 
582     String m_clientRedirectSourceForHistory;
583     bool m_didCreateGlobalHistoryEntry { false };
584 
585     bool m_loadingMainResource { false };
586     LoadTiming m_loadTiming;
587 
588     MonotonicTime m_timeOfLastDataReceived;
589     unsigned long m_identifierForLoadWithoutResourceLoader { 0 };
590 
591     DocumentLoaderTimer m_dataLoadTimer;
592     bool m_waitingForContentPolicy { false };
593     bool m_waitingForNavigationPolicy { false };
594 
595     HashMap&lt;uint64_t, LinkIcon&gt; m_iconsPendingLoadDecision;
596     HashMap&lt;std::unique_ptr&lt;IconLoader&gt;, uint64_t&gt; m_iconLoaders;
597     Vector&lt;LinkIcon&gt; m_linkIcons;
598 
599 #if ENABLE(APPLICATION_MANIFEST)
600     HashMap&lt;std::unique_ptr&lt;ApplicationManifestLoader&gt;, uint64_t&gt; m_applicationManifestLoaders;
601 #endif
602 
603     Vector&lt;CustomHeaderFields&gt; m_customHeaderFields;
604 
605     ShouldOpenExternalURLsPolicy m_shouldOpenExternalURLsPolicy { ShouldOpenExternalURLsPolicy::ShouldNotAllow };
606 
607     std::unique_ptr&lt;ApplicationCacheHost&gt; m_applicationCacheHost;
608 
609 #if ENABLE(CONTENT_FILTERING)
610     std::unique_ptr&lt;ContentFilter&gt; m_contentFilter;
611 #endif
612 
613 #if USE(QUICK_LOOK)
614     RefPtr&lt;PreviewConverter&gt; m_previewConverter;
615 #endif
616 
617 #if ENABLE(CONTENT_EXTENSIONS)
618     HashMap&lt;String, RefPtr&lt;StyleSheetContents&gt;&gt; m_pendingNamedContentExtensionStyleSheets;
619     HashMap&lt;String, Vector&lt;std::pair&lt;String, uint32_t&gt;&gt;&gt; m_pendingContentExtensionDisplayNoneSelectors;
620 #endif
621     String m_customUserAgent;
622     String m_customUserAgentAsSiteSpecificQuirks;
623     bool m_allowContentChangeObserverQuirk { false };
624     String m_customNavigatorPlatform;
625     bool m_userContentExtensionsEnabled { true };
626 #if ENABLE(DEVICE_ORIENTATION)
627     DeviceOrientationOrMotionPermissionState m_deviceOrientationAndMotionAccessState { DeviceOrientationOrMotionPermissionState::Prompt };
628 #endif
629     AutoplayPolicy m_autoplayPolicy { AutoplayPolicy::Default };
630     OptionSet&lt;AutoplayQuirk&gt; m_allowedAutoplayQuirks;
631     PopUpPolicy m_popUpPolicy { PopUpPolicy::Default };
632     MetaViewportPolicy m_metaViewportPolicy { MetaViewportPolicy::Default };
633     MediaSourcePolicy m_mediaSourcePolicy { MediaSourcePolicy::Default };
634     SimulatedMouseEventsDispatchPolicy m_simulatedMouseEventsDispatchPolicy { SimulatedMouseEventsDispatchPolicy::Default };
635     LegacyOverflowScrollingTouchPolicy m_legacyOverflowScrollingTouchPolicy { LegacyOverflowScrollingTouchPolicy::Default };
636 
637 #if ENABLE(SERVICE_WORKER)
638     Optional&lt;ServiceWorkerRegistrationData&gt; m_serviceWorkerRegistrationData;
639     Optional&lt;DocumentIdentifier&gt; m_temporaryServiceWorkerClient;
640 #endif
641 
642 #if ASSERT_ENABLED
643     bool m_hasEverBeenAttached { false };
644 #endif
645 
646     bool m_allowsWebArchiveForMainFrame { false };
647     bool m_allowsDataURLsForMainFrame { false };
648     String m_downloadAttribute;
649 };
650 
651 inline void DocumentLoader::recordMemoryCacheLoadForFutureClientNotification(const ResourceRequest&amp; request)
652 {
653     m_resourcesLoadedFromMemoryCacheForClientNotification.append(request);
654 }
655 
656 inline void DocumentLoader::takeMemoryCacheLoadsForClientNotification(Vector&lt;ResourceRequest&gt;&amp; loadsSet)
657 {
658     loadsSet.swap(m_resourcesLoadedFromMemoryCacheForClientNotification);
659     m_resourcesLoadedFromMemoryCacheForClientNotification.clear();
660 }
661 
662 inline const ResourceRequest&amp; DocumentLoader::originalRequest() const
663 {
664     return m_originalRequest;
665 }
666 
667 inline const ResourceRequest&amp; DocumentLoader::originalRequestCopy() const
668 {
669     return m_originalRequestCopy;
670 }
671 
672 inline const ResourceRequest&amp; DocumentLoader::request() const
673 {
674     return m_request;
675 }
676 
677 inline ResourceRequest&amp; DocumentLoader::request()
678 {
679     return m_request;
680 }
681 
682 inline const URL&amp; DocumentLoader::url() const
683 {
684     return m_request.url();
685 }
686 
687 inline const URL&amp; DocumentLoader::originalURL() const
688 {
689     return m_originalRequestCopy.url();
690 }
691 
692 inline const URL&amp; DocumentLoader::responseURL() const
693 {
694     return m_response.url();
695 }
696 
697 inline const String&amp; DocumentLoader::responseMIMEType() const
698 {
699     return m_response.mimeType();
700 }
701 
702 inline const String&amp; DocumentLoader::currentContentType() const
703 {
704     return m_writer.mimeType();
705 }
706 
707 inline const URL&amp; DocumentLoader::unreachableURL() const
708 {
709     return m_substituteData.failingURL();
710 }
711 
712 inline ApplicationCacheHost&amp; DocumentLoader::applicationCacheHost() const
713 {
714     // For a short time while the document loader is being destroyed, m_applicationCacheHost is null.
715     // It&#39;s not acceptable to call this function during that time.
716     ASSERT(m_applicationCacheHost);
717     return *m_applicationCacheHost;
718 }
719 
720 inline ApplicationCacheHost* DocumentLoader::applicationCacheHostUnlessBeingDestroyed() const
721 {
722     return m_applicationCacheHost.get();
723 }
724 
725 inline void DocumentLoader::didTellClientAboutLoad(const String&amp; url)
726 {
727 #if !PLATFORM(COCOA)
728     // Don&#39;t include data URLs here, as if a lot of data is loaded that way, we hold on to the (large) URL string for too long.
729     if (protocolIs(url, &quot;data&quot;))
730         return;
731 #endif
732     if (!url.isEmpty())
733         m_resourcesClientKnowsAbout.add(url);
734 }
735 
736 }
    </pre>
  </body>
</html>
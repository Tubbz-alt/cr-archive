<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/mathml/MathMLElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2009 Alex Milowski (alex@milowski.com). All rights reserved.
  3  * Copyright (C) 2010 Apple Inc. All rights reserved.
  4  * Copyright (C) 2010 Fran√ßois Sausset (sausset@gmail.com). All rights reserved.
  5  * Copyright (C) 2016 Igalia S.L.
  6  *
  7  * Redistribution and use in source and binary forms, with or without
  8  * modification, are permitted provided that the following conditions
  9  * are met:
 10  * 1. Redistributions of source code must retain the above copyright
 11  *    notice, this list of conditions and the following disclaimer.
 12  * 2. Redistributions in binary form must reproduce the above copyright
 13  *    notice, this list of conditions and the following disclaimer in the
 14  *    documentation and/or other materials provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;MathMLElement.h&quot;
 31 
 32 #if ENABLE(MATHML)
 33 
 34 #include &quot;EventHandler.h&quot;
 35 #include &quot;FrameLoader.h&quot;
 36 #include &quot;HTMLAnchorElement.h&quot;
 37 #include &quot;HTMLElement.h&quot;
 38 #include &quot;HTMLNames.h&quot;
 39 #include &quot;HTMLParserIdioms.h&quot;
 40 #include &quot;MathMLNames.h&quot;
 41 #include &quot;MouseEvent.h&quot;
 42 #include &quot;RenderTableCell.h&quot;
 43 #include &quot;Settings.h&quot;
 44 #include &lt;wtf/IsoMallocInlines.h&gt;
 45 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 46 
 47 namespace WebCore {
 48 
 49 WTF_MAKE_ISO_ALLOCATED_IMPL(MathMLElement);
 50 
 51 using namespace MathMLNames;
 52 
 53 MathMLElement::MathMLElement(const QualifiedName&amp; tagName, Document&amp; document)
 54     : StyledElement(tagName, document, CreateMathMLElement)
 55 {
 56 }
 57 
 58 Ref&lt;MathMLElement&gt; MathMLElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 59 {
 60     return adoptRef(*new MathMLElement(tagName, document));
 61 }
 62 
 63 unsigned MathMLElement::colSpan() const
 64 {
 65     if (!hasTagName(mtdTag))
 66         return 1u;
 67     auto&amp; colSpanValue = attributeWithoutSynchronization(columnspanAttr);
 68     return std::max(1u, limitToOnlyHTMLNonNegative(colSpanValue, 1u));
 69 }
 70 
 71 unsigned MathMLElement::rowSpan() const
 72 {
 73     if (!hasTagName(mtdTag))
 74         return 1u;
 75     auto&amp; rowSpanValue = attributeWithoutSynchronization(rowspanAttr);
 76     static const unsigned maxRowspan = 8190; // This constant comes from HTMLTableCellElement.
 77     return std::max(1u, std::min(limitToOnlyHTMLNonNegative(rowSpanValue, 1u), maxRowspan));
 78 }
 79 
 80 void MathMLElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 81 {
 82     if (name == hrefAttr) {
 83         bool wasLink = isLink();
 84         setIsLink(!value.isNull() &amp;&amp; !shouldProhibitLinks(this));
 85         if (wasLink != isLink())
 86             invalidateStyleForSubtree();
 87     } else if (name == rowspanAttr) {
 88         if (is&lt;RenderTableCell&gt;(renderer()) &amp;&amp; hasTagName(mtdTag))
 89             downcast&lt;RenderTableCell&gt;(*renderer()).colSpanOrRowSpanChanged();
 90     } else if (name == columnspanAttr) {
 91         if (is&lt;RenderTableCell&gt;(renderer()) &amp;&amp; hasTagName(mtdTag))
 92             downcast&lt;RenderTableCell&gt;(renderer())-&gt;colSpanOrRowSpanChanged();
 93     } else if (name == HTMLNames::tabindexAttr) {
 94         if (value.isEmpty())
 95             clearTabIndexExplicitlyIfNeeded();
 96         else if (auto optionalTabIndex = parseHTMLInteger(value))
 97             setTabIndexExplicitly(optionalTabIndex.value());
 98     } else {
 99         auto&amp; eventName = HTMLElement::eventNameForEventHandlerAttribute(name);
100         if (!eventName.isNull()) {
101             setAttributeEventListener(eventName, name, value);
102             return;
103         }
104 
105         StyledElement::parseAttribute(name, value);
106     }
107 }
108 
109 bool MathMLElement::isPresentationAttribute(const QualifiedName&amp; name) const
110 {
111     if (name == backgroundAttr || name == colorAttr || name == dirAttr || name == fontfamilyAttr || name == fontsizeAttr || name == fontstyleAttr || name == fontweightAttr || name == mathbackgroundAttr || name == mathcolorAttr || name == mathsizeAttr)
112         return true;
113     return StyledElement::isPresentationAttribute(name);
114 }
115 
116 static String convertMathSizeIfNeeded(const AtomString&amp; value)
117 {
118     if (value == &quot;small&quot;)
119         return &quot;0.75em&quot;;
120     if (value == &quot;normal&quot;)
121         return &quot;1em&quot;;
122     if (value == &quot;big&quot;)
123         return &quot;1.5em&quot;;
124 
125     // FIXME: mathsize accepts any MathML length, including named spaces (see parseMathMLLength).
126     // FIXME: Might be better to use double than float.
127     // FIXME: Might be better to use &quot;shortest&quot; numeric formatting instead of fixed width.
128     bool ok = false;
129     float unitlessValue = value.toFloat(&amp;ok);
130     if (!ok)
131         return value;
132     return makeString(FormattedNumber::fixedWidth(unitlessValue * 100, 3), &#39;%&#39;);
133 }
134 
135 void MathMLElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
136 {
137     if (name == mathbackgroundAttr)
138         addPropertyToPresentationAttributeStyle(style, CSSPropertyBackgroundColor, value);
139     else if (name == mathsizeAttr)
140         addPropertyToPresentationAttributeStyle(style, CSSPropertyFontSize, convertMathSizeIfNeeded(value));
141     else if (name == mathcolorAttr)
142         addPropertyToPresentationAttributeStyle(style, CSSPropertyColor, value);
143     else if (name == dirAttr) {
144         if (document().settings().coreMathMLEnabled() || hasTagName(mathTag) || hasTagName(mrowTag) || hasTagName(mstyleTag) || isMathMLToken())
145             addPropertyToPresentationAttributeStyle(style, CSSPropertyDirection, value);
146     } else {
147         if (document().settings().coreMathMLEnabled()) {
148             StyledElement::collectStyleForPresentationAttribute(name, value, style);
149             return;
150         }
151         // FIXME: The following are deprecated attributes that should lose if there is a conflict with a non-deprecated attribute.
152         if (name == fontsizeAttr)
153             addPropertyToPresentationAttributeStyle(style, CSSPropertyFontSize, value);
154         else if (name == backgroundAttr)
155             addPropertyToPresentationAttributeStyle(style, CSSPropertyBackgroundColor, value);
156         else if (name == colorAttr)
157             addPropertyToPresentationAttributeStyle(style, CSSPropertyColor, value);
158         else if (name == fontstyleAttr)
159             addPropertyToPresentationAttributeStyle(style, CSSPropertyFontStyle, value);
160         else if (name == fontweightAttr)
161             addPropertyToPresentationAttributeStyle(style, CSSPropertyFontWeight, value);
162         else if (name == fontfamilyAttr)
163             addPropertyToPresentationAttributeStyle(style, CSSPropertyFontFamily, value);
164         else {
165             ASSERT(!isPresentationAttribute(name));
166             StyledElement::collectStyleForPresentationAttribute(name, value, style);
167         }
168     }
169 }
170 
171 bool MathMLElement::childShouldCreateRenderer(const Node&amp; child) const
172 {
173     // In general, only MathML children are allowed. Text nodes are only visible in token MathML elements.
174     return is&lt;MathMLElement&gt;(child);
175 }
176 
177 bool MathMLElement::willRespondToMouseClickEvents()
178 {
179     return isLink() || StyledElement::willRespondToMouseClickEvents();
180 }
181 
182 void MathMLElement::defaultEventHandler(Event&amp; event)
183 {
184     if (isLink()) {
185         if (focused() &amp;&amp; isEnterKeyKeydownEvent(event)) {
186             event.setDefaultHandled();
187             dispatchSimulatedClick(&amp;event);
188             return;
189         }
190         if (MouseEvent::canTriggerActivationBehavior(event)) {
191             auto&amp; href = attributeWithoutSynchronization(hrefAttr);
192             const auto&amp; url = stripLeadingAndTrailingHTMLSpaces(href);
193             event.setDefaultHandled();
194             if (auto* frame = document().frame())
195                 frame-&gt;loader().urlSelected(document().completeURL(url), &quot;_self&quot;, &amp;event, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, document().shouldOpenExternalURLsPolicyToPropagate());
196             return;
197         }
198     }
199 
200     StyledElement::defaultEventHandler(event);
201 }
202 
203 bool MathMLElement::canStartSelection() const
204 {
205     if (!isLink())
206         return StyledElement::canStartSelection();
207 
208     return hasEditableStyle();
209 }
210 
211 bool MathMLElement::isKeyboardFocusable(KeyboardEvent* event) const
212 {
213     if (isFocusable() &amp;&amp; StyledElement::supportsFocus())
214         return StyledElement::isKeyboardFocusable(event);
215 
216     if (isLink())
217         return document().frame()-&gt;eventHandler().tabsToLinks(event);
218 
219     return StyledElement::isKeyboardFocusable(event);
220 }
221 
222 bool MathMLElement::isMouseFocusable() const
223 {
224     // Links are focusable by default, but only allow links with tabindex or contenteditable to be mouse focusable.
225     // https://bugs.webkit.org/show_bug.cgi?id=26856
226     if (isLink())
227         return StyledElement::supportsFocus();
228 
229     return StyledElement::isMouseFocusable();
230 }
231 
232 bool MathMLElement::isURLAttribute(const Attribute&amp; attribute) const
233 {
234     return attribute.name().localName() == hrefAttr || StyledElement::isURLAttribute(attribute);
235 }
236 
237 bool MathMLElement::supportsFocus() const
238 {
239     if (hasEditableStyle())
240         return StyledElement::supportsFocus();
241     // If not a link we should still be able to focus the element if it has tabIndex.
242     return isLink() || StyledElement::supportsFocus();
243 }
244 
245 }
246 
247 #endif // ENABLE(MATHML)
    </pre>
  </body>
</html>
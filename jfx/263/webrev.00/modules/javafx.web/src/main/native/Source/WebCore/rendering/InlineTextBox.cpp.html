<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineTextBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * (C) 1999 Lars Knoll (knoll@kde.org)
   3  * (C) 2000 Dirk Mueller (mueller@kde.org)
   4  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;InlineTextBox.h&quot;
  25 
  26 #include &quot;BreakLines.h&quot;
  27 #include &quot;CompositionHighlight.h&quot;
  28 #include &quot;DashArray.h&quot;
  29 #include &quot;Document.h&quot;
  30 #include &quot;DocumentMarkerController.h&quot;
  31 #include &quot;Editor.h&quot;
  32 #include &quot;ElementRuleCollector.h&quot;
  33 #include &quot;EllipsisBox.h&quot;
  34 #include &quot;EventRegion.h&quot;
  35 #include &quot;FloatRoundedRect.h&quot;
  36 #include &quot;Frame.h&quot;
  37 #include &quot;GraphicsContext.h&quot;
  38 #include &quot;HighlightMap.h&quot;
  39 #include &quot;HitTestResult.h&quot;
  40 #include &quot;ImageBuffer.h&quot;
  41 #include &quot;InlineTextBoxStyle.h&quot;
  42 #include &quot;MarkedText.h&quot;
  43 #include &quot;Page.h&quot;
  44 #include &quot;PaintInfo.h&quot;
  45 #include &quot;RenderBlock.h&quot;
  46 #include &quot;RenderCombineText.h&quot;
  47 #include &quot;RenderLineBreak.h&quot;
  48 #include &quot;RenderRubyRun.h&quot;
  49 #include &quot;RenderRubyText.h&quot;
  50 #include &quot;RenderTheme.h&quot;
  51 #include &quot;RenderView.h&quot;
  52 #include &quot;RenderedDocumentMarker.h&quot;
  53 #include &quot;RuntimeEnabledFeatures.h&quot;
  54 #include &quot;SelectionRangeData.h&quot;
  55 #include &quot;Text.h&quot;
  56 #include &quot;TextDecorationPainter.h&quot;
  57 #include &quot;TextPaintStyle.h&quot;
  58 #include &quot;TextPainter.h&quot;
  59 #include &lt;stdio.h&gt;
  60 #include &lt;wtf/IsoMallocInlines.h&gt;
  61 #include &lt;wtf/text/CString.h&gt;
  62 #include &lt;wtf/text/TextStream.h&gt;
  63 
  64 namespace WebCore {
  65 
  66 WTF_MAKE_ISO_ALLOCATED_IMPL(InlineTextBox);
  67 
  68 struct SameSizeAsInlineTextBox : public InlineBox {
  69     unsigned variables[1];
  70     unsigned short variables2[2];
  71     void* pointers[2];
  72 };
  73 
  74 COMPILE_ASSERT(sizeof(InlineTextBox) == sizeof(SameSizeAsInlineTextBox), InlineTextBox_should_stay_small);
  75 
  76 typedef WTF::HashMap&lt;const InlineTextBox*, LayoutRect&gt; InlineTextBoxOverflowMap;
  77 static InlineTextBoxOverflowMap* gTextBoxesWithOverflow;
  78 
  79 InlineTextBox::~InlineTextBox()
  80 {
  81     if (!knownToHaveNoOverflow() &amp;&amp; gTextBoxesWithOverflow)
  82         gTextBoxesWithOverflow-&gt;remove(this);
  83     TextPainter::removeGlyphDisplayList(*this);
  84 }
  85 
  86 bool InlineTextBox::hasTextContent() const
  87 {
  88     if (m_len &gt; 1)
  89         return true;
  90     if (auto* combinedText = this-&gt;combinedText()) {
  91         ASSERT(m_len == 1);
  92         return !combinedText-&gt;combinedStringForRendering().isEmpty();
  93     }
  94     return m_len;
  95 }
  96 
  97 void InlineTextBox::markDirty(bool dirty)
  98 {
  99     if (dirty) {
 100         m_len = 0;
 101         m_start = 0;
 102     }
 103     InlineBox::markDirty(dirty);
 104 }
 105 
 106 LayoutRect InlineTextBox::logicalOverflowRect() const
 107 {
 108     if (knownToHaveNoOverflow() || !gTextBoxesWithOverflow)
 109         return enclosingIntRect(logicalFrameRect());
 110     return gTextBoxesWithOverflow-&gt;get(this);
 111 }
 112 
 113 void InlineTextBox::setLogicalOverflowRect(const LayoutRect&amp; rect)
 114 {
 115     ASSERT(!knownToHaveNoOverflow());
 116     if (!gTextBoxesWithOverflow)
 117         gTextBoxesWithOverflow = new InlineTextBoxOverflowMap;
 118     gTextBoxesWithOverflow-&gt;add(this, rect);
 119 }
 120 
 121 int InlineTextBox::baselinePosition(FontBaseline baselineType) const
 122 {
 123     if (!parent())
 124         return 0;
 125     if (&amp;parent()-&gt;renderer() == renderer().parent())
 126         return parent()-&gt;baselinePosition(baselineType);
 127     return downcast&lt;RenderBoxModelObject&gt;(*renderer().parent()).baselinePosition(baselineType, isFirstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOnContainingLine);
 128 }
 129 
 130 LayoutUnit InlineTextBox::lineHeight() const
 131 {
 132     if (!renderer().parent())
 133         return 0;
 134     if (&amp;parent()-&gt;renderer() == renderer().parent())
 135         return parent()-&gt;lineHeight();
 136     return downcast&lt;RenderBoxModelObject&gt;(*renderer().parent()).lineHeight(isFirstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOnContainingLine);
 137 }
 138 
 139 LayoutUnit InlineTextBox::selectionTop() const
 140 {
 141     return root().selectionTop();
 142 }
 143 
 144 LayoutUnit InlineTextBox::selectionBottom() const
 145 {
 146     return root().selectionBottom();
 147 }
 148 
 149 LayoutUnit InlineTextBox::selectionHeight() const
 150 {
 151     return root().selectionHeight();
 152 }
 153 
 154 bool InlineTextBox::isSelected(unsigned startPosition, unsigned endPosition) const
 155 {
 156     return clampedOffset(startPosition) &lt; clampedOffset(endPosition);
 157 }
 158 
 159 RenderObject::SelectionState InlineTextBox::selectionState()
 160 {
 161     auto state = verifySelectionState(renderer().selectionState(), renderer().view().selection());
 162 
 163     // FIXME: this code mutates selection state, but it&#39;s used at a simple getter elsewhere
 164     // in this file. This code should likely live in SelectionRangeData, or somewhere else.
 165     // &lt;rdar://problem/58125978&gt;
 166     // https://bugs.webkit.org/show_bug.cgi?id=205528
 167     // If there are ellipsis following, make sure their selection is updated.
 168     if (m_truncation != cNoTruncation &amp;&amp; root().ellipsisBox()) {
 169         EllipsisBox* ellipsis = root().ellipsisBox();
 170         if (state != RenderObject::SelectionNone) {
 171             auto [selectionStart, selectionEnd] = selectionStartEnd();
 172             // The ellipsis should be considered to be selected if the end of
 173             // the selection is past the beginning of the truncation and the
 174             // beginning of the selection is before or at the beginning of the
 175             // truncation.
 176             ellipsis-&gt;setSelectionState(selectionEnd &gt;= m_truncation &amp;&amp; selectionStart &lt;= m_truncation ?
 177                 RenderObject::SelectionInside : RenderObject::SelectionNone);
 178         } else
 179             ellipsis-&gt;setSelectionState(RenderObject::SelectionNone);
 180     }
 181 
 182     return state;
 183 }
 184 
 185 RenderObject::SelectionState InlineTextBox::verifySelectionState(RenderObject::SelectionState state, SelectionRangeData&amp; selection) const
 186 {
 187     if (state == RenderObject::SelectionStart || state == RenderObject::SelectionEnd || state == RenderObject::SelectionBoth) {
 188         auto startOffset = selection.startOffset();
 189         auto endOffset = selection.endOffset();
 190         // The position after a hard line break is considered to be past its end.
 191         ASSERT(start() + len() &gt;= (isLineBreak() ? 1 : 0));
 192         unsigned lastSelectable = start() + len() - (isLineBreak() ? 1 : 0);
 193 
 194         bool start = (state != RenderObject::SelectionEnd &amp;&amp; startOffset &gt;= m_start &amp;&amp; startOffset &lt; m_start + m_len);
 195         bool end = (state != RenderObject::SelectionStart &amp;&amp; endOffset &gt; m_start &amp;&amp; endOffset &lt;= lastSelectable);
 196         if (start &amp;&amp; end)
 197             state = RenderObject::SelectionBoth;
 198         else if (start)
 199             state = RenderObject::SelectionStart;
 200         else if (end)
 201             state = RenderObject::SelectionEnd;
 202         else if ((state == RenderObject::SelectionEnd || startOffset &lt; m_start)
 203             &amp;&amp; (state == RenderObject::SelectionStart || endOffset &gt; lastSelectable))
 204             state = RenderObject::SelectionInside;
 205         else if (state == RenderObject::SelectionBoth)
 206             state = RenderObject::SelectionNone;
 207     }
 208 
 209     return state;
 210 }
 211 
 212 inline const FontCascade&amp; InlineTextBox::lineFont() const
 213 {
 214     return combinedText() ? combinedText()-&gt;textCombineFont() : lineStyle().fontCascade();
 215 }
 216 
 217 LayoutRect snappedSelectionRect(const LayoutRect&amp; selectionRect, float logicalRight, float selectionTop, float selectionHeight, bool isHorizontal)
 218 {
 219     auto snappedSelectionRect = enclosingIntRect(selectionRect);
 220     LayoutUnit logicalWidth = snappedSelectionRect.width();
 221     if (snappedSelectionRect.x() &gt; logicalRight)
 222         logicalWidth = 0;
 223     else if (snappedSelectionRect.maxX() &gt; logicalRight)
 224         logicalWidth = logicalRight - snappedSelectionRect.x();
 225 
 226     LayoutPoint topPoint;
 227     LayoutUnit width;
 228     LayoutUnit height;
 229     if (isHorizontal) {
 230         topPoint = LayoutPoint { snappedSelectionRect.x(), selectionTop };
 231         width = logicalWidth;
 232         height = selectionHeight;
 233     } else {
 234         topPoint = LayoutPoint { selectionTop, snappedSelectionRect.x() };
 235         width = selectionHeight;
 236         height = logicalWidth;
 237     }
 238     return LayoutRect { topPoint, LayoutSize { width, height } };
 239 }
 240 
 241 // FIXME: Share more code with paintMarkedTextBackground().
 242 LayoutRect InlineTextBox::localSelectionRect(unsigned startPos, unsigned endPos) const
 243 {
 244     unsigned sPos = clampedOffset(startPos);
 245     unsigned ePos = clampedOffset(endPos);
 246 
 247     if (sPos &gt;= ePos &amp;&amp; !(startPos == endPos &amp;&amp; startPos &gt;= start() &amp;&amp; startPos &lt;= (start() + len())))
 248         return { };
 249 
 250     LayoutUnit selectionTop = this-&gt;selectionTop();
 251     LayoutUnit selectionHeight = this-&gt;selectionHeight();
 252 
 253     TextRun textRun = createTextRun();
 254 
 255     LayoutRect selectionRect { LayoutUnit(logicalLeft()), selectionTop, LayoutUnit(logicalWidth()), selectionHeight };
 256     // Avoid measuring the text when the entire line box is selected as an optimization.
 257     if (sPos || ePos != textRun.length())
 258         lineFont().adjustSelectionRectForText(textRun, selectionRect, sPos, ePos);
 259     // FIXME: The computation of the snapped selection rect differs from the computation of this rect
 260     // in paintMarkedTextBackground(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=138913&gt;.
 261     return snappedSelectionRect(selectionRect, logicalRight(), selectionTop, selectionHeight, isHorizontal());
 262 }
 263 
 264 void InlineTextBox::deleteLine()
 265 {
 266     renderer().removeTextBox(*this);
 267     delete this;
 268 }
 269 
 270 void InlineTextBox::extractLine()
 271 {
 272     if (extracted())
 273         return;
 274 
 275     renderer().extractTextBox(*this);
 276 }
 277 
 278 void InlineTextBox::attachLine()
 279 {
 280     if (!extracted())
 281         return;
 282 
 283     renderer().attachTextBox(*this);
 284 }
 285 
 286 float InlineTextBox::placeEllipsisBox(bool flowIsLTR, float visibleLeftEdge, float visibleRightEdge, float ellipsisWidth, float &amp;truncatedWidth, bool&amp; foundBox)
 287 {
 288     if (foundBox) {
 289         m_truncation = cFullTruncation;
 290         return -1;
 291     }
 292 
 293     // For LTR this is the left edge of the box, for RTL, the right edge in parent coordinates.
 294     float ellipsisX = flowIsLTR ? visibleRightEdge - ellipsisWidth : visibleLeftEdge + ellipsisWidth;
 295 
 296     // Criteria for full truncation:
 297     // LTR: the left edge of the ellipsis is to the left of our text run.
 298     // RTL: the right edge of the ellipsis is to the right of our text run.
 299     bool ltrFullTruncation = flowIsLTR &amp;&amp; ellipsisX &lt;= left();
 300     bool rtlFullTruncation = !flowIsLTR &amp;&amp; ellipsisX &gt;= left() + logicalWidth();
 301     if (ltrFullTruncation || rtlFullTruncation) {
 302         // Too far.  Just set full truncation, but return -1 and let the ellipsis just be placed at the edge of the box.
 303         m_truncation = cFullTruncation;
 304         foundBox = true;
 305         return -1;
 306     }
 307 
 308     bool ltrEllipsisWithinBox = flowIsLTR &amp;&amp; (ellipsisX &lt; right());
 309     bool rtlEllipsisWithinBox = !flowIsLTR &amp;&amp; (ellipsisX &gt; left());
 310     if (ltrEllipsisWithinBox || rtlEllipsisWithinBox) {
 311         foundBox = true;
 312 
 313         // The inline box may have different directionality than it&#39;s parent.  Since truncation
 314         // behavior depends both on both the parent and the inline block&#39;s directionality, we
 315         // must keep track of these separately.
 316         bool ltr = isLeftToRightDirection();
 317         if (ltr != flowIsLTR) {
 318           // Width in pixels of the visible portion of the box, excluding the ellipsis.
 319           int visibleBoxWidth = visibleRightEdge - visibleLeftEdge  - ellipsisWidth;
 320           ellipsisX = ltr ? left() + visibleBoxWidth : right() - visibleBoxWidth;
 321         }
 322 
 323         int offset = offsetForPosition(ellipsisX, false);
 324         if (offset == 0) {
 325             // No characters should be rendered.  Set ourselves to full truncation and place the ellipsis at the min of our start
 326             // and the ellipsis edge.
 327             m_truncation = cFullTruncation;
 328             truncatedWidth += ellipsisWidth;
 329             return flowIsLTR ? std::min(ellipsisX, x()) : std::max(ellipsisX, right() - ellipsisWidth);
 330         }
 331 
 332         // Set the truncation index on the text run.
 333         m_truncation = offset;
 334 
 335         // If we got here that means that we were only partially truncated and we need to return the pixel offset at which
 336         // to place the ellipsis.
 337         float widthOfVisibleText = renderer().width(m_start, offset, textPos(), isFirstLine());
 338 
 339         // The ellipsis needs to be placed just after the last visible character.
 340         // Where &quot;after&quot; is defined by the flow directionality, not the inline
 341         // box directionality.
 342         // e.g. In the case of an LTR inline box truncated in an RTL flow then we can
 343         // have a situation such as |Hello| -&gt; |...He|
 344         truncatedWidth += widthOfVisibleText + ellipsisWidth;
 345         if (flowIsLTR)
 346             return left() + widthOfVisibleText;
 347         else
 348             return right() - widthOfVisibleText - ellipsisWidth;
 349     }
 350     truncatedWidth += logicalWidth();
 351     return -1;
 352 }
 353 
 354 
 355 
 356 bool InlineTextBox::isLineBreak() const
 357 {
 358     return renderer().style().preserveNewline() &amp;&amp; len() == 1 &amp;&amp; renderer().text()[start()] == &#39;\n&#39;;
 359 }
 360 
 361 bool InlineTextBox::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, LayoutUnit /* lineTop */, LayoutUnit /*lineBottom*/,
 362     HitTestAction /*hitTestAction*/)
 363 {
 364     if (!visibleToHitTesting())
 365         return false;
 366 
 367     if (isLineBreak())
 368         return false;
 369 
 370     if (m_truncation == cFullTruncation)
 371         return false;
 372 
 373     FloatRect rect(locationIncludingFlipping(), size());
 374     // Make sure truncated text is ignored while hittesting.
 375     if (m_truncation != cNoTruncation) {
 376         LayoutUnit widthOfVisibleText { renderer().width(m_start, m_truncation, textPos(), isFirstLine()) };
 377 
 378         if (isHorizontal())
 379             renderer().style().isLeftToRightDirection() ? rect.setWidth(widthOfVisibleText) : rect.shiftXEdgeTo(right() - widthOfVisibleText);
 380         else
 381             rect.setHeight(widthOfVisibleText);
 382     }
 383 
 384     rect.moveBy(accumulatedOffset);
 385 
 386     if (locationInContainer.intersects(rect)) {
 387         renderer().updateHitTestResult(result, flipForWritingMode(locationInContainer.point() - toLayoutSize(accumulatedOffset)));
 388         if (result.addNodeToListBasedTestResult(renderer().textNode(), request, locationInContainer, rect) == HitTestProgress::Stop)
 389             return true;
 390     }
 391     return false;
 392 }
 393 
 394 Optional&lt;bool&gt; InlineTextBox::emphasisMarkExistsAndIsAbove(const RenderStyle&amp; style) const
 395 {
 396     // This function returns true if there are text emphasis marks and they are suppressed by ruby text.
 397     if (style.textEmphasisMark() == TextEmphasisMark::None)
 398         return WTF::nullopt;
 399 
 400     const OptionSet&lt;TextEmphasisPosition&gt; horizontalMask { TextEmphasisPosition::Left, TextEmphasisPosition::Right };
 401 
 402     auto emphasisPosition = style.textEmphasisPosition();
 403     auto emphasisPositionHorizontalValue = emphasisPosition &amp; horizontalMask;
 404     ASSERT(!((emphasisPosition &amp; TextEmphasisPosition::Over) &amp;&amp; (emphasisPosition &amp; TextEmphasisPosition::Under)));
 405     ASSERT(emphasisPositionHorizontalValue != horizontalMask);
 406 
 407     bool isAbove = false;
 408     if (!emphasisPositionHorizontalValue)
 409         isAbove = emphasisPosition.contains(TextEmphasisPosition::Over);
 410     else if (style.isHorizontalWritingMode())
 411         isAbove = emphasisPosition.contains(TextEmphasisPosition::Over);
 412     else
 413         isAbove = emphasisPositionHorizontalValue == TextEmphasisPosition::Right;
 414 
 415     if ((style.isHorizontalWritingMode() &amp;&amp; (emphasisPosition &amp; TextEmphasisPosition::Under))
 416         || (!style.isHorizontalWritingMode() &amp;&amp; (emphasisPosition &amp; TextEmphasisPosition::Left)))
 417         return isAbove; // Ruby text is always over, so it cannot suppress emphasis marks under.
 418 
 419     RenderBlock* containingBlock = renderer().containingBlock();
 420     if (!containingBlock-&gt;isRubyBase())
 421         return isAbove; // This text is not inside a ruby base, so it does not have ruby text over it.
 422 
 423     if (!is&lt;RenderRubyRun&gt;(*containingBlock-&gt;parent()))
 424         return isAbove; // Cannot get the ruby text.
 425 
 426     RenderRubyText* rubyText = downcast&lt;RenderRubyRun&gt;(*containingBlock-&gt;parent()).rubyText();
 427 
 428     // The emphasis marks over are suppressed only if there is a ruby text box and it not empty.
 429     if (rubyText &amp;&amp; rubyText-&gt;hasLines())
 430         return WTF::nullopt;
 431 
 432     return isAbove;
 433 }
 434 
 435 struct InlineTextBox::MarkedTextStyle {
 436     static bool areBackgroundMarkedTextStylesEqual(const MarkedTextStyle&amp; a, const MarkedTextStyle&amp; b)
 437     {
 438         return a.backgroundColor == b.backgroundColor;
 439     }
 440     static bool areForegroundMarkedTextStylesEqual(const MarkedTextStyle&amp; a, const MarkedTextStyle&amp; b)
 441     {
 442         return a.textStyles == b.textStyles &amp;&amp; a.textShadow == b.textShadow &amp;&amp; a.alpha == b.alpha;
 443     }
 444     static bool areDecorationMarkedTextStylesEqual(const MarkedTextStyle&amp; a, const MarkedTextStyle&amp; b)
 445     {
 446         return a.textDecorationStyles == b.textDecorationStyles &amp;&amp; a.textShadow == b.textShadow &amp;&amp; a.alpha == b.alpha;
 447     }
 448 
 449     Color backgroundColor;
 450     TextPaintStyle textStyles;
 451     TextDecorationPainter::Styles textDecorationStyles;
 452     Optional&lt;ShadowData&gt; textShadow;
 453     float alpha;
 454 };
 455 
 456 struct InlineTextBox::StyledMarkedText : MarkedText {
 457     StyledMarkedText(const MarkedText&amp; marker)
 458         : MarkedText { marker }
 459     {
 460     }
 461 
 462     MarkedTextStyle style;
 463 };
 464 
 465 static MarkedText createMarkedTextFromSelectionInBox(const InlineTextBox&amp; box)
 466 {
 467     auto [selectionStart, selectionEnd] = box.selectionStartEnd();
 468     if (selectionStart &lt; selectionEnd)
 469         return { selectionStart, selectionEnd, MarkedText::Selection };
 470     return { };
 471 }
 472 
 473 void InlineTextBox::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, LayoutUnit /*lineTop*/, LayoutUnit /*lineBottom*/)
 474 {
 475     if (isLineBreak() || !paintInfo.shouldPaintWithinRoot(renderer()) || renderer().style().visibility() != Visibility::Visible
 476         || m_truncation == cFullTruncation || paintInfo.phase == PaintPhase::Outline || !hasTextContent())
 477         return;
 478 
 479     ASSERT(paintInfo.phase != PaintPhase::SelfOutline &amp;&amp; paintInfo.phase != PaintPhase::ChildOutlines);
 480 
 481     LayoutUnit logicalLeftSide = logicalLeftVisualOverflow();
 482     LayoutUnit logicalRightSide = logicalRightVisualOverflow();
 483     LayoutUnit logicalStart = logicalLeftSide + (isHorizontal() ? paintOffset.x() : paintOffset.y());
 484     LayoutUnit logicalExtent = logicalRightSide - logicalLeftSide;
 485 
 486     LayoutUnit paintEnd = isHorizontal() ? paintInfo.rect.maxX() : paintInfo.rect.maxY();
 487     LayoutUnit paintStart = isHorizontal() ? paintInfo.rect.x() : paintInfo.rect.y();
 488 
 489     FloatPoint localPaintOffset(paintOffset);
 490 
 491     if (logicalStart &gt;= paintEnd || logicalStart + logicalExtent &lt;= paintStart)
 492         return;
 493 
 494     bool isPrinting = renderer().document().printing();
 495 
 496     // Determine whether or not we&#39;re selected.
 497     bool haveSelection = !isPrinting &amp;&amp; paintInfo.phase != PaintPhase::TextClip &amp;&amp; selectionState() != RenderObject::SelectionNone;
 498     if (!haveSelection &amp;&amp; paintInfo.phase == PaintPhase::Selection) {
 499         // When only painting the selection, don&#39;t bother to paint if there is none.
 500         return;
 501     }
 502 
 503     if (m_truncation != cNoTruncation) {
 504         if (renderer().containingBlock()-&gt;style().isLeftToRightDirection() != isLeftToRightDirection()) {
 505             // Make the visible fragment of text hug the edge closest to the rest of the run by moving the origin
 506             // at which we start drawing text.
 507             // e.g. In the case of LTR text truncated in an RTL Context, the correct behavior is:
 508             // |Hello|CBA| -&gt; |...He|CBA|
 509             // In order to draw the fragment &quot;He&quot; aligned to the right edge of it&#39;s box, we need to start drawing
 510             // farther to the right.
 511             // NOTE: WebKit&#39;s behavior differs from that of IE which appears to just overlay the ellipsis on top of the
 512             // truncated string i.e.  |Hello|CBA| -&gt; |...lo|CBA|
 513             LayoutUnit widthOfVisibleText { renderer().width(m_start, m_truncation, textPos(), isFirstLine()) };
 514             LayoutUnit widthOfHiddenText { logicalWidth() - widthOfVisibleText };
 515             LayoutSize truncationOffset(isLeftToRightDirection() ? widthOfHiddenText : -widthOfHiddenText, 0_lu);
 516             localPaintOffset.move(isHorizontal() ? truncationOffset : truncationOffset.transposedSize());
 517         }
 518     }
 519 
 520     GraphicsContext&amp; context = paintInfo.context();
 521 
 522     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
 523 
 524     localPaintOffset.move(0, lineStyle.isHorizontalWritingMode() ? 0 : -logicalHeight());
 525 
 526     FloatPoint boxOrigin = locationIncludingFlipping();
 527     boxOrigin.moveBy(localPaintOffset);
 528     FloatRect boxRect(boxOrigin, FloatSize(logicalWidth(), logicalHeight()));
 529 
 530     if (paintInfo.phase == PaintPhase::EventRegion) {
 531         if (visibleToHitTesting())
 532             paintInfo.eventRegionContext-&gt;unite(enclosingIntRect(boxRect), renderer().style());
 533         return;
 534     }
 535 
 536     auto* combinedText = this-&gt;combinedText();
 537 
 538     bool shouldRotate = !isHorizontal() &amp;&amp; !combinedText;
 539     if (shouldRotate)
 540         context.concatCTM(rotation(boxRect, Clockwise));
 541 
 542     // Determine whether or not we have composition underlines to draw.
 543     bool containsComposition = renderer().textNode() &amp;&amp; renderer().frame().editor().compositionNode() == renderer().textNode();
 544     bool useCustomUnderlines = containsComposition &amp;&amp; renderer().frame().editor().compositionUsesCustomUnderlines();
 545 
 546     MarkedTextStyle unmarkedStyle = computeStyleForUnmarkedMarkedText(paintInfo);
 547 
 548     // 1. Paint backgrounds behind text if needed. Examples of such backgrounds include selection
 549     // and composition underlines.
 550     if (paintInfo.phase != PaintPhase::Selection &amp;&amp; paintInfo.phase != PaintPhase::TextClip &amp;&amp; !isPrinting) {
 551         if (containsComposition &amp;&amp; !useCustomUnderlines)
 552             paintCompositionBackground(paintInfo, boxOrigin);
 553 
 554         Vector&lt;MarkedText&gt; markedTexts = collectMarkedTextsForDocumentMarkers(TextPaintPhase::Background);
 555         auto highlightMarkedTexts = collectMarkedTextsForHighlights(TextPaintPhase::Background);
 556         if (!highlightMarkedTexts.isEmpty())
 557             markedTexts.appendVector(WTFMove(highlightMarkedTexts));
 558 #if ENABLE(TEXT_SELECTION)
 559         if (haveSelection &amp;&amp; !useCustomUnderlines &amp;&amp; !context.paintingDisabled()) {
 560             auto selectionMarkedText = createMarkedTextFromSelectionInBox(*this);
 561             if (!selectionMarkedText.isEmpty())
 562                 markedTexts.append(WTFMove(selectionMarkedText));
 563         }
 564 #endif
 565         auto styledMarkedTexts = subdivideAndResolveStyle(markedTexts, unmarkedStyle, paintInfo);
 566 
 567         // Coalesce styles of adjacent marked texts to minimize the number of drawing commands.
 568         auto coalescedStyledMarkedTexts = coalesceAdjacentMarkedTexts(styledMarkedTexts, &amp;MarkedTextStyle::areBackgroundMarkedTextStylesEqual);
 569 
 570         paintMarkedTexts(paintInfo, TextPaintPhase::Background, boxRect, coalescedStyledMarkedTexts);
 571     }
 572 
 573     // FIXME: Right now, InlineTextBoxes never call addRelevantUnpaintedObject() even though they might
 574     // legitimately be unpainted if they are waiting on a slow-loading web font. We should fix that, and
 575     // when we do, we will have to account for the fact the InlineTextBoxes do not always have unique
 576     // renderers and Page currently relies on each unpainted object having a unique renderer.
 577     if (paintInfo.phase == PaintPhase::Foreground)
 578         renderer().page().addRelevantRepaintedObject(&amp;renderer(), IntRect(boxOrigin.x(), boxOrigin.y(), logicalWidth(), logicalHeight()));
 579 
 580     if (paintInfo.phase == PaintPhase::Foreground)
 581         paintPlatformDocumentMarkers(context, boxOrigin);
 582 
 583     // 2. Now paint the foreground, including text and decorations like underline/overline (in quirks mode only).
 584     bool shouldPaintSelectionForeground = haveSelection &amp;&amp; !useCustomUnderlines;
 585     Vector&lt;MarkedText&gt; markedTexts;
 586     if (paintInfo.phase != PaintPhase::Selection) {
 587         // The marked texts for the gaps between document markers and selection are implicitly created by subdividing the entire line.
 588         markedTexts.append({ clampedOffset(m_start), clampedOffset(end()), MarkedText::Unmarked });
 589         if (!isPrinting) {
 590             markedTexts.appendVector(collectMarkedTextsForDocumentMarkers(TextPaintPhase::Foreground));
 591             auto highlightMarkedTexts = collectMarkedTextsForHighlights(TextPaintPhase::Foreground);
 592             if (!highlightMarkedTexts.isEmpty())
 593                 markedTexts.appendVector(WTFMove(highlightMarkedTexts));
 594 
 595             bool shouldPaintDraggedContent = !(paintInfo.paintBehavior.contains(PaintBehavior::ExcludeSelection));
 596             if (shouldPaintDraggedContent) {
 597                 auto markedTextsForDraggedContent = collectMarkedTextsForDraggedContent();
 598                 if (!markedTextsForDraggedContent.isEmpty()) {
 599                     shouldPaintSelectionForeground = false;
 600                     markedTexts.appendVector(markedTextsForDraggedContent);
 601                 }
 602             }
 603         }
 604     }
 605     // The selection marked text acts as a placeholder when computing the marked texts for the gaps...
 606     if (shouldPaintSelectionForeground) {
 607         ASSERT(!isPrinting);
 608         auto selectionMarkedText = createMarkedTextFromSelectionInBox(*this);
 609         if (!selectionMarkedText.isEmpty())
 610             markedTexts.append(WTFMove(selectionMarkedText));
 611     }
 612 
 613     auto styledMarkedTexts = subdivideAndResolveStyle(markedTexts, unmarkedStyle, paintInfo);
 614 
 615     // ... now remove the selection marked text if we are excluding selection.
 616     if (!isPrinting &amp;&amp; paintInfo.paintBehavior.contains(PaintBehavior::ExcludeSelection))
 617         styledMarkedTexts.removeAllMatching([] (const StyledMarkedText&amp; markedText) { return markedText.type == MarkedText::Selection; });
 618 
 619     // Coalesce styles of adjacent marked texts to minimize the number of drawing commands.
 620     auto coalescedStyledMarkedTexts = coalesceAdjacentMarkedTexts(styledMarkedTexts, &amp;MarkedTextStyle::areForegroundMarkedTextStylesEqual);
 621 
 622     paintMarkedTexts(paintInfo, TextPaintPhase::Foreground, boxRect, coalescedStyledMarkedTexts);
 623 
 624     // Paint decorations
 625     auto textDecorations = lineStyle.textDecorationsInEffect();
 626     if (!textDecorations.isEmpty() &amp;&amp; paintInfo.phase != PaintPhase::Selection) {
 627         TextRun textRun = createTextRun();
 628         unsigned length = textRun.length();
 629         if (m_truncation != cNoTruncation)
 630             length = m_truncation;
 631         unsigned selectionStart = 0;
 632         unsigned selectionEnd = 0;
 633         if (haveSelection)
 634             std::tie(selectionStart, selectionEnd) = selectionStartEnd();
 635 
 636         FloatRect textDecorationSelectionClipOutRect;
 637         if ((paintInfo.paintBehavior.contains(PaintBehavior::ExcludeSelection)) &amp;&amp; selectionStart &lt; selectionEnd &amp;&amp; selectionEnd &lt;= length) {
 638             textDecorationSelectionClipOutRect = logicalOverflowRect();
 639             textDecorationSelectionClipOutRect.moveBy(localPaintOffset);
 640             float logicalWidthBeforeRange;
 641             float logicalWidthAfterRange;
 642             float logicalSelectionWidth = lineFont().widthOfTextRange(textRun, selectionStart, selectionEnd, nullptr, &amp;logicalWidthBeforeRange, &amp;logicalWidthAfterRange);
 643             // FIXME: Do we need to handle vertical bottom to top text?
 644             if (!isHorizontal()) {
 645                 textDecorationSelectionClipOutRect.move(0, logicalWidthBeforeRange);
 646                 textDecorationSelectionClipOutRect.setHeight(logicalSelectionWidth);
 647             } else if (direction() == TextDirection::RTL) {
 648                 textDecorationSelectionClipOutRect.move(logicalWidthAfterRange, 0);
 649                 textDecorationSelectionClipOutRect.setWidth(logicalSelectionWidth);
 650             } else {
 651                 textDecorationSelectionClipOutRect.move(logicalWidthBeforeRange, 0);
 652                 textDecorationSelectionClipOutRect.setWidth(logicalSelectionWidth);
 653             }
 654         }
 655 
 656         // Coalesce styles of adjacent marked texts to minimize the number of drawing commands.
 657         auto coalescedStyledMarkedTexts = coalesceAdjacentMarkedTexts(styledMarkedTexts, &amp;MarkedTextStyle::areDecorationMarkedTextStylesEqual);
 658 
 659         paintMarkedTexts(paintInfo, TextPaintPhase::Decoration, boxRect, coalescedStyledMarkedTexts, textDecorationSelectionClipOutRect);
 660     }
 661 
 662     // 3. Paint fancy decorations, including composition underlines and platform-specific underlines for spelling errors, grammar errors, et cetera.
 663     if (paintInfo.phase == PaintPhase::Foreground &amp;&amp; useCustomUnderlines)
 664         paintCompositionUnderlines(paintInfo, boxOrigin);
 665 
 666     if (shouldRotate)
 667         context.concatCTM(rotation(boxRect, Counterclockwise));
 668 }
 669 
 670 unsigned InlineTextBox::clampedOffset(unsigned x) const
 671 {
 672     unsigned offset = std::max(std::min(x, m_start + m_len), m_start) - m_start;
 673     if (m_truncation == cFullTruncation)
 674         return offset;
 675     if (m_truncation != cNoTruncation)
 676         offset = std::min&lt;unsigned&gt;(offset, m_truncation);
 677     else if (offset == m_len) {
 678         // Fix up the offset if we are combined text or have a hyphen because we manage these embellishments.
 679         // That is, they are not reflected in renderer().text(). We treat combined text as a single unit.
 680         // We also treat the last codepoint in this box and the hyphen as a single unit.
 681         if (auto* combinedText = this-&gt;combinedText())
 682             offset = combinedText-&gt;combinedStringForRendering().length();
 683         else if (hasHyphen())
 684             offset += lineStyle().hyphenString().length();
 685     }
 686     return offset;
 687 }
 688 
 689 std::pair&lt;unsigned, unsigned&gt; InlineTextBox::clampedStartEndForState(unsigned start, unsigned end, RenderObject::SelectionState selectionState) const
 690 {
 691     if (selectionState == RenderObject::SelectionInside)
 692         return { 0, clampedOffset(m_start + m_len) };
 693 
 694     if (selectionState == RenderObject::SelectionStart)
 695         end = renderer().text().length();
 696     else if (selectionState == RenderObject::SelectionEnd)
 697         start = 0;
 698     return { clampedOffset(start), clampedOffset(end) };
 699 }
 700 
 701 std::pair&lt;unsigned, unsigned&gt; InlineTextBox::selectionStartEnd() const
 702 {
 703     auto selectionState = renderer().selectionState();
 704 
 705     return clampedStartEndForState(renderer().view().selection().startOffset(), renderer().view().selection().endOffset(), selectionState);
 706 }
 707 
 708 std::pair&lt;unsigned, unsigned&gt; InlineTextBox::highlightStartEnd(SelectionRangeData &amp;rangeData) const
 709 {
 710     auto state = rangeData.selectionStateForRenderer(renderer());
 711     state = verifySelectionState(state, rangeData);
 712 
 713     if (state == RenderObject::SelectionNone)
 714         return {0, 0};
 715 
 716     return clampedStartEndForState(rangeData.startOffset(), rangeData.endOffset(), state);
 717 }
 718 
 719 bool InlineTextBox::hasMarkers() const
 720 {
 721     return collectMarkedTextsForDocumentMarkers(TextPaintPhase::Decoration).size();
 722 }
 723 
 724 void InlineTextBox::paintPlatformDocumentMarkers(GraphicsContext&amp; context, const FloatPoint&amp; boxOrigin)
 725 {
 726     // This must match calculateUnionOfAllDocumentMarkerBounds().
 727     for (auto&amp; markedText : subdivide(collectMarkedTextsForDocumentMarkers(TextPaintPhase::Decoration), OverlapStrategy::Frontmost))
 728         paintPlatformDocumentMarker(context, boxOrigin, markedText);
 729 }
 730 
 731 FloatRect InlineTextBox::calculateUnionOfAllDocumentMarkerBounds() const
 732 {
 733     // This must match paintPlatformDocumentMarkers().
 734     FloatRect result;
 735     for (auto&amp; markedText : subdivide(collectMarkedTextsForDocumentMarkers(TextPaintPhase::Decoration), OverlapStrategy::Frontmost))
 736         result = unionRect(result, calculateDocumentMarkerBounds(markedText));
 737     return result;
 738 }
 739 
 740 FloatRect InlineTextBox::calculateDocumentMarkerBounds(const MarkedText&amp; markedText) const
 741 {
 742     auto&amp; font = lineFont();
 743     auto ascent = font.fontMetrics().ascent();
 744     auto fontSize = std::min(std::max(font.size(), 10.0f), 40.0f);
 745     auto y = ascent + 0.11035 * fontSize;
 746     auto height = 0.13247 * fontSize;
 747 
 748     // Avoid measuring the text when the entire line box is selected as an optimization.
 749     if (markedText.startOffset || markedText.endOffset != clampedOffset(end())) {
 750         TextRun run = createTextRun();
 751         LayoutRect selectionRect = LayoutRect(0, y, 0, height);
 752         lineFont().adjustSelectionRectForText(run, selectionRect, markedText.startOffset, markedText.endOffset);
 753         return selectionRect;
 754     }
 755 
 756     return FloatRect(0, y, logicalWidth(), height);
 757 }
 758 
 759 void InlineTextBox::paintPlatformDocumentMarker(GraphicsContext&amp; context, const FloatPoint&amp; boxOrigin, const MarkedText&amp; markedText)
 760 {
 761     // Never print spelling/grammar markers (5327887)
 762     if (renderer().document().printing())
 763         return;
 764 
 765     if (m_truncation == cFullTruncation)
 766         return;
 767 
 768     auto bounds = calculateDocumentMarkerBounds(markedText);
 769 
 770     auto lineStyleForMarkedTextType = [&amp;]() -&gt; DocumentMarkerLineStyle {
 771         bool shouldUseDarkAppearance = renderer().useDarkAppearance();
 772         switch (markedText.type) {
 773         case MarkedText::SpellingError:
 774             return { DocumentMarkerLineStyle::Mode::Spelling, shouldUseDarkAppearance };
 775         case MarkedText::GrammarError:
 776             return { DocumentMarkerLineStyle::Mode::Grammar, shouldUseDarkAppearance };
 777         case MarkedText::Correction:
 778             return { DocumentMarkerLineStyle::Mode::AutocorrectionReplacement, shouldUseDarkAppearance };
 779         case MarkedText::DictationAlternatives:
 780             return { DocumentMarkerLineStyle::Mode::DictationAlternatives, shouldUseDarkAppearance };
 781 #if PLATFORM(IOS_FAMILY)
 782         case MarkedText::DictationPhraseWithAlternatives:
 783             // FIXME: Rename DocumentMarkerLineStyle::TextCheckingDictationPhraseWithAlternatives and remove the PLATFORM(IOS_FAMILY)-guard.
 784             return { DocumentMarkerLineStyle::Mode::TextCheckingDictationPhraseWithAlternatives, shouldUseDarkAppearance };
 785 #endif
 786         default:
 787             ASSERT_NOT_REACHED();
 788             return { DocumentMarkerLineStyle::Mode::Spelling, shouldUseDarkAppearance };
 789         }
 790     };
 791 
 792     bounds.moveBy(boxOrigin);
 793     context.drawDotsForDocumentMarker(bounds, lineStyleForMarkedTextType());
 794 }
 795 
 796 auto InlineTextBox::computeStyleForUnmarkedMarkedText(const PaintInfo&amp; paintInfo) const -&gt; MarkedTextStyle
 797 {
 798     auto&amp; lineStyle = this-&gt;lineStyle();
 799 
 800     MarkedTextStyle style;
 801     style.textDecorationStyles = TextDecorationPainter::stylesForRenderer(renderer(), lineStyle.textDecorationsInEffect(), isFirstLine());
 802     style.textStyles = computeTextPaintStyle(renderer().frame(), lineStyle, paintInfo);
 803     style.textShadow = ShadowData::clone(paintInfo.forceTextColor() ? nullptr : lineStyle.textShadow());
 804     style.alpha = 1;
 805     return style;
 806 }
 807 
 808 auto InlineTextBox::resolveStyleForMarkedText(const MarkedText&amp; markedText, const MarkedTextStyle&amp; baseStyle, const PaintInfo&amp; paintInfo) -&gt; StyledMarkedText
 809 {
 810     MarkedTextStyle style = baseStyle;
 811     switch (markedText.type) {
 812     case MarkedText::Correction:
 813     case MarkedText::DictationAlternatives:
 814 #if PLATFORM(IOS_FAMILY)
 815     // FIXME: See &lt;rdar://problem/8933352&gt;. Also, remove the PLATFORM(IOS_FAMILY)-guard.
 816     case MarkedText::DictationPhraseWithAlternatives:
 817 #endif
 818     case MarkedText::GrammarError:
 819     case MarkedText::SpellingError:
 820     case MarkedText::Unmarked:
 821         break;
 822     case MarkedText::Highlight:
 823         if (auto renderStyle = parent()-&gt;renderer().getUncachedPseudoStyle({ PseudoId::Highlight, markedText.highlightName }, &amp;parent()-&gt;renderer().style())) {
 824             style.backgroundColor = renderStyle-&gt;backgroundColor();
 825             style.textStyles.fillColor = renderStyle-&gt;computedStrokeColor();
 826             style.textStyles.strokeColor = renderStyle-&gt;computedStrokeColor();
 827 
 828             auto color = renderStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyWebkitTextFillColor);
 829             auto decorationStyle = renderStyle-&gt;textDecorationStyle();
 830             auto decorations = renderStyle-&gt;textDecorationsInEffect();
 831 
 832             if (decorations.containsAny({ TextDecoration::Underline, TextDecoration::Overline, TextDecoration::LineThrough })) {
 833                 style.textDecorationStyles.underlineColor = color;
 834                 style.textDecorationStyles.underlineStyle = decorationStyle;
 835             }
 836         }
 837         break;
 838     case MarkedText::DraggedContent:
 839         style.alpha = 0.25;
 840         break;
 841     case MarkedText::Selection: {
 842         style.textStyles = computeTextSelectionPaintStyle(style.textStyles, renderer(), lineStyle(), paintInfo, style.textShadow);
 843 
 844         Color selectionBackgroundColor = renderer().selectionBackgroundColor();
 845         style.backgroundColor = selectionBackgroundColor;
 846         if (selectionBackgroundColor.isValid() &amp;&amp; selectionBackgroundColor.alpha() &amp;&amp; style.textStyles.fillColor == selectionBackgroundColor)
 847             style.backgroundColor = { 0xff - selectionBackgroundColor.red(), 0xff - selectionBackgroundColor.green(), 0xff - selectionBackgroundColor.blue() };
 848         break;
 849     }
 850     case MarkedText::TextMatch: {
 851         // Text matches always use the light system appearance.
 852         OptionSet&lt;StyleColor::Options&gt; styleColorOptions = { StyleColor::Options::UseSystemAppearance };
 853 #if PLATFORM(MAC)
 854         style.textStyles.fillColor = renderer().theme().systemColor(CSSValueAppleSystemLabel, styleColorOptions);
 855 #endif
 856         style.backgroundColor = markedText.marker-&gt;isActiveMatch() ? renderer().theme().activeTextSearchHighlightColor(styleColorOptions) : renderer().theme().inactiveTextSearchHighlightColor(styleColorOptions);
 857         break;
 858     }
 859     }
 860     StyledMarkedText styledMarkedText = markedText;
 861     styledMarkedText.style = WTFMove(style);
 862     return styledMarkedText;
 863 }
 864 
 865 auto InlineTextBox::subdivideAndResolveStyle(const Vector&lt;MarkedText&gt;&amp; textsToSubdivide, const MarkedTextStyle&amp; baseStyle, const PaintInfo&amp; paintInfo) -&gt; Vector&lt;StyledMarkedText&gt;
 866 {
 867     if (textsToSubdivide.isEmpty())
 868         return { };
 869 
 870     auto markedTexts = subdivide(textsToSubdivide);
 871     ASSERT(!markedTexts.isEmpty());
 872     if (UNLIKELY(markedTexts.isEmpty()))
 873         return { };
 874 
 875     // Compute frontmost overlapping styled marked texts.
 876     Vector&lt;StyledMarkedText&gt; frontmostMarkedTexts;
 877     frontmostMarkedTexts.reserveInitialCapacity(markedTexts.size());
 878     frontmostMarkedTexts.uncheckedAppend(resolveStyleForMarkedText(markedTexts[0], baseStyle, paintInfo));
 879     for (auto it = markedTexts.begin() + 1, end = markedTexts.end(); it != end; ++it) {
 880         StyledMarkedText&amp; previousStyledMarkedText = frontmostMarkedTexts.last();
 881         if (previousStyledMarkedText.startOffset == it-&gt;startOffset &amp;&amp; previousStyledMarkedText.endOffset == it-&gt;endOffset) {
 882             // Marked texts completely cover each other.
 883             previousStyledMarkedText = resolveStyleForMarkedText(*it, previousStyledMarkedText.style, paintInfo);
 884             continue;
 885         }
 886         frontmostMarkedTexts.uncheckedAppend(resolveStyleForMarkedText(*it, baseStyle, paintInfo));
 887     }
 888 
 889     return frontmostMarkedTexts;
 890 }
 891 
 892 auto InlineTextBox::coalesceAdjacentMarkedTexts(const Vector&lt;StyledMarkedText&gt;&amp; textsToCoalesce, MarkedTextStylesEqualityFunction areMarkedTextStylesEqual) -&gt; Vector&lt;StyledMarkedText&gt;
 893 {
 894     if (textsToCoalesce.isEmpty())
 895         return { };
 896 
 897     auto areAdjacentMarkedTextsWithSameStyle = [&amp;] (const StyledMarkedText&amp; a, const StyledMarkedText&amp; b) {
 898         return a.endOffset == b.startOffset &amp;&amp; areMarkedTextStylesEqual(a.style, b.style);
 899     };
 900 
 901     Vector&lt;StyledMarkedText&gt; styledMarkedTexts;
 902     styledMarkedTexts.reserveInitialCapacity(textsToCoalesce.size());
 903     styledMarkedTexts.uncheckedAppend(textsToCoalesce[0]);
 904     for (auto it = textsToCoalesce.begin() + 1, end = textsToCoalesce.end(); it != end; ++it) {
 905         StyledMarkedText&amp; previousStyledMarkedText = styledMarkedTexts.last();
 906         if (areAdjacentMarkedTextsWithSameStyle(previousStyledMarkedText, *it)) {
 907             previousStyledMarkedText.endOffset = it-&gt;endOffset;
 908             continue;
 909         }
 910         styledMarkedTexts.uncheckedAppend(*it);
 911     }
 912 
 913     return styledMarkedTexts;
 914 }
 915 
 916 Vector&lt;MarkedText&gt; InlineTextBox::collectMarkedTextsForDraggedContent()
 917 {
 918     using DraggendContentRange = std::pair&lt;unsigned, unsigned&gt;;
 919     auto draggedContentRanges = renderer().draggedContentRangesBetweenOffsets(m_start, m_start + m_len);
 920     Vector&lt;MarkedText&gt; result = draggedContentRanges.map([this] (const DraggendContentRange&amp; range) -&gt; MarkedText {
 921         return { clampedOffset(range.first), clampedOffset(range.second), MarkedText::DraggedContent };
 922     });
 923     return result;
 924 }
 925 
 926 Vector&lt;MarkedText&gt; InlineTextBox::collectMarkedTextsForDocumentMarkers(TextPaintPhase phase) const
 927 {
 928     ASSERT_ARG(phase, phase == TextPaintPhase::Background || phase == TextPaintPhase::Foreground || phase == TextPaintPhase::Decoration);
 929 
 930     if (!renderer().textNode())
 931         return { };
 932 
 933     Vector&lt;RenderedDocumentMarker*&gt; markers = renderer().document().markers().markersFor(*renderer().textNode());
 934 
 935     auto markedTextTypeForMarkerType = [] (DocumentMarker::MarkerType type) {
 936         switch (type) {
 937         case DocumentMarker::Spelling:
 938             return MarkedText::SpellingError;
 939         case DocumentMarker::Grammar:
 940             return MarkedText::GrammarError;
 941         case DocumentMarker::CorrectionIndicator:
 942             return MarkedText::Correction;
 943         case DocumentMarker::TextMatch:
 944             return MarkedText::TextMatch;
 945         case DocumentMarker::DictationAlternatives:
 946             return MarkedText::DictationAlternatives;
 947 #if PLATFORM(IOS_FAMILY)
 948         case DocumentMarker::DictationPhraseWithAlternatives:
 949             return MarkedText::DictationPhraseWithAlternatives;
 950 #endif
 951         default:
 952             return MarkedText::Unmarked;
 953         }
 954     };
 955 
 956     Vector&lt;MarkedText&gt; markedTexts;
 957     markedTexts.reserveInitialCapacity(markers.size());
 958 
 959     // Give any document markers that touch this run a chance to draw before the text has been drawn.
 960     // Note end() points at the last char, not one past it like endOffset and ranges do.
 961     for (auto* marker : markers) {
 962         // Collect either the background markers or the foreground markers, but not both
 963         switch (marker-&gt;type()) {
 964         case DocumentMarker::Grammar:
 965         case DocumentMarker::Spelling:
 966         case DocumentMarker::CorrectionIndicator:
 967         case DocumentMarker::Replacement:
 968         case DocumentMarker::DictationAlternatives:
 969 #if PLATFORM(IOS_FAMILY)
 970         // FIXME: Remove the PLATFORM(IOS_FAMILY)-guard.
 971         case DocumentMarker::DictationPhraseWithAlternatives:
 972 #endif
 973             if (phase != TextPaintPhase::Decoration)
 974                 continue;
 975             break;
 976         case DocumentMarker::TextMatch:
 977             if (!renderer().frame().editor().markedTextMatchesAreHighlighted())
 978                 continue;
 979             if (phase == TextPaintPhase::Decoration)
 980                 continue;
 981             break;
 982 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
 983         case DocumentMarker::TelephoneNumber:
 984             if (!renderer().frame().editor().markedTextMatchesAreHighlighted())
 985                 continue;
 986             if (phase != TextPaintPhase::Background)
 987                 continue;
 988             break;
 989 #endif
 990         default:
 991             continue;
 992         }
 993 
 994         if (marker-&gt;endOffset() &lt;= start()) {
 995             // Marker is completely before this run. This might be a marker that sits before the
 996             // first run we draw, or markers that were within runs we skipped due to truncation.
 997             continue;
 998         }
 999 
1000         if (marker-&gt;startOffset() &gt;= end()) {
1001             // Marker is completely after this run, bail. A later run will paint it.
1002             break;
1003         }
1004 
1005         // Marker intersects this run. Collect it.
1006         switch (marker-&gt;type()) {
1007         case DocumentMarker::Spelling:
1008         case DocumentMarker::CorrectionIndicator:
1009         case DocumentMarker::DictationAlternatives:
1010         case DocumentMarker::Grammar:
1011 #if PLATFORM(IOS_FAMILY)
1012         // FIXME: See &lt;rdar://problem/8933352&gt;. Also, remove the PLATFORM(IOS_FAMILY)-guard.
1013         case DocumentMarker::DictationPhraseWithAlternatives:
1014 #endif
1015         case DocumentMarker::TextMatch:
1016             markedTexts.uncheckedAppend({ clampedOffset(marker-&gt;startOffset()), clampedOffset(marker-&gt;endOffset()), markedTextTypeForMarkerType(marker-&gt;type()), marker });
1017             break;
1018         case DocumentMarker::Replacement:
1019             break;
1020 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
1021         case DocumentMarker::TelephoneNumber:
1022             break;
1023 #endif
1024         default:
1025             ASSERT_NOT_REACHED();
1026         }
1027     }
1028     return markedTexts;
1029 }
1030 
1031 
1032 Vector&lt;MarkedText&gt; InlineTextBox::collectMarkedTextsForHighlights(TextPaintPhase phase) const
1033 {
1034     if (!RuntimeEnabledFeatures::sharedFeatures().highlightAPIEnabled())
1035         return { };
1036     ASSERT_ARG(phase, phase == TextPaintPhase::Background || phase == TextPaintPhase::Foreground || phase == TextPaintPhase::Decoration);
1037     UNUSED_PARAM(phase);
1038     if (!renderer().textNode())
1039         return { };
1040 
1041     Vector&lt;MarkedText&gt; markedTexts;
1042     auto&amp; parentRenderer = parent()-&gt;renderer();
1043     auto&amp; parentStyle = parentRenderer.style();
1044     for (auto&amp; highlight : renderer().document().highlightMap().map()) {
1045         auto renderStyle = parentRenderer.getUncachedPseudoStyle({ PseudoId::Highlight, highlight.key }, &amp;parentStyle);
1046         if (!renderStyle)
1047             continue;
1048         for (auto&amp; rangeData : highlight.value-&gt;rangesData()) {
1049             if (rangeData-&gt;startPosition &amp;&amp; rangeData-&gt;endPosition) {
1050                 Position startPos = rangeData-&gt;startPosition.value();
1051                 Position endPos = rangeData-&gt;endPosition.value();
1052                 RenderObject* startRenderer = startPos.deprecatedNode()-&gt;renderer();
1053                 int startOffset = startPos.deprecatedEditingOffset();
1054                 RenderObject* endRenderer = endPos.deprecatedNode()-&gt;renderer();
1055                 int endOffset = endPos.deprecatedEditingOffset();
1056                 ASSERT(startOffset &gt;= 0 &amp;&amp; endOffset &gt;= 0);
1057                 if (!startRenderer || !endRenderer)
1058                     continue;
1059                 auto highlightData = SelectionRangeData(renderer().view());
1060                 highlightData.setContext({startRenderer, endRenderer, static_cast&lt;unsigned&gt;(startOffset), static_cast&lt;unsigned&gt;(endOffset)});
1061                 auto [highlightStart, highlightEnd] = highlightStartEnd(highlightData);
1062                 if (highlightStart &lt; highlightEnd)
1063                     markedTexts.append({ highlightStart, highlightEnd, MarkedText::Highlight, nullptr, highlight.key });
1064             }
1065         }
1066     }
1067     return markedTexts;
1068 }
1069 
1070 FloatPoint InlineTextBox::textOriginFromBoxRect(const FloatRect&amp; boxRect) const
1071 {
1072     FloatPoint textOrigin { boxRect.x(), boxRect.y() + lineFont().fontMetrics().ascent() };
1073     if (auto* combinedText = this-&gt;combinedText()) {
1074         if (auto newOrigin = combinedText-&gt;computeTextOrigin(boxRect))
1075             textOrigin = newOrigin.value();
1076     }
1077     if (isHorizontal())
1078         textOrigin.setY(roundToDevicePixel(LayoutUnit { textOrigin.y() }, renderer().document().deviceScaleFactor()));
1079     else
1080         textOrigin.setX(roundToDevicePixel(LayoutUnit { textOrigin.x() }, renderer().document().deviceScaleFactor()));
1081     return textOrigin;
1082 }
1083 
1084 void InlineTextBox::paintMarkedTexts(PaintInfo&amp; paintInfo, TextPaintPhase phase, const FloatRect&amp; boxRect, const Vector&lt;StyledMarkedText&gt;&amp; markedTexts, const FloatRect&amp; decorationClipOutRect)
1085 {
1086     switch (phase) {
1087     case TextPaintPhase::Background:
1088         for (auto&amp; markedText : markedTexts)
1089             paintMarkedTextBackground(paintInfo, boxRect.location(), markedText.style.backgroundColor, markedText.startOffset, markedText.endOffset);
1090         return;
1091     case TextPaintPhase::Foreground:
1092         for (auto&amp; markedText : markedTexts)
1093             paintMarkedTextForeground(paintInfo, boxRect, markedText);
1094         return;
1095     case TextPaintPhase::Decoration:
1096         for (auto&amp; markedText : markedTexts)
1097             paintMarkedTextDecoration(paintInfo, boxRect, decorationClipOutRect, markedText);
1098         return;
1099     }
1100 }
1101 
1102 void InlineTextBox::paintMarkedTextBackground(PaintInfo&amp; paintInfo, const FloatPoint&amp; boxOrigin, const Color&amp; color, unsigned clampedStartOffset, unsigned clampedEndOffset)
1103 {
1104     if (clampedStartOffset &gt;= clampedEndOffset)
1105         return;
1106 
1107     GraphicsContext&amp; context = paintInfo.context();
1108     GraphicsContextStateSaver stateSaver { context };
1109     updateGraphicsContext(context, TextPaintStyle { color }); // Don&#39;t draw text at all!
1110 
1111     // Note that if the text is truncated, we let the thing being painted in the truncation
1112     // draw its own highlight.
1113     TextRun textRun = createTextRun();
1114 
1115     const RootInlineBox&amp; rootBox = root();
1116     LayoutUnit selectionBottom = rootBox.selectionBottom();
1117     LayoutUnit selectionTop = rootBox.selectionTopAdjustedForPrecedingBlock();
1118 
1119     // Use same y positioning and height as for selection, so that when the selection and this subrange are on
1120     // the same word there are no pieces sticking out.
1121     LayoutUnit deltaY { renderer().style().isFlippedLinesWritingMode() ? selectionBottom - logicalBottom() : logicalTop() - selectionTop };
1122     LayoutUnit selectionHeight = std::max&lt;LayoutUnit&gt;(0, selectionBottom - selectionTop);
1123 
1124     LayoutRect selectionRect { LayoutUnit(boxOrigin.x()), LayoutUnit(boxOrigin.y() - deltaY), LayoutUnit(logicalWidth()), selectionHeight };
1125     lineFont().adjustSelectionRectForText(textRun, selectionRect, clampedStartOffset, clampedEndOffset);
1126 
1127     // FIXME: Support painting combined text. See &lt;https://bugs.webkit.org/show_bug.cgi?id=180993&gt;.
1128     context.fillRect(snapRectToDevicePixelsWithWritingDirection(selectionRect, renderer().document().deviceScaleFactor(), textRun.ltr()), color);
1129 }
1130 
1131 void InlineTextBox::paintMarkedTextForeground(PaintInfo&amp; paintInfo, const FloatRect&amp; boxRect, const StyledMarkedText&amp; markedText)
1132 {
1133     if (markedText.startOffset &gt;= markedText.endOffset)
1134         return;
1135 
1136     GraphicsContext&amp; context = paintInfo.context();
1137     const FontCascade&amp; font = lineFont();
1138     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
1139 
1140     float emphasisMarkOffset = 0;
1141     Optional&lt;bool&gt; markExistsAndIsAbove = emphasisMarkExistsAndIsAbove(lineStyle);
1142     const AtomString&amp; emphasisMark = markExistsAndIsAbove ? lineStyle.textEmphasisMarkString() : nullAtom();
1143     if (!emphasisMark.isEmpty())
1144         emphasisMarkOffset = *markExistsAndIsAbove ? -font.fontMetrics().ascent() - font.emphasisMarkDescent(emphasisMark) : font.fontMetrics().descent() + font.emphasisMarkAscent(emphasisMark);
1145 
1146     TextPainter textPainter { context };
1147     textPainter.setFont(font);
1148     textPainter.setStyle(markedText.style.textStyles);
1149     textPainter.setIsHorizontal(isHorizontal());
1150     if (markedText.style.textShadow) {
1151         textPainter.setShadow(&amp;markedText.style.textShadow.value());
1152         if (lineStyle.hasAppleColorFilter())
1153             textPainter.setShadowColorFilter(&amp;lineStyle.appleColorFilter());
1154     }
1155     textPainter.setEmphasisMark(emphasisMark, emphasisMarkOffset, combinedText());
1156 
1157     TextRun textRun = createTextRun();
1158     textPainter.setGlyphDisplayListIfNeeded(*this, paintInfo, font, context, textRun);
1159 
1160     GraphicsContextStateSaver stateSaver { context, false };
1161     if (markedText.type == MarkedText::DraggedContent) {
1162         stateSaver.save();
1163         context.setAlpha(markedText.style.alpha);
1164     }
1165     // TextPainter wants the box rectangle and text origin of the entire line box.
1166     textPainter.paintRange(textRun, boxRect, textOriginFromBoxRect(boxRect), markedText.startOffset, markedText.endOffset);
1167 }
1168 
1169 void InlineTextBox::paintMarkedTextDecoration(PaintInfo&amp; paintInfo, const FloatRect&amp; boxRect, const FloatRect&amp; clipOutRect, const StyledMarkedText&amp; markedText)
1170 {
1171     if (m_truncation == cFullTruncation)
1172         return;
1173 
1174     GraphicsContext&amp; context = paintInfo.context();
1175     updateGraphicsContext(context, markedText.style.textStyles);
1176 
1177     bool isCombinedText = combinedText();
1178     if (isCombinedText)
1179         context.concatCTM(rotation(boxRect, Clockwise));
1180 
1181     // 1. Compute text selection
1182     unsigned startOffset = markedText.startOffset;
1183     unsigned endOffset = markedText.endOffset;
1184     if (startOffset &gt;= endOffset)
1185         return;
1186 
1187     // Note that if the text is truncated, we let the thing being painted in the truncation
1188     // draw its own decoration.
1189     TextRun textRun = createTextRun();
1190 
1191     // Avoid measuring the text when the entire line box is selected as an optimization.
1192     FloatRect snappedSelectionRect = boxRect;
1193     if (startOffset || endOffset != textRun.length()) {
1194         LayoutRect selectionRect = { boxRect.x(), boxRect.y(), boxRect.width(), boxRect.height() };
1195         lineFont().adjustSelectionRectForText(textRun, selectionRect, startOffset, endOffset);
1196         snappedSelectionRect = snapRectToDevicePixelsWithWritingDirection(selectionRect, renderer().document().deviceScaleFactor(), textRun.ltr());
1197     }
1198 
1199     // 2. Paint
1200     TextDecorationPainter decorationPainter { context, lineStyle().textDecorationsInEffect(), renderer(), isFirstLine(), lineFont(), markedText.style.textDecorationStyles };
1201     decorationPainter.setInlineTextBox(this);
1202     decorationPainter.setWidth(snappedSelectionRect.width());
1203     decorationPainter.setIsHorizontal(isHorizontal());
1204     if (markedText.style.textShadow) {
1205         decorationPainter.setTextShadow(&amp;markedText.style.textShadow.value());
1206         if (lineStyle().hasAppleColorFilter())
1207             decorationPainter.setShadowColorFilter(&amp;lineStyle().appleColorFilter());
1208     }
1209 
1210     {
1211         GraphicsContextStateSaver stateSaver { context, false };
1212         bool isDraggedContent = markedText.type == MarkedText::DraggedContent;
1213         if (isDraggedContent || !clipOutRect.isEmpty()) {
1214             stateSaver.save();
1215             if (isDraggedContent)
1216                 context.setAlpha(markedText.style.alpha);
1217             if (!clipOutRect.isEmpty())
1218                 context.clipOut(clipOutRect);
1219         }
1220         decorationPainter.paintTextDecoration(textRun.subRun(startOffset, endOffset - startOffset), textOriginFromBoxRect(snappedSelectionRect), snappedSelectionRect.location());
1221     }
1222 
1223     if (isCombinedText)
1224         context.concatCTM(rotation(boxRect, Counterclockwise));
1225 }
1226 
1227 void InlineTextBox::paintCompositionBackground(PaintInfo&amp; paintInfo, const FloatPoint&amp; boxOrigin)
1228 {
1229     if (!renderer().frame().editor().compositionUsesCustomHighlights()) {
1230         paintMarkedTextBackground(paintInfo, boxOrigin, Color::compositionFill, clampedOffset(renderer().frame().editor().compositionStart()), clampedOffset(renderer().frame().editor().compositionEnd()));
1231         return;
1232     }
1233 
1234     for (auto&amp; highlight : renderer().frame().editor().customCompositionHighlights()) {
1235         if (highlight.endOffset &lt;= m_start)
1236             continue;
1237 
1238         if (highlight.startOffset &gt;= end())
1239             break;
1240 
1241         paintMarkedTextBackground(paintInfo, boxOrigin, highlight.color, clampedOffset(highlight.startOffset), clampedOffset(highlight.endOffset));
1242 
1243         if (highlight.endOffset &gt; end())
1244             break;
1245     }
1246 }
1247 
1248 void InlineTextBox::paintCompositionUnderlines(PaintInfo&amp; paintInfo, const FloatPoint&amp; boxOrigin) const
1249 {
1250     if (m_truncation == cFullTruncation)
1251         return;
1252 
1253     for (auto&amp; underline : renderer().frame().editor().customCompositionUnderlines()) {
1254         if (underline.endOffset &lt;= m_start) {
1255             // Underline is completely before this run. This might be an underline that sits
1256             // before the first run we draw, or underlines that were within runs we skipped
1257             // due to truncation.
1258             continue;
1259         }
1260 
1261         if (underline.startOffset &gt;= end())
1262             break; // Underline is completely after this run, bail. A later run will paint it.
1263 
1264         // Underline intersects this run. Paint it.
1265         paintCompositionUnderline(paintInfo, boxOrigin, underline);
1266 
1267         if (underline.endOffset &gt; end())
1268             break; // Underline also runs into the next run. Bail now, no more marker advancement.
1269     }
1270 }
1271 
1272 static inline void mirrorRTLSegment(float logicalWidth, TextDirection direction, float&amp; start, float width)
1273 {
1274     if (direction == TextDirection::LTR)
1275         return;
1276     start = logicalWidth - width - start;
1277 }
1278 
1279 void InlineTextBox::paintCompositionUnderline(PaintInfo&amp; paintInfo, const FloatPoint&amp; boxOrigin, const CompositionUnderline&amp; underline) const
1280 {
1281     if (m_truncation == cFullTruncation)
1282         return;
1283 
1284     float start = 0; // start of line to draw, relative to tx
1285     float width = logicalWidth(); // how much line to draw
1286     bool useWholeWidth = true;
1287     unsigned paintStart = m_start;
1288     unsigned paintEnd = end();
1289     if (paintStart &lt;= underline.startOffset) {
1290         paintStart = underline.startOffset;
1291         useWholeWidth = false;
1292         start = renderer().width(m_start, paintStart - m_start, textPos(), isFirstLine());
1293     }
1294     if (paintEnd != underline.endOffset) {      // end points at the last char, not past it
1295         paintEnd = std::min(paintEnd, (unsigned)underline.endOffset);
1296         useWholeWidth = false;
1297     }
1298     if (m_truncation != cNoTruncation) {
1299         paintEnd = std::min(paintEnd, (unsigned)m_start + m_truncation);
1300         useWholeWidth = false;
1301     }
1302     if (!useWholeWidth) {
1303         width = renderer().width(paintStart, paintEnd - paintStart, textPos() + start, isFirstLine());
1304         mirrorRTLSegment(logicalWidth(), direction(), start, width);
1305     }
1306 
1307     // Thick marked text underlines are 2px thick as long as there is room for the 2px line under the baseline.
1308     // All other marked text underlines are 1px thick.
1309     // If there&#39;s not enough space the underline will touch or overlap characters.
1310     int lineThickness = 1;
1311     int baseline = lineStyle().fontMetrics().ascent();
1312     if (underline.thick &amp;&amp; logicalHeight() - baseline &gt;= 2)
1313         lineThickness = 2;
1314 
1315     // We need to have some space between underlines of subsequent clauses, because some input methods do not use different underline styles for those.
1316     // We make each line shorter, which has a harmless side effect of shortening the first and last clauses, too.
1317     start += 1;
1318     width -= 2;
1319 
1320     GraphicsContext&amp; context = paintInfo.context();
1321     Color underlineColor = underline.compositionUnderlineColor == CompositionUnderlineColor::TextColor ? renderer().style().visitedDependentColorWithColorFilter(CSSPropertyWebkitTextFillColor) : renderer().style().colorByApplyingColorFilter(underline.color);
1322     context.setStrokeColor(underlineColor);
1323     context.setStrokeThickness(lineThickness);
1324     context.drawLineForText(FloatRect(boxOrigin.x() + start, boxOrigin.y() + logicalHeight() - lineThickness, width, lineThickness), renderer().document().printing());
1325 }
1326 
1327 int InlineTextBox::caretMinOffset() const
1328 {
1329     return m_start;
1330 }
1331 
1332 int InlineTextBox::caretMaxOffset() const
1333 {
1334     return m_start + m_len;
1335 }
1336 
1337 float InlineTextBox::textPos() const
1338 {
1339     // When computing the width of a text run, RenderBlock::computeInlineDirectionPositionsForLine() doesn&#39;t include the actual offset
1340     // from the containing block edge in its measurement. textPos() should be consistent so the text are rendered in the same width.
1341     if (logicalLeft() == 0)
1342         return 0;
1343     return logicalLeft() - root().logicalLeft();
1344 }
1345 
1346 int InlineTextBox::offsetForPosition(float lineOffset, bool includePartialGlyphs) const
1347 {
1348     if (isLineBreak())
1349         return 0;
1350     if (lineOffset - logicalLeft() &gt; logicalWidth())
1351         return isLeftToRightDirection() ? len() : 0;
1352     if (lineOffset - logicalLeft() &lt; 0)
1353         return isLeftToRightDirection() ? 0 : len();
1354     bool ignoreCombinedText = true;
1355     bool ignoreHyphen = true;
1356     return lineFont().offsetForPosition(createTextRun(ignoreCombinedText, ignoreHyphen), lineOffset - logicalLeft(), includePartialGlyphs);
1357 }
1358 
1359 float InlineTextBox::positionForOffset(unsigned offset) const
1360 {
1361     ASSERT(offset &gt;= m_start);
1362     ASSERT(offset &lt;= m_start + len());
1363 
1364     if (isLineBreak())
1365         return logicalLeft();
1366 
1367     unsigned startOffset;
1368     unsigned endOffset;
1369     if (isLeftToRightDirection()) {
1370         startOffset = 0;
1371         endOffset = clampedOffset(offset);
1372     } else {
1373         startOffset = clampedOffset(offset);
1374         endOffset = m_len;
1375     }
1376 
1377     // FIXME: Do we need to add rightBearing here?
1378     LayoutRect selectionRect = LayoutRect(logicalLeft(), 0, 0, 0);
1379     bool ignoreCombinedText = true;
1380     bool ignoreHyphen = true;
1381     TextRun textRun = createTextRun(ignoreCombinedText, ignoreHyphen);
1382     lineFont().adjustSelectionRectForText(textRun, selectionRect, startOffset, endOffset);
1383     return snapRectToDevicePixelsWithWritingDirection(selectionRect, renderer().document().deviceScaleFactor(), textRun.ltr()).maxX();
1384 }
1385 
1386 TextRun InlineTextBox::createTextRun(bool ignoreCombinedText, bool ignoreHyphen) const
1387 {
1388     const auto&amp; style = lineStyle();
1389     TextRun textRun { text(ignoreCombinedText, ignoreHyphen), textPos(), expansion(), expansionBehavior(), direction(), dirOverride() || style.rtlOrdering() == Order::Visual, !renderer().canUseSimpleFontCodePath() };
1390     textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
1391     return textRun;
1392 }
1393 
1394 String InlineTextBox::text(bool ignoreCombinedText, bool ignoreHyphen) const
1395 {
1396     if (auto* combinedText = this-&gt;combinedText()) {
1397         if (ignoreCombinedText)
1398             return renderer().text().substring(m_start, m_len);
1399         return combinedText-&gt;combinedStringForRendering();
1400     }
1401     if (hasHyphen()) {
1402         if (ignoreHyphen)
1403             return renderer().text().substring(m_start, m_len);
1404         return makeString(StringView(renderer().text()).substring(m_start, m_len), lineStyle().hyphenString());
1405     }
1406     return renderer().text().substring(m_start, m_len);
1407 }
1408 
1409 inline const RenderCombineText* InlineTextBox::combinedText() const
1410 {
1411     return lineStyle().hasTextCombine() &amp;&amp; is&lt;RenderCombineText&gt;(renderer()) &amp;&amp; downcast&lt;RenderCombineText&gt;(renderer()).isCombined() ? &amp;downcast&lt;RenderCombineText&gt;(renderer()) : nullptr;
1412 }
1413 
1414 ExpansionBehavior InlineTextBox::expansionBehavior() const
1415 {
1416     ExpansionBehavior leadingBehavior;
1417     if (forceLeadingExpansion())
1418         leadingBehavior = ForceLeadingExpansion;
1419     else if (canHaveLeadingExpansion())
1420         leadingBehavior = AllowLeadingExpansion;
1421     else
1422         leadingBehavior = ForbidLeadingExpansion;
1423 
1424     ExpansionBehavior trailingBehavior;
1425     if (forceTrailingExpansion())
1426         trailingBehavior = ForceTrailingExpansion;
1427     else if (expansion() &amp;&amp; nextLeafOnLine() &amp;&amp; !nextLeafOnLine()-&gt;isLineBreak())
1428         trailingBehavior = AllowTrailingExpansion;
1429     else
1430         trailingBehavior = ForbidTrailingExpansion;
1431 
1432     return leadingBehavior | trailingBehavior;
1433 }
1434 
1435 #if ENABLE(TREE_DEBUGGING)
1436 
1437 const char* InlineTextBox::boxName() const
1438 {
1439     return &quot;InlineTextBox&quot;;
1440 }
1441 
1442 void InlineTextBox::outputLineBox(TextStream&amp; stream, bool mark, int depth) const
1443 {
1444     stream &lt;&lt; &quot;-------- &quot; &lt;&lt; (isDirty() ? &quot;D&quot; : &quot;-&quot;) &lt;&lt; &quot;-&quot;;
1445 
1446     int printedCharacters = 0;
1447     if (mark) {
1448         stream &lt;&lt; &quot;*&quot;;
1449         ++printedCharacters;
1450     }
1451     while (++printedCharacters &lt;= depth * 2)
1452         stream &lt;&lt; &quot; &quot;;
1453 
1454     String value = renderer().text();
1455     value = value.substring(start(), len());
1456     value.replaceWithLiteral(&#39;\\&#39;, &quot;\\\\&quot;);
1457     value.replaceWithLiteral(&#39;\n&#39;, &quot;\\n&quot;);
1458     stream &lt;&lt; boxName() &lt;&lt; &quot; &quot; &lt;&lt; FloatRect(x(), y(), width(), height()) &lt;&lt; &quot; (&quot; &lt;&lt; this &lt;&lt; &quot;) renderer-&gt;(&quot; &lt;&lt; &amp;renderer() &lt;&lt; &quot;) run(&quot; &lt;&lt; start() &lt;&lt; &quot;, &quot; &lt;&lt; start() + len() &lt;&lt; &quot;) \&quot;&quot; &lt;&lt; value.utf8().data() &lt;&lt; &quot;\&quot;&quot;;
1459     stream.nextLine();
1460 }
1461 
1462 #endif
1463 
1464 } // namespace WebCore
    </pre>
  </body>
</html>
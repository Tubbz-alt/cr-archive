<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/AXObjectCacheAtk.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../AccessibleSetValueEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityObjectAtk.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/AXObjectCacheAtk.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 46,11 ***</span>
      AtkObject* atkParent = ATK_OBJECT_CLASS(atkObjectClass)-&gt;get_parent(ATK_OBJECT(wrapper));
      // We don&#39;t want to emit any signal from an object outside WebKit&#39;s world.
      return WEBKIT_IS_ACCESSIBLE(atkParent) ? atkParent : nullptr;
  }
  
<span class="line-modified">! void AXObjectCache::detachWrapper(AccessibilityObject* obj, AccessibilityDetachmentType detachmentType)</span>
  {
      auto* wrapper = obj-&gt;wrapper();
      ASSERT(wrapper);
  
      // If an object is being detached NOT because of the AXObjectCache being destroyed,
<span class="line-new-header">--- 46,11 ---</span>
      AtkObject* atkParent = ATK_OBJECT_CLASS(atkObjectClass)-&gt;get_parent(ATK_OBJECT(wrapper));
      // We don&#39;t want to emit any signal from an object outside WebKit&#39;s world.
      return WEBKIT_IS_ACCESSIBLE(atkParent) ? atkParent : nullptr;
  }
  
<span class="line-modified">! void AXObjectCache::detachWrapper(AXCoreObject* obj, AccessibilityDetachmentType detachmentType)</span>
  {
      auto* wrapper = obj-&gt;wrapper();
      ASSERT(wrapper);
  
      // If an object is being detached NOT because of the AXObjectCache being destroyed,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,34 ***</span>
          m_deferredDetachedWrapperList.add(wrapper);
  
      webkitAccessibleDetach(WEBKIT_ACCESSIBLE(wrapper));
  }
  
<span class="line-modified">! void AXObjectCache::attachWrapper(AccessibilityObject* obj)</span>
  {
<span class="line-modified">!     GRefPtr&lt;WebKitAccessible&gt; wrapper = adoptGRef(webkitAccessibleNew(obj));</span>
<span class="line-modified">!     obj-&gt;setWrapper(wrapper.get());</span>
  
      // If an object is being attached and we are not in the middle of a layout update, then
      // we should report ATs by emitting the children-changed::add signal from the parent.
<span class="line-modified">!     Document* document = obj-&gt;document();</span>
      if (!document || document-&gt;childNeedsStyleRecalc())
          return;
  
      // Don&#39;t emit the signal when the actual object being added is not going to be exposed.
<span class="line-modified">!     if (obj-&gt;accessibilityIsIgnoredByDefault())</span>
          return;
  
      // Don&#39;t emit the signal if the object being added is not -- or not yet -- rendered,
      // which can occur in nested iframes. In these instances we don&#39;t want to ignore the
      // child. But if an assistive technology is listening, AT-SPI2 will attempt to create
      // and cache the state set for the child upon emission of the signal. If the object
      // has not yet been rendered, this will result in a crash.
<span class="line-modified">!     if (!obj-&gt;renderer())</span>
          return;
  
<span class="line-modified">!     m_deferredAttachedWrapperObjectList.add(obj);</span>
  }
  
  void AXObjectCache::platformPerformDeferredCacheUpdate()
  {
      for (auto&amp; coreObject : m_deferredAttachedWrapperObjectList) {
<span class="line-new-header">--- 59,39 ---</span>
          m_deferredDetachedWrapperList.add(wrapper);
  
      webkitAccessibleDetach(WEBKIT_ACCESSIBLE(wrapper));
  }
  
<span class="line-modified">! void AXObjectCache::attachWrapper(AXCoreObject* obj)</span>
  {
<span class="line-modified">!     // FIXME: at the moment, only allow to attach AccessibilityObjects.</span>
<span class="line-modified">!     if (!is&lt;AccessibilityObject&gt;(obj))</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     AccessibilityObject* accessibilityObject = downcast&lt;AccessibilityObject&gt;(obj);</span>
<span class="line-added">+ </span>
<span class="line-added">+     GRefPtr&lt;WebKitAccessible&gt; wrapper = adoptGRef(webkitAccessibleNew(accessibilityObject));</span>
<span class="line-added">+     accessibilityObject-&gt;setWrapper(wrapper.get());</span>
  
      // If an object is being attached and we are not in the middle of a layout update, then
      // we should report ATs by emitting the children-changed::add signal from the parent.
<span class="line-modified">!     Document* document = accessibilityObject-&gt;document();</span>
      if (!document || document-&gt;childNeedsStyleRecalc())
          return;
  
      // Don&#39;t emit the signal when the actual object being added is not going to be exposed.
<span class="line-modified">!     if (accessibilityObject-&gt;accessibilityIsIgnoredByDefault())</span>
          return;
  
      // Don&#39;t emit the signal if the object being added is not -- or not yet -- rendered,
      // which can occur in nested iframes. In these instances we don&#39;t want to ignore the
      // child. But if an assistive technology is listening, AT-SPI2 will attempt to create
      // and cache the state set for the child upon emission of the signal. If the object
      // has not yet been rendered, this will result in a crash.
<span class="line-modified">!     if (!accessibilityObject-&gt;renderer())</span>
          return;
  
<span class="line-modified">!     m_deferredAttachedWrapperObjectList.add(accessibilityObject);</span>
  }
  
  void AXObjectCache::platformPerformDeferredCacheUpdate()
  {
      for (auto&amp; coreObject : m_deferredAttachedWrapperObjectList) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,11 ***</span>
          }
      }
      m_deferredDetachedWrapperList.clear();
  }
  
<span class="line-modified">! static AccessibilityObject* getListObject(AccessibilityObject* object)</span>
  {
      // Only list boxes and menu lists supported so far.
      if (!object-&gt;isListBox() &amp;&amp; !object-&gt;isMenuList())
          return 0;
  
<span class="line-new-header">--- 122,11 ---</span>
          }
      }
      m_deferredDetachedWrapperList.clear();
  }
  
<span class="line-modified">! static AXCoreObject* getListObject(AXCoreObject* object)</span>
  {
      // Only list boxes and menu lists supported so far.
      if (!object-&gt;isListBox() &amp;&amp; !object-&gt;isMenuList())
          return 0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,25 ***</span>
      // of items with role MenuListOptionRole.
      const AccessibilityObject::AccessibilityChildrenVector&amp; children = object-&gt;children();
      if (!children.size())
          return 0;
  
<span class="line-modified">!     AccessibilityObject* listObject = children.at(0).get();</span>
      if (!listObject-&gt;isMenuListPopup())
          return 0;
  
      return listObject;
  }
  
<span class="line-modified">! static void notifyChildrenSelectionChange(AccessibilityObject* object)</span>
  {
      // This static variables are needed to keep track of the old
      // focused object and its associated list object, as per previous
      // calls to this function, in order to properly decide whether to
      // emit some signals or not.
<span class="line-modified">!     static NeverDestroyed&lt;RefPtr&lt;AccessibilityObject&gt;&gt; oldListObject;</span>
<span class="line-modified">!     static NeverDestroyed&lt;RefPtr&lt;AccessibilityObject&gt;&gt; oldFocusedObject;</span>
  
      // Only list boxes and menu lists supported so far.
      if (!object || !(object-&gt;isListBox() || object-&gt;isMenuList()))
          return;
  
<span class="line-new-header">--- 139,25 ---</span>
      // of items with role MenuListOptionRole.
      const AccessibilityObject::AccessibilityChildrenVector&amp; children = object-&gt;children();
      if (!children.size())
          return 0;
  
<span class="line-modified">!     AXCoreObject* listObject = children.at(0).get();</span>
      if (!listObject-&gt;isMenuListPopup())
          return 0;
  
      return listObject;
  }
  
<span class="line-modified">! static void notifyChildrenSelectionChange(AXCoreObject* object)</span>
  {
      // This static variables are needed to keep track of the old
      // focused object and its associated list object, as per previous
      // calls to this function, in order to properly decide whether to
      // emit some signals or not.
<span class="line-modified">!     static NeverDestroyed&lt;RefPtr&lt;AXCoreObject&gt;&gt; oldListObject;</span>
<span class="line-modified">!     static NeverDestroyed&lt;RefPtr&lt;AXCoreObject&gt;&gt; oldFocusedObject;</span>
  
      // Only list boxes and menu lists supported so far.
      if (!object || !(object-&gt;isListBox() || object-&gt;isMenuList()))
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,20 ***</span>
  
      // Find the item where the selection change was triggered from.
      HTMLSelectElement&amp; select = downcast&lt;HTMLSelectElement&gt;(*node);
      int changedItemIndex = select.activeSelectionStartListIndex();
  
<span class="line-modified">!     AccessibilityObject* listObject = getListObject(object);</span>
      if (!listObject) {
          oldListObject.get() = nullptr;
          return;
      }
  
      const AccessibilityObject::AccessibilityChildrenVector&amp; items = listObject-&gt;children();
      if (changedItemIndex &lt; 0 || changedItemIndex &gt;= static_cast&lt;int&gt;(items.size()))
          return;
<span class="line-modified">!     AccessibilityObject* item = items.at(changedItemIndex).get();</span>
  
      // Ensure the current list object is the same than the old one so
      // further comparisons make sense. Otherwise, just reset
      // oldFocusedObject so it won&#39;t be taken into account.
      if (oldListObject.get() != listObject)
<span class="line-new-header">--- 171,20 ---</span>
  
      // Find the item where the selection change was triggered from.
      HTMLSelectElement&amp; select = downcast&lt;HTMLSelectElement&gt;(*node);
      int changedItemIndex = select.activeSelectionStartListIndex();
  
<span class="line-modified">!     AXCoreObject* listObject = getListObject(object);</span>
      if (!listObject) {
          oldListObject.get() = nullptr;
          return;
      }
  
      const AccessibilityObject::AccessibilityChildrenVector&amp; items = listObject-&gt;children();
      if (changedItemIndex &lt; 0 || changedItemIndex &gt;= static_cast&lt;int&gt;(items.size()))
          return;
<span class="line-modified">!     AXCoreObject* item = items.at(changedItemIndex).get();</span>
  
      // Ensure the current list object is the same than the old one so
      // further comparisons make sense. Otherwise, just reset
      // oldFocusedObject so it won&#39;t be taken into account.
      if (oldListObject.get() != listObject)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,11 ***</span>
      // Update pointers to the previously involved objects.
      oldListObject.get() = listObject;
      oldFocusedObject.get() = item;
  }
  
<span class="line-modified">! void AXObjectCache::postPlatformNotification(AccessibilityObject* coreObject, AXNotification notification)</span>
  {
      auto* axObject = ATK_OBJECT(coreObject-&gt;wrapper());
      if (!axObject)
          return;
  
<span class="line-new-header">--- 214,11 ---</span>
      // Update pointers to the previously involved objects.
      oldListObject.get() = listObject;
      oldFocusedObject.get() = item;
  }
  
<span class="line-modified">! void AXObjectCache::postPlatformNotification(AXCoreObject* coreObject, AXNotification notification)</span>
  {
      auto* axObject = ATK_OBJECT(coreObject-&gt;wrapper());
      if (!axObject)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 291,11 ***</span>
      case AXRequiredStatusChanged:
          atk_object_notify_state_change(axObject, ATK_STATE_REQUIRED, coreObject-&gt;isRequired());
          break;
  
      case AXActiveDescendantChanged:
<span class="line-modified">!         if (AccessibilityObject* descendant = coreObject-&gt;activeDescendant())</span>
              platformHandleFocusedUIElementChanged(nullptr, descendant-&gt;node());
          break;
  
      default:
          break;
<span class="line-new-header">--- 296,11 ---</span>
      case AXRequiredStatusChanged:
          atk_object_notify_state_change(axObject, ATK_STATE_REQUIRED, coreObject-&gt;isRequired());
          break;
  
      case AXActiveDescendantChanged:
<span class="line-modified">!         if (AXCoreObject* descendant = coreObject-&gt;activeDescendant())</span>
              platformHandleFocusedUIElementChanged(nullptr, descendant-&gt;node());
          break;
  
      default:
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,11 ***</span>
  void AXObjectCache::nodeTextChangePlatformNotification(AccessibilityObject* object, AXTextChange textChange, unsigned offset, const String&amp; text)
  {
      if (!object || text.isEmpty())
          return;
  
<span class="line-modified">!     AccessibilityObject* parentObject = object-&gt;isNonNativeTextControl() ? object : object-&gt;parentObjectUnignored();</span>
      if (!parentObject)
          return;
  
      auto* wrapper = parentObject-&gt;wrapper();
      if (!wrapper || !ATK_IS_TEXT(wrapper))
<span class="line-new-header">--- 310,11 ---</span>
  void AXObjectCache::nodeTextChangePlatformNotification(AccessibilityObject* object, AXTextChange textChange, unsigned offset, const String&amp; text)
  {
      if (!object || text.isEmpty())
          return;
  
<span class="line-modified">!     AXCoreObject* parentObject = object-&gt;isNonNativeTextControl() ? object : object-&gt;parentObjectUnignored();</span>
      if (!parentObject)
          return;
  
      auto* wrapper = parentObject-&gt;wrapper();
      if (!wrapper || !ATK_IS_TEXT(wrapper))
</pre>
<center><a href="../AccessibleSetValueEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityObjectAtk.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
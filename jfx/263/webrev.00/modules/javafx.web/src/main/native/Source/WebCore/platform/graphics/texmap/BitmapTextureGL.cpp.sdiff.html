<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/BitmapTextureGL.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BitmapTexture.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BitmapTextureGL.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/BitmapTextureGL.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  modify it under the terms of the GNU Library General Public
  8  License as published by the Free Software Foundation; either
  9  version 2 of the License, or (at your option) any later version.
 10 
 11  This library is distributed in the hope that it will be useful,
 12  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  Library General Public License for more details.
 15 
 16  You should have received a copy of the GNU Library General Public License
 17  along with this library; see the file COPYING.LIB.  If not, write to
 18  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;BitmapTextureGL.h&quot;
 24 
 25 #if USE(TEXTURE_MAPPER_GL)
 26 
<span class="line-modified"> 27 #include &quot;Extensions3D.h&quot;</span>
 28 #include &quot;FilterOperations.h&quot;
<span class="line-removed"> 29 #include &quot;Image.h&quot;</span>
 30 #include &quot;LengthFunctions.h&quot;
 31 #include &quot;NativeImage.h&quot;
 32 #include &quot;NotImplemented.h&quot;
 33 #include &quot;TextureMapperShaderProgram.h&quot;
 34 #include &quot;Timer.h&quot;
 35 #include &lt;wtf/HashMap.h&gt;
 36 #include &lt;wtf/RefCounted.h&gt;
 37 #include &lt;wtf/RefPtr.h&gt;
 38 
 39 #if USE(CAIRO)
 40 #include &quot;CairoUtilities.h&quot;
 41 #include &quot;RefPtrCairo.h&quot;
 42 #include &lt;cairo.h&gt;
 43 #include &lt;wtf/text/CString.h&gt;
 44 #endif
 45 
 46 #if USE(DIRECT2D)
 47 #include &lt;d2d1.h&gt;
 48 #include &lt;wincodec.h&gt;
 49 #endif
 50 
 51 #if OS(DARWIN)
 52 #define GL_UNSIGNED_INT_8_8_8_8_REV 0x8367
 53 #endif
 54 
 55 namespace WebCore {
 56 
 57 BitmapTextureGL* toBitmapTextureGL(BitmapTexture* texture)
 58 {
 59     if (!texture || !texture-&gt;isBackedByOpenGL())
 60         return 0;
 61 
 62     return static_cast&lt;BitmapTextureGL*&gt;(texture);
 63 }
 64 
 65 BitmapTextureGL::BitmapTextureGL(const TextureMapperContextAttributes&amp; contextAttributes, const Flags, GLint internalFormat)
 66     : m_contextAttributes(contextAttributes)

 67 {
 68     if (internalFormat != GL_DONT_CARE) {
<span class="line-modified"> 69         m_internalFormat = m_format = internalFormat;</span>
 70         return;
 71     }
 72 
<span class="line-modified"> 73     m_internalFormat = m_format = GL_RGBA;</span>
 74 }
 75 
 76 void BitmapTextureGL::didReset()
 77 {
 78     if (!m_id)
 79         glGenTextures(1, &amp;m_id);
 80 
 81     m_shouldClear = true;
 82     m_colorConvertFlags = TextureMapperGL::NoFlag;
 83     if (m_textureSize == contentSize())
 84         return;
 85 
 86     m_textureSize = contentSize();
 87     glBindTexture(GL_TEXTURE_2D, m_id);
 88     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
 89     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 90     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 91     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 92 
 93     glTexImage2D(GL_TEXTURE_2D, 0, m_internalFormat, m_textureSize.width(), m_textureSize.height(), 0, m_format, m_type, 0);
</pre>
<hr />
<pre>
152     if (!image)
153         return;
154     NativeImagePtr frameImage = image-&gt;nativeImageForCurrentFrame();
155     if (!frameImage)
156         return;
157 
158     int bytesPerLine;
159     const char* imageData;
160 
161 #if USE(CAIRO)
162     cairo_surface_t* surface = frameImage.get();
163     imageData = reinterpret_cast&lt;const char*&gt;(cairo_image_surface_get_data(surface));
164     bytesPerLine = cairo_image_surface_get_stride(surface);
165 #elif USE(DIRECT2D)
166     notImplemented();
167 #endif
168 
169     updateContents(imageData, targetRect, offset, bytesPerLine);
170 }
171 



















172 static unsigned getPassesRequiredForFilter(FilterOperation::OperationType type)
173 {
174     switch (type) {
175     case FilterOperation::GRAYSCALE:
176     case FilterOperation::SEPIA:
177     case FilterOperation::SATURATE:
178     case FilterOperation::HUE_ROTATE:
179     case FilterOperation::INVERT:
180     case FilterOperation::BRIGHTNESS:
181     case FilterOperation::CONTRAST:
182     case FilterOperation::OPACITY:
183         return 1;
184     case FilterOperation::BLUR:
185     case FilterOperation::DROP_SHADOW:
186         // We use two-passes (vertical+horizontal) for blur and drop-shadow.
187         return 2;
188     default:
189         return 0;
190     }
191 }
</pre>
</td>
<td>
<hr />
<pre>
  7  modify it under the terms of the GNU Library General Public
  8  License as published by the Free Software Foundation; either
  9  version 2 of the License, or (at your option) any later version.
 10 
 11  This library is distributed in the hope that it will be useful,
 12  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  Library General Public License for more details.
 15 
 16  You should have received a copy of the GNU Library General Public License
 17  along with this library; see the file COPYING.LIB.  If not, write to
 18  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;BitmapTextureGL.h&quot;
 24 
 25 #if USE(TEXTURE_MAPPER_GL)
 26 
<span class="line-modified"> 27 #include &quot;ExtensionsGL.h&quot;</span>
 28 #include &quot;FilterOperations.h&quot;

 29 #include &quot;LengthFunctions.h&quot;
 30 #include &quot;NativeImage.h&quot;
 31 #include &quot;NotImplemented.h&quot;
 32 #include &quot;TextureMapperShaderProgram.h&quot;
 33 #include &quot;Timer.h&quot;
 34 #include &lt;wtf/HashMap.h&gt;
 35 #include &lt;wtf/RefCounted.h&gt;
 36 #include &lt;wtf/RefPtr.h&gt;
 37 
 38 #if USE(CAIRO)
 39 #include &quot;CairoUtilities.h&quot;
 40 #include &quot;RefPtrCairo.h&quot;
 41 #include &lt;cairo.h&gt;
 42 #include &lt;wtf/text/CString.h&gt;
 43 #endif
 44 
 45 #if USE(DIRECT2D)
 46 #include &lt;d2d1.h&gt;
 47 #include &lt;wincodec.h&gt;
 48 #endif
 49 
 50 #if OS(DARWIN)
 51 #define GL_UNSIGNED_INT_8_8_8_8_REV 0x8367
 52 #endif
 53 
 54 namespace WebCore {
 55 
 56 BitmapTextureGL* toBitmapTextureGL(BitmapTexture* texture)
 57 {
 58     if (!texture || !texture-&gt;isBackedByOpenGL())
 59         return 0;
 60 
 61     return static_cast&lt;BitmapTextureGL*&gt;(texture);
 62 }
 63 
 64 BitmapTextureGL::BitmapTextureGL(const TextureMapperContextAttributes&amp; contextAttributes, const Flags, GLint internalFormat)
 65     : m_contextAttributes(contextAttributes)
<span class="line-added"> 66     , m_format(GL_RGBA)</span>
 67 {
 68     if (internalFormat != GL_DONT_CARE) {
<span class="line-modified"> 69         m_internalFormat = internalFormat;</span>
 70         return;
 71     }
 72 
<span class="line-modified"> 73     m_internalFormat = GL_RGBA;</span>
 74 }
 75 
 76 void BitmapTextureGL::didReset()
 77 {
 78     if (!m_id)
 79         glGenTextures(1, &amp;m_id);
 80 
 81     m_shouldClear = true;
 82     m_colorConvertFlags = TextureMapperGL::NoFlag;
 83     if (m_textureSize == contentSize())
 84         return;
 85 
 86     m_textureSize = contentSize();
 87     glBindTexture(GL_TEXTURE_2D, m_id);
 88     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
 89     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 90     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 91     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 92 
 93     glTexImage2D(GL_TEXTURE_2D, 0, m_internalFormat, m_textureSize.width(), m_textureSize.height(), 0, m_format, m_type, 0);
</pre>
<hr />
<pre>
152     if (!image)
153         return;
154     NativeImagePtr frameImage = image-&gt;nativeImageForCurrentFrame();
155     if (!frameImage)
156         return;
157 
158     int bytesPerLine;
159     const char* imageData;
160 
161 #if USE(CAIRO)
162     cairo_surface_t* surface = frameImage.get();
163     imageData = reinterpret_cast&lt;const char*&gt;(cairo_image_surface_get_data(surface));
164     bytesPerLine = cairo_image_surface_get_stride(surface);
165 #elif USE(DIRECT2D)
166     notImplemented();
167 #endif
168 
169     updateContents(imageData, targetRect, offset, bytesPerLine);
170 }
171 
<span class="line-added">172 #if USE(ANGLE)</span>
<span class="line-added">173 void BitmapTextureGL::setPendingContents(RefPtr&lt;Image&gt;&amp;&amp; image)</span>
<span class="line-added">174 {</span>
<span class="line-added">175     m_pendingContents = image;</span>
<span class="line-added">176 }</span>
<span class="line-added">177 </span>
<span class="line-added">178 void BitmapTextureGL::updatePendingContents(const IntRect&amp; targetRect, const IntPoint&amp; offset)</span>
<span class="line-added">179 {</span>
<span class="line-added">180     if (!m_pendingContents)</span>
<span class="line-added">181         return;</span>
<span class="line-added">182 </span>
<span class="line-added">183     if (!isValid()) {</span>
<span class="line-added">184         IntSize textureSize(m_pendingContents-&gt;size());</span>
<span class="line-added">185         reset(textureSize);</span>
<span class="line-added">186     }</span>
<span class="line-added">187     updateContents(m_pendingContents.get(), targetRect, offset);</span>
<span class="line-added">188 }</span>
<span class="line-added">189 #endif</span>
<span class="line-added">190 </span>
191 static unsigned getPassesRequiredForFilter(FilterOperation::OperationType type)
192 {
193     switch (type) {
194     case FilterOperation::GRAYSCALE:
195     case FilterOperation::SEPIA:
196     case FilterOperation::SATURATE:
197     case FilterOperation::HUE_ROTATE:
198     case FilterOperation::INVERT:
199     case FilterOperation::BRIGHTNESS:
200     case FilterOperation::CONTRAST:
201     case FilterOperation::OPACITY:
202         return 1;
203     case FilterOperation::BLUR:
204     case FilterOperation::DROP_SHADOW:
205         // We use two-passes (vertical+horizontal) for blur and drop-shadow.
206         return 2;
207     default:
208         return 0;
209     }
210 }
</pre>
</td>
</tr>
</table>
<center><a href="BitmapTexture.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BitmapTextureGL.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
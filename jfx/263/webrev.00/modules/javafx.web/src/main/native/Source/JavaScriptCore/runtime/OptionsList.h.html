<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/OptionsList.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;GCLogging.h&quot;
 29 
 30 using WTF::PrintStream;
 31 
 32 namespace JSC {
 33 
 34 #if PLATFORM(IOS_FAMILY)
 35 #define MAXIMUM_NUMBER_OF_FTL_COMPILER_THREADS 2
 36 #else
 37 #define MAXIMUM_NUMBER_OF_FTL_COMPILER_THREADS 8
 38 #endif
 39 
 40 #if ENABLE(WEBASSEMBLY_STREAMING_API)
 41 constexpr bool enableWebAssemblyStreamingApi = true;
 42 #else
 43 constexpr bool enableWebAssemblyStreamingApi = false;
 44 #endif
 45 
 46 // How do JSC VM options work?
 47 // ===========================
 48 // The FOR_EACH_JSC_OPTION() macro below defines a list of all JSC options in use,
 49 // along with their types and default values. The options values are actually
 50 // realized as fields in OptionsStorage embedded in JSC::Config.
 51 //
 52 //     Options::initialize() will initialize the option values with the defaults
 53 // specified in FOR_EACH_JSC_OPTION() below. After that, the values can be
 54 // programmatically read and written to using an accessor method with the same
 55 // name as the option. For example, the option &quot;useJIT&quot; can be read and set like
 56 // so:
 57 //
 58 //     bool jitIsOn = Options::useJIT();  // Get the option value.
 59 //     Options::useJIT() = false;         // Sets the option value.
 60 //
 61 //     If you want to tweak any of these values programmatically for testing
 62 // purposes, you can do so in Options::initialize() after the default values
 63 // are set.
 64 //
 65 //     Alternatively, you can override the default values by specifying
 66 // environment variables of the form: JSC_&lt;name of JSC option&gt;.
 67 //
 68 // Note: Options::initialize() tries to ensure some sanity on the option values
 69 // which are set by doing some range checks, and value corrections. These
 70 // checks are done after the option values are set. If you alter the option
 71 // values after the sanity checks (for your own testing), then you&#39;re liable to
 72 // ensure that the new values set are sane and reasonable for your own run.
 73 //
 74 // Any modifications to options must be done before the first VM is instantiated.
 75 // On instantiation of the first VM instance, the Options will be write protected
 76 // and cannot be modified thereafter.
 77 
 78 #define FOR_EACH_JSC_OPTION(v)                                          \
 79     v(Bool, useKernTCSM, true, Normal, &quot;Note: this needs to go before other options since they depend on this value.&quot;) \
 80     v(Bool, validateOptions, false, Normal, &quot;crashes if mis-typed JSC options were passed to the VM&quot;) \
 81     v(Unsigned, dumpOptions, 0, Normal, &quot;dumps JSC options (0 = None, 1 = Overridden only, 2 = All, 3 = Verbose)&quot;) \
 82     v(OptionString, configFile, nullptr, Normal, &quot;file to configure JSC options and logging location&quot;) \
 83     \
 84     v(Bool, useLLInt,  true, Normal, &quot;allows the LLINT to be used if true&quot;) \
 85     v(Bool, useJIT, jitEnabledByDefault(), Normal, &quot;allows the executable pages to be allocated for JIT and thunks if true&quot;) \
 86     v(Bool, useBaselineJIT, true, Normal, &quot;allows the baseline JIT to be used if true&quot;) \
 87     v(Bool, useDFGJIT, true, Normal, &quot;allows the DFG JIT to be used if true&quot;) \
 88     v(Bool, useRegExpJIT, jitEnabledByDefault(), Normal, &quot;allows the RegExp JIT to be used if true&quot;) \
 89     v(Bool, useDOMJIT, is64Bit(), Normal, &quot;allows the DOMJIT to be used if true&quot;) \
 90     \
 91     v(Bool, reportMustSucceedExecutableAllocations, false, Normal, nullptr) \
 92     \
 93     v(Unsigned, maxPerThreadStackUsage, 5 * MB, Normal, &quot;Max allowed stack usage by the VM&quot;) \
 94     v(Unsigned, softReservedZoneSize, 128 * KB, Normal, &quot;A buffer greater than reservedZoneSize that reserves space for stringifying exceptions.&quot;) \
 95     v(Unsigned, reservedZoneSize, 64 * KB, Normal, &quot;The amount of stack space we guarantee to our clients (and to interal VM code that does not call out to clients).&quot;) \
 96     \
 97     v(Bool, crashIfCantAllocateJITMemory, false, Normal, nullptr) \
 98     v(Unsigned, jitMemoryReservationSize, 0, Normal, &quot;Set this number to change the executable allocation size in ExecutableAllocatorFixedVMPool. (In bytes.)&quot;) \
 99     v(Bool, useSeparatedWXHeap, false, Normal, nullptr) \
100     \
101     v(Bool, forceCodeBlockLiveness, false, Normal, nullptr) \
102     v(Bool, forceICFailure, false, Normal, nullptr) \
103     \
104     v(Unsigned, repatchCountForCoolDown, 8, Normal, nullptr) \
105     v(Unsigned, initialCoolDownCount, 20, Normal, nullptr) \
106     v(Unsigned, repatchBufferingCountdown, 8, Normal, nullptr) \
107     \
108     v(Bool, dumpGeneratedBytecodes, false, Normal, nullptr) \
109     v(Bool, dumpGeneratedWasmBytecodes, false, Normal, nullptr) \
110     v(Bool, dumpBytecodeLivenessResults, false, Normal, nullptr) \
111     v(Bool, validateBytecode, false, Normal, nullptr) \
112     v(Bool, forceDebuggerBytecodeGeneration, false, Normal, nullptr) \
113     v(Bool, dumpBytecodesBeforeGeneratorification, false, Normal, nullptr) \
114     \
115     v(Bool, useFunctionDotArguments, true, Normal, nullptr) \
116     v(Bool, useTailCalls, true, Normal, nullptr) \
117     v(Bool, optimizeRecursiveTailCalls, true, Normal, nullptr) \
118     v(Bool, alwaysUseShadowChicken, false, Normal, nullptr) \
119     v(Unsigned, shadowChickenLogSize, 1000, Normal, nullptr) \
120     v(Unsigned, shadowChickenMaxTailDeletedFramesSize, 128, Normal, nullptr) \
121     \
122     /* dumpDisassembly implies dumpDFGDisassembly. */ \
123     v(Bool, dumpDisassembly, false, Normal, &quot;dumps disassembly of all JIT compiled code upon compilation&quot;) \
124     v(Bool, asyncDisassembly, false, Normal, nullptr) \
125     v(Bool, dumpDFGDisassembly, false, Normal, &quot;dumps disassembly of DFG function upon compilation&quot;) \
126     v(Bool, dumpFTLDisassembly, false, Normal, &quot;dumps disassembly of FTL function upon compilation&quot;) \
127     v(Bool, dumpRegExpDisassembly, false, Normal, &quot;dumps disassembly of RegExp upon compilation&quot;) \
128     v(Bool, dumpWasmDisassembly, false, Normal, &quot;dumps disassembly of all Wasm code upon compilation&quot;) \
129     v(Bool, dumpBBQDisassembly, false, Normal, &quot;dumps disassembly of BBQ Wasm code upon compilation&quot;) \
130     v(Bool, dumpOMGDisassembly, false, Normal, &quot;dumps disassembly of OMG Wasm code upon compilation&quot;) \
131     v(Bool, logJITCodeForPerf, false, Configurable, nullptr) \
132     v(OptionRange, bytecodeRangeToJITCompile, 0, Normal, &quot;bytecode size range to allow compilation on, e.g. 1:100&quot;) \
133     v(OptionRange, bytecodeRangeToDFGCompile, 0, Normal, &quot;bytecode size range to allow DFG compilation on, e.g. 1:100&quot;) \
134     v(OptionRange, bytecodeRangeToFTLCompile, 0, Normal, &quot;bytecode size range to allow FTL compilation on, e.g. 1:100&quot;) \
135     v(OptionString, jitWhitelist, nullptr, Normal, &quot;file with list of function signatures to allow compilation on&quot;) \
136     v(OptionString, dfgWhitelist, nullptr, Normal, &quot;file with list of function signatures to allow DFG compilation on&quot;) \
137     v(OptionString, ftlWhitelist, nullptr, Normal, &quot;file with list of function signatures to allow FTL compilation on&quot;) \
138     v(Bool, dumpSourceAtDFGTime, false, Normal, &quot;dumps source code of JS function being DFG compiled&quot;) \
139     v(Bool, dumpBytecodeAtDFGTime, false, Normal, &quot;dumps bytecode of JS function being DFG compiled&quot;) \
140     v(Bool, dumpGraphAfterParsing, false, Normal, nullptr) \
141     v(Bool, dumpGraphAtEachPhase, false, Normal, nullptr) \
142     v(Bool, dumpDFGGraphAtEachPhase, false, Normal, &quot;dumps the DFG graph at each phase of DFG compilation (note this excludes DFG graphs during FTL compilation)&quot;) \
143     v(Bool, dumpDFGFTLGraphAtEachPhase, false, Normal, &quot;dumps the DFG graph at each phase of DFG compilation when compiling FTL code&quot;) \
144     v(Bool, dumpB3GraphAtEachPhase, false, Normal, &quot;dumps the B3 graph at each phase of compilation&quot;) \
145     v(Bool, dumpAirGraphAtEachPhase, false, Normal, &quot;dumps the Air graph at each phase of compilation&quot;) \
146     v(Bool, verboseDFGBytecodeParsing, false, Normal, nullptr) \
147     v(Bool, safepointBeforeEachPhase, true, Normal, nullptr) \
148     v(Bool, verboseCompilation, false, Normal, nullptr) \
149     v(Bool, verboseFTLCompilation, false, Normal, nullptr) \
150     v(Bool, logCompilationChanges, false, Normal, nullptr) \
151     v(Bool, useProbeOSRExit, false, Normal, nullptr) \
152     v(Bool, printEachOSRExit, false, Normal, nullptr) \
153     v(Bool, validateGraph, false, Normal, nullptr) \
154     v(Bool, validateGraphAtEachPhase, false, Normal, nullptr) \
155     v(Bool, verboseValidationFailure, false, Normal, nullptr) \
156     v(Bool, verboseOSR, false, Normal, nullptr) \
157     v(Bool, verboseDFGOSRExit, false, Normal, nullptr) \
158     v(Bool, verboseFTLOSRExit, false, Normal, nullptr) \
159     v(Bool, verboseCallLink, false, Normal, nullptr) \
160     v(Bool, verboseCompilationQueue, false, Normal, nullptr) \
161     v(Bool, reportCompileTimes, false, Normal, &quot;dumps JS function signature and the time it took to compile in all tiers&quot;) \
162     v(Bool, reportBaselineCompileTimes, false, Normal, &quot;dumps JS function signature and the time it took to BaselineJIT compile&quot;) \
163     v(Bool, reportDFGCompileTimes, false, Normal, &quot;dumps JS function signature and the time it took to DFG and FTL compile&quot;) \
164     v(Bool, reportFTLCompileTimes, false, Normal, &quot;dumps JS function signature and the time it took to FTL compile&quot;) \
165     v(Bool, reportTotalCompileTimes, false, Normal, nullptr) \
166     v(Bool, reportTotalPhaseTimes, false, Normal, &quot;This prints phase times at the end of running script inside jsc.cpp&quot;) \
167     v(Bool, reportParseTimes, false, Normal, &quot;dumps JS function signature and the time it took to parse&quot;) \
168     v(Bool, reportBytecodeCompileTimes, false, Normal, &quot;dumps JS function signature and the time it took to bytecode compile&quot;) \
169     v(Bool, countParseTimes, false, Normal, &quot;counts parse times&quot;) \
170     v(Bool, verboseExitProfile, false, Normal, nullptr) \
171     v(Bool, verboseCFA, false, Normal, nullptr) \
172     v(Bool, verboseDFGFailure, false, Normal, nullptr) \
173     v(Bool, verboseFTLToJSThunk, false, Normal, nullptr) \
174     v(Bool, verboseFTLFailure, false, Normal, nullptr) \
175     v(Bool, alwaysComputeHash, false, Normal, nullptr) \
176     v(Bool, testTheFTL, false, Normal, nullptr) \
177     v(Bool, verboseSanitizeStack, false, Normal, nullptr) \
178     v(Bool, useGenerationalGC, true, Normal, nullptr) \
179     v(Bool, useConcurrentGC, true, Normal, nullptr) \
180     v(Bool, collectContinuously, false, Normal, nullptr) \
181     v(Double, collectContinuouslyPeriodMS, 1, Normal, nullptr) \
182     v(Bool, forceFencedBarrier, false, Normal, nullptr) \
183     v(Bool, verboseVisitRace, false, Normal, nullptr) \
184     v(Bool, optimizeParallelSlotVisitorsForStoppedMutator, false, Normal, nullptr) \
185     v(Unsigned, largeHeapSize, 32 * 1024 * 1024, Normal, nullptr) \
186     v(Unsigned, smallHeapSize, 1 * 1024 * 1024, Normal, nullptr) \
187     v(Double, smallHeapRAMFraction, 0.25, Normal, nullptr) \
188     v(Double, smallHeapGrowthFactor, 2, Normal, nullptr) \
189     v(Double, mediumHeapRAMFraction, 0.5, Normal, nullptr) \
190     v(Double, mediumHeapGrowthFactor, 1.5, Normal, nullptr) \
191     v(Double, largeHeapGrowthFactor, 1.24, Normal, nullptr) \
192     v(Double, miniVMHeapGrowthFactor, 1.27, Normal, nullptr) \
193     v(Double, criticalGCMemoryThreshold, 0.80, Normal, &quot;percent memory in use the GC considers critical.  The collector is much more aggressive above this threshold&quot;) \
194     v(Double, minimumMutatorUtilization, 0, Normal, nullptr) \
195     v(Double, maximumMutatorUtilization, 0.7, Normal, nullptr) \
196     v(Double, epsilonMutatorUtilization, 0.01, Normal, nullptr) \
197     v(Double, concurrentGCMaxHeadroom, 1.5, Normal, nullptr) \
198     v(Double, concurrentGCPeriodMS, 2, Normal, nullptr) \
199     v(Bool, useStochasticMutatorScheduler, true, Normal, nullptr) \
200     v(Double, minimumGCPauseMS, 0.3, Normal, nullptr) \
201     v(Double, gcPauseScale, 0.3, Normal, nullptr) \
202     v(Double, gcIncrementBytes, 10000, Normal, nullptr) \
203     v(Double, gcIncrementMaxBytes, 100000, Normal, nullptr) \
204     v(Double, gcIncrementScale, 0, Normal, nullptr) \
205     v(Bool, scribbleFreeCells, false, Normal, nullptr) \
206     v(Double, sizeClassProgression, 1.4, Normal, nullptr) \
207     v(Unsigned, preciseAllocationCutoff, 100000, Normal, nullptr) \
208     v(Bool, dumpSizeClasses, false, Normal, nullptr) \
209     v(Bool, useBumpAllocator, true, Normal, nullptr) \
210     v(Bool, stealEmptyBlocksFromOtherAllocators, true, Normal, nullptr) \
211     v(Bool, eagerlyUpdateTopCallFrame, false, Normal, nullptr) \
212     v(Bool, dumpZappedCellCrashData, false, Normal, nullptr) \
213     \
214     v(Bool, useOSREntryToDFG, true, Normal, nullptr) \
215     v(Bool, useOSREntryToFTL, true, Normal, nullptr) \
216     \
217     v(Bool, useFTLJIT, true, Normal, &quot;allows the FTL JIT to be used if true&quot;) \
218     v(Bool, validateFTLOSRExitLiveness, false, Normal, nullptr) \
219     v(Unsigned, defaultB3OptLevel, 2, Normal, nullptr) \
220     v(Bool, b3AlwaysFailsBeforeCompile, false, Normal, nullptr) \
221     v(Bool, b3AlwaysFailsBeforeLink, false, Normal, nullptr) \
222     v(Bool, ftlCrashes, false, Normal, nullptr) /* fool-proof way of checking that you ended up in the FTL. ;-) */\
223     v(Bool, clobberAllRegsInFTLICSlowPath, ASSERT_ENABLED, Normal, nullptr) \
224     v(Bool, enableJITDebugAssertions, ASSERT_ENABLED, Normal, nullptr) \
225     v(Bool, useAccessInlining, true, Normal, nullptr) \
226     v(Unsigned, maxAccessVariantListSize, 8, Normal, nullptr) \
227     v(Bool, usePolyvariantDevirtualization, true, Normal, nullptr) \
228     v(Bool, usePolymorphicAccessInlining, true, Normal, nullptr) \
229     v(Unsigned, maxPolymorphicAccessInliningListSize, 8, Normal, nullptr) \
230     v(Bool, usePolymorphicCallInlining, true, Normal, nullptr) \
231     v(Bool, usePolymorphicCallInliningForNonStubStatus, false, Normal, nullptr) \
232     v(Unsigned, maxPolymorphicCallVariantListSize, 15, Normal, nullptr) \
233     v(Unsigned, maxPolymorphicCallVariantListSizeForTopTier, 5, Normal, nullptr) \
234     v(Unsigned, maxPolymorphicCallVariantListSizeForWebAssemblyToJS, 5, Normal, nullptr) \
235     v(Unsigned, maxPolymorphicCallVariantsForInlining, 5, Normal, nullptr) \
236     v(Unsigned, frequentCallThreshold, 2, Normal, nullptr) \
237     v(Double, minimumCallToKnownRate, 0.51, Normal, nullptr) \
238     v(Bool, createPreHeaders, true, Normal, nullptr) \
239     v(Bool, useMovHintRemoval, true, Normal, nullptr) \
240     v(Bool, usePutStackSinking, true, Normal, nullptr) \
241     v(Bool, useObjectAllocationSinking, true, Normal, nullptr) \
242     v(Bool, useValueRepElimination, true, Normal, nullptr) \
243     v(Bool, useArityFixupInlining, true, Normal, nullptr) \
244     v(Bool, logExecutableAllocation, false, Normal, nullptr) \
245     v(Unsigned, maxDFGNodesInBasicBlockForPreciseAnalysis, 20000, Normal, &quot;Disable precise but costly analysis and give conservative results if the number of DFG nodes in a block exceeds this threshold&quot;) \
246     \
247     v(Bool, useConcurrentJIT, true, Normal, &quot;allows the DFG / FTL compilation in threads other than the executing JS thread&quot;) \
248     v(Unsigned, numberOfDFGCompilerThreads, computeNumberOfWorkerThreads(3, 2) - 1, Normal, nullptr) \
249     v(Unsigned, numberOfFTLCompilerThreads, computeNumberOfWorkerThreads(MAXIMUM_NUMBER_OF_FTL_COMPILER_THREADS, 2) - 1, Normal, nullptr) \
250     v(Int32, priorityDeltaOfDFGCompilerThreads, computePriorityDeltaOfWorkerThreads(-1, 0), Normal, nullptr) \
251     v(Int32, priorityDeltaOfFTLCompilerThreads, computePriorityDeltaOfWorkerThreads(-2, 0), Normal, nullptr) \
252     v(Int32, priorityDeltaOfWasmCompilerThreads, computePriorityDeltaOfWorkerThreads(-1, 0), Normal, nullptr) \
253     \
254     v(Bool, useProfiler, false, Normal, nullptr) \
255     v(Bool, disassembleBaselineForProfiler, true, Normal, nullptr) \
256     \
257     v(Bool, useArchitectureSpecificOptimizations, true, Normal, nullptr) \
258     \
259     v(Bool, breakOnThrow, false, Normal, nullptr) \
260     \
261     v(Unsigned, maximumOptimizationCandidateBytecodeCost, 100000, Normal, nullptr) \
262     \
263     v(Unsigned, maximumFunctionForCallInlineCandidateBytecodeCost, 120, Normal, nullptr) \
264     v(Unsigned, maximumFunctionForClosureCallInlineCandidateBytecodeCost, 100, Normal, nullptr) \
265     v(Unsigned, maximumFunctionForConstructInlineCandidateBytecoodeCost, 100, Normal, nullptr) \
266     \
267     v(Unsigned, maximumFTLCandidateBytecodeCost, 20000, Normal, nullptr) \
268     \
269     /* Depth of inline stack, so 1 = no inlining, 2 = one level, etc. */ \
270     v(Unsigned, maximumInliningDepth, 5, Normal, &quot;maximum allowed inlining depth.  Depth of 1 means no inlining&quot;) \
271     v(Unsigned, maximumInliningRecursion, 2, Normal, nullptr) \
272     \
273     /* Maximum size of a caller for enabling inlining. This is purely to protect us */\
274     /* from super long compiles that take a lot of memory. */\
275     v(Unsigned, maximumInliningCallerBytecodeCost, 10000, Normal, nullptr) \
276     \
277     v(Unsigned, maximumVarargsForInlining, 100, Normal, nullptr) \
278     \
279     v(Unsigned, maximumBinaryStringSwitchCaseLength, 50, Normal, nullptr) \
280     v(Unsigned, maximumBinaryStringSwitchTotalLength, 2000, Normal, nullptr) \
281     \
282     v(Double, jitPolicyScale, 1.0, Normal, &quot;scale JIT thresholds to this specified ratio between 0.0 (compile ASAP) and 1.0 (compile like normal).&quot;) \
283     v(Bool, forceEagerCompilation, false, Normal, nullptr) \
284     v(Int32, thresholdForJITAfterWarmUp, 500, Normal, nullptr) \
285     v(Int32, thresholdForJITSoon, 100, Normal, nullptr) \
286     \
287     v(Int32, thresholdForOptimizeAfterWarmUp, 1000, Normal, nullptr) \
288     v(Int32, thresholdForOptimizeAfterLongWarmUp, 1000, Normal, nullptr) \
289     v(Int32, thresholdForOptimizeSoon, 1000, Normal, nullptr) \
290     v(Int32, executionCounterIncrementForLoop, 1, Normal, nullptr) \
291     v(Int32, executionCounterIncrementForEntry, 15, Normal, nullptr) \
292     \
293     v(Int32, thresholdForFTLOptimizeAfterWarmUp, 100000, Normal, nullptr) \
294     v(Int32, thresholdForFTLOptimizeSoon, 1000, Normal, nullptr) \
295     v(Int32, ftlTierUpCounterIncrementForLoop, 1, Normal, nullptr) \
296     v(Int32, ftlTierUpCounterIncrementForReturn, 15, Normal, nullptr) \
297     v(Unsigned, ftlOSREntryFailureCountForReoptimization, 15, Normal, nullptr) \
298     v(Unsigned, ftlOSREntryRetryThreshold, 100, Normal, nullptr) \
299     \
300     v(Int32, evalThresholdMultiplier, 10, Normal, nullptr) \
301     v(Unsigned, maximumEvalCacheableSourceLength, 256, Normal, nullptr) \
302     \
303     v(Bool, randomizeExecutionCountsBetweenCheckpoints, false, Normal, nullptr) \
304     v(Int32, maximumExecutionCountsBetweenCheckpointsForBaseline, 1000, Normal, nullptr) \
305     v(Int32, maximumExecutionCountsBetweenCheckpointsForUpperTiers, 50000, Normal, nullptr) \
306     \
307     v(Unsigned, likelyToTakeSlowCaseMinimumCount, 20, Normal, nullptr) \
308     v(Unsigned, couldTakeSlowCaseMinimumCount, 10, Normal, nullptr) \
309     \
310     v(Unsigned, osrExitCountForReoptimization, 100, Normal, nullptr) \
311     v(Unsigned, osrExitCountForReoptimizationFromLoop, 5, Normal, nullptr) \
312     \
313     v(Unsigned, reoptimizationRetryCounterMax, 0, Normal, nullptr)  \
314     \
315     v(Unsigned, minimumOptimizationDelay, 1, Normal, nullptr) \
316     v(Unsigned, maximumOptimizationDelay, 5, Normal, nullptr) \
317     v(Double, desiredProfileLivenessRate, 0.75, Normal, nullptr) \
318     v(Double, desiredProfileFullnessRate, 0.35, Normal, nullptr) \
319     \
320     v(Double, doubleVoteRatioForDoubleFormat, 2, Normal, nullptr) \
321     v(Double, structureCheckVoteRatioForHoisting, 1, Normal, nullptr) \
322     v(Double, checkArrayVoteRatioForHoisting, 1, Normal, nullptr) \
323     \
324     v(Unsigned, maximumDirectCallStackSize, 200, Normal, nullptr) \
325     \
326     v(Unsigned, minimumNumberOfScansBetweenRebalance, 100, Normal, nullptr) \
327     v(Unsigned, numberOfGCMarkers, computeNumberOfGCMarkers(8), Normal, nullptr) \
328     v(Bool, useParallelMarkingConstraintSolver, true, Normal, nullptr) \
329     v(Unsigned, opaqueRootMergeThreshold, 1000, Normal, nullptr) \
330     v(Double, minHeapUtilization, 0.8, Normal, nullptr) \
331     v(Double, minMarkedBlockUtilization, 0.9, Normal, nullptr) \
332     v(Unsigned, slowPathAllocsBetweenGCs, 0, Normal, &quot;force a GC on every Nth slow path alloc, where N is specified by this option&quot;) \
333     \
334     v(Double, percentCPUPerMBForFullTimer, 0.0003125, Normal, nullptr) \
335     v(Double, percentCPUPerMBForEdenTimer, 0.0025, Normal, nullptr) \
336     v(Double, collectionTimerMaxPercentCPU, 0.05, Normal, nullptr) \
337     \
338     v(Bool, forceWeakRandomSeed, false, Normal, nullptr) \
339     v(Unsigned, forcedWeakRandomSeed, 0, Normal, nullptr) \
340     \
341     v(Bool, useZombieMode, false, Normal, &quot;debugging option to scribble over dead objects with 0xbadbeef0&quot;) \
342     v(Bool, useImmortalObjects, false, Normal, &quot;debugging option to keep all objects alive forever&quot;) \
343     v(Bool, sweepSynchronously, false, Normal, &quot;debugging option to sweep all dead objects synchronously at GC end before resuming mutator&quot;) \
344     v(Unsigned, maxSingleAllocationSize, 0, Configurable, &quot;debugging option to limit individual allocations to a max size (0 = limit not set, N = limit size in bytes)&quot;) \
345     \
346     v(GCLogLevel, logGC, GCLogging::None, Normal, &quot;debugging option to log GC activity (0 = None, 1 = Basic, 2 = Verbose)&quot;) \
347     v(Bool, useGC, true, Normal, nullptr) \
348     v(Bool, gcAtEnd, false, Normal, &quot;If true, the jsc CLI will do a GC before exiting&quot;) \
349     v(Bool, forceGCSlowPaths, false, Normal, &quot;If true, we will force all JIT fast allocations down their slow paths.&quot;) \
350     v(Bool, forceDidDeferGCWork, false, Normal, &quot;If true, we will force all DeferGC destructions to perform a GC.&quot;) \
351     v(Unsigned, gcMaxHeapSize, 0, Normal, nullptr) \
352     v(Unsigned, forceRAMSize, 0, Normal, nullptr) \
353     v(Bool, recordGCPauseTimes, false, Normal, nullptr) \
354     v(Bool, dumpHeapStatisticsAtVMDestruction, false, Normal, nullptr) \
355     v(Bool, forceCodeBlockToJettisonDueToOldAge, false, Normal, &quot;If true, this means that anytime we can jettison a CodeBlock due to old age, we do.&quot;) \
356     v(Bool, useEagerCodeBlockJettisonTiming, false, Normal, &quot;If true, the time slices for jettisoning a CodeBlock due to old age are shrunk significantly.&quot;) \
357     \
358     v(Bool, useTypeProfiler, false, Normal, nullptr) \
359     v(Bool, useControlFlowProfiler, false, Normal, nullptr) \
360     \
361     v(Bool, useSamplingProfiler, false, Normal, nullptr) \
362     v(Unsigned, sampleInterval, 1000, Normal, &quot;Time between stack traces in microseconds.&quot;) \
363     v(Bool, collectSamplingProfilerDataForJSCShell, false, Normal, &quot;This corresponds to the JSC shell&#39;s --sample option.&quot;) \
364     v(Unsigned, samplingProfilerTopFunctionsCount, 12, Normal, &quot;Number of top functions to report when using the command line interface.&quot;) \
365     v(Unsigned, samplingProfilerTopBytecodesCount, 40, Normal, &quot;Number of top bytecodes to report when using the command line interface.&quot;) \
366     v(OptionString, samplingProfilerPath, nullptr, Normal, &quot;The path to the directory to write sampiling profiler output to. This probably will not work with WK2 unless the path is in the whitelist.&quot;) \
367     v(Bool, sampleCCode, false, Normal, &quot;Causes the sampling profiler to record profiling data for C frames.&quot;) \
368     \
369     v(Bool, alwaysGeneratePCToCodeOriginMap, false, Normal, &quot;This will make sure we always generate a PCToCodeOriginMap for JITed code.&quot;) \
370     \
371     v(Double, randomIntegrityAuditRate, 0.05, Normal, &quot;Probability of random integrity audits [0.0 - 1.0]&quot;) \
372     v(Bool, verifyHeap, false, Normal, nullptr) \
373     v(Unsigned, numberOfGCCyclesToRecordForVerification, 3, Normal, nullptr) \
374     \
375     v(Unsigned, exceptionStackTraceLimit, 100, Normal, &quot;Stack trace limit for internal Exception object&quot;) \
376     v(Unsigned, defaultErrorStackTraceLimit, 100, Normal, &quot;The default value for Error.stackTraceLimit&quot;) \
377     v(Bool, useExceptionFuzz, false, Normal, nullptr) \
378     v(Unsigned, fireExceptionFuzzAt, 0, Normal, nullptr) \
379     v(Bool, validateDFGExceptionHandling, false, Normal, &quot;Causes the DFG to emit code validating exception handling for each node that can exit&quot;) /* This is true by default on Debug builds */\
380     v(Bool, dumpSimulatedThrows, false, Normal, &quot;Dumps the call stack of the last simulated throw if exception scope verification fails&quot;) \
381     v(Bool, validateExceptionChecks, false, Normal, &quot;Verifies that needed exception checks are performed.&quot;) \
382     v(Unsigned, unexpectedExceptionStackTraceLimit, 100, Normal, &quot;Stack trace limit for debugging unexpected exceptions observed in the VM&quot;) \
383     \
384     v(Bool, useExecutableAllocationFuzz, false, Normal, nullptr) \
385     v(Unsigned, fireExecutableAllocationFuzzAt, 0, Normal, nullptr) \
386     v(Unsigned, fireExecutableAllocationFuzzAtOrAfter, 0, Normal, nullptr) \
387     v(Bool, verboseExecutableAllocationFuzz, false, Normal, nullptr) \
388     \
389     v(Bool, useOSRExitFuzz, false, Normal, nullptr) \
390     v(Unsigned, fireOSRExitFuzzAtStatic, 0, Normal, nullptr) \
391     v(Unsigned, fireOSRExitFuzzAt, 0, Normal, nullptr) \
392     v(Unsigned, fireOSRExitFuzzAtOrAfter, 0, Normal, nullptr) \
393     \
394     v(Unsigned, seedOfVMRandomForFuzzer, 0, Normal, &quot;0 means not fuzzing this; use a cryptographically random seed&quot;) \
395     v(Bool, useRandomizingFuzzerAgent, false, Normal, nullptr) \
396     v(Unsigned, seedOfRandomizingFuzzerAgent, 1, Normal, nullptr) \
397     v(Bool, dumpFuzzerAgentPredictions, false, Normal, nullptr) \
398     v(Bool, useDoublePredictionFuzzerAgent, false, Normal, nullptr) \
399     v(Bool, useFileBasedFuzzerAgent, false, Normal, nullptr) \
400     v(Bool, usePredictionFileCreatingFuzzerAgent, false, Normal, nullptr) \
401     v(Bool, requirePredictionForFileBasedFuzzerAgent, false, Normal, nullptr) \
402     v(OptionString, fuzzerPredictionsFile, nullptr, Normal, &quot;file with list of predictions for FileBasedFuzzerAgent&quot;) \
403     v(Bool, useNarrowingNumberPredictionFuzzerAgent, false, Normal, nullptr) \
404     v(Bool, useWideningNumberPredictionFuzzerAgent, false, Normal, nullptr) \
405     \
406     v(Bool, logPhaseTimes, false, Normal, nullptr) \
407     v(Double, rareBlockPenalty, 0.001, Normal, nullptr) \
408     v(Bool, airLinearScanVerbose, false, Normal, nullptr) \
409     v(Bool, airLinearScanSpillsEverything, false, Normal, nullptr) \
410     v(Bool, airForceBriggsAllocator, false, Normal, nullptr) \
411     v(Bool, airForceIRCAllocator, false, Normal, nullptr) \
412     v(Bool, airRandomizeRegs, false, Normal, nullptr) \
413     v(Unsigned, airRandomizeRegsSeed, 0, Normal, nullptr) \
414     v(Bool, coalesceSpillSlots, true, Normal, nullptr) \
415     v(Bool, logAirRegisterPressure, false, Normal, nullptr) \
416     v(Bool, useB3TailDup, true, Normal, nullptr) \
417     v(Unsigned, maxB3TailDupBlockSize, 3, Normal, nullptr) \
418     v(Unsigned, maxB3TailDupBlockSuccessors, 3, Normal, nullptr) \
419     \
420     v(Bool, useDollarVM, false, Restricted, &quot;installs the $vm debugging tool in global objects&quot;) \
421     v(OptionString, functionOverrides, nullptr, Restricted, &quot;file with debugging overrides for function bodies&quot;) \
422     v(Bool, useSigillCrashAnalyzer, false, Configurable, &quot;logs data about SIGILL crashes&quot;) \
423     \
424     v(Unsigned, watchdog, 0, Normal, &quot;watchdog timeout (0 = Disabled, N = a timeout period of N milliseconds)&quot;) \
425     v(Bool, usePollingTraps, false, Normal, &quot;use polling (instead of signalling) VM traps&quot;) \
426     \
427     v(Bool, useMachForExceptions, true, Normal, &quot;Use mach exceptions rather than signals to handle faults and pass thread messages. (This does nothing on platforms without mach)&quot;) \
428     \
429     v(Bool, useICStats, false, Normal, nullptr) \
430     \
431     v(Unsigned, prototypeHitCountForLLIntCaching, 2, Normal, &quot;Number of prototype property hits before caching a prototype in the LLInt. A count of 0 means never cache.&quot;) \
432     \
433     v(Bool, dumpCompiledRegExpPatterns, false, Normal, nullptr) \
434     \
435     v(Bool, dumpModuleRecord, false, Normal, nullptr) \
436     v(Bool, dumpModuleLoadingState, false, Normal, nullptr) \
437     v(Bool, exposeInternalModuleLoader, false, Normal, &quot;expose the internal module loader object to the global space for debugging&quot;) \
438     \
439     v(Bool, useSuperSampler, false, Normal, nullptr) \
440     \
441     v(Bool, useSourceProviderCache, true, Normal, &quot;If false, the parser will not use the source provider cache. It&#39;s good to verify everything works when this is false. Because the cache is so successful, it can mask bugs.&quot;) \
442     v(Bool, useCodeCache, true, Normal, &quot;If false, the unlinked byte code cache will not be used.&quot;) \
443     \
444     v(Bool, useWebAssembly, true, Normal, &quot;Expose the WebAssembly global object.&quot;) \
445     \
446     v(Bool, failToCompileWebAssemblyCode, false, Normal, &quot;If true, no Wasm::Plan will sucessfully compile a function.&quot;) \
447     v(Size, webAssemblyPartialCompileLimit, 5000, Normal, &quot;Limit on the number of bytes a Wasm::Plan::compile should attempt before checking for other work.&quot;) \
448     v(Unsigned, webAssemblyBBQAirOptimizationLevel, 0, Normal, &quot;Air Optimization level for BBQ Web Assembly module compilations.&quot;) \
449     v(Unsigned, webAssemblyBBQB3OptimizationLevel, 1, Normal, &quot;B3 Optimization level for BBQ Web Assembly module compilations.&quot;) \
450     v(Unsigned, webAssemblyOMGOptimizationLevel, Options::defaultB3OptLevel(), Normal, &quot;B3 Optimization level for OMG Web Assembly module compilations.&quot;) \
451     \
452     v(Bool, useBBQTierUpChecks, true, Normal, &quot;Enables tier up checks for our BBQ code.&quot;) \
453     v(Bool, useWebAssemblyOSR, true, Normal, nullptr) \
454     v(Int32, thresholdForBBQOptimizeAfterWarmUp, 150, Normal, &quot;The count before we tier up a function to BBQ.&quot;) \
455     v(Int32, thresholdForBBQOptimizeSoon, 50, Normal, nullptr) \
456     v(Int32, thresholdForOMGOptimizeAfterWarmUp, 50000, Normal, &quot;The count before we tier up a function to OMG.&quot;) \
457     v(Int32, thresholdForOMGOptimizeSoon, 500, Normal, nullptr) \
458     v(Int32, omgTierUpCounterIncrementForLoop, 1, Normal, &quot;The amount the tier up counter is incremented on each loop backedge.&quot;) \
459     v(Int32, omgTierUpCounterIncrementForEntry, 15, Normal, &quot;The amount the tier up counter is incremented on each function entry.&quot;) \
460     /* FIXME: enable fast memories on iOS and pre-allocate them. https://bugs.webkit.org/show_bug.cgi?id=170774 */ \
461     v(Bool, useWebAssemblyFastMemory, OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH) &gt;= 48, Normal, &quot;If true, we will try to use a 32-bit address space with a signal handler to bounds check wasm memory.&quot;) \
462     v(Bool, logWebAssemblyMemory, false, Normal, nullptr) \
463     v(Unsigned, webAssemblyFastMemoryRedzonePages, 128, Normal, &quot;WebAssembly fast memories use 4GiB virtual allocations, plus a redzone (counted as multiple of 64KiB WebAssembly pages) at the end to catch reg+imm accesses which exceed 32-bit, anything beyond the redzone is explicitly bounds-checked&quot;) \
464     v(Bool, crashIfWebAssemblyCantFastMemory, false, Normal, &quot;If true, we will crash if we can&#39;t obtain fast memory for wasm.&quot;) \
465     v(Bool, crashOnFailedWebAssemblyValidate, false, Normal, &quot;If true, we will crash if we can&#39;t validate a wasm module instead of throwing an exception.&quot;) \
466     v(Unsigned, maxNumWebAssemblyFastMemories, 4, Normal, nullptr) \
467     v(Bool, useFastTLSForWasmContext, true, Normal, &quot;If true, we will store context in fast TLS. If false, we will pin it to a register.&quot;) \
468     v(Bool, wasmBBQUsesAir, true, Normal, nullptr) \
469     v(Bool, useWasmLLInt, true, Normal, nullptr) \
470     v(Bool, wasmLLIntTiersUpToBBQ, true, Normal, nullptr) \
471     v(Size, webAssemblyBBQAirModeThreshold, isIOS() ? (10 * MB) : 0, Normal, &quot;If 0, we always use BBQ Air. If Wasm module code size hits this threshold, we compile Wasm module with B3 BBQ mode.&quot;) \
472     v(Bool, useWebAssemblyStreamingApi, enableWebAssemblyStreamingApi, Normal, &quot;Allow to run WebAssembly&#39;s Streaming API&quot;) \
473     v(Bool, useEagerWebAssemblyModuleHashing, false, Normal, &quot;Unnamed WebAssembly modules are identified in backtraces through their hash, if available.&quot;) \
474     v(Bool, useWebAssemblyReferences, true, Normal, &quot;Allow types from the wasm references spec.&quot;) \
475     v(Bool, useWebAssemblyMultiValues, true, Normal, &quot;Allow types from the wasm mulit-values spec.&quot;) \
476     v(Bool, useWeakRefs, false, Normal, &quot;Expose the WeakRef constructor.&quot;) \
477     v(Bool, useBigInt, false, Normal, &quot;If true, we will enable BigInt support.&quot;) \
478     v(Bool, useArrayAllocationProfiling, true, Normal, &quot;If true, we will use our normal array allocation profiling. If false, the allocation profile will always claim to be undecided.&quot;) \
479     v(Bool, forcePolyProto, false, Normal, &quot;If true, create_this will always create an object with a poly proto structure.&quot;) \
480     v(Bool, forceMiniVMMode, false, Normal, &quot;If true, it will force mini VM mode on.&quot;) \
481     v(Bool, useTracePoints, false, Normal, nullptr) \
482     v(Bool, traceLLIntExecution, false, Configurable, nullptr) \
483     v(Bool, traceLLIntSlowPath, false, Configurable, nullptr) \
484     v(Bool, traceBaselineJITExecution, false, Normal, nullptr) \
485     v(Unsigned, thresholdForGlobalLexicalBindingEpoch, UINT_MAX, Normal, &quot;Threshold for global lexical binding epoch. If the epoch reaches to this value, CodeBlock metadata for scope operations will be revised globally. It needs to be greater than 1.&quot;) \
486     v(OptionString, diskCachePath, nullptr, Restricted, nullptr) \
487     v(Bool, forceDiskCache, false, Restricted, nullptr) \
488     v(Bool, validateAbstractInterpreterState, false, Restricted, nullptr) \
489     v(Double, validateAbstractInterpreterStateProbability, 0.5, Normal, nullptr) \
490     v(OptionString, dumpJITMemoryPath, nullptr, Restricted, nullptr) \
491     v(Double, dumpJITMemoryFlushInterval, 10, Restricted, &quot;Maximum time in between flushes of the JIT memory dump in seconds.&quot;) \
492     v(Bool, useUnlinkedCodeBlockJettisoning, false, Normal, &quot;If true, UnlinkedCodeBlock can be jettisoned.&quot;) \
493     v(Bool, forceOSRExitToLLInt, false, Normal, &quot;If true, we always exit to the LLInt. If false, we exit to whatever is most convenient.&quot;) \
494     v(Unsigned, getByValICMaxNumberOfIdentifiers, 4, Normal, &quot;Number of identifiers we see in the LLInt that could cause us to bail on generating an IC for get_by_val.&quot;) \
495     v(Bool, useClassFields, false, Normal, &quot;If true, the parser will understand data fields inside classes.&quot;) \
496 
497 enum OptionEquivalence {
498     SameOption,
499     InvertedOption,
500 };
501 
502 #define FOR_EACH_JSC_ALIASED_OPTION(v) \
503     v(enableFunctionDotArguments, useFunctionDotArguments, SameOption) \
504     v(enableTailCalls, useTailCalls, SameOption) \
505     v(showDisassembly, dumpDisassembly, SameOption) \
506     v(showDFGDisassembly, dumpDFGDisassembly, SameOption) \
507     v(showFTLDisassembly, dumpFTLDisassembly, SameOption) \
508     v(alwaysDoFullCollection, useGenerationalGC, InvertedOption) \
509     v(enableOSREntryToDFG, useOSREntryToDFG, SameOption) \
510     v(enableOSREntryToFTL, useOSREntryToFTL, SameOption) \
511     v(enableAccessInlining, useAccessInlining, SameOption) \
512     v(enablePolyvariantDevirtualization, usePolyvariantDevirtualization, SameOption) \
513     v(enablePolymorphicAccessInlining, usePolymorphicAccessInlining, SameOption) \
514     v(enablePolymorphicCallInlining, usePolymorphicCallInlining, SameOption) \
515     v(enableMovHintRemoval, useMovHintRemoval, SameOption) \
516     v(enableObjectAllocationSinking, useObjectAllocationSinking, SameOption) \
517     v(enableConcurrentJIT, useConcurrentJIT, SameOption) \
518     v(enableProfiler, useProfiler, SameOption) \
519     v(enableArchitectureSpecificOptimizations, useArchitectureSpecificOptimizations, SameOption) \
520     v(enablePolyvariantCallInlining, usePolyvariantCallInlining, SameOption) \
521     v(enablePolyvariantByIdInlining, usePolyvariantByIdInlining, SameOption) \
522     v(objectsAreImmortal, useImmortalObjects, SameOption) \
523     v(showObjectStatistics, dumpObjectStatistics, SameOption) \
524     v(disableGC, useGC, InvertedOption) \
525     v(enableTypeProfiler, useTypeProfiler, SameOption) \
526     v(enableControlFlowProfiler, useControlFlowProfiler, SameOption) \
527     v(enableExceptionFuzz, useExceptionFuzz, SameOption) \
528     v(enableExecutableAllocationFuzz, useExecutableAllocationFuzz, SameOption) \
529     v(enableOSRExitFuzz, useOSRExitFuzz, SameOption) \
530     v(enableDollarVM, useDollarVM, SameOption) \
531     v(enableWebAssembly, useWebAssembly, SameOption) \
532     v(verboseDFGByteCodeParsing, verboseDFGBytecodeParsing, SameOption) \
533     v(maximumOptimizationCandidateInstructionCount, maximumOptimizationCandidateBytecodeCost, SameOption) \
534     v(maximumFunctionForCallInlineCandidateInstructionCount, maximumFunctionForCallInlineCandidateBytecodeCost, SameOption) \
535     v(maximumFunctionForClosureCallInlineCandidateInstructionCount, maximumFunctionForClosureCallInlineCandidateBytecodeCost, SameOption) \
536     v(maximumFunctionForConstructInlineCandidateInstructionCount, maximumFunctionForConstructInlineCandidateBytecoodeCost, SameOption) \
537     v(maximumFTLCandidateInstructionCount, maximumFTLCandidateBytecodeCost, SameOption) \
538     v(maximumInliningCallerSize, maximumInliningCallerBytecodeCost, SameOption) \
539 
540 
541 constexpr size_t countNumberOfJSCOptions()
542 {
543 #define COUNT_OPTION(type_, name_, defaultValue_, availability_, description_) count++;
544     size_t count = 0;
545     FOR_EACH_JSC_OPTION(COUNT_OPTION);
546     return count;
547 #undef COUNT_OPTION
548 }
549 
550 constexpr size_t NumberOfOptions = countNumberOfJSCOptions();
551 
552 class OptionRange {
553 private:
554     enum RangeState { Uninitialized, InitError, Normal, Inverted };
555 public:
556     OptionRange&amp; operator=(int value)
557     {
558         // Only used for initialization to state Uninitialized.
559         // OptionsList specifies OptionRange options with default value 0.
560         RELEASE_ASSERT(!value);
561 
562         m_state = Uninitialized;
563         m_rangeString = 0;
564         m_lowLimit = 0;
565         m_highLimit = 0;
566         return *this;
567     }
568 
569     bool init(const char*);
570     bool isInRange(unsigned);
571     const char* rangeString() const { return (m_state &gt; InitError) ? m_rangeString : s_nullRangeStr; }
572 
573     void dump(PrintStream&amp; out) const;
574 
575 private:
576     static const char* const s_nullRangeStr;
577 
578     RangeState m_state;
579     const char* m_rangeString;
580     unsigned m_lowLimit;
581     unsigned m_highLimit;
582 };
583 
584 struct OptionsStorage {
585     using Bool = bool;
586     using Unsigned = unsigned;
587     using Double = double;
588     using Int32 = int32_t;
589     using Size = size_t;
590     using OptionRange = JSC::OptionRange;
591     using OptionString = const char*;
592     using GCLogLevel = GCLogging::Level;
593 
594 #define DECLARE_OPTION(type_, name_, defaultValue_, availability_, description_) \
595     type_ name_; \
596     type_ name_##Default;
597 FOR_EACH_JSC_OPTION(DECLARE_OPTION)
598 #undef DECLARE_OPTION
599 };
600 
601 // Options::Metadata&#39;s offsetOfOption and offsetOfOptionDefault relies on this.
602 static_assert(sizeof(OptionsStorage) &lt;= 16 * KB);
603 
604 } // namespace JSC
    </pre>
  </body>
</html>
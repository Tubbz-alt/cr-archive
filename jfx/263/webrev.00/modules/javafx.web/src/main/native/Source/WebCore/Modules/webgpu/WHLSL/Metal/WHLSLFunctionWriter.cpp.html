<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;NotImplemented.h&quot;
 32 #include &quot;WHLSLAST.h&quot;
 33 #include &quot;WHLSLEntryPointScaffolding.h&quot;
 34 #include &quot;WHLSLInferTypes.h&quot;
 35 #include &quot;WHLSLNativeFunctionWriter.h&quot;
 36 #include &quot;WHLSLProgram.h&quot;
 37 #include &quot;WHLSLTypeNamer.h&quot;
 38 #include &quot;WHLSLVisitor.h&quot;
 39 #include &lt;wtf/HashMap.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 #include &lt;wtf/SetForScope.h&gt;
 42 #include &lt;wtf/text/StringBuilder.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 namespace WHLSL {
 47 
 48 namespace Metal {
 49 
 50 static void declareFunction(StringBuilder&amp; stringBuilder, AST::FunctionDeclaration&amp; functionDeclaration, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)
 51 {
 52     if (functionDeclaration.entryPointType())
 53         return;
 54 
 55     auto iterator = functionMapping.find(&amp;functionDeclaration);
 56     ASSERT(iterator != functionMapping.end());
 57     stringBuilder.append(typeNamer.mangledNameForType(functionDeclaration.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
 58     for (size_t i = 0; i &lt; functionDeclaration.parameters().size(); ++i) {
 59         if (i)
 60             stringBuilder.append(&quot;, &quot;);
 61         stringBuilder.append(typeNamer.mangledNameForType(*functionDeclaration.parameters()[i]-&gt;type()));
 62     }
 63     stringBuilder.append(&quot;);\n&quot;);
 64 }
 65 
 66 struct Variable {
 67     MangledVariableName name;
 68     MangledTypeName type;
 69 };
 70 
 71 class FunctionDefinitionWriter : public Visitor {
 72     class HoistedVariableCollector : public Visitor {
 73         public:
 74         HoistedVariableCollector(FunctionDefinitionWriter&amp; functionDefinitionWriter)
 75             : functionDefinitionWriter(functionDefinitionWriter)
 76         {
 77         }
 78 
 79         void visit(AST::CallExpression&amp; callExpression) override
 80         {
 81             Vector&lt;Variable&gt; variables;
 82             size_t size = callExpression.arguments().size();
 83             bool isVoid = matches(callExpression.resolvedType(), functionDefinitionWriter.m_intrinsics.voidType());
 84             if (!isVoid)
 85                 ++size;
 86             variables.reserveInitialCapacity(size);
 87 
 88             for (auto&amp; argument : callExpression.arguments()) {
 89                 auto type = functionDefinitionWriter.m_typeNamer.mangledNameForType(argument-&gt;resolvedType());
 90                 auto name = functionDefinitionWriter.generateNextVariableName();
 91                 variables.uncheckedAppend(Variable { name, type });
 92             }
 93 
 94             if (!isVoid)
 95                 variables.uncheckedAppend(Variable { functionDefinitionWriter.generateNextVariableName(), functionDefinitionWriter.m_typeNamer.mangledNameForType(callExpression.resolvedType()) });
 96 
 97             toHoist.add(&amp;callExpression, WTFMove(variables));
 98 
 99             Visitor::visit(callExpression);
100         }
101 
102         void visit(AST::ReadModifyWriteExpression&amp; readModifyWrite) override
103         {
104             Vector&lt;Variable&gt; variables;
105             variables.append(Variable { functionDefinitionWriter.generateNextVariableName(), functionDefinitionWriter.m_typeNamer.mangledNameForType(*readModifyWrite.oldValue().type()) });
106             variables.append(Variable { functionDefinitionWriter.generateNextVariableName(), functionDefinitionWriter.m_typeNamer.mangledNameForType(*readModifyWrite.newValue().type()) });
107 
108             toHoist.add(&amp;readModifyWrite, WTFMove(variables));
109 
110             Visitor::visit(readModifyWrite);
111         }
112 
113         FunctionDefinitionWriter&amp; functionDefinitionWriter;
114         HashMap&lt;AST::Expression*, Vector&lt;Variable&gt;&gt; toHoist;
115     };
116 
117 public:
118     FunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, Layout&amp; layout)
119         : m_stringBuilder(stringBuilder)
120         , m_intrinsics(intrinsics)
121         , m_typeNamer(typeNamer)
122         , m_functionMapping(functionMapping)
123         , m_layout(layout)
124     {
125     }
126 
127     virtual ~FunctionDefinitionWriter() = default;
128 
129     void visit(AST::NativeFunctionDeclaration&amp;) override;
130     void visit(AST::FunctionDefinition&amp;) override;
131 
132 protected:
133     virtual std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) = 0;
134 
135     void visit(AST::FunctionDeclaration&amp;) override;
136     void visit(AST::Statement&amp;) override;
137     void visit(AST::Block&amp;) override;
138     void visit(AST::Break&amp;) override;
139     void visit(AST::Continue&amp;) override;
140     void visit(AST::DoWhileLoop&amp;) override;
141     void visit(AST::EffectfulExpressionStatement&amp;) override;
142     void visit(AST::Fallthrough&amp;) override;
143     void visit(AST::ForLoop&amp;) override;
144     void visit(AST::IfStatement&amp;) override;
145     void visit(AST::Return&amp;) override;
146     void visit(AST::SwitchStatement&amp;) override;
147     void visit(AST::SwitchCase&amp;) override;
148     void visit(AST::VariableDeclarationsStatement&amp;) override;
149     void visit(AST::WhileLoop&amp;) override;
150     void visit(AST::IntegerLiteral&amp;) override;
151     void visit(AST::UnsignedIntegerLiteral&amp;) override;
152     void visit(AST::FloatLiteral&amp;) override;
153     void visit(AST::BooleanLiteral&amp;) override;
154     void visit(AST::EnumerationMemberLiteral&amp;) override;
155     void visit(AST::Expression&amp;) override;
156     void visit(AST::GlobalVariableReference&amp;) override;
157     void visit(AST::DotExpression&amp;) override;
158     void visit(AST::IndexExpression&amp;) override;
159     void visit(AST::VariableDeclaration&amp;) override;
160     void visit(AST::AssignmentExpression&amp;) override;
161     void visit(AST::CallExpression&amp;) override;
162     void visit(AST::CommaExpression&amp;) override;
163     void visit(AST::DereferenceExpression&amp;) override;
164     void visit(AST::LogicalExpression&amp;) override;
165     void visit(AST::LogicalNotExpression&amp;) override;
166     void visit(AST::MakeArrayReferenceExpression&amp;) override;
167     void visit(AST::MakePointerExpression&amp;) override;
168     void visit(AST::ReadModifyWriteExpression&amp;) override;
169     void visit(AST::TernaryExpression&amp;) override;
170     void visit(AST::VariableReference&amp;) override;
171 
172     enum class LoopConditionLocation {
173         BeforeBody,
174         AfterBody
175     };
176     void emitLoop(LoopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body);
177 
178     void emitConstantExpressionString(AST::ConstantExpression&amp;);
179 
180     MangledVariableName generateNextVariableName() { return { m_variableCount++ }; }
181 
182     enum class BreakContext {
183         Loop,
184         Switch
185     };
186 
187     Optional&lt;BreakContext&gt; m_currentBreakContext;
188 
189     StringBuilder&amp; m_stringBuilder;
190     Intrinsics&amp; m_intrinsics;
191     TypeNamer&amp; m_typeNamer;
192     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; m_functionMapping;
193     HashMap&lt;AST::VariableDeclaration*, MangledVariableName&gt; m_variableMapping;
194 
195     std::unique_ptr&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;
196     Layout&amp; m_layout;
197     unsigned m_variableCount { 0 };
198     Optional&lt;MangledVariableName&gt; m_breakOutOfCurrentLoopEarlyVariable;
199     Indentation&lt;4&gt; m_indent { 0 };
200     HashMap&lt;AST::Expression*, Vector&lt;Variable&gt;&gt; m_hoistedVariables;
201 };
202 
203 void FunctionDefinitionWriter::visit(AST::NativeFunctionDeclaration&amp;)
204 {
205     // We inline native function calls.
206 }
207 
208 void FunctionDefinitionWriter::visit(AST::FunctionDefinition&amp; functionDefinition)
209 {
210 
211     {
212         HoistedVariableCollector collector(*this);
213         collector.Visitor::visit(functionDefinition);
214         m_hoistedVariables = WTFMove(collector.toHoist);
215     }
216 
217     auto defineHoistedVariables = [&amp;] {
218         for (const auto&amp; vector : m_hoistedVariables.values()) {
219             for (auto variable : vector)
220                 m_stringBuilder.append(m_indent, variable.type, &#39; &#39;, variable.name, &quot;;\n&quot;);
221         }
222     };
223 
224     auto iterator = m_functionMapping.find(&amp;functionDefinition);
225     ASSERT(iterator != m_functionMapping.end());
226     if (functionDefinition.entryPointType()) {
227         auto entryPointScaffolding = createEntryPointScaffolding(functionDefinition);
228         if (!entryPointScaffolding)
229             return;
230         m_entryPointScaffolding = WTFMove(entryPointScaffolding);
231 
232         m_entryPointScaffolding-&gt;emitHelperTypes(m_stringBuilder, m_indent);
233         m_entryPointScaffolding-&gt;emitSignature(m_stringBuilder, iterator-&gt;value, m_indent);
234         m_stringBuilder.append(m_indent, &quot;{\n&quot;);
235         {
236             IndentationScope scope(m_indent);
237 
238             m_entryPointScaffolding-&gt;emitUnpack(m_stringBuilder, m_indent);
239 
240             for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
241                 auto addResult = m_variableMapping.add(&amp;functionDefinition.parameters()[i], m_entryPointScaffolding-&gt;parameterVariables()[i]);
242                 ASSERT_UNUSED(addResult, addResult.isNewEntry);
243             }
244 
245             defineHoistedVariables();
246 
247             checkErrorAndVisit(functionDefinition.block());
248         }
249         m_stringBuilder.append(&quot;}\n\n&quot;);
250 
251         m_entryPointScaffolding = nullptr;
252     } else {
253         ASSERT(m_entryPointScaffolding == nullptr);
254         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
255         for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
256             if (i)
257                 m_stringBuilder.append(&quot;, &quot;);
258             auto&amp; parameter = functionDefinition.parameters()[i];
259             auto parameterName = generateNextVariableName();
260             auto addResult = m_variableMapping.add(&amp;parameter, parameterName);
261             ASSERT_UNUSED(addResult, addResult.isNewEntry);
262             m_stringBuilder.append(m_typeNamer.mangledNameForType(*parameter-&gt;type()), &#39; &#39;, parameterName);
263         }
264         m_stringBuilder.append(&quot;)\n&quot;);
265 
266         m_stringBuilder.append(&quot;{\n&quot;);
267 
268         defineHoistedVariables();
269 
270         checkErrorAndVisit(functionDefinition.block());
271         m_stringBuilder.append(&quot;}\n&quot;);
272         m_stringBuilder.append(&#39;\n&#39;);
273     }
274 }
275 
276 void FunctionDefinitionWriter::visit(AST::FunctionDeclaration&amp;)
277 {
278     ASSERT_NOT_REACHED();
279 }
280 
281 void FunctionDefinitionWriter::visit(AST::Statement&amp; statement)
282 {
283     Visitor::visit(statement);
284 }
285 
286 void FunctionDefinitionWriter::visit(AST::Block&amp; block)
287 {
288     m_stringBuilder.append(m_indent, &quot;{\n&quot;);
289     {
290         IndentationScope scope(m_indent);
291         for (auto&amp; statement : block.statements())
292             checkErrorAndVisit(statement);
293     }
294     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
295 }
296 
297 void FunctionDefinitionWriter::visit(AST::Break&amp;)
298 {
299     ASSERT(m_currentBreakContext);
300     switch (*m_currentBreakContext) {
301     case BreakContext::Switch:
302         m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
303         break;
304     case BreakContext::Loop:
305         ASSERT(m_breakOutOfCurrentLoopEarlyVariable);
306         m_stringBuilder.append(
307             m_indent, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = true;\n&quot;,
308             m_indent, &quot;break;\n&quot;
309         );
310         break;
311     }
312 }
313 
314 void FunctionDefinitionWriter::visit(AST::Continue&amp;)
315 {
316     ASSERT(m_breakOutOfCurrentLoopEarlyVariable);
317     m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
318 }
319 
320 void FunctionDefinitionWriter::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)
321 {
322     m_stringBuilder.append(m_indent);
323     checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());
324     m_stringBuilder.append(&quot;;\n&quot;);
325 }
326 
327 void FunctionDefinitionWriter::visit(AST::Fallthrough&amp;)
328 {
329     m_stringBuilder.append(m_indent, &quot;[[clang::fallthrough]];\n&quot;); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195808 Make sure this is okay. Alternatively, we could do nothing and just return here instead.
330 }
331 
332 void FunctionDefinitionWriter::emitLoop(LoopConditionLocation loopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body)
333 {
334     SetForScope&lt;Optional&lt;MangledVariableName&gt;&gt; loopVariableScope(m_breakOutOfCurrentLoopEarlyVariable, generateNextVariableName());
335 
336     m_stringBuilder.append(
337         m_indent, &quot;bool &quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = false;\n&quot;,
338         m_indent, &quot;while (true) {\n&quot;
339     );
340     {
341         IndentationScope whileScope(m_indent);
342 
343         if (loopConditionLocation == LoopConditionLocation::BeforeBody &amp;&amp; conditionExpression) {
344             m_stringBuilder.append(
345                 m_indent, &quot;if (!(&quot;);
346             checkErrorAndVisit(*conditionExpression);
347             m_stringBuilder.append(
348                 &quot;))\n&quot;,
349                 &quot;    break;\n&quot;);
350         }
351 
352         m_stringBuilder.append(m_indent, &quot;do {\n&quot;);
353         SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Loop);
354 
355         {
356             IndentationScope doScope(m_indent);
357             checkErrorAndVisit(body);
358         }
359         m_stringBuilder.append(m_indent, &quot;} while(false); \n&quot;);
360 
361         m_stringBuilder.append(
362             m_indent, &quot;if (&quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot;)\n&quot;,
363             m_indent, &quot;    break;\n&quot;);
364 
365         if (increment) {
366             m_stringBuilder.append(&quot;(&quot;);
367             checkErrorAndVisit(*increment);
368             m_stringBuilder.append(&quot;);\n&quot;);
369         }
370 
371         if (loopConditionLocation == LoopConditionLocation::AfterBody &amp;&amp; conditionExpression) {
372             m_stringBuilder.append(
373                 m_indent, &quot;if (!(&quot;);
374             checkErrorAndVisit(*conditionExpression);
375             m_stringBuilder.append(
376                 &quot;))\n&quot;,
377                 &quot;    break;\n&quot;);
378         }
379     }
380 
381     m_stringBuilder.append(m_indent, &quot;} \n&quot;);
382 }
383 
384 void FunctionDefinitionWriter::visit(AST::DoWhileLoop&amp; doWhileLoop)
385 {
386     emitLoop(LoopConditionLocation::AfterBody, &amp;doWhileLoop.conditional(), nullptr, doWhileLoop.body());
387 }
388 
389 void FunctionDefinitionWriter::visit(AST::WhileLoop&amp; whileLoop)
390 {
391     emitLoop(LoopConditionLocation::BeforeBody, &amp;whileLoop.conditional(), nullptr, whileLoop.body());
392 }
393 
394 void FunctionDefinitionWriter::visit(AST::ForLoop&amp; forLoop)
395 {
396     m_stringBuilder.append(m_indent, &quot;{\n&quot;);
397     {
398         IndentationScope scope(m_indent);
399         checkErrorAndVisit(forLoop.initialization());
400         emitLoop(LoopConditionLocation::BeforeBody, forLoop.condition(), forLoop.increment(), forLoop.body());
401     }
402     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
403 }
404 
405 void FunctionDefinitionWriter::visit(AST::IfStatement&amp; ifStatement)
406 {
407     m_stringBuilder.append(m_indent, &quot;if (&quot;);
408     checkErrorAndVisit(ifStatement.conditional());
409     m_stringBuilder.append(&quot;) {\n&quot;);
410 
411     {
412         IndentationScope ifScope(m_indent);
413         checkErrorAndVisit(ifStatement.body());
414     }
415 
416     if (ifStatement.elseBody()) {
417         m_stringBuilder.append(m_indent, &quot;} else {\n&quot;);
418         {
419             IndentationScope elseScope(m_indent);
420             checkErrorAndVisit(*ifStatement.elseBody());
421         }
422     }
423 
424     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
425 }
426 
427 void FunctionDefinitionWriter::visit(AST::Return&amp; returnStatement)
428 {
429     if (returnStatement.value()) {
430         auto tempReturnName = generateNextVariableName();
431         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(returnStatement.value()-&gt;resolvedType()), &#39; &#39;, tempReturnName, &quot; = &quot;);
432         checkErrorAndVisit(*returnStatement.value());
433         m_stringBuilder.append(&quot;;\n&quot;);
434 
435         if (m_entryPointScaffolding) {
436             auto variableName = generateNextVariableName();
437             m_entryPointScaffolding-&gt;emitPack(m_stringBuilder, tempReturnName, variableName, m_indent);
438             m_stringBuilder.append(m_indent, &quot;return &quot;, variableName, &quot;;\n&quot;);
439         } else
440             m_stringBuilder.append(m_indent, &quot;return &quot;, tempReturnName, &quot;;\n&quot;);
441     } else
442         m_stringBuilder.append(m_indent, &quot;return;\n&quot;);
443 }
444 
445 void FunctionDefinitionWriter::visit(AST::SwitchStatement&amp; switchStatement)
446 {
447     m_stringBuilder.append(m_indent, &quot;switch (&quot;);
448     checkErrorAndVisit(switchStatement.value());
449     m_stringBuilder.append(&quot;) {&quot;);
450 
451     {
452         IndentationScope switchScope(m_indent);
453         for (auto&amp; switchCase : switchStatement.switchCases())
454             checkErrorAndVisit(switchCase);
455     }
456     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
457 }
458 
459 void FunctionDefinitionWriter::visit(AST::SwitchCase&amp; switchCase)
460 {
461     if (switchCase.value()) {
462         m_stringBuilder.append(m_indent, &quot;case &quot;);
463         emitConstantExpressionString(*switchCase.value());
464         m_stringBuilder.append(&quot;:\n&quot;);
465     } else
466         m_stringBuilder.append(m_indent, &quot;default:\n&quot;);
467     SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Switch);
468     checkErrorAndVisit(switchCase.block());
469     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195812 Figure out whether we need to break or fallthrough.
470 }
471 
472 void FunctionDefinitionWriter::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)
473 {
474     Visitor::visit(variableDeclarationsStatement);
475 }
476 
477 void FunctionDefinitionWriter::visit(AST::IntegerLiteral&amp; integerLiteral)
478 {
479     auto mangledTypeName = m_typeNamer.mangledNameForType(integerLiteral.resolvedType());
480     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;)&quot;);
481 }
482 
483 void FunctionDefinitionWriter::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
484 {
485     auto mangledTypeName = m_typeNamer.mangledNameForType(unsignedIntegerLiteral.resolvedType());
486     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;)&quot;);
487 }
488 
489 void FunctionDefinitionWriter::visit(AST::FloatLiteral&amp; floatLiteral)
490 {
491     auto mangledTypeName = m_typeNamer.mangledNameForType(floatLiteral.resolvedType());
492     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;)&quot;);
493 }
494 
495 void FunctionDefinitionWriter::visit(AST::BooleanLiteral&amp; booleanLiteral)
496 {
497     auto mangledTypeName = m_typeNamer.mangledNameForType(booleanLiteral.resolvedType());
498     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;)&quot;);
499 }
500 
501 void FunctionDefinitionWriter::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
502 {
503     ASSERT(enumerationMemberLiteral.enumerationDefinition());
504     ASSERT(enumerationMemberLiteral.enumerationDefinition());
505     auto mangledTypeName = m_typeNamer.mangledNameForType(enumerationMemberLiteral.resolvedType());
506     m_stringBuilder.append(mangledTypeName, &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));
507 }
508 
509 void FunctionDefinitionWriter::visit(AST::Expression&amp; expression)
510 {
511     Visitor::visit(expression);
512 }
513 
514 void FunctionDefinitionWriter::visit(AST::GlobalVariableReference&amp; globalVariableReference)
515 {
516     MangledStructureElementName mangledFieldName = m_typeNamer.mangledNameForStructureElement(globalVariableReference.structField());
517     m_stringBuilder.append(&#39;(&#39;);
518     checkErrorAndVisit(globalVariableReference.base());
519     m_stringBuilder.append(&quot;)-&gt;&quot;, mangledFieldName);
520 }
521 
522 void FunctionDefinitionWriter::visit(AST::DotExpression&amp; dotExpression)
523 {
524     auto&amp; type = dotExpression.base().resolvedType().unifyNode();
525 
526     if (is&lt;AST::StructureDefinition&gt;(type)) {
527         auto&amp; structureDefinition = downcast&lt;AST::StructureDefinition&gt;(type);
528         auto* structureElement = structureDefinition.find(dotExpression.fieldName());
529         ASSERT(structureElement);
530         auto elementName = m_typeNamer.mangledNameForStructureElement(*structureElement);
531 
532         m_stringBuilder.append(&#39;(&#39;);
533         checkErrorAndVisit(dotExpression.base());
534         m_stringBuilder.append(&quot;).&quot;, elementName);
535     } else {
536         String elementName = dotExpression.fieldName();
537         if (elementName == &quot;length&quot; &amp;&amp; (is&lt;AST::ArrayReferenceType&gt;(type) || is&lt;AST::ArrayType&gt;(type) || (is&lt;AST::NativeTypeDeclaration&gt;(type) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(type).isVector()))) {
538             if (is&lt;AST::ArrayReferenceType&gt;(type)) {
539                 m_stringBuilder.append(&#39;(&#39;);
540                 checkErrorAndVisit(dotExpression.base());
541                 m_stringBuilder.append(&quot;).length&quot;);
542             } else if (is&lt;AST::ArrayType&gt;(type)) {
543                 m_stringBuilder.append(&#39;(&#39;);
544                 checkErrorAndVisit(dotExpression.base());
545                 m_stringBuilder.append(&quot;, &quot;, downcast&lt;AST::ArrayType&gt;(type).numElements(), &quot;)&quot;);
546             } else {
547                 m_stringBuilder.append(&#39;(&#39;);
548                 checkErrorAndVisit(dotExpression.base());
549                 m_stringBuilder.append(&quot;, &quot;, downcast&lt;AST::NativeTypeDeclaration&gt;(type).vectorSize(), &quot;)&quot;);
550             }
551         } else {
552             m_stringBuilder.append(&#39;(&#39;);
553             checkErrorAndVisit(dotExpression.base());
554             m_stringBuilder.append(&quot;).&quot;, elementName);
555         }
556     }
557 }
558 
559 void FunctionDefinitionWriter::visit(AST::IndexExpression&amp; indexExpression)
560 {
561     auto&amp; type = indexExpression.base().resolvedType().unifyNode();
562     if (is&lt;AST::ArrayReferenceType&gt;(type)) {
563         m_stringBuilder.append(&#39;(&#39;);
564         checkErrorAndVisit(indexExpression.base());
565         m_stringBuilder.append(&quot;).pointer[(&quot;);
566         checkErrorAndVisit(indexExpression.indexExpression());
567         m_stringBuilder.append(&quot;) &lt; (&quot;);
568         checkErrorAndVisit(indexExpression.base());
569         m_stringBuilder.append(&quot;).length ? &quot;);
570         checkErrorAndVisit(indexExpression.indexExpression());
571         m_stringBuilder.append(&quot; : 0]&quot;);
572     } else if (is&lt;AST::ArrayType&gt;(type)) {
573         m_stringBuilder.append(&#39;(&#39;);
574         checkErrorAndVisit(indexExpression.base());
575         m_stringBuilder.append(&quot;).data()[(&quot;);
576         checkErrorAndVisit(indexExpression.indexExpression());
577         m_stringBuilder.append(&quot;) &lt; &quot;, downcast&lt;AST::ArrayType&gt;(type).numElements(), &quot; ? &quot;);
578         checkErrorAndVisit(indexExpression.indexExpression());
579         m_stringBuilder.append(&quot; : 0]&quot;);
580     } else if (is&lt;AST::NativeTypeDeclaration&gt;(type)) {
581         auto&amp; nativeType = downcast&lt;AST::NativeTypeDeclaration&gt;(type);
582         unsigned size;
583         if (nativeType.isMatrix())
584             size = nativeType.numberOfMatrixColumns();
585         else if (nativeType.isVector())
586             size = nativeType.vectorSize();
587         else
588             RELEASE_ASSERT_NOT_REACHED();
589 
590         m_stringBuilder.append(&#39;(&#39;);
591         checkErrorAndVisit(indexExpression.base());
592         m_stringBuilder.append(&quot;)[(&quot;);
593         checkErrorAndVisit(indexExpression.indexExpression());
594         m_stringBuilder.append(&quot; &lt; &quot;, size, &quot;) ? (&quot;);
595         checkErrorAndVisit(indexExpression.indexExpression());
596         m_stringBuilder.append(&quot;) : 0]&quot;);
597     } else
598         RELEASE_ASSERT_NOT_REACHED();
599 }
600 
601 void FunctionDefinitionWriter::visit(AST::VariableDeclaration&amp; variableDeclaration)
602 {
603     ASSERT(variableDeclaration.type());
604     auto variableName = generateNextVariableName();
605     auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);
606     ASSERT_UNUSED(addResult, addResult.isNewEntry);
607     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198160 Implement qualifiers.
608     if (variableDeclaration.initializer()) {
609         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;);
610         checkErrorAndVisit(*variableDeclaration.initializer());
611         m_stringBuilder.append(&quot;;\n&quot;);
612     } else
613         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = { };\n&quot;);
614 }
615 
616 void FunctionDefinitionWriter::visit(AST::AssignmentExpression&amp; assignmentExpression)
617 {
618     m_stringBuilder.append(&#39;(&#39;);
619     checkErrorAndVisit(assignmentExpression.left());
620     m_stringBuilder.append(&#39;)&#39;);
621     m_stringBuilder.append(&quot; = (&quot;);
622     checkErrorAndVisit(assignmentExpression.right());
623     m_stringBuilder.append(&#39;)&#39;);
624 }
625 
626 void FunctionDefinitionWriter::visit(AST::CallExpression&amp; callExpression)
627 {
628     auto iter = m_hoistedVariables.find(&amp;callExpression);
629     RELEASE_ASSERT(iter != m_hoistedVariables.end());
630     auto&amp; variables = iter-&gt;value;
631     RELEASE_ASSERT(callExpression.arguments().size() &lt;= variables.size());
632     Vector&lt;MangledVariableName&gt; argumentNames;
633 
634     MangledVariableName resultName;
635     if (!matches(callExpression.resolvedType(), m_intrinsics.voidType()))
636         resultName = variables.last().name;
637 
638     m_stringBuilder.append(&#39;(&#39;);
639     for (size_t i = 0; i &lt; callExpression.arguments().size(); ++i) {
640         argumentNames.append(variables[i].name);
641         m_stringBuilder.append(variables[i].name, &quot; = (&quot;);
642         checkErrorAndVisit(callExpression.arguments()[i]);
643         m_stringBuilder.append(&quot;), &quot;);
644     }
645 
646     if (is&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function())) {
647         inlineNativeFunction(m_stringBuilder, downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()), argumentNames, resultName, m_typeNamer);
648     } else {
649         auto iterator = m_functionMapping.find(&amp;callExpression.function());
650         ASSERT(iterator != m_functionMapping.end());
651         m_stringBuilder.append(iterator-&gt;value, &#39;(&#39;);
652         for (size_t i = 0; i &lt; callExpression.arguments().size(); ++i) {
653             if (i)
654                 m_stringBuilder.append(&quot;, &quot;);
655             m_stringBuilder.append(variables[i].name);
656         }
657         m_stringBuilder.append(&#39;)&#39;);
658     }
659 
660     m_stringBuilder.append(&#39;)&#39;);
661 }
662 
663 void FunctionDefinitionWriter::visit(AST::CommaExpression&amp; commaExpression)
664 {
665     m_stringBuilder.append(&#39;(&#39;);
666     bool ranOnce = false;
667     for (auto&amp; expression : commaExpression.list()) {
668         if (ranOnce)
669             m_stringBuilder.append(&quot;, &quot;);
670         ranOnce = true;
671         checkErrorAndVisit(expression);
672     }
673     m_stringBuilder.append(&#39;)&#39;);
674 }
675 
676 void FunctionDefinitionWriter::visit(AST::DereferenceExpression&amp; dereferenceExpression)
677 {
678     m_stringBuilder.append(&quot;*(&quot;);
679     checkErrorAndVisit(dereferenceExpression.pointer());
680     m_stringBuilder.append(&#39;)&#39;);
681 }
682 
683 void FunctionDefinitionWriter::visit(AST::LogicalExpression&amp; logicalExpression)
684 {
685     m_stringBuilder.append(&quot;((&quot;);
686     checkErrorAndVisit(logicalExpression.left());
687     m_stringBuilder.append(&#39;)&#39;);
688 
689     switch (logicalExpression.type()) {
690     case AST::LogicalExpression::Type::And:
691         m_stringBuilder.append(&quot; &amp;&amp; &quot;);
692         break;
693     case AST::LogicalExpression::Type::Or:
694         m_stringBuilder.append(&quot; || &quot;);
695         break;
696     }
697 
698     m_stringBuilder.append(&#39;(&#39;);
699     checkErrorAndVisit(logicalExpression.right());
700     m_stringBuilder.append(&quot;))&quot;);
701 }
702 
703 void FunctionDefinitionWriter::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
704 {
705     m_stringBuilder.append(&quot;!(&quot;);
706     checkErrorAndVisit(logicalNotExpression.operand());
707     m_stringBuilder.append(&#39;)&#39;);
708 }
709 
710 void FunctionDefinitionWriter::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
711 {
712     // FIXME: This needs to be made to work. It probably should be using the last leftValue too.
713     // https://bugs.webkit.org/show_bug.cgi?id=198838
714     auto mangledTypeName = m_typeNamer.mangledNameForType(makeArrayReferenceExpression.resolvedType());
715     if (is&lt;AST::PointerType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
716         m_stringBuilder.append(mangledTypeName, &quot;{ &quot;);
717         checkErrorAndVisit(makeArrayReferenceExpression.leftValue());
718         m_stringBuilder.append(&quot;, 1 }&quot;);
719     } else if (is&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
720         auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType());
721         m_stringBuilder.append(mangledTypeName, &quot; { &quot;);
722         checkErrorAndVisit(makeArrayReferenceExpression.leftValue());
723         m_stringBuilder.append(&quot;.data(), &quot;, arrayType.numElements(), &quot; }&quot;);
724     } else {
725         m_stringBuilder.append(mangledTypeName, &quot; { &amp;&quot;);
726         checkErrorAndVisit(makeArrayReferenceExpression.leftValue());
727         m_stringBuilder.append(&quot;, 1 }&quot;);
728     }
729 }
730 
731 void FunctionDefinitionWriter::visit(AST::MakePointerExpression&amp; makePointerExpression)
732 {
733     m_stringBuilder.append(&quot;&amp;(&quot;);
734     checkErrorAndVisit(makePointerExpression.leftValue());
735     m_stringBuilder.append(&#39;)&#39;);
736 }
737 
738 void FunctionDefinitionWriter::visit(AST::ReadModifyWriteExpression&amp; readModifyWrite)
739 {
740     /*
741      *  1. Evaluate m_leftValue
742      *  2. Assign the result to m_oldValue
743      *  3. Evaluate m_newValueExpression
744      *  4. Assign the result to m_newValue
745      *  5. Assign the result to m_leftValue
746      *  6. Evaluate m_resultExpression
747      *  7. Return the result
748      */
749 
750     auto iter = m_hoistedVariables.find(&amp;readModifyWrite);
751     RELEASE_ASSERT(iter != m_hoistedVariables.end());
752     auto&amp; variables = iter-&gt;value;
753     RELEASE_ASSERT(variables.size() == 2);
754 
755     MangledVariableName oldValueVariable = variables[0].name;
756     MangledVariableName newValueVariable = variables[1].name;
757 
758     m_variableMapping.add(&amp;readModifyWrite.oldValue(), oldValueVariable);
759     m_variableMapping.add(&amp;readModifyWrite.newValue(), newValueVariable);
760 
761     m_stringBuilder.append(&#39;(&#39;);
762 
763     m_stringBuilder.append(oldValueVariable, &quot; = &quot;);
764     checkErrorAndVisit(readModifyWrite.leftValue());
765 
766     m_stringBuilder.append(&quot;, &quot;, newValueVariable, &quot; = &quot;);
767     checkErrorAndVisit(readModifyWrite.newValueExpression());
768 
769     m_stringBuilder.append(&quot;, &quot;);
770     checkErrorAndVisit(readModifyWrite.leftValue());
771     m_stringBuilder.append(&quot; = &quot;, newValueVariable, &quot;, &quot;);
772 
773     checkErrorAndVisit(readModifyWrite.resultExpression());
774     m_stringBuilder.append(&#39;)&#39;);
775 }
776 
777 void FunctionDefinitionWriter::visit(AST::TernaryExpression&amp; ternaryExpression)
778 {
779     m_stringBuilder.append(&#39;(&#39;);
780     checkErrorAndVisit(ternaryExpression.predicate());
781     m_stringBuilder.append(&quot;) ? (&quot;);
782     checkErrorAndVisit(ternaryExpression.bodyExpression());
783     m_stringBuilder.append(&quot;) : (&quot;);
784     checkErrorAndVisit(ternaryExpression.elseExpression());
785     m_stringBuilder.append(&#39;)&#39;);
786 }
787 
788 void FunctionDefinitionWriter::visit(AST::VariableReference&amp; variableReference)
789 {
790     ASSERT(variableReference.variable());
791     auto iterator = m_variableMapping.find(variableReference.variable());
792     ASSERT(iterator != m_variableMapping.end());
793 
794     MangledVariableName variableName = iterator-&gt;value;
795     m_stringBuilder.append(variableName);
796 }
797 
798 void FunctionDefinitionWriter::emitConstantExpressionString(AST::ConstantExpression&amp; constantExpression)
799 {
800     constantExpression.visit(WTF::makeVisitor(
801         [&amp;](AST::IntegerLiteral&amp; integerLiteral) {
802             m_stringBuilder.append(integerLiteral.value());
803         },
804         [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
805             m_stringBuilder.append(unsignedIntegerLiteral.value());
806         },
807         [&amp;](AST::FloatLiteral&amp; floatLiteral) {
808             m_stringBuilder.append(floatLiteral.value());
809         },
810         [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {
811             if (booleanLiteral.value())
812                 m_stringBuilder.append(&quot;true&quot;);
813             else
814                 m_stringBuilder.append(&quot;false&quot;);
815         },
816         [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
817             ASSERT(enumerationMemberLiteral.enumerationDefinition());
818             ASSERT(enumerationMemberLiteral.enumerationDefinition());
819             m_stringBuilder.append(m_typeNamer.mangledNameForType(*enumerationMemberLiteral.enumerationDefinition()), &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));
820         }
821     ));
822 }
823 
824 class RenderFunctionDefinitionWriter final : public FunctionDefinitionWriter {
825 public:
826     RenderFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
827         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)
828         , m_matchedSemantics(WTFMove(matchedSemantics))
829     {
830     }
831 
832 private:
833     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;
834 
835     MatchedRenderSemantics m_matchedSemantics;
836 };
837 
838 std::unique_ptr&lt;EntryPointScaffolding&gt; RenderFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)
839 {
840     auto generateNextVariableName = [this]() -&gt; MangledVariableName {
841         return this-&gt;generateNextVariableName();
842     };
843     if (&amp;functionDefinition == m_matchedSemantics.vertexShader)
844         return makeUnique&lt;VertexEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.vertexShaderEntryPointItems, m_matchedSemantics.vertexShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedVertexAttributes);
845     if (&amp;functionDefinition == m_matchedSemantics.fragmentShader)
846         return makeUnique&lt;FragmentEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.fragmentShaderEntryPointItems, m_matchedSemantics.fragmentShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedColorAttachments);
847     return nullptr;
848 }
849 
850 class ComputeFunctionDefinitionWriter final : public FunctionDefinitionWriter {
851 public:
852     ComputeFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
853         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)
854         , m_matchedSemantics(WTFMove(matchedSemantics))
855     {
856     }
857 
858 private:
859     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;
860 
861     MatchedComputeSemantics m_matchedSemantics;
862 };
863 
864 std::unique_ptr&lt;EntryPointScaffolding&gt; ComputeFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)
865 {
866     auto generateNextVariableName = [this]() -&gt; MangledVariableName {
867         return this-&gt;generateNextVariableName();
868     };
869     if (&amp;functionDefinition == m_matchedSemantics.shader)
870         return makeUnique&lt;ComputeEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.entryPointItems, m_matchedSemantics.resourceMap, m_layout, WTFMove(generateNextVariableName));
871     return nullptr;
872 }
873 
874 static HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; generateMetalFunctionsMapping(Program&amp; program)
875 {
876     unsigned numFunctions = 0;
877     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; functionMapping;
878     for (auto&amp; functionDefinition : program.functionDefinitions()) {
879         auto addResult = functionMapping.add(&amp;functionDefinition, MangledFunctionName { numFunctions++ });
880         ASSERT_UNUSED(addResult, addResult.isNewEntry);
881     }
882 
883     return functionMapping;
884 }
885 
886 static void emitSharedMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, const HashSet&lt;AST::FunctionDeclaration*&gt;&amp; reachableFunctions, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)
887 {
888     for (auto&amp; functionDefinition : program.functionDefinitions()) {
889         if (!functionDefinition-&gt;entryPointType() &amp;&amp; reachableFunctions.contains(&amp;functionDefinition))
890             declareFunction(stringBuilder, functionDefinition, typeNamer, functionMapping);
891     }
892 
893     stringBuilder.append(&#39;\n&#39;);
894 }
895 
896 class ReachableFunctionsGatherer final : public Visitor {
897 public:
898     void visit(AST::FunctionDeclaration&amp; functionDeclaration) override
899     {
900         auto result = m_reachableFunctions.add(&amp;functionDeclaration);
901         if (result.isNewEntry)
902             Visitor::visit(functionDeclaration);
903     }
904 
905     void visit(AST::CallExpression&amp; callExpression) override
906     {
907         Visitor::visit(callExpression);
908         if (is&lt;AST::FunctionDefinition&gt;(callExpression.function()))
909             checkErrorAndVisit(downcast&lt;AST::FunctionDefinition&gt;(callExpression.function()));
910         else
911             checkErrorAndVisit(downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()));
912     }
913 
914     HashSet&lt;AST::FunctionDeclaration*&gt; takeReachableFunctions() { return WTFMove(m_reachableFunctions); }
915 
916 private:
917     HashSet&lt;AST::FunctionDeclaration*&gt; m_reachableFunctions;
918 };
919 
920 RenderMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
921 {
922     auto&amp; vertexShaderEntryPoint = *matchedSemantics.vertexShader;
923     auto* fragmentShaderEntryPoint = matchedSemantics.fragmentShader;
924 
925     ReachableFunctionsGatherer reachableFunctionsGatherer;
926     reachableFunctionsGatherer.Visitor::visit(vertexShaderEntryPoint);
927     if (fragmentShaderEntryPoint)
928         reachableFunctionsGatherer.Visitor::visit(*fragmentShaderEntryPoint);
929     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();
930 
931     auto functionMapping = generateMetalFunctionsMapping(program);
932 
933     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);
934 
935     RenderFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);
936     for (auto&amp; functionDefinition : program.functionDefinitions()) {
937         if (reachableFunctions.contains(&amp;functionDefinition))
938             functionDefinitionWriter.visit(functionDefinition);
939     }
940 
941     return { functionMapping.get(&amp;vertexShaderEntryPoint), fragmentShaderEntryPoint ? functionMapping.get(fragmentShaderEntryPoint) : MangledFunctionName { 0 } };
942 }
943 
944 ComputeMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
945 {
946     auto&amp; entryPoint = *matchedSemantics.shader;
947 
948     ReachableFunctionsGatherer reachableFunctionsGatherer;
949     reachableFunctionsGatherer.Visitor::visit(entryPoint);
950     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();
951 
952     auto functionMapping = generateMetalFunctionsMapping(program);
953     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);
954 
955     ComputeFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);
956     for (auto&amp; functionDefinition : program.functionDefinitions()) {
957         if (reachableFunctions.contains(&amp;functionDefinition))
958             functionDefinitionWriter.visit(functionDefinition);
959     }
960 
961     return { functionMapping.get(&amp;entryPoint) };
962 }
963 
964 } // namespace Metal
965 
966 } // namespace WHLSL
967 
968 } // namespace WebCore
969 
970 #endif
    </pre>
  </body>
</html>
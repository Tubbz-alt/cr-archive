<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebGLRenderingContextBase.h&quot;
  28 
  29 #if ENABLE(WEBGL)
  30 
  31 #include &quot;ANGLEInstancedArrays.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;DOMWindow.h&quot;
  34 #include &quot;DiagnosticLoggingClient.h&quot;
  35 #include &quot;DiagnosticLoggingKeys.h&quot;
  36 #include &quot;Document.h&quot;
  37 #include &quot;EXTBlendMinMax.h&quot;
  38 #include &quot;EXTFragDepth.h&quot;
  39 #include &quot;EXTShaderTextureLOD.h&quot;
  40 #include &quot;EXTTextureFilterAnisotropic.h&quot;
  41 #include &quot;EXTsRGB.h&quot;
  42 #include &quot;EventNames.h&quot;
  43 #include &quot;ExtensionsGL.h&quot;
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameLoader.h&quot;
  46 #include &quot;FrameLoaderClient.h&quot;
  47 #include &quot;FrameView.h&quot;
  48 #include &quot;GraphicsContext.h&quot;
  49 #include &quot;HTMLCanvasElement.h&quot;
  50 #include &quot;HTMLImageElement.h&quot;
  51 #include &quot;HTMLVideoElement.h&quot;
  52 #include &quot;ImageBuffer.h&quot;
  53 #include &quot;ImageData.h&quot;
  54 #include &quot;InspectorInstrumentation.h&quot;
  55 #include &quot;IntSize.h&quot;
  56 #include &quot;JSExecState.h&quot;
  57 #include &quot;Logging.h&quot;
  58 #include &quot;NotImplemented.h&quot;
  59 #include &quot;OESElementIndexUint.h&quot;
  60 #include &quot;OESStandardDerivatives.h&quot;
  61 #include &quot;OESTextureFloat.h&quot;
  62 #include &quot;OESTextureFloatLinear.h&quot;
  63 #include &quot;OESTextureHalfFloat.h&quot;
  64 #include &quot;OESTextureHalfFloatLinear.h&quot;
  65 #include &quot;OESVertexArrayObject.h&quot;
  66 #include &quot;Page.h&quot;
  67 #include &quot;RenderBox.h&quot;
  68 #include &quot;RuntimeEnabledFeatures.h&quot;
  69 #include &quot;Settings.h&quot;
  70 #include &quot;WebGL2RenderingContext.h&quot;
  71 #include &quot;WebGLActiveInfo.h&quot;
  72 #include &quot;WebGLBuffer.h&quot;
  73 #include &quot;WebGLCompressedTextureASTC.h&quot;
  74 #include &quot;WebGLCompressedTextureATC.h&quot;
  75 #include &quot;WebGLCompressedTextureETC.h&quot;
  76 #include &quot;WebGLCompressedTextureETC1.h&quot;
  77 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
  78 #include &quot;WebGLCompressedTextureS3TC.h&quot;
  79 #include &quot;WebGLContextAttributes.h&quot;
  80 #include &quot;WebGLContextEvent.h&quot;
  81 #include &quot;WebGLContextGroup.h&quot;
  82 #include &quot;WebGLDebugRendererInfo.h&quot;
  83 #include &quot;WebGLDebugShaders.h&quot;
  84 #include &quot;WebGLDepthTexture.h&quot;
  85 #include &quot;WebGLDrawBuffers.h&quot;
  86 #include &quot;WebGLFramebuffer.h&quot;
  87 #include &quot;WebGLLoseContext.h&quot;
  88 #include &quot;WebGLProgram.h&quot;
  89 #include &quot;WebGLRenderbuffer.h&quot;
  90 #include &quot;WebGLRenderingContext.h&quot;
  91 #include &quot;WebGLShader.h&quot;
  92 #include &quot;WebGLShaderPrecisionFormat.h&quot;
  93 #include &quot;WebGLTexture.h&quot;
  94 #include &quot;WebGLUniformLocation.h&quot;
  95 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
  96 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  97 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  98 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  99 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
 100 #include &lt;JavaScriptCore/Uint32Array.h&gt;
 101 #include &lt;wtf/CheckedArithmetic.h&gt;
 102 #include &lt;wtf/HashMap.h&gt;
 103 #include &lt;wtf/HexNumber.h&gt;
 104 #include &lt;wtf/IsoMallocInlines.h&gt;
 105 #include &lt;wtf/Lock.h&gt;
 106 #include &lt;wtf/StdLibExtras.h&gt;
 107 #include &lt;wtf/UniqueArray.h&gt;
 108 #include &lt;wtf/text/CString.h&gt;
 109 #include &lt;wtf/text/StringBuilder.h&gt;
 110 
 111 #if ENABLE(OFFSCREEN_CANVAS)
 112 #include &quot;OffscreenCanvas.h&quot;
 113 #endif
 114 
 115 namespace WebCore {
 116 
 117 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContextBase);
 118 
 119 static const Seconds secondsBetweenRestoreAttempts { 1_s };
 120 const int maxGLErrorsAllowedToConsole = 256;
 121 static const Seconds checkContextLossHandlingDelay { 3_s };
 122 
 123 namespace {
 124 
 125     GCGLint clamp(GCGLint value, GCGLint min, GCGLint max)
 126     {
 127         if (value &lt; min)
 128             value = min;
 129         if (value &gt; max)
 130             value = max;
 131         return value;
 132     }
 133 
 134     // Return true if a character belongs to the ASCII subset as defined in
 135     // GLSL ES 1.0 spec section 3.1.
 136     bool validateCharacter(unsigned char c)
 137     {
 138         // Printing characters are valid except &quot; $ ` @ \ &#39; DEL.
 139         if (c &gt;= 32 &amp;&amp; c &lt;= 126
 140             &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;$&#39; &amp;&amp; c != &#39;`&#39; &amp;&amp; c != &#39;@&#39; &amp;&amp; c != &#39;\\&#39; &amp;&amp; c != &#39;\&#39;&#39;)
 141             return true;
 142         // Horizontal tab, line feed, vertical tab, form feed, carriage return
 143         // are also valid.
 144         if (c &gt;= 9 &amp;&amp; c &lt;= 13)
 145             return true;
 146         return false;
 147     }
 148 
 149     bool isPrefixReserved(const String&amp; name)
 150     {
 151         if (name.startsWith(&quot;gl_&quot;) || name.startsWith(&quot;webgl_&quot;) || name.startsWith(&quot;_webgl_&quot;))
 152             return true;
 153         return false;
 154     }
 155 
 156     // Strips comments from shader text. This allows non-ASCII characters
 157     // to be used in comments without potentially breaking OpenGL
 158     // implementations not expecting characters outside the GLSL ES set.
 159     class StripComments {
 160     public:
 161         StripComments(const String&amp; str)
 162             : m_parseState(BeginningOfLine)
 163             , m_sourceString(str)
 164             , m_length(str.length())
 165             , m_position(0)
 166         {
 167             parse();
 168         }
 169 
 170         String result()
 171         {
 172             return m_builder.toString();
 173         }
 174 
 175     private:
 176         bool hasMoreCharacters() const
 177         {
 178             return (m_position &lt; m_length);
 179         }
 180 
 181         void parse()
 182         {
 183             while (hasMoreCharacters()) {
 184                 process(current());
 185                 // process() might advance the position.
 186                 if (hasMoreCharacters())
 187                     advance();
 188             }
 189         }
 190 
 191         void process(UChar);
 192 
 193         bool peek(UChar&amp; character) const
 194         {
 195             if (m_position + 1 &gt;= m_length)
 196                 return false;
 197             character = m_sourceString[m_position + 1];
 198             return true;
 199         }
 200 
 201         UChar current() const
 202         {
 203             ASSERT_WITH_SECURITY_IMPLICATION(m_position &lt; m_length);
 204             return m_sourceString[m_position];
 205         }
 206 
 207         void advance()
 208         {
 209             ++m_position;
 210         }
 211 
 212         bool isNewline(UChar character) const
 213         {
 214             // Don&#39;t attempt to canonicalize newline related characters.
 215             return (character == &#39;\n&#39; || character == &#39;\r&#39;);
 216         }
 217 
 218         void emit(UChar character)
 219         {
 220             m_builder.append(character);
 221         }
 222 
 223         enum ParseState {
 224             // Have not seen an ASCII non-whitespace character yet on
 225             // this line. Possible that we might see a preprocessor
 226             // directive.
 227             BeginningOfLine,
 228 
 229             // Have seen at least one ASCII non-whitespace character
 230             // on this line.
 231             MiddleOfLine,
 232 
 233             // Handling a preprocessor directive. Passes through all
 234             // characters up to the end of the line. Disables comment
 235             // processing.
 236             InPreprocessorDirective,
 237 
 238             // Handling a single-line comment. The comment text is
 239             // replaced with a single space.
 240             InSingleLineComment,
 241 
 242             // Handling a multi-line comment. Newlines are passed
 243             // through to preserve line numbers.
 244             InMultiLineComment
 245         };
 246 
 247         ParseState m_parseState;
 248         String m_sourceString;
 249         unsigned m_length;
 250         unsigned m_position;
 251         StringBuilder m_builder;
 252     };
 253 
 254     void StripComments::process(UChar c)
 255     {
 256         if (isNewline(c)) {
 257             // No matter what state we are in, pass through newlines
 258             // so we preserve line numbers.
 259             emit(c);
 260 
 261             if (m_parseState != InMultiLineComment)
 262                 m_parseState = BeginningOfLine;
 263 
 264             return;
 265         }
 266 
 267         UChar temp = 0;
 268         switch (m_parseState) {
 269         case BeginningOfLine:
 270             if (WTF::isASCIISpace(c)) {
 271                 emit(c);
 272                 break;
 273             }
 274 
 275             if (c == &#39;#&#39;) {
 276                 m_parseState = InPreprocessorDirective;
 277                 emit(c);
 278                 break;
 279             }
 280 
 281             // Transition to normal state and re-handle character.
 282             m_parseState = MiddleOfLine;
 283             process(c);
 284             break;
 285 
 286         case MiddleOfLine:
 287             if (c == &#39;/&#39; &amp;&amp; peek(temp)) {
 288                 if (temp == &#39;/&#39;) {
 289                     m_parseState = InSingleLineComment;
 290                     emit(&#39; &#39;);
 291                     advance();
 292                     break;
 293                 }
 294 
 295                 if (temp == &#39;*&#39;) {
 296                     m_parseState = InMultiLineComment;
 297                     // Emit the comment start in case the user has
 298                     // an unclosed comment and we want to later
 299                     // signal an error.
 300                     emit(&#39;/&#39;);
 301                     emit(&#39;*&#39;);
 302                     advance();
 303                     break;
 304                 }
 305             }
 306 
 307             emit(c);
 308             break;
 309 
 310         case InPreprocessorDirective:
 311             // No matter what the character is, just pass it
 312             // through. Do not parse comments in this state. This
 313             // might not be the right thing to do long term, but it
 314             // should handle the #error preprocessor directive.
 315             emit(c);
 316             break;
 317 
 318         case InSingleLineComment:
 319             // The newline code at the top of this function takes care
 320             // of resetting our state when we get out of the
 321             // single-line comment. Swallow all other characters.
 322             break;
 323 
 324         case InMultiLineComment:
 325             if (c == &#39;*&#39; &amp;&amp; peek(temp) &amp;&amp; temp == &#39;/&#39;) {
 326                 emit(&#39;*&#39;);
 327                 emit(&#39;/&#39;);
 328                 m_parseState = MiddleOfLine;
 329                 advance();
 330                 break;
 331             }
 332 
 333             // Swallow all other characters. Unclear whether we may
 334             // want or need to just emit a space per character to try
 335             // to preserve column numbers for debugging purposes.
 336             break;
 337         }
 338     }
 339 } // namespace anonymous
 340 
 341 // Returns false if no clipping is necessary, i.e., x, y, width, height stay the same.
 342 static bool clip2D(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height,
 343     GCGLsizei sourceWidth, GCGLsizei sourceHeight,
 344     GCGLint* clippedX, GCGLint* clippedY, GCGLsizei* clippedWidth, GCGLsizei*clippedHeight)
 345 {
 346     ASSERT(clippedX &amp;&amp; clippedY &amp;&amp; clippedWidth &amp;&amp; clippedHeight);
 347 
 348     GCGLint left = std::max(x, 0);
 349     GCGLint top = std::max(y, 0);
 350     GCGLint right = 0;
 351     GCGLint bottom = 0;
 352 
 353     Checked&lt;GCGLint, RecordOverflow&gt; checkedInputRight = Checked&lt;GCGLint&gt;(x) + Checked&lt;GCGLsizei&gt;(width);
 354     Checked&lt;GCGLint, RecordOverflow&gt; checkedInputBottom = Checked&lt;GCGLint&gt;(y) + Checked&lt;GCGLsizei&gt;(height);
 355     if (!checkedInputRight.hasOverflowed() &amp;&amp; !checkedInputBottom.hasOverflowed()) {
 356         right = std::min(checkedInputRight.unsafeGet(), sourceWidth);
 357         bottom = std::min(checkedInputBottom.unsafeGet(), sourceHeight);
 358     }
 359 
 360     if (left &gt;= right || top &gt;= bottom) {
 361         *clippedX = 0;
 362         *clippedY = 0;
 363         *clippedWidth = 0;
 364         *clippedHeight = 0;
 365         return true;
 366     }
 367 
 368     *clippedX = left;
 369     *clippedY = top;
 370     *clippedWidth = right - left;
 371     *clippedHeight = bottom - top;
 372 
 373     return (*clippedX != x || *clippedY != y || *clippedWidth != width || *clippedHeight != height);
 374 }
 375 
 376 class InspectorScopedShaderProgramHighlight {
 377 public:
 378     InspectorScopedShaderProgramHighlight(WebGLRenderingContextBase&amp; context, WebGLProgram* program)
 379         : m_context(context)
 380         , m_program(program)
 381     {
 382         showHightlight();
 383     }
 384 
 385     ~InspectorScopedShaderProgramHighlight()
 386     {
 387         hideHighlight();
 388     }
 389 
 390 private:
 391     void showHightlight()
 392     {
 393         if (!m_program || LIKELY(!InspectorInstrumentation::isWebGLProgramHighlighted(m_context, *m_program)))
 394             return;
 395 
 396         if (hasBufferBinding(GraphicsContextGL::FRAMEBUFFER_BINDING)) {
 397             if (!hasBufferBinding(GraphicsContextGL::RENDERBUFFER_BINDING))
 398                 return;
 399             if (hasFramebufferParameterAttachment(GraphicsContextGL::DEPTH_ATTACHMENT))
 400                 return;
 401             if (hasFramebufferParameterAttachment(GraphicsContextGL::STENCIL_ATTACHMENT))
 402                 return;
 403 #if ENABLE(WEBGL2)
 404             if (hasFramebufferParameterAttachment(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT))
 405                 return;
 406 #endif
 407         }
 408 
 409         saveBlendValue(GraphicsContextGL::BLEND_COLOR, m_savedBlend.color);
 410         saveBlendValue(GraphicsContextGL::BLEND_EQUATION_RGB, m_savedBlend.equationRGB);
 411         saveBlendValue(GraphicsContextGL::BLEND_EQUATION_ALPHA, m_savedBlend.equationAlpha);
 412         saveBlendValue(GraphicsContextGL::BLEND_SRC_RGB, m_savedBlend.srcRGB);
 413         saveBlendValue(GraphicsContextGL::BLEND_SRC_ALPHA, m_savedBlend.srcAlpha);
 414         saveBlendValue(GraphicsContextGL::BLEND_DST_RGB, m_savedBlend.dstRGB);
 415         saveBlendValue(GraphicsContextGL::BLEND_DST_ALPHA, m_savedBlend.dstAlpha);
 416         saveBlendValue(GraphicsContextGL::BLEND, m_savedBlend.enabled);
 417 
 418         static const GCGLfloat red = 111.0 / 255.0;
 419         static const GCGLfloat green = 168.0 / 255.0;
 420         static const GCGLfloat blue = 220.0 / 255.0;
 421         static const GCGLfloat alpha = 2.0 / 3.0;
 422 
 423         m_context.enable(GraphicsContextGL::BLEND);
 424         m_context.blendColor(red, green, blue, alpha);
 425         m_context.blendEquation(GraphicsContextGL::FUNC_ADD);
 426         m_context.blendFunc(GraphicsContextGL::CONSTANT_COLOR, GraphicsContextGL::ONE_MINUS_SRC_ALPHA);
 427 
 428         m_didApply = true;
 429     }
 430 
 431     void hideHighlight()
 432     {
 433         if (!m_didApply)
 434             return;
 435 
 436         if (!m_savedBlend.enabled)
 437             m_context.disable(GraphicsContextGL::BLEND);
 438 
 439         const RefPtr&lt;Float32Array&gt;&amp; color = m_savedBlend.color;
 440         m_context.blendColor(color-&gt;item(0), color-&gt;item(1), color-&gt;item(2), color-&gt;item(3));
 441         m_context.blendEquationSeparate(m_savedBlend.equationRGB, m_savedBlend.equationAlpha);
 442         m_context.blendFuncSeparate(m_savedBlend.srcRGB, m_savedBlend.dstRGB, m_savedBlend.srcAlpha, m_savedBlend.dstAlpha);
 443 
 444         m_savedBlend.color = nullptr;
 445 
 446         m_didApply = false;
 447     }
 448 
 449     template &lt;typename T&gt;
 450     void saveBlendValue(GCGLenum attachment, T&amp; destination)
 451     {
 452         WebGLAny param = m_context.getParameter(attachment);
 453         if (WTF::holds_alternative&lt;T&gt;(param))
 454             destination = WTF::get&lt;T&gt;(param);
 455     }
 456 
 457     bool hasBufferBinding(GCGLenum pname)
 458     {
 459         WebGLAny binding = m_context.getParameter(pname);
 460         if (pname == GraphicsContextGL::FRAMEBUFFER_BINDING)
 461             return WTF::holds_alternative&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding);
 462         if (pname == GraphicsContextGL::RENDERBUFFER_BINDING)
 463             return WTF::holds_alternative&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding);
 464         return false;
 465     }
 466 
 467     bool hasFramebufferParameterAttachment(GCGLenum attachment)
 468     {
 469         WebGLAny attachmentParameter = m_context.getFramebufferAttachmentParameter(GraphicsContextGL::FRAMEBUFFER, attachment, GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE);
 470         if (!WTF::holds_alternative&lt;unsigned&gt;(attachmentParameter))
 471             return false;
 472         if (WTF::get&lt;unsigned&gt;(attachmentParameter) != static_cast&lt;unsigned&gt;(GraphicsContextGL::RENDERBUFFER))
 473             return false;
 474         return true;
 475     }
 476 
 477     struct {
 478         RefPtr&lt;Float32Array&gt; color;
 479         unsigned equationRGB { 0 };
 480         unsigned equationAlpha { 0 };
 481         unsigned srcRGB { 0 };
 482         unsigned srcAlpha { 0 };
 483         unsigned dstRGB { 0 };
 484         unsigned dstAlpha { 0 };
 485         bool enabled { false };
 486     } m_savedBlend;
 487 
 488     WebGLRenderingContextBase&amp; m_context;
 489     WebGLProgram* m_program { nullptr };
 490     bool m_didApply { false };
 491 };
 492 
 493 static bool isHighPerformanceContext(const RefPtr&lt;GraphicsContextGLOpenGL&gt;&amp; context)
 494 {
 495     return context-&gt;powerPreferenceUsedForCreation() == WebGLPowerPreference::HighPerformance;
 496 }
 497 
 498 std::unique_ptr&lt;WebGLRenderingContextBase&gt; WebGLRenderingContextBase::create(CanvasBase&amp; canvas, WebGLContextAttributes&amp; attributes, const String&amp; type)
 499 {
 500 #if ENABLE(WEBGL2)
 501     if (type == &quot;webgl2&quot; &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().webGL2Enabled())
 502         return nullptr;
 503 #else
 504     UNUSED_PARAM(type);
 505 #endif
 506 
 507     bool isPendingPolicyResolution = false;
 508     HostWindow* hostWindow = nullptr;
 509 
 510     auto* canvasElement = is&lt;HTMLCanvasElement&gt;(canvas) ? &amp;downcast&lt;HTMLCanvasElement&gt;(canvas) : nullptr;
 511 
 512     if (canvasElement) {
 513         Document&amp; document = canvasElement-&gt;document();
 514         RefPtr&lt;Frame&gt; frame = document.frame();
 515         if (!frame)
 516             return nullptr;
 517 
 518         // The FrameLoaderClient might block creation of a new WebGL context despite the page settings; in
 519         // particular, if WebGL contexts were lost one or more times via the GL_ARB_robustness extension.
 520         if (!frame-&gt;loader().client().allowWebGL(frame-&gt;settings().webGLEnabled())) {
 521             canvasElement-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextcreationerrorEvent,
 522                 Event::CanBubble::No, Event::IsCancelable::Yes, &quot;Web page was not allowed to create a WebGL context.&quot;));
 523             return nullptr;
 524         }
 525 
 526         Document&amp; topDocument = document.topDocument();
 527         Page* page = topDocument.page();
 528         bool forcingPendingPolicy = frame-&gt;settings().isForcePendingWebGLPolicy();
 529 
 530         if (forcingPendingPolicy || (page &amp;&amp; !topDocument.url().isLocalFile())) {
 531             WebGLLoadPolicy policy = forcingPendingPolicy ? WebGLPendingCreation : page-&gt;mainFrame().loader().client().webGLPolicyForURL(topDocument.url());
 532 
 533             if (policy == WebGLBlockCreation) {
 534                 LOG(WebGL, &quot;The policy for this URL (%s) is to block WebGL.&quot;, topDocument.url().host().utf8().data());
 535                 return nullptr;
 536             }
 537 
 538             if (policy == WebGLPendingCreation) {
 539                 LOG(WebGL, &quot;WebGL policy is pending. May need to be resolved later.&quot;);
 540                 isPendingPolicyResolution = true;
 541             }
 542         }
 543 
 544         if (frame-&gt;settings().forceWebGLUsesLowPower()) {
 545             if (attributes.powerPreference == GraphicsContextGLPowerPreference::HighPerformance)
 546                 LOG(WebGL, &quot;Overriding powerPreference from high-performance to low-power.&quot;);
 547             attributes.powerPreference = GraphicsContextGLPowerPreference::LowPower;
 548         }
 549 
 550         if (page)
 551             attributes.devicePixelRatio = page-&gt;deviceScaleFactor();
 552 
 553         hostWindow = document.view()-&gt;root()-&gt;hostWindow();
 554     }
 555 
 556     attributes.noExtensions = true;
 557     attributes.shareResources = false;
 558 
 559     attributes.initialPowerPreference = attributes.powerPreference;
 560 
 561 
 562 #if ENABLE(WEBGL2)
 563     if (type == &quot;webgl2&quot;)
 564         attributes.isWebGL2 = true;
 565 #endif
 566 
 567     if (isPendingPolicyResolution) {
 568         LOG(WebGL, &quot;Create a WebGL context that looks real, but will require a policy resolution if used.&quot;);
 569         std::unique_ptr&lt;WebGLRenderingContextBase&gt; renderingContext = nullptr;
 570 #if ENABLE(WEBGL2)
 571         if (type == &quot;webgl2&quot;)
 572             renderingContext = WebGL2RenderingContext::create(canvas, attributes);
 573         else
 574 #endif
 575             renderingContext = WebGLRenderingContext::create(canvas, attributes);
 576         renderingContext-&gt;suspendIfNeeded();
 577         return renderingContext;
 578     }
 579 
 580     auto context = GraphicsContextGLOpenGL::create(attributes, hostWindow);
 581     if (!context || !context-&gt;makeContextCurrent()) {
 582         if (canvasElement) {
 583             canvasElement-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextcreationerrorEvent,
 584                 Event::CanBubble::No, Event::IsCancelable::Yes, &quot;Could not create a WebGL context.&quot;));
 585         }
 586         return nullptr;
 587     }
 588 
 589     auto&amp; extensions = context-&gt;getExtensions();
 590     if (extensions.supports(&quot;GL_EXT_debug_marker&quot;_s))
 591         extensions.pushGroupMarkerEXT(&quot;WebGLRenderingContext&quot;_s);
 592 
 593 #if ENABLE(WEBGL2) &amp;&amp; PLATFORM(MAC) &amp;&amp; !USE(ANGLE)
 594     // glTexStorage() was only added to Core in OpenGL 4.2.
 595     // However, according to https://developer.apple.com/opengl/capabilities/ all Apple GPUs support this extension.
 596     if (attributes.isWebGL2 &amp;&amp; !extensions.supports(&quot;GL_ARB_texture_storage&quot;))
 597         return nullptr;
 598 #endif
 599 
 600     std::unique_ptr&lt;WebGLRenderingContextBase&gt; renderingContext;
 601 #if ENABLE(WEBGL2)
 602     if (type == &quot;webgl2&quot;)
 603         renderingContext = WebGL2RenderingContext::create(canvas, context.releaseNonNull(), attributes);
 604     else
 605 #endif
 606         renderingContext = WebGLRenderingContext::create(canvas, context.releaseNonNull(), attributes);
 607     renderingContext-&gt;suspendIfNeeded();
 608 
 609     return renderingContext;
 610 }
 611 
 612 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, WebGLContextAttributes attributes)
 613     : GPUBasedCanvasRenderingContext(canvas)
 614     , m_dispatchContextLostEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)
 615     , m_dispatchContextChangedEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextChangedEvent)
 616     , m_restoreTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::maybeRestoreContext)
 617     , m_attributes(attributes)
 618     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 619     , m_isPendingPolicyResolution(true)
 620     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 621 {
 622     m_dispatchContextLostEventTimer.suspendIfNeeded();
 623     m_dispatchContextChangedEventTimer.suspendIfNeeded();
 624     m_restoreTimer.suspendIfNeeded();
 625 
 626     registerWithWebGLStateTracker();
 627     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 628 }
 629 
 630 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, WebGLContextAttributes attributes)
 631     : GPUBasedCanvasRenderingContext(canvas)
 632     , m_context(WTFMove(context))
 633     , m_dispatchContextLostEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)
 634     , m_dispatchContextChangedEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextChangedEvent)
 635     , m_restoreTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::maybeRestoreContext)
 636     , m_generatedImageCache(4)
 637     , m_attributes(attributes)
 638     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 639     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 640 {
 641     m_dispatchContextLostEventTimer.suspendIfNeeded();
 642     m_dispatchContextChangedEventTimer.suspendIfNeeded();
 643     m_restoreTimer.suspendIfNeeded();
 644 
 645     m_contextGroup = WebGLContextGroup::create();
 646     m_contextGroup-&gt;addContext(*this);
 647 
 648     m_context-&gt;addClient(*this);
 649 
 650     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_VIEWPORT_DIMS, m_maxViewportDims);
 651 
 652     setupFlags();
 653     initializeNewContext();
 654     registerWithWebGLStateTracker();
 655     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 656 
 657     addActivityStateChangeObserverIfNecessary();
 658 }
 659 
 660 WebGLCanvas WebGLRenderingContextBase::canvas()
 661 {
 662     auto&amp; base = canvasBase();
 663 #if ENABLE(OFFSCREEN_CANVAS)
 664     if (is&lt;OffscreenCanvas&gt;(base))
 665         return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 666 #endif
 667     return &amp;downcast&lt;HTMLCanvasElement&gt;(base);
 668 }
 669 
 670 #if ENABLE(OFFSCREEN_CANVAS)
 671 OffscreenCanvas* WebGLRenderingContextBase::offscreenCanvas()
 672 {
 673     auto&amp; base = canvasBase();
 674     if (!is&lt;OffscreenCanvas&gt;(base))
 675         return nullptr;
 676     return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 677 }
 678 #endif
 679 
 680 // We check for context loss handling after a few seconds to give the JS a chance to register the event listeners
 681 // and to discard temporary GL contexts (e.g. feature detection).
 682 void WebGLRenderingContextBase::checkForContextLossHandling()
 683 {
 684     auto canvas = htmlCanvas();
 685     if (!canvas)
 686         return;
 687 
 688     if (!canvas-&gt;renderer())
 689         return;
 690 
 691     auto* page = canvas-&gt;document().page();
 692     if (!page)
 693         return;
 694 
 695     bool handlesContextLoss = canvas-&gt;hasEventListeners(eventNames().webglcontextlostEvent) &amp;&amp; canvas-&gt;hasEventListeners(eventNames().webglcontextrestoredEvent);
 696     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::pageHandlesWebGLContextLossKey(), handlesContextLoss ? DiagnosticLoggingKeys::yesKey() : DiagnosticLoggingKeys::noKey(), ShouldSample::No);
 697 }
 698 
 699 void WebGLRenderingContextBase::registerWithWebGLStateTracker()
 700 {
 701     auto canvas = htmlCanvas();
 702     if (!canvas)
 703         return;
 704 
 705     auto* page = canvas-&gt;document().page();
 706     if (!page)
 707         return;
 708 
 709     auto* tracker = page-&gt;webGLStateTracker();
 710     if (!tracker)
 711         return;
 712 
 713     m_trackerToken = tracker-&gt;token(m_attributes.initialPowerPreference);
 714 }
 715 
 716 void WebGLRenderingContextBase::initializeNewContext()
 717 {
 718     ASSERT(!m_contextLost);
 719     m_needsUpdate = true;
 720     m_markedCanvasDirty = false;
 721     m_activeTextureUnit = 0;
 722     m_packAlignment = 4;
 723     m_unpackAlignment = 4;
 724     m_unpackFlipY = false;
 725     m_unpackPremultiplyAlpha = false;
 726     m_unpackColorspaceConversion = GraphicsContextGL::BROWSER_DEFAULT_WEBGL;
 727     m_boundArrayBuffer = nullptr;
 728     m_currentProgram = nullptr;
 729     m_framebufferBinding = nullptr;
 730     m_readFramebufferBinding = nullptr;
 731     m_renderbufferBinding = nullptr;
 732     m_depthMask = true;
 733     m_stencilEnabled = false;
 734     m_stencilMask = 0xFFFFFFFF;
 735     m_stencilMaskBack = 0xFFFFFFFF;
 736     m_stencilFuncRef = 0;
 737     m_stencilFuncRefBack = 0;
 738     m_stencilFuncMask = 0xFFFFFFFF;
 739     m_stencilFuncMaskBack = 0xFFFFFFFF;
 740     m_layerCleared = false;
 741     m_numGLErrorsToConsoleAllowed = maxGLErrorsAllowedToConsole;
 742 
 743     m_clearColor[0] = m_clearColor[1] = m_clearColor[2] = m_clearColor[3] = 0;
 744     m_scissorEnabled = false;
 745     m_clearDepth = 1;
 746     m_clearStencil = 0;
 747     m_colorMask[0] = m_colorMask[1] = m_colorMask[2] = m_colorMask[3] = true;
 748 
 749     GCGLint numCombinedTextureImageUnits = 0;
 750     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_COMBINED_TEXTURE_IMAGE_UNITS, &amp;numCombinedTextureImageUnits);
 751     m_textureUnits.clear();
 752     m_textureUnits.resize(numCombinedTextureImageUnits);
 753     for (GCGLint i = 0; i &lt; numCombinedTextureImageUnits; ++i)
 754         m_unrenderableTextureUnits.add(i);
 755 
 756     GCGLint numVertexAttribs = 0;
 757     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_VERTEX_ATTRIBS, &amp;numVertexAttribs);
 758     m_maxVertexAttribs = numVertexAttribs;
 759 
 760     m_maxTextureSize = 0;
 761     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_TEXTURE_SIZE, &amp;m_maxTextureSize);
 762     m_maxTextureLevel = WebGLTexture::computeLevelCount(m_maxTextureSize, m_maxTextureSize);
 763     m_maxCubeMapTextureSize = 0;
 764     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_CUBE_MAP_TEXTURE_SIZE, &amp;m_maxCubeMapTextureSize);
 765     m_maxCubeMapTextureLevel = WebGLTexture::computeLevelCount(m_maxCubeMapTextureSize, m_maxCubeMapTextureSize);
 766     m_maxRenderbufferSize = 0;
 767     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_RENDERBUFFER_SIZE, &amp;m_maxRenderbufferSize);
 768 
 769     // These two values from EXT_draw_buffers are lazily queried.
 770     m_maxDrawBuffers = 0;
 771     m_maxColorAttachments = 0;
 772 
 773     m_backDrawBuffer = GraphicsContextGL::BACK;
 774     m_drawBuffersWebGLRequirementsChecked = false;
 775     m_drawBuffersSupported = false;
 776 
 777     m_vertexAttribValue.resize(m_maxVertexAttribs);
 778 
 779     if (!isGLES2NPOTStrict())
 780         createFallbackBlackTextures1x1();
 781 
 782     IntSize canvasSize = clampedCanvasSize();
 783     m_context-&gt;reshape(canvasSize.width(), canvasSize.height());
 784     m_context-&gt;viewport(0, 0, canvasSize.width(), canvasSize.height());
 785     m_context-&gt;scissor(0, 0, canvasSize.width(), canvasSize.height());
 786 }
 787 
 788 void WebGLRenderingContextBase::setupFlags()
 789 {
 790     ASSERT(m_context);
 791 
 792     auto canvas = htmlCanvas();
 793     if (canvas) {
 794         if (Page* page = canvas-&gt;document().page())
 795             m_synthesizedErrorsToConsole = page-&gt;settings().webGLErrorsToConsoleEnabled();
 796     }
 797 
 798     m_isGLES2Compliant = m_context-&gt;isGLES2Compliant();
 799     if (m_isGLES2Compliant) {
 800         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_texture_npot&quot;);
 801         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_packed_depth_stencil&quot;) || m_context-&gt;getExtensions().isEnabled(&quot;GL_ANGLE_depth_texture&quot;);
 802     } else {
 803         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_ARB_texture_non_power_of_two&quot;);
 804         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_packed_depth_stencil&quot;) || m_context-&gt;getExtensions().isEnabled(&quot;GL_ANGLE_depth_texture&quot;);
 805     }
 806     m_isRobustnessEXTSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_robustness&quot;);
 807 }
 808 
 809 void WebGLRenderingContextBase::addCompressedTextureFormat(GCGLenum format)
 810 {
 811     if (!m_compressedTextureFormats.contains(format))
 812         m_compressedTextureFormats.append(format);
 813 }
 814 
 815 void WebGLRenderingContextBase::addActivityStateChangeObserverIfNecessary()
 816 {
 817     // We are only interested in visibility changes for contexts
 818     // that are using the high-performance GPU.
 819     if (!isHighPerformanceContext(m_context))
 820         return;
 821 
 822     auto* canvas = htmlCanvas();
 823     if (!canvas)
 824         return;
 825 
 826     auto* page = canvas-&gt;document().page();
 827     if (!page)
 828         return;
 829 
 830     page-&gt;addActivityStateChangeObserver(*this);
 831 
 832     // We won&#39;t get a state change right away, so
 833     // make sure the context knows if it visible or not.
 834     if (m_context)
 835         m_context-&gt;setContextVisibility(page-&gt;isVisible());
 836 }
 837 
 838 void WebGLRenderingContextBase::removeActivityStateChangeObserver()
 839 {
 840     auto* canvas = htmlCanvas();
 841     if (canvas) {
 842         if (auto* page = canvas-&gt;document().page())
 843             page-&gt;removeActivityStateChangeObserver(*this);
 844     }
 845 }
 846 
 847 WebGLRenderingContextBase::~WebGLRenderingContextBase()
 848 {
 849     // Remove all references to WebGLObjects so if they are the last reference
 850     // they will be freed before the last context is removed from the context group.
 851     m_boundArrayBuffer = nullptr;
 852     m_defaultVertexArrayObject = nullptr;
 853     m_boundVertexArrayObject = nullptr;
 854     m_vertexAttrib0Buffer = nullptr;
 855     m_currentProgram = nullptr;
 856     m_framebufferBinding = nullptr;
 857     m_readFramebufferBinding = nullptr;
 858     m_renderbufferBinding = nullptr;
 859 
 860     for (auto&amp; textureUnit : m_textureUnits) {
 861         textureUnit.texture2DBinding = nullptr;
 862         textureUnit.textureCubeMapBinding = nullptr;
 863     }
 864 
 865     m_blackTexture2D = nullptr;
 866     m_blackTextureCubeMap = nullptr;
 867 
 868     if (!m_isPendingPolicyResolution) {
 869         detachAndRemoveAllObjects();
 870         destroyGraphicsContextGL();
 871         m_contextGroup-&gt;removeContext(*this);
 872     }
 873 
 874     {
 875         LockHolder lock(WebGLProgram::instancesMutex());
 876         for (auto&amp; entry : WebGLProgram::instances(lock)) {
 877             if (entry.value == this) {
 878                 // Don&#39;t remove any WebGLProgram from the instances list, as they may still exist.
 879                 // Only remove the association with a WebGL context.
 880                 entry.value = nullptr;
 881             }
 882         }
 883     }
 884 }
 885 
 886 void WebGLRenderingContextBase::destroyGraphicsContextGL()
 887 {
 888     if (m_isPendingPolicyResolution)
 889         return;
 890 
 891     removeActivityStateChangeObserver();
 892 
 893     if (m_context) {
 894         m_context-&gt;removeClient(*this);
 895         m_context = nullptr;
 896     }
 897 }
 898 
 899 void WebGLRenderingContextBase::markContextChanged()
 900 {
 901     if (m_framebufferBinding)
 902         return;
 903 
 904     m_context-&gt;markContextChanged();
 905 
 906     m_layerCleared = false;
 907 
 908     auto* canvas = htmlCanvas();
 909     if (!canvas)
 910         return;
 911 
 912     RenderBox* renderBox = canvas-&gt;renderBox();
 913     if (isAccelerated() &amp;&amp; renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing()) {
 914         m_markedCanvasDirty = true;
 915         htmlCanvas()-&gt;clearCopiedImage();
 916         renderBox-&gt;contentChanged(CanvasPixelsChanged);
 917     } else {
 918         if (!m_markedCanvasDirty) {
 919             m_markedCanvasDirty = true;
 920             canvas-&gt;didDraw(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
 921         }
 922     }
 923 }
 924 
 925 void WebGLRenderingContextBase::markContextChangedAndNotifyCanvasObserver()
 926 {
 927     markContextChanged();
 928     if (!isAccelerated())
 929         return;
 930 
 931     auto* canvas = htmlCanvas();
 932     if (!canvas)
 933         return;
 934 
 935     RenderBox* renderBox = canvas-&gt;renderBox();
 936     if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing())
 937         canvas-&gt;notifyObserversCanvasChanged(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
 938 }
 939 
 940 bool WebGLRenderingContextBase::clearIfComposited(GCGLbitfield mask)
 941 {
 942     if (isContextLostOrPending())
 943         return false;
 944 
 945     if (!m_context-&gt;layerComposited() || m_layerCleared
 946         || m_attributes.preserveDrawingBuffer || (mask &amp;&amp; m_framebufferBinding)
 947         || m_preventBufferClearForInspector)
 948         return false;
 949 
 950     auto contextAttributes = getContextAttributes();
 951     ASSERT(contextAttributes);
 952 
 953     // Determine if it&#39;s possible to combine the clear the user asked for and this clear.
 954     bool combinedClear = mask &amp;&amp; !m_scissorEnabled;
 955 
 956     m_context-&gt;disable(GraphicsContextGL::SCISSOR_TEST);
 957     if (combinedClear &amp;&amp; (mask &amp; GraphicsContextGL::COLOR_BUFFER_BIT)) {
 958         m_context-&gt;clearColor(m_colorMask[0] ? m_clearColor[0] : 0,
 959                               m_colorMask[1] ? m_clearColor[1] : 0,
 960                               m_colorMask[2] ? m_clearColor[2] : 0,
 961                               m_colorMask[3] ? m_clearColor[3] : 0);
 962     } else
 963         m_context-&gt;clearColor(0, 0, 0, 0);
 964     m_context-&gt;colorMask(true, true, true, true);
 965     GCGLbitfield clearMask = GraphicsContextGL::COLOR_BUFFER_BIT;
 966     if (contextAttributes-&gt;depth) {
 967         if (!combinedClear || !m_depthMask || !(mask &amp; GraphicsContextGL::DEPTH_BUFFER_BIT))
 968             m_context-&gt;clearDepth(1.0f);
 969         clearMask |= GraphicsContextGL::DEPTH_BUFFER_BIT;
 970         m_context-&gt;depthMask(true);
 971     }
 972     if (contextAttributes-&gt;stencil) {
 973         if (combinedClear &amp;&amp; (mask &amp; GraphicsContextGL::STENCIL_BUFFER_BIT))
 974             m_context-&gt;clearStencil(m_clearStencil &amp; m_stencilMask);
 975         else
 976             m_context-&gt;clearStencil(0);
 977         clearMask |= GraphicsContextGL::STENCIL_BUFFER_BIT;
 978         m_context-&gt;stencilMaskSeparate(GraphicsContextGL::FRONT, 0xFFFFFFFF);
 979     }
 980     if (m_framebufferBinding)
 981         m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, 0);
 982     m_context-&gt;clear(clearMask);
 983 
 984     restoreStateAfterClear();
 985     if (m_framebufferBinding)
 986         m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));
 987     m_layerCleared = true;
 988 
 989     return combinedClear;
 990 }
 991 
 992 void WebGLRenderingContextBase::restoreStateAfterClear()
 993 {
 994     // Restore the state that the context set.
 995     if (m_scissorEnabled)
 996         m_context-&gt;enable(GraphicsContextGL::SCISSOR_TEST);
 997     m_context-&gt;clearColor(m_clearColor[0], m_clearColor[1],
 998                           m_clearColor[2], m_clearColor[3]);
 999     m_context-&gt;colorMask(m_colorMask[0], m_colorMask[1],
1000                          m_colorMask[2], m_colorMask[3]);
1001     m_context-&gt;clearDepth(m_clearDepth);
1002     m_context-&gt;clearStencil(m_clearStencil);
1003     m_context-&gt;stencilMaskSeparate(GraphicsContextGL::FRONT, m_stencilMask);
1004     m_context-&gt;depthMask(m_depthMask);
1005 }
1006 
1007 void WebGLRenderingContextBase::markLayerComposited()
1008 {
1009     if (isContextLostOrPending())
1010         return;
1011     m_context-&gt;markLayerComposited();
1012 }
1013 
1014 void WebGLRenderingContextBase::paintRenderingResultsToCanvas()
1015 {
1016     if (isContextLostOrPending())
1017         return;
1018 
1019     auto* canvas = htmlCanvas();
1020     if (!canvas)
1021         return;
1022 
1023     if (canvas-&gt;document().printing())
1024         canvas-&gt;clearPresentationCopy();
1025 
1026     // Until the canvas is written to by the application, the clear that
1027     // happened after it was composited should be ignored by the compositor.
1028     if (m_context-&gt;layerComposited() &amp;&amp; !m_attributes.preserveDrawingBuffer) {
1029         m_context-&gt;paintCompositedResultsToCanvas(canvas-&gt;buffer());
1030 
1031         canvas-&gt;makePresentationCopy();
1032     } else
1033         canvas-&gt;clearPresentationCopy();
1034     clearIfComposited();
1035 
1036     if (!m_markedCanvasDirty &amp;&amp; !m_layerCleared)
1037         return;
1038 
1039     canvas-&gt;clearCopiedImage();
1040     m_markedCanvasDirty = false;
1041 
1042     m_context-&gt;paintRenderingResultsToCanvas(canvas-&gt;buffer());
1043 }
1044 
1045 RefPtr&lt;ImageData&gt; WebGLRenderingContextBase::paintRenderingResultsToImageData()
1046 {
1047     if (isContextLostOrPending())
1048         return nullptr;
1049     clearIfComposited();
1050     return m_context-&gt;paintRenderingResultsToImageData();
1051 }
1052 
1053 WebGLTexture::TextureExtensionFlag WebGLRenderingContextBase::textureExtensionFlags() const
1054 {
1055     return static_cast&lt;WebGLTexture::TextureExtensionFlag&gt;((m_oesTextureFloatLinear ? WebGLTexture::TextureExtensionFloatLinearEnabled : 0) | (m_oesTextureHalfFloatLinear ? WebGLTexture::TextureExtensionHalfFloatLinearEnabled : 0));
1056 }
1057 
1058 void WebGLRenderingContextBase::reshape(int width, int height)
1059 {
1060     if (isContextLostOrPending())
1061         return;
1062 
1063     // This is an approximation because at WebGLRenderingContext level we don&#39;t
1064     // know if the underlying FBO uses textures or renderbuffers.
1065     GCGLint maxSize = std::min(m_maxTextureSize, m_maxRenderbufferSize);
1066     GCGLint maxWidth = std::min(maxSize, m_maxViewportDims[0]);
1067     GCGLint maxHeight = std::min(maxSize, m_maxViewportDims[1]);
1068     width = clamp(width, 1, maxWidth);
1069     height = clamp(height, 1, maxHeight);
1070 
1071     if (m_needsUpdate) {
1072         notifyCanvasContentChanged();
1073         m_needsUpdate = false;
1074     }
1075 
1076     // We don&#39;t have to mark the canvas as dirty, since the newly created image buffer will also start off
1077     // clear (and this matches what reshape will do).
1078     m_context-&gt;reshape(width, height);
1079 
1080     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
1081     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, objectOrZero(textureUnit.texture2DBinding.get()));
1082     if (textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(textureExtensionFlags()))
1083         m_unrenderableTextureUnits.add(m_activeTextureUnit);
1084     m_context-&gt;bindRenderbuffer(GraphicsContextGL::RENDERBUFFER, objectOrZero(m_renderbufferBinding.get()));
1085     if (m_framebufferBinding)
1086         m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));
1087 }
1088 
1089 int WebGLRenderingContextBase::drawingBufferWidth() const
1090 {
1091     if (isContextLost())
1092         return 0;
1093 
1094     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution)
1095         return 0;
1096 
1097     return m_context-&gt;getInternalFramebufferSize().width();
1098 }
1099 
1100 int WebGLRenderingContextBase::drawingBufferHeight() const
1101 {
1102     if (isContextLost())
1103         return 0;
1104 
1105     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution)
1106         return 0;
1107 
1108     return m_context-&gt;getInternalFramebufferSize().height();
1109 }
1110 
1111 unsigned WebGLRenderingContextBase::sizeInBytes(GCGLenum type)
1112 {
1113     switch (type) {
1114     case GraphicsContextGL::BYTE:
1115         return sizeof(GCGLbyte);
1116     case GraphicsContextGL::UNSIGNED_BYTE:
1117         return sizeof(GCGLubyte);
1118     case GraphicsContextGL::SHORT:
1119         return sizeof(GCGLshort);
1120     case GraphicsContextGL::UNSIGNED_SHORT:
1121         return sizeof(GCGLushort);
1122     case GraphicsContextGL::INT:
1123         return sizeof(GCGLint);
1124     case GraphicsContextGL::UNSIGNED_INT:
1125         return sizeof(GCGLuint);
1126     case GraphicsContextGL::FLOAT:
1127         return sizeof(GCGLfloat);
1128     }
1129     ASSERT_NOT_REACHED();
1130     return 0;
1131 }
1132 
1133 void WebGLRenderingContextBase::activeTexture(GCGLenum texture)
1134 {
1135     if (isContextLostOrPending())
1136         return;
1137     if (texture - GraphicsContextGL::TEXTURE0 &gt;= m_textureUnits.size()) {
1138         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;activeTexture&quot;, &quot;texture unit out of range&quot;);
1139         return;
1140     }
1141     m_activeTextureUnit = texture - GraphicsContextGL::TEXTURE0;
1142     m_context-&gt;activeTexture(texture);
1143 }
1144 
1145 void WebGLRenderingContextBase::attachShader(WebGLProgram* program, WebGLShader* shader)
1146 {
1147     if (isContextLostOrPending() || !validateWebGLObject(&quot;attachShader&quot;, program) || !validateWebGLObject(&quot;attachShader&quot;, shader))
1148         return;
1149     if (!program-&gt;attachShader(shader)) {
1150         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;attachShader&quot;, &quot;shader attachment already has shader&quot;);
1151         return;
1152     }
1153     m_context-&gt;attachShader(objectOrZero(program), objectOrZero(shader));
1154     shader-&gt;onAttached();
1155 }
1156 
1157 void WebGLRenderingContextBase::bindAttribLocation(WebGLProgram* program, GCGLuint index, const String&amp; name)
1158 {
1159     if (isContextLostOrPending() || !validateWebGLObject(&quot;bindAttribLocation&quot;, program))
1160         return;
1161     if (!validateLocationLength(&quot;bindAttribLocation&quot;, name))
1162         return;
1163     if (!validateString(&quot;bindAttribLocation&quot;, name))
1164         return;
1165     if (isPrefixReserved(name)) {
1166         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;bindAttribLocation&quot;, &quot;reserved prefix&quot;);
1167         return;
1168     }
1169     if (index &gt;= m_maxVertexAttribs) {
1170         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bindAttribLocation&quot;, &quot;index out of range&quot;);
1171         return;
1172     }
1173     m_context-&gt;bindAttribLocation(objectOrZero(program), index, name);
1174 }
1175 
1176 bool WebGLRenderingContextBase::checkObjectToBeBound(const char* functionName, WebGLObject* object, bool&amp; deleted)
1177 {
1178     deleted = false;
1179     if (isContextLostOrPending())
1180         return false;
1181     if (object) {
1182         if (!object-&gt;validate(contextGroup(), *this)) {
1183             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;object not from this context&quot;);
1184             return false;
1185         }
1186         deleted = !object-&gt;object();
1187     }
1188     return true;
1189 }
1190 
1191 bool WebGLRenderingContextBase::validateAndCacheBufferBinding(const char* functionName, GCGLenum target, WebGLBuffer* buffer)
1192 {
1193     bool deleted;
1194     if (!checkObjectToBeBound(functionName, buffer, deleted))
1195         return false;
1196     if (deleted)
1197         buffer = nullptr;
1198 
1199     if (buffer) {
1200         // In WebGL, a buffer may only be bound to one of the ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target in its lifetime.
1201         if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER) {
1202             if (buffer-&gt;arrayBufferOrElementArrayBuffer() &amp;&amp; target != buffer-&gt;arrayBufferOrElementArrayBuffer()) {
1203                 synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;buffers can only be bound to one of ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER&quot;);
1204                 return false;
1205             }
1206         }
1207 
1208         buffer-&gt;setTarget(target);
1209     }
1210 
1211     if (target == GraphicsContextGL::ARRAY_BUFFER)
1212         m_boundArrayBuffer = buffer;
1213     else if (target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER)
1214         m_boundVertexArrayObject-&gt;setElementArrayBuffer(buffer);
1215     else {
1216         bool success = false;
1217 #if ENABLE(WEBGL2)
1218         if (isWebGL2()) {
1219             success = true;
1220             switch (target) {
1221             case GraphicsContextGL::COPY_READ_BUFFER:
1222                 m_boundCopyReadBuffer = buffer;
1223                 break;
1224             case GraphicsContextGL::COPY_WRITE_BUFFER:
1225                 m_boundCopyWriteBuffer = buffer;
1226                 break;
1227             case GraphicsContextGL::PIXEL_PACK_BUFFER:
1228                 m_boundPixelPackBuffer = buffer;
1229                 break;
1230             case GraphicsContextGL::PIXEL_UNPACK_BUFFER:
1231                 m_boundPixelUnpackBuffer = buffer;
1232                 break;
1233             case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:
1234                 m_boundTransformFeedbackBuffer = buffer;
1235                 break;
1236             case GraphicsContextGL::UNIFORM_BUFFER:
1237                 m_boundUniformBuffer = buffer;
1238                 break;
1239             default:
1240                 success = false;
1241                 break;
1242             }
1243         }
1244 #endif
1245         if (!success) {
1246             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindBuffer&quot;, &quot;invalid target&quot;);
1247             return false;
1248         }
1249     }
1250 
1251     return true;
1252 }
1253 
1254 void WebGLRenderingContextBase::bindBuffer(GCGLenum target, WebGLBuffer* buffer)
1255 {
1256     if (!validateAndCacheBufferBinding(&quot;bindBuffer&quot;, target, buffer))
1257         return;
1258 
1259     m_context-&gt;bindBuffer(target, objectOrZero(buffer));
1260 }
1261 
1262 void WebGLRenderingContextBase::bindFramebuffer(GCGLenum target, WebGLFramebuffer* buffer)
1263 {
1264     bool deleted;
1265     if (!checkObjectToBeBound(&quot;bindFramebuffer&quot;, buffer, deleted))
1266         return;
1267     if (deleted)
1268         buffer = 0;
1269 
1270     bool isWebGL2DrawFramebufferTarget = false;
1271 #if ENABLE(WEBGL2)
1272     isWebGL2DrawFramebufferTarget = isWebGL2() &amp;&amp; target == GraphicsContextGL::DRAW_FRAMEBUFFER;
1273 #endif
1274     bool success = false;
1275 
1276     if (target == GraphicsContextGL::FRAMEBUFFER || isWebGL2DrawFramebufferTarget) {
1277         m_framebufferBinding = buffer;
1278         success = true;
1279     }
1280 #if ENABLE(WEBGL2)
1281     if (isWebGL2() &amp;&amp; (target == GraphicsContextGL::FRAMEBUFFER || target == GraphicsContextGL::READ_FRAMEBUFFER)) {
1282         m_readFramebufferBinding = buffer;
1283         success = true;
1284     }
1285 #endif
1286 
1287     if (!success) {
1288         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindFramebuffer&quot;, &quot;invalid target&quot;);
1289         return;
1290     }
1291 
1292     m_context-&gt;bindFramebuffer(target, objectOrZero(buffer));
1293     if (buffer)
1294         buffer-&gt;setHasEverBeenBound();
1295     applyStencilTest();
1296 }
1297 
1298 void WebGLRenderingContextBase::bindRenderbuffer(GCGLenum target, WebGLRenderbuffer* renderBuffer)
1299 {
1300     bool deleted;
1301     if (!checkObjectToBeBound(&quot;bindRenderbuffer&quot;, renderBuffer, deleted))
1302         return;
1303     if (deleted)
1304         renderBuffer = 0;
1305     if (target != GraphicsContextGL::RENDERBUFFER) {
1306         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindRenderbuffer&quot;, &quot;invalid target&quot;);
1307         return;
1308     }
1309     m_renderbufferBinding = renderBuffer;
1310     m_context-&gt;bindRenderbuffer(target, objectOrZero(renderBuffer));
1311     if (renderBuffer)
1312         renderBuffer-&gt;setHasEverBeenBound();
1313 }
1314 
1315 void WebGLRenderingContextBase::bindTexture(GCGLenum target, WebGLTexture* texture)
1316 {
1317     bool deleted;
1318     if (!checkObjectToBeBound(&quot;bindTexture&quot;, texture, deleted))
1319         return;
1320     if (deleted)
1321         texture = nullptr;
1322     if (texture &amp;&amp; texture-&gt;getTarget() &amp;&amp; texture-&gt;getTarget() != target) {
1323         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;bindTexture&quot;, &quot;textures can not be used with multiple targets&quot;);
1324         return;
1325     }
1326     GCGLint maxLevel = 0;
1327     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
1328     if (target == GraphicsContextGL::TEXTURE_2D) {
1329         textureUnit.texture2DBinding = texture;
1330         maxLevel = m_maxTextureLevel;
1331         if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
1332             m_unrenderableTextureUnits.add(m_activeTextureUnit);
1333         else
1334             m_unrenderableTextureUnits.remove(m_activeTextureUnit);
1335     } else if (target == GraphicsContextGL::TEXTURE_CUBE_MAP) {
1336         textureUnit.textureCubeMapBinding = texture;
1337         maxLevel = m_maxCubeMapTextureLevel;
1338         if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
1339             m_unrenderableTextureUnits.add(m_activeTextureUnit);
1340         else
1341             m_unrenderableTextureUnits.remove(m_activeTextureUnit);
1342     } else {
1343         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindTexture&quot;, &quot;invalid target&quot;);
1344         return;
1345     }
1346     m_context-&gt;bindTexture(target, objectOrZero(texture));
1347     if (texture)
1348         texture-&gt;setTarget(target, maxLevel);
1349 
1350     // Note: previously we used to automatically set the TEXTURE_WRAP_R
1351     // repeat mode to CLAMP_TO_EDGE for cube map textures, because OpenGL
1352     // ES 2.0 doesn&#39;t expose this flag (a bug in the specification) and
1353     // otherwise the application has no control over the seams in this
1354     // dimension. However, it appears that supporting this properly on all
1355     // platforms is fairly involved (will require a HashMap from texture ID
1356     // in all ports), and we have not had any complaints, so the logic has
1357     // been removed.
1358 }
1359 
1360 void WebGLRenderingContextBase::blendColor(GCGLfloat red, GCGLfloat green, GCGLfloat blue, GCGLfloat alpha)
1361 {
1362     if (isContextLostOrPending())
1363         return;
1364     m_context-&gt;blendColor(red, green, blue, alpha);
1365 }
1366 
1367 void WebGLRenderingContextBase::blendEquation(GCGLenum mode)
1368 {
1369     if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, mode))
1370         return;
1371     m_context-&gt;blendEquation(mode);
1372 }
1373 
1374 void WebGLRenderingContextBase::blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha)
1375 {
1376     if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, modeRGB) || !validateBlendEquation(&quot;blendEquation&quot;, modeAlpha))
1377         return;
1378     m_context-&gt;blendEquationSeparate(modeRGB, modeAlpha);
1379 }
1380 
1381 
1382 void WebGLRenderingContextBase::blendFunc(GCGLenum sfactor, GCGLenum dfactor)
1383 {
1384     if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, sfactor, dfactor))
1385         return;
1386     m_context-&gt;blendFunc(sfactor, dfactor);
1387 }
1388 
1389 void WebGLRenderingContextBase::blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha)
1390 {
1391     // Note: Alpha does not have the same restrictions as RGB.
1392     if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, srcRGB, dstRGB))
1393         return;
1394     m_context-&gt;blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
1395 }
1396 
1397 void WebGLRenderingContextBase::bufferData(GCGLenum target, long long size, GCGLenum usage)
1398 {
1399     if (isContextLostOrPending())
1400         return;
1401     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
1402     if (!buffer)
1403         return;
1404     if (size &lt; 0) {
1405         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;size &lt; 0&quot;);
1406         return;
1407     }
1408     if (!size) {
1409         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;size == 0&quot;);
1410         return;
1411     }
1412     if (!buffer-&gt;associateBufferData(static_cast&lt;GCGLsizeiptr&gt;(size))) {
1413         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);
1414         return;
1415     }
1416 
1417     m_context-&gt;moveErrorsToSyntheticErrorList();
1418     m_context-&gt;bufferData(target, static_cast&lt;GCGLsizeiptr&gt;(size), usage);
1419     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1420         // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1421         buffer-&gt;disassociateBufferData();
1422     }
1423 }
1424 
1425 void WebGLRenderingContextBase::bufferData(GCGLenum target, Optional&lt;BufferDataSource&gt;&amp;&amp; data, GCGLenum usage)
1426 {
1427     if (isContextLostOrPending())
1428         return;
1429     if (!data) {
1430         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;null data&quot;);
1431         return;
1432     }
1433     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
1434     if (!buffer)
1435         return;
1436 
1437     WTF::visit([&amp;](auto&amp; data) {
1438         if (!buffer-&gt;associateBufferData(data.get())) {
1439             this-&gt;synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);
1440             return;
1441         }
1442 
1443         m_context-&gt;moveErrorsToSyntheticErrorList();
1444         m_context-&gt;bufferData(target, data-&gt;byteLength(), data-&gt;data(), usage);
1445         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1446             // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1447             buffer-&gt;disassociateBufferData();
1448         }
1449     }, data.value());
1450 }
1451 
1452 void WebGLRenderingContextBase::bufferSubData(GCGLenum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp; data)
1453 {
1454     if (isContextLostOrPending())
1455         return;
1456     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferSubData&quot;, target, GraphicsContextGL::STATIC_DRAW);
1457     if (!buffer)
1458         return;
1459     if (offset &lt; 0) {
1460         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset &lt; 0&quot;);
1461         return;
1462     }
1463     if (!data)
1464         return;
1465 
1466     WTF::visit([&amp;](auto&amp; data) {
1467         if (!buffer-&gt;associateBufferSubData(static_cast&lt;GCGLintptr&gt;(offset), data.get())) {
1468             this-&gt;synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset out of range&quot;);
1469             return;
1470         }
1471 
1472         m_context-&gt;moveErrorsToSyntheticErrorList();
1473         m_context-&gt;bufferSubData(target, static_cast&lt;GCGLintptr&gt;(offset), data-&gt;byteLength(), data-&gt;data());
1474         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1475             // The bufferSubData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1476             buffer-&gt;disassociateBufferData();
1477         }
1478     }, data.value());
1479 }
1480 
1481 GCGLenum WebGLRenderingContextBase::checkFramebufferStatus(GCGLenum target)
1482 {
1483     if (isContextLostOrPending())
1484         return GraphicsContextGL::FRAMEBUFFER_UNSUPPORTED;
1485     if (target != GraphicsContextGL::FRAMEBUFFER) {
1486 #if ENABLE(WEBGL2)
1487         if (isWebGL1() || (target != GraphicsContextGL::DRAW_FRAMEBUFFER &amp;&amp; target != GraphicsContextGL::READ_FRAMEBUFFER)) {
1488 #endif
1489             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;checkFramebufferStatus&quot;, &quot;invalid target&quot;);
1490             return 0;
1491 #if ENABLE(WEBGL2)
1492         }
1493 #endif
1494     }
1495 
1496     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;
1497 
1498     if (!targetFramebuffer || !targetFramebuffer-&gt;object())
1499         return GraphicsContextGL::FRAMEBUFFER_COMPLETE;
1500     const char* reason = &quot;framebuffer incomplete&quot;;
1501     GCGLenum result = targetFramebuffer-&gt;checkStatus(&amp;reason);
1502     if (result != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {
1503         String str = &quot;WebGL: checkFramebufferStatus:&quot; + String(reason);
1504         printToConsole(MessageLevel::Warning, str);
1505         return result;
1506     }
1507     result = m_context-&gt;checkFramebufferStatus(target);
1508     return result;
1509 }
1510 
1511 void WebGLRenderingContextBase::clearColor(GCGLfloat r, GCGLfloat g, GCGLfloat b, GCGLfloat a)
1512 {
1513     if (isContextLostOrPending())
1514         return;
1515     if (std::isnan(r))
1516         r = 0;
1517     if (std::isnan(g))
1518         g = 0;
1519     if (std::isnan(b))
1520         b = 0;
1521     if (std::isnan(a))
1522         a = 1;
1523     m_clearColor[0] = r;
1524     m_clearColor[1] = g;
1525     m_clearColor[2] = b;
1526     m_clearColor[3] = a;
1527     m_context-&gt;clearColor(r, g, b, a);
1528 }
1529 
1530 void WebGLRenderingContextBase::clearDepth(GCGLfloat depth)
1531 {
1532     if (isContextLostOrPending())
1533         return;
1534     m_clearDepth = depth;
1535     m_context-&gt;clearDepth(depth);
1536 }
1537 
1538 void WebGLRenderingContextBase::clearStencil(GCGLint s)
1539 {
1540     if (isContextLostOrPending())
1541         return;
1542     m_clearStencil = s;
1543     m_context-&gt;clearStencil(s);
1544 }
1545 
1546 void WebGLRenderingContextBase::colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha)
1547 {
1548     if (isContextLostOrPending())
1549         return;
1550     m_colorMask[0] = red;
1551     m_colorMask[1] = green;
1552     m_colorMask[2] = blue;
1553     m_colorMask[3] = alpha;
1554     m_context-&gt;colorMask(red, green, blue, alpha);
1555 }
1556 
1557 void WebGLRenderingContextBase::compileShader(WebGLShader* shader)
1558 {
1559     if (isContextLostOrPending() || !validateWebGLObject(&quot;compileShader&quot;, shader))
1560         return;
1561     m_context-&gt;compileShader(objectOrZero(shader));
1562     GCGLint value;
1563     m_context-&gt;getShaderiv(objectOrZero(shader), GraphicsContextGL::COMPILE_STATUS, &amp;value);
1564     shader-&gt;setValid(value);
1565 
1566     auto* canvas = htmlCanvas();
1567 
1568     if (canvas &amp;&amp; m_synthesizedErrorsToConsole &amp;&amp; !value) {
1569         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
1570 
1571         for (auto&amp; error : getShaderInfoLog(shader).split(&#39;\n&#39;))
1572             canvas-&gt;document().addConsoleMessage(makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Error, &quot;WebGL: &quot; + error, stackTrace.copyRef()));
1573     }
1574 }
1575 
1576 void WebGLRenderingContextBase::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, ArrayBufferView&amp; data)
1577 {
1578     if (isContextLostOrPending())
1579         return;
1580     if (!validateTexFuncLevel(&quot;compressedTexImage2D&quot;, target, level))
1581         return;
1582 
1583     if (!validateCompressedTexFormat(internalformat)) {
1584         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;compressedTexImage2D&quot;, &quot;invalid internalformat&quot;);
1585         return;
1586     }
1587     if (border) {
1588         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;compressedTexImage2D&quot;, &quot;border not 0&quot;);
1589         return;
1590     }
1591     if (!validateCompressedTexDimensions(&quot;compressedTexImage2D&quot;, target, level, width, height, internalformat))
1592         return;
1593     if (!validateCompressedTexFuncData(&quot;compressedTexImage2D&quot;, width, height, internalformat, data))
1594         return;
1595 
1596     auto tex = validateTextureBinding(&quot;compressedTexImage2D&quot;, target, true);
1597     if (!tex)
1598         return;
1599     if (!validateNPOTTextureLevel(width, height, level, &quot;compressedTexImage2D&quot;))
1600         return;
1601     m_context-&gt;moveErrorsToSyntheticErrorList();
1602     m_context-&gt;compressedTexImage2D(target, level, internalformat, width, height,
1603         border, data.byteLength(), data.baseAddress());
1604     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1605         // The compressedTexImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
1606         tex-&gt;markInvalid(target, level);
1607         return;
1608     }
1609 
1610     tex-&gt;setLevelInfo(target, level, internalformat, width, height, GraphicsContextGL::UNSIGNED_BYTE);
1611     tex-&gt;setCompressed();
1612 }
1613 
1614 void WebGLRenderingContextBase::compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; data)
1615 {
1616     if (isContextLostOrPending())
1617         return;
1618     if (!validateTexFuncLevel(&quot;compressedTexSubImage2D&quot;, target, level))
1619         return;
1620     if (!validateCompressedTexFormat(format)) {
1621         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;compressedTexSubImage2D&quot;, &quot;invalid format&quot;);
1622         return;
1623     }
1624     if (!validateCompressedTexFuncData(&quot;compressedTexSubImage2D&quot;, width, height, format, data))
1625         return;
1626 
1627     auto tex = validateTextureBinding(&quot;compressedTexSubImage2D&quot;, target, true);
1628     if (!tex)
1629         return;
1630 
1631     if (format != tex-&gt;getInternalFormat(target, level)) {
1632         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;compressedTexSubImage2D&quot;, &quot;format does not match texture format&quot;);
1633         return;
1634     }
1635 
1636     if (!validateCompressedTexSubDimensions(&quot;compressedTexSubImage2D&quot;, target, level, xoffset, yoffset, width, height, format, tex.get()))
1637         return;
1638 
1639     graphicsContextGL()-&gt;compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data.byteLength(), data.baseAddress());
1640     tex-&gt;setCompressed();
1641 }
1642 
1643 bool WebGLRenderingContextBase::validateSettableTexInternalFormat(const char* functionName, GCGLenum internalFormat)
1644 {
1645     switch (internalFormat) {
1646     case GraphicsContextGL::DEPTH_COMPONENT:
1647     case GraphicsContextGL::DEPTH_STENCIL:
1648     case GraphicsContextGL::DEPTH_COMPONENT16:
1649     case GraphicsContextGL::DEPTH_COMPONENT24:
1650     case GraphicsContextGL::DEPTH_COMPONENT32F:
1651     case GraphicsContextGL::DEPTH24_STENCIL8:
1652     case GraphicsContextGL::DEPTH32F_STENCIL8:
1653     case GraphicsContextGL::STENCIL_INDEX8:
1654         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;format can not be set, only rendered to&quot;);
1655         return false;
1656     default:
1657         return true;
1658     }
1659 }
1660 
1661 void WebGLRenderingContextBase::copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
1662 {
1663     if (isContextLostOrPending())
1664         return;
1665     if (!validateTexFuncLevel(&quot;copyTexSubImage2D&quot;, target, level))
1666         return;
1667     auto tex = validateTextureBinding(&quot;copyTexSubImage2D&quot;, target, true);
1668     if (!tex)
1669         return;
1670     if (!validateSize(&quot;copyTexSubImage2D&quot;, xoffset, yoffset) || !validateSize(&quot;copyTexSubImage2D&quot;, width, height))
1671         return;
1672     // Before checking if it is in the range, check if overflow happens first.
1673     if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
1674         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);
1675         return;
1676     }
1677     if (xoffset + width &gt; tex-&gt;getWidth(target, level) || yoffset + height &gt; tex-&gt;getHeight(target, level)) {
1678         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;rectangle out of range&quot;);
1679         return;
1680     }
1681     GCGLenum internalFormat = tex-&gt;getInternalFormat(target, level);
1682     if (!validateSettableTexInternalFormat(&quot;copyTexSubImage2D&quot;, internalFormat))
1683         return;
1684     if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
1685         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;copyTexSubImage2D&quot;, &quot;framebuffer is incompatible format&quot;);
1686         return;
1687     }
1688     const char* reason = &quot;framebuffer incomplete&quot;;
1689     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {
1690         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexSubImage2D&quot;, reason);
1691         return;
1692     }
1693     clearIfComposited();
1694 
1695     GCGLint clippedX, clippedY;
1696     GCGLsizei clippedWidth, clippedHeight;
1697     if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
1698         GCGLenum format;
1699         GCGLenum type;
1700         if (!GraphicsContextGLOpenGL::possibleFormatAndTypeForInternalFormat(tex-&gt;getInternalFormat(target, level), format, type)) {
1701             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;copyTexSubImage2D&quot;, &quot;Texture has unknown internal format&quot;);
1702             return;
1703         }
1704         UniqueArray&lt;unsigned char&gt; zero;
1705         if (width &amp;&amp; height) {
1706             unsigned size;
1707             GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;size, nullptr);
1708             if (error != GraphicsContextGL::NO_ERROR) {
1709                 synthesizeGLError(error, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);
1710                 return;
1711             }
1712             zero = makeUniqueArray&lt;unsigned char&gt;(size);
1713             if (!zero) {
1714                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;out of memory&quot;);
1715                 return;
1716             }
1717             memset(zero.get(), 0, size);
1718         }
1719         m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, zero.get());
1720         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0)
1721             m_context-&gt;copyTexSubImage2D(target, level, xoffset + clippedX - x, yoffset + clippedY - y, clippedX, clippedY, clippedWidth, clippedHeight);
1722     } else
1723         m_context-&gt;copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
1724 }
1725 
1726 RefPtr&lt;WebGLBuffer&gt; WebGLRenderingContextBase::createBuffer()
1727 {
1728     if (isContextLostOrPending())
1729         return nullptr;
1730     auto buffer = WebGLBuffer::create(*this);
1731     addSharedObject(buffer.get());
1732     return buffer;
1733 }
1734 
1735 RefPtr&lt;WebGLFramebuffer&gt; WebGLRenderingContextBase::createFramebuffer()
1736 {
1737     if (isContextLostOrPending())
1738         return nullptr;
1739     auto buffer = WebGLFramebuffer::create(*this);
1740     addContextObject(buffer.get());
1741     return buffer;
1742 }
1743 
1744 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::createTexture()
1745 {
1746     if (isContextLostOrPending())
1747         return nullptr;
1748     auto texture = WebGLTexture::create(*this);
1749     addSharedObject(texture.get());
1750     return texture;
1751 }
1752 
1753 RefPtr&lt;WebGLProgram&gt; WebGLRenderingContextBase::createProgram()
1754 {
1755     if (isContextLostOrPending())
1756         return nullptr;
1757     auto program = WebGLProgram::create(*this);
1758     addSharedObject(program.get());
1759 
1760     InspectorInstrumentation::didCreateWebGLProgram(*this, program.get());
1761 
1762     return program;
1763 }
1764 
1765 RefPtr&lt;WebGLRenderbuffer&gt; WebGLRenderingContextBase::createRenderbuffer()
1766 {
1767     if (isContextLostOrPending())
1768         return nullptr;
1769     auto buffer = WebGLRenderbuffer::create(*this);
1770     addSharedObject(buffer.get());
1771     return buffer;
1772 }
1773 
1774 RefPtr&lt;WebGLShader&gt; WebGLRenderingContextBase::createShader(GCGLenum type)
1775 {
1776     if (isContextLostOrPending())
1777         return nullptr;
1778     if (type != GraphicsContextGL::VERTEX_SHADER &amp;&amp; type != GraphicsContextGL::FRAGMENT_SHADER) {
1779         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;createShader&quot;, &quot;invalid shader type&quot;);
1780         return nullptr;
1781     }
1782 
1783     auto shader = WebGLShader::create(*this, type);
1784     addSharedObject(shader.get());
1785     return shader;
1786 }
1787 
1788 void WebGLRenderingContextBase::cullFace(GCGLenum mode)
1789 {
1790     if (isContextLostOrPending())
1791         return;
1792     m_context-&gt;cullFace(mode);
1793 }
1794 
1795 bool WebGLRenderingContextBase::deleteObject(WebGLObject* object)
1796 {
1797     if (isContextLostOrPending() || !object)
1798         return false;
1799     if (!object-&gt;validate(contextGroup(), *this)) {
1800         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;delete&quot;, &quot;object does not belong to this context&quot;);
1801         return false;
1802     }
1803     if (object-&gt;isDeleted())
1804         return false;
1805     if (object-&gt;object())
1806         // We need to pass in context here because we want
1807         // things in this context unbound.
1808         object-&gt;deleteObject(graphicsContextGL());
1809     return true;
1810 }
1811 
1812 #define REMOVE_BUFFER_FROM_BINDING(binding) \
1813     if (binding == buffer) \
1814         binding = nullptr;
1815 
1816 void WebGLRenderingContextBase::uncacheDeletedBuffer(WebGLBuffer* buffer)
1817 {
1818     REMOVE_BUFFER_FROM_BINDING(m_boundArrayBuffer);
1819     REMOVE_BUFFER_FROM_BINDING(m_boundCopyReadBuffer);
1820     REMOVE_BUFFER_FROM_BINDING(m_boundCopyWriteBuffer);
1821     REMOVE_BUFFER_FROM_BINDING(m_boundPixelPackBuffer);
1822     REMOVE_BUFFER_FROM_BINDING(m_boundPixelUnpackBuffer);
1823     REMOVE_BUFFER_FROM_BINDING(m_boundTransformFeedbackBuffer);
1824     REMOVE_BUFFER_FROM_BINDING(m_boundUniformBuffer);
1825 
1826     m_boundVertexArrayObject-&gt;unbindBuffer(*buffer);
1827 }
1828 
1829 void WebGLRenderingContextBase::deleteBuffer(WebGLBuffer* buffer)
1830 {
1831     if (!deleteObject(buffer))
1832         return;
1833 
1834     uncacheDeletedBuffer(buffer);
1835 }
1836 
1837 void WebGLRenderingContextBase::deleteFramebuffer(WebGLFramebuffer* framebuffer)
1838 {
1839     if (!deleteObject(framebuffer))
1840         return;
1841 #if ENABLE(WEBGL2)
1842     if (isWebGL2() &amp;&amp; framebuffer == m_readFramebufferBinding) {
1843         m_readFramebufferBinding = nullptr;
1844         m_context-&gt;bindFramebuffer(GraphicsContextGL::READ_FRAMEBUFFER, 0);
1845     }
1846 #endif
1847     if (framebuffer == m_framebufferBinding) {
1848         m_framebufferBinding = nullptr;
1849 #if ENABLE(WEBGL2)
1850         if (isWebGL2())
1851             m_context-&gt;bindFramebuffer(GraphicsContextGL::DRAW_FRAMEBUFFER, 0);
1852         else
1853 #endif
1854             m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, 0);
1855     }
1856 }
1857 
1858 void WebGLRenderingContextBase::deleteProgram(WebGLProgram* program)
1859 {
1860     if (program)
1861         InspectorInstrumentation::willDestroyWebGLProgram(*program);
1862 
1863     deleteObject(program);
1864     // We don&#39;t reset m_currentProgram to 0 here because the deletion of the
1865     // current program is delayed.
1866 }
1867 
1868 void WebGLRenderingContextBase::deleteRenderbuffer(WebGLRenderbuffer* renderbuffer)
1869 {
1870     if (!deleteObject(renderbuffer))
1871         return;
1872     if (renderbuffer == m_renderbufferBinding)
1873         m_renderbufferBinding = nullptr;
1874     if (m_framebufferBinding)
1875         m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(renderbuffer);
1876 }
1877 
1878 void WebGLRenderingContextBase::deleteShader(WebGLShader* shader)
1879 {
1880     deleteObject(shader);
1881 }
1882 
1883 void WebGLRenderingContextBase::deleteTexture(WebGLTexture* texture)
1884 {
1885     if (!deleteObject(texture))
1886         return;
1887 
1888     unsigned current = 0;
1889     for (auto&amp; textureUnit : m_textureUnits) {
1890         if (texture == textureUnit.texture2DBinding) {
1891             textureUnit.texture2DBinding = nullptr;
1892             m_unrenderableTextureUnits.remove(current);
1893         }
1894         if (texture == textureUnit.textureCubeMapBinding) {
1895             textureUnit.textureCubeMapBinding = nullptr;
1896             m_unrenderableTextureUnits.remove(current);
1897         }
1898         ++current;
1899     }
1900     if (m_framebufferBinding)
1901         m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(texture);
1902 }
1903 
1904 void WebGLRenderingContextBase::depthFunc(GCGLenum func)
1905 {
1906     if (isContextLostOrPending())
1907         return;
1908     m_context-&gt;depthFunc(func);
1909 }
1910 
1911 void WebGLRenderingContextBase::depthMask(GCGLboolean flag)
1912 {
1913     if (isContextLostOrPending())
1914         return;
1915     m_depthMask = flag;
1916     m_context-&gt;depthMask(flag);
1917 }
1918 
1919 void WebGLRenderingContextBase::depthRange(GCGLfloat zNear, GCGLfloat zFar)
1920 {
1921     if (isContextLostOrPending())
1922         return;
1923     if (zNear &gt; zFar) {
1924         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;depthRange&quot;, &quot;zNear &gt; zFar&quot;);
1925         return;
1926     }
1927     m_context-&gt;depthRange(zNear, zFar);
1928 }
1929 
1930 void WebGLRenderingContextBase::detachShader(WebGLProgram* program, WebGLShader* shader)
1931 {
1932     if (isContextLostOrPending() || !validateWebGLObject(&quot;detachShader&quot;, program) || !validateWebGLObject(&quot;detachShader&quot;, shader))
1933         return;
1934     if (!program-&gt;detachShader(shader)) {
1935         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;detachShader&quot;, &quot;shader not attached&quot;);
1936         return;
1937     }
1938     m_context-&gt;detachShader(objectOrZero(program), objectOrZero(shader));
1939     shader-&gt;onDetached(graphicsContextGL());
1940 }
1941 
1942 void WebGLRenderingContextBase::disable(GCGLenum cap)
1943 {
1944     if (isContextLostOrPending() || !validateCapability(&quot;disable&quot;, cap))
1945         return;
1946     if (cap == GraphicsContextGL::STENCIL_TEST) {
1947         m_stencilEnabled = false;
1948         applyStencilTest();
1949         return;
1950     }
1951     if (cap == GraphicsContextGL::SCISSOR_TEST)
1952         m_scissorEnabled = false;
1953     m_context-&gt;disable(cap);
1954 }
1955 
1956 void WebGLRenderingContextBase::disableVertexAttribArray(GCGLuint index)
1957 {
1958     if (isContextLostOrPending())
1959         return;
1960     if (index &gt;= m_maxVertexAttribs) {
1961         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;disableVertexAttribArray&quot;, &quot;index out of range&quot;);
1962         return;
1963     }
1964 
1965     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
1966     state.enabled = false;
1967 
1968     if (index &gt; 0 || isGLES2Compliant())
1969         m_context-&gt;disableVertexAttribArray(index);
1970 }
1971 
1972 bool WebGLRenderingContextBase::validateNPOTTextureLevel(GCGLsizei width, GCGLsizei height, GCGLint level, const char* functionName)
1973 {
1974     if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
1975         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level &gt; 0 not power of 2&quot;);
1976         return false;
1977     }
1978 
1979     return true;
1980 }
1981 
1982 bool WebGLRenderingContextBase::validateElementArraySize(GCGLsizei count, GCGLenum type, GCGLintptr offset)
1983 {
1984     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
1985 
1986     if (!elementArrayBuffer)
1987         return false;
1988 
1989     if (offset &lt; 0)
1990         return false;
1991 
1992     if (type == GraphicsContextGL::UNSIGNED_INT) {
1993         // For an unsigned int array, offset must be divisible by 4 for alignment reasons.
1994         if (offset % 4)
1995             return false;
1996 
1997         // Make uoffset an element offset.
1998         offset /= 4;
1999 
2000         GCGLsizeiptr n = elementArrayBuffer-&gt;byteLength() / 4;
2001         if (offset &gt; n || count &gt; n - offset)
2002             return false;
2003     } else if (type == GraphicsContextGL::UNSIGNED_SHORT) {
2004         // For an unsigned short array, offset must be divisible by 2 for alignment reasons.
2005         if (offset % 2)
2006             return false;
2007 
2008         // Make uoffset an element offset.
2009         offset /= 2;
2010 
2011         GCGLsizeiptr n = elementArrayBuffer-&gt;byteLength() / 2;
2012         if (offset &gt; n || count &gt; n - offset)
2013             return false;
2014     } else if (type == GraphicsContextGL::UNSIGNED_BYTE) {
2015         GCGLsizeiptr n = elementArrayBuffer-&gt;byteLength();
2016         if (offset &gt; n || count &gt; n - offset)
2017             return false;
2018     }
2019     return true;
2020 }
2021 
2022 bool WebGLRenderingContextBase::validateIndexArrayPrecise(GCGLsizei count, GCGLenum type, GCGLintptr offset, unsigned&amp; numElementsRequired)
2023 {
2024     ASSERT(count &gt;= 0 &amp;&amp; offset &gt;= 0);
2025     unsigned maxIndex = 0;
2026 
2027     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
2028 
2029     if (!elementArrayBuffer)
2030         return false;
2031 
2032     if (!count) {
2033         numElementsRequired = 0;
2034         return true;
2035     }
2036 
2037     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
2038     if (!buffer)
2039         return false;
2040 
2041     switch (type) {
2042     case GraphicsContextGL::UNSIGNED_INT:
2043         maxIndex = getMaxIndex&lt;GCGLuint&gt;(buffer, offset, count);
2044         break;
2045     case GraphicsContextGL::UNSIGNED_SHORT:
2046         maxIndex = getMaxIndex&lt;GCGLushort&gt;(buffer, offset, count);
2047         break;
2048     case GraphicsContextGL::UNSIGNED_BYTE:
2049         maxIndex = getMaxIndex&lt;GCGLubyte&gt;(buffer, offset, count);
2050         break;
2051     }
2052 
2053     // Then set the maxiumum index in the index array and make sure it is valid.
2054     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex, 1, 1);
2055     if (!checkedNumElementsRequired)
2056         return false;
2057     numElementsRequired = checkedNumElementsRequired.value();
2058     return true;
2059 }
2060 
2061 bool WebGLRenderingContextBase::validateVertexAttributes(unsigned elementCount, unsigned primitiveCount)
2062 {
2063 #if USE(ANGLE)
2064     UNUSED_PARAM(elementCount);
2065     UNUSED_PARAM(primitiveCount);
2066 #else
2067     if (!m_currentProgram)
2068         return false;
2069 
2070     // Look in each enabled vertex attrib and check if they&#39;ve been bound to a buffer.
2071     for (unsigned i = 0; i &lt; m_maxVertexAttribs; ++i) {
2072         if (!m_boundVertexArrayObject-&gt;getVertexAttribState(i).validateBinding())
2073             return false;
2074     }
2075 
2076     if (!elementCount)
2077         return true;
2078 
2079     // Look in each consumed vertex attrib (by the current program).
2080     bool sawNonInstancedAttrib = false;
2081     bool sawEnabledAttrib = false;
2082     int numActiveAttribLocations = m_currentProgram-&gt;numActiveAttribLocations();
2083     for (int i = 0; i &lt; numActiveAttribLocations; ++i) {
2084         int loc = m_currentProgram-&gt;getActiveAttribLocation(i);
2085         if (loc &gt;= 0 &amp;&amp; loc &lt; static_cast&lt;int&gt;(m_maxVertexAttribs)) {
2086             const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(loc);
2087             if (state.enabled) {
2088                 sawEnabledAttrib = true;
2089                 // Avoid off-by-one errors in numElements computation.
2090                 // For the last element, we will only touch the data for the
2091                 // element and nothing beyond it.
2092                 int bytesRemaining = static_cast&lt;int&gt;(state.bufferBinding-&gt;byteLength() - state.offset);
2093                 if (bytesRemaining &lt;= 0)
2094                     return false;
2095                 unsigned numElements = 0;
2096                 ASSERT(state.stride &gt; 0);
2097                 if (bytesRemaining &gt;= state.bytesPerElement)
2098                     numElements = 1 + (bytesRemaining - state.bytesPerElement) / state.stride;
2099                 unsigned instancesRequired = 0;
2100                 if (state.divisor) {
2101                     instancesRequired = ceil(static_cast&lt;float&gt;(primitiveCount) / state.divisor);
2102                     if (instancesRequired &gt; numElements)
2103                         return false;
2104                 } else {
2105                     sawNonInstancedAttrib = true;
2106                     if (elementCount &gt; numElements)
2107                         return false;
2108                 }
2109             }
2110         }
2111     }
2112 
2113     if (!sawNonInstancedAttrib &amp;&amp; sawEnabledAttrib)
2114         return false;
2115 
2116     bool usingSimulatedArrayBuffer = m_currentProgram-&gt;isUsingVertexAttrib0();
2117 
2118     // Guard against access into non-existent buffers.
2119     if (elementCount &amp;&amp; !sawEnabledAttrib &amp;&amp; !usingSimulatedArrayBuffer)
2120         return false;
2121 
2122     if (elementCount &amp;&amp; sawEnabledAttrib) {
2123         if (!m_boundArrayBuffer &amp;&amp; !m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
2124             if (usingSimulatedArrayBuffer) {
2125                 auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
2126                 if (state.enabled &amp;&amp; state.isBound()) {
2127                     if (state.bufferBinding-&gt;getTarget() == GraphicsContextGL::ARRAY_BUFFER || state.bufferBinding-&gt;getTarget() == GraphicsContextGL::ELEMENT_ARRAY_BUFFER)
2128                         return !!state.bufferBinding-&gt;byteLength();
2129                 }
2130             }
2131             return false;
2132         }
2133     }
2134 #endif
2135 
2136     return true;
2137 }
2138 
2139 bool WebGLRenderingContextBase::validateWebGLObject(const char* functionName, WebGLObject* object)
2140 {
2141     if (!object || !object-&gt;object()) {
2142         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no object or object deleted&quot;);
2143         return false;
2144     }
2145     if (!object-&gt;validate(contextGroup(), *this)) {
2146         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;object does not belong to this context&quot;);
2147         return false;
2148     }
2149     return true;
2150 }
2151 
2152 bool WebGLRenderingContextBase::validateDrawArrays(const char* functionName, GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primitiveCount)
2153 {
2154     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
2155         return false;
2156 
2157     if (!validateStencilSettings(functionName))
2158         return false;
2159 
2160     if (first &lt; 0 || count &lt; 0) {
2161         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;first or count &lt; 0&quot;);
2162         return false;
2163     }
2164 
2165     if (!count) {
2166         markContextChanged();
2167         return false;
2168     }
2169 
2170     if (primitiveCount &lt; 0) {
2171         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);
2172         return false;
2173     }
2174 
2175     // Ensure we have a valid rendering state.
2176     Checked&lt;GCGLint, RecordOverflow&gt; checkedSum = Checked&lt;GCGLint, RecordOverflow&gt;(first) + Checked&lt;GCGLint, RecordOverflow&gt;(count);
2177     Checked&lt;GCGLint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);
2178     if (checkedSum.hasOverflowed() || checkedPrimitiveCount.hasOverflowed() || !validateVertexAttributes(checkedSum.unsafeGet(), checkedPrimitiveCount.unsafeGet())) {
2179         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);
2180         return false;
2181     }
2182     if (!validateSimulatedVertexAttrib0(checkedSum.unsafeGet() - 1)) {
2183         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);
2184         return false;
2185     }
2186 
2187     const char* reason = &quot;framebuffer incomplete&quot;;
2188     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {
2189         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);
2190         return false;
2191     }
2192 
2193     return true;
2194 }
2195 
2196 bool WebGLRenderingContextBase::validateDrawElements(const char* functionName, GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, unsigned&amp; numElements, GCGLsizei primitiveCount)
2197 {
2198     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
2199         return false;
2200 
2201     if (!validateStencilSettings(functionName))
2202         return false;
2203 
2204     switch (type) {
2205     case GraphicsContextGL::UNSIGNED_BYTE:
2206     case GraphicsContextGL::UNSIGNED_SHORT:
2207         break;
2208     case GraphicsContextGL::UNSIGNED_INT:
2209         if (m_oesElementIndexUint || isWebGL2())
2210             break;
2211         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid type&quot;);
2212         return false;
2213     default:
2214         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid type&quot;);
2215         return false;
2216     }
2217 
2218     if (count &lt; 0 || offset &lt; 0) {
2219         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;count or offset &lt; 0&quot;);
2220         return false;
2221     }
2222 
2223     if (!count) {
2224         markContextChanged();
2225         return false;
2226     }
2227 
2228     if (primitiveCount &lt; 0) {
2229         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);
2230         return false;
2231     }
2232 
2233     if (!m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
2234         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;no ELEMENT_ARRAY_BUFFER bound&quot;);
2235         return false;
2236     }
2237 
2238     // Ensure we have a valid rendering state.
2239     if (!validateElementArraySize(count, type, static_cast&lt;GCGLintptr&gt;(offset))) {
2240         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;request out of bounds for current ELEMENT_ARRAY_BUFFER&quot;);
2241         return false;
2242     }
2243     if (!count)
2244         return false;
2245 
2246     Checked&lt;GCGLint, RecordOverflow&gt; checkedCount(count);
2247     Checked&lt;GCGLint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);
2248     if (checkedCount.hasOverflowed() || checkedPrimitiveCount.hasOverflowed()) {
2249         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);
2250         return false;
2251     }
2252 
2253     if (!validateIndexArrayConservative(type, numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {
2254         if (!validateIndexArrayPrecise(checkedCount.unsafeGet(), type, static_cast&lt;GCGLintptr&gt;(offset), numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {
2255             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);
2256             return false;
2257         }
2258     }
2259 
2260     if (!validateSimulatedVertexAttrib0(numElements)) {
2261         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);
2262         return false;
2263     }
2264 
2265     const char* reason = &quot;framebuffer incomplete&quot;;
2266     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {
2267         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);
2268         return false;
2269     }
2270 
2271     return true;
2272 }
2273 
2274 void WebGLRenderingContextBase::drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count)
2275 {
2276     if (!validateDrawArrays(&quot;drawArrays&quot;, mode, first, count, 0))
2277         return;
2278 
2279     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isWebGLProgramDisabled(*this, *m_currentProgram))
2280         return;
2281 
2282     clearIfComposited();
2283 
2284     bool vertexAttrib0Simulated = false;
2285     if (!isGLES2Compliant()) {
2286         auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
2287         if (!simulateVertexAttrib0Status) {
2288             // We were unable to simulate the attribute buffer.
2289             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawArrays&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);
2290             return;
2291         }
2292         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
2293     }
2294     bool usesFallbackTexture = false;
2295     if (!isGLES2NPOTStrict())
2296         usesFallbackTexture = checkTextureCompleteness(&quot;drawArrays&quot;, true);
2297 
2298     {
2299         InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
2300 
2301         m_context-&gt;drawArrays(mode, first, count);
2302     }
2303 
2304     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
2305         restoreStatesAfterVertexAttrib0Simulation();
2306     if (usesFallbackTexture)
2307         checkTextureCompleteness(&quot;drawArrays&quot;, false);
2308     markContextChangedAndNotifyCanvasObserver();
2309 }
2310 
2311 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
2312 static GCGLuint getRestartIndex(GCGLenum type)
2313 {
2314     switch (type) {
2315     case GraphicsContextGL::UNSIGNED_BYTE:
2316         return std::numeric_limits&lt;GCGLubyte&gt;::max();
2317     case GraphicsContextGL::UNSIGNED_SHORT:
2318         return std::numeric_limits&lt;GCGLushort&gt;::max();
2319     case GraphicsContextGL::UNSIGNED_INT:
2320         return std::numeric_limits&lt;GCGLuint&gt;::max();
2321     }
2322 
2323     return 0;
2324 }
2325 #endif
2326 
2327 void WebGLRenderingContextBase::drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset)
2328 {
2329     unsigned numElements = 0;
2330     if (!validateDrawElements(&quot;drawElements&quot;, mode, count, type, offset, numElements, 0))
2331         return;
2332 
2333     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isWebGLProgramDisabled(*this, *m_currentProgram))
2334         return;
2335 
2336     clearIfComposited();
2337 
2338     bool vertexAttrib0Simulated = false;
2339     if (!isGLES2Compliant()) {
2340         if (!numElements)
2341             validateIndexArrayPrecise(count, type, static_cast&lt;GCGLintptr&gt;(offset), numElements);
2342         auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
2343         if (!simulateVertexAttrib0Status) {
2344             // We were unable to simulate the attribute buffer.
2345             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawElements&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);
2346             return;
2347         }
2348         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
2349     }
2350 
2351     bool usesFallbackTexture = false;
2352     if (!isGLES2NPOTStrict())
2353         usesFallbackTexture = checkTextureCompleteness(&quot;drawElements&quot;, true);
2354 
2355 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
2356     if (isWebGL2())
2357         m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
2358 #endif
2359 
2360     {
2361         InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
2362 
2363         m_context-&gt;drawElements(mode, count, type, static_cast&lt;GCGLintptr&gt;(offset));
2364     }
2365 
2366     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
2367         restoreStatesAfterVertexAttrib0Simulation();
2368     if (usesFallbackTexture)
2369         checkTextureCompleteness(&quot;drawElements&quot;, false);
2370     markContextChangedAndNotifyCanvasObserver();
2371 }
2372 
2373 void WebGLRenderingContextBase::enable(GCGLenum cap)
2374 {
2375     if (isContextLostOrPending() || !validateCapability(&quot;enable&quot;, cap))
2376         return;
2377     if (cap == GraphicsContextGL::STENCIL_TEST) {
2378         m_stencilEnabled = true;
2379         applyStencilTest();
2380         return;
2381     }
2382     if (cap == GraphicsContextGL::SCISSOR_TEST)
2383         m_scissorEnabled = true;
2384     m_context-&gt;enable(cap);
2385 }
2386 
2387 void WebGLRenderingContextBase::enableVertexAttribArray(GCGLuint index)
2388 {
2389     if (isContextLostOrPending())
2390         return;
2391     if (index &gt;= m_maxVertexAttribs) {
2392         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;enableVertexAttribArray&quot;, &quot;index out of range&quot;);
2393         return;
2394     }
2395 
2396     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
2397     state.enabled = true;
2398 
2399     m_context-&gt;enableVertexAttribArray(index);
2400 }
2401 
2402 void WebGLRenderingContextBase::finish()
2403 {
2404     if (isContextLostOrPending())
2405         return;
2406     m_context-&gt;finish();
2407 }
2408 
2409 void WebGLRenderingContextBase::flush()
2410 {
2411     if (isContextLostOrPending())
2412         return;
2413     m_context-&gt;flush();
2414 }
2415 
2416 void WebGLRenderingContextBase::framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, WebGLRenderbuffer* buffer)
2417 {
2418     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferRenderbuffer&quot;, target, attachment))
2419         return;
2420     if (renderbuffertarget != GraphicsContextGL::RENDERBUFFER) {
2421         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;framebufferRenderbuffer&quot;, &quot;invalid target&quot;);
2422         return;
2423     }
2424     if (buffer &amp;&amp; !buffer-&gt;validate(contextGroup(), *this)) {
2425         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no buffer or buffer not from this context&quot;);
2426         return;
2427     }
2428     if (buffer &amp;&amp; !buffer-&gt;hasEverBeenBound()) {
2429         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;buffer has never been bound&quot;);
2430         return;
2431     }
2432 
2433     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;
2434 
2435     // Don&#39;t allow the default framebuffer to be mutated; all current
2436     // implementations use an FBO internally in place of the default
2437     // FBO.
2438     if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
2439         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no framebuffer bound&quot;);
2440         return;
2441     }
2442     PlatformGLObject bufferObject = objectOrZero(buffer);
2443 #if !USE(ANGLE)
2444     if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {
2445         m_context-&gt;framebufferRenderbuffer(target, GraphicsContextGL::DEPTH_ATTACHMENT, renderbuffertarget, bufferObject);
2446         m_context-&gt;framebufferRenderbuffer(target, GraphicsContextGL::STENCIL_ATTACHMENT, renderbuffertarget, bufferObject);
2447     } else
2448 #endif
2449         m_context-&gt;framebufferRenderbuffer(target, attachment, renderbuffertarget, bufferObject);
2450     targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, buffer);
2451     applyStencilTest();
2452 }
2453 
2454 void WebGLRenderingContextBase::framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, WebGLTexture* texture, GCGLint level)
2455 {
2456     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferTexture2D&quot;, target, attachment))
2457         return;
2458     if (level &amp;&amp; isWebGL1()) {
2459         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;framebufferTexture2D&quot;, &quot;level not 0&quot;);
2460         return;
2461     }
2462     if (texture &amp;&amp; !texture-&gt;validate(contextGroup(), *this)) {
2463         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no texture or texture not from this context&quot;);
2464         return;
2465     }
2466 
2467     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;
2468 
2469     // Don&#39;t allow the default framebuffer to be mutated; all current
2470     // implementations use an FBO internally in place of the default
2471     // FBO.
2472     if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
2473         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no framebuffer bound&quot;);
2474         return;
2475     }
2476     PlatformGLObject textureObject = objectOrZero(texture);
2477 
2478 #if !USE_ANGLE
2479     if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {
2480         m_context-&gt;framebufferTexture2D(target, GraphicsContextGL::DEPTH_ATTACHMENT, textarget, textureObject, level);
2481         m_context-&gt;framebufferTexture2D(target, GraphicsContextGL::STENCIL_ATTACHMENT, textarget, textureObject, level);
2482     } else
2483 #endif
2484         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);
2485 
2486     targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, textarget, texture, level);
2487     applyStencilTest();
2488 }
2489 
2490 void WebGLRenderingContextBase::frontFace(GCGLenum mode)
2491 {
2492     if (isContextLostOrPending())
2493         return;
2494     m_context-&gt;frontFace(mode);
2495 }
2496 
2497 void WebGLRenderingContextBase::generateMipmap(GCGLenum target)
2498 {
2499     if (isContextLostOrPending())
2500         return;
2501     auto tex = validateTextureBinding(&quot;generateMipmap&quot;, target, false);
2502     if (!tex)
2503         return;
2504     if (!tex-&gt;canGenerateMipmaps()) {
2505         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;level 0 not power of 2 or not all the same size&quot;);
2506         return;
2507     }
2508     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=123916. Compressed textures should be allowed in WebGL 2:
2509     if (tex-&gt;isCompressed()) {
2510         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;trying to generate mipmaps from compressed texture&quot;);
2511         return;
2512     }
2513     if (!validateSettableTexInternalFormat(&quot;generateMipmap&quot;, tex-&gt;getInternalFormat(target, 0)))
2514         return;
2515 
2516     // generateMipmap won&#39;t work properly if minFilter is not NEAREST_MIPMAP_LINEAR
2517     // on Mac.  Remove the hack once this driver bug is fixed.
2518 #if OS(DARWIN)
2519     bool needToResetMinFilter = false;
2520     if (tex-&gt;getMinFilter() != GraphicsContextGL::NEAREST_MIPMAP_LINEAR) {
2521         m_context-&gt;texParameteri(target, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::NEAREST_MIPMAP_LINEAR);
2522         needToResetMinFilter = true;
2523     }
2524 #endif
2525     m_context-&gt;generateMipmap(target);
2526 #if OS(DARWIN)
2527     if (needToResetMinFilter)
2528         m_context-&gt;texParameteri(target, GraphicsContextGL::TEXTURE_MIN_FILTER, tex-&gt;getMinFilter());
2529 #endif
2530     tex-&gt;generateMipmapLevelInfo();
2531 }
2532 
2533 RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveAttrib(WebGLProgram* program, GCGLuint index)
2534 {
2535     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveAttrib&quot;, program))
2536         return nullptr;
2537     GraphicsContextGL::ActiveInfo info;
2538     if (!m_context-&gt;getActiveAttrib(objectOrZero(program), index, info))
2539         return nullptr;
2540 
2541     LOG(WebGL, &quot;Returning active attribute %d: %s&quot;, index, info.name.utf8().data());
2542 
2543     return WebGLActiveInfo::create(info.name, info.type, info.size);
2544 }
2545 
2546 RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveUniform(WebGLProgram* program, GCGLuint index)
2547 {
2548     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveUniform&quot;, program))
2549         return nullptr;
2550     GraphicsContextGL::ActiveInfo info;
2551     if (!m_context-&gt;getActiveUniform(objectOrZero(program), index, info))
2552         return nullptr;
2553     if (!isGLES2Compliant())
2554         if (info.size &gt; 1 &amp;&amp; !info.name.endsWith(&quot;[0]&quot;))
2555             info.name.append(&quot;[0]&quot;);
2556 
2557     LOG(WebGL, &quot;Returning active uniform %d: %s&quot;, index, info.name.utf8().data());
2558 
2559     return WebGLActiveInfo::create(info.name, info.type, info.size);
2560 }
2561 
2562 Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; WebGLRenderingContextBase::getAttachedShaders(WebGLProgram* program)
2563 {
2564     if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttachedShaders&quot;, program))
2565         return WTF::nullopt;
2566 
2567     const GCGLenum shaderTypes[] = {
2568         GraphicsContextGL::VERTEX_SHADER,
2569         GraphicsContextGL::FRAGMENT_SHADER
2570     };
2571     Vector&lt;RefPtr&lt;WebGLShader&gt;&gt; shaderObjects;
2572     for (auto shaderType : shaderTypes) {
2573         RefPtr&lt;WebGLShader&gt; shader = program-&gt;getAttachedShader(shaderType);
2574         if (shader)
2575             shaderObjects.append(shader);
2576     }
2577     return shaderObjects;
2578 }
2579 
2580 GCGLint WebGLRenderingContextBase::getAttribLocation(WebGLProgram* program, const String&amp; name)
2581 {
2582     if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttribLocation&quot;, program))
2583         return -1;
2584     if (!validateLocationLength(&quot;getAttribLocation&quot;, name))
2585         return -1;
2586     if (!validateString(&quot;getAttribLocation&quot;, name))
2587         return -1;
2588     if (isPrefixReserved(name))
2589         return -1;
2590     if (!program-&gt;getLinkStatus()) {
2591         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getAttribLocation&quot;, &quot;program not linked&quot;);
2592         return -1;
2593     }
2594     return m_context-&gt;getAttribLocation(objectOrZero(program), name);
2595 }
2596 
2597 WebGLAny WebGLRenderingContextBase::getBufferParameter(GCGLenum target, GCGLenum pname)
2598 {
2599     if (isContextLostOrPending())
2600         return nullptr;
2601 
2602     bool valid = false;
2603     if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER)
2604         valid = true;
2605 #if ENABLE(WEBGL2)
2606     if (isWebGL2()) {
2607         switch (target) {
2608         case GraphicsContextGL::COPY_READ_BUFFER:
2609         case GraphicsContextGL::COPY_WRITE_BUFFER:
2610         case GraphicsContextGL::PIXEL_PACK_BUFFER:
2611         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:
2612         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:
2613         case GraphicsContextGL::UNIFORM_BUFFER:
2614             valid = true;
2615         }
2616     }
2617 #endif
2618     if (!valid) {
2619         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid target&quot;);
2620         return nullptr;
2621     }
2622 
2623     if (pname != GraphicsContextGL::BUFFER_SIZE &amp;&amp; pname != GraphicsContextGL::BUFFER_USAGE) {
2624         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid parameter name&quot;);
2625         return nullptr;
2626     }
2627 
2628     GCGLint value = 0;
2629     m_context-&gt;getBufferParameteriv(target, pname, &amp;value);
2630     if (pname == GraphicsContextGL::BUFFER_SIZE)
2631         return value;
2632     return static_cast&lt;unsigned&gt;(value);
2633 }
2634 
2635 Optional&lt;WebGLContextAttributes&gt; WebGLRenderingContextBase::getContextAttributes()
2636 {
2637     if (isContextLostOrPending())
2638         return WTF::nullopt;
2639 
2640     // Also, we need to enforce requested values of &quot;false&quot; for depth
2641     // and stencil, regardless of the properties of the underlying
2642     // GraphicsContextGLOpenGL.
2643 
2644     auto attributes = m_context-&gt;contextAttributes();
2645     if (!m_attributes.depth)
2646         attributes.depth = false;
2647     if (!m_attributes.stencil)
2648         attributes.stencil = false;
2649     return attributes;
2650 }
2651 
2652 GCGLenum WebGLRenderingContextBase::getError()
2653 {
2654     if (m_isPendingPolicyResolution)
2655         return GraphicsContextGL::NO_ERROR;
2656     return m_context-&gt;getError();
2657 }
2658 
2659 WebGLAny WebGLRenderingContextBase::getProgramParameter(WebGLProgram* program, GCGLenum pname)
2660 {
2661     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramParameter&quot;, program))
2662         return nullptr;
2663 
2664     GCGLint value = 0;
2665     switch (pname) {
2666     case GraphicsContextGL::DELETE_STATUS:
2667         return program-&gt;isDeleted();
2668     case GraphicsContextGL::VALIDATE_STATUS:
2669         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2670         return static_cast&lt;bool&gt;(value);
2671     case GraphicsContextGL::LINK_STATUS:
2672         return program-&gt;getLinkStatus();
2673     case GraphicsContextGL::ATTACHED_SHADERS:
2674         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2675         return value;
2676     case GraphicsContextGL::ACTIVE_ATTRIBUTES:
2677     case GraphicsContextGL::ACTIVE_UNIFORMS:
2678 #if USE(ANGLE)
2679         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2680 #else
2681         m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), pname, &amp;value);
2682 #endif // USE(ANGLE)
2683         return value;
2684     default:
2685 #if ENABLE(WEBGL2)
2686         if (isWebGL2()) {
2687             switch (pname) {
2688             case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER_MODE:
2689             case GraphicsContextGL::TRANSFORM_FEEDBACK_VARYINGS:
2690             case GraphicsContextGL::ACTIVE_UNIFORM_BLOCKS:
2691                 m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2692                 return value;
2693             default:
2694                 break;
2695             }
2696         }
2697 #endif // ENABLE(WEBGL2)
2698         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getProgramParameter&quot;, &quot;invalid parameter name&quot;);
2699         return nullptr;
2700     }
2701 }
2702 
2703 String WebGLRenderingContextBase::getProgramInfoLog(WebGLProgram* program)
2704 {
2705     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramInfoLog&quot;, program))
2706         return String();
2707     return ensureNotNull(m_context-&gt;getProgramInfoLog(objectOrZero(program)));
2708 }
2709 
2710 WebGLAny WebGLRenderingContextBase::getRenderbufferParameter(GCGLenum target, GCGLenum pname)
2711 {
2712     if (isContextLostOrPending())
2713         return nullptr;
2714     if (target != GraphicsContextGL::RENDERBUFFER) {
2715         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid target&quot;);
2716         return nullptr;
2717     }
2718     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
2719         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getRenderbufferParameter&quot;, &quot;no renderbuffer bound&quot;);
2720         return nullptr;
2721     }
2722 
2723     if (m_renderbufferBinding-&gt;getInternalFormat() == GraphicsContextGL::DEPTH_STENCIL
2724         &amp;&amp; !m_renderbufferBinding-&gt;isValid()) {
2725         ASSERT(!isDepthStencilSupported());
2726         int value = 0;
2727         switch (pname) {
2728         case GraphicsContextGL::RENDERBUFFER_WIDTH:
2729             value = m_renderbufferBinding-&gt;getWidth();
2730             break;
2731         case GraphicsContextGL::RENDERBUFFER_HEIGHT:
2732             value = m_renderbufferBinding-&gt;getHeight();
2733             break;
2734         case GraphicsContextGL::RENDERBUFFER_RED_SIZE:
2735         case GraphicsContextGL::RENDERBUFFER_GREEN_SIZE:
2736         case GraphicsContextGL::RENDERBUFFER_BLUE_SIZE:
2737         case GraphicsContextGL::RENDERBUFFER_ALPHA_SIZE:
2738             value = 0;
2739             break;
2740         case GraphicsContextGL::RENDERBUFFER_DEPTH_SIZE:
2741             value = 24;
2742             break;
2743         case GraphicsContextGL::RENDERBUFFER_STENCIL_SIZE:
2744             value = 8;
2745             break;
2746         case GraphicsContextGL::RENDERBUFFER_INTERNAL_FORMAT:
2747             return m_renderbufferBinding-&gt;getInternalFormat();
2748         default:
2749             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);
2750             return nullptr;
2751         }
2752         return value;
2753     }
2754 
2755     GCGLint value = 0;
2756     switch (pname) {
2757     case GraphicsContextGL::RENDERBUFFER_WIDTH:
2758     case GraphicsContextGL::RENDERBUFFER_HEIGHT:
2759     case GraphicsContextGL::RENDERBUFFER_RED_SIZE:
2760     case GraphicsContextGL::RENDERBUFFER_GREEN_SIZE:
2761     case GraphicsContextGL::RENDERBUFFER_BLUE_SIZE:
2762     case GraphicsContextGL::RENDERBUFFER_ALPHA_SIZE:
2763     case GraphicsContextGL::RENDERBUFFER_DEPTH_SIZE:
2764     case GraphicsContextGL::RENDERBUFFER_STENCIL_SIZE:
2765         m_context-&gt;getRenderbufferParameteriv(target, pname, &amp;value);
2766         return value;
2767     case GraphicsContextGL::RENDERBUFFER_INTERNAL_FORMAT:
2768         return m_renderbufferBinding-&gt;getInternalFormat();
2769     default:
2770         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);
2771         return nullptr;
2772     }
2773 }
2774 
2775 WebGLAny WebGLRenderingContextBase::getShaderParameter(WebGLShader* shader, GCGLenum pname)
2776 {
2777     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderParameter&quot;, shader))
2778         return nullptr;
2779     GCGLint value = 0;
2780     switch (pname) {
2781     case GraphicsContextGL::DELETE_STATUS:
2782         return shader-&gt;isDeleted();
2783     case GraphicsContextGL::COMPILE_STATUS:
2784         m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
2785         return static_cast&lt;bool&gt;(value);
2786     case GraphicsContextGL::SHADER_TYPE:
2787         m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
2788         return static_cast&lt;unsigned&gt;(value);
2789     default:
2790         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getShaderParameter&quot;, &quot;invalid parameter name&quot;);
2791         return nullptr;
2792     }
2793 }
2794 
2795 String WebGLRenderingContextBase::getShaderInfoLog(WebGLShader* shader)
2796 {
2797     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderInfoLog&quot;, shader))
2798         return String();
2799     return ensureNotNull(m_context-&gt;getShaderInfoLog(objectOrZero(shader)));
2800 }
2801 
2802 RefPtr&lt;WebGLShaderPrecisionFormat&gt; WebGLRenderingContextBase::getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType)
2803 {
2804     if (isContextLostOrPending())
2805         return nullptr;
2806     switch (shaderType) {
2807     case GraphicsContextGL::VERTEX_SHADER:
2808     case GraphicsContextGL::FRAGMENT_SHADER:
2809         break;
2810     default:
2811         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid shader type&quot;);
2812         return nullptr;
2813     }
2814     switch (precisionType) {
2815     case GraphicsContextGL::LOW_FLOAT:
2816     case GraphicsContextGL::MEDIUM_FLOAT:
2817     case GraphicsContextGL::HIGH_FLOAT:
2818     case GraphicsContextGL::LOW_INT:
2819     case GraphicsContextGL::MEDIUM_INT:
2820     case GraphicsContextGL::HIGH_INT:
2821         break;
2822     default:
2823         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid precision type&quot;);
2824         return nullptr;
2825     }
2826 
2827     GCGLint range[2] = {0, 0};
2828     GCGLint precision = 0;
2829     m_context-&gt;getShaderPrecisionFormat(shaderType, precisionType, range, &amp;precision);
2830     return WebGLShaderPrecisionFormat::create(range[0], range[1], precision);
2831 }
2832 
2833 String WebGLRenderingContextBase::getShaderSource(WebGLShader* shader)
2834 {
2835     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderSource&quot;, shader))
2836         return String();
2837     return ensureNotNull(shader-&gt;getSource());
2838 }
2839 
2840 WebGLAny WebGLRenderingContextBase::getTexParameter(GCGLenum target, GCGLenum pname)
2841 {
2842     if (isContextLostOrPending())
2843         return nullptr;
2844     auto tex = validateTextureBinding(&quot;getTexParameter&quot;, target, false);
2845     if (!tex)
2846         return nullptr;
2847     GCGLint value = 0;
2848     GCGLfloat fValue = 0;
2849     switch (pname) {
2850     case GraphicsContextGL::TEXTURE_MAG_FILTER:
2851     case GraphicsContextGL::TEXTURE_MIN_FILTER:
2852     case GraphicsContextGL::TEXTURE_WRAP_S:
2853     case GraphicsContextGL::TEXTURE_WRAP_T:
2854         m_context-&gt;getTexParameteriv(target, pname, &amp;value);
2855         return static_cast&lt;unsigned&gt;(value);
2856     case ExtensionsGL::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic
2857         if (m_extTextureFilterAnisotropic) {
2858             m_context-&gt;getTexParameterfv(target, pname, &amp;fValue);
2859             return static_cast&lt;float&gt;(fValue);
2860         }
2861         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);
2862         return nullptr;
2863     default:
2864         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name&quot;);
2865         return nullptr;
2866     }
2867 }
2868 
2869 WebGLAny WebGLRenderingContextBase::getUniform(WebGLProgram* program, const WebGLUniformLocation* uniformLocation)
2870 {
2871     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniform&quot;, program))
2872         return nullptr;
2873     if (!uniformLocation || uniformLocation-&gt;program() != program) {
2874         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getUniform&quot;, &quot;no uniformlocation or not valid for this program&quot;);
2875         return nullptr;
2876     }
2877     GCGLint location = uniformLocation-&gt;location();
2878 
2879     GCGLenum baseType;
2880     unsigned length;
2881     switch (uniformLocation-&gt;type()) {
2882     case GraphicsContextGL::BOOL:
2883         baseType = GraphicsContextGL::BOOL;
2884         length = 1;
2885         break;
2886     case GraphicsContextGL::BOOL_VEC2:
2887         baseType = GraphicsContextGL::BOOL;
2888         length = 2;
2889         break;
2890     case GraphicsContextGL::BOOL_VEC3:
2891         baseType = GraphicsContextGL::BOOL;
2892         length = 3;
2893         break;
2894     case GraphicsContextGL::BOOL_VEC4:
2895         baseType = GraphicsContextGL::BOOL;
2896         length = 4;
2897         break;
2898     case GraphicsContextGL::INT:
2899         baseType = GraphicsContextGL::INT;
2900         length = 1;
2901         break;
2902     case GraphicsContextGL::INT_VEC2:
2903         baseType = GraphicsContextGL::INT;
2904         length = 2;
2905         break;
2906     case GraphicsContextGL::INT_VEC3:
2907         baseType = GraphicsContextGL::INT;
2908         length = 3;
2909         break;
2910     case GraphicsContextGL::INT_VEC4:
2911         baseType = GraphicsContextGL::INT;
2912         length = 4;
2913         break;
2914     case GraphicsContextGL::FLOAT:
2915         baseType = GraphicsContextGL::FLOAT;
2916         length = 1;
2917         break;
2918     case GraphicsContextGL::FLOAT_VEC2:
2919         baseType = GraphicsContextGL::FLOAT;
2920         length = 2;
2921         break;
2922     case GraphicsContextGL::FLOAT_VEC3:
2923         baseType = GraphicsContextGL::FLOAT;
2924         length = 3;
2925         break;
2926     case GraphicsContextGL::FLOAT_VEC4:
2927         baseType = GraphicsContextGL::FLOAT;
2928         length = 4;
2929         break;
2930     case GraphicsContextGL::FLOAT_MAT2:
2931         baseType = GraphicsContextGL::FLOAT;
2932         length = 4;
2933         break;
2934     case GraphicsContextGL::FLOAT_MAT3:
2935         baseType = GraphicsContextGL::FLOAT;
2936         length = 9;
2937         break;
2938     case GraphicsContextGL::FLOAT_MAT4:
2939         baseType = GraphicsContextGL::FLOAT;
2940         length = 16;
2941         break;
2942     case GraphicsContextGL::SAMPLER_2D:
2943     case GraphicsContextGL::SAMPLER_CUBE:
2944         baseType = GraphicsContextGL::INT;
2945         length = 1;
2946         break;
2947     default:
2948         // Can&#39;t handle this type
2949         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getUniform&quot;, &quot;unhandled type&quot;);
2950         return nullptr;
2951     }
2952     switch (baseType) {
2953     case GraphicsContextGL::FLOAT: {
2954         GCGLfloat value[16] = {0};
2955         if (m_isRobustnessEXTSupported)
2956             m_context-&gt;getExtensions().getnUniformfvEXT(objectOrZero(program), location, 16 * sizeof(GCGLfloat), value);
2957         else
2958             m_context-&gt;getUniformfv(objectOrZero(program), location, value);
2959         if (length == 1)
2960             return value[0];
2961         return Float32Array::tryCreate(value, length);
2962     }
2963     case GraphicsContextGL::INT: {
2964         GCGLint value[4] = {0};
2965         if (m_isRobustnessEXTSupported)
2966             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GCGLint), value);
2967         else
2968             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2969         if (length == 1)
2970             return value[0];
2971         return Int32Array::tryCreate(value, length);
2972     }
2973     case GraphicsContextGL::BOOL: {
2974         GCGLint value[4] = {0};
2975         if (m_isRobustnessEXTSupported)
2976             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GCGLint), value);
2977         else
2978             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2979         if (length &gt; 1) {
2980             Vector&lt;bool&gt; vector(length);
2981             for (unsigned j = 0; j &lt; length; j++)
2982                 vector[j] = value[j];
2983             return vector;
2984         }
2985         return static_cast&lt;bool&gt;(value[0]);
2986     }
2987     default:
2988         notImplemented();
2989     }
2990 
2991     // If we get here, something went wrong in our unfortunately complex logic above
2992     synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getUniform&quot;, &quot;unknown error&quot;);
2993     return nullptr;
2994 }
2995 
2996 RefPtr&lt;WebGLUniformLocation&gt; WebGLRenderingContextBase::getUniformLocation(WebGLProgram* program, const String&amp; name)
2997 {
2998     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniformLocation&quot;, program))
2999         return nullptr;
3000     if (!validateLocationLength(&quot;getUniformLocation&quot;, name))
3001         return nullptr;
3002     if (!validateString(&quot;getUniformLocation&quot;, name))
3003         return nullptr;
3004     if (isPrefixReserved(name))
3005         return nullptr;
3006     if (!program-&gt;getLinkStatus()) {
3007         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getUniformLocation&quot;, &quot;program not linked&quot;);
3008         return nullptr;
3009     }
3010     GCGLint uniformLocation = m_context-&gt;getUniformLocation(objectOrZero(program), name);
3011     if (uniformLocation == -1)
3012         return nullptr;
3013 
3014     GCGLint activeUniforms = 0;
3015 #if USE(ANGLE)
3016     m_context-&gt;getProgramiv(objectOrZero(program), GraphicsContextGL::ACTIVE_UNIFORMS, &amp;activeUniforms);
3017 #else
3018     m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), GraphicsContextGL::ACTIVE_UNIFORMS, &amp;activeUniforms);
3019 #endif
3020     for (GCGLint i = 0; i &lt; activeUniforms; i++) {
3021         GraphicsContextGL::ActiveInfo info;
3022         if (!m_context-&gt;getActiveUniform(objectOrZero(program), i, info))
3023             return nullptr;
3024         // Strip &quot;[0]&quot; from the name if it&#39;s an array.
3025         if (info.name.endsWith(&quot;[0]&quot;))
3026             info.name = info.name.left(info.name.length() - 3);
3027         // If it&#39;s an array, we need to iterate through each element, appending &quot;[index]&quot; to the name.
3028         for (GCGLint index = 0; index &lt; info.size; ++index) {
3029             String uniformName = makeString(info.name, &#39;[&#39;, index, &#39;]&#39;);
3030 
3031             if (name == uniformName || name == info.name)
3032                 return WebGLUniformLocation::create(program, uniformLocation, info.type);
3033         }
3034     }
3035     return nullptr;
3036 }
3037 
3038 WebGLAny WebGLRenderingContextBase::getVertexAttrib(GCGLuint index, GCGLenum pname)
3039 {
3040     if (isContextLostOrPending())
3041         return nullptr;
3042 
3043     if (index &gt;= m_maxVertexAttribs) {
3044         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getVertexAttrib&quot;, &quot;index out of range&quot;);
3045         return nullptr;
3046     }
3047 
3048     const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
3049 
3050     if ((isWebGL2() || m_angleInstancedArrays) &amp;&amp; pname == GraphicsContextGL::VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)
3051         return state.divisor;
3052 
3053     switch (pname) {
3054     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
3055         if ((!isGLES2Compliant() &amp;&amp; !index &amp;&amp; m_boundVertexArrayObject-&gt;getVertexAttribState(0).bufferBinding == m_vertexAttrib0Buffer)
3056             || !state.bufferBinding
3057             || !state.bufferBinding-&gt;object())
3058             return nullptr;
3059         return state.bufferBinding;
3060     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_ENABLED:
3061         return state.enabled;
3062     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_NORMALIZED:
3063         return state.normalized;
3064     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_SIZE:
3065         return state.size;
3066     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_STRIDE:
3067         return state.originalStride;
3068     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_TYPE:
3069         return state.type;
3070     case GraphicsContextGL::CURRENT_VERTEX_ATTRIB:
3071         return Float32Array::tryCreate(m_vertexAttribValue[index].value, 4);
3072     default:
3073         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getVertexAttrib&quot;, &quot;invalid parameter name&quot;);
3074         return nullptr;
3075     }
3076 }
3077 
3078 long long WebGLRenderingContextBase::getVertexAttribOffset(GCGLuint index, GCGLenum pname)
3079 {
3080     if (isContextLostOrPending())
3081         return 0;
3082     return m_context-&gt;getVertexAttribOffset(index, pname);
3083 }
3084 
3085 bool WebGLRenderingContextBase::extensionIsEnabled(const String&amp; name)
3086 {
3087 #define CHECK_EXTENSION(variable, nameLiteral) \
3088     if (equalIgnoringASCIICase(name, nameLiteral)) \
3089         return variable != nullptr;
3090 
3091     CHECK_EXTENSION(m_extFragDepth, &quot;EXT_frag_depth&quot;);
3092     CHECK_EXTENSION(m_extBlendMinMax, &quot;EXT_blend_minmax&quot;);
3093     CHECK_EXTENSION(m_extsRGB, &quot;EXT_sRGB&quot;);
3094     CHECK_EXTENSION(m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;);
3095     CHECK_EXTENSION(m_extTextureFilterAnisotropic, &quot;WEBKIT_EXT_texture_filter_anisotropic&quot;);
3096     CHECK_EXTENSION(m_extShaderTextureLOD, &quot;EXT_shader_texture_lod&quot;);
3097     CHECK_EXTENSION(m_oesTextureFloat, &quot;OES_texture_float&quot;);
3098     CHECK_EXTENSION(m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;);
3099     CHECK_EXTENSION(m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;);
3100     CHECK_EXTENSION(m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;);
3101     CHECK_EXTENSION(m_oesStandardDerivatives, &quot;OES_standard_derivatives&quot;);
3102     CHECK_EXTENSION(m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;);
3103     CHECK_EXTENSION(m_oesElementIndexUint, &quot;OES_element_index_uint&quot;);
3104     CHECK_EXTENSION(m_webglLoseContext, &quot;WEBGL_lose_context&quot;);
3105     CHECK_EXTENSION(m_webglDebugRendererInfo, &quot;WEBGL_debug_renderer_info&quot;);
3106     CHECK_EXTENSION(m_webglDebugShaders, &quot;WEBGL_debug_shaders&quot;);
3107     CHECK_EXTENSION(m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;);
3108     CHECK_EXTENSION(m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;);
3109     CHECK_EXTENSION(m_webglCompressedTextureETC, &quot;WEBGL_compressed_texture_etc&quot;);
3110     CHECK_EXTENSION(m_webglCompressedTextureETC1, &quot;WEBGL_compressed_texture_etc1&quot;);
3111     CHECK_EXTENSION(m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;);
3112     CHECK_EXTENSION(m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;);
3113     CHECK_EXTENSION(m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;);
3114     CHECK_EXTENSION(m_webglDrawBuffers, &quot;WEBGL_draw_buffers&quot;);
3115     CHECK_EXTENSION(m_angleInstancedArrays, &quot;ANGLE_instanced_arrays&quot;);
3116     return false;
3117 }
3118 
3119 GCGLboolean WebGLRenderingContextBase::isBuffer(WebGLBuffer* buffer)
3120 {
3121     if (!buffer || isContextLostOrPending())
3122         return 0;
3123 
3124     if (!buffer-&gt;hasEverBeenBound())
3125         return 0;
3126 
3127     return m_context-&gt;isBuffer(buffer-&gt;object());
3128 }
3129 
3130 bool WebGLRenderingContextBase::isContextLost() const
3131 {
3132     return m_contextLost;
3133 }
3134 
3135 bool WebGLRenderingContextBase::isContextLostOrPending()
3136 {
3137     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution) {
3138         LOG(WebGL, &quot;Context is being used. Attempt to resolve the policy.&quot;);
3139         auto* canvas = htmlCanvas();
3140         if (canvas) {
3141             Document&amp; document = canvas-&gt;document().topDocument();
3142             Page* page = document.page();
3143             if (page &amp;&amp; !document.url().isLocalFile())
3144                 page-&gt;mainFrame().loader().client().resolveWebGLPolicyForURL(document.url());
3145             // FIXME: We don&#39;t currently do anything with the result from resolution. A more
3146             // complete implementation might try to construct a real context, etc and proceed
3147             // with normal operation.
3148             // https://bugs.webkit.org/show_bug.cgi?id=129122
3149         }
3150         m_hasRequestedPolicyResolution = true;
3151     }
3152 
3153     return m_contextLost || m_isPendingPolicyResolution;
3154 }
3155 
3156 GCGLboolean WebGLRenderingContextBase::isEnabled(GCGLenum cap)
3157 {
3158     if (isContextLostOrPending() || !validateCapability(&quot;isEnabled&quot;, cap))
3159         return 0;
3160     if (cap == GraphicsContextGL::STENCIL_TEST)
3161         return m_stencilEnabled;
3162     return m_context-&gt;isEnabled(cap);
3163 }
3164 
3165 GCGLboolean WebGLRenderingContextBase::isFramebuffer(WebGLFramebuffer* framebuffer)
3166 {
3167     if (!framebuffer || isContextLostOrPending())
3168         return 0;
3169 
3170     if (!framebuffer-&gt;hasEverBeenBound())
3171         return 0;
3172 
3173     return m_context-&gt;isFramebuffer(framebuffer-&gt;object());
3174 }
3175 
3176 GCGLboolean WebGLRenderingContextBase::isProgram(WebGLProgram* program)
3177 {
3178     if (!program || isContextLostOrPending())
3179         return 0;
3180 
3181     return m_context-&gt;isProgram(program-&gt;object());
3182 }
3183 
3184 GCGLboolean WebGLRenderingContextBase::isRenderbuffer(WebGLRenderbuffer* renderbuffer)
3185 {
3186     if (!renderbuffer || isContextLostOrPending())
3187         return 0;
3188 
3189     if (!renderbuffer-&gt;hasEverBeenBound())
3190         return 0;
3191 
3192     return m_context-&gt;isRenderbuffer(renderbuffer-&gt;object());
3193 }
3194 
3195 GCGLboolean WebGLRenderingContextBase::isShader(WebGLShader* shader)
3196 {
3197     if (!shader || isContextLostOrPending())
3198         return 0;
3199 
3200     return m_context-&gt;isShader(shader-&gt;object());
3201 }
3202 
3203 GCGLboolean WebGLRenderingContextBase::isTexture(WebGLTexture* texture)
3204 {
3205     if (!texture || isContextLostOrPending())
3206         return 0;
3207 
3208     if (!texture-&gt;hasEverBeenBound())
3209         return 0;
3210 
3211     return m_context-&gt;isTexture(texture-&gt;object());
3212 }
3213 
3214 void WebGLRenderingContextBase::lineWidth(GCGLfloat width)
3215 {
3216     if (isContextLostOrPending())
3217         return;
3218     m_context-&gt;lineWidth(width);
3219 }
3220 
3221 void WebGLRenderingContextBase::linkProgram(WebGLProgram* program)
3222 {
3223     if (!linkProgramWithoutInvalidatingAttribLocations(program))
3224         return;
3225 
3226     program-&gt;increaseLinkCount();
3227 }
3228 
3229 bool WebGLRenderingContextBase::linkProgramWithoutInvalidatingAttribLocations(WebGLProgram* program)
3230 {
3231     if (isContextLostOrPending() || !validateWebGLObject(&quot;linkProgram&quot;, program))
3232         return false;
3233 
3234     RefPtr&lt;WebGLShader&gt; vertexShader = program-&gt;getAttachedShader(GraphicsContextGL::VERTEX_SHADER);
3235     RefPtr&lt;WebGLShader&gt; fragmentShader = program-&gt;getAttachedShader(GraphicsContextGL::FRAGMENT_SHADER);
3236     if (!vertexShader || !vertexShader-&gt;isValid() || !fragmentShader || !fragmentShader-&gt;isValid()) {
3237         program-&gt;setLinkStatus(false);
3238         return false;
3239     }
3240 
3241 #if !USE(ANGLE)
3242     if (!m_context-&gt;precisionsMatch(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))
3243         || !m_context-&gt;checkVaryingsPacking(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))) {
3244         program-&gt;setLinkStatus(false);
3245         return false;
3246     }
3247 #endif
3248 
3249     m_context-&gt;linkProgram(objectOrZero(program));
3250     return true;
3251 }
3252 
3253 void WebGLRenderingContextBase::pixelStorei(GCGLenum pname, GCGLint param)
3254 {
3255     if (isContextLostOrPending())
3256         return;
3257     switch (pname) {
3258     case GraphicsContextGL::UNPACK_FLIP_Y_WEBGL:
3259         m_unpackFlipY = param;
3260         break;
3261     case GraphicsContextGL::UNPACK_PREMULTIPLY_ALPHA_WEBGL:
3262         m_unpackPremultiplyAlpha = param;
3263         break;
3264     case GraphicsContextGL::UNPACK_COLORSPACE_CONVERSION_WEBGL:
3265         if (param == GraphicsContextGL::BROWSER_DEFAULT_WEBGL || param == GraphicsContextGL::NONE)
3266             m_unpackColorspaceConversion = static_cast&lt;GCGLenum&gt;(param);
3267         else {
3268             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for UNPACK_COLORSPACE_CONVERSION_WEBGL&quot;);
3269             return;
3270         }
3271         break;
3272     case GraphicsContextGL::PACK_ALIGNMENT:
3273     case GraphicsContextGL::UNPACK_ALIGNMENT:
3274         if (param == 1 || param == 2 || param == 4 || param == 8) {
3275             if (pname == GraphicsContextGL::PACK_ALIGNMENT)
3276                 m_packAlignment = param;
3277             else // GraphicsContextGL::UNPACK_ALIGNMENT:
3278                 m_unpackAlignment = param;
3279             m_context-&gt;pixelStorei(pname, param);
3280         } else {
3281             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for alignment&quot;);
3282             return;
3283         }
3284         break;
3285     default:
3286         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;pixelStorei&quot;, &quot;invalid parameter name&quot;);
3287         return;
3288     }
3289 }
3290 
3291 void WebGLRenderingContextBase::polygonOffset(GCGLfloat factor, GCGLfloat units)
3292 {
3293     if (isContextLostOrPending())
3294         return;
3295     m_context-&gt;polygonOffset(factor, units);
3296 }
3297 
3298 enum class InternalFormatTheme {
3299     None,
3300     NormalizedFixedPoint,
3301     Packed,
3302     SignedNormalizedFixedPoint,
3303     FloatingPoint,
3304     SignedInteger,
3305     UnsignedInteger
3306 };
3307 
3308 static InternalFormatTheme internalFormatTheme(GCGLenum internalFormat)
3309 {
3310     switch (internalFormat) {
3311     case GraphicsContextGL::RGB:
3312     case GraphicsContextGL::RGBA:
3313     case GraphicsContextGL::LUMINANCE_ALPHA:
3314     case GraphicsContextGL::LUMINANCE:
3315     case GraphicsContextGL::ALPHA:
3316     case GraphicsContextGL::R8:
3317     case GraphicsContextGL::RG8:
3318     case GraphicsContextGL::RGB8:
3319     case GraphicsContextGL::SRGB8:
3320     case GraphicsContextGL::RGBA8:
3321     case GraphicsContextGL::SRGB8_ALPHA8:
3322     case GraphicsContextGL::SRGB_ALPHA:
3323         return InternalFormatTheme::NormalizedFixedPoint;
3324     case GraphicsContextGL::RGB565:
3325     case GraphicsContextGL::RGB5_A1:
3326     case GraphicsContextGL::RGBA4:
3327     case GraphicsContextGL::RGB9_E5:
3328     case GraphicsContextGL::RGB10_A2:
3329     case GraphicsContextGL::R11F_G11F_B10F:
3330     case GraphicsContextGL::RGB10_A2UI:
3331         return InternalFormatTheme::Packed;
3332     case GraphicsContextGL::R8_SNORM:
3333     case GraphicsContextGL::RG8_SNORM:
3334     case GraphicsContextGL::RGB8_SNORM:
3335     case GraphicsContextGL::RGBA8_SNORM:
3336         return InternalFormatTheme::SignedNormalizedFixedPoint;
3337     case GraphicsContextGL::R16F:
3338     case GraphicsContextGL::R32F:
3339     case GraphicsContextGL::RG16F:
3340     case GraphicsContextGL::RG32F:
3341     case GraphicsContextGL::RGB16F:
3342     case GraphicsContextGL::RGB32F:
3343     case GraphicsContextGL::RGBA16F:
3344     case GraphicsContextGL::RGBA32F:
3345         return InternalFormatTheme::FloatingPoint;
3346     case GraphicsContextGL::R8I:
3347     case GraphicsContextGL::R16I:
3348     case GraphicsContextGL::R32I:
3349     case GraphicsContextGL::RG8I:
3350     case GraphicsContextGL::RG16I:
3351     case GraphicsContextGL::RG32I:
3352     case GraphicsContextGL::RGB8I:
3353     case GraphicsContextGL::RGB16I:
3354     case GraphicsContextGL::RGB32I:
3355     case GraphicsContextGL::RGBA8I:
3356     case GraphicsContextGL::RGBA16I:
3357     case GraphicsContextGL::RGBA32I:
3358         return InternalFormatTheme::SignedInteger;
3359     case GraphicsContextGL::R8UI:
3360     case GraphicsContextGL::R16UI:
3361     case GraphicsContextGL::R32UI:
3362     case GraphicsContextGL::RG8UI:
3363     case GraphicsContextGL::RG16UI:
3364     case GraphicsContextGL::RG32UI:
3365     case GraphicsContextGL::RGB8UI:
3366     case GraphicsContextGL::RGB16UI:
3367     case GraphicsContextGL::RGB32UI:
3368     case GraphicsContextGL::RGBA8UI:
3369     case GraphicsContextGL::RGBA16UI:
3370     case GraphicsContextGL::RGBA32UI:
3371         return InternalFormatTheme::UnsignedInteger;
3372     default:
3373         return InternalFormatTheme::None;
3374     }
3375 }
3376 
3377 static int numberOfComponentsForFormat(GCGLenum format)
3378 {
3379     switch (format) {
3380     case GraphicsContextGL::RED:
3381     case GraphicsContextGL::RED_INTEGER:
3382         return 1;
3383     case GraphicsContextGL::RG:
3384     case GraphicsContextGL::RG_INTEGER:
3385         return 2;
3386     case GraphicsContextGL::RGB:
3387     case GraphicsContextGL::RGB_INTEGER:
3388         return 3;
3389     case GraphicsContextGL::RGBA:
3390     case GraphicsContextGL::RGBA_INTEGER:
3391         return 4;
3392     default:
3393         return 0;
3394     }
3395 }
3396 
3397 static int numberOfComponentsForInternalFormat(GCGLenum internalFormat)
3398 {
3399     switch (internalFormat) {
3400     case GraphicsContextGL::LUMINANCE:
3401     case GraphicsContextGL::ALPHA:
3402     case GraphicsContextGL::R8:
3403     case GraphicsContextGL::R8_SNORM:
3404     case GraphicsContextGL::R16F:
3405     case GraphicsContextGL::R32F:
3406     case GraphicsContextGL::R8UI:
3407     case GraphicsContextGL::R8I:
3408     case GraphicsContextGL::R16UI:
3409     case GraphicsContextGL::R16I:
3410     case GraphicsContextGL::R32UI:
3411     case GraphicsContextGL::R32I:
3412     case GraphicsContextGL::DEPTH_COMPONENT16:
3413     case GraphicsContextGL::DEPTH_COMPONENT24:
3414     case GraphicsContextGL::DEPTH_COMPONENT32F:
3415         return 1;
3416     case GraphicsContextGL::RG8:
3417     case GraphicsContextGL::LUMINANCE_ALPHA:
3418     case GraphicsContextGL::RG8_SNORM:
3419     case GraphicsContextGL::RG16F:
3420     case GraphicsContextGL::RG32F:
3421     case GraphicsContextGL::RG8UI:
3422     case GraphicsContextGL::RG8I:
3423     case GraphicsContextGL::RG16UI:
3424     case GraphicsContextGL::RG16I:
3425     case GraphicsContextGL::RG32UI:
3426     case GraphicsContextGL::RG32I:
3427     case GraphicsContextGL::DEPTH24_STENCIL8:
3428     case GraphicsContextGL::DEPTH32F_STENCIL8:
3429         return 2;
3430     case GraphicsContextGL::RGB:
3431     case GraphicsContextGL::RGB8:
3432     case GraphicsContextGL::SRGB8:
3433     case GraphicsContextGL::RGB565:
3434     case GraphicsContextGL::RGB8_SNORM:
3435     case GraphicsContextGL::R11F_G11F_B10F:
3436     case GraphicsContextGL::RGB9_E5:
3437     case GraphicsContextGL::RGB16F:
3438     case GraphicsContextGL::RGB32F:
3439     case GraphicsContextGL::RGB8UI:
3440     case GraphicsContextGL::RGB8I:
3441     case GraphicsContextGL::RGB16UI:
3442     case GraphicsContextGL::RGB16I:
3443     case GraphicsContextGL::RGB32UI:
3444     case GraphicsContextGL::RGB32I:
3445         return 3;
3446     case GraphicsContextGL::RGBA:
3447     case GraphicsContextGL::RGBA8:
3448     case GraphicsContextGL::SRGB_ALPHA:
3449     case GraphicsContextGL::SRGB8_ALPHA8:
3450     case GraphicsContextGL::RGBA8_SNORM:
3451     case GraphicsContextGL::RGB5_A1:
3452     case GraphicsContextGL::RGBA4:
3453     case GraphicsContextGL::RGB10_A2:
3454     case GraphicsContextGL::RGBA16F:
3455     case GraphicsContextGL::RGBA32F:
3456     case GraphicsContextGL::RGBA8UI:
3457     case GraphicsContextGL::RGBA8I:
3458     case GraphicsContextGL::RGB10_A2UI:
3459     case GraphicsContextGL::RGBA16UI:
3460     case GraphicsContextGL::RGBA16I:
3461     case GraphicsContextGL::RGBA32UI:
3462     case GraphicsContextGL::RGBA32I:
3463         return 4;
3464     default:
3465         return 0;
3466     }
3467 }
3468 
3469 void WebGLRenderingContextBase::readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, ArrayBufferView&amp; pixels)
3470 {
3471     if (isContextLostOrPending())
3472         return;
3473     // Due to WebGL&#39;s same-origin restrictions, it is not possible to
3474     // taint the origin using the WebGL API.
3475     ASSERT(canvasBase().originClean());
3476 
3477     GCGLenum internalFormat = 0;
3478     if (m_framebufferBinding) {
3479         const char* reason = &quot;framebuffer incomplete&quot;;
3480         if (!m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {
3481             synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;readPixels&quot;, reason);
3482             return;
3483         }
3484         // FIXME: readBuffer() should affect this
3485         internalFormat = m_framebufferBinding-&gt;getColorBufferFormat();
3486     } else {
3487         if (m_attributes.alpha)
3488             internalFormat = GraphicsContextGL::RGBA8;
3489         else
3490             internalFormat = GraphicsContextGL::RGB8;
3491     }
3492 
3493     if (!internalFormat) {
3494         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;readPixels&quot;, &quot;Missing attachment&quot;);
3495         return;
3496     }
3497 
3498     if (isWebGL1()) {
3499         switch (format) {
3500         case GraphicsContextGL::ALPHA:
3501         case GraphicsContextGL::RGB:
3502         case GraphicsContextGL::RGBA:
3503             break;
3504         default:
3505             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid format&quot;);
3506             return;
3507         }
3508         switch (type) {
3509         case GraphicsContextGL::UNSIGNED_BYTE:
3510         case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:
3511         case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:
3512         case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:
3513             break;
3514         case GraphicsContextGL::FLOAT:
3515             if (!m_oesTextureFloat &amp;&amp; !m_oesTextureHalfFloat) {
3516                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);
3517                 return;
3518             }
3519             break;
3520         default:
3521             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);
3522             return;
3523         }
3524         if (format != GraphicsContextGL::RGBA || (type != GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; type != GraphicsContextGL::FLOAT)) {
3525             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;readPixels&quot;, &quot;format not RGBA or type not UNSIGNED_BYTE|FLOAT&quot;);
3526             return;
3527         }
3528     }
3529 
3530     InternalFormatTheme internalFormatTheme = WebCore::internalFormatTheme(internalFormat);
3531     int internalFormatComponentCount = numberOfComponentsForInternalFormat(internalFormat);
3532     if (internalFormatTheme == InternalFormatTheme::None || !internalFormatComponentCount) {
3533         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
3534         return;
3535     }
3536 
3537 #define CHECK_COMPONENT_COUNT \
3538     if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \
3539         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \
3540         return; \
3541     }
3542 
3543 #define INTERNAL_FORMAT_CHECK(typeMacro, pixelTypeMacro) \
3544     if (type != GraphicsContextGLOpenGL::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \
3545         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \
3546         return; \
3547     } \
3548     if (format != GraphicsContextGL::RED &amp;&amp; format != GraphicsContextGL::RG &amp;&amp; format != GraphicsContextGL::RGB &amp;&amp; format != GraphicsContextGL::RGBA) { \
3549         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \
3550         return; \
3551     } \
3552     CHECK_COMPONENT_COUNT
3553 
3554 #define INTERNAL_FORMAT_INTEGER_CHECK(typeMacro, pixelTypeMacro) \
3555     if (type != GraphicsContextGLOpenGL::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \
3556         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \
3557         return; \
3558     } \
3559     if (format != GraphicsContextGL::RED_INTEGER &amp;&amp; format != GraphicsContextGL::RG_INTEGER &amp;&amp; format != GraphicsContextGL::RGB_INTEGER &amp;&amp; format != GraphicsContextGL::RGBA_INTEGER) { \
3560         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \
3561         return; \
3562     } \
3563     CHECK_COMPONENT_COUNT
3564 
3565 #define CASE_PACKED_INTERNAL_FORMAT_CHECK(internalFormatMacro, formatMacro, type0Macro, pixelType0Macro, type1Macro, pixelType1Macro) case GraphicsContextGLOpenGL::internalFormatMacro: \
3566     if (!(type == GraphicsContextGLOpenGL::type0Macro &amp;&amp; pixels.getType() == JSC::pixelType0Macro) \
3567         &amp;&amp; !(type == GraphicsContextGLOpenGL::type1Macro &amp;&amp; pixels.getType() == JSC::pixelType1Macro)) { \
3568         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \
3569         return; \
3570     } \
3571     if (format != GraphicsContextGLOpenGL::formatMacro) { \
3572         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Invalid format&quot;); \
3573         return; \
3574     } \
3575     break;
3576 
3577     switch (internalFormatTheme) {
3578     case InternalFormatTheme::NormalizedFixedPoint:
3579         if (type == GraphicsContextGL::FLOAT) {
3580             INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);
3581         } else {
3582             INTERNAL_FORMAT_CHECK(UNSIGNED_BYTE, TypeUint8);
3583         }
3584         break;
3585     case InternalFormatTheme::SignedNormalizedFixedPoint:
3586         INTERNAL_FORMAT_CHECK(BYTE, TypeInt8);
3587         break;
3588     case InternalFormatTheme::FloatingPoint:
3589         INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);
3590         break;
3591     case InternalFormatTheme::SignedInteger:
3592         INTERNAL_FORMAT_INTEGER_CHECK(INT, TypeInt32);
3593         break;
3594     case InternalFormatTheme::UnsignedInteger:
3595         INTERNAL_FORMAT_INTEGER_CHECK(UNSIGNED_INT, TypeUint32);
3596         break;
3597     case InternalFormatTheme::Packed:
3598         switch (internalFormat) {
3599             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB565        , RGB         , UNSIGNED_SHORT_5_6_5        , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );
3600             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB5_A1       , RGBA        , UNSIGNED_SHORT_5_5_5_1      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );
3601             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGBA4         , RGBA        , UNSIGNED_SHORT_4_4_4_4      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );
3602             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB9_E5       , RGB         , UNSIGNED_INT_5_9_9_9_REV    , TypeUint32, UNSIGNED_INT_5_9_9_9_REV   , TypeUint32 );
3603             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2      , RGBA        , UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );
3604             CASE_PACKED_INTERNAL_FORMAT_CHECK(R11F_G11F_B10F, RGB         , UNSIGNED_INT_10F_11F_11F_REV, TypeUint32, FLOAT                      , TypeFloat32);
3605             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2UI    , RGBA_INTEGER, UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );
3606         }
3607         break;
3608     case InternalFormatTheme::None:
3609         ASSERT_NOT_REACHED();
3610     }
3611 #undef CHECK_COMPONENT_COUNT
3612 #undef INTERNAL_FORMAT_CHECK
3613 #undef INTERNAL_FORMAT_INTEGER_CHECK
3614 #undef CASE_PACKED_INTERNAL_FORMAT_CHECK
3615 
3616     // Calculate array size, taking into consideration of PACK_ALIGNMENT.
3617     unsigned totalBytesRequired = 0;
3618     unsigned padding = 0;
3619     if (!m_isRobustnessEXTSupported) {
3620         GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_packAlignment, &amp;totalBytesRequired, &amp;padding);
3621         if (error != GraphicsContextGL::NO_ERROR) {
3622             synthesizeGLError(error, &quot;readPixels&quot;, &quot;invalid dimensions&quot;);
3623             return;
3624         }
3625         if (pixels.byteLength() &lt; totalBytesRequired) {
3626             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;readPixels&quot;, &quot;ArrayBufferView not large enough for dimensions&quot;);
3627             return;
3628         }
3629     }
3630 
3631     clearIfComposited();
3632     void* data = pixels.baseAddress();
3633 
3634     if (m_isRobustnessEXTSupported)
3635         m_context-&gt;getExtensions().readnPixelsEXT(x, y, width, height, format, type, pixels.byteLength(), data);
3636     else
3637         m_context-&gt;readPixels(x, y, width, height, format, type, data);
3638 }
3639 
3640 void WebGLRenderingContextBase::releaseShaderCompiler()
3641 {
3642     if (isContextLostOrPending())
3643         return;
3644     m_context-&gt;releaseShaderCompiler();
3645 }
3646 
3647 void WebGLRenderingContextBase::sampleCoverage(GCGLfloat value, GCGLboolean invert)
3648 {
3649     if (isContextLostOrPending())
3650         return;
3651     m_context-&gt;sampleCoverage(value, invert);
3652 }
3653 
3654 void WebGLRenderingContextBase::scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
3655 {
3656     if (isContextLostOrPending())
3657         return;
3658     if (!validateSize(&quot;scissor&quot;, width, height))
3659         return;
3660     m_context-&gt;scissor(x, y, width, height);
3661 }
3662 
3663 void WebGLRenderingContextBase::shaderSource(WebGLShader* shader, const String&amp; string)
3664 {
3665     if (isContextLostOrPending() || !validateWebGLObject(&quot;shaderSource&quot;, shader))
3666         return;
3667 #if USE(ANGLE)
3668     m_context-&gt;shaderSource(objectOrZero(shader), string);
3669 #else
3670     String stringWithoutComments = StripComments(string).result();
3671     if (!validateString(&quot;shaderSource&quot;, stringWithoutComments))
3672         return;
3673     m_context-&gt;shaderSource(objectOrZero(shader), stringWithoutComments);
3674 #endif
3675     shader-&gt;setSource(string);
3676 }
3677 
3678 void WebGLRenderingContextBase::stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask)
3679 {
3680     if (isContextLostOrPending())
3681         return;
3682     if (!validateStencilFunc(&quot;stencilFunc&quot;, func))
3683         return;
3684     m_stencilFuncRef = ref;
3685     m_stencilFuncRefBack = ref;
3686     m_stencilFuncMask = mask;
3687     m_stencilFuncMaskBack = mask;
3688     m_context-&gt;stencilFunc(func, ref, mask);
3689 }
3690 
3691 void WebGLRenderingContextBase::stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask)
3692 {
3693     if (isContextLostOrPending())
3694         return;
3695     if (!validateStencilFunc(&quot;stencilFuncSeparate&quot;, func))
3696         return;
3697     switch (face) {
3698     case GraphicsContextGL::FRONT_AND_BACK:
3699         m_stencilFuncRef = ref;
3700         m_stencilFuncRefBack = ref;
3701         m_stencilFuncMask = mask;
3702         m_stencilFuncMaskBack = mask;
3703         break;
3704     case GraphicsContextGL::FRONT:
3705         m_stencilFuncRef = ref;
3706         m_stencilFuncMask = mask;
3707         break;
3708     case GraphicsContextGL::BACK:
3709         m_stencilFuncRefBack = ref;
3710         m_stencilFuncMaskBack = mask;
3711         break;
3712     default:
3713         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;stencilFuncSeparate&quot;, &quot;invalid face&quot;);
3714         return;
3715     }
3716     m_context-&gt;stencilFuncSeparate(face, func, ref, mask);
3717 }
3718 
3719 void WebGLRenderingContextBase::stencilMask(GCGLuint mask)
3720 {
3721     if (isContextLostOrPending())
3722         return;
3723     m_stencilMask = mask;
3724     m_stencilMaskBack = mask;
3725     m_context-&gt;stencilMask(mask);
3726 }
3727 
3728 void WebGLRenderingContextBase::stencilMaskSeparate(GCGLenum face, GCGLuint mask)
3729 {
3730     if (isContextLostOrPending())
3731         return;
3732     switch (face) {
3733     case GraphicsContextGL::FRONT_AND_BACK:
3734         m_stencilMask = mask;
3735         m_stencilMaskBack = mask;
3736         break;
3737     case GraphicsContextGL::FRONT:
3738         m_stencilMask = mask;
3739         break;
3740     case GraphicsContextGL::BACK:
3741         m_stencilMaskBack = mask;
3742         break;
3743     default:
3744         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;stencilMaskSeparate&quot;, &quot;invalid face&quot;);
3745         return;
3746     }
3747     m_context-&gt;stencilMaskSeparate(face, mask);
3748 }
3749 
3750 void WebGLRenderingContextBase::stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass)
3751 {
3752     if (isContextLostOrPending())
3753         return;
3754     m_context-&gt;stencilOp(fail, zfail, zpass);
3755 }
3756 
3757 void WebGLRenderingContextBase::stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass)
3758 {
3759     if (isContextLostOrPending())
3760         return;
3761     m_context-&gt;stencilOpSeparate(face, fail, zfail, zpass);
3762 }
3763 
3764 void WebGLRenderingContextBase::texImage2DBase(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels)
3765 {
3766     // FIXME: For now we ignore any errors returned.
3767     auto tex = validateTextureBinding(&quot;texImage2D&quot;, target, true);
3768     ASSERT(validateTexFuncParameters(&quot;texImage2D&quot;, TexImage, target, level, internalFormat, width, height, border, format, type));
3769     ASSERT(tex);
3770     ASSERT(validateNPOTTextureLevel(width, height, level, &quot;texImage2D&quot;));
3771     if (!pixels) {
3772         if (!m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border, format, type, m_unpackAlignment))
3773             return;
3774     } else {
3775         ASSERT(validateSettableTexInternalFormat(&quot;texImage2D&quot;, internalFormat));
3776         m_context-&gt;moveErrorsToSyntheticErrorList();
3777         m_context-&gt;texImage2D(target, level, internalFormat, width, height,
3778                               border, format, type, pixels);
3779         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
3780             // The texImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
3781             tex-&gt;markInvalid(target, level);
3782             return;
3783         }
3784     }
3785     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, type);
3786 }
3787 
3788 void WebGLRenderingContextBase::texImage2DImpl(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Image* image, GraphicsContextGL::DOMSource domSource, bool flipY, bool premultiplyAlpha)
3789 {
3790     Vector&lt;uint8_t&gt; data;
3791     GraphicsContextGLOpenGL::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContextGL::NONE);
3792     if (!imageExtractor.extractSucceeded()) {
3793         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);
3794         return;
3795     }
3796     GraphicsContextGL::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();
3797     GraphicsContextGL::AlphaOp alphaOp = imageExtractor.imageAlphaOp();
3798     const void* imagePixelData = imageExtractor.imagePixelData();
3799 
3800     bool needConversion = true;
3801     if (type == GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContextGL::DataFormat::RGBA8 &amp;&amp; format == GraphicsContextGL::RGBA &amp;&amp; alphaOp == GraphicsContextGL::AlphaOp::DoNothing &amp;&amp; !flipY)
3802         needConversion = false;
3803     else {
3804         if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
3805             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;packImage error&quot;);
3806             return;
3807         }
3808     }
3809 
3810     if (m_unpackAlignment != 1)
3811         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);
3812     texImage2DBase(target, level, internalformat, image-&gt;width(), image-&gt;height(), 0, format, type, needConversion ? data.data() : imagePixelData);
3813     if (m_unpackAlignment != 1)
3814         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);
3815 }
3816 
3817 bool WebGLRenderingContextBase::validateTexFunc(const char* functionName, TexFuncValidationFunctionType functionType, TexFuncValidationSourceType sourceType, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLint xoffset, GCGLint yoffset)
3818 {
3819     if (!validateTexFuncParameters(functionName, functionType, target, level, internalFormat, width, height, border, format, type))
3820         return false;
3821 
3822     auto texture = validateTextureBinding(functionName, target, true);
3823     if (!texture)
3824         return false;
3825 
3826     if (functionType != TexSubImage) {
3827         if (functionType == TexImage &amp;&amp; texture-&gt;immutable()) {
3828             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;texStorage() called on this texture previously&quot;);
3829             return false;
3830         }
3831         if (!validateNPOTTextureLevel(width, height, level, functionName))
3832             return false;
3833         // For SourceArrayBufferView, function validateTexFuncData() would handle whether to validate the SettableTexFormat
3834         // by checking if the ArrayBufferView is null or not.
3835         if (sourceType != SourceArrayBufferView) {
3836             if (!validateSettableTexInternalFormat(functionName, internalFormat))
3837                 return false;
3838         }
3839     } else {
3840         if (!validateSettableTexInternalFormat(functionName, internalFormat))
3841             return false;
3842         if (!validateSize(functionName, xoffset, yoffset))
3843             return false;
3844         // Before checking if it is in the range, check if overflow happens first.
3845         if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
3846             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;bad dimensions&quot;);
3847             return false;
3848         }
3849         if (xoffset + width &gt; texture-&gt;getWidth(target, level) || yoffset + height &gt; texture-&gt;getHeight(target, level)) {
3850             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;dimensions out of range&quot;);
3851             return false;
3852         }
3853         if (texture-&gt;getInternalFormat(target, level) != internalFormat || (isWebGL1() &amp;&amp; texture-&gt;getType(target, level) != type)) {
3854             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;type and format do not match texture&quot;);
3855             return false;
3856         }
3857     }
3858 
3859     return true;
3860 }
3861 
3862 void WebGLRenderingContextBase::texImage2D(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)
3863 {
3864     if (isContextLostOrPending() || !validateTexFuncData(&quot;texImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullAllowed)
3865         || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceArrayBufferView, target, level, internalFormat, width, height, border, format, type, 0, 0))
3866         return;
3867     void* data = pixels ? pixels-&gt;baseAddress() : 0;
3868     Vector&lt;uint8_t&gt; tempData;
3869     bool changeUnpackAlignment = false;
3870     if (data &amp;&amp; (m_unpackFlipY || m_unpackPremultiplyAlpha)) {
3871         if (!m_context-&gt;extractTextureData(width, height, format, type,
3872                                            m_unpackAlignment,
3873                                            m_unpackFlipY, m_unpackPremultiplyAlpha,
3874                                            data,
3875                                            tempData))
3876             return;
3877         data = tempData.data();
3878         changeUnpackAlignment = true;
3879     }
3880     if (changeUnpackAlignment)
3881         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);
3882     texImage2DBase(target, level, internalFormat, width, height, border, format, type, data);
3883     if (changeUnpackAlignment)
3884         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);
3885 }
3886 
3887 void WebGLRenderingContextBase::texSubImage2DImpl(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Image* image, GraphicsContextGL::DOMSource domSource, bool flipY, bool premultiplyAlpha)
3888 {
3889     Vector&lt;uint8_t&gt; data;
3890     GraphicsContextGLOpenGL::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContextGL::NONE);
3891     if (!imageExtractor.extractSucceeded()) {
3892         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image&quot;);
3893         return;
3894     }
3895     GraphicsContextGL::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();
3896     GraphicsContextGL::AlphaOp alphaOp = imageExtractor.imageAlphaOp();
3897     const void* imagePixelData = imageExtractor.imagePixelData();
3898 
3899     bool needConversion = true;
3900     if (type == GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContextGL::DataFormat::RGBA8 &amp;&amp; format == GraphicsContextGL::RGBA &amp;&amp; alphaOp == GraphicsContextGL::AlphaOp::DoNothing &amp;&amp; !flipY)
3901         needConversion = false;
3902     else {
3903         if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
3904             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);
3905             return;
3906         }
3907     }
3908 
3909     if (m_unpackAlignment != 1)
3910         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);
3911 
3912     texSubImage2DBase(target, level, xoffset, yoffset, image-&gt;width(), image-&gt;height(), format, format, type, needConversion ? data.data() : imagePixelData);
3913 
3914     if (m_unpackAlignment != 1)
3915         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);
3916 }
3917 
3918 void WebGLRenderingContextBase::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)
3919 {
3920     if (isContextLostOrPending())
3921         return;
3922 
3923     auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3924     if (!texture)
3925         return;
3926 
3927     GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);
3928     if (!internalFormat) {
3929         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
3930         return;
3931     }
3932 
3933     if (!validateTexFuncData(&quot;texSubImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullNotAllowed))
3934         return;
3935 
3936     if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceArrayBufferView, target, level, internalFormat, width, height, 0, format, type, xoffset, yoffset))
3937         return;
3938 
3939     void* data = pixels-&gt;baseAddress();
3940     Vector&lt;uint8_t&gt; tempData;
3941     bool changeUnpackAlignment = false;
3942     if (data &amp;&amp; (m_unpackFlipY || m_unpackPremultiplyAlpha)) {
3943         if (!m_context-&gt;extractTextureData(width, height, format, type, m_unpackAlignment, m_unpackFlipY, m_unpackPremultiplyAlpha, data, tempData))
3944             return;
3945         data = tempData.data();
3946         changeUnpackAlignment = true;
3947     }
3948     if (changeUnpackAlignment)
3949         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);
3950 
3951     texSubImage2DBase(target, level, xoffset, yoffset, width, height, internalFormat, format, type, data);
3952 
3953     if (changeUnpackAlignment)
3954         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);
3955 }
3956 
3957 ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt;&amp;&amp; source)
3958 {
3959     if (!source) {
3960         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;source is null&quot;);
3961         return { };
3962     }
3963 
3964     if (isContextLostOrPending())
3965         return { };
3966 
3967     auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
3968         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3969         if (!texture)
3970             return { };
3971 
3972         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);
3973         if (!internalFormat) {
3974             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
3975             return { };
3976         }
3977 
3978         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageBitmap, target, level, internalFormat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, xoffset, yoffset))
3979             return { };
3980 
3981         ImageBuffer* buffer = bitmap-&gt;buffer();
3982         if (!buffer)
3983             return { };
3984 
3985         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(DontCopyBackingStore);
3986         if (image)
3987             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);
3988         return { };
3989     }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
3990         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3991         if (!texture)
3992             return { };
3993 
3994         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);
3995         if (!internalFormat) {
3996             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
3997             return { };
3998         }
3999 
4000         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageData, target, level, internalFormat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, xoffset, yoffset))
4001             return { };
4002 
4003         Vector&lt;uint8_t&gt; data;
4004         bool needConversion = true;
4005         // The data from ImageData is always of format RGBA8.
4006         // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
4007         if (format == GraphicsContextGL::RGBA &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; !m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha)
4008             needConversion = false;
4009         else {
4010             if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
4011                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image data&quot;);
4012                 return { };
4013             }
4014         }
4015         if (m_unpackAlignment != 1)
4016             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);
4017 
4018         texSubImage2DBase(target, level, xoffset, yoffset, pixels-&gt;width(), pixels-&gt;height(), format, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
4019 
4020         if (m_unpackAlignment != 1)
4021             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);
4022 
4023         return { };
4024     } , [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
4025         if (isContextLostOrPending())
4026             return { };
4027         auto validationResult = validateHTMLImageElement(&quot;texSubImage2D&quot;, image.get());
4028         if (validationResult.hasException())
4029             return validationResult.releaseException();
4030         if (!validationResult.returnValue())
4031             return { };
4032 
4033         RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
4034         if (!imageForRender)
4035             return { };
4036 
4037         if (imageForRender-&gt;isSVGImage() || imageForRender-&gt;orientation() != ImageOrientation::None)
4038             imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
4039 
4040         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4041         if (!texture)
4042             return { };
4043 
4044         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);
4045         if (!internalFormat) {
4046             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
4047             return { };
4048         }
4049 
4050         if (!imageForRender || !validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLImageElement, target, level, internalFormat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, xoffset, yoffset))
4051             return { };
4052 
4053         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, imageForRender.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);
4054         return { };
4055     }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
4056         if (isContextLostOrPending())
4057             return { };
4058         auto validationResult = validateHTMLCanvasElement(&quot;texSubImage2D&quot;, canvas.get());
4059         if (validationResult.hasException())
4060             return validationResult.releaseException();
4061         if (!validationResult.returnValue())
4062             return { };
4063 
4064         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4065         if (!texture)
4066             return { };
4067 
4068         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);
4069         if (!internalFormat) {
4070             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
4071             return { };
4072         }
4073 
4074         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLCanvasElement, target, level, internalFormat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, xoffset, yoffset))
4075             return { };
4076 
4077         RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
4078         if (imageData)
4079             texSubImage2D(target, level, xoffset, yoffset, format, type, TexImageSource(imageData.get()));
4080         else
4081             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, canvas-&gt;copiedImage(), GraphicsContextGL::DOMSource::Canvas, m_unpackFlipY, m_unpackPremultiplyAlpha);
4082         return { };
4083     }
4084 #if ENABLE(VIDEO)
4085     , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
4086         if (isContextLostOrPending())
4087             return { };
4088         auto validationResult = validateHTMLVideoElement(&quot;texSubImage2D&quot;, video.get());
4089         if (validationResult.hasException())
4090             return validationResult.releaseException();
4091         if (!validationResult.returnValue())
4092             return { };
4093 
4094         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4095         if (!texture)
4096             return { };
4097 
4098         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);
4099         if (!internalFormat) {
4100             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
4101             return { };
4102         }
4103 
4104         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLVideoElement, target, level, internalFormat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, xoffset, yoffset))
4105             return { };
4106 
4107         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), DontCopyBackingStore);
4108         if (!image)
4109             return { };
4110         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContextGL::DOMSource::Video, m_unpackFlipY, m_unpackPremultiplyAlpha);
4111         return { };
4112     }
4113 #endif
4114     );
4115 
4116     return WTF::visit(visitor, source.value());
4117 }
4118 
4119 bool WebGLRenderingContextBase::validateArrayBufferType(const char* functionName, GCGLenum type, Optional&lt;JSC::TypedArrayType&gt; arrayType)
4120 {
4121 #define TYPE_VALIDATION_CASE(arrayTypeMacro) if (arrayType &amp;&amp; arrayType.value() != JSC::arrayTypeMacro) { \
4122             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;ArrayBufferView not &quot; #arrayTypeMacro); \
4123             return false; \
4124         } \
4125         break;
4126 
4127     switch (type) {
4128     case GraphicsContextGL::UNSIGNED_BYTE:
4129         TYPE_VALIDATION_CASE(TypeUint8);
4130     case GraphicsContextGL::BYTE:
4131         TYPE_VALIDATION_CASE(TypeInt8);
4132     case GraphicsContextGL::UNSIGNED_SHORT:
4133     case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:
4134     case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:
4135     case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:
4136         TYPE_VALIDATION_CASE(TypeUint16);
4137     case GraphicsContextGL::SHORT:
4138         TYPE_VALIDATION_CASE(TypeInt16);
4139     case GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV:
4140     case GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV:
4141     case GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV:
4142     case GraphicsContextGL::UNSIGNED_INT_24_8:
4143     case GraphicsContextGL::UNSIGNED_INT:
4144         TYPE_VALIDATION_CASE(TypeUint32);
4145     case GraphicsContextGL::INT:
4146         TYPE_VALIDATION_CASE(TypeInt32);
4147     case GraphicsContextGL::FLOAT: // OES_texture_float
4148         TYPE_VALIDATION_CASE(TypeFloat32);
4149     case GraphicsContextGL::HALF_FLOAT_OES: // OES_texture_half_float
4150     case GraphicsContextGL::HALF_FLOAT:
4151     case GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV:
4152         TYPE_VALIDATION_CASE(TypeUint16);
4153     default:
4154         ASSERT_NOT_REACHED();
4155         return false;
4156     }
4157 #undef TYPE_VALIDATION_CASE
4158     return true;
4159 }
4160 
4161 bool WebGLRenderingContextBase::validateTexFuncData(const char* functionName, GCGLint level, GCGLsizei width, GCGLsizei height, GCGLenum internalFormat, GCGLenum format, GCGLenum type, ArrayBufferView* pixels, NullDisposition disposition)
4162 {
4163     if (!pixels) {
4164         if (disposition == NullAllowed)
4165             return true;
4166         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no pixels&quot;);
4167         return false;
4168     }
4169 
4170     if (!validateTexFuncFormatAndType(functionName, internalFormat, format, type, level))
4171         return false;
4172     if (!validateSettableTexInternalFormat(functionName, internalFormat))
4173         return false;
4174     if (!validateArrayBufferType(functionName, type, pixels ? Optional&lt;JSC::TypedArrayType&gt;(pixels-&gt;getType()) : WTF::nullopt))
4175         return false;
4176 
4177     unsigned totalBytesRequired;
4178     GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;totalBytesRequired, nullptr);
4179     if (error != GraphicsContextGL::NO_ERROR) {
4180         synthesizeGLError(error, functionName, &quot;invalid texture dimensions&quot;);
4181         return false;
4182     }
4183     if (pixels-&gt;byteLength() &lt; totalBytesRequired) {
4184         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;ArrayBufferView not big enough for request&quot;);
4185         return false;
4186     }
4187     return true;
4188 }
4189 
4190 bool WebGLRenderingContextBase::validateTexFuncParameters(const char* functionName,
4191     TexFuncValidationFunctionType functionType,
4192     GCGLenum target, GCGLint level,
4193     GCGLenum internalformat,
4194     GCGLsizei width, GCGLsizei height, GCGLint border,
4195     GCGLenum format, GCGLenum type)
4196 {
4197     // We absolutely have to validate the format and type combination.
4198     // The texImage2D entry points taking HTMLImage, etc. will produce
4199     // temporary data based on this combination, so it must be legal.
4200     if (!validateTexFuncFormatAndType(functionName, internalformat, format, type, level) || !validateTexFuncLevel(functionName, target, level))
4201         return false;
4202 
4203     if (width &lt; 0 || height &lt; 0) {
4204         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);
4205         return false;
4206     }
4207 
4208     GCGLint maxTextureSizeForLevel = pow(2.0, m_maxTextureLevel - 1 - level);
4209     switch (target) {
4210     case GraphicsContextGL::TEXTURE_2D:
4211         if (width &gt; maxTextureSizeForLevel || height &gt; maxTextureSizeForLevel) {
4212             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height out of range&quot;);
4213             return false;
4214         }
4215         break;
4216     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:
4217     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:
4218     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:
4219     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:
4220     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:
4221     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:
4222         if (functionType != TexSubImage &amp;&amp; width != height) {
4223             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width != height for cube map&quot;);
4224             return false;
4225         }
4226         // No need to check height here. For texImage width == height.
4227         // For texSubImage that will be checked when checking yoffset + height is in range.
4228         if (width &gt; maxTextureSizeForLevel) {
4229             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height out of range for cube map&quot;);
4230             return false;
4231         }
4232         break;
4233     default:
4234         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);
4235         return false;
4236     }
4237 
4238     if (border) {
4239         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;border != 0&quot;);
4240         return false;
4241     }
4242 
4243     return true;
4244 }
4245 
4246 bool WebGLRenderingContextBase::validateTexFuncFormatAndType(const char* functionName, GCGLenum internalFormat, GCGLenum format, GCGLenum type, GCGLint level)
4247 {
4248     switch (format) {
4249     case GraphicsContextGL::ALPHA:
4250     case GraphicsContextGL::LUMINANCE:
4251     case GraphicsContextGL::LUMINANCE_ALPHA:
4252     case GraphicsContextGL::RGB:
4253     case GraphicsContextGL::RGBA:
4254         break;
4255     case GraphicsContextGL::DEPTH_STENCIL:
4256     case GraphicsContextGL::DEPTH_COMPONENT:
4257         if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
4258             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;depth texture formats not enabled&quot;);
4259             return false;
4260         }
4261         if (level &gt; 0) {
4262             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;level must be 0 for depth formats&quot;);
4263             return false;
4264         }
4265         break;
4266     case ExtensionsGL::SRGB_EXT:
4267     case ExtensionsGL::SRGB_ALPHA_EXT:
4268         if (!m_extsRGB) {
4269             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;sRGB texture formats not enabled&quot;);
4270             return false;
4271         }
4272         break;
4273     default:
4274 #if ENABLE(WEBGL2)
4275         if (!isWebGL1()) {
4276             switch (format) {
4277             case GraphicsContextGL::RED:
4278             case GraphicsContextGL::RED_INTEGER:
4279             case GraphicsContextGL::RG:
4280             case GraphicsContextGL::RG_INTEGER:
4281             case GraphicsContextGL::RGB_INTEGER:
4282             case GraphicsContextGL::RGBA_INTEGER:
4283                 break;
4284             default:
4285                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);
4286                 return false;
4287             }
4288         } else
4289 #endif
4290         {
4291             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);
4292             return false;
4293         }
4294     }
4295 
4296     switch (type) {
4297     case GraphicsContextGL::UNSIGNED_BYTE:
4298     case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:
4299     case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:
4300     case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:
4301         break;
4302     case GraphicsContextGL::FLOAT:
4303         if (!m_oesTextureFloat &amp;&amp; isWebGL1()) {
4304             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4305             return false;
4306         }
4307         break;
4308     case GraphicsContextGL::HALF_FLOAT:
4309     case GraphicsContextGL::HALF_FLOAT_OES:
4310         if (!m_oesTextureHalfFloat &amp;&amp; isWebGL1()) {
4311             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4312             return false;
4313         }
4314         break;
4315     case GraphicsContextGL::UNSIGNED_INT:
4316     case GraphicsContextGL::UNSIGNED_INT_24_8:
4317     case GraphicsContextGL::UNSIGNED_SHORT:
4318         if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
4319             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4320             return false;
4321         }
4322         break;
4323     default:
4324 #if ENABLE(WEBGL2)
4325         if (!isWebGL1()) {
4326             switch (type) {
4327             case GraphicsContextGL::BYTE:
4328             case GraphicsContextGL::SHORT:
4329             case GraphicsContextGL::INT:
4330             case GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV:
4331             case GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV:
4332             case GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV:
4333             case GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV:
4334                 break;
4335             default:
4336                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4337                 return false;
4338             }
4339         } else
4340 #endif
4341         {
4342             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4343             return false;
4344         }
4345     }
4346 
4347     // Verify that the combination of internalformat, format, and type is supported.
4348 #define INTERNAL_FORMAT_CASE(internalFormatMacro, formatMacro, type0, type1, type2, type3, type4) case GraphicsContextGLOpenGL::internalFormatMacro: \
4349     if (format != GraphicsContextGLOpenGL::formatMacro) { \
4350         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid format for internalformat&quot;); \
4351         return false; \
4352     } \
4353     if (type != type0 &amp;&amp; type != type1 &amp;&amp; type != type2 &amp;&amp; type != type3 &amp;&amp; type != type4) { \
4354         if (type != GraphicsContextGL::HALF_FLOAT_OES || (type0 != GraphicsContextGL::HALF_FLOAT &amp;&amp; type1 != GraphicsContextGL::HALF_FLOAT &amp;&amp; type2 != GraphicsContextGL::HALF_FLOAT &amp;&amp; type3 != GraphicsContextGL::HALF_FLOAT)) { \
4355             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid type for internalformat&quot;); \
4356             return false; \
4357         } \
4358     } \
4359     break;
4360     switch (internalFormat) {
4361     INTERNAL_FORMAT_CASE(RGB               , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_5_6_5  , GraphicsContextGL::HALF_FLOAT                  , GraphicsContextGL::FLOAT     , 0                       );
4362     INTERNAL_FORMAT_CASE(RGBA              , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4, GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1      , GraphicsContextGL::HALF_FLOAT, GraphicsContextGL::FLOAT);
4363     INTERNAL_FORMAT_CASE(LUMINANCE_ALPHA   , LUMINANCE_ALPHA, GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );
4364     INTERNAL_FORMAT_CASE(LUMINANCE         , LUMINANCE      , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );
4365     INTERNAL_FORMAT_CASE(ALPHA             , ALPHA          , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );
4366     INTERNAL_FORMAT_CASE(R8                , RED            , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4367     INTERNAL_FORMAT_CASE(R8_SNORM          , RED            , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4368     INTERNAL_FORMAT_CASE(R16F              , RED            , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );
4369     INTERNAL_FORMAT_CASE(R32F              , RED            , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4370     INTERNAL_FORMAT_CASE(R8UI              , RED_INTEGER    , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4371     INTERNAL_FORMAT_CASE(R8I               , RED_INTEGER    , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4372     INTERNAL_FORMAT_CASE(R16UI             , RED_INTEGER    , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );
4373     INTERNAL_FORMAT_CASE(R16I              , RED_INTEGER    , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );
4374     INTERNAL_FORMAT_CASE(R32UI             , RED_INTEGER    , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4375     INTERNAL_FORMAT_CASE(R32I              , RED_INTEGER    , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );
4376     INTERNAL_FORMAT_CASE(RG8               , RG             , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4377     INTERNAL_FORMAT_CASE(RG8_SNORM         , RG             , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4378     INTERNAL_FORMAT_CASE(RG16F             , RG             , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );
4379     INTERNAL_FORMAT_CASE(RG32F             , RG             , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4380     INTERNAL_FORMAT_CASE(RG8UI             , RG_INTEGER     , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4381     INTERNAL_FORMAT_CASE(RG8I              , RG_INTEGER     , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4382     INTERNAL_FORMAT_CASE(RG16UI            , RG_INTEGER     , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );
4383     INTERNAL_FORMAT_CASE(RG16I             , RG_INTEGER     , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );
4384     INTERNAL_FORMAT_CASE(RG32UI            , RG_INTEGER     , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4385     INTERNAL_FORMAT_CASE(RG32I             , RG_INTEGER     , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );
4386     INTERNAL_FORMAT_CASE(RGB8              , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4387     INTERNAL_FORMAT_CASE(SRGB8             , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4388     INTERNAL_FORMAT_CASE(RGB565            , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_5_6_5  , 0                                              , 0                            , 0                       );
4389     INTERNAL_FORMAT_CASE(RGB8_SNORM        , RGB            , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4390     INTERNAL_FORMAT_CASE(R11F_G11F_B10F    , RGB            , GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV  , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );
4391     INTERNAL_FORMAT_CASE(RGB9_E5           , RGB            , GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV      , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );
4392     INTERNAL_FORMAT_CASE(RGB16F            , RGB            , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );
4393     INTERNAL_FORMAT_CASE(RGB32F            , RGB            , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4394     INTERNAL_FORMAT_CASE(RGB8UI            , RGB_INTEGER    , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4395     INTERNAL_FORMAT_CASE(RGB8I             , RGB_INTEGER    , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4396     INTERNAL_FORMAT_CASE(RGB16UI           , RGB_INTEGER    , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );
4397     INTERNAL_FORMAT_CASE(RGB16I            , RGB_INTEGER    , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );
4398     INTERNAL_FORMAT_CASE(RGB32UI           , RGB_INTEGER    , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4399     INTERNAL_FORMAT_CASE(RGB32I            , RGB_INTEGER    , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );
4400     INTERNAL_FORMAT_CASE(RGBA8             , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4401     INTERNAL_FORMAT_CASE(SRGB8_ALPHA8      , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4402     INTERNAL_FORMAT_CASE(RGBA8_SNORM       , RGBA           , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4403     INTERNAL_FORMAT_CASE(RGB5_A1           , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1, GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV , 0                            , 0                       );
4404     INTERNAL_FORMAT_CASE(RGBA4             , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4, 0                                              , 0                            , 0                       );
4405     INTERNAL_FORMAT_CASE(RGB10_A2          , RGBA           , GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );
4406     INTERNAL_FORMAT_CASE(RGBA16F           , RGBA           , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );
4407     INTERNAL_FORMAT_CASE(RGBA32F           , RGBA           , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4408     INTERNAL_FORMAT_CASE(RGBA8UI           , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4409     INTERNAL_FORMAT_CASE(RGBA8I            , RGBA_INTEGER   , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4410     INTERNAL_FORMAT_CASE(RGB10_A2UI        , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );
4411     INTERNAL_FORMAT_CASE(RGBA16UI          , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );
4412     INTERNAL_FORMAT_CASE(RGBA16I           , RGBA_INTEGER   , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );
4413     INTERNAL_FORMAT_CASE(RGBA32I           , RGBA_INTEGER   , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );
4414     INTERNAL_FORMAT_CASE(RGBA32UI          , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4415     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT   , DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_SHORT                , GraphicsContextGL::UNSIGNED_INT          , 0                                              , 0                            , 0                       );
4416     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT16 , DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_SHORT                , GraphicsContextGL::UNSIGNED_INT          , 0                                              , 0                            , 0                       );
4417     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT24 , DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4418     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT32F, DEPTH_COMPONENT, GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4419     INTERNAL_FORMAT_CASE(DEPTH_STENCIL     , DEPTH_STENCIL  , GraphicsContextGL::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );
4420     INTERNAL_FORMAT_CASE(DEPTH24_STENCIL8  , DEPTH_STENCIL  , GraphicsContextGL::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );
4421     INTERNAL_FORMAT_CASE(DEPTH32F_STENCIL8 , DEPTH_STENCIL  , GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV, 0                                        , 0                                              , 0                            , 0                       );
4422     case ExtensionsGL::SRGB_EXT:
4423         if (format != internalFormat) {
4424             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);
4425             return false;
4426         }
4427         if (type != GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; type != GraphicsContextGL::UNSIGNED_SHORT_5_6_5 &amp;&amp; type != GraphicsContextGL::FLOAT &amp;&amp; type != GraphicsContextGL::HALF_FLOAT_OES &amp;&amp; type != GraphicsContextGL::HALF_FLOAT) {
4428             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);
4429             return false;
4430         }
4431         break;
4432     case ExtensionsGL::SRGB_ALPHA_EXT:
4433         if (format != internalFormat) {
4434             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);
4435             return false;
4436         }
4437         if (type != GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; type != GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4 &amp;&amp; type != GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1 &amp;&amp; type != GraphicsContextGL::FLOAT &amp;&amp; type != GraphicsContextGL::HALF_FLOAT_OES &amp;&amp; type != GraphicsContextGL::HALF_FLOAT) {
4438             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);
4439             return false;
4440         }
4441         break;
4442     default:
4443         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;Unknown internal format&quot;);
4444         return false;
4445     }
4446 #undef INTERNAL_FORMAT_CASE
4447 
4448     return true;
4449 }
4450 
4451 void WebGLRenderingContextBase::texSubImage2DBase(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum internalFormat, GCGLenum format, GCGLenum type, const void* pixels)
4452 {
4453     ASSERT(!isContextLost());
4454     ASSERT(validateTexFuncParameters(&quot;texSubImage2D&quot;, TexSubImage, target, level, internalFormat, width, height, 0, format, type));
4455     ASSERT(validateSize(&quot;texSubImage2D&quot;, xoffset, yoffset));
4456     ASSERT(validateSettableTexInternalFormat(&quot;texSubImage2D&quot;, internalFormat));
4457     auto tex = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4458     if (!tex) {
4459         ASSERT_NOT_REACHED();
4460         return;
4461     }
4462     ASSERT((xoffset + width) &gt;= 0);
4463     ASSERT((yoffset + height) &gt;= 0);
4464     ASSERT(tex-&gt;getWidth(target, level) &gt;= (xoffset + width));
4465     ASSERT(tex-&gt;getHeight(target, level) &gt;= (yoffset + height));
4466     ASSERT_UNUSED(internalFormat, tex-&gt;getInternalFormat(target, level) == internalFormat);
4467     m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
4468 }
4469 
4470 void WebGLRenderingContextBase::copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border)
4471 {
4472     if (isContextLostOrPending())
4473         return;
4474     if (!validateTexFuncParameters(&quot;copyTexImage2D&quot;, CopyTexImage, target, level, internalFormat, width, height, border, internalFormat, GraphicsContextGL::UNSIGNED_BYTE))
4475         return;
4476     if (!validateSettableTexInternalFormat(&quot;copyTexImage2D&quot;, internalFormat))
4477         return;
4478     auto tex = validateTextureBinding(&quot;copyTexImage2D&quot;, target, true);
4479     if (!tex)
4480         return;
4481     if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
4482         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;copyTexImage2D&quot;, &quot;framebuffer is incompatible format&quot;);
4483         return;
4484     }
4485     if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
4486         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexImage2D&quot;, &quot;level &gt; 0 not power of 2&quot;);
4487         return;
4488     }
4489     const char* reason = &quot;framebuffer incomplete&quot;;
4490     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {
4491         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexImage2D&quot;, reason);
4492         return;
4493     }
4494     clearIfComposited();
4495 
4496     GCGLint clippedX, clippedY;
4497     GCGLsizei clippedWidth, clippedHeight;
4498     if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
4499         m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border,
4500             internalFormat, GraphicsContextGL::UNSIGNED_BYTE, m_unpackAlignment);
4501         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0) {
4502             m_context-&gt;copyTexSubImage2D(target, level, clippedX - x, clippedY - y,
4503                 clippedX, clippedY, clippedWidth, clippedHeight);
4504         }
4505     } else
4506         m_context-&gt;copyTexImage2D(target, level, internalFormat, x, y, width, height, border);
4507 
4508     // FIXME: if the framebuffer is not complete, none of the below should be executed.
4509     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);
4510 }
4511 
4512 static bool isRGBFormat(GCGLenum internalFormat)
4513 {
4514     return internalFormat == GraphicsContextGL::RGB
4515         || internalFormat == GraphicsContextGL::RGBA
4516         || internalFormat == GraphicsContextGL::RGB8
4517         || internalFormat == GraphicsContextGL::RGBA8;
4518 }
4519 
4520 ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt; source)
4521 {
4522     if (!source) {
4523         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;source is null&quot;);
4524         return { };
4525     }
4526 
4527     auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
4528         if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageBitmap, target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, 0, 0))
4529             return { };
4530 
4531         ImageBuffer* buffer = bitmap-&gt;buffer();
4532         if (!buffer)
4533             return { };
4534 
4535         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4536         // If possible, copy from the bitmap directly to the texture
4537         // via the GPU, without a read-back to system memory.
4538         //
4539         // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
4540         // ImageBuffer::copyToPlatformTexture implementations are fully functional.
4541         if (texture
4542             &amp;&amp; (format == GraphicsContextGL::RGB || format == GraphicsContextGL::RGBA)
4543             &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE) {
4544             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4545             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4546                 if (buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4547                     texture-&gt;setLevelInfo(target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), type);
4548                     return { };
4549                 }
4550             }
4551         }
4552 
4553         // Normal pure SW path.
4554         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(DontCopyBackingStore);
4555         if (image)
4556             texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);
4557         return { };
4558     }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
4559         if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageData, target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, 0, 0))
4560             return { };
4561         Vector&lt;uint8_t&gt; data;
4562         bool needConversion = true;
4563         // The data from ImageData is always of format RGBA8.
4564         // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
4565         if (!m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha &amp;&amp; format == GraphicsContextGL::RGBA &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE)
4566             needConversion = false;
4567         else {
4568             if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
4569                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);
4570                 return { };
4571             }
4572         }
4573         if (m_unpackAlignment != 1)
4574             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);
4575         texImage2DBase(target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
4576         if (m_unpackAlignment != 1)
4577             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);
4578         return { };
4579     }, [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
4580         if (isContextLostOrPending())
4581             return { };
4582         auto validationResult = validateHTMLImageElement(&quot;texImage2D&quot;, image.get());
4583         if (validationResult.hasException())
4584             return validationResult.releaseException();
4585         if (!validationResult.returnValue())
4586             return { };
4587 
4588         RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
4589         if (!imageForRender)
4590             return { };
4591 
4592         if (imageForRender-&gt;isSVGImage() || imageForRender-&gt;orientation() != ImageOrientation::None)
4593             imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
4594 
4595         if (!imageForRender || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLImageElement, target, level, internalformat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, 0, 0))
4596             return { };
4597 
4598         texImage2DImpl(target, level, internalformat, format, type, imageForRender.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);
4599         return { };
4600     }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
4601         if (isContextLostOrPending())
4602             return { };
4603         auto validationResult = validateHTMLCanvasElement(&quot;texImage2D&quot;, canvas.get());
4604         if (validationResult.hasException())
4605             return validationResult.releaseException();
4606         if (!validationResult.returnValue())
4607             return { };
4608         if (!validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLCanvasElement, target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, 0, 0))
4609             return { };
4610 
4611         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4612         // If possible, copy from the canvas element directly to the texture
4613         // via the GPU, without a read-back to system memory.
4614         //
4615         // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
4616         // ImageBuffer::copyToPlatformTexture implementations are fully functional.
4617         if (texture
4618             &amp;&amp; (format == GraphicsContextGL::RGB || format == GraphicsContextGL::RGBA)
4619             &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE) {
4620             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4621             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4622                 ImageBuffer* buffer = canvas-&gt;buffer();
4623                 if (buffer &amp;&amp; buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4624                     texture-&gt;setLevelInfo(target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), type);
4625                     return { };
4626                 }
4627             }
4628         }
4629 
4630         RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
4631         if (imageData)
4632             texImage2D(target, level, internalformat, format, type, TexImageSource(imageData.get()));
4633         else
4634             texImage2DImpl(target, level, internalformat, format, type, canvas-&gt;copiedImage(), GraphicsContextGL::DOMSource::Canvas, m_unpackFlipY, m_unpackPremultiplyAlpha);
4635         return { };
4636     }
4637 #if ENABLE(VIDEO)
4638     , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
4639         if (isContextLostOrPending())
4640             return { };
4641         auto validationResult = validateHTMLVideoElement(&quot;texImage2D&quot;, video.get());
4642         if (validationResult.hasException())
4643             return validationResult.releaseException();
4644         if (!validationResult.returnValue())
4645             return { };
4646         if (!validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLVideoElement, target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, 0, 0))
4647             return { };
4648 
4649         // Go through the fast path doing a GPU-GPU textures copy without a readback to system memory if possible.
4650         // Otherwise, it will fall back to the normal SW path.
4651         // FIXME: The current restrictions require that format shoud be RGB or RGBA,
4652         // type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
4653         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4654         if (GraphicsContextGL::TEXTURE_2D == target &amp;&amp; texture
4655             &amp;&amp; (format == GraphicsContextGL::RGB || format == GraphicsContextGL::RGBA)
4656             &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE
4657             &amp;&amp; !level) {
4658             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4659             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4660                 if (video-&gt;copyVideoTextureToPlatformTexture(m_context.get(), texture-&gt;object(), target, level, internalformat, format, type, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4661                     texture-&gt;setLevelInfo(target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), type);
4662                     return { };
4663                 }
4664             }
4665         }
4666 
4667         // Normal pure SW path.
4668         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), DontCopyBackingStore);
4669         if (!image)
4670             return { };
4671         texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContextGL::DOMSource::Video, m_unpackFlipY, m_unpackPremultiplyAlpha);
4672         return { };
4673     }
4674 #endif
4675     );
4676 
4677     return WTF::visit(visitor, source.value());
4678 }
4679 
4680 RefPtr&lt;Image&gt; WebGLRenderingContextBase::drawImageIntoBuffer(Image&amp; image, int width, int height, int deviceScaleFactor)
4681 {
4682     IntSize size(width, height);
4683     size.scale(deviceScaleFactor);
4684     ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
4685     if (!buf) {
4686         synthesizeGLError(GraphicsContextGL::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);
4687         return nullptr;
4688     }
4689 
4690     FloatRect srcRect(FloatPoint(), image.size());
4691     FloatRect destRect(FloatPoint(), size);
4692     buf-&gt;context().drawImage(image, destRect, srcRect);
4693     return buf-&gt;copyImage(DontCopyBackingStore);
4694 }
4695 
4696 #if ENABLE(VIDEO)
4697 
4698 RefPtr&lt;Image&gt; WebGLRenderingContextBase::videoFrameToImage(HTMLVideoElement* video, BackingStoreCopy backingStoreCopy)
4699 {
4700     IntSize size(video-&gt;videoWidth(), video-&gt;videoHeight());
4701     ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
4702     if (!buf) {
4703         synthesizeGLError(GraphicsContextGL::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);
4704         return nullptr;
4705     }
4706     FloatRect destRect(0, 0, size.width(), size.height());
4707     // FIXME: Turn this into a GPU-GPU texture copy instead of CPU readback.
4708     video-&gt;paintCurrentFrameInContext(buf-&gt;context(), destRect);
4709     return buf-&gt;copyImage(backingStoreCopy);
4710 }
4711 
4712 #endif
4713 
4714 void WebGLRenderingContextBase::texParameter(GCGLenum target, GCGLenum pname, GCGLfloat paramf, GCGLint parami, bool isFloat)
4715 {
4716     if (isContextLostOrPending())
4717         return;
4718     auto tex = validateTextureBinding(&quot;texParameter&quot;, target, false);
4719     if (!tex)
4720         return;
4721     switch (pname) {
4722     case GraphicsContextGL::TEXTURE_MIN_FILTER:
4723     case GraphicsContextGL::TEXTURE_MAG_FILTER:
4724         break;
4725     case GraphicsContextGL::TEXTURE_WRAP_S:
4726     case GraphicsContextGL::TEXTURE_WRAP_T:
4727         if ((isFloat &amp;&amp; paramf != GraphicsContextGL::CLAMP_TO_EDGE &amp;&amp; paramf != GraphicsContextGL::MIRRORED_REPEAT &amp;&amp; paramf != GraphicsContextGL::REPEAT)
4728             || (!isFloat &amp;&amp; parami != GraphicsContextGL::CLAMP_TO_EDGE &amp;&amp; parami != GraphicsContextGL::MIRRORED_REPEAT &amp;&amp; parami != GraphicsContextGL::REPEAT)) {
4729             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter&quot;);
4730             return;
4731         }
4732         break;
4733     case ExtensionsGL::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic
4734         if (!m_extTextureFilterAnisotropic) {
4735             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter, EXT_texture_filter_anisotropic not enabled&quot;);
4736             return;
4737         }
4738         break;
4739     default:
4740         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter name&quot;);
4741         return;
4742     }
4743     if (isFloat) {
4744         tex-&gt;setParameterf(pname, paramf);
4745         m_context-&gt;texParameterf(target, pname, paramf);
4746     } else {
4747         tex-&gt;setParameteri(pname, parami);
4748         m_context-&gt;texParameteri(target, pname, parami);
4749     }
4750 }
4751 
4752 void WebGLRenderingContextBase::texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat param)
4753 {
4754     texParameter(target, pname, param, 0, true);
4755 }
4756 
4757 void WebGLRenderingContextBase::texParameteri(GCGLenum target, GCGLenum pname, GCGLint param)
4758 {
4759     texParameter(target, pname, 0, param, false);
4760 }
4761 
4762 void WebGLRenderingContextBase::uniform1f(const WebGLUniformLocation* location, GCGLfloat x)
4763 {
4764     if (isContextLostOrPending() || !location)
4765         return;
4766 
4767     if (location-&gt;program() != m_currentProgram) {
4768         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform1f&quot;, &quot;location not for current program&quot;);
4769         return;
4770     }
4771 
4772     m_context-&gt;uniform1f(location-&gt;location(), x);
4773 }
4774 
4775 void WebGLRenderingContextBase::uniform2f(const WebGLUniformLocation* location, GCGLfloat x, GCGLfloat y)
4776 {
4777     if (isContextLostOrPending() || !location)
4778         return;
4779 
4780     if (location-&gt;program() != m_currentProgram) {
4781         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform2f&quot;, &quot;location not for current program&quot;);
4782         return;
4783     }
4784 
4785     m_context-&gt;uniform2f(location-&gt;location(), x, y);
4786 }
4787 
4788 void WebGLRenderingContextBase::uniform3f(const WebGLUniformLocation* location, GCGLfloat x, GCGLfloat y, GCGLfloat z)
4789 {
4790     if (isContextLostOrPending() || !location)
4791         return;
4792 
4793     if (location-&gt;program() != m_currentProgram) {
4794         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform3f&quot;, &quot;location not for current program&quot;);
4795         return;
4796     }
4797 
4798     m_context-&gt;uniform3f(location-&gt;location(), x, y, z);
4799 }
4800 
4801 void WebGLRenderingContextBase::uniform4f(const WebGLUniformLocation* location, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w)
4802 {
4803     if (isContextLostOrPending() || !location)
4804         return;
4805 
4806     if (location-&gt;program() != m_currentProgram) {
4807         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform4f&quot;, &quot;location not for current program&quot;);
4808         return;
4809     }
4810 
4811     m_context-&gt;uniform4f(location-&gt;location(), x, y, z, w);
4812 }
4813 
4814 void WebGLRenderingContextBase::uniform1i(const WebGLUniformLocation* location, GCGLint x)
4815 {
4816     if (isContextLostOrPending() || !location)
4817         return;
4818 
4819     if (location-&gt;program() != m_currentProgram) {
4820         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform1i&quot;, &quot;location not for current program&quot;);
4821         return;
4822     }
4823 
4824     if ((location-&gt;type() == GraphicsContextGL::SAMPLER_2D || location-&gt;type() == GraphicsContextGL::SAMPLER_CUBE) &amp;&amp; x &gt;= (int)m_textureUnits.size()) {
4825         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;uniform1i&quot;, &quot;invalid texture unit&quot;);
4826         return;
4827     }
4828 
4829     m_context-&gt;uniform1i(location-&gt;location(), x);
4830 }
4831 
4832 void WebGLRenderingContextBase::uniform2i(const WebGLUniformLocation* location, GCGLint x, GCGLint y)
4833 {
4834     if (isContextLostOrPending() || !location)
4835         return;
4836 
4837     if (location-&gt;program() != m_currentProgram) {
4838         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform2i&quot;, &quot;location not for current program&quot;);
4839         return;
4840     }
4841 
4842     m_context-&gt;uniform2i(location-&gt;location(), x, y);
4843 }
4844 
4845 void WebGLRenderingContextBase::uniform3i(const WebGLUniformLocation* location, GCGLint x, GCGLint y, GCGLint z)
4846 {
4847     if (isContextLostOrPending() || !location)
4848         return;
4849 
4850     if (location-&gt;program() != m_currentProgram) {
4851         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform3i&quot;, &quot;location not for current program&quot;);
4852         return;
4853     }
4854 
4855     m_context-&gt;uniform3i(location-&gt;location(), x, y, z);
4856 }
4857 
4858 void WebGLRenderingContextBase::uniform4i(const WebGLUniformLocation* location, GCGLint x, GCGLint y, GCGLint z, GCGLint w)
4859 {
4860     if (isContextLostOrPending() || !location)
4861         return;
4862 
4863     if (location-&gt;program() != m_currentProgram) {
4864         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform4i&quot;, &quot;location not for current program&quot;);
4865         return;
4866     }
4867 
4868     m_context-&gt;uniform4i(location-&gt;location(), x, y, z, w);
4869 }
4870 
4871 void WebGLRenderingContextBase::uniform1fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4872 {
4873     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform1fv&quot;, location, v, 1))
4874         return;
4875 
4876     m_context-&gt;uniform1fv(location-&gt;location(), v.length(), v.data());
4877 }
4878 
4879 void WebGLRenderingContextBase::uniform2fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4880 {
4881     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform2fv&quot;, location, v, 2))
4882         return;
4883 
4884     m_context-&gt;uniform2fv(location-&gt;location(), v.length() / 2, v.data());
4885 }
4886 
4887 void WebGLRenderingContextBase::uniform3fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4888 {
4889     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform3fv&quot;, location, v, 3))
4890         return;
4891 
4892     m_context-&gt;uniform3fv(location-&gt;location(), v.length() / 3, v.data());
4893 }
4894 
4895 void WebGLRenderingContextBase::uniform4fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4896 {
4897     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform4fv&quot;, location, v, 4))
4898         return;
4899 
4900     m_context-&gt;uniform4fv(location-&gt;location(), v.length() / 4, v.data());
4901 }
4902 
4903 void WebGLRenderingContextBase::uniform1iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4904 {
4905     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform1iv&quot;, location, v, 1))
4906         return;
4907 
4908     auto data = v.data();
4909     auto length = v.length();
4910 
4911     if (location-&gt;type() == GraphicsContextGL::SAMPLER_2D || location-&gt;type() == GraphicsContextGL::SAMPLER_CUBE) {
4912         for (auto i = 0; i &lt; length; ++i) {
4913             if (data[i] &gt;= static_cast&lt;int&gt;(m_textureUnits.size())) {
4914                 LOG(WebGL, &quot;Texture unit size=%zu, v[%d]=%d. Location type = %04X.&quot;, m_textureUnits.size(), i, data[i], location-&gt;type());
4915                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;uniform1iv&quot;, &quot;invalid texture unit&quot;);
4916                 return;
4917             }
4918         }
4919     }
4920 
4921     m_context-&gt;uniform1iv(location-&gt;location(), length, data);
4922 }
4923 
4924 void WebGLRenderingContextBase::uniform2iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4925 {
4926     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform2iv&quot;, location, v, 2))
4927         return;
4928 
4929     m_context-&gt;uniform2iv(location-&gt;location(), v.length() / 2, v.data());
4930 }
4931 
4932 void WebGLRenderingContextBase::uniform3iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4933 {
4934     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform3iv&quot;, location, v, 3))
4935         return;
4936 
4937     m_context-&gt;uniform3iv(location-&gt;location(), v.length() / 3, v.data());
4938 }
4939 
4940 void WebGLRenderingContextBase::uniform4iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4941 {
4942     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform4iv&quot;, location, v, 4))
4943         return;
4944 
4945     m_context-&gt;uniform4iv(location-&gt;location(), v.length() / 4, v.data());
4946 }
4947 
4948 void WebGLRenderingContextBase::uniformMatrix2fv(const WebGLUniformLocation* location, GCGLboolean transpose, Float32List&amp;&amp; v)
4949 {
4950     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix2fv&quot;, location, transpose, v, 4))
4951         return;
4952     m_context-&gt;uniformMatrix2fv(location-&gt;location(), v.length() / 4, transpose, v.data());
4953 }
4954 
4955 void WebGLRenderingContextBase::uniformMatrix3fv(const WebGLUniformLocation* location, GCGLboolean transpose, Float32List&amp;&amp; v)
4956 {
4957     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix3fv&quot;, location, transpose, v, 9))
4958         return;
4959     m_context-&gt;uniformMatrix3fv(location-&gt;location(), v.length() / 9, transpose, v.data());
4960 }
4961 
4962 void WebGLRenderingContextBase::uniformMatrix4fv(const WebGLUniformLocation* location, GCGLboolean transpose, Float32List&amp;&amp; v)
4963 {
4964     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix4fv&quot;, location, transpose, v, 16))
4965         return;
4966     m_context-&gt;uniformMatrix4fv(location-&gt;location(), v.length() / 16, transpose, v.data());
4967 }
4968 
4969 void WebGLRenderingContextBase::useProgram(WebGLProgram* program)
4970 {
4971     bool deleted;
4972     if (!checkObjectToBeBound(&quot;useProgram&quot;, program, deleted))
4973         return;
4974     if (deleted)
4975         program = 0;
4976     if (program &amp;&amp; !program-&gt;getLinkStatus()) {
4977         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;useProgram&quot;, &quot;program not valid&quot;);
4978         return;
4979     }
4980     if (m_currentProgram != program) {
4981         if (m_currentProgram)
4982             m_currentProgram-&gt;onDetached(graphicsContextGL());
4983         m_currentProgram = program;
4984         m_context-&gt;useProgram(objectOrZero(program));
4985         if (program)
4986             program-&gt;onAttached();
4987     }
4988 }
4989 
4990 void WebGLRenderingContextBase::validateProgram(WebGLProgram* program)
4991 {
4992     if (isContextLostOrPending() || !validateWebGLObject(&quot;validateProgram&quot;, program))
4993         return;
4994     m_context-&gt;validateProgram(objectOrZero(program));
4995 }
4996 
4997 void WebGLRenderingContextBase::vertexAttrib1f(GCGLuint index, GCGLfloat v0)
4998 {
4999     vertexAttribfImpl(&quot;vertexAttrib1f&quot;, index, 1, v0, 0.0f, 0.0f, 1.0f);
5000 }
5001 
5002 void WebGLRenderingContextBase::vertexAttrib2f(GCGLuint index, GCGLfloat v0, GCGLfloat v1)
5003 {
5004     vertexAttribfImpl(&quot;vertexAttrib2f&quot;, index, 2, v0, v1, 0.0f, 1.0f);
5005 }
5006 
5007 void WebGLRenderingContextBase::vertexAttrib3f(GCGLuint index, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2)
5008 {
5009     vertexAttribfImpl(&quot;vertexAttrib3f&quot;, index, 3, v0, v1, v2, 1.0f);
5010 }
5011 
5012 void WebGLRenderingContextBase::vertexAttrib4f(GCGLuint index, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2, GCGLfloat v3)
5013 {
5014     vertexAttribfImpl(&quot;vertexAttrib4f&quot;, index, 4, v0, v1, v2, v3);
5015 }
5016 
5017 void WebGLRenderingContextBase::vertexAttrib1fv(GCGLuint index, Float32List&amp;&amp; v)
5018 {
5019     vertexAttribfvImpl(&quot;vertexAttrib1fv&quot;, index, WTFMove(v), 1);
5020 }
5021 
5022 void WebGLRenderingContextBase::vertexAttrib2fv(GCGLuint index, Float32List&amp;&amp; v)
5023 {
5024     vertexAttribfvImpl(&quot;vertexAttrib2fv&quot;, index, WTFMove(v), 2);
5025 }
5026 
5027 void WebGLRenderingContextBase::vertexAttrib3fv(GCGLuint index, Float32List&amp;&amp; v)
5028 {
5029     vertexAttribfvImpl(&quot;vertexAttrib3fv&quot;, index, WTFMove(v), 3);
5030 }
5031 
5032 void WebGLRenderingContextBase::vertexAttrib4fv(GCGLuint index, Float32List&amp;&amp; v)
5033 {
5034     vertexAttribfvImpl(&quot;vertexAttrib4fv&quot;, index, WTFMove(v), 4);
5035 }
5036 
5037 void WebGLRenderingContextBase::vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized, GCGLsizei stride, long long offset)
5038 {
5039     if (isContextLostOrPending())
5040         return;
5041     switch (type) {
5042     case GraphicsContextGL::BYTE:
5043     case GraphicsContextGL::UNSIGNED_BYTE:
5044     case GraphicsContextGL::SHORT:
5045     case GraphicsContextGL::UNSIGNED_SHORT:
5046     case GraphicsContextGL::FLOAT:
5047         break;
5048     default:
5049         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);
5050         return;
5051     }
5052     if (index &gt;= m_maxVertexAttribs) {
5053         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;index out of range&quot;);
5054         return;
5055     }
5056     if (size &lt; 1 || size &gt; 4) {
5057         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad size&quot;);
5058         return;
5059     }
5060     if (stride &lt; 0 || stride &gt; 255) {
5061         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad stride&quot;);
5062         return;
5063     }
5064     if (offset &lt; 0 || offset &gt; std::numeric_limits&lt;int32_t&gt;::max()) {
5065         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad offset&quot;);
5066         return;
5067     }
5068     if (!m_boundArrayBuffer &amp;&amp; offset) {
5069         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;no bound ARRAY_BUFFER&quot;);
5070         return;
5071     }
5072     // Determine the number of elements the bound buffer can hold, given the offset, size, type and stride
5073     auto typeSize = sizeInBytes(type);
5074     if (!typeSize) {
5075         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);
5076         return;
5077     }
5078     if ((stride % typeSize) || (static_cast&lt;GCGLintptr&gt;(offset) % typeSize)) {
5079         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;stride or offset not valid for type&quot;);
5080         return;
5081     }
5082     GCGLsizei bytesPerElement = size * typeSize;
5083 
5084     m_boundVertexArrayObject-&gt;setVertexAttribState(index, bytesPerElement, size, type, normalized, stride, static_cast&lt;GCGLintptr&gt;(offset), m_boundArrayBuffer.get());
5085     m_context-&gt;vertexAttribPointer(index, size, type, normalized, stride, static_cast&lt;GCGLintptr&gt;(offset));
5086 }
5087 
5088 void WebGLRenderingContextBase::viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
5089 {
5090     if (isContextLostOrPending())
5091         return;
5092     if (!validateSize(&quot;viewport&quot;, width, height))
5093         return;
5094     m_context-&gt;viewport(x, y, width, height);
5095 }
5096 
5097 void WebGLRenderingContextBase::forceLostContext(WebGLRenderingContextBase::LostContextMode mode)
5098 {
5099     if (isContextLostOrPending()) {
5100         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;loseContext&quot;, &quot;context already lost&quot;);
5101         return;
5102     }
5103 
5104     m_contextGroup-&gt;loseContextGroup(mode);
5105 }
5106 
5107 void WebGLRenderingContextBase::loseContextImpl(WebGLRenderingContextBase::LostContextMode mode)
5108 {
5109     if (isContextLost())
5110         return;
5111 
5112     m_contextLost = true;
5113     m_contextLostMode = mode;
5114 
5115     if (mode == RealLostContext) {
5116         // Inform the embedder that a lost context was received. In response, the embedder might
5117         // decide to take action such as asking the user for permission to use WebGL again.
5118         auto* canvas = htmlCanvas();
5119         if (canvas) {
5120             if (RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame())
5121                 frame-&gt;loader().client().didLoseWebGLContext(m_context-&gt;getExtensions().getGraphicsResetStatusARB());
5122         }
5123     }
5124 
5125     detachAndRemoveAllObjects();
5126 
5127     // There is no direct way to clear errors from a GL implementation and
5128     // looping until getError() becomes NO_ERROR might cause an infinite loop if
5129     // the driver or context implementation had a bug. So, loop a reasonably
5130     // large number of times to clear any existing errors.
5131     for (int i = 0; i &lt; 100; ++i) {
5132         if (m_context-&gt;getError() == GraphicsContextGL::NO_ERROR)
5133             break;
5134     }
5135     ConsoleDisplayPreference display = (mode == RealLostContext) ? DisplayInConsole: DontDisplayInConsole;
5136     synthesizeGLError(GraphicsContextGL::CONTEXT_LOST_WEBGL, &quot;loseContext&quot;, &quot;context lost&quot;, display);
5137 
5138     // Don&#39;t allow restoration unless the context lost event has both been
5139     // dispatched and its default behavior prevented.
5140     m_restoreAllowed = false;
5141 
5142     // Always defer the dispatch of the context lost event, to implement
5143     // the spec behavior of queueing a task.
5144     m_dispatchContextLostEventTimer.startOneShot(0_s);
5145 }
5146 
5147 void WebGLRenderingContextBase::forceRestoreContext()
5148 {
5149     if (!isContextLostOrPending()) {
5150         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context not lost&quot;);
5151         return;
5152     }
5153 
5154     if (!m_restoreAllowed) {
5155         if (m_contextLostMode == SyntheticLostContext)
5156             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context restoration not allowed&quot;);
5157         return;
5158     }
5159 
5160     if (!m_restoreTimer.isActive())
5161         m_restoreTimer.startOneShot(0_s);
5162 }
5163 
5164 PlatformLayer* WebGLRenderingContextBase::platformLayer() const
5165 {
5166     return (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) ? m_context-&gt;platformLayer() : 0;
5167 }
5168 
5169 void WebGLRenderingContextBase::removeSharedObject(WebGLSharedObject&amp; object)
5170 {
5171     if (m_isPendingPolicyResolution)
5172         return;
5173 
5174     m_contextGroup-&gt;removeObject(object);
5175 }
5176 
5177 void WebGLRenderingContextBase::addSharedObject(WebGLSharedObject&amp; object)
5178 {
5179     if (m_isPendingPolicyResolution)
5180         return;
5181 
5182     ASSERT(!isContextLost());
5183     m_contextGroup-&gt;addObject(object);
5184 }
5185 
5186 void WebGLRenderingContextBase::removeContextObject(WebGLContextObject&amp; object)
5187 {
5188     if (m_isPendingPolicyResolution)
5189         return;
5190 
5191     m_contextObjects.remove(&amp;object);
5192 }
5193 
5194 void WebGLRenderingContextBase::addContextObject(WebGLContextObject&amp; object)
5195 {
5196     if (m_isPendingPolicyResolution)
5197         return;
5198 
5199     ASSERT(!isContextLost());
5200     m_contextObjects.add(&amp;object);
5201 }
5202 
5203 void WebGLRenderingContextBase::detachAndRemoveAllObjects()
5204 {
5205     if (m_isPendingPolicyResolution)
5206         return;
5207 
5208     while (m_contextObjects.size() &gt; 0) {
5209         HashSet&lt;WebGLContextObject*&gt;::iterator it = m_contextObjects.begin();
5210         (*it)-&gt;detachContext();
5211     }
5212 }
5213 
5214 bool WebGLRenderingContextBase::hasPendingActivity() const
5215 {
5216     return false;
5217 }
5218 
5219 void WebGLRenderingContextBase::stop()
5220 {
5221     if (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) {
5222         forceLostContext(SyntheticLostContext);
5223         destroyGraphicsContextGL();
5224     }
5225 }
5226 
5227 const char* WebGLRenderingContextBase::activeDOMObjectName() const
5228 {
5229     return &quot;WebGLRenderingContext&quot;;
5230 }
5231 
5232 void WebGLRenderingContextBase::suspend(ReasonForSuspension)
5233 {
5234     m_isSuspended = true;
5235 }
5236 
5237 void WebGLRenderingContextBase::resume()
5238 {
5239     m_isSuspended = false;
5240 }
5241 
5242 bool WebGLRenderingContextBase::getBooleanParameter(GCGLenum pname)
5243 {
5244     GCGLboolean value = 0;
5245     m_context-&gt;getBooleanv(pname, &amp;value);
5246     return value;
5247 }
5248 
5249 Vector&lt;bool&gt; WebGLRenderingContextBase::getBooleanArrayParameter(GCGLenum pname)
5250 {
5251     if (pname != GraphicsContextGL::COLOR_WRITEMASK) {
5252         notImplemented();
5253         return { };
5254     }
5255     GCGLboolean value[4] = { 0 };
5256     m_context-&gt;getBooleanv(pname, value);
5257     Vector&lt;bool&gt; vector(4);
5258     for (unsigned i = 0; i &lt; 4; ++i)
5259         vector[i] = value[i];
5260     return vector;
5261 }
5262 
5263 float WebGLRenderingContextBase::getFloatParameter(GCGLenum pname)
5264 {
5265     GCGLfloat value = 0;
5266     m_context-&gt;getFloatv(pname, &amp;value);
5267     return value;
5268 }
5269 
5270 int WebGLRenderingContextBase::getIntParameter(GCGLenum pname)
5271 {
5272     GCGLint value = 0;
5273     m_context-&gt;getIntegerv(pname, &amp;value);
5274     return value;
5275 }
5276 
5277 unsigned WebGLRenderingContextBase::getUnsignedIntParameter(GCGLenum pname)
5278 {
5279     GCGLint value = 0;
5280     m_context-&gt;getIntegerv(pname, &amp;value);
5281     return value;
5282 }
5283 
5284 long long WebGLRenderingContextBase::getInt64Parameter(GCGLenum pname)
5285 {
5286     GCGLint64 value = 0;
5287     m_context-&gt;getInteger64v(pname, &amp;value);
5288     return value;
5289 }
5290 
5291 RefPtr&lt;Float32Array&gt; WebGLRenderingContextBase::getWebGLFloatArrayParameter(GCGLenum pname)
5292 {
5293     GCGLfloat value[4] = {0};
5294     m_context-&gt;getFloatv(pname, value);
5295     unsigned length = 0;
5296     switch (pname) {
5297     case GraphicsContextGL::ALIASED_POINT_SIZE_RANGE:
5298     case GraphicsContextGL::ALIASED_LINE_WIDTH_RANGE:
5299     case GraphicsContextGL::DEPTH_RANGE:
5300         length = 2;
5301         break;
5302     case GraphicsContextGL::BLEND_COLOR:
5303     case GraphicsContextGL::COLOR_CLEAR_VALUE:
5304         length = 4;
5305         break;
5306     default:
5307         notImplemented();
5308     }
5309     return Float32Array::tryCreate(value, length);
5310 }
5311 
5312 RefPtr&lt;Int32Array&gt; WebGLRenderingContextBase::getWebGLIntArrayParameter(GCGLenum pname)
5313 {
5314     GCGLint value[4] = {0};
5315     m_context-&gt;getIntegerv(pname, value);
5316     unsigned length = 0;
5317     switch (pname) {
5318     case GraphicsContextGL::MAX_VIEWPORT_DIMS:
5319         length = 2;
5320         break;
5321     case GraphicsContextGL::SCISSOR_BOX:
5322     case GraphicsContextGL::VIEWPORT:
5323         length = 4;
5324         break;
5325     default:
5326         notImplemented();
5327     }
5328     return Int32Array::tryCreate(value, length);
5329 }
5330 
5331 bool WebGLRenderingContextBase::checkTextureCompleteness(const char* functionName, bool prepareToDraw)
5332 {
5333     bool resetActiveUnit = false;
5334     bool usesAtLeastOneBlackTexture = false;
5335     WebGLTexture::TextureExtensionFlag extensions = textureExtensionFlags();
5336 
5337     Vector&lt;unsigned&gt; noLongerUnrenderable;
5338     for (unsigned badTexture : m_unrenderableTextureUnits) {
5339         ASSERT(badTexture &lt; m_textureUnits.size());
5340         auto&amp; textureUnit = m_textureUnits[badTexture];
5341         bool needsToUseBlack2DTexture = textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(extensions);
5342         bool needsToUseBlack3DTexture = textureUnit.textureCubeMapBinding &amp;&amp; textureUnit.textureCubeMapBinding-&gt;needToUseBlackTexture(extensions);
5343 
5344         if (!needsToUseBlack2DTexture &amp;&amp; !needsToUseBlack3DTexture) {
5345             noLongerUnrenderable.append(badTexture);
5346             continue;
5347         }
5348 
5349         usesAtLeastOneBlackTexture = true;
5350 
5351         if (badTexture != m_activeTextureUnit) {
5352             m_context-&gt;activeTexture(badTexture + GraphicsContextGL::TEXTURE0);
5353             resetActiveUnit = true;
5354         } else if (resetActiveUnit) {
5355             m_context-&gt;activeTexture(badTexture + GraphicsContextGL::TEXTURE0);
5356             resetActiveUnit = false;
5357         }
5358         RefPtr&lt;WebGLTexture&gt; tex2D;
5359         RefPtr&lt;WebGLTexture&gt; texCubeMap;
5360         if (prepareToDraw) {
5361             printToConsole(MessageLevel::Error, makeString(&quot;WebGL: &quot;, functionName, &quot;: texture bound to texture unit &quot;, badTexture,
5362                 &quot; is not renderable. It maybe non-power-of-2 and have incompatible texture filtering or is not &#39;texture complete&#39;,&quot;
5363                 &quot; or it is a float/half-float type with linear filtering and without the relevant float/half-float linear extension enabled.&quot;));
5364             tex2D = m_blackTexture2D.get();
5365             texCubeMap = m_blackTextureCubeMap.get();
5366         } else {
5367             tex2D = textureUnit.texture2DBinding.get();
5368             texCubeMap = textureUnit.textureCubeMapBinding.get();
5369         }
5370         if (needsToUseBlack2DTexture)
5371             m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, objectOrZero(tex2D.get()));
5372         if (needsToUseBlack3DTexture)
5373             m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_CUBE_MAP, objectOrZero(texCubeMap.get()));
5374     }
5375     if (resetActiveUnit)
5376         m_context-&gt;activeTexture(m_activeTextureUnit + GraphicsContextGL::TEXTURE0);
5377 
5378     for (unsigned renderable : noLongerUnrenderable)
5379         m_unrenderableTextureUnits.remove(renderable);
5380 
5381     return usesAtLeastOneBlackTexture;
5382 }
5383 
5384 void WebGLRenderingContextBase::createFallbackBlackTextures1x1()
5385 {
5386     unsigned char black[] = {0, 0, 0, 255};
5387     m_blackTexture2D = createTexture();
5388     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, m_blackTexture2D-&gt;object());
5389     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::RGBA, 1, 1,
5390         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);
5391     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, 0);
5392     m_blackTextureCubeMap = createTexture();
5393     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_CUBE_MAP, m_blackTextureCubeMap-&gt;object());
5394     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X, 0, GraphicsContextGL::RGBA, 1, 1,
5395         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);
5396     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GraphicsContextGL::RGBA, 1, 1,
5397         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);
5398     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GraphicsContextGL::RGBA, 1, 1,
5399         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);
5400     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GraphicsContextGL::RGBA, 1, 1,
5401         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);
5402     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GraphicsContextGL::RGBA, 1, 1,
5403         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);
5404     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GraphicsContextGL::RGBA, 1, 1,
5405         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);
5406     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_CUBE_MAP, 0);
5407 }
5408 
5409 bool WebGLRenderingContextBase::isTexInternalFormatColorBufferCombinationValid(GCGLenum texInternalFormat, GCGLenum colorBufferFormat)
5410 {
5411     auto need = GraphicsContextGLOpenGL::getChannelBitsByFormat(texInternalFormat);
5412     auto have = GraphicsContextGLOpenGL::getChannelBitsByFormat(colorBufferFormat);
5413     return (need &amp; have) == need;
5414 }
5415 
5416 GCGLenum WebGLRenderingContextBase::getBoundFramebufferColorFormat()
5417 {
5418     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5419         return m_framebufferBinding-&gt;getColorBufferFormat();
5420     if (m_attributes.alpha)
5421         return GraphicsContextGL::RGBA;
5422     return GraphicsContextGL::RGB;
5423 }
5424 
5425 int WebGLRenderingContextBase::getBoundFramebufferWidth()
5426 {
5427     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5428         return m_framebufferBinding-&gt;getColorBufferWidth();
5429     return m_context-&gt;getInternalFramebufferSize().width();
5430 }
5431 
5432 int WebGLRenderingContextBase::getBoundFramebufferHeight()
5433 {
5434     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5435         return m_framebufferBinding-&gt;getColorBufferHeight();
5436     return m_context-&gt;getInternalFramebufferSize().height();
5437 }
5438 
5439 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::validateTextureBinding(const char* functionName, GCGLenum target, bool useSixEnumsForCubeMap)
5440 {
5441     RefPtr&lt;WebGLTexture&gt; texture;
5442     switch (target) {
5443     case GraphicsContextGL::TEXTURE_2D:
5444         texture = m_textureUnits[m_activeTextureUnit].texture2DBinding;
5445         break;
5446     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:
5447     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:
5448     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:
5449     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:
5450     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:
5451     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:
5452         if (!useSixEnumsForCubeMap) {
5453             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);
5454             return nullptr;
5455         }
5456         texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
5457         break;
5458     case GraphicsContextGL::TEXTURE_CUBE_MAP:
5459         if (useSixEnumsForCubeMap) {
5460             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);
5461             return nullptr;
5462         }
5463         texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
5464         break;
5465     default:
5466         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);
5467         return nullptr;
5468     }
5469 
5470     if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
5471         m_unrenderableTextureUnits.add(m_activeTextureUnit);
5472 
5473     if (!texture)
5474         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;no texture&quot;);
5475     return texture;
5476 }
5477 
5478 bool WebGLRenderingContextBase::validateLocationLength(const char* functionName, const String&amp; string)
5479 {
5480     const unsigned maxWebGLLocationLength = 256;
5481     if (string.length() &gt; maxWebGLLocationLength) {
5482         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;location length &gt; 256&quot;);
5483         return false;
5484     }
5485     return true;
5486 }
5487 
5488 bool WebGLRenderingContextBase::validateSize(const char* functionName, GCGLint x, GCGLint y)
5489 {
5490     if (x &lt; 0 || y &lt; 0) {
5491         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;size &lt; 0&quot;);
5492         return false;
5493     }
5494     return true;
5495 }
5496 
5497 bool WebGLRenderingContextBase::validateString(const char* functionName, const String&amp; string)
5498 {
5499     for (size_t i = 0; i &lt; string.length(); ++i) {
5500         if (!validateCharacter(string[i])) {
5501             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;string not ASCII&quot;);
5502             return false;
5503         }
5504     }
5505     return true;
5506 }
5507 
5508 bool WebGLRenderingContextBase::validateTexFuncLevel(const char* functionName, GCGLenum target, GCGLint level)
5509 {
5510     if (level &lt; 0) {
5511         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level &lt; 0&quot;);
5512         return false;
5513     }
5514     switch (target) {
5515     case GraphicsContextGL::TEXTURE_2D:
5516         if (level &gt;= m_maxTextureLevel) {
5517             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level out of range&quot;);
5518             return false;
5519         }
5520         break;
5521     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:
5522     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:
5523     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:
5524     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:
5525     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:
5526     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:
5527         if (level &gt;= m_maxCubeMapTextureLevel) {
5528             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level out of range&quot;);
5529             return false;
5530         }
5531         break;
5532     }
5533     // This function only checks if level is legal, so we return true and don&#39;t
5534     // generate INVALID_ENUM if target is illegal.
5535     return true;
5536 }
5537 
5538 bool WebGLRenderingContextBase::validateCompressedTexFormat(GCGLenum format)
5539 {
5540     return m_compressedTextureFormats.contains(format);
5541 }
5542 
5543 struct BlockParameters {
5544     const int width;
5545     const int height;
5546     const int size;
5547 };
5548 
5549 static inline unsigned calculateBytesForASTC(GCGLsizei width, GCGLsizei height, const BlockParameters&amp; parameters)
5550 {
5551     return ((width + parameters.width - 1) / parameters.width) * ((height + parameters.height - 1) / parameters.height) * parameters.size;
5552 }
5553 
5554 bool WebGLRenderingContextBase::validateCompressedTexFuncData(const char* functionName, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; pixels)
5555 {
5556     if (width &lt; 0 || height &lt; 0) {
5557         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);
5558         return false;
5559     }
5560 
5561     unsigned bytesRequired = 0;
5562 
5563     // Block parameters for ASTC formats
5564     const int kASTCBlockSize = 16;
5565     static const BlockParameters ASTCParameters[] {
5566         BlockParameters { 4, 4, kASTCBlockSize },
5567         BlockParameters { 5, 4, kASTCBlockSize },
5568         BlockParameters { 5, 5, kASTCBlockSize },
5569         BlockParameters { 6, 5, kASTCBlockSize },
5570         BlockParameters { 6, 6, kASTCBlockSize },
5571         BlockParameters { 8, 5, kASTCBlockSize },
5572         BlockParameters { 8, 6, kASTCBlockSize },
5573         BlockParameters { 8, 8, kASTCBlockSize },
5574         BlockParameters { 10, 5, kASTCBlockSize },
5575         BlockParameters { 10, 6, kASTCBlockSize },
5576         BlockParameters { 10, 8, kASTCBlockSize },
5577         BlockParameters { 10, 10, kASTCBlockSize },
5578         BlockParameters { 12, 10, kASTCBlockSize },
5579         BlockParameters { 12, 12, kASTCBlockSize }
5580     };
5581     const GCGLenum ASTCEnumStartRGBA = ExtensionsGL::COMPRESSED_RGBA_ASTC_4x4_KHR;
5582     const GCGLenum ASTCEnumStartSRGB8 = ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
5583 
5584     const int kEACAndETC2BlockSize = 4;
5585 
5586     switch (format) {
5587     case ExtensionsGL::COMPRESSED_RGB_S3TC_DXT1_EXT:
5588     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT1_EXT:
5589     case ExtensionsGL::COMPRESSED_ATC_RGB_AMD:
5590     case ExtensionsGL::ETC1_RGB8_OES: {
5591         const int kBlockSize = 8;
5592         const int kBlockWidth = 4;
5593         const int kBlockHeight = 4;
5594         int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;
5595         int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;
5596         bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;
5597         break;
5598     }
5599     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT3_EXT:
5600     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT5_EXT:
5601     case ExtensionsGL::COMPRESSED_ATC_RGBA_EXPLICIT_ALPHA_AMD:
5602     case ExtensionsGL::COMPRESSED_ATC_RGBA_INTERPOLATED_ALPHA_AMD:
5603         {
5604             const int kBlockSize = 16;
5605             const int kBlockWidth = 4;
5606             const int kBlockHeight = 4;
5607             int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;
5608             int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;
5609             bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;
5610         }
5611         break;
5612     case ExtensionsGL::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
5613     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
5614         {
5615             const int kBlockSize = 8;
5616             const int kBlockWidth = 8;
5617             const int kBlockHeight = 8;
5618             bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 4 + 7) / kBlockSize;
5619         }
5620         break;
5621     case ExtensionsGL::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
5622     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:
5623         {
5624             const int kBlockSize = 8;
5625             const int kBlockWidth = 16;
5626             const int kBlockHeight = 8;
5627             bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 2 + 7) / kBlockSize;
5628         }
5629         break;
5630     case ExtensionsGL::COMPRESSED_RGBA_ASTC_4x4_KHR:
5631     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x4_KHR:
5632     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x5_KHR:
5633     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x5_KHR:
5634     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x6_KHR:
5635     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x5_KHR:
5636     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x6_KHR:
5637     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x8_KHR:
5638     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x5_KHR:
5639     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x6_KHR:
5640     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x8_KHR:
5641     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x10_KHR:
5642     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x10_KHR:
5643     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x12_KHR:
5644         bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartRGBA]);
5645         break;
5646     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:
5647     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:
5648     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:
5649     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:
5650     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:
5651     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:
5652     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:
5653     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:
5654     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:
5655     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:
5656     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:
5657     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:
5658     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:
5659     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:
5660         bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartSRGB8]);
5661         break;
5662     case ExtensionsGL::COMPRESSED_R11_EAC:
5663     case ExtensionsGL::COMPRESSED_SIGNED_R11_EAC:
5664     case ExtensionsGL::COMPRESSED_RGB8_ETC2:
5665     case ExtensionsGL::COMPRESSED_SRGB8_ETC2:
5666     case ExtensionsGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
5667     case ExtensionsGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: {
5668         Checked&lt;unsigned, RecordOverflow&gt; checkedBytesRequired = (width + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;
5669         checkedBytesRequired *= (height + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;
5670         checkedBytesRequired *= 8;
5671         if (checkedBytesRequired.hasOverflowed()) {
5672             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;too large dimensions&quot;);
5673             return false;
5674         }
5675         bytesRequired = checkedBytesRequired.unsafeGet();
5676         break;
5677     }
5678     case ExtensionsGL::COMPRESSED_RG11_EAC:
5679     case ExtensionsGL::COMPRESSED_SIGNED_RG11_EAC:
5680     case ExtensionsGL::COMPRESSED_RGBA8_ETC2_EAC:
5681     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: {
5682         Checked&lt;unsigned, RecordOverflow&gt; checkedBytesRequired = (width + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;
5683         checkedBytesRequired *= (height + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;
5684         checkedBytesRequired *= 16;
5685         if (checkedBytesRequired.hasOverflowed()) {
5686             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;too large dimensions&quot;);
5687             return false;
5688         }
5689         bytesRequired = checkedBytesRequired.unsafeGet();
5690         break;
5691     }
5692     default:
5693         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid format&quot;);
5694         return false;
5695     }
5696 
5697     if (pixels.byteLength() != bytesRequired) {
5698         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;length of ArrayBufferView is not correct for dimensions&quot;);
5699         return false;
5700     }
5701 
5702     return true;
5703 }
5704 
5705 bool WebGLRenderingContextBase::validateCompressedTexDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLsizei width, GCGLsizei height, GCGLenum format)
5706 {
5707     switch (format) {
5708     case ExtensionsGL::COMPRESSED_RGB_S3TC_DXT1_EXT:
5709     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT1_EXT:
5710     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT3_EXT:
5711     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT5_EXT: {
5712         const GCGLsizei kBlockWidth = 4;
5713         const GCGLsizei kBlockHeight = 4;
5714         const GCGLint maxTextureSize = target ? m_maxTextureSize : m_maxCubeMapTextureSize;
5715         const GCGLsizei maxCompressedDimension = maxTextureSize &gt;&gt; level;
5716         bool widthValid = (level &amp;&amp; width == 1) || (level &amp;&amp; width == 2) || (!(width % kBlockWidth) &amp;&amp; width &lt;= maxCompressedDimension);
5717         bool heightValid = (level &amp;&amp; height == 1) || (level &amp;&amp; height == 2) || (!(height % kBlockHeight) &amp;&amp; height &lt;= maxCompressedDimension);
5718         if (!widthValid || !heightValid) {
5719             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);
5720             return false;
5721         }
5722         return true;
5723     }
5724     case ExtensionsGL::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
5725     case ExtensionsGL::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
5726     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
5727     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:
5728         // Height and width must be powers of 2.
5729         if ((width &amp; (width - 1)) || (height &amp; (height - 1))) {
5730             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);
5731             return false;
5732         }
5733         return true;
5734     case ExtensionsGL::COMPRESSED_RGBA_ASTC_4x4_KHR:
5735     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x4_KHR:
5736     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x5_KHR:
5737     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x5_KHR:
5738     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x6_KHR:
5739     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x5_KHR:
5740     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x6_KHR:
5741     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x8_KHR:
5742     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x5_KHR:
5743     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x6_KHR:
5744     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x8_KHR:
5745     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x10_KHR:
5746     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x10_KHR:
5747     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x12_KHR:
5748     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:
5749     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:
5750     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:
5751     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:
5752     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:
5753     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:
5754     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:
5755     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:
5756     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:
5757     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:
5758     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:
5759     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:
5760     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:
5761     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:
5762     case ExtensionsGL::ETC1_RGB8_OES:
5763     case ExtensionsGL::COMPRESSED_R11_EAC:
5764     case ExtensionsGL::COMPRESSED_SIGNED_R11_EAC:
5765     case ExtensionsGL::COMPRESSED_RG11_EAC:
5766     case ExtensionsGL::COMPRESSED_SIGNED_RG11_EAC:
5767     case ExtensionsGL::COMPRESSED_RGB8_ETC2:
5768     case ExtensionsGL::COMPRESSED_SRGB8_ETC2:
5769     case ExtensionsGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
5770     case ExtensionsGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
5771     case ExtensionsGL::COMPRESSED_RGBA8_ETC2_EAC:
5772     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
5773         // No height and width restrictions on ASTC, ETC1 or ETC2.
5774         return true;
5775     default:
5776         return false;
5777     }
5778 }
5779 
5780 bool WebGLRenderingContextBase::validateCompressedTexSubDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, WebGLTexture* tex)
5781 {
5782     if (xoffset &lt; 0 || yoffset &lt; 0) {
5783         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;xoffset or yoffset &lt; 0&quot;);
5784         return false;
5785     }
5786 
5787     switch (format) {
5788     case ExtensionsGL::COMPRESSED_RGB_S3TC_DXT1_EXT:
5789     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT1_EXT:
5790     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT3_EXT:
5791     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT5_EXT: {
5792         const int kBlockWidth = 4;
5793         const int kBlockHeight = 4;
5794         if ((xoffset % kBlockWidth) || (yoffset % kBlockHeight)) {
5795             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;xoffset or yoffset not multiple of 4&quot;);
5796             return false;
5797         }
5798         if (width - xoffset &gt; tex-&gt;getWidth(target, level)
5799             || height - yoffset &gt; tex-&gt;getHeight(target, level)) {
5800             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;dimensions out of range&quot;);
5801             return false;
5802         }
5803         return validateCompressedTexDimensions(functionName, target, level, width, height, format);
5804     }
5805     case ExtensionsGL::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
5806     case ExtensionsGL::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
5807     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
5808     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: {
5809         if (xoffset || yoffset) {
5810             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;xoffset and yoffset must be zero&quot;);
5811             return false;
5812         }
5813         if (width != tex-&gt;getWidth(target, level)
5814             || height != tex-&gt;getHeight(target, level)) {
5815             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;dimensions must match existing level&quot;);
5816             return false;
5817         }
5818         return validateCompressedTexDimensions(functionName, target, level, width, height, format);
5819     }
5820     case ExtensionsGL::ETC1_RGB8_OES:
5821         // Not supported for ETC1_RGB8_OES textures.
5822         return false;
5823     case ExtensionsGL::COMPRESSED_R11_EAC:
5824     case ExtensionsGL::COMPRESSED_SIGNED_R11_EAC:
5825     case ExtensionsGL::COMPRESSED_RG11_EAC:
5826     case ExtensionsGL::COMPRESSED_SIGNED_RG11_EAC:
5827     case ExtensionsGL::COMPRESSED_RGB8_ETC2:
5828     case ExtensionsGL::COMPRESSED_SRGB8_ETC2:
5829     case ExtensionsGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
5830     case ExtensionsGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
5831     case ExtensionsGL::COMPRESSED_RGBA8_ETC2_EAC:
5832     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: {
5833         if (target == GraphicsContextGL::TEXTURE_3D) {
5834             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;not supported on TEXTURE_3D textures&quot;);
5835             return false;
5836         }
5837         const int kBlockSize = 4;
5838         int texWidth = tex-&gt;getWidth(target, level);
5839         int texHeight = tex-&gt;getHeight(target, level);
5840         if ((xoffset % kBlockSize) || (yoffset % kBlockSize)
5841             || ((width % kBlockSize) &amp;&amp; xoffset + width != texWidth)
5842             || ((height % kBlockSize) &amp;&amp; yoffset + height != texHeight)) {
5843             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;dimensions must match existing texture level dimensions&quot;);
5844             return false;
5845         }
5846         return true;
5847     }
5848     default:
5849         return false;
5850     }
5851 }
5852 
5853 bool WebGLRenderingContextBase::validateDrawMode(const char* functionName, GCGLenum mode)
5854 {
5855     switch (mode) {
5856     case GraphicsContextGL::POINTS:
5857     case GraphicsContextGL::LINE_STRIP:
5858     case GraphicsContextGL::LINE_LOOP:
5859     case GraphicsContextGL::LINES:
5860     case GraphicsContextGL::TRIANGLE_STRIP:
5861     case GraphicsContextGL::TRIANGLE_FAN:
5862     case GraphicsContextGL::TRIANGLES:
5863         return true;
5864     default:
5865         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid draw mode&quot;);
5866         return false;
5867     }
5868 }
5869 
5870 bool WebGLRenderingContextBase::validateStencilSettings(const char* functionName)
5871 {
5872     if (m_stencilMask != m_stencilMaskBack || m_stencilFuncRef != m_stencilFuncRefBack || m_stencilFuncMask != m_stencilFuncMaskBack) {
5873         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;front and back stencils settings do not match&quot;);
5874         return false;
5875     }
5876     return true;
5877 }
5878 
5879 bool WebGLRenderingContextBase::validateStencilFunc(const char* functionName, GCGLenum func)
5880 {
5881     switch (func) {
5882     case GraphicsContextGL::NEVER:
5883     case GraphicsContextGL::LESS:
5884     case GraphicsContextGL::LEQUAL:
5885     case GraphicsContextGL::GREATER:
5886     case GraphicsContextGL::GEQUAL:
5887     case GraphicsContextGL::EQUAL:
5888     case GraphicsContextGL::NOTEQUAL:
5889     case GraphicsContextGL::ALWAYS:
5890         return true;
5891     default:
5892         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid function&quot;);
5893         return false;
5894     }
5895 }
5896 
5897 void WebGLRenderingContextBase::printToConsole(MessageLevel level, const String&amp; message)
5898 {
5899     if (!m_synthesizedErrorsToConsole || !m_numGLErrorsToConsoleAllowed)
5900         return;
5901 
5902     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; consoleMessage;
5903 
5904     // Error messages can occur during function calls, so show stack traces for them.
5905     if (level == MessageLevel::Error) {
5906         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
5907         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message, WTFMove(stackTrace));
5908     } else
5909         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message);
5910 
5911     auto* canvas = htmlCanvas();
5912     if (canvas)
5913         canvas-&gt;document().addConsoleMessage(WTFMove(consoleMessage));
5914 
5915     --m_numGLErrorsToConsoleAllowed;
5916     if (!m_numGLErrorsToConsoleAllowed)
5917         printToConsole(MessageLevel::Warning, &quot;WebGL: too many errors, no more errors will be reported to the console for this context.&quot;);
5918 }
5919 
5920 bool WebGLRenderingContextBase::validateBlendFuncFactors(const char* functionName, GCGLenum src, GCGLenum dst)
5921 {
5922     if (((src == GraphicsContextGL::CONSTANT_COLOR || src == GraphicsContextGL::ONE_MINUS_CONSTANT_COLOR)
5923         &amp;&amp; (dst == GraphicsContextGL::CONSTANT_ALPHA || dst == GraphicsContextGL::ONE_MINUS_CONSTANT_ALPHA))
5924         || ((dst == GraphicsContextGL::CONSTANT_COLOR || dst == GraphicsContextGL::ONE_MINUS_CONSTANT_COLOR)
5925             &amp;&amp; (src == GraphicsContextGL::CONSTANT_ALPHA || src == GraphicsContextGL::ONE_MINUS_CONSTANT_ALPHA))) {
5926         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;incompatible src and dst&quot;);
5927         return false;
5928     }
5929     return true;
5930 }
5931 
5932 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Float32List&amp; v, GCGLsizei requiredMinSize)
5933 {
5934     return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
5935 }
5936 
5937 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Int32List&amp; v, GCGLsizei requiredMinSize)
5938 {
5939     return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
5940 }
5941 
5942 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, void* v, GCGLsizei size, GCGLsizei requiredMinSize)
5943 {
5944     return validateUniformMatrixParameters(functionName, location, false, v, size, requiredMinSize);
5945 }
5946 
5947 bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GCGLboolean transpose, const Float32List&amp; v, GCGLsizei requiredMinSize)
5948 {
5949     return validateUniformMatrixParameters(functionName, location, transpose, v.data(), v.length(), requiredMinSize);
5950 }
5951 
5952 bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GCGLboolean transpose, const void* v, GCGLsizei size, GCGLsizei requiredMinSize)
5953 {
5954     if (!location)
5955         return false;
5956     if (location-&gt;program() != m_currentProgram) {
5957         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;location is not from current program&quot;);
5958         return false;
5959     }
5960     if (!v) {
5961         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no array&quot;);
5962         return false;
5963     }
5964     if (transpose) {
5965         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;transpose not FALSE&quot;);
5966         return false;
5967     }
5968     if (size &lt; requiredMinSize || (size % requiredMinSize)) {
5969         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;invalid size&quot;);
5970         return false;
5971     }
5972     return true;
5973 }
5974 
5975 WebGLBuffer* WebGLRenderingContextBase::validateBufferDataParameters(const char* functionName, GCGLenum target, GCGLenum usage)
5976 {
5977     Optional&lt;WebGLBuffer*&gt; buffer;
5978     switch (target) {
5979     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:
5980         buffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
5981         break;
5982     case GraphicsContextGL::ARRAY_BUFFER:
5983         buffer = m_boundArrayBuffer.get();
5984         break;
5985     default:
5986 #if ENABLE(WEBGL2)
5987         if (isWebGL2()) {
5988             switch (target) {
5989             case GraphicsContextGL::COPY_READ_BUFFER:
5990                 buffer = m_boundCopyReadBuffer.get();
5991                 break;
5992             case GraphicsContextGL::COPY_WRITE_BUFFER:
5993                 buffer = m_boundCopyWriteBuffer.get();
5994                 break;
5995             case GraphicsContextGL::PIXEL_PACK_BUFFER:
5996                 buffer = m_boundPixelPackBuffer.get();
5997                 break;
5998             case GraphicsContextGL::PIXEL_UNPACK_BUFFER:
5999                 buffer = m_boundPixelUnpackBuffer.get();
6000                 break;
6001             case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:
6002                 buffer = m_boundTransformFeedbackBuffer.get();
6003                 break;
6004             case GraphicsContextGL::UNIFORM_BUFFER:
6005                 buffer = m_boundUniformBuffer.get();
6006                 break;
6007             }
6008             if (buffer)
6009                 break;
6010         }
6011 #endif
6012         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);
6013         return nullptr;
6014     }
6015     if (!buffer || !buffer.value()) {
6016         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;no buffer&quot;);
6017         return nullptr;
6018     }
6019     switch (usage) {
6020     case GraphicsContextGL::STREAM_DRAW:
6021     case GraphicsContextGL::STATIC_DRAW:
6022     case GraphicsContextGL::DYNAMIC_DRAW:
6023         return buffer.value();
6024     }
6025     synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid usage&quot;);
6026     return nullptr;
6027 }
6028 
6029 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLImageElement(const char* functionName, HTMLImageElement* image)
6030 {
6031     if (!image || !image-&gt;cachedImage()) {
6032         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no image&quot;);
6033         return false;
6034     }
6035     const URL&amp; url = image-&gt;cachedImage()-&gt;response().url();
6036     if (url.isNull() || url.isEmpty() || !url.isValid()) {
6037         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;invalid image&quot;);
6038         return false;
6039     }
6040     if (wouldTaintOrigin(image))
6041         return Exception { SecurityError };
6042     return true;
6043 }
6044 
6045 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement* canvas)
6046 {
6047     if (!canvas || !canvas-&gt;buffer()) {
6048         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no canvas&quot;);
6049         return false;
6050     }
6051     if (wouldTaintOrigin(canvas))
6052         return Exception { SecurityError };
6053     return true;
6054 }
6055 
6056 #if ENABLE(VIDEO)
6057 
6058 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLVideoElement(const char* functionName, HTMLVideoElement* video)
6059 {
6060     if (!video || !video-&gt;videoWidth() || !video-&gt;videoHeight()) {
6061         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no video&quot;);
6062         return false;
6063     }
6064     if (wouldTaintOrigin(video))
6065         return Exception { SecurityError };
6066     return true;
6067 }
6068 
6069 #endif
6070 
6071 void WebGLRenderingContextBase::vertexAttribfImpl(const char* functionName, GCGLuint index, GCGLsizei expectedSize, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2, GCGLfloat v3)
6072 {
6073     if (isContextLostOrPending())
6074         return;
6075     if (index &gt;= m_maxVertexAttribs) {
6076         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;index out of range&quot;);
6077         return;
6078     }
6079     // In GL, we skip setting vertexAttrib0 values.
6080     if (index || isGLES2Compliant()) {
6081         switch (expectedSize) {
6082         case 1:
6083             m_context-&gt;vertexAttrib1f(index, v0);
6084             break;
6085         case 2:
6086             m_context-&gt;vertexAttrib2f(index, v0, v1);
6087             break;
6088         case 3:
6089             m_context-&gt;vertexAttrib3f(index, v0, v1, v2);
6090             break;
6091         case 4:
6092             m_context-&gt;vertexAttrib4f(index, v0, v1, v2, v3);
6093             break;
6094         }
6095     }
6096     VertexAttribValue&amp; attribValue = m_vertexAttribValue[index];
6097     attribValue.value[0] = v0;
6098     attribValue.value[1] = v1;
6099     attribValue.value[2] = v2;
6100     attribValue.value[3] = v3;
6101 }
6102 
6103 void WebGLRenderingContextBase::vertexAttribfvImpl(const char* functionName, GCGLuint index, Float32List&amp;&amp; list, GCGLsizei expectedSize)
6104 {
6105     if (isContextLostOrPending())
6106         return;
6107 
6108     auto data = list.data();
6109     if (!data) {
6110         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no array&quot;);
6111         return;
6112     }
6113 
6114     int size = list.length();
6115     if (size &lt; expectedSize) {
6116         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;invalid size&quot;);
6117         return;
6118     }
6119     if (index &gt;= m_maxVertexAttribs) {
6120         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;index out of range&quot;);
6121         return;
6122     }
6123     // In GL, we skip setting vertexAttrib0 values.
6124     if (index || isGLES2Compliant()) {
6125         switch (expectedSize) {
6126         case 1:
6127             m_context-&gt;vertexAttrib1fv(index, data);
6128             break;
6129         case 2:
6130             m_context-&gt;vertexAttrib2fv(index, data);
6131             break;
6132         case 3:
6133             m_context-&gt;vertexAttrib3fv(index, data);
6134             break;
6135         case 4:
6136             m_context-&gt;vertexAttrib4fv(index, data);
6137             break;
6138         }
6139     }
6140     VertexAttribValue&amp; attribValue = m_vertexAttribValue[index];
6141     attribValue.initValue();
6142     for (int ii = 0; ii &lt; expectedSize; ++ii)
6143         attribValue.value[ii] = data[ii];
6144 }
6145 
6146 void WebGLRenderingContextBase::initVertexAttrib0()
6147 {
6148     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6149 
6150     m_vertexAttrib0Buffer = createBuffer();
6151     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());
6152     m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, 0, GraphicsContextGL::DYNAMIC_DRAW);
6153     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContextGL::FLOAT, false, 0, 0);
6154     state.bufferBinding = m_vertexAttrib0Buffer;
6155     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, 0);
6156     m_context-&gt;enableVertexAttribArray(0);
6157     m_vertexAttrib0BufferSize = 0;
6158     m_vertexAttrib0BufferValue[0] = 0.0f;
6159     m_vertexAttrib0BufferValue[1] = 0.0f;
6160     m_vertexAttrib0BufferValue[2] = 0.0f;
6161     m_vertexAttrib0BufferValue[3] = 1.0f;
6162     m_forceAttrib0BufferRefill = false;
6163     m_vertexAttrib0UsedBefore = false;
6164 }
6165 
6166 bool WebGLRenderingContextBase::validateSimulatedVertexAttrib0(GCGLuint numVertex)
6167 {
6168     if (!m_currentProgram)
6169         return true;
6170 
6171     bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
6172     if (!usingVertexAttrib0)
6173         return true;
6174 
6175     auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6176     if (state.enabled)
6177         return true;
6178 
6179     auto bufferSize = checkedAddAndMultiply&lt;GCGLuint&gt;(numVertex, 1, 4);
6180     if (!bufferSize)
6181         return false;
6182 
6183     Checked&lt;GCGLsizeiptr, RecordOverflow&gt; bufferDataSize(bufferSize.value());
6184     bufferDataSize *= Checked&lt;GCGLsizeiptr&gt;(sizeof(GCGLfloat));
6185     return !bufferDataSize.hasOverflowed() &amp;&amp; bufferDataSize.unsafeGet() &gt; 0;
6186 }
6187 
6188 Optional&lt;bool&gt; WebGLRenderingContextBase::simulateVertexAttrib0(GCGLuint numVertex)
6189 {
6190     if (!m_currentProgram)
6191         return false;
6192     bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
6193     if (usingVertexAttrib0)
6194         m_vertexAttrib0UsedBefore = true;
6195 
6196     auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6197     if (state.enabled &amp;&amp; usingVertexAttrib0)
6198         return false;
6199     if (!usingVertexAttrib0 &amp;&amp; !m_vertexAttrib0UsedBefore)
6200         return false;
6201     m_vertexAttrib0UsedBefore = true;
6202     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());
6203 
6204     // We know bufferSize and bufferDataSize won&#39;t overflow or go negative, thanks to validateSimulatedVertexAttrib0
6205     GCGLuint bufferSize = (numVertex + 1) * 4;
6206     GCGLsizeiptr bufferDataSize = bufferSize * sizeof(GCGLfloat);
6207 
6208     if (bufferDataSize &gt; m_vertexAttrib0BufferSize) {
6209         m_context-&gt;moveErrorsToSyntheticErrorList();
6210         m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, bufferDataSize, 0, GraphicsContextGL::DYNAMIC_DRAW);
6211         if (m_context-&gt;getError() != GraphicsContextGL::NO_ERROR) {
6212             // We were unable to create a buffer.
6213             m_vertexAttrib0UsedBefore = false;
6214             m_vertexAttrib0BufferSize = 0;
6215             m_forceAttrib0BufferRefill = true;
6216             return WTF::nullopt;
6217         }
6218         m_vertexAttrib0BufferSize = bufferDataSize;
6219         m_forceAttrib0BufferRefill = true;
6220     }
6221 
6222     auto&amp; attribValue = m_vertexAttribValue[0];
6223 
6224     if (usingVertexAttrib0
6225         &amp;&amp; (m_forceAttrib0BufferRefill
6226             || attribValue.value[0] != m_vertexAttrib0BufferValue[0]
6227             || attribValue.value[1] != m_vertexAttrib0BufferValue[1]
6228             || attribValue.value[2] != m_vertexAttrib0BufferValue[2]
6229             || attribValue.value[3] != m_vertexAttrib0BufferValue[3])) {
6230 
6231         auto bufferData = makeUniqueArray&lt;GCGLfloat&gt;(bufferSize);
6232         for (GCGLuint ii = 0; ii &lt; numVertex + 1; ++ii) {
6233             bufferData[ii * 4] = attribValue.value[0];
6234             bufferData[ii * 4 + 1] = attribValue.value[1];
6235             bufferData[ii * 4 + 2] = attribValue.value[2];
6236             bufferData[ii * 4 + 3] = attribValue.value[3];
6237         }
6238         m_vertexAttrib0BufferValue[0] = attribValue.value[0];
6239         m_vertexAttrib0BufferValue[1] = attribValue.value[1];
6240         m_vertexAttrib0BufferValue[2] = attribValue.value[2];
6241         m_vertexAttrib0BufferValue[3] = attribValue.value[3];
6242         m_forceAttrib0BufferRefill = false;
6243         m_context-&gt;bufferSubData(GraphicsContextGL::ARRAY_BUFFER, 0, bufferDataSize, bufferData.get());
6244     }
6245     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContextGL::FLOAT, 0, 0, 0);
6246     return true;
6247 }
6248 
6249 void WebGLRenderingContextBase::restoreStatesAfterVertexAttrib0Simulation()
6250 {
6251     const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6252     if (state.bufferBinding != m_vertexAttrib0Buffer) {
6253         m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, objectOrZero(state.bufferBinding.get()));
6254         m_context-&gt;vertexAttribPointer(0, state.size, state.type, state.normalized, state.originalStride, state.offset);
6255     }
6256     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, objectOrZero(m_boundArrayBuffer.get()));
6257 }
6258 
6259 void WebGLRenderingContextBase::dispatchContextLostEvent()
6260 {
6261     RELEASE_ASSERT(!m_isSuspended);
6262     auto* canvas = htmlCanvas();
6263     if (!canvas)
6264         return;
6265 
6266     Ref&lt;WebGLContextEvent&gt; event = WebGLContextEvent::create(eventNames().webglcontextlostEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString());
6267     canvas-&gt;dispatchEvent(event);
6268     m_restoreAllowed = event-&gt;defaultPrevented();
6269     if (m_contextLostMode == RealLostContext &amp;&amp; m_restoreAllowed)
6270         m_restoreTimer.startOneShot(0_s);
6271 }
6272 
6273 void WebGLRenderingContextBase::maybeRestoreContext()
6274 {
6275     RELEASE_ASSERT(!m_isSuspended);
6276     ASSERT(m_contextLost);
6277     if (!m_contextLost)
6278         return;
6279 
6280     // The rendering context is not restored unless the default behavior of the
6281     // webglcontextlost event was prevented earlier.
6282     //
6283     // Because of the way m_restoreTimer is set up for real vs. synthetic lost
6284     // context events, we don&#39;t have to worry about this test short-circuiting
6285     // the retry loop for real context lost events.
6286     if (!m_restoreAllowed)
6287         return;
6288 
6289     int contextLostReason = m_context-&gt;getExtensions().getGraphicsResetStatusARB();
6290 
6291     switch (contextLostReason) {
6292     case GraphicsContextGL::NO_ERROR:
6293         // The GraphicsContextGLOpenGL implementation might not fully
6294         // support GL_ARB_robustness semantics yet. Alternatively, the
6295         // WEBGL_lose_context extension might have been used to force
6296         // a lost context.
6297         break;
6298     case ExtensionsGL::GUILTY_CONTEXT_RESET_ARB:
6299         // The rendering context is not restored if this context was
6300         // guilty of causing the graphics reset.
6301         printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page caused the graphics card to reset; not restoring the context&quot;);
6302         return;
6303     case ExtensionsGL::INNOCENT_CONTEXT_RESET_ARB:
6304         // Always allow the context to be restored.
6305         break;
6306     case ExtensionsGL::UNKNOWN_CONTEXT_RESET_ARB:
6307         // Warn. Ideally, prompt the user telling them that WebGL
6308         // content on the page might have caused the graphics card to
6309         // reset and ask them whether they want to continue running
6310         // the content. Only if they say &quot;yes&quot; should we start
6311         // attempting to restore the context.
6312         printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page might have caused the graphics card to reset&quot;);
6313         break;
6314     }
6315 
6316     auto* canvas = htmlCanvas();
6317     if (!canvas)
6318         return;
6319 
6320     RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame();
6321     if (!frame)
6322         return;
6323 
6324     if (!frame-&gt;loader().client().allowWebGL(frame-&gt;settings().webGLEnabled()))
6325         return;
6326 
6327     RefPtr&lt;FrameView&gt; view = frame-&gt;view();
6328     if (!view)
6329         return;
6330     RefPtr&lt;ScrollView&gt; root = view-&gt;root();
6331     if (!root)
6332         return;
6333     HostWindow* hostWindow = root-&gt;hostWindow();
6334     if (!hostWindow)
6335         return;
6336 
6337     RefPtr&lt;GraphicsContextGLOpenGL&gt; context(GraphicsContextGLOpenGL::create(m_attributes, hostWindow));
6338     if (!context) {
6339         if (m_contextLostMode == RealLostContext)
6340             m_restoreTimer.startOneShot(secondsBetweenRestoreAttempts);
6341         else
6342             // This likely shouldn&#39;t happen but is the best way to report it to the WebGL app.
6343             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;&quot;, &quot;error restoring context&quot;);
6344         return;
6345     }
6346 
6347     m_context = context;
6348     addActivityStateChangeObserverIfNecessary();
6349     m_contextLost = false;
6350     setupFlags();
6351     initializeNewContext();
6352     initializeVertexArrayObjects();
6353     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextrestoredEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
6354 }
6355 
6356 void WebGLRenderingContextBase::simulateContextChanged()
6357 {
6358     if (m_context)
6359         m_context-&gt;simulateContextChanged();
6360 }
6361 
6362 String WebGLRenderingContextBase::ensureNotNull(const String&amp; text) const
6363 {
6364     if (text.isNull())
6365         return WTF::emptyString();
6366     return text;
6367 }
6368 
6369 WebGLRenderingContextBase::LRUImageBufferCache::LRUImageBufferCache(int capacity)
6370     : m_buffers(capacity)
6371 {
6372 }
6373 
6374 ImageBuffer* WebGLRenderingContextBase::LRUImageBufferCache::imageBuffer(const IntSize&amp; size)
6375 {
6376     size_t i;
6377     for (i = 0; i &lt; m_buffers.size(); ++i) {
6378         ImageBuffer* buf = m_buffers[i].get();
6379         if (!buf)
6380             break;
6381         if (buf-&gt;logicalSize() != size)
6382             continue;
6383         bubbleToFront(i);
6384         buf-&gt;context().clearRect(FloatRect({ }, FloatSize(size)));
6385         return buf;
6386     }
6387 
6388     // FIXME (149423): Should this ImageBuffer be unconditionally unaccelerated?
6389     std::unique_ptr&lt;ImageBuffer&gt; temp = ImageBuffer::create(size, RenderingMode::Unaccelerated);
6390     if (!temp)
6391         return nullptr;
6392     ASSERT(m_buffers.size() &gt; 0);
6393     i = std::min(m_buffers.size() - 1, i);
6394     m_buffers[i] = WTFMove(temp);
6395 
6396     ImageBuffer* buf = m_buffers[i].get();
6397     bubbleToFront(i);
6398     return buf;
6399 }
6400 
6401 void WebGLRenderingContextBase::LRUImageBufferCache::bubbleToFront(size_t idx)
6402 {
6403     for (size_t i = idx; i &gt; 0; --i)
6404         m_buffers[i].swap(m_buffers[i-1]);
6405 }
6406 
6407 namespace {
6408 
6409     String GetErrorString(GCGLenum error)
6410     {
6411         switch (error) {
6412         case GraphicsContextGL::INVALID_ENUM:
6413             return &quot;INVALID_ENUM&quot;_s;
6414         case GraphicsContextGL::INVALID_VALUE:
6415             return &quot;INVALID_VALUE&quot;_s;
6416         case GraphicsContextGL::INVALID_OPERATION:
6417             return &quot;INVALID_OPERATION&quot;_s;
6418         case GraphicsContextGL::OUT_OF_MEMORY:
6419             return &quot;OUT_OF_MEMORY&quot;_s;
6420         case GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION:
6421             return &quot;INVALID_FRAMEBUFFER_OPERATION&quot;_s;
6422         case GraphicsContextGL::CONTEXT_LOST_WEBGL:
6423             return &quot;CONTEXT_LOST_WEBGL&quot;_s;
6424         default:
6425             return makeString(&quot;WebGL ERROR(&quot;, hex(error, 4, Lowercase), &#39;)&#39;);
6426         }
6427     }
6428 
6429 } // namespace anonymous
6430 
6431 void WebGLRenderingContextBase::synthesizeGLError(GCGLenum error, const char* functionName, const char* description, ConsoleDisplayPreference display)
6432 {
6433     if (m_synthesizedErrorsToConsole &amp;&amp; display == DisplayInConsole) {
6434         String str = &quot;WebGL: &quot; + GetErrorString(error) +  &quot;: &quot; + String(functionName) + &quot;: &quot; + String(description);
6435         printToConsole(MessageLevel::Error, str);
6436     }
6437     m_context-&gt;synthesizeGLError(error);
6438 }
6439 
6440 void WebGLRenderingContextBase::applyStencilTest()
6441 {
6442     bool haveStencilBuffer = false;
6443 
6444     if (m_framebufferBinding)
6445         haveStencilBuffer = m_framebufferBinding-&gt;hasStencilBuffer();
6446     else {
6447         auto attributes = getContextAttributes();
6448         ASSERT(attributes);
6449         haveStencilBuffer = attributes-&gt;stencil;
6450     }
6451     enableOrDisable(GraphicsContextGL::STENCIL_TEST, m_stencilEnabled &amp;&amp; haveStencilBuffer);
6452 }
6453 
6454 void WebGLRenderingContextBase::enableOrDisable(GCGLenum capability, bool enable)
6455 {
6456     if (enable)
6457         m_context-&gt;enable(capability);
6458     else
6459         m_context-&gt;disable(capability);
6460 }
6461 
6462 IntSize WebGLRenderingContextBase::clampedCanvasSize()
6463 {
6464     return IntSize(clamp(canvasBase().width(), 1, m_maxViewportDims[0]),
6465         clamp(canvasBase().height(), 1, m_maxViewportDims[1]));
6466 }
6467 
6468 GCGLint WebGLRenderingContextBase::getMaxDrawBuffers()
6469 {
6470     if (!supportsDrawBuffers())
6471         return 0;
6472     if (!m_maxDrawBuffers)
6473         m_context-&gt;getIntegerv(ExtensionsGL::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);
6474     if (!m_maxColorAttachments)
6475         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);
6476     // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
6477     return std::min(m_maxDrawBuffers, m_maxColorAttachments);
6478 }
6479 
6480 GCGLint WebGLRenderingContextBase::getMaxColorAttachments()
6481 {
6482     if (!supportsDrawBuffers())
6483         return 0;
6484     if (!m_maxColorAttachments)
6485         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);
6486     return m_maxColorAttachments;
6487 }
6488 
6489 void WebGLRenderingContextBase::setBackDrawBuffer(GCGLenum buf)
6490 {
6491     m_backDrawBuffer = buf;
6492 }
6493 
6494 void WebGLRenderingContextBase::restoreCurrentFramebuffer()
6495 {
6496     bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_framebufferBinding.get());
6497 }
6498 
6499 void WebGLRenderingContextBase::restoreCurrentTexture2D()
6500 {
6501     auto texture = m_textureUnits[m_activeTextureUnit].texture2DBinding.get();
6502     bindTexture(GraphicsContextGL::TEXTURE_2D, texture);
6503     if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
6504         m_unrenderableTextureUnits.add(m_activeTextureUnit);
6505 }
6506 
6507 bool WebGLRenderingContextBase::supportsDrawBuffers()
6508 {
6509     if (!m_drawBuffersWebGLRequirementsChecked) {
6510         m_drawBuffersWebGLRequirementsChecked = true;
6511         m_drawBuffersSupported = WebGLDrawBuffers::supported(*this);
6512     }
6513     return m_drawBuffersSupported;
6514 }
6515 
6516 void WebGLRenderingContextBase::drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount)
6517 {
6518     if (!primcount) {
6519         markContextChanged();
6520         return;
6521     }
6522 
6523     if (!validateDrawArrays(&quot;drawArraysInstanced&quot;, mode, first, count, primcount))
6524         return;
6525 
6526     clearIfComposited();
6527 
6528     bool vertexAttrib0Simulated = false;
6529     if (!isGLES2Compliant()) {
6530         auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
6531         if (!simulateVertexAttrib0Status) {
6532             // We were unable to simulate the attribute buffer.
6533             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);
6534             return;
6535         }
6536         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
6537     }
6538     if (!isGLES2NPOTStrict())
6539         checkTextureCompleteness(&quot;drawArraysInstanced&quot;, true);
6540 
6541     m_context-&gt;drawArraysInstanced(mode, first, count, primcount);
6542 
6543     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
6544         restoreStatesAfterVertexAttrib0Simulation();
6545     if (!isGLES2NPOTStrict())
6546         checkTextureCompleteness(&quot;drawArraysInstanced&quot;, false);
6547     markContextChangedAndNotifyCanvasObserver();
6548 }
6549 
6550 void WebGLRenderingContextBase::drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, GCGLsizei primcount)
6551 {
6552     if (!primcount) {
6553         markContextChanged();
6554         return;
6555     }
6556 
6557     unsigned numElements = 0;
6558     if (!validateDrawElements(&quot;drawElementsInstanced&quot;, mode, count, type, offset, numElements, primcount))
6559         return;
6560 
6561     clearIfComposited();
6562 
6563     bool vertexAttrib0Simulated = false;
6564     if (!isGLES2Compliant()) {
6565         if (!numElements)
6566             validateIndexArrayPrecise(count, type, static_cast&lt;GCGLintptr&gt;(offset), numElements);
6567         auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
6568         if (!simulateVertexAttrib0Status) {
6569             // We were unable to simulate the attribute buffer.
6570             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);
6571             return;
6572         }
6573         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
6574     }
6575     if (!isGLES2NPOTStrict())
6576         checkTextureCompleteness(&quot;drawElementsInstanced&quot;, true);
6577 
6578 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
6579     if (isWebGL2())
6580         m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
6581 #endif
6582 
6583     m_context-&gt;drawElementsInstanced(mode, count, type, static_cast&lt;GCGLintptr&gt;(offset), primcount);
6584 
6585     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
6586         restoreStatesAfterVertexAttrib0Simulation();
6587     if (!isGLES2NPOTStrict())
6588         checkTextureCompleteness(&quot;drawElementsInstanced&quot;, false);
6589     markContextChangedAndNotifyCanvasObserver();
6590 }
6591 
6592 void WebGLRenderingContextBase::vertexAttribDivisor(GCGLuint index, GCGLuint divisor)
6593 {
6594     if (isContextLostOrPending())
6595         return;
6596 
6597     if (index &gt;= m_maxVertexAttribs) {
6598         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribDivisor&quot;, &quot;index out of range&quot;);
6599         return;
6600     }
6601 
6602     m_boundVertexArrayObject-&gt;setVertexAttribDivisor(index, divisor);
6603     m_context-&gt;vertexAttribDivisor(index, divisor);
6604 }
6605 
6606 bool WebGLRenderingContextBase::enableSupportedExtension(ASCIILiteral extensionNameLiteral)
6607 {
6608     ASSERT(m_context);
6609     auto&amp; extensions = m_context-&gt;getExtensions();
6610     String extensionName { extensionNameLiteral };
6611     if (!extensions.supports(extensionName))
6612         return false;
6613     extensions.ensureEnabled(extensionName);
6614     return true;
6615 }
6616 
6617 void WebGLRenderingContextBase::activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState)
6618 {
6619     if (!m_context)
6620         return;
6621 
6622     auto changed = oldActivityState ^ newActivityState;
6623     if (changed &amp; ActivityState::IsVisible)
6624         m_context-&gt;setContextVisibility(newActivityState.contains(ActivityState::IsVisible));
6625 }
6626 
6627 void WebGLRenderingContextBase::setFailNextGPUStatusCheck()
6628 {
6629     if (!m_context)
6630         return;
6631 
6632     m_context-&gt;setFailNextGPUStatusCheck();
6633 }
6634 
6635 void WebGLRenderingContextBase::didComposite()
6636 {
6637     if (UNLIKELY(callTracingActive()))
6638         InspectorInstrumentation::didFinishRecordingCanvasFrame(*this);
6639 }
6640 
6641 void WebGLRenderingContextBase::forceContextLost()
6642 {
6643     forceLostContext(WebGLRenderingContextBase::RealLostContext);
6644 }
6645 
6646 void WebGLRenderingContextBase::recycleContext()
6647 {
6648     printToConsole(MessageLevel::Error, &quot;There are too many active WebGL contexts on this page, the oldest context will be lost.&quot;);
6649     // Using SyntheticLostContext means the developer won&#39;t be able to force the restoration
6650     // of the context by calling preventDefault() in a &quot;webglcontextlost&quot; event handler.
6651     forceLostContext(SyntheticLostContext);
6652     destroyGraphicsContextGL();
6653 }
6654 
6655 void WebGLRenderingContextBase::dispatchContextChangedNotification()
6656 {
6657     if (!m_dispatchContextChangedEventTimer.isActive())
6658         m_dispatchContextChangedEventTimer.startOneShot(0_s);
6659 }
6660 
6661 void WebGLRenderingContextBase::dispatchContextChangedEvent()
6662 {
6663     RELEASE_ASSERT(!m_isSuspended);
6664     auto* canvas = htmlCanvas();
6665     if (!canvas)
6666         return;
6667 
6668     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextchangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
6669 }
6670 
6671 
6672 } // namespace WebCore
6673 
6674 #endif // ENABLE(WEBGL)
    </pre>
  </body>
</html>
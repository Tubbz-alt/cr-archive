<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeLivenessAnalysis.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeList.rb.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeLivenessAnalysis.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeLivenessAnalysis.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 40,47 ***</span>
  BytecodeLivenessAnalysis::BytecodeLivenessAnalysis(CodeBlock* codeBlock)
      : m_graph(codeBlock, codeBlock-&gt;instructions())
  {
      runLivenessFixpoint(codeBlock, codeBlock-&gt;instructions(), m_graph);
  
<span class="line-modified">!     if (Options::dumpBytecodeLivenessResults())</span>
          dumpResults(codeBlock);
  }
  
<span class="line-modified">! void BytecodeLivenessAnalysis::getLivenessInfoAtBytecodeOffset(CodeBlock* codeBlock, unsigned bytecodeOffset, FastBitVector&amp; result)</span>
  {
<span class="line-modified">!     BytecodeBasicBlock* block = m_graph.findBasicBlockForBytecodeOffset(bytecodeOffset);</span>
      ASSERT(block);
      ASSERT(!block-&gt;isEntryBlock());
      ASSERT(!block-&gt;isExitBlock());
      result.resize(block-&gt;out().numBits());
<span class="line-modified">!     computeLocalLivenessForBytecodeOffset(codeBlock, codeBlock-&gt;instructions(), m_graph, block, bytecodeOffset, result);</span>
  }
  
<span class="line-modified">! FastBitVector BytecodeLivenessAnalysis::getLivenessInfoAtBytecodeOffset(CodeBlock* codeBlock, unsigned bytecodeOffset)</span>
  {
      FastBitVector out;
<span class="line-modified">!     getLivenessInfoAtBytecodeOffset(codeBlock, bytecodeOffset, out);</span>
      return out;
  }
  
  void BytecodeLivenessAnalysis::computeFullLiveness(CodeBlock* codeBlock, FullBytecodeLiveness&amp; result)
  {
      FastBitVector out;
  
<span class="line-modified">!     result.m_map.resize(codeBlock-&gt;instructions().size());</span>
  
<span class="line-modified">!     for (std::unique_ptr&lt;BytecodeBasicBlock&gt;&amp; block : m_graph.basicBlocksInReverseOrder()) {</span>
<span class="line-modified">!         if (block-&gt;isEntryBlock() || block-&gt;isExitBlock())</span>
              continue;
  
<span class="line-modified">!         out = block-&gt;out();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         for (unsigned i = block-&gt;offsets().size(); i--;) {</span>
<span class="line-modified">!             unsigned bytecodeOffset = block-&gt;offsets()[i];</span>
<span class="line-modified">!             stepOverInstruction(codeBlock, codeBlock-&gt;instructions(), m_graph, bytecodeOffset, out);</span>
<span class="line-modified">!             result.m_map[bytecodeOffset] = out;</span>
          }
      }
  }
  
  void BytecodeLivenessAnalysis::computeKills(CodeBlock* codeBlock, BytecodeKills&amp; result)
<span class="line-new-header">--- 40,65 ---</span>
  BytecodeLivenessAnalysis::BytecodeLivenessAnalysis(CodeBlock* codeBlock)
      : m_graph(codeBlock, codeBlock-&gt;instructions())
  {
      runLivenessFixpoint(codeBlock, codeBlock-&gt;instructions(), m_graph);
  
<span class="line-modified">!     if (UNLIKELY(Options::dumpBytecodeLivenessResults()))</span>
          dumpResults(codeBlock);
  }
  
<span class="line-modified">! void BytecodeLivenessAnalysis::getLivenessInfoAtBytecodeIndex(CodeBlock* codeBlock, BytecodeIndex bytecodeIndex, FastBitVector&amp; result)</span>
  {
<span class="line-modified">!     BytecodeBasicBlock* block = m_graph.findBasicBlockForBytecodeOffset(bytecodeIndex.offset());</span>
      ASSERT(block);
      ASSERT(!block-&gt;isEntryBlock());
      ASSERT(!block-&gt;isExitBlock());
      result.resize(block-&gt;out().numBits());
<span class="line-modified">!     computeLocalLivenessForBytecodeIndex(codeBlock, codeBlock-&gt;instructions(), m_graph, *block, bytecodeIndex, result);</span>
  }
  
<span class="line-modified">! FastBitVector BytecodeLivenessAnalysis::getLivenessInfoAtBytecodeIndex(CodeBlock* codeBlock, BytecodeIndex bytecodeIndex)</span>
  {
      FastBitVector out;
<span class="line-modified">!     getLivenessInfoAtBytecodeIndex(codeBlock, bytecodeIndex, out);</span>
      return out;
  }
  
  void BytecodeLivenessAnalysis::computeFullLiveness(CodeBlock* codeBlock, FullBytecodeLiveness&amp; result)
  {
      FastBitVector out;
  
<span class="line-modified">!     result.m_beforeUseVector.resize(codeBlock-&gt;instructions().size());</span>
<span class="line-added">+     result.m_afterUseVector.resize(codeBlock-&gt;instructions().size());</span>
  
<span class="line-modified">!     for (BytecodeBasicBlock&amp; block : m_graph.basicBlocksInReverseOrder()) {</span>
<span class="line-modified">!         if (block.isEntryBlock() || block.isExitBlock())</span>
              continue;
  
<span class="line-modified">!         out = block.out();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         auto use = [&amp;] (unsigned bitIndex) {</span>
<span class="line-modified">!             // This is the use functor, so we set the bit.</span>
<span class="line-modified">!             out[bitIndex] = true;</span>
<span class="line-modified">!         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto def = [&amp;] (unsigned bitIndex) {</span>
<span class="line-added">+             // This is the def functor, so we clear the bit.</span>
<span class="line-added">+             out[bitIndex] = false;</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto&amp; instructions = codeBlock-&gt;instructions();</span>
<span class="line-added">+         unsigned cursor = block.totalLength();</span>
<span class="line-added">+         for (unsigned i = block.delta().size(); i--;) {</span>
<span class="line-added">+             cursor -= block.delta()[i];</span>
<span class="line-added">+             BytecodeIndex bytecodeIndex = BytecodeIndex(block.leaderOffset() + cursor);</span>
<span class="line-added">+ </span>
<span class="line-added">+             stepOverInstructionDef(codeBlock, instructions, m_graph, bytecodeIndex, def);</span>
<span class="line-added">+             stepOverInstructionUseInExceptionHandler(codeBlock, instructions, m_graph, bytecodeIndex, use);</span>
<span class="line-added">+             result.m_afterUseVector[bytecodeIndex.offset()] = out; // AfterUse point.</span>
<span class="line-added">+             stepOverInstructionUse(codeBlock, instructions, m_graph, bytecodeIndex, use);</span>
<span class="line-added">+             result.m_beforeUseVector[bytecodeIndex.offset()] = out; // BeforeUse point.</span>
          }
      }
  }
  
  void BytecodeLivenessAnalysis::computeKills(CodeBlock* codeBlock, BytecodeKills&amp; result)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,25 ***</span>
      FastBitVector out;
  
      result.m_codeBlock = codeBlock;
      result.m_killSets = makeUniqueArray&lt;BytecodeKills::KillSet&gt;(codeBlock-&gt;instructions().size());
  
<span class="line-modified">!     for (std::unique_ptr&lt;BytecodeBasicBlock&gt;&amp; block : m_graph.basicBlocksInReverseOrder()) {</span>
<span class="line-modified">!         if (block-&gt;isEntryBlock() || block-&gt;isExitBlock())</span>
              continue;
  
<span class="line-modified">!         out = block-&gt;out();</span>
  
<span class="line-modified">!         for (unsigned i = block-&gt;offsets().size(); i--;) {</span>
<span class="line-modified">!             unsigned bytecodeOffset = block-&gt;offsets()[i];</span>
              stepOverInstruction(
<span class="line-modified">!                 codeBlock, codeBlock-&gt;instructions(), m_graph, bytecodeOffset,</span>
                  [&amp;] (unsigned index) {
                      // This is for uses.
                      if (out[index])
                          return;
<span class="line-modified">!                     result.m_killSets[bytecodeOffset].add(index);</span>
                      out[index] = true;
                  },
                  [&amp;] (unsigned index) {
                      // This is for defs.
                      out[index] = false;
<span class="line-new-header">--- 107,27 ---</span>
      FastBitVector out;
  
      result.m_codeBlock = codeBlock;
      result.m_killSets = makeUniqueArray&lt;BytecodeKills::KillSet&gt;(codeBlock-&gt;instructions().size());
  
<span class="line-modified">!     for (BytecodeBasicBlock&amp; block : m_graph.basicBlocksInReverseOrder()) {</span>
<span class="line-modified">!         if (block.isEntryBlock() || block.isExitBlock())</span>
              continue;
  
<span class="line-modified">!         out = block.out();</span>
  
<span class="line-modified">!         unsigned cursor = block.totalLength();</span>
<span class="line-modified">!         for (unsigned i = block.delta().size(); i--;) {</span>
<span class="line-added">+             cursor -= block.delta()[i];</span>
<span class="line-added">+             BytecodeIndex bytecodeIndex = BytecodeIndex(block.leaderOffset() + cursor);</span>
              stepOverInstruction(
<span class="line-modified">!                 codeBlock, codeBlock-&gt;instructions(), m_graph, bytecodeIndex,</span>
                  [&amp;] (unsigned index) {
                      // This is for uses.
                      if (out[index])
                          return;
<span class="line-modified">!                     result.m_killSets[bytecodeIndex.offset()].add(index);</span>
                      out[index] = true;
                  },
                  [&amp;] (unsigned index) {
                      // This is for defs.
                      out[index] = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,16 ***</span>
      const auto&amp; instructions = codeBlock-&gt;instructions();
      unsigned i = 0;
  
      unsigned numberOfBlocks = m_graph.size();
      Vector&lt;FastBitVector&gt; predecessors(numberOfBlocks);
<span class="line-modified">!     for (BytecodeBasicBlock* block : m_graph)</span>
<span class="line-modified">!         predecessors[block-&gt;index()].resize(numberOfBlocks);</span>
<span class="line-modified">!     for (BytecodeBasicBlock* block : m_graph) {</span>
<span class="line-modified">!         for (unsigned j = 0; j &lt; block-&gt;successors().size(); j++) {</span>
<span class="line-modified">!             unsigned blockIndex = block-&gt;index();</span>
<span class="line-removed">-             unsigned successorIndex = block-&gt;successors()[j]-&gt;index();</span>
              predecessors[successorIndex][blockIndex] = true;
          }
      }
  
      auto dumpBitVector = [] (FastBitVector&amp; bits) {
<span class="line-new-header">--- 142,15 ---</span>
      const auto&amp; instructions = codeBlock-&gt;instructions();
      unsigned i = 0;
  
      unsigned numberOfBlocks = m_graph.size();
      Vector&lt;FastBitVector&gt; predecessors(numberOfBlocks);
<span class="line-modified">!     for (BytecodeBasicBlock&amp; block : m_graph)</span>
<span class="line-modified">!         predecessors[block.index()].resize(numberOfBlocks);</span>
<span class="line-modified">!     for (BytecodeBasicBlock&amp; block : m_graph) {</span>
<span class="line-modified">!         for (unsigned successorIndex : block.successors()) {</span>
<span class="line-modified">!             unsigned blockIndex = block.index();</span>
              predecessors[successorIndex][blockIndex] = true;
          }
      }
  
      auto dumpBitVector = [] (FastBitVector&amp; bits) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 139,50 ***</span>
              if (bits[j])
                  dataLogF(&quot; %u&quot;, j);
          }
      };
  
<span class="line-modified">!     for (BytecodeBasicBlock* block : m_graph) {</span>
<span class="line-modified">!         dataLogF(&quot;\nBytecode basic block %u: %p (offset: %u, length: %u)\n&quot;, i++, block, block-&gt;leaderOffset(), block-&gt;totalLength());</span>
  
          dataLogF(&quot;Predecessors:&quot;);
<span class="line-modified">!         dumpBitVector(predecessors[block-&gt;index()]);</span>
          dataLogF(&quot;\n&quot;);
  
          dataLogF(&quot;Successors:&quot;);
          FastBitVector successors;
          successors.resize(numberOfBlocks);
<span class="line-modified">!         for (unsigned j = 0; j &lt; block-&gt;successors().size(); j++) {</span>
<span class="line-modified">!             BytecodeBasicBlock* successor = block-&gt;successors()[j];</span>
<span class="line-removed">-             successors[successor-&gt;index()] = true;</span>
<span class="line-removed">-         }</span>
          dumpBitVector(successors); // Dump in sorted order.
          dataLogF(&quot;\n&quot;);
  
<span class="line-modified">!         if (block-&gt;isEntryBlock()) {</span>
<span class="line-modified">!             dataLogF(&quot;Entry block %p\n&quot;, block);</span>
              continue;
          }
<span class="line-modified">!         if (block-&gt;isExitBlock()) {</span>
<span class="line-modified">!             dataLogF(&quot;Exit block: %p\n&quot;, block);</span>
              continue;
          }
<span class="line-modified">!         for (unsigned bytecodeOffset = block-&gt;leaderOffset(); bytecodeOffset &lt; block-&gt;leaderOffset() + block-&gt;totalLength();) {</span>
              const auto currentInstruction = instructions.at(bytecodeOffset);
  
              dataLogF(&quot;Live variables:&quot;);
<span class="line-modified">!             FastBitVector liveBefore = getLivenessInfoAtBytecodeOffset(codeBlock, bytecodeOffset);</span>
              dumpBitVector(liveBefore);
              dataLogF(&quot;\n&quot;);
              codeBlock-&gt;dumpBytecode(WTF::dataFile(), currentInstruction);
  
              bytecodeOffset += currentInstruction-&gt;size();
          }
  
          dataLogF(&quot;Live variables:&quot;);
<span class="line-modified">!         FastBitVector liveAfter = block-&gt;out();</span>
          dumpBitVector(liveAfter);
          dataLogF(&quot;\n&quot;);
      }
  }
  
  } // namespace JSC
<span class="line-new-header">--- 158,83 ---</span>
              if (bits[j])
                  dataLogF(&quot; %u&quot;, j);
          }
      };
  
<span class="line-modified">!     for (BytecodeBasicBlock&amp; block : m_graph) {</span>
<span class="line-modified">!         dataLogF(&quot;\nBytecode basic block %u: %p (offset: %u, length: %u)\n&quot;, i++, &amp;block, block.leaderOffset(), block.totalLength());</span>
  
          dataLogF(&quot;Predecessors:&quot;);
<span class="line-modified">!         dumpBitVector(predecessors[block.index()]);</span>
          dataLogF(&quot;\n&quot;);
  
          dataLogF(&quot;Successors:&quot;);
          FastBitVector successors;
          successors.resize(numberOfBlocks);
<span class="line-modified">!         for (unsigned successorIndex : block.successors())</span>
<span class="line-modified">!             successors[successorIndex] = true;</span>
          dumpBitVector(successors); // Dump in sorted order.
          dataLogF(&quot;\n&quot;);
  
<span class="line-modified">!         if (block.isEntryBlock()) {</span>
<span class="line-modified">!             dataLogF(&quot;Entry block %p\n&quot;, &amp;block);</span>
              continue;
          }
<span class="line-modified">!         if (block.isExitBlock()) {</span>
<span class="line-modified">!             dataLogF(&quot;Exit block: %p\n&quot;, &amp;block);</span>
              continue;
          }
<span class="line-modified">!         for (unsigned bytecodeOffset = block.leaderOffset(); bytecodeOffset &lt; block.leaderOffset() + block.totalLength();) {</span>
              const auto currentInstruction = instructions.at(bytecodeOffset);
  
              dataLogF(&quot;Live variables:&quot;);
<span class="line-modified">!             FastBitVector liveBefore = getLivenessInfoAtBytecodeIndex(codeBlock, BytecodeIndex(bytecodeOffset));</span>
              dumpBitVector(liveBefore);
              dataLogF(&quot;\n&quot;);
              codeBlock-&gt;dumpBytecode(WTF::dataFile(), currentInstruction);
  
              bytecodeOffset += currentInstruction-&gt;size();
          }
  
          dataLogF(&quot;Live variables:&quot;);
<span class="line-modified">!         FastBitVector liveAfter = block.out();</span>
          dumpBitVector(liveAfter);
          dataLogF(&quot;\n&quot;);
      }
  }
  
<span class="line-added">+ template&lt;typename EnumType1, typename EnumType2&gt;</span>
<span class="line-added">+ constexpr bool enumValuesEqualAsIntegral(EnumType1 v1, EnumType2 v2)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     using IntType1 = typename std::underlying_type&lt;EnumType1&gt;::type;</span>
<span class="line-added">+     using IntType2 = typename std::underlying_type&lt;EnumType2&gt;::type;</span>
<span class="line-added">+     if constexpr (sizeof(IntType1) &gt; sizeof(IntType2))</span>
<span class="line-added">+         return static_cast&lt;IntType1&gt;(v1) == static_cast&lt;IntType1&gt;(v2);</span>
<span class="line-added">+     else</span>
<span class="line-added">+         return static_cast&lt;IntType2&gt;(v1) == static_cast&lt;IntType2&gt;(v2);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Bitmap&lt;maxNumCheckpointTmps&gt; tmpLivenessForCheckpoint(const CodeBlock&amp; codeBlock, BytecodeIndex bytecodeIndex)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Bitmap&lt;maxNumCheckpointTmps&gt; result;</span>
<span class="line-added">+     uint8_t checkpoint = bytecodeIndex.checkpoint();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!checkpoint)</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+ </span>
<span class="line-added">+     switch (codeBlock.instructions().at(bytecodeIndex)-&gt;opcodeID()) {</span>
<span class="line-added">+     case op_call_varargs:</span>
<span class="line-added">+     case op_tail_call_varargs:</span>
<span class="line-added">+     case op_construct_varargs: {</span>
<span class="line-added">+         static_assert(enumValuesEqualAsIntegral(OpCallVarargs::makeCall, OpTailCallVarargs::makeCall) &amp;&amp; enumValuesEqualAsIntegral(OpCallVarargs::argCountIncludingThis, OpTailCallVarargs::argCountIncludingThis));</span>
<span class="line-added">+         static_assert(enumValuesEqualAsIntegral(OpCallVarargs::makeCall, OpConstructVarargs::makeCall) &amp;&amp; enumValuesEqualAsIntegral(OpCallVarargs::argCountIncludingThis, OpConstructVarargs::argCountIncludingThis));</span>
<span class="line-added">+         if (checkpoint == OpCallVarargs::makeCall)</span>
<span class="line-added">+             result.set(OpCallVarargs::argCountIncludingThis);</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace JSC
</pre>
<center><a href="BytecodeList.rb.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeLivenessAnalysis.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/URLParser.cpp b/modules/javafx.web/src/main/native/Source/WTF/wtf/URLParser.cpp
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/URLParser.cpp
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/URLParser.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -650,16 +650,15 @@
     }
 }
 
 Optional<uint16_t> URLParser::defaultPortForProtocol(StringView scheme)
 {
-    static const uint16_t ftpPort = 21;
-    static const uint16_t gopherPort = 70;
-    static const uint16_t httpPort = 80;
-    static const uint16_t httpsPort = 443;
-    static const uint16_t wsPort = 80;
-    static const uint16_t wssPort = 443;
+    static constexpr uint16_t ftpPort = 21;
+    static constexpr uint16_t httpPort = 80;
+    static constexpr uint16_t httpsPort = 443;
+    static constexpr uint16_t wsPort = 80;
+    static constexpr uint16_t wssPort = 443;
 
     auto length = scheme.length();
     if (!length)
         return WTF::nullopt;
     switch (scheme[0]) {
@@ -693,19 +692,10 @@
                 return httpsPort;
             return WTF::nullopt;
         default:
             return WTF::nullopt;
         }
-    case 'g':
-        if (length == 6
-            && scheme[1] == 'o'
-            && scheme[2] == 'p'
-            && scheme[3] == 'h'
-            && scheme[4] == 'e'
-            && scheme[5] == 'r')
-            return gopherPort;
-        return WTF::nullopt;
     case 'f':
         if (length == 3
             && scheme[1] == 't'
             && scheme[2] == 'p')
             return ftpPort;
@@ -721,11 +711,10 @@
 #endif
     WS,
     WSS,
     File,
     FTP,
-    Gopher,
     HTTP,
     HTTPS,
     NonSpecial
 };
 
@@ -749,19 +738,10 @@
                 return Scheme::File;
             return Scheme::NonSpecial;
         default:
             return Scheme::NonSpecial;
         }
-    case 'g':
-        if (length == 6
-            && scheme[1] == 'o'
-            && scheme[2] == 'p'
-            && scheme[3] == 'h'
-            && scheme[4] == 'e'
-            && scheme[5] == 'r')
-            return Scheme::Gopher;
-        return Scheme::NonSpecial;
     case 'h':
         switch (length) {
         case 4:
             if (scheme[1] == 't'
                 && scheme[2] == 't'
@@ -930,11 +910,10 @@
         return;
     case Scheme::File:
         m_urlIsFile = true;
         FALLTHROUGH;
     case Scheme::FTP:
-    case Scheme::Gopher:
     case Scheme::HTTP:
     case Scheme::HTTPS:
         m_urlIsSpecial = true;
         return;
     case Scheme::NonSpecial:
@@ -1180,19 +1159,19 @@
     ASSERT(!m_url.m_isValid
         || m_didSeeSyntaxViolation == (m_url.string() != input)
         || (input.isAllSpecialCharacters<isC0ControlOrSpace>()
             && m_url.m_string == base.m_string.left(base.m_queryEnd)));
     ASSERT(internalValuesConsistent(m_url));
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     if (!m_didSeeSyntaxViolation) {
         // Force a syntax violation at the beginning to make sure we get the same result.
         URLParser parser(makeString(" ", input), base, nonUTF8QueryEncoding);
         URL parsed = parser.result();
         if (parsed.isValid())
             ASSERT(allValuesEqual(parser.result(), m_url));
     }
-#endif
+#endif // ASSERT_ENABLED
 }
 
 template<typename CharacterType>
 void URLParser::parse(const CharacterType* input, const unsigned length, const URL& base, const URLTextEncoding* nonUTF8QueryEncoding)
 {
@@ -1311,11 +1290,10 @@
                 case Scheme::HTTP:
                 case Scheme::HTTPS:
                     m_url.m_protocolIsInHTTPFamily = true;
                     FALLTHROUGH;
                 case Scheme::FTP:
-                case Scheme::Gopher:
                     m_urlIsSpecial = true;
                     if (base.protocolIs(urlScheme))
                         state = State::SpecialRelativeOrAuthority;
                     else
                         state = State::SpecialAuthoritySlashes;
@@ -2589,18 +2567,18 @@
     UErrorCode error = U_ZERO_ERROR;
     UIDNAInfo processingDetails = UIDNA_INFO_INITIALIZER;
     int32_t numCharactersConverted = uidna_nameToASCII(&internationalDomainNameTranscoder(), StringView(domain).upconvertedCharacters(), domain.length(), hostnameBuffer, maxDomainLength, &processingDetails, &error);
 
     if (U_SUCCESS(error) && !processingDetails.errors) {
-#if ASSERT_DISABLED
-        UNUSED_PARAM(numCharactersConverted);
-#else
+#if ASSERT_ENABLED
         for (int32_t i = 0; i < numCharactersConverted; ++i) {
             ASSERT(isASCII(hostnameBuffer[i]));
             ASSERT(!isASCIIUpper(hostnameBuffer[i]));
         }
-#endif
+#else
+        UNUSED_PARAM(numCharactersConverted);
+#endif // ASSERT_ENABLED
         ascii.append(hostnameBuffer, numCharactersConverted);
         if (domain != StringView(ascii.data(), ascii.size()))
             syntaxViolation(iteratorForSyntaxViolationPosition);
         return ascii;
     }

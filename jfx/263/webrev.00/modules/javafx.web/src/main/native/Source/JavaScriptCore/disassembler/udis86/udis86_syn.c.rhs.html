<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/disassembler/udis86/udis86_syn.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* udis86 - libudis86/syn.c
  2  *
  3  * Copyright (c) 2002-2013 Vivek Thampi
  4  * All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without modification,
  7  * are permitted provided that the following conditions are met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright notice,
 10  *       this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above copyright notice,
 12  *       this list of conditions and the following disclaimer in the documentation
 13  *       and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 16  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 19  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 22  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 24  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 
<a name="1" id="anc1"></a><span class="line-modified"> 29 #if ENABLE(UDIS86)</span>
 30 
 31 #include &quot;udis86_types.h&quot;
 32 #include &quot;udis86_decode.h&quot;
 33 #include &quot;udis86_syn.h&quot;
 34 #include &quot;udis86_udint.h&quot;
 35 
 36 /*
 37  * Register Table - Order Matters (types.h)!
 38  *
 39  */
 40 const char* const ud_reg_tab[] =
 41 {
 42   &quot;al&quot;,   &quot;cl&quot;,   &quot;dl&quot;,   &quot;bl&quot;,
 43   &quot;ah&quot;,   &quot;ch&quot;,   &quot;dh&quot;,   &quot;bh&quot;,
 44   &quot;spl&quot;,  &quot;bpl&quot;,  &quot;sil&quot;,  &quot;dil&quot;,
 45   &quot;r8b&quot;,  &quot;r9b&quot;,  &quot;r10b&quot;, &quot;r11b&quot;,
 46   &quot;r12b&quot;, &quot;r13b&quot;, &quot;r14b&quot;, &quot;r15b&quot;,
 47 
 48   &quot;ax&quot;,   &quot;cx&quot;,   &quot;dx&quot;,   &quot;bx&quot;,
 49   &quot;sp&quot;,   &quot;bp&quot;,   &quot;si&quot;,   &quot;di&quot;,
 50   &quot;r8w&quot;,  &quot;r9w&quot;,  &quot;r10w&quot;, &quot;r11w&quot;,
 51   &quot;r12w&quot;, &quot;r13w&quot;, &quot;r14w&quot;, &quot;r15w&quot;,
 52 
 53   &quot;eax&quot;,  &quot;ecx&quot;,  &quot;edx&quot;,  &quot;ebx&quot;,
 54   &quot;esp&quot;,  &quot;ebp&quot;,  &quot;esi&quot;,  &quot;edi&quot;,
 55   &quot;r8d&quot;,  &quot;r9d&quot;,  &quot;r10d&quot;, &quot;r11d&quot;,
 56   &quot;r12d&quot;, &quot;r13d&quot;, &quot;r14d&quot;, &quot;r15d&quot;,
 57 
 58   &quot;rax&quot;,  &quot;rcx&quot;,  &quot;rdx&quot;,  &quot;rbx&quot;,
 59   &quot;rsp&quot;,  &quot;rbp&quot;,  &quot;rsi&quot;,  &quot;rdi&quot;,
 60   &quot;r8&quot;,   &quot;r9&quot;,   &quot;r10&quot;,  &quot;r11&quot;,
 61   &quot;r12&quot;,  &quot;r13&quot;,  &quot;r14&quot;,  &quot;r15&quot;,
 62 
 63   &quot;es&quot;,   &quot;cs&quot;,   &quot;ss&quot;,   &quot;ds&quot;,
 64   &quot;fs&quot;,   &quot;gs&quot;,
 65 
 66   &quot;cr0&quot;,  &quot;cr1&quot;,  &quot;cr2&quot;,  &quot;cr3&quot;,
 67   &quot;cr4&quot;,  &quot;cr5&quot;,  &quot;cr6&quot;,  &quot;cr7&quot;,
 68   &quot;cr8&quot;,  &quot;cr9&quot;,  &quot;cr10&quot;, &quot;cr11&quot;,
 69   &quot;cr12&quot;, &quot;cr13&quot;, &quot;cr14&quot;, &quot;cr15&quot;,
 70 
 71   &quot;dr0&quot;,  &quot;dr1&quot;,  &quot;dr2&quot;,  &quot;dr3&quot;,
 72   &quot;dr4&quot;,  &quot;dr5&quot;,  &quot;dr6&quot;,  &quot;dr7&quot;,
 73   &quot;dr8&quot;,  &quot;dr9&quot;,  &quot;dr10&quot;, &quot;dr11&quot;,
 74   &quot;dr12&quot;, &quot;dr13&quot;, &quot;dr14&quot;, &quot;dr15&quot;,
 75 
 76   &quot;mm0&quot;,  &quot;mm1&quot;,  &quot;mm2&quot;,  &quot;mm3&quot;,
 77   &quot;mm4&quot;,  &quot;mm5&quot;,  &quot;mm6&quot;,  &quot;mm7&quot;,
 78 
 79   &quot;st0&quot;,  &quot;st1&quot;,  &quot;st2&quot;,  &quot;st3&quot;,
 80   &quot;st4&quot;,  &quot;st5&quot;,  &quot;st6&quot;,  &quot;st7&quot;,
 81 
 82   &quot;xmm0&quot;, &quot;xmm1&quot;, &quot;xmm2&quot;, &quot;xmm3&quot;,
 83   &quot;xmm4&quot;, &quot;xmm5&quot;, &quot;xmm6&quot;, &quot;xmm7&quot;,
 84   &quot;xmm8&quot;, &quot;xmm9&quot;, &quot;xmm10&quot;, &quot;xmm11&quot;,
 85   &quot;xmm12&quot;, &quot;xmm13&quot;, &quot;xmm14&quot;, &quot;xmm15&quot;,
 86 
 87   &quot;ymm0&quot;, &quot;ymm1&quot;, &quot;ymm2&quot;,   &quot;ymm3&quot;,
 88   &quot;ymm4&quot;, &quot;ymm5&quot;, &quot;ymm6&quot;,   &quot;ymm7&quot;,
 89   &quot;ymm8&quot;, &quot;ymm9&quot;, &quot;ymm10&quot;,  &quot;ymm11&quot;,
 90   &quot;ymm12&quot;, &quot;ymm13&quot;, &quot;ymm14&quot;, &quot;ymm15&quot;,
 91 
 92   &quot;rip&quot;
 93 };
 94 
 95 
 96 uint64_t
 97 ud_syn_rel_target(struct ud *u, struct ud_operand *opr)
 98 {
 99   const uint64_t trunc_mask = 0xffffffffffffffffull &gt;&gt; (64 - u-&gt;opr_mode);
100   switch (opr-&gt;size) {
101   case 8 : return (u-&gt;pc + opr-&gt;lval.sbyte)  &amp; trunc_mask;
102   case 16: return (u-&gt;pc + opr-&gt;lval.sword)  &amp; trunc_mask;
103   case 32: return (u-&gt;pc + opr-&gt;lval.sdword) &amp; trunc_mask;
104   default: UD_ASSERT(!&quot;invalid relative offset size.&quot;);
105     return 0ull;
106   }
107 }
108 
109 
110 /*
111  * asmprintf
112  *    Printf style function for printing translated assembly
113  *    output. Returns the number of characters written and
114  *    moves the buffer pointer forward. On an overflow,
115  *    returns a negative number and truncates the output.
116  */
117 int
118 ud_asmprintf(struct ud *u, const char *fmt, ...)
119 {
120   int ret;
121   int avail;
122   va_list ap;
123   va_start(ap, fmt);
124   avail = u-&gt;asm_buf_size - u-&gt;asm_buf_fill - 1 /* nullchar */;
125   ret = vsnprintf((char*) u-&gt;asm_buf + u-&gt;asm_buf_fill, avail, fmt, ap);
126   if (ret &lt; 0 || ret &gt; avail) {
127       u-&gt;asm_buf_fill = u-&gt;asm_buf_size - 1;
128   } else {
129       u-&gt;asm_buf_fill += ret;
130   }
131   va_end(ap);
132   return ret;
133 }
134 
135 
136 void
137 ud_syn_print_addr(struct ud *u, uint64_t addr)
138 {
139   const char *name = NULL;
140   if (u-&gt;sym_resolver) {
141     int64_t offset = 0;
142     name = u-&gt;sym_resolver(u, addr, &amp;offset);
143     if (name) {
144       if (offset) {
145         ud_asmprintf(u, &quot;%s%+&quot; FMT64 &quot;d&quot;, name, offset);
146       } else {
147         ud_asmprintf(u, &quot;%s&quot;, name);
148       }
149       return;
150     }
151   }
152   ud_asmprintf(u, &quot;0x%&quot; FMT64 &quot;x&quot;, addr);
153 }
154 
155 
156 void
157 ud_syn_print_imm(struct ud* u, const struct ud_operand *op)
158 {
159   uint64_t v;
160   if (op-&gt;_oprcode == OP_sI &amp;&amp; op-&gt;size != u-&gt;opr_mode) {
161     if (op-&gt;size == 8) {
162       v = (int64_t)op-&gt;lval.sbyte;
163     } else {
164       UD_ASSERT(op-&gt;size == 32);
165       v = (int64_t)op-&gt;lval.sdword;
166     }
167     if (u-&gt;opr_mode &lt; 64) {
168       v = v &amp; ((1ull &lt;&lt; u-&gt;opr_mode) - 1ull);
169     }
170   } else {
171     switch (op-&gt;size) {
172     case 8 : v = op-&gt;lval.ubyte;  break;
173     case 16: v = op-&gt;lval.uword;  break;
174     case 32: v = op-&gt;lval.udword; break;
175     case 64: v = op-&gt;lval.uqword; break;
176     default: UD_ASSERT(!&quot;invalid offset&quot;); v = 0; /* keep cc happy */
177     }
178   }
179   ud_asmprintf(u, &quot;0x%&quot; FMT64 &quot;x&quot;, v);
180 }
181 
182 
183 void
184 ud_syn_print_mem_disp(struct ud* u, const struct ud_operand *op, int sign)
185 {
186   UD_ASSERT(op-&gt;offset != 0);
187  if (op-&gt;base == UD_NONE &amp;&amp; op-&gt;index == UD_NONE) {
188     uint64_t v;
189     UD_ASSERT(op-&gt;scale == UD_NONE &amp;&amp; op-&gt;offset != 8);
190     /* unsigned mem-offset */
191     switch (op-&gt;offset) {
192     case 16: v = op-&gt;lval.uword;  break;
193     case 32: v = op-&gt;lval.udword; break;
194     case 64: v = op-&gt;lval.uqword; break;
195     default: UD_ASSERT(!&quot;invalid offset&quot;); v = 0; /* keep cc happy */
196     }
197     ud_asmprintf(u, &quot;0x%&quot; FMT64 &quot;x&quot;, v);
198   } else {
199     int64_t v;
200     UD_ASSERT(op-&gt;offset != 64);
201     switch (op-&gt;offset) {
202     case 8 : v = op-&gt;lval.sbyte;  break;
203     case 16: v = op-&gt;lval.sword;  break;
204     case 32: v = op-&gt;lval.sdword; break;
205     default: UD_ASSERT(!&quot;invalid offset&quot;); v = 0; /* keep cc happy */
206     }
207     if (v &lt; 0) {
208       ud_asmprintf(u, &quot;-0x%&quot; FMT64 &quot;x&quot;, -v);
209     } else if (v &gt; 0) {
210       ud_asmprintf(u, &quot;%s0x%&quot; FMT64 &quot;x&quot;, sign? &quot;+&quot; : &quot;&quot;, v);
211     }
212   }
213 }
214 
<a name="2" id="anc2"></a><span class="line-modified">215 #endif // ENABLE(UDIS86)</span>
216 
217 /*
218 vim: set ts=2 sw=2 expandtab
219 */
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
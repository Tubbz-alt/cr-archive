<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSCanvasValue.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSCrossfadeValue.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,10 ***</span>
<span class="line-new-header">--- 34,11 ---</span>
  #include &quot;CSSFontFeatureValue.h&quot;
  #include &quot;CSSFontStyleValue.h&quot;
  #include &quot;CSSFontValue.h&quot;
  #include &quot;CSSFontVariationValue.h&quot;
  #include &quot;CSSFunctionValue.h&quot;
<span class="line-added">+ #include &quot;CSSGridAutoRepeatValue.h&quot;</span>
  #include &quot;CSSLineBoxContainValue.h&quot;
  #include &quot;CSSPrimitiveValue.h&quot;
  #include &quot;CSSPrimitiveValueMappings.h&quot;
  #include &quot;CSSPropertyNames.h&quot;
  #include &quot;CSSPropertyParser.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,11 ***</span>
  #include &quot;Rect.h&quot;
  #include &quot;RenderBlock.h&quot;
  #include &quot;RenderBox.h&quot;
  #include &quot;RenderInline.h&quot;
  #include &quot;RenderStyle.h&quot;
<span class="line-removed">- #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  #include &quot;SVGElement.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;ShapeValue.h&quot;
  #include &quot;StyleProperties.h&quot;
  #include &quot;StylePropertyShorthand.h&quot;
<span class="line-new-header">--- 62,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,420 ***</span>
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(CSSComputedStyleDeclaration);
  
<span class="line-modified">! // List of all properties we know how to compute, omitting shorthands.</span>
<span class="line-removed">- static const CSSPropertyID computedProperties[] = {</span>
<span class="line-removed">-     CSSPropertyAlignContent,</span>
<span class="line-removed">-     CSSPropertyAlignItems,</span>
<span class="line-removed">-     CSSPropertyAlignSelf,</span>
<span class="line-removed">-     CSSPropertyAlignmentBaseline,</span>
<span class="line-removed">-     CSSPropertyAlt,</span>
<span class="line-removed">-     CSSPropertyAnimationDelay,</span>
<span class="line-removed">-     CSSPropertyAnimationDirection,</span>
<span class="line-removed">-     CSSPropertyAnimationDuration,</span>
<span class="line-removed">-     CSSPropertyAnimationFillMode,</span>
<span class="line-removed">-     CSSPropertyAnimationIterationCount,</span>
<span class="line-removed">-     CSSPropertyAnimationName,</span>
<span class="line-removed">-     CSSPropertyAnimationPlayState,</span>
<span class="line-removed">-     CSSPropertyAnimationTimingFunction,</span>
<span class="line-removed">-     CSSPropertyBackgroundAttachment,</span>
<span class="line-removed">-     CSSPropertyBackgroundBlendMode,</span>
<span class="line-removed">-     CSSPropertyBackgroundClip,</span>
<span class="line-removed">-     CSSPropertyBackgroundColor,</span>
<span class="line-removed">-     CSSPropertyBackgroundImage,</span>
<span class="line-removed">-     CSSPropertyBackgroundOrigin,</span>
<span class="line-removed">-     CSSPropertyBackgroundPosition, // more-specific background-position-x/y are non-standard</span>
<span class="line-removed">-     CSSPropertyBackgroundRepeat,</span>
<span class="line-removed">-     CSSPropertyBackgroundSize,</span>
<span class="line-removed">-     CSSPropertyBaselineShift,</span>
<span class="line-removed">-     CSSPropertyBorderBottomColor,</span>
<span class="line-removed">-     CSSPropertyBorderBottomLeftRadius,</span>
<span class="line-removed">-     CSSPropertyBorderBottomRightRadius,</span>
<span class="line-removed">-     CSSPropertyBorderBottomStyle,</span>
<span class="line-removed">-     CSSPropertyBorderBottomWidth,</span>
<span class="line-removed">-     CSSPropertyBorderCollapse,</span>
<span class="line-removed">-     CSSPropertyBorderImageOutset,</span>
<span class="line-removed">-     CSSPropertyBorderImageRepeat,</span>
<span class="line-removed">-     CSSPropertyBorderImageSlice,</span>
<span class="line-removed">-     CSSPropertyBorderImageSource,</span>
<span class="line-removed">-     CSSPropertyBorderImageWidth,</span>
<span class="line-removed">-     CSSPropertyBorderLeftColor,</span>
<span class="line-removed">-     CSSPropertyBorderLeftStyle,</span>
<span class="line-removed">-     CSSPropertyBorderLeftWidth,</span>
<span class="line-removed">-     CSSPropertyBorderRightColor,</span>
<span class="line-removed">-     CSSPropertyBorderRightStyle,</span>
<span class="line-removed">-     CSSPropertyBorderRightWidth,</span>
<span class="line-removed">-     CSSPropertyBorderTopColor,</span>
<span class="line-removed">-     CSSPropertyBorderTopLeftRadius,</span>
<span class="line-removed">-     CSSPropertyBorderTopRightRadius,</span>
<span class="line-removed">-     CSSPropertyBorderTopStyle,</span>
<span class="line-removed">-     CSSPropertyBorderTopWidth,</span>
<span class="line-removed">-     CSSPropertyBottom,</span>
<span class="line-removed">-     CSSPropertyBoxShadow,</span>
<span class="line-removed">-     CSSPropertyBoxSizing,</span>
<span class="line-removed">-     CSSPropertyBufferedRendering,</span>
<span class="line-removed">-     CSSPropertyCaptionSide,</span>
<span class="line-removed">-     CSSPropertyCaretColor,</span>
<span class="line-removed">-     CSSPropertyClear,</span>
<span class="line-removed">-     CSSPropertyClip,</span>
<span class="line-removed">-     CSSPropertyClipPath,</span>
<span class="line-removed">-     CSSPropertyClipRule,</span>
<span class="line-removed">-     CSSPropertyColor,</span>
<span class="line-removed">-     CSSPropertyColorInterpolation,</span>
<span class="line-removed">-     CSSPropertyColorInterpolationFilters,</span>
<span class="line-removed">-     CSSPropertyColorRendering,</span>
<span class="line-removed">- #if ENABLE(DARK_MODE_CSS)</span>
<span class="line-removed">-     CSSPropertyColorScheme,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyColumnCount,</span>
<span class="line-removed">-     CSSPropertyColumnFill,</span>
<span class="line-removed">-     CSSPropertyColumnGap,</span>
<span class="line-removed">-     CSSPropertyColumnRuleColor,</span>
<span class="line-removed">-     CSSPropertyColumnRuleStyle,</span>
<span class="line-removed">-     CSSPropertyColumnRuleWidth,</span>
<span class="line-removed">-     CSSPropertyColumnSpan,</span>
<span class="line-removed">-     CSSPropertyColumnWidth,</span>
<span class="line-removed">-     CSSPropertyContent,</span>
<span class="line-removed">-     CSSPropertyCounterIncrement,</span>
<span class="line-removed">-     CSSPropertyCounterReset,</span>
<span class="line-removed">-     CSSPropertyCursor,</span>
<span class="line-removed">-     CSSPropertyCx,</span>
<span class="line-removed">-     CSSPropertyCy,</span>
<span class="line-removed">-     CSSPropertyDirection,</span>
<span class="line-removed">-     CSSPropertyDisplay,</span>
<span class="line-removed">-     CSSPropertyDominantBaseline,</span>
<span class="line-removed">-     CSSPropertyEmptyCells,</span>
<span class="line-removed">-     CSSPropertyFill,</span>
<span class="line-removed">-     CSSPropertyFillOpacity,</span>
<span class="line-removed">-     CSSPropertyFillRule,</span>
<span class="line-removed">-     CSSPropertyFilter,</span>
<span class="line-removed">-     CSSPropertyFlexBasis,</span>
<span class="line-removed">-     CSSPropertyFlexDirection,</span>
<span class="line-removed">-     CSSPropertyFlexFlow,</span>
<span class="line-removed">-     CSSPropertyFlexGrow,</span>
<span class="line-removed">-     CSSPropertyFlexShrink,</span>
<span class="line-removed">-     CSSPropertyFlexWrap,</span>
<span class="line-removed">-     CSSPropertyFloat,</span>
<span class="line-removed">-     CSSPropertyFloodColor,</span>
<span class="line-removed">-     CSSPropertyFloodOpacity,</span>
<span class="line-removed">-     CSSPropertyFontFamily,</span>
<span class="line-removed">- #if ENABLE(VARIATION_FONTS)</span>
<span class="line-removed">-     CSSPropertyFontOpticalSizing,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyFontSize,</span>
<span class="line-removed">-     CSSPropertyFontStretch,</span>
<span class="line-removed">-     CSSPropertyFontStyle,</span>
<span class="line-removed">-     CSSPropertyFontSynthesis,</span>
<span class="line-removed">-     CSSPropertyFontVariant,</span>
<span class="line-removed">-     CSSPropertyFontVariantAlternates,</span>
<span class="line-removed">-     CSSPropertyFontVariantCaps,</span>
<span class="line-removed">-     CSSPropertyFontVariantEastAsian,</span>
<span class="line-removed">-     CSSPropertyFontVariantLigatures,</span>
<span class="line-removed">-     CSSPropertyFontVariantNumeric,</span>
<span class="line-removed">-     CSSPropertyFontVariantPosition,</span>
<span class="line-removed">- #if ENABLE(VARIATION_FONTS)</span>
<span class="line-removed">-     CSSPropertyFontVariationSettings,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyFontWeight,</span>
<span class="line-removed">-     CSSPropertyGlyphOrientationHorizontal,</span>
<span class="line-removed">-     CSSPropertyGlyphOrientationVertical,</span>
<span class="line-removed">-     CSSPropertyGridAutoColumns,</span>
<span class="line-removed">-     CSSPropertyGridAutoFlow,</span>
<span class="line-removed">-     CSSPropertyGridAutoRows,</span>
<span class="line-removed">-     CSSPropertyGridColumnEnd,</span>
<span class="line-removed">-     CSSPropertyGridColumnStart,</span>
<span class="line-removed">-     CSSPropertyGridRowEnd,</span>
<span class="line-removed">-     CSSPropertyGridRowStart,</span>
<span class="line-removed">-     CSSPropertyGridTemplateAreas,</span>
<span class="line-removed">-     CSSPropertyGridTemplateColumns,</span>
<span class="line-removed">-     CSSPropertyGridTemplateRows,</span>
<span class="line-removed">-     CSSPropertyHangingPunctuation,</span>
<span class="line-removed">-     CSSPropertyHeight,</span>
<span class="line-removed">- #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
<span class="line-removed">-     CSSPropertyImageOrientation,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyImageRendering,</span>
<span class="line-removed">- #if ENABLE(CSS_IMAGE_RESOLUTION)</span>
<span class="line-removed">-     CSSPropertyImageResolution,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-removed">-     CSSPropertyIsolation,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyJustifyContent,</span>
<span class="line-removed">-     CSSPropertyJustifyItems,</span>
<span class="line-removed">-     CSSPropertyJustifySelf,</span>
<span class="line-removed">-     CSSPropertyKerning,</span>
<span class="line-removed">-     CSSPropertyLeft,</span>
<span class="line-removed">-     CSSPropertyLetterSpacing,</span>
<span class="line-removed">-     CSSPropertyLightingColor,</span>
<span class="line-removed">-     CSSPropertyLineBreak,</span>
<span class="line-removed">-     CSSPropertyLineHeight,</span>
<span class="line-removed">-     CSSPropertyListStyleImage,</span>
<span class="line-removed">-     CSSPropertyListStylePosition,</span>
<span class="line-removed">-     CSSPropertyListStyleType,</span>
<span class="line-removed">-     CSSPropertyMarginBottom,</span>
<span class="line-removed">-     CSSPropertyMarginLeft,</span>
<span class="line-removed">-     CSSPropertyMarginRight,</span>
<span class="line-removed">-     CSSPropertyMarginTop,</span>
<span class="line-removed">-     CSSPropertyMarkerEnd,</span>
<span class="line-removed">-     CSSPropertyMarkerMid,</span>
<span class="line-removed">-     CSSPropertyMarkerStart,</span>
<span class="line-removed">-     CSSPropertyMask,</span>
<span class="line-removed">-     CSSPropertyMaskType,</span>
<span class="line-removed">-     CSSPropertyMaxHeight,</span>
<span class="line-removed">-     CSSPropertyMaxWidth,</span>
<span class="line-removed">-     CSSPropertyMinHeight,</span>
<span class="line-removed">-     CSSPropertyMinWidth,</span>
<span class="line-removed">- #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-removed">-     CSSPropertyMixBlendMode,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyObjectFit,</span>
<span class="line-removed">-     CSSPropertyObjectPosition,</span>
<span class="line-removed">-     CSSPropertyOpacity,</span>
<span class="line-removed">-     CSSPropertyOrder,</span>
<span class="line-removed">-     CSSPropertyOrphans,</span>
<span class="line-removed">-     CSSPropertyOutlineColor,</span>
<span class="line-removed">-     CSSPropertyOutlineOffset,</span>
<span class="line-removed">-     CSSPropertyOutlineStyle,</span>
<span class="line-removed">-     CSSPropertyOutlineWidth,</span>
<span class="line-removed">-     CSSPropertyOverflowWrap,</span>
<span class="line-removed">-     CSSPropertyOverflowX,</span>
<span class="line-removed">-     CSSPropertyOverflowY,</span>
<span class="line-removed">-     CSSPropertyPaddingBottom,</span>
<span class="line-removed">-     CSSPropertyPaddingLeft,</span>
<span class="line-removed">-     CSSPropertyPaddingRight,</span>
<span class="line-removed">-     CSSPropertyPaddingTop,</span>
<span class="line-removed">-     CSSPropertyPageBreakAfter,</span>
<span class="line-removed">-     CSSPropertyPageBreakBefore,</span>
<span class="line-removed">-     CSSPropertyPageBreakInside,</span>
<span class="line-removed">-     CSSPropertyPaintOrder,</span>
<span class="line-removed">-     CSSPropertyPerspective,</span>
<span class="line-removed">-     CSSPropertyPerspectiveOrigin,</span>
<span class="line-removed">-     CSSPropertyPlaceContent,</span>
<span class="line-removed">-     CSSPropertyPlaceItems,</span>
<span class="line-removed">-     CSSPropertyPlaceSelf,</span>
<span class="line-removed">-     CSSPropertyPointerEvents,</span>
<span class="line-removed">-     CSSPropertyPosition,</span>
<span class="line-removed">-     CSSPropertyR,</span>
<span class="line-removed">-     CSSPropertyResize,</span>
<span class="line-removed">-     CSSPropertyRight,</span>
<span class="line-removed">-     CSSPropertyRowGap,</span>
<span class="line-removed">-     CSSPropertyRx,</span>
<span class="line-removed">-     CSSPropertyRy,</span>
<span class="line-removed">- #if ENABLE(CSS_SCROLL_SNAP)</span>
<span class="line-removed">-     CSSPropertyScrollPadding,</span>
<span class="line-removed">-     CSSPropertyScrollPaddingBottom,</span>
<span class="line-removed">-     CSSPropertyScrollPaddingLeft,</span>
<span class="line-removed">-     CSSPropertyScrollPaddingRight,</span>
<span class="line-removed">-     CSSPropertyScrollPaddingTop,</span>
<span class="line-removed">-     CSSPropertyScrollSnapAlign,</span>
<span class="line-removed">-     CSSPropertyScrollSnapMargin,</span>
<span class="line-removed">-     CSSPropertyScrollSnapMarginBottom,</span>
<span class="line-removed">-     CSSPropertyScrollSnapMarginLeft,</span>
<span class="line-removed">-     CSSPropertyScrollSnapMarginRight,</span>
<span class="line-removed">-     CSSPropertyScrollSnapMarginTop,</span>
<span class="line-removed">-     CSSPropertyScrollSnapType,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyShapeImageThreshold,</span>
<span class="line-removed">-     CSSPropertyShapeMargin,</span>
<span class="line-removed">-     CSSPropertyShapeOutside,</span>
<span class="line-removed">-     CSSPropertyShapeRendering,</span>
<span class="line-removed">-     CSSPropertySpeakAs,</span>
<span class="line-removed">-     CSSPropertyStopColor,</span>
<span class="line-removed">-     CSSPropertyStopOpacity,</span>
<span class="line-removed">-     CSSPropertyStroke,</span>
<span class="line-removed">-     CSSPropertyStrokeColor,</span>
<span class="line-removed">-     CSSPropertyStrokeDasharray,</span>
<span class="line-removed">-     CSSPropertyStrokeDashoffset,</span>
<span class="line-removed">-     CSSPropertyStrokeLinecap,</span>
<span class="line-removed">-     CSSPropertyStrokeLinejoin,</span>
<span class="line-removed">-     CSSPropertyStrokeMiterlimit,</span>
<span class="line-removed">-     CSSPropertyStrokeOpacity,</span>
<span class="line-removed">-     CSSPropertyStrokeWidth,</span>
<span class="line-removed">-     CSSPropertyTabSize,</span>
<span class="line-removed">-     CSSPropertyTableLayout,</span>
<span class="line-removed">-     CSSPropertyTextAlign,</span>
<span class="line-removed">-     CSSPropertyTextAnchor,</span>
<span class="line-removed">-     CSSPropertyTextDecoration,</span>
<span class="line-removed">-     CSSPropertyTextDecorationColor,</span>
<span class="line-removed">-     CSSPropertyTextDecorationLine,</span>
<span class="line-removed">-     CSSPropertyTextDecorationSkip,</span>
<span class="line-removed">-     CSSPropertyTextDecorationStyle,</span>
<span class="line-removed">-     CSSPropertyTextIndent,</span>
<span class="line-removed">-     CSSPropertyTextOverflow,</span>
<span class="line-removed">-     CSSPropertyTextRendering,</span>
<span class="line-removed">-     CSSPropertyTextShadow,</span>
<span class="line-removed">-     CSSPropertyTextTransform,</span>
<span class="line-removed">-     CSSPropertyTextUnderlinePosition,</span>
<span class="line-removed">-     CSSPropertyTop,</span>
<span class="line-removed">- #if ENABLE(POINTER_EVENTS)</span>
<span class="line-removed">-     CSSPropertyTouchAction,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyTransform,</span>
<span class="line-removed">-     CSSPropertyTransformBox,</span>
<span class="line-removed">-     CSSPropertyTransformOrigin,</span>
<span class="line-removed">-     CSSPropertyTransformStyle,</span>
<span class="line-removed">-     CSSPropertyTransitionDelay,</span>
<span class="line-removed">-     CSSPropertyTransitionDuration,</span>
<span class="line-removed">-     CSSPropertyTransitionProperty,</span>
<span class="line-removed">-     CSSPropertyTransitionTimingFunction,</span>
<span class="line-removed">-     CSSPropertyUnicodeBidi,</span>
<span class="line-removed">-     CSSPropertyVectorEffect,</span>
<span class="line-removed">-     CSSPropertyVerticalAlign,</span>
<span class="line-removed">-     CSSPropertyVisibility,</span>
<span class="line-removed">-     CSSPropertyWhiteSpace,</span>
<span class="line-removed">-     CSSPropertyWidows,</span>
<span class="line-removed">-     CSSPropertyWidth,</span>
<span class="line-removed">-     CSSPropertyWillChange,</span>
<span class="line-removed">-     CSSPropertyWordBreak,</span>
<span class="line-removed">-     CSSPropertyWordSpacing,</span>
<span class="line-removed">-     CSSPropertyWordWrap,</span>
<span class="line-removed">-     CSSPropertyWritingMode,</span>
<span class="line-removed">-     CSSPropertyX,</span>
<span class="line-removed">-     CSSPropertyY,</span>
<span class="line-removed">-     CSSPropertyZIndex,</span>
<span class="line-removed">-     CSSPropertyZoom,</span>
<span class="line-removed">-     CSSPropertyAppleColorFilter,</span>
<span class="line-removed">-     CSSPropertyWebkitAppearance,</span>
<span class="line-removed">- #if ENABLE(FILTERS_LEVEL_2)</span>
<span class="line-removed">-     CSSPropertyWebkitBackdropFilter,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyWebkitBackfaceVisibility,</span>
<span class="line-removed">-     CSSPropertyWebkitBackgroundClip,</span>
<span class="line-removed">-     CSSPropertyWebkitBackgroundComposite,</span>
<span class="line-removed">-     CSSPropertyWebkitBackgroundOrigin,</span>
<span class="line-removed">-     CSSPropertyWebkitBackgroundSize,</span>
<span class="line-removed">-     CSSPropertyWebkitBorderFit,</span>
<span class="line-removed">-     CSSPropertyWebkitBorderHorizontalSpacing,</span>
<span class="line-removed">-     CSSPropertyWebkitBorderImage,</span>
<span class="line-removed">-     CSSPropertyWebkitBorderVerticalSpacing,</span>
<span class="line-removed">-     CSSPropertyWebkitBoxAlign,</span>
<span class="line-removed">- #if ENABLE(CSS_BOX_DECORATION_BREAK)</span>
<span class="line-removed">-     CSSPropertyWebkitBoxDecorationBreak,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyWebkitBoxDirection,</span>
<span class="line-removed">-     CSSPropertyWebkitBoxFlex,</span>
<span class="line-removed">-     CSSPropertyWebkitBoxFlexGroup,</span>
<span class="line-removed">-     CSSPropertyWebkitBoxLines,</span>
<span class="line-removed">-     CSSPropertyWebkitBoxOrdinalGroup,</span>
<span class="line-removed">-     CSSPropertyWebkitBoxOrient,</span>
<span class="line-removed">-     CSSPropertyWebkitBoxPack,</span>
<span class="line-removed">-     CSSPropertyWebkitBoxReflect,</span>
<span class="line-removed">-     CSSPropertyWebkitBoxShadow,</span>
<span class="line-removed">-     CSSPropertyWebkitClipPath,</span>
<span class="line-removed">-     CSSPropertyWebkitColumnAxis,</span>
<span class="line-removed">-     CSSPropertyWebkitColumnBreakAfter,</span>
<span class="line-removed">-     CSSPropertyWebkitColumnBreakBefore,</span>
<span class="line-removed">-     CSSPropertyWebkitColumnBreakInside,</span>
<span class="line-removed">-     CSSPropertyWebkitColumnProgression,</span>
<span class="line-removed">- #if ENABLE(CURSOR_VISIBILITY)</span>
<span class="line-removed">-     CSSPropertyWebkitCursorVisibility,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyWebkitFontKerning,</span>
<span class="line-removed">-     CSSPropertyWebkitFontSmoothing,</span>
<span class="line-removed">-     CSSPropertyWebkitHyphenateCharacter,</span>
<span class="line-removed">-     CSSPropertyWebkitHyphenateLimitAfter,</span>
<span class="line-removed">-     CSSPropertyWebkitHyphenateLimitBefore,</span>
<span class="line-removed">-     CSSPropertyWebkitHyphenateLimitLines,</span>
<span class="line-removed">-     CSSPropertyWebkitHyphens,</span>
<span class="line-removed">-     CSSPropertyWebkitInitialLetter,</span>
<span class="line-removed">-     CSSPropertyWebkitLineAlign,</span>
<span class="line-removed">-     CSSPropertyWebkitLineBoxContain,</span>
<span class="line-removed">-     CSSPropertyWebkitLineClamp,</span>
<span class="line-removed">-     CSSPropertyWebkitLineGrid,</span>
<span class="line-removed">-     CSSPropertyWebkitLineSnap,</span>
<span class="line-removed">-     CSSPropertyWebkitLocale,</span>
<span class="line-removed">-     CSSPropertyWebkitMarginAfterCollapse,</span>
<span class="line-removed">-     CSSPropertyWebkitMarginBeforeCollapse,</span>
<span class="line-removed">-     CSSPropertyWebkitMarqueeDirection,</span>
<span class="line-removed">-     CSSPropertyWebkitMarqueeIncrement,</span>
<span class="line-removed">-     CSSPropertyWebkitMarqueeRepetition,</span>
<span class="line-removed">-     CSSPropertyWebkitMarqueeStyle,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskBoxImage,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskBoxImageOutset,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskBoxImageRepeat,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskBoxImageSlice,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskBoxImageSource,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskBoxImageWidth,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskClip,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskComposite,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskImage,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskOrigin,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskPosition,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskRepeat,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskSize,</span>
<span class="line-removed">-     CSSPropertyWebkitMaskSourceType,</span>
<span class="line-removed">-     CSSPropertyWebkitNbspMode,</span>
<span class="line-removed">- #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
<span class="line-removed">-     CSSPropertyWebkitOverflowScrolling,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyWebkitPrintColorAdjust,</span>
<span class="line-removed">-     CSSPropertyWebkitRtlOrdering,</span>
<span class="line-removed">- #if ENABLE(TOUCH_EVENTS)</span>
<span class="line-removed">-     CSSPropertyWebkitTapHighlightColor,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- #if ENABLE(CSS3_TEXT)</span>
<span class="line-removed">-     CSSPropertyWebkitTextAlignLast,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyWebkitTextCombine,</span>
<span class="line-removed">-     CSSPropertyWebkitTextDecorationsInEffect,</span>
<span class="line-removed">-     CSSPropertyWebkitTextEmphasisColor,</span>
<span class="line-removed">-     CSSPropertyWebkitTextEmphasisPosition,</span>
<span class="line-removed">-     CSSPropertyWebkitTextEmphasisStyle,</span>
<span class="line-removed">-     CSSPropertyWebkitTextFillColor,</span>
<span class="line-removed">- #if ENABLE(CSS3_TEXT)</span>
<span class="line-removed">-     CSSPropertyWebkitTextJustify,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyWebkitTextOrientation,</span>
<span class="line-removed">-     CSSPropertyWebkitTextSecurity,</span>
<span class="line-removed">- #if ENABLE(TEXT_AUTOSIZING)</span>
<span class="line-removed">-     CSSPropertyWebkitTextSizeAdjust,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyWebkitTextStrokeColor,</span>
<span class="line-removed">-     CSSPropertyWebkitTextStrokeWidth,</span>
<span class="line-removed">-     CSSPropertyWebkitTextZoom,</span>
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">-     CSSPropertyWebkitTouchCallout,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     CSSPropertyWebkitTransformStyle,</span>
<span class="line-removed">-     CSSPropertyWebkitUserDrag,</span>
<span class="line-removed">-     CSSPropertyWebkitUserModify,</span>
<span class="line-removed">-     CSSPropertyWebkitUserSelect,</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- const unsigned numComputedProperties = WTF_ARRAY_LENGTH(computedProperties);</span>
<span class="line-removed">- </span>
<span class="line-removed">- static CSSValueID valueForRepeatRule(int rule)</span>
  {
      switch (rule) {
<span class="line-modified">!         case RepeatImageRule:</span>
<span class="line-modified">!             return CSSValueRepeat;</span>
<span class="line-modified">!         case RoundImageRule:</span>
<span class="line-modified">!             return CSSValueRound;</span>
<span class="line-modified">!         case SpaceImageRule:</span>
<span class="line-modified">!             return CSSValueSpace;</span>
<span class="line-modified">!         default:</span>
<span class="line-modified">!             return CSSValueStretch;</span>
      }
  }
  
  static Ref&lt;CSSPrimitiveValue&gt; valueForImageSliceSide(const Length&amp; length)
  {
      // These values can be percentages, numbers, or while an animation of mixed types is in progress,
      // a calculation that combines a percentage and a number.
      if (length.isPercent())
<span class="line-modified">!         return CSSValuePool::singleton().createValue(length.percent(), CSSPrimitiveValue::CSS_PERCENTAGE);</span>
      if (length.isFixed())
<span class="line-modified">!         return CSSValuePool::singleton().createValue(length.value(), CSSPrimitiveValue::CSS_NUMBER);</span>
  
      // Calculating the actual length currently in use would require most of the code from RenderBoxModelObject::paintNinePieceImage.
      // And even if we could do that, it&#39;s not clear if that&#39;s exactly what we&#39;d want during animation.
      // FIXME: For now, just return 0.
      ASSERT(length.isCalculated());
<span class="line-modified">!     return CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::CSS_NUMBER);</span>
  }
  
  static Ref&lt;CSSBorderImageSliceValue&gt; valueForNinePieceImageSlice(const NinePieceImage&amp; image)
  {
      auto&amp; slices = image.imageSlices();
<span class="line-new-header">--- 86,38 ---</span>
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(CSSComputedStyleDeclaration);
  
<span class="line-modified">! static CSSValueID valueForRepeatRule(NinePieceImageRule rule)</span>
  {
      switch (rule) {
<span class="line-modified">!     case NinePieceImageRule::Repeat:</span>
<span class="line-modified">!         return CSSValueRepeat;</span>
<span class="line-modified">!     case NinePieceImageRule::Round:</span>
<span class="line-modified">!         return CSSValueRound;</span>
<span class="line-modified">!     case NinePieceImageRule::Space:</span>
<span class="line-modified">!         return CSSValueSpace;</span>
<span class="line-modified">!     default:</span>
<span class="line-modified">!         return CSSValueStretch;</span>
      }
  }
  
  static Ref&lt;CSSPrimitiveValue&gt; valueForImageSliceSide(const Length&amp; length)
  {
      // These values can be percentages, numbers, or while an animation of mixed types is in progress,
      // a calculation that combines a percentage and a number.
      if (length.isPercent())
<span class="line-modified">!         return CSSValuePool::singleton().createValue(length.percent(), CSSUnitType::CSS_PERCENTAGE);</span>
      if (length.isFixed())
<span class="line-modified">!         return CSSValuePool::singleton().createValue(length.value(), CSSUnitType::CSS_NUMBER);</span>
  
      // Calculating the actual length currently in use would require most of the code from RenderBoxModelObject::paintNinePieceImage.
      // And even if we could do that, it&#39;s not clear if that&#39;s exactly what we&#39;d want during animation.
      // FIXME: For now, just return 0.
      ASSERT(length.isCalculated());
<span class="line-modified">!     return CSSValuePool::singleton().createValue(0, CSSUnitType::CSS_NUMBER);</span>
  }
  
  static Ref&lt;CSSBorderImageSliceValue&gt; valueForNinePieceImageSlice(const NinePieceImage&amp; image)
  {
      auto&amp; slices = image.imageSlices();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 547,38 ***</span>
      RefPtr&lt;CSSPrimitiveValue&gt; left;
  
      auto&amp; cssValuePool = CSSValuePool::singleton();
  
      if (box.top().isRelative())
<span class="line-modified">!         top = cssValuePool.createValue(box.top().value(), CSSPrimitiveValue::CSS_NUMBER);</span>
      else
          top = cssValuePool.createValue(box.top());
  
      if (box.right() == box.top() &amp;&amp; box.bottom() == box.top() &amp;&amp; box.left() == box.top()) {
          right = top;
          bottom = top;
          left = top;
      } else {
          if (box.right().isRelative())
<span class="line-modified">!             right = cssValuePool.createValue(box.right().value(), CSSPrimitiveValue::CSS_NUMBER);</span>
          else
              right = cssValuePool.createValue(box.right());
  
          if (box.bottom() == box.top() &amp;&amp; box.right() == box.left()) {
              bottom = top;
              left = right;
          } else {
              if (box.bottom().isRelative())
<span class="line-modified">!                 bottom = cssValuePool.createValue(box.bottom().value(), CSSPrimitiveValue::CSS_NUMBER);</span>
              else
                  bottom = cssValuePool.createValue(box.bottom());
  
              if (box.left() == box.right())
                  left = right;
              else {
                  if (box.left().isRelative())
<span class="line-modified">!                     left = cssValuePool.createValue(box.left().value(), CSSPrimitiveValue::CSS_NUMBER);</span>
                  else
                      left = cssValuePool.createValue(box.left());
              }
          }
      }
<span class="line-new-header">--- 165,38 ---</span>
      RefPtr&lt;CSSPrimitiveValue&gt; left;
  
      auto&amp; cssValuePool = CSSValuePool::singleton();
  
      if (box.top().isRelative())
<span class="line-modified">!         top = cssValuePool.createValue(box.top().value(), CSSUnitType::CSS_NUMBER);</span>
      else
          top = cssValuePool.createValue(box.top());
  
      if (box.right() == box.top() &amp;&amp; box.bottom() == box.top() &amp;&amp; box.left() == box.top()) {
          right = top;
          bottom = top;
          left = top;
      } else {
          if (box.right().isRelative())
<span class="line-modified">!             right = cssValuePool.createValue(box.right().value(), CSSUnitType::CSS_NUMBER);</span>
          else
              right = cssValuePool.createValue(box.right());
  
          if (box.bottom() == box.top() &amp;&amp; box.right() == box.left()) {
              bottom = top;
              left = right;
          } else {
              if (box.bottom().isRelative())
<span class="line-modified">!                 bottom = cssValuePool.createValue(box.bottom().value(), CSSUnitType::CSS_NUMBER);</span>
              else
                  bottom = cssValuePool.createValue(box.bottom());
  
              if (box.left() == box.right())
                  left = right;
              else {
                  if (box.left().isRelative())
<span class="line-modified">!                     left = cssValuePool.createValue(box.left().value(), CSSUnitType::CSS_NUMBER);</span>
                  else
                      left = cssValuePool.createValue(box.left());
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 629,19 ***</span>
      return createBorderImageValue(WTFMove(imageValue), WTFMove(imageSlices), WTFMove(borderSlices), WTFMove(outset), WTFMove(repeat));
  }
  
  inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedPixelValue(double value, const RenderStyle&amp; style)
  {
<span class="line-modified">!     return CSSValuePool::singleton().createValue(adjustFloatForAbsoluteZoom(value, style), CSSPrimitiveValue::CSS_PX);</span>
  }
  
  inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedNumberValue(double value, const RenderStyle&amp; style)
  {
<span class="line-modified">!     return CSSValuePool::singleton().createValue(value / style.effectiveZoom(), CSSPrimitiveValue::CSS_NUMBER);</span>
  }
  
<span class="line-modified">! static Ref&lt;CSSValue&gt; zoomAdjustedPixelValueForLength(const Length&amp; length, const RenderStyle&amp; style)</span>
  {
      if (length.isFixed())
          return zoomAdjustedPixelValue(length.value(), style);
      return CSSValuePool::singleton().createValue(length, style);
  }
<span class="line-new-header">--- 247,19 ---</span>
      return createBorderImageValue(WTFMove(imageValue), WTFMove(imageSlices), WTFMove(borderSlices), WTFMove(outset), WTFMove(repeat));
  }
  
  inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedPixelValue(double value, const RenderStyle&amp; style)
  {
<span class="line-modified">!     return CSSValuePool::singleton().createValue(adjustFloatForAbsoluteZoom(value, style), CSSUnitType::CSS_PX);</span>
  }
  
  inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedNumberValue(double value, const RenderStyle&amp; style)
  {
<span class="line-modified">!     return CSSValuePool::singleton().createValue(value / style.effectiveZoom(), CSSUnitType::CSS_NUMBER);</span>
  }
  
<span class="line-modified">! static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedPixelValueForLength(const Length&amp; length, const RenderStyle&amp; style)</span>
  {
      if (length.isFixed())
          return zoomAdjustedPixelValue(length.value(), style);
      return CSSValuePool::singleton().createValue(length, style);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 651,26 ***</span>
      if (!reflection)
          return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
  
      RefPtr&lt;CSSPrimitiveValue&gt; offset;
      if (reflection-&gt;offset().isPercentOrCalculated())
<span class="line-modified">!         offset = CSSValuePool::singleton().createValue(reflection-&gt;offset().percent(), CSSPrimitiveValue::CSS_PERCENTAGE);</span>
      else
          offset = zoomAdjustedPixelValue(reflection-&gt;offset().value(), style);
  
      RefPtr&lt;CSSPrimitiveValue&gt; direction;
      switch (reflection-&gt;direction()) {
<span class="line-modified">!     case ReflectionBelow:</span>
          direction = CSSValuePool::singleton().createIdentifierValue(CSSValueBelow);
          break;
<span class="line-modified">!     case ReflectionAbove:</span>
          direction = CSSValuePool::singleton().createIdentifierValue(CSSValueAbove);
          break;
<span class="line-modified">!     case ReflectionLeft:</span>
          direction = CSSValuePool::singleton().createIdentifierValue(CSSValueLeft);
          break;
<span class="line-modified">!     case ReflectionRight:</span>
          direction = CSSValuePool::singleton().createIdentifierValue(CSSValueRight);
          break;
      }
  
      return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), valueForNinePieceImage(reflection-&gt;mask()));
<span class="line-new-header">--- 269,26 ---</span>
      if (!reflection)
          return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
  
      RefPtr&lt;CSSPrimitiveValue&gt; offset;
      if (reflection-&gt;offset().isPercentOrCalculated())
<span class="line-modified">!         offset = CSSValuePool::singleton().createValue(reflection-&gt;offset().percent(), CSSUnitType::CSS_PERCENTAGE);</span>
      else
          offset = zoomAdjustedPixelValue(reflection-&gt;offset().value(), style);
  
      RefPtr&lt;CSSPrimitiveValue&gt; direction;
      switch (reflection-&gt;direction()) {
<span class="line-modified">!     case ReflectionDirection::Below:</span>
          direction = CSSValuePool::singleton().createIdentifierValue(CSSValueBelow);
          break;
<span class="line-modified">!     case ReflectionDirection::Above:</span>
          direction = CSSValuePool::singleton().createIdentifierValue(CSSValueAbove);
          break;
<span class="line-modified">!     case ReflectionDirection::Left:</span>
          direction = CSSValuePool::singleton().createIdentifierValue(CSSValueLeft);
          break;
<span class="line-modified">!     case ReflectionDirection::Right:</span>
          direction = CSSValuePool::singleton().createIdentifierValue(CSSValueRight);
          break;
      }
  
      return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), valueForNinePieceImage(reflection-&gt;mask()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 832,21 ***</span>
  }
  
  static Ref&lt;CSSPrimitiveValue&gt; percentageOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
  {
      if (length.isPercent())
<span class="line-modified">!         return CSSValuePool::singleton().createValue(length.percent(), CSSPrimitiveValue::CSS_PERCENTAGE);</span>
  
<span class="line-modified">!     return zoomAdjustedPixelValue(valueForLength(length, 0), style);</span>
  }
  
  static Ref&lt;CSSPrimitiveValue&gt; autoOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
  {
      if (length.isAuto())
          return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
  
<span class="line-modified">!     return zoomAdjustedPixelValue(valueForLength(length, 0), style);</span>
  }
  
  static Ref&lt;CSSValueList&gt; borderRadiusCornerValues(const LengthSize&amp; radius, const RenderStyle&amp; style)
  {
      auto list = CSSValueList::createSpaceSeparated();
<span class="line-new-header">--- 450,21 ---</span>
  }
  
  static Ref&lt;CSSPrimitiveValue&gt; percentageOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
  {
      if (length.isPercent())
<span class="line-modified">!         return CSSValuePool::singleton().createValue(length.percent(), CSSUnitType::CSS_PERCENTAGE);</span>
  
<span class="line-modified">!     return zoomAdjustedPixelValueForLength(length, style);</span>
  }
  
  static Ref&lt;CSSPrimitiveValue&gt; autoOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
  {
      if (length.isAuto())
          return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
  
<span class="line-modified">!     return zoomAdjustedPixelValueForLength(length, style);</span>
  }
  
  static Ref&lt;CSSValueList&gt; borderRadiusCornerValues(const LengthSize&amp; radius, const RenderStyle&amp; style)
  {
      auto list = CSSValueList::createSpaceSeparated();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 918,38 ***</span>
      RefPtr&lt;CSSFunctionValue&gt; transformValue;
      auto&amp; cssValuePool = CSSValuePool::singleton();
      if (transform.isAffine()) {
          transformValue = CSSFunctionValue::create(CSSValueMatrix);
  
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.a(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.b(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.c(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.d(), CSSPrimitiveValue::CSS_NUMBER));</span>
          transformValue-&gt;append(zoomAdjustedNumberValue(transform.e(), style));
          transformValue-&gt;append(zoomAdjustedNumberValue(transform.f(), style));
      } else {
          transformValue = CSSFunctionValue::create(CSSValueMatrix3d);
  
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m11(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m12(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m13(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m14(), CSSPrimitiveValue::CSS_NUMBER));</span>
  
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m21(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m22(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m23(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m24(), CSSPrimitiveValue::CSS_NUMBER));</span>
  
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m31(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m32(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m33(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m34(), CSSPrimitiveValue::CSS_NUMBER));</span>
  
          transformValue-&gt;append(zoomAdjustedNumberValue(transform.m41(), style));
          transformValue-&gt;append(zoomAdjustedNumberValue(transform.m42(), style));
          transformValue-&gt;append(zoomAdjustedNumberValue(transform.m43(), style));
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m44(), CSSPrimitiveValue::CSS_NUMBER));</span>
      }
  
      return transformValue.releaseNonNull();
  }
  
<span class="line-new-header">--- 536,38 ---</span>
      RefPtr&lt;CSSFunctionValue&gt; transformValue;
      auto&amp; cssValuePool = CSSValuePool::singleton();
      if (transform.isAffine()) {
          transformValue = CSSFunctionValue::create(CSSValueMatrix);
  
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.a(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.b(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.c(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.d(), CSSUnitType::CSS_NUMBER));</span>
          transformValue-&gt;append(zoomAdjustedNumberValue(transform.e(), style));
          transformValue-&gt;append(zoomAdjustedNumberValue(transform.f(), style));
      } else {
          transformValue = CSSFunctionValue::create(CSSValueMatrix3d);
  
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m11(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m12(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m13(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m14(), CSSUnitType::CSS_NUMBER));</span>
  
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m21(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m22(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m23(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m24(), CSSUnitType::CSS_NUMBER));</span>
  
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m31(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m32(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m33(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m34(), CSSUnitType::CSS_NUMBER));</span>
  
          transformValue-&gt;append(zoomAdjustedNumberValue(transform.m41(), style));
          transformValue-&gt;append(zoomAdjustedNumberValue(transform.m42(), style));
          transformValue-&gt;append(zoomAdjustedNumberValue(transform.m43(), style));
<span class="line-modified">!         transformValue-&gt;append(cssValuePool.createValue(transform.m44(), CSSUnitType::CSS_NUMBER));</span>
      }
  
      return transformValue.releaseNonNull();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 973,11 ***</span>
      return list;
  }
  
  static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(double length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
  {
<span class="line-modified">!     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length, style) : CSSValuePool::singleton().createValue(length, CSSPrimitiveValue::CSS_PX);</span>
  }
  
  static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(const Length&amp; length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
  {
      return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length.value(), style) : CSSValuePool::singleton().createValue(length);
<span class="line-new-header">--- 591,11 ---</span>
      return list;
  }
  
  static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(double length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
  {
<span class="line-modified">!     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length, style) : CSSValuePool::singleton().createValue(length, CSSUnitType::CSS_PX);</span>
  }
  
  static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(const Length&amp; length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
  {
      return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length.value(), style) : CSSValuePool::singleton().createValue(length);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 993,11 ***</span>
      for (const ShadowData* currShadowData = shadow; currShadowData; currShadowData = currShadowData-&gt;next()) {
          auto x = adjustLengthForZoom(currShadowData-&gt;x(), style, adjust);
          auto y = adjustLengthForZoom(currShadowData-&gt;y(), style, adjust);
          auto blur = adjustLengthForZoom(currShadowData-&gt;radius(), style, adjust);
          auto spread = propertyID == CSSPropertyTextShadow ? RefPtr&lt;CSSPrimitiveValue&gt;() : adjustLengthForZoom(currShadowData-&gt;spread(), style, adjust);
<span class="line-modified">!         auto style = propertyID == CSSPropertyTextShadow || currShadowData-&gt;style() == Normal ? RefPtr&lt;CSSPrimitiveValue&gt;() : cssValuePool.createIdentifierValue(CSSValueInset);</span>
          auto color = cssValuePool.createColorValue(currShadowData-&gt;color());
          list-&gt;prepend(CSSShadowValue::create(WTFMove(x), WTFMove(y), WTFMove(blur), WTFMove(spread), WTFMove(style), WTFMove(color)));
      }
      return list;
  }
<span class="line-new-header">--- 611,11 ---</span>
      for (const ShadowData* currShadowData = shadow; currShadowData; currShadowData = currShadowData-&gt;next()) {
          auto x = adjustLengthForZoom(currShadowData-&gt;x(), style, adjust);
          auto y = adjustLengthForZoom(currShadowData-&gt;y(), style, adjust);
          auto blur = adjustLengthForZoom(currShadowData-&gt;radius(), style, adjust);
          auto spread = propertyID == CSSPropertyTextShadow ? RefPtr&lt;CSSPrimitiveValue&gt;() : adjustLengthForZoom(currShadowData-&gt;spread(), style, adjust);
<span class="line-modified">!         auto style = propertyID == CSSPropertyTextShadow || currShadowData-&gt;style() == ShadowStyle::Normal ? RefPtr&lt;CSSPrimitiveValue&gt;() : cssValuePool.createIdentifierValue(CSSValueInset);</span>
          auto color = cssValuePool.createColorValue(currShadowData-&gt;color());
          list-&gt;prepend(CSSShadowValue::create(WTFMove(x), WTFMove(y), WTFMove(blur), WTFMove(spread), WTFMove(style), WTFMove(color)));
      }
      return list;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1014,56 ***</span>
      for (Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator it = filterOperations.operations().begin(); it != end; ++it) {
          FilterOperation&amp; filterOperation = **it;
  
          if (filterOperation.type() == FilterOperation::REFERENCE) {
              ReferenceFilterOperation&amp; referenceOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(referenceOperation.url(), CSSPrimitiveValue::CSS_URI));</span>
          } else {
              RefPtr&lt;CSSFunctionValue&gt; filterValue;
              switch (filterOperation.type()) {
              case FilterOperation::GRAYSCALE: {
                  filterValue = CSSFunctionValue::create(CSSValueGrayscale);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::SEPIA: {
                  filterValue = CSSFunctionValue::create(CSSValueSepia);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::SATURATE: {
                  filterValue = CSSFunctionValue::create(CSSValueSaturate);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::HUE_ROTATE: {
                  filterValue = CSSFunctionValue::create(CSSValueHueRotate);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_DEG));</span>
                  break;
              }
              case FilterOperation::INVERT: {
                  filterValue = CSSFunctionValue::create(CSSValueInvert);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::APPLE_INVERT_LIGHTNESS: {
                  filterValue = CSSFunctionValue::create(CSSValueAppleInvertLightness);
                  break;
              }
              case FilterOperation::OPACITY: {
                  filterValue = CSSFunctionValue::create(CSSValueOpacity);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::BRIGHTNESS: {
                  filterValue = CSSFunctionValue::create(CSSValueBrightness);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::CONTRAST: {
                  filterValue = CSSFunctionValue::create(CSSValueContrast);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::BLUR: {
                  filterValue = CSSFunctionValue::create(CSSValueBlur);
                  filterValue-&gt;append(adjustLengthForZoom(downcast&lt;BlurFilterOperation&gt;(filterOperation).stdDeviation(), style, adjust));
<span class="line-new-header">--- 632,56 ---</span>
      for (Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator it = filterOperations.operations().begin(); it != end; ++it) {
          FilterOperation&amp; filterOperation = **it;
  
          if (filterOperation.type() == FilterOperation::REFERENCE) {
              ReferenceFilterOperation&amp; referenceOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(referenceOperation.url(), CSSUnitType::CSS_URI));</span>
          } else {
              RefPtr&lt;CSSFunctionValue&gt; filterValue;
              switch (filterOperation.type()) {
              case FilterOperation::GRAYSCALE: {
                  filterValue = CSSFunctionValue::create(CSSValueGrayscale);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::SEPIA: {
                  filterValue = CSSFunctionValue::create(CSSValueSepia);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::SATURATE: {
                  filterValue = CSSFunctionValue::create(CSSValueSaturate);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::HUE_ROTATE: {
                  filterValue = CSSFunctionValue::create(CSSValueHueRotate);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_DEG));</span>
                  break;
              }
              case FilterOperation::INVERT: {
                  filterValue = CSSFunctionValue::create(CSSValueInvert);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::APPLE_INVERT_LIGHTNESS: {
                  filterValue = CSSFunctionValue::create(CSSValueAppleInvertLightness);
                  break;
              }
              case FilterOperation::OPACITY: {
                  filterValue = CSSFunctionValue::create(CSSValueOpacity);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::BRIGHTNESS: {
                  filterValue = CSSFunctionValue::create(CSSValueBrightness);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::CONTRAST: {
                  filterValue = CSSFunctionValue::create(CSSValueContrast);
<span class="line-modified">!                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
                  break;
              }
              case FilterOperation::BLUR: {
                  filterValue = CSSFunctionValue::create(CSSValueBlur);
                  filterValue-&gt;append(adjustLengthForZoom(downcast&lt;BlurFilterOperation&gt;(filterOperation).stdDeviation(), style, adjust));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1071,11 ***</span>
              }
              case FilterOperation::DROP_SHADOW: {
                  DropShadowFilterOperation&amp; dropShadowOperation = downcast&lt;DropShadowFilterOperation&gt;(filterOperation);
                  filterValue = CSSFunctionValue::create(CSSValueDropShadow);
                  // We want our computed style to look like that of a text shadow (has neither spread nor inset style).
<span class="line-modified">!                 ShadowData shadowData = ShadowData(dropShadowOperation.location(), dropShadowOperation.stdDeviation(), 0, Normal, false, dropShadowOperation.color());</span>
                  filterValue-&gt;append(valueForShadow(&amp;shadowData, CSSPropertyTextShadow, style, adjust));
                  break;
              }
              default:
                  ASSERT_NOT_REACHED();
<span class="line-new-header">--- 689,11 ---</span>
              }
              case FilterOperation::DROP_SHADOW: {
                  DropShadowFilterOperation&amp; dropShadowOperation = downcast&lt;DropShadowFilterOperation&gt;(filterOperation);
                  filterValue = CSSFunctionValue::create(CSSValueDropShadow);
                  // We want our computed style to look like that of a text shadow (has neither spread nor inset style).
<span class="line-modified">!                 ShadowData shadowData = ShadowData(dropShadowOperation.location(), dropShadowOperation.stdDeviation(), 0, ShadowStyle::Normal, false, dropShadowOperation.color());</span>
                  filterValue-&gt;append(valueForShadow(&amp;shadowData, CSSPropertyTextShadow, style, adjust));
                  break;
              }
              default:
                  ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1089,11 ***</span>
  }
  
  static Ref&lt;CSSValue&gt; specifiedValueForGridTrackBreadth(const GridLength&amp; trackBreadth, const RenderStyle&amp; style)
  {
      if (!trackBreadth.isLength())
<span class="line-modified">!         return CSSValuePool::singleton().createValue(trackBreadth.flex(), CSSPrimitiveValue::CSS_FR);</span>
  
      const Length&amp; trackBreadthLength = trackBreadth.length();
      if (trackBreadthLength.isAuto())
          return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
      return zoomAdjustedPixelValueForLength(trackBreadthLength, style);
<span class="line-new-header">--- 707,11 ---</span>
  }
  
  static Ref&lt;CSSValue&gt; specifiedValueForGridTrackBreadth(const GridLength&amp; trackBreadth, const RenderStyle&amp; style)
  {
      if (!trackBreadth.isLength())
<span class="line-modified">!         return CSSValuePool::singleton().createValue(trackBreadth.flex(), CSSUnitType::CSS_FR);</span>
  
      const Length&amp; trackBreadthLength = trackBreadth.length();
      if (trackBreadthLength.isAuto())
          return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
      return zoomAdjustedPixelValueForLength(trackBreadthLength, style);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1110,11 ***</span>
          return fitContentTrackSize;
      }
      default:
          ASSERT(trackSize.type() == MinMaxTrackSizing);
          if (trackSize.minTrackBreadth().isAuto() &amp;&amp; trackSize.maxTrackBreadth().isFlex())
<span class="line-modified">!             return CSSValuePool::singleton().createValue(trackSize.maxTrackBreadth().flex(), CSSPrimitiveValue::CSS_FR);</span>
  
          auto minMaxTrackBreadths = CSSFunctionValue::create(CSSValueMinmax);
          minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style));
          minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.maxTrackBreadth(), style));
          return minMaxTrackBreadths;
<span class="line-new-header">--- 728,11 ---</span>
          return fitContentTrackSize;
      }
      default:
          ASSERT(trackSize.type() == MinMaxTrackSizing);
          if (trackSize.minTrackBreadth().isAuto() &amp;&amp; trackSize.maxTrackBreadth().isFlex())
<span class="line-modified">!             return CSSValuePool::singleton().createValue(trackSize.maxTrackBreadth().flex(), CSSUnitType::CSS_FR);</span>
  
          auto minMaxTrackBreadths = CSSFunctionValue::create(CSSValueMinmax);
          minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style));
          minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.maxTrackBreadth(), style));
          return minMaxTrackBreadths;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1122,29 ***</span>
  }
  
  class OrderedNamedLinesCollector {
      WTF_MAKE_NONCOPYABLE(OrderedNamedLinesCollector);
  public:
<span class="line-modified">!     OrderedNamedLinesCollector(const RenderStyle&amp; style, bool isRowAxis, unsigned autoRepeatTracksCount)</span>
          : m_orderedNamedGridLines(isRowAxis ? style.orderedNamedGridColumnLines() : style.orderedNamedGridRowLines())
          , m_orderedNamedAutoRepeatGridLines(isRowAxis ? style.autoRepeatOrderedNamedGridColumnLines() : style.autoRepeatOrderedNamedGridRowLines())
<span class="line-removed">-         , m_insertionPoint(isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint())</span>
<span class="line-removed">-         , m_autoRepeatTotalTracks(autoRepeatTracksCount)</span>
<span class="line-removed">-         , m_autoRepeatTrackListLength(isRowAxis ? style.gridAutoRepeatColumns().size() : style.gridAutoRepeatRows().size())</span>
      {
      }
  
      bool isEmpty() const { return m_orderedNamedGridLines.isEmpty() &amp;&amp; m_orderedNamedAutoRepeatGridLines.isEmpty(); }
<span class="line-modified">!     void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const;</span>
  
<span class="line-modified">! private:</span>
  
      enum NamedLinesType { NamedLines, AutoRepeatNamedLines };
      void appendLines(CSSGridLineNamesValue&amp;, unsigned index, NamedLinesType) const;
  
      const OrderedNamedGridLinesMap&amp; m_orderedNamedGridLines;
      const OrderedNamedGridLinesMap&amp; m_orderedNamedAutoRepeatGridLines;
      unsigned m_insertionPoint;
      unsigned m_autoRepeatTotalTracks;
      unsigned m_autoRepeatTrackListLength;
  };
  
<span class="line-new-header">--- 740,52 ---</span>
  }
  
  class OrderedNamedLinesCollector {
      WTF_MAKE_NONCOPYABLE(OrderedNamedLinesCollector);
  public:
<span class="line-modified">!     OrderedNamedLinesCollector(const RenderStyle&amp; style, bool isRowAxis)</span>
          : m_orderedNamedGridLines(isRowAxis ? style.orderedNamedGridColumnLines() : style.orderedNamedGridRowLines())
          , m_orderedNamedAutoRepeatGridLines(isRowAxis ? style.autoRepeatOrderedNamedGridColumnLines() : style.autoRepeatOrderedNamedGridRowLines())
      {
      }
<span class="line-added">+     virtual ~OrderedNamedLinesCollector() = default;</span>
  
      bool isEmpty() const { return m_orderedNamedGridLines.isEmpty() &amp;&amp; m_orderedNamedAutoRepeatGridLines.isEmpty(); }
<span class="line-modified">!     virtual void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const;</span>
  
<span class="line-modified">! protected:</span>
  
      enum NamedLinesType { NamedLines, AutoRepeatNamedLines };
      void appendLines(CSSGridLineNamesValue&amp;, unsigned index, NamedLinesType) const;
  
      const OrderedNamedGridLinesMap&amp; m_orderedNamedGridLines;
      const OrderedNamedGridLinesMap&amp; m_orderedNamedAutoRepeatGridLines;
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class OrderedNamedLinesCollectorInsideRepeat : public OrderedNamedLinesCollector {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     OrderedNamedLinesCollectorInsideRepeat(const RenderStyle&amp; style, bool isRowAxis)</span>
<span class="line-added">+         : OrderedNamedLinesCollector(style, isRowAxis)</span>
<span class="line-added">+     {</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const override;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class OrderedNamedLinesCollectorInGridLayout : public OrderedNamedLinesCollector {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     OrderedNamedLinesCollectorInGridLayout(const RenderStyle&amp; style, bool isRowAxis, unsigned autoRepeatTracksCount, unsigned autoRepeatTrackListLength)</span>
<span class="line-added">+         : OrderedNamedLinesCollector(style, isRowAxis)</span>
<span class="line-added">+         , m_insertionPoint(isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint())</span>
<span class="line-added">+         , m_autoRepeatTotalTracks(autoRepeatTracksCount)</span>
<span class="line-added">+         , m_autoRepeatTrackListLength(autoRepeatTrackListLength)</span>
<span class="line-added">+     {</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const override;</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
      unsigned m_insertionPoint;
      unsigned m_autoRepeatTotalTracks;
      unsigned m_autoRepeatTrackListLength;
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1155,17 ***</span>
      if (iter == endIter)
          return;
  
      auto&amp; cssValuePool = CSSValuePool::singleton();
      for (const auto&amp; lineName : iter-&gt;value)
<span class="line-modified">!         lineNamesValue.append(cssValuePool.createValue(lineName, CSSPrimitiveValue::CSS_STRING));</span>
  }
  
  void OrderedNamedLinesCollector::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const
  {
      ASSERT(!isEmpty());
<span class="line-modified">!     if (m_orderedNamedAutoRepeatGridLines.isEmpty() || i &lt; m_insertionPoint) {</span>
          appendLines(lineNamesValue, i, NamedLines);
          return;
      }
  
      ASSERT(m_autoRepeatTotalTracks);
<span class="line-new-header">--- 796,29 ---</span>
      if (iter == endIter)
          return;
  
      auto&amp; cssValuePool = CSSValuePool::singleton();
      for (const auto&amp; lineName : iter-&gt;value)
<span class="line-modified">!         lineNamesValue.append(cssValuePool.createValue(lineName, CSSUnitType::CSS_STRING));</span>
  }
  
  void OrderedNamedLinesCollector::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const
  {
      ASSERT(!isEmpty());
<span class="line-modified">!     appendLines(lineNamesValue, i, NamedLines);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void OrderedNamedLinesCollectorInsideRepeat::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(!isEmpty());</span>
<span class="line-added">+     appendLines(lineNamesValue, i, AutoRepeatNamedLines);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void OrderedNamedLinesCollectorInGridLayout::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(!isEmpty());</span>
<span class="line-added">+     if (!m_autoRepeatTrackListLength || i &lt; m_insertionPoint) {</span>
          appendLines(lineNamesValue, i, NamedLines);
          return;
      }
  
      ASSERT(m_autoRepeatTotalTracks);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1212,75 ***</span>
      for (auto&amp; trackSize : autoTrackSizes)
          list-&gt;append(specifiedValueForGridTrackSize(trackSize, style));
      return list;
  }
  
  static Ref&lt;CSSValue&gt; valueForGridTrackList(GridTrackSizingDirection direction, RenderObject* renderer, const RenderStyle&amp; style)
  {
      bool isRowAxis = direction == ForColumns;
      bool isRenderGrid = is&lt;RenderGrid&gt;(renderer);
      auto&amp; trackSizes = isRowAxis ? style.gridColumns() : style.gridRows();
      auto&amp; autoRepeatTrackSizes = isRowAxis ? style.gridAutoRepeatColumns() : style.gridAutoRepeatRows();
  
      // Handle the &#39;none&#39; case.
<span class="line-modified">!     bool trackListIsEmpty = trackSizes.isEmpty() &amp;&amp; autoRepeatTrackSizes.isEmpty();</span>
<span class="line-removed">-     if (isRenderGrid &amp;&amp; trackListIsEmpty) {</span>
<span class="line-removed">-         // For grids we should consider every listed track, whether implicitly or explicitly</span>
<span class="line-removed">-         // created. Empty grids have a sole grid line per axis.</span>
<span class="line-removed">-         auto&amp; grid = downcast&lt;RenderGrid&gt;(*renderer);</span>
<span class="line-removed">-         auto&amp; positions = isRowAxis ? grid.columnPositions() : grid.rowPositions();</span>
<span class="line-removed">-         trackListIsEmpty = positions.size() == 1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (trackListIsEmpty)</span>
          return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
  
<span class="line-removed">-     unsigned autoRepeatTotalTracks = isRenderGrid ? downcast&lt;RenderGrid&gt;(renderer)-&gt;autoRepeatCountForDirection(direction) : 0;</span>
<span class="line-removed">-     OrderedNamedLinesCollector collector(style, isRowAxis, autoRepeatTotalTracks);</span>
      auto list = CSSValueList::createSpaceSeparated();
<span class="line-removed">-     unsigned insertionIndex;</span>
<span class="line-removed">-     if (isRenderGrid) {</span>
<span class="line-removed">-         auto computedTrackSizes = downcast&lt;RenderGrid&gt;(*renderer).trackSizesForComputedStyle(direction);</span>
<span class="line-removed">-         unsigned numTracks = computedTrackSizes.size();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         for (unsigned i = 0; i &lt; numTracks; ++i) {</span>
<span class="line-removed">-             addValuesForNamedGridLinesAtIndex(collector, i, list.get());</span>
<span class="line-removed">-             list-&gt;append(zoomAdjustedPixelValue(computedTrackSizes[i], style));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         addValuesForNamedGridLinesAtIndex(collector, numTracks + 1, list.get());</span>
<span class="line-removed">-         insertionIndex = numTracks;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         for (unsigned i = 0; i &lt; trackSizes.size(); ++i) {</span>
<span class="line-removed">-             addValuesForNamedGridLinesAtIndex(collector, i, list.get());</span>
<span class="line-removed">-             list-&gt;append(specifiedValueForGridTrackSize(trackSizes[i], style));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         insertionIndex = trackSizes.size();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // Those are the trailing &lt;ident&gt;* allowed in the syntax.</span>
<span class="line-modified">!     addValuesForNamedGridLinesAtIndex(collector, insertionIndex, list.get());</span>
      return list;
  }
  
  static Ref&lt;CSSValue&gt; valueForGridPosition(const GridPosition&amp; position)
  {
      auto&amp; cssValuePool = CSSValuePool::singleton();
      if (position.isAuto())
          return cssValuePool.createIdentifierValue(CSSValueAuto);
  
      if (position.isNamedGridArea())
<span class="line-modified">!         return cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING);</span>
  
      auto list = CSSValueList::createSpaceSeparated();
      if (position.isSpan()) {
          list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpan));
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(position.spanPosition(), CSSPrimitiveValue::CSS_NUMBER));</span>
      } else
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(position.integerPosition(), CSSPrimitiveValue::CSS_NUMBER));</span>
  
      if (!position.namedGridLine().isNull())
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING));</span>
      return list;
  }
  
  static Ref&lt;CSSValue&gt; createTransitionPropertyValue(const Animation&amp; animation)
  {
<span class="line-new-header">--- 865,97 ---</span>
      for (auto&amp; trackSize : autoTrackSizes)
          list-&gt;append(specifiedValueForGridTrackSize(trackSize, style));
      return list;
  }
  
<span class="line-added">+ template &lt;typename T, typename F&gt;</span>
<span class="line-added">+ void populateGridTrackList(CSSValueList&amp; list, OrderedNamedLinesCollector&amp; collector, const Vector&lt;T&gt;&amp; tracks, F getTrackSize, unsigned start, unsigned end, unsigned offset = 0)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(end &lt;= tracks.size());</span>
<span class="line-added">+     for (unsigned i = start; i &lt; end; ++i) {</span>
<span class="line-added">+         addValuesForNamedGridLinesAtIndex(collector, i + offset, list);</span>
<span class="line-added">+         list.append(getTrackSize(tracks[i]));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     addValuesForNamedGridLinesAtIndex(collector, end + offset, list);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T, typename F&gt;</span>
<span class="line-added">+ void populateGridTrackList(CSSValueList&amp; list, OrderedNamedLinesCollector&amp; collector, const Vector&lt;T&gt;&amp; tracks, F getTrackSize)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     populateGridTrackList&lt;T&gt;(list, collector, tracks, getTrackSize, 0, tracks.size());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static Ref&lt;CSSValue&gt; valueForGridTrackList(GridTrackSizingDirection direction, RenderObject* renderer, const RenderStyle&amp; style)
  {
      bool isRowAxis = direction == ForColumns;
      bool isRenderGrid = is&lt;RenderGrid&gt;(renderer);
      auto&amp; trackSizes = isRowAxis ? style.gridColumns() : style.gridRows();
      auto&amp; autoRepeatTrackSizes = isRowAxis ? style.gridAutoRepeatColumns() : style.gridAutoRepeatRows();
  
      // Handle the &#39;none&#39; case.
<span class="line-modified">!     if (trackSizes.isEmpty() &amp;&amp; autoRepeatTrackSizes.isEmpty())</span>
          return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
  
      auto list = CSSValueList::createSpaceSeparated();
  
<span class="line-modified">!     // If the element is a grid container, the resolved value is the used value,</span>
<span class="line-modified">!     // specifying track sizes in pixels and expanding the repeat() notation.</span>
<span class="line-added">+     if (isRenderGrid) {</span>
<span class="line-added">+         auto* grid = downcast&lt;RenderGrid&gt;(renderer);</span>
<span class="line-added">+         OrderedNamedLinesCollectorInGridLayout collector(style, isRowAxis, grid-&gt;autoRepeatCountForDirection(direction), autoRepeatTrackSizes.size());</span>
<span class="line-added">+         populateGridTrackList(list.get(), collector, grid-&gt;trackSizesForComputedStyle(direction), [&amp;](const LayoutUnit&amp; v) {</span>
<span class="line-added">+             return zoomAdjustedPixelValue(v, style);</span>
<span class="line-added">+         });</span>
<span class="line-added">+         return list;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Otherwise, the resolved value is the computed value, preserving repeat().</span>
<span class="line-added">+     OrderedNamedLinesCollector collector(style, isRowAxis);</span>
<span class="line-added">+     auto getTrackSize = [&amp;](const GridTrackSize&amp; v) {</span>
<span class="line-added">+         return specifiedValueForGridTrackSize(v, style);</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (autoRepeatTrackSizes.isEmpty()) {</span>
<span class="line-added">+         // If there&#39;s no auto repeat(), just add all the line names and track sizes.</span>
<span class="line-added">+         populateGridTrackList(list.get(), collector, trackSizes, getTrackSize);</span>
<span class="line-added">+         return list;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Add the line names and track sizes that precede the auto repeat().</span>
<span class="line-added">+     unsigned autoRepeatInsertionPoint = isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint();</span>
<span class="line-added">+     populateGridTrackList(list.get(), collector, trackSizes, getTrackSize, 0, autoRepeatInsertionPoint);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Add a CSSGridAutoRepeatValue with the contents of the auto repeat().</span>
<span class="line-added">+     AutoRepeatType autoRepeatType = isRowAxis ? style.gridAutoRepeatColumnsType() : style.gridAutoRepeatRowsType();</span>
<span class="line-added">+     auto repeatedValues = CSSGridAutoRepeatValue::create(autoRepeatType == AutoRepeatType::Fill ? CSSValueAutoFill : CSSValueAutoFit);</span>
<span class="line-added">+     OrderedNamedLinesCollectorInsideRepeat repeatCollector(style, isRowAxis);</span>
<span class="line-added">+     populateGridTrackList(repeatedValues.get(), repeatCollector, autoRepeatTrackSizes, getTrackSize);</span>
<span class="line-added">+     list-&gt;append(repeatedValues.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Add the line names and track sizes that follow the auto repeat().</span>
<span class="line-added">+     populateGridTrackList(list.get(), collector, trackSizes, getTrackSize, autoRepeatInsertionPoint, trackSizes.size(), 1);</span>
      return list;
  }
  
  static Ref&lt;CSSValue&gt; valueForGridPosition(const GridPosition&amp; position)
  {
      auto&amp; cssValuePool = CSSValuePool::singleton();
      if (position.isAuto())
          return cssValuePool.createIdentifierValue(CSSValueAuto);
  
      if (position.isNamedGridArea())
<span class="line-modified">!         return cssValuePool.createValue(position.namedGridLine(), CSSUnitType::CSS_STRING);</span>
  
      auto list = CSSValueList::createSpaceSeparated();
      if (position.isSpan()) {
          list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpan));
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(position.spanPosition(), CSSUnitType::CSS_NUMBER));</span>
      } else
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(position.integerPosition(), CSSUnitType::CSS_NUMBER));</span>
  
      if (!position.namedGridLine().isNull())
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(position.namedGridLine(), CSSUnitType::CSS_STRING));</span>
      return list;
  }
  
  static Ref&lt;CSSValue&gt; createTransitionPropertyValue(const Animation&amp; animation)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1288,13 ***</span>
      case Animation::AnimateNone:
          return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
      case Animation::AnimateAll:
          return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
      case Animation::AnimateSingleProperty:
<span class="line-modified">!         return CSSValuePool::singleton().createValue(getPropertyNameString(animation.property()), CSSPrimitiveValue::CSS_STRING);</span>
      case Animation::AnimateUnknownProperty:
<span class="line-modified">!         return CSSValuePool::singleton().createValue(animation.unknownProperty(), CSSPrimitiveValue::CSS_STRING);</span>
      }
      ASSERT_NOT_REACHED();
      return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
  }
  
<span class="line-new-header">--- 963,13 ---</span>
      case Animation::AnimateNone:
          return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
      case Animation::AnimateAll:
          return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
      case Animation::AnimateSingleProperty:
<span class="line-modified">!         return CSSValuePool::singleton().createValue(getPropertyNameString(animation.property()), CSSUnitType::CSS_STRING);</span>
      case Animation::AnimateUnknownProperty:
<span class="line-modified">!         return CSSValuePool::singleton().createValue(animation.unknownProperty(), CSSUnitType::CSS_STRING);</span>
      }
      ASSERT_NOT_REACHED();
      return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1551,28 ***</span>
  {
      auto&amp; cssValuePool = CSSValuePool::singleton();
      auto list = CSSValueList::createCommaSeparated();
      if (animationList) {
          for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).delay(), CSSPrimitiveValue::CSS_S));</span>
      } else {
          // Note that initialAnimationDelay() is used for both transitions and animations
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));</span>
      }
      return list;
  }
  
  static Ref&lt;CSSValueList&gt; durationValue(const AnimationList* animationList)
  {
      auto&amp; cssValuePool = CSSValuePool::singleton();
      auto list = CSSValueList::createCommaSeparated();
      if (animationList) {
          for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).duration(), CSSPrimitiveValue::CSS_S));</span>
      } else {
          // Note that initialAnimationDuration() is used for both transitions and animations
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSPrimitiveValue::CSS_S));</span>
      }
      return list;
  }
  
  static Ref&lt;CSSValue&gt; createTimingFunctionValue(const TimingFunction&amp; timingFunction)
<span class="line-new-header">--- 1226,28 ---</span>
  {
      auto&amp; cssValuePool = CSSValuePool::singleton();
      auto list = CSSValueList::createCommaSeparated();
      if (animationList) {
          for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).delay(), CSSUnitType::CSS_S));</span>
      } else {
          // Note that initialAnimationDelay() is used for both transitions and animations
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSUnitType::CSS_S));</span>
      }
      return list;
  }
  
  static Ref&lt;CSSValueList&gt; durationValue(const AnimationList* animationList)
  {
      auto&amp; cssValuePool = CSSValuePool::singleton();
      auto list = CSSValueList::createCommaSeparated();
      if (animationList) {
          for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).duration(), CSSUnitType::CSS_S));</span>
      } else {
          // Note that initialAnimationDuration() is used for both transitions and animations
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSUnitType::CSS_S));</span>
      }
      return list;
  }
  
  static Ref&lt;CSSValue&gt; createTimingFunctionValue(const TimingFunction&amp; timingFunction)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1625,11 ***</span>
          // Note that initialAnimationTimingFunction() is used for both transitions and animations
          list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
      return list;
  }
  
<span class="line-modified">! static Ref&lt;CSSValue&gt; createLineBoxContainValue(unsigned lineBoxContain)</span>
  {
      if (!lineBoxContain)
          return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
      return CSSLineBoxContainValue::create(lineBoxContain);
  }
<span class="line-new-header">--- 1300,11 ---</span>
          // Note that initialAnimationTimingFunction() is used for both transitions and animations
          list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
      return list;
  }
  
<span class="line-modified">! static Ref&lt;CSSValue&gt; createLineBoxContainValue(OptionSet&lt;LineBoxContain&gt; lineBoxContain)</span>
  {
      if (!lineBoxContain)
          return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
      return CSSLineBoxContainValue::create(lineBoxContain);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1689,14 ***</span>
  }
  
  String CSSComputedStyleDeclaration::cssText() const
  {
      StringBuilder result;
<span class="line-modified">!     for (unsigned i = 0; i &lt; numComputedProperties; i++) {</span>
          if (i)
              result.append(&#39; &#39;);
<span class="line-modified">!         result.append(getPropertyName(computedProperties[i]), &quot;: &quot;, getPropertyValue(computedProperties[i]), &#39;;&#39;);</span>
      }
      return result.toString();
  }
  
  ExceptionOr&lt;void&gt; CSSComputedStyleDeclaration::setCssText(const String&amp;)
<span class="line-new-header">--- 1364,14 ---</span>
  }
  
  String CSSComputedStyleDeclaration::cssText() const
  {
      StringBuilder result;
<span class="line-modified">!     for (unsigned i = 0; i &lt; numComputedPropertyIDs; i++) {</span>
          if (i)
              result.append(&#39; &#39;);
<span class="line-modified">!         result.append(getPropertyName(computedPropertyIDs[i]), &quot;: &quot;, getPropertyValue(computedPropertyIDs[i]), &#39;;&#39;);</span>
      }
      return result.toString();
  }
  
  ExceptionOr&lt;void&gt; CSSComputedStyleDeclaration::setCssText(const String&amp;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1845,21 ***</span>
  static Ref&lt;CSSValue&gt; textUnderlineOffsetToCSSValue(const TextUnderlineOffset&amp; textUnderlineOffset)
  {
      if (textUnderlineOffset.isAuto())
          return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
      ASSERT(textUnderlineOffset.isLength());
<span class="line-modified">!     return CSSValuePool::singleton().createValue(textUnderlineOffset.lengthValue(), CSSPrimitiveValue::CSS_PX);</span>
  }
  
  static Ref&lt;CSSValue&gt; textDecorationThicknessToCSSValue(const TextDecorationThickness&amp; textDecorationThickness)
  {
      if (textDecorationThickness.isAuto())
          return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
      if (textDecorationThickness.isFromFont())
          return CSSValuePool::singleton().createIdentifierValue(CSSValueFromFont);
      ASSERT(textDecorationThickness.isLength());
<span class="line-modified">!     return CSSValuePool::singleton().createValue(textDecorationThickness.lengthValue(), CSSPrimitiveValue::CSS_PX);</span>
  }
  
  static Ref&lt;CSSValue&gt; renderEmphasisPositionFlagsToCSSValue(OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition)
  {
      ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Over) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Under)));
<span class="line-new-header">--- 1520,21 ---</span>
  static Ref&lt;CSSValue&gt; textUnderlineOffsetToCSSValue(const TextUnderlineOffset&amp; textUnderlineOffset)
  {
      if (textUnderlineOffset.isAuto())
          return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
      ASSERT(textUnderlineOffset.isLength());
<span class="line-modified">!     return CSSValuePool::singleton().createValue(textUnderlineOffset.lengthValue(), CSSUnitType::CSS_PX);</span>
  }
  
  static Ref&lt;CSSValue&gt; textDecorationThicknessToCSSValue(const TextDecorationThickness&amp; textDecorationThickness)
  {
      if (textDecorationThickness.isAuto())
          return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
      if (textDecorationThickness.isFromFont())
          return CSSValuePool::singleton().createIdentifierValue(CSSValueFromFont);
      ASSERT(textDecorationThickness.isLength());
<span class="line-modified">!     return CSSValuePool::singleton().createValue(textDecorationThickness.lengthValue(), CSSUnitType::CSS_PX);</span>
  }
  
  static Ref&lt;CSSValue&gt; renderEmphasisPositionFlagsToCSSValue(OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition)
  {
      ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Over) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Under)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1959,24 ***</span>
      return list;
  }
  
  static Ref&lt;CSSValue&gt; altTextToCSSValue(const RenderStyle&amp; style)
  {
<span class="line-modified">!     return CSSValuePool::singleton().createValue(style.contentAltText(), CSSPrimitiveValue::CSS_STRING);</span>
  }
  
  static Ref&lt;CSSValueList&gt; contentToCSSValue(const RenderStyle&amp; style)
  {
      auto&amp; cssValuePool = CSSValuePool::singleton();
      auto list = CSSValueList::createSpaceSeparated();
      for (auto* contentData = style.contentData(); contentData; contentData = contentData-&gt;next()) {
          if (is&lt;CounterContentData&gt;(*contentData))
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(downcast&lt;CounterContentData&gt;(*contentData).counter().identifier(), CSSPrimitiveValue::CSS_COUNTER_NAME));</span>
          else if (is&lt;ImageContentData&gt;(*contentData))
              list-&gt;append(downcast&lt;ImageContentData&gt;(*contentData).image().cssValue());
          else if (is&lt;TextContentData&gt;(*contentData))
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(downcast&lt;TextContentData&gt;(*contentData).text(), CSSPrimitiveValue::CSS_STRING));</span>
      }
      return list;
  }
  
  static Ref&lt;CSSValue&gt; counterToCSSValue(const RenderStyle&amp; style, CSSPropertyID propertyID)
<span class="line-new-header">--- 1634,24 ---</span>
      return list;
  }
  
  static Ref&lt;CSSValue&gt; altTextToCSSValue(const RenderStyle&amp; style)
  {
<span class="line-modified">!     return CSSValuePool::singleton().createValue(style.contentAltText(), CSSUnitType::CSS_STRING);</span>
  }
  
  static Ref&lt;CSSValueList&gt; contentToCSSValue(const RenderStyle&amp; style)
  {
      auto&amp; cssValuePool = CSSValuePool::singleton();
      auto list = CSSValueList::createSpaceSeparated();
      for (auto* contentData = style.contentData(); contentData; contentData = contentData-&gt;next()) {
          if (is&lt;CounterContentData&gt;(*contentData))
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(downcast&lt;CounterContentData&gt;(*contentData).counter().identifier(), CSSUnitType::CSS_COUNTER_NAME));</span>
          else if (is&lt;ImageContentData&gt;(*contentData))
              list-&gt;append(downcast&lt;ImageContentData&gt;(*contentData).image().cssValue());
          else if (is&lt;TextContentData&gt;(*contentData))
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(downcast&lt;TextContentData&gt;(*contentData).text(), CSSUnitType::CSS_STRING));</span>
      }
      return list;
  }
  
  static Ref&lt;CSSValue&gt; counterToCSSValue(const RenderStyle&amp; style, CSSPropertyID propertyID)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1986,26 ***</span>
          return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
  
      auto&amp; cssValuePool = CSSValuePool::singleton();
      auto list = CSSValueList::createSpaceSeparated();
      for (auto&amp; keyValue : *map) {
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(keyValue.key, CSSPrimitiveValue::CSS_STRING));</span>
          double number = (propertyID == CSSPropertyCounterIncrement ? keyValue.value.incrementValue : keyValue.value.resetValue).valueOr(0);
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(number, CSSPrimitiveValue::CSS_NUMBER));</span>
      }
      return list;
  }
  
<span class="line-removed">- static void logUnimplementedPropertyID(CSSPropertyID propertyID)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     static NeverDestroyed&lt;HashSet&lt;CSSPropertyID&gt;&gt; propertyIDSet;</span>
<span class="line-removed">-     if (!propertyIDSet.get().add(propertyID).isNewEntry)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     LOG_ERROR(&quot;WebKit does not yet implement getComputedStyle for &#39;%s&#39;.&quot;, getPropertyName(propertyID));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static Ref&lt;CSSValueList&gt; fontFamilyListFromStyle(const RenderStyle&amp; style)
  {
      auto list = CSSValueList::createCommaSeparated();
      for (unsigned i = 0; i &lt; style.fontCascade().familyCount(); ++i)
          list-&gt;append(valueForFamily(style.fontCascade().familyAt(i)));
<span class="line-new-header">--- 1661,17 ---</span>
          return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
  
      auto&amp; cssValuePool = CSSValuePool::singleton();
      auto list = CSSValueList::createSpaceSeparated();
      for (auto&amp; keyValue : *map) {
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(keyValue.key, CSSUnitType::CSS_STRING));</span>
          double number = (propertyID == CSSPropertyCounterIncrement ? keyValue.value.incrementValue : keyValue.value.resetValue).valueOr(0);
<span class="line-modified">!         list-&gt;append(cssValuePool.createValue(number, CSSUnitType::CSS_NUMBER));</span>
      }
      return list;
  }
  
  static Ref&lt;CSSValueList&gt; fontFamilyListFromStyle(const RenderStyle&amp; style)
  {
      auto list = CSSValueList::createCommaSeparated();
      for (unsigned i = 0; i &lt; style.fontCascade().familyCount(); ++i)
          list-&gt;append(valueForFamily(style.fontCascade().familyAt(i)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2020,12 ***</span>
  }
  
  static Ref&lt;CSSPrimitiveValue&gt; lineHeightFromStyle(const RenderStyle&amp; style)
  {
      Length length = style.lineHeight();
<span class="line-modified">!     if (length.isNegative()) // If true, line-height not set; use the font&#39;s line spacing.</span>
<span class="line-modified">!         return zoomAdjustedPixelValue(style.fontMetrics().floatLineSpacing(), style);</span>
      if (length.isPercent()) {
          // This is imperfect, because it doesn&#39;t include the zoom factor and the real computation
          // for how high to be in pixels does include things like minimum font size and the zoom factor.
          // On the other hand, since font-size doesn&#39;t include the zoom factor, we really can&#39;t do
          // that here either.
<span class="line-new-header">--- 1686,12 ---</span>
  }
  
  static Ref&lt;CSSPrimitiveValue&gt; lineHeightFromStyle(const RenderStyle&amp; style)
  {
      Length length = style.lineHeight();
<span class="line-modified">!     if (length.isNegative())</span>
<span class="line-modified">!         return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);</span>
      if (length.isPercent()) {
          // This is imperfect, because it doesn&#39;t include the zoom factor and the real computation
          // for how high to be in pixels does include things like minimum font size and the zoom factor.
          // On the other hand, since font-size doesn&#39;t include the zoom factor, we really can&#39;t do
          // that here either.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2039,11 ***</span>
      return zoomAdjustedPixelValue(style.fontDescription().computedSize(), style);
  }
  
  Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordWeightFromStyleValue(FontSelectionValue weight)
  {
<span class="line-modified">!     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSPrimitiveValue::CSS_NUMBER);</span>
  }
  
  Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontWeightFromStyleValue(FontSelectionValue weight)
  {
      if (auto value = fontWeightKeyword(weight))
<span class="line-new-header">--- 1705,11 ---</span>
      return zoomAdjustedPixelValue(style.fontDescription().computedSize(), style);
  }
  
  Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordWeightFromStyleValue(FontSelectionValue weight)
  {
<span class="line-modified">!     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSUnitType::CSS_NUMBER);</span>
  }
  
  Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontWeightFromStyleValue(FontSelectionValue weight)
  {
      if (auto value = fontWeightKeyword(weight))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2056,11 ***</span>
      return ComputedStyleExtractor::fontWeightFromStyleValue(style.fontDescription().weight());
  }
  
  Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordStretchFromStyleValue(FontSelectionValue stretch)
  {
<span class="line-modified">!     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(stretch), CSSPrimitiveValue::CSS_PERCENTAGE);</span>
  }
  
  Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontStretchFromStyleValue(FontSelectionValue stretch)
  {
      if (auto keyword = fontStretchKeyword(stretch))
<span class="line-new-header">--- 1722,11 ---</span>
      return ComputedStyleExtractor::fontWeightFromStyleValue(style.fontDescription().weight());
  }
  
  Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordStretchFromStyleValue(FontSelectionValue stretch)
  {
<span class="line-modified">!     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(stretch), CSSUnitType::CSS_PERCENTAGE);</span>
  }
  
  Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontStretchFromStyleValue(FontSelectionValue stretch)
  {
      if (auto keyword = fontStretchKeyword(stretch))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2073,11 ***</span>
      return ComputedStyleExtractor::fontStretchFromStyleValue(style.fontDescription().stretch());
  }
  
  Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontNonKeywordStyleFromStyleValue(FontSelectionValue italic)
  {
<span class="line-modified">!     return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(italic), CSSPrimitiveValue::CSS_DEG));</span>
  }
  
  Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontStyleFromStyleValue(Optional&lt;FontSelectionValue&gt; italic, FontStyleAxis fontStyleAxis)
  {
      if (auto keyword = fontStyleKeyword(italic, fontStyleAxis))
<span class="line-new-header">--- 1739,11 ---</span>
      return ComputedStyleExtractor::fontStretchFromStyleValue(style.fontDescription().stretch());
  }
  
  Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontNonKeywordStyleFromStyleValue(FontSelectionValue italic)
  {
<span class="line-modified">!     return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(italic), CSSUnitType::CSS_DEG));</span>
  }
  
  Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontStyleFromStyleValue(Optional&lt;FontSelectionValue&gt; italic, FontStyleAxis fontStyleAxis)
  {
      if (auto keyword = fontStyleKeyword(italic, fontStyleAxis))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2714,11 ***</span>
  
      auto weight = fontDescription.weight();
      if (auto value = fontWeightKeyword(weight))
          computedFont-&gt;weight = CSSValuePool::singleton().createIdentifierValue(value.value());
      else if (isCSS21Weight(weight))
<span class="line-modified">!         computedFont-&gt;weight = CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSPrimitiveValue::CSS_NUMBER);</span>
      else
          return CSSFontValue::create();
  
      if (auto keyword = fontStretchKeyword(fontDescription.stretch()))
          computedFont-&gt;stretch = CSSValuePool::singleton().createIdentifierValue(keyword.value());
<span class="line-new-header">--- 2380,11 ---</span>
  
      auto weight = fontDescription.weight();
      if (auto value = fontWeightKeyword(weight))
          computedFont-&gt;weight = CSSValuePool::singleton().createIdentifierValue(value.value());
      else if (isCSS21Weight(weight))
<span class="line-modified">!         computedFont-&gt;weight = CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSUnitType::CSS_NUMBER);</span>
      else
          return CSSFontValue::create();
  
      if (auto keyword = fontStretchKeyword(fontDescription.stretch()))
          computedFont-&gt;stretch = CSSValuePool::singleton().createIdentifierValue(keyword.value());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2962,17 ***</span>
          return cssValuePool.createIdentifierValue(CSSValueClone);
  #endif
          case CSSPropertyWebkitBoxDirection:
              return cssValuePool.createValue(style.boxDirection());
          case CSSPropertyWebkitBoxFlex:
<span class="line-modified">!             return cssValuePool.createValue(style.boxFlex(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyWebkitBoxFlexGroup:
<span class="line-modified">!             return cssValuePool.createValue(style.boxFlexGroup(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyWebkitBoxLines:
              return cssValuePool.createValue(style.boxLines());
          case CSSPropertyWebkitBoxOrdinalGroup:
<span class="line-modified">!             return cssValuePool.createValue(style.boxOrdinalGroup(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyWebkitBoxOrient:
              return cssValuePool.createValue(style.boxOrient());
          case CSSPropertyWebkitBoxPack:
              return cssValuePool.createValue(style.boxPack());
          case CSSPropertyWebkitBoxReflect:
<span class="line-new-header">--- 2628,17 ---</span>
          return cssValuePool.createIdentifierValue(CSSValueClone);
  #endif
          case CSSPropertyWebkitBoxDirection:
              return cssValuePool.createValue(style.boxDirection());
          case CSSPropertyWebkitBoxFlex:
<span class="line-modified">!             return cssValuePool.createValue(style.boxFlex(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyWebkitBoxFlexGroup:
<span class="line-modified">!             return cssValuePool.createValue(style.boxFlexGroup(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyWebkitBoxLines:
              return cssValuePool.createValue(style.boxLines());
          case CSSPropertyWebkitBoxOrdinalGroup:
<span class="line-modified">!             return cssValuePool.createValue(style.boxOrdinalGroup(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyWebkitBoxOrient:
              return cssValuePool.createValue(style.boxOrient());
          case CSSPropertyWebkitBoxPack:
              return cssValuePool.createValue(style.boxPack());
          case CSSPropertyWebkitBoxReflect:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2993,11 ***</span>
          case CSSPropertyWebkitColumnAxis:
              return cssValuePool.createValue(style.columnAxis());
          case CSSPropertyColumnCount:
              if (style.hasAutoColumnCount())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">!             return cssValuePool.createValue(style.columnCount(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyColumnFill:
              return cssValuePool.createValue(style.columnFill());
          case CSSPropertyColumnGap:
              if (style.columnGap().isNormal())
                  return cssValuePool.createIdentifierValue(CSSValueNormal);
<span class="line-new-header">--- 2659,11 ---</span>
          case CSSPropertyWebkitColumnAxis:
              return cssValuePool.createValue(style.columnAxis());
          case CSSPropertyColumnCount:
              if (style.hasAutoColumnCount())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">!             return cssValuePool.createValue(style.columnCount(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyColumnFill:
              return cssValuePool.createValue(style.columnFill());
          case CSSPropertyColumnGap:
              if (style.columnGap().isNormal())
                  return cssValuePool.createIdentifierValue(CSSValueNormal);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3025,11 ***</span>
          case CSSPropertyColumnWidth:
              if (style.hasAutoColumnWidth())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
              return zoomAdjustedPixelValue(style.columnWidth(), style);
          case CSSPropertyTabSize:
<span class="line-modified">!             return cssValuePool.createValue(style.tabSize().widthInPixels(1.0), style.tabSize().isSpaces() ? CSSPrimitiveValue::CSS_NUMBER : CSSPrimitiveValue::CSS_PX);</span>
          case CSSPropertyCursor: {
              RefPtr&lt;CSSValueList&gt; list;
              auto* cursors = style.cursors();
              if (cursors &amp;&amp; cursors-&gt;size() &gt; 0) {
                  list = CSSValueList::createCommaSeparated();
<span class="line-new-header">--- 2691,11 ---</span>
          case CSSPropertyColumnWidth:
              if (style.hasAutoColumnWidth())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
              return zoomAdjustedPixelValue(style.columnWidth(), style);
          case CSSPropertyTabSize:
<span class="line-modified">!             return cssValuePool.createValue(style.tabSize().widthInPixels(1.0), style.tabSize().isSpaces() ? CSSUnitType::CSS_NUMBER : CSSUnitType::CSS_PX);</span>
          case CSSPropertyCursor: {
              RefPtr&lt;CSSValueList&gt; list;
              auto* cursors = style.cursors();
              if (cursors &amp;&amp; cursors-&gt;size() &gt; 0) {
                  list = CSSValueList::createCommaSeparated();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3085,11 ***</span>
          case CSSPropertyPlaceItems:
              return getCSSPropertyValuesForShorthandProperties(placeItemsShorthand());
          case CSSPropertyPlaceSelf:
              return getCSSPropertyValuesForShorthandProperties(placeSelfShorthand());
          case CSSPropertyOrder:
<span class="line-modified">!             return cssValuePool.createValue(style.order(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyFloat:
              if (style.display() != DisplayType::None &amp;&amp; style.hasOutOfFlowPosition())
                  return cssValuePool.createIdentifierValue(CSSValueNone);
              return cssValuePool.createValue(style.floating());
          case CSSPropertyFont: {
<span class="line-new-header">--- 2751,11 ---</span>
          case CSSPropertyPlaceItems:
              return getCSSPropertyValuesForShorthandProperties(placeItemsShorthand());
          case CSSPropertyPlaceSelf:
              return getCSSPropertyValuesForShorthandProperties(placeSelfShorthand());
          case CSSPropertyOrder:
<span class="line-modified">!             return cssValuePool.createValue(style.order(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyFloat:
              if (style.display() != DisplayType::None &amp;&amp; style.hasOutOfFlowPosition())
                  return cssValuePool.createIdentifierValue(CSSValueNone);
              return cssValuePool.createValue(style.floating());
          case CSSPropertyFont: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3201,47 ***</span>
          case CSSPropertyWebkitHyphens:
              return cssValuePool.createValue(style.hyphens());
          case CSSPropertyWebkitHyphenateCharacter:
              if (style.hyphenationString().isNull())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">!             return cssValuePool.createValue(style.hyphenationString(), CSSPrimitiveValue::CSS_STRING);</span>
          case CSSPropertyWebkitHyphenateLimitAfter:
              if (style.hyphenationLimitAfter() &lt; 0)
                  return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
<span class="line-modified">!             return CSSPrimitiveValue::create(style.hyphenationLimitAfter(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyWebkitHyphenateLimitBefore:
              if (style.hyphenationLimitBefore() &lt; 0)
                  return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
<span class="line-modified">!             return CSSPrimitiveValue::create(style.hyphenationLimitBefore(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyWebkitHyphenateLimitLines:
              if (style.hyphenationLimitLines() &lt; 0)
                  return CSSPrimitiveValue::createIdentifier(CSSValueNoLimit);
<span class="line-modified">!             return CSSPrimitiveValue::create(style.hyphenationLimitLines(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyWebkitBorderFit:
              if (style.borderFit() == BorderFit::Border)
                  return cssValuePool.createIdentifierValue(CSSValueBorder);
              return cssValuePool.createIdentifierValue(CSSValueLines);
<span class="line-removed">- #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
          case CSSPropertyImageOrientation:
<span class="line-modified">!             return cssValuePool.createValue(style.imageOrientation());</span>
<span class="line-modified">! #endif</span>
          case CSSPropertyImageRendering:
              return CSSPrimitiveValue::create(style.imageRendering());
  #if ENABLE(CSS_IMAGE_RESOLUTION)
          case CSSPropertyImageResolution:
<span class="line-modified">!             return cssValuePool.createValue(style.imageResolution(), CSSPrimitiveValue::CSS_DPPX);</span>
  #endif
          case CSSPropertyLeft:
              return positionOffsetValue(style, CSSPropertyLeft, renderer);
          case CSSPropertyLetterSpacing:
              if (!style.letterSpacing())
                  return cssValuePool.createIdentifierValue(CSSValueNormal);
              return zoomAdjustedPixelValue(style.letterSpacing(), style);
          case CSSPropertyWebkitLineClamp:
              if (style.lineClamp().isNone())
                  return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">!             return cssValuePool.createValue(style.lineClamp().value(), style.lineClamp().isPercentage() ? CSSPrimitiveValue::CSS_PERCENTAGE : CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyLineHeight:
              return lineHeightFromStyle(style);
          case CSSPropertyListStyleImage:
              if (style.listStyleImage())
                  return style.listStyleImage()-&gt;cssValue();
<span class="line-new-header">--- 2867,47 ---</span>
          case CSSPropertyWebkitHyphens:
              return cssValuePool.createValue(style.hyphens());
          case CSSPropertyWebkitHyphenateCharacter:
              if (style.hyphenationString().isNull())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">!             return cssValuePool.createValue(style.hyphenationString(), CSSUnitType::CSS_STRING);</span>
          case CSSPropertyWebkitHyphenateLimitAfter:
              if (style.hyphenationLimitAfter() &lt; 0)
                  return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
<span class="line-modified">!             return CSSPrimitiveValue::create(style.hyphenationLimitAfter(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyWebkitHyphenateLimitBefore:
              if (style.hyphenationLimitBefore() &lt; 0)
                  return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
<span class="line-modified">!             return CSSPrimitiveValue::create(style.hyphenationLimitBefore(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyWebkitHyphenateLimitLines:
              if (style.hyphenationLimitLines() &lt; 0)
                  return CSSPrimitiveValue::createIdentifier(CSSValueNoLimit);
<span class="line-modified">!             return CSSPrimitiveValue::create(style.hyphenationLimitLines(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyWebkitBorderFit:
              if (style.borderFit() == BorderFit::Border)
                  return cssValuePool.createIdentifierValue(CSSValueBorder);
              return cssValuePool.createIdentifierValue(CSSValueLines);
          case CSSPropertyImageOrientation:
<span class="line-modified">!             if (style.imageOrientation() == ImageOrientation::FromImage)</span>
<span class="line-modified">!                 return cssValuePool.createIdentifierValue(CSSValueFromImage);</span>
<span class="line-added">+             return cssValuePool.createIdentifierValue(CSSValueNone);</span>
          case CSSPropertyImageRendering:
              return CSSPrimitiveValue::create(style.imageRendering());
  #if ENABLE(CSS_IMAGE_RESOLUTION)
          case CSSPropertyImageResolution:
<span class="line-modified">!             return cssValuePool.createValue(style.imageResolution(), CSSUnitType::CSS_DPPX);</span>
  #endif
          case CSSPropertyLeft:
              return positionOffsetValue(style, CSSPropertyLeft, renderer);
          case CSSPropertyLetterSpacing:
              if (!style.letterSpacing())
                  return cssValuePool.createIdentifierValue(CSSValueNormal);
              return zoomAdjustedPixelValue(style.letterSpacing(), style);
          case CSSPropertyWebkitLineClamp:
              if (style.lineClamp().isNone())
                  return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">!             return cssValuePool.createValue(style.lineClamp().value(), style.lineClamp().isPercentage() ? CSSUnitType::CSS_PERCENTAGE : CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyLineHeight:
              return lineHeightFromStyle(style);
          case CSSPropertyListStyleImage:
              if (style.listStyleImage())
                  return style.listStyleImage()-&gt;cssValue();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3251,11 ***</span>
          case CSSPropertyListStyleType:
              return cssValuePool.createValue(style.listStyleType());
          case CSSPropertyWebkitLocale:
              if (style.locale().isNull())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">!             return cssValuePool.createValue(style.locale(), CSSPrimitiveValue::CSS_STRING);</span>
          case CSSPropertyMarginTop:
              return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginTop, &amp;RenderBoxModelObject::marginTop&gt;(style, renderer);
          case CSSPropertyMarginRight: {
              Length marginRight = style.marginRight();
              if (marginRight.isFixed() || !is&lt;RenderBox&gt;(renderer))
<span class="line-new-header">--- 2917,11 ---</span>
          case CSSPropertyListStyleType:
              return cssValuePool.createValue(style.listStyleType());
          case CSSPropertyWebkitLocale:
              if (style.locale().isNull())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">!             return cssValuePool.createValue(style.locale(), CSSUnitType::CSS_STRING);</span>
          case CSSPropertyMarginTop:
              return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginTop, &amp;RenderBoxModelObject::marginTop&gt;(style, renderer);
          case CSSPropertyMarginRight: {
              Length marginRight = style.marginRight();
              if (marginRight.isFixed() || !is&lt;RenderBox&gt;(renderer))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3272,20 ***</span>
          }
          case CSSPropertyMarginBottom:
              return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginBottom, &amp;RenderBoxModelObject::marginBottom&gt;(style, renderer);
          case CSSPropertyMarginLeft:
              return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginLeft, &amp;RenderBoxModelObject::marginLeft&gt;(style, renderer);
<span class="line-removed">-         case CSSPropertyWebkitMarqueeDirection:</span>
<span class="line-removed">-             return cssValuePool.createValue(style.marqueeDirection());</span>
<span class="line-removed">-         case CSSPropertyWebkitMarqueeIncrement:</span>
<span class="line-removed">-             return cssValuePool.createValue(style.marqueeIncrement());</span>
<span class="line-removed">-         case CSSPropertyWebkitMarqueeRepetition:</span>
<span class="line-removed">-             if (style.marqueeLoopCount() &lt; 0)</span>
<span class="line-removed">-                 return cssValuePool.createIdentifierValue(CSSValueInfinite);</span>
<span class="line-removed">-             return cssValuePool.createValue(style.marqueeLoopCount(), CSSPrimitiveValue::CSS_NUMBER);</span>
<span class="line-removed">-         case CSSPropertyWebkitMarqueeStyle:</span>
<span class="line-removed">-             return cssValuePool.createValue(style.marqueeBehavior());</span>
          case CSSPropertyWebkitUserModify:
              return cssValuePool.createValue(style.userModify());
          case CSSPropertyMaxHeight: {
              const Length&amp; maxHeight = style.maxHeight();
              if (maxHeight.isUndefined())
<span class="line-new-header">--- 2938,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3321,15 ***</span>
              list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().x(), style));
              list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().y(), style));
              return list;
          }
          case CSSPropertyOpacity:
<span class="line-modified">!             return cssValuePool.createValue(style.opacity(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyOrphans:
              if (style.hasAutoOrphans())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">!             return cssValuePool.createValue(style.orphans(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyOutlineColor:
              return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.outlineColor());
          case CSSPropertyOutlineOffset:
              return zoomAdjustedPixelValue(style.outlineOffset(), style);
          case CSSPropertyOutlineStyle:
<span class="line-new-header">--- 2977,15 ---</span>
              list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().x(), style));
              list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().y(), style));
              return list;
          }
          case CSSPropertyOpacity:
<span class="line-modified">!             return cssValuePool.createValue(style.opacity(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyOrphans:
              if (style.hasAutoOrphans())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">!             return cssValuePool.createValue(style.orphans(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyOutlineColor:
              return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.outlineColor());
          case CSSPropertyOutlineOffset:
              return zoomAdjustedPixelValue(style.outlineOffset(), style);
          case CSSPropertyOutlineStyle:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3337,11 ***</span>
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
              return cssValuePool.createValue(style.outlineStyle());
          case CSSPropertyOutlineWidth:
              return zoomAdjustedPixelValue(style.outlineWidth(), style);
          case CSSPropertyOverflow:
<span class="line-modified">!             return cssValuePool.createValue(std::max(style.overflowX(), style.overflowY()));</span>
          case CSSPropertyOverflowWrap:
              return cssValuePool.createValue(style.overflowWrap());
          case CSSPropertyOverflowX:
              return cssValuePool.createValue(style.overflowX());
          case CSSPropertyOverflowY:
<span class="line-new-header">--- 2993,11 ---</span>
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
              return cssValuePool.createValue(style.outlineStyle());
          case CSSPropertyOutlineWidth:
              return zoomAdjustedPixelValue(style.outlineWidth(), style);
          case CSSPropertyOverflow:
<span class="line-modified">!             return getCSSPropertyValuesFor2SidesShorthand(overflowShorthand());</span>
          case CSSPropertyOverflowWrap:
              return cssValuePool.createValue(style.overflowWrap());
          case CSSPropertyOverflowX:
              return cssValuePool.createValue(style.overflowX());
          case CSSPropertyOverflowY:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3413,14 ***</span>
          case CSSPropertyWebkitTextEmphasisStyle:
              switch (style.textEmphasisMark()) {
              case TextEmphasisMark::None:
                  return cssValuePool.createIdentifierValue(CSSValueNone);
              case TextEmphasisMark::Custom:
<span class="line-modified">!                 return cssValuePool.createValue(style.textEmphasisCustomMark(), CSSPrimitiveValue::CSS_STRING);</span>
              case TextEmphasisMark::Auto:
                  ASSERT_NOT_REACHED();
<span class="line-modified">! #if ASSERT_DISABLED</span>
                  FALLTHROUGH;
  #endif
              case TextEmphasisMark::Dot:
              case TextEmphasisMark::Circle:
              case TextEmphasisMark::DoubleCircle:
<span class="line-new-header">--- 3069,14 ---</span>
          case CSSPropertyWebkitTextEmphasisStyle:
              switch (style.textEmphasisMark()) {
              case TextEmphasisMark::None:
                  return cssValuePool.createIdentifierValue(CSSValueNone);
              case TextEmphasisMark::Custom:
<span class="line-modified">!                 return cssValuePool.createValue(style.textEmphasisCustomMark(), CSSUnitType::CSS_STRING);</span>
              case TextEmphasisMark::Auto:
                  ASSERT_NOT_REACHED();
<span class="line-modified">! #if !ASSERT_ENABLED</span>
                  FALLTHROUGH;
  #endif
              case TextEmphasisMark::Dot:
              case TextEmphasisMark::Circle:
              case TextEmphasisMark::DoubleCircle:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3465,11 ***</span>
          case CSSPropertyWebkitTextSizeAdjust:
              if (style.textSizeAdjust().isAuto())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
              if (style.textSizeAdjust().isNone())
                  return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">!             return CSSPrimitiveValue::create(style.textSizeAdjust().percentage(), CSSPrimitiveValue::CSS_PERCENTAGE);</span>
  #endif
          case CSSPropertyWebkitTextStrokeColor:
              return currentColorOrValidColor(&amp;style, style.textStrokeColor());
          case CSSPropertyWebkitTextStrokeWidth:
              return zoomAdjustedPixelValue(style.textStrokeWidth(), style);
<span class="line-new-header">--- 3121,11 ---</span>
          case CSSPropertyWebkitTextSizeAdjust:
              if (style.textSizeAdjust().isAuto())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
              if (style.textSizeAdjust().isNone())
                  return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">!             return CSSPrimitiveValue::create(style.textSizeAdjust().percentage(), CSSUnitType::CSS_PERCENTAGE);</span>
  #endif
          case CSSPropertyWebkitTextStrokeColor:
              return currentColorOrValidColor(&amp;style, style.textStrokeColor());
          case CSSPropertyWebkitTextStrokeWidth:
              return zoomAdjustedPixelValue(style.textStrokeWidth(), style);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3509,11 ***</span>
          case CSSPropertyWhiteSpace:
              return cssValuePool.createValue(style.whiteSpace());
          case CSSPropertyWidows:
              if (style.hasAutoWidows())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">!             return cssValuePool.createValue(style.widows(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyWidth:
              if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
                  // According to http://www.w3.org/TR/CSS2/visudet.html#the-width-property,
                  // the &quot;width&quot; property does not apply for non-replaced inline elements.
                  if (!isNonReplacedInline(*renderer))
<span class="line-new-header">--- 3165,11 ---</span>
          case CSSPropertyWhiteSpace:
              return cssValuePool.createValue(style.whiteSpace());
          case CSSPropertyWidows:
              if (style.hasAutoWidows())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">!             return cssValuePool.createValue(style.widows(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyWidth:
              if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
                  // According to http://www.w3.org/TR/CSS2/visudet.html#the-width-property,
                  // the &quot;width&quot; property does not apply for non-replaced inline elements.
                  if (!isNonReplacedInline(*renderer))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3549,15 ***</span>
          case CSSPropertyFontVariantAlternates:
              return fontVariantAlternatesPropertyValue(style.fontDescription().variantAlternates());
          case CSSPropertyFontVariantEastAsian:
              return fontVariantEastAsianPropertyValue(style.fontDescription().variantEastAsianVariant(), style.fontDescription().variantEastAsianWidth(), style.fontDescription().variantEastAsianRuby());
          case CSSPropertyZIndex:
<span class="line-modified">!             if (style.hasAutoZIndex())</span>
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">!             return cssValuePool.createValue(style.zIndex(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyZoom:
<span class="line-modified">!             return cssValuePool.createValue(style.zoom(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyBoxSizing:
              if (style.boxSizing() == BoxSizing::ContentBox)
                  return cssValuePool.createIdentifierValue(CSSValueContentBox);
              return cssValuePool.createIdentifierValue(CSSValueBorderBox);
          case CSSPropertyAnimationDelay:
<span class="line-new-header">--- 3205,15 ---</span>
          case CSSPropertyFontVariantAlternates:
              return fontVariantAlternatesPropertyValue(style.fontDescription().variantAlternates());
          case CSSPropertyFontVariantEastAsian:
              return fontVariantEastAsianPropertyValue(style.fontDescription().variantEastAsianVariant(), style.fontDescription().variantEastAsianWidth(), style.fontDescription().variantEastAsianRuby());
          case CSSPropertyZIndex:
<span class="line-modified">!             if (style.hasAutoSpecifiedZIndex())</span>
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">!             return cssValuePool.createValue(style.specifiedZIndex(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyZoom:
<span class="line-modified">!             return cssValuePool.createValue(style.zoom(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyBoxSizing:
              if (style.boxSizing() == BoxSizing::ContentBox)
                  return cssValuePool.createIdentifierValue(CSSValueContentBox);
              return cssValuePool.createIdentifierValue(CSSValueBorderBox);
          case CSSPropertyAnimationDelay:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3619,22 ***</span>
                  for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
                      double iterationCount = t-&gt;animation(i).iterationCount();
                      if (iterationCount == Animation::IterationCountInfinite)
                          list-&gt;append(cssValuePool.createIdentifierValue(CSSValueInfinite));
                      else
<span class="line-modified">!                         list-&gt;append(cssValuePool.createValue(iterationCount, CSSPrimitiveValue::CSS_NUMBER));</span>
                  }
              } else
<span class="line-modified">!                 list-&gt;append(cssValuePool.createValue(Animation::initialIterationCount(), CSSPrimitiveValue::CSS_NUMBER));</span>
              return list;
          }
          case CSSPropertyAnimationName: {
              auto list = CSSValueList::createCommaSeparated();
              const AnimationList* t = style.animations();
              if (t) {
                  for (size_t i = 0; i &lt; t-&gt;size(); ++i)
<span class="line-modified">!                     list-&gt;append(cssValuePool.createValue(t-&gt;animation(i).name(), CSSPrimitiveValue::CSS_STRING));</span>
              } else
                  list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
              return list;
          }
          case CSSPropertyAnimationPlayState: {
<span class="line-new-header">--- 3275,22 ---</span>
                  for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
                      double iterationCount = t-&gt;animation(i).iterationCount();
                      if (iterationCount == Animation::IterationCountInfinite)
                          list-&gt;append(cssValuePool.createIdentifierValue(CSSValueInfinite));
                      else
<span class="line-modified">!                         list-&gt;append(cssValuePool.createValue(iterationCount, CSSUnitType::CSS_NUMBER));</span>
                  }
              } else
<span class="line-modified">!                 list-&gt;append(cssValuePool.createValue(Animation::initialIterationCount(), CSSUnitType::CSS_NUMBER));</span>
              return list;
          }
          case CSSPropertyAnimationName: {
              auto list = CSSValueList::createCommaSeparated();
              const AnimationList* t = style.animations();
              if (t) {
                  for (size_t i = 0; i &lt; t-&gt;size(); ++i)
<span class="line-modified">!                     list-&gt;append(cssValuePool.createValue(t-&gt;animation(i).name(), CSSUnitType::CSS_STRING));</span>
              } else
                  list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
              return list;
          }
          case CSSPropertyAnimationPlayState: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3700,12 ***</span>
              return cssValuePool.createIdentifierValue(CSSValueNone);
          case CSSPropertyWebkitFontSizeDelta:
              // Not a real style property -- used by the editing engine -- so has no computed value.
              break;
          case CSSPropertyWebkitInitialLetter: {
<span class="line-modified">!             auto drop = !style.initialLetterDrop() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterDrop(), CSSPrimitiveValue::CSS_NUMBER);</span>
<span class="line-modified">!             auto size = !style.initialLetterHeight() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterHeight(), CSSPrimitiveValue::CSS_NUMBER);</span>
              return cssValuePool.createValue(Pair::create(WTFMove(drop), WTFMove(size)));
          }
          case CSSPropertyWebkitMarginBottomCollapse:
          case CSSPropertyWebkitMarginAfterCollapse:
              return cssValuePool.createValue(style.marginAfterCollapse());
<span class="line-new-header">--- 3356,12 ---</span>
              return cssValuePool.createIdentifierValue(CSSValueNone);
          case CSSPropertyWebkitFontSizeDelta:
              // Not a real style property -- used by the editing engine -- so has no computed value.
              break;
          case CSSPropertyWebkitInitialLetter: {
<span class="line-modified">!             auto drop = !style.initialLetterDrop() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterDrop(), CSSUnitType::CSS_NUMBER);</span>
<span class="line-modified">!             auto size = !style.initialLetterHeight() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterHeight(), CSSUnitType::CSS_NUMBER);</span>
              return cssValuePool.createValue(Pair::create(WTFMove(drop), WTFMove(size)));
          }
          case CSSPropertyWebkitMarginBottomCollapse:
          case CSSPropertyWebkitMarginAfterCollapse:
              return cssValuePool.createValue(style.marginAfterCollapse());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3716,10 ***</span>
<span class="line-new-header">--- 3372,14 ---</span>
          case CSSPropertyWebkitOverflowScrolling:
              if (!style.useTouchOverflowScrolling())
                  return cssValuePool.createIdentifierValue(CSSValueAuto);
              return cssValuePool.createIdentifierValue(CSSValueTouch);
  #endif
<span class="line-added">+         case CSSPropertyScrollBehavior:</span>
<span class="line-added">+             if (!style.useSmoothScrolling())</span>
<span class="line-added">+                 return cssValuePool.createIdentifierValue(CSSValueAuto);</span>
<span class="line-added">+             return cssValuePool.createIdentifierValue(CSSValueSmooth);</span>
          case CSSPropertyPerspective:
              if (!style.hasPerspective())
                  return cssValuePool.createIdentifierValue(CSSValueNone);
              return zoomAdjustedPixelValue(style.perspective(), style);
          case CSSPropertyPerspectiveOrigin: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3814,32 ***</span>
                  auto transitionsList = CSSValueList::createCommaSeparated();
                  for (size_t i = 0; i &lt; animationList-&gt;size(); ++i) {
                      auto list = CSSValueList::createSpaceSeparated();
                      auto&amp; animation = animationList-&gt;animation(i);
                      list-&gt;append(createTransitionPropertyValue(animation));
<span class="line-modified">!                     list-&gt;append(cssValuePool.createValue(animation.duration(), CSSPrimitiveValue::CSS_S));</span>
                      list-&gt;append(createTimingFunctionValue(*animation.timingFunction()));
<span class="line-modified">!                     list-&gt;append(cssValuePool.createValue(animation.delay(), CSSPrimitiveValue::CSS_S));</span>
                      transitionsList-&gt;append(WTFMove(list));
                  }
                  return transitionsList;
              }
  
              auto list = CSSValueList::createSpaceSeparated();
              // transition-property default value.
              list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAll));
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSPrimitiveValue::CSS_S));</span>
              list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));</span>
              return list;
          }
          case CSSPropertyPointerEvents:
              return cssValuePool.createValue(style.pointerEvents());
          case CSSPropertyWebkitLineGrid:
              if (style.lineGrid().isNull())
                  return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">!             return cssValuePool.createValue(style.lineGrid(), CSSPrimitiveValue::CSS_STRING);</span>
          case CSSPropertyWebkitLineSnap:
              return CSSPrimitiveValue::create(style.lineSnap());
          case CSSPropertyWebkitLineAlign:
              return CSSPrimitiveValue::create(style.lineAlign());
          case CSSPropertyWritingMode:
<span class="line-new-header">--- 3474,32 ---</span>
                  auto transitionsList = CSSValueList::createCommaSeparated();
                  for (size_t i = 0; i &lt; animationList-&gt;size(); ++i) {
                      auto list = CSSValueList::createSpaceSeparated();
                      auto&amp; animation = animationList-&gt;animation(i);
                      list-&gt;append(createTransitionPropertyValue(animation));
<span class="line-modified">!                     list-&gt;append(cssValuePool.createValue(animation.duration(), CSSUnitType::CSS_S));</span>
                      list-&gt;append(createTimingFunctionValue(*animation.timingFunction()));
<span class="line-modified">!                     list-&gt;append(cssValuePool.createValue(animation.delay(), CSSUnitType::CSS_S));</span>
                      transitionsList-&gt;append(WTFMove(list));
                  }
                  return transitionsList;
              }
  
              auto list = CSSValueList::createSpaceSeparated();
              // transition-property default value.
              list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAll));
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSUnitType::CSS_S));</span>
              list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
<span class="line-modified">!             list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSUnitType::CSS_S));</span>
              return list;
          }
          case CSSPropertyPointerEvents:
              return cssValuePool.createValue(style.pointerEvents());
          case CSSPropertyWebkitLineGrid:
              if (style.lineGrid().isNull())
                  return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">!             return cssValuePool.createValue(style.lineGrid(), CSSUnitType::CSS_STRING);</span>
          case CSSPropertyWebkitLineSnap:
              return CSSPrimitiveValue::create(style.lineSnap());
          case CSSPropertyWebkitLineAlign:
              return CSSPrimitiveValue::create(style.lineAlign());
          case CSSPropertyWritingMode:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3856,16 ***</span>
              return contentToCSSValue(style);
          case CSSPropertyCounterIncrement:
              return counterToCSSValue(style, propertyID);
          case CSSPropertyCounterReset:
              return counterToCSSValue(style, propertyID);
<span class="line-modified">!         case CSSPropertyWebkitClipPath: {</span>
              auto* operation = style.clipPath();
              if (!operation)
                  return cssValuePool.createIdentifierValue(CSSValueNone);
              if (is&lt;ReferenceClipPathOperation&gt;(*operation))
<span class="line-modified">!                 return CSSPrimitiveValue::create(downcast&lt;ReferenceClipPathOperation&gt;(*operation).url(), CSSPrimitiveValue::CSS_URI);</span>
              auto list = CSSValueList::createSpaceSeparated();
              if (is&lt;ShapeClipPathOperation&gt;(*operation)) {
                  auto&amp; shapeOperation = downcast&lt;ShapeClipPathOperation&gt;(*operation);
                  list-&gt;append(valueForBasicShape(style, shapeOperation.basicShape()));
                  if (shapeOperation.referenceBox() != CSSBoxType::BoxMissing)
<span class="line-new-header">--- 3516,16 ---</span>
              return contentToCSSValue(style);
          case CSSPropertyCounterIncrement:
              return counterToCSSValue(style, propertyID);
          case CSSPropertyCounterReset:
              return counterToCSSValue(style, propertyID);
<span class="line-modified">!         case CSSPropertyClipPath: {</span>
              auto* operation = style.clipPath();
              if (!operation)
                  return cssValuePool.createIdentifierValue(CSSValueNone);
              if (is&lt;ReferenceClipPathOperation&gt;(*operation))
<span class="line-modified">!                 return CSSPrimitiveValue::create(downcast&lt;ReferenceClipPathOperation&gt;(*operation).url(), CSSUnitType::CSS_URI);</span>
              auto list = CSSValueList::createSpaceSeparated();
              if (is&lt;ShapeClipPathOperation&gt;(*operation)) {
                  auto&amp; shapeOperation = downcast&lt;ShapeClipPathOperation&gt;(*operation);
                  list-&gt;append(valueForBasicShape(style, shapeOperation.basicShape()));
                  if (shapeOperation.referenceBox() != CSSBoxType::BoxMissing)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3876,11 ***</span>
              return list;
          }
          case CSSPropertyShapeMargin:
              return cssValuePool.createValue(style.shapeMargin(), style);
          case CSSPropertyShapeImageThreshold:
<span class="line-modified">!             return cssValuePool.createValue(style.shapeImageThreshold(), CSSPrimitiveValue::CSS_NUMBER);</span>
          case CSSPropertyShapeOutside:
              return shapePropertyValue(style, style.shapeOutside());
          case CSSPropertyFilter:
              return valueForFilter(style, style.filter());
          case CSSPropertyAppleColorFilter:
<span class="line-new-header">--- 3536,11 ---</span>
              return list;
          }
          case CSSPropertyShapeMargin:
              return cssValuePool.createValue(style.shapeMargin(), style);
          case CSSPropertyShapeImageThreshold:
<span class="line-modified">!             return cssValuePool.createValue(style.shapeImageThreshold(), CSSUnitType::CSS_NUMBER);</span>
          case CSSPropertyShapeOutside:
              return shapePropertyValue(style, style.shapeOutside());
          case CSSPropertyFilter:
              return valueForFilter(style, style.filter());
          case CSSPropertyAppleColorFilter:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4074,11 ***</span>
          case CSSPropertyStrokeWidth:
              return zoomAdjustedPixelValueForLength(style.strokeWidth(), style);
          case CSSPropertyStrokeColor:
              return currentColorOrValidColor(&amp;style, style.strokeColor());
          case CSSPropertyStrokeMiterlimit:
<span class="line-modified">!             return CSSPrimitiveValue::create(style.strokeMiterLimit(), CSSPrimitiveValue::CSS_NUMBER);</span>
  
          /* Unimplemented CSS 3 properties (including CSS3 shorthand properties) */
          case CSSPropertyAll:
          case CSSPropertyAnimation:
          case CSSPropertyWebkitTextEmphasis:
<span class="line-new-header">--- 3734,11 ---</span>
          case CSSPropertyStrokeWidth:
              return zoomAdjustedPixelValueForLength(style.strokeWidth(), style);
          case CSSPropertyStrokeColor:
              return currentColorOrValidColor(&amp;style, style.strokeColor());
          case CSSPropertyStrokeMiterlimit:
<span class="line-modified">!             return CSSPrimitiveValue::create(style.strokeMiterLimit(), CSSUnitType::CSS_NUMBER);</span>
  
          /* Unimplemented CSS 3 properties (including CSS3 shorthand properties) */
          case CSSPropertyAll:
          case CSSPropertyAnimation:
          case CSSPropertyWebkitTextEmphasis:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4135,11 ***</span>
              break;
  
          /* Unimplemented -webkit- properties */
          case CSSPropertyWebkitBorderRadius:
          case CSSPropertyWebkitMarginCollapse:
<span class="line-modified">!         case CSSPropertyWebkitMarquee:</span>
          case CSSPropertyWebkitMarqueeSpeed:
          case CSSPropertyWebkitMask:
          case CSSPropertyWebkitMaskRepeatX:
          case CSSPropertyWebkitMaskRepeatY:
          case CSSPropertyPerspectiveOriginX:
<span class="line-new-header">--- 3795,14 ---</span>
              break;
  
          /* Unimplemented -webkit- properties */
          case CSSPropertyWebkitBorderRadius:
          case CSSPropertyWebkitMarginCollapse:
<span class="line-modified">!         case CSSPropertyWebkitMarqueeDirection:</span>
<span class="line-added">+         case CSSPropertyWebkitMarqueeIncrement:</span>
<span class="line-added">+         case CSSPropertyWebkitMarqueeRepetition:</span>
<span class="line-added">+         case CSSPropertyWebkitMarqueeStyle:</span>
          case CSSPropertyWebkitMarqueeSpeed:
          case CSSPropertyWebkitMask:
          case CSSPropertyWebkitMaskRepeatX:
          case CSSPropertyWebkitMaskRepeatY:
          case CSSPropertyPerspectiveOriginX:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4157,11 ***</span>
          case CSSPropertyUserZoom:
              break;
  #endif
  
          case CSSPropertyBufferedRendering:
<span class="line-removed">-         case CSSPropertyClipPath:</span>
          case CSSPropertyClipRule:
          case CSSPropertyMask:
          case CSSPropertyEnableBackground:
          case CSSPropertyFloodColor:
          case CSSPropertyFloodOpacity:
<span class="line-new-header">--- 3820,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4196,11 ***</span>
          case CSSPropertyCustom:
              ASSERT_NOT_REACHED();
              return nullptr;
      }
  
<span class="line-removed">-     logUnimplementedPropertyID(propertyID);</span>
      return nullptr;
  }
  
  String CSSComputedStyleDeclaration::getPropertyValue(CSSPropertyID propertyID) const
  {
<span class="line-new-header">--- 3858,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4216,35 ***</span>
  
      auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
      if (!style)
          return 0;
  
<span class="line-modified">!     return numComputedProperties + style-&gt;inheritedCustomProperties().size() + style-&gt;nonInheritedCustomProperties().size();</span>
  }
  
  String CSSComputedStyleDeclaration::item(unsigned i) const
  {
      if (i &gt;= length())
          return String();
  
<span class="line-modified">!     if (i &lt; numComputedProperties)</span>
<span class="line-modified">!         return getPropertyNameString(computedProperties[i]);</span>
  
      auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
      if (!style)
          return String();
  
      const auto&amp; inheritedCustomProperties = style-&gt;inheritedCustomProperties();
  
<span class="line-modified">!     if (i &lt; numComputedProperties + inheritedCustomProperties.size()) {</span>
          auto results = copyToVector(inheritedCustomProperties.keys());
<span class="line-modified">!         return results.at(i - numComputedProperties);</span>
      }
  
      const auto&amp; nonInheritedCustomProperties = style-&gt;nonInheritedCustomProperties();
      auto results = copyToVector(nonInheritedCustomProperties.keys());
<span class="line-modified">!     return results.at(i - inheritedCustomProperties.size() - numComputedProperties);</span>
  }
  
  bool ComputedStyleExtractor::propertyMatches(CSSPropertyID propertyID, const CSSValue* value)
  {
      if (!m_element)
<span class="line-new-header">--- 3877,35 ---</span>
  
      auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
      if (!style)
          return 0;
  
<span class="line-modified">!     return numComputedPropertyIDs + style-&gt;inheritedCustomProperties().size() + style-&gt;nonInheritedCustomProperties().size();</span>
  }
  
  String CSSComputedStyleDeclaration::item(unsigned i) const
  {
      if (i &gt;= length())
          return String();
  
<span class="line-modified">!     if (i &lt; numComputedPropertyIDs)</span>
<span class="line-modified">!         return getPropertyNameString(computedPropertyIDs[i]);</span>
  
      auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
      if (!style)
          return String();
  
      const auto&amp; inheritedCustomProperties = style-&gt;inheritedCustomProperties();
  
<span class="line-modified">!     if (i &lt; numComputedPropertyIDs + inheritedCustomProperties.size()) {</span>
          auto results = copyToVector(inheritedCustomProperties.keys());
<span class="line-modified">!         return results.at(i - numComputedPropertyIDs);</span>
      }
  
      const auto&amp; nonInheritedCustomProperties = style-&gt;nonInheritedCustomProperties();
      auto results = copyToVector(nonInheritedCustomProperties.keys());
<span class="line-modified">!     return results.at(i - inheritedCustomProperties.size() - numComputedPropertyIDs);</span>
  }
  
  bool ComputedStyleExtractor::propertyMatches(CSSPropertyID propertyID, const CSSValue* value)
  {
      if (!m_element)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4261,15 ***</span>
      }
      RefPtr&lt;CSSValue&gt; computedValue = propertyValue(propertyID);
      return computedValue &amp;&amp; value &amp;&amp; computedValue-&gt;equals(*value);
  }
  
<span class="line-removed">- Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyProperties()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return copyPropertiesInSet(computedProperties, numComputedProperties);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForShorthandProperties(const StylePropertyShorthand&amp; shorthand)
  {
      auto list = CSSValueList::createSpaceSeparated();
      for (size_t i = 0; i &lt; shorthand.length(); ++i)
          list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
<span class="line-new-header">--- 3922,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4334,17 ***</span>
      return list;
  }
  
  Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyPropertiesInSet(const CSSPropertyID* set, unsigned length)
  {
<span class="line-modified">!     Vector&lt;CSSProperty, 256&gt; list;</span>
      list.reserveInitialCapacity(length);
      for (unsigned i = 0; i &lt; length; ++i) {
          if (auto value = propertyValue(set[i]))
              list.append(CSSProperty(set[i], WTFMove(value), false));
      }
<span class="line-modified">!     return MutableStyleProperties::create(list.data(), list.size());</span>
  }
  
  CSSRule* CSSComputedStyleDeclaration::parentRule() const
  {
      return nullptr;
<span class="line-new-header">--- 3990,29 ---</span>
      return list;
  }
  
  Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyPropertiesInSet(const CSSPropertyID* set, unsigned length)
  {
<span class="line-modified">!     Vector&lt;CSSProperty&gt; list;</span>
      list.reserveInitialCapacity(length);
      for (unsigned i = 0; i &lt; length; ++i) {
          if (auto value = propertyValue(set[i]))
              list.append(CSSProperty(set[i], WTFMove(value), false));
      }
<span class="line-modified">!     return MutableStyleProperties::create(WTFMove(list));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyProperties()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Vector&lt;CSSProperty&gt; list;</span>
<span class="line-added">+     list.reserveInitialCapacity(numCSSProperties);</span>
<span class="line-added">+     for (unsigned i = firstCSSProperty; i &lt; lastCSSProperty; ++i) {</span>
<span class="line-added">+         auto propertyID = convertToCSSPropertyID(i);</span>
<span class="line-added">+         if (auto value = propertyValue(propertyID))</span>
<span class="line-added">+             list.append(CSSProperty(propertyID, WTFMove(value)));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return MutableStyleProperties::create(WTFMove(list));</span>
  }
  
  CSSRule* CSSComputedStyleDeclaration::parentRule() const
  {
      return nullptr;
</pre>
<center><a href="CSSCanvasValue.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSCrossfadeValue.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/Bitmap.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  *  Copyright (C) 2010-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Lesser General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Lesser General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Lesser General Public
 15  *  License along with this library; if not, write to the Free Software
 16  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 17  *
 18  */
 19 
 20 #pragma once
 21 
 22 #include &lt;array&gt;
 23 #include &lt;wtf/Atomics.h&gt;
 24 #include &lt;wtf/HashFunctions.h&gt;
 25 #include &lt;wtf/StdLibExtras.h&gt;
 26 #include &lt;stdint.h&gt;
 27 #include &lt;string.h&gt;
 28 
 29 namespace WTF {
 30 
 31 template&lt;size_t bitmapSize, typename WordType = uint32_t&gt;
 32 class Bitmap final {
 33     WTF_MAKE_FAST_ALLOCATED;
 34 
 35     static_assert(sizeof(WordType) &lt;= sizeof(unsigned), &quot;WordType must not be bigger than unsigned&quot;);
 36 public:
 37     constexpr Bitmap();
 38 
 39     static constexpr size_t size()
 40     {
 41         return bitmapSize;
 42     }
 43 
 44     bool get(size_t, Dependency = Dependency()) const;
 45     void set(size_t);
 46     void set(size_t, bool);
 47     bool testAndSet(size_t);
 48     bool testAndClear(size_t);
 49     bool concurrentTestAndSet(size_t, Dependency = Dependency());
 50     bool concurrentTestAndClear(size_t, Dependency = Dependency());
 51     size_t nextPossiblyUnset(size_t) const;
 52     void clear(size_t);
 53     void clearAll();
<a name="2" id="anc2"></a><span class="line-added"> 54     void invert();</span>
 55     int64_t findRunOfZeros(size_t runLength) const;
 56     size_t count(size_t start = 0) const;
 57     size_t isEmpty() const;
 58     size_t isFull() const;
 59 
 60     void merge(const Bitmap&amp;);
 61     void filter(const Bitmap&amp;);
 62     void exclude(const Bitmap&amp;);
 63 
 64     void concurrentFilter(const Bitmap&amp;);
 65 
 66     bool subsumes(const Bitmap&amp;) const;
 67 
 68     template&lt;typename Func&gt;
 69     void forEachSetBit(const Func&amp;) const;
 70 
 71     size_t findBit(size_t startIndex, bool value) const;
 72 
 73     class iterator {
 74         WTF_MAKE_FAST_ALLOCATED;
 75     public:
 76         iterator()
 77             : m_bitmap(nullptr)
 78             , m_index(0)
 79         {
 80         }
 81 
 82         iterator(const Bitmap&amp; bitmap, size_t index)
 83             : m_bitmap(&amp;bitmap)
 84             , m_index(index)
 85         {
 86         }
 87 
 88         size_t operator*() const { return m_index; }
 89 
 90         iterator&amp; operator++()
 91         {
 92             m_index = m_bitmap-&gt;findBit(m_index + 1, true);
 93             return *this;
 94         }
 95 
 96         bool operator==(const iterator&amp; other) const
 97         {
 98             return m_index == other.m_index;
 99         }
100 
101         bool operator!=(const iterator&amp; other) const
102         {
103             return !(*this == other);
104         }
105 
<a name="3" id="anc3"></a><span class="line-added">106         iterator&amp; operator=(bool value)</span>
<span class="line-added">107         {</span>
<span class="line-added">108             m_bitmap-&gt;set(m_index, value);</span>
<span class="line-added">109             return *this;</span>
<span class="line-added">110         }</span>
<span class="line-added">111 </span>
112     private:
113         const Bitmap* m_bitmap;
114         size_t m_index;
115     };
116 
117     // Use this to iterate over set bits.
118     iterator begin() const { return iterator(*this, findBit(0, true)); }
119     iterator end() const { return iterator(*this, bitmapSize); }
120 
<a name="4" id="anc4"></a><span class="line-added">121     iterator operator[](size_t);</span>
<span class="line-added">122     const iterator operator[](size_t) const;</span>
<span class="line-added">123 </span>
124     void mergeAndClear(Bitmap&amp;);
125     void setAndClear(Bitmap&amp;);
126 
127     bool operator==(const Bitmap&amp;) const;
128     bool operator!=(const Bitmap&amp;) const;
129 
130     unsigned hash() const;
131 
132 private:
<a name="5" id="anc5"></a><span class="line-modified">133     static constexpr unsigned wordSize = sizeof(WordType) * 8;</span>
<span class="line-modified">134     static constexpr unsigned words = (bitmapSize + wordSize - 1) / wordSize;</span>
135 
136     // the literal &#39;1&#39; is of type signed int.  We want to use an unsigned
137     // version of the correct size when doing the calculations because if
138     // WordType is larger than int, &#39;1 &lt;&lt; 31&#39; will first be sign extended
139     // and then casted to unsigned, meaning that set(31) when WordType is
140     // a 64 bit unsigned int would give 0xffff8000
<a name="6" id="anc6"></a><span class="line-modified">141     static constexpr WordType one = 1;</span>
142 
143     std::array&lt;WordType, words&gt; bits;
144 };
145 
146 template&lt;size_t bitmapSize, typename WordType&gt;
147 constexpr Bitmap&lt;bitmapSize, WordType&gt;::Bitmap()
148 {
149     clearAll();
150 }
151 
152 template&lt;size_t bitmapSize, typename WordType&gt;
153 inline bool Bitmap&lt;bitmapSize, WordType&gt;::get(size_t n, Dependency dependency) const
154 {
155     return !!(dependency.consume(this)-&gt;bits[n / wordSize] &amp; (one &lt;&lt; (n % wordSize)));
156 }
157 
158 template&lt;size_t bitmapSize, typename WordType&gt;
159 inline void Bitmap&lt;bitmapSize, WordType&gt;::set(size_t n)
160 {
161     bits[n / wordSize] |= (one &lt;&lt; (n % wordSize));
162 }
163 
164 template&lt;size_t bitmapSize, typename WordType&gt;
165 inline void Bitmap&lt;bitmapSize, WordType&gt;::set(size_t n, bool value)
166 {
167     if (value)
168         set(n);
169     else
170         clear(n);
171 }
172 
173 template&lt;size_t bitmapSize, typename WordType&gt;
174 inline bool Bitmap&lt;bitmapSize, WordType&gt;::testAndSet(size_t n)
175 {
176     WordType mask = one &lt;&lt; (n % wordSize);
177     size_t index = n / wordSize;
178     bool result = bits[index] &amp; mask;
179     bits[index] |= mask;
180     return result;
181 }
182 
183 template&lt;size_t bitmapSize, typename WordType&gt;
184 inline bool Bitmap&lt;bitmapSize, WordType&gt;::testAndClear(size_t n)
185 {
186     WordType mask = one &lt;&lt; (n % wordSize);
187     size_t index = n / wordSize;
188     bool result = bits[index] &amp; mask;
189     bits[index] &amp;= ~mask;
190     return result;
191 }
192 
193 template&lt;size_t bitmapSize, typename WordType&gt;
194 ALWAYS_INLINE bool Bitmap&lt;bitmapSize, WordType&gt;::concurrentTestAndSet(size_t n, Dependency dependency)
195 {
196     WordType mask = one &lt;&lt; (n % wordSize);
197     size_t index = n / wordSize;
198     WordType* data = dependency.consume(bits.data()) + index;
199     return !bitwise_cast&lt;Atomic&lt;WordType&gt;*&gt;(data)-&gt;transactionRelaxed(
200         [&amp;] (WordType&amp; value) -&gt; bool {
201             if (value &amp; mask)
202                 return false;
203 
204             value |= mask;
205             return true;
206         });
207 }
208 
209 template&lt;size_t bitmapSize, typename WordType&gt;
210 ALWAYS_INLINE bool Bitmap&lt;bitmapSize, WordType&gt;::concurrentTestAndClear(size_t n, Dependency dependency)
211 {
212     WordType mask = one &lt;&lt; (n % wordSize);
213     size_t index = n / wordSize;
214     WordType* data = dependency.consume(bits.data()) + index;
215     return !bitwise_cast&lt;Atomic&lt;WordType&gt;*&gt;(data)-&gt;transactionRelaxed(
216         [&amp;] (WordType&amp; value) -&gt; bool {
217             if (!(value &amp; mask))
218                 return false;
219 
220             value &amp;= ~mask;
221             return true;
222         });
223 }
224 
225 template&lt;size_t bitmapSize, typename WordType&gt;
226 inline void Bitmap&lt;bitmapSize, WordType&gt;::clear(size_t n)
227 {
228     bits[n / wordSize] &amp;= ~(one &lt;&lt; (n % wordSize));
229 }
230 
231 template&lt;size_t bitmapSize, typename WordType&gt;
232 inline void Bitmap&lt;bitmapSize, WordType&gt;::clearAll()
233 {
234     memset(bits.data(), 0, sizeof(bits));
235 }
236 
<a name="7" id="anc7"></a><span class="line-added">237 template&lt;size_t bitmapSize, typename WordType&gt;</span>
<span class="line-added">238 inline void Bitmap&lt;bitmapSize, WordType&gt;::invert()</span>
<span class="line-added">239 {</span>
<span class="line-added">240     for (size_t i = 0; i &lt; words; ++i)</span>
<span class="line-added">241         bits[i] = ~bits[i];</span>
<span class="line-added">242 }</span>
<span class="line-added">243 </span>
244 template&lt;size_t bitmapSize, typename WordType&gt;
245 inline size_t Bitmap&lt;bitmapSize, WordType&gt;::nextPossiblyUnset(size_t start) const
246 {
247     if (!~bits[start / wordSize])
248         return ((start / wordSize) + 1) * wordSize;
249     return start + 1;
250 }
251 
252 template&lt;size_t bitmapSize, typename WordType&gt;
253 inline int64_t Bitmap&lt;bitmapSize, WordType&gt;::findRunOfZeros(size_t runLength) const
254 {
255     if (!runLength)
256         runLength = 1;
257 
258     for (size_t i = 0; i &lt;= (bitmapSize - runLength) ; i++) {
259         bool found = true;
260         for (size_t j = i; j &lt;= (i + runLength - 1) ; j++) {
261             if (get(j)) {
262                 found = false;
263                 break;
264             }
265         }
266         if (found)
267             return i;
268     }
269     return -1;
270 }
271 
272 template&lt;size_t bitmapSize, typename WordType&gt;
273 inline size_t Bitmap&lt;bitmapSize, WordType&gt;::count(size_t start) const
274 {
275     size_t result = 0;
276     for ( ; (start % wordSize); ++start) {
277         if (get(start))
278             ++result;
279     }
280     for (size_t i = start / wordSize; i &lt; words; ++i)
281         result += WTF::bitCount(static_cast&lt;unsigned&gt;(bits[i]));
282     return result;
283 }
284 
285 template&lt;size_t bitmapSize, typename WordType&gt;
286 inline size_t Bitmap&lt;bitmapSize, WordType&gt;::isEmpty() const
287 {
288     for (size_t i = 0; i &lt; words; ++i)
289         if (bits[i])
290             return false;
291     return true;
292 }
293 
294 template&lt;size_t bitmapSize, typename WordType&gt;
295 inline size_t Bitmap&lt;bitmapSize, WordType&gt;::isFull() const
296 {
297     for (size_t i = 0; i &lt; words; ++i)
298         if (~bits[i])
299             return false;
300     return true;
301 }
302 
303 template&lt;size_t bitmapSize, typename WordType&gt;
304 inline void Bitmap&lt;bitmapSize, WordType&gt;::merge(const Bitmap&amp; other)
305 {
306     for (size_t i = 0; i &lt; words; ++i)
307         bits[i] |= other.bits[i];
308 }
309 
310 template&lt;size_t bitmapSize, typename WordType&gt;
311 inline void Bitmap&lt;bitmapSize, WordType&gt;::filter(const Bitmap&amp; other)
312 {
313     for (size_t i = 0; i &lt; words; ++i)
314         bits[i] &amp;= other.bits[i];
315 }
316 
317 template&lt;size_t bitmapSize, typename WordType&gt;
318 inline void Bitmap&lt;bitmapSize, WordType&gt;::exclude(const Bitmap&amp; other)
319 {
320     for (size_t i = 0; i &lt; words; ++i)
321         bits[i] &amp;= ~other.bits[i];
322 }
323 
324 template&lt;size_t bitmapSize, typename WordType&gt;
325 inline void Bitmap&lt;bitmapSize, WordType&gt;::concurrentFilter(const Bitmap&amp; other)
326 {
327     for (size_t i = 0; i &lt; words; ++i) {
328         for (;;) {
329             WordType otherBits = other.bits[i];
330             if (!otherBits) {
331                 bits[i] = 0;
332                 break;
333             }
334             WordType oldBits = bits[i];
335             WordType filteredBits = oldBits &amp; otherBits;
336             if (oldBits == filteredBits)
337                 break;
338             if (atomicCompareExchangeWeakRelaxed(&amp;bits[i], oldBits, filteredBits))
339                 break;
340         }
341     }
342 }
343 
344 template&lt;size_t bitmapSize, typename WordType&gt;
345 inline bool Bitmap&lt;bitmapSize, WordType&gt;::subsumes(const Bitmap&amp; other) const
346 {
347     for (size_t i = 0; i &lt; words; ++i) {
348         WordType myBits = bits[i];
349         WordType otherBits = other.bits[i];
350         if ((myBits | otherBits) != myBits)
351             return false;
352     }
353     return true;
354 }
355 
356 template&lt;size_t bitmapSize, typename WordType&gt;
357 template&lt;typename Func&gt;
358 inline void Bitmap&lt;bitmapSize, WordType&gt;::forEachSetBit(const Func&amp; func) const
359 {
360     for (size_t i = 0; i &lt; words; ++i) {
361         WordType word = bits[i];
362         if (!word)
363             continue;
364         size_t base = i * wordSize;
365         for (size_t j = 0; j &lt; wordSize; ++j) {
366             if (word &amp; 1)
367                 func(base + j);
368             word &gt;&gt;= 1;
369         }
370     }
371 }
372 
373 template&lt;size_t bitmapSize, typename WordType&gt;
374 inline size_t Bitmap&lt;bitmapSize, WordType&gt;::findBit(size_t startIndex, bool value) const
375 {
376     WordType skipValue = -(static_cast&lt;WordType&gt;(value) ^ 1);
377     size_t wordIndex = startIndex / wordSize;
378     size_t startIndexInWord = startIndex - wordIndex * wordSize;
379 
380     while (wordIndex &lt; words) {
381         WordType word = bits[wordIndex];
382         if (word != skipValue) {
383             size_t index = startIndexInWord;
384             if (findBitInWord(word, index, wordSize, value))
385                 return wordIndex * wordSize + index;
386         }
387 
388         wordIndex++;
389         startIndexInWord = 0;
390     }
391 
392     return bitmapSize;
393 }
394 
395 template&lt;size_t bitmapSize, typename WordType&gt;
396 inline void Bitmap&lt;bitmapSize, WordType&gt;::mergeAndClear(Bitmap&amp; other)
397 {
398     for (size_t i = 0; i &lt; words; ++i) {
399         bits[i] |= other.bits[i];
400         other.bits[i] = 0;
401     }
402 }
403 
404 template&lt;size_t bitmapSize, typename WordType&gt;
405 inline void Bitmap&lt;bitmapSize, WordType&gt;::setAndClear(Bitmap&amp; other)
406 {
407     for (size_t i = 0; i &lt; words; ++i) {
408         bits[i] = other.bits[i];
409         other.bits[i] = 0;
410     }
411 }
412 
413 template&lt;size_t bitmapSize, typename WordType&gt;
414 inline bool Bitmap&lt;bitmapSize, WordType&gt;::operator==(const Bitmap&amp; other) const
415 {
416     for (size_t i = 0; i &lt; words; ++i) {
417         if (bits[i] != other.bits[i])
418             return false;
419     }
420     return true;
421 }
422 
423 template&lt;size_t bitmapSize, typename WordType&gt;
424 inline bool Bitmap&lt;bitmapSize, WordType&gt;::operator!=(const Bitmap&amp; other) const
425 {
426     return !(*this == other);
427 }
428 
<a name="8" id="anc8"></a><span class="line-added">429 template&lt;size_t bitmapSize, typename WordType&gt;</span>
<span class="line-added">430 inline auto Bitmap&lt;bitmapSize, WordType&gt;::operator[](size_t index) -&gt; iterator</span>
<span class="line-added">431 {</span>
<span class="line-added">432     ASSERT(index &lt; size());</span>
<span class="line-added">433     return iterator(*this, index);</span>
<span class="line-added">434 }</span>
<span class="line-added">435 </span>
<span class="line-added">436 template&lt;size_t bitmapSize, typename WordType&gt;</span>
<span class="line-added">437 inline auto Bitmap&lt;bitmapSize, WordType&gt;::operator[](size_t index) const -&gt; const iterator</span>
<span class="line-added">438 {</span>
<span class="line-added">439     return (*const_cast&lt;Bitmap&lt;bitmapSize, WordType&gt;*&gt;(this))[index];</span>
<span class="line-added">440 }</span>
<span class="line-added">441 </span>
442 template&lt;size_t bitmapSize, typename WordType&gt;
443 inline unsigned Bitmap&lt;bitmapSize, WordType&gt;::hash() const
444 {
445     unsigned result = 0;
446     for (size_t i = 0; i &lt; words; ++i)
447         result ^= IntHash&lt;WordType&gt;::hash(bits[i]);
448     return result;
449 }
450 
451 } // namespace WTF
452 
453 using WTF::Bitmap;
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyInstance.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSWebAssemblyHelpers.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSWebAssemblyInstance.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyInstance.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,11 ***</span>
  #include &quot;JSWebAssemblyHelpers.h&quot;
  #include &quot;JSWebAssemblyLinkError.h&quot;
  #include &quot;JSWebAssemblyMemory.h&quot;
  #include &quot;JSWebAssemblyModule.h&quot;
  #include &quot;WebAssemblyModuleRecord.h&quot;
<span class="line-removed">- #include &quot;WebAssemblyToJSCallee.h&quot;</span>
  #include &lt;wtf/StdLibExtras.h&gt;
  
  namespace JSC {
  
  const ClassInfo JSWebAssemblyInstance::s_info = { &quot;WebAssembly.Instance&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSWebAssemblyInstance) };
<span class="line-new-header">--- 35,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 51,10 ***</span>
<span class="line-new-header">--- 50,11 ---</span>
  
  JSWebAssemblyInstance::JSWebAssemblyInstance(VM&amp; vm, Structure* structure, Ref&lt;Wasm::Instance&gt;&amp;&amp; instance)
      : Base(vm, structure)
      , m_instance(WTFMove(instance))
      , m_vm(&amp;vm)
<span class="line-added">+     , m_globalObject(vm, this, structure-&gt;globalObject())</span>
      , m_tables(m_instance-&gt;module().moduleInformation().tableCount())
  {
      for (unsigned i = 0; i &lt; this-&gt;instance().numImportFunctions(); ++i)
          new (this-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(i)) WriteBarrier&lt;JSObject&gt;();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,11 ***</span>
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
  
      m_module.set(vm, this, module);
      m_moduleNamespaceObject.set(vm, this, moduleNamespaceObject);
<span class="line-removed">-     m_callee.set(vm, this, module-&gt;callee());</span>
  
      vm.heap.reportExtraMemoryAllocated(m_instance-&gt;extraMemoryAllocated());
  }
  
  void JSWebAssemblyInstance::destroy(JSCell* cell)
<span class="line-new-header">--- 64,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,31 ***</span>
      visitor.append(thisObject-&gt;m_codeBlock);
      visitor.append(thisObject-&gt;m_moduleNamespaceObject);
      visitor.append(thisObject-&gt;m_memory);
      for (unsigned i = 0; i &lt; thisObject-&gt;instance().module().moduleInformation().tableCount(); ++i)
          visitor.append(thisObject-&gt;m_tables[i]);
<span class="line-removed">-     visitor.append(thisObject-&gt;m_callee);</span>
      visitor.reportExtraMemoryVisited(thisObject-&gt;m_instance-&gt;extraMemoryAllocated());
      for (unsigned i = 0; i &lt; thisObject-&gt;instance().numImportFunctions(); ++i)
          visitor.append(*thisObject-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(i)); // This also keeps the functions&#39; JSWebAssemblyInstance alive.
  
      for (size_t i : thisObject-&gt;instance().globalsToMark())
          visitor.appendUnbarriered(JSValue::decode(thisObject-&gt;instance().loadI64Global(i)));
  
      auto locker = holdLock(cell-&gt;cellLock());
      for (auto&amp; wrapper : thisObject-&gt;instance().functionWrappers())
          visitor.appendUnbarriered(wrapper.get());
  }
  
<span class="line-modified">! void JSWebAssemblyInstance::finalizeCreation(VM&amp; vm, ExecState* exec, Ref&lt;Wasm::CodeBlock&gt;&amp;&amp; wasmCodeBlock, JSObject* importObject, Wasm::CreationMode creationMode)</span>
  {
      m_instance-&gt;finalizeCreation(this, wasmCodeBlock.copyRef());
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!wasmCodeBlock-&gt;runnable()) {
<span class="line-modified">!         throwException(exec, scope, JSWebAssemblyLinkError::create(exec, vm, globalObject(vm)-&gt;webAssemblyLinkErrorStructure(), wasmCodeBlock-&gt;errorMessage()));</span>
          return;
      }
  
      RELEASE_ASSERT(wasmCodeBlock-&gt;isSafeToRun(memoryMode()));
      JSWebAssemblyCodeBlock* jsCodeBlock = m_module-&gt;codeBlock(memoryMode());
<span class="line-new-header">--- 85,35 ---</span>
      visitor.append(thisObject-&gt;m_codeBlock);
      visitor.append(thisObject-&gt;m_moduleNamespaceObject);
      visitor.append(thisObject-&gt;m_memory);
      for (unsigned i = 0; i &lt; thisObject-&gt;instance().module().moduleInformation().tableCount(); ++i)
          visitor.append(thisObject-&gt;m_tables[i]);
      visitor.reportExtraMemoryVisited(thisObject-&gt;m_instance-&gt;extraMemoryAllocated());
      for (unsigned i = 0; i &lt; thisObject-&gt;instance().numImportFunctions(); ++i)
          visitor.append(*thisObject-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(i)); // This also keeps the functions&#39; JSWebAssemblyInstance alive.
  
<span class="line-added">+     for (size_t i : thisObject-&gt;instance().globalsToBinding()) {</span>
<span class="line-added">+         Wasm::Global* binding = thisObject-&gt;instance().getGlobalBinding(i);</span>
<span class="line-added">+         if (binding)</span>
<span class="line-added">+             visitor.appendUnbarriered(binding-&gt;owner&lt;JSWebAssemblyGlobal&gt;());</span>
<span class="line-added">+     }</span>
      for (size_t i : thisObject-&gt;instance().globalsToMark())
          visitor.appendUnbarriered(JSValue::decode(thisObject-&gt;instance().loadI64Global(i)));
  
      auto locker = holdLock(cell-&gt;cellLock());
      for (auto&amp; wrapper : thisObject-&gt;instance().functionWrappers())
          visitor.appendUnbarriered(wrapper.get());
  }
  
<span class="line-modified">! void JSWebAssemblyInstance::finalizeCreation(VM&amp; vm, JSGlobalObject* globalObject, Ref&lt;Wasm::CodeBlock&gt;&amp;&amp; wasmCodeBlock, JSObject* importObject, Wasm::CreationMode creationMode)</span>
  {
      m_instance-&gt;finalizeCreation(this, wasmCodeBlock.copyRef());
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!wasmCodeBlock-&gt;runnable()) {
<span class="line-modified">!         throwException(globalObject, scope, JSWebAssemblyLinkError::create(globalObject, vm, this-&gt;globalObject()-&gt;webAssemblyLinkErrorStructure(), wasmCodeBlock-&gt;errorMessage()));</span>
          return;
      }
  
      RELEASE_ASSERT(wasmCodeBlock-&gt;isSafeToRun(memoryMode()));
      JSWebAssemblyCodeBlock* jsCodeBlock = m_module-&gt;codeBlock(memoryMode());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,11 ***</span>
          ASSERT(&amp;jsCodeBlock-&gt;codeBlock() == wasmCodeBlock.ptr());
          m_codeBlock.set(vm, this, jsCodeBlock);
      } else {
          jsCodeBlock = JSWebAssemblyCodeBlock::create(vm, WTFMove(wasmCodeBlock), module()-&gt;module().moduleInformation());
          if (UNLIKELY(!jsCodeBlock-&gt;runnable())) {
<span class="line-modified">!             throwException(exec, scope, JSWebAssemblyLinkError::create(exec, vm, globalObject(vm)-&gt;webAssemblyLinkErrorStructure(), jsCodeBlock-&gt;errorMessage()));</span>
              return;
          }
          m_codeBlock.set(vm, this, jsCodeBlock);
          m_module-&gt;setCodeBlock(vm, memoryMode(), jsCodeBlock);
      }
<span class="line-new-header">--- 125,11 ---</span>
          ASSERT(&amp;jsCodeBlock-&gt;codeBlock() == wasmCodeBlock.ptr());
          m_codeBlock.set(vm, this, jsCodeBlock);
      } else {
          jsCodeBlock = JSWebAssemblyCodeBlock::create(vm, WTFMove(wasmCodeBlock), module()-&gt;module().moduleInformation());
          if (UNLIKELY(!jsCodeBlock-&gt;runnable())) {
<span class="line-modified">!             throwException(globalObject, scope, JSWebAssemblyLinkError::create(globalObject, vm, this-&gt;globalObject()-&gt;webAssemblyLinkErrorStructure(), jsCodeBlock-&gt;errorMessage()));</span>
              return;
          }
          m_codeBlock.set(vm, this, jsCodeBlock);
          m_module-&gt;setCodeBlock(vm, memoryMode(), jsCodeBlock);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,50 ***</span>
  
      auto* moduleRecord = jsCast&lt;WebAssemblyModuleRecord*&gt;(m_moduleNamespaceObject-&gt;moduleRecord());
      moduleRecord-&gt;prepareLink(vm, this);
  
      if (creationMode == Wasm::CreationMode::FromJS) {
<span class="line-modified">!         moduleRecord-&gt;link(exec, jsNull(), importObject, creationMode);</span>
          RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!         JSValue startResult = moduleRecord-&gt;evaluate(exec);</span>
          UNUSED_PARAM(startResult);
          RETURN_IF_EXCEPTION(scope, void());
      }
  }
  
  Identifier JSWebAssemblyInstance::createPrivateModuleKey()
  {
      return Identifier::fromUid(PrivateName(PrivateName::Description, &quot;WebAssemblyInstance&quot;));
  }
  
<span class="line-modified">! JSWebAssemblyInstance* JSWebAssemblyInstance::create(VM&amp; vm, ExecState* exec, const Identifier&amp; moduleKey, JSWebAssemblyModule* jsModule, JSObject* importObject, Structure* instanceStructure, Ref&lt;Wasm::Module&gt;&amp;&amp; module, Wasm::CreationMode creationMode)</span>
  {
      auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-removed">-     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
  
      const Wasm::ModuleInformation&amp; moduleInformation = jsModule-&gt;moduleInformation();
  
      auto exception = [&amp;] (JSObject* error) {
<span class="line-modified">!         throwException(exec, throwScope, error);</span>
          return nullptr;
      };
  
      if (!globalObject-&gt;webAssemblyEnabled())
<span class="line-modified">!         return exception(createEvalError(exec, globalObject-&gt;webAssemblyDisabledErrorMessage()));</span>
  
      auto importFailMessage = [&amp;] (const Wasm::Import&amp; import, const char* before, const char* after) {
          return makeString(before, &quot; &quot;, String::fromUTF8(import.module), &quot;:&quot;, String::fromUTF8(import.field), &quot; &quot;, after);
      };
  
<span class="line-modified">!     WebAssemblyModuleRecord* moduleRecord = WebAssemblyModuleRecord::create(exec, vm, globalObject-&gt;webAssemblyModuleRecordStructure(), moduleKey, moduleInformation);</span>
      RETURN_IF_EXCEPTION(throwScope, nullptr);
  
<span class="line-modified">!     JSModuleNamespaceObject* moduleNamespace = moduleRecord-&gt;getModuleNamespace(exec);</span>
  
      auto storeTopCallFrame = [&amp;vm] (void* topCallFrame) {
<span class="line-modified">!         vm.topCallFrame = bitwise_cast&lt;ExecState*&gt;(topCallFrame);</span>
      };
  
      // FIXME: These objects could be pretty big we should try to throw OOM here.
      auto* jsInstance = new (NotNull, allocateCell&lt;JSWebAssemblyInstance&gt;(vm.heap)) JSWebAssemblyInstance(vm, instanceStructure,
          Wasm::Instance::create(&amp;vm.wasmContext, WTFMove(module), &amp;vm.topEntryFrame, vm.addressOfSoftStackLimit(), WTFMove(storeTopCallFrame)));
<span class="line-new-header">--- 141,49 ---</span>
  
      auto* moduleRecord = jsCast&lt;WebAssemblyModuleRecord*&gt;(m_moduleNamespaceObject-&gt;moduleRecord());
      moduleRecord-&gt;prepareLink(vm, this);
  
      if (creationMode == Wasm::CreationMode::FromJS) {
<span class="line-modified">!         moduleRecord-&gt;link(globalObject, jsNull(), importObject, creationMode);</span>
          RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!         JSValue startResult = moduleRecord-&gt;evaluate(globalObject);</span>
          UNUSED_PARAM(startResult);
          RETURN_IF_EXCEPTION(scope, void());
      }
  }
  
  Identifier JSWebAssemblyInstance::createPrivateModuleKey()
  {
      return Identifier::fromUid(PrivateName(PrivateName::Description, &quot;WebAssemblyInstance&quot;));
  }
  
<span class="line-modified">! JSWebAssemblyInstance* JSWebAssemblyInstance::tryCreate(VM&amp; vm, JSGlobalObject* globalObject, const Identifier&amp; moduleKey, JSWebAssemblyModule* jsModule, JSObject* importObject, Structure* instanceStructure, Ref&lt;Wasm::Module&gt;&amp;&amp; module, Wasm::CreationMode creationMode)</span>
  {
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      const Wasm::ModuleInformation&amp; moduleInformation = jsModule-&gt;moduleInformation();
  
      auto exception = [&amp;] (JSObject* error) {
<span class="line-modified">!         throwException(globalObject, throwScope, error);</span>
          return nullptr;
      };
  
      if (!globalObject-&gt;webAssemblyEnabled())
<span class="line-modified">!         return exception(createEvalError(globalObject, globalObject-&gt;webAssemblyDisabledErrorMessage()));</span>
  
      auto importFailMessage = [&amp;] (const Wasm::Import&amp; import, const char* before, const char* after) {
          return makeString(before, &quot; &quot;, String::fromUTF8(import.module), &quot;:&quot;, String::fromUTF8(import.field), &quot; &quot;, after);
      };
  
<span class="line-modified">!     WebAssemblyModuleRecord* moduleRecord = WebAssemblyModuleRecord::create(globalObject, vm, globalObject-&gt;webAssemblyModuleRecordStructure(), moduleKey, moduleInformation);</span>
      RETURN_IF_EXCEPTION(throwScope, nullptr);
  
<span class="line-modified">!     JSModuleNamespaceObject* moduleNamespace = moduleRecord-&gt;getModuleNamespace(globalObject);</span>
  
      auto storeTopCallFrame = [&amp;vm] (void* topCallFrame) {
<span class="line-modified">!         vm.topCallFrame = bitwise_cast&lt;CallFrame*&gt;(topCallFrame);</span>
      };
  
      // FIXME: These objects could be pretty big we should try to throw OOM here.
      auto* jsInstance = new (NotNull, allocateCell&lt;JSWebAssemblyInstance&gt;(vm.heap)) JSWebAssemblyInstance(vm, instanceStructure,
          Wasm::Instance::create(&amp;vm.wasmContext, WTFMove(module), &amp;vm.topEntryFrame, vm.addressOfSoftStackLimit(), WTFMove(storeTopCallFrame)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,11 ***</span>
      bool hasMemoryImport = false;
  
      if (creationMode == Wasm::CreationMode::FromJS) {
          // If the list of module.imports is not empty and Type(importObject) is not Object, a TypeError is thrown.
          if (moduleInformation.imports.size() &amp;&amp; !importObject)
<span class="line-modified">!             return exception(createTypeError(exec, &quot;can&#39;t make WebAssembly.Instance because there is no imports Object and the WebAssembly.Module requires imports&quot;_s));</span>
      }
  
      // For each import i in module.imports:
      for (auto&amp; import : moduleInformation.imports) {
          Identifier moduleName = Identifier::fromString(vm, String::fromUTF8(import.module));
<span class="line-new-header">--- 195,11 ---</span>
      bool hasMemoryImport = false;
  
      if (creationMode == Wasm::CreationMode::FromJS) {
          // If the list of module.imports is not empty and Type(importObject) is not Object, a TypeError is thrown.
          if (moduleInformation.imports.size() &amp;&amp; !importObject)
<span class="line-modified">!             return exception(createTypeError(globalObject, &quot;can&#39;t make WebAssembly.Instance because there is no imports Object and the WebAssembly.Module requires imports&quot;_s));</span>
      }
  
      // For each import i in module.imports:
      for (auto&amp; import : moduleInformation.imports) {
          Identifier moduleName = Identifier::fromString(vm, String::fromUTF8(import.module));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 222,19 ***</span>
          }
  
          JSValue value;
          if (creationMode == Wasm::CreationMode::FromJS) {
              // 1. Let o be the resultant value of performing Get(importObject, i.module_name).
<span class="line-modified">!             JSValue importModuleValue = importObject-&gt;get(exec, moduleName);</span>
              RETURN_IF_EXCEPTION(throwScope, nullptr);
              // 2. If Type(o) is not Object, throw a TypeError.
              if (!importModuleValue.isObject())
<span class="line-modified">!                 return exception(createTypeError(exec, importFailMessage(import, &quot;import&quot;, &quot;must be an object&quot;), defaultSourceAppender, runtimeTypeForValue(vm, importModuleValue)));</span>
  
              // 3. Let v be the value of performing Get(o, i.item_name)
              JSObject* object = jsCast&lt;JSObject*&gt;(importModuleValue);
<span class="line-modified">!             value = object-&gt;get(exec, fieldName);</span>
              RETURN_IF_EXCEPTION(throwScope, nullptr);
          }
          if (!value)
              value = jsUndefined();
  
<span class="line-new-header">--- 224,19 ---</span>
          }
  
          JSValue value;
          if (creationMode == Wasm::CreationMode::FromJS) {
              // 1. Let o be the resultant value of performing Get(importObject, i.module_name).
<span class="line-modified">!             JSValue importModuleValue = importObject-&gt;get(globalObject, moduleName);</span>
              RETURN_IF_EXCEPTION(throwScope, nullptr);
              // 2. If Type(o) is not Object, throw a TypeError.
              if (!importModuleValue.isObject())
<span class="line-modified">!                 return exception(createTypeError(globalObject, importFailMessage(import, &quot;import&quot;, &quot;must be an object&quot;), defaultSourceAppender, runtimeTypeForValue(vm, importModuleValue)));</span>
  
              // 3. Let v be the value of performing Get(o, i.item_name)
              JSObject* object = jsCast&lt;JSObject*&gt;(importModuleValue);
<span class="line-modified">!             value = object-&gt;get(globalObject, fieldName);</span>
              RETURN_IF_EXCEPTION(throwScope, nullptr);
          }
          if (!value)
              value = jsUndefined();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 250,24 ***</span>
              RELEASE_ASSERT(moduleInformation.memory);
              hasMemoryImport = true;
              JSWebAssemblyMemory* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, value);
              // i. If v is not a WebAssembly.Memory object, throw a WebAssembly.LinkError.
              if (!memory)
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Memory import&quot;, &quot;is not an instance of WebAssembly.Memory&quot;)));</span>
  
              Wasm::PageCount declaredInitial = moduleInformation.memory.initial();
              Wasm::PageCount importedInitial = memory-&gt;memory().initial();
              if (importedInitial &lt; declaredInitial)
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Memory import&quot;, &quot;provided an &#39;initial&#39; that is smaller than the module&#39;s declared &#39;initial&#39; import memory size&quot;)));</span>
  
              if (Wasm::PageCount declaredMaximum = moduleInformation.memory.maximum()) {
                  Wasm::PageCount importedMaximum = memory-&gt;memory().maximum();
                  if (!importedMaximum)
<span class="line-modified">!                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Memory import&quot;, &quot;did not have a &#39;maximum&#39; but the module requires that it does&quot;)));</span>
  
                  if (importedMaximum &gt; declaredMaximum)
<span class="line-modified">!                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Memory import&quot;, &quot;provided a &#39;maximum&#39; that is larger than the module&#39;s declared &#39;maximum&#39; import memory size&quot;)));</span>
              }
  
              // ii. Append v to memories.
              // iii. Append v.[[Memory]] to imports.
              jsInstance-&gt;setMemory(vm, memory);
<span class="line-new-header">--- 252,24 ---</span>
              RELEASE_ASSERT(moduleInformation.memory);
              hasMemoryImport = true;
              JSWebAssemblyMemory* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, value);
              // i. If v is not a WebAssembly.Memory object, throw a WebAssembly.LinkError.
              if (!memory)
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Memory import&quot;, &quot;is not an instance of WebAssembly.Memory&quot;)));</span>
  
              Wasm::PageCount declaredInitial = moduleInformation.memory.initial();
              Wasm::PageCount importedInitial = memory-&gt;memory().initial();
              if (importedInitial &lt; declaredInitial)
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Memory import&quot;, &quot;provided an &#39;initial&#39; that is smaller than the module&#39;s declared &#39;initial&#39; import memory size&quot;)));</span>
  
              if (Wasm::PageCount declaredMaximum = moduleInformation.memory.maximum()) {
                  Wasm::PageCount importedMaximum = memory-&gt;memory().maximum();
                  if (!importedMaximum)
<span class="line-modified">!                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Memory import&quot;, &quot;did not have a &#39;maximum&#39; but the module requires that it does&quot;)));</span>
  
                  if (importedMaximum &gt; declaredMaximum)
<span class="line-modified">!                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Memory import&quot;, &quot;provided a &#39;maximum&#39; that is larger than the module&#39;s declared &#39;maximum&#39; import memory size&quot;)));</span>
              }
  
              // ii. Append v to memories.
              // iii. Append v.[[Memory]] to imports.
              jsInstance-&gt;setMemory(vm, memory);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,29 ***</span>
  
          if (moduleInformation.memory &amp;&amp; !hasMemoryImport) {
              // We create a memory when it&#39;s a memory definition.
              RELEASE_ASSERT(!moduleInformation.memory.isImport());
  
<span class="line-modified">!             auto* jsMemory = JSWebAssemblyMemory::create(exec, vm, globalObject-&gt;webAssemblyMemoryStructure());</span>
              RETURN_IF_EXCEPTION(throwScope, nullptr);
  
              RefPtr&lt;Wasm::Memory&gt; memory = Wasm::Memory::tryCreate(moduleInformation.memory.initial(), moduleInformation.memory.maximum(),
                  [&amp;vm] (Wasm::Memory::NotifyPressure) { vm.heap.collectAsync(CollectionScope::Full); },
                  [&amp;vm] (Wasm::Memory::SyncTryToReclaim) { vm.heap.collectSync(CollectionScope::Full); },
                  [&amp;vm, jsMemory] (Wasm::Memory::GrowSuccess, Wasm::PageCount oldPageCount, Wasm::PageCount newPageCount) { jsMemory-&gt;growSuccessCallback(vm, oldPageCount, newPageCount); });
              if (!memory)
<span class="line-modified">!                 return exception(createOutOfMemoryError(exec));</span>
  
              jsMemory-&gt;adopt(memory.releaseNonNull());
              jsInstance-&gt;setMemory(vm, jsMemory);
              RETURN_IF_EXCEPTION(throwScope, nullptr);
          }
      }
  
      if (!jsInstance-&gt;memory()) {
          // Make sure we have a dummy memory, so that wasm -&gt; wasm thunks avoid checking for a nullptr Memory when trying to set pinned registers.
<span class="line-modified">!         auto* jsMemory = JSWebAssemblyMemory::create(exec, vm, globalObject-&gt;webAssemblyMemoryStructure());</span>
          jsMemory-&gt;adopt(Wasm::Memory::create());
          jsInstance-&gt;setMemory(vm, jsMemory);
          RETURN_IF_EXCEPTION(throwScope, nullptr);
      }
  
<span class="line-new-header">--- 288,30 ---</span>
  
          if (moduleInformation.memory &amp;&amp; !hasMemoryImport) {
              // We create a memory when it&#39;s a memory definition.
              RELEASE_ASSERT(!moduleInformation.memory.isImport());
  
<span class="line-modified">!             auto* jsMemory = JSWebAssemblyMemory::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyMemoryStructure());</span>
              RETURN_IF_EXCEPTION(throwScope, nullptr);
  
              RefPtr&lt;Wasm::Memory&gt; memory = Wasm::Memory::tryCreate(moduleInformation.memory.initial(), moduleInformation.memory.maximum(),
                  [&amp;vm] (Wasm::Memory::NotifyPressure) { vm.heap.collectAsync(CollectionScope::Full); },
                  [&amp;vm] (Wasm::Memory::SyncTryToReclaim) { vm.heap.collectSync(CollectionScope::Full); },
                  [&amp;vm, jsMemory] (Wasm::Memory::GrowSuccess, Wasm::PageCount oldPageCount, Wasm::PageCount newPageCount) { jsMemory-&gt;growSuccessCallback(vm, oldPageCount, newPageCount); });
              if (!memory)
<span class="line-modified">!                 return exception(createOutOfMemoryError(globalObject));</span>
  
              jsMemory-&gt;adopt(memory.releaseNonNull());
              jsInstance-&gt;setMemory(vm, jsMemory);
              RETURN_IF_EXCEPTION(throwScope, nullptr);
          }
      }
  
      if (!jsInstance-&gt;memory()) {
          // Make sure we have a dummy memory, so that wasm -&gt; wasm thunks avoid checking for a nullptr Memory when trying to set pinned registers.
<span class="line-modified">!         auto* jsMemory = JSWebAssemblyMemory::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyMemoryStructure());</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
          jsMemory-&gt;adopt(Wasm::Memory::create());
          jsInstance-&gt;setMemory(vm, jsMemory);
          RETURN_IF_EXCEPTION(throwScope, nullptr);
      }
  
</pre>
<center><a href="JSWebAssemblyHelpers.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSWebAssemblyInstance.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
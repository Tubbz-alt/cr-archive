diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedBlock.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedBlock.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedBlock.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedBlock.cpp
@@ -40,15 +40,16 @@
 namespace JSC {
 namespace MarkedBlockInternal {
 static constexpr bool verbose = false;
 }
 
-const size_t MarkedBlock::blockSize;
-
-static const bool computeBalance = false;
+static constexpr bool computeBalance = false;
 static size_t balance;
 
+DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MarkedBlock);
+DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MarkedBlockHandle);
+
 MarkedBlock::Handle* MarkedBlock::tryCreate(Heap& heap, AlignedMemoryAllocator* alignedMemoryAllocator)
 {
     if (computeBalance) {
         balance++;
         if (!(balance % 10))
@@ -62,16 +63,14 @@
     return new Handle(heap, alignedMemoryAllocator, blockSpace);
 }
 
 MarkedBlock::Handle::Handle(Heap& heap, AlignedMemoryAllocator* alignedMemoryAllocator, void* blockSpace)
     : m_alignedMemoryAllocator(alignedMemoryAllocator)
-    , m_weakSet(heap.vm(), CellContainer())
+    , m_weakSet(heap.vm())
 {
     m_block = new (NotNull, blockSpace) MarkedBlock(heap.vm(), *this);
 
-    m_weakSet.setContainer(*m_block);
-
     heap.didAllocateBlock(blockSize);
 }
 
 MarkedBlock::Handle::~Handle()
 {
@@ -115,16 +114,10 @@
 {
     RELEASE_ASSERT(m_isFreeListed);
     m_isFreeListed = false;
 }
 
-void MarkedBlock::Handle::setIsFreeListed()
-{
-    m_directory->setIsEmpty(NoLockingNecessary, this, false);
-    m_isFreeListed = true;
-}
-
 void MarkedBlock::Handle::stopAllocating(const FreeList& freeList)
 {
     auto locker = holdLock(blockFooter().m_lock);
 
     if (MarkedBlockInternal::verbose)
@@ -149,11 +142,11 @@
 
     blockFooter().m_newlyAllocated.clearAll();
     blockFooter().m_newlyAllocatedVersion = heap()->objectSpace().newlyAllocatedVersion();
 
     forEachCell(
-        [&] (HeapCell* cell, HeapCell::Kind) -> IterationStatus {
+        [&] (size_t, HeapCell* cell, HeapCell::Kind) -> IterationStatus {
             block().setNewlyAllocated(cell);
             return IterationStatus::Continue;
         });
 
     freeList.forEach(
@@ -270,16 +263,16 @@
     if (areMarksStale())
         footer().m_marks.clearAll();
     footer().m_markingVersion = MarkedSpace::nullVersion;
 }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 void MarkedBlock::assertMarksNotStale()
 {
     ASSERT(footer().m_markingVersion == vm().heap.objectSpace().markingVersion());
 }
-#endif // !ASSERT_DISABLED
+#endif // ASSERT_ENABLED
 
 bool MarkedBlock::areMarksStale()
 {
     return areMarksStale(vm().heap.objectSpace().markingVersion());
 }
@@ -326,13 +319,13 @@
         return;
 
     m_directory->removeBlock(this);
 }
 
-void MarkedBlock::Handle::didAddToDirectory(BlockDirectory* directory, size_t index)
+void MarkedBlock::Handle::didAddToDirectory(BlockDirectory* directory, unsigned index)
 {
-    ASSERT(m_index == std::numeric_limits<size_t>::max());
+    ASSERT(m_index == std::numeric_limits<unsigned>::max());
     ASSERT(!m_directory);
 
     RELEASE_ASSERT(directory->subspace()->alignedMemoryAllocator() == m_alignedMemoryAllocator);
 
     m_index = index;
@@ -358,33 +351,33 @@
     blockFooter().m_biasedMarkCount = blockFooter().m_markCountBias = static_cast<int16_t>(markCountBias);
 }
 
 void MarkedBlock::Handle::didRemoveFromDirectory()
 {
-    ASSERT(m_index != std::numeric_limits<size_t>::max());
+    ASSERT(m_index != std::numeric_limits<unsigned>::max());
     ASSERT(m_directory);
 
-    m_index = std::numeric_limits<size_t>::max();
+    m_index = std::numeric_limits<unsigned>::max();
     m_directory = nullptr;
     blockFooter().m_subspace = nullptr;
 }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 void MarkedBlock::assertValidCell(VM& vm, HeapCell* cell) const
 {
     RELEASE_ASSERT(&vm == &this->vm());
     RELEASE_ASSERT(const_cast<MarkedBlock*>(this)->handle().cellAlign(cell) == cell);
 }
-#endif
+#endif // ASSERT_ENABLED
 
 void MarkedBlock::Handle::dumpState(PrintStream& out)
 {
     CommaPrinter comma;
     directory()->forEachBitVectorWithName(
         holdLock(directory()->bitvectorLock()),
-        [&] (FastBitVector& bitvector, const char* name) {
-            out.print(comma, name, ":", bitvector[index()] ? "YES" : "no");
+        [&](auto vectorRef, const char* name) {
+            out.print(comma, name, ":", vectorRef[index()] ? "YES" : "no");
         });
 }
 
 Subspace* MarkedBlock::Handle::subspace() const
 {

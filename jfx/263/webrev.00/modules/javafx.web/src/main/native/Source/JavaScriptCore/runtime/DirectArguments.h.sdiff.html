<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DirectArguments.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DirectEvalExecutable.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 33 namespace JSC {
 34 
 35 // This is an Arguments-class object that we create when you say &quot;arguments&quot; inside a function,
 36 // and none of the arguments are captured in the function&#39;s activation. The function will copy all
 37 // of its arguments into this object, and all subsequent accesses to the arguments will go through
 38 // this object thereafter. Special support is in place for mischevious events like the arguments
 39 // being deleted (something like &quot;delete arguments[0]&quot;) or reconfigured (broadly, we say deletions
 40 // and reconfigurations mean that the respective argument was &quot;overridden&quot;).
 41 //
 42 // To speed allocation, this object will hold all of the arguments in-place. The arguments as well
 43 // as a table of flags saying which arguments were overridden.
 44 class DirectArguments final : public GenericArguments&lt;DirectArguments&gt; {
 45 private:
 46     DirectArguments(VM&amp;, Structure*, unsigned length, unsigned capacity);
 47 
 48 public:
 49     template&lt;typename CellType, SubspaceAccess&gt;
 50     static CompleteSubspace* subspaceFor(VM&amp; vm)
 51     {
 52         static_assert(!CellType::needsDestruction, &quot;&quot;);
<span class="line-modified"> 53         return &amp;vm.jsValueGigacageCellSpace;</span>
 54     }
 55 
 56     // Creates an arguments object but leaves it uninitialized. This is dangerous if we GC right
 57     // after allocation.
 58     static DirectArguments* createUninitialized(VM&amp;, Structure*, unsigned length, unsigned capacity);
 59 
 60     // Creates an arguments object and initializes everything to the empty value. Use this if you
 61     // cannot guarantee that you&#39;ll immediately initialize all of the elements.
 62     static DirectArguments* create(VM&amp;, Structure*, unsigned length, unsigned capacity);
 63 
 64     // Creates an arguments object by copying the argumnets from the stack.
<span class="line-modified"> 65     static DirectArguments* createByCopying(ExecState*);</span>
 66 
 67     static size_t estimatedSize(JSCell*, VM&amp;);
 68     static void visitChildren(JSCell*, SlotVisitor&amp;);
 69 
 70     uint32_t internalLength() const
 71     {
 72         return m_length;
 73     }
 74 
<span class="line-modified"> 75     uint32_t length(ExecState* exec) const</span>
 76     {
 77         if (UNLIKELY(m_mappedArguments)) {
<span class="line-modified"> 78             VM&amp; vm = exec-&gt;vm();</span>
 79             auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 80             JSValue value = get(exec, vm.propertyNames-&gt;length);</span>
 81             RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified"> 82             RELEASE_AND_RETURN(scope, value.toUInt32(exec));</span>
 83         }
 84         return m_length;
 85     }
 86 
 87     bool isMappedArgument(uint32_t i) const
 88     {
 89         return i &lt; m_length &amp;&amp; (!m_mappedArguments || !m_mappedArguments.at(i, m_length));
 90     }
 91 
 92     bool isMappedArgumentInDFG(uint32_t i) const
 93     {
 94         return i &lt; m_length &amp;&amp; !overrodeThings();
 95     }
 96 
 97     JSValue getIndexQuickly(uint32_t i) const
 98     {
 99         ASSERT_WITH_SECURITY_IMPLICATION(isMappedArgument(i));
100         return const_cast&lt;DirectArguments*&gt;(this)-&gt;storage()[i].get();
101     }
102 
</pre>
<hr />
<pre>
108 
109     JSFunction* callee()
110     {
111         return m_callee.get();
112     }
113 
114     void setCallee(VM&amp; vm, JSFunction* function)
115     {
116         m_callee.set(vm, this, function);
117     }
118 
119     WriteBarrier&lt;Unknown&gt;&amp; argument(DirectArgumentsOffset offset)
120     {
121         ASSERT(offset);
122         ASSERT_WITH_SECURITY_IMPLICATION(offset.offset() &lt; std::max(m_length, m_minCapacity));
123         return storage()[offset.offset()];
124     }
125 
126     // Methods intended for use by the GenericArguments mixin.
127     bool overrodeThings() const { return !!m_mappedArguments; }
<span class="line-modified">128     void overrideThings(VM&amp;);</span>
<span class="line-modified">129     void overrideThingsIfNecessary(VM&amp;);</span>
<span class="line-modified">130     void unmapArgument(VM&amp;, unsigned index);</span>
131 
<span class="line-modified">132     void initModifiedArgumentsDescriptorIfNecessary(VM&amp; vm)</span>
133     {
<span class="line-modified">134         GenericArguments&lt;DirectArguments&gt;::initModifiedArgumentsDescriptorIfNecessary(vm, m_length);</span>
135     }
136 
<span class="line-modified">137     void setModifiedArgumentDescriptor(VM&amp; vm, unsigned index)</span>
138     {
<span class="line-modified">139         GenericArguments&lt;DirectArguments&gt;::setModifiedArgumentDescriptor(vm, index, m_length);</span>
140     }
141 
142     bool isModifiedArgumentDescriptor(unsigned index)
143     {
144         return GenericArguments&lt;DirectArguments&gt;::isModifiedArgumentDescriptor(index, m_length);
145     }
146 
<span class="line-modified">147     void copyToArguments(ExecState*, VirtualRegister firstElementDest, unsigned offset, unsigned length);</span>
148 
149     DECLARE_INFO;
150 
151     static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue prototype);
152 
153     static ptrdiff_t offsetOfCallee() { return OBJECT_OFFSETOF(DirectArguments, m_callee); }
154     static ptrdiff_t offsetOfLength() { return OBJECT_OFFSETOF(DirectArguments, m_length); }
155     static ptrdiff_t offsetOfMinCapacity() { return OBJECT_OFFSETOF(DirectArguments, m_minCapacity); }
156     static ptrdiff_t offsetOfMappedArguments() { return OBJECT_OFFSETOF(DirectArguments, m_mappedArguments); }
157     static ptrdiff_t offsetOfModifiedArgumentsDescriptor() { return OBJECT_OFFSETOF(DirectArguments, m_modifiedArgumentsDescriptor); }
158 
159     static size_t storageOffset()
160     {
161         return WTF::roundUpToMultipleOf&lt;sizeof(WriteBarrier&lt;Unknown&gt;)&gt;(sizeof(DirectArguments));
162     }
163 
164     static size_t offsetOfSlot(Checked&lt;size_t&gt; index)
165     {
166         return (storageOffset() + sizeof(WriteBarrier&lt;Unknown&gt;) * index).unsafeGet();
167     }
168 
169     static size_t allocationSize(Checked&lt;size_t&gt; capacity)
170     {
171         return offsetOfSlot(capacity);
172     }
173 
174 private:
175     WriteBarrier&lt;Unknown&gt;* storage()
176     {
177         return bitwise_cast&lt;WriteBarrier&lt;Unknown&gt;*&gt;(bitwise_cast&lt;char*&gt;(this) + storageOffset());
178     }
179 
180     unsigned mappedArgumentsSize();
181 
182     WriteBarrier&lt;JSFunction&gt; m_callee;
183     uint32_t m_length; // Always the actual length of captured arguments and never what was stored into the length property.
184     uint32_t m_minCapacity; // The max of this and length determines the capacity of this object. It may be the actual capacity, or maybe something smaller. We arrange it this way to be kind to the JITs.
185     using MappedArguments = CagedBarrierPtr&lt;Gigacage::Primitive, bool&gt;;
186     MappedArguments m_mappedArguments; // If non-null, it means that length, callee, and caller are fully materialized properties.


187 };
188 
189 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 33 namespace JSC {
 34 
 35 // This is an Arguments-class object that we create when you say &quot;arguments&quot; inside a function,
 36 // and none of the arguments are captured in the function&#39;s activation. The function will copy all
 37 // of its arguments into this object, and all subsequent accesses to the arguments will go through
 38 // this object thereafter. Special support is in place for mischevious events like the arguments
 39 // being deleted (something like &quot;delete arguments[0]&quot;) or reconfigured (broadly, we say deletions
 40 // and reconfigurations mean that the respective argument was &quot;overridden&quot;).
 41 //
 42 // To speed allocation, this object will hold all of the arguments in-place. The arguments as well
 43 // as a table of flags saying which arguments were overridden.
 44 class DirectArguments final : public GenericArguments&lt;DirectArguments&gt; {
 45 private:
 46     DirectArguments(VM&amp;, Structure*, unsigned length, unsigned capacity);
 47 
 48 public:
 49     template&lt;typename CellType, SubspaceAccess&gt;
 50     static CompleteSubspace* subspaceFor(VM&amp; vm)
 51     {
 52         static_assert(!CellType::needsDestruction, &quot;&quot;);
<span class="line-modified"> 53         return &amp;vm.variableSizedCellSpace;</span>
 54     }
 55 
 56     // Creates an arguments object but leaves it uninitialized. This is dangerous if we GC right
 57     // after allocation.
 58     static DirectArguments* createUninitialized(VM&amp;, Structure*, unsigned length, unsigned capacity);
 59 
 60     // Creates an arguments object and initializes everything to the empty value. Use this if you
 61     // cannot guarantee that you&#39;ll immediately initialize all of the elements.
 62     static DirectArguments* create(VM&amp;, Structure*, unsigned length, unsigned capacity);
 63 
 64     // Creates an arguments object by copying the argumnets from the stack.
<span class="line-modified"> 65     static DirectArguments* createByCopying(JSGlobalObject*, CallFrame*);</span>
 66 
 67     static size_t estimatedSize(JSCell*, VM&amp;);
 68     static void visitChildren(JSCell*, SlotVisitor&amp;);
 69 
 70     uint32_t internalLength() const
 71     {
 72         return m_length;
 73     }
 74 
<span class="line-modified"> 75     uint32_t length(JSGlobalObject* globalObject) const</span>
 76     {
 77         if (UNLIKELY(m_mappedArguments)) {
<span class="line-modified"> 78             VM&amp; vm = getVM(globalObject);</span>
 79             auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 80             JSValue value = get(globalObject, vm.propertyNames-&gt;length);</span>
 81             RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified"> 82             RELEASE_AND_RETURN(scope, value.toUInt32(globalObject));</span>
 83         }
 84         return m_length;
 85     }
 86 
 87     bool isMappedArgument(uint32_t i) const
 88     {
 89         return i &lt; m_length &amp;&amp; (!m_mappedArguments || !m_mappedArguments.at(i, m_length));
 90     }
 91 
 92     bool isMappedArgumentInDFG(uint32_t i) const
 93     {
 94         return i &lt; m_length &amp;&amp; !overrodeThings();
 95     }
 96 
 97     JSValue getIndexQuickly(uint32_t i) const
 98     {
 99         ASSERT_WITH_SECURITY_IMPLICATION(isMappedArgument(i));
100         return const_cast&lt;DirectArguments*&gt;(this)-&gt;storage()[i].get();
101     }
102 
</pre>
<hr />
<pre>
108 
109     JSFunction* callee()
110     {
111         return m_callee.get();
112     }
113 
114     void setCallee(VM&amp; vm, JSFunction* function)
115     {
116         m_callee.set(vm, this, function);
117     }
118 
119     WriteBarrier&lt;Unknown&gt;&amp; argument(DirectArgumentsOffset offset)
120     {
121         ASSERT(offset);
122         ASSERT_WITH_SECURITY_IMPLICATION(offset.offset() &lt; std::max(m_length, m_minCapacity));
123         return storage()[offset.offset()];
124     }
125 
126     // Methods intended for use by the GenericArguments mixin.
127     bool overrodeThings() const { return !!m_mappedArguments; }
<span class="line-modified">128     void overrideThings(JSGlobalObject*);</span>
<span class="line-modified">129     void overrideThingsIfNecessary(JSGlobalObject*);</span>
<span class="line-modified">130     void unmapArgument(JSGlobalObject*, unsigned index);</span>
131 
<span class="line-modified">132     void initModifiedArgumentsDescriptorIfNecessary(JSGlobalObject* globalObject)</span>
133     {
<span class="line-modified">134         GenericArguments&lt;DirectArguments&gt;::initModifiedArgumentsDescriptorIfNecessary(globalObject, m_length);</span>
135     }
136 
<span class="line-modified">137     void setModifiedArgumentDescriptor(JSGlobalObject* globalObject, unsigned index)</span>
138     {
<span class="line-modified">139         GenericArguments&lt;DirectArguments&gt;::setModifiedArgumentDescriptor(globalObject, index, m_length);</span>
140     }
141 
142     bool isModifiedArgumentDescriptor(unsigned index)
143     {
144         return GenericArguments&lt;DirectArguments&gt;::isModifiedArgumentDescriptor(index, m_length);
145     }
146 
<span class="line-modified">147     void copyToArguments(JSGlobalObject*, JSValue* firstElementDest, unsigned offset, unsigned length);</span>
148 
149     DECLARE_INFO;
150 
151     static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue prototype);
152 
153     static ptrdiff_t offsetOfCallee() { return OBJECT_OFFSETOF(DirectArguments, m_callee); }
154     static ptrdiff_t offsetOfLength() { return OBJECT_OFFSETOF(DirectArguments, m_length); }
155     static ptrdiff_t offsetOfMinCapacity() { return OBJECT_OFFSETOF(DirectArguments, m_minCapacity); }
156     static ptrdiff_t offsetOfMappedArguments() { return OBJECT_OFFSETOF(DirectArguments, m_mappedArguments); }
157     static ptrdiff_t offsetOfModifiedArgumentsDescriptor() { return OBJECT_OFFSETOF(DirectArguments, m_modifiedArgumentsDescriptor); }
158 
159     static size_t storageOffset()
160     {
161         return WTF::roundUpToMultipleOf&lt;sizeof(WriteBarrier&lt;Unknown&gt;)&gt;(sizeof(DirectArguments));
162     }
163 
164     static size_t offsetOfSlot(Checked&lt;size_t&gt; index)
165     {
166         return (storageOffset() + sizeof(WriteBarrier&lt;Unknown&gt;) * index).unsafeGet();
167     }
168 
169     static size_t allocationSize(Checked&lt;size_t&gt; capacity)
170     {
171         return offsetOfSlot(capacity);
172     }
173 
174 private:
175     WriteBarrier&lt;Unknown&gt;* storage()
176     {
177         return bitwise_cast&lt;WriteBarrier&lt;Unknown&gt;*&gt;(bitwise_cast&lt;char*&gt;(this) + storageOffset());
178     }
179 
180     unsigned mappedArgumentsSize();
181 
182     WriteBarrier&lt;JSFunction&gt; m_callee;
183     uint32_t m_length; // Always the actual length of captured arguments and never what was stored into the length property.
184     uint32_t m_minCapacity; // The max of this and length determines the capacity of this object. It may be the actual capacity, or maybe something smaller. We arrange it this way to be kind to the JITs.
185     using MappedArguments = CagedBarrierPtr&lt;Gigacage::Primitive, bool&gt;;
186     MappedArguments m_mappedArguments; // If non-null, it means that length, callee, and caller are fully materialized properties.
<span class="line-added">187 </span>
<span class="line-added">188     friend size_t cellSize(VM&amp;, JSCell*);</span>
189 };
190 
191 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="DirectArguments.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DirectEvalExecutable.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/CSSFontFaceSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CSSFontFaceSet.h&quot;
 28 
 29 #include &quot;CSSFontFaceSource.h&quot;
 30 #include &quot;CSSFontFamily.h&quot;
 31 #include &quot;CSSFontSelector.h&quot;
 32 #include &quot;CSSFontStyleValue.h&quot;
 33 #include &quot;CSSParser.h&quot;
 34 #include &quot;CSSPrimitiveValue.h&quot;
 35 #include &quot;CSSSegmentedFontFace.h&quot;
 36 #include &quot;CSSValueList.h&quot;
 37 #include &quot;CSSValuePool.h&quot;
 38 #include &quot;FontCache.h&quot;
 39 #include &quot;StyleBuilderConverter.h&quot;
 40 #include &quot;StyleProperties.h&quot;
 41 
 42 namespace WebCore {
 43 
 44 CSSFontFaceSet::CSSFontFaceSet(CSSFontSelector* owningFontSelector)
 45     : m_owningFontSelector(makeWeakPtr(owningFontSelector))
 46 {
 47 }
 48 
 49 CSSFontFaceSet::~CSSFontFaceSet()
 50 {
 51     for (auto&amp; face : m_faces)
 52         face-&gt;removeClient(*this);
 53 
 54     for (auto&amp; pair : m_locallyInstalledFacesLookupTable) {
 55         for (auto&amp; face : pair.value)
 56             face-&gt;removeClient(*this);
 57     }
 58 }
 59 
 60 void CSSFontFaceSet::addClient(CSSFontFaceSetClient&amp; client)
 61 {
 62     m_clients.add(&amp;client);
 63 }
 64 
 65 void CSSFontFaceSet::removeClient(CSSFontFaceSetClient&amp; client)
 66 {
 67     ASSERT(m_clients.contains(&amp;client));
 68     m_clients.remove(&amp;client);
 69 }
 70 
 71 void CSSFontFaceSet::incrementActiveCount()
 72 {
 73     ++m_activeCount;
 74     if (m_activeCount == 1) {
 75         m_status = Status::Loading;
 76         for (auto* client : m_clients)
 77             client-&gt;startedLoading();
 78     }
 79 }
 80 
 81 void CSSFontFaceSet::decrementActiveCount()
 82 {
 83     --m_activeCount;
 84     if (!m_activeCount) {
 85         m_status = Status::Loaded;
 86         for (auto* client : m_clients)
 87             client-&gt;completedLoading();
 88     }
 89 }
 90 
 91 bool CSSFontFaceSet::hasFace(const CSSFontFace&amp; face) const
 92 {
 93     for (auto&amp; myFace : m_faces) {
 94         if (myFace.ptr() == &amp;face)
 95             return true;
 96     }
 97 
 98     return false;
 99 }
100 
101 void CSSFontFaceSet::ensureLocalFontFacesForFamilyRegistered(const String&amp; familyName)
102 {
103     ASSERT(m_owningFontSelector);
104     if (m_locallyInstalledFacesLookupTable.contains(familyName))
105         return;
106 
107     AllowUserInstalledFonts allowUserInstalledFonts = AllowUserInstalledFonts::Yes;
108     if (m_owningFontSelector-&gt;document())
109         allowUserInstalledFonts = m_owningFontSelector-&gt;document()-&gt;settings().shouldAllowUserInstalledFonts() ? AllowUserInstalledFonts::Yes : AllowUserInstalledFonts::No;
110     Vector&lt;FontSelectionCapabilities&gt; capabilities = FontCache::singleton().getFontSelectionCapabilitiesInFamily(familyName, allowUserInstalledFonts);
111     if (capabilities.isEmpty())
112         return;
113 
114     Vector&lt;Ref&lt;CSSFontFace&gt;&gt; faces;
115     for (auto item : capabilities) {
116         Ref&lt;CSSFontFace&gt; face = CSSFontFace::create(m_owningFontSelector.get(), nullptr, nullptr, true);
117 
118         Ref&lt;CSSValueList&gt; familyList = CSSValueList::createCommaSeparated();
119         familyList-&gt;append(CSSValuePool::singleton().createFontFamilyValue(familyName));
120         face-&gt;setFamilies(familyList.get());
121         face-&gt;setFontSelectionCapabilities(item);
122         face-&gt;adoptSource(makeUnique&lt;CSSFontFaceSource&gt;(face.get(), familyName));
123         ASSERT(!face-&gt;computeFailureState());
124         faces.append(WTFMove(face));
125     }
126     m_locallyInstalledFacesLookupTable.add(familyName, WTFMove(faces));
127 }
128 
129 String CSSFontFaceSet::familyNameFromPrimitive(const CSSPrimitiveValue&amp; value)
130 {
131     if (value.isFontFamily())
132         return value.fontFamily().familyName;
133     if (!value.isValueID())
134         return { };
135 
136     // We need to use the raw text for all the generic family types, since @font-face is a way of actually
137     // defining what font to use for those types.
138     switch (value.valueID()) {
139     case CSSValueSerif:
140         return serifFamily.get();
141     case CSSValueSansSerif:
142         return sansSerifFamily.get();
143     case CSSValueCursive:
144         return cursiveFamily.get();
145     case CSSValueFantasy:
146         return fantasyFamily.get();
147     case CSSValueMonospace:
148         return monospaceFamily.get();
149     case CSSValueWebkitPictograph:
150         return pictographFamily.get();
151     case CSSValueSystemUi:
152         return systemUiFamily.get();
153     default:
154         return { };
155     }
156 }
157 
158 void CSSFontFaceSet::addToFacesLookupTable(CSSFontFace&amp; face)
159 {
<a name="1" id="anc1"></a><span class="line-modified">160     if (!face.families() || !face.families().hasValue())</span>
161         return;
<a name="2" id="anc2"></a><span class="line-added">162     auto families = face.families().value();</span>
163 
<a name="3" id="anc3"></a><span class="line-modified">164     for (auto&amp; item : *families) {</span>
165         String familyName = CSSFontFaceSet::familyNameFromPrimitive(downcast&lt;CSSPrimitiveValue&gt;(item.get()));
166         if (familyName.isEmpty())
167             continue;
168 
169         auto addResult = m_facesLookupTable.add(familyName, Vector&lt;Ref&lt;CSSFontFace&gt;&gt;());
170         auto&amp; familyFontFaces = addResult.iterator-&gt;value;
171         if (addResult.isNewEntry) {
172             // m_locallyInstalledFontFaces grows without bound, eventually encorporating every font installed on the system.
173             // This is by design.
174             if (m_owningFontSelector)
175                 ensureLocalFontFacesForFamilyRegistered(familyName);
176             familyFontFaces = { };
177         }
178 
179         familyFontFaces.append(face);
180     }
181 }
182 
183 void CSSFontFaceSet::add(CSSFontFace&amp; face)
184 {
185     ASSERT(!hasFace(face));
186 
187     for (auto* client : m_clients)
188         client-&gt;fontModified();
189 
190     face.addClient(*this);
191     m_cache.clear();
192 
193     if (face.cssConnection())
194         m_faces.insert(m_facesPartitionIndex++, face);
195     else
196         m_faces.append(face);
197 
198     addToFacesLookupTable(face);
199 
200     if (face.status() == CSSFontFace::Status::Loading || face.status() == CSSFontFace::Status::TimedOut)
201         incrementActiveCount();
202 
203     if (face.cssConnection()) {
204         ASSERT(!m_constituentCSSConnections.contains(face.cssConnection()));
205         m_constituentCSSConnections.add(face.cssConnection(), &amp;face);
206     }
207 }
208 
209 void CSSFontFaceSet::removeFromFacesLookupTable(const CSSFontFace&amp; face, const CSSValueList&amp; familiesToSearchFor)
210 {
211     for (auto&amp; item : familiesToSearchFor) {
212         String familyName = CSSFontFaceSet::familyNameFromPrimitive(downcast&lt;CSSPrimitiveValue&gt;(item.get()));
213         if (familyName.isEmpty())
214             continue;
215 
216         auto iterator = m_facesLookupTable.find(familyName);
217         ASSERT(iterator != m_facesLookupTable.end());
218         bool found = false;
219         for (size_t i = 0; i &lt; iterator-&gt;value.size(); ++i) {
220             if (iterator-&gt;value[i].ptr() == &amp;face) {
221                 found = true;
222                 iterator-&gt;value.remove(i);
223                 break;
224             }
225         }
226         ASSERT_UNUSED(found, found);
227         if (!iterator-&gt;value.size())
228             m_facesLookupTable.remove(iterator);
229     }
230 }
231 
232 void CSSFontFaceSet::remove(const CSSFontFace&amp; face)
233 {
234     auto protect = makeRef(face);
235 
236     m_cache.clear();
237 
238     for (auto* client : m_clients)
239         client-&gt;fontModified();
240 
<a name="4" id="anc4"></a><span class="line-modified">241     if (face.families() &amp;&amp; face.families().hasValue())</span>
<span class="line-modified">242         removeFromFacesLookupTable(face, *face.families().value());</span>
243 
244     if (face.cssConnection()) {
245         ASSERT(m_constituentCSSConnections.get(face.cssConnection()) == &amp;face);
246         m_constituentCSSConnections.remove(face.cssConnection());
247     }
248 
249     for (size_t i = 0; i &lt; m_faces.size(); ++i) {
250         if (m_faces[i].ptr() == &amp;face) {
251             if (i &lt; m_facesPartitionIndex)
252                 --m_facesPartitionIndex;
253             m_faces[i]-&gt;removeClient(*this);
254             m_faces.remove(i);
255             if (face.status() == CSSFontFace::Status::Loading || face.status() == CSSFontFace::Status::TimedOut)
256                 decrementActiveCount();
257             return;
258         }
259     }
260     ASSERT_NOT_REACHED();
261 }
262 
263 CSSFontFace* CSSFontFaceSet::lookUpByCSSConnection(StyleRuleFontFace&amp; target)
264 {
265     return m_constituentCSSConnections.get(&amp;target);
266 }
267 
268 void CSSFontFaceSet::purge()
269 {
270     Vector&lt;Ref&lt;CSSFontFace&gt;&gt; toRemove;
271     for (auto&amp; face : m_faces) {
272         if (face-&gt;purgeable())
273             toRemove.append(face.copyRef());
274     }
275 
276     for (auto&amp; item : toRemove)
277         remove(item.get());
278 }
279 
280 void CSSFontFaceSet::emptyCaches()
281 {
282     m_cache.clear();
283 }
284 
285 void CSSFontFaceSet::clear()
286 {
287     for (auto&amp; face : m_faces)
288         face-&gt;removeClient(*this);
289     m_faces.clear();
290     m_facesLookupTable.clear();
291     m_locallyInstalledFacesLookupTable.clear();
292     m_cache.clear();
293     m_constituentCSSConnections.clear();
294     m_facesPartitionIndex = 0;
295     m_status = Status::Loaded;
296 }
297 
298 CSSFontFace&amp; CSSFontFaceSet::operator[](size_t i)
299 {
300     ASSERT(i &lt; faceCount());
301     return m_faces[i];
302 }
303 
<a name="5" id="anc5"></a><span class="line-modified">304 static ExceptionOr&lt;FontSelectionRequest&gt; computeFontSelectionRequest(MutableStyleProperties&amp; style)</span>
305 {
306     RefPtr&lt;CSSValue&gt; weightValue = style.getPropertyCSSValue(CSSPropertyFontWeight).get();
<a name="6" id="anc6"></a><span class="line-modified">307     if (!weightValue || weightValue-&gt;isInitialValue())</span>
308         weightValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal).ptr();
309 
310     RefPtr&lt;CSSValue&gt; stretchValue = style.getPropertyCSSValue(CSSPropertyFontStretch).get();
<a name="7" id="anc7"></a><span class="line-modified">311     if (!stretchValue || stretchValue-&gt;isInitialValue())</span>
312         stretchValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal).ptr();
313 
314     RefPtr&lt;CSSValue&gt; styleValue = style.getPropertyCSSValue(CSSPropertyFontStyle).get();
<a name="8" id="anc8"></a><span class="line-modified">315     if (!styleValue || styleValue-&gt;isInitialValue())</span>
316         styleValue = CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueNormal));
317 
<a name="9" id="anc9"></a><span class="line-modified">318     if (weightValue-&gt;isGlobalKeyword() || stretchValue-&gt;isGlobalKeyword() || styleValue-&gt;isGlobalKeyword())</span>
<span class="line-modified">319         return Exception { SyntaxError };</span>
<span class="line-modified">320 </span>
<span class="line-added">321     auto weightSelectionValue = Style::BuilderConverter::convertFontWeightFromValue(*weightValue);</span>
<span class="line-added">322     auto stretchSelectionValue = Style::BuilderConverter::convertFontStretchFromValue(*stretchValue);</span>
<span class="line-added">323     auto styleSelectionValue = Style::BuilderConverter::convertFontStyleFromValue(*styleValue);</span>
324 
<a name="10" id="anc10"></a><span class="line-modified">325     return {{ weightSelectionValue, stretchSelectionValue, styleSelectionValue }};</span>
326 }
327 
328 static HashSet&lt;UChar32&gt; codePointsFromString(StringView stringView)
329 {
330     HashSet&lt;UChar32&gt; result;
331     auto graphemeClusters = stringView.graphemeClusters();
332     for (auto cluster : graphemeClusters) {
333         ASSERT(cluster.length() &gt; 0);
334         UChar32 character = 0;
335         if (cluster.is8Bit())
336             character = cluster[0];
337         else
338             U16_GET(cluster.characters16(), 0, 0, cluster.length(), character);
339         result.add(character);
340     }
341     return result;
342 }
343 
344 ExceptionOr&lt;Vector&lt;std::reference_wrapper&lt;CSSFontFace&gt;&gt;&gt; CSSFontFaceSet::matchingFacesExcludingPreinstalledFonts(const String&amp; font, const String&amp; string)
345 {
346     auto style = MutableStyleProperties::create();
347     auto parseResult = CSSParser::parseValue(style, CSSPropertyFont, font, true, HTMLStandardMode);
348     if (parseResult == CSSParser::ParseResult::Error)
349         return Exception { SyntaxError };
350 
<a name="11" id="anc11"></a><span class="line-modified">351     auto requestOrException = computeFontSelectionRequest(style.get());</span>
<span class="line-added">352     if (requestOrException.hasException())</span>
<span class="line-added">353         return requestOrException.releaseException();</span>
<span class="line-added">354     auto request = requestOrException.releaseReturnValue();</span>
355 
356     auto family = style-&gt;getPropertyCSSValue(CSSPropertyFontFamily);
357     if (!is&lt;CSSValueList&gt;(family))
358         return Exception { SyntaxError };
359     CSSValueList&amp; familyList = downcast&lt;CSSValueList&gt;(*family);
360 
361     HashSet&lt;AtomString&gt; uniqueFamilies;
362     Vector&lt;AtomString&gt; familyOrder;
363     for (auto&amp; family : familyList) {
364         auto&amp; primitive = downcast&lt;CSSPrimitiveValue&gt;(family.get());
365         if (!primitive.isFontFamily())
366             continue;
367         if (uniqueFamilies.add(primitive.fontFamily().familyName).isNewEntry)
368             familyOrder.append(primitive.fontFamily().familyName);
369     }
370 
371     HashSet&lt;CSSFontFace*&gt; resultConstituents;
372     for (auto codePoint : codePointsFromString(string)) {
373         bool found = false;
374         for (auto&amp; family : familyOrder) {
375             auto* faces = fontFace(request, family);
376             if (!faces)
377                 continue;
378             for (auto&amp; constituentFace : faces-&gt;constituentFaces()) {
379                 if (constituentFace-&gt;isLocalFallback())
380                     continue;
381                 if (constituentFace-&gt;rangesMatchCodePoint(codePoint)) {
382                     resultConstituents.add(constituentFace.ptr());
383                     found = true;
384                     break;
385                 }
386             }
387             if (found)
388                 break;
389         }
390     }
391 
392     Vector&lt;std::reference_wrapper&lt;CSSFontFace&gt;&gt; result;
393     result.reserveInitialCapacity(resultConstituents.size());
394     for (auto* constituent : resultConstituents)
395         result.uncheckedAppend(*constituent);
396     return result;
397 }
398 
399 ExceptionOr&lt;bool&gt; CSSFontFaceSet::check(const String&amp; font, const String&amp; text)
400 {
401     auto matchingFaces = this-&gt;matchingFacesExcludingPreinstalledFonts(font, text);
402     if (matchingFaces.hasException())
403         return matchingFaces.releaseException();
404 
405     for (auto&amp; face : matchingFaces.releaseReturnValue()) {
406         if (face.get().status() == CSSFontFace::Status::Pending)
407             return false;
408     }
409     return true;
410 }
411 
412 CSSSegmentedFontFace* CSSFontFaceSet::fontFace(FontSelectionRequest request, const AtomString&amp; family)
413 {
414     auto iterator = m_facesLookupTable.find(family);
415     if (iterator == m_facesLookupTable.end())
416         return nullptr;
417     auto&amp; familyFontFaces = iterator-&gt;value;
418 
419     auto&amp; segmentedFontFaceCache = m_cache.add(family, FontSelectionHashMap()).iterator-&gt;value;
420 
421     auto&amp; face = segmentedFontFaceCache.add(request, nullptr).iterator-&gt;value;
422     if (face)
423         return face.get();
424 
425     face = CSSSegmentedFontFace::create();
426 
427     Vector&lt;std::reference_wrapper&lt;CSSFontFace&gt;, 32&gt; candidateFontFaces;
428     for (int i = familyFontFaces.size() - 1; i &gt;= 0; --i) {
429         CSSFontFace&amp; candidate = familyFontFaces[i];
<a name="12" id="anc12"></a><span class="line-modified">430         auto capabilitiesWrapped = candidate.fontSelectionCapabilities();</span>
<span class="line-added">431         if (!capabilitiesWrapped.hasValue())</span>
<span class="line-added">432             continue;</span>
<span class="line-added">433         auto capabilities = capabilitiesWrapped.value();</span>
434         if (!isItalic(request.slope) &amp;&amp; isItalic(capabilities.slope.minimum))
435             continue;
436         candidateFontFaces.append(candidate);
437     }
438 
439     auto localIterator = m_locallyInstalledFacesLookupTable.find(family);
440     if (localIterator != m_locallyInstalledFacesLookupTable.end()) {
441         for (auto&amp; candidate : localIterator-&gt;value) {
<a name="13" id="anc13"></a><span class="line-modified">442             auto capabilitiesWrapped = candidate-&gt;fontSelectionCapabilities();</span>
<span class="line-added">443             if (!capabilitiesWrapped.hasValue())</span>
<span class="line-added">444                 continue;</span>
<span class="line-added">445             auto capabilities = capabilitiesWrapped.value();</span>
446             if (!isItalic(request.slope) &amp;&amp; isItalic(capabilities.slope.minimum))
447                 continue;
448             candidateFontFaces.append(candidate);
449         }
450     }
451 
452     if (!candidateFontFaces.isEmpty()) {
453         Vector&lt;FontSelectionCapabilities&gt; capabilities;
454         capabilities.reserveInitialCapacity(candidateFontFaces.size());
<a name="14" id="anc14"></a><span class="line-modified">455         for (auto&amp; face : candidateFontFaces) {</span>
<span class="line-modified">456             auto fontSelectionCapabilitiesWrapped = face.get().fontSelectionCapabilities();</span>
<span class="line-added">457             ASSERT(fontSelectionCapabilitiesWrapped.hasValue());</span>
<span class="line-added">458             auto fontSelectionCapabilities = fontSelectionCapabilitiesWrapped.value();</span>
<span class="line-added">459             capabilities.uncheckedAppend(fontSelectionCapabilities);</span>
<span class="line-added">460         }</span>
461         FontSelectionAlgorithm fontSelectionAlgorithm(request, capabilities);
462         std::stable_sort(candidateFontFaces.begin(), candidateFontFaces.end(), [&amp;fontSelectionAlgorithm](const CSSFontFace&amp; first, const CSSFontFace&amp; second) {
<a name="15" id="anc15"></a><span class="line-modified">463             auto firstCapabilitiesWrapped = first.fontSelectionCapabilities();</span>
<span class="line-modified">464             auto secondCapabilitiesWrapped = second.fontSelectionCapabilities();</span>
<span class="line-added">465             ASSERT(firstCapabilitiesWrapped.hasValue() &amp;&amp; secondCapabilitiesWrapped.hasValue());</span>
466 
<a name="16" id="anc16"></a><span class="line-added">467             auto firstCapabilities = firstCapabilitiesWrapped.value();</span>
<span class="line-added">468             auto secondCapabilities = secondCapabilitiesWrapped.value();</span>
469             auto stretchDistanceFirst = fontSelectionAlgorithm.stretchDistance(firstCapabilities).distance;
470             auto stretchDistanceSecond = fontSelectionAlgorithm.stretchDistance(secondCapabilities).distance;
471             if (stretchDistanceFirst &lt; stretchDistanceSecond)
472                 return true;
473             if (stretchDistanceFirst &gt; stretchDistanceSecond)
474                 return false;
475 
476             auto styleDistanceFirst = fontSelectionAlgorithm.styleDistance(firstCapabilities).distance;
477             auto styleDistanceSecond = fontSelectionAlgorithm.styleDistance(secondCapabilities).distance;
478             if (styleDistanceFirst &lt; styleDistanceSecond)
479                 return true;
480             if (styleDistanceFirst &gt; styleDistanceSecond)
481                 return false;
482 
483             auto weightDistanceFirst = fontSelectionAlgorithm.weightDistance(firstCapabilities).distance;
484             auto weightDistanceSecond = fontSelectionAlgorithm.weightDistance(secondCapabilities).distance;
485             if (weightDistanceFirst &lt; weightDistanceSecond)
486                 return true;
487             return false;
488         });
489         for (auto&amp; candidate : candidateFontFaces)
490             face-&gt;appendFontFace(candidate.get());
491     }
492 
493     return face.get();
494 }
495 
496 void CSSFontFaceSet::fontStateChanged(CSSFontFace&amp; face, CSSFontFace::Status oldState, CSSFontFace::Status newState)
497 {
498     ASSERT(hasFace(face));
499     if (oldState == CSSFontFace::Status::Pending) {
500         ASSERT(newState == CSSFontFace::Status::Loading);
501         incrementActiveCount();
502     }
503     if (newState == CSSFontFace::Status::Success || newState == CSSFontFace::Status::Failure) {
504         ASSERT(oldState == CSSFontFace::Status::Loading || oldState == CSSFontFace::Status::TimedOut);
505         for (auto* client : m_clients)
506             client-&gt;faceFinished(face, newState);
507         decrementActiveCount();
508     }
509 }
510 
511 void CSSFontFaceSet::fontPropertyChanged(CSSFontFace&amp; face, CSSValueList* oldFamilies)
512 {
513     m_cache.clear();
514 
515     if (oldFamilies) {
516         removeFromFacesLookupTable(face, *oldFamilies);
517         addToFacesLookupTable(face);
518     }
519 
520     for (auto* client : m_clients)
521         client-&gt;fontModified();
522 }
523 
524 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2009-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ArrayBufferSharingMode.h&quot;
 29 #include &quot;GCIncomingRefCounted.h&quot;
 30 #include &quot;Watchpoint.h&quot;
 31 #include &quot;Weak.h&quot;
 32 #include &lt;wtf/CagedPtr.h&gt;
 33 #include &lt;wtf/CheckedArithmetic.h&gt;
 34 #include &lt;wtf/PackedRefPtr.h&gt;
 35 #include &lt;wtf/SharedTask.h&gt;
 36 #include &lt;wtf/StdLibExtras.h&gt;
 37 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 38 #include &lt;wtf/text/WTFString.h&gt;
 39 
 40 namespace JSC {
 41 
 42 #define MAX_ARRAY_BUFFER_SIZE 0x7fffffffu
 43 
 44 class VM;
 45 class ArrayBuffer;
 46 class ArrayBufferView;
 47 class JSArrayBuffer;
 48 
 49 using ArrayBufferDestructorFunction = RefPtr&lt;SharedTask&lt;void(void*)&gt;&gt;;
 50 using PackedArrayBufferDestructorFunction = PackedRefPtr&lt;SharedTask&lt;void(void*)&gt;&gt;;
 51 
 52 class SharedArrayBufferContents : public ThreadSafeRefCounted&lt;SharedArrayBufferContents&gt; {
 53 public:
 54     SharedArrayBufferContents(void* data, unsigned size, ArrayBufferDestructorFunction&amp;&amp;);
 55     ~SharedArrayBufferContents();
 56 
 57     void* data() const { return m_data.getMayBeNull(m_sizeInBytes); }
 58 
 59 private:
 60     using DataType = CagedPtr&lt;Gigacage::Primitive, void, tagCagedPtr&gt;;
 61     DataType m_data;
 62     PackedArrayBufferDestructorFunction m_destructor;
 63     unsigned m_sizeInBytes;
 64 };
 65 
 66 class ArrayBufferContents {
 67     WTF_MAKE_NONCOPYABLE(ArrayBufferContents);
 68 public:
 69     JS_EXPORT_PRIVATE ArrayBufferContents();
 70     JS_EXPORT_PRIVATE ArrayBufferContents(void* data, unsigned sizeInBytes, ArrayBufferDestructorFunction&amp;&amp;);
 71 
 72     JS_EXPORT_PRIVATE ArrayBufferContents(ArrayBufferContents&amp;&amp;);
 73     JS_EXPORT_PRIVATE ArrayBufferContents&amp; operator=(ArrayBufferContents&amp;&amp;);
 74 
 75     JS_EXPORT_PRIVATE ~ArrayBufferContents();
 76 
 77     JS_EXPORT_PRIVATE void clear();
 78 
 79     explicit operator bool() { return !!m_data; }
 80 
 81     void* data() const { return m_data.getMayBeNull(sizeInBytes()); }
 82     unsigned sizeInBytes() const { return m_sizeInBytes; }
 83 
 84     bool isShared() const { return m_shared; }
 85 
 86 private:
 87     void destroy();
 88     void reset();
 89 
 90     friend class ArrayBuffer;
 91 
 92     enum InitializationPolicy {
 93         ZeroInitialize,
 94         DontInitialize
 95     };
 96 
 97     void tryAllocate(unsigned numElements, unsigned elementByteSize, InitializationPolicy);
 98 
 99     void makeShared();
100     void transferTo(ArrayBufferContents&amp;);
101     void copyTo(ArrayBufferContents&amp;);
102     void shareWith(ArrayBufferContents&amp;);
103 
104     using DataType = CagedPtr&lt;Gigacage::Primitive, void, tagCagedPtr&gt;;
105     DataType m_data;
106     PackedArrayBufferDestructorFunction m_destructor;
107     PackedRefPtr&lt;SharedArrayBufferContents&gt; m_shared;
108     unsigned m_sizeInBytes;
109 };
110 
111 class ArrayBuffer : public GCIncomingRefCounted&lt;ArrayBuffer&gt; {
112 public:
113     JS_EXPORT_PRIVATE static Ref&lt;ArrayBuffer&gt; create(unsigned numElements, unsigned elementByteSize);
114     JS_EXPORT_PRIVATE static Ref&lt;ArrayBuffer&gt; create(ArrayBuffer&amp;);
115     JS_EXPORT_PRIVATE static Ref&lt;ArrayBuffer&gt; create(const void* source, unsigned byteLength);
116     JS_EXPORT_PRIVATE static Ref&lt;ArrayBuffer&gt; create(ArrayBufferContents&amp;&amp;);
117     JS_EXPORT_PRIVATE static Ref&lt;ArrayBuffer&gt; createAdopted(const void* data, unsigned byteLength);
118     JS_EXPORT_PRIVATE static Ref&lt;ArrayBuffer&gt; createFromBytes(const void* data, unsigned byteLength, ArrayBufferDestructorFunction&amp;&amp;);
119     JS_EXPORT_PRIVATE static RefPtr&lt;ArrayBuffer&gt; tryCreate(unsigned numElements, unsigned elementByteSize);
120     JS_EXPORT_PRIVATE static RefPtr&lt;ArrayBuffer&gt; tryCreate(ArrayBuffer&amp;);
121     JS_EXPORT_PRIVATE static RefPtr&lt;ArrayBuffer&gt; tryCreate(const void* source, unsigned byteLength);
122 
123     // Only for use by Uint8ClampedArray::tryCreateUninitialized and SharedBuffer::tryCreateArrayBuffer.
124     JS_EXPORT_PRIVATE static Ref&lt;ArrayBuffer&gt; createUninitialized(unsigned numElements, unsigned elementByteSize);
125     JS_EXPORT_PRIVATE static RefPtr&lt;ArrayBuffer&gt; tryCreateUninitialized(unsigned numElements, unsigned elementByteSize);
126 
127     inline void* data();
128     inline const void* data() const;
129     inline unsigned byteLength() const;
130 
131     void makeShared();
132     void setSharingMode(ArrayBufferSharingMode);
133     inline bool isShared() const;
134     inline ArrayBufferSharingMode sharingMode() const { return isShared() ? ArrayBufferSharingMode::Shared : ArrayBufferSharingMode::Default; }
135 
136     inline size_t gcSizeEstimateInBytes() const;
137 
138     JS_EXPORT_PRIVATE RefPtr&lt;ArrayBuffer&gt; slice(double begin, double end) const;
139     JS_EXPORT_PRIVATE RefPtr&lt;ArrayBuffer&gt; slice(double begin) const;
140 
141     inline void pin();
142     inline void unpin();
143     inline void pinAndLock();
144     inline bool isLocked();
145 
146     void makeWasmMemory();
147     inline bool isWasmMemory();
148 
149     JS_EXPORT_PRIVATE bool transferTo(VM&amp;, ArrayBufferContents&amp;);
150     JS_EXPORT_PRIVATE bool shareWith(ArrayBufferContents&amp;);
151 
152     void neuter(VM&amp;);
153     bool isNeutered() { return !m_contents.m_data; }
154     InlineWatchpointSet&amp; neuteringWatchpointSet() { return m_neuteringWatchpointSet; }
155 
156     static ptrdiff_t offsetOfData() { return OBJECT_OFFSETOF(ArrayBuffer, m_contents) + OBJECT_OFFSETOF(ArrayBufferContents, m_data); }
157 
158     ~ArrayBuffer() { }
159 
160     JS_EXPORT_PRIVATE static Ref&lt;SharedTask&lt;void(void*)&gt;&gt; primitiveGigacageDestructor();
161 
162 private:
163     static Ref&lt;ArrayBuffer&gt; create(unsigned numElements, unsigned elementByteSize, ArrayBufferContents::InitializationPolicy);
164     static Ref&lt;ArrayBuffer&gt; createInternal(ArrayBufferContents&amp;&amp;, const void*, unsigned);
165     static RefPtr&lt;ArrayBuffer&gt; tryCreate(unsigned numElements, unsigned elementByteSize, ArrayBufferContents::InitializationPolicy);
166     ArrayBuffer(ArrayBufferContents&amp;&amp;);
167     RefPtr&lt;ArrayBuffer&gt; sliceImpl(unsigned begin, unsigned end) const;
168     inline unsigned clampIndex(double index) const;
169     static inline unsigned clampValue(double x, unsigned left, unsigned right);
170 
171     void notifyNeutering(VM&amp;);
172 
173     ArrayBufferContents m_contents;
174     InlineWatchpointSet m_neuteringWatchpointSet { IsWatched };
175 public:
176     Weak&lt;JSArrayBuffer&gt; m_wrapper;
177 private:
178     Checked&lt;unsigned&gt; m_pinCount;
179     bool m_isWasmMemory;
180     // m_locked == true means that some API user fetched m_contents directly from a TypedArray object,
181     // the buffer is backed by a WebAssembly.Memory, or is a SharedArrayBuffer.
182     bool m_locked;
183 };
184 
185 void* ArrayBuffer::data()
186 {
187     return m_contents.data();
188 }
189 
190 const void* ArrayBuffer::data() const
191 {
192     return m_contents.data();
193 }
194 
195 unsigned ArrayBuffer::byteLength() const
196 {
197     return m_contents.sizeInBytes();
198 }
199 
200 bool ArrayBuffer::isShared() const
201 {
202     return m_contents.isShared();
203 }
204 
205 size_t ArrayBuffer::gcSizeEstimateInBytes() const
206 {
207     // FIXME: We probably want to scale this by the shared ref count or something.
208     return sizeof(ArrayBuffer) + static_cast&lt;size_t&gt;(byteLength());
209 }
210 
211 void ArrayBuffer::pin()
212 {
213     m_pinCount++;
214 }
215 
216 void ArrayBuffer::unpin()
217 {
218     m_pinCount--;
219 }
220 
221 void ArrayBuffer::pinAndLock()
222 {
223     m_locked = true;
224 }
225 
226 bool ArrayBuffer::isLocked()
227 {
228     return m_locked;
229 }
230 
231 bool ArrayBuffer::isWasmMemory()
232 {
233     return m_isWasmMemory;
234 }
235 
236 JS_EXPORT_PRIVATE ASCIILiteral errorMesasgeForTransfer(ArrayBuffer*);
237 
238 } // namespace JSC
239 
240 using JSC::ArrayBuffer;
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/ProgressTracker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PolicyChecker.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProgressTracker.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/ProgressTracker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 60 // How many bytes are required between heartbeats to consider it progress.
 61 static const unsigned minumumBytesPerHeartbeatForProgress = 1024;
 62 
 63 static const Seconds progressNotificationTimeInterval { 200_ms };
 64 
 65 struct ProgressItem {
 66     WTF_MAKE_NONCOPYABLE(ProgressItem); WTF_MAKE_FAST_ALLOCATED;
 67 public:
 68     explicit ProgressItem(long long length)
 69         : bytesReceived(0)
 70         , estimatedLength(length)
 71     {
 72     }
 73 
 74     long long bytesReceived;
 75     long long estimatedLength;
 76 };
 77 
 78 unsigned long ProgressTracker::s_uniqueIdentifier = 0;
 79 
<span class="line-modified"> 80 ProgressTracker::ProgressTracker(ProgressTrackerClient&amp; client)</span>
<span class="line-modified"> 81     : m_client(client)</span>
 82     , m_progressHeartbeatTimer(*this, &amp;ProgressTracker::progressHeartbeatTimerFired)
 83 {
 84 }
 85 
<span class="line-modified"> 86 ProgressTracker::~ProgressTracker()</span>
<span class="line-removed"> 87 {</span>
<span class="line-removed"> 88     m_client.progressTrackerDestroyed();</span>
<span class="line-removed"> 89 }</span>
 90 
 91 double ProgressTracker::estimatedProgress() const
 92 {
 93     return m_progressValue;
 94 }
 95 
 96 void ProgressTracker::reset()
 97 {
 98     m_progressItems.clear();
 99 
100     m_totalPageAndResourceBytesToLoad = 0;
101     m_totalBytesReceived = 0;
102     m_totalBytesReceivedBeforePreviousHeartbeat = 0;
103 
104     m_lastNotifiedProgressValue = 0;
105     m_progressValue = 0;
106 
107     m_lastNotifiedProgressTime = MonotonicTime();
108     m_finalProgressChangedSent = false;
109     m_numProgressTrackedFrames = 0;
110     m_originatingProgressFrame = nullptr;
111 
112     m_heartbeatsWithNoProgress = 0;
113     m_progressHeartbeatTimer.stop();
114 }
115 
116 void ProgressTracker::progressStarted(Frame&amp; frame)
117 {
118     LOG(Progress, &quot;Progress started (%p) - frame %p(\&quot;%s\&quot;), value %f, tracked frames %d, originating frame %p&quot;, this, &amp;frame, frame.tree().uniqueName().string().utf8().data(), m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get());
119 
<span class="line-modified">120     m_client.willChangeEstimatedProgress();</span>
121 
122     if (!m_numProgressTrackedFrames || m_originatingProgressFrame == &amp;frame) {
123         reset();
124         m_progressValue = initialProgressValue;
125         m_originatingProgressFrame = &amp;frame;
126 
127         m_progressHeartbeatTimer.startRepeating(progressHeartbeatInterval);
128         m_originatingProgressFrame-&gt;loader().loadProgressingStatusChanged();
129 
130         bool isMainFrame = !m_originatingProgressFrame-&gt;tree().parent();
131         auto elapsedTimeSinceMainLoadComplete = MonotonicTime::now() - m_mainLoadCompletionTime;
132 
133         static const auto subframePartOfMainLoadThreshold = 1_s;
134         m_isMainLoad = isMainFrame || elapsedTimeSinceMainLoadComplete &lt; subframePartOfMainLoadThreshold;
135 
<span class="line-modified">136         m_client.progressStarted(*m_originatingProgressFrame);</span>
137     }
138     m_numProgressTrackedFrames++;
139 
140     RELEASE_LOG_IF_ALLOWED(&quot;progressStarted: frame %p, value %f, tracked frames %d, originating frame %p, isMainLoad %d&quot;, &amp;frame, m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get(), m_isMainLoad);
141 
<span class="line-modified">142     m_client.didChangeEstimatedProgress();</span>
143     InspectorInstrumentation::frameStartedLoading(frame);
144 }
145 
146 void ProgressTracker::progressCompleted(Frame&amp; frame)
147 {
148     LOG(Progress, &quot;Progress completed (%p) - frame %p(\&quot;%s\&quot;), value %f, tracked frames %d, originating frame %p&quot;, this, &amp;frame, frame.tree().uniqueName().string().utf8().data(), m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get());
149     RELEASE_LOG_IF_ALLOWED(&quot;progressCompleted: frame %p, value %f, tracked frames %d, originating frame %p, isMainLoad %d&quot;, &amp;frame, m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get(), m_isMainLoad);
150 
151     if (m_numProgressTrackedFrames &lt;= 0)
152         return;
153 
<span class="line-modified">154     m_client.willChangeEstimatedProgress();</span>
155 
156     m_numProgressTrackedFrames--;
157     if (!m_numProgressTrackedFrames || m_originatingProgressFrame == &amp;frame)
158         finalProgressComplete();
159 
<span class="line-modified">160     m_client.didChangeEstimatedProgress();</span>
161 }
162 
163 void ProgressTracker::finalProgressComplete()
164 {
165     LOG(Progress, &quot;Final progress complete (%p)&quot;, this);
166     RELEASE_LOG_IF_ALLOWED(&quot;finalProgressComplete: value %f, tracked frames %d, originating frame %p, isMainLoad %d, isMainLoadProgressing %d&quot;, m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get(), m_isMainLoad, isMainLoadProgressing());
167 
168     auto frame = WTFMove(m_originatingProgressFrame);
169 
170     // Before resetting progress value be sure to send client a least one notification
171     // with final progress value.
172     if (!m_finalProgressChangedSent) {
173         m_progressValue = 1;
<span class="line-modified">174         m_client.progressEstimateChanged(*frame);</span>
175     }
176 
177     reset();
178 
179     if (m_isMainLoad)
180         m_mainLoadCompletionTime = MonotonicTime::now();
181 
182     frame-&gt;loader().client().setMainFrameDocumentReady(true);
<span class="line-modified">183     m_client.progressFinished(*frame);</span>
184     frame-&gt;loader().loadProgressingStatusChanged();
185 
186     InspectorInstrumentation::frameStoppedLoading(*frame);
187 }
188 
189 void ProgressTracker::incrementProgress(unsigned long identifier, const ResourceResponse&amp; response)
190 {
191     LOG(Progress, &quot;Progress incremented (%p) - value %f, tracked frames %d, originating frame %p&quot;, this, m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get());
192 
193     if (m_numProgressTrackedFrames &lt;= 0)
194         return;
195 
196     long long estimatedLength = response.expectedContentLength();
197     if (estimatedLength &lt; 0)
198         estimatedLength = progressItemDefaultEstimatedLength;
199 
200     m_totalPageAndResourceBytesToLoad += estimatedLength;
201 
202     auto&amp; item = m_progressItems.add(identifier, nullptr).iterator-&gt;value;
203     if (!item) {
204         item = makeUnique&lt;ProgressItem&gt;(estimatedLength);
205         return;
206     }
207 
208     item-&gt;bytesReceived = 0;
209     item-&gt;estimatedLength = estimatedLength;
210 }
211 
212 void ProgressTracker::incrementProgress(unsigned long identifier, unsigned bytesReceived)
213 {
214     ProgressItem* item = m_progressItems.get(identifier);
215 
216     // FIXME: Can this ever happen?
217     if (!item)
218         return;
219 
220     RefPtr&lt;Frame&gt; frame = m_originatingProgressFrame;
221 
<span class="line-modified">222     m_client.willChangeEstimatedProgress();</span>
223 
224     double increment, percentOfRemainingBytes;
225     long long remainingBytes, estimatedBytesForPendingRequests;
226 
227     item-&gt;bytesReceived += bytesReceived;
228     if (item-&gt;bytesReceived &gt; item-&gt;estimatedLength) {
229         m_totalPageAndResourceBytesToLoad += ((item-&gt;bytesReceived * 2) - item-&gt;estimatedLength);
230         item-&gt;estimatedLength = item-&gt;bytesReceived * 2;
231     }
232 
233     int numPendingOrLoadingRequests = frame-&gt;loader().numPendingOrLoadingRequests(true);
234     estimatedBytesForPendingRequests = static_cast&lt;long long&gt;(progressItemDefaultEstimatedLength) * numPendingOrLoadingRequests;
235     remainingBytes = ((m_totalPageAndResourceBytesToLoad + estimatedBytesForPendingRequests) - m_totalBytesReceived);
236     if (remainingBytes &gt; 0)  // Prevent divide by 0.
237         percentOfRemainingBytes = (double)bytesReceived / (double)remainingBytes;
238     else
239         percentOfRemainingBytes = 1.0;
240 
241     // For documents that use WebCore&#39;s layout system, treat first layout as the half-way point.
242     // FIXME: The hasHTMLView function is a sort of roundabout way of asking &quot;do you use WebCore&#39;s layout system&quot;.
243     bool useClampedMaxProgress = frame-&gt;loader().client().hasHTMLView()
244         &amp;&amp; !frame-&gt;loader().stateMachine().firstLayoutDone();
245     double maxProgressValue = useClampedMaxProgress ? 0.5 : finalProgressValue;
246     increment = (maxProgressValue - m_progressValue) * percentOfRemainingBytes;
247     m_progressValue += increment;
248     m_progressValue = std::min(m_progressValue, maxProgressValue);
249     ASSERT(m_progressValue &gt;= initialProgressValue);
250 
251     m_totalBytesReceived += bytesReceived;
252 
253     auto now = MonotonicTime::now();
254     auto notifiedProgressTimeDelta = now - m_lastNotifiedProgressTime;
255 
256     LOG(Progress, &quot;Progress incremented (%p) - value %f, tracked frames %d&quot;, this, m_progressValue, m_numProgressTrackedFrames);
257     if ((notifiedProgressTimeDelta &gt;= progressNotificationTimeInterval || m_progressValue == 1) &amp;&amp; m_numProgressTrackedFrames &gt; 0) {
258         if (!m_finalProgressChangedSent) {
259             if (m_progressValue == 1)
260                 m_finalProgressChangedSent = true;
261 
<span class="line-modified">262             m_client.progressEstimateChanged(*frame);</span>
263 
264             m_lastNotifiedProgressValue = m_progressValue;
265             m_lastNotifiedProgressTime = now;
266         }
267     }
268 
<span class="line-modified">269     m_client.didChangeEstimatedProgress();</span>
270 }
271 
272 void ProgressTracker::completeProgress(unsigned long identifier)
273 {
274     auto it = m_progressItems.find(identifier);
275 
276     // This can happen if a load fails without receiving any response data.
277     if (it == m_progressItems.end())
278         return;
279 
280     ProgressItem&amp; item = *it-&gt;value;
281 
282     // Adjust the total expected bytes to account for any overage/underage.
283     long long delta = item.bytesReceived - item.estimatedLength;
284     m_totalPageAndResourceBytesToLoad += delta;
285 
286     m_progressItems.remove(it);
287 }
288 
289 unsigned long ProgressTracker::createUniqueIdentifier()
</pre>
</td>
<td>
<hr />
<pre>
 60 // How many bytes are required between heartbeats to consider it progress.
 61 static const unsigned minumumBytesPerHeartbeatForProgress = 1024;
 62 
 63 static const Seconds progressNotificationTimeInterval { 200_ms };
 64 
 65 struct ProgressItem {
 66     WTF_MAKE_NONCOPYABLE(ProgressItem); WTF_MAKE_FAST_ALLOCATED;
 67 public:
 68     explicit ProgressItem(long long length)
 69         : bytesReceived(0)
 70         , estimatedLength(length)
 71     {
 72     }
 73 
 74     long long bytesReceived;
 75     long long estimatedLength;
 76 };
 77 
 78 unsigned long ProgressTracker::s_uniqueIdentifier = 0;
 79 
<span class="line-modified"> 80 ProgressTracker::ProgressTracker(UniqueRef&lt;ProgressTrackerClient&gt;&amp;&amp; client)</span>
<span class="line-modified"> 81     : m_client(WTFMove(client))</span>
 82     , m_progressHeartbeatTimer(*this, &amp;ProgressTracker::progressHeartbeatTimerFired)
 83 {
 84 }
 85 
<span class="line-modified"> 86 ProgressTracker::~ProgressTracker() = default;</span>



 87 
 88 double ProgressTracker::estimatedProgress() const
 89 {
 90     return m_progressValue;
 91 }
 92 
 93 void ProgressTracker::reset()
 94 {
 95     m_progressItems.clear();
 96 
 97     m_totalPageAndResourceBytesToLoad = 0;
 98     m_totalBytesReceived = 0;
 99     m_totalBytesReceivedBeforePreviousHeartbeat = 0;
100 
101     m_lastNotifiedProgressValue = 0;
102     m_progressValue = 0;
103 
104     m_lastNotifiedProgressTime = MonotonicTime();
105     m_finalProgressChangedSent = false;
106     m_numProgressTrackedFrames = 0;
107     m_originatingProgressFrame = nullptr;
108 
109     m_heartbeatsWithNoProgress = 0;
110     m_progressHeartbeatTimer.stop();
111 }
112 
113 void ProgressTracker::progressStarted(Frame&amp; frame)
114 {
115     LOG(Progress, &quot;Progress started (%p) - frame %p(\&quot;%s\&quot;), value %f, tracked frames %d, originating frame %p&quot;, this, &amp;frame, frame.tree().uniqueName().string().utf8().data(), m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get());
116 
<span class="line-modified">117     m_client-&gt;willChangeEstimatedProgress();</span>
118 
119     if (!m_numProgressTrackedFrames || m_originatingProgressFrame == &amp;frame) {
120         reset();
121         m_progressValue = initialProgressValue;
122         m_originatingProgressFrame = &amp;frame;
123 
124         m_progressHeartbeatTimer.startRepeating(progressHeartbeatInterval);
125         m_originatingProgressFrame-&gt;loader().loadProgressingStatusChanged();
126 
127         bool isMainFrame = !m_originatingProgressFrame-&gt;tree().parent();
128         auto elapsedTimeSinceMainLoadComplete = MonotonicTime::now() - m_mainLoadCompletionTime;
129 
130         static const auto subframePartOfMainLoadThreshold = 1_s;
131         m_isMainLoad = isMainFrame || elapsedTimeSinceMainLoadComplete &lt; subframePartOfMainLoadThreshold;
132 
<span class="line-modified">133         m_client-&gt;progressStarted(*m_originatingProgressFrame);</span>
134     }
135     m_numProgressTrackedFrames++;
136 
137     RELEASE_LOG_IF_ALLOWED(&quot;progressStarted: frame %p, value %f, tracked frames %d, originating frame %p, isMainLoad %d&quot;, &amp;frame, m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get(), m_isMainLoad);
138 
<span class="line-modified">139     m_client-&gt;didChangeEstimatedProgress();</span>
140     InspectorInstrumentation::frameStartedLoading(frame);
141 }
142 
143 void ProgressTracker::progressCompleted(Frame&amp; frame)
144 {
145     LOG(Progress, &quot;Progress completed (%p) - frame %p(\&quot;%s\&quot;), value %f, tracked frames %d, originating frame %p&quot;, this, &amp;frame, frame.tree().uniqueName().string().utf8().data(), m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get());
146     RELEASE_LOG_IF_ALLOWED(&quot;progressCompleted: frame %p, value %f, tracked frames %d, originating frame %p, isMainLoad %d&quot;, &amp;frame, m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get(), m_isMainLoad);
147 
148     if (m_numProgressTrackedFrames &lt;= 0)
149         return;
150 
<span class="line-modified">151     m_client-&gt;willChangeEstimatedProgress();</span>
152 
153     m_numProgressTrackedFrames--;
154     if (!m_numProgressTrackedFrames || m_originatingProgressFrame == &amp;frame)
155         finalProgressComplete();
156 
<span class="line-modified">157     m_client-&gt;didChangeEstimatedProgress();</span>
158 }
159 
160 void ProgressTracker::finalProgressComplete()
161 {
162     LOG(Progress, &quot;Final progress complete (%p)&quot;, this);
163     RELEASE_LOG_IF_ALLOWED(&quot;finalProgressComplete: value %f, tracked frames %d, originating frame %p, isMainLoad %d, isMainLoadProgressing %d&quot;, m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get(), m_isMainLoad, isMainLoadProgressing());
164 
165     auto frame = WTFMove(m_originatingProgressFrame);
166 
167     // Before resetting progress value be sure to send client a least one notification
168     // with final progress value.
169     if (!m_finalProgressChangedSent) {
170         m_progressValue = 1;
<span class="line-modified">171         m_client-&gt;progressEstimateChanged(*frame);</span>
172     }
173 
174     reset();
175 
176     if (m_isMainLoad)
177         m_mainLoadCompletionTime = MonotonicTime::now();
178 
179     frame-&gt;loader().client().setMainFrameDocumentReady(true);
<span class="line-modified">180     m_client-&gt;progressFinished(*frame);</span>
181     frame-&gt;loader().loadProgressingStatusChanged();
182 
183     InspectorInstrumentation::frameStoppedLoading(*frame);
184 }
185 
186 void ProgressTracker::incrementProgress(unsigned long identifier, const ResourceResponse&amp; response)
187 {
188     LOG(Progress, &quot;Progress incremented (%p) - value %f, tracked frames %d, originating frame %p&quot;, this, m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get());
189 
190     if (m_numProgressTrackedFrames &lt;= 0)
191         return;
192 
193     long long estimatedLength = response.expectedContentLength();
194     if (estimatedLength &lt; 0)
195         estimatedLength = progressItemDefaultEstimatedLength;
196 
197     m_totalPageAndResourceBytesToLoad += estimatedLength;
198 
199     auto&amp; item = m_progressItems.add(identifier, nullptr).iterator-&gt;value;
200     if (!item) {
201         item = makeUnique&lt;ProgressItem&gt;(estimatedLength);
202         return;
203     }
204 
205     item-&gt;bytesReceived = 0;
206     item-&gt;estimatedLength = estimatedLength;
207 }
208 
209 void ProgressTracker::incrementProgress(unsigned long identifier, unsigned bytesReceived)
210 {
211     ProgressItem* item = m_progressItems.get(identifier);
212 
213     // FIXME: Can this ever happen?
214     if (!item)
215         return;
216 
217     RefPtr&lt;Frame&gt; frame = m_originatingProgressFrame;
218 
<span class="line-modified">219     m_client-&gt;willChangeEstimatedProgress();</span>
220 
221     double increment, percentOfRemainingBytes;
222     long long remainingBytes, estimatedBytesForPendingRequests;
223 
224     item-&gt;bytesReceived += bytesReceived;
225     if (item-&gt;bytesReceived &gt; item-&gt;estimatedLength) {
226         m_totalPageAndResourceBytesToLoad += ((item-&gt;bytesReceived * 2) - item-&gt;estimatedLength);
227         item-&gt;estimatedLength = item-&gt;bytesReceived * 2;
228     }
229 
230     int numPendingOrLoadingRequests = frame-&gt;loader().numPendingOrLoadingRequests(true);
231     estimatedBytesForPendingRequests = static_cast&lt;long long&gt;(progressItemDefaultEstimatedLength) * numPendingOrLoadingRequests;
232     remainingBytes = ((m_totalPageAndResourceBytesToLoad + estimatedBytesForPendingRequests) - m_totalBytesReceived);
233     if (remainingBytes &gt; 0)  // Prevent divide by 0.
234         percentOfRemainingBytes = (double)bytesReceived / (double)remainingBytes;
235     else
236         percentOfRemainingBytes = 1.0;
237 
238     // For documents that use WebCore&#39;s layout system, treat first layout as the half-way point.
239     // FIXME: The hasHTMLView function is a sort of roundabout way of asking &quot;do you use WebCore&#39;s layout system&quot;.
240     bool useClampedMaxProgress = frame-&gt;loader().client().hasHTMLView()
241         &amp;&amp; !frame-&gt;loader().stateMachine().firstLayoutDone();
242     double maxProgressValue = useClampedMaxProgress ? 0.5 : finalProgressValue;
243     increment = (maxProgressValue - m_progressValue) * percentOfRemainingBytes;
244     m_progressValue += increment;
245     m_progressValue = std::min(m_progressValue, maxProgressValue);
246     ASSERT(m_progressValue &gt;= initialProgressValue);
247 
248     m_totalBytesReceived += bytesReceived;
249 
250     auto now = MonotonicTime::now();
251     auto notifiedProgressTimeDelta = now - m_lastNotifiedProgressTime;
252 
253     LOG(Progress, &quot;Progress incremented (%p) - value %f, tracked frames %d&quot;, this, m_progressValue, m_numProgressTrackedFrames);
254     if ((notifiedProgressTimeDelta &gt;= progressNotificationTimeInterval || m_progressValue == 1) &amp;&amp; m_numProgressTrackedFrames &gt; 0) {
255         if (!m_finalProgressChangedSent) {
256             if (m_progressValue == 1)
257                 m_finalProgressChangedSent = true;
258 
<span class="line-modified">259             m_client-&gt;progressEstimateChanged(*frame);</span>
260 
261             m_lastNotifiedProgressValue = m_progressValue;
262             m_lastNotifiedProgressTime = now;
263         }
264     }
265 
<span class="line-modified">266     m_client-&gt;didChangeEstimatedProgress();</span>
267 }
268 
269 void ProgressTracker::completeProgress(unsigned long identifier)
270 {
271     auto it = m_progressItems.find(identifier);
272 
273     // This can happen if a load fails without receiving any response data.
274     if (it == m_progressItems.end())
275         return;
276 
277     ProgressItem&amp; item = *it-&gt;value;
278 
279     // Adjust the total expected bytes to account for any overage/underage.
280     long long delta = item.bytesReceived - item.estimatedLength;
281     m_totalPageAndResourceBytesToLoad += delta;
282 
283     m_progressItems.remove(it);
284 }
285 
286 unsigned long ProgressTracker::createUniqueIdentifier()
</pre>
</td>
</tr>
</table>
<center><a href="PolicyChecker.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProgressTracker.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
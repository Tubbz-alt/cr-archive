<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLPlugInImageElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLPlugInElement.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLSelectElement.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLPlugInImageElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,30 ***</span>
  #include &quot;HTMLImageLoader.h&quot;
  #include &quot;JSDOMConvertBoolean.h&quot;
  #include &quot;JSDOMConvertInterface.h&quot;
  #include &quot;JSDOMConvertStrings.h&quot;
  #include &quot;JSShadowRoot.h&quot;
  #include &quot;LocalizedStrings.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;MouseEvent.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;PlatformMouseEvent.h&quot;
  #include &quot;PlugInClient.h&quot;
  #include &quot;PluginViewBase.h&quot;
  #include &quot;RenderImage.h&quot;
  #include &quot;RenderSnapshottedPlugIn.h&quot;
  #include &quot;RenderTreeUpdater.h&quot;
<span class="line-removed">- #include &quot;SchemeRegistry.h&quot;</span>
  #include &quot;ScriptController.h&quot;
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;ShadowRoot.h&quot;
  #include &quot;StyleTreeResolver.h&quot;
  #include &quot;SubframeLoader.h&quot;
  #include &quot;TypedElementDescendantIterator.h&quot;
  #include &quot;UserGestureIndicator.h&quot;
  #include &lt;JavaScriptCore/CatchScope.h&gt;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLPlugInImageElement);
<span class="line-new-header">--- 31,31 ---</span>
  #include &quot;HTMLImageLoader.h&quot;
  #include &quot;JSDOMConvertBoolean.h&quot;
  #include &quot;JSDOMConvertInterface.h&quot;
  #include &quot;JSDOMConvertStrings.h&quot;
  #include &quot;JSShadowRoot.h&quot;
<span class="line-added">+ #include &quot;LegacySchemeRegistry.h&quot;</span>
  #include &quot;LocalizedStrings.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;MouseEvent.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;PlatformMouseEvent.h&quot;
  #include &quot;PlugInClient.h&quot;
  #include &quot;PluginViewBase.h&quot;
  #include &quot;RenderImage.h&quot;
  #include &quot;RenderSnapshottedPlugIn.h&quot;
  #include &quot;RenderTreeUpdater.h&quot;
  #include &quot;ScriptController.h&quot;
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;ShadowRoot.h&quot;
  #include &quot;StyleTreeResolver.h&quot;
  #include &quot;SubframeLoader.h&quot;
  #include &quot;TypedElementDescendantIterator.h&quot;
  #include &quot;UserGestureIndicator.h&quot;
  #include &lt;JavaScriptCore/CatchScope.h&gt;
<span class="line-added">+ #include &lt;JavaScriptCore/JSGlobalObjectInlines.h&gt;</span>
  #include &lt;wtf/IsoMallocInlines.h&gt;
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLPlugInImageElement);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,17 ***</span>
      return document().frame()-&gt;loader().client().objectContentType(completedURL, serviceType) == ObjectContentType::PlugIn;
  }
  
  RenderPtr&lt;RenderElement&gt; HTMLPlugInImageElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
  {
<span class="line-modified">!     ASSERT(document().pageCacheState() == Document::NotInPageCache);</span>
  
      if (displayState() &gt;= PreparingPluginReplacement)
          return HTMLPlugInElement::createElementRenderer(WTFMove(style), insertionPosition);
  
      // Once a plug-in element creates its renderer, it needs to be told when the document goes
<span class="line-modified">!     // inactive or reactivates so it can clear the renderer before going into the page cache.</span>
      if (!m_needsDocumentActivationCallbacks) {
          m_needsDocumentActivationCallbacks = true;
          document().registerForDocumentSuspensionCallbacks(*this);
      }
  
<span class="line-new-header">--- 183,17 ---</span>
      return document().frame()-&gt;loader().client().objectContentType(completedURL, serviceType) == ObjectContentType::PlugIn;
  }
  
  RenderPtr&lt;RenderElement&gt; HTMLPlugInImageElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
  {
<span class="line-modified">!     ASSERT(document().backForwardCacheState() == Document::NotInBackForwardCache);</span>
  
      if (displayState() &gt;= PreparingPluginReplacement)
          return HTMLPlugInElement::createElementRenderer(WTFMove(style), insertionPosition);
  
      // Once a plug-in element creates its renderer, it needs to be told when the document goes
<span class="line-modified">!     // inactive or reactivates so it can clear the renderer before going into the back/forward cache.</span>
      if (!m_needsDocumentActivationCallbacks) {
          m_needsDocumentActivationCallbacks = true;
          document().registerForDocumentSuspensionCallbacks(*this);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 360,11 ***</span>
          renderer-&gt;repaint();
  }
  
  static DOMWrapperWorld&amp; plugInImageElementIsolatedWorld()
  {
<span class="line-modified">!     static auto&amp; isolatedWorld = DOMWrapperWorld::create(commonVM()).leakRef();</span>
      return isolatedWorld;
  }
  
  void HTMLPlugInImageElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
  {
<span class="line-new-header">--- 361,11 ---</span>
          renderer-&gt;repaint();
  }
  
  static DOMWrapperWorld&amp; plugInImageElementIsolatedWorld()
  {
<span class="line-modified">!     static auto&amp; isolatedWorld = DOMWrapperWorld::create(commonVM(), DOMWrapperWorld::Type::Internal, &quot;Plugin&quot;_s).leakRef();</span>
      return isolatedWorld;
  }
  
  void HTMLPlugInImageElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,35 ***</span>
      auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(scriptController.globalObject(isolatedWorld));
  
      auto&amp; vm = globalObject.vm();
      JSC::JSLockHolder lock(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     auto&amp; state = *globalObject.globalExec();</span>
  
      JSC::MarkedArgumentBuffer argList;
<span class="line-modified">!     argList.append(toJS&lt;IDLInterface&lt;ShadowRoot&gt;&gt;(state, globalObject, root));</span>
<span class="line-modified">!     argList.append(toJS&lt;IDLDOMString&gt;(state, titleText(*page, mimeType)));</span>
<span class="line-modified">!     argList.append(toJS&lt;IDLDOMString&gt;(state, subtitleText(*page, mimeType)));</span>
  
      // This parameter determines whether or not the snapshot overlay should always be visible over the plugin snapshot.
      // If no snapshot was found then we want the overlay to be visible.
      argList.append(toJS&lt;IDLBoolean&gt;(!m_snapshotImage));
      ASSERT(!argList.hasOverflowed());
  
      // It is expected the JS file provides a createOverlay(shadowRoot, title, subtitle) function.
<span class="line-modified">!     auto* overlay = globalObject.get(&amp;state, JSC::Identifier::fromString(vm, &quot;createOverlay&quot;)).toObject(&amp;state);</span>
      ASSERT(!overlay == !!scope.exception());
      if (!overlay) {
          scope.clearException();
          return;
      }
      JSC::CallData callData;
      auto callType = overlay-&gt;methodTable(vm)-&gt;getCallData(overlay, callData);
      if (callType == JSC::CallType::None)
          return;
  
<span class="line-modified">!     call(&amp;state, overlay, callType, callData, &amp;globalObject, argList);</span>
      scope.clearException();
  }
  
  bool HTMLPlugInImageElement::partOfSnapshotOverlay(const EventTarget* target) const
  {
<span class="line-new-header">--- 391,35 ---</span>
      auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(scriptController.globalObject(isolatedWorld));
  
      auto&amp; vm = globalObject.vm();
      JSC::JSLockHolder lock(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     auto&amp; lexicalGlobalObject = globalObject;</span>
  
      JSC::MarkedArgumentBuffer argList;
<span class="line-modified">!     argList.append(toJS&lt;IDLInterface&lt;ShadowRoot&gt;&gt;(lexicalGlobalObject, globalObject, root));</span>
<span class="line-modified">!     argList.append(toJS&lt;IDLDOMString&gt;(lexicalGlobalObject, titleText(*page, mimeType)));</span>
<span class="line-modified">!     argList.append(toJS&lt;IDLDOMString&gt;(lexicalGlobalObject, subtitleText(*page, mimeType)));</span>
  
      // This parameter determines whether or not the snapshot overlay should always be visible over the plugin snapshot.
      // If no snapshot was found then we want the overlay to be visible.
      argList.append(toJS&lt;IDLBoolean&gt;(!m_snapshotImage));
      ASSERT(!argList.hasOverflowed());
  
      // It is expected the JS file provides a createOverlay(shadowRoot, title, subtitle) function.
<span class="line-modified">!     auto* overlay = globalObject.get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;createOverlay&quot;)).toObject(&amp;lexicalGlobalObject);</span>
      ASSERT(!overlay == !!scope.exception());
      if (!overlay) {
          scope.clearException();
          return;
      }
      JSC::CallData callData;
      auto callType = overlay-&gt;methodTable(vm)-&gt;getCallData(overlay, callData);
      if (callType == JSC::CallType::None)
          return;
  
<span class="line-modified">!     call(&amp;lexicalGlobalObject, overlay, callType, callData, &amp;globalObject, argList);</span>
      scope.clearException();
  }
  
  bool HTMLPlugInImageElement::partOfSnapshotOverlay(const EventTarget* target) const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 482,12 ***</span>
  {
      if (forwardEvent)
          m_pendingClickEventFromSnapshot = &amp;event;
  
      auto plugInOrigin = m_loadedUrl.host();
<span class="line-modified">!     if (document().page() &amp;&amp; !SchemeRegistry::shouldTreatURLSchemeAsLocal(document().page()-&gt;mainFrame().document()-&gt;baseURL().protocol().toStringWithoutCopying()) &amp;&amp; document().page()-&gt;settings().autostartOriginPlugInSnapshottingEnabled())</span>
<span class="line-modified">!         document().page()-&gt;plugInClient()-&gt;didStartFromOrigin(document().page()-&gt;mainFrame().document()-&gt;baseURL().host().toString(), plugInOrigin.toString(), serviceType(), document().page()-&gt;sessionID());</span>
  
      LOG(Plugins, &quot;%p User clicked on snapshotted plug-in. Restart.&quot;, this);
      restartSnapshottedPlugIn();
      if (forwardEvent)
          setDisplayState(RestartingWithPendingMouseClick);
<span class="line-new-header">--- 483,12 ---</span>
  {
      if (forwardEvent)
          m_pendingClickEventFromSnapshot = &amp;event;
  
      auto plugInOrigin = m_loadedUrl.host();
<span class="line-modified">!     if (document().page() &amp;&amp; !LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(document().page()-&gt;mainFrame().document()-&gt;baseURL().protocol().toStringWithoutCopying()) &amp;&amp; document().page()-&gt;settings().autostartOriginPlugInSnapshottingEnabled())</span>
<span class="line-modified">!         document().page()-&gt;plugInClient()-&gt;didStartFromOrigin(document().page()-&gt;mainFrame().document()-&gt;baseURL().host().toString(), plugInOrigin.toString(), serviceType());</span>
  
      LOG(Plugins, &quot;%p User clicked on snapshotted plug-in. Restart.&quot;, this);
      restartSnapshottedPlugIn();
      if (forwardEvent)
          setDisplayState(RestartingWithPendingMouseClick);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 699,11 ***</span>
          LOG(Plugins, &quot;%p Plug-in has no src URL but does have a valid mime type %s, set to play&quot;, this, serviceType().utf8().data());
          m_snapshotDecision = MaySnapshotWhenContentIsSet;
          return;
      }
  
<span class="line-modified">!     if (!SchemeRegistry::shouldTreatURLSchemeAsLocal(m_loadedUrl.protocol().toStringWithoutCopying()) &amp;&amp; !m_loadedUrl.host().isEmpty() &amp;&amp; m_loadedUrl.host() == document().page()-&gt;mainFrame().document()-&gt;baseURL().host()) {</span>
          LOG(Plugins, &quot;%p Plug-in is served from page&#39;s domain, set to play&quot;, this);
          m_snapshotDecision = NeverSnapshot;
          return;
      }
  
<span class="line-new-header">--- 700,11 ---</span>
          LOG(Plugins, &quot;%p Plug-in has no src URL but does have a valid mime type %s, set to play&quot;, this, serviceType().utf8().data());
          m_snapshotDecision = MaySnapshotWhenContentIsSet;
          return;
      }
  
<span class="line-modified">!     if (!LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(m_loadedUrl.protocol().toStringWithoutCopying()) &amp;&amp; !m_loadedUrl.host().isEmpty() &amp;&amp; m_loadedUrl.host() == document().page()-&gt;mainFrame().document()-&gt;baseURL().host()) {</span>
          LOG(Plugins, &quot;%p Plug-in is served from page&#39;s domain, set to play&quot;, this);
          m_snapshotDecision = NeverSnapshot;
          return;
      }
  
</pre>
<center><a href="HTMLPlugInElement.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLSelectElement.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
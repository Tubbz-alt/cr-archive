<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorTargetAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorTargetAgent.h&quot;
 28 
 29 #include &quot;InspectorTarget.h&quot;
 30 
 31 namespace Inspector {
 32 
 33 InspectorTargetAgent::InspectorTargetAgent(FrontendRouter&amp; frontendRouter, BackendDispatcher&amp; backendDispatcher)
 34     : InspectorAgentBase(&quot;Target&quot;_s)
<a name="1" id="anc1"></a><span class="line-added"> 35     , m_router(frontendRouter)</span>
 36     , m_frontendDispatcher(makeUnique&lt;TargetFrontendDispatcher&gt;(frontendRouter))
 37     , m_backendDispatcher(TargetBackendDispatcher::create(backendDispatcher, this))
 38 {
 39 }
 40 
 41 InspectorTargetAgent::~InspectorTargetAgent() = default;
 42 
 43 void InspectorTargetAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
 44 {
 45     m_isConnected = true;
 46 
 47     connectToTargets();
 48 }
 49 
 50 void InspectorTargetAgent::willDestroyFrontendAndBackend(DisconnectReason)
 51 {
 52     disconnectFromTargets();
 53 
 54     m_isConnected = false;
<a name="2" id="anc2"></a><span class="line-added"> 55     m_shouldPauseOnStart = false;</span>
 56 }
 57 
<a name="3" id="anc3"></a><span class="line-modified"> 58 void InspectorTargetAgent::setPauseOnStart(ErrorString&amp;, bool pauseOnStart)</span>
 59 {
<a name="4" id="anc4"></a><span class="line-modified"> 60     m_shouldPauseOnStart = pauseOnStart;</span>
<span class="line-modified"> 61 }</span>
<span class="line-added"> 62 </span>
<span class="line-added"> 63 void InspectorTargetAgent::resume(ErrorString&amp; errorString, const String&amp; targetId)</span>
<span class="line-added"> 64 {</span>
<span class="line-added"> 65     auto* target = m_targets.get(targetId);</span>
<span class="line-added"> 66     if (!target) {</span>
<span class="line-added"> 67         errorString = &quot;Missing target for given targetId&quot;_s;</span>
<span class="line-added"> 68         return;</span>
<span class="line-added"> 69     }</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71     if (!target-&gt;isPaused()) {</span>
<span class="line-added"> 72         errorString = &quot;Target for given targetId is not paused&quot;_s;</span>
<span class="line-added"> 73         return;</span>
<span class="line-added"> 74     }</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76     target-&gt;resume();</span>
 77 }
 78 
 79 void InspectorTargetAgent::sendMessageToTarget(ErrorString&amp; errorString, const String&amp; targetId, const String&amp; message)
 80 {
 81     InspectorTarget* target = m_targets.get(targetId);
 82     if (!target) {
 83         errorString = &quot;Missing target for given targetId&quot;_s;
 84         return;
 85     }
 86 
 87     target-&gt;sendMessageToTargetBackend(message);
 88 }
 89 
 90 void InspectorTargetAgent::sendMessageFromTargetToFrontend(const String&amp; targetId, const String&amp; message)
 91 {
 92     ASSERT_WITH_MESSAGE(m_targets.get(targetId), &quot;Sending a message from an untracked target to the frontend.&quot;);
 93 
 94     m_frontendDispatcher-&gt;dispatchMessageFromTarget(targetId, message);
 95 }
 96 
 97 static Protocol::Target::TargetInfo::Type targetTypeToProtocolType(InspectorTargetType type)
 98 {
 99     switch (type) {
<a name="5" id="anc5"></a>

100     case InspectorTargetType::Page:
101         return Protocol::Target::TargetInfo::Type::Page;
102     case InspectorTargetType::DedicatedWorker:
103         return Protocol::Target::TargetInfo::Type::Worker;
104     case InspectorTargetType::ServiceWorker:
105         return Protocol::Target::TargetInfo::Type::ServiceWorker;
106     }
107 
108     ASSERT_NOT_REACHED();
<a name="6" id="anc6"></a><span class="line-modified">109     return Protocol::Target::TargetInfo::Type::Page;</span>
110 }
111 
112 static Ref&lt;Protocol::Target::TargetInfo&gt; buildTargetInfoObject(const InspectorTarget&amp; target)
113 {
<a name="7" id="anc7"></a><span class="line-modified">114     auto result = Protocol::Target::TargetInfo::create()</span>
115         .setTargetId(target.identifier())
116         .setType(targetTypeToProtocolType(target.type()))
117         .release();
<a name="8" id="anc8"></a><span class="line-added">118     if (target.isProvisional())</span>
<span class="line-added">119         result-&gt;setIsProvisional(true);</span>
<span class="line-added">120     if (target.isPaused())</span>
<span class="line-added">121         result-&gt;setIsPaused(true);</span>
<span class="line-added">122     return result;</span>
123 }
124 
125 void InspectorTargetAgent::targetCreated(InspectorTarget&amp; target)
126 {
127     auto addResult = m_targets.set(target.identifier(), &amp;target);
128     ASSERT_UNUSED(addResult, addResult.isNewEntry);
129 
130     if (!m_isConnected)
131         return;
132 
<a name="9" id="anc9"></a><span class="line-modified">133     if (m_shouldPauseOnStart)</span>
<span class="line-added">134         target.pause();</span>
<span class="line-added">135     target.connect(connectionType());</span>
136 
137     m_frontendDispatcher-&gt;targetCreated(buildTargetInfoObject(target));
138 }
139 
140 void InspectorTargetAgent::targetDestroyed(InspectorTarget&amp; target)
141 {
142     m_targets.remove(target.identifier());
143 
144     if (!m_isConnected)
145         return;
146 
<a name="10" id="anc10"></a>

147     m_frontendDispatcher-&gt;targetDestroyed(target.identifier());
148 }
149 
<a name="11" id="anc11"></a><span class="line-modified">150 void InspectorTargetAgent::didCommitProvisionalTarget(const String&amp; oldTargetID, const String&amp; committedTargetID)</span>
151 {
<a name="12" id="anc12"></a><span class="line-modified">152     if (!m_isConnected)</span>
<span class="line-added">153         return;</span>
<span class="line-added">154 </span>
<span class="line-added">155     auto* target = m_targets.get(committedTargetID);</span>
<span class="line-added">156     if (!target)</span>
<span class="line-added">157         return;</span>
<span class="line-added">158 </span>
<span class="line-added">159     m_frontendDispatcher-&gt;didCommitProvisionalTarget(oldTargetID, committedTargetID);</span>
<span class="line-added">160 }</span>
161 
<a name="13" id="anc13"></a><span class="line-added">162 FrontendChannel::ConnectionType InspectorTargetAgent::connectionType() const</span>
<span class="line-added">163 {</span>
<span class="line-added">164     return m_router.hasLocalFrontend() ? Inspector::FrontendChannel::ConnectionType::Local : Inspector::FrontendChannel::ConnectionType::Remote;</span>
<span class="line-added">165 }</span>
<span class="line-added">166 </span>
<span class="line-added">167 void InspectorTargetAgent::connectToTargets()</span>
<span class="line-added">168 {</span>
169     for (InspectorTarget* target : m_targets.values()) {
<a name="14" id="anc14"></a><span class="line-modified">170         target-&gt;connect(connectionType());</span>
171         m_frontendDispatcher-&gt;targetCreated(buildTargetInfoObject(*target));
172     }
173 }
174 
175 void InspectorTargetAgent::disconnectFromTargets()
176 {
<a name="15" id="anc15"></a>

177     for (InspectorTarget* target : m_targets.values())
<a name="16" id="anc16"></a><span class="line-modified">178         target-&gt;disconnect();</span>
179 }
180 
181 } // namespace Inspector
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/crypto/SubtleCrypto.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CryptoAlgorithm.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SubtleCrypto.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/crypto/SubtleCrypto.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  61     , m_workQueue(WorkQueue::create(&quot;com.apple.WebKit.CryptoQueue&quot;))
  62 {
  63 }
  64 
  65 SubtleCrypto::~SubtleCrypto() = default;
  66 
  67 enum class Operations {
  68     Encrypt,
  69     Decrypt,
  70     Sign,
  71     Verify,
  72     Digest,
  73     GenerateKey,
  74     DeriveBits,
  75     ImportKey,
  76     WrapKey,
  77     UnwrapKey,
  78     GetKeyLength
  79 };
  80 
<span class="line-modified">  81 static ExceptionOr&lt;std::unique_ptr&lt;CryptoAlgorithmParameters&gt;&gt; normalizeCryptoAlgorithmParameters(ExecState&amp;, WebCore::SubtleCrypto::AlgorithmIdentifier, Operations);</span>
  82 
<span class="line-modified">  83 static ExceptionOr&lt;CryptoAlgorithmIdentifier&gt; toHashIdentifier(ExecState&amp; state, SubtleCrypto::AlgorithmIdentifier algorithmIdentifier)</span>
  84 {
  85     auto digestParams = normalizeCryptoAlgorithmParameters(state, algorithmIdentifier, Operations::Digest);
  86     if (digestParams.hasException())
  87         return digestParams.releaseException();
  88     return digestParams.returnValue()-&gt;identifier;
  89 }
  90 
<span class="line-modified">  91 static ExceptionOr&lt;std::unique_ptr&lt;CryptoAlgorithmParameters&gt;&gt; normalizeCryptoAlgorithmParameters(ExecState&amp; state, SubtleCrypto::AlgorithmIdentifier algorithmIdentifier, Operations operation)</span>
  92 {
  93     VM&amp; vm = state.vm();
  94     auto scope = DECLARE_THROW_SCOPE(vm);
  95 
  96     if (WTF::holds_alternative&lt;String&gt;(algorithmIdentifier)) {
  97         auto newParams = Strong&lt;JSObject&gt;(vm, constructEmptyObject(&amp;state));
  98         newParams-&gt;putDirect(vm, Identifier::fromString(vm, &quot;name&quot;), jsString(vm, WTF::get&lt;String&gt;(algorithmIdentifier)));
  99 
 100         return normalizeCryptoAlgorithmParameters(state, newParams, operation);
 101     }
 102 
 103     auto&amp; value = WTF::get&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;(algorithmIdentifier);
 104 
 105     auto params = convertDictionary&lt;CryptoAlgorithmParameters&gt;(state, value.get());
 106     RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 107 
 108     auto identifier = CryptoAlgorithmRegistry::singleton().identifier(params.name);
 109     if (UNLIKELY(!identifier))
 110         return Exception { NotSupportedError };
 111 
</pre>
<hr />
<pre>
 521     switch (importParams.parametersClass()) {
 522     case CryptoAlgorithmParameters::Class::None: {
 523         auto result = makeUnique&lt;CryptoAlgorithmParameters&gt;();
 524         result-&gt;identifier = importParams.identifier;
 525         return result;
 526     }
 527     case CryptoAlgorithmParameters::Class::EcKeyParams:
 528         return makeUnique&lt;CryptoAlgorithmEcKeyParams&gt;(crossThreadCopy(downcast&lt;CryptoAlgorithmEcKeyParams&gt;(importParams)));
 529     case CryptoAlgorithmParameters::Class::HmacKeyParams:
 530         return makeUnique&lt;CryptoAlgorithmHmacKeyParams&gt;(crossThreadCopy(downcast&lt;CryptoAlgorithmHmacKeyParams&gt;(importParams)));
 531     case CryptoAlgorithmParameters::Class::RsaHashedImportParams:
 532         return makeUnique&lt;CryptoAlgorithmRsaHashedImportParams&gt;(crossThreadCopy(downcast&lt;CryptoAlgorithmRsaHashedImportParams&gt;(importParams)));
 533     default:
 534         ASSERT_NOT_REACHED();
 535         return nullptr;
 536     }
 537 }
 538 
 539 // MARK: - Exposed functions.
 540 
<span class="line-modified"> 541 void SubtleCrypto::encrypt(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 542 {
 543     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Encrypt);
 544     if (paramsOrException.hasException()) {
 545         promise-&gt;reject(paramsOrException.releaseException());
 546         return;
 547     }
 548     auto params = paramsOrException.releaseReturnValue();
 549 
 550     auto data = copyToVector(WTFMove(dataBufferSource));
 551 
 552     if (params-&gt;identifier != key.algorithmIdentifier()) {
 553         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t match AlgorithmIdentifier&quot;_s);
 554         return;
 555     }
 556 
 557     if (!key.allows(CryptoKeyUsageEncrypt)) {
 558         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t support encryption&quot;_s);
 559         return;
 560     }
 561 
 562     auto algorithm = CryptoAlgorithmRegistry::singleton().create(key.algorithmIdentifier());
 563 
 564     auto index = promise.ptr();
 565     m_pendingPromises.add(index, WTFMove(promise));
 566     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 567     auto callback = [index, subtleCryptoWeakPointer](const Vector&lt;uint8_t&gt;&amp; cipherText) mutable {
 568         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 569             fulfillPromiseWithArrayBuffer(promise.releaseNonNull(), cipherText.data(), cipherText.size());
 570     };
 571     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 572         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 573             rejectWithException(promise.releaseNonNull(), ec);
 574     };
 575 
 576     algorithm-&gt;encrypt(*params, key, WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 577 }
 578 
<span class="line-modified"> 579 void SubtleCrypto::decrypt(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 580 {
 581     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Decrypt);
 582     if (paramsOrException.hasException()) {
 583         promise-&gt;reject(paramsOrException.releaseException());
 584         return;
 585     }
 586     auto params = paramsOrException.releaseReturnValue();
 587 
 588     auto data = copyToVector(WTFMove(dataBufferSource));
 589 
 590     if (params-&gt;identifier != key.algorithmIdentifier()) {
 591         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t match AlgorithmIdentifier&quot;_s);
 592         return;
 593     }
 594 
 595     if (!key.allows(CryptoKeyUsageDecrypt)) {
 596         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t support decryption&quot;_s);
 597         return;
 598     }
 599 
 600     auto algorithm = CryptoAlgorithmRegistry::singleton().create(key.algorithmIdentifier());
 601 
 602     auto index = promise.ptr();
 603     m_pendingPromises.add(index, WTFMove(promise));
 604     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 605     auto callback = [index, subtleCryptoWeakPointer](const Vector&lt;uint8_t&gt;&amp; plainText) mutable {
 606         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 607             fulfillPromiseWithArrayBuffer(promise.releaseNonNull(), plainText.data(), plainText.size());
 608     };
 609     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 610         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 611             rejectWithException(promise.releaseNonNull(), ec);
 612     };
 613 
 614     algorithm-&gt;decrypt(*params, key, WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 615 }
 616 
<span class="line-modified"> 617 void SubtleCrypto::sign(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 618 {
 619     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Sign);
 620     if (paramsOrException.hasException()) {
 621         promise-&gt;reject(paramsOrException.releaseException());
 622         return;
 623     }
 624     auto params = paramsOrException.releaseReturnValue();
 625 
 626     auto data = copyToVector(WTFMove(dataBufferSource));
 627 
 628     if (params-&gt;identifier != key.algorithmIdentifier()) {
 629         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t match AlgorithmIdentifier&quot;_s);
 630         return;
 631     }
 632 
 633     if (!key.allows(CryptoKeyUsageSign)) {
 634         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t support signing&quot;_s);
 635         return;
 636     }
 637 
 638     auto algorithm = CryptoAlgorithmRegistry::singleton().create(key.algorithmIdentifier());
 639 
 640     auto index = promise.ptr();
 641     m_pendingPromises.add(index, WTFMove(promise));
 642     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 643     auto callback = [index, subtleCryptoWeakPointer](const Vector&lt;uint8_t&gt;&amp; signature) mutable {
 644         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 645             fulfillPromiseWithArrayBuffer(promise.releaseNonNull(), signature.data(), signature.size());
 646     };
 647     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 648         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 649             rejectWithException(promise.releaseNonNull(), ec);
 650     };
 651 
 652     algorithm-&gt;sign(*params, key, WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 653 }
 654 
<span class="line-modified"> 655 void SubtleCrypto::verify(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; signatureBufferSource, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 656 {
 657     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Verify);
 658     if (paramsOrException.hasException()) {
 659         promise-&gt;reject(paramsOrException.releaseException());
 660         return;
 661     }
 662     auto params = paramsOrException.releaseReturnValue();
 663 
 664     auto signature = copyToVector(WTFMove(signatureBufferSource));
 665     auto data = copyToVector(WTFMove(dataBufferSource));
 666 
 667     if (params-&gt;identifier != key.algorithmIdentifier()) {
 668         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t match AlgorithmIdentifier&quot;_s);
 669         return;
 670     }
 671 
 672     if (!key.allows(CryptoKeyUsageVerify)) {
 673         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t support verification&quot;_s);
 674         return;
 675     }
 676 
 677     auto algorithm = CryptoAlgorithmRegistry::singleton().create(key.algorithmIdentifier());
 678 
 679     auto index = promise.ptr();
 680     m_pendingPromises.add(index, WTFMove(promise));
 681     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 682     auto callback = [index, subtleCryptoWeakPointer](bool result) mutable {
 683         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 684             promise-&gt;resolve&lt;IDLBoolean&gt;(result);
 685     };
 686     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 687         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 688             rejectWithException(promise.releaseNonNull(), ec);
 689     };
 690 
 691     algorithm-&gt;verify(*params, key, WTFMove(signature), WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 692 }
 693 
<span class="line-modified"> 694 void SubtleCrypto::digest(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 695 {
 696     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Digest);
 697     if (paramsOrException.hasException()) {
 698         promise-&gt;reject(paramsOrException.releaseException());
 699         return;
 700     }
 701     auto params = paramsOrException.releaseReturnValue();
 702 
 703     auto data = copyToVector(WTFMove(dataBufferSource));
 704 
 705     auto algorithm = CryptoAlgorithmRegistry::singleton().create(params-&gt;identifier);
 706 
 707     auto index = promise.ptr();
 708     m_pendingPromises.add(index, WTFMove(promise));
 709     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 710     auto callback = [index, subtleCryptoWeakPointer](const Vector&lt;uint8_t&gt;&amp; digest) mutable {
 711         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 712             fulfillPromiseWithArrayBuffer(promise.releaseNonNull(), digest.data(), digest.size());
 713     };
 714     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 715         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 716             rejectWithException(promise.releaseNonNull(), ec);
 717     };
 718 
 719     algorithm-&gt;digest(WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 720 }
 721 
<span class="line-modified"> 722 void SubtleCrypto::generateKey(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 723 {
 724     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::GenerateKey);
 725     if (paramsOrException.hasException()) {
 726         promise-&gt;reject(paramsOrException.releaseException());
 727         return;
 728     }
 729     auto params = paramsOrException.releaseReturnValue();
 730 
 731     auto keyUsagesBitmap = toCryptoKeyUsageBitmap(keyUsages);
 732 
 733     auto algorithm = CryptoAlgorithmRegistry::singleton().create(params-&gt;identifier);
 734 
 735     auto index = promise.ptr();
 736     m_pendingPromises.add(index, WTFMove(promise));
 737     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 738     auto callback = [index, subtleCryptoWeakPointer](KeyOrKeyPair&amp;&amp; keyOrKeyPair) mutable {
 739         if (auto promise = getPromise(index, subtleCryptoWeakPointer)) {
 740             WTF::switchOn(keyOrKeyPair,
 741                 [&amp;promise] (RefPtr&lt;CryptoKey&gt;&amp; key) {
 742                     if ((key-&gt;type() == CryptoKeyType::Private || key-&gt;type() == CryptoKeyType::Secret) &amp;&amp; !key-&gt;usagesBitmap()) {
</pre>
<hr />
<pre>
 749                     if (!keyPair.privateKey-&gt;usagesBitmap()) {
 750                         rejectWithException(promise.releaseNonNull(), SyntaxError);
 751                         return;
 752                     }
 753                     promise-&gt;resolve&lt;IDLDictionary&lt;CryptoKeyPair&gt;&gt;(keyPair);
 754                 }
 755             );
 756         }
 757     };
 758     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 759         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 760             rejectWithException(promise.releaseNonNull(), ec);
 761     };
 762 
 763     // The 26 January 2017 version of the specification suggests we should perform the following task asynchronously
 764     // regardless what kind of keys it produces: https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-generateKey
 765     // That&#39;s simply not efficient for AES, HMAC and EC keys. Therefore, we perform it as an async task only for RSA keys.
 766     algorithm-&gt;generateKey(*params, extractable, keyUsagesBitmap, WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext());
 767 }
 768 
<span class="line-modified"> 769 void SubtleCrypto::deriveKey(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; baseKey, AlgorithmIdentifier&amp;&amp; derivedKeyType, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 770 {
 771     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::DeriveBits);
 772     if (paramsOrException.hasException()) {
 773         promise-&gt;reject(paramsOrException.releaseException());
 774         return;
 775     }
 776     auto params = paramsOrException.releaseReturnValue();
 777 
 778     auto importParamsOrException = normalizeCryptoAlgorithmParameters(state, derivedKeyType, Operations::ImportKey);
 779     if (importParamsOrException.hasException()) {
 780         promise-&gt;reject(importParamsOrException.releaseException());
 781         return;
 782     }
 783     auto importParams = importParamsOrException.releaseReturnValue();
 784 
 785     auto getLengthParamsOrException = normalizeCryptoAlgorithmParameters(state, derivedKeyType, Operations::GetKeyLength);
 786     if (getLengthParamsOrException.hasException()) {
 787         promise-&gt;reject(getLengthParamsOrException.releaseException());
 788         return;
 789     }
</pre>
<hr />
<pre>
 826                     return;
 827                 }
 828                 promise-&gt;resolve&lt;IDLInterface&lt;CryptoKey&gt;&gt;(key);
 829             }
 830         };
 831         auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 832             if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 833                 rejectWithException(promise.releaseNonNull(), ec);
 834         };
 835 
 836         importAlgorithm-&gt;importKey(SubtleCrypto::KeyFormat::Raw, WTFMove(data), *importParams, extractable, keyUsagesBitmap, WTFMove(callback), WTFMove(exceptionCallback));
 837     };
 838     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 839         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 840             rejectWithException(promise.releaseNonNull(), ec);
 841     };
 842 
 843     algorithm-&gt;deriveBits(*params, baseKey, length, WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 844 }
 845 
<span class="line-modified"> 846 void SubtleCrypto::deriveBits(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; baseKey, unsigned length, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 847 {
 848     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::DeriveBits);
 849     if (paramsOrException.hasException()) {
 850         promise-&gt;reject(paramsOrException.releaseException());
 851         return;
 852     }
 853     auto params = paramsOrException.releaseReturnValue();
 854 
 855     if (params-&gt;identifier != baseKey.algorithmIdentifier()) {
 856         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t match AlgorithmIdentifier&quot;_s);
 857         return;
 858     }
 859 
 860     if (!baseKey.allows(CryptoKeyUsageDeriveBits)) {
 861         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t support bits derivation&quot;_s);
 862         return;
 863     }
 864 
 865     auto algorithm = CryptoAlgorithmRegistry::singleton().create(params-&gt;identifier);
 866 
 867     auto index = promise.ptr();
 868     m_pendingPromises.add(index, WTFMove(promise));
 869     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 870     auto callback = [index, subtleCryptoWeakPointer](const Vector&lt;uint8_t&gt;&amp; derivedKey) mutable {
 871         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 872             fulfillPromiseWithArrayBuffer(promise.releaseNonNull(), derivedKey.data(), derivedKey.size());
 873     };
 874     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 875         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 876             rejectWithException(promise.releaseNonNull(), ec);
 877     };
 878 
 879     algorithm-&gt;deriveBits(*params, baseKey, length, WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 880 }
 881 
<span class="line-modified"> 882 void SubtleCrypto::importKey(JSC::ExecState&amp; state, KeyFormat format, KeyDataVariant&amp;&amp; keyDataVariant, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 883 {
 884     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::ImportKey);
 885     if (paramsOrException.hasException()) {
 886         promise-&gt;reject(paramsOrException.releaseException());
 887         return;
 888     }
 889     auto params = paramsOrException.releaseReturnValue();
 890 
 891     auto keyDataOrNull = toKeyData(format, WTFMove(keyDataVariant), promise);
 892     if (!keyDataOrNull) {
 893         // When toKeyData, it means the promise has been rejected, and we should return.
 894         return;
 895     }
 896 
 897     auto keyData = *keyDataOrNull;
 898     auto keyUsagesBitmap = toCryptoKeyUsageBitmap(keyUsages);
 899 
 900     auto algorithm = CryptoAlgorithmRegistry::singleton().create(params-&gt;identifier);
 901 
 902     auto index = promise.ptr();
</pre>
<hr />
<pre>
 950                 return;
 951             }
 952             case SubtleCrypto::KeyFormat::Jwk:
 953                 promise-&gt;resolve&lt;IDLDictionary&lt;JsonWebKey&gt;&gt;(WTFMove(WTF::get&lt;JsonWebKey&gt;(key)));
 954                 return;
 955             }
 956             ASSERT_NOT_REACHED();
 957         }
 958     };
 959     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 960         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 961             rejectWithException(promise.releaseNonNull(), ec);
 962     };
 963 
 964     // The 11 December 2014 version of the specification suggests we should perform the following task asynchronously:
 965     // https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-exportKey
 966     // It is not beneficial for less time consuming operations. Therefore, we perform it synchronously.
 967     algorithm-&gt;exportKey(format, key, WTFMove(callback), WTFMove(exceptionCallback));
 968 }
 969 
<span class="line-modified"> 970 void SubtleCrypto::wrapKey(JSC::ExecState&amp; state, KeyFormat format, CryptoKey&amp; key, CryptoKey&amp; wrappingKey, AlgorithmIdentifier&amp;&amp; wrapAlgorithmIdentifier, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 971 {
 972     bool isEncryption = false;
 973 
 974     auto wrapParamsOrException = normalizeCryptoAlgorithmParameters(state, wrapAlgorithmIdentifier, Operations::WrapKey);
 975     if (wrapParamsOrException.hasException()) {
 976         ASSERT(wrapParamsOrException.exception().code() != ExistingExceptionError);
 977 
 978         wrapParamsOrException = normalizeCryptoAlgorithmParameters(state, wrapAlgorithmIdentifier, Operations::Encrypt);
 979         if (wrapParamsOrException.hasException()) {
 980             promise-&gt;reject(wrapParamsOrException.releaseException());
 981             return;
 982         }
 983 
 984         isEncryption = true;
 985     }
 986     auto wrapParams = wrapParamsOrException.releaseReturnValue();
 987 
 988     if (wrapParams-&gt;identifier != wrappingKey.algorithmIdentifier()) {
 989         promise-&gt;reject(InvalidAccessError, &quot;Wrapping CryptoKey doesn&#39;t match AlgorithmIdentifier&quot;_s);
 990         return;
</pre>
<hr />
<pre>
1008     auto exportAlgorithm = CryptoAlgorithmRegistry::singleton().create(key.algorithmIdentifier());
1009     auto wrapAlgorithm = CryptoAlgorithmRegistry::singleton().create(wrappingKey.algorithmIdentifier());
1010 
1011     auto context = scriptExecutionContext();
1012 
1013     auto index = promise.ptr();
1014     m_pendingPromises.add(index, WTFMove(promise));
1015     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
1016     auto callback = [index, subtleCryptoWeakPointer, wrapAlgorithm, wrappingKey = makeRef(wrappingKey), wrapParams = WTFMove(wrapParams), isEncryption, context, workQueue = m_workQueue.copyRef()](SubtleCrypto::KeyFormat format, KeyData&amp;&amp; key) mutable {
1017         if (subtleCryptoWeakPointer) {
1018             if (auto promise = subtleCryptoWeakPointer-&gt;m_pendingPromises.get(index)) {
1019                 Vector&lt;uint8_t&gt; bytes;
1020                 switch (format) {
1021                 case SubtleCrypto::KeyFormat::Spki:
1022                 case SubtleCrypto::KeyFormat::Pkcs8:
1023                 case SubtleCrypto::KeyFormat::Raw:
1024                     bytes = WTF::get&lt;Vector&lt;uint8_t&gt;&gt;(key);
1025                     break;
1026                 case SubtleCrypto::KeyFormat::Jwk: {
1027                     // FIXME: Converting to JS just to JSON-Stringify seems inefficient. We should find a way to go directly from the struct to JSON.
<span class="line-modified">1028                     auto jwk = toJS&lt;IDLDictionary&lt;JsonWebKey&gt;&gt;(*(promise-&gt;globalObject()-&gt;globalExec()), *(promise-&gt;globalObject()), WTFMove(WTF::get&lt;JsonWebKey&gt;(key)));</span>
<span class="line-modified">1029                     String jwkString = JSONStringify(promise-&gt;globalObject()-&gt;globalExec(), jwk, 0);</span>
1030                     CString jwkUtf8String = jwkString.utf8(StrictConversion);
1031                     bytes.append(jwkUtf8String.data(), jwkUtf8String.length());
1032                 }
1033                 }
1034 
1035                 auto callback = [index, subtleCryptoWeakPointer](const Vector&lt;uint8_t&gt;&amp; wrappedKey) mutable {
1036                     if (auto promise = getPromise(index, subtleCryptoWeakPointer))
1037                         fulfillPromiseWithArrayBuffer(promise.releaseNonNull(), wrappedKey.data(), wrappedKey.size());
1038                 };
1039                 auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
1040                     if (auto promise = getPromise(index, subtleCryptoWeakPointer))
1041                         rejectWithException(promise.releaseNonNull(), ec);
1042                 };
1043 
1044                 if (!isEncryption) {
1045                     // The 11 December 2014 version of the specification suggests we should perform the following task asynchronously:
1046                     // https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-wrapKey
1047                     // It is not beneficial for less time consuming operations. Therefore, we perform it synchronously.
1048                     wrapAlgorithm-&gt;wrapKey(wrappingKey.get(), WTFMove(bytes), WTFMove(callback), WTFMove(exceptionCallback));
1049                     return;
1050                 }
1051                 // The following operation should be performed asynchronously.
1052                 wrapAlgorithm-&gt;encrypt(*wrapParams, WTFMove(wrappingKey), WTFMove(bytes), WTFMove(callback), WTFMove(exceptionCallback), *context, workQueue);
1053             }
1054         }
1055     };
1056     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
1057         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
1058             rejectWithException(promise.releaseNonNull(), ec);
1059     };
1060 
1061     // The following operation should be performed synchronously.
1062     exportAlgorithm-&gt;exportKey(format, key, WTFMove(callback), WTFMove(exceptionCallback));
1063 }
1064 
<span class="line-modified">1065 void SubtleCrypto::unwrapKey(JSC::ExecState&amp; state, KeyFormat format, BufferSource&amp;&amp; wrappedKeyBufferSource, CryptoKey&amp; unwrappingKey, AlgorithmIdentifier&amp;&amp; unwrapAlgorithmIdentifier, AlgorithmIdentifier&amp;&amp; unwrappedKeyAlgorithmIdentifier, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
1066 {
1067     auto wrappedKey = copyToVector(WTFMove(wrappedKeyBufferSource));
1068 
1069     bool isDecryption = false;
1070 
1071     auto unwrapParamsOrException = normalizeCryptoAlgorithmParameters(state, unwrapAlgorithmIdentifier, Operations::UnwrapKey);
1072     if (unwrapParamsOrException.hasException()) {
1073         ASSERT(unwrapParamsOrException.exception().code() != ExistingExceptionError);
1074 
1075         unwrapParamsOrException = normalizeCryptoAlgorithmParameters(state, unwrapAlgorithmIdentifier, Operations::Decrypt);
1076         if (unwrapParamsOrException.hasException()) {
1077             promise-&gt;reject(unwrapParamsOrException.releaseException());
1078             return;
1079         }
1080 
1081         isDecryption = true;
1082     }
1083     auto unwrapParams = unwrapParamsOrException.releaseReturnValue();
1084 
1085     auto unwrappedKeyAlgorithmOrException = normalizeCryptoAlgorithmParameters(state, unwrappedKeyAlgorithmIdentifier, Operations::ImportKey);
</pre>
<hr />
<pre>
1110     auto unwrapAlgorithm = CryptoAlgorithmRegistry::singleton().create(unwrappingKey.algorithmIdentifier());
1111     if (UNLIKELY(!unwrapAlgorithm)) {
1112         promise-&gt;reject(Exception { NotSupportedError });
1113         return;
1114     }
1115 
1116     auto index = promise.ptr();
1117     m_pendingPromises.add(index, WTFMove(promise));
1118     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
1119     auto callback = [index, subtleCryptoWeakPointer, format, importAlgorithm, unwrappedKeyAlgorithm = crossThreadCopyImportParams(*unwrappedKeyAlgorithm), extractable, keyUsagesBitmap](const Vector&lt;uint8_t&gt;&amp; bytes) mutable {
1120         if (subtleCryptoWeakPointer) {
1121             if (auto promise = subtleCryptoWeakPointer-&gt;m_pendingPromises.get(index)) {
1122                 KeyData keyData;
1123                 switch (format) {
1124                 case SubtleCrypto::KeyFormat::Spki:
1125                 case SubtleCrypto::KeyFormat::Pkcs8:
1126                 case SubtleCrypto::KeyFormat::Raw:
1127                     keyData = bytes;
1128                     break;
1129                 case SubtleCrypto::KeyFormat::Jwk: {
<span class="line-modified">1130                     auto&amp; state = *(promise-&gt;globalObject()-&gt;globalExec());</span>
1131                     auto&amp; vm = state.vm();
1132                     auto scope = DECLARE_THROW_SCOPE(vm);
1133 
1134                     String jwkString(reinterpret_cast_ptr&lt;const char*&gt;(bytes.data()), bytes.size());
1135                     JSLockHolder locker(vm);
1136                     auto jwkObject = JSONParse(&amp;state, jwkString);
1137                     if (!jwkObject) {
1138                         promise-&gt;reject(DataError, &quot;WrappedKey cannot be converted to a JSON object&quot;_s);
1139                         return;
1140                     }
1141                     auto jwk = convert&lt;IDLDictionary&lt;JsonWebKey&gt;&gt;(state, jwkObject);
1142                     RETURN_IF_EXCEPTION(scope, void());
1143                     normalizeJsonWebKey(jwk);
1144 
1145                     keyData = jwk;
1146                     break;
1147                 }
1148                 }
1149 
1150                 auto callback = [index, subtleCryptoWeakPointer](CryptoKey&amp; key) mutable {
</pre>
</td>
<td>
<hr />
<pre>
  61     , m_workQueue(WorkQueue::create(&quot;com.apple.WebKit.CryptoQueue&quot;))
  62 {
  63 }
  64 
  65 SubtleCrypto::~SubtleCrypto() = default;
  66 
  67 enum class Operations {
  68     Encrypt,
  69     Decrypt,
  70     Sign,
  71     Verify,
  72     Digest,
  73     GenerateKey,
  74     DeriveBits,
  75     ImportKey,
  76     WrapKey,
  77     UnwrapKey,
  78     GetKeyLength
  79 };
  80 
<span class="line-modified">  81 static ExceptionOr&lt;std::unique_ptr&lt;CryptoAlgorithmParameters&gt;&gt; normalizeCryptoAlgorithmParameters(JSGlobalObject&amp;, WebCore::SubtleCrypto::AlgorithmIdentifier, Operations);</span>
  82 
<span class="line-modified">  83 static ExceptionOr&lt;CryptoAlgorithmIdentifier&gt; toHashIdentifier(JSGlobalObject&amp; state, SubtleCrypto::AlgorithmIdentifier algorithmIdentifier)</span>
  84 {
  85     auto digestParams = normalizeCryptoAlgorithmParameters(state, algorithmIdentifier, Operations::Digest);
  86     if (digestParams.hasException())
  87         return digestParams.releaseException();
  88     return digestParams.returnValue()-&gt;identifier;
  89 }
  90 
<span class="line-modified">  91 static ExceptionOr&lt;std::unique_ptr&lt;CryptoAlgorithmParameters&gt;&gt; normalizeCryptoAlgorithmParameters(JSGlobalObject&amp; state, SubtleCrypto::AlgorithmIdentifier algorithmIdentifier, Operations operation)</span>
  92 {
  93     VM&amp; vm = state.vm();
  94     auto scope = DECLARE_THROW_SCOPE(vm);
  95 
  96     if (WTF::holds_alternative&lt;String&gt;(algorithmIdentifier)) {
  97         auto newParams = Strong&lt;JSObject&gt;(vm, constructEmptyObject(&amp;state));
  98         newParams-&gt;putDirect(vm, Identifier::fromString(vm, &quot;name&quot;), jsString(vm, WTF::get&lt;String&gt;(algorithmIdentifier)));
  99 
 100         return normalizeCryptoAlgorithmParameters(state, newParams, operation);
 101     }
 102 
 103     auto&amp; value = WTF::get&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;(algorithmIdentifier);
 104 
 105     auto params = convertDictionary&lt;CryptoAlgorithmParameters&gt;(state, value.get());
 106     RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 107 
 108     auto identifier = CryptoAlgorithmRegistry::singleton().identifier(params.name);
 109     if (UNLIKELY(!identifier))
 110         return Exception { NotSupportedError };
 111 
</pre>
<hr />
<pre>
 521     switch (importParams.parametersClass()) {
 522     case CryptoAlgorithmParameters::Class::None: {
 523         auto result = makeUnique&lt;CryptoAlgorithmParameters&gt;();
 524         result-&gt;identifier = importParams.identifier;
 525         return result;
 526     }
 527     case CryptoAlgorithmParameters::Class::EcKeyParams:
 528         return makeUnique&lt;CryptoAlgorithmEcKeyParams&gt;(crossThreadCopy(downcast&lt;CryptoAlgorithmEcKeyParams&gt;(importParams)));
 529     case CryptoAlgorithmParameters::Class::HmacKeyParams:
 530         return makeUnique&lt;CryptoAlgorithmHmacKeyParams&gt;(crossThreadCopy(downcast&lt;CryptoAlgorithmHmacKeyParams&gt;(importParams)));
 531     case CryptoAlgorithmParameters::Class::RsaHashedImportParams:
 532         return makeUnique&lt;CryptoAlgorithmRsaHashedImportParams&gt;(crossThreadCopy(downcast&lt;CryptoAlgorithmRsaHashedImportParams&gt;(importParams)));
 533     default:
 534         ASSERT_NOT_REACHED();
 535         return nullptr;
 536     }
 537 }
 538 
 539 // MARK: - Exposed functions.
 540 
<span class="line-modified"> 541 void SubtleCrypto::encrypt(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 542 {
 543     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Encrypt);
 544     if (paramsOrException.hasException()) {
 545         promise-&gt;reject(paramsOrException.releaseException());
 546         return;
 547     }
 548     auto params = paramsOrException.releaseReturnValue();
 549 
 550     auto data = copyToVector(WTFMove(dataBufferSource));
 551 
 552     if (params-&gt;identifier != key.algorithmIdentifier()) {
 553         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t match AlgorithmIdentifier&quot;_s);
 554         return;
 555     }
 556 
 557     if (!key.allows(CryptoKeyUsageEncrypt)) {
 558         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t support encryption&quot;_s);
 559         return;
 560     }
 561 
 562     auto algorithm = CryptoAlgorithmRegistry::singleton().create(key.algorithmIdentifier());
 563 
 564     auto index = promise.ptr();
 565     m_pendingPromises.add(index, WTFMove(promise));
 566     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 567     auto callback = [index, subtleCryptoWeakPointer](const Vector&lt;uint8_t&gt;&amp; cipherText) mutable {
 568         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 569             fulfillPromiseWithArrayBuffer(promise.releaseNonNull(), cipherText.data(), cipherText.size());
 570     };
 571     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 572         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 573             rejectWithException(promise.releaseNonNull(), ec);
 574     };
 575 
 576     algorithm-&gt;encrypt(*params, key, WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 577 }
 578 
<span class="line-modified"> 579 void SubtleCrypto::decrypt(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 580 {
 581     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Decrypt);
 582     if (paramsOrException.hasException()) {
 583         promise-&gt;reject(paramsOrException.releaseException());
 584         return;
 585     }
 586     auto params = paramsOrException.releaseReturnValue();
 587 
 588     auto data = copyToVector(WTFMove(dataBufferSource));
 589 
 590     if (params-&gt;identifier != key.algorithmIdentifier()) {
 591         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t match AlgorithmIdentifier&quot;_s);
 592         return;
 593     }
 594 
 595     if (!key.allows(CryptoKeyUsageDecrypt)) {
 596         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t support decryption&quot;_s);
 597         return;
 598     }
 599 
 600     auto algorithm = CryptoAlgorithmRegistry::singleton().create(key.algorithmIdentifier());
 601 
 602     auto index = promise.ptr();
 603     m_pendingPromises.add(index, WTFMove(promise));
 604     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 605     auto callback = [index, subtleCryptoWeakPointer](const Vector&lt;uint8_t&gt;&amp; plainText) mutable {
 606         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 607             fulfillPromiseWithArrayBuffer(promise.releaseNonNull(), plainText.data(), plainText.size());
 608     };
 609     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 610         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 611             rejectWithException(promise.releaseNonNull(), ec);
 612     };
 613 
 614     algorithm-&gt;decrypt(*params, key, WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 615 }
 616 
<span class="line-modified"> 617 void SubtleCrypto::sign(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 618 {
 619     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Sign);
 620     if (paramsOrException.hasException()) {
 621         promise-&gt;reject(paramsOrException.releaseException());
 622         return;
 623     }
 624     auto params = paramsOrException.releaseReturnValue();
 625 
 626     auto data = copyToVector(WTFMove(dataBufferSource));
 627 
 628     if (params-&gt;identifier != key.algorithmIdentifier()) {
 629         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t match AlgorithmIdentifier&quot;_s);
 630         return;
 631     }
 632 
 633     if (!key.allows(CryptoKeyUsageSign)) {
 634         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t support signing&quot;_s);
 635         return;
 636     }
 637 
 638     auto algorithm = CryptoAlgorithmRegistry::singleton().create(key.algorithmIdentifier());
 639 
 640     auto index = promise.ptr();
 641     m_pendingPromises.add(index, WTFMove(promise));
 642     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 643     auto callback = [index, subtleCryptoWeakPointer](const Vector&lt;uint8_t&gt;&amp; signature) mutable {
 644         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 645             fulfillPromiseWithArrayBuffer(promise.releaseNonNull(), signature.data(), signature.size());
 646     };
 647     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 648         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 649             rejectWithException(promise.releaseNonNull(), ec);
 650     };
 651 
 652     algorithm-&gt;sign(*params, key, WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 653 }
 654 
<span class="line-modified"> 655 void SubtleCrypto::verify(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; signatureBufferSource, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 656 {
 657     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Verify);
 658     if (paramsOrException.hasException()) {
 659         promise-&gt;reject(paramsOrException.releaseException());
 660         return;
 661     }
 662     auto params = paramsOrException.releaseReturnValue();
 663 
 664     auto signature = copyToVector(WTFMove(signatureBufferSource));
 665     auto data = copyToVector(WTFMove(dataBufferSource));
 666 
 667     if (params-&gt;identifier != key.algorithmIdentifier()) {
 668         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t match AlgorithmIdentifier&quot;_s);
 669         return;
 670     }
 671 
 672     if (!key.allows(CryptoKeyUsageVerify)) {
 673         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t support verification&quot;_s);
 674         return;
 675     }
 676 
 677     auto algorithm = CryptoAlgorithmRegistry::singleton().create(key.algorithmIdentifier());
 678 
 679     auto index = promise.ptr();
 680     m_pendingPromises.add(index, WTFMove(promise));
 681     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 682     auto callback = [index, subtleCryptoWeakPointer](bool result) mutable {
 683         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 684             promise-&gt;resolve&lt;IDLBoolean&gt;(result);
 685     };
 686     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 687         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 688             rejectWithException(promise.releaseNonNull(), ec);
 689     };
 690 
 691     algorithm-&gt;verify(*params, key, WTFMove(signature), WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 692 }
 693 
<span class="line-modified"> 694 void SubtleCrypto::digest(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 695 {
 696     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Digest);
 697     if (paramsOrException.hasException()) {
 698         promise-&gt;reject(paramsOrException.releaseException());
 699         return;
 700     }
 701     auto params = paramsOrException.releaseReturnValue();
 702 
 703     auto data = copyToVector(WTFMove(dataBufferSource));
 704 
 705     auto algorithm = CryptoAlgorithmRegistry::singleton().create(params-&gt;identifier);
 706 
 707     auto index = promise.ptr();
 708     m_pendingPromises.add(index, WTFMove(promise));
 709     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 710     auto callback = [index, subtleCryptoWeakPointer](const Vector&lt;uint8_t&gt;&amp; digest) mutable {
 711         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 712             fulfillPromiseWithArrayBuffer(promise.releaseNonNull(), digest.data(), digest.size());
 713     };
 714     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 715         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 716             rejectWithException(promise.releaseNonNull(), ec);
 717     };
 718 
 719     algorithm-&gt;digest(WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 720 }
 721 
<span class="line-modified"> 722 void SubtleCrypto::generateKey(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 723 {
 724     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::GenerateKey);
 725     if (paramsOrException.hasException()) {
 726         promise-&gt;reject(paramsOrException.releaseException());
 727         return;
 728     }
 729     auto params = paramsOrException.releaseReturnValue();
 730 
 731     auto keyUsagesBitmap = toCryptoKeyUsageBitmap(keyUsages);
 732 
 733     auto algorithm = CryptoAlgorithmRegistry::singleton().create(params-&gt;identifier);
 734 
 735     auto index = promise.ptr();
 736     m_pendingPromises.add(index, WTFMove(promise));
 737     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 738     auto callback = [index, subtleCryptoWeakPointer](KeyOrKeyPair&amp;&amp; keyOrKeyPair) mutable {
 739         if (auto promise = getPromise(index, subtleCryptoWeakPointer)) {
 740             WTF::switchOn(keyOrKeyPair,
 741                 [&amp;promise] (RefPtr&lt;CryptoKey&gt;&amp; key) {
 742                     if ((key-&gt;type() == CryptoKeyType::Private || key-&gt;type() == CryptoKeyType::Secret) &amp;&amp; !key-&gt;usagesBitmap()) {
</pre>
<hr />
<pre>
 749                     if (!keyPair.privateKey-&gt;usagesBitmap()) {
 750                         rejectWithException(promise.releaseNonNull(), SyntaxError);
 751                         return;
 752                     }
 753                     promise-&gt;resolve&lt;IDLDictionary&lt;CryptoKeyPair&gt;&gt;(keyPair);
 754                 }
 755             );
 756         }
 757     };
 758     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 759         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 760             rejectWithException(promise.releaseNonNull(), ec);
 761     };
 762 
 763     // The 26 January 2017 version of the specification suggests we should perform the following task asynchronously
 764     // regardless what kind of keys it produces: https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-generateKey
 765     // That&#39;s simply not efficient for AES, HMAC and EC keys. Therefore, we perform it as an async task only for RSA keys.
 766     algorithm-&gt;generateKey(*params, extractable, keyUsagesBitmap, WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext());
 767 }
 768 
<span class="line-modified"> 769 void SubtleCrypto::deriveKey(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; baseKey, AlgorithmIdentifier&amp;&amp; derivedKeyType, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 770 {
 771     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::DeriveBits);
 772     if (paramsOrException.hasException()) {
 773         promise-&gt;reject(paramsOrException.releaseException());
 774         return;
 775     }
 776     auto params = paramsOrException.releaseReturnValue();
 777 
 778     auto importParamsOrException = normalizeCryptoAlgorithmParameters(state, derivedKeyType, Operations::ImportKey);
 779     if (importParamsOrException.hasException()) {
 780         promise-&gt;reject(importParamsOrException.releaseException());
 781         return;
 782     }
 783     auto importParams = importParamsOrException.releaseReturnValue();
 784 
 785     auto getLengthParamsOrException = normalizeCryptoAlgorithmParameters(state, derivedKeyType, Operations::GetKeyLength);
 786     if (getLengthParamsOrException.hasException()) {
 787         promise-&gt;reject(getLengthParamsOrException.releaseException());
 788         return;
 789     }
</pre>
<hr />
<pre>
 826                     return;
 827                 }
 828                 promise-&gt;resolve&lt;IDLInterface&lt;CryptoKey&gt;&gt;(key);
 829             }
 830         };
 831         auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 832             if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 833                 rejectWithException(promise.releaseNonNull(), ec);
 834         };
 835 
 836         importAlgorithm-&gt;importKey(SubtleCrypto::KeyFormat::Raw, WTFMove(data), *importParams, extractable, keyUsagesBitmap, WTFMove(callback), WTFMove(exceptionCallback));
 837     };
 838     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 839         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 840             rejectWithException(promise.releaseNonNull(), ec);
 841     };
 842 
 843     algorithm-&gt;deriveBits(*params, baseKey, length, WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 844 }
 845 
<span class="line-modified"> 846 void SubtleCrypto::deriveBits(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; baseKey, unsigned length, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 847 {
 848     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::DeriveBits);
 849     if (paramsOrException.hasException()) {
 850         promise-&gt;reject(paramsOrException.releaseException());
 851         return;
 852     }
 853     auto params = paramsOrException.releaseReturnValue();
 854 
 855     if (params-&gt;identifier != baseKey.algorithmIdentifier()) {
 856         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t match AlgorithmIdentifier&quot;_s);
 857         return;
 858     }
 859 
 860     if (!baseKey.allows(CryptoKeyUsageDeriveBits)) {
 861         promise-&gt;reject(InvalidAccessError, &quot;CryptoKey doesn&#39;t support bits derivation&quot;_s);
 862         return;
 863     }
 864 
 865     auto algorithm = CryptoAlgorithmRegistry::singleton().create(params-&gt;identifier);
 866 
 867     auto index = promise.ptr();
 868     m_pendingPromises.add(index, WTFMove(promise));
 869     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
 870     auto callback = [index, subtleCryptoWeakPointer](const Vector&lt;uint8_t&gt;&amp; derivedKey) mutable {
 871         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 872             fulfillPromiseWithArrayBuffer(promise.releaseNonNull(), derivedKey.data(), derivedKey.size());
 873     };
 874     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 875         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 876             rejectWithException(promise.releaseNonNull(), ec);
 877     };
 878 
 879     algorithm-&gt;deriveBits(*params, baseKey, length, WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
 880 }
 881 
<span class="line-modified"> 882 void SubtleCrypto::importKey(JSC::JSGlobalObject&amp; state, KeyFormat format, KeyDataVariant&amp;&amp; keyDataVariant, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 883 {
 884     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::ImportKey);
 885     if (paramsOrException.hasException()) {
 886         promise-&gt;reject(paramsOrException.releaseException());
 887         return;
 888     }
 889     auto params = paramsOrException.releaseReturnValue();
 890 
 891     auto keyDataOrNull = toKeyData(format, WTFMove(keyDataVariant), promise);
 892     if (!keyDataOrNull) {
 893         // When toKeyData, it means the promise has been rejected, and we should return.
 894         return;
 895     }
 896 
 897     auto keyData = *keyDataOrNull;
 898     auto keyUsagesBitmap = toCryptoKeyUsageBitmap(keyUsages);
 899 
 900     auto algorithm = CryptoAlgorithmRegistry::singleton().create(params-&gt;identifier);
 901 
 902     auto index = promise.ptr();
</pre>
<hr />
<pre>
 950                 return;
 951             }
 952             case SubtleCrypto::KeyFormat::Jwk:
 953                 promise-&gt;resolve&lt;IDLDictionary&lt;JsonWebKey&gt;&gt;(WTFMove(WTF::get&lt;JsonWebKey&gt;(key)));
 954                 return;
 955             }
 956             ASSERT_NOT_REACHED();
 957         }
 958     };
 959     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
 960         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
 961             rejectWithException(promise.releaseNonNull(), ec);
 962     };
 963 
 964     // The 11 December 2014 version of the specification suggests we should perform the following task asynchronously:
 965     // https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-exportKey
 966     // It is not beneficial for less time consuming operations. Therefore, we perform it synchronously.
 967     algorithm-&gt;exportKey(format, key, WTFMove(callback), WTFMove(exceptionCallback));
 968 }
 969 
<span class="line-modified"> 970 void SubtleCrypto::wrapKey(JSC::JSGlobalObject&amp; state, KeyFormat format, CryptoKey&amp; key, CryptoKey&amp; wrappingKey, AlgorithmIdentifier&amp;&amp; wrapAlgorithmIdentifier, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
 971 {
 972     bool isEncryption = false;
 973 
 974     auto wrapParamsOrException = normalizeCryptoAlgorithmParameters(state, wrapAlgorithmIdentifier, Operations::WrapKey);
 975     if (wrapParamsOrException.hasException()) {
 976         ASSERT(wrapParamsOrException.exception().code() != ExistingExceptionError);
 977 
 978         wrapParamsOrException = normalizeCryptoAlgorithmParameters(state, wrapAlgorithmIdentifier, Operations::Encrypt);
 979         if (wrapParamsOrException.hasException()) {
 980             promise-&gt;reject(wrapParamsOrException.releaseException());
 981             return;
 982         }
 983 
 984         isEncryption = true;
 985     }
 986     auto wrapParams = wrapParamsOrException.releaseReturnValue();
 987 
 988     if (wrapParams-&gt;identifier != wrappingKey.algorithmIdentifier()) {
 989         promise-&gt;reject(InvalidAccessError, &quot;Wrapping CryptoKey doesn&#39;t match AlgorithmIdentifier&quot;_s);
 990         return;
</pre>
<hr />
<pre>
1008     auto exportAlgorithm = CryptoAlgorithmRegistry::singleton().create(key.algorithmIdentifier());
1009     auto wrapAlgorithm = CryptoAlgorithmRegistry::singleton().create(wrappingKey.algorithmIdentifier());
1010 
1011     auto context = scriptExecutionContext();
1012 
1013     auto index = promise.ptr();
1014     m_pendingPromises.add(index, WTFMove(promise));
1015     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
1016     auto callback = [index, subtleCryptoWeakPointer, wrapAlgorithm, wrappingKey = makeRef(wrappingKey), wrapParams = WTFMove(wrapParams), isEncryption, context, workQueue = m_workQueue.copyRef()](SubtleCrypto::KeyFormat format, KeyData&amp;&amp; key) mutable {
1017         if (subtleCryptoWeakPointer) {
1018             if (auto promise = subtleCryptoWeakPointer-&gt;m_pendingPromises.get(index)) {
1019                 Vector&lt;uint8_t&gt; bytes;
1020                 switch (format) {
1021                 case SubtleCrypto::KeyFormat::Spki:
1022                 case SubtleCrypto::KeyFormat::Pkcs8:
1023                 case SubtleCrypto::KeyFormat::Raw:
1024                     bytes = WTF::get&lt;Vector&lt;uint8_t&gt;&gt;(key);
1025                     break;
1026                 case SubtleCrypto::KeyFormat::Jwk: {
1027                     // FIXME: Converting to JS just to JSON-Stringify seems inefficient. We should find a way to go directly from the struct to JSON.
<span class="line-modified">1028                     auto jwk = toJS&lt;IDLDictionary&lt;JsonWebKey&gt;&gt;(*(promise-&gt;globalObject()), *(promise-&gt;globalObject()), WTFMove(WTF::get&lt;JsonWebKey&gt;(key)));</span>
<span class="line-modified">1029                     String jwkString = JSONStringify(promise-&gt;globalObject(), jwk, 0);</span>
1030                     CString jwkUtf8String = jwkString.utf8(StrictConversion);
1031                     bytes.append(jwkUtf8String.data(), jwkUtf8String.length());
1032                 }
1033                 }
1034 
1035                 auto callback = [index, subtleCryptoWeakPointer](const Vector&lt;uint8_t&gt;&amp; wrappedKey) mutable {
1036                     if (auto promise = getPromise(index, subtleCryptoWeakPointer))
1037                         fulfillPromiseWithArrayBuffer(promise.releaseNonNull(), wrappedKey.data(), wrappedKey.size());
1038                 };
1039                 auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
1040                     if (auto promise = getPromise(index, subtleCryptoWeakPointer))
1041                         rejectWithException(promise.releaseNonNull(), ec);
1042                 };
1043 
1044                 if (!isEncryption) {
1045                     // The 11 December 2014 version of the specification suggests we should perform the following task asynchronously:
1046                     // https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-wrapKey
1047                     // It is not beneficial for less time consuming operations. Therefore, we perform it synchronously.
1048                     wrapAlgorithm-&gt;wrapKey(wrappingKey.get(), WTFMove(bytes), WTFMove(callback), WTFMove(exceptionCallback));
1049                     return;
1050                 }
1051                 // The following operation should be performed asynchronously.
1052                 wrapAlgorithm-&gt;encrypt(*wrapParams, WTFMove(wrappingKey), WTFMove(bytes), WTFMove(callback), WTFMove(exceptionCallback), *context, workQueue);
1053             }
1054         }
1055     };
1056     auto exceptionCallback = [index, subtleCryptoWeakPointer](ExceptionCode ec) mutable {
1057         if (auto promise = getPromise(index, subtleCryptoWeakPointer))
1058             rejectWithException(promise.releaseNonNull(), ec);
1059     };
1060 
1061     // The following operation should be performed synchronously.
1062     exportAlgorithm-&gt;exportKey(format, key, WTFMove(callback), WTFMove(exceptionCallback));
1063 }
1064 
<span class="line-modified">1065 void SubtleCrypto::unwrapKey(JSC::JSGlobalObject&amp; state, KeyFormat format, BufferSource&amp;&amp; wrappedKeyBufferSource, CryptoKey&amp; unwrappingKey, AlgorithmIdentifier&amp;&amp; unwrapAlgorithmIdentifier, AlgorithmIdentifier&amp;&amp; unwrappedKeyAlgorithmIdentifier, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
1066 {
1067     auto wrappedKey = copyToVector(WTFMove(wrappedKeyBufferSource));
1068 
1069     bool isDecryption = false;
1070 
1071     auto unwrapParamsOrException = normalizeCryptoAlgorithmParameters(state, unwrapAlgorithmIdentifier, Operations::UnwrapKey);
1072     if (unwrapParamsOrException.hasException()) {
1073         ASSERT(unwrapParamsOrException.exception().code() != ExistingExceptionError);
1074 
1075         unwrapParamsOrException = normalizeCryptoAlgorithmParameters(state, unwrapAlgorithmIdentifier, Operations::Decrypt);
1076         if (unwrapParamsOrException.hasException()) {
1077             promise-&gt;reject(unwrapParamsOrException.releaseException());
1078             return;
1079         }
1080 
1081         isDecryption = true;
1082     }
1083     auto unwrapParams = unwrapParamsOrException.releaseReturnValue();
1084 
1085     auto unwrappedKeyAlgorithmOrException = normalizeCryptoAlgorithmParameters(state, unwrappedKeyAlgorithmIdentifier, Operations::ImportKey);
</pre>
<hr />
<pre>
1110     auto unwrapAlgorithm = CryptoAlgorithmRegistry::singleton().create(unwrappingKey.algorithmIdentifier());
1111     if (UNLIKELY(!unwrapAlgorithm)) {
1112         promise-&gt;reject(Exception { NotSupportedError });
1113         return;
1114     }
1115 
1116     auto index = promise.ptr();
1117     m_pendingPromises.add(index, WTFMove(promise));
1118     auto subtleCryptoWeakPointer = makeWeakPtr(*this);
1119     auto callback = [index, subtleCryptoWeakPointer, format, importAlgorithm, unwrappedKeyAlgorithm = crossThreadCopyImportParams(*unwrappedKeyAlgorithm), extractable, keyUsagesBitmap](const Vector&lt;uint8_t&gt;&amp; bytes) mutable {
1120         if (subtleCryptoWeakPointer) {
1121             if (auto promise = subtleCryptoWeakPointer-&gt;m_pendingPromises.get(index)) {
1122                 KeyData keyData;
1123                 switch (format) {
1124                 case SubtleCrypto::KeyFormat::Spki:
1125                 case SubtleCrypto::KeyFormat::Pkcs8:
1126                 case SubtleCrypto::KeyFormat::Raw:
1127                     keyData = bytes;
1128                     break;
1129                 case SubtleCrypto::KeyFormat::Jwk: {
<span class="line-modified">1130                     auto&amp; state = *(promise-&gt;globalObject());</span>
1131                     auto&amp; vm = state.vm();
1132                     auto scope = DECLARE_THROW_SCOPE(vm);
1133 
1134                     String jwkString(reinterpret_cast_ptr&lt;const char*&gt;(bytes.data()), bytes.size());
1135                     JSLockHolder locker(vm);
1136                     auto jwkObject = JSONParse(&amp;state, jwkString);
1137                     if (!jwkObject) {
1138                         promise-&gt;reject(DataError, &quot;WrappedKey cannot be converted to a JSON object&quot;_s);
1139                         return;
1140                     }
1141                     auto jwk = convert&lt;IDLDictionary&lt;JsonWebKey&gt;&gt;(state, jwkObject);
1142                     RETURN_IF_EXCEPTION(scope, void());
1143                     normalizeJsonWebKey(jwk);
1144 
1145                     keyData = jwk;
1146                     break;
1147                 }
1148                 }
1149 
1150                 auto callback = [index, subtleCryptoWeakPointer](CryptoKey&amp; key) mutable {
</pre>
</td>
</tr>
</table>
<center><a href="CryptoAlgorithm.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SubtleCrypto.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/cache/DOMCacheStorage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DOMCacheStorage.h&quot;
 28 
 29 #include &quot;CacheQueryOptions.h&quot;
 30 #include &quot;ClientOrigin.h&quot;
<a name="1" id="anc1"></a>
 31 #include &quot;JSDOMCache.h&quot;
 32 #include &quot;JSFetchResponse.h&quot;
 33 #include &quot;ScriptExecutionContext.h&quot;
 34 
<a name="2" id="anc2"></a><span class="line-removed"> 35 </span>
 36 namespace WebCore {
 37 using namespace WebCore::DOMCacheEngine;
 38 
 39 DOMCacheStorage::DOMCacheStorage(ScriptExecutionContext&amp; context, Ref&lt;CacheStorageConnection&gt;&amp;&amp; connection)
 40     : ActiveDOMObject(&amp;context)
 41     , m_connection(WTFMove(connection))
 42 {
 43     suspendIfNeeded();
 44 }
 45 
<a name="3" id="anc3"></a>

 46 Optional&lt;ClientOrigin&gt; DOMCacheStorage::origin() const
 47 {
 48     auto* origin = scriptExecutionContext() ? scriptExecutionContext()-&gt;securityOrigin() : nullptr;
 49     if (!origin)
 50         return WTF::nullopt;
 51 
 52     return ClientOrigin { scriptExecutionContext()-&gt;topOrigin().data(), origin-&gt;data() };
 53 }
 54 
 55 static void doSequentialMatch(size_t index, Vector&lt;Ref&lt;DOMCache&gt;&gt;&amp;&amp; caches, DOMCache::RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, DOMCache::MatchCallback&amp;&amp; completionHandler)
 56 {
 57     if (index &gt;= caches.size()) {
 58         completionHandler(nullptr);
 59         return;
 60     }
 61 
 62     auto&amp; cache = caches[index].get();
<a name="4" id="anc4"></a><span class="line-modified"> 63     cache.doMatch(WTFMove(info), WTFMove(options), [caches = WTFMove(caches), info, options, completionHandler = WTFMove(completionHandler), index](ExceptionOr&lt;FetchResponse*&gt;&amp;&amp; result) mutable {</span>
 64         if (result.hasException()) {
 65             completionHandler(result.releaseException());
 66             return;
 67         }
 68         if (result.returnValue()) {
<a name="5" id="anc5"></a><span class="line-modified"> 69             completionHandler(result.returnValue());</span>
 70             return;
 71         }
 72         doSequentialMatch(++index, WTFMove(caches), WTFMove(info), WTFMove(options), WTFMove(completionHandler));
 73     });
 74 }
 75 
 76 static inline void startSequentialMatch(Vector&lt;Ref&lt;DOMCache&gt;&gt;&amp;&amp; caches, DOMCache::RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, DOMCache::MatchCallback&amp;&amp; completionHandler)
 77 {
 78     doSequentialMatch(0, WTFMove(caches), WTFMove(info), WTFMove(options), WTFMove(completionHandler));
 79 }
 80 
 81 static inline Ref&lt;DOMCache&gt; copyCache(const Ref&lt;DOMCache&gt;&amp; cache)
 82 {
 83     return cache.copyRef();
 84 }
 85 
 86 void DOMCacheStorage::doSequentialMatch(DOMCache::RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 87 {
<a name="6" id="anc6"></a><span class="line-modified"> 88     startSequentialMatch(WTF::map(m_caches, copyCache), WTFMove(info), WTFMove(options), [this, pendingActivity = makePendingActivity(*this), promise = WTFMove(promise)](ExceptionOr&lt;FetchResponse*&gt;&amp;&amp; result) mutable {</span>
<span class="line-removed"> 89         if (m_isStopped)</span>
<span class="line-removed"> 90             return;</span>
 91         if (result.hasException()) {
 92             promise-&gt;reject(result.releaseException());
 93             return;
 94         }
 95         if (!result.returnValue()) {
 96             promise-&gt;resolve();
 97             return;
 98         }
 99         promise-&gt;resolve&lt;IDLInterface&lt;FetchResponse&gt;&gt;(*result.returnValue());
100     });
101 }
102 
103 void DOMCacheStorage::match(DOMCache::RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
104 {
105     retrieveCaches([this, info = WTFMove(info), options = WTFMove(options), promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
106         if (exception) {
<a name="7" id="anc7"></a><span class="line-modified">107             promise-&gt;reject(WTFMove(exception.value()));</span>
108             return;
109         }
110 
111         if (!options.cacheName.isNull()) {
112             auto position = m_caches.findMatching([&amp;](auto&amp; item) { return item-&gt;name() == options.cacheName; });
113             if (position != notFound) {
114                 m_caches[position]-&gt;match(WTFMove(info), WTFMove(options), WTFMove(promise));
115                 return;
116             }
117             promise-&gt;resolve();
118             return;
119         }
120 
121         this-&gt;doSequentialMatch(WTFMove(info), WTFMove(options), WTFMove(promise));
122     });
123 }
124 
125 void DOMCacheStorage::has(const String&amp; name, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
126 {
127     retrieveCaches([this, name, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
128         if (exception) {
129             promise.reject(WTFMove(exception.value()));
130             return;
131         }
132         promise.resolve(m_caches.findMatching([&amp;](auto&amp; item) { return item-&gt;name() == name; }) != notFound);
133     });
134 }
135 
136 Ref&lt;DOMCache&gt; DOMCacheStorage::findCacheOrCreate(CacheInfo&amp;&amp; info)
137 {
138    auto position = m_caches.findMatching([&amp;] (const auto&amp; cache) { return info.identifier == cache-&gt;identifier(); });
139    if (position != notFound)
140        return m_caches[position].copyRef();
141    return DOMCache::create(*scriptExecutionContext(), WTFMove(info.name), info.identifier, m_connection.copyRef());
142 }
143 
<a name="8" id="anc8"></a><span class="line-modified">144 void DOMCacheStorage::retrieveCaches(WTF::Function&lt;void(Optional&lt;Exception&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
145 {
146     auto origin = this-&gt;origin();
<a name="9" id="anc9"></a><span class="line-modified">147     if (!origin)</span>

148         return;
<a name="10" id="anc10"></a>
149 
150     m_connection-&gt;retrieveCaches(*origin, m_updateCounter, [this, callback = WTFMove(callback), pendingActivity = makePendingActivity(*this)](CacheInfosOrError&amp;&amp; result) mutable {
<a name="11" id="anc11"></a><span class="line-modified">151         if (!m_isStopped) {</span>
<span class="line-modified">152             if (!result.has_value()) {</span>
<span class="line-modified">153                 callback(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));</span>
<span class="line-modified">154                 return;</span>
<span class="line-modified">155             }</span>



156 
<a name="12" id="anc12"></a><span class="line-modified">157             auto&amp; cachesInfo = result.value();</span>
158 
<a name="13" id="anc13"></a><span class="line-modified">159             if (m_updateCounter != cachesInfo.updateCounter) {</span>
<span class="line-modified">160                 m_updateCounter = cachesInfo.updateCounter;</span>
161 
<a name="14" id="anc14"></a><span class="line-modified">162                 m_caches = WTF::map(WTFMove(cachesInfo.infos), [this] (CacheInfo&amp;&amp; info) {</span>
<span class="line-modified">163                     return findCacheOrCreate(WTFMove(info));</span>
<span class="line-modified">164                 });</span>
<span class="line-removed">165             }</span>
<span class="line-removed">166             callback(WTF::nullopt);</span>
167         }
<a name="15" id="anc15"></a>
168     });
169 }
170 
171 static void logConsolePersistencyError(ScriptExecutionContext* context, const String&amp; cacheName)
172 {
173     if (!context)
174         return;
175 
176     context-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, makeString(&quot;There was an error making &quot;, cacheName, &quot; persistent on the filesystem&quot;));
177 }
178 
179 void DOMCacheStorage::open(const String&amp; name, DOMPromiseDeferred&lt;IDLInterface&lt;DOMCache&gt;&gt;&amp;&amp; promise)
180 {
181     retrieveCaches([this, name, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
182         if (exception) {
<a name="16" id="anc16"></a><span class="line-modified">183             promise.reject(WTFMove(exception.value()));</span>
184             return;
185         }
186         doOpen(name, WTFMove(promise));
187     });
188 }
189 
190 void DOMCacheStorage::doOpen(const String&amp; name, DOMPromiseDeferred&lt;IDLInterface&lt;DOMCache&gt;&gt;&amp;&amp; promise)
191 {
192     auto position = m_caches.findMatching([&amp;](auto&amp; item) { return item-&gt;name() == name; });
193     if (position != notFound) {
<a name="17" id="anc17"></a><span class="line-modified">194         auto&amp; cache = m_caches[position];</span>
<span class="line-removed">195         promise.resolve(DOMCache::create(*scriptExecutionContext(), String { cache-&gt;name() }, cache-&gt;identifier(), m_connection.copyRef()));</span>
196         return;
197     }
198 
199     m_connection-&gt;open(*origin(), name, [this, name, promise = WTFMove(promise), pendingActivity = makePendingActivity(*this)](const CacheIdentifierOrError&amp; result) mutable {
<a name="18" id="anc18"></a><span class="line-modified">200         if (!m_isStopped) {</span>
<span class="line-modified">201             if (!result.has_value())</span>
<span class="line-modified">202                 promise.reject(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));</span>
<span class="line-modified">203             else {</span>
<span class="line-modified">204                 if (result.value().hadStorageError)</span>
<span class="line-modified">205                     logConsolePersistencyError(scriptExecutionContext(), name);</span>
<span class="line-modified">206 </span>
<span class="line-modified">207                 auto cache = DOMCache::create(*scriptExecutionContext(), String { name }, result.value().identifier, m_connection.copyRef());</span>
<span class="line-modified">208                 promise.resolve(cache);</span>
<span class="line-removed">209                 m_caches.append(WTFMove(cache));</span>
<span class="line-removed">210             }</span>
211         }
212     });
213 }
214 
215 void DOMCacheStorage::remove(const String&amp; name, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
216 {
217     retrieveCaches([this, name, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
218         if (exception) {
<a name="19" id="anc19"></a><span class="line-modified">219             promise.reject(WTFMove(exception.value()));</span>
220             return;
221         }
222         doRemove(name, WTFMove(promise));
223     });
224 }
225 
226 void DOMCacheStorage::doRemove(const String&amp; name, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
227 {
228     auto position = m_caches.findMatching([&amp;](auto&amp; item) { return item-&gt;name() == name; });
229     if (position == notFound) {
230         promise.resolve(false);
231         return;
232     }
233 
234     m_connection-&gt;remove(m_caches[position]-&gt;identifier(), [this, name, promise = WTFMove(promise), pendingActivity = makePendingActivity(*this)](const CacheIdentifierOrError&amp; result) mutable {
<a name="20" id="anc20"></a><span class="line-modified">235         if (!m_isStopped) {</span>
<span class="line-modified">236             if (!result.has_value())</span>
<span class="line-modified">237                 promise.reject(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));</span>
<span class="line-modified">238             else {</span>
<span class="line-modified">239                 if (result.value().hadStorageError)</span>
<span class="line-modified">240                     logConsolePersistencyError(scriptExecutionContext(), name);</span>
<span class="line-removed">241                 promise.resolve(!!result.value().identifier);</span>
<span class="line-removed">242             }</span>
243         }
244     });
245 }
246 
247 void DOMCacheStorage::keys(KeysPromise&amp;&amp; promise)
248 {
249     retrieveCaches([this, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
250         if (exception) {
251             promise.reject(WTFMove(exception.value()));
252             return;
253         }
254 
255         promise.resolve(WTF::map(m_caches, [] (const auto&amp; cache) {
256             return cache-&gt;name();
257         }));
258     });
259 }
260 
261 void DOMCacheStorage::stop()
262 {
263     m_isStopped = true;
264 }
265 
266 const char* DOMCacheStorage::activeDOMObjectName() const
267 {
268     return &quot;CacheStorage&quot;;
269 }
270 
<a name="21" id="anc21"></a><span class="line-removed">271 bool DOMCacheStorage::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">272 {</span>
<span class="line-removed">273     return !hasPendingActivity();</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
276 } // namespace WebCore
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
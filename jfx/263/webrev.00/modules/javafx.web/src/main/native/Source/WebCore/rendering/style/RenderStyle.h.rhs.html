<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
   3  *           (C) 2000 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
   5  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
   6  * Copyright (C) 2006 Graham Dennis (graham.dennis@gmail.com)
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #pragma once
  26 
  27 #include &quot;AnimationList.h&quot;
  28 #include &quot;BorderValue.h&quot;
  29 #include &quot;CSSLineBoxContainValue.h&quot;
  30 #include &quot;CSSPrimitiveValue.h&quot;
  31 #include &quot;CSSPropertyNames.h&quot;
  32 #include &quot;Color.h&quot;
  33 #include &quot;CounterDirectives.h&quot;
  34 #include &quot;DataRef.h&quot;
  35 #include &quot;FilterOperations.h&quot;
  36 #include &quot;FontCascadeDescription.h&quot;
  37 #include &quot;GapLength.h&quot;
  38 #include &quot;GraphicsTypes.h&quot;
  39 #include &quot;Length.h&quot;
  40 #include &quot;LengthBox.h&quot;
  41 #include &quot;LengthFunctions.h&quot;
  42 #include &quot;LengthPoint.h&quot;
  43 #include &quot;LengthSize.h&quot;
  44 #include &quot;LineClampValue.h&quot;
  45 #include &quot;NinePieceImage.h&quot;
  46 #include &quot;Pagination.h&quot;
  47 #include &quot;RenderStyleConstants.h&quot;
  48 #include &quot;RoundedRect.h&quot;
  49 #include &quot;SVGRenderStyle.h&quot;
  50 #include &quot;ShadowData.h&quot;
  51 #include &quot;ShapeValue.h&quot;
  52 #include &quot;StyleBackgroundData.h&quot;
  53 #include &quot;StyleBoxData.h&quot;
  54 #include &quot;StyleDeprecatedFlexibleBoxData.h&quot;
  55 #include &quot;StyleFilterData.h&quot;
  56 #include &quot;StyleFlexibleBoxData.h&quot;
  57 #include &quot;StyleMarqueeData.h&quot;
  58 #include &quot;StyleMultiColData.h&quot;
  59 #include &quot;StyleRareInheritedData.h&quot;
  60 #include &quot;StyleRareNonInheritedData.h&quot;
  61 #include &quot;StyleReflection.h&quot;
  62 #include &quot;StyleSurroundData.h&quot;
  63 #include &quot;StyleTransformData.h&quot;
  64 #include &quot;StyleVisualData.h&quot;
  65 #include &quot;TextFlags.h&quot;
  66 #include &quot;ThemeTypes.h&quot;
  67 #include &quot;TouchAction.h&quot;
  68 #include &quot;TransformOperations.h&quot;
  69 #include &quot;UnicodeBidi.h&quot;
  70 #include &lt;memory&gt;
  71 #include &lt;wtf/Forward.h&gt;
  72 #include &lt;wtf/NeverDestroyed.h&gt;
  73 #include &lt;wtf/OptionSet.h&gt;
  74 #include &lt;wtf/StdLibExtras.h&gt;
  75 #include &lt;wtf/Vector.h&gt;
  76 
  77 #include &quot;StyleGridData.h&quot;
  78 #include &quot;StyleGridItemData.h&quot;
  79 
  80 #if ENABLE(TEXT_AUTOSIZING)
  81 #include &quot;TextSizeAdjustment.h&quot;
  82 #endif
  83 
  84 #if ENABLE(DARK_MODE_CSS)
  85 #include &quot;StyleColorScheme.h&quot;
  86 #endif
  87 
  88 #define SET_VAR(group, variable, value) do { \
  89         if (!compareEqual(group-&gt;variable, value)) \
  90             group.access().variable = value; \
  91     } while (0)
  92 
  93 #define SET_NESTED_VAR(group, parentVariable, variable, value) do { \
  94         if (!compareEqual(group-&gt;parentVariable-&gt;variable, value)) \
  95             group.access().parentVariable.access().variable = value; \
  96     } while (0)
  97 
  98 #define SET_BORDERVALUE_COLOR(group, variable, value) do { \
  99         if (!compareEqual(group-&gt;variable.color(), value)) \
 100             group.access().variable.setColor(value); \
 101     } while (0)
 102 
 103 namespace WebCore {
 104 
 105 class BorderData;
 106 class ContentData;
 107 class CounterContent;
 108 class CursorList;
 109 class FontCascade;
 110 class FontMetrics;
 111 class IntRect;
 112 class Pair;
 113 class ShadowData;
 114 class StyleImage;
 115 class StyleInheritedData;
<a name="1" id="anc1"></a>
 116 class StyleScrollSnapArea;
 117 class StyleScrollSnapPort;
 118 class TransformationMatrix;
 119 
 120 struct ScrollSnapAlign;
 121 struct ScrollSnapType;
 122 
 123 using PseudoStyleCache = Vector&lt;std::unique_ptr&lt;RenderStyle&gt;, 4&gt;;
 124 
 125 template&lt;typename T, typename U&gt; inline bool compareEqual(const T&amp; t, const U&amp; u) { return t == static_cast&lt;const T&amp;&gt;(u); }
 126 
<a name="2" id="anc2"></a><span class="line-added"> 127 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderStyle);</span>
 128 class RenderStyle {
<a name="3" id="anc3"></a><span class="line-modified"> 129     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(RenderStyle);</span>

 130 private:
 131     enum CloneTag { Clone };
 132     enum CreateDefaultStyleTag { CreateDefaultStyle };
 133 
 134 public:
 135     RenderStyle(RenderStyle&amp;&amp;);
 136     RenderStyle&amp; operator=(RenderStyle&amp;&amp;);
<a name="4" id="anc4"></a><span class="line-modified"> 137     WEBCORE_EXPORT ~RenderStyle();</span>
 138 
 139     RenderStyle replace(RenderStyle&amp;&amp;) WARN_UNUSED_RETURN;
 140 
 141     explicit RenderStyle(CreateDefaultStyleTag);
 142     RenderStyle(const RenderStyle&amp;, CloneTag);
 143 
 144     static RenderStyle&amp; defaultStyle();
 145 
 146     static RenderStyle create();
 147     static std::unique_ptr&lt;RenderStyle&gt; createPtr();
 148 
 149     static RenderStyle clone(const RenderStyle&amp;);
 150     static std::unique_ptr&lt;RenderStyle&gt; clonePtr(const RenderStyle&amp;);
 151 
 152     static RenderStyle createAnonymousStyleWithDisplay(const RenderStyle&amp; parentStyle, DisplayType);
 153     static RenderStyle createStyleInheritingFromPseudoStyle(const RenderStyle&amp; pseudoStyle);
 154 
<a name="5" id="anc5"></a><span class="line-modified"> 155 #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)</span>
 156     bool deletionHasBegun() const { return m_deletionHasBegun; }
 157 #endif
 158 
 159     bool operator==(const RenderStyle&amp;) const;
 160     bool operator!=(const RenderStyle&amp; other) const { return !(*this == other); }
 161 
 162     void inheritFrom(const RenderStyle&amp; inheritParent);
 163     void copyNonInheritedFrom(const RenderStyle&amp;);
 164     void copyContentFrom(const RenderStyle&amp;);
 165 
 166     ContentPosition resolvedJustifyContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 167     ContentDistribution resolvedJustifyContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 168     ContentPosition resolvedAlignContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 169     ContentDistribution resolvedAlignContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 170     StyleSelfAlignmentData resolvedAlignItems(ItemPosition normalValueBehaviour) const;
 171     StyleSelfAlignmentData resolvedAlignSelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 172     StyleContentAlignmentData resolvedAlignContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
 173     StyleSelfAlignmentData resolvedJustifyItems(ItemPosition normalValueBehaviour) const;
 174     StyleSelfAlignmentData resolvedJustifySelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 175     StyleContentAlignmentData resolvedJustifyContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
 176 
 177     PseudoId styleType() const { return static_cast&lt;PseudoId&gt;(m_nonInheritedFlags.styleType); }
 178     void setStyleType(PseudoId styleType) { m_nonInheritedFlags.styleType = static_cast&lt;unsigned&gt;(styleType); }
 179 
 180     RenderStyle* getCachedPseudoStyle(PseudoId) const;
 181     RenderStyle* addCachedPseudoStyle(std::unique_ptr&lt;RenderStyle&gt;);
 182     void removeCachedPseudoStyle(PseudoId);
 183 
 184     const PseudoStyleCache* cachedPseudoStyles() const { return m_cachedPseudoStyles.get(); }
 185 
 186     const CustomPropertyValueMap&amp; inheritedCustomProperties() const { return m_rareInheritedData-&gt;customProperties-&gt;values; }
 187     const CustomPropertyValueMap&amp; nonInheritedCustomProperties() const { return m_rareNonInheritedData-&gt;customProperties-&gt;values; }
 188     const CSSCustomPropertyValue* getCustomProperty(const AtomString&amp;) const;
 189     void setInheritedCustomPropertyValue(const AtomString&amp; name, Ref&lt;CSSCustomPropertyValue&gt;&amp;&amp; value) { return m_rareInheritedData.access().customProperties.access().setCustomPropertyValue(name, WTFMove(value)); }
 190     void setNonInheritedCustomPropertyValue(const AtomString&amp; name, Ref&lt;CSSCustomPropertyValue&gt;&amp;&amp; value) { return m_rareNonInheritedData.access().customProperties.access().setCustomPropertyValue(name, WTFMove(value)); }
 191 
 192     void setHasViewportUnits(bool v = true) { m_nonInheritedFlags.hasViewportUnits = v; }
 193     bool hasViewportUnits() const { return m_nonInheritedFlags.hasViewportUnits; }
 194 
 195     bool affectedByHover() const { return m_nonInheritedFlags.affectedByHover; }
 196     bool affectedByActive() const { return m_nonInheritedFlags.affectedByActive; }
 197     bool affectedByDrag() const { return m_nonInheritedFlags.affectedByDrag; }
 198 
 199     void setAffectedByHover() { m_nonInheritedFlags.affectedByHover = true; }
 200     void setAffectedByActive() { m_nonInheritedFlags.affectedByActive = true; }
 201     void setAffectedByDrag() { m_nonInheritedFlags.affectedByDrag = true; }
 202 
 203     void setColumnStylesFromPaginationMode(const Pagination::Mode&amp;);
 204 
 205     bool isFloating() const { return static_cast&lt;Float&gt;(m_nonInheritedFlags.floating) != Float::No; }
 206     bool hasMargin() const { return !m_surroundData-&gt;margin.isZero(); }
 207     bool hasBorder() const { return m_surroundData-&gt;border.hasBorder(); }
 208     bool hasBorderFill() const { return m_surroundData-&gt;border.hasFill(); }
 209     bool hasVisibleBorderDecoration() const { return hasVisibleBorder() || hasBorderFill(); }
 210     bool hasVisibleBorder() const { return m_surroundData-&gt;border.hasVisibleBorder(); }
 211     bool hasPadding() const { return !m_surroundData-&gt;padding.isZero(); }
 212     bool hasOffset() const { return !m_surroundData-&gt;offset.isZero(); }
 213     bool hasMarginBeforeQuirk() const { return marginBefore().hasQuirk(); }
 214     bool hasMarginAfterQuirk() const { return marginAfter().hasQuirk(); }
 215 
 216     bool hasBackgroundImage() const { return m_backgroundData-&gt;background.hasImage(); }
 217     bool hasFixedBackgroundImage() const { return m_backgroundData-&gt;background.hasFixedImage(); }
 218 
 219     bool hasEntirelyFixedBackground() const;
 220 
 221     bool hasAppearance() const { return appearance() != NoControlPart; }
 222 
 223     bool hasBackground() const;
 224 
 225     LayoutBoxExtent imageOutsets(const NinePieceImage&amp;) const;
 226     bool hasBorderImageOutsets() const { return borderImage().hasImage() &amp;&amp; !borderImage().outset().isZero(); }
 227     LayoutBoxExtent borderImageOutsets() const { return imageOutsets(borderImage()); }
 228 
 229     LayoutBoxExtent maskBoxImageOutsets() const { return imageOutsets(maskBoxImage()); }
 230 
<a name="6" id="anc6"></a><span class="line-modified"> 231     IntOutsets filterOutsets() const { return hasFilter() ? filter().outsets() : IntOutsets(); }</span>

 232 
 233     Order rtlOrdering() const { return static_cast&lt;Order&gt;(m_inheritedFlags.rtlOrdering); }
 234     void setRTLOrdering(Order ordering) { m_inheritedFlags.rtlOrdering = static_cast&lt;unsigned&gt;(ordering); }
 235 
 236     bool isStyleAvailable() const;
 237 
 238     bool hasAnyPublicPseudoStyles() const;
 239     bool hasPseudoStyle(PseudoId) const;
 240     void setHasPseudoStyle(PseudoId);
 241     void setHasPseudoStyles(PseudoIdSet);
 242     bool hasUniquePseudoStyle() const;
 243 
 244     // attribute getter methods
 245 
 246     DisplayType display() const { return static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.effectiveDisplay); }
 247 
 248     const Length&amp; left() const { return m_surroundData-&gt;offset.left(); }
 249     const Length&amp; right() const { return m_surroundData-&gt;offset.right(); }
 250     const Length&amp; top() const { return m_surroundData-&gt;offset.top(); }
 251     const Length&amp; bottom() const { return m_surroundData-&gt;offset.bottom(); }
 252 
 253     // Accessors for positioned object edges that take into account writing mode.
 254     const Length&amp; logicalLeft() const { return m_surroundData-&gt;offset.start(writingMode()); }
 255     const Length&amp; logicalRight() const { return m_surroundData-&gt;offset.end(writingMode()); }
 256     const Length&amp; logicalTop() const { return m_surroundData-&gt;offset.before(writingMode()); }
 257     const Length&amp; logicalBottom() const { return m_surroundData-&gt;offset.after(writingMode()); }
 258 
 259     // Whether or not a positioned element requires normal flow x/y to be computed  to determine its position.
 260     bool hasStaticInlinePosition(bool horizontal) const { return horizontal ? hasAutoLeftAndRight() : hasAutoTopAndBottom(); }
 261     bool hasStaticBlockPosition(bool horizontal) const { return horizontal ? hasAutoTopAndBottom() : hasAutoLeftAndRight(); }
 262 
 263     PositionType position() const { return static_cast&lt;PositionType&gt;(m_nonInheritedFlags.position); }
 264     bool hasOutOfFlowPosition() const { return position() == PositionType::Absolute || position() == PositionType::Fixed; }
 265     bool hasInFlowPosition() const { return position() == PositionType::Relative || position() == PositionType::Sticky; }
 266     bool hasViewportConstrainedPosition() const { return position() == PositionType::Fixed || position() == PositionType::Sticky; }
 267     Float floating() const { return static_cast&lt;Float&gt;(m_nonInheritedFlags.floating); }
 268 
 269     const Length&amp; width() const { return m_boxData-&gt;width(); }
 270     const Length&amp; height() const { return m_boxData-&gt;height(); }
 271     const Length&amp; minWidth() const { return m_boxData-&gt;minWidth(); }
 272     const Length&amp; maxWidth() const { return m_boxData-&gt;maxWidth(); }
 273     const Length&amp; minHeight() const { return m_boxData-&gt;minHeight(); }
 274     const Length&amp; maxHeight() const { return m_boxData-&gt;maxHeight(); }
 275 
 276     const Length&amp; logicalWidth() const { return isHorizontalWritingMode() ? width() : height(); }
 277     const Length&amp; logicalHeight() const { return isHorizontalWritingMode() ? height() : width(); }
 278     const Length&amp; logicalMinWidth() const { return isHorizontalWritingMode() ? minWidth() : minHeight(); }
 279     const Length&amp; logicalMaxWidth() const { return isHorizontalWritingMode() ? maxWidth() : maxHeight(); }
 280     const Length&amp; logicalMinHeight() const { return isHorizontalWritingMode() ? minHeight() : minWidth(); }
 281     const Length&amp; logicalMaxHeight() const { return isHorizontalWritingMode() ? maxHeight() : maxWidth(); }
 282 
 283     const BorderData&amp; border() const { return m_surroundData-&gt;border; }
 284     const BorderValue&amp; borderLeft() const { return m_surroundData-&gt;border.left(); }
 285     const BorderValue&amp; borderRight() const { return m_surroundData-&gt;border.right(); }
 286     const BorderValue&amp; borderTop() const { return m_surroundData-&gt;border.top(); }
 287     const BorderValue&amp; borderBottom() const { return m_surroundData-&gt;border.bottom(); }
 288 
 289     const BorderValue&amp; borderBefore() const;
 290     const BorderValue&amp; borderAfter() const;
 291     const BorderValue&amp; borderStart() const;
 292     const BorderValue&amp; borderEnd() const;
 293 
 294     const NinePieceImage&amp; borderImage() const { return m_surroundData-&gt;border.image(); }
 295     StyleImage* borderImageSource() const { return m_surroundData-&gt;border.image().image(); }
 296     const LengthBox&amp; borderImageSlices() const { return m_surroundData-&gt;border.image().imageSlices(); }
 297     const LengthBox&amp; borderImageWidth() const { return m_surroundData-&gt;border.image().borderSlices(); }
 298     const LengthBox&amp; borderImageOutset() const { return m_surroundData-&gt;border.image().outset(); }
 299 
<a name="7" id="anc7"></a><span class="line-modified"> 300     const LengthSize&amp; borderTopLeftRadius() const { return m_surroundData-&gt;border.topLeftRadius(); }</span>
<span class="line-modified"> 301     const LengthSize&amp; borderTopRightRadius() const { return m_surroundData-&gt;border.topRightRadius(); }</span>
<span class="line-modified"> 302     const LengthSize&amp; borderBottomLeftRadius() const { return m_surroundData-&gt;border.bottomLeftRadius(); }</span>
<span class="line-modified"> 303     const LengthSize&amp; borderBottomRightRadius() const { return m_surroundData-&gt;border.bottomRightRadius(); }</span>
 304     bool hasBorderRadius() const { return m_surroundData-&gt;border.hasBorderRadius(); }
 305 
 306     float borderLeftWidth() const { return m_surroundData-&gt;border.borderLeftWidth(); }
 307     BorderStyle borderLeftStyle() const { return m_surroundData-&gt;border.left().style(); }
 308     bool borderLeftIsTransparent() const { return m_surroundData-&gt;border.left().isTransparent(); }
 309     float borderRightWidth() const { return m_surroundData-&gt;border.borderRightWidth(); }
 310     BorderStyle borderRightStyle() const { return m_surroundData-&gt;border.right().style(); }
 311     bool borderRightIsTransparent() const { return m_surroundData-&gt;border.right().isTransparent(); }
 312     float borderTopWidth() const { return m_surroundData-&gt;border.borderTopWidth(); }
 313     BorderStyle borderTopStyle() const { return m_surroundData-&gt;border.top().style(); }
 314     bool borderTopIsTransparent() const { return m_surroundData-&gt;border.top().isTransparent(); }
 315     float borderBottomWidth() const { return m_surroundData-&gt;border.borderBottomWidth(); }
 316     BorderStyle borderBottomStyle() const { return m_surroundData-&gt;border.bottom().style(); }
 317     bool borderBottomIsTransparent() const { return m_surroundData-&gt;border.bottom().isTransparent(); }
 318     FloatBoxExtent borderWidth() const { return m_surroundData-&gt;border.borderWidth(); }
 319 
 320     float borderBeforeWidth() const;
 321     float borderAfterWidth() const;
 322     float borderStartWidth() const;
 323     float borderEndWidth() const;
 324 
 325     float outlineSize() const { return std::max&lt;float&gt;(0, outlineWidth() + outlineOffset()); }
 326     float outlineWidth() const;
 327     bool hasOutline() const { return outlineStyle() &gt; BorderStyle::Hidden &amp;&amp; outlineWidth() &gt; 0; }
 328     BorderStyle outlineStyle() const { return m_backgroundData-&gt;outline.style(); }
 329     OutlineIsAuto outlineStyleIsAuto() const { return static_cast&lt;OutlineIsAuto&gt;(m_backgroundData-&gt;outline.isAuto()); }
 330     bool hasOutlineInVisualOverflow() const { return hasOutline() &amp;&amp; outlineSize() &gt; 0; }
 331 
 332     Overflow overflowX() const { return static_cast&lt;Overflow&gt;(m_nonInheritedFlags.overflowX); }
 333     Overflow overflowY() const { return static_cast&lt;Overflow&gt;(m_nonInheritedFlags.overflowY); }
 334     Overflow overflowInlineDirection() const { return isHorizontalWritingMode() ? overflowX() : overflowY(); }
 335     Overflow overflowBlockDirection() const { return isHorizontalWritingMode() ? overflowY() : overflowX(); }
 336     bool isOverflowVisible() const { return overflowX() == Overflow::Visible || overflowY() == Overflow::Visible; }
 337 
 338     Visibility visibility() const { return static_cast&lt;Visibility&gt;(m_inheritedFlags.visibility); }
 339     VerticalAlign verticalAlign() const { return static_cast&lt;VerticalAlign&gt;(m_nonInheritedFlags.verticalAlign); }
 340     const Length&amp; verticalAlignLength() const { return m_boxData-&gt;verticalAlign(); }
 341 
 342     const Length&amp; clipLeft() const { return m_visualData-&gt;clip.left(); }
 343     const Length&amp; clipRight() const { return m_visualData-&gt;clip.right(); }
 344     const Length&amp; clipTop() const { return m_visualData-&gt;clip.top(); }
 345     const Length&amp; clipBottom() const { return m_visualData-&gt;clip.bottom(); }
 346     const LengthBox&amp; clip() const { return m_visualData-&gt;clip; }
 347     bool hasClip() const { return m_visualData-&gt;hasClip; }
 348 
 349     EUnicodeBidi unicodeBidi() const { return static_cast&lt;EUnicodeBidi&gt;(m_nonInheritedFlags.unicodeBidi); }
 350 
 351     Clear clear() const { return static_cast&lt;Clear&gt;(m_nonInheritedFlags.clear); }
 352     TableLayoutType tableLayout() const { return static_cast&lt;TableLayoutType&gt;(m_nonInheritedFlags.tableLayout); }
 353 
 354     WEBCORE_EXPORT const FontCascade&amp; fontCascade() const;
 355     WEBCORE_EXPORT const FontMetrics&amp; fontMetrics() const;
 356     WEBCORE_EXPORT const FontCascadeDescription&amp; fontDescription() const;
 357     float specifiedFontSize() const;
 358     float computedFontSize() const;
 359     unsigned computedFontPixelSize() const;
 360     std::pair&lt;FontOrientation, NonCJKGlyphOrientation&gt; fontAndGlyphOrientation();
 361 
 362 #if ENABLE(VARIATION_FONTS)
 363     FontVariationSettings fontVariationSettings() const { return fontDescription().variationSettings(); }
 364 #endif
 365     FontSelectionValue fontWeight() const { return fontDescription().weight(); }
 366     FontSelectionValue fontStretch() const { return fontDescription().stretch(); }
 367     Optional&lt;FontSelectionValue&gt; fontItalic() const { return fontDescription().italic(); }
 368 
 369     const Length&amp; textIndent() const { return m_rareInheritedData-&gt;indent; }
 370     TextAlignMode textAlign() const { return static_cast&lt;TextAlignMode&gt;(m_inheritedFlags.textAlign); }
 371     TextTransform textTransform() const { return static_cast&lt;TextTransform&gt;(m_inheritedFlags.textTransform); }
 372     OptionSet&lt;TextDecoration&gt; textDecorationsInEffect() const { return OptionSet&lt;TextDecoration&gt;::fromRaw(m_inheritedFlags.textDecorations); }
 373     OptionSet&lt;TextDecoration&gt; textDecoration() const { return OptionSet&lt;TextDecoration&gt;::fromRaw(m_visualData-&gt;textDecoration); }
 374     TextDecorationStyle textDecorationStyle() const { return static_cast&lt;TextDecorationStyle&gt;(m_rareNonInheritedData-&gt;textDecorationStyle); }
 375     OptionSet&lt;TextDecorationSkip&gt; textDecorationSkip() const { return OptionSet&lt;TextDecorationSkip&gt;::fromRaw(m_rareInheritedData-&gt;textDecorationSkip); }
 376     TextUnderlinePosition textUnderlinePosition() const { return static_cast&lt;TextUnderlinePosition&gt;(m_rareInheritedData-&gt;textUnderlinePosition); }
 377     TextUnderlineOffset textUnderlineOffset() const { return m_rareInheritedData-&gt;textUnderlineOffset; }
 378     TextDecorationThickness textDecorationThickness() const { return m_rareInheritedData-&gt;textDecorationThickness; }
 379 
 380 #if ENABLE(CSS3_TEXT)
 381     TextIndentLine textIndentLine() const { return static_cast&lt;TextIndentLine&gt;(m_rareInheritedData-&gt;textIndentLine); }
 382     TextIndentType textIndentType() const { return static_cast&lt;TextIndentType&gt;(m_rareInheritedData-&gt;textIndentType); }
 383     TextAlignLast textAlignLast() const { return static_cast&lt;TextAlignLast&gt;(m_rareInheritedData-&gt;textAlignLast); }
 384     TextJustify textJustify() const { return static_cast&lt;TextJustify&gt;(m_rareInheritedData-&gt;textJustify); }
 385 #endif
 386 
 387     const Length&amp; wordSpacing() const;
 388     float letterSpacing() const;
 389 
 390     float zoom() const { return m_visualData-&gt;zoom; }
 391     float effectiveZoom() const { return m_rareInheritedData-&gt;effectiveZoom; }
 392 
 393     TextZoom textZoom() const { return static_cast&lt;TextZoom&gt;(m_rareInheritedData-&gt;textZoom); }
 394 
 395     TextDirection direction() const { return static_cast&lt;TextDirection&gt;(m_inheritedFlags.direction); }
 396     bool isLeftToRightDirection() const { return direction() == TextDirection::LTR; }
 397     bool hasExplicitlySetDirection() const { return m_nonInheritedFlags.hasExplicitlySetDirection; }
 398 
 399     const Length&amp; specifiedLineHeight() const;
 400     WEBCORE_EXPORT const Length&amp; lineHeight() const;
 401     WEBCORE_EXPORT int computedLineHeight() const;
 402 
 403     WhiteSpace whiteSpace() const { return static_cast&lt;WhiteSpace&gt;(m_inheritedFlags.whiteSpace); }
 404     static bool autoWrap(WhiteSpace);
 405     bool autoWrap() const { return autoWrap(whiteSpace()); }
 406     static bool preserveNewline(WhiteSpace);
 407     bool preserveNewline() const { return preserveNewline(whiteSpace()); }
 408     static bool collapseWhiteSpace(WhiteSpace);
 409     bool collapseWhiteSpace() const { return collapseWhiteSpace(whiteSpace()); }
 410     bool isCollapsibleWhiteSpace(UChar) const;
 411     bool breakOnlyAfterWhiteSpace() const;
 412     bool breakWords() const;
 413 
 414     FillRepeat backgroundRepeatX() const { return static_cast&lt;FillRepeat&gt;(m_backgroundData-&gt;background.repeatX()); }
 415     FillRepeat backgroundRepeatY() const { return static_cast&lt;FillRepeat&gt;(m_backgroundData-&gt;background.repeatY()); }
 416     CompositeOperator backgroundComposite() const { return static_cast&lt;CompositeOperator&gt;(m_backgroundData-&gt;background.composite()); }
 417     FillAttachment backgroundAttachment() const { return static_cast&lt;FillAttachment&gt;(m_backgroundData-&gt;background.attachment()); }
 418     FillBox backgroundClip() const { return static_cast&lt;FillBox&gt;(m_backgroundData-&gt;background.clip()); }
 419     FillBox backgroundOrigin() const { return static_cast&lt;FillBox&gt;(m_backgroundData-&gt;background.origin()); }
 420     const Length&amp; backgroundXPosition() const { return m_backgroundData-&gt;background.xPosition(); }
 421     const Length&amp; backgroundYPosition() const { return m_backgroundData-&gt;background.yPosition(); }
 422     FillSizeType backgroundSizeType() const { return m_backgroundData-&gt;background.sizeType(); }
 423     const LengthSize&amp; backgroundSizeLength() const { return m_backgroundData-&gt;background.sizeLength(); }
 424     FillLayer&amp; ensureBackgroundLayers() { return m_backgroundData.access().background; }
 425     const FillLayer&amp; backgroundLayers() const { return m_backgroundData-&gt;background; }
 426 
 427     StyleImage* maskImage() const { return m_rareNonInheritedData-&gt;mask.image(); }
 428     FillRepeat maskRepeatX() const { return static_cast&lt;FillRepeat&gt;(m_rareNonInheritedData-&gt;mask.repeatX()); }
 429     FillRepeat maskRepeatY() const { return static_cast&lt;FillRepeat&gt;(m_rareNonInheritedData-&gt;mask.repeatY()); }
 430     CompositeOperator maskComposite() const { return static_cast&lt;CompositeOperator&gt;(m_rareNonInheritedData-&gt;mask.composite()); }
 431     FillBox maskClip() const { return static_cast&lt;FillBox&gt;(m_rareNonInheritedData-&gt;mask.clip()); }
 432     FillBox maskOrigin() const { return static_cast&lt;FillBox&gt;(m_rareNonInheritedData-&gt;mask.origin()); }
 433     const Length&amp; maskXPosition() const { return m_rareNonInheritedData-&gt;mask.xPosition(); }
 434     const Length&amp; maskYPosition() const { return m_rareNonInheritedData-&gt;mask.yPosition(); }
 435     FillSizeType maskSizeType() const { return m_rareNonInheritedData-&gt;mask.sizeType(); }
 436     const LengthSize&amp; maskSizeLength() const { return m_rareNonInheritedData-&gt;mask.sizeLength(); }
 437     FillLayer&amp; ensureMaskLayers() { return m_rareNonInheritedData.access().mask; }
 438     const FillLayer&amp; maskLayers() const { return m_rareNonInheritedData-&gt;mask; }
 439     const NinePieceImage&amp; maskBoxImage() const { return m_rareNonInheritedData-&gt;maskBoxImage; }
 440     StyleImage* maskBoxImageSource() const { return m_rareNonInheritedData-&gt;maskBoxImage.image(); }
 441 
 442     BorderCollapse borderCollapse() const { return static_cast&lt;BorderCollapse&gt;(m_inheritedFlags.borderCollapse); }
 443     float horizontalBorderSpacing() const;
 444     float verticalBorderSpacing() const;
 445     EmptyCell emptyCells() const { return static_cast&lt;EmptyCell&gt;(m_inheritedFlags.emptyCells); }
 446     CaptionSide captionSide() const { return static_cast&lt;CaptionSide&gt;(m_inheritedFlags.captionSide); }
 447 
 448     ListStyleType listStyleType() const { return static_cast&lt;ListStyleType&gt;(m_inheritedFlags.listStyleType); }
 449     StyleImage* listStyleImage() const;
 450     ListStylePosition listStylePosition() const { return static_cast&lt;ListStylePosition&gt;(m_inheritedFlags.listStylePosition); }
 451 
 452     const Length&amp; marginTop() const { return m_surroundData-&gt;margin.top(); }
 453     const Length&amp; marginBottom() const { return m_surroundData-&gt;margin.bottom(); }
 454     const Length&amp; marginLeft() const { return m_surroundData-&gt;margin.left(); }
 455     const Length&amp; marginRight() const { return m_surroundData-&gt;margin.right(); }
 456     const Length&amp; marginBefore() const { return m_surroundData-&gt;margin.before(writingMode()); }
 457     const Length&amp; marginAfter() const { return m_surroundData-&gt;margin.after(writingMode()); }
 458     const Length&amp; marginStart() const { return m_surroundData-&gt;margin.start(writingMode(), direction()); }
 459     const Length&amp; marginEnd() const { return m_surroundData-&gt;margin.end(writingMode(), direction()); }
 460     const Length&amp; marginStartUsing(const RenderStyle* otherStyle) const { return m_surroundData-&gt;margin.start(otherStyle-&gt;writingMode(), otherStyle-&gt;direction()); }
 461     const Length&amp; marginEndUsing(const RenderStyle* otherStyle) const { return m_surroundData-&gt;margin.end(otherStyle-&gt;writingMode(), otherStyle-&gt;direction()); }
 462     const Length&amp; marginBeforeUsing(const RenderStyle* otherStyle) const { return m_surroundData-&gt;margin.before(otherStyle-&gt;writingMode()); }
 463     const Length&amp; marginAfterUsing(const RenderStyle* otherStyle) const { return m_surroundData-&gt;margin.after(otherStyle-&gt;writingMode()); }
 464 
 465     const LengthBox&amp; paddingBox() const { return m_surroundData-&gt;padding; }
 466     const Length&amp; paddingTop() const { return m_surroundData-&gt;padding.top(); }
 467     const Length&amp; paddingBottom() const { return m_surroundData-&gt;padding.bottom(); }
 468     const Length&amp; paddingLeft() const { return m_surroundData-&gt;padding.left(); }
 469     const Length&amp; paddingRight() const { return m_surroundData-&gt;padding.right(); }
 470     const Length&amp; paddingBefore() const { return m_surroundData-&gt;padding.before(writingMode()); }
 471     const Length&amp; paddingAfter() const { return m_surroundData-&gt;padding.after(writingMode()); }
 472     const Length&amp; paddingStart() const { return m_surroundData-&gt;padding.start(writingMode(), direction()); }
 473     const Length&amp; paddingEnd() const { return m_surroundData-&gt;padding.end(writingMode(), direction()); }
 474 
 475     CursorType cursor() const { return static_cast&lt;CursorType&gt;(m_inheritedFlags.cursor); }
 476 
 477 #if ENABLE(CURSOR_VISIBILITY)
 478     CursorVisibility cursorVisibility() const { return static_cast&lt;CursorVisibility&gt;(m_inheritedFlags.cursorVisibility); }
 479 #endif
 480 
 481     CursorList* cursors() const { return m_rareInheritedData-&gt;cursorData.get(); }
 482 
 483     InsideLink insideLink() const { return static_cast&lt;InsideLink&gt;(m_inheritedFlags.insideLink); }
 484     bool isLink() const { return m_nonInheritedFlags.isLink; }
 485 
 486     bool insideDefaultButton() const { return m_inheritedFlags.insideDefaultButton; }
 487 
 488     short widows() const { return m_rareInheritedData-&gt;widows; }
 489     short orphans() const { return m_rareInheritedData-&gt;orphans; }
 490     bool hasAutoWidows() const { return m_rareInheritedData-&gt;hasAutoWidows; }
 491     bool hasAutoOrphans() const { return m_rareInheritedData-&gt;hasAutoOrphans; }
 492 
 493     BreakInside breakInside() const { return static_cast&lt;BreakInside&gt;(m_rareNonInheritedData-&gt;breakInside); }
 494     BreakBetween breakBefore() const { return static_cast&lt;BreakBetween&gt;(m_rareNonInheritedData-&gt;breakBefore); }
 495     BreakBetween breakAfter() const { return static_cast&lt;BreakBetween&gt;(m_rareNonInheritedData-&gt;breakAfter); }
 496 
 497     OptionSet&lt;HangingPunctuation&gt; hangingPunctuation() const { return OptionSet&lt;HangingPunctuation&gt;::fromRaw(m_rareInheritedData-&gt;hangingPunctuation); }
 498 
 499     float outlineOffset() const;
 500     const ShadowData* textShadow() const { return m_rareInheritedData-&gt;textShadow.get(); }
 501     void getTextShadowInlineDirectionExtent(LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const { getShadowInlineDirectionExtent(textShadow(), logicalLeft, logicalRight); }
 502     void getTextShadowBlockDirectionExtent(LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const { getShadowBlockDirectionExtent(textShadow(), logicalTop, logicalBottom); }
 503 
 504     float textStrokeWidth() const { return m_rareInheritedData-&gt;textStrokeWidth; }
 505     float opacity() const { return m_rareNonInheritedData-&gt;opacity; }
 506     ControlPart appearance() const { return static_cast&lt;ControlPart&gt;(m_rareNonInheritedData-&gt;appearance); }
 507     AspectRatioType aspectRatioType() const { return static_cast&lt;AspectRatioType&gt;(m_rareNonInheritedData-&gt;aspectRatioType); }
 508     float aspectRatioDenominator() const { return m_rareNonInheritedData-&gt;aspectRatioDenominator; }
 509     float aspectRatioNumerator() const { return m_rareNonInheritedData-&gt;aspectRatioNumerator; }
 510     BoxAlignment boxAlign() const { return static_cast&lt;BoxAlignment&gt;(m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;align); }
 511     BoxDirection boxDirection() const { return static_cast&lt;BoxDirection&gt;(m_inheritedFlags.boxDirection); }
 512     float boxFlex() const { return m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;flex; }
 513     unsigned boxFlexGroup() const { return m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;flexGroup; }
 514     BoxLines boxLines() const { return static_cast&lt;BoxLines&gt;(m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;lines); }
 515     unsigned boxOrdinalGroup() const { return m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;ordinalGroup; }
 516     BoxOrient boxOrient() const { return static_cast&lt;BoxOrient&gt;(m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;orient); }
 517     BoxPack boxPack() const { return static_cast&lt;BoxPack&gt;(m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;pack); }
 518 
 519     int order() const { return m_rareNonInheritedData-&gt;order; }
 520     float flexGrow() const { return m_rareNonInheritedData-&gt;flexibleBox-&gt;flexGrow; }
 521     float flexShrink() const { return m_rareNonInheritedData-&gt;flexibleBox-&gt;flexShrink; }
 522     const Length&amp; flexBasis() const { return m_rareNonInheritedData-&gt;flexibleBox-&gt;flexBasis; }
 523     const StyleContentAlignmentData&amp; alignContent() const { return m_rareNonInheritedData-&gt;alignContent; }
 524     const StyleSelfAlignmentData&amp; alignItems() const { return m_rareNonInheritedData-&gt;alignItems; }
 525     const StyleSelfAlignmentData&amp; alignSelf() const { return m_rareNonInheritedData-&gt;alignSelf; }
 526     FlexDirection flexDirection() const { return static_cast&lt;FlexDirection&gt;(m_rareNonInheritedData-&gt;flexibleBox-&gt;flexDirection); }
 527     bool isColumnFlexDirection() const { return flexDirection() == FlexDirection::Column || flexDirection() == FlexDirection::ColumnReverse; }
 528     bool isReverseFlexDirection() const { return flexDirection() == FlexDirection::RowReverse || flexDirection() == FlexDirection::ColumnReverse; }
 529     FlexWrap flexWrap() const { return static_cast&lt;FlexWrap&gt;(m_rareNonInheritedData-&gt;flexibleBox-&gt;flexWrap); }
 530     const StyleContentAlignmentData&amp; justifyContent() const { return m_rareNonInheritedData-&gt;justifyContent; }
 531     const StyleSelfAlignmentData&amp; justifyItems() const { return m_rareNonInheritedData-&gt;justifyItems; }
 532     const StyleSelfAlignmentData&amp; justifySelf() const { return m_rareNonInheritedData-&gt;justifySelf; }
 533 
 534     const Vector&lt;GridTrackSize&gt;&amp; gridColumns() const { return m_rareNonInheritedData-&gt;grid-&gt;gridColumns; }
 535     const Vector&lt;GridTrackSize&gt;&amp; gridRows() const { return m_rareNonInheritedData-&gt;grid-&gt;gridRows; }
 536     const Vector&lt;GridTrackSize&gt;&amp; gridAutoRepeatColumns() const { return m_rareNonInheritedData-&gt;grid-&gt;gridAutoRepeatColumns; }
 537     const Vector&lt;GridTrackSize&gt;&amp; gridAutoRepeatRows() const { return m_rareNonInheritedData-&gt;grid-&gt;gridAutoRepeatRows; }
 538     unsigned gridAutoRepeatColumnsInsertionPoint() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatColumnsInsertionPoint; }
 539     unsigned gridAutoRepeatRowsInsertionPoint() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatRowsInsertionPoint; }
 540     AutoRepeatType gridAutoRepeatColumnsType() const  { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatColumnsType; }
 541     AutoRepeatType gridAutoRepeatRowsType() const  { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatRowsType; }
 542     const NamedGridLinesMap&amp; namedGridColumnLines() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridColumnLines; }
 543     const NamedGridLinesMap&amp; namedGridRowLines() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridRowLines; }
 544     const OrderedNamedGridLinesMap&amp; orderedNamedGridColumnLines() const { return m_rareNonInheritedData-&gt;grid-&gt;orderedNamedGridColumnLines; }
 545     const OrderedNamedGridLinesMap&amp; orderedNamedGridRowLines() const { return m_rareNonInheritedData-&gt;grid-&gt;orderedNamedGridRowLines; }
 546     const NamedGridLinesMap&amp; autoRepeatNamedGridColumnLines() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatNamedGridColumnLines; }
 547     const NamedGridLinesMap&amp; autoRepeatNamedGridRowLines() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatNamedGridRowLines; }
 548     const OrderedNamedGridLinesMap&amp; autoRepeatOrderedNamedGridColumnLines() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatOrderedNamedGridColumnLines; }
 549     const OrderedNamedGridLinesMap&amp; autoRepeatOrderedNamedGridRowLines() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatOrderedNamedGridRowLines; }
 550     const NamedGridAreaMap&amp; namedGridArea() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridArea; }
 551     size_t namedGridAreaRowCount() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridAreaRowCount; }
 552     size_t namedGridAreaColumnCount() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridAreaColumnCount; }
 553     GridAutoFlow gridAutoFlow() const { return static_cast&lt;GridAutoFlow&gt;(m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow); }
 554     bool isGridAutoFlowDirectionRow() const { return (m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow &amp; InternalAutoFlowDirectionRow); }
 555     bool isGridAutoFlowDirectionColumn() const { return (m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow &amp; InternalAutoFlowDirectionColumn); }
 556     bool isGridAutoFlowAlgorithmSparse() const { return (m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow &amp; InternalAutoFlowAlgorithmSparse); }
 557     bool isGridAutoFlowAlgorithmDense() const { return (m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow &amp; InternalAutoFlowAlgorithmDense); }
 558     const Vector&lt;GridTrackSize&gt;&amp; gridAutoColumns() const { return m_rareNonInheritedData-&gt;grid-&gt;gridAutoColumns; }
 559     const Vector&lt;GridTrackSize&gt;&amp; gridAutoRows() const { return m_rareNonInheritedData-&gt;grid-&gt;gridAutoRows; }
 560 
 561     const GridPosition&amp; gridItemColumnStart() const { return m_rareNonInheritedData-&gt;gridItem-&gt;gridColumnStart; }
 562     const GridPosition&amp; gridItemColumnEnd() const { return m_rareNonInheritedData-&gt;gridItem-&gt;gridColumnEnd; }
 563     const GridPosition&amp; gridItemRowStart() const { return m_rareNonInheritedData-&gt;gridItem-&gt;gridRowStart; }
 564     const GridPosition&amp; gridItemRowEnd() const { return m_rareNonInheritedData-&gt;gridItem-&gt;gridRowEnd; }
 565 
 566     const ShadowData* boxShadow() const { return m_rareNonInheritedData-&gt;boxShadow.get(); }
 567     void getBoxShadowExtent(LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const { getShadowExtent(boxShadow(), top, right, bottom, left); }
 568     LayoutBoxExtent getBoxShadowInsetExtent() const { return getShadowInsetExtent(boxShadow()); }
 569     void getBoxShadowHorizontalExtent(LayoutUnit&amp; left, LayoutUnit&amp; right) const { getShadowHorizontalExtent(boxShadow(), left, right); }
 570     void getBoxShadowVerticalExtent(LayoutUnit&amp; top, LayoutUnit&amp; bottom) const { getShadowVerticalExtent(boxShadow(), top, bottom); }
 571     void getBoxShadowInlineDirectionExtent(LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const { getShadowInlineDirectionExtent(boxShadow(), logicalLeft, logicalRight); }
 572     void getBoxShadowBlockDirectionExtent(LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const { getShadowBlockDirectionExtent(boxShadow(), logicalTop, logicalBottom); }
 573 
 574 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 575     BoxDecorationBreak boxDecorationBreak() const { return m_boxData-&gt;boxDecorationBreak(); }
 576 #endif
 577 
 578     StyleReflection* boxReflect() const { return m_rareNonInheritedData-&gt;boxReflect.get(); }
 579     BoxSizing boxSizing() const { return m_boxData-&gt;boxSizing(); }
 580     const Length&amp; marqueeIncrement() const { return m_rareNonInheritedData-&gt;marquee-&gt;increment; }
 581     int marqueeSpeed() const { return m_rareNonInheritedData-&gt;marquee-&gt;speed; }
 582     int marqueeLoopCount() const { return m_rareNonInheritedData-&gt;marquee-&gt;loops; }
 583     MarqueeBehavior marqueeBehavior() const { return static_cast&lt;MarqueeBehavior&gt;(m_rareNonInheritedData-&gt;marquee-&gt;behavior); }
 584     MarqueeDirection marqueeDirection() const { return static_cast&lt;MarqueeDirection&gt;(m_rareNonInheritedData-&gt;marquee-&gt;direction); }
 585     UserModify userModify() const { return static_cast&lt;UserModify&gt;(m_rareInheritedData-&gt;userModify); }
 586     UserDrag userDrag() const { return static_cast&lt;UserDrag&gt;(m_rareNonInheritedData-&gt;userDrag); }
 587     UserSelect userSelect() const { return static_cast&lt;UserSelect&gt;(m_rareInheritedData-&gt;userSelect); }
 588     TextOverflow textOverflow() const { return static_cast&lt;TextOverflow&gt;(m_rareNonInheritedData-&gt;textOverflow); }
 589     MarginCollapse marginBeforeCollapse() const { return static_cast&lt;MarginCollapse&gt;(m_rareNonInheritedData-&gt;marginBeforeCollapse); }
 590     MarginCollapse marginAfterCollapse() const { return static_cast&lt;MarginCollapse&gt;(m_rareNonInheritedData-&gt;marginAfterCollapse); }
 591     WordBreak wordBreak() const { return static_cast&lt;WordBreak&gt;(m_rareInheritedData-&gt;wordBreak); }
 592     OverflowWrap overflowWrap() const { return static_cast&lt;OverflowWrap&gt;(m_rareInheritedData-&gt;overflowWrap); }
 593     NBSPMode nbspMode() const { return static_cast&lt;NBSPMode&gt;(m_rareInheritedData-&gt;nbspMode); }
 594     LineBreak lineBreak() const { return static_cast&lt;LineBreak&gt;(m_rareInheritedData-&gt;lineBreak); }
 595     Hyphens hyphens() const { return static_cast&lt;Hyphens&gt;(m_rareInheritedData-&gt;hyphens); }
 596     short hyphenationLimitBefore() const { return m_rareInheritedData-&gt;hyphenationLimitBefore; }
 597     short hyphenationLimitAfter() const { return m_rareInheritedData-&gt;hyphenationLimitAfter; }
 598     short hyphenationLimitLines() const { return m_rareInheritedData-&gt;hyphenationLimitLines; }
 599     const AtomString&amp; hyphenationString() const { return m_rareInheritedData-&gt;hyphenationString; }
 600     const AtomString&amp; locale() const { return fontDescription().locale(); }
 601     BorderFit borderFit() const { return static_cast&lt;BorderFit&gt;(m_rareNonInheritedData-&gt;borderFit); }
 602     Resize resize() const { return static_cast&lt;Resize&gt;(m_rareNonInheritedData-&gt;resize); }
 603     ColumnAxis columnAxis() const { return static_cast&lt;ColumnAxis&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;axis); }
 604     bool hasInlineColumnAxis() const;
 605     ColumnProgression columnProgression() const { return static_cast&lt;ColumnProgression&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;progression); }
 606     float columnWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;width; }
 607     bool hasAutoColumnWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;autoWidth; }
 608     unsigned short columnCount() const { return m_rareNonInheritedData-&gt;multiCol-&gt;count; }
 609     bool hasAutoColumnCount() const { return m_rareNonInheritedData-&gt;multiCol-&gt;autoCount; }
 610     bool specifiesColumns() const { return !hasAutoColumnCount() || !hasAutoColumnWidth() || !hasInlineColumnAxis(); }
 611     ColumnFill columnFill() const { return static_cast&lt;ColumnFill&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;fill); }
 612     const GapLength&amp; columnGap() const { return m_rareNonInheritedData-&gt;columnGap; }
 613     const GapLength&amp; rowGap() const { return m_rareNonInheritedData-&gt;rowGap; }
 614     BorderStyle columnRuleStyle() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.style(); }
 615     unsigned short columnRuleWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;ruleWidth(); }
 616     bool columnRuleIsTransparent() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.isTransparent(); }
 617     ColumnSpan columnSpan() const { return static_cast&lt;ColumnSpan&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;columnSpan); }
 618 
 619     const TransformOperations&amp; transform() const { return m_rareNonInheritedData-&gt;transform-&gt;operations; }
 620     bool hasTransform() const { return !m_rareNonInheritedData-&gt;transform-&gt;operations.operations().isEmpty(); }
 621     const Length&amp; transformOriginX() const { return m_rareNonInheritedData-&gt;transform-&gt;x; }
 622     const Length&amp; transformOriginY() const { return m_rareNonInheritedData-&gt;transform-&gt;y; }
 623     float transformOriginZ() const { return m_rareNonInheritedData-&gt;transform-&gt;z; }
 624     TransformBox transformBox() const { return m_rareNonInheritedData-&gt;transform-&gt;transformBox; }
 625 
 626     TextEmphasisFill textEmphasisFill() const { return static_cast&lt;TextEmphasisFill&gt;(m_rareInheritedData-&gt;textEmphasisFill); }
 627     TextEmphasisMark textEmphasisMark() const;
 628     const AtomString&amp; textEmphasisCustomMark() const { return m_rareInheritedData-&gt;textEmphasisCustomMark; }
 629     OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition() const { return OptionSet&lt;TextEmphasisPosition&gt;::fromRaw(m_rareInheritedData-&gt;textEmphasisPosition); }
 630     const AtomString&amp; textEmphasisMarkString() const;
 631 
 632     RubyPosition rubyPosition() const { return static_cast&lt;RubyPosition&gt;(m_rareInheritedData-&gt;rubyPosition); }
 633 
 634 #if ENABLE(DARK_MODE_CSS)
 635     StyleColorScheme colorScheme() const { return m_rareInheritedData-&gt;colorScheme; }
 636     void setHasExplicitlySetColorScheme(bool v) { m_nonInheritedFlags.hasExplicitlySetColorScheme = v; }
 637     bool hasExplicitlySetColorScheme() const { return m_nonInheritedFlags.hasExplicitlySetColorScheme; };
 638 #endif
 639 
 640     TextOrientation textOrientation() const { return static_cast&lt;TextOrientation&gt;(m_rareInheritedData-&gt;textOrientation); }
 641 
 642     ObjectFit objectFit() const { return static_cast&lt;ObjectFit&gt;(m_rareNonInheritedData-&gt;objectFit); }
 643     LengthPoint objectPosition() const { return m_rareNonInheritedData-&gt;objectPosition; }
 644 
 645     // Return true if any transform related property (currently transform, transformStyle3D or perspective)
 646     // indicates that we are transforming.
 647     bool hasTransformRelatedProperty() const { return hasTransform() || preserves3D() || hasPerspective(); }
 648 
 649     enum ApplyTransformOrigin { IncludeTransformOrigin, ExcludeTransformOrigin };
 650     void applyTransform(TransformationMatrix&amp;, const FloatRect&amp; boundingBox, ApplyTransformOrigin = IncludeTransformOrigin) const;
 651     void setPageScaleTransform(float);
 652 
 653     bool hasMask() const { return m_rareNonInheritedData-&gt;mask.hasImage() || m_rareNonInheritedData-&gt;maskBoxImage.hasImage(); }
 654 
 655     TextCombine textCombine() const { return static_cast&lt;TextCombine&gt;(m_rareNonInheritedData-&gt;textCombine); }
 656     bool hasTextCombine() const { return textCombine() != TextCombine::None; }
 657 
 658     const TabSize&amp; tabSize() const { return m_rareInheritedData-&gt;tabSize; }
 659 
 660     // End CSS3 Getters
 661 
 662     const AtomString&amp; lineGrid() const { return m_rareInheritedData-&gt;lineGrid; }
 663     LineSnap lineSnap() const { return static_cast&lt;LineSnap&gt;(m_rareInheritedData-&gt;lineSnap); }
 664     LineAlign lineAlign() const { return static_cast&lt;LineAlign&gt;(m_rareInheritedData-&gt;lineAlign); }
 665 
 666     PointerEvents pointerEvents() const { return static_cast&lt;PointerEvents&gt;(m_inheritedFlags.pointerEvents); }
 667     const AnimationList* animations() const { return m_rareNonInheritedData-&gt;animations.get(); }
 668     const AnimationList* transitions() const { return m_rareNonInheritedData-&gt;transitions.get(); }
 669 
 670     AnimationList* animations() { return m_rareNonInheritedData-&gt;animations.get(); }
 671     AnimationList* transitions() { return m_rareNonInheritedData-&gt;transitions.get(); }
 672 
 673     bool hasAnimationsOrTransitions() const { return hasAnimations() || hasTransitions(); }
 674 
 675     AnimationList&amp; ensureAnimations();
 676     AnimationList&amp; ensureTransitions();
 677 
 678     bool hasAnimations() const { return m_rareNonInheritedData-&gt;animations &amp;&amp; m_rareNonInheritedData-&gt;animations-&gt;size() &gt; 0; }
 679     bool hasTransitions() const { return m_rareNonInheritedData-&gt;transitions &amp;&amp; m_rareNonInheritedData-&gt;transitions-&gt;size() &gt; 0; }
 680 
 681     // Return the first found Animation (including &#39;all&#39; transitions).
 682     const Animation* transitionForProperty(CSSPropertyID) const;
 683 
 684     TransformStyle3D transformStyle3D() const { return static_cast&lt;TransformStyle3D&gt;(m_rareNonInheritedData-&gt;transformStyle3D); }
 685     bool preserves3D() const { return transformStyle3D() == TransformStyle3D::Preserve3D; }
 686 
 687     BackfaceVisibility backfaceVisibility() const { return static_cast&lt;BackfaceVisibility&gt;(m_rareNonInheritedData-&gt;backfaceVisibility); }
 688     float perspective() const { return m_rareNonInheritedData-&gt;perspective; }
 689     bool hasPerspective() const { return m_rareNonInheritedData-&gt;perspective &gt; 0; }
 690     const Length&amp; perspectiveOriginX() const { return m_rareNonInheritedData-&gt;perspectiveOriginX; }
 691     const Length&amp; perspectiveOriginY() const { return m_rareNonInheritedData-&gt;perspectiveOriginY; }
 692     const LengthSize&amp; pageSize() const { return m_rareNonInheritedData-&gt;pageSize; }
 693     PageSizeType pageSizeType() const { return static_cast&lt;PageSizeType&gt;(m_rareNonInheritedData-&gt;pageSizeType); }
 694 
<a name="8" id="anc8"></a><span class="line-modified"> 695     OptionSet&lt;LineBoxContain&gt; lineBoxContain() const { return OptionSet&lt;LineBoxContain&gt;::fromRaw(m_rareInheritedData-&gt;lineBoxContain); }</span>
 696     const LineClampValue&amp; lineClamp() const { return m_rareNonInheritedData-&gt;lineClamp; }
 697     const IntSize&amp; initialLetter() const { return m_rareNonInheritedData-&gt;initialLetter; }
 698     int initialLetterDrop() const { return initialLetter().width(); }
 699     int initialLetterHeight() const { return initialLetter().height(); }
 700 
 701 #if ENABLE(POINTER_EVENTS)
 702     OptionSet&lt;TouchAction&gt; touchActions() const { return OptionSet&lt;TouchAction&gt;::fromRaw(m_rareNonInheritedData-&gt;touchActions); }
 703     // &#39;touch-action&#39; behavior depends on values in ancestors. We use an additional inherited property to implement that.
 704     OptionSet&lt;TouchAction&gt; effectiveTouchActions() const { return OptionSet&lt;TouchAction&gt;::fromRaw(m_rareInheritedData-&gt;effectiveTouchActions); }
 705 #endif
 706 
 707 #if ENABLE(CSS_SCROLL_SNAP)
 708     // Scroll snap port style.
 709     const StyleScrollSnapPort&amp; scrollSnapPort() const;
 710     const ScrollSnapType&amp; scrollSnapType() const;
 711     const LengthBox&amp; scrollPadding() const;
 712     const Length&amp; scrollPaddingTop() const;
 713     const Length&amp; scrollPaddingBottom() const;
 714     const Length&amp; scrollPaddingLeft() const;
 715     const Length&amp; scrollPaddingRight() const;
 716 
 717     // Scroll snap area style.
 718     const StyleScrollSnapArea&amp; scrollSnapArea() const;
 719     const ScrollSnapAlign&amp; scrollSnapAlign() const;
 720     const LengthBox&amp; scrollSnapMargin() const;
 721     const Length&amp; scrollSnapMarginTop() const;
 722     const Length&amp; scrollSnapMarginBottom() const;
 723     const Length&amp; scrollSnapMarginLeft() const;
 724     const Length&amp; scrollSnapMarginRight() const;
 725 #endif
 726 
 727 #if ENABLE(TOUCH_EVENTS)
 728     Color tapHighlightColor() const { return m_rareInheritedData-&gt;tapHighlightColor; }
 729 #endif
 730 
 731 #if PLATFORM(IOS_FAMILY)
 732     bool touchCalloutEnabled() const { return m_rareInheritedData-&gt;touchCalloutEnabled; }
 733 #endif
 734 
 735 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
 736     bool useTouchOverflowScrolling() const { return m_rareInheritedData-&gt;useTouchOverflowScrolling; }
 737 #endif
 738 
<a name="9" id="anc9"></a><span class="line-added"> 739     bool useSmoothScrolling() const { return m_rareNonInheritedData-&gt;useSmoothScrolling; }</span>
<span class="line-added"> 740 </span>
 741 #if ENABLE(TEXT_AUTOSIZING)
 742     TextSizeAdjustment textSizeAdjust() const { return m_rareInheritedData-&gt;textSizeAdjust; }
 743     AutosizeStatus autosizeStatus() const;
 744     bool isIdempotentTextAutosizingCandidate() const;
 745 #endif
 746 
 747     TextSecurity textSecurity() const { return static_cast&lt;TextSecurity&gt;(m_rareInheritedData-&gt;textSecurity); }
 748 
 749     WritingMode writingMode() const { return static_cast&lt;WritingMode&gt;(m_inheritedFlags.writingMode); }
 750     bool isHorizontalWritingMode() const { return WebCore::isHorizontalWritingMode(writingMode()); }
 751     bool isVerticalWritingMode() const { return WebCore::isVerticalWritingMode(writingMode()); }
 752     bool isFlippedLinesWritingMode() const { return WebCore::isFlippedLinesWritingMode(writingMode()); }
 753     bool isFlippedBlocksWritingMode() const { return WebCore::isFlippedWritingMode(writingMode()); }
 754 
 755     ImageOrientation imageOrientation() const;
 756 
 757     ImageRendering imageRendering() const { return static_cast&lt;ImageRendering&gt;(m_rareInheritedData-&gt;imageRendering); }
 758 
 759 #if ENABLE(CSS_IMAGE_RESOLUTION)
 760     ImageResolutionSource imageResolutionSource() const { return static_cast&lt;ImageResolutionSource&gt;(m_rareInheritedData-&gt;imageResolutionSource); }
 761     ImageResolutionSnap imageResolutionSnap() const { return static_cast&lt;ImageResolutionSnap&gt;(m_rareInheritedData-&gt;imageResolutionSnap); }
 762     float imageResolution() const { return m_rareInheritedData-&gt;imageResolution; }
 763 #endif
 764 
 765     OptionSet&lt;SpeakAs&gt; speakAs() const { return OptionSet&lt;SpeakAs&gt;::fromRaw(m_rareInheritedData-&gt;speakAs); }
 766 
 767     FilterOperations&amp; mutableFilter() { return m_rareNonInheritedData.access().filter.access().operations; }
 768     const FilterOperations&amp; filter() const { return m_rareNonInheritedData-&gt;filter-&gt;operations; }
 769     bool hasFilter() const { return !m_rareNonInheritedData-&gt;filter-&gt;operations.operations().isEmpty(); }
 770     bool hasReferenceFilterOnly() const;
 771 
 772     FilterOperations&amp; mutableAppleColorFilter() { return m_rareInheritedData.access().appleColorFilter.access().operations; }
 773     const FilterOperations&amp; appleColorFilter() const { return m_rareInheritedData-&gt;appleColorFilter-&gt;operations; }
 774     bool hasAppleColorFilter() const { return !m_rareInheritedData-&gt;appleColorFilter-&gt;operations.operations().isEmpty(); }
 775 
 776 #if ENABLE(FILTERS_LEVEL_2)
 777     FilterOperations&amp; mutableBackdropFilter() { return m_rareNonInheritedData.access().backdropFilter.access().operations; }
 778     const FilterOperations&amp; backdropFilter() const { return m_rareNonInheritedData-&gt;backdropFilter-&gt;operations; }
 779     bool hasBackdropFilter() const { return !m_rareNonInheritedData-&gt;backdropFilter-&gt;operations.operations().isEmpty(); }
 780 #else
 781     bool hasBackdropFilter() const { return false; }
 782 #endif
 783 
 784 #if ENABLE(CSS_COMPOSITING)
 785     BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_rareNonInheritedData-&gt;effectiveBlendMode); }
 786     void setBlendMode(BlendMode mode) { SET_VAR(m_rareNonInheritedData, effectiveBlendMode, static_cast&lt;unsigned&gt;(mode)); }
 787     bool hasBlendMode() const { return static_cast&lt;BlendMode&gt;(m_rareNonInheritedData-&gt;effectiveBlendMode) != BlendMode::Normal; }
 788 
 789     Isolation isolation() const { return static_cast&lt;Isolation&gt;(m_rareNonInheritedData-&gt;isolation); }
 790     void setIsolation(Isolation isolation) { SET_VAR(m_rareNonInheritedData, isolation, static_cast&lt;unsigned&gt;(isolation)); }
 791     bool hasIsolation() const { return isolation() != Isolation::Auto; }
 792 #else
 793     BlendMode blendMode() const { return BlendMode::Normal; }
 794     bool hasBlendMode() const { return false; }
 795 
 796     Isolation isolation() const { return Isolation::Auto; }
 797     bool hasIsolation() const { return false; }
 798 #endif
 799 
 800     bool shouldPlaceBlockDirectionScrollbarOnLeft() const;
 801 
 802 #if ENABLE(CSS_TRAILING_WORD)
 803     TrailingWord trailingWord() const { return TrailingWord::Auto; }
 804 #endif
 805 
 806 #if ENABLE(APPLE_PAY)
 807     ApplePayButtonStyle applePayButtonStyle() const { return static_cast&lt;ApplePayButtonStyle&gt;(m_rareNonInheritedData-&gt;applePayButtonStyle); }
 808     ApplePayButtonType applePayButtonType() const { return static_cast&lt;ApplePayButtonType&gt;(m_rareNonInheritedData-&gt;applePayButtonType); }
 809 #endif
 810 
 811 // attribute setter methods
 812 
 813     void setDisplay(DisplayType v) { m_nonInheritedFlags.effectiveDisplay = static_cast&lt;unsigned&gt;(v); }
 814     void setOriginalDisplay(DisplayType v) { m_nonInheritedFlags.originalDisplay = static_cast&lt;unsigned&gt;(v); }
 815     void setPosition(PositionType v) { m_nonInheritedFlags.position = static_cast&lt;unsigned&gt;(v); }
 816     void setFloating(Float v) { m_nonInheritedFlags.floating = static_cast&lt;unsigned&gt;(v); }
 817 
 818     void setLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.left(), WTFMove(length)); }
 819     void setRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.right(), WTFMove(length)); }
 820     void setTop(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.top(), WTFMove(length)); }
 821     void setBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.bottom(), WTFMove(length)); }
 822 
 823     void setWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_width, WTFMove(length)); }
 824     void setHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_height, WTFMove(length)); }
 825 
 826     void setLogicalWidth(Length&amp;&amp;);
 827     void setLogicalHeight(Length&amp;&amp;);
 828 
 829     void setMinWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minWidth, WTFMove(length)); }
 830     void setMaxWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxWidth, WTFMove(length)); }
 831     void setMinHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minHeight, WTFMove(length)); }
 832     void setMaxHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxHeight, WTFMove(length)); }
 833 
 834     void resetBorder() { resetBorderImage(); resetBorderTop(); resetBorderRight(); resetBorderBottom(); resetBorderLeft(); resetBorderRadius(); }
 835     void resetBorderTop() { SET_VAR(m_surroundData, border.m_top, BorderValue()); }
 836     void resetBorderRight() { SET_VAR(m_surroundData, border.m_right, BorderValue()); }
 837     void resetBorderBottom() { SET_VAR(m_surroundData, border.m_bottom, BorderValue()); }
 838     void resetBorderLeft() { SET_VAR(m_surroundData, border.m_left, BorderValue()); }
 839     void resetBorderImage() { SET_VAR(m_surroundData, border.m_image, NinePieceImage()); }
 840     void resetBorderRadius() { resetBorderTopLeftRadius(); resetBorderTopRightRadius(); resetBorderBottomLeftRadius(); resetBorderBottomRightRadius(); }
<a name="10" id="anc10"></a><span class="line-modified"> 841     void resetBorderTopLeftRadius() { SET_VAR(m_surroundData, border.m_topLeftRadius, initialBorderRadius()); }</span>
<span class="line-modified"> 842     void resetBorderTopRightRadius() { SET_VAR(m_surroundData, border.m_topRightRadius, initialBorderRadius()); }</span>
<span class="line-modified"> 843     void resetBorderBottomLeftRadius() { SET_VAR(m_surroundData, border.m_bottomLeftRadius, initialBorderRadius()); }</span>
<span class="line-modified"> 844     void resetBorderBottomRightRadius() { SET_VAR(m_surroundData, border.m_bottomRightRadius, initialBorderRadius()); }</span>
 845 
 846     void setBackgroundColor(const Color&amp; v) { SET_VAR(m_backgroundData, color, v); }
 847 
 848     void setBackgroundXPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_xPosition, WTFMove(length)); }
 849     void setBackgroundYPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_yPosition, WTFMove(length)); }
 850     void setBackgroundSize(FillSizeType b) { SET_VAR(m_backgroundData, background.m_sizeType, static_cast&lt;unsigned&gt;(b)); }
 851     void setBackgroundSizeLength(LengthSize&amp;&amp; size) { SET_VAR(m_backgroundData, background.m_sizeLength, WTFMove(size)); }
 852 
 853     void setBorderImage(const NinePieceImage&amp; b) { SET_VAR(m_surroundData, border.m_image, b); }
 854     void setBorderImageSource(RefPtr&lt;StyleImage&gt;&amp;&amp;);
 855     void setBorderImageSlices(LengthBox&amp;&amp;);
 856     void setBorderImageWidth(LengthBox&amp;&amp;);
 857     void setBorderImageOutset(LengthBox&amp;&amp;);
 858 
<a name="11" id="anc11"></a><span class="line-modified"> 859     void setBorderTopLeftRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_topLeftRadius, WTFMove(size)); }</span>
<span class="line-modified"> 860     void setBorderTopRightRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_topRightRadius, WTFMove(size)); }</span>
<span class="line-modified"> 861     void setBorderBottomLeftRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_bottomLeftRadius, WTFMove(size)); }</span>
<span class="line-modified"> 862     void setBorderBottomRightRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_bottomRightRadius, WTFMove(size)); }</span>
 863 
 864     void setBorderRadius(LengthSize&amp;&amp;);
 865     void setBorderRadius(const IntSize&amp;);
 866 
 867     RoundedRect getRoundedBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 868     RoundedRect getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 869 
 870     RoundedRect getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, LayoutUnit topWidth, LayoutUnit bottomWidth,
 871         LayoutUnit leftWidth, LayoutUnit rightWidth, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 872 
 873     void setBorderLeftWidth(float v) { SET_VAR(m_surroundData, border.m_left.m_width, v); }
 874     void setBorderLeftStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_left.m_style, static_cast&lt;unsigned&gt;(v)); }
 875     void setBorderLeftColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_left, v); }
 876     void setBorderRightWidth(float v) { SET_VAR(m_surroundData, border.m_right.m_width, v); }
 877     void setBorderRightStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_right.m_style, static_cast&lt;unsigned&gt;(v)); }
 878     void setBorderRightColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_right, v); }
 879     void setBorderTopWidth(float v) { SET_VAR(m_surroundData, border.m_top.m_width, v); }
 880     void setBorderTopStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_top.m_style, static_cast&lt;unsigned&gt;(v)); }
 881     void setBorderTopColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_top, v); }
 882     void setBorderBottomWidth(float v) { SET_VAR(m_surroundData, border.m_bottom.m_width, v); }
 883     void setBorderBottomStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_bottom.m_style, static_cast&lt;unsigned&gt;(v)); }
 884     void setBorderBottomColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_bottom, v); }
 885 
 886     void setOutlineWidth(float v) { SET_VAR(m_backgroundData, outline.m_width, v); }
 887     void setOutlineStyleIsAuto(OutlineIsAuto isAuto) { SET_VAR(m_backgroundData, outline.m_isAuto, static_cast&lt;unsigned&gt;(isAuto)); }
 888     void setOutlineStyle(BorderStyle v) { SET_VAR(m_backgroundData, outline.m_style, static_cast&lt;unsigned&gt;(v)); }
 889     void setOutlineColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_backgroundData, outline, v); }
 890 
 891     void setOverflowX(Overflow v) { m_nonInheritedFlags.overflowX =  static_cast&lt;unsigned&gt;(v); }
 892     void setOverflowY(Overflow v) { m_nonInheritedFlags.overflowY = static_cast&lt;unsigned&gt;(v); }
 893     void setVisibility(Visibility v) { m_inheritedFlags.visibility = static_cast&lt;unsigned&gt;(v); }
 894     void setVerticalAlign(VerticalAlign v) { m_nonInheritedFlags.verticalAlign = static_cast&lt;unsigned&gt;(v); }
 895     void setVerticalAlignLength(Length&amp;&amp; length) { setVerticalAlign(VerticalAlign::Length); SET_VAR(m_boxData, m_verticalAlign, WTFMove(length)); }
 896 
 897     void setHasClip(bool b = true) { SET_VAR(m_visualData, hasClip, b); }
 898     void setClipLeft(Length&amp;&amp; length) { SET_VAR(m_visualData, clip.left(), WTFMove(length)); }
 899     void setClipRight(Length&amp;&amp; length) { SET_VAR(m_visualData, clip.right(), WTFMove(length)); }
 900     void setClipTop(Length&amp;&amp; length) { SET_VAR(m_visualData, clip.top(), WTFMove(length)); }
 901     void setClipBottom(Length&amp;&amp; length) { SET_VAR(m_visualData, clip.bottom(), WTFMove(length)); }
 902     void setClip(Length&amp;&amp; top, Length&amp;&amp; right, Length&amp;&amp; bottom, Length&amp;&amp; left);
 903     void setClip(LengthBox&amp;&amp; box) { SET_VAR(m_visualData, clip, WTFMove(box)); }
 904 
 905     void setUnicodeBidi(EUnicodeBidi v) { m_nonInheritedFlags.unicodeBidi = v; }
 906 
 907     void setClear(Clear v) { m_nonInheritedFlags.clear = static_cast&lt;unsigned&gt;(v); }
 908     void setTableLayout(TableLayoutType v) { m_nonInheritedFlags.tableLayout = static_cast&lt;unsigned&gt;(v); }
 909 
 910     bool setFontDescription(FontCascadeDescription&amp;&amp;);
 911 
 912     // Only used for blending font sizes when animating, for MathML anonymous blocks, and for text autosizing.
 913     void setFontSize(float);
 914 
 915 #if ENABLE(VARIATION_FONTS)
 916     void setFontVariationSettings(FontVariationSettings);
 917 #endif
 918     void setFontWeight(FontSelectionValue);
 919     void setFontStretch(FontSelectionValue);
 920     void setFontItalic(Optional&lt;FontSelectionValue&gt;);
 921 
 922     void setColor(const Color&amp;);
 923     void setTextIndent(Length&amp;&amp; length) { SET_VAR(m_rareInheritedData, indent, WTFMove(length)); }
 924     void setTextAlign(TextAlignMode v) { m_inheritedFlags.textAlign = static_cast&lt;unsigned&gt;(v); }
 925     void setTextTransform(TextTransform v) { m_inheritedFlags.textTransform = static_cast&lt;unsigned&gt;(v); }
 926     void addToTextDecorationsInEffect(OptionSet&lt;TextDecoration&gt; v) { m_inheritedFlags.textDecorations |= static_cast&lt;unsigned&gt;(v.toRaw()); }
 927     void setTextDecorationsInEffect(OptionSet&lt;TextDecoration&gt; v) { m_inheritedFlags.textDecorations = v.toRaw(); }
 928     void setTextDecoration(OptionSet&lt;TextDecoration&gt; v) { SET_VAR(m_visualData, textDecoration, v.toRaw()); }
 929     void setTextDecorationStyle(TextDecorationStyle v) { SET_VAR(m_rareNonInheritedData, textDecorationStyle, static_cast&lt;unsigned&gt;(v)); }
 930     void setTextDecorationSkip(OptionSet&lt;TextDecorationSkip&gt; skip) { SET_VAR(m_rareInheritedData, textDecorationSkip, skip.toRaw()); }
 931     void setTextUnderlinePosition(TextUnderlinePosition position) { SET_VAR(m_rareInheritedData, textUnderlinePosition, static_cast&lt;unsigned&gt;(position)); }
 932     void setTextUnderlineOffset(TextUnderlineOffset textUnderlineOffset) { SET_VAR(m_rareInheritedData, textUnderlineOffset, textUnderlineOffset); }
 933     void setTextDecorationThickness(TextDecorationThickness textDecorationThickness) { SET_VAR(m_rareInheritedData, textDecorationThickness, textDecorationThickness); }
 934     void setDirection(TextDirection v) { m_inheritedFlags.direction = static_cast&lt;unsigned&gt;(v); }
 935     void setHasExplicitlySetDirection(bool v) { m_nonInheritedFlags.hasExplicitlySetDirection = v; }
 936     void setLineHeight(Length&amp;&amp;);
 937     bool setZoom(float);
 938     void setZoomWithoutReturnValue(float f) { setZoom(f); }
 939     bool setEffectiveZoom(float);
 940     void setTextZoom(TextZoom v) { SET_VAR(m_rareInheritedData, textZoom, static_cast&lt;unsigned&gt;(v)); }
 941 
 942 #if ENABLE(CSS3_TEXT)
 943     void setTextIndentLine(TextIndentLine v) { SET_VAR(m_rareInheritedData, textIndentLine, v); }
 944     void setTextIndentType(TextIndentType v) { SET_VAR(m_rareInheritedData, textIndentType, v); }
 945     void setTextAlignLast(TextAlignLast v) { SET_VAR(m_rareInheritedData, textAlignLast, v); }
 946     void setTextJustify(TextJustify v) { SET_VAR(m_rareInheritedData, textJustify, v); }
 947 #endif
 948 
 949 #if ENABLE(TEXT_AUTOSIZING)
 950     void setSpecifiedLineHeight(Length&amp;&amp;);
 951 #endif
 952 
<a name="12" id="anc12"></a>
 953     void setImageOrientation(ImageOrientation v) { SET_VAR(m_rareInheritedData, imageOrientation, static_cast&lt;int&gt;(v)); }
<a name="13" id="anc13"></a>

 954     void setImageRendering(ImageRendering v) { SET_VAR(m_rareInheritedData, imageRendering, static_cast&lt;unsigned&gt;(v)); }
 955 
 956 #if ENABLE(CSS_IMAGE_RESOLUTION)
 957     void setImageResolutionSource(ImageResolutionSource v) { SET_VAR(m_rareInheritedData, imageResolutionSource, v); }
 958     void setImageResolutionSnap(ImageResolutionSnap v) { SET_VAR(m_rareInheritedData, imageResolutionSnap, v); }
 959     void setImageResolution(float f) { SET_VAR(m_rareInheritedData, imageResolution, f); }
 960 #endif
 961 
 962     void setWhiteSpace(WhiteSpace v) { m_inheritedFlags.whiteSpace = static_cast&lt;unsigned&gt;(v); }
 963 
 964     void setWordSpacing(Length&amp;&amp;);
 965     void setLetterSpacing(float);
 966 
 967     void clearBackgroundLayers() { m_backgroundData.access().background = FillLayer(FillLayerType::Background); }
 968     void inheritBackgroundLayers(const FillLayer&amp; parent) { m_backgroundData.access().background = parent; }
 969 
 970     void adjustBackgroundLayers();
 971 
 972     void clearMaskLayers() { m_rareNonInheritedData.access().mask = FillLayer(FillLayerType::Mask); }
 973     void inheritMaskLayers(const FillLayer&amp; parent) { m_rareNonInheritedData.access().mask = parent; }
 974 
 975     void adjustMaskLayers();
 976 
 977     void setMaskImage(RefPtr&lt;StyleImage&gt;&amp;&amp; v) { m_rareNonInheritedData.access().mask.setImage(WTFMove(v)); }
 978 
 979     void setMaskBoxImage(const NinePieceImage&amp; b) { SET_VAR(m_rareNonInheritedData, maskBoxImage, b); }
 980     void setMaskBoxImageSource(RefPtr&lt;StyleImage&gt;&amp;&amp; v) { m_rareNonInheritedData.access().maskBoxImage.setImage(WTFMove(v)); }
 981     void setMaskXPosition(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, mask.m_xPosition, WTFMove(length)); }
 982     void setMaskYPosition(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, mask.m_yPosition, WTFMove(length)); }
 983     void setMaskSize(LengthSize size) { SET_VAR(m_rareNonInheritedData, mask.m_sizeLength, WTFMove(size)); }
 984 
 985     void setBorderCollapse(BorderCollapse collapse) { m_inheritedFlags.borderCollapse = static_cast&lt;unsigned&gt;(collapse); }
 986     void setHorizontalBorderSpacing(float);
 987     void setVerticalBorderSpacing(float);
 988     void setEmptyCells(EmptyCell v) { m_inheritedFlags.emptyCells = static_cast&lt;unsigned&gt;(v); }
 989     void setCaptionSide(CaptionSide v) { m_inheritedFlags.captionSide = static_cast&lt;unsigned&gt;(v); }
 990 
 991     void setAspectRatioType(AspectRatioType aspectRatioType) { SET_VAR(m_rareNonInheritedData, aspectRatioType, static_cast&lt;unsigned&gt;(aspectRatioType)); }
 992     void setAspectRatioDenominator(float v) { SET_VAR(m_rareNonInheritedData, aspectRatioDenominator, v); }
 993     void setAspectRatioNumerator(float v) { SET_VAR(m_rareNonInheritedData, aspectRatioNumerator, v); }
 994 
 995     void setListStyleType(ListStyleType v) { m_inheritedFlags.listStyleType = static_cast&lt;unsigned&gt;(v); }
 996     void setListStyleImage(RefPtr&lt;StyleImage&gt;&amp;&amp;);
 997     void setListStylePosition(ListStylePosition v) { m_inheritedFlags.listStylePosition = static_cast&lt;unsigned&gt;(v); }
 998 
 999     void resetMargin() { SET_VAR(m_surroundData, margin, LengthBox(Fixed)); }
1000     void setMarginTop(Length&amp;&amp; length) { SET_VAR(m_surroundData, margin.top(), WTFMove(length)); }
1001     void setMarginBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, margin.bottom(), WTFMove(length)); }
1002     void setMarginLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, margin.left(), WTFMove(length)); }
1003     void setMarginRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, margin.right(), WTFMove(length)); }
1004     void setMarginStart(Length&amp;&amp;);
1005     void setMarginEnd(Length&amp;&amp;);
1006 
1007     void resetPadding() { SET_VAR(m_surroundData, padding, LengthBox(Auto)); }
1008     void setPaddingBox(LengthBox&amp;&amp; box) { SET_VAR(m_surroundData, padding, WTFMove(box)); }
1009     void setPaddingTop(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.top(), WTFMove(length)); }
1010     void setPaddingBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.bottom(), WTFMove(length)); }
1011     void setPaddingLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.left(), WTFMove(length)); }
1012     void setPaddingRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.right(), WTFMove(length)); }
1013 
1014     void setCursor(CursorType c) { m_inheritedFlags.cursor = static_cast&lt;unsigned&gt;(c); }
1015     void addCursor(RefPtr&lt;StyleImage&gt;&amp;&amp;, const IntPoint&amp; hotSpot = IntPoint());
1016     void setCursorList(RefPtr&lt;CursorList&gt;&amp;&amp;);
1017     void clearCursorList();
1018 
1019 #if ENABLE(CURSOR_VISIBILITY)
1020     void setCursorVisibility(CursorVisibility c) { m_inheritedFlags.cursorVisibility = static_cast&lt;unsigned&gt;(c); }
1021 #endif
1022 
1023     void setInsideLink(InsideLink insideLink) { m_inheritedFlags.insideLink = static_cast&lt;unsigned&gt;(insideLink); }
1024     void setIsLink(bool v) { m_nonInheritedFlags.isLink = v; }
1025 
1026     void setInsideDefaultButton(bool insideDefaultButton) { m_inheritedFlags.insideDefaultButton = insideDefaultButton; }
1027 
1028     PrintColorAdjust printColorAdjust() const { return static_cast&lt;PrintColorAdjust&gt;(m_inheritedFlags.printColorAdjust); }
1029     void setPrintColorAdjust(PrintColorAdjust value) { m_inheritedFlags.printColorAdjust = static_cast&lt;unsigned&gt;(value); }
1030 
<a name="14" id="anc14"></a><span class="line-modified">1031     int specifiedZIndex() const { return m_boxData-&gt;specifiedZIndex(); }</span>
<span class="line-modified">1032     bool hasAutoSpecifiedZIndex() const { return m_boxData-&gt;hasAutoSpecifiedZIndex(); }</span>
<span class="line-modified">1033     void setSpecifiedZIndex(int v)</span>
<span class="line-modified">1034     {</span>
<span class="line-added">1035         SET_VAR(m_boxData, m_hasAutoSpecifiedZIndex, false);</span>
<span class="line-added">1036         SET_VAR(m_boxData, m_specifiedZIndex, v);</span>
<span class="line-added">1037     }</span>
<span class="line-added">1038     void setHasAutoSpecifiedZIndex()</span>
<span class="line-added">1039     {</span>
<span class="line-added">1040         SET_VAR(m_boxData, m_hasAutoSpecifiedZIndex, true);</span>
<span class="line-added">1041         SET_VAR(m_boxData, m_specifiedZIndex, 0);</span>
<span class="line-added">1042     }</span>
<span class="line-added">1043 </span>
<span class="line-added">1044     int usedZIndex() const { return m_boxData-&gt;usedZIndex(); }</span>
<span class="line-added">1045     bool hasAutoUsedZIndex() const { return m_boxData-&gt;hasAutoUsedZIndex(); }</span>
<span class="line-added">1046     void setUsedZIndex(int v)</span>
<span class="line-added">1047     {</span>
<span class="line-added">1048         SET_VAR(m_boxData, m_hasAutoUsedZIndex, false);</span>
<span class="line-added">1049         SET_VAR(m_boxData, m_usedZIndex, v);</span>
<span class="line-added">1050     }</span>
<span class="line-added">1051     void setHasAutoUsedZIndex()</span>
<span class="line-added">1052     {</span>
<span class="line-added">1053         SET_VAR(m_boxData, m_hasAutoUsedZIndex, true);</span>
<span class="line-added">1054         SET_VAR(m_boxData, m_usedZIndex, 0);</span>
<span class="line-added">1055     }</span>
1056 
1057     void setHasAutoWidows() { SET_VAR(m_rareInheritedData, hasAutoWidows, true); SET_VAR(m_rareInheritedData, widows, initialWidows()); }
1058     void setWidows(short w) { SET_VAR(m_rareInheritedData, hasAutoWidows, false); SET_VAR(m_rareInheritedData, widows, w); }
1059 
1060     void setHasAutoOrphans() { SET_VAR(m_rareInheritedData, hasAutoOrphans, true); SET_VAR(m_rareInheritedData, orphans, initialOrphans()); }
1061     void setOrphans(short o) { SET_VAR(m_rareInheritedData, hasAutoOrphans, false); SET_VAR(m_rareInheritedData, orphans, o); }
1062 
1063     // CSS3 Setters
1064     void setOutlineOffset(float v) { SET_VAR(m_backgroundData, outline.m_offset, v); }
1065     void setTextShadow(std::unique_ptr&lt;ShadowData&gt;, bool add = false);
1066     void setTextStrokeColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textStrokeColor, c); }
1067     void setTextStrokeWidth(float w) { SET_VAR(m_rareInheritedData, textStrokeWidth, w); }
1068     void setTextFillColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textFillColor, c); }
1069     void setCaretColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, caretColor, c); }
1070     void setOpacity(float f) { float v = clampTo&lt;float&gt;(f, 0.f, 1.f); SET_VAR(m_rareNonInheritedData, opacity, v); }
1071     void setAppearance(ControlPart a) { SET_VAR(m_rareNonInheritedData, appearance, a); }
1072     // For valid values of box-align see http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/#alignment
1073     void setBoxAlign(BoxAlignment a) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, align, static_cast&lt;unsigned&gt;(a)); }
1074     void setBoxDirection(BoxDirection d) { m_inheritedFlags.boxDirection = static_cast&lt;unsigned&gt;(d); }
1075     void setBoxFlex(float f) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, flex, f); }
1076     void setBoxFlexGroup(unsigned group) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, flexGroup, group); }
1077     void setBoxLines(BoxLines lines) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, lines, static_cast&lt;unsigned&gt;(lines)); }
1078     void setBoxOrdinalGroup(unsigned group) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, ordinalGroup, group); }
1079     void setBoxOrient(BoxOrient o) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, orient, static_cast&lt;unsigned&gt;(o)); }
1080     void setBoxPack(BoxPack p) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, pack, static_cast&lt;unsigned&gt;(p)); }
1081     void setBoxShadow(std::unique_ptr&lt;ShadowData&gt;, bool add = false);
1082     void setBoxReflect(RefPtr&lt;StyleReflection&gt;&amp;&amp;);
1083     void setBoxSizing(BoxSizing s) { SET_VAR(m_boxData, m_boxSizing, static_cast&lt;unsigned&gt;(s)); }
1084     void setFlexGrow(float f) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexGrow, f); }
1085     void setFlexShrink(float f) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexShrink, f); }
1086     void setFlexBasis(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexBasis, WTFMove(length)); }
1087     void setOrder(int o) { SET_VAR(m_rareNonInheritedData, order, o); }
1088     void setAlignContent(const StyleContentAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, alignContent, data); }
1089     void setAlignItems(const StyleSelfAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, alignItems, data); }
1090     void setAlignItemsPosition(ItemPosition position) { m_rareNonInheritedData.access().alignItems.setPosition(position); }
1091     void setAlignSelf(const StyleSelfAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, alignSelf, data); }
1092     void setAlignSelfPosition(ItemPosition position) { m_rareNonInheritedData.access().alignSelf.setPosition(position); }
1093     void setFlexDirection(FlexDirection direction) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexDirection, static_cast&lt;unsigned&gt;(direction)); }
1094     void setFlexWrap(FlexWrap w) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexWrap, static_cast&lt;unsigned&gt;(w)); }
1095     void setJustifyContent(const StyleContentAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, justifyContent, data); }
1096     void setJustifyContentPosition(ContentPosition position) { m_rareNonInheritedData.access().justifyContent.setPosition(position); }
1097     void setJustifyItems(const StyleSelfAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, justifyItems, data); }
1098     void setJustifySelf(const StyleSelfAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, justifySelf, data); }
1099     void setJustifySelfPosition(ItemPosition position) { m_rareNonInheritedData.access().justifySelf.setPosition(position); }
1100 
1101 #if ENABLE(CSS_BOX_DECORATION_BREAK)
1102     void setBoxDecorationBreak(BoxDecorationBreak b) { SET_VAR(m_boxData, m_boxDecorationBreak, static_cast&lt;unsigned&gt;(b)); }
1103 #endif
1104 
1105     void setGridAutoColumns(const Vector&lt;GridTrackSize&gt;&amp; trackSizeList) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoColumns, trackSizeList); }
1106     void setGridAutoRows(const Vector&lt;GridTrackSize&gt;&amp; trackSizeList) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoRows, trackSizeList); }
1107     void setGridColumns(const Vector&lt;GridTrackSize&gt;&amp; lengths) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridColumns, lengths); }
1108     void setGridRows(const Vector&lt;GridTrackSize&gt;&amp; lengths) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridRows, lengths); }
1109     void setGridAutoRepeatColumns(const Vector&lt;GridTrackSize&gt;&amp; lengths) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoRepeatColumns, lengths); }
1110     void setGridAutoRepeatRows(const Vector&lt;GridTrackSize&gt;&amp; lengths) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoRepeatRows, lengths); }
1111     void setGridAutoRepeatColumnsInsertionPoint(const unsigned insertionPoint) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatColumnsInsertionPoint, insertionPoint); }
1112     void setGridAutoRepeatRowsInsertionPoint(const unsigned insertionPoint) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatRowsInsertionPoint, insertionPoint); }
1113     void setGridAutoRepeatColumnsType(const AutoRepeatType autoRepeatType) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatColumnsType, autoRepeatType); }
1114     void setGridAutoRepeatRowsType(const AutoRepeatType autoRepeatType) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatRowsType, autoRepeatType); }
1115     void setNamedGridColumnLines(const NamedGridLinesMap&amp; namedGridColumnLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridColumnLines, namedGridColumnLines); }
1116     void setNamedGridRowLines(const NamedGridLinesMap&amp; namedGridRowLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridRowLines, namedGridRowLines); }
1117     void setOrderedNamedGridColumnLines(const OrderedNamedGridLinesMap&amp; orderedNamedGridColumnLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, orderedNamedGridColumnLines, orderedNamedGridColumnLines); }
1118     void setOrderedNamedGridRowLines(const OrderedNamedGridLinesMap&amp; orderedNamedGridRowLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, orderedNamedGridRowLines, orderedNamedGridRowLines); }
1119     void setAutoRepeatNamedGridColumnLines(const NamedGridLinesMap&amp; namedGridColumnLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatNamedGridColumnLines, namedGridColumnLines); }
1120     void setAutoRepeatNamedGridRowLines(const NamedGridLinesMap&amp; namedGridRowLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatNamedGridRowLines, namedGridRowLines); }
1121     void setAutoRepeatOrderedNamedGridColumnLines(const OrderedNamedGridLinesMap&amp; orderedNamedGridColumnLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatOrderedNamedGridColumnLines, orderedNamedGridColumnLines); }
1122     void setAutoRepeatOrderedNamedGridRowLines(const OrderedNamedGridLinesMap&amp; orderedNamedGridRowLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatOrderedNamedGridRowLines, orderedNamedGridRowLines); }
1123     void setNamedGridArea(const NamedGridAreaMap&amp; namedGridArea) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridArea, namedGridArea); }
1124     void setNamedGridAreaRowCount(size_t rowCount) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridAreaRowCount, rowCount); }
1125     void setNamedGridAreaColumnCount(size_t columnCount) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridAreaColumnCount, columnCount); }
1126     void setGridAutoFlow(GridAutoFlow flow) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoFlow, flow); }
1127     void setGridItemColumnStart(const GridPosition&amp; columnStartPosition) { SET_NESTED_VAR(m_rareNonInheritedData, gridItem, gridColumnStart, columnStartPosition); }
1128     void setGridItemColumnEnd(const GridPosition&amp; columnEndPosition) { SET_NESTED_VAR(m_rareNonInheritedData, gridItem, gridColumnEnd, columnEndPosition); }
1129     void setGridItemRowStart(const GridPosition&amp; rowStartPosition) { SET_NESTED_VAR(m_rareNonInheritedData, gridItem, gridRowStart, rowStartPosition); }
1130     void setGridItemRowEnd(const GridPosition&amp; rowEndPosition) { SET_NESTED_VAR(m_rareNonInheritedData, gridItem, gridRowEnd, rowEndPosition); }
1131 
1132     void setMarqueeIncrement(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, increment, WTFMove(length)); }
1133     void setMarqueeSpeed(int f) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, speed, f); }
1134     void setMarqueeDirection(MarqueeDirection d) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, direction, static_cast&lt;unsigned&gt;(d)); }
1135     void setMarqueeBehavior(MarqueeBehavior b) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, behavior, static_cast&lt;unsigned&gt;(b)); }
1136     void setMarqueeLoopCount(int i) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, loops, i); }
1137     void setUserModify(UserModify u) { SET_VAR(m_rareInheritedData, userModify, static_cast&lt;unsigned&gt;(u)); }
1138     void setUserDrag(UserDrag d) { SET_VAR(m_rareNonInheritedData, userDrag, static_cast&lt;unsigned&gt;(d)); }
1139     void setUserSelect(UserSelect s) { SET_VAR(m_rareInheritedData, userSelect, static_cast&lt;unsigned&gt;(s)); }
1140     void setTextOverflow(TextOverflow overflow) { SET_VAR(m_rareNonInheritedData, textOverflow, static_cast&lt;unsigned&gt;(overflow)); }
1141     void setMarginBeforeCollapse(MarginCollapse c) { SET_VAR(m_rareNonInheritedData, marginBeforeCollapse, static_cast&lt;unsigned&gt;(c)); }
1142     void setMarginAfterCollapse(MarginCollapse c) { SET_VAR(m_rareNonInheritedData, marginAfterCollapse, static_cast&lt;unsigned&gt;(c)); }
1143     void setWordBreak(WordBreak b) { SET_VAR(m_rareInheritedData, wordBreak, static_cast&lt;unsigned&gt;(b)); }
1144     void setOverflowWrap(OverflowWrap b) { SET_VAR(m_rareInheritedData, overflowWrap, static_cast&lt;unsigned&gt;(b)); }
1145     void setNBSPMode(NBSPMode b) { SET_VAR(m_rareInheritedData, nbspMode, static_cast&lt;unsigned&gt;(b)); }
1146     void setLineBreak(LineBreak b) { SET_VAR(m_rareInheritedData, lineBreak, static_cast&lt;unsigned&gt;(b)); }
1147     void setHyphens(Hyphens h) { SET_VAR(m_rareInheritedData, hyphens, static_cast&lt;unsigned&gt;(h)); }
1148     void setHyphenationLimitBefore(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitBefore, limit); }
1149     void setHyphenationLimitAfter(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitAfter, limit); }
1150     void setHyphenationLimitLines(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitLines, limit); }
1151     void setHyphenationString(const AtomString&amp; h) { SET_VAR(m_rareInheritedData, hyphenationString, h); }
1152     void setBorderFit(BorderFit b) { SET_VAR(m_rareNonInheritedData, borderFit, static_cast&lt;unsigned&gt;(b)); }
1153     void setResize(Resize r) { SET_VAR(m_rareNonInheritedData, resize, static_cast&lt;unsigned&gt;(r)); }
1154     void setColumnAxis(ColumnAxis axis) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, axis, static_cast&lt;unsigned&gt;(axis)); }
1155     void setColumnProgression(ColumnProgression progression) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, progression, static_cast&lt;unsigned&gt;(progression)); }
1156     void setColumnWidth(float f) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoWidth, false); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, width, f); }
1157     void setHasAutoColumnWidth() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoWidth, true); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, width, 0); }
1158     void setColumnCount(unsigned short c) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoCount, false); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, count, c); }
1159     void setHasAutoColumnCount() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoCount, true); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, count, 0); }
1160     void setColumnFill(ColumnFill columnFill) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, fill, static_cast&lt;unsigned&gt;(columnFill)); }
1161     void setColumnGap(GapLength&amp;&amp; gapLength) { SET_VAR(m_rareNonInheritedData, columnGap, WTFMove(gapLength)); }
1162     void setRowGap(GapLength&amp;&amp; gapLength) { SET_VAR(m_rareNonInheritedData, rowGap, WTFMove(gapLength)); }
1163     void setColumnRuleColor(const Color&amp; c) { SET_BORDERVALUE_COLOR(m_rareNonInheritedData.access().multiCol, rule, c); }
1164     void setColumnRuleStyle(BorderStyle b) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule.m_style, static_cast&lt;unsigned&gt;(b)); }
1165     void setColumnRuleWidth(unsigned short w) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule.m_width, w); }
1166     void resetColumnRule() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule, BorderValue()); }
1167     void setColumnSpan(ColumnSpan columnSpan) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, columnSpan, static_cast&lt;unsigned&gt;(columnSpan)); }
1168     void inheritColumnPropertiesFrom(const RenderStyle&amp; parent) { m_rareNonInheritedData.access().multiCol = parent.m_rareNonInheritedData-&gt;multiCol; }
1169 
1170     void setTransform(const TransformOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, transform, operations, ops); }
1171     void setTransformOriginX(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, transform, x, WTFMove(length)); }
1172     void setTransformOriginY(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, transform, y, WTFMove(length)); }
1173     void setTransformOriginZ(float f) { SET_NESTED_VAR(m_rareNonInheritedData, transform, z, f); }
1174     void setTransformBox(TransformBox box) { SET_NESTED_VAR(m_rareNonInheritedData, transform, transformBox, box); }
1175 
1176     void setSpeakAs(OptionSet&lt;SpeakAs&gt; s) { SET_VAR(m_rareInheritedData, speakAs, s.toRaw()); }
1177     void setTextCombine(TextCombine v) { SET_VAR(m_rareNonInheritedData, textCombine, static_cast&lt;unsigned&gt;(v)); }
1178     void setTextDecorationColor(const Color&amp; c) { SET_VAR(m_rareNonInheritedData, textDecorationColor, c); }
1179     void setTextEmphasisColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textEmphasisColor, c); }
1180     void setTextEmphasisFill(TextEmphasisFill fill) { SET_VAR(m_rareInheritedData, textEmphasisFill, static_cast&lt;unsigned&gt;(fill)); }
1181     void setTextEmphasisMark(TextEmphasisMark mark) { SET_VAR(m_rareInheritedData, textEmphasisMark, static_cast&lt;unsigned&gt;(mark)); }
1182     void setTextEmphasisCustomMark(const AtomString&amp; mark) { SET_VAR(m_rareInheritedData, textEmphasisCustomMark, mark); }
1183     void setTextEmphasisPosition(OptionSet&lt;TextEmphasisPosition&gt; position) { SET_VAR(m_rareInheritedData, textEmphasisPosition, static_cast&lt;unsigned&gt;(position.toRaw())); }
1184     bool setTextOrientation(TextOrientation);
1185 
1186     void setObjectFit(ObjectFit fit) { SET_VAR(m_rareNonInheritedData, objectFit, static_cast&lt;unsigned&gt;(fit)); }
1187     void setObjectPosition(LengthPoint&amp;&amp; position) { SET_VAR(m_rareNonInheritedData, objectPosition, WTFMove(position)); }
1188 
1189     void setRubyPosition(RubyPosition position) { SET_VAR(m_rareInheritedData, rubyPosition, static_cast&lt;unsigned&gt;(position)); }
1190 
1191 #if ENABLE(DARK_MODE_CSS)
1192     void setColorScheme(StyleColorScheme supported) { SET_VAR(m_rareInheritedData, colorScheme, supported); }
1193 #endif
1194 
1195     void setFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, filter, operations, ops); }
1196     void setAppleColorFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareInheritedData, appleColorFilter, operations, ops); }
1197 
1198 #if ENABLE(FILTERS_LEVEL_2)
1199     void setBackdropFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, backdropFilter, operations, ops); }
1200 #endif
1201 
1202     void setTabSize(const TabSize&amp; size) { SET_VAR(m_rareInheritedData, tabSize, size); }
1203 
1204     void setBreakBefore(BreakBetween breakBehavior) { SET_VAR(m_rareNonInheritedData, breakBefore, static_cast&lt;unsigned&gt;(breakBehavior)); }
1205     void setBreakAfter(BreakBetween breakBehavior) { SET_VAR(m_rareNonInheritedData, breakAfter, static_cast&lt;unsigned&gt;(breakBehavior)); }
1206     void setBreakInside(BreakInside breakBehavior) { SET_VAR(m_rareNonInheritedData, breakInside, static_cast&lt;unsigned&gt;(breakBehavior)); }
1207 
1208     void setHangingPunctuation(OptionSet&lt;HangingPunctuation&gt; punctuation) { SET_VAR(m_rareInheritedData, hangingPunctuation, punctuation.toRaw()); }
1209 
1210     // End CSS3 Setters
1211 
1212     void setLineGrid(const AtomString&amp; lineGrid) { SET_VAR(m_rareInheritedData, lineGrid, lineGrid); }
1213     void setLineSnap(LineSnap lineSnap) { SET_VAR(m_rareInheritedData, lineSnap, static_cast&lt;unsigned&gt;(lineSnap)); }
1214     void setLineAlign(LineAlign lineAlign) { SET_VAR(m_rareInheritedData, lineAlign, static_cast&lt;unsigned&gt;(lineAlign)); }
1215 
1216     void setPointerEvents(PointerEvents p) { m_inheritedFlags.pointerEvents = static_cast&lt;unsigned&gt;(p); }
1217 
1218     void clearAnimations();
1219     void clearTransitions();
1220 
1221     void adjustAnimations();
1222     void adjustTransitions();
1223 
1224     void setTransformStyle3D(TransformStyle3D b) { SET_VAR(m_rareNonInheritedData, transformStyle3D, static_cast&lt;unsigned&gt;(b)); }
1225     void setBackfaceVisibility(BackfaceVisibility b) { SET_VAR(m_rareNonInheritedData, backfaceVisibility, static_cast&lt;unsigned&gt;(b)); }
1226     void setPerspective(float p) { SET_VAR(m_rareNonInheritedData, perspective, p); }
1227     void setPerspectiveOriginX(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginX, WTFMove(length)); }
1228     void setPerspectiveOriginY(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginY, WTFMove(length)); }
1229     void setPageSize(LengthSize size) { SET_VAR(m_rareNonInheritedData, pageSize, WTFMove(size)); }
1230     void setPageSizeType(PageSizeType t) { SET_VAR(m_rareNonInheritedData, pageSizeType, t); }
1231     void resetPageSizeType() { SET_VAR(m_rareNonInheritedData, pageSizeType, PAGE_SIZE_AUTO); }
1232 
<a name="15" id="anc15"></a><span class="line-modified">1233     void setLineBoxContain(OptionSet&lt;LineBoxContain&gt; c) { SET_VAR(m_rareInheritedData, lineBoxContain, c.toRaw()); }</span>
1234     void setLineClamp(LineClampValue c) { SET_VAR(m_rareNonInheritedData, lineClamp, c); }
1235 
1236     void setInitialLetter(const IntSize&amp; size) { SET_VAR(m_rareNonInheritedData, initialLetter, size); }
1237 
1238 #if ENABLE(POINTER_EVENTS)
1239     void setTouchActions(OptionSet&lt;TouchAction&gt; touchActions) { SET_VAR(m_rareNonInheritedData, touchActions, touchActions.toRaw()); }
1240     void setEffectiveTouchActions(OptionSet&lt;TouchAction&gt; touchActions) { SET_VAR(m_rareInheritedData, effectiveTouchActions, touchActions.toRaw()); }
1241 #endif
1242 
1243 #if ENABLE(CSS_SCROLL_SNAP)
1244     void setScrollSnapType(const ScrollSnapType&amp;);
1245     void setScrollPaddingTop(Length&amp;&amp;);
1246     void setScrollPaddingBottom(Length&amp;&amp;);
1247     void setScrollPaddingLeft(Length&amp;&amp;);
1248     void setScrollPaddingRight(Length&amp;&amp;);
1249 
1250     void setScrollSnapAlign(const ScrollSnapAlign&amp;);
1251     void setScrollSnapMarginTop(Length&amp;&amp;);
1252     void setScrollSnapMarginBottom(Length&amp;&amp;);
1253     void setScrollSnapMarginLeft(Length&amp;&amp;);
1254     void setScrollSnapMarginRight(Length&amp;&amp;);
1255 #endif
1256 
1257 #if ENABLE(TOUCH_EVENTS)
1258     void setTapHighlightColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, tapHighlightColor, c); }
1259 #endif
1260 
1261 #if PLATFORM(IOS_FAMILY)
1262     void setTouchCalloutEnabled(bool v) { SET_VAR(m_rareInheritedData, touchCalloutEnabled, v); }
1263 #endif
1264 
1265 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
1266     void setUseTouchOverflowScrolling(bool v) { SET_VAR(m_rareInheritedData, useTouchOverflowScrolling, v); }
1267 #endif
1268 
<a name="16" id="anc16"></a><span class="line-added">1269     void setUseSmoothScrolling(bool v) { SET_VAR(m_rareNonInheritedData, useSmoothScrolling, v); }</span>
<span class="line-added">1270 </span>
1271 #if ENABLE(TEXT_AUTOSIZING)
1272     void setTextSizeAdjust(TextSizeAdjustment adjustment) { SET_VAR(m_rareInheritedData, textSizeAdjust, adjustment); }
1273     void setAutosizeStatus(AutosizeStatus);
1274 #endif
1275 
1276     void setTextSecurity(TextSecurity security) { SET_VAR(m_rareInheritedData, textSecurity, static_cast&lt;unsigned&gt;(security)); }
1277 
1278 #if ENABLE(CSS_TRAILING_WORD)
1279     void setTrailingWord(TrailingWord) { }
1280 #endif
1281 
1282 #if ENABLE(APPLE_PAY)
1283     void setApplePayButtonStyle(ApplePayButtonStyle style) { SET_VAR(m_rareNonInheritedData, applePayButtonStyle, static_cast&lt;unsigned&gt;(style)); }
1284     void setApplePayButtonType(ApplePayButtonType type) { SET_VAR(m_rareNonInheritedData, applePayButtonType, static_cast&lt;unsigned&gt;(type)); }
1285 #endif
1286 
1287 #if ENABLE(CSS_PAINTING_API)
1288     void addCustomPaintWatchProperty(const String&amp; name);
1289 #endif
1290 
1291     // Support for paint-order, stroke-linecap, stroke-linejoin, and stroke-miterlimit from https://drafts.fxtf.org/paint/.
1292     void setPaintOrder(PaintOrder order) { SET_VAR(m_rareInheritedData, paintOrder, static_cast&lt;unsigned&gt;(order)); }
1293     PaintOrder paintOrder() const { return static_cast&lt;PaintOrder&gt;(m_rareInheritedData-&gt;paintOrder); }
1294     static PaintOrder initialPaintOrder() { return PaintOrder::Normal; }
1295     static Vector&lt;PaintType, 3&gt; paintTypesForPaintOrder(PaintOrder);
1296 
1297     void setCapStyle(LineCap val) { SET_VAR(m_rareInheritedData, capStyle, val); }
1298     LineCap capStyle() const { return static_cast&lt;LineCap&gt;(m_rareInheritedData-&gt;capStyle); }
1299     static LineCap initialCapStyle() { return ButtCap; }
1300 
1301     void setJoinStyle(LineJoin val) { SET_VAR(m_rareInheritedData, joinStyle, val); }
1302     LineJoin joinStyle() const { return static_cast&lt;LineJoin&gt;(m_rareInheritedData-&gt;joinStyle); }
1303     static LineJoin initialJoinStyle() { return MiterJoin; }
1304 
1305     const Length&amp; strokeWidth() const { return m_rareInheritedData-&gt;strokeWidth; }
1306     void setStrokeWidth(Length&amp;&amp; w) { SET_VAR(m_rareInheritedData, strokeWidth, WTFMove(w)); }
1307     bool hasVisibleStroke() const { return svgStyle().hasStroke() &amp;&amp; !strokeWidth().isZero(); }
1308     static Length initialStrokeWidth() { return initialOneLength(); }
1309 
1310     float computedStrokeWidth(const IntSize&amp; viewportSize) const;
1311     void setHasExplicitlySetStrokeWidth(bool v) { SET_VAR(m_rareInheritedData, hasSetStrokeWidth, static_cast&lt;unsigned&gt;(v)); }
1312     bool hasExplicitlySetStrokeWidth() const { return m_rareInheritedData-&gt;hasSetStrokeWidth; };
1313     bool hasPositiveStrokeWidth() const;
1314 
1315     Color strokeColor() const { return m_rareInheritedData-&gt;strokeColor; }
1316     void setStrokeColor(const Color&amp; v)  { SET_VAR(m_rareInheritedData, strokeColor, v); }
1317     void setVisitedLinkStrokeColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkStrokeColor, v); }
1318     const Color&amp; visitedLinkStrokeColor() const { return m_rareInheritedData-&gt;visitedLinkStrokeColor; }
1319     void setHasExplicitlySetStrokeColor(bool v) { SET_VAR(m_rareInheritedData, hasSetStrokeColor, static_cast&lt;unsigned&gt;(v)); }
1320     bool hasExplicitlySetStrokeColor() const { return m_rareInheritedData-&gt;hasSetStrokeColor; };
1321     static Color initialStrokeColor() { return Color(Color::transparent); }
1322     Color computedStrokeColor() const;
1323 
1324     float strokeMiterLimit() const { return m_rareInheritedData-&gt;miterLimit; }
1325     void setStrokeMiterLimit(float f) { SET_VAR(m_rareInheritedData, miterLimit, f); }
1326     static float initialStrokeMiterLimit() { return defaultMiterLimit; }
1327 
1328 
1329     const SVGRenderStyle&amp; svgStyle() const { return m_svgStyle; }
1330     SVGRenderStyle&amp; accessSVGStyle() { return m_svgStyle.access(); }
1331 
1332     SVGPaintType fillPaintType() const { return svgStyle().fillPaintType(); }
1333     Color fillPaintColor() const { return svgStyle().fillPaintColor(); }
1334     void setFillPaintColor(const Color&amp; color) { accessSVGStyle().setFillPaint(SVGPaintType::RGBColor, color, emptyString()); }
1335     float fillOpacity() const { return svgStyle().fillOpacity(); }
1336     void setFillOpacity(float f) { accessSVGStyle().setFillOpacity(f); }
1337 
1338     SVGPaintType strokePaintType() const { return svgStyle().strokePaintType(); }
1339     Color strokePaintColor() const { return svgStyle().strokePaintColor(); }
1340     void setStrokePaintColor(const Color&amp; color) { accessSVGStyle().setStrokePaint(SVGPaintType::RGBColor, color, emptyString()); }
1341     float strokeOpacity() const { return svgStyle().strokeOpacity(); }
1342     void setStrokeOpacity(float f) { accessSVGStyle().setStrokeOpacity(f); }
1343     Vector&lt;SVGLengthValue&gt; strokeDashArray() const { return svgStyle().strokeDashArray(); }
1344     void setStrokeDashArray(Vector&lt;SVGLengthValue&gt; array) { accessSVGStyle().setStrokeDashArray(array); }
1345     const Length&amp; strokeDashOffset() const { return svgStyle().strokeDashOffset(); }
1346     void setStrokeDashOffset(Length&amp;&amp; d) { accessSVGStyle().setStrokeDashOffset(WTFMove(d)); }
1347 
1348     const Length&amp; cx() const { return svgStyle().cx(); }
1349     void setCx(Length&amp;&amp; cx) { accessSVGStyle().setCx(WTFMove(cx)); }
1350     const Length&amp; cy() const { return svgStyle().cy(); }
1351     void setCy(Length&amp;&amp; cy) { accessSVGStyle().setCy(WTFMove(cy)); }
1352     const Length&amp; r() const { return svgStyle().r(); }
1353     void setR(Length&amp;&amp; r) { accessSVGStyle().setR(WTFMove(r)); }
1354     const Length&amp; rx() const { return svgStyle().rx(); }
1355     void setRx(Length&amp;&amp; rx) { accessSVGStyle().setRx(WTFMove(rx)); }
1356     const Length&amp; ry() const { return svgStyle().ry(); }
1357     void setRy(Length&amp;&amp; ry) { accessSVGStyle().setRy(WTFMove(ry)); }
1358     const Length&amp; x() const { return svgStyle().x(); }
1359     void setX(Length&amp;&amp; x) { accessSVGStyle().setX(WTFMove(x)); }
1360     const Length&amp; y() const { return svgStyle().y(); }
1361     void setY(Length&amp;&amp; y) { accessSVGStyle().setY(WTFMove(y)); }
1362 
1363     float floodOpacity() const { return svgStyle().floodOpacity(); }
1364     void setFloodOpacity(float f) { accessSVGStyle().setFloodOpacity(f); }
1365 
1366     float stopOpacity() const { return svgStyle().stopOpacity(); }
1367     void setStopOpacity(float f) { accessSVGStyle().setStopOpacity(f); }
1368 
1369     void setStopColor(const Color&amp; c) { accessSVGStyle().setStopColor(c); }
1370     void setFloodColor(const Color&amp; c) { accessSVGStyle().setFloodColor(c); }
1371     void setLightingColor(const Color&amp; c) { accessSVGStyle().setLightingColor(c); }
1372 
1373     SVGLengthValue baselineShiftValue() const { return svgStyle().baselineShiftValue(); }
1374     void setBaselineShiftValue(SVGLengthValue s) { accessSVGStyle().setBaselineShiftValue(s); }
1375     SVGLengthValue kerning() const { return svgStyle().kerning(); }
1376     void setKerning(SVGLengthValue k) { accessSVGStyle().setKerning(k); }
1377 
1378     void setShapeOutside(RefPtr&lt;ShapeValue&gt;&amp;&amp;);
1379     ShapeValue* shapeOutside() const { return m_rareNonInheritedData-&gt;shapeOutside.get(); }
1380     static ShapeValue* initialShapeOutside() { return nullptr; }
1381 
1382     const Length&amp; shapeMargin() const { return m_rareNonInheritedData-&gt;shapeMargin; }
1383     void setShapeMargin(Length&amp;&amp; shapeMargin) { SET_VAR(m_rareNonInheritedData, shapeMargin, WTFMove(shapeMargin)); }
1384     static Length initialShapeMargin() { return Length(0, Fixed); }
1385 
1386     float shapeImageThreshold() const { return m_rareNonInheritedData-&gt;shapeImageThreshold; }
1387     void setShapeImageThreshold(float);
1388     static float initialShapeImageThreshold() { return 0; }
1389 
1390     void setClipPath(RefPtr&lt;ClipPathOperation&gt;&amp;&amp;);
1391     ClipPathOperation* clipPath() const { return m_rareNonInheritedData-&gt;clipPath.get(); }
1392     static ClipPathOperation* initialClipPath() { return nullptr; }
1393 
1394     bool hasContent() const { return contentData(); }
1395     const ContentData* contentData() const { return m_rareNonInheritedData-&gt;content.get(); }
1396     bool contentDataEquivalent(const RenderStyle* otherStyle) const { return const_cast&lt;RenderStyle*&gt;(this)-&gt;m_rareNonInheritedData-&gt;contentDataEquivalent(*const_cast&lt;RenderStyle*&gt;(otherStyle)-&gt;m_rareNonInheritedData); }
1397     void clearContent();
1398     void setContent(const String&amp;, bool add = false);
1399     void setContent(RefPtr&lt;StyleImage&gt;&amp;&amp;, bool add = false);
1400     void setContent(std::unique_ptr&lt;CounterContent&gt;, bool add = false);
1401     void setContent(QuoteType, bool add = false);
1402     void setContentAltText(const String&amp;);
1403     const String&amp; contentAltText() const;
1404     bool hasAttrContent() const { return m_rareNonInheritedData-&gt;hasAttrContent; }
1405     void setHasAttrContent();
1406 
1407     const CounterDirectiveMap* counterDirectives() const;
1408     CounterDirectiveMap&amp; accessCounterDirectives();
1409 
1410     QuotesData* quotes() const { return m_rareInheritedData-&gt;quotes.get(); }
1411     void setQuotes(RefPtr&lt;QuotesData&gt;&amp;&amp;);
1412 
1413     WillChangeData* willChange() const { return m_rareNonInheritedData-&gt;willChange.get(); }
1414     void setWillChange(RefPtr&lt;WillChangeData&gt;&amp;&amp;);
1415 
1416     bool willChangeCreatesStackingContext() const;
1417 
1418     const AtomString&amp; hyphenString() const;
1419 
<a name="17" id="anc17"></a><span class="line-modified">1420     bool inheritedEqual(const RenderStyle&amp;) const;</span>
<span class="line-modified">1421     bool descendantAffectingNonInheritedPropertiesEqual(const RenderStyle&amp;) const;</span>
1422 
1423 #if ENABLE(TEXT_AUTOSIZING)
1424     uint32_t hashForTextAutosizing() const;
1425     bool equalForTextAutosizing(const RenderStyle&amp;) const;
1426 #endif
1427 
1428     StyleDifference diff(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1429     bool diffRequiresLayerRepaint(const RenderStyle&amp;, bool isComposited) const;
1430 
1431     bool isDisplayInlineType() const { return isDisplayInlineType(display()); }
1432     bool isOriginalDisplayInlineType() const { return isDisplayInlineType(originalDisplay()); }
1433     bool isDisplayFlexibleOrGridBox() const { return isDisplayFlexibleOrGridBox(display()); }
1434     bool isDisplayRegionType() const;
1435 
1436     bool setWritingMode(WritingMode);
1437 
1438     bool hasExplicitlySetWritingMode() const { return m_nonInheritedFlags.hasExplicitlySetWritingMode; }
1439     void setHasExplicitlySetWritingMode(bool v) { m_nonInheritedFlags.hasExplicitlySetWritingMode = v; }
1440 
1441     bool hasExplicitlySetTextAlign() const { return m_nonInheritedFlags.hasExplicitlySetTextAlign; }
1442     void setHasExplicitlySetTextAlign(bool v) { m_nonInheritedFlags.hasExplicitlySetTextAlign = v; }
1443 
1444     // A unique style is one that has matches something that makes it impossible to share.
1445     bool unique() const { return m_nonInheritedFlags.isUnique; }
1446     void setUnique() { m_nonInheritedFlags.isUnique = true; }
1447 
1448     bool emptyState() const { return m_nonInheritedFlags.emptyState; }
1449     void setEmptyState(bool v) { setUnique(); m_nonInheritedFlags.emptyState = v; }
1450     bool firstChildState() const { return m_nonInheritedFlags.firstChildState; }
1451     void setFirstChildState() { setUnique(); m_nonInheritedFlags.firstChildState = true; }
1452     bool lastChildState() const { return m_nonInheritedFlags.lastChildState; }
1453     void setLastChildState() { setUnique(); m_nonInheritedFlags.lastChildState = true; }
1454 
1455     WEBCORE_EXPORT Color visitedDependentColor(CSSPropertyID) const;
1456     WEBCORE_EXPORT Color visitedDependentColorWithColorFilter(CSSPropertyID) const;
1457 
1458     WEBCORE_EXPORT Color colorByApplyingColorFilter(const Color&amp;) const;
1459 
1460     bool backgroundColorEqualsToColorIgnoringVisited(const Color&amp; color) const { return color == backgroundColor(); }
1461 
1462     void setHasExplicitlyInheritedProperties() { m_nonInheritedFlags.hasExplicitlyInheritedProperties = true; }
1463     bool hasExplicitlyInheritedProperties() const { return m_nonInheritedFlags.hasExplicitlyInheritedProperties; }
1464 
1465     // Initial values for all the properties
1466     static Overflow initialOverflowX() { return Overflow::Visible; }
1467     static Overflow initialOverflowY() { return Overflow::Visible; }
1468     static Clear initialClear() { return Clear::None; }
1469     static DisplayType initialDisplay() { return DisplayType::Inline; }
1470     static EUnicodeBidi initialUnicodeBidi() { return UBNormal; }
1471     static PositionType initialPosition() { return PositionType::Static; }
1472     static VerticalAlign initialVerticalAlign() { return VerticalAlign::Baseline; }
1473     static Float initialFloating() { return Float::No; }
1474     static BreakBetween initialBreakBetween() { return BreakBetween::Auto; }
1475     static BreakInside initialBreakInside() { return BreakInside::Auto; }
1476     static OptionSet&lt;HangingPunctuation&gt; initialHangingPunctuation() { return OptionSet&lt;HangingPunctuation&gt; { }; }
1477     static TableLayoutType initialTableLayout() { return TableLayoutType::Auto; }
1478     static BorderCollapse initialBorderCollapse() { return BorderCollapse::Separate; }
1479     static BorderStyle initialBorderStyle() { return BorderStyle::None; }
1480     static OutlineIsAuto initialOutlineStyleIsAuto() { return OutlineIsAuto::Off; }
1481     static NinePieceImage initialNinePieceImage() { return NinePieceImage(); }
1482     static LengthSize initialBorderRadius() { return { { 0, Fixed }, { 0, Fixed } }; }
1483     static CaptionSide initialCaptionSide() { return CaptionSide::Top; }
1484     static ColumnAxis initialColumnAxis() { return ColumnAxis::Auto; }
1485     static ColumnProgression initialColumnProgression() { return ColumnProgression::Normal; }
1486     static TextDirection initialDirection() { return TextDirection::LTR; }
1487     static WritingMode initialWritingMode() { return TopToBottomWritingMode; }
1488     static TextCombine initialTextCombine() { return TextCombine::None; }
1489     static TextOrientation initialTextOrientation() { return TextOrientation::Mixed; }
1490     static ObjectFit initialObjectFit() { return ObjectFit::Fill; }
1491     static LengthPoint initialObjectPosition() { return LengthPoint(Length(50.0f, Percent), Length(50.0f, Percent)); }
1492     static EmptyCell initialEmptyCells() { return EmptyCell::Show; }
1493     static ListStylePosition initialListStylePosition() { return ListStylePosition::Outside; }
1494     static ListStyleType initialListStyleType() { return ListStyleType::Disc; }
1495     static TextTransform initialTextTransform() { return TextTransform::None; }
1496     static Visibility initialVisibility() { return Visibility::Visible; }
1497     static WhiteSpace initialWhiteSpace() { return WhiteSpace::Normal; }
1498     static float initialHorizontalBorderSpacing() { return 0; }
1499     static float initialVerticalBorderSpacing() { return 0; }
1500     static CursorType initialCursor() { return CursorType::Auto; }
1501     static Color initialColor() { return Color::black; }
1502     static StyleImage* initialListStyleImage() { return 0; }
1503     static float initialBorderWidth() { return 3; }
1504     static unsigned short initialColumnRuleWidth() { return 3; }
1505     static float initialOutlineWidth() { return 3; }
1506     static float initialLetterSpacing() { return 0; }
1507     static Length initialWordSpacing() { return Length(Fixed); }
1508     static Length initialSize() { return Length(); }
1509     static Length initialMinSize() { return Length(); }
1510     static Length initialMaxSize() { return Length(Undefined); }
1511     static Length initialOffset() { return Length(); }
<a name="18" id="anc18"></a><span class="line-added">1512     static Length initialRadius() { return Length(); }</span>
1513     static Length initialMargin() { return Length(Fixed); }
1514     static Length initialPadding() { return Length(Fixed); }
1515     static Length initialTextIndent() { return Length(Fixed); }
1516     static Length initialZeroLength() { return Length(Fixed); }
1517     static Length initialOneLength() { return Length(1, Fixed); }
1518     static short initialWidows() { return 2; }
1519     static short initialOrphans() { return 2; }
1520     static Length initialLineHeight() { return Length(-100.0f, Percent); }
1521     static TextAlignMode initialTextAlign() { return TextAlignMode::Start; }
1522     static OptionSet&lt;TextDecoration&gt; initialTextDecoration() { return OptionSet&lt;TextDecoration&gt; { }; }
1523     static TextDecorationStyle initialTextDecorationStyle() { return TextDecorationStyle::Solid; }
1524     static OptionSet&lt;TextDecorationSkip&gt; initialTextDecorationSkip() { return TextDecorationSkip::Auto; }
1525     static TextUnderlinePosition initialTextUnderlinePosition() { return TextUnderlinePosition::Auto; }
1526     static TextUnderlineOffset initialTextUnderlineOffset() { return TextUnderlineOffset::createWithAuto(); }
1527     static TextDecorationThickness initialTextDecorationThickness() { return TextDecorationThickness::createWithAuto(); }
1528     static float initialZoom() { return 1.0f; }
1529     static TextZoom initialTextZoom() { return TextZoom::Normal; }
1530     static float initialOutlineOffset() { return 0; }
1531     static float initialOpacity() { return 1.0f; }
1532     static BoxAlignment initialBoxAlign() { return BoxAlignment::Stretch; }
1533     static BoxDecorationBreak initialBoxDecorationBreak() { return BoxDecorationBreak::Slice; }
1534     static BoxDirection initialBoxDirection() { return BoxDirection::Normal; }
1535     static BoxLines initialBoxLines() { return BoxLines::Single; }
1536     static BoxOrient initialBoxOrient() { return BoxOrient::Horizontal; }
1537     static BoxPack initialBoxPack() { return BoxPack::Start; }
1538     static float initialBoxFlex() { return 0.0f; }
1539     static unsigned initialBoxFlexGroup() { return 1; }
1540     static unsigned initialBoxOrdinalGroup() { return 1; }
1541     static BoxSizing initialBoxSizing() { return BoxSizing::ContentBox; }
1542     static StyleReflection* initialBoxReflect() { return 0; }
1543     static float initialFlexGrow() { return 0; }
1544     static float initialFlexShrink() { return 1; }
1545     static Length initialFlexBasis() { return Length(Auto); }
1546     static int initialOrder() { return 0; }
1547     static StyleSelfAlignmentData initialJustifyItems() { return StyleSelfAlignmentData(ItemPosition::Legacy, OverflowAlignment::Default); }
1548     static StyleSelfAlignmentData initialSelfAlignment() { return StyleSelfAlignmentData(ItemPosition::Auto, OverflowAlignment::Default); }
1549     static StyleSelfAlignmentData initialDefaultAlignment() { return StyleSelfAlignmentData(ItemPosition::Normal, OverflowAlignment::Default); }
1550     static StyleContentAlignmentData initialContentAlignment() { return StyleContentAlignmentData(ContentPosition::Normal, ContentDistribution::Default, OverflowAlignment::Default); }
1551     static FlexDirection initialFlexDirection() { return FlexDirection::Row; }
1552     static FlexWrap initialFlexWrap() { return FlexWrap::NoWrap; }
1553     static int initialMarqueeLoopCount() { return -1; }
1554     static int initialMarqueeSpeed() { return 85; }
1555     static Length initialMarqueeIncrement() { return Length(6, Fixed); }
1556     static MarqueeBehavior initialMarqueeBehavior() { return MarqueeBehavior::Scroll; }
1557     static MarqueeDirection initialMarqueeDirection() { return MarqueeDirection::Auto; }
1558     static UserModify initialUserModify() { return UserModify::ReadOnly; }
1559     static UserDrag initialUserDrag() { return UserDrag::Auto; }
1560     static UserSelect initialUserSelect() { return UserSelect::Text; }
1561     static TextOverflow initialTextOverflow() { return TextOverflow::Clip; }
1562     static MarginCollapse initialMarginBeforeCollapse() { return MarginCollapse::Collapse; }
1563     static MarginCollapse initialMarginAfterCollapse() { return MarginCollapse::Collapse; }
1564     static WordBreak initialWordBreak() { return WordBreak::Normal; }
1565     static OverflowWrap initialOverflowWrap() { return OverflowWrap::Normal; }
1566     static NBSPMode initialNBSPMode() { return NBSPMode::Normal; }
1567     static LineBreak initialLineBreak() { return LineBreak::Auto; }
1568     static OptionSet&lt;SpeakAs&gt; initialSpeakAs() { return OptionSet&lt;SpeakAs&gt; { }; }
1569     static Hyphens initialHyphens() { return Hyphens::Manual; }
1570     static short initialHyphenationLimitBefore() { return -1; }
1571     static short initialHyphenationLimitAfter() { return -1; }
1572     static short initialHyphenationLimitLines() { return -1; }
1573     static const AtomString&amp; initialHyphenationString() { return nullAtom(); }
1574     static BorderFit initialBorderFit() { return BorderFit::Border; }
1575     static Resize initialResize() { return Resize::None; }
1576     static ControlPart initialAppearance() { return NoControlPart; }
1577     static AspectRatioType initialAspectRatioType() { return AspectRatioType::Auto; }
1578     static float initialAspectRatioDenominator() { return 1; }
1579     static float initialAspectRatioNumerator() { return 1; }
1580     static Order initialRTLOrdering() { return Order::Logical; }
1581     static float initialTextStrokeWidth() { return 0; }
1582     static unsigned short initialColumnCount() { return 1; }
1583     static ColumnFill initialColumnFill() { return ColumnFill::Balance; }
1584     static ColumnSpan initialColumnSpan() { return ColumnSpan::None; }
1585     static GapLength initialColumnGap() { return GapLength(); }
1586     static GapLength initialRowGap() { return GapLength(); }
1587     static const TransformOperations&amp; initialTransform() { static NeverDestroyed&lt;TransformOperations&gt; ops; return ops; }
1588     static Length initialTransformOriginX() { return Length(50.0f, Percent); }
1589     static Length initialTransformOriginY() { return Length(50.0f, Percent); }
1590     static TransformBox initialTransformBox() { return TransformBox::BorderBox; }
1591     static PointerEvents initialPointerEvents() { return PointerEvents::Auto; }
1592     static float initialTransformOriginZ() { return 0; }
1593     static TransformStyle3D initialTransformStyle3D() { return TransformStyle3D::Flat; }
1594     static BackfaceVisibility initialBackfaceVisibility() { return BackfaceVisibility::Visible; }
1595     static float initialPerspective() { return 0; }
1596     static Length initialPerspectiveOriginX() { return Length(50.0f, Percent); }
1597     static Length initialPerspectiveOriginY() { return Length(50.0f, Percent); }
1598     static Color initialBackgroundColor() { return Color::transparent; }
1599     static Color initialTextEmphasisColor() { return Color(); }
1600     static TextEmphasisFill initialTextEmphasisFill() { return TextEmphasisFill::Filled; }
1601     static TextEmphasisMark initialTextEmphasisMark() { return TextEmphasisMark::None; }
1602     static const AtomString&amp; initialTextEmphasisCustomMark() { return nullAtom(); }
1603     static OptionSet&lt;TextEmphasisPosition&gt; initialTextEmphasisPosition() { return { TextEmphasisPosition::Over, TextEmphasisPosition::Right }; }
1604     static RubyPosition initialRubyPosition() { return RubyPosition::Before; }
<a name="19" id="anc19"></a><span class="line-modified">1605     static OptionSet&lt;LineBoxContain&gt; initialLineBoxContain() { return { LineBoxContain::Block, LineBoxContain::Inline, LineBoxContain::Replaced }; }</span>
<span class="line-modified">1606     static ImageOrientation initialImageOrientation() { return ImageOrientation::FromImage; }</span>
1607     static ImageRendering initialImageRendering() { return ImageRendering::Auto; }
1608     static ImageResolutionSource initialImageResolutionSource() { return ImageResolutionSource::Specified; }
1609     static ImageResolutionSnap initialImageResolutionSnap() { return ImageResolutionSnap::None; }
1610     static float initialImageResolution() { return 1; }
1611     static StyleImage* initialBorderImageSource() { return nullptr; }
1612     static StyleImage* initialMaskBoxImageSource() { return nullptr; }
1613     static PrintColorAdjust initialPrintColorAdjust() { return PrintColorAdjust::Economy; }
1614     static QuotesData* initialQuotes() { return nullptr; }
1615     static const AtomString&amp; initialContentAltText() { return emptyAtom(); }
1616 
1617 #if ENABLE(DARK_MODE_CSS)
1618     static StyleColorScheme initialColorScheme() { return { }; }
1619 #endif
1620 
1621 #if ENABLE(CSS3_TEXT)
1622     static TextIndentLine initialTextIndentLine() { return TextIndentLine::FirstLine; }
1623     static TextIndentType initialTextIndentType() { return TextIndentType::Normal; }
1624     static TextAlignLast initialTextAlignLast() { return TextAlignLast::Auto; }
1625     static TextJustify initialTextJustify() { return TextJustify::Auto; }
1626 #endif
1627 
1628 #if ENABLE(CURSOR_VISIBILITY)
1629     static CursorVisibility initialCursorVisibility() { return CursorVisibility::Auto; }
1630 #endif
1631 
1632 #if ENABLE(TEXT_AUTOSIZING)
1633     static Length initialSpecifiedLineHeight() { return Length(-100.0f, Percent); }
1634     static TextSizeAdjustment initialTextSizeAdjust() { return TextSizeAdjustment(); }
1635 #endif
1636 
1637     static WillChangeData* initialWillChange() { return nullptr; }
1638 
1639 #if ENABLE(POINTER_EVENTS)
1640     static TouchAction initialTouchActions() { return TouchAction::Auto; }
1641 #endif
1642 
1643 #if ENABLE(CSS_SCROLL_SNAP)
1644     static ScrollSnapType initialScrollSnapType();
1645     static ScrollSnapAlign initialScrollSnapAlign();
1646     static Length initialScrollSnapMargin() { return Length(Fixed); }
1647     static Length initialScrollPadding() { return Length(Fixed); }
1648 #endif
1649 
1650 #if ENABLE(CSS_TRAILING_WORD)
1651     static TrailingWord initialTrailingWord() { return TrailingWord::Auto; }
1652 #endif
1653 
1654 #if ENABLE(APPLE_PAY)
1655     static ApplePayButtonStyle initialApplePayButtonStyle() { return ApplePayButtonStyle::Black; }
1656     static ApplePayButtonType initialApplePayButtonType() { return ApplePayButtonType::Plain; }
1657 #endif
1658 
1659     // The initial value is &#39;none&#39; for grid tracks.
1660     static Vector&lt;GridTrackSize&gt; initialGridColumns() { return Vector&lt;GridTrackSize&gt;(); }
1661     static Vector&lt;GridTrackSize&gt; initialGridRows() { return Vector&lt;GridTrackSize&gt;(); }
1662 
1663     static Vector&lt;GridTrackSize&gt; initialGridAutoRepeatTracks() { return Vector&lt;GridTrackSize&gt;(); }
1664     static unsigned initialGridAutoRepeatInsertionPoint() { return 0; }
1665     static AutoRepeatType initialGridAutoRepeatType() { return AutoRepeatType::None; }
1666 
1667     static GridAutoFlow initialGridAutoFlow() { return AutoFlowRow; }
1668 
1669     static Vector&lt;GridTrackSize&gt; initialGridAutoColumns() { return { GridTrackSize(Length(Auto)) }; }
1670     static Vector&lt;GridTrackSize&gt; initialGridAutoRows() { return { GridTrackSize(Length(Auto)) }; }
1671 
1672     static NamedGridAreaMap initialNamedGridArea() { return NamedGridAreaMap(); }
1673     static size_t initialNamedGridAreaCount() { return 0; }
1674 
1675     static NamedGridLinesMap initialNamedGridColumnLines() { return NamedGridLinesMap(); }
1676     static NamedGridLinesMap initialNamedGridRowLines() { return NamedGridLinesMap(); }
1677 
1678     static OrderedNamedGridLinesMap initialOrderedNamedGridColumnLines() { return OrderedNamedGridLinesMap(); }
1679     static OrderedNamedGridLinesMap initialOrderedNamedGridRowLines() { return OrderedNamedGridLinesMap(); }
1680 
1681     // &#39;auto&#39; is the default.
1682     static GridPosition initialGridItemColumnStart() { return GridPosition(); }
1683     static GridPosition initialGridItemColumnEnd() { return GridPosition(); }
1684     static GridPosition initialGridItemRowStart() { return GridPosition(); }
1685     static GridPosition initialGridItemRowEnd() { return GridPosition(); }
1686 
1687     static TabSize initialTabSize() { return 8; }
1688 
1689     static const AtomString&amp; initialLineGrid() { return nullAtom(); }
1690     static LineSnap initialLineSnap() { return LineSnap::None; }
1691     static LineAlign initialLineAlign() { return LineAlign::None; }
1692 
1693     static IntSize initialInitialLetter() { return IntSize(); }
1694     static LineClampValue initialLineClamp() { return LineClampValue(); }
1695     static TextSecurity initialTextSecurity() { return TextSecurity::None; }
1696 
1697 #if PLATFORM(IOS_FAMILY)
1698     static bool initialTouchCalloutEnabled() { return true; }
1699 #endif
1700 
1701 #if ENABLE(TOUCH_EVENTS)
1702     static Color initialTapHighlightColor();
1703 #endif
1704 
1705 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
1706     static bool initialUseTouchOverflowScrolling() { return false; }
1707 #endif
1708 
<a name="20" id="anc20"></a><span class="line-added">1709     static bool initialUseSmoothScrolling() { return false; }</span>
<span class="line-added">1710 </span>
1711     static const FilterOperations&amp; initialFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1712     static const FilterOperations&amp; initialAppleColorFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1713 
1714 #if ENABLE(FILTERS_LEVEL_2)
1715     static const FilterOperations&amp; initialBackdropFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1716 #endif
1717 
1718 #if ENABLE(CSS_COMPOSITING)
1719     static BlendMode initialBlendMode() { return BlendMode::Normal; }
1720     static Isolation initialIsolation() { return Isolation::Auto; }
1721 #endif
1722 
1723     // Indicates the style is likely to change due to a pending stylesheet load.
1724     bool isNotFinal() const { return m_rareNonInheritedData-&gt;isNotFinal; }
1725     void setIsNotFinal() { SET_VAR(m_rareNonInheritedData, isNotFinal, true); }
1726 
1727     void setVisitedLinkColor(const Color&amp;);
1728     void setVisitedLinkBackgroundColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBackgroundColor, v); }
1729     void setVisitedLinkBorderLeftColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderLeftColor, v); }
1730     void setVisitedLinkBorderRightColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderRightColor, v); }
1731     void setVisitedLinkBorderBottomColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderBottomColor, v); }
1732     void setVisitedLinkBorderTopColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderTopColor, v); }
1733     void setVisitedLinkOutlineColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkOutlineColor, v); }
1734     void setVisitedLinkColumnRuleColor(const Color&amp; v) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, visitedLinkColumnRuleColor, v); }
1735     void setVisitedLinkTextDecorationColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkTextDecorationColor, v); }
1736     void setVisitedLinkTextEmphasisColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextEmphasisColor, v); }
1737     void setVisitedLinkTextFillColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextFillColor, v); }
1738     void setVisitedLinkTextStrokeColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextStrokeColor, v); }
1739     void setVisitedLinkCaretColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkCaretColor, v); }
1740 
1741     void inheritUnicodeBidiFrom(const RenderStyle* parent) { m_nonInheritedFlags.unicodeBidi = parent-&gt;m_nonInheritedFlags.unicodeBidi; }
1742     void getShadowExtent(const ShadowData*, LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const;
1743     void getShadowHorizontalExtent(const ShadowData*, LayoutUnit&amp; left, LayoutUnit&amp; right) const;
1744     void getShadowVerticalExtent(const ShadowData*, LayoutUnit&amp; top, LayoutUnit&amp; bottom) const;
1745     void getShadowInlineDirectionExtent(const ShadowData*, LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const;
1746     void getShadowBlockDirectionExtent(const ShadowData*, LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const;
1747 
1748     static Color invalidColor() { return Color(); }
1749     const Color&amp; borderLeftColor() const { return m_surroundData-&gt;border.left().color(); }
1750     const Color&amp; borderRightColor() const { return m_surroundData-&gt;border.right().color(); }
1751     const Color&amp; borderTopColor() const { return m_surroundData-&gt;border.top().color(); }
1752     const Color&amp; borderBottomColor() const { return m_surroundData-&gt;border.bottom().color(); }
1753     const Color&amp; backgroundColor() const { return m_backgroundData-&gt;color; }
<a name="21" id="anc21"></a><span class="line-modified">1754     WEBCORE_EXPORT const Color&amp; color() const;</span>
1755     const Color&amp; columnRuleColor() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.color(); }
1756     const Color&amp; outlineColor() const { return m_backgroundData-&gt;outline.color(); }
1757     const Color&amp; textEmphasisColor() const { return m_rareInheritedData-&gt;textEmphasisColor; }
1758     const Color&amp; textFillColor() const { return m_rareInheritedData-&gt;textFillColor; }
1759     const Color&amp; textStrokeColor() const { return m_rareInheritedData-&gt;textStrokeColor; }
1760     const Color&amp; caretColor() const { return m_rareInheritedData-&gt;caretColor; }
1761     const Color&amp; visitedLinkColor() const;
1762     const Color&amp; visitedLinkBackgroundColor() const { return m_rareNonInheritedData-&gt;visitedLinkBackgroundColor; }
1763     const Color&amp; visitedLinkBorderLeftColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderLeftColor; }
1764     const Color&amp; visitedLinkBorderRightColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderRightColor; }
1765     const Color&amp; visitedLinkBorderBottomColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderBottomColor; }
1766     const Color&amp; visitedLinkBorderTopColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderTopColor; }
1767     const Color&amp; visitedLinkOutlineColor() const { return m_rareNonInheritedData-&gt;visitedLinkOutlineColor; }
1768     const Color&amp; visitedLinkColumnRuleColor() const { return m_rareNonInheritedData-&gt;multiCol-&gt;visitedLinkColumnRuleColor; }
1769     const Color&amp; textDecorationColor() const { return m_rareNonInheritedData-&gt;textDecorationColor; }
1770     const Color&amp; visitedLinkTextDecorationColor() const { return m_rareNonInheritedData-&gt;visitedLinkTextDecorationColor; }
1771     const Color&amp; visitedLinkTextEmphasisColor() const { return m_rareInheritedData-&gt;visitedLinkTextEmphasisColor; }
1772     const Color&amp; visitedLinkTextFillColor() const { return m_rareInheritedData-&gt;visitedLinkTextFillColor; }
1773     const Color&amp; visitedLinkTextStrokeColor() const { return m_rareInheritedData-&gt;visitedLinkTextStrokeColor; }
1774     const Color&amp; visitedLinkCaretColor() const { return m_rareInheritedData-&gt;visitedLinkCaretColor; }
1775 
1776     const Color&amp; stopColor() const { return svgStyle().stopColor(); }
1777     const Color&amp; floodColor() const { return svgStyle().floodColor(); }
1778     const Color&amp; lightingColor() const { return svgStyle().lightingColor(); }
1779 
1780 private:
1781     struct NonInheritedFlags {
1782         bool operator==(const NonInheritedFlags&amp;) const;
1783         bool operator!=(const NonInheritedFlags&amp; other) const { return !(*this == other); }
1784 
1785         void copyNonInheritedFrom(const NonInheritedFlags&amp;);
1786 
1787         bool hasAnyPublicPseudoStyles() const { return static_cast&lt;unsigned&gt;(PseudoId::PublicPseudoIdMask) &amp; pseudoBits; }
1788         bool hasPseudoStyle(PseudoId) const;
1789         void setHasPseudoStyle(PseudoId);
1790         void setHasPseudoStyles(PseudoIdSet);
1791 
1792         unsigned effectiveDisplay : 5; // DisplayType
1793         unsigned originalDisplay : 5; // DisplayType
1794         unsigned overflowX : 3; // Overflow
1795         unsigned overflowY : 3; // Overflow
1796         unsigned verticalAlign : 4; // VerticalAlign
1797         unsigned clear : 2; // Clear
1798         unsigned position : 3; // PositionType
1799         unsigned unicodeBidi : 3; // EUnicodeBidi
1800         unsigned floating : 2; // Float
1801         unsigned tableLayout : 1; // TableLayoutType
1802 
1803         unsigned hasExplicitlySetDirection : 1;
1804         unsigned hasExplicitlySetWritingMode : 1;
1805         unsigned hasExplicitlySetTextAlign : 1;
1806 #if ENABLE(DARK_MODE_CSS)
1807         unsigned hasExplicitlySetColorScheme : 1;
1808 #endif
1809         unsigned hasViewportUnits : 1;
1810         unsigned hasExplicitlyInheritedProperties : 1; // Explicitly inherits a non-inherited property.
1811         unsigned isUnique : 1; // Style cannot be shared.
1812         unsigned emptyState : 1;
1813         unsigned firstChildState : 1;
1814         unsigned lastChildState : 1;
1815         unsigned affectedByHover : 1;
1816         unsigned affectedByActive : 1;
1817         unsigned affectedByDrag : 1;
1818         unsigned isLink : 1;
1819 
1820         unsigned styleType : 4; // PseudoId
1821         unsigned pseudoBits : (static_cast&lt;unsigned&gt;(PseudoId::FirstInternalPseudoId) - static_cast&lt;unsigned&gt;(PseudoId::FirstPublicPseudoId));
1822 
1823         // If you add more style bits here, you will also need to update RenderStyle::NonInheritedFlags::copyNonInheritedFrom().
1824     };
1825 
1826     struct InheritedFlags {
1827         bool operator==(const InheritedFlags&amp;) const;
1828         bool operator!=(const InheritedFlags&amp; other) const { return !(*this == other); }
1829 
1830         unsigned emptyCells : 1; // EmptyCell
1831         unsigned captionSide : 2; // CaptionSide
1832         unsigned listStyleType : 7; // ListStyleType
1833         unsigned listStylePosition : 1; // ListStylePosition
1834         unsigned visibility : 2; // Visibility
1835         unsigned textAlign : 4; // TextAlignMode
1836         unsigned textTransform : 2; // TextTransform
1837         unsigned textDecorations : TextDecorationBits;
1838         unsigned cursor : 6; // CursorType
1839 #if ENABLE(CURSOR_VISIBILITY)
1840         unsigned cursorVisibility : 1; // CursorVisibility
1841 #endif
1842         unsigned direction : 1; // TextDirection
1843         unsigned whiteSpace : 3; // WhiteSpace
1844         // 35 bits
1845         unsigned borderCollapse : 1; // BorderCollapse
1846         unsigned boxDirection : 1; // BoxDirection
1847 
1848         // non CSS2 inherited
1849         unsigned rtlOrdering : 1; // Order
1850         unsigned printColorAdjust : PrintColorAdjustBits; // PrintColorAdjust
1851         unsigned pointerEvents : 4; // PointerEvents
1852         unsigned insideLink : 2; // InsideLink
1853         unsigned insideDefaultButton : 1;
1854         // 46 bits
1855 
1856         // CSS Text Layout Module Level 3: Vertical writing support
1857         unsigned writingMode : 2; // WritingMode
1858         // 48 bits
1859 
1860 #if ENABLE(TEXT_AUTOSIZING)
1861         unsigned autosizeStatus : 5;
1862 #endif
1863         // 53 bits
1864     };
1865 
1866     // This constructor is used to implement the replace operation.
1867     RenderStyle(RenderStyle&amp;, RenderStyle&amp;&amp;);
1868 
1869     DisplayType originalDisplay() const { return static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.originalDisplay); }
1870 
1871     bool hasAutoLeftAndRight() const { return left().isAuto() &amp;&amp; right().isAuto(); }
1872     bool hasAutoTopAndBottom() const { return top().isAuto() &amp;&amp; bottom().isAuto(); }
1873 
1874     void setContent(std::unique_ptr&lt;ContentData&gt;, bool add);
1875 
1876     LayoutBoxExtent getShadowInsetExtent(const ShadowData*) const;
1877 
1878     static bool isDisplayReplacedType(DisplayType);
1879     static bool isDisplayInlineType(DisplayType);
1880     static bool isDisplayFlexibleBox(DisplayType);
1881     static bool isDisplayGridBox(DisplayType);
1882     static bool isDisplayFlexibleOrGridBox(DisplayType);
1883 
1884     Color colorIncludingFallback(CSSPropertyID colorProperty, bool visitedLink) const;
1885 
1886     bool changeAffectsVisualOverflow(const RenderStyle&amp;) const;
1887     bool changeRequiresLayout(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1888     bool changeRequiresPositionedLayoutOnly(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1889     bool changeRequiresLayerRepaint(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1890     bool changeRequiresRepaint(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1891     bool changeRequiresRepaintIfTextOrBorderOrOutline(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1892     bool changeRequiresRecompositeLayer(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1893 
1894     // non-inherited attributes
1895     DataRef&lt;StyleBoxData&gt; m_boxData;
1896     DataRef&lt;StyleVisualData&gt; m_visualData;
1897     DataRef&lt;StyleBackgroundData&gt; m_backgroundData;
1898     DataRef&lt;StyleSurroundData&gt; m_surroundData;
1899     DataRef&lt;StyleRareNonInheritedData&gt; m_rareNonInheritedData;
1900     NonInheritedFlags m_nonInheritedFlags;
1901 
1902     // inherited attributes
1903     DataRef&lt;StyleRareInheritedData&gt; m_rareInheritedData;
1904     DataRef&lt;StyleInheritedData&gt; m_inheritedData;
1905     InheritedFlags m_inheritedFlags;
1906 
1907     // list of associated pseudo styles
1908     std::unique_ptr&lt;PseudoStyleCache&gt; m_cachedPseudoStyles;
1909 
1910     DataRef&lt;SVGRenderStyle&gt; m_svgStyle;
1911 
<a name="22" id="anc22"></a><span class="line-modified">1912 #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)</span>
1913     bool m_deletionHasBegun { false };
1914 #endif
1915 };
1916 
1917 int adjustForAbsoluteZoom(int, const RenderStyle&amp;);
1918 float adjustFloatForAbsoluteZoom(float, const RenderStyle&amp;);
1919 LayoutUnit adjustLayoutUnitForAbsoluteZoom(LayoutUnit, const RenderStyle&amp;);
1920 
1921 BorderStyle collapsedBorderStyle(BorderStyle);
1922 
1923 bool pseudoElementRendererIsNeeded(const RenderStyle*);
1924 
1925 inline bool RenderStyle::NonInheritedFlags::operator==(const NonInheritedFlags&amp; other) const
1926 {
1927     return effectiveDisplay == other.effectiveDisplay
1928         &amp;&amp; originalDisplay == other.originalDisplay
1929         &amp;&amp; overflowX == other.overflowX
1930         &amp;&amp; overflowY == other.overflowY
1931         &amp;&amp; verticalAlign == other.verticalAlign
1932         &amp;&amp; clear == other.clear
1933         &amp;&amp; position == other.position
1934         &amp;&amp; unicodeBidi == other.unicodeBidi
1935         &amp;&amp; floating == other.floating
1936         &amp;&amp; tableLayout == other.tableLayout
1937         &amp;&amp; hasExplicitlySetDirection == other.hasExplicitlySetDirection
1938         &amp;&amp; hasExplicitlySetWritingMode == other.hasExplicitlySetWritingMode
1939         &amp;&amp; hasExplicitlySetTextAlign == other.hasExplicitlySetTextAlign
1940 #if ENABLE(DARK_MODE_CSS)
1941         &amp;&amp; hasExplicitlySetColorScheme == other.hasExplicitlySetColorScheme
1942 #endif
1943         &amp;&amp; hasViewportUnits == other.hasViewportUnits
1944         &amp;&amp; hasExplicitlyInheritedProperties == other.hasExplicitlyInheritedProperties
1945         &amp;&amp; isUnique == other.isUnique
1946         &amp;&amp; emptyState == other.emptyState
1947         &amp;&amp; firstChildState == other.firstChildState
1948         &amp;&amp; lastChildState == other.lastChildState
1949         &amp;&amp; affectedByHover == other.affectedByHover
1950         &amp;&amp; affectedByActive == other.affectedByActive
1951         &amp;&amp; affectedByDrag == other.affectedByDrag
1952         &amp;&amp; isLink == other.isLink
1953         &amp;&amp; styleType == other.styleType
1954         &amp;&amp; pseudoBits == other.pseudoBits;
1955 }
1956 
1957 inline void RenderStyle::NonInheritedFlags::copyNonInheritedFrom(const NonInheritedFlags&amp; other)
1958 {
1959     // Only a subset is copied because NonInheritedFlags contains a bunch of stuff other than real style data.
1960     effectiveDisplay = other.effectiveDisplay;
1961     originalDisplay = other.originalDisplay;
1962     overflowX = other.overflowX;
1963     overflowY = other.overflowY;
1964     verticalAlign = other.verticalAlign;
1965     clear = other.clear;
1966     position = other.position;
1967     unicodeBidi = other.unicodeBidi;
1968     floating = other.floating;
1969     tableLayout = other.tableLayout;
1970     hasViewportUnits = other.hasViewportUnits;
1971     hasExplicitlyInheritedProperties = other.hasExplicitlyInheritedProperties;
1972 }
1973 
1974 inline bool RenderStyle::NonInheritedFlags::hasPseudoStyle(PseudoId pseudo) const
1975 {
1976     ASSERT(pseudo &gt; PseudoId::None);
1977     ASSERT(pseudo &lt; PseudoId::FirstInternalPseudoId);
1978     return pseudoBits &amp; (1 &lt;&lt; (static_cast&lt;unsigned&gt;(pseudo) - 1 /* PseudoId::None */));
1979 }
1980 
1981 inline void RenderStyle::NonInheritedFlags::setHasPseudoStyle(PseudoId pseudo)
1982 {
1983     ASSERT(pseudo &gt; PseudoId::None);
1984     ASSERT(pseudo &lt; PseudoId::FirstInternalPseudoId);
1985     pseudoBits |= 1 &lt;&lt; (static_cast&lt;unsigned&gt;(pseudo) - 1 /* PseudoId::None */);
1986 }
1987 
1988 inline void RenderStyle::NonInheritedFlags::setHasPseudoStyles(PseudoIdSet pseudoIdSet)
1989 {
1990     ASSERT(pseudoIdSet);
1991     ASSERT((pseudoIdSet.data() &amp; static_cast&lt;unsigned&gt;(PseudoId::PublicPseudoIdMask)) == pseudoIdSet.data());
1992     pseudoBits |= pseudoIdSet.data() &gt;&gt; 1; // Shift down as we do not store a bit for PseudoId::None.
1993 }
1994 
1995 inline bool RenderStyle::InheritedFlags::operator==(const InheritedFlags&amp; other) const
1996 {
1997     return emptyCells == other.emptyCells
1998         &amp;&amp; captionSide == other.captionSide
1999         &amp;&amp; listStyleType == other.listStyleType
2000         &amp;&amp; listStylePosition == other.listStylePosition
2001         &amp;&amp; visibility == other.visibility
2002         &amp;&amp; textAlign == other.textAlign
2003         &amp;&amp; textTransform == other.textTransform
2004         &amp;&amp; textDecorations == other.textDecorations
2005         &amp;&amp; cursor == other.cursor
2006 #if ENABLE(CURSOR_VISIBILITY)
2007         &amp;&amp; cursorVisibility == other.cursorVisibility
2008 #endif
2009         &amp;&amp; direction == other.direction
2010         &amp;&amp; whiteSpace == other.whiteSpace
2011         &amp;&amp; borderCollapse == other.borderCollapse
2012         &amp;&amp; boxDirection == other.boxDirection
2013         &amp;&amp; rtlOrdering == other.rtlOrdering
2014         &amp;&amp; printColorAdjust == other.printColorAdjust
2015         &amp;&amp; pointerEvents == other.pointerEvents
2016         &amp;&amp; insideLink == other.insideLink
2017         &amp;&amp; insideDefaultButton == other.insideDefaultButton
2018         &amp;&amp; writingMode == other.writingMode;
2019 }
2020 
2021 inline int adjustForAbsoluteZoom(int value, const RenderStyle&amp; style)
2022 {
2023     double zoomFactor = style.effectiveZoom();
2024     if (zoomFactor == 1)
2025         return value;
2026     // Needed because computeLengthInt truncates (rather than rounds) when scaling up.
2027     if (zoomFactor &gt; 1) {
2028         if (value &lt; 0)
2029             value--;
2030         else
2031             value++;
2032     }
2033 
2034     return roundForImpreciseConversion&lt;int&gt;(value / zoomFactor);
2035 }
2036 
2037 inline float adjustFloatForAbsoluteZoom(float value, const RenderStyle&amp; style)
2038 {
2039     return value / style.effectiveZoom();
2040 }
2041 
2042 inline LayoutUnit adjustLayoutUnitForAbsoluteZoom(LayoutUnit value, const RenderStyle&amp; style)
2043 {
2044     return LayoutUnit(value / style.effectiveZoom());
2045 }
2046 
2047 inline BorderStyle collapsedBorderStyle(BorderStyle style)
2048 {
2049     if (style == BorderStyle::Outset)
2050         return BorderStyle::Groove;
2051     if (style == BorderStyle::Inset)
2052         return BorderStyle::Ridge;
2053     return style;
2054 }
2055 
2056 inline const CSSCustomPropertyValue* RenderStyle::getCustomProperty(const AtomString&amp; name) const
2057 {
2058     for (auto* map : { &amp;nonInheritedCustomProperties(), &amp;inheritedCustomProperties() }) {
2059         if (auto* val = map-&gt;get(name))
2060             return val;
2061     }
2062     return nullptr;
2063 }
2064 
2065 inline bool RenderStyle::hasBackground() const
2066 {
2067     return visitedDependentColor(CSSPropertyBackgroundColor).isVisible() ||  hasBackgroundImage();
2068 }
2069 
2070 inline bool RenderStyle::autoWrap(WhiteSpace whiteSpace)
2071 {
2072     // Nowrap and pre don&#39;t automatically wrap.
2073     return whiteSpace != WhiteSpace::NoWrap &amp;&amp; whiteSpace != WhiteSpace::Pre;
2074 }
2075 
2076 inline bool RenderStyle::preserveNewline(WhiteSpace whiteSpace)
2077 {
2078     // Normal and nowrap do not preserve newlines.
2079     return whiteSpace != WhiteSpace::Normal &amp;&amp; whiteSpace != WhiteSpace::NoWrap;
2080 }
2081 
2082 inline bool RenderStyle::collapseWhiteSpace(WhiteSpace ws)
2083 {
2084     // Pre and prewrap do not collapse whitespace.
2085     return ws != WhiteSpace::Pre &amp;&amp; ws != WhiteSpace::PreWrap &amp;&amp; ws != WhiteSpace::BreakSpaces;
2086 }
2087 
2088 inline bool RenderStyle::isCollapsibleWhiteSpace(UChar character) const
2089 {
2090     switch (character) {
2091     case &#39; &#39;:
2092     case &#39;\t&#39;:
2093         return collapseWhiteSpace();
2094     case &#39;\n&#39;:
2095         return !preserveNewline();
2096     default:
2097         return false;
2098     }
2099 }
2100 
2101 inline bool RenderStyle::breakOnlyAfterWhiteSpace() const
2102 {
2103     return whiteSpace() == WhiteSpace::PreWrap || whiteSpace() == WhiteSpace::BreakSpaces || lineBreak() == LineBreak::AfterWhiteSpace;
2104 }
2105 
2106 inline bool RenderStyle::breakWords() const
2107 {
2108     return wordBreak() == WordBreak::BreakWord || overflowWrap() == OverflowWrap::Break;
2109 }
2110 
2111 inline bool RenderStyle::hasInlineColumnAxis() const
2112 {
2113     auto axis = columnAxis();
2114     return axis == ColumnAxis::Auto || isHorizontalWritingMode() == (axis == ColumnAxis::Horizontal);
2115 }
2116 
2117 inline ImageOrientation RenderStyle::imageOrientation() const
2118 {
<a name="23" id="anc23"></a><span class="line-modified">2119     return static_cast&lt;ImageOrientation::Orientation&gt;(m_rareInheritedData-&gt;imageOrientation);</span>




2120 }
2121 
2122 inline void RenderStyle::setLogicalWidth(Length&amp;&amp; logicalWidth)
2123 {
2124     if (isHorizontalWritingMode())
2125         setWidth(WTFMove(logicalWidth));
2126     else
2127         setHeight(WTFMove(logicalWidth));
2128 }
2129 
2130 inline void RenderStyle::setLogicalHeight(Length&amp;&amp; logicalHeight)
2131 {
2132     if (isHorizontalWritingMode())
2133         setHeight(WTFMove(logicalHeight));
2134     else
2135         setWidth(WTFMove(logicalHeight));
2136 }
2137 
2138 inline void RenderStyle::setBorderRadius(LengthSize&amp;&amp; size)
2139 {
2140     auto topLeft = size;
2141     setBorderTopLeftRadius(WTFMove(topLeft));
2142     auto topRight = size;
2143     setBorderTopRightRadius(WTFMove(topRight));
2144     auto bottomLeft = size;
2145     setBorderBottomLeftRadius(WTFMove(bottomLeft));
2146     setBorderBottomRightRadius(WTFMove(size));
2147 }
2148 
2149 inline void RenderStyle::setBorderRadius(const IntSize&amp; size)
2150 {
2151     setBorderRadius(LengthSize { { size.width(), Fixed }, { size.height(), Fixed } });
2152 }
2153 
2154 inline bool RenderStyle::setZoom(float zoomLevel)
2155 {
2156     setEffectiveZoom(effectiveZoom() * zoomLevel);
2157     if (compareEqual(m_visualData-&gt;zoom, zoomLevel))
2158         return false;
2159     m_visualData.access().zoom = zoomLevel;
2160     return true;
2161 }
2162 
2163 inline bool RenderStyle::setEffectiveZoom(float zoomLevel)
2164 {
2165     if (compareEqual(m_rareInheritedData-&gt;effectiveZoom, zoomLevel))
2166         return false;
2167     m_rareInheritedData.access().effectiveZoom = zoomLevel;
2168     return true;
2169 }
2170 
2171 inline bool RenderStyle::setTextOrientation(TextOrientation textOrientation)
2172 {
2173     if (compareEqual(static_cast&lt;TextOrientation&gt;(m_rareInheritedData-&gt;textOrientation), textOrientation))
2174         return false;
2175     m_rareInheritedData.access().textOrientation = static_cast&lt;unsigned&gt;(textOrientation);
2176     return true;
2177 }
2178 
2179 inline void RenderStyle::adjustBackgroundLayers()
2180 {
2181     if (backgroundLayers().next()) {
2182         ensureBackgroundLayers().cullEmptyLayers();
2183         ensureBackgroundLayers().fillUnsetProperties();
2184     }
2185 }
2186 
2187 inline void RenderStyle::adjustMaskLayers()
2188 {
2189     if (maskLayers().next()) {
2190         ensureMaskLayers().cullEmptyLayers();
2191         ensureMaskLayers().fillUnsetProperties();
2192     }
2193 }
2194 
2195 inline void RenderStyle::clearAnimations()
2196 {
2197     m_rareNonInheritedData.access().animations = nullptr;
2198 }
2199 
2200 inline void RenderStyle::clearTransitions()
2201 {
2202     m_rareNonInheritedData.access().transitions = nullptr;
2203 }
2204 
2205 inline void RenderStyle::setShapeOutside(RefPtr&lt;ShapeValue&gt;&amp;&amp; value)
2206 {
2207     if (m_rareNonInheritedData-&gt;shapeOutside == value)
2208         return;
2209     m_rareNonInheritedData.access().shapeOutside = WTFMove(value);
2210 }
2211 
2212 inline void RenderStyle::setShapeImageThreshold(float shapeImageThreshold)
2213 {
2214     float clampedShapeImageThreshold = clampTo&lt;float&gt;(shapeImageThreshold, 0.f, 1.f);
2215     SET_VAR(m_rareNonInheritedData, shapeImageThreshold, clampedShapeImageThreshold);
2216 }
2217 
2218 inline void RenderStyle::setClipPath(RefPtr&lt;ClipPathOperation&gt;&amp;&amp; operation)
2219 {
2220     if (m_rareNonInheritedData-&gt;clipPath != operation)
2221         m_rareNonInheritedData.access().clipPath = WTFMove(operation);
2222 }
2223 
2224 inline bool RenderStyle::willChangeCreatesStackingContext() const
2225 {
2226     return willChange() &amp;&amp; willChange()-&gt;canCreateStackingContext();
2227 }
2228 
2229 inline bool RenderStyle::isDisplayRegionType() const
2230 {
2231     return display() == DisplayType::Block || display() == DisplayType::InlineBlock
2232         || display() == DisplayType::TableCell || display() == DisplayType::TableCaption
2233         || display() == DisplayType::ListItem;
2234 }
2235 
2236 inline bool RenderStyle::setWritingMode(WritingMode v)
2237 {
2238     if (v == writingMode())
2239         return false;
2240     m_inheritedFlags.writingMode = v;
2241     return true;
2242 }
2243 
2244 inline void RenderStyle::getShadowInlineDirectionExtent(const ShadowData* shadow, LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const
2245 {
2246     return isHorizontalWritingMode() ? getShadowHorizontalExtent(shadow, logicalLeft, logicalRight) : getShadowVerticalExtent(shadow, logicalLeft, logicalRight);
2247 }
2248 
2249 inline void RenderStyle::getShadowBlockDirectionExtent(const ShadowData* shadow, LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const
2250 {
2251     return isHorizontalWritingMode() ? getShadowVerticalExtent(shadow, logicalTop, logicalBottom) : getShadowHorizontalExtent(shadow, logicalTop, logicalBottom);
2252 }
2253 
2254 inline bool RenderStyle::isDisplayReplacedType(DisplayType display)
2255 {
2256     return display == DisplayType::InlineBlock || display == DisplayType::InlineBox || display == DisplayType::InlineFlex
2257         || display == DisplayType::InlineGrid || display == DisplayType::InlineTable;
2258 }
2259 
2260 inline bool RenderStyle::isDisplayInlineType(DisplayType display)
2261 {
2262     return display == DisplayType::Inline || isDisplayReplacedType(display);
2263 }
2264 
2265 inline bool RenderStyle::isDisplayFlexibleBox(DisplayType display)
2266 {
2267     return display == DisplayType::Flex || display == DisplayType::InlineFlex;
2268 }
2269 
2270 inline bool RenderStyle::isDisplayGridBox(DisplayType display)
2271 {
2272     return display == DisplayType::Grid || display == DisplayType::InlineGrid;
2273 }
2274 
2275 inline bool RenderStyle::isDisplayFlexibleOrGridBox(DisplayType display)
2276 {
2277     return isDisplayFlexibleBox(display) || isDisplayGridBox(display);
2278 }
2279 
2280 inline bool RenderStyle::hasAnyPublicPseudoStyles() const
2281 {
2282     return m_nonInheritedFlags.hasAnyPublicPseudoStyles();
2283 }
2284 
2285 inline bool RenderStyle::hasPseudoStyle(PseudoId pseudo) const
2286 {
2287     return m_nonInheritedFlags.hasPseudoStyle(pseudo);
2288 }
2289 
2290 inline void RenderStyle::setHasPseudoStyle(PseudoId pseudo)
2291 {
2292     m_nonInheritedFlags.setHasPseudoStyle(pseudo);
2293 }
2294 
2295 inline void RenderStyle::setHasPseudoStyles(PseudoIdSet pseudoIdSet)
2296 {
2297     m_nonInheritedFlags.setHasPseudoStyles(pseudoIdSet);
2298 }
2299 
2300 inline void RenderStyle::setBoxReflect(RefPtr&lt;StyleReflection&gt;&amp;&amp; reflect)
2301 {
2302     SET_VAR(m_rareNonInheritedData, boxReflect, WTFMove(reflect));
2303 }
2304 
2305 inline bool pseudoElementRendererIsNeeded(const RenderStyle* style)
2306 {
2307     return style &amp;&amp; style-&gt;display() != DisplayType::None &amp;&amp; style-&gt;contentData();
2308 }
2309 
2310 } // namespace WebCore
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/generate_js_backend_commands.py</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 #!/usr/bin/env python
  2 #
  3 # Copyright (c) 2014, 2016 Apple Inc. All rights reserved.
  4 # Copyright (c) 2014 University of Washington. All rights reserved.
  5 #
  6 # Redistribution and use in source and binary forms, with or without
  7 # modification, are permitted provided that the following conditions
  8 # are met:
  9 # 1. Redistributions of source code must retain the above copyright
 10 #    notice, this list of conditions and the following disclaimer.
 11 # 2. Redistributions in binary form must reproduce the above copyright
 12 #    notice, this list of conditions and the following disclaimer in the
 13 #    documentation and/or other materials provided with the distribution.
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25 # THE POSSIBILITY OF SUCH DAMAGE.
 26 
 27 
 28 import json
 29 import logging
 30 import string
 31 from string import Template
 32 
 33 try:
 34     from .generator import Generator, ucfirst
 35     from .generator_templates import GeneratorTemplates as Templates
 36     from .models import EnumType
 37 except ValueError:
 38     from generator import Generator, ucfirst
 39     from generator_templates import GeneratorTemplates as Templates
 40     from models import EnumType
 41 
 42 log = logging.getLogger(&#39;global&#39;)
 43 
 44 
 45 class JSBackendCommandsGenerator(Generator):
 46     def __init__(self, *args, **kwargs):
 47         Generator.__init__(self, *args, **kwargs)
 48 
 49     def output_filename(self):
 50         return &quot;InspectorBackendCommands.js&quot;
 51 
 52     def should_generate_domain(self, domain):
 53         type_declarations = self.type_declarations_for_domain(domain)
 54         domain_enum_types = [declaration for declaration in type_declarations if isinstance(declaration.type, EnumType)]
 55         return self.version_for_domain(domain) is not None or len(self.commands_for_domain(domain)) &gt; 0 or len(self.events_for_domain(domain)) &gt; 0 or len(domain_enum_types) &gt; 0
 56 
 57     def domains_to_generate(self):
 58         return list(filter(self.should_generate_domain, Generator.domains_to_generate(self)))
 59 
 60     def generate_output(self):
 61         sections = []
 62         sections.append(self.generate_license())
 63         sections.extend(list(map(self.generate_domain, self.domains_to_generate())))
 64         return &quot;\n\n&quot;.join(sections)
 65 
 66     def generate_domain(self, domain):
 67         lines = []
 68         args = {
 69             &#39;domain&#39;: domain.domain_name
 70         }
 71 
 72         lines.append(&#39;// %(domain)s.&#39; % args)
 73 
 74         version = self.version_for_domain(domain)
 75         type_declarations = self.type_declarations_for_domain(domain)
 76         commands = self.commands_for_domain(domain)
 77         events = self.events_for_domain(domain)
 78 
 79         has_async_commands = any([command.is_async for command in commands])
 80         if len(events) &gt; 0 or has_async_commands:
 81             lines.append(&#39;InspectorBackend.register%(domain)sDispatcher = InspectorBackend.registerDomainDispatcher.bind(InspectorBackend, &quot;%(domain)s&quot;);&#39; % args)
 82 
 83         if isinstance(version, int):
 84             version_args = {
 85                 &#39;domain&#39;: domain.domain_name,
 86                 &#39;version&#39;: version
 87             }
 88             lines.append(&#39;InspectorBackend.registerVersion(&quot;%(domain)s&quot;, %(version)s);&#39; % version_args)
 89 
 90         for declaration in type_declarations:
 91             if declaration.type.is_enum():
 92                 enum_args = {
 93                     &#39;domain&#39;: domain.domain_name,
 94                     &#39;enumName&#39;: declaration.type_name,
 95                     &#39;enumMap&#39;: &quot;, &quot;.join([&#39;%s: &quot;%s&quot;&#39; % (Generator.stylized_name_for_enum_value(enum_value), enum_value) for enum_value in declaration.type.enum_values()])
 96                 }
 97                 lines.append(&#39;InspectorBackend.registerEnum(&quot;%(domain)s.%(enumName)s&quot;, {%(enumMap)s});&#39; % enum_args)
 98 
 99             def is_anonymous_enum_member(type_member):
100                 return isinstance(type_member.type, EnumType) and type_member.type.is_anonymous
101 
102             for _member in filter(is_anonymous_enum_member, declaration.type_members):
103                 enum_args = {
104                     &#39;domain&#39;: domain.domain_name,
105                     &#39;enumName&#39;: &#39;%s%s&#39; % (declaration.type_name, ucfirst(_member.member_name)),
106                     &#39;enumMap&#39;: &quot;, &quot;.join([&#39;%s: &quot;%s&quot;&#39; % (Generator.stylized_name_for_enum_value(enum_value), enum_value) for enum_value in _member.type.enum_values()])
107                 }
108                 lines.append(&#39;InspectorBackend.registerEnum(&quot;%(domain)s.%(enumName)s&quot;, {%(enumMap)s});&#39; % enum_args)
109 
110         def is_anonymous_enum_param(param):
111             return isinstance(param.type, EnumType) and param.type.is_anonymous
112 
113         for event in events:
114             for param in filter(is_anonymous_enum_param, event.event_parameters):
115                 enum_args = {
116                     &#39;domain&#39;: domain.domain_name,
117                     &#39;enumName&#39;: &#39;%s%s&#39; % (ucfirst(event.event_name), ucfirst(param.parameter_name)),
118                     &#39;enumMap&#39;: &quot;, &quot;.join([&#39;%s: &quot;%s&quot;&#39; % (Generator.stylized_name_for_enum_value(enum_value), enum_value) for enum_value in param.type.enum_values()])
119                 }
120                 lines.append(&#39;InspectorBackend.registerEnum(&quot;%(domain)s.%(enumName)s&quot;, {%(enumMap)s});&#39; % enum_args)
121 
122             event_args = {
123                 &#39;domain&#39;: domain.domain_name,
124                 &#39;eventName&#39;: event.event_name,
125                 &#39;params&#39;: &quot;, &quot;.join([&#39;&quot;%s&quot;&#39; % parameter.parameter_name for parameter in event.event_parameters])
126             }
127             lines.append(&#39;InspectorBackend.registerEvent(&quot;%(domain)s.%(eventName)s&quot;, [%(params)s]);&#39; % event_args)
128 
129         for command in commands:
130             def generate_parameter_object(parameter):
131                 optional_string = &quot;true&quot; if parameter.is_optional else &quot;false&quot;
132                 pairs = []
133                 pairs.append(&#39;&quot;name&quot;: &quot;%s&quot;&#39; % parameter.parameter_name)
134                 pairs.append(&#39;&quot;type&quot;: &quot;%s&quot;&#39; % Generator.js_name_for_parameter_type(parameter.type))
135                 pairs.append(&#39;&quot;optional&quot;: %s&#39; % optional_string)
136                 return &quot;{%s}&quot; % &quot;, &quot;.join(pairs)
137 
138             command_args = {
139                 &#39;domain&#39;: domain.domain_name,
140                 &#39;commandName&#39;: command.command_name,
141                 &#39;callParams&#39;: &quot;, &quot;.join([generate_parameter_object(parameter) for parameter in command.call_parameters]),
142                 &#39;returnParams&#39;: &quot;, &quot;.join([&#39;&quot;%s&quot;&#39; % parameter.parameter_name for parameter in command.return_parameters]),
143             }
144             lines.append(&#39;InspectorBackend.registerCommand(&quot;%(domain)s.%(commandName)s&quot;, [%(callParams)s], [%(returnParams)s]);&#39; % command_args)
145 
146         activate_args = {
147             &#39;domain&#39;: domain.domain_name,
148             &#39;availability&#39;: json.dumps(domain.availability) if domain.availability else &#39;&#39;,
149         }
150         if domain.availability:
151             lines.append(&#39;InspectorBackend.activateDomain(&quot;%(domain)s&quot;, %(availability)s);&#39; % activate_args)
152         else:
153             lines.append(&#39;InspectorBackend.activateDomain(&quot;%(domain)s&quot;);&#39; % activate_args)
154 
155         return &quot;\n&quot;.join(lines)
    </pre>
  </body>
</html>
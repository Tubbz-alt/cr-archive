<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMDebuggerAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2015 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;InspectorDOMDebuggerAgent.h&quot;
 34 
 35 #include &quot;Event.h&quot;
 36 #include &quot;EventTarget.h&quot;
 37 #include &quot;InspectorDOMAgent.h&quot;
 38 #include &quot;InstrumentingAgents.h&quot;
 39 #include &quot;JSEvent.h&quot;
 40 #include &quot;RegisteredEventListener.h&quot;
 41 #include &quot;ScriptExecutionContext.h&quot;
 42 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
 43 #include &lt;JavaScriptCore/InjectedScript.h&gt;
 44 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 45 #include &lt;JavaScriptCore/InspectorFrontendDispatchers.h&gt;
 46 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 47 #include &lt;wtf/JSONValues.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 using namespace Inspector;
 52 
 53 InspectorDOMDebuggerAgent::InspectorDOMDebuggerAgent(WebAgentContext&amp; context, InspectorDebuggerAgent* debuggerAgent)
 54     : InspectorAgentBase(&quot;DOMDebugger&quot;_s, context)
 55     , m_debuggerAgent(debuggerAgent)
 56     , m_backendDispatcher(Inspector::DOMDebuggerBackendDispatcher::create(context.backendDispatcher, this))
 57     , m_injectedScriptManager(context.injectedScriptManager)
 58 {
 59     m_debuggerAgent-&gt;addListener(*this);
 60 }
 61 
 62 InspectorDOMDebuggerAgent::~InspectorDOMDebuggerAgent() = default;
 63 
 64 bool InspectorDOMDebuggerAgent::enabled() const
 65 {
 66     return m_instrumentingAgents.inspectorDOMDebuggerAgent() == this;
 67 }
 68 
 69 void InspectorDOMDebuggerAgent::enable()
 70 {
 71     m_instrumentingAgents.setInspectorDOMDebuggerAgent(this);
 72 }
 73 
 74 void InspectorDOMDebuggerAgent::disable()
 75 {
 76     m_instrumentingAgents.setInspectorDOMDebuggerAgent(nullptr);
 77 
 78     m_listenerBreakpoints.clear();
 79     m_urlBreakpoints.clear();
 80     m_pauseOnAllIntervalsEnabled = false;
 81     m_pauseOnAllListenersEnabled = false;
 82     m_pauseOnAllTimeoutsEnabled = false;
 83     m_pauseOnAllURLsEnabled = false;
 84 }
 85 
 86 // Browser debugger agent enabled only when JS debugger is enabled.
 87 void InspectorDOMDebuggerAgent::debuggerWasEnabled()
 88 {
 89     ASSERT(!enabled());
 90     enable();
 91 }
 92 
 93 void InspectorDOMDebuggerAgent::debuggerWasDisabled()
 94 {
 95     ASSERT(enabled());
 96     disable();
 97 }
 98 
 99 void InspectorDOMDebuggerAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
100 {
101 }
102 
103 void InspectorDOMDebuggerAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
104 {
105     disable();
106 }
107 
108 void InspectorDOMDebuggerAgent::discardAgent()
109 {
110     m_debuggerAgent-&gt;removeListener(*this);
111     m_debuggerAgent = nullptr;
112 }
113 
114 void InspectorDOMDebuggerAgent::setEventBreakpoint(ErrorString&amp; errorString, const String&amp; breakpointTypeString, const String* eventName)
115 {
116     if (breakpointTypeString.isEmpty()) {
117         errorString = &quot;breakpointType is empty&quot;_s;
118         return;
119     }
120 
121     auto breakpointType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::DOMDebugger::EventBreakpointType&gt;(breakpointTypeString);
122     if (!breakpointType) {
123         errorString = makeString(&quot;Unknown breakpointType: &quot;_s, breakpointTypeString);
124         return;
125     }
126 
127     if (eventName &amp;&amp; !eventName-&gt;isEmpty()) {
128         if (breakpointType.value() == Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener) {
129             if (!m_listenerBreakpoints.add(*eventName))
130                 errorString = &quot;Breakpoint with eventName already exists&quot;_s;
131             return;
132         }
133 
134         errorString = &quot;Unexpected eventName&quot;_s;
135         return;
136     }
137 
138     switch (breakpointType.value()) {
139     case Inspector::Protocol::DOMDebugger::EventBreakpointType::AnimationFrame:
140         setAnimationFrameBreakpoint(errorString, true);
141         break;
142 
143     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Interval:
144         if (m_pauseOnAllIntervalsEnabled)
145             errorString = &quot;Breakpoint for Interval already exists&quot;_s;
146         m_pauseOnAllIntervalsEnabled = true;
147         break;
148 
149     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener:
150         if (m_pauseOnAllListenersEnabled)
151             errorString = &quot;Breakpoint for Listener already exists&quot;_s;
152         m_pauseOnAllListenersEnabled = true;
153         break;
154 
155     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Timeout:
156         if (m_pauseOnAllTimeoutsEnabled)
157             errorString = &quot;Breakpoint for Timeout already exists&quot;_s;
158         m_pauseOnAllTimeoutsEnabled = true;
159         break;
160     }
161 }
162 
163 void InspectorDOMDebuggerAgent::removeEventBreakpoint(ErrorString&amp; errorString, const String&amp; breakpointTypeString, const String* eventName)
164 {
165     if (breakpointTypeString.isEmpty()) {
166         errorString = &quot;breakpointType is empty&quot;_s;
167         return;
168     }
169 
170     auto breakpointType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::DOMDebugger::EventBreakpointType&gt;(breakpointTypeString);
171     if (!breakpointType) {
172         errorString = makeString(&quot;Unknown breakpointType: &quot;_s, breakpointTypeString);
173         return;
174     }
175 
176     if (eventName &amp;&amp; !eventName-&gt;isEmpty()) {
177         if (breakpointType.value() == Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener) {
178             if (!m_listenerBreakpoints.remove(*eventName))
179                 errorString = &quot;Breakpoint for given eventName missing&quot;_s;
180             return;
181         }
182 
183         errorString = &quot;Unexpected eventName&quot;_s;
184         return;
185     }
186 
187     switch (breakpointType.value()) {
188     case Inspector::Protocol::DOMDebugger::EventBreakpointType::AnimationFrame:
189         setAnimationFrameBreakpoint(errorString, false);
190         break;
191 
192     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Interval:
193         if (!m_pauseOnAllIntervalsEnabled)
194             errorString = &quot;Breakpoint for Intervals missing&quot;_s;
195         m_pauseOnAllIntervalsEnabled = false;
196         break;
197 
198     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener:
199         if (!m_pauseOnAllListenersEnabled)
200             errorString = &quot;Breakpoint for Listeners missing&quot;_s;
201         m_pauseOnAllListenersEnabled = false;
202         break;
203 
204     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Timeout:
205         if (!m_pauseOnAllTimeoutsEnabled)
206             errorString = &quot;Breakpoint for Timeouts missing&quot;_s;
207         m_pauseOnAllTimeoutsEnabled = false;
208         break;
209     }
210 }
211 
212 void InspectorDOMDebuggerAgent::willHandleEvent(Event&amp; event, const RegisteredEventListener&amp; registeredEventListener)
213 {
214     if (!m_debuggerAgent-&gt;breakpointsActive())
215         return;
216 
217     auto state = event.target()-&gt;scriptExecutionContext()-&gt;execState();
218     auto injectedScript = m_injectedScriptManager.injectedScriptFor(state);
219     ASSERT(!injectedScript.hasNoValue());
220     {
221         JSC::JSLockHolder lock(state);
222 
223         injectedScript.setEventValue(toJS(state, deprecatedGlobalObjectForPrototype(state), event));
224     }
225 
226     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
227 
228     bool shouldPause = m_debuggerAgent-&gt;pauseOnNextStatementEnabled() || m_pauseOnAllListenersEnabled || m_listenerBreakpoints.contains(event.type());
229     if (!shouldPause &amp;&amp; domAgent)
230         shouldPause = domAgent-&gt;hasBreakpointForEventListener(*event.currentTarget(), event.type(), registeredEventListener.callback(), registeredEventListener.useCapture());
231     if (!shouldPause)
232         return;
233 
234     Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
235     eventData-&gt;setString(&quot;eventName&quot;_s, event.type());
236     if (domAgent) {
237         int eventListenerId = domAgent-&gt;idForEventListener(*event.currentTarget(), event.type(), registeredEventListener.callback(), registeredEventListener.useCapture());
238         if (eventListenerId)
239             eventData-&gt;setInteger(&quot;eventListenerId&quot;_s, eventListenerId);
240     }
241 
242     m_debuggerAgent-&gt;schedulePauseOnNextStatement(Inspector::DebuggerFrontendDispatcher::Reason::Listener, WTFMove(eventData));
243 }
244 
245 void InspectorDOMDebuggerAgent::didHandleEvent()
246 {
247     m_injectedScriptManager.clearEventValue();
248 }
249 
250 void InspectorDOMDebuggerAgent::willFireTimer(bool oneShot)
251 {
252     if (!m_debuggerAgent-&gt;breakpointsActive())
253         return;
254 
255     bool shouldPause = m_debuggerAgent-&gt;pauseOnNextStatementEnabled() || (oneShot ? m_pauseOnAllTimeoutsEnabled : m_pauseOnAllIntervalsEnabled);
256     if (!shouldPause)
257         return;
258 
259     auto breakReason = oneShot ? Inspector::DebuggerFrontendDispatcher::Reason::Timeout : Inspector::DebuggerFrontendDispatcher::Reason::Interval;
260     m_debuggerAgent-&gt;schedulePauseOnNextStatement(breakReason, nullptr);
261 }
262 
263 void InspectorDOMDebuggerAgent::setURLBreakpoint(ErrorString&amp; errorString, const String&amp; url, const bool* optionalIsRegex)
264 {
265     if (url.isEmpty()) {
266         if (m_pauseOnAllURLsEnabled)
267             errorString = &quot;Breakpoint for all URLs already exists&quot;_s;
268         m_pauseOnAllURLsEnabled = true;
269         return;
270     }
271 
272     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
273     auto result = m_urlBreakpoints.set(url, isRegex ? URLBreakpointType::RegularExpression : URLBreakpointType::Text);
274     if (!result.isNewEntry)
275         errorString = &quot;Breakpoint for given url already exists&quot;_s;
276 }
277 
278 void InspectorDOMDebuggerAgent::removeURLBreakpoint(ErrorString&amp; errorString, const String&amp; url)
279 {
280     if (url.isEmpty()) {
281         if (!m_pauseOnAllURLsEnabled)
282             errorString = &quot;Breakpoint for all URLs missing&quot;_s;
283         m_pauseOnAllURLsEnabled = false;
284         return;
285     }
286 
287     auto result = m_urlBreakpoints.remove(url);
288     if (!result)
289         errorString = &quot;Breakpoint for given url missing&quot;_s;
290 }
291 
292 void InspectorDOMDebuggerAgent::breakOnURLIfNeeded(const String&amp; url, URLBreakpointSource source)
293 {
294     if (!m_debuggerAgent-&gt;breakpointsActive())
295         return;
296 
297     String breakpointURL;
298     if (m_pauseOnAllURLsEnabled)
299         breakpointURL = emptyString();
300     else {
301         for (auto&amp; [query, type] : m_urlBreakpoints) {
302             bool isRegex = type == URLBreakpointType::RegularExpression;
303             auto searchStringType = isRegex ? ContentSearchUtilities::SearchStringType::Regex : ContentSearchUtilities::SearchStringType::ContainsString;
304             auto regex = ContentSearchUtilities::createRegularExpressionForSearchString(query, false, searchStringType);
305             if (regex.match(url) != -1) {
306                 breakpointURL = query;
307                 break;
308             }
309         }
310     }
311 
312     if (breakpointURL.isNull())
313         return;
314 
315     Inspector::DebuggerFrontendDispatcher::Reason breakReason;
316     if (source == URLBreakpointSource::Fetch)
317         breakReason = Inspector::DebuggerFrontendDispatcher::Reason::Fetch;
318     else if (source == URLBreakpointSource::XHR)
319         breakReason = Inspector::DebuggerFrontendDispatcher::Reason::XHR;
320     else {
321         ASSERT_NOT_REACHED();
322         breakReason = Inspector::DebuggerFrontendDispatcher::Reason::Other;
323     }
324 
325     Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
326     eventData-&gt;setString(&quot;breakpointURL&quot;, breakpointURL);
327     eventData-&gt;setString(&quot;url&quot;, url);
328     m_debuggerAgent-&gt;breakProgram(breakReason, WTFMove(eventData));
329 }
330 
331 void InspectorDOMDebuggerAgent::willSendXMLHttpRequest(const String&amp; url)
332 {
333     breakOnURLIfNeeded(url, URLBreakpointSource::XHR);
334 }
335 
336 void InspectorDOMDebuggerAgent::willFetch(const String&amp; url)
337 {
338     breakOnURLIfNeeded(url, URLBreakpointSource::Fetch);
339 }
340 
341 } // namespace WebCore
    </pre>
  </body>
</html>
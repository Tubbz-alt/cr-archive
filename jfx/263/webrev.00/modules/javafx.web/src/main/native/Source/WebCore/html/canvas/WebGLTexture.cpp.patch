diff a/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLTexture.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLTexture.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLTexture.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLTexture.cpp
@@ -41,110 +41,110 @@
 }
 
 WebGLTexture::WebGLTexture(WebGLRenderingContextBase& ctx)
     : WebGLSharedObject(ctx)
     , m_target(0)
-    , m_minFilter(GraphicsContext3D::NEAREST_MIPMAP_LINEAR)
-    , m_magFilter(GraphicsContext3D::LINEAR)
-    , m_wrapS(GraphicsContext3D::REPEAT)
-    , m_wrapT(GraphicsContext3D::REPEAT)
+    , m_minFilter(GraphicsContextGL::NEAREST_MIPMAP_LINEAR)
+    , m_magFilter(GraphicsContextGL::LINEAR)
+    , m_wrapS(GraphicsContextGL::REPEAT)
+    , m_wrapT(GraphicsContextGL::REPEAT)
     , m_isNPOT(false)
     , m_isComplete(false)
     , m_needToUseBlackTexture(false)
     , m_isCompressed(false)
     , m_isFloatType(false)
     , m_isHalfFloatType(false)
     , m_isForWebGL1(ctx.isWebGL1())
 {
-    setObject(ctx.graphicsContext3D()->createTexture());
+    setObject(ctx.graphicsContextGL()->createTexture());
 }
 
 WebGLTexture::~WebGLTexture()
 {
     deleteObject(0);
 }
 
-void WebGLTexture::setTarget(GC3Denum target, GC3Dint maxLevel)
+void WebGLTexture::setTarget(GCGLenum target, GCGLint maxLevel)
 {
     if (!object())
         return;
     // Target is finalized the first time bindTexture() is called.
     if (m_target)
         return;
     switch (target) {
-    case GraphicsContext3D::TEXTURE_2D:
+    case GraphicsContextGL::TEXTURE_2D:
         m_target = target;
         m_info.resize(1);
         m_info[0].resize(maxLevel);
         break;
-    case GraphicsContext3D::TEXTURE_CUBE_MAP:
+    case GraphicsContextGL::TEXTURE_CUBE_MAP:
         m_target = target;
         m_info.resize(6);
         for (int ii = 0; ii < 6; ++ii)
             m_info[ii].resize(maxLevel);
         break;
     }
 }
 
-void WebGLTexture::setParameteri(GC3Denum pname, GC3Dint param)
+void WebGLTexture::setParameteri(GCGLenum pname, GCGLint param)
 {
     if (!object() || !m_target)
         return;
     switch (pname) {
-    case GraphicsContext3D::TEXTURE_MIN_FILTER:
+    case GraphicsContextGL::TEXTURE_MIN_FILTER:
         switch (param) {
-        case GraphicsContext3D::NEAREST:
-        case GraphicsContext3D::LINEAR:
-        case GraphicsContext3D::NEAREST_MIPMAP_NEAREST:
-        case GraphicsContext3D::LINEAR_MIPMAP_NEAREST:
-        case GraphicsContext3D::NEAREST_MIPMAP_LINEAR:
-        case GraphicsContext3D::LINEAR_MIPMAP_LINEAR:
+        case GraphicsContextGL::NEAREST:
+        case GraphicsContextGL::LINEAR:
+        case GraphicsContextGL::NEAREST_MIPMAP_NEAREST:
+        case GraphicsContextGL::LINEAR_MIPMAP_NEAREST:
+        case GraphicsContextGL::NEAREST_MIPMAP_LINEAR:
+        case GraphicsContextGL::LINEAR_MIPMAP_LINEAR:
             m_minFilter = param;
             break;
         }
         break;
-    case GraphicsContext3D::TEXTURE_MAG_FILTER:
+    case GraphicsContextGL::TEXTURE_MAG_FILTER:
         switch (param) {
-        case GraphicsContext3D::NEAREST:
-        case GraphicsContext3D::LINEAR:
+        case GraphicsContextGL::NEAREST:
+        case GraphicsContextGL::LINEAR:
             m_magFilter = param;
             break;
         }
         break;
-    case GraphicsContext3D::TEXTURE_WRAP_S:
+    case GraphicsContextGL::TEXTURE_WRAP_S:
         switch (param) {
-        case GraphicsContext3D::CLAMP_TO_EDGE:
-        case GraphicsContext3D::MIRRORED_REPEAT:
-        case GraphicsContext3D::REPEAT:
+        case GraphicsContextGL::CLAMP_TO_EDGE:
+        case GraphicsContextGL::MIRRORED_REPEAT:
+        case GraphicsContextGL::REPEAT:
             m_wrapS = param;
             break;
         }
         break;
-    case GraphicsContext3D::TEXTURE_WRAP_T:
+    case GraphicsContextGL::TEXTURE_WRAP_T:
         switch (param) {
-        case GraphicsContext3D::CLAMP_TO_EDGE:
-        case GraphicsContext3D::MIRRORED_REPEAT:
-        case GraphicsContext3D::REPEAT:
+        case GraphicsContextGL::CLAMP_TO_EDGE:
+        case GraphicsContextGL::MIRRORED_REPEAT:
+        case GraphicsContextGL::REPEAT:
             m_wrapT = param;
             break;
         }
         break;
     default:
         return;
     }
     update();
 }
 
-void WebGLTexture::setParameterf(GC3Denum pname, GC3Dfloat param)
+void WebGLTexture::setParameterf(GCGLenum pname, GCGLfloat param)
 {
     if (!object() || !m_target)
         return;
-    GC3Dint iparam = static_cast<GC3Dint>(param);
+    GCGLint iparam = static_cast<GCGLint>(param);
     setParameteri(pname, iparam);
 }
 
-void WebGLTexture::setLevelInfo(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Denum type)
+void WebGLTexture::setLevelInfo(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLenum type)
 {
     if (!object() || !m_target)
         return;
     // We assume level, internalFormat, width, height, and type have all been
     // validated already.
@@ -162,14 +162,14 @@
     if (!canGenerateMipmaps())
         return;
     if (!m_isComplete) {
         for (size_t ii = 0; ii < m_info.size(); ++ii) {
             const LevelInfo& info0 = m_info[ii][0];
-            GC3Dsizei width = info0.width;
-            GC3Dsizei height = info0.height;
-            GC3Dint levelCount = computeLevelCount(width, height);
-            for (GC3Dint level = 1; level < levelCount; ++level) {
+            GCGLsizei width = info0.width;
+            GCGLsizei height = info0.height;
+            GCGLint levelCount = computeLevelCount(width, height);
+            for (GCGLint level = 1; level < levelCount; ++level) {
                 width = std::max(1, width >> 1);
                 height = std::max(1, height >> 1);
                 LevelInfo& info = m_info[ii][level];
                 info.setInfo(info0.internalFormat, width, height, info0.type);
             }
@@ -177,61 +177,61 @@
         m_isComplete = true;
     }
     m_needToUseBlackTexture = false;
 }
 
-GC3Denum WebGLTexture::getInternalFormat(GC3Denum target, GC3Dint level) const
+GCGLenum WebGLTexture::getInternalFormat(GCGLenum target, GCGLint level) const
 {
     const LevelInfo* info = getLevelInfo(target, level);
     if (!info)
         return 0;
     return info->internalFormat;
 }
 
-GC3Denum WebGLTexture::getType(GC3Denum target, GC3Dint level) const
+GCGLenum WebGLTexture::getType(GCGLenum target, GCGLint level) const
 {
     ASSERT(m_isForWebGL1);
     const LevelInfo* info = getLevelInfo(target, level);
     if (!info)
         return 0;
     return info->type;
 }
 
-GC3Dsizei WebGLTexture::getWidth(GC3Denum target, GC3Dint level) const
+GCGLsizei WebGLTexture::getWidth(GCGLenum target, GCGLint level) const
 {
     const LevelInfo* info = getLevelInfo(target, level);
     if (!info)
         return 0;
     return info->width;
 }
 
-GC3Dsizei WebGLTexture::getHeight(GC3Denum target, GC3Dint level) const
+GCGLsizei WebGLTexture::getHeight(GCGLenum target, GCGLint level) const
 {
     const LevelInfo* info = getLevelInfo(target, level);
     if (!info)
         return 0;
     return info->height;
 }
 
-bool WebGLTexture::isValid(GC3Denum target, GC3Dint level) const
+bool WebGLTexture::isValid(GCGLenum target, GCGLint level) const
 {
     const LevelInfo* info = getLevelInfo(target, level);
     if (!info)
         return 0;
     return info->valid;
 }
 
-void WebGLTexture::markInvalid(GC3Denum target, GC3Dint level)
+void WebGLTexture::markInvalid(GCGLenum target, GCGLint level)
 {
     int index = mapTargetToIndex(target);
     if (index < 0)
         return;
     m_info[index][level].valid = false;
     update();
 }
 
-bool WebGLTexture::isNPOT(GC3Dsizei width, GC3Dsizei height)
+bool WebGLTexture::isNPOT(GCGLsizei width, GCGLsizei height)
 {
     ASSERT(width >= 0 && height >= 0);
     if (!width || !height)
         return false;
     if ((width & (width - 1)) || (height & (height - 1)))
@@ -250,11 +250,11 @@
 {
     if (!object())
         return false;
     if (m_needToUseBlackTexture)
         return true;
-    if (m_magFilter == GraphicsContext3D::NEAREST && (m_minFilter == GraphicsContext3D::NEAREST || m_minFilter == GraphicsContext3D::NEAREST_MIPMAP_NEAREST))
+    if (m_magFilter == GraphicsContextGL::NEAREST && (m_minFilter == GraphicsContextGL::NEAREST || m_minFilter == GraphicsContextGL::NEAREST_MIPMAP_NEAREST))
         return false;
     if (m_isForWebGL1 && m_isHalfFloatType && !(extensions & TextureExtensionHalfFloatLinearEnabled))
         return true;
     if (m_isFloatType && !(extensions & TextureExtensionFloatLinearEnabled))
         return true;
@@ -272,33 +272,33 @@
 {
     ASSERT(object());
     m_isCompressed = true;
 }
 
-void WebGLTexture::deleteObjectImpl(GraphicsContext3D* context3d, Platform3DObject object)
+void WebGLTexture::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)
 {
     context3d->deleteTexture(object);
 }
 
-int WebGLTexture::mapTargetToIndex(GC3Denum target) const
+int WebGLTexture::mapTargetToIndex(GCGLenum target) const
 {
-    if (m_target == GraphicsContext3D::TEXTURE_2D) {
-        if (target == GraphicsContext3D::TEXTURE_2D)
+    if (m_target == GraphicsContextGL::TEXTURE_2D) {
+        if (target == GraphicsContextGL::TEXTURE_2D)
             return 0;
-    } else if (m_target == GraphicsContext3D::TEXTURE_CUBE_MAP) {
+    } else if (m_target == GraphicsContextGL::TEXTURE_CUBE_MAP) {
         switch (target) {
-        case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:
+        case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:
             return 0;
-        case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:
+        case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:
             return 1;
-        case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:
+        case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:
             return 2;
-        case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:
+        case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:
             return 3;
-        case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:
+        case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:
             return 4;
-        case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:
+        case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:
             return 5;
         }
     }
     return -1;
 }
@@ -316,54 +316,54 @@
             return false;
     }
     return true;
 }
 
-GC3Dint WebGLTexture::computeLevelCount(GC3Dsizei width, GC3Dsizei height)
+GCGLint WebGLTexture::computeLevelCount(GCGLsizei width, GCGLsizei height)
 {
     // return 1 + log2Floor(std::max(width, height));
-    GC3Dsizei n = std::max(width, height);
+    GCGLsizei n = std::max(width, height);
     if (n <= 0)
         return 0;
-    GC3Dint log = 0;
-    GC3Dsizei value = n;
+    GCGLint log = 0;
+    GCGLsizei value = n;
     for (int ii = 4; ii >= 0; --ii) {
         int shift = (1 << ii);
-        GC3Dsizei x = (value >> shift);
+        GCGLsizei x = (value >> shift);
         if (x) {
             value = x;
             log += shift;
         }
     }
     ASSERT(value == 1);
     return log + 1;
 }
 
-static bool internalFormatIsFloatType(GC3Denum internalFormat)
+static bool internalFormatIsFloatType(GCGLenum internalFormat)
 {
     switch (internalFormat) {
-    case GraphicsContext3D::R32F:
-    case GraphicsContext3D::RG32F:
-    case GraphicsContext3D::RGB32F:
-    case GraphicsContext3D::RGBA32F:
-    case GraphicsContext3D::DEPTH_COMPONENT32F:
-    case GraphicsContext3D::DEPTH32F_STENCIL8:
+    case GraphicsContextGL::R32F:
+    case GraphicsContextGL::RG32F:
+    case GraphicsContextGL::RGB32F:
+    case GraphicsContextGL::RGBA32F:
+    case GraphicsContextGL::DEPTH_COMPONENT32F:
+    case GraphicsContextGL::DEPTH32F_STENCIL8:
         return true;
     default:
         return false;
     }
 }
 
-static bool internalFormatIsHalfFloatType(GC3Denum internalFormat)
+static bool internalFormatIsHalfFloatType(GCGLenum internalFormat)
 {
     switch (internalFormat) {
-    case GraphicsContext3D::R16F:
-    case GraphicsContext3D::RG16F:
-    case GraphicsContext3D::R11F_G11F_B10F:
-    case GraphicsContext3D::RGB9_E5:
-    case GraphicsContext3D::RGB16F:
-    case GraphicsContext3D::RGBA16F:
+    case GraphicsContextGL::R16F:
+    case GraphicsContextGL::RG16F:
+    case GraphicsContextGL::R11F_G11F_B10F:
+    case GraphicsContextGL::RGB9_E5:
+    case GraphicsContextGL::RGB16F:
+    case GraphicsContextGL::RGBA16F:
         return true;
     default:
         return false;
     }
 }
@@ -377,11 +377,11 @@
             break;
         }
     }
     m_isComplete = true;
     const LevelInfo& first = m_info[0][0];
-    GC3Dint levelCount = computeLevelCount(first.width, first.height);
+    GCGLint levelCount = computeLevelCount(first.width, first.height);
     if (levelCount < 1)
         m_isComplete = false;
     else {
         for (size_t ii = 0; ii < m_info.size() && m_isComplete; ++ii) {
             const LevelInfo& info0 = m_info[ii][0];
@@ -389,13 +389,13 @@
                 || info0.width != first.width || info0.height != first.height
                 || info0.internalFormat != first.internalFormat || (m_isForWebGL1 && info0.type != first.type)) {
                 m_isComplete = false;
                 break;
             }
-            GC3Dsizei width = info0.width;
-            GC3Dsizei height = info0.height;
-            for (GC3Dint level = 1; level < levelCount; ++level) {
+            GCGLsizei width = info0.width;
+            GCGLsizei height = info0.height;
+            for (GCGLint level = 1; level < levelCount; ++level) {
                 width = std::max(1, width >> 1);
                 height = std::max(1, height >> 1);
                 const LevelInfo& info = m_info[ii][level];
                 if (!info.valid
                     || info.width != width || info.height != height
@@ -410,16 +410,16 @@
 
     m_isFloatType = false;
     if (m_isForWebGL1) {
         if (m_isComplete) {
             if (m_isForWebGL1)
-                m_isFloatType = m_info[0][0].type == GraphicsContext3D::FLOAT;
+                m_isFloatType = m_info[0][0].type == GraphicsContextGL::FLOAT;
             else
                 m_isFloatType = internalFormatIsFloatType(m_info[0][0].internalFormat);
         } else {
             for (size_t ii = 0; ii < m_info.size(); ++ii) {
-                if ((m_isForWebGL1 && m_info[ii][0].type == GraphicsContext3D::FLOAT)
+                if ((m_isForWebGL1 && m_info[ii][0].type == GraphicsContextGL::FLOAT)
                     || (!m_isForWebGL1 && internalFormatIsFloatType(m_info[ii][0].internalFormat))) {
                     m_isFloatType = true;
                     break;
                 }
             }
@@ -430,40 +430,40 @@
     if (m_isForWebGL1) {
         if (m_isComplete) {
             if (m_isForWebGL1)
                 m_isHalfFloatType = internalFormatIsHalfFloatType(m_info[0][0].internalFormat);
             else
-                m_isHalfFloatType = m_info[0][0].type == GraphicsContext3D::HALF_FLOAT_OES;
+                m_isHalfFloatType = m_info[0][0].type == GraphicsContextGL::HALF_FLOAT_OES;
         } else {
             for (size_t ii = 0; ii < m_info.size(); ++ii) {
-                if ((m_isForWebGL1 && m_info[ii][0].type == GraphicsContext3D::HALF_FLOAT_OES)
+                if ((m_isForWebGL1 && m_info[ii][0].type == GraphicsContextGL::HALF_FLOAT_OES)
                     || (!m_isForWebGL1 && internalFormatIsHalfFloatType(m_info[ii][0].internalFormat))) {
                     m_isHalfFloatType = true;
                     break;
                 }
             }
         }
     }
 
     m_needToUseBlackTexture = false;
     // NPOT
-    if (m_isNPOT && ((m_minFilter != GraphicsContext3D::NEAREST && m_minFilter != GraphicsContext3D::LINEAR)
-                     || m_wrapS != GraphicsContext3D::CLAMP_TO_EDGE || m_wrapT != GraphicsContext3D::CLAMP_TO_EDGE))
+    if (m_isNPOT && ((m_minFilter != GraphicsContextGL::NEAREST && m_minFilter != GraphicsContextGL::LINEAR)
+        || m_wrapS != GraphicsContextGL::CLAMP_TO_EDGE || m_wrapT != GraphicsContextGL::CLAMP_TO_EDGE))
         m_needToUseBlackTexture = true;
     // Completeness
-    if (!m_isComplete && m_minFilter != GraphicsContext3D::NEAREST && m_minFilter != GraphicsContext3D::LINEAR)
+    if (!m_isComplete && m_minFilter != GraphicsContextGL::NEAREST && m_minFilter != GraphicsContextGL::LINEAR)
         m_needToUseBlackTexture = true;
 }
 
-const WebGLTexture::LevelInfo* WebGLTexture::getLevelInfo(GC3Denum target, GC3Dint level) const
+const WebGLTexture::LevelInfo* WebGLTexture::getLevelInfo(GCGLenum target, GCGLint level) const
 {
     if (!object() || !m_target)
         return 0;
     int targetIndex = mapTargetToIndex(target);
     if (targetIndex < 0 || targetIndex >= static_cast<int>(m_info.size()))
         return 0;
-    if (level < 0 || level >= static_cast<GC3Dint>(m_info[targetIndex].size()))
+    if (level < 0 || level >= static_cast<GCGLint>(m_info[targetIndex].size()))
         return 0;
     return &(m_info[targetIndex][level]);
 }
 
 }

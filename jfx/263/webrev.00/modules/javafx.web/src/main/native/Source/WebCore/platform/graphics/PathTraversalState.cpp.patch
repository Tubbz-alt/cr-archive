diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PathTraversalState.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PathTraversalState.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PathTraversalState.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PathTraversalState.cpp
@@ -33,13 +33,11 @@
     return FloatPoint((first.x() + second.x()) / 2.0f, (first.y() + second.y()) / 2.0f);
 }
 
 static inline float distanceLine(const FloatPoint& start, const FloatPoint& end)
 {
-    float dx = end.x() - start.x();
-    float dy = end.y() - start.y();
-    return sqrtf(dx * dx + dy * dy);
+    return std::hypot(end.x() - start.x(), end.y() - start.y());
 }
 
 struct QuadraticBezier {
     QuadraticBezier() { }
     QuadraticBezier(const FloatPoint& s, const FloatPoint& c, const FloatPoint& e)
@@ -241,34 +239,34 @@
 
     m_previous = m_current;
     return m_success;
 }
 
-bool PathTraversalState::appendPathElement(PathElementType type, const FloatPoint* points)
+bool PathTraversalState::appendPathElement(PathElement::Type type, const FloatPoint* points)
 {
     switch (type) {
-    case PathElementMoveToPoint:
+    case PathElement::Type::MoveToPoint:
         moveTo(points[0]);
         break;
-    case PathElementAddLineToPoint:
+    case PathElement::Type::AddLineToPoint:
         lineTo(points[0]);
         break;
-    case PathElementAddQuadCurveToPoint:
+    case PathElement::Type::AddQuadCurveToPoint:
         quadraticBezierTo(points[0], points[1]);
         break;
-    case PathElementAddCurveToPoint:
+    case PathElement::Type::AddCurveToPoint:
         cubicBezierTo(points[0], points[1], points[2]);
         break;
-    case PathElementCloseSubpath:
+    case PathElement::Type::CloseSubpath:
         closeSubpath();
         break;
     }
 
     return finalizeAppendPathElement();
 }
 
-bool PathTraversalState::processPathElement(PathElementType type, const FloatPoint* points)
+bool PathTraversalState::processPathElement(PathElement::Type type, const FloatPoint* points)
 {
     if (m_success)
         return true;
 
     if (m_isZeroVector) {

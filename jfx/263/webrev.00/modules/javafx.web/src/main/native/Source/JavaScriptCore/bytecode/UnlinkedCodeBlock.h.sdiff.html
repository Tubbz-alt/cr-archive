<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnlinkedCodeBlock.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedEvalCodeBlock.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;BytecodeConventions.h&quot;
 29 #include &quot;CodeType.h&quot;
 30 #include &quot;DFGExitProfile.h&quot;
 31 #include &quot;ExpressionRangeInfo.h&quot;
 32 #include &quot;HandlerInfo.h&quot;
 33 #include &quot;Identifier.h&quot;
 34 #include &quot;InstructionStream.h&quot;
 35 #include &quot;JSCast.h&quot;
 36 #include &quot;LockDuringMarking.h&quot;
 37 #include &quot;Opcode.h&quot;
 38 #include &quot;ParserModes.h&quot;
 39 #include &quot;RegExp.h&quot;
<span class="line-removed"> 40 #include &quot;SpecialPointer.h&quot;</span>
 41 #include &quot;UnlinkedFunctionExecutable.h&quot;
 42 #include &quot;UnlinkedMetadataTable.h&quot;
 43 #include &quot;VirtualRegister.h&quot;
 44 #include &lt;algorithm&gt;
 45 #include &lt;wtf/BitVector.h&gt;
 46 #include &lt;wtf/HashSet.h&gt;

 47 #include &lt;wtf/TriState.h&gt;
 48 #include &lt;wtf/Vector.h&gt;
 49 #include &lt;wtf/text/UniquedStringImpl.h&gt;
 50 
 51 namespace JSC {
 52 
<span class="line-removed"> 53 class BytecodeGenerator;</span>
 54 class BytecodeLivenessAnalysis;
 55 class BytecodeRewriter;
 56 class CodeBlock;
 57 class Debugger;
 58 class FunctionExecutable;
 59 class ParserError;
 60 class ScriptExecutable;
 61 class SourceCode;
 62 class SourceProvider;
 63 class UnlinkedCodeBlock;

 64 class UnlinkedFunctionCodeBlock;
 65 class UnlinkedFunctionExecutable;
 66 struct ExecutableInfo;

 67 
 68 template&lt;typename CodeBlockType&gt;
 69 class CachedCodeBlock;
 70 
 71 typedef unsigned UnlinkedValueProfile;
 72 typedef unsigned UnlinkedArrayProfile;
 73 typedef unsigned UnlinkedArrayAllocationProfile;
 74 typedef unsigned UnlinkedObjectAllocationProfile;
 75 typedef unsigned UnlinkedLLIntCallLinkInfo;
 76 using ConstantIdentifierSetEntry = std::pair&lt;IdentifierSet, unsigned&gt;;
 77 
 78 struct UnlinkedStringJumpTable {
 79     struct OffsetLocation {
 80         int32_t branchOffset;
 81     };
 82 
 83     typedef HashMap&lt;RefPtr&lt;StringImpl&gt;, OffsetLocation&gt; StringOffsetTable;
 84     StringOffsetTable offsetTable;
 85 
 86     inline int32_t offsetForValue(StringImpl* value, int32_t defaultOffset)
 87     {
 88         StringOffsetTable::const_iterator end = offsetTable.end();
 89         StringOffsetTable::const_iterator loc = offsetTable.find(value);
 90         if (loc == end)
 91             return defaultOffset;
 92         return loc-&gt;value.branchOffset;
 93     }
 94 
 95 };
 96 
 97 struct UnlinkedSimpleJumpTable {
<span class="line-modified"> 98     Vector&lt;int32_t&gt; branchOffsets;</span>
 99     int32_t min;
100 
101     int32_t offsetForValue(int32_t value, int32_t defaultOffset);
102     void add(int32_t key, int32_t offset)
103     {
104         if (!branchOffsets[key])
105             branchOffsets[key] = offset;
106     }
107 };
108 
109 class UnlinkedCodeBlock : public JSCell {
110 public:
111     typedef JSCell Base;
<span class="line-modified">112     static const unsigned StructureFlags = Base::StructureFlags;</span>
113 
<span class="line-modified">114     static const bool needsDestruction = true;</span>






115 
116     enum { CallFunction, ApplyFunction };
117 
118     bool isConstructor() const { return m_isConstructor; }
119     bool isStrictMode() const { return m_isStrictMode; }
120     bool usesEval() const { return m_usesEval; }
121     SourceParseMode parseMode() const { return m_parseMode; }
122     bool isArrowFunction() const { return isArrowFunctionParseMode(parseMode()); }
123     DerivedContextType derivedContextType() const { return static_cast&lt;DerivedContextType&gt;(m_derivedContextType); }
124     EvalContextType evalContextType() const { return static_cast&lt;EvalContextType&gt;(m_evalContextType); }
125     bool isArrowFunctionContext() const { return m_isArrowFunctionContext; }
126     bool isClassContext() const { return m_isClassContext; }
127     bool hasTailCalls() const { return m_hasTailCalls; }
128     void setHasTailCalls() { m_hasTailCalls = true; }
129     bool allowDirectEvalCache() const { return !(m_features &amp; NoEvalCacheFeature); }
130 
<span class="line-removed">131     void addExpressionInfo(unsigned instructionOffset, int divot,</span>
<span class="line-removed">132         int startOffset, int endOffset, unsigned line, unsigned column);</span>
<span class="line-removed">133 </span>
<span class="line-removed">134     void addTypeProfilerExpressionInfo(unsigned instructionOffset, unsigned startDivot, unsigned endDivot);</span>
<span class="line-removed">135 </span>
136     bool hasExpressionInfo() { return m_expressionInfo.size(); }
<span class="line-modified">137     const Vector&lt;ExpressionRangeInfo&gt;&amp; expressionInfo() { return m_expressionInfo; }</span>



138 
139     // Special registers
140     void setThisRegister(VirtualRegister thisRegister) { m_thisRegister = thisRegister; }
141     void setScopeRegister(VirtualRegister scopeRegister) { m_scopeRegister = scopeRegister; }
142 
143     // Parameter information
144     void setNumParameters(int newValue) { m_numParameters = newValue; }
<span class="line-removed">145     void addParameter() { m_numParameters++; }</span>
146     unsigned numParameters() const { return m_numParameters; }
147 
148     // Constant Pools
149 
150     size_t numberOfIdentifiers() const { return m_identifiers.size(); }
<span class="line-removed">151     void addIdentifier(const Identifier&amp; i) { return m_identifiers.append(i); }</span>
152     const Identifier&amp; identifier(int index) const { return m_identifiers[index]; }
<span class="line-modified">153     const Vector&lt;Identifier&gt;&amp; identifiers() const { return m_identifiers; }</span>
154 
155     BitVector&amp; bitVector(size_t i) { ASSERT(m_rareData); return m_rareData-&gt;m_bitVectors[i]; }
<span class="line-removed">156     unsigned addBitVector(BitVector&amp;&amp; bitVector)</span>
<span class="line-removed">157     {</span>
<span class="line-removed">158         createRareDataIfNecessary();</span>
<span class="line-removed">159         m_rareData-&gt;m_bitVectors.append(WTFMove(bitVector));</span>
<span class="line-removed">160         return m_rareData-&gt;m_bitVectors.size() - 1;</span>
<span class="line-removed">161     }</span>
162 
<span class="line-modified">163     void addSetConstant(IdentifierSet&amp; set)</span>
<span class="line-modified">164     {</span>
<span class="line-modified">165         createRareDataIfNecessary();</span>
<span class="line-modified">166         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">167         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">168         unsigned result = m_constantRegisters.size();</span>
<span class="line-removed">169         m_constantRegisters.append(WriteBarrier&lt;Unknown&gt;());</span>
<span class="line-removed">170         m_constantsSourceCodeRepresentation.append(SourceCodeRepresentation::Other);</span>
<span class="line-removed">171         m_rareData-&gt;m_constantIdentifierSets.append(ConstantIdentifierSetEntry(set, result));</span>
<span class="line-removed">172     }</span>
<span class="line-removed">173 </span>
<span class="line-removed">174     unsigned addConstant(JSValue v, SourceCodeRepresentation sourceCodeRepresentation = SourceCodeRepresentation::Other)</span>
<span class="line-removed">175     {</span>
<span class="line-removed">176         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">177         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">178         unsigned result = m_constantRegisters.size();</span>
<span class="line-removed">179         m_constantRegisters.append(WriteBarrier&lt;Unknown&gt;());</span>
<span class="line-removed">180         m_constantRegisters.last().set(vm, this, v);</span>
<span class="line-removed">181         m_constantsSourceCodeRepresentation.append(sourceCodeRepresentation);</span>
<span class="line-removed">182         return result;</span>
<span class="line-removed">183     }</span>
<span class="line-removed">184     unsigned addConstant(LinkTimeConstant type)</span>
<span class="line-removed">185     {</span>
<span class="line-removed">186         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">187         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">188         unsigned result = m_constantRegisters.size();</span>
<span class="line-removed">189         ASSERT(result);</span>
<span class="line-removed">190         unsigned index = static_cast&lt;unsigned&gt;(type);</span>
<span class="line-removed">191         ASSERT(index &lt; LinkTimeConstantCount);</span>
<span class="line-removed">192         m_linkTimeConstants[index] = result;</span>
<span class="line-removed">193         m_constantRegisters.append(WriteBarrier&lt;Unknown&gt;());</span>
<span class="line-removed">194         m_constantsSourceCodeRepresentation.append(SourceCodeRepresentation::Other);</span>
<span class="line-removed">195         return result;</span>
<span class="line-removed">196     }</span>
<span class="line-removed">197 </span>
<span class="line-removed">198     unsigned registerIndexForLinkTimeConstant(LinkTimeConstant type)</span>
<span class="line-removed">199     {</span>
<span class="line-removed">200         unsigned index = static_cast&lt;unsigned&gt;(type);</span>
<span class="line-removed">201         ASSERT(index &lt; LinkTimeConstantCount);</span>
<span class="line-removed">202         return m_linkTimeConstants[index];</span>
<span class="line-removed">203     }</span>
<span class="line-removed">204 </span>
<span class="line-removed">205     const Vector&lt;WriteBarrier&lt;Unknown&gt;&gt;&amp; constantRegisters() { return m_constantRegisters; }</span>
<span class="line-removed">206     const WriteBarrier&lt;Unknown&gt;&amp; constantRegister(int index) const { return m_constantRegisters[index - FirstConstantRegisterIndex]; }</span>
<span class="line-removed">207     ALWAYS_INLINE bool isConstantRegisterIndex(int index) const { return index &gt;= FirstConstantRegisterIndex; }</span>
<span class="line-removed">208     ALWAYS_INLINE JSValue getConstant(int index) const { return m_constantRegisters[index - FirstConstantRegisterIndex].get(); }</span>
<span class="line-removed">209     const Vector&lt;SourceCodeRepresentation&gt;&amp; constantsSourceCodeRepresentation() { return m_constantsSourceCodeRepresentation; }</span>
210 
211     unsigned numberOfConstantIdentifierSets() const { return m_rareData ? m_rareData-&gt;m_constantIdentifierSets.size() : 0; }
<span class="line-modified">212     const Vector&lt;ConstantIdentifierSetEntry&gt;&amp; constantIdentifierSets() { ASSERT(m_rareData); return m_rareData-&gt;m_constantIdentifierSets; }</span>
213 
214     // Jumps
215     size_t numberOfJumpTargets() const { return m_jumpTargets.size(); }
<span class="line-removed">216     void addJumpTarget(unsigned jumpTarget) { m_jumpTargets.append(jumpTarget); }</span>
217     unsigned jumpTarget(int index) const { return m_jumpTargets[index]; }
218     unsigned lastJumpTarget() const { return m_jumpTargets.last(); }
219 
<span class="line-modified">220     UnlinkedHandlerInfo* handlerForBytecodeOffset(unsigned bytecodeOffset, RequiredHandler = RequiredHandler::AnyHandler);</span>
221     UnlinkedHandlerInfo* handlerForIndex(unsigned, RequiredHandler = RequiredHandler::AnyHandler);
222 
223     bool isBuiltinFunction() const { return m_isBuiltinFunction; }
224 
225     ConstructorKind constructorKind() const { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
226     SuperBinding superBinding() const { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
227     JSParserScriptMode scriptMode() const { return static_cast&lt;JSParserScriptMode&gt;(m_scriptMode); }
228 
<span class="line-removed">229     void shrinkToFit();</span>
<span class="line-removed">230 </span>
<span class="line-removed">231     void setInstructions(std::unique_ptr&lt;InstructionStream&gt;);</span>
232     const InstructionStream&amp; instructions() const;
233 
234     int numCalleeLocals() const { return m_numCalleeLocals; }
235     int numVars() const { return m_numVars; }
236 
237     // Jump Tables
238 
239     size_t numberOfSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_switchJumpTables.size() : 0; }
<span class="line-removed">240     UnlinkedSimpleJumpTable&amp; addSwitchJumpTable() { createRareDataIfNecessary(); m_rareData-&gt;m_switchJumpTables.append(UnlinkedSimpleJumpTable()); return m_rareData-&gt;m_switchJumpTables.last(); }</span>
241     UnlinkedSimpleJumpTable&amp; switchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_switchJumpTables[tableIndex]; }
242 
243     size_t numberOfStringSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_stringSwitchJumpTables.size() : 0; }
<span class="line-removed">244     UnlinkedStringJumpTable&amp; addStringSwitchJumpTable() { createRareDataIfNecessary(); m_rareData-&gt;m_stringSwitchJumpTables.append(UnlinkedStringJumpTable()); return m_rareData-&gt;m_stringSwitchJumpTables.last(); }</span>
245     UnlinkedStringJumpTable&amp; stringSwitchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_stringSwitchJumpTables[tableIndex]; }
246 
<span class="line-removed">247     unsigned addFunctionDecl(UnlinkedFunctionExecutable* n)</span>
<span class="line-removed">248     {</span>
<span class="line-removed">249         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">250         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">251         unsigned size = m_functionDecls.size();</span>
<span class="line-removed">252         m_functionDecls.append(WriteBarrier&lt;UnlinkedFunctionExecutable&gt;());</span>
<span class="line-removed">253         m_functionDecls.last().set(vm, this, n);</span>
<span class="line-removed">254         return size;</span>
<span class="line-removed">255     }</span>
256     UnlinkedFunctionExecutable* functionDecl(int index) { return m_functionDecls[index].get(); }
257     size_t numberOfFunctionDecls() { return m_functionDecls.size(); }
<span class="line-removed">258     unsigned addFunctionExpr(UnlinkedFunctionExecutable* n)</span>
<span class="line-removed">259     {</span>
<span class="line-removed">260         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">261         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">262         unsigned size = m_functionExprs.size();</span>
<span class="line-removed">263         m_functionExprs.append(WriteBarrier&lt;UnlinkedFunctionExecutable&gt;());</span>
<span class="line-removed">264         m_functionExprs.last().set(vm, this, n);</span>
<span class="line-removed">265         return size;</span>
<span class="line-removed">266     }</span>
267     UnlinkedFunctionExecutable* functionExpr(int index) { return m_functionExprs[index].get(); }
268     size_t numberOfFunctionExprs() { return m_functionExprs.size(); }
269 
270     // Exception handling support
271     size_t numberOfExceptionHandlers() const { return m_rareData ? m_rareData-&gt;m_exceptionHandlers.size() : 0; }
<span class="line-removed">272     void addExceptionHandler(const UnlinkedHandlerInfo&amp; handler) { createRareDataIfNecessary(); return m_rareData-&gt;m_exceptionHandlers.append(handler); }</span>
273     UnlinkedHandlerInfo&amp; exceptionHandler(int index) { ASSERT(m_rareData); return m_rareData-&gt;m_exceptionHandlers[index]; }
274 
275     CodeType codeType() const { return static_cast&lt;CodeType&gt;(m_codeType); }
276 
277     VirtualRegister thisRegister() const { return m_thisRegister; }
278     VirtualRegister scopeRegister() const { return m_scopeRegister; }
279 
<span class="line-removed">280     void addPropertyAccessInstruction(InstructionStream::Offset propertyAccessInstruction)</span>
<span class="line-removed">281     {</span>
<span class="line-removed">282         m_propertyAccessInstructions.append(propertyAccessInstruction);</span>
<span class="line-removed">283     }</span>
<span class="line-removed">284 </span>
<span class="line-removed">285     size_t numberOfPropertyAccessInstructions() const { return m_propertyAccessInstructions.size(); }</span>
<span class="line-removed">286     const Vector&lt;InstructionStream::Offset&gt;&amp; propertyAccessInstructions() const { return m_propertyAccessInstructions; }</span>
<span class="line-removed">287 </span>
288     bool hasRareData() const { return m_rareData.get(); }
289 
<span class="line-modified">290     int lineNumberForBytecodeOffset(unsigned bytecodeOffset);</span>
291 
<span class="line-modified">292     void expressionRangeForBytecodeOffset(unsigned bytecodeOffset, int&amp; divot,</span>
293         int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const;
294 
295     bool typeProfilerExpressionInfoForBytecodeOffset(unsigned bytecodeOffset, unsigned&amp; startDivot, unsigned&amp; endDivot);
296 
297     void recordParse(CodeFeatures features, bool hasCapturedVariables, unsigned lineCount, unsigned endColumn)
298     {
299         m_features = features;
300         m_hasCapturedVariables = hasCapturedVariables;
301         m_lineCount = lineCount;
302         // For the UnlinkedCodeBlock, startColumn is always 0.
303         m_endColumn = endColumn;
304     }
305 
<span class="line-modified">306     const String&amp; sourceURLDirective() const { return m_sourceURLDirective; }</span>
<span class="line-modified">307     const String&amp; sourceMappingURLDirective() const { return m_sourceMappingURLDirective; }</span>
<span class="line-modified">308     void setSourceURLDirective(const String&amp; sourceURL) { m_sourceURLDirective = sourceURL; }</span>
<span class="line-modified">309     void setSourceMappingURLDirective(const String&amp; sourceMappingURL) { m_sourceMappingURLDirective = sourceMappingURL; }</span>
310 
311     CodeFeatures codeFeatures() const { return m_features; }
312     bool hasCapturedVariables() const { return m_hasCapturedVariables; }
313     unsigned lineCount() const { return m_lineCount; }
314     ALWAYS_INLINE unsigned startColumn() const { return 0; }
315     unsigned endColumn() const { return m_endColumn; }
316 
<span class="line-modified">317     void addOpProfileControlFlowBytecodeOffset(InstructionStream::Offset offset)</span>
<span class="line-removed">318     {</span>
<span class="line-removed">319         createRareDataIfNecessary();</span>
<span class="line-removed">320         m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets.append(offset);</span>
<span class="line-removed">321     }</span>
<span class="line-removed">322     const Vector&lt;InstructionStream::Offset&gt;&amp; opProfileControlFlowBytecodeOffsets() const</span>
323     {
324         ASSERT(m_rareData);
325         return m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets;
326     }
327     bool hasOpProfileControlFlowBytecodeOffsets() const
328     {
329         return m_rareData &amp;&amp; !m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets.isEmpty();
330     }
331 
332     void dumpExpressionRangeInfo(); // For debugging purpose only.
333 
334     bool wasCompiledWithDebuggingOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::Debugger); }
335     bool wasCompiledWithTypeProfilerOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::TypeProfiler); }
336     bool wasCompiledWithControlFlowProfilerOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::ControlFlowProfiler); }
337     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode() const { return m_codeGenerationMode; }
338 
339     TriState didOptimize() const { return static_cast&lt;TriState&gt;(m_didOptimize); }
340     void setDidOptimize(TriState didOptimize) { m_didOptimize = static_cast&lt;unsigned&gt;(didOptimize); }
341 
342     static constexpr unsigned maxAge = 7;
343 
344     unsigned age() const { return m_age; }
345     void resetAge() { m_age = 0; }
346 







347     void dump(PrintStream&amp;) const;
348 
349     BytecodeLivenessAnalysis&amp; livenessAnalysis(CodeBlock* codeBlock)
350     {
351         if (m_liveness)
352             return *m_liveness;
353         return livenessAnalysisSlow(codeBlock);
354     }
355 
356 #if ENABLE(DFG_JIT)
357     bool hasExitSite(const ConcurrentJSLocker&amp; locker, const DFG::FrequentExitSite&amp; site) const
358     {
359         return m_exitProfile.hasExitSite(locker, site);
360     }
361 
362     bool hasExitSite(const DFG::FrequentExitSite&amp; site)
363     {
364         ConcurrentJSLocker locker(m_lock);
365         return hasExitSite(locker, site);
366     }
</pre>
<hr />
<pre>
374     {
375         return m_metadata-&gt;sizeInBytes();
376     }
377 
378 
379 protected:
380     UnlinkedCodeBlock(VM&amp;, Structure*, CodeType, const ExecutableInfo&amp;, OptionSet&lt;CodeGenerationMode&gt;);
381 
382     template&lt;typename CodeBlockType&gt;
383     UnlinkedCodeBlock(Decoder&amp;, Structure*, const CachedCodeBlock&lt;CodeBlockType&gt;&amp;);
384 
385     ~UnlinkedCodeBlock();
386 
387     void finishCreation(VM&amp; vm)
388     {
389         Base::finishCreation(vm);
390     }
391 
392 private:
393     friend class BytecodeRewriter;
<span class="line-modified">394     friend class BytecodeGenerator;</span>


395 
396     template&lt;typename CodeBlockType&gt;
397     friend class CachedCodeBlock;
398 
<span class="line-modified">399     void applyModification(BytecodeRewriter&amp;, InstructionStreamWriter&amp;);</span>
<span class="line-removed">400 </span>
<span class="line-removed">401     void createRareDataIfNecessary()</span>
402     {
<span class="line-modified">403         if (!m_rareData) {</span>
<span class="line-removed">404             auto locker = lockDuringMarking(*heap(), cellLock());</span>
405             m_rareData = makeUnique&lt;RareData&gt;();
<span class="line-removed">406         }</span>
407     }
408 
409     void getLineAndColumn(const ExpressionRangeInfo&amp;, unsigned&amp; line, unsigned&amp; column) const;
410     BytecodeLivenessAnalysis&amp; livenessAnalysisSlow(CodeBlock*);
411 
412 
413     VirtualRegister m_thisRegister;
414     VirtualRegister m_scopeRegister;
415 
<span class="line-removed">416     std::array&lt;unsigned, LinkTimeConstantCount&gt; m_linkTimeConstants;</span>
<span class="line-removed">417 </span>
418     unsigned m_usesEval : 1;
419     unsigned m_isStrictMode : 1;
420     unsigned m_isConstructor : 1;
421     unsigned m_hasCapturedVariables : 1;
422     unsigned m_isBuiltinFunction : 1;
423     unsigned m_superBinding : 1;
424     unsigned m_scriptMode: 1;
425     unsigned m_isArrowFunctionContext : 1;
426     unsigned m_isClassContext : 1;
427     unsigned m_hasTailCalls : 1;
428     unsigned m_constructorKind : 2;
429     unsigned m_derivedContextType : 2;
430     unsigned m_evalContextType : 2;
431     unsigned m_codeType : 2;
432     unsigned m_didOptimize : 2;
433     unsigned m_age : 3;
434     static_assert(((1U &lt;&lt; 3) - 1) &gt;= maxAge);

435 public:
436     ConcurrentJSLock m_lock;
437 private:
438     CodeFeatures m_features { 0 };
439     SourceParseMode m_parseMode;
440     OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;
441 
442     unsigned m_lineCount { 0 };
443     unsigned m_endColumn { UINT_MAX };
444 
445     int m_numVars { 0 };
446     int m_numCalleeLocals { 0 };
447     int m_numParameters { 0 };
448 
<span class="line-modified">449     String m_sourceURLDirective;</span>
<span class="line-modified">450     String m_sourceMappingURLDirective;</span>
451 
<span class="line-modified">452     Vector&lt;InstructionStream::Offset&gt; m_jumpTargets;</span>
453     Ref&lt;UnlinkedMetadataTable&gt; m_metadata;
454     std::unique_ptr&lt;InstructionStream&gt; m_instructions;
455     std::unique_ptr&lt;BytecodeLivenessAnalysis&gt; m_liveness;
456 
457 
458 #if ENABLE(DFG_JIT)
459     DFG::ExitProfile m_exitProfile;
460 #endif
461 
<span class="line-removed">462 </span>
<span class="line-removed">463     Vector&lt;InstructionStream::Offset&gt; m_propertyAccessInstructions;</span>
<span class="line-removed">464 </span>
465     // Constant Pools
<span class="line-modified">466     Vector&lt;Identifier&gt; m_identifiers;</span>
<span class="line-modified">467     Vector&lt;WriteBarrier&lt;Unknown&gt;&gt; m_constantRegisters;</span>
<span class="line-modified">468     Vector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;</span>
<span class="line-modified">469     typedef Vector&lt;WriteBarrier&lt;UnlinkedFunctionExecutable&gt;&gt; FunctionExpressionVector;</span>
470     FunctionExpressionVector m_functionDecls;
471     FunctionExpressionVector m_functionExprs;
472 
473 public:
474     struct RareData {
475         WTF_MAKE_STRUCT_FAST_ALLOCATED;
476 
<span class="line-modified">477         Vector&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;</span>
478 
479         // Jump Tables
<span class="line-modified">480         Vector&lt;UnlinkedSimpleJumpTable&gt; m_switchJumpTables;</span>
<span class="line-modified">481         Vector&lt;UnlinkedStringJumpTable&gt; m_stringSwitchJumpTables;</span>
482 
<span class="line-modified">483         Vector&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;</span>
484 
485         struct TypeProfilerExpressionRange {
486             unsigned m_startDivot;
487             unsigned m_endDivot;
488         };
489         HashMap&lt;unsigned, TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
<span class="line-modified">490         Vector&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;</span>
<span class="line-modified">491         Vector&lt;BitVector&gt; m_bitVectors;</span>
<span class="line-modified">492         Vector&lt;ConstantIdentifierSetEntry&gt; m_constantIdentifierSets;</span>


493     };
494 
<span class="line-removed">495     void addOutOfLineJumpTarget(InstructionStream::Offset, int target);</span>
496     int outOfLineJumpOffset(InstructionStream::Offset);
497     int outOfLineJumpOffset(const InstructionStream::Ref&amp; instruction)
498     {
499         return outOfLineJumpOffset(instruction.offset());
500     }
501 
502 private:
503     using OutOfLineJumpTargets = HashMap&lt;InstructionStream::Offset, int&gt;;
504 
<span class="line-removed">505     OutOfLineJumpTargets replaceOutOfLineJumpTargets()</span>
<span class="line-removed">506     {</span>
<span class="line-removed">507         OutOfLineJumpTargets newJumpTargets;</span>
<span class="line-removed">508         std::swap(m_outOfLineJumpTargets, newJumpTargets);</span>
<span class="line-removed">509         return newJumpTargets;</span>
<span class="line-removed">510     }</span>
<span class="line-removed">511 </span>
512     OutOfLineJumpTargets m_outOfLineJumpTargets;
513     std::unique_ptr&lt;RareData&gt; m_rareData;
<span class="line-modified">514     Vector&lt;ExpressionRangeInfo&gt; m_expressionInfo;</span>
515 
516 protected:
517     static void visitChildren(JSCell*, SlotVisitor&amp;);
518     static size_t estimatedSize(JSCell*, VM&amp;);
519 
520 public:
521     DECLARE_INFO;
522 };
523 
524 }
</pre>
</td>
<td>
<hr />
<pre>
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;BytecodeConventions.h&quot;
 29 #include &quot;CodeType.h&quot;
 30 #include &quot;DFGExitProfile.h&quot;
 31 #include &quot;ExpressionRangeInfo.h&quot;
 32 #include &quot;HandlerInfo.h&quot;
 33 #include &quot;Identifier.h&quot;
 34 #include &quot;InstructionStream.h&quot;
 35 #include &quot;JSCast.h&quot;
 36 #include &quot;LockDuringMarking.h&quot;
 37 #include &quot;Opcode.h&quot;
 38 #include &quot;ParserModes.h&quot;
 39 #include &quot;RegExp.h&quot;

 40 #include &quot;UnlinkedFunctionExecutable.h&quot;
 41 #include &quot;UnlinkedMetadataTable.h&quot;
 42 #include &quot;VirtualRegister.h&quot;
 43 #include &lt;algorithm&gt;
 44 #include &lt;wtf/BitVector.h&gt;
 45 #include &lt;wtf/HashSet.h&gt;
<span class="line-added"> 46 #include &lt;wtf/RefCountedArray.h&gt;</span>
 47 #include &lt;wtf/TriState.h&gt;
 48 #include &lt;wtf/Vector.h&gt;
 49 #include &lt;wtf/text/UniquedStringImpl.h&gt;
 50 
 51 namespace JSC {
 52 

 53 class BytecodeLivenessAnalysis;
 54 class BytecodeRewriter;
 55 class CodeBlock;
 56 class Debugger;
 57 class FunctionExecutable;
 58 class ParserError;
 59 class ScriptExecutable;
 60 class SourceCode;
 61 class SourceProvider;
 62 class UnlinkedCodeBlock;
<span class="line-added"> 63 class UnlinkedCodeBlockGenerator;</span>
 64 class UnlinkedFunctionCodeBlock;
 65 class UnlinkedFunctionExecutable;
 66 struct ExecutableInfo;
<span class="line-added"> 67 enum class LinkTimeConstant : int32_t;</span>
 68 
 69 template&lt;typename CodeBlockType&gt;
 70 class CachedCodeBlock;
 71 
 72 typedef unsigned UnlinkedValueProfile;
 73 typedef unsigned UnlinkedArrayProfile;
 74 typedef unsigned UnlinkedArrayAllocationProfile;
 75 typedef unsigned UnlinkedObjectAllocationProfile;
 76 typedef unsigned UnlinkedLLIntCallLinkInfo;
 77 using ConstantIdentifierSetEntry = std::pair&lt;IdentifierSet, unsigned&gt;;
 78 
 79 struct UnlinkedStringJumpTable {
 80     struct OffsetLocation {
 81         int32_t branchOffset;
 82     };
 83 
 84     typedef HashMap&lt;RefPtr&lt;StringImpl&gt;, OffsetLocation&gt; StringOffsetTable;
 85     StringOffsetTable offsetTable;
 86 
 87     inline int32_t offsetForValue(StringImpl* value, int32_t defaultOffset)
 88     {
 89         StringOffsetTable::const_iterator end = offsetTable.end();
 90         StringOffsetTable::const_iterator loc = offsetTable.find(value);
 91         if (loc == end)
 92             return defaultOffset;
 93         return loc-&gt;value.branchOffset;
 94     }
 95 
 96 };
 97 
 98 struct UnlinkedSimpleJumpTable {
<span class="line-modified"> 99     RefCountedArray&lt;int32_t&gt; branchOffsets;</span>
100     int32_t min;
101 
102     int32_t offsetForValue(int32_t value, int32_t defaultOffset);
103     void add(int32_t key, int32_t offset)
104     {
105         if (!branchOffsets[key])
106             branchOffsets[key] = offset;
107     }
108 };
109 
110 class UnlinkedCodeBlock : public JSCell {
111 public:
112     typedef JSCell Base;
<span class="line-modified">113     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
114 
<span class="line-modified">115     static constexpr bool needsDestruction = true;</span>
<span class="line-added">116 </span>
<span class="line-added">117     template&lt;typename, SubspaceAccess&gt;</span>
<span class="line-added">118     static void subspaceFor(VM&amp;)</span>
<span class="line-added">119     {</span>
<span class="line-added">120         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">121     }</span>
122 
123     enum { CallFunction, ApplyFunction };
124 
125     bool isConstructor() const { return m_isConstructor; }
126     bool isStrictMode() const { return m_isStrictMode; }
127     bool usesEval() const { return m_usesEval; }
128     SourceParseMode parseMode() const { return m_parseMode; }
129     bool isArrowFunction() const { return isArrowFunctionParseMode(parseMode()); }
130     DerivedContextType derivedContextType() const { return static_cast&lt;DerivedContextType&gt;(m_derivedContextType); }
131     EvalContextType evalContextType() const { return static_cast&lt;EvalContextType&gt;(m_evalContextType); }
132     bool isArrowFunctionContext() const { return m_isArrowFunctionContext; }
133     bool isClassContext() const { return m_isClassContext; }
134     bool hasTailCalls() const { return m_hasTailCalls; }
135     void setHasTailCalls() { m_hasTailCalls = true; }
136     bool allowDirectEvalCache() const { return !(m_features &amp; NoEvalCacheFeature); }
137 





138     bool hasExpressionInfo() { return m_expressionInfo.size(); }
<span class="line-modified">139     const RefCountedArray&lt;ExpressionRangeInfo&gt;&amp; expressionInfo() { return m_expressionInfo; }</span>
<span class="line-added">140 </span>
<span class="line-added">141     bool hasCheckpoints() const { return m_hasCheckpoints; }</span>
<span class="line-added">142     void setHasCheckpoints() { m_hasCheckpoints = true; }</span>
143 
144     // Special registers
145     void setThisRegister(VirtualRegister thisRegister) { m_thisRegister = thisRegister; }
146     void setScopeRegister(VirtualRegister scopeRegister) { m_scopeRegister = scopeRegister; }
147 
148     // Parameter information
149     void setNumParameters(int newValue) { m_numParameters = newValue; }

150     unsigned numParameters() const { return m_numParameters; }
151 
152     // Constant Pools
153 
154     size_t numberOfIdentifiers() const { return m_identifiers.size(); }

155     const Identifier&amp; identifier(int index) const { return m_identifiers[index]; }
<span class="line-modified">156     const RefCountedArray&lt;Identifier&gt;&amp; identifiers() const { return m_identifiers; }</span>
157 
158     BitVector&amp; bitVector(size_t i) { ASSERT(m_rareData); return m_rareData-&gt;m_bitVectors[i]; }






159 
<span class="line-modified">160     const RefCountedArray&lt;WriteBarrier&lt;Unknown&gt;&gt;&amp; constantRegisters() { return m_constantRegisters; }</span>
<span class="line-modified">161     const WriteBarrier&lt;Unknown&gt;&amp; constantRegister(VirtualRegister reg) const { return m_constantRegisters[reg.toConstantIndex()]; }</span>
<span class="line-modified">162     ALWAYS_INLINE JSValue getConstant(VirtualRegister reg) const { return m_constantRegisters[reg.toConstantIndex()].get(); }</span>
<span class="line-modified">163     const RefCountedArray&lt;SourceCodeRepresentation&gt;&amp; constantsSourceCodeRepresentation() { return m_constantsSourceCodeRepresentation; }</span>











































164 
165     unsigned numberOfConstantIdentifierSets() const { return m_rareData ? m_rareData-&gt;m_constantIdentifierSets.size() : 0; }
<span class="line-modified">166     const RefCountedArray&lt;ConstantIdentifierSetEntry&gt;&amp; constantIdentifierSets() { ASSERT(m_rareData); return m_rareData-&gt;m_constantIdentifierSets; }</span>
167 
168     // Jumps
169     size_t numberOfJumpTargets() const { return m_jumpTargets.size(); }

170     unsigned jumpTarget(int index) const { return m_jumpTargets[index]; }
171     unsigned lastJumpTarget() const { return m_jumpTargets.last(); }
172 
<span class="line-modified">173     UnlinkedHandlerInfo* handlerForBytecodeIndex(BytecodeIndex, RequiredHandler = RequiredHandler::AnyHandler);</span>
174     UnlinkedHandlerInfo* handlerForIndex(unsigned, RequiredHandler = RequiredHandler::AnyHandler);
175 
176     bool isBuiltinFunction() const { return m_isBuiltinFunction; }
177 
178     ConstructorKind constructorKind() const { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
179     SuperBinding superBinding() const { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
180     JSParserScriptMode scriptMode() const { return static_cast&lt;JSParserScriptMode&gt;(m_scriptMode); }
181 



182     const InstructionStream&amp; instructions() const;
183 
184     int numCalleeLocals() const { return m_numCalleeLocals; }
185     int numVars() const { return m_numVars; }
186 
187     // Jump Tables
188 
189     size_t numberOfSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_switchJumpTables.size() : 0; }

190     UnlinkedSimpleJumpTable&amp; switchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_switchJumpTables[tableIndex]; }
191 
192     size_t numberOfStringSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_stringSwitchJumpTables.size() : 0; }

193     UnlinkedStringJumpTable&amp; stringSwitchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_stringSwitchJumpTables[tableIndex]; }
194 









195     UnlinkedFunctionExecutable* functionDecl(int index) { return m_functionDecls[index].get(); }
196     size_t numberOfFunctionDecls() { return m_functionDecls.size(); }









197     UnlinkedFunctionExecutable* functionExpr(int index) { return m_functionExprs[index].get(); }
198     size_t numberOfFunctionExprs() { return m_functionExprs.size(); }
199 
200     // Exception handling support
201     size_t numberOfExceptionHandlers() const { return m_rareData ? m_rareData-&gt;m_exceptionHandlers.size() : 0; }

202     UnlinkedHandlerInfo&amp; exceptionHandler(int index) { ASSERT(m_rareData); return m_rareData-&gt;m_exceptionHandlers[index]; }
203 
204     CodeType codeType() const { return static_cast&lt;CodeType&gt;(m_codeType); }
205 
206     VirtualRegister thisRegister() const { return m_thisRegister; }
207     VirtualRegister scopeRegister() const { return m_scopeRegister; }
208 








209     bool hasRareData() const { return m_rareData.get(); }
210 
<span class="line-modified">211     int lineNumberForBytecodeIndex(BytecodeIndex);</span>
212 
<span class="line-modified">213     void expressionRangeForBytecodeIndex(BytecodeIndex, int&amp; divot,</span>
214         int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const;
215 
216     bool typeProfilerExpressionInfoForBytecodeOffset(unsigned bytecodeOffset, unsigned&amp; startDivot, unsigned&amp; endDivot);
217 
218     void recordParse(CodeFeatures features, bool hasCapturedVariables, unsigned lineCount, unsigned endColumn)
219     {
220         m_features = features;
221         m_hasCapturedVariables = hasCapturedVariables;
222         m_lineCount = lineCount;
223         // For the UnlinkedCodeBlock, startColumn is always 0.
224         m_endColumn = endColumn;
225     }
226 
<span class="line-modified">227     StringImpl* sourceURLDirective() const { return m_sourceURLDirective.get(); }</span>
<span class="line-modified">228     StringImpl* sourceMappingURLDirective() const { return m_sourceMappingURLDirective.get(); }</span>
<span class="line-modified">229     void setSourceURLDirective(const String&amp; sourceURL) { m_sourceURLDirective = sourceURL.impl(); }</span>
<span class="line-modified">230     void setSourceMappingURLDirective(const String&amp; sourceMappingURL) { m_sourceMappingURLDirective = sourceMappingURL.impl(); }</span>
231 
232     CodeFeatures codeFeatures() const { return m_features; }
233     bool hasCapturedVariables() const { return m_hasCapturedVariables; }
234     unsigned lineCount() const { return m_lineCount; }
235     ALWAYS_INLINE unsigned startColumn() const { return 0; }
236     unsigned endColumn() const { return m_endColumn; }
237 
<span class="line-modified">238     const RefCountedArray&lt;InstructionStream::Offset&gt;&amp; opProfileControlFlowBytecodeOffsets() const</span>





239     {
240         ASSERT(m_rareData);
241         return m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets;
242     }
243     bool hasOpProfileControlFlowBytecodeOffsets() const
244     {
245         return m_rareData &amp;&amp; !m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets.isEmpty();
246     }
247 
248     void dumpExpressionRangeInfo(); // For debugging purpose only.
249 
250     bool wasCompiledWithDebuggingOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::Debugger); }
251     bool wasCompiledWithTypeProfilerOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::TypeProfiler); }
252     bool wasCompiledWithControlFlowProfilerOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::ControlFlowProfiler); }
253     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode() const { return m_codeGenerationMode; }
254 
255     TriState didOptimize() const { return static_cast&lt;TriState&gt;(m_didOptimize); }
256     void setDidOptimize(TriState didOptimize) { m_didOptimize = static_cast&lt;unsigned&gt;(didOptimize); }
257 
258     static constexpr unsigned maxAge = 7;
259 
260     unsigned age() const { return m_age; }
261     void resetAge() { m_age = 0; }
262 
<span class="line-added">263     NeedsClassFieldInitializer needsClassFieldInitializer() const</span>
<span class="line-added">264     {</span>
<span class="line-added">265         if (m_rareData)</span>
<span class="line-added">266             return static_cast&lt;NeedsClassFieldInitializer&gt;(m_rareData-&gt;m_needsClassFieldInitializer);</span>
<span class="line-added">267         return NeedsClassFieldInitializer::No;</span>
<span class="line-added">268     }</span>
<span class="line-added">269 </span>
270     void dump(PrintStream&amp;) const;
271 
272     BytecodeLivenessAnalysis&amp; livenessAnalysis(CodeBlock* codeBlock)
273     {
274         if (m_liveness)
275             return *m_liveness;
276         return livenessAnalysisSlow(codeBlock);
277     }
278 
279 #if ENABLE(DFG_JIT)
280     bool hasExitSite(const ConcurrentJSLocker&amp; locker, const DFG::FrequentExitSite&amp; site) const
281     {
282         return m_exitProfile.hasExitSite(locker, site);
283     }
284 
285     bool hasExitSite(const DFG::FrequentExitSite&amp; site)
286     {
287         ConcurrentJSLocker locker(m_lock);
288         return hasExitSite(locker, site);
289     }
</pre>
<hr />
<pre>
297     {
298         return m_metadata-&gt;sizeInBytes();
299     }
300 
301 
302 protected:
303     UnlinkedCodeBlock(VM&amp;, Structure*, CodeType, const ExecutableInfo&amp;, OptionSet&lt;CodeGenerationMode&gt;);
304 
305     template&lt;typename CodeBlockType&gt;
306     UnlinkedCodeBlock(Decoder&amp;, Structure*, const CachedCodeBlock&lt;CodeBlockType&gt;&amp;);
307 
308     ~UnlinkedCodeBlock();
309 
310     void finishCreation(VM&amp; vm)
311     {
312         Base::finishCreation(vm);
313     }
314 
315 private:
316     friend class BytecodeRewriter;
<span class="line-modified">317     friend class UnlinkedCodeBlockGenerator;</span>
<span class="line-added">318     template&lt;typename Traits&gt;</span>
<span class="line-added">319     friend class BytecodeGeneratorBase;</span>
320 
321     template&lt;typename CodeBlockType&gt;
322     friend class CachedCodeBlock;
323 
<span class="line-modified">324     void createRareDataIfNecessary(const AbstractLocker&amp;)</span>


325     {
<span class="line-modified">326         if (!m_rareData)</span>

327             m_rareData = makeUnique&lt;RareData&gt;();

328     }
329 
330     void getLineAndColumn(const ExpressionRangeInfo&amp;, unsigned&amp; line, unsigned&amp; column) const;
331     BytecodeLivenessAnalysis&amp; livenessAnalysisSlow(CodeBlock*);
332 
333 
334     VirtualRegister m_thisRegister;
335     VirtualRegister m_scopeRegister;
336 


337     unsigned m_usesEval : 1;
338     unsigned m_isStrictMode : 1;
339     unsigned m_isConstructor : 1;
340     unsigned m_hasCapturedVariables : 1;
341     unsigned m_isBuiltinFunction : 1;
342     unsigned m_superBinding : 1;
343     unsigned m_scriptMode: 1;
344     unsigned m_isArrowFunctionContext : 1;
345     unsigned m_isClassContext : 1;
346     unsigned m_hasTailCalls : 1;
347     unsigned m_constructorKind : 2;
348     unsigned m_derivedContextType : 2;
349     unsigned m_evalContextType : 2;
350     unsigned m_codeType : 2;
351     unsigned m_didOptimize : 2;
352     unsigned m_age : 3;
353     static_assert(((1U &lt;&lt; 3) - 1) &gt;= maxAge);
<span class="line-added">354     bool m_hasCheckpoints : 1;</span>
355 public:
356     ConcurrentJSLock m_lock;
357 private:
358     CodeFeatures m_features { 0 };
359     SourceParseMode m_parseMode;
360     OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;
361 
362     unsigned m_lineCount { 0 };
363     unsigned m_endColumn { UINT_MAX };
364 
365     int m_numVars { 0 };
366     int m_numCalleeLocals { 0 };
367     int m_numParameters { 0 };
368 
<span class="line-modified">369     PackedRefPtr&lt;StringImpl&gt; m_sourceURLDirective;</span>
<span class="line-modified">370     PackedRefPtr&lt;StringImpl&gt; m_sourceMappingURLDirective;</span>
371 
<span class="line-modified">372     RefCountedArray&lt;InstructionStream::Offset&gt; m_jumpTargets;</span>
373     Ref&lt;UnlinkedMetadataTable&gt; m_metadata;
374     std::unique_ptr&lt;InstructionStream&gt; m_instructions;
375     std::unique_ptr&lt;BytecodeLivenessAnalysis&gt; m_liveness;
376 
377 
378 #if ENABLE(DFG_JIT)
379     DFG::ExitProfile m_exitProfile;
380 #endif
381 



382     // Constant Pools
<span class="line-modified">383     RefCountedArray&lt;Identifier&gt; m_identifiers;</span>
<span class="line-modified">384     RefCountedArray&lt;WriteBarrier&lt;Unknown&gt;&gt; m_constantRegisters;</span>
<span class="line-modified">385     RefCountedArray&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;</span>
<span class="line-modified">386     using FunctionExpressionVector = RefCountedArray&lt;WriteBarrier&lt;UnlinkedFunctionExecutable&gt;&gt;;</span>
387     FunctionExpressionVector m_functionDecls;
388     FunctionExpressionVector m_functionExprs;
389 
390 public:
391     struct RareData {
392         WTF_MAKE_STRUCT_FAST_ALLOCATED;
393 
<span class="line-modified">394         RefCountedArray&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;</span>
395 
396         // Jump Tables
<span class="line-modified">397         RefCountedArray&lt;UnlinkedSimpleJumpTable&gt; m_switchJumpTables;</span>
<span class="line-modified">398         RefCountedArray&lt;UnlinkedStringJumpTable&gt; m_stringSwitchJumpTables;</span>
399 
<span class="line-modified">400         RefCountedArray&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;</span>
401 
402         struct TypeProfilerExpressionRange {
403             unsigned m_startDivot;
404             unsigned m_endDivot;
405         };
406         HashMap&lt;unsigned, TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
<span class="line-modified">407         RefCountedArray&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;</span>
<span class="line-modified">408         RefCountedArray&lt;BitVector&gt; m_bitVectors;</span>
<span class="line-modified">409         RefCountedArray&lt;ConstantIdentifierSetEntry&gt; m_constantIdentifierSets;</span>
<span class="line-added">410 </span>
<span class="line-added">411         unsigned m_needsClassFieldInitializer : 1;</span>
412     };
413 

414     int outOfLineJumpOffset(InstructionStream::Offset);
415     int outOfLineJumpOffset(const InstructionStream::Ref&amp; instruction)
416     {
417         return outOfLineJumpOffset(instruction.offset());
418     }
419 
420 private:
421     using OutOfLineJumpTargets = HashMap&lt;InstructionStream::Offset, int&gt;;
422 







423     OutOfLineJumpTargets m_outOfLineJumpTargets;
424     std::unique_ptr&lt;RareData&gt; m_rareData;
<span class="line-modified">425     RefCountedArray&lt;ExpressionRangeInfo&gt; m_expressionInfo;</span>
426 
427 protected:
428     static void visitChildren(JSCell*, SlotVisitor&amp;);
429     static size_t estimatedSize(JSCell*, VM&amp;);
430 
431 public:
432     DECLARE_INFO;
433 };
434 
435 }
</pre>
</td>
</tr>
</table>
<center><a href="UnlinkedCodeBlock.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedEvalCodeBlock.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
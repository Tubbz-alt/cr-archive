<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/ThreadingPrimitives.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Threading.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TinyPtrSet.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/ThreadingPrimitives.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 #pragma once
 32 
 33 #include &lt;limits.h&gt;
 34 #include &lt;wtf/FastMalloc.h&gt;
 35 #include &lt;wtf/Locker.h&gt;
 36 #include &lt;wtf/Noncopyable.h&gt;
 37 #include &lt;wtf/WallTime.h&gt;
 38 
 39 #if OS(WINDOWS)
 40 #include &lt;windows.h&gt;
 41 #endif
 42 
 43 #if USE(PTHREADS)
 44 #include &lt;pthread.h&gt;
 45 #if !defined(PTHREAD_KEYS_MAX)
 46 // PTHREAD_KEYS_MAX is not defined in bionic nor in Hurd, so explicitly define it here.
 47 #define PTHREAD_KEYS_MAX 1024
 48 #endif
 49 #endif
 50 
<span class="line-removed"> 51 #if OS(WINDOWS) &amp;&amp; CPU(X86)</span>
<span class="line-removed"> 52 #define THREAD_SPECIFIC_CALL __stdcall</span>
<span class="line-removed"> 53 #else</span>
<span class="line-removed"> 54 #define THREAD_SPECIFIC_CALL</span>
<span class="line-removed"> 55 #endif</span>
<span class="line-removed"> 56 </span>
 57 namespace WTF {
 58 
 59 using ThreadFunction = void (*)(void* argument);
 60 
 61 #if USE(PTHREADS)
 62 using PlatformThreadHandle = pthread_t;
 63 using PlatformMutex = pthread_mutex_t;
 64 using PlatformCondition = pthread_cond_t;
 65 using ThreadSpecificKey = pthread_key_t;
 66 #elif OS(WINDOWS)
 67 using ThreadIdentifier = uint32_t;
 68 using PlatformThreadHandle = HANDLE;
 69 using PlatformMutex = SRWLOCK;
 70 using PlatformCondition = CONDITION_VARIABLE;
 71 using ThreadSpecificKey = DWORD;
 72 #else
 73 #error &quot;Not supported platform&quot;
 74 #endif
 75 
 76 class Mutex final {
</pre>
<hr />
<pre>
128         CRASH();
129 }
130 
131 inline void threadSpecificKeyDelete(ThreadSpecificKey key)
132 {
133     int error = pthread_key_delete(key);
134     if (error)
135         CRASH();
136 }
137 
138 inline void threadSpecificSet(ThreadSpecificKey key, void* value)
139 {
140     pthread_setspecific(key, value);
141 }
142 
143 inline void* threadSpecificGet(ThreadSpecificKey key)
144 {
145     return pthread_getspecific(key);
146 }
147 
<span class="line-removed">148 #elif OS(WINDOWS)</span>
<span class="line-removed">149 </span>
<span class="line-removed">150 static constexpr ThreadSpecificKey InvalidThreadSpecificKey = FLS_OUT_OF_INDEXES;</span>
<span class="line-removed">151 </span>
<span class="line-removed">152 inline void threadSpecificKeyCreate(ThreadSpecificKey* key, void (THREAD_SPECIFIC_CALL *destructor)(void *))</span>
<span class="line-removed">153 {</span>
<span class="line-removed">154     DWORD flsKey = FlsAlloc(destructor);</span>
<span class="line-removed">155     if (flsKey == FLS_OUT_OF_INDEXES)</span>
<span class="line-removed">156         CRASH();</span>
<span class="line-removed">157 </span>
<span class="line-removed">158     *key = flsKey;</span>
<span class="line-removed">159 }</span>
<span class="line-removed">160 </span>
<span class="line-removed">161 inline void threadSpecificKeyDelete(ThreadSpecificKey key)</span>
<span class="line-removed">162 {</span>
<span class="line-removed">163     FlsFree(key);</span>
<span class="line-removed">164 }</span>
<span class="line-removed">165 </span>
<span class="line-removed">166 inline void threadSpecificSet(ThreadSpecificKey key, void* data)</span>
<span class="line-removed">167 {</span>
<span class="line-removed">168     FlsSetValue(key, data);</span>
<span class="line-removed">169 }</span>
<span class="line-removed">170 </span>
<span class="line-removed">171 inline void* threadSpecificGet(ThreadSpecificKey key)</span>
<span class="line-removed">172 {</span>
<span class="line-removed">173     return FlsGetValue(key);</span>
<span class="line-removed">174 }</span>
<span class="line-removed">175 </span>
176 #endif
177 
178 } // namespace WTF
179 
180 using WTF::Mutex;
181 using WTF::MutexLocker;
182 using WTF::ThreadCondition;
</pre>
</td>
<td>
<hr />
<pre>
 31 #pragma once
 32 
 33 #include &lt;limits.h&gt;
 34 #include &lt;wtf/FastMalloc.h&gt;
 35 #include &lt;wtf/Locker.h&gt;
 36 #include &lt;wtf/Noncopyable.h&gt;
 37 #include &lt;wtf/WallTime.h&gt;
 38 
 39 #if OS(WINDOWS)
 40 #include &lt;windows.h&gt;
 41 #endif
 42 
 43 #if USE(PTHREADS)
 44 #include &lt;pthread.h&gt;
 45 #if !defined(PTHREAD_KEYS_MAX)
 46 // PTHREAD_KEYS_MAX is not defined in bionic nor in Hurd, so explicitly define it here.
 47 #define PTHREAD_KEYS_MAX 1024
 48 #endif
 49 #endif
 50 






 51 namespace WTF {
 52 
 53 using ThreadFunction = void (*)(void* argument);
 54 
 55 #if USE(PTHREADS)
 56 using PlatformThreadHandle = pthread_t;
 57 using PlatformMutex = pthread_mutex_t;
 58 using PlatformCondition = pthread_cond_t;
 59 using ThreadSpecificKey = pthread_key_t;
 60 #elif OS(WINDOWS)
 61 using ThreadIdentifier = uint32_t;
 62 using PlatformThreadHandle = HANDLE;
 63 using PlatformMutex = SRWLOCK;
 64 using PlatformCondition = CONDITION_VARIABLE;
 65 using ThreadSpecificKey = DWORD;
 66 #else
 67 #error &quot;Not supported platform&quot;
 68 #endif
 69 
 70 class Mutex final {
</pre>
<hr />
<pre>
122         CRASH();
123 }
124 
125 inline void threadSpecificKeyDelete(ThreadSpecificKey key)
126 {
127     int error = pthread_key_delete(key);
128     if (error)
129         CRASH();
130 }
131 
132 inline void threadSpecificSet(ThreadSpecificKey key, void* value)
133 {
134     pthread_setspecific(key, value);
135 }
136 
137 inline void* threadSpecificGet(ThreadSpecificKey key)
138 {
139     return pthread_getspecific(key);
140 }
141 




























142 #endif
143 
144 } // namespace WTF
145 
146 using WTF::Mutex;
147 using WTF::MutexLocker;
148 using WTF::ThreadCondition;
</pre>
</td>
</tr>
</table>
<center><a href="Threading.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TinyPtrSet.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/network/ResourceResponseBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006, 2008, 2016 Apple Inc. All rights reserved.
  3  * Copyright (C) 2009 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;ResourceResponseBase.h&quot;
 29 
 30 #include &quot;CacheValidation.h&quot;
 31 #include &quot;HTTPHeaderNames.h&quot;
 32 #include &quot;HTTPParsers.h&quot;
 33 #include &quot;MIMETypeRegistry.h&quot;
 34 #include &quot;ParsedContentRange.h&quot;
 35 #include &quot;ResourceResponse.h&quot;
 36 #include &lt;wtf/MathExtras.h&gt;
 37 #include &lt;wtf/StdLibExtras.h&gt;
 38 #include &lt;wtf/text/StringView.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 bool isScriptAllowedByNosniff(const ResourceResponse&amp; response)
 43 {
 44     if (parseContentTypeOptionsHeader(response.httpHeaderField(HTTPHeaderName::XContentTypeOptions)) != ContentTypeOptionsNosniff)
 45         return true;
 46     String mimeType = extractMIMETypeFromMediaType(response.httpHeaderField(HTTPHeaderName::ContentType));
 47     return MIMETypeRegistry::isSupportedJavaScriptMIMEType(mimeType);
 48 }
 49 
 50 ResourceResponseBase::ResourceResponseBase()
 51     : m_haveParsedCacheControlHeader(false)
 52     , m_haveParsedAgeHeader(false)
 53     , m_haveParsedDateHeader(false)
 54     , m_haveParsedExpiresHeader(false)
 55     , m_haveParsedLastModifiedHeader(false)
 56     , m_haveParsedContentRangeHeader(false)
 57     , m_isRedirected(false)
 58     , m_isNull(true)
 59 {
 60 }
 61 
 62 ResourceResponseBase::ResourceResponseBase(const URL&amp; url, const String&amp; mimeType, long long expectedLength, const String&amp; textEncodingName)
 63     : m_url(url)
 64     , m_mimeType(mimeType)
 65     , m_expectedContentLength(expectedLength)
 66     , m_textEncodingName(textEncodingName)
 67     , m_certificateInfo(CertificateInfo()) // Empty but valid for synthetic responses.
 68     , m_haveParsedCacheControlHeader(false)
 69     , m_haveParsedAgeHeader(false)
 70     , m_haveParsedDateHeader(false)
 71     , m_haveParsedExpiresHeader(false)
 72     , m_haveParsedLastModifiedHeader(false)
 73     , m_haveParsedContentRangeHeader(false)
 74     , m_isRedirected(false)
 75     , m_isNull(false)
 76 {
 77 }
 78 
 79 ResourceResponseBase::CrossThreadData ResourceResponseBase::crossThreadData() const
 80 {
 81     CrossThreadData data;
 82 
 83     data.url = url().isolatedCopy();
 84     data.mimeType = mimeType().isolatedCopy();
 85     data.expectedContentLength = expectedContentLength();
 86     data.textEncodingName = textEncodingName().isolatedCopy();
 87 
 88     data.httpStatusCode = httpStatusCode();
 89     data.httpStatusText = httpStatusText().isolatedCopy();
 90     data.httpVersion = httpVersion().isolatedCopy();
 91 
 92     data.httpHeaderFields = httpHeaderFields().isolatedCopy();
 93     data.networkLoadMetrics = m_networkLoadMetrics.isolatedCopy();
 94     data.type = m_type;
 95     data.tainting = m_tainting;
 96     data.isRedirected = m_isRedirected;
 97     data.isRangeRequested = m_isRangeRequested;
 98 
 99     return data;
100 }
101 
102 ResourceResponse ResourceResponseBase::fromCrossThreadData(CrossThreadData&amp;&amp; data)
103 {
104     ResourceResponse response;
105 
106     response.setURL(data.url);
107     response.setMimeType(data.mimeType);
108     response.setExpectedContentLength(data.expectedContentLength);
109     response.setTextEncodingName(data.textEncodingName);
110 
111     response.setHTTPStatusCode(data.httpStatusCode);
112     response.setHTTPStatusText(data.httpStatusText);
113     response.setHTTPVersion(data.httpVersion);
114 
115     response.m_httpHeaderFields = WTFMove(data.httpHeaderFields);
116     response.m_networkLoadMetrics = data.networkLoadMetrics;
117     response.m_type = data.type;
118     response.m_tainting = data.tainting;
119     response.m_isRedirected = data.isRedirected;
120     response.m_isRangeRequested = data.isRangeRequested;
121 
122     return response;
123 }
124 
125 ResourceResponse ResourceResponseBase::syntheticRedirectResponse(const URL&amp; fromURL, const URL&amp; toURL)
126 {
127     ResourceResponse redirectResponse;
128     redirectResponse.setURL(fromURL);
129     redirectResponse.setHTTPStatusCode(302);
130     redirectResponse.setHTTPVersion(&quot;HTTP/1.1&quot;_s);
131     redirectResponse.setHTTPHeaderField(HTTPHeaderName::Location, toURL.string());
132     redirectResponse.setHTTPHeaderField(HTTPHeaderName::CacheControl, &quot;no-store&quot;_s);
133 
134     return redirectResponse;
135 }
136 
137 ResourceResponse ResourceResponseBase::filter(const ResourceResponse&amp; response)
138 {
139     if (response.tainting() == Tainting::Opaque) {
140         ResourceResponse opaqueResponse;
141         opaqueResponse.setTainting(Tainting::Opaque);
142         opaqueResponse.setType(Type::Opaque);
143         return opaqueResponse;
144     }
145 
146     if (response.tainting() == Tainting::Opaqueredirect) {
147         ResourceResponse opaqueResponse;
148         opaqueResponse.setTainting(Tainting::Opaqueredirect);
149         opaqueResponse.setType(Type::Opaqueredirect);
150         opaqueResponse.setURL(response.url());
151         return opaqueResponse;
152     }
153 
154     ResourceResponse filteredResponse = response;
155     // Let&#39;s initialize filteredResponse to remove some header fields.
156     filteredResponse.lazyInit(AllFields);
157 
158     if (response.tainting() == Tainting::Basic) {
159         filteredResponse.setType(Type::Basic);
160         filteredResponse.m_httpHeaderFields.remove(HTTPHeaderName::SetCookie);
161         filteredResponse.m_httpHeaderFields.remove(HTTPHeaderName::SetCookie2);
162         return filteredResponse;
163     }
164 
165     ASSERT(response.tainting() == Tainting::Cors);
166     filteredResponse.setType(Type::Cors);
167 
168     auto accessControlExposeHeaderSet = parseAccessControlAllowList&lt;ASCIICaseInsensitiveHash&gt;(response.httpHeaderField(HTTPHeaderName::AccessControlExposeHeaders));
169     filteredResponse.m_httpHeaderFields.uncommonHeaders().removeAllMatching([&amp;](auto&amp; entry) {
170         return !isCrossOriginSafeHeader(entry.key, accessControlExposeHeaderSet);
171     });
172     filteredResponse.m_httpHeaderFields.commonHeaders().removeAllMatching([&amp;](auto&amp; entry) {
173         return !isCrossOriginSafeHeader(entry.key, accessControlExposeHeaderSet);
174     });
175 
176     return filteredResponse;
177 }
178 
179 // FIXME: Name does not make it clear this is true for HTTPS!
180 bool ResourceResponseBase::isHTTP() const
181 {
182     lazyInit(CommonFieldsOnly);
183 
184     return m_url.protocolIsInHTTPFamily();
185 }
186 
187 const URL&amp; ResourceResponseBase::url() const
188 {
189     lazyInit(CommonFieldsOnly);
190 
191     return m_url;
192 }
193 
194 void ResourceResponseBase::setURL(const URL&amp; url)
195 {
196     lazyInit(CommonFieldsOnly);
197     m_isNull = false;
198 
199     m_url = url;
200 
201     // FIXME: Should invalidate or update platform response if present.
202 }
203 
204 const String&amp; ResourceResponseBase::mimeType() const
205 {
206     lazyInit(CommonFieldsOnly);
207 
208     return m_mimeType;
209 }
210 
211 void ResourceResponseBase::setMimeType(const String&amp; mimeType)
212 {
213     lazyInit(CommonFieldsOnly);
214     m_isNull = false;
215 
216     // FIXME: MIME type is determined by HTTP Content-Type header. We should update the header, so that it doesn&#39;t disagree with m_mimeType.
217     m_mimeType = mimeType;
218 
219     // FIXME: Should invalidate or update platform response if present.
220 }
221 
222 long long ResourceResponseBase::expectedContentLength() const
223 {
224     lazyInit(CommonFieldsOnly);
225 
226     return m_expectedContentLength;
227 }
228 
229 void ResourceResponseBase::setExpectedContentLength(long long expectedContentLength)
230 {
231     lazyInit(CommonFieldsOnly);
232     m_isNull = false;
233 
234     // FIXME: Content length is determined by HTTP Content-Length header. We should update the header, so that it doesn&#39;t disagree with m_expectedContentLength.
235     m_expectedContentLength = expectedContentLength;
236 
237     // FIXME: Should invalidate or update platform response if present.
238 }
239 
240 const String&amp; ResourceResponseBase::textEncodingName() const
241 {
242     lazyInit(CommonFieldsOnly);
243 
244     return m_textEncodingName;
245 }
246 
247 void ResourceResponseBase::setTextEncodingName(const String&amp; encodingName)
248 {
249     lazyInit(CommonFieldsOnly);
250     m_isNull = false;
251 
252     // FIXME: Text encoding is determined by HTTP Content-Type header. We should update the header, so that it doesn&#39;t disagree with m_textEncodingName.
253     m_textEncodingName = encodingName;
254 
255     // FIXME: Should invalidate or update platform response if present.
256 }
257 
258 void ResourceResponseBase::setType(Type type)
259 {
260     m_isNull = false;
261     m_type = type;
262 }
263 
264 void ResourceResponseBase::includeCertificateInfo(UsedLegacyTLS usedLegacyTLS) const
265 {
266     if (m_certificateInfo)
267         return;
268     m_certificateInfo = static_cast&lt;const ResourceResponse*&gt;(this)-&gt;platformCertificateInfo();
269     m_usedLegacyTLS = usedLegacyTLS;
270 }
271 
272 String ResourceResponseBase::suggestedFilename() const
273 {
274     return static_cast&lt;const ResourceResponse*&gt;(this)-&gt;platformSuggestedFilename();
275 }
276 
277 String ResourceResponseBase::sanitizeSuggestedFilename(const String&amp; suggestedFilename)
278 {
279     if (suggestedFilename.isEmpty())
280         return suggestedFilename;
281 
282     ResourceResponse response(URL({ }, &quot;http://example.com/&quot;), String(), -1, String());
283     response.setHTTPStatusCode(200);
284     String escapedSuggestedFilename = String(suggestedFilename).replace(&#39;\\&#39;, &quot;\\\\&quot;).replace(&#39;&quot;&#39;, &quot;\\\&quot;&quot;);
285     String value = makeString(&quot;attachment; filename=\&quot;&quot;, escapedSuggestedFilename, &#39;&quot;&#39;);
286     response.setHTTPHeaderField(HTTPHeaderName::ContentDisposition, value);
287     return response.suggestedFilename();
288 }
289 
290 bool ResourceResponseBase::isSuccessful() const
291 {
292     int code = httpStatusCode();
293     return code &gt;= 200 &amp;&amp; code &lt; 300;
294 }
295 
296 int ResourceResponseBase::httpStatusCode() const
297 {
298     lazyInit(CommonFieldsOnly);
299 
300     return m_httpStatusCode;
301 }
302 
303 void ResourceResponseBase::setHTTPStatusCode(int statusCode)
304 {
305     lazyInit(CommonFieldsOnly);
306 
307     m_httpStatusCode = statusCode;
308     m_isNull = false;
309 
310     // FIXME: Should invalidate or update platform response if present.
311 }
312 
313 bool ResourceResponseBase::isRedirection() const
314 {
315     return isRedirectionStatusCode(m_httpStatusCode);
316 }
317 
318 const String&amp; ResourceResponseBase::httpStatusText() const
319 {
320     lazyInit(AllFields);
321 
322     return m_httpStatusText;
323 }
324 
325 void ResourceResponseBase::setHTTPStatusText(const String&amp; statusText)
326 {
327     lazyInit(AllFields);
328 
329     m_httpStatusText = statusText;
330 
331     // FIXME: Should invalidate or update platform response if present.
332 }
333 
334 const String&amp; ResourceResponseBase::httpVersion() const
335 {
336     lazyInit(AllFields);
337 
338     return m_httpVersion;
339 }
340 
341 void ResourceResponseBase::setHTTPVersion(const String&amp; versionText)
342 {
343     lazyInit(AllFields);
344 
345     m_httpVersion = versionText;
346 
347     // FIXME: Should invalidate or update platform response if present.
348 }
349 
350 static bool isSafeRedirectionResponseHeader(HTTPHeaderName name)
351 {
352     // WebCore needs to keep location and cache related headers as it does caching.
353     // We also keep CORS/ReferrerPolicy headers until CORS checks/Referrer computation are done in NetworkProcess.
354     return name == HTTPHeaderName::Location
355         || name == HTTPHeaderName::ReferrerPolicy
356         || name == HTTPHeaderName::CacheControl
357         || name == HTTPHeaderName::Date
358         || name == HTTPHeaderName::Expires
359         || name == HTTPHeaderName::ETag
360         || name == HTTPHeaderName::LastModified
361         || name == HTTPHeaderName::Age
362         || name == HTTPHeaderName::Pragma
363         || name == HTTPHeaderName::ReferrerPolicy
364         || name == HTTPHeaderName::Refresh
365         || name == HTTPHeaderName::Vary
366         || name == HTTPHeaderName::AccessControlAllowCredentials
367         || name == HTTPHeaderName::AccessControlAllowHeaders
368         || name == HTTPHeaderName::AccessControlAllowMethods
369         || name == HTTPHeaderName::AccessControlAllowOrigin
370         || name == HTTPHeaderName::AccessControlExposeHeaders
371         || name == HTTPHeaderName::AccessControlMaxAge
372         || name == HTTPHeaderName::CrossOriginResourcePolicy
373         || name == HTTPHeaderName::TimingAllowOrigin;
374 }
375 
376 static bool isSafeCrossOriginResponseHeader(HTTPHeaderName name)
377 {
378     // All known response headers used in WebProcesses.
379     return name == HTTPHeaderName::AcceptRanges
380         || name == HTTPHeaderName::AccessControlAllowCredentials
381         || name == HTTPHeaderName::AccessControlAllowHeaders
382         || name == HTTPHeaderName::AccessControlAllowMethods
383         || name == HTTPHeaderName::AccessControlAllowOrigin
384         || name == HTTPHeaderName::AccessControlExposeHeaders
385         || name == HTTPHeaderName::AccessControlMaxAge
386         || name == HTTPHeaderName::AccessControlRequestHeaders
387         || name == HTTPHeaderName::AccessControlRequestMethod
388         || name == HTTPHeaderName::Age
389         || name == HTTPHeaderName::CacheControl
390         || name == HTTPHeaderName::ContentDisposition
391         || name == HTTPHeaderName::ContentEncoding
392         || name == HTTPHeaderName::ContentLanguage
393         || name == HTTPHeaderName::ContentLength
394         || name == HTTPHeaderName::ContentRange
395         || name == HTTPHeaderName::ContentSecurityPolicy
396         || name == HTTPHeaderName::ContentSecurityPolicyReportOnly
397         || name == HTTPHeaderName::ContentType
398         || name == HTTPHeaderName::CrossOriginResourcePolicy
399         || name == HTTPHeaderName::Date
400         || name == HTTPHeaderName::ETag
401         || name == HTTPHeaderName::Expires
402         || name == HTTPHeaderName::IcyMetaInt
403         || name == HTTPHeaderName::IcyMetadata
404         || name == HTTPHeaderName::LastEventID
405         || name == HTTPHeaderName::LastModified
406         || name == HTTPHeaderName::Link
407         || name == HTTPHeaderName::Location
408         || name == HTTPHeaderName::Pragma
409         || name == HTTPHeaderName::Range
410         || name == HTTPHeaderName::ReferrerPolicy
411         || name == HTTPHeaderName::Refresh
412         || name == HTTPHeaderName::ServerTiming
413         || name == HTTPHeaderName::SourceMap
414         || name == HTTPHeaderName::XSourceMap
415         || name == HTTPHeaderName::TimingAllowOrigin
416         || name == HTTPHeaderName::Trailer
417         || name == HTTPHeaderName::Vary
418         || name == HTTPHeaderName::XContentTypeOptions
419         || name == HTTPHeaderName::XDNSPrefetchControl
420         || name == HTTPHeaderName::XFrameOptions
421         || name == HTTPHeaderName::XWebKitCSP
422         || name == HTTPHeaderName::XWebKitCSPReportOnly
423         || name == HTTPHeaderName::XXSSProtection;
424 }
425 
426 void ResourceResponseBase::sanitizeHTTPHeaderFieldsAccordingToTainting()
427 {
428     switch (m_tainting) {
429     case ResourceResponse::Tainting::Basic:
430         return;
431     case ResourceResponse::Tainting::Cors: {
432         HTTPHeaderMap filteredHeaders;
433         for (auto&amp; header : m_httpHeaderFields.commonHeaders()) {
434             if (isSafeCrossOriginResponseHeader(header.key))
435                 filteredHeaders.add(header.key, WTFMove(header.value));
436         }
437         auto corsSafeHeaderSet = parseAccessControlAllowList&lt;ASCIICaseInsensitiveHash&gt;(httpHeaderField(HTTPHeaderName::AccessControlExposeHeaders));
438         for (auto&amp; headerName : corsSafeHeaderSet) {
439             if (!filteredHeaders.contains(headerName)) {
440                 auto value = m_httpHeaderFields.get(headerName);
441                 if (!value.isNull())
442                     filteredHeaders.add(headerName, value);
443             }
444         }
445         m_httpHeaderFields = WTFMove(filteredHeaders);
446         return;
447     }
448     case ResourceResponse::Tainting::Opaque:
449     case ResourceResponse::Tainting::Opaqueredirect: {
450         HTTPHeaderMap filteredHeaders;
451         for (auto&amp; header : m_httpHeaderFields.commonHeaders()) {
452             if (isSafeCrossOriginResponseHeader(header.key))
453                 filteredHeaders.add(header.key, WTFMove(header.value));
454         }
455         m_httpHeaderFields = WTFMove(filteredHeaders);
456         return;
457     }
458     }
459 }
460 
461 void ResourceResponseBase::sanitizeHTTPHeaderFields(SanitizationType type)
462 {
463     lazyInit(AllFields);
464 
465     m_httpHeaderFields.remove(HTTPHeaderName::SetCookie);
466     m_httpHeaderFields.remove(HTTPHeaderName::SetCookie2);
467 
468     switch (type) {
469     case SanitizationType::RemoveCookies:
470         return;
471     case SanitizationType::Redirection: {
472         auto commonHeaders = WTFMove(m_httpHeaderFields.commonHeaders());
473         for (auto&amp; header : commonHeaders) {
474             if (isSafeRedirectionResponseHeader(header.key))
475                 m_httpHeaderFields.add(header.key, WTFMove(header.value));
476         }
477         m_httpHeaderFields.uncommonHeaders().clear();
478         return;
479     }
480     case SanitizationType::CrossOriginSafe:
481         sanitizeHTTPHeaderFieldsAccordingToTainting();
482     }
483 }
484 
485 bool ResourceResponseBase::isHTTP09() const
486 {
487     lazyInit(AllFields);
488 
489     return m_httpVersion.startsWith(&quot;HTTP/0.9&quot;);
490 }
491 
492 String ResourceResponseBase::httpHeaderField(const String&amp; name) const
493 {
494     lazyInit(CommonFieldsOnly);
495 
496     // If we already have the header, just return it instead of consuming memory by grabing all headers.
497     String value = m_httpHeaderFields.get(name);
498     if (!value.isEmpty())
499         return value;
500 
501     lazyInit(AllFields);
502 
503     return m_httpHeaderFields.get(name);
504 }
505 
506 String ResourceResponseBase::httpHeaderField(HTTPHeaderName name) const
507 {
508     lazyInit(CommonFieldsOnly);
509 
510     // If we already have the header, just return it instead of consuming memory by grabing all headers.
511     String value = m_httpHeaderFields.get(name);
512     if (!value.isEmpty())
513         return value;
514 
515     lazyInit(AllFields);
516 
517     return m_httpHeaderFields.get(name);
518 }
519 
520 void ResourceResponseBase::updateHeaderParsedState(HTTPHeaderName name)
521 {
522     switch (name) {
523     case HTTPHeaderName::Age:
524         m_haveParsedAgeHeader = false;
525         break;
526 
527     case HTTPHeaderName::CacheControl:
528     case HTTPHeaderName::Pragma:
529         m_haveParsedCacheControlHeader = false;
530         break;
531 
532     case HTTPHeaderName::Date:
533         m_haveParsedDateHeader = false;
534         break;
535 
536     case HTTPHeaderName::Expires:
537         m_haveParsedExpiresHeader = false;
538         break;
539 
540     case HTTPHeaderName::LastModified:
541         m_haveParsedLastModifiedHeader = false;
542         break;
543 
544     case HTTPHeaderName::ContentRange:
545         m_haveParsedContentRangeHeader = false;
546         break;
547 
548     default:
549         break;
550     }
551 }
552 
553 void ResourceResponseBase::setHTTPHeaderField(const String&amp; name, const String&amp; value)
554 {
555     lazyInit(AllFields);
556 
557     HTTPHeaderName headerName;
558     if (findHTTPHeaderName(name, headerName))
559         updateHeaderParsedState(headerName);
560 
561     m_httpHeaderFields.set(name, value);
562 
563     // FIXME: Should invalidate or update platform response if present.
564 }
565 
566 void ResourceResponseBase::setHTTPHeaderFields(HTTPHeaderMap&amp;&amp; headerFields)
567 {
568     lazyInit(AllFields);
569 
570     m_httpHeaderFields = WTFMove(headerFields);
571 }
572 
573 void ResourceResponseBase::setHTTPHeaderField(HTTPHeaderName name, const String&amp; value)
574 {
575     lazyInit(AllFields);
576 
577     updateHeaderParsedState(name);
578 
579     m_httpHeaderFields.set(name, value);
580 
581     // FIXME: Should invalidate or update platform response if present.
582 }
583 
584 void ResourceResponseBase::addHTTPHeaderField(HTTPHeaderName name, const String&amp; value)
585 {
586     lazyInit(AllFields);
587     updateHeaderParsedState(name);
588     m_httpHeaderFields.add(name, value);
589 }
590 
591 void ResourceResponseBase::addHTTPHeaderField(const String&amp; name, const String&amp; value)
592 {
593     HTTPHeaderName headerName;
594     if (findHTTPHeaderName(name, headerName))
595         addHTTPHeaderField(headerName, value);
596     else {
597         lazyInit(AllFields);
598         m_httpHeaderFields.add(name, value);
599     }
600 }
601 
602 const HTTPHeaderMap&amp; ResourceResponseBase::httpHeaderFields() const
603 {
604     lazyInit(AllFields);
605 
606     return m_httpHeaderFields;
607 }
608 
609 void ResourceResponseBase::parseCacheControlDirectives() const
610 {
611     ASSERT(!m_haveParsedCacheControlHeader);
612 
613     lazyInit(CommonFieldsOnly);
614 
615     m_cacheControlDirectives = WebCore::parseCacheControlDirectives(m_httpHeaderFields);
616     m_haveParsedCacheControlHeader = true;
617 }
618 
619 bool ResourceResponseBase::cacheControlContainsNoCache() const
620 {
621     if (!m_haveParsedCacheControlHeader)
622         parseCacheControlDirectives();
623     return m_cacheControlDirectives.noCache;
624 }
625 
626 bool ResourceResponseBase::cacheControlContainsNoStore() const
627 {
628     if (!m_haveParsedCacheControlHeader)
629         parseCacheControlDirectives();
630     return m_cacheControlDirectives.noStore;
631 }
632 
633 bool ResourceResponseBase::cacheControlContainsMustRevalidate() const
634 {
635     if (!m_haveParsedCacheControlHeader)
636         parseCacheControlDirectives();
637     return m_cacheControlDirectives.mustRevalidate;
638 }
639 
640 bool ResourceResponseBase::cacheControlContainsImmutable() const
641 {
642     if (!m_haveParsedCacheControlHeader)
643         parseCacheControlDirectives();
644     return m_cacheControlDirectives.immutable;
645 }
646 
647 bool ResourceResponseBase::hasCacheValidatorFields() const
648 {
649     lazyInit(CommonFieldsOnly);
650 
651     return !m_httpHeaderFields.get(HTTPHeaderName::LastModified).isEmpty() || !m_httpHeaderFields.get(HTTPHeaderName::ETag).isEmpty();
652 }
653 
654 Optional&lt;Seconds&gt; ResourceResponseBase::cacheControlMaxAge() const
655 {
656     if (!m_haveParsedCacheControlHeader)
657         parseCacheControlDirectives();
658     return m_cacheControlDirectives.maxAge;
659 }
660 
661 Optional&lt;Seconds&gt; ResourceResponseBase::cacheControlStaleWhileRevalidate() const
662 {
663     if (!m_haveParsedCacheControlHeader)
664         parseCacheControlDirectives();
665     return m_cacheControlDirectives.staleWhileRevalidate;
666 }
667 
668 static Optional&lt;WallTime&gt; parseDateValueInHeader(const HTTPHeaderMap&amp; headers, HTTPHeaderName headerName)
669 {
670     String headerValue = headers.get(headerName);
671     if (headerValue.isEmpty())
672         return WTF::nullopt;
673     // This handles all date formats required by RFC2616:
674     // Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
675     // Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
676     // Sun Nov  6 08:49:37 1994       ; ANSI C&#39;s asctime() format
677     return parseHTTPDate(headerValue);
678 }
679 
680 Optional&lt;WallTime&gt; ResourceResponseBase::date() const
681 {
682     lazyInit(CommonFieldsOnly);
683 
684     if (!m_haveParsedDateHeader) {
685         m_date = parseDateValueInHeader(m_httpHeaderFields, HTTPHeaderName::Date);
686         m_haveParsedDateHeader = true;
687     }
688     return m_date;
689 }
690 
691 Optional&lt;Seconds&gt; ResourceResponseBase::age() const
692 {
693     lazyInit(CommonFieldsOnly);
694 
695     if (!m_haveParsedAgeHeader) {
696         String headerValue = m_httpHeaderFields.get(HTTPHeaderName::Age);
697         bool ok;
698         double ageDouble = headerValue.toDouble(&amp;ok);
699         if (ok)
700             m_age = Seconds { ageDouble };
701         m_haveParsedAgeHeader = true;
702     }
703     return m_age;
704 }
705 
706 Optional&lt;WallTime&gt; ResourceResponseBase::expires() const
707 {
708     lazyInit(CommonFieldsOnly);
709 
710     if (!m_haveParsedExpiresHeader) {
711         m_expires = parseDateValueInHeader(m_httpHeaderFields, HTTPHeaderName::Expires);
712         m_haveParsedExpiresHeader = true;
713     }
714     return m_expires;
715 }
716 
717 Optional&lt;WallTime&gt; ResourceResponseBase::lastModified() const
718 {
719     lazyInit(CommonFieldsOnly);
720 
721     if (!m_haveParsedLastModifiedHeader) {
722         m_lastModified = parseDateValueInHeader(m_httpHeaderFields, HTTPHeaderName::LastModified);
723 #if PLATFORM(COCOA)
724         // CFNetwork converts malformed dates into Epoch so we need to treat Epoch as
725         // an invalid value (rdar://problem/22352838).
726         const WallTime epoch = WallTime::fromRawSeconds(0);
727         if (m_lastModified &amp;&amp; m_lastModified.value() == epoch)
728             m_lastModified = WTF::nullopt;
729 #endif
730         m_haveParsedLastModifiedHeader = true;
731     }
732     return m_lastModified;
733 }
734 
735 static ParsedContentRange parseContentRangeInHeader(const HTTPHeaderMap&amp; headers)
736 {
737     String contentRangeValue = headers.get(HTTPHeaderName::ContentRange);
738     if (contentRangeValue.isEmpty())
739         return ParsedContentRange();
740 
741     return ParsedContentRange(contentRangeValue);
742 }
743 
744 const ParsedContentRange&amp; ResourceResponseBase::contentRange() const
745 {
746     lazyInit(CommonFieldsOnly);
747 
748     if (!m_haveParsedContentRangeHeader) {
749         m_contentRange = parseContentRangeInHeader(m_httpHeaderFields);
750         m_haveParsedContentRangeHeader = true;
751     }
752 
753     return m_contentRange;
754 }
755 
756 bool ResourceResponseBase::isAttachment() const
757 {
758     lazyInit(AllFields);
759 
760     auto value = m_httpHeaderFields.get(HTTPHeaderName::ContentDisposition);
761     return equalLettersIgnoringASCIICase(value.left(value.find(&#39;;&#39;)).stripWhiteSpace(), &quot;attachment&quot;);
762 }
763 
764 bool ResourceResponseBase::isAttachmentWithFilename() const
765 {
766     lazyInit(AllFields);
767 
768     String contentDisposition = m_httpHeaderFields.get(HTTPHeaderName::ContentDisposition);
769     if (contentDisposition.isNull())
770         return false;
771 
772     if (!equalLettersIgnoringASCIICase(contentDisposition.left(contentDisposition.find(&#39;;&#39;)).stripWhiteSpace(), &quot;attachment&quot;))
773         return false;
774 
775     String filename = filenameFromHTTPContentDisposition(contentDisposition);
776     return !filename.isNull();
777 }
778 
779 ResourceResponseBase::Source ResourceResponseBase::source() const
780 {
781     lazyInit(AllFields);
782 
783     return m_source;
784 }
785 
786 void ResourceResponseBase::lazyInit(InitLevel initLevel) const
787 {
788     const_cast&lt;ResourceResponse*&gt;(static_cast&lt;const ResourceResponse*&gt;(this))-&gt;platformLazyInit(initLevel);
789 }
790 
791 bool ResourceResponseBase::compare(const ResourceResponse&amp; a, const ResourceResponse&amp; b)
792 {
793     if (a.isNull() != b.isNull())
794         return false;
795     if (a.url() != b.url())
796         return false;
797     if (a.mimeType() != b.mimeType())
798         return false;
799     if (a.expectedContentLength() != b.expectedContentLength())
800         return false;
801     if (a.textEncodingName() != b.textEncodingName())
802         return false;
803     if (a.suggestedFilename() != b.suggestedFilename())
804         return false;
805     if (a.httpStatusCode() != b.httpStatusCode())
806         return false;
807     if (a.httpStatusText() != b.httpStatusText())
808         return false;
809     if (a.httpHeaderFields() != b.httpHeaderFields())
810         return false;
811     if (a.deprecatedNetworkLoadMetrics() != b.deprecatedNetworkLoadMetrics())
812         return false;
813     return ResourceResponse::platformCompare(a, b);
814 }
815 
816 }
    </pre>
  </body>
</html>
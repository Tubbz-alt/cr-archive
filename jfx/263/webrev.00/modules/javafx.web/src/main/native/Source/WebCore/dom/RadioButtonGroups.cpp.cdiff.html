<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/RadioButtonGroups.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="QualifiedName.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RadioButtonGroups.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/RadioButtonGroups.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 21,62 ***</span>
  #include &quot;config.h&quot;
  #include &quot;RadioButtonGroups.h&quot;
  
  #include &quot;HTMLInputElement.h&quot;
  #include &quot;Range.h&quot;
<span class="line-modified">! #include &lt;wtf/HashSet.h&gt;</span>
  
  namespace WebCore {
  
  class RadioButtonGroup {
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     bool isEmpty() const { return m_members.isEmpty(); }</span>
      bool isRequired() const { return m_requiredCount; }
<span class="line-modified">!     HTMLInputElement* checkedButton() const { return m_checkedButton; }</span>
      void add(HTMLInputElement&amp;);
      void updateCheckedState(HTMLInputElement&amp;);
      void requiredStateChanged(HTMLInputElement&amp;);
      void remove(HTMLInputElement&amp;);
      bool contains(HTMLInputElement&amp;) const;
<span class="line-modified">!     Vector&lt;HTMLInputElement*&gt; members() const;</span>
  
  private:
      void setNeedsStyleRecalcForAllButtons();
      void updateValidityForAllButtons();
      bool isValid() const;
      void setCheckedButton(HTMLInputElement*);
  
<span class="line-modified">!     HashSet&lt;HTMLInputElement*&gt; m_members;</span>
<span class="line-modified">!     HTMLInputElement* m_checkedButton { nullptr };</span>
      size_t m_requiredCount { 0 };
  };
  
  inline bool RadioButtonGroup::isValid() const
  {
      return !isRequired() || m_checkedButton;
  }
  
<span class="line-modified">! Vector&lt;HTMLInputElement*&gt; RadioButtonGroup::members() const</span>
  {
<span class="line-modified">!     auto members = copyToVector(m_members);</span>
<span class="line-modified">!     std::sort(members.begin(), members.end(), documentOrderComparator);</span>
<span class="line-modified">!     return members;</span>
  }
  
  void RadioButtonGroup::setCheckedButton(HTMLInputElement* button)
  {
<span class="line-modified">!     RefPtr&lt;HTMLInputElement&gt; oldCheckedButton = m_checkedButton;</span>
      if (oldCheckedButton == button)
          return;
  
<span class="line-modified">!     bool hadCheckedButton = m_checkedButton;</span>
      bool willHaveCheckedButton = button;
      if (hadCheckedButton != willHaveCheckedButton)
          setNeedsStyleRecalcForAllButtons();
  
<span class="line-modified">!     m_checkedButton = button;</span>
      if (oldCheckedButton)
          oldCheckedButton-&gt;setChecked(false);
  }
  
  void RadioButtonGroup::add(HTMLInputElement&amp; button)
<span class="line-new-header">--- 21,67 ---</span>
  #include &quot;config.h&quot;
  #include &quot;RadioButtonGroups.h&quot;
  
  #include &quot;HTMLInputElement.h&quot;
  #include &quot;Range.h&quot;
<span class="line-modified">! #include &lt;wtf/WeakHashSet.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/WeakPtr.h&gt;</span>
  
  namespace WebCore {
  
  class RadioButtonGroup {
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     bool isEmpty() const { return m_members.computesEmpty(); }</span>
      bool isRequired() const { return m_requiredCount; }
<span class="line-modified">!     RefPtr&lt;HTMLInputElement&gt; checkedButton() const { return m_checkedButton.get(); }</span>
      void add(HTMLInputElement&amp;);
      void updateCheckedState(HTMLInputElement&amp;);
      void requiredStateChanged(HTMLInputElement&amp;);
      void remove(HTMLInputElement&amp;);
      bool contains(HTMLInputElement&amp;) const;
<span class="line-modified">!     Vector&lt;Ref&lt;HTMLInputElement&gt;&gt; members() const;</span>
  
  private:
      void setNeedsStyleRecalcForAllButtons();
      void updateValidityForAllButtons();
      bool isValid() const;
      void setCheckedButton(HTMLInputElement*);
  
<span class="line-modified">!     WeakHashSet&lt;HTMLInputElement&gt; m_members;</span>
<span class="line-modified">!     WeakPtr&lt;HTMLInputElement&gt; m_checkedButton;</span>
      size_t m_requiredCount { 0 };
  };
  
  inline bool RadioButtonGroup::isValid() const
  {
      return !isRequired() || m_checkedButton;
  }
  
<span class="line-modified">! Vector&lt;Ref&lt;HTMLInputElement&gt;&gt; RadioButtonGroup::members() const</span>
  {
<span class="line-modified">!     Vector&lt;Ref&lt;HTMLInputElement&gt;&gt; sortedMembers;</span>
<span class="line-modified">!     for (auto&amp; memeber : m_members)</span>
<span class="line-modified">!         sortedMembers.append(memeber);</span>
<span class="line-added">+     std::sort(sortedMembers.begin(), sortedMembers.end(), [](auto&amp; a, auto&amp; b) {</span>
<span class="line-added">+         return documentOrderComparator(a.ptr(), b.ptr());</span>
<span class="line-added">+     });</span>
<span class="line-added">+     return sortedMembers;</span>
  }
  
  void RadioButtonGroup::setCheckedButton(HTMLInputElement* button)
  {
<span class="line-modified">!     RefPtr&lt;HTMLInputElement&gt; oldCheckedButton = m_checkedButton.get();</span>
      if (oldCheckedButton == button)
          return;
  
<span class="line-modified">!     bool hadCheckedButton = m_checkedButton.get();</span>
      bool willHaveCheckedButton = button;
      if (hadCheckedButton != willHaveCheckedButton)
          setNeedsStyleRecalcForAllButtons();
  
<span class="line-modified">!     m_checkedButton = makeWeakPtr(button);</span>
      if (oldCheckedButton)
          oldCheckedButton-&gt;setChecked(false);
  }
  
  void RadioButtonGroup::add(HTMLInputElement&amp; button)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,11 ***</span>
  }
  
  void RadioButtonGroup::updateCheckedState(HTMLInputElement&amp; button)
  {
      ASSERT(button.isRadioButton());
<span class="line-modified">!     ASSERT(m_members.contains(&amp;button));</span>
      bool wasValid = isValid();
      if (button.checked())
          setCheckedButton(&amp;button);
      else {
          if (m_checkedButton == &amp;button)
<span class="line-new-header">--- 106,11 ---</span>
  }
  
  void RadioButtonGroup::updateCheckedState(HTMLInputElement&amp; button)
  {
      ASSERT(button.isRadioButton());
<span class="line-modified">!     ASSERT(m_members.contains(button));</span>
      bool wasValid = isValid();
      if (button.checked())
          setCheckedButton(&amp;button);
      else {
          if (m_checkedButton == &amp;button)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,11 ***</span>
  }
  
  void RadioButtonGroup::requiredStateChanged(HTMLInputElement&amp; button)
  {
      ASSERT(button.isRadioButton());
<span class="line-modified">!     ASSERT(m_members.contains(&amp;button));</span>
      bool wasValid = isValid();
      if (button.isRequired())
          ++m_requiredCount;
      else {
          ASSERT(m_requiredCount);
<span class="line-new-header">--- 121,11 ---</span>
  }
  
  void RadioButtonGroup::requiredStateChanged(HTMLInputElement&amp; button)
  {
      ASSERT(button.isRadioButton());
<span class="line-modified">!     ASSERT(m_members.contains(button));</span>
      bool wasValid = isValid();
      if (button.isRequired())
          ++m_requiredCount;
      else {
          ASSERT(m_requiredCount);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,16 ***</span>
  }
  
  void RadioButtonGroup::remove(HTMLInputElement&amp; button)
  {
      ASSERT(button.isRadioButton());
<span class="line-modified">!     auto it = m_members.find(&amp;button);</span>
<span class="line-removed">-     if (it == m_members.end())</span>
          return;
  
      bool wasValid = isValid();
<span class="line-modified">!     m_members.remove(it);</span>
      if (button.isRequired()) {
          ASSERT(m_requiredCount);
          --m_requiredCount;
      }
      if (m_checkedButton) {
<span class="line-new-header">--- 136,15 ---</span>
  }
  
  void RadioButtonGroup::remove(HTMLInputElement&amp; button)
  {
      ASSERT(button.isRadioButton());
<span class="line-modified">!     if (!m_members.contains(button))</span>
          return;
  
      bool wasValid = isValid();
<span class="line-modified">!     m_members.remove(button);</span>
      if (button.isRequired()) {
          ASSERT(m_requiredCount);
          --m_requiredCount;
      }
      if (m_checkedButton) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 149,11 ***</span>
              m_checkedButton = nullptr;
              setNeedsStyleRecalcForAllButtons();
          }
      }
  
<span class="line-modified">!     if (m_members.isEmpty()) {</span>
          ASSERT(!m_requiredCount);
          ASSERT(!m_checkedButton);
      } else if (wasValid != isValid())
          updateValidityForAllButtons();
      if (!wasValid) {
<span class="line-new-header">--- 153,11 ---</span>
              m_checkedButton = nullptr;
              setNeedsStyleRecalcForAllButtons();
          }
      }
  
<span class="line-modified">!     if (m_members.computesEmpty()) {</span>
          ASSERT(!m_requiredCount);
          ASSERT(!m_checkedButton);
      } else if (wasValid != isValid())
          updateValidityForAllButtons();
      if (!wasValid) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 164,26 ***</span>
  }
  
  void RadioButtonGroup::setNeedsStyleRecalcForAllButtons()
  {
      for (auto&amp; button : m_members) {
<span class="line-modified">!         ASSERT(button-&gt;isRadioButton());</span>
<span class="line-modified">!         button-&gt;invalidateStyleForSubtree();</span>
      }
  }
  
  void RadioButtonGroup::updateValidityForAllButtons()
  {
      for (auto&amp; button : m_members) {
<span class="line-modified">!         ASSERT(button-&gt;isRadioButton());</span>
<span class="line-modified">!         button-&gt;updateValidity();</span>
      }
  }
  
  bool RadioButtonGroup::contains(HTMLInputElement&amp; button) const
  {
<span class="line-modified">!     return m_members.contains(&amp;button);</span>
  }
  
  // ----------------------------------------------------------------
  
  // Explicitly define default constructor and destructor here outside the header
<span class="line-new-header">--- 168,26 ---</span>
  }
  
  void RadioButtonGroup::setNeedsStyleRecalcForAllButtons()
  {
      for (auto&amp; button : m_members) {
<span class="line-modified">!         ASSERT(button.isRadioButton());</span>
<span class="line-modified">!         button.invalidateStyleForSubtree();</span>
      }
  }
  
  void RadioButtonGroup::updateValidityForAllButtons()
  {
      for (auto&amp; button : m_members) {
<span class="line-modified">!         ASSERT(button.isRadioButton());</span>
<span class="line-modified">!         button.updateValidity();</span>
      }
  }
  
  bool RadioButtonGroup::contains(HTMLInputElement&amp; button) const
  {
<span class="line-modified">!     return m_members.contains(button);</span>
  }
  
  // ----------------------------------------------------------------
  
  // Explicitly define default constructor and destructor here outside the header
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,110 ***</span>
  {
      ASSERT(element.isRadioButton());
      if (element.name().isEmpty())
          return;
  
<span class="line-modified">!     if (!m_nameToGroupMap)</span>
<span class="line-removed">-         m_nameToGroupMap = makeUnique&lt;NameToGroupMap&gt;();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto&amp; group = m_nameToGroupMap-&gt;add(element.name().impl(), nullptr).iterator-&gt;value;</span>
      if (!group)
          group = makeUnique&lt;RadioButtonGroup&gt;();
      group-&gt;add(element);
  }
  
<span class="line-modified">! Vector&lt;HTMLInputElement*&gt; RadioButtonGroups::groupMembers(const HTMLInputElement&amp; element) const</span>
  {
      ASSERT(element.isRadioButton());
      if (!element.isRadioButton())
          return { };
  
      auto* name = element.name().impl();
      if (!name)
          return { };
  
<span class="line-modified">!     if (!m_nameToGroupMap)</span>
<span class="line-removed">-         return { };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto* group = m_nameToGroupMap-&gt;get(name);</span>
      if (!group)
          return { };
      return group-&gt;members();
  }
  
  void RadioButtonGroups::updateCheckedState(HTMLInputElement&amp; element)
  {
      ASSERT(element.isRadioButton());
      if (element.name().isEmpty())
          return;
<span class="line-modified">!     ASSERT(m_nameToGroupMap);</span>
<span class="line-removed">-     if (!m_nameToGroupMap)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     m_nameToGroupMap-&gt;get(element.name().impl())-&gt;updateCheckedState(element);</span>
  }
  
  void RadioButtonGroups::requiredStateChanged(HTMLInputElement&amp; element)
  {
      ASSERT(element.isRadioButton());
      if (element.name().isEmpty())
          return;
<span class="line-modified">!     ASSERT(m_nameToGroupMap);</span>
<span class="line-removed">-     if (!m_nameToGroupMap)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     auto* group = m_nameToGroupMap-&gt;get(element.name().impl());</span>
      ASSERT(group);
      group-&gt;requiredStateChanged(element);
  }
  
<span class="line-modified">! HTMLInputElement* RadioButtonGroups::checkedButtonForGroup(const AtomString&amp; name) const</span>
  {
<span class="line-modified">!     if (!m_nameToGroupMap)</span>
<span class="line-modified">!         return nullptr;</span>
<span class="line-removed">-     m_nameToGroupMap-&gt;checkConsistency();</span>
<span class="line-removed">-     RadioButtonGroup* group = m_nameToGroupMap-&gt;get(name.impl());</span>
      return group ? group-&gt;checkedButton() : nullptr;
  }
  
  bool RadioButtonGroups::hasCheckedButton(const HTMLInputElement&amp; element) const
  {
      ASSERT(element.isRadioButton());
      const AtomString&amp; name = element.name();
<span class="line-modified">!     if (name.isEmpty() || !m_nameToGroupMap)</span>
          return element.checked();
<span class="line-modified">!     return m_nameToGroupMap-&gt;get(name.impl())-&gt;checkedButton();</span>
  }
  
  bool RadioButtonGroups::isInRequiredGroup(HTMLInputElement&amp; element) const
  {
      ASSERT(element.isRadioButton());
      if (element.name().isEmpty())
          return false;
<span class="line-modified">!     if (!m_nameToGroupMap)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     auto* group = m_nameToGroupMap-&gt;get(element.name().impl());</span>
      return group &amp;&amp; group-&gt;isRequired() &amp;&amp; group-&gt;contains(element);
  }
  
  void RadioButtonGroups::removeButton(HTMLInputElement&amp; element)
  {
      ASSERT(element.isRadioButton());
      if (element.name().isEmpty())
          return;
<span class="line-removed">-     if (!m_nameToGroupMap)</span>
<span class="line-removed">-         return;</span>
  
<span class="line-modified">!     m_nameToGroupMap-&gt;checkConsistency();</span>
<span class="line-modified">!     auto it = m_nameToGroupMap-&gt;find(element.name().impl());</span>
<span class="line-modified">!     if (it == m_nameToGroupMap-&gt;end())</span>
          return;
      it-&gt;value-&gt;remove(element);
<span class="line-modified">!     if (it-&gt;value-&gt;isEmpty()) {</span>
<span class="line-modified">!         // FIXME: We may skip deallocating the empty RadioButtonGroup for</span>
<span class="line-removed">-         // performance improvement. If we do so, we need to change the key type</span>
<span class="line-removed">-         // of m_nameToGroupMap from AtomStringImpl* to RefPtr&lt;AtomStringImpl&gt;.</span>
<span class="line-removed">-         m_nameToGroupMap-&gt;remove(it);</span>
<span class="line-removed">-         if (m_nameToGroupMap-&gt;isEmpty())</span>
<span class="line-removed">-             m_nameToGroupMap = nullptr;</span>
<span class="line-removed">-     }</span>
  }
  
  } // namespace
<span class="line-new-header">--- 199,89 ---</span>
  {
      ASSERT(element.isRadioButton());
      if (element.name().isEmpty())
          return;
  
<span class="line-modified">!     auto&amp; group = m_nameToGroupMap.add(element.name().impl(), nullptr).iterator-&gt;value;</span>
      if (!group)
          group = makeUnique&lt;RadioButtonGroup&gt;();
      group-&gt;add(element);
  }
  
<span class="line-modified">! Vector&lt;Ref&lt;HTMLInputElement&gt;&gt; RadioButtonGroups::groupMembers(const HTMLInputElement&amp; element) const</span>
  {
      ASSERT(element.isRadioButton());
      if (!element.isRadioButton())
          return { };
  
      auto* name = element.name().impl();
      if (!name)
          return { };
  
<span class="line-modified">!     auto* group = m_nameToGroupMap.get(name);</span>
      if (!group)
          return { };
      return group-&gt;members();
  }
  
  void RadioButtonGroups::updateCheckedState(HTMLInputElement&amp; element)
  {
      ASSERT(element.isRadioButton());
      if (element.name().isEmpty())
          return;
<span class="line-modified">!     m_nameToGroupMap.get(element.name().impl())-&gt;updateCheckedState(element);</span>
  }
  
  void RadioButtonGroups::requiredStateChanged(HTMLInputElement&amp; element)
  {
      ASSERT(element.isRadioButton());
      if (element.name().isEmpty())
          return;
<span class="line-modified">!     auto* group = m_nameToGroupMap.get(element.name().impl());</span>
      ASSERT(group);
      group-&gt;requiredStateChanged(element);
  }
  
<span class="line-modified">! RefPtr&lt;HTMLInputElement&gt; RadioButtonGroups::checkedButtonForGroup(const AtomString&amp; name) const</span>
  {
<span class="line-modified">!     m_nameToGroupMap.checkConsistency();</span>
<span class="line-modified">!     RadioButtonGroup* group = m_nameToGroupMap.get(name.impl());</span>
      return group ? group-&gt;checkedButton() : nullptr;
  }
  
  bool RadioButtonGroups::hasCheckedButton(const HTMLInputElement&amp; element) const
  {
      ASSERT(element.isRadioButton());
      const AtomString&amp; name = element.name();
<span class="line-modified">!     if (name.isEmpty())</span>
          return element.checked();
<span class="line-modified">!     auto* group = m_nameToGroupMap.get(name.impl());</span>
<span class="line-added">+     if (!group)</span>
<span class="line-added">+         return false; // FIXME: Update the radio button group before author script had a chance to run in didFinishInsertingNode().</span>
<span class="line-added">+     return group-&gt;checkedButton();</span>
  }
  
  bool RadioButtonGroups::isInRequiredGroup(HTMLInputElement&amp; element) const
  {
      ASSERT(element.isRadioButton());
      if (element.name().isEmpty())
          return false;
<span class="line-modified">!     auto* group = m_nameToGroupMap.get(element.name().impl());</span>
      return group &amp;&amp; group-&gt;isRequired() &amp;&amp; group-&gt;contains(element);
  }
  
  void RadioButtonGroups::removeButton(HTMLInputElement&amp; element)
  {
      ASSERT(element.isRadioButton());
      if (element.name().isEmpty())
          return;
  
<span class="line-modified">!     m_nameToGroupMap.checkConsistency();</span>
<span class="line-modified">!     auto it = m_nameToGroupMap.find(element.name().impl());</span>
<span class="line-modified">!     if (it == m_nameToGroupMap.end())</span>
          return;
      it-&gt;value-&gt;remove(element);
<span class="line-modified">!     if (it-&gt;value-&gt;isEmpty())</span>
<span class="line-modified">!         m_nameToGroupMap.remove(it);</span>
  }
  
  } // namespace
</pre>
<center><a href="QualifiedName.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RadioButtonGroups.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlNumberFormat.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IntlDateTimeFormatPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntlNumberFormat.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlNumberFormat.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,9 ***</span>
  /*
   * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
   * Copyright (C) 2016 Sukolsak Sakshuwong (sukolsak@gmail.com)
<span class="line-modified">!  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,9 ---</span>
  /*
   * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
   * Copyright (C) 2016 Sukolsak Sakshuwong (sukolsak@gmail.com)
<span class="line-modified">!  * Copyright (C) 2016-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,25 ***</span>
  {
      return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  }
  
  IntlNumberFormat::IntlNumberFormat(VM&amp; vm, Structure* structure)
<span class="line-modified">!     : JSDestructibleObject(vm, structure)</span>
  {
  }
  
  void IntlNumberFormat::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
  }
  
<span class="line-removed">- void IntlNumberFormat::destroy(JSCell* cell)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     static_cast&lt;IntlNumberFormat*&gt;(cell)-&gt;IntlNumberFormat::~IntlNumberFormat();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void IntlNumberFormat::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
  {
      IntlNumberFormat* thisObject = jsCast&lt;IntlNumberFormat*&gt;(cell);
      ASSERT_GC_OBJECT_INHERITS(thisObject, info());
  
<span class="line-new-header">--- 65,20 ---</span>
  {
      return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  }
  
  IntlNumberFormat::IntlNumberFormat(VM&amp; vm, Structure* structure)
<span class="line-modified">!     : Base(vm, structure)</span>
  {
  }
  
  void IntlNumberFormat::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
  }
  
  void IntlNumberFormat::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
  {
      IntlNumberFormat* thisObject = jsCast&lt;IntlNumberFormat*&gt;(cell);
      ASSERT_GC_OBJECT_INHERITS(thisObject, info());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,79 ***</span>
      if (currencyMinorUnit)
          return currencyMinorUnit-&gt;second;
      return 2;
  }
  
<span class="line-modified">! void IntlNumberFormat::initializeNumberFormat(ExecState&amp; state, JSValue locales, JSValue optionsValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 11.1.2 InitializeNumberFormat (numberFormat, locales, options) (ECMA-402)
      // https://tc39.github.io/ecma402/#sec-initializenumberformat
  
<span class="line-modified">!     auto requestedLocales = canonicalizeLocaleList(state, locales);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      JSObject* options;
      if (optionsValue.isUndefined())
<span class="line-modified">!         options = constructEmptyObject(&amp;state, state.lexicalGlobalObject()-&gt;nullPrototypeObjectStructure());</span>
      else {
<span class="line-modified">!         options = optionsValue.toObject(&amp;state);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
  
      HashMap&lt;String, String&gt; opt;
  
<span class="line-modified">!     String matcher = intlStringOption(state, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
      RETURN_IF_EXCEPTION(scope, void());
      opt.add(&quot;localeMatcher&quot;_s, matcher);
  
<span class="line-modified">!     auto&amp; availableLocales = state.jsCallee()-&gt;globalObject(vm)-&gt;intlNumberFormatAvailableLocales();</span>
<span class="line-modified">!     auto result = resolveLocale(state, availableLocales, requestedLocales, opt, relevantNumberExtensionKeys, WTF_ARRAY_LENGTH(relevantNumberExtensionKeys), IntlNFInternal::localeData);</span>
  
      m_locale = result.get(&quot;locale&quot;_s);
      if (m_locale.isEmpty()) {
<span class="line-modified">!         throwTypeError(&amp;state, scope, &quot;failed to initialize NumberFormat due to invalid locale&quot;_s);</span>
          return;
      }
  
      m_numberingSystem = result.get(&quot;nu&quot;_s);
  
<span class="line-modified">!     String styleString = intlStringOption(state, options, Identifier::fromString(vm, &quot;style&quot;), { &quot;decimal&quot;, &quot;percent&quot;, &quot;currency&quot; }, &quot;style must be either \&quot;decimal\&quot;, \&quot;percent\&quot;, or \&quot;currency\&quot;&quot;, &quot;decimal&quot;);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (styleString == &quot;decimal&quot;)
          m_style = Style::Decimal;
      else if (styleString == &quot;percent&quot;)
          m_style = Style::Percent;
      else if (styleString == &quot;currency&quot;)
          m_style = Style::Currency;
      else
          ASSERT_NOT_REACHED();
  
<span class="line-modified">!     String currency = intlStringOption(state, options, Identifier::fromString(vm, &quot;currency&quot;), { }, nullptr, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!currency.isNull()) {
          if (currency.length() != 3 || !currency.isAllSpecialCharacters&lt;isASCIIAlpha&gt;()) {
<span class="line-modified">!             throwException(&amp;state, scope, createRangeError(&amp;state, &quot;currency is not a well-formed currency code&quot;_s));</span>
              return;
          }
      }
  
      unsigned currencyDigits = 0;
      if (m_style == Style::Currency) {
          if (currency.isNull()) {
<span class="line-modified">!             throwTypeError(&amp;state, scope, &quot;currency must be a string&quot;_s);</span>
              return;
          }
  
          currency = currency.convertToASCIIUppercase();
          m_currency = currency;
          currencyDigits = computeCurrencyDigits(currency);
      }
  
<span class="line-modified">!     String currencyDisplayString = intlStringOption(state, options, Identifier::fromString(vm, &quot;currencyDisplay&quot;), { &quot;code&quot;, &quot;symbol&quot;, &quot;name&quot; }, &quot;currencyDisplay must be either \&quot;code\&quot;, \&quot;symbol\&quot;, or \&quot;name\&quot;&quot;, &quot;symbol&quot;);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (m_style == Style::Currency) {
          if (currencyDisplayString == &quot;code&quot;)
              m_currencyDisplay = CurrencyDisplay::Code;
          else if (currencyDisplayString == &quot;symbol&quot;)
<span class="line-new-header">--- 152,79 ---</span>
      if (currencyMinorUnit)
          return currencyMinorUnit-&gt;second;
      return 2;
  }
  
<span class="line-modified">! void IntlNumberFormat::initializeNumberFormat(JSGlobalObject* globalObject, JSValue locales, JSValue optionsValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 11.1.2 InitializeNumberFormat (numberFormat, locales, options) (ECMA-402)
      // https://tc39.github.io/ecma402/#sec-initializenumberformat
  
<span class="line-modified">!     auto requestedLocales = canonicalizeLocaleList(globalObject, locales);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      JSObject* options;
      if (optionsValue.isUndefined())
<span class="line-modified">!         options = constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure());</span>
      else {
<span class="line-modified">!         options = optionsValue.toObject(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
  
      HashMap&lt;String, String&gt; opt;
  
<span class="line-modified">!     String matcher = intlStringOption(globalObject, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
      RETURN_IF_EXCEPTION(scope, void());
      opt.add(&quot;localeMatcher&quot;_s, matcher);
  
<span class="line-modified">!     auto&amp; availableLocales = intlNumberFormatAvailableLocales();</span>
<span class="line-modified">!     auto result = resolveLocale(globalObject, availableLocales, requestedLocales, opt, relevantNumberExtensionKeys, WTF_ARRAY_LENGTH(relevantNumberExtensionKeys), IntlNFInternal::localeData);</span>
  
      m_locale = result.get(&quot;locale&quot;_s);
      if (m_locale.isEmpty()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;failed to initialize NumberFormat due to invalid locale&quot;_s);</span>
          return;
      }
  
      m_numberingSystem = result.get(&quot;nu&quot;_s);
  
<span class="line-modified">!     String styleString = intlStringOption(globalObject, options, Identifier::fromString(vm, &quot;style&quot;), { &quot;decimal&quot;, &quot;percent&quot;, &quot;currency&quot; }, &quot;style must be either \&quot;decimal\&quot;, \&quot;percent\&quot;, or \&quot;currency\&quot;&quot;, &quot;decimal&quot;);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (styleString == &quot;decimal&quot;)
          m_style = Style::Decimal;
      else if (styleString == &quot;percent&quot;)
          m_style = Style::Percent;
      else if (styleString == &quot;currency&quot;)
          m_style = Style::Currency;
      else
          ASSERT_NOT_REACHED();
  
<span class="line-modified">!     String currency = intlStringOption(globalObject, options, Identifier::fromString(vm, &quot;currency&quot;), { }, nullptr, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!currency.isNull()) {
          if (currency.length() != 3 || !currency.isAllSpecialCharacters&lt;isASCIIAlpha&gt;()) {
<span class="line-modified">!             throwException(globalObject, scope, createRangeError(globalObject, &quot;currency is not a well-formed currency code&quot;_s));</span>
              return;
          }
      }
  
      unsigned currencyDigits = 0;
      if (m_style == Style::Currency) {
          if (currency.isNull()) {
<span class="line-modified">!             throwTypeError(globalObject, scope, &quot;currency must be a string&quot;_s);</span>
              return;
          }
  
          currency = currency.convertToASCIIUppercase();
          m_currency = currency;
          currencyDigits = computeCurrencyDigits(currency);
      }
  
<span class="line-modified">!     String currencyDisplayString = intlStringOption(globalObject, options, Identifier::fromString(vm, &quot;currencyDisplay&quot;), { &quot;code&quot;, &quot;symbol&quot;, &quot;name&quot; }, &quot;currencyDisplay must be either \&quot;code\&quot;, \&quot;symbol\&quot;, or \&quot;name\&quot;&quot;, &quot;symbol&quot;);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (m_style == Style::Currency) {
          if (currencyDisplayString == &quot;code&quot;)
              m_currencyDisplay = CurrencyDisplay::Code;
          else if (currencyDisplayString == &quot;symbol&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 238,17 ***</span>
              m_currencyDisplay = CurrencyDisplay::Name;
          else
              ASSERT_NOT_REACHED();
      }
  
<span class="line-modified">!     unsigned minimumIntegerDigits = intlNumberOption(state, options, Identifier::fromString(vm, &quot;minimumIntegerDigits&quot;), 1, 21, 1);</span>
      RETURN_IF_EXCEPTION(scope, void());
      m_minimumIntegerDigits = minimumIntegerDigits;
  
      unsigned minimumFractionDigitsDefault = (m_style == Style::Currency) ? currencyDigits : 0;
  
<span class="line-modified">!     unsigned minimumFractionDigits = intlNumberOption(state, options, Identifier::fromString(vm, &quot;minimumFractionDigits&quot;), 0, 20, minimumFractionDigitsDefault);</span>
      RETURN_IF_EXCEPTION(scope, void());
      m_minimumFractionDigits = minimumFractionDigits;
  
      unsigned maximumFractionDigitsDefault;
      if (m_style == Style::Currency)
<span class="line-new-header">--- 233,17 ---</span>
              m_currencyDisplay = CurrencyDisplay::Name;
          else
              ASSERT_NOT_REACHED();
      }
  
<span class="line-modified">!     unsigned minimumIntegerDigits = intlNumberOption(globalObject, options, Identifier::fromString(vm, &quot;minimumIntegerDigits&quot;), 1, 21, 1);</span>
      RETURN_IF_EXCEPTION(scope, void());
      m_minimumIntegerDigits = minimumIntegerDigits;
  
      unsigned minimumFractionDigitsDefault = (m_style == Style::Currency) ? currencyDigits : 0;
  
<span class="line-modified">!     unsigned minimumFractionDigits = intlNumberOption(globalObject, options, Identifier::fromString(vm, &quot;minimumFractionDigits&quot;), 0, 20, minimumFractionDigitsDefault);</span>
      RETURN_IF_EXCEPTION(scope, void());
      m_minimumFractionDigits = minimumFractionDigits;
  
      unsigned maximumFractionDigitsDefault;
      if (m_style == Style::Currency)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,31 ***</span>
      else if (m_style == Style::Percent)
          maximumFractionDigitsDefault = minimumFractionDigits;
      else
          maximumFractionDigitsDefault = std::max(minimumFractionDigits, 3u);
  
<span class="line-modified">!     unsigned maximumFractionDigits = intlNumberOption(state, options, Identifier::fromString(vm, &quot;maximumFractionDigits&quot;), minimumFractionDigits, 20, maximumFractionDigitsDefault);</span>
      RETURN_IF_EXCEPTION(scope, void());
      m_maximumFractionDigits = maximumFractionDigits;
  
<span class="line-modified">!     JSValue minimumSignificantDigitsValue = options-&gt;get(&amp;state, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;));</span>
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!     JSValue maximumSignificantDigitsValue = options-&gt;get(&amp;state, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;));</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      if (!minimumSignificantDigitsValue.isUndefined() || !maximumSignificantDigitsValue.isUndefined()) {
<span class="line-modified">!         unsigned minimumSignificantDigits = intlDefaultNumberOption(state, minimumSignificantDigitsValue, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;), 1, 21, 1);</span>
          RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!         unsigned maximumSignificantDigits = intlDefaultNumberOption(state, maximumSignificantDigitsValue, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;), minimumSignificantDigits, 21, 21);</span>
          RETURN_IF_EXCEPTION(scope, void());
          m_minimumSignificantDigits = minimumSignificantDigits;
          m_maximumSignificantDigits = maximumSignificantDigits;
      }
  
      bool usesFallback;
<span class="line-modified">!     bool useGrouping = intlBooleanOption(state, options, Identifier::fromString(vm, &quot;useGrouping&quot;), usesFallback);</span>
      if (usesFallback)
          useGrouping = true;
      RETURN_IF_EXCEPTION(scope, void());
      m_useGrouping = useGrouping;
  
<span class="line-new-header">--- 251,31 ---</span>
      else if (m_style == Style::Percent)
          maximumFractionDigitsDefault = minimumFractionDigits;
      else
          maximumFractionDigitsDefault = std::max(minimumFractionDigits, 3u);
  
<span class="line-modified">!     unsigned maximumFractionDigits = intlNumberOption(globalObject, options, Identifier::fromString(vm, &quot;maximumFractionDigits&quot;), minimumFractionDigits, 20, maximumFractionDigitsDefault);</span>
      RETURN_IF_EXCEPTION(scope, void());
      m_maximumFractionDigits = maximumFractionDigits;
  
<span class="line-modified">!     JSValue minimumSignificantDigitsValue = options-&gt;get(globalObject, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;));</span>
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!     JSValue maximumSignificantDigitsValue = options-&gt;get(globalObject, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;));</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      if (!minimumSignificantDigitsValue.isUndefined() || !maximumSignificantDigitsValue.isUndefined()) {
<span class="line-modified">!         unsigned minimumSignificantDigits = intlDefaultNumberOption(globalObject, minimumSignificantDigitsValue, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;), 1, 21, 1);</span>
          RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!         unsigned maximumSignificantDigits = intlDefaultNumberOption(globalObject, maximumSignificantDigitsValue, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;), minimumSignificantDigits, 21, 21);</span>
          RETURN_IF_EXCEPTION(scope, void());
          m_minimumSignificantDigits = minimumSignificantDigits;
          m_maximumSignificantDigits = maximumSignificantDigits;
      }
  
      bool usesFallback;
<span class="line-modified">!     bool useGrouping = intlBooleanOption(globalObject, options, Identifier::fromString(vm, &quot;useGrouping&quot;), usesFallback);</span>
      if (usesFallback)
          useGrouping = true;
      RETURN_IF_EXCEPTION(scope, void());
      m_useGrouping = useGrouping;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 312,18 ***</span>
      }
  
      UErrorCode status = U_ZERO_ERROR;
      m_numberFormat = std::unique_ptr&lt;UNumberFormat, UNumberFormatDeleter&gt;(unum_open(style, nullptr, 0, m_locale.utf8().data(), nullptr, &amp;status));
      if (U_FAILURE(status)) {
<span class="line-modified">!         throwTypeError(&amp;state, scope, &quot;failed to initialize NumberFormat&quot;_s);</span>
          return;
      }
  
      if (m_style == Style::Currency) {
          unum_setTextAttribute(m_numberFormat.get(), UNUM_CURRENCY_CODE, StringView(m_currency).upconvertedCharacters(), m_currency.length(), &amp;status);
          if (U_FAILURE(status)) {
<span class="line-modified">!             throwTypeError(&amp;state, scope, &quot;failed to initialize NumberFormat&quot;_s);</span>
              return;
          }
      }
      if (!m_minimumSignificantDigits) {
          unum_setAttribute(m_numberFormat.get(), UNUM_MIN_INTEGER_DIGITS, m_minimumIntegerDigits);
<span class="line-new-header">--- 307,18 ---</span>
      }
  
      UErrorCode status = U_ZERO_ERROR;
      m_numberFormat = std::unique_ptr&lt;UNumberFormat, UNumberFormatDeleter&gt;(unum_open(style, nullptr, 0, m_locale.utf8().data(), nullptr, &amp;status));
      if (U_FAILURE(status)) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;failed to initialize NumberFormat&quot;_s);</span>
          return;
      }
  
      if (m_style == Style::Currency) {
          unum_setTextAttribute(m_numberFormat.get(), UNUM_CURRENCY_CODE, StringView(m_currency).upconvertedCharacters(), m_currency.length(), &amp;status);
          if (U_FAILURE(status)) {
<span class="line-modified">!             throwTypeError(globalObject, scope, &quot;failed to initialize NumberFormat&quot;_s);</span>
              return;
          }
      }
      if (!m_minimumSignificantDigits) {
          unum_setAttribute(m_numberFormat.get(), UNUM_MIN_INTEGER_DIGITS, m_minimumIntegerDigits);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,18 ***</span>
      unum_setAttribute(m_numberFormat.get(), UNUM_ROUNDING_MODE, UNUM_ROUND_HALFUP);
  
      m_initializedNumberFormat = true;
  }
  
<span class="line-modified">! JSValue IntlNumberFormat::formatNumber(ExecState&amp; state, double number)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 11.3.4 FormatNumber abstract operation (ECMA-402 2.0)
      if (!m_initializedNumberFormat)
<span class="line-modified">!         return throwTypeError(&amp;state, scope, &quot;Intl.NumberFormat.prototype.format called on value that&#39;s not an object initialized as a NumberFormat&quot;_s);</span>
  
      // Map negative zero to positive zero.
      if (!number)
          number = 0.0;
  
<span class="line-new-header">--- 333,18 ---</span>
      unum_setAttribute(m_numberFormat.get(), UNUM_ROUNDING_MODE, UNUM_ROUND_HALFUP);
  
      m_initializedNumberFormat = true;
  }
  
<span class="line-modified">! JSValue IntlNumberFormat::formatNumber(JSGlobalObject* globalObject, double number)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 11.3.4 FormatNumber abstract operation (ECMA-402 2.0)
      if (!m_initializedNumberFormat)
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;Intl.NumberFormat.prototype.format called on value that&#39;s not an object initialized as a NumberFormat&quot;_s);</span>
  
      // Map negative zero to positive zero.
      if (!number)
          number = 0.0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 360,11 ***</span>
          buffer.grow(length);
          status = U_ZERO_ERROR;
          unum_formatDouble(m_numberFormat.get(), number, buffer.data(), length, nullptr, &amp;status);
      }
      if (U_FAILURE(status))
<span class="line-modified">!         return throwException(&amp;state, scope, createError(&amp;state, &quot;Failed to format a number.&quot;_s));</span>
  
      return jsString(vm, String(buffer.data(), length));
  }
  
  ASCIILiteral IntlNumberFormat::styleString(Style style)
<span class="line-new-header">--- 355,11 ---</span>
          buffer.grow(length);
          status = U_ZERO_ERROR;
          unum_formatDouble(m_numberFormat.get(), number, buffer.data(), length, nullptr, &amp;status);
      }
      if (U_FAILURE(status))
<span class="line-modified">!         return throwException(globalObject, scope, createError(globalObject, &quot;Failed to format a number.&quot;_s));</span>
  
      return jsString(vm, String(buffer.data(), length));
  }
  
  ASCIILiteral IntlNumberFormat::styleString(Style style)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 393,13 ***</span>
      }
      ASSERT_NOT_REACHED();
      return ASCIILiteral::null();
  }
  
<span class="line-modified">! JSObject* IntlNumberFormat::resolvedOptions(ExecState&amp; state)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 11.3.5 Intl.NumberFormat.prototype.resolvedOptions() (ECMA-402 2.0)
      // The function returns a new object whose properties and attributes are set as if
      // constructed by an object literal assigning to each of the following properties the
<span class="line-new-header">--- 388,13 ---</span>
      }
      ASSERT_NOT_REACHED();
      return ASCIILiteral::null();
  }
  
<span class="line-modified">! JSObject* IntlNumberFormat::resolvedOptions(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 11.3.5 Intl.NumberFormat.prototype.resolvedOptions() (ECMA-402 2.0)
      // The function returns a new object whose properties and attributes are set as if
      // constructed by an object literal assigning to each of the following properties the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 408,15 ***</span>
      // minimumFractionDigits, maximumFractionDigits, minimumSignificantDigits,
      // maximumSignificantDigits, and useGrouping. Properties whose corresponding internal
      // slots are not present are not assigned.
  
      if (!m_initializedNumberFormat) {
<span class="line-modified">!         initializeNumberFormat(state, jsUndefined(), jsUndefined());</span>
          scope.assertNoException();
      }
  
<span class="line-modified">!     JSObject* options = constructEmptyObject(&amp;state);</span>
      options-&gt;putDirect(vm, vm.propertyNames-&gt;locale, jsString(vm, m_locale));
      options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;numberingSystem&quot;), jsString(vm, m_numberingSystem));
      options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;style&quot;), jsNontrivialString(vm, styleString(m_style)));
      if (m_style == Style::Currency) {
          options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;currency&quot;), jsNontrivialString(vm, m_currency));
<span class="line-new-header">--- 403,15 ---</span>
      // minimumFractionDigits, maximumFractionDigits, minimumSignificantDigits,
      // maximumSignificantDigits, and useGrouping. Properties whose corresponding internal
      // slots are not present are not assigned.
  
      if (!m_initializedNumberFormat) {
<span class="line-modified">!         initializeNumberFormat(globalObject, jsUndefined(), jsUndefined());</span>
          scope.assertNoException();
      }
  
<span class="line-modified">!     JSObject* options = constructEmptyObject(globalObject);</span>
      options-&gt;putDirect(vm, vm.propertyNames-&gt;locale, jsString(vm, m_locale));
      options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;numberingSystem&quot;), jsString(vm, m_numberingSystem));
      options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;style&quot;), jsNontrivialString(vm, styleString(m_style)));
      if (m_style == Style::Currency) {
          options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;currency&quot;), jsNontrivialString(vm, m_currency));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 481,37 ***</span>
          return &quot;unknown&quot;_s;
      }
      return &quot;unknown&quot;_s;
  }
  
<span class="line-modified">! JSValue IntlNumberFormat::formatToParts(ExecState&amp; exec, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // FormatNumberToParts (ECMA-402)
      // https://tc39.github.io/ecma402/#sec-formatnumbertoparts
      // https://tc39.github.io/ecma402/#sec-partitionnumberpattern
  
      if (!m_initializedNumberFormat)
<span class="line-modified">!         return throwTypeError(&amp;exec, scope, &quot;Intl.NumberFormat.prototype.formatToParts called on value that&#39;s not an object initialized as a NumberFormat&quot;_s);</span>
  
      UErrorCode status = U_ZERO_ERROR;
      auto fieldItr = std::unique_ptr&lt;UFieldPositionIterator, UFieldPositionIteratorDeleter&gt;(ufieldpositer_open(&amp;status));
      if (U_FAILURE(status))
<span class="line-modified">!         return throwTypeError(&amp;exec, scope, &quot;failed to open field position iterator&quot;_s);</span>
  
      status = U_ZERO_ERROR;
      Vector&lt;UChar, 32&gt; result(32);
      auto resultLength = unum_formatDoubleForFields(m_numberFormat.get(), value, result.data(), result.size(), fieldItr.get(), &amp;status);
      if (status == U_BUFFER_OVERFLOW_ERROR) {
          status = U_ZERO_ERROR;
          result.grow(resultLength);
          unum_formatDoubleForFields(m_numberFormat.get(), value, result.data(), resultLength, fieldItr.get(), &amp;status);
      }
      if (U_FAILURE(status))
<span class="line-modified">!         return throwTypeError(&amp;exec, scope, &quot;failed to format a number.&quot;_s);</span>
  
      int32_t literalFieldType = -1;
      auto literalField = IntlNumberFormatField(literalFieldType, resultLength);
      Vector&lt;IntlNumberFormatField&gt; fields(resultLength, literalField);
      int32_t beginIndex = 0;
<span class="line-new-header">--- 476,37 ---</span>
          return &quot;unknown&quot;_s;
      }
      return &quot;unknown&quot;_s;
  }
  
<span class="line-modified">! JSValue IntlNumberFormat::formatToParts(JSGlobalObject* globalObject, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // FormatNumberToParts (ECMA-402)
      // https://tc39.github.io/ecma402/#sec-formatnumbertoparts
      // https://tc39.github.io/ecma402/#sec-partitionnumberpattern
  
      if (!m_initializedNumberFormat)
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;Intl.NumberFormat.prototype.formatToParts called on value that&#39;s not an object initialized as a NumberFormat&quot;_s);</span>
  
      UErrorCode status = U_ZERO_ERROR;
      auto fieldItr = std::unique_ptr&lt;UFieldPositionIterator, UFieldPositionIteratorDeleter&gt;(ufieldpositer_open(&amp;status));
      if (U_FAILURE(status))
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;failed to open field position iterator&quot;_s);</span>
  
      status = U_ZERO_ERROR;
      Vector&lt;UChar, 32&gt; result(32);
      auto resultLength = unum_formatDoubleForFields(m_numberFormat.get(), value, result.data(), result.size(), fieldItr.get(), &amp;status);
      if (status == U_BUFFER_OVERFLOW_ERROR) {
          status = U_ZERO_ERROR;
          result.grow(resultLength);
          unum_formatDoubleForFields(m_numberFormat.get(), value, result.data(), resultLength, fieldItr.get(), &amp;status);
      }
      if (U_FAILURE(status))
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;failed to format a number.&quot;_s);</span>
  
      int32_t literalFieldType = -1;
      auto literalField = IntlNumberFormatField(literalFieldType, resultLength);
      Vector&lt;IntlNumberFormatField&gt; fields(resultLength, literalField);
      int32_t beginIndex = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 525,32 ***</span>
                  fields[i] = IntlNumberFormatField(fieldType, size);
          }
          fieldType = ufieldpositer_next(fieldItr.get(), &amp;beginIndex, &amp;endIndex);
      }
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec.jsCallee()-&gt;globalObject(vm);</span>
      JSArray* parts = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);
      if (!parts)
<span class="line-modified">!         return throwOutOfMemoryError(&amp;exec, scope);</span>
      unsigned index = 0;
  
      auto resultString = String(result.data(), resultLength);
      auto typePropertyName = Identifier::fromString(vm, &quot;type&quot;);
<span class="line-modified">!     auto literalString = jsString(vm, &quot;literal&quot;_s);</span>
  
      int32_t currentIndex = 0;
      while (currentIndex &lt; resultLength) {
          auto startIndex = currentIndex;
          auto fieldType = fields[currentIndex].type;
          while (currentIndex &lt; resultLength &amp;&amp; fields[currentIndex].type == fieldType)
              ++currentIndex;
          auto partType = fieldType == literalFieldType ? literalString : jsString(vm, partTypeString(UNumberFormatFields(fieldType), value));
          auto partValue = jsSubstring(vm, resultString, startIndex, currentIndex - startIndex);
<span class="line-modified">!         JSObject* part = constructEmptyObject(&amp;exec);</span>
          part-&gt;putDirect(vm, typePropertyName, partType);
          part-&gt;putDirect(vm, vm.propertyNames-&gt;value, partValue);
<span class="line-modified">!         parts-&gt;putDirectIndex(&amp;exec, index++, part);</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
  
      return parts;
  }
<span class="line-new-header">--- 520,31 ---</span>
                  fields[i] = IntlNumberFormatField(fieldType, size);
          }
          fieldType = ufieldpositer_next(fieldItr.get(), &amp;beginIndex, &amp;endIndex);
      }
  
      JSArray* parts = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);
      if (!parts)
<span class="line-modified">!         return throwOutOfMemoryError(globalObject, scope);</span>
      unsigned index = 0;
  
      auto resultString = String(result.data(), resultLength);
      auto typePropertyName = Identifier::fromString(vm, &quot;type&quot;);
<span class="line-modified">!     auto literalString = jsNontrivialString(vm, &quot;literal&quot;_s);</span>
  
      int32_t currentIndex = 0;
      while (currentIndex &lt; resultLength) {
          auto startIndex = currentIndex;
          auto fieldType = fields[currentIndex].type;
          while (currentIndex &lt; resultLength &amp;&amp; fields[currentIndex].type == fieldType)
              ++currentIndex;
          auto partType = fieldType == literalFieldType ? literalString : jsString(vm, partTypeString(UNumberFormatFields(fieldType), value));
          auto partValue = jsSubstring(vm, resultString, startIndex, currentIndex - startIndex);
<span class="line-modified">!         JSObject* part = constructEmptyObject(globalObject);</span>
          part-&gt;putDirect(vm, typePropertyName, partType);
          part-&gt;putDirect(vm, vm.propertyNames-&gt;value, partValue);
<span class="line-modified">!         parts-&gt;putDirectIndex(globalObject, index++, part);</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
  
      return parts;
  }
</pre>
<center><a href="IntlDateTimeFormatPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntlNumberFormat.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
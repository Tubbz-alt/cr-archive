<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/GetterSetterAccessCase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GetByIdVariant.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GetterSetterAccessCase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/GetterSetterAccessCase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;GetterSetterAccessCase.h&quot;
 28 
 29 #if ENABLE(JIT)
 30 
 31 #include &quot;AccessCaseSnippetParams.h&quot;
 32 #include &quot;DOMJITCallDOMGetterSnippet.h&quot;
 33 #include &quot;DOMJITGetterSetter.h&quot;
 34 #include &quot;HeapInlines.h&quot;
 35 #include &quot;JSCJSValueInlines.h&quot;
 36 #include &quot;PolymorphicAccess.h&quot;
 37 #include &quot;StructureStubInfo.h&quot;
 38 
 39 namespace JSC {
 40 
 41 namespace GetterSetterAccessCaseInternal {
<span class="line-modified"> 42 static const bool verbose = false;</span>
 43 }
 44 
<span class="line-modified"> 45 GetterSetterAccessCase::GetterSetterAccessCase(VM&amp; vm, JSCell* owner, AccessType accessType, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet, bool viaProxy, WatchpointSet* additionalSet, JSObject* customSlotBase, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)</span>
<span class="line-modified"> 46     : Base(vm, owner, accessType, offset, structure, conditionSet, viaProxy, additionalSet, WTFMove(prototypeAccessChain))</span>
 47 {
 48     m_customSlotBase.setMayBeNull(vm, owner, customSlotBase);
 49 }
 50 
<span class="line-removed"> 51 </span>
 52 std::unique_ptr&lt;AccessCase&gt; GetterSetterAccessCase::create(
<span class="line-modified"> 53     VM&amp; vm, JSCell* owner, AccessType type, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet,</span>
 54     bool viaProxy, WatchpointSet* additionalSet, FunctionPtr&lt;OperationPtrTag&gt; customGetter, JSObject* customSlotBase,
 55     Optional&lt;DOMAttributeAnnotation&gt; domAttribute, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)
 56 {
 57     switch (type) {
 58     case Getter:
 59     case CustomAccessorGetter:
 60     case CustomValueGetter:
 61         break;
 62     default:
 63         ASSERT_NOT_REACHED();
 64     };
 65 
<span class="line-modified"> 66     std::unique_ptr&lt;GetterSetterAccessCase&gt; result(new GetterSetterAccessCase(vm, owner, type, offset, structure, conditionSet, viaProxy, additionalSet, customSlotBase, WTFMove(prototypeAccessChain)));</span>
 67     result-&gt;m_domAttribute = domAttribute;
 68     result-&gt;m_customAccessor = customGetter ? FunctionPtr&lt;OperationPtrTag&gt;(customGetter) : nullptr;
 69     return result;
 70 }
 71 
<span class="line-modified"> 72 std::unique_ptr&lt;AccessCase&gt; GetterSetterAccessCase::create(VM&amp; vm, JSCell* owner, AccessType type, Structure* structure, PropertyOffset offset,</span>
 73     const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain, FunctionPtr&lt;OperationPtrTag&gt; customSetter,
 74     JSObject* customSlotBase)
 75 {
 76     ASSERT(type == Setter || type == CustomValueSetter || type == CustomAccessorSetter);
<span class="line-modified"> 77     std::unique_ptr&lt;GetterSetterAccessCase&gt; result(new GetterSetterAccessCase(vm, owner, type, offset, structure, conditionSet, false, nullptr, customSlotBase, WTFMove(prototypeAccessChain)));</span>
 78     result-&gt;m_customAccessor = customSetter ? FunctionPtr&lt;OperationPtrTag&gt;(customSetter) : nullptr;
 79     return result;
 80 }
 81 
 82 
 83 GetterSetterAccessCase::~GetterSetterAccessCase()
 84 {
 85 }
 86 
 87 
 88 GetterSetterAccessCase::GetterSetterAccessCase(const GetterSetterAccessCase&amp; other)
 89     : Base(other)
 90     , m_customSlotBase(other.m_customSlotBase)
 91 {
 92     m_customAccessor = other.m_customAccessor;
 93     m_domAttribute = other.m_domAttribute;
 94 }
 95 
 96 std::unique_ptr&lt;AccessCase&gt; GetterSetterAccessCase::clone() const
 97 {
</pre>
<hr />
<pre>
121     if (callLinkInfo())
122         out.print(comma, &quot;callLinkInfo = &quot;, RawPointer(callLinkInfo()));
123     out.print(comma, &quot;customAccessor = &quot;, RawPointer(m_customAccessor.executableAddress()));
124 }
125 
126 void GetterSetterAccessCase::emitDOMJITGetter(AccessGenerationState&amp; state, const DOMJIT::GetterSetter* domJIT, GPRReg baseForGetGPR)
127 {
128     CCallHelpers&amp; jit = *state.jit;
129     StructureStubInfo&amp; stubInfo = *state.stubInfo;
130     JSValueRegs valueRegs = state.valueRegs;
131     GPRReg baseGPR = state.baseGPR;
132     GPRReg scratchGPR = state.scratchGPR;
133 
134     // We construct the environment that can execute the DOMJIT::Snippet here.
135     Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = domJIT-&gt;compiler()();
136 
137     Vector&lt;GPRReg&gt; gpScratch;
138     Vector&lt;FPRReg&gt; fpScratch;
139     Vector&lt;SnippetParams::Value&gt; regs;
140 
<span class="line-modified">141     ScratchRegisterAllocator allocator(stubInfo.patch.usedRegisters);</span>
<span class="line-modified">142     allocator.lock(baseGPR);</span>
<span class="line-removed">143 #if USE(JSVALUE32_64)</span>
<span class="line-removed">144     allocator.lock(stubInfo.patch.baseTagGPR);</span>
<span class="line-removed">145 #endif</span>
146     allocator.lock(valueRegs);
147     allocator.lock(scratchGPR);
148 
149     GPRReg paramBaseGPR = InvalidGPRReg;
150     GPRReg paramGlobalObjectGPR = InvalidGPRReg;
151     JSValueRegs paramValueRegs = valueRegs;
152     GPRReg remainingScratchGPR = InvalidGPRReg;
153 
154     // valueRegs and baseForGetGPR may be the same. For example, in Baseline JIT, we pass the same regT0 for baseGPR and valueRegs.
155     // In FTL, there is no constraint that the baseForGetGPR interferes with the result. To make implementation simple in
156     // Snippet, Snippet assumes that result registers always early interfere with input registers, in this case,
157     // baseForGetGPR. So we move baseForGetGPR to the other register if baseForGetGPR == valueRegs.
158     if (baseForGetGPR != valueRegs.payloadGPR()) {
159         paramBaseGPR = baseForGetGPR;
160         if (!snippet-&gt;requireGlobalObject)
161             remainingScratchGPR = scratchGPR;
162         else
163             paramGlobalObjectGPR = scratchGPR;
164     } else {
165         jit.move(valueRegs.payloadGPR(), scratchGPR);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2017-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;GetterSetterAccessCase.h&quot;
 28 
 29 #if ENABLE(JIT)
 30 
 31 #include &quot;AccessCaseSnippetParams.h&quot;
 32 #include &quot;DOMJITCallDOMGetterSnippet.h&quot;
 33 #include &quot;DOMJITGetterSetter.h&quot;
 34 #include &quot;HeapInlines.h&quot;
 35 #include &quot;JSCJSValueInlines.h&quot;
 36 #include &quot;PolymorphicAccess.h&quot;
 37 #include &quot;StructureStubInfo.h&quot;
 38 
 39 namespace JSC {
 40 
 41 namespace GetterSetterAccessCaseInternal {
<span class="line-modified"> 42 static constexpr bool verbose = false;</span>
 43 }
 44 
<span class="line-modified"> 45 GetterSetterAccessCase::GetterSetterAccessCase(VM&amp; vm, JSCell* owner, AccessType accessType, CacheableIdentifier identifier, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet, bool viaProxy, WatchpointSet* additionalSet, JSObject* customSlotBase, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)</span>
<span class="line-modified"> 46     : Base(vm, owner, accessType, identifier, offset, structure, conditionSet, viaProxy, additionalSet, WTFMove(prototypeAccessChain))</span>
 47 {
 48     m_customSlotBase.setMayBeNull(vm, owner, customSlotBase);
 49 }
 50 

 51 std::unique_ptr&lt;AccessCase&gt; GetterSetterAccessCase::create(
<span class="line-modified"> 52     VM&amp; vm, JSCell* owner, AccessType type, CacheableIdentifier identifier, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet,</span>
 53     bool viaProxy, WatchpointSet* additionalSet, FunctionPtr&lt;OperationPtrTag&gt; customGetter, JSObject* customSlotBase,
 54     Optional&lt;DOMAttributeAnnotation&gt; domAttribute, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)
 55 {
 56     switch (type) {
 57     case Getter:
 58     case CustomAccessorGetter:
 59     case CustomValueGetter:
 60         break;
 61     default:
 62         ASSERT_NOT_REACHED();
 63     };
 64 
<span class="line-modified"> 65     std::unique_ptr&lt;GetterSetterAccessCase&gt; result(new GetterSetterAccessCase(vm, owner, type, identifier, offset, structure, conditionSet, viaProxy, additionalSet, customSlotBase, WTFMove(prototypeAccessChain)));</span>
 66     result-&gt;m_domAttribute = domAttribute;
 67     result-&gt;m_customAccessor = customGetter ? FunctionPtr&lt;OperationPtrTag&gt;(customGetter) : nullptr;
 68     return result;
 69 }
 70 
<span class="line-modified"> 71 std::unique_ptr&lt;AccessCase&gt; GetterSetterAccessCase::create(VM&amp; vm, JSCell* owner, AccessType type, Structure* structure, CacheableIdentifier identifier, PropertyOffset offset,</span>
 72     const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain, FunctionPtr&lt;OperationPtrTag&gt; customSetter,
 73     JSObject* customSlotBase)
 74 {
 75     ASSERT(type == Setter || type == CustomValueSetter || type == CustomAccessorSetter);
<span class="line-modified"> 76     std::unique_ptr&lt;GetterSetterAccessCase&gt; result(new GetterSetterAccessCase(vm, owner, type, identifier, offset, structure, conditionSet, false, nullptr, customSlotBase, WTFMove(prototypeAccessChain)));</span>
 77     result-&gt;m_customAccessor = customSetter ? FunctionPtr&lt;OperationPtrTag&gt;(customSetter) : nullptr;
 78     return result;
 79 }
 80 
 81 
 82 GetterSetterAccessCase::~GetterSetterAccessCase()
 83 {
 84 }
 85 
 86 
 87 GetterSetterAccessCase::GetterSetterAccessCase(const GetterSetterAccessCase&amp; other)
 88     : Base(other)
 89     , m_customSlotBase(other.m_customSlotBase)
 90 {
 91     m_customAccessor = other.m_customAccessor;
 92     m_domAttribute = other.m_domAttribute;
 93 }
 94 
 95 std::unique_ptr&lt;AccessCase&gt; GetterSetterAccessCase::clone() const
 96 {
</pre>
<hr />
<pre>
120     if (callLinkInfo())
121         out.print(comma, &quot;callLinkInfo = &quot;, RawPointer(callLinkInfo()));
122     out.print(comma, &quot;customAccessor = &quot;, RawPointer(m_customAccessor.executableAddress()));
123 }
124 
125 void GetterSetterAccessCase::emitDOMJITGetter(AccessGenerationState&amp; state, const DOMJIT::GetterSetter* domJIT, GPRReg baseForGetGPR)
126 {
127     CCallHelpers&amp; jit = *state.jit;
128     StructureStubInfo&amp; stubInfo = *state.stubInfo;
129     JSValueRegs valueRegs = state.valueRegs;
130     GPRReg baseGPR = state.baseGPR;
131     GPRReg scratchGPR = state.scratchGPR;
132 
133     // We construct the environment that can execute the DOMJIT::Snippet here.
134     Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = domJIT-&gt;compiler()();
135 
136     Vector&lt;GPRReg&gt; gpScratch;
137     Vector&lt;FPRReg&gt; fpScratch;
138     Vector&lt;SnippetParams::Value&gt; regs;
139 
<span class="line-modified">140     ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-modified">141     allocator.lock(stubInfo.baseRegs());</span>



142     allocator.lock(valueRegs);
143     allocator.lock(scratchGPR);
144 
145     GPRReg paramBaseGPR = InvalidGPRReg;
146     GPRReg paramGlobalObjectGPR = InvalidGPRReg;
147     JSValueRegs paramValueRegs = valueRegs;
148     GPRReg remainingScratchGPR = InvalidGPRReg;
149 
150     // valueRegs and baseForGetGPR may be the same. For example, in Baseline JIT, we pass the same regT0 for baseGPR and valueRegs.
151     // In FTL, there is no constraint that the baseForGetGPR interferes with the result. To make implementation simple in
152     // Snippet, Snippet assumes that result registers always early interfere with input registers, in this case,
153     // baseForGetGPR. So we move baseForGetGPR to the other register if baseForGetGPR == valueRegs.
154     if (baseForGetGPR != valueRegs.payloadGPR()) {
155         paramBaseGPR = baseForGetGPR;
156         if (!snippet-&gt;requireGlobalObject)
157             remainingScratchGPR = scratchGPR;
158         else
159             paramGlobalObjectGPR = scratchGPR;
160     } else {
161         jit.move(valueRegs.payloadGPR(), scratchGPR);
</pre>
</td>
</tr>
</table>
<center><a href="GetByIdVariant.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GetterSetterAccessCase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
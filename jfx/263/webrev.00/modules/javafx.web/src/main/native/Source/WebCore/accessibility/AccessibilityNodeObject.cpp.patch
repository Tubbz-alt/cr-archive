diff a/modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityNodeObject.cpp b/modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityNodeObject.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityNodeObject.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityNodeObject.cpp
@@ -104,14 +104,14 @@
 Ref<AccessibilityNodeObject> AccessibilityNodeObject::create(Node* node)
 {
     return adoptRef(*new AccessibilityNodeObject(node));
 }
 
-void AccessibilityNodeObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)
+void AccessibilityNodeObject::detachRemoteParts(AccessibilityDetachmentType detachmentType)
 {
     // AccessibilityObject calls clearChildren.
-    AccessibilityObject::detach(detachmentType, cache);
+    AccessibilityObject::detachRemoteParts(detachmentType);
     m_node = nullptr;
 }
 
 void AccessibilityNodeObject::childrenChanged()
 {
@@ -910,11 +910,11 @@
 {
     AccessibilityRole role = roleValue();
     return role == AccessibilityRole::Group || role == AccessibilityRole::TextGroup || role == AccessibilityRole::ApplicationGroup || role == AccessibilityRole::ApplicationTextGroup;
 }
 
-AccessibilityObject* AccessibilityNodeObject::selectedRadioButton()
+AXCoreObject* AccessibilityNodeObject::selectedRadioButton()
 {
     if (!isRadioGroup())
         return nullptr;
 
     // Find the child radio button that is selected (ie. the intValue == 1).
@@ -923,18 +923,18 @@
             return child.get();
     }
     return nullptr;
 }
 
-AccessibilityObject* AccessibilityNodeObject::selectedTabItem()
+AXCoreObject* AccessibilityNodeObject::selectedTabItem()
 {
     if (!isTabList())
         return nullptr;
 
     // FIXME: Is this valid? ARIA tab items support aria-selected; not aria-checked.
     // Find the child tab item that is selected (ie. the intValue == 1).
-    AccessibilityObject::AccessibilityChildrenVector tabs;
+    AXCoreObject::AccessibilityChildrenVector tabs;
     tabChildren(tabs);
 
     for (const auto& child : children()) {
         if (child->isTabItem() && (child->isChecked() || child->isSelected()))
             return child.get();
@@ -1102,11 +1102,11 @@
     float step = stepValueForRange();
     float value = valueForRange();
 
     value += increase ? step : -step;
 
-    setValue(String::numberToStringFixedPrecision(value));
+    setValue(String::number(value));
 
     auto objectCache = axObjectCache();
     if (objectCache)
         objectCache->postNotification(node(), AXObjectCache::AXValueChanged);
 }
@@ -1120,11 +1120,11 @@
     // Make sure the specified percent will cause a change of one integer step or larger.
     if (std::abs(step) < 1)
         step = std::abs(percentChange) * (1 / percentChange);
 
     value += step;
-    setValue(String::numberToStringFixedPrecision(value));
+    setValue(String::number(value));
 
     auto objectCache = axObjectCache();
     if (objectCache)
         objectCache->postNotification(node(), AXObjectCache::AXValueChanged);
 }
@@ -1465,11 +1465,11 @@
     else if (isControl()) {
         // For controls, use their fieldset parent's described-by text if available.
         auto matchFunc = [] (const AccessibilityObject& object) {
             return object.isFieldset() && !object.ariaDescribedByAttribute().isEmpty();
         };
-        if (const auto* parent = AccessibilityObject::matchedParent(*this, false, WTFMove(matchFunc)))
+        if (const auto* parent = Accessibility::findAncestor<AccessibilityObject>(*this, false, WTFMove(matchFunc)))
             textOrder.append(AccessibilityText(parent->ariaDescribedByAttribute(), AccessibilityTextSource::Summary));
     }
 
     // Summary attribute used as help text on tables.
     const AtomString& summary = getAttribute(summaryAttr);
@@ -1511,15 +1511,15 @@
             return;
 
         Vector<Element*> elements;
         ariaLabeledByElements(elements);
 
-        Vector<RefPtr<AccessibilityObject>> axElements;
+        Vector<AXCoreObject*> axElements;
         for (const auto& element : elements)
             axElements.append(objectCache->getOrCreate(element));
 
-        textOrder.append(AccessibilityText(ariaLabeledBy, AccessibilityTextSource::Alternative, WTFMove(axElements)));
+        textOrder.append(AccessibilityText(ariaLabeledBy, AccessibilityTextSource::Alternative, axElements));
     }
 }
 
 String AccessibilityNodeObject::alternativeTextForWebArea() const
 {
@@ -1768,11 +1768,11 @@
 {
     Node* node = this->node();
     if (is<Text>(node))
         return downcast<Text>(*node).wholeText();
 
-    bool isAriaVisible = AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject& object) {
+    bool isAriaVisible = Accessibility::findAncestor<AccessibilityObject>(*this, true, [] (const AccessibilityObject& object) {
         return equalLettersIgnoringASCIICase(object.getAttribute(aria_hiddenAttr), "false");
     }) != nullptr;
 
     // The Accname specification states that if the current node is hidden, and not directly
     // referenced by aria-labelledby or aria-describedby, and is not a host language text

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderRuby.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeBuilderRuby.h&quot;
 28 
 29 #include &quot;RenderAncestorIterator.h&quot;
 30 #include &quot;RenderRuby.h&quot;
 31 #include &quot;RenderRubyBase.h&quot;
 32 #include &quot;RenderRubyRun.h&quot;
 33 #include &quot;RenderTreeBuilder.h&quot;
 34 #include &quot;RenderTreeBuilderBlock.h&quot;
 35 #include &quot;RenderTreeBuilderBlockFlow.h&quot;
 36 #include &quot;RenderTreeBuilderInline.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 static inline RenderRubyRun&amp; findRubyRunParent(RenderObject&amp; child)
 41 {
 42     return *lineageOfType&lt;RenderRubyRun&gt;(child).first();
 43 }
 44 
 45 static inline bool isAnonymousRubyInlineBlock(const RenderObject* object)
 46 {
 47     ASSERT(!object
 48         || !isRuby(object-&gt;parent())
 49         || is&lt;RenderRubyRun&gt;(*object)
 50         || (object-&gt;isInline() &amp;&amp; (object-&gt;isBeforeContent() || object-&gt;isAfterContent()))
<a name="1" id="anc1"></a><span class="line-modified"> 51         || (object-&gt;isAnonymous() &amp;&amp; is&lt;RenderBlock&gt;(*object) &amp;&amp; object-&gt;style().display() == DisplayType::InlineBlock));</span>


 52 
 53     return object
 54         &amp;&amp; isRuby(object-&gt;parent())
 55         &amp;&amp; is&lt;RenderBlock&gt;(*object)
 56         &amp;&amp; !is&lt;RenderRubyRun&gt;(*object);
 57 }
 58 
 59 static inline bool isRubyBeforeBlock(const RenderObject* object)
 60 {
 61     return isAnonymousRubyInlineBlock(object)
 62         &amp;&amp; !object-&gt;previousSibling()
 63         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()
 64         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()-&gt;style().styleType() == PseudoId::Before;
 65 }
 66 
 67 static inline bool isRubyAfterBlock(const RenderObject* object)
 68 {
 69     return isAnonymousRubyInlineBlock(object)
 70         &amp;&amp; !object-&gt;nextSibling()
 71         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()
 72         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()-&gt;style().styleType() == PseudoId::After;
 73 }
 74 
<a name="2" id="anc2"></a><span class="line-modified"> 75 #ifndef ASSERT_DISABLED</span>
 76 static inline bool isRubyChildForNormalRemoval(const RenderObject&amp; object)
 77 {
 78     return object.isRubyRun()
 79     || object.isBeforeContent()
 80     || object.isAfterContent()
 81     || object.isRenderMultiColumnFlow()
 82     || object.isRenderMultiColumnSet()
 83     || isAnonymousRubyInlineBlock(&amp;object);
 84 }
<a name="3" id="anc3"></a><span class="line-modified"> 85 #endif</span>
 86 
 87 static inline RenderBlock* rubyBeforeBlock(const RenderElement* ruby)
 88 {
 89     RenderObject* child = ruby-&gt;firstChild();
 90     return isRubyBeforeBlock(child) ? downcast&lt;RenderBlock&gt;(child) : nullptr;
 91 }
 92 
 93 static inline RenderBlock* rubyAfterBlock(const RenderElement* ruby)
 94 {
 95     RenderObject* child = ruby-&gt;lastChild();
 96     return isRubyAfterBlock(child) ? downcast&lt;RenderBlock&gt;(child) : nullptr;
 97 }
 98 
 99 static auto createAnonymousRubyInlineBlock(RenderObject&amp; ruby)
100 {
101     auto newBlock = createRenderer&lt;RenderBlockFlow&gt;(ruby.document(), RenderStyle::createAnonymousStyleWithDisplay(ruby.style(), DisplayType::InlineBlock));
102     newBlock-&gt;initializeStyle();
103     return newBlock;
104 }
105 
106 static RenderRubyRun* lastRubyRun(const RenderElement* ruby)
107 {
108     RenderObject* child = ruby-&gt;lastChild();
109     if (child &amp;&amp; !is&lt;RenderRubyRun&gt;(*child))
110         child = child-&gt;previousSibling();
111     if (!is&lt;RenderRubyRun&gt;(child)) {
<a name="4" id="anc4"></a><span class="line-modified">112         ASSERT(!child || child-&gt;isBeforeContent() || child == rubyBeforeBlock(ruby));</span>
113         return nullptr;
114     }
115     return downcast&lt;RenderRubyRun&gt;(child);
116 }
117 
118 RenderTreeBuilder::Ruby::Ruby(RenderTreeBuilder&amp; builder)
119     : m_builder(builder)
120 {
121 }
122 
123 void RenderTreeBuilder::Ruby::moveInlineChildren(RenderRubyBase&amp; from, RenderRubyBase&amp; to, RenderObject* beforeChild)
124 {
125     ASSERT(from.childrenInline());
126 
127     if (!from.firstChild())
128         return;
129 
130     RenderBlock* toBlock = nullptr;
131     if (to.childrenInline()) {
132         // The standard and easy case: move the children into the target base
133         toBlock = &amp;to;
134     } else {
135         // We need to wrap the inline objects into an anonymous block.
136         // If toBase has a suitable block, we re-use it, otherwise create a new one.
137         auto* lastChild = to.lastChild();
138         if (lastChild &amp;&amp; lastChild-&gt;isAnonymousBlock() &amp;&amp; lastChild-&gt;childrenInline())
139             toBlock = downcast&lt;RenderBlock&gt;(lastChild);
140         else {
141             auto newToBlock = to.createAnonymousBlock();
142             toBlock = newToBlock.get();
143             m_builder.attachToRenderElementInternal(to, WTFMove(newToBlock));
144         }
145     }
146     ASSERT(toBlock);
147     // Move our inline children into the target block we determined above.
148     m_builder.moveChildren(from, *toBlock, from.firstChild(), beforeChild, RenderTreeBuilder::NormalizeAfterInsertion::No);
149 }
150 
151 void RenderTreeBuilder::Ruby::moveBlockChildren(RenderRubyBase&amp; from, RenderRubyBase&amp; to, RenderObject* beforeChild)
152 {
153     ASSERT(!from.childrenInline());
154 
155     if (!from.firstChild())
156         return;
157 
158     if (to.childrenInline())
159         m_builder.makeChildrenNonInline(to);
160 
161     // If an anonymous block would be put next to another such block, then merge those.
162     auto* firstChildHere = from.firstChild();
163     auto* lastChildThere = to.lastChild();
164     if (firstChildHere-&gt;isAnonymousBlock() &amp;&amp; firstChildHere-&gt;childrenInline()
165         &amp;&amp; lastChildThere &amp;&amp; lastChildThere-&gt;isAnonymousBlock() &amp;&amp; lastChildThere-&gt;childrenInline()) {
166         auto* anonBlockHere = downcast&lt;RenderBlock&gt;(firstChildHere);
167         auto* anonBlockThere = downcast&lt;RenderBlock&gt;(lastChildThere);
168         m_builder.moveAllChildren(*anonBlockHere, *anonBlockThere, RenderTreeBuilder::NormalizeAfterInsertion::Yes);
169         anonBlockHere-&gt;deleteLines();
170         m_builder.destroy(*anonBlockHere);
171     }
172     // Move all remaining children normally.
173     m_builder.moveChildren(from, to, from.firstChild(), beforeChild, RenderTreeBuilder::NormalizeAfterInsertion::No);
174 }
175 
176 void RenderTreeBuilder::Ruby::moveChildren(RenderRubyBase&amp; from, RenderRubyBase&amp; to)
177 {
178     moveChildrenInternal(from, to);
179     from.addFloatsToNewParent(to);
180 }
181 
182 void RenderTreeBuilder::Ruby::moveChildrenInternal(RenderRubyBase&amp; from, RenderRubyBase&amp; to, RenderObject* beforeChild)
183 {
184     // This function removes all children that are before (!) beforeChild
185     // and appends them to toBase.
186     if (beforeChild &amp;&amp; beforeChild-&gt;parent() != &amp;from)
187         beforeChild = m_builder.splitAnonymousBoxesAroundChild(from, *beforeChild);
188 
189     if (from.childrenInline())
190         moveInlineChildren(from, to, beforeChild);
191     else
192         moveBlockChildren(from, to, beforeChild);
193 
194     from.setNeedsLayoutAndPrefWidthsRecalc();
195     to.setNeedsLayoutAndPrefWidthsRecalc();
196 }
197 
198 void RenderTreeBuilder::Ruby::attach(RenderRubyRun&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
199 {
200     if (child-&gt;isRubyText()) {
201         if (!beforeChild) {
202             // RenderRuby has already ascertained that we can add the child here.
203             ASSERT(!parent.hasRubyText());
204             // prepend ruby texts as first child
205             m_builder.blockFlowBuilder().attach(parent, WTFMove(child), parent.firstChild());
206             return;
207         }
208         if (beforeChild-&gt;isRubyText()) {
209             // New text is inserted just before another.
210             // In this case the new text takes the place of the old one, and
211             // the old text goes into a new run that is inserted as next sibling.
212             ASSERT(beforeChild-&gt;parent() == &amp;parent);
213             RenderElement* ruby = parent.parent();
214             ASSERT(isRuby(ruby));
215             auto newRun = RenderRubyRun::staticCreateRubyRun(ruby);
<a name="5" id="anc5"></a>
216             m_builder.attach(*ruby, WTFMove(newRun), parent.nextSibling());
217             // Add the new ruby text and move the old one to the new run
218             // Note: Doing it in this order and not using RenderRubyRun&#39;s methods,
219             // in order to avoid automatic removal of the ruby run in case there is no
220             // other child besides the old ruby text.
221             m_builder.blockFlowBuilder().attach(parent, WTFMove(child), beforeChild);
222             auto takenBeforeChild = m_builder.blockBuilder().detach(parent, *beforeChild);
223 
<a name="6" id="anc6"></a><span class="line-modified">224             m_builder.attach(*newRun, WTFMove(takenBeforeChild));</span>
225             return;
226         }
227         if (parent.hasRubyBase()) {
228             // Insertion before a ruby base object.
229             // In this case we need insert a new run before the current one and split the base.
230             RenderElement* ruby = parent.parent();
231             auto newRun = RenderRubyRun::staticCreateRubyRun(ruby);
232             auto&amp; run = *newRun;
233             m_builder.attach(*ruby, WTFMove(newRun), &amp;parent);
234             m_builder.attach(run, WTFMove(child));
235             moveChildrenInternal(rubyBaseSafe(parent), rubyBaseSafe(run), beforeChild);
236         }
237         return;
238     }
239     // child is not a text -&gt; insert it into the base
240     // (append it instead if beforeChild is the ruby text)
241     if (beforeChild &amp;&amp; beforeChild-&gt;isRubyText())
242         beforeChild = nullptr;
243     m_builder.attach(rubyBaseSafe(parent), WTFMove(child), beforeChild);
244 }
245 
246 RenderElement&amp; RenderTreeBuilder::Ruby::findOrCreateParentForChild(RenderRubyAsBlock&amp; parent, const RenderObject&amp; child, RenderObject*&amp; beforeChild)
247 {
248     // Insert :before and :after content before/after the RenderRubyRun(s)
249     if (child.isBeforeContent()) {
250         // Add generated inline content normally
251         if (child.isInline())
252             return parent;
253         // Wrap non-inline content in an anonymous inline-block.
254         auto* beforeBlock = rubyBeforeBlock(&amp;parent);
255         if (!beforeBlock) {
256             auto newBlock = createAnonymousRubyInlineBlock(parent);
257             beforeBlock = newBlock.get();
258             m_builder.blockFlowBuilder().attach(parent, WTFMove(newBlock), parent.firstChild());
259         }
260         beforeChild = nullptr;
261         return *beforeBlock;
262     }
263 
264     if (child.isAfterContent()) {
265         // Add generated inline content normally
266         if (child.isInline())
267             return parent;
268         // Wrap non-inline content with an anonymous inline-block.
269         auto* afterBlock = rubyAfterBlock(&amp;parent);
270         if (!afterBlock) {
271             auto newBlock = createAnonymousRubyInlineBlock(parent);
272             afterBlock = newBlock.get();
273             m_builder.blockFlowBuilder().attach(parent, WTFMove(newBlock), nullptr);
274         }
275         beforeChild = nullptr;
276         return *afterBlock;
277     }
278 
279     // If the child is a ruby run, just add it normally.
280     if (child.isRubyRun())
281         return parent;
282 
283     if (beforeChild &amp;&amp; !parent.isAfterContent(beforeChild)) {
284         // insert child into run
285         ASSERT(!beforeChild-&gt;isRubyRun());
286         auto* run = beforeChild-&gt;parent();
287         while (run &amp;&amp; !run-&gt;isRubyRun())
288             run = run-&gt;parent();
289         if (run)
290             return *run;
291         ASSERT_NOT_REACHED(); // beforeChild should always have a run as parent!
292         // Emergency fallback: fall through and just append.
293     }
294 
295     // If the new child would be appended, try to add the child to the previous run
296     // if possible, or create a new run otherwise.
297     // (The RenderRubyRun object will handle the details)
298     auto* lastRun = lastRubyRun(&amp;parent);
299     if (!lastRun || lastRun-&gt;hasRubyText()) {
300         auto newRun = RenderRubyRun::staticCreateRubyRun(&amp;parent);
301         lastRun = newRun.get();
302         m_builder.blockFlowBuilder().attach(parent, WTFMove(newRun), beforeChild);
303     }
304     beforeChild = nullptr;
305     return *lastRun;
306 }
307 
308 RenderElement&amp; RenderTreeBuilder::Ruby::findOrCreateParentForChild(RenderRubyAsInline&amp; parent, const RenderObject&amp; child, RenderObject*&amp; beforeChild)
309 {
310     // Insert :before and :after content before/after the RenderRubyRun(s)
311     if (child.isBeforeContent()) {
312         // Add generated inline content normally
313         if (child.isInline())
314             return parent;
315         // Wrap non-inline content with an anonymous inline-block.
316         auto* beforeBlock = rubyBeforeBlock(&amp;parent);
317         if (!beforeBlock) {
318             auto newBlock = createAnonymousRubyInlineBlock(parent);
319             beforeBlock = newBlock.get();
320             m_builder.inlineBuilder().attach(parent, WTFMove(newBlock), parent.firstChild());
321         }
322         beforeChild = nullptr;
323         return *beforeBlock;
324     }
325 
326     if (child.isAfterContent()) {
327         // Add generated inline content normally
328         if (child.isInline())
329             return parent;
330         // Wrap non-inline content with an anonymous inline-block.
331         auto* afterBlock = rubyAfterBlock(&amp;parent);
332         if (!afterBlock) {
333             auto newBlock = createAnonymousRubyInlineBlock(parent);
334             afterBlock = newBlock.get();
335             m_builder.inlineBuilder().attach(parent, WTFMove(newBlock), nullptr);
336         }
337         beforeChild = nullptr;
338         return *afterBlock;
339     }
340 
341     // If the child is a ruby run, just add it normally.
342     if (child.isRubyRun())
343         return parent;
344 
345     if (beforeChild &amp;&amp; !parent.isAfterContent(beforeChild)) {
346         // insert child into run
347         ASSERT(!beforeChild-&gt;isRubyRun());
348         auto* run = beforeChild-&gt;parent();
349         while (run &amp;&amp; !run-&gt;isRubyRun())
350             run = run-&gt;parent();
351         if (run)
352             return *run;
353         ASSERT_NOT_REACHED(); // beforeChild should always have a run as parent!
354         // Emergency fallback: fall through and just append.
355     }
356 
357     // If the new child would be appended, try to add the child to the previous run
358     // if possible, or create a new run otherwise.
359     // (The RenderRubyRun object will handle the details)
360     auto* lastRun = lastRubyRun(&amp;parent);
361     if (!lastRun || lastRun-&gt;hasRubyText()) {
362         auto newRun = RenderRubyRun::staticCreateRubyRun(&amp;parent);
363         lastRun = newRun.get();
364         m_builder.inlineBuilder().attach(parent, WTFMove(newRun), beforeChild);
365     }
366     beforeChild = nullptr;
367     return *lastRun;
368 }
369 
370 RenderRubyBase&amp; RenderTreeBuilder::Ruby::rubyBaseSafe(RenderRubyRun&amp; rubyRun)
371 {
372     auto* base = rubyRun.rubyBase();
373     if (!base) {
374         auto newBase = rubyRun.createRubyBase();
375         base = newBase.get();
376         m_builder.blockFlowBuilder().attach(rubyRun, WTFMove(newBase), nullptr);
377     }
378     return *base;
379 }
380 
381 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyAsInline&amp; parent, RenderObject&amp; child)
382 {
383     // If the child&#39;s parent is *this (must be a ruby run or generated content or anonymous block),
384     // just use the normal remove method.
385     if (child.parent() == &amp;parent) {
<a name="7" id="anc7"></a><span class="line-removed">386 #ifndef ASSERT_DISABLED</span>
387         ASSERT(isRubyChildForNormalRemoval(child));
<a name="8" id="anc8"></a><span class="line-removed">388 #endif</span>
389         return m_builder.detachFromRenderElement(parent, child);
390     }
391     // If the child&#39;s parent is an anoymous block (must be generated :before/:after content)
392     // just use the block&#39;s remove method.
393     if (isAnonymousRubyInlineBlock(child.parent())) {
394         ASSERT(child.isBeforeContent() || child.isAfterContent());
395         auto&amp; parent = *child.parent();
396         auto takenChild = m_builder.detach(parent, child);
397         m_builder.destroy(parent);
398         return takenChild;
399     }
400 
401     // Otherwise find the containing run and remove it from there.
402     return m_builder.detach(findRubyRunParent(child), child);
403 }
404 
405 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyAsBlock&amp; parent, RenderObject&amp; child)
406 {
407     // If the child&#39;s parent is *this (must be a ruby run or generated content or anonymous block),
408     // just use the normal remove method.
409     if (child.parent() == &amp;parent) {
<a name="9" id="anc9"></a><span class="line-removed">410 #ifndef ASSERT_DISABLED</span>
411         ASSERT(isRubyChildForNormalRemoval(child));
<a name="10" id="anc10"></a><span class="line-removed">412 #endif</span>
413         return m_builder.blockBuilder().detach(parent, child);
414     }
415     // If the child&#39;s parent is an anoymous block (must be generated :before/:after content)
416     // just use the block&#39;s remove method.
417     if (isAnonymousRubyInlineBlock(child.parent())) {
418         ASSERT(child.isBeforeContent() || child.isAfterContent());
419         auto&amp; parent = *child.parent();
420         auto takenChild = m_builder.detach(parent, child);
421         m_builder.destroy(parent);
422         return takenChild;
423     }
424 
425     // Otherwise find the containing run and remove it from there.
426     return m_builder.detach(findRubyRunParent(child), child);
427 }
428 
429 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyRun&amp; parent, RenderObject&amp; child)
430 {
431     // If the child is a ruby text, then merge the ruby base with the base of
432     // the right sibling run, if possible.
433     if (!parent.beingDestroyed() &amp;&amp; !parent.renderTreeBeingDestroyed() &amp;&amp; child.isRubyText()) {
434         RenderRubyBase* base = parent.rubyBase();
435         RenderObject* rightNeighbour = parent.nextSibling();
436         if (base &amp;&amp; is&lt;RenderRubyRun&gt;(rightNeighbour)) {
437             // Ruby run without a base can happen only at the first run.
438             RenderRubyRun&amp; rightRun = downcast&lt;RenderRubyRun&gt;(*rightNeighbour);
439             if (rightRun.hasRubyBase()) {
440                 RenderRubyBase* rightBase = rightRun.rubyBase();
441                 // Collect all children in a single base, then swap the bases.
442                 moveChildren(*rightBase, *base);
443                 m_builder.move(parent, rightRun, *base, RenderTreeBuilder::NormalizeAfterInsertion::No);
444                 m_builder.move(rightRun, parent, *rightBase, RenderTreeBuilder::NormalizeAfterInsertion::No);
445                 // The now empty ruby base will be removed below.
446                 ASSERT(!parent.rubyBase()-&gt;firstChild());
447             }
448         }
449     }
450 
451     auto takenChild = m_builder.blockBuilder().detach(parent, child);
452 
453     if (!parent.beingDestroyed() &amp;&amp; !parent.renderTreeBeingDestroyed()) {
454         // Check if our base (if any) is now empty. If so, destroy it.
455         RenderBlock* base = parent.rubyBase();
456         if (base &amp;&amp; !base-&gt;firstChild()) {
457             auto takenBase = m_builder.blockBuilder().detach(parent, *base);
458             base-&gt;deleteLines();
459         }
460     }
461     return takenChild;
462 }
463 
464 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
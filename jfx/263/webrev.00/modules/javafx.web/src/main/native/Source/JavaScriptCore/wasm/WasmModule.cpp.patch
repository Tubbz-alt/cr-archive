diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmModule.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmModule.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmModule.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmModule.cpp
@@ -26,84 +26,91 @@
 #include "config.h"
 #include "WasmModule.h"
 
 #if ENABLE(WEBASSEMBLY)
 
-#include "WasmBBQPlanInlines.h"
+#include "WasmBBQPlan.h"
+#include "WasmLLIntPlan.h"
 #include "WasmModuleInformation.h"
 #include "WasmWorklist.h"
 
 namespace JSC { namespace Wasm {
 
-Module::Module(Ref<ModuleInformation>&& moduleInformation)
-    : m_moduleInformation(WTFMove(moduleInformation))
+Module::Module(LLIntPlan& plan)
+    : m_moduleInformation(plan.takeModuleInformation())
+    , m_llintCallees(LLIntCallees::create(plan.takeCallees()))
+    , m_llintEntryThunks(plan.takeEntryThunks())
 {
 }
 
 Module::~Module() { }
 
 Wasm::SignatureIndex Module::signatureIndexFromFunctionIndexSpace(unsigned functionIndexSpace) const
 {
     return m_moduleInformation->signatureIndexFromFunctionIndexSpace(functionIndexSpace);
 }
 
-static Module::ValidationResult makeValidationResult(BBQPlan& plan)
+static Module::ValidationResult makeValidationResult(LLIntPlan& plan)
 {
     ASSERT(!plan.hasWork());
     if (plan.failed())
         return Unexpected<String>(plan.errorMessage());
-    return Module::ValidationResult(Module::create(plan.takeModuleInformation()));
+    return Module::ValidationResult(Module::create(plan));
 }
 
 static Plan::CompletionTask makeValidationCallback(Module::AsyncValidationCallback&& callback)
 {
     return createSharedTask<Plan::CallbackType>([callback = WTFMove(callback)] (Plan& plan) {
         ASSERT(!plan.hasWork());
-        callback->run(makeValidationResult(static_cast<BBQPlan&>(plan)));
+        callback->run(makeValidationResult(static_cast<LLIntPlan&>(plan)));
     });
 }
 
 Module::ValidationResult Module::validateSync(Context* context, Vector<uint8_t>&& source)
 {
-    Ref<BBQPlan> plan = adoptRef(*new BBQPlan(context, WTFMove(source), BBQPlan::Validation, Plan::dontFinalize(), nullptr, nullptr));
-    plan->parseAndValidateModule();
+    Ref<LLIntPlan> plan = adoptRef(*new LLIntPlan(context, WTFMove(source), EntryPlan::Validation, Plan::dontFinalize()));
+    Wasm::ensureWorklist().enqueue(plan.get());
+    plan->waitForCompletion();
     return makeValidationResult(plan.get());
 }
 
 void Module::validateAsync(Context* context, Vector<uint8_t>&& source, Module::AsyncValidationCallback&& callback)
 {
-    Ref<Plan> plan = adoptRef(*new BBQPlan(context, WTFMove(source), BBQPlan::Validation, makeValidationCallback(WTFMove(callback)), nullptr, nullptr));
+    Ref<Plan> plan = adoptRef(*new LLIntPlan(context, WTFMove(source), EntryPlan::Validation, makeValidationCallback(WTFMove(callback))));
     Wasm::ensureWorklist().enqueue(WTFMove(plan));
 }
 
-Ref<CodeBlock> Module::getOrCreateCodeBlock(Context* context, MemoryMode mode, CreateEmbedderWrapper&& createEmbedderWrapper, ThrowWasmException throwWasmException)
+Ref<CodeBlock> Module::getOrCreateCodeBlock(Context* context, MemoryMode mode)
 {
     RefPtr<CodeBlock> codeBlock;
     auto locker = holdLock(m_lock);
     codeBlock = m_codeBlocks[static_cast<uint8_t>(mode)];
     // If a previous attempt at a compile errored out, let's try again.
     // Compilations from valid modules can fail because OOM and cancellation.
     // It's worth retrying.
     // FIXME: We might want to back off retrying at some point:
     // https://bugs.webkit.org/show_bug.cgi?id=170607
     if (!codeBlock || (codeBlock->compilationFinished() && !codeBlock->runnable())) {
-        codeBlock = CodeBlock::create(context, mode, const_cast<ModuleInformation&>(moduleInformation()), WTFMove(createEmbedderWrapper), throwWasmException);
+        RefPtr<LLIntCallees> llintCallees = nullptr;
+        if (Options::useWasmLLInt())
+            llintCallees = m_llintCallees;
+        codeBlock = CodeBlock::create(context, mode, const_cast<ModuleInformation&>(moduleInformation()), llintCallees);
         m_codeBlocks[static_cast<uint8_t>(mode)] = codeBlock;
     }
     return codeBlock.releaseNonNull();
 }
 
-Ref<CodeBlock> Module::compileSync(Context* context, MemoryMode mode, CreateEmbedderWrapper&& createEmbedderWrapper, ThrowWasmException throwWasmException)
+Ref<CodeBlock> Module::compileSync(Context* context, MemoryMode mode)
 {
-    Ref<CodeBlock> codeBlock = getOrCreateCodeBlock(context, mode, WTFMove(createEmbedderWrapper), throwWasmException);
+    Ref<CodeBlock> codeBlock = getOrCreateCodeBlock(context, mode);
     codeBlock->waitUntilFinished();
     return codeBlock;
 }
 
-void Module::compileAsync(Context* context, MemoryMode mode, CodeBlock::AsyncCompilationCallback&& task, CreateEmbedderWrapper&& createEmbedderWrapper, ThrowWasmException throwWasmException)
+void Module::compileAsync(Context* context, MemoryMode mode, CodeBlock::AsyncCompilationCallback&& task)
 {
-    Ref<CodeBlock> codeBlock = getOrCreateCodeBlock(context, mode, WTFMove(createEmbedderWrapper), throwWasmException);
+    Ref<CodeBlock> codeBlock = getOrCreateCodeBlock(context, mode);
     codeBlock->compileAsync(context, WTFMove(task));
 }
 
 } } // namespace JSC::Wasm
 

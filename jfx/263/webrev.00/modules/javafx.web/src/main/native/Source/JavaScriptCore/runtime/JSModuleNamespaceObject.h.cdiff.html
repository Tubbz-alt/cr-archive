<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSModuleNamespaceObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSModuleNamespaceObject.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSModuleRecord.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSModuleNamespaceObject.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,81 ***</span>
  #include &quot;AbstractModuleRecord.h&quot;
  #include &quot;JSDestructibleObject.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! class JSModuleNamespaceObject final : public JSDestructibleObject {</span>
  public:
<span class="line-modified">!     typedef JSDestructibleObject Base;</span>
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesGetPropertyNames | GetOwnPropertySlotIsImpureForPropertyAbsence | IsImmutablePrototypeExoticObject;</span>
  
<span class="line-modified">!     static JSModuleNamespaceObject* create(ExecState* exec, JSGlobalObject* globalObject, Structure* structure, AbstractModuleRecord* moduleRecord, Vector&lt;std::pair&lt;Identifier, AbstractModuleRecord::Resolution&gt;&gt;&amp;&amp; resolutions)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!         JSModuleNamespaceObject* object =</span>
<span class="line-modified">!             new (</span>
<span class="line-removed">-                 NotNull,</span>
<span class="line-removed">-                 allocateCell&lt;JSModuleNamespaceObject&gt;(vm.heap, JSModuleNamespaceObject::allocationSize(resolutions.size())))</span>
<span class="line-removed">-             JSModuleNamespaceObject(vm, structure);</span>
<span class="line-removed">-         object-&gt;finishCreation(exec, globalObject, moduleRecord, WTFMove(resolutions));</span>
          return object;
      }
  
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool getOwnPropertySlotByIndex(JSObject*, ExecState*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool deleteProperty(JSCell*, ExecState*, PropertyName);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static void getOwnPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
  
      DECLARE_EXPORT_INFO;
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-modified">!         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());</span>
      }
  
      AbstractModuleRecord* moduleRecord() { return m_moduleRecord.get(); }
  
  protected:
<span class="line-modified">!     JS_EXPORT_PRIVATE void finishCreation(ExecState*, JSGlobalObject*, AbstractModuleRecord*, Vector&lt;std::pair&lt;Identifier, AbstractModuleRecord::Resolution&gt;&gt;&amp;&amp;);</span>
      JS_EXPORT_PRIVATE JSModuleNamespaceObject(VM&amp;, Structure*);
  
  private:
<span class="line-removed">-     static void destroy(JSCell*);</span>
      static void visitChildren(JSCell*, SlotVisitor&amp;);
<span class="line-modified">!     bool getOwnPropertySlotCommon(ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     WriteBarrierBase&lt;AbstractModuleRecord&gt;&amp; moduleRecordAt(unsigned offset)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return moduleRecords()[offset];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     WriteBarrierBase&lt;AbstractModuleRecord&gt;* moduleRecords()</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return bitwise_cast&lt;WriteBarrierBase&lt;AbstractModuleRecord&gt;*&gt;(bitwise_cast&lt;char*&gt;(this) + offsetOfModuleRecords());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static size_t offsetOfModuleRecords()</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return WTF::roundUpToMultipleOf&lt;sizeof(WriteBarrier&lt;AbstractModuleRecord&gt;)&gt;(sizeof(JSModuleNamespaceObject));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static size_t allocationSize(Checked&lt;size_t&gt; moduleRecords)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return (offsetOfModuleRecords() + moduleRecords * sizeof(WriteBarrier&lt;AbstractModuleRecord&gt;)).unsafeGet();</span>
<span class="line-removed">-     }</span>
  
      struct ExportEntry {
          Identifier localName;
<span class="line-modified">!         unsigned moduleRecordOffset;</span>
      };
  
      typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, ExportEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;&gt; ExportMap;
  
      ExportMap m_exports;
      Vector&lt;Identifier&gt; m_names;
      WriteBarrier&lt;AbstractModuleRecord&gt; m_moduleRecord;
  };
  
  } // namespace JSC
<span class="line-new-header">--- 28,67 ---</span>
  #include &quot;AbstractModuleRecord.h&quot;
  #include &quot;JSDestructibleObject.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! class JSModuleNamespaceObject final : public JSNonFinalObject {</span>
  public:
<span class="line-modified">!     using Base = JSNonFinalObject;</span>
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesGetPropertyNames | GetOwnPropertySlotIsImpureForPropertyAbsence | IsImmutablePrototypeExoticObject;</span>
  
<span class="line-modified">!     static constexpr bool needsDestruction = true;</span>
<span class="line-added">+     static void destroy(JSCell*);</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;typename CellType, SubspaceAccess mode&gt;</span>
<span class="line-added">+     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return vm.moduleNamespaceObjectSpace&lt;mode&gt;();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     static JSModuleNamespaceObject* create(JSGlobalObject* globalObject, Structure* structure, AbstractModuleRecord* moduleRecord, Vector&lt;std::pair&lt;Identifier, AbstractModuleRecord::Resolution&gt;&gt;&amp;&amp; resolutions)</span>
      {
<span class="line-modified">!         VM&amp; vm = getVM(globalObject);</span>
<span class="line-modified">!         JSModuleNamespaceObject* object = new (NotNull, allocateCell&lt;JSModuleNamespaceObject&gt;(vm.heap)) JSModuleNamespaceObject(vm, structure);</span>
<span class="line-modified">!         object-&gt;finishCreation(globalObject, moduleRecord, WTFMove(resolutions));</span>
          return object;
      }
  
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool getOwnPropertySlotByIndex(JSObject*, JSGlobalObject*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool putByIndex(JSCell*, JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static void getOwnPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
  
      DECLARE_EXPORT_INFO;
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-modified">!         return Structure::create(vm, globalObject, prototype, TypeInfo(ModuleNamespaceObjectType, StructureFlags), info());</span>
      }
  
      AbstractModuleRecord* moduleRecord() { return m_moduleRecord.get(); }
  
  protected:
<span class="line-modified">!     JS_EXPORT_PRIVATE void finishCreation(JSGlobalObject*, AbstractModuleRecord*, Vector&lt;std::pair&lt;Identifier, AbstractModuleRecord::Resolution&gt;&gt;&amp;&amp;);</span>
      JS_EXPORT_PRIVATE JSModuleNamespaceObject(VM&amp;, Structure*);
  
  private:
      static void visitChildren(JSCell*, SlotVisitor&amp;);
<span class="line-modified">!     bool getOwnPropertySlotCommon(JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
  
      struct ExportEntry {
          Identifier localName;
<span class="line-modified">!         WriteBarrier&lt;AbstractModuleRecord&gt; moduleRecord;</span>
      };
  
      typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, ExportEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;&gt; ExportMap;
  
      ExportMap m_exports;
      Vector&lt;Identifier&gt; m_names;
      WriteBarrier&lt;AbstractModuleRecord&gt; m_moduleRecord;
<span class="line-added">+ </span>
<span class="line-added">+     friend size_t cellSize(VM&amp;, JSCell*);</span>
  };
  
  } // namespace JSC
</pre>
<center><a href="JSModuleNamespaceObject.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSModuleRecord.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="YarrInterpreter.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrJIT.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -52,37 +52,36 @@</span>
      static const RegisterID initialStart = ARMRegisters::r8;
  
      static const RegisterID returnRegister = ARMRegisters::r0;
      static const RegisterID returnRegister2 = ARMRegisters::r1;
  
<span class="udiff-line-removed">- #define HAVE_INITIAL_START_REG</span>
  #elif CPU(ARM64)
      // Argument registers
      static const RegisterID input = ARM64Registers::x0;
      static const RegisterID index = ARM64Registers::x1;
      static const RegisterID length = ARM64Registers::x2;
      static const RegisterID output = ARM64Registers::x3;
      static const RegisterID freelistRegister = ARM64Registers::x4;
<span class="udiff-line-modified-removed">-     static const RegisterID freelistSizeRegister = ARM64Registers::x5;</span>
<span class="udiff-line-modified-added">+     static const RegisterID freelistSizeRegister = ARM64Registers::x5; // Only used during initialization.</span>
  
      // Scratch registers
      static const RegisterID regT0 = ARM64Registers::x6;
      static const RegisterID regT1 = ARM64Registers::x7;
      static const RegisterID regT2 = ARM64Registers::x8;
      static const RegisterID remainingMatchCount = ARM64Registers::x9;
      static const RegisterID regUnicodeInputAndTrail = ARM64Registers::x10;
<span class="udiff-line-added">+     static const RegisterID unicodeTemp = ARM64Registers::x5;</span>
      static const RegisterID initialStart = ARM64Registers::x11;
      static const RegisterID supplementaryPlanesBase = ARM64Registers::x12;
      static const RegisterID leadingSurrogateTag = ARM64Registers::x13;
      static const RegisterID trailingSurrogateTag = ARM64Registers::x14;
      static const RegisterID endOfStringAddress = ARM64Registers::x15;
  
      static const RegisterID returnRegister = ARM64Registers::x0;
      static const RegisterID returnRegister2 = ARM64Registers::x1;
  
      const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);
<span class="udiff-line-removed">- #define HAVE_INITIAL_START_REG</span>
  #define JIT_UNICODE_EXPRESSIONS
  #elif CPU(MIPS)
      static const RegisterID input = MIPSRegisters::a0;
      static const RegisterID index = MIPSRegisters::a1;
      static const RegisterID length = MIPSRegisters::a2;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -93,22 +92,10 @@</span>
      static const RegisterID initialStart = MIPSRegisters::t6;
  
      static const RegisterID returnRegister = MIPSRegisters::v0;
      static const RegisterID returnRegister2 = MIPSRegisters::v1;
  
<span class="udiff-line-removed">- #define HAVE_INITIAL_START_REG</span>
<span class="udiff-line-removed">- #elif CPU(X86)</span>
<span class="udiff-line-removed">-     static const RegisterID input = X86Registers::eax;</span>
<span class="udiff-line-removed">-     static const RegisterID index = X86Registers::edx;</span>
<span class="udiff-line-removed">-     static const RegisterID length = X86Registers::ecx;</span>
<span class="udiff-line-removed">-     static const RegisterID output = X86Registers::edi;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static const RegisterID regT0 = X86Registers::ebx;</span>
<span class="udiff-line-removed">-     static const RegisterID regT1 = X86Registers::esi;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static const RegisterID returnRegister = X86Registers::eax;</span>
<span class="udiff-line-removed">-     static const RegisterID returnRegister2 = X86Registers::edx;</span>
  #elif CPU(X86_64)
  #if !OS(WINDOWS)
      // Argument registers
      static const RegisterID input = X86Registers::edi;
      static const RegisterID index = X86Registers::esi;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -141,20 +128,20 @@</span>
      static const RegisterID remainingMatchCount = X86Registers::r12;
  #else
      static const RegisterID remainingMatchCount = X86Registers::esi;
  #endif
      static const RegisterID regUnicodeInputAndTrail = X86Registers::r13;
<span class="udiff-line-modified-removed">-     static const RegisterID leadingSurrogateTag = X86Registers::r14;</span>
<span class="udiff-line-modified-added">+     static const RegisterID unicodeTemp = X86Registers::r14;</span>
      static const RegisterID endOfStringAddress = X86Registers::r15;
  
      static const RegisterID returnRegister = X86Registers::eax;
      static const RegisterID returnRegister2 = X86Registers::edx;
  
      const TrustedImm32 supplementaryPlanesBase = TrustedImm32(0x10000);
<span class="udiff-line-added">+     const TrustedImm32 leadingSurrogateTag = TrustedImm32(0xd800);</span>
      const TrustedImm32 trailingSurrogateTag = TrustedImm32(0xdc00);
      const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);
<span class="udiff-line-removed">- #define HAVE_INITIAL_START_REG</span>
  #define JIT_UNICODE_EXPRESSIONS
  #endif
  
  #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
      struct ParenContextSizes {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -541,22 +528,27 @@</span>
          ASSERT(m_charSize == Char16);
  
          JumpList notUnicode;
  
          load16Unaligned(regUnicodeInputAndTrail, resultReg);
<span class="udiff-line-modified-removed">-         and32(surrogateTagMask, resultReg, regT2);</span>
<span class="udiff-line-modified-removed">-         notUnicode.append(branch32(NotEqual, regT2, leadingSurrogateTag));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         // Is the character a leading surrogate?</span>
<span class="udiff-line-added">+         and32(surrogateTagMask, resultReg, unicodeTemp);</span>
<span class="udiff-line-added">+         notUnicode.append(branch32(NotEqual, unicodeTemp, leadingSurrogateTag));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Is the input long enough to read a trailing surrogate?</span>
          addPtr(TrustedImm32(2), regUnicodeInputAndTrail);
          notUnicode.append(branchPtr(AboveOrEqual, regUnicodeInputAndTrail, endOfStringAddress));
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Is the character a trailing surrogate?</span>
          load16Unaligned(Address(regUnicodeInputAndTrail), regUnicodeInputAndTrail);
<span class="udiff-line-modified-removed">-         and32(surrogateTagMask, regUnicodeInputAndTrail, regT2);</span>
<span class="udiff-line-modified-removed">-         notUnicode.append(branch32(NotEqual, regT2, trailingSurrogateTag));</span>
<span class="udiff-line-modified-removed">-         sub32(leadingSurrogateTag, resultReg);</span>
<span class="udiff-line-modified-removed">-         sub32(trailingSurrogateTag, regUnicodeInputAndTrail);</span>
<span class="udiff-line-modified-added">+         and32(surrogateTagMask, regUnicodeInputAndTrail, unicodeTemp);</span>
<span class="udiff-line-modified-added">+         notUnicode.append(branch32(NotEqual, unicodeTemp, trailingSurrogateTag));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         // Combine leading and trailing surrogates to produce a code point.</span>
          lshift32(TrustedImm32(10), resultReg);
<span class="udiff-line-modified-removed">-         or32(regUnicodeInputAndTrail, resultReg);</span>
<span class="udiff-line-removed">-         add32(supplementaryPlanesBase, resultReg);</span>
<span class="udiff-line-modified-added">+         getEffectiveAddress(BaseIndex(resultReg, regUnicodeInputAndTrail, TimesOne, -U16_SURROGATE_OFFSET), resultReg);</span>
          notUnicode.link(this);
      }
  
      void tryReadUnicodeChar(BaseIndex address, RegisterID resultReg)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -569,20 +561,10 @@</span>
          else
              tryReadUnicodeCharImpl(resultReg);
      }
  #endif
  
<span class="udiff-line-removed">-     void readCharacterDontDecodeSurrogates(Checked&lt;unsigned&gt; negativeCharacterOffset, RegisterID resultReg, RegisterID indexReg = index)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         BaseIndex address = negativeOffsetIndexedAddress(negativeCharacterOffset, resultReg, indexReg);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (m_charSize == Char8)</span>
<span class="udiff-line-removed">-             load8(address, resultReg);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             load16Unaligned(address, resultReg);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      void readCharacter(Checked&lt;unsigned&gt; negativeCharacterOffset, RegisterID resultReg, RegisterID indexReg = index)
      {
          BaseIndex address = negativeOffsetIndexedAddress(negativeCharacterOffset, resultReg, indexReg);
  
          if (m_charSize == Char8)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -654,35 +636,12 @@</span>
          return callFrameSize;
      }
      void initCallFrame()
      {
          unsigned callFrameSizeInBytes = alignCallFrameSizeInBytes(m_pattern.m_body-&gt;m_callFrameSize);
<span class="udiff-line-modified-removed">-         if (callFrameSizeInBytes) {</span>
<span class="udiff-line-modified-removed">- #if CPU(X86_64) || CPU(ARM64)</span>
<span class="udiff-line-removed">-             if (Options::zeroStackFrame()) {</span>
<span class="udiff-line-removed">-                 // We need to start from the stack pointer, because we could have spilled callee saves</span>
<span class="udiff-line-removed">-                 move(stackPointerRegister, regT0);</span>
<span class="udiff-line-removed">-                 subPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);</span>
<span class="udiff-line-removed">-                 if (callFrameSizeInBytes &lt;= 128) {</span>
<span class="udiff-line-removed">-                     for (unsigned offset = 0; offset &lt; callFrameSizeInBytes; offset += sizeof(intptr_t))</span>
<span class="udiff-line-removed">-                         storePtr(TrustedImm32(0), Address(regT0, -8 - offset));</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     Label zeroLoop = label();</span>
<span class="udiff-line-removed">-                     subPtr(TrustedImm32(sizeof(intptr_t) * 2), regT0);</span>
<span class="udiff-line-removed">- #if CPU(ARM64)</span>
<span class="udiff-line-removed">-                     storePair64(ARM64Registers::zr, ARM64Registers::zr, regT0);</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-                     storePtr(TrustedImm32(0), Address(regT0));</span>
<span class="udiff-line-removed">-                     storePtr(TrustedImm32(0), Address(regT0, sizeof(intptr_t)));</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-                     branchPtr(NotEqual, regT0, stackPointerRegister).linkTo(zeroLoop, this);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             } else</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-                 subPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         if (callFrameSizeInBytes)</span>
<span class="udiff-line-modified-added">+             subPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);</span>
      }
      void removeCallFrame()
      {
          unsigned callFrameSizeInBytes = alignCallFrameSizeInBytes(m_pattern.m_body-&gt;m_callFrameSize);
          if (callFrameSizeInBytes)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1148,12 +1107,12 @@</span>
          PatternTerm* term = op.m_term;
          unsigned subpatternId = term-&gt;backReferenceSubpatternId;
  
          Label loop(this);
  
<span class="udiff-line-modified-removed">-         readCharacterDontDecodeSurrogates(0, patternCharacter, patternIndex);</span>
<span class="udiff-line-modified-removed">-         readCharacterDontDecodeSurrogates(m_checkedOffset - term-&gt;inputPosition, character);</span>
<span class="udiff-line-modified-added">+         readCharacter(0, patternCharacter, patternIndex);</span>
<span class="udiff-line-modified-added">+         readCharacter(m_checkedOffset - term-&gt;inputPosition, character);</span>
  
          if (!m_pattern.ignoreCase())
              characterMatchFails.append(branch32(NotEqual, character, patternCharacter));
          else {
              Jump charactersMatch = branch32(Equal, character, patternCharacter);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1163,14 +1122,20 @@</span>
              load16(patternTableEntry, patternCharacter);
              characterMatchFails.append(branch32(NotEqual, character, patternCharacter));
              charactersMatch.link(this);
          }
  
<span class="udiff-line-removed">- </span>
          add32(TrustedImm32(1), index);
          add32(TrustedImm32(1), patternIndex);
  
<span class="udiff-line-added">+         if (m_decodeSurrogatePairs) {</span>
<span class="udiff-line-added">+             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="udiff-line-added">+             add32(TrustedImm32(1), index);</span>
<span class="udiff-line-added">+             add32(TrustedImm32(1), patternIndex);</span>
<span class="udiff-line-added">+             isBMPChar.link(this);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          branch32(NotEqual, patternIndex, Address(output, ((subpatternId &lt;&lt; 1) + 1) * sizeof(int))).linkTo(loop, this);
      }
  
      void generateBackReference(size_t opIndex)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2029,14 +1994,10 @@</span>
          YarrOp&amp; op = m_ops[opIndex];
          PatternTerm* term = op.m_term;
  
          const RegisterID character = regT0;
          const RegisterID matchPos = regT1;
<span class="udiff-line-removed">- #ifndef HAVE_INITIAL_START_REG</span>
<span class="udiff-line-removed">-         const RegisterID initialStart = character;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
          JumpList foundBeginningNewLine;
          JumpList saveStartIndex;
          JumpList foundEndingNewLine;
  
          if (m_pattern.dotAll()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2047,25 +2008,19 @@</span>
          }
  
          ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
          getMatchStart(matchPos);
  
<span class="udiff-line-removed">- #ifndef HAVE_INITIAL_START_REG</span>
<span class="udiff-line-removed">-         loadFromFrame(m_pattern.m_initialStartValueFrameLocation, initialStart);</span>
<span class="udiff-line-removed">- #endif</span>
          saveStartIndex.append(branch32(BelowOrEqual, matchPos, initialStart));
          Label findBOLLoop(this);
          sub32(TrustedImm32(1), matchPos);
          if (m_charSize == Char8)
              load8(BaseIndex(input, matchPos, TimesOne, 0), character);
          else
              load16(BaseIndex(input, matchPos, TimesTwo, 0), character);
          matchCharacterClass(character, foundBeginningNewLine, m_pattern.newlineCharacterClass());
  
<span class="udiff-line-removed">- #ifndef HAVE_INITIAL_START_REG</span>
<span class="udiff-line-removed">-         loadFromFrame(m_pattern.m_initialStartValueFrameLocation, initialStart);</span>
<span class="udiff-line-removed">- #endif</span>
          branch32(Above, matchPos, initialStart).linkTo(findBOLLoop, this);
          saveStartIndex.append(jump());
  
          foundBeginningNewLine.link(this);
          add32(TrustedImm32(1), matchPos); // Advance past newline
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3749,40 +3704,20 @@</span>
  
          if (m_decodeSurrogatePairs) {
              push(X86Registers::r13);
              push(X86Registers::r14);
              push(X86Registers::r15);
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             move(TrustedImm32(0xd800), leadingSurrogateTag);</span>
          }
          // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
          zeroExtend32ToPtr(index, index);
          zeroExtend32ToPtr(length, length);
  #if OS(WINDOWS)
          if (compileMode == IncludeSubpatterns)
              loadPtr(Address(X86Registers::ebp, 6 * sizeof(void*)), output);
          // rcx is the pointer to the allocated space for result in x64 Windows.
          push(X86Registers::ecx);
  #endif
<span class="udiff-line-removed">- #elif CPU(X86)</span>
<span class="udiff-line-removed">-         push(X86Registers::ebp);</span>
<span class="udiff-line-removed">-         move(stackPointerRegister, X86Registers::ebp);</span>
<span class="udiff-line-removed">-         // TODO: do we need spill registers to fill the output pointer if there are no sub captures?</span>
<span class="udiff-line-removed">-         push(X86Registers::ebx);</span>
<span class="udiff-line-removed">-         push(X86Registers::edi);</span>
<span class="udiff-line-removed">-         push(X86Registers::esi);</span>
<span class="udiff-line-removed">-         // load output into edi (2 = saved ebp + return address).</span>
<span class="udiff-line-removed">-     #if COMPILER(MSVC)</span>
<span class="udiff-line-removed">-         loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), input);</span>
<span class="udiff-line-removed">-         loadPtr(Address(X86Registers::ebp, 3 * sizeof(void*)), index);</span>
<span class="udiff-line-removed">-         loadPtr(Address(X86Registers::ebp, 4 * sizeof(void*)), length);</span>
<span class="udiff-line-removed">-         if (compileMode == IncludeSubpatterns)</span>
<span class="udiff-line-removed">-             loadPtr(Address(X86Registers::ebp, 5 * sizeof(void*)), output);</span>
<span class="udiff-line-removed">-     #else</span>
<span class="udiff-line-removed">-         if (compileMode == IncludeSubpatterns)</span>
<span class="udiff-line-removed">-             loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), output);</span>
<span class="udiff-line-removed">-     #endif</span>
  #elif CPU(ARM64)
          tagReturnAddress();
          if (m_decodeSurrogatePairs) {
              pushPair(framePointerRegister, linkRegister);
              move(TrustedImm32(0x10000), supplementaryPlanesBase);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3836,15 +3771,10 @@</span>
  #endif
  
          if (m_pattern.m_saveInitialStartValue)
              pop(X86Registers::ebx);
          pop(X86Registers::ebp);
<span class="udiff-line-removed">- #elif CPU(X86)</span>
<span class="udiff-line-removed">-         pop(X86Registers::esi);</span>
<span class="udiff-line-removed">-         pop(X86Registers::edi);</span>
<span class="udiff-line-removed">-         pop(X86Registers::ebx);</span>
<span class="udiff-line-removed">-         pop(X86Registers::ebp);</span>
  #elif CPU(ARM64)
          if (m_decodeSurrogatePairs)
              popPair(framePointerRegister, linkRegister);
  #elif CPU(ARM_THUMB2)
          pop(ARMRegisters::r8);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3949,17 +3879,12 @@</span>
                  return;
              }
          }
  #endif
  
<span class="udiff-line-modified-removed">-         if (m_pattern.m_saveInitialStartValue) {</span>
<span class="udiff-line-removed">- #ifdef HAVE_INITIAL_START_REG</span>
<span class="udiff-line-modified-added">+         if (m_pattern.m_saveInitialStartValue)</span>
              move(index, initialStart);
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-             storeToFrame(index, m_pattern.m_initialStartValueFrameLocation);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-         }</span>
  
          generate();
          if (m_disassembler)
              m_disassembler-&gt;setEndOfGenerate(label());
          backtrack();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4293,11 +4218,11 @@</span>
          YarrGenerator&lt;MatchOnly&gt;(vm, pattern, patternString, codeBlock, charSize).compile();
      else
          YarrGenerator&lt;IncludeSubpatterns&gt;(vm, pattern, patternString, codeBlock, charSize).compile();
  
      if (auto failureReason = codeBlock.failureReason()) {
<span class="udiff-line-modified-removed">-         if (Options::dumpCompiledRegExpPatterns()) {</span>
<span class="udiff-line-modified-added">+         if (UNLIKELY(Options::dumpCompiledRegExpPatterns())) {</span>
              pattern.dumpPatternString(WTF::dataFile(), patternString);
              dataLog(&quot; : &quot;);
              dumpCompileFailure(*failureReason);
          }
      }
</pre>
<center><a href="YarrInterpreter.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrJIT.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
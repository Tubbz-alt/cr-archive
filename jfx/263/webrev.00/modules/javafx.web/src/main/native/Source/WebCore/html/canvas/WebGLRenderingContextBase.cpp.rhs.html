<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebGLRenderingContextBase.h&quot;
  28 
  29 #if ENABLE(WEBGL)
  30 
  31 #include &quot;ANGLEInstancedArrays.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;DOMWindow.h&quot;
  34 #include &quot;DiagnosticLoggingClient.h&quot;
  35 #include &quot;DiagnosticLoggingKeys.h&quot;
  36 #include &quot;Document.h&quot;
  37 #include &quot;EXTBlendMinMax.h&quot;
  38 #include &quot;EXTFragDepth.h&quot;
  39 #include &quot;EXTShaderTextureLOD.h&quot;
  40 #include &quot;EXTTextureFilterAnisotropic.h&quot;
  41 #include &quot;EXTsRGB.h&quot;
  42 #include &quot;EventNames.h&quot;
<a name="1" id="anc1"></a><span class="line-modified">  43 #include &quot;ExtensionsGL.h&quot;</span>
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameLoader.h&quot;
  46 #include &quot;FrameLoaderClient.h&quot;
  47 #include &quot;FrameView.h&quot;
  48 #include &quot;GraphicsContext.h&quot;
  49 #include &quot;HTMLCanvasElement.h&quot;
  50 #include &quot;HTMLImageElement.h&quot;
  51 #include &quot;HTMLVideoElement.h&quot;
  52 #include &quot;ImageBuffer.h&quot;
  53 #include &quot;ImageData.h&quot;
  54 #include &quot;InspectorInstrumentation.h&quot;
  55 #include &quot;IntSize.h&quot;
  56 #include &quot;JSExecState.h&quot;
  57 #include &quot;Logging.h&quot;
  58 #include &quot;NotImplemented.h&quot;
  59 #include &quot;OESElementIndexUint.h&quot;
  60 #include &quot;OESStandardDerivatives.h&quot;
  61 #include &quot;OESTextureFloat.h&quot;
  62 #include &quot;OESTextureFloatLinear.h&quot;
  63 #include &quot;OESTextureHalfFloat.h&quot;
  64 #include &quot;OESTextureHalfFloatLinear.h&quot;
  65 #include &quot;OESVertexArrayObject.h&quot;
<a name="2" id="anc2"></a>
  66 #include &quot;Page.h&quot;
  67 #include &quot;RenderBox.h&quot;
  68 #include &quot;RuntimeEnabledFeatures.h&quot;
  69 #include &quot;Settings.h&quot;
  70 #include &quot;WebGL2RenderingContext.h&quot;
  71 #include &quot;WebGLActiveInfo.h&quot;
  72 #include &quot;WebGLBuffer.h&quot;
  73 #include &quot;WebGLCompressedTextureASTC.h&quot;
  74 #include &quot;WebGLCompressedTextureATC.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  75 #include &quot;WebGLCompressedTextureETC.h&quot;</span>
<span class="line-added">  76 #include &quot;WebGLCompressedTextureETC1.h&quot;</span>
  77 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
  78 #include &quot;WebGLCompressedTextureS3TC.h&quot;
  79 #include &quot;WebGLContextAttributes.h&quot;
  80 #include &quot;WebGLContextEvent.h&quot;
  81 #include &quot;WebGLContextGroup.h&quot;
  82 #include &quot;WebGLDebugRendererInfo.h&quot;
  83 #include &quot;WebGLDebugShaders.h&quot;
  84 #include &quot;WebGLDepthTexture.h&quot;
  85 #include &quot;WebGLDrawBuffers.h&quot;
  86 #include &quot;WebGLFramebuffer.h&quot;
  87 #include &quot;WebGLLoseContext.h&quot;
  88 #include &quot;WebGLProgram.h&quot;
  89 #include &quot;WebGLRenderbuffer.h&quot;
  90 #include &quot;WebGLRenderingContext.h&quot;
  91 #include &quot;WebGLShader.h&quot;
  92 #include &quot;WebGLShaderPrecisionFormat.h&quot;
  93 #include &quot;WebGLTexture.h&quot;
  94 #include &quot;WebGLUniformLocation.h&quot;
  95 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
  96 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  97 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  98 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  99 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
 100 #include &lt;JavaScriptCore/Uint32Array.h&gt;
 101 #include &lt;wtf/CheckedArithmetic.h&gt;
 102 #include &lt;wtf/HashMap.h&gt;
 103 #include &lt;wtf/HexNumber.h&gt;
 104 #include &lt;wtf/IsoMallocInlines.h&gt;
 105 #include &lt;wtf/Lock.h&gt;
 106 #include &lt;wtf/StdLibExtras.h&gt;
 107 #include &lt;wtf/UniqueArray.h&gt;
 108 #include &lt;wtf/text/CString.h&gt;
 109 #include &lt;wtf/text/StringBuilder.h&gt;
 110 
<a name="4" id="anc4"></a><span class="line-added"> 111 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 112 #include &quot;OffscreenCanvas.h&quot;</span>
<span class="line-added"> 113 #endif</span>
<span class="line-added"> 114 </span>
 115 namespace WebCore {
 116 
 117 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContextBase);
 118 
 119 static const Seconds secondsBetweenRestoreAttempts { 1_s };
 120 const int maxGLErrorsAllowedToConsole = 256;
 121 static const Seconds checkContextLossHandlingDelay { 3_s };
 122 
 123 namespace {
 124 
<a name="5" id="anc5"></a><span class="line-modified"> 125     GCGLint clamp(GCGLint value, GCGLint min, GCGLint max)</span>
 126     {
 127         if (value &lt; min)
 128             value = min;
 129         if (value &gt; max)
 130             value = max;
 131         return value;
 132     }
 133 
 134     // Return true if a character belongs to the ASCII subset as defined in
 135     // GLSL ES 1.0 spec section 3.1.
 136     bool validateCharacter(unsigned char c)
 137     {
 138         // Printing characters are valid except &quot; $ ` @ \ &#39; DEL.
 139         if (c &gt;= 32 &amp;&amp; c &lt;= 126
 140             &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;$&#39; &amp;&amp; c != &#39;`&#39; &amp;&amp; c != &#39;@&#39; &amp;&amp; c != &#39;\\&#39; &amp;&amp; c != &#39;\&#39;&#39;)
 141             return true;
 142         // Horizontal tab, line feed, vertical tab, form feed, carriage return
 143         // are also valid.
 144         if (c &gt;= 9 &amp;&amp; c &lt;= 13)
 145             return true;
 146         return false;
 147     }
 148 
 149     bool isPrefixReserved(const String&amp; name)
 150     {
 151         if (name.startsWith(&quot;gl_&quot;) || name.startsWith(&quot;webgl_&quot;) || name.startsWith(&quot;_webgl_&quot;))
 152             return true;
 153         return false;
 154     }
 155 
 156     // Strips comments from shader text. This allows non-ASCII characters
 157     // to be used in comments without potentially breaking OpenGL
 158     // implementations not expecting characters outside the GLSL ES set.
 159     class StripComments {
 160     public:
 161         StripComments(const String&amp; str)
 162             : m_parseState(BeginningOfLine)
 163             , m_sourceString(str)
 164             , m_length(str.length())
 165             , m_position(0)
 166         {
 167             parse();
 168         }
 169 
 170         String result()
 171         {
 172             return m_builder.toString();
 173         }
 174 
 175     private:
 176         bool hasMoreCharacters() const
 177         {
 178             return (m_position &lt; m_length);
 179         }
 180 
 181         void parse()
 182         {
 183             while (hasMoreCharacters()) {
 184                 process(current());
 185                 // process() might advance the position.
 186                 if (hasMoreCharacters())
 187                     advance();
 188             }
 189         }
 190 
 191         void process(UChar);
 192 
 193         bool peek(UChar&amp; character) const
 194         {
 195             if (m_position + 1 &gt;= m_length)
 196                 return false;
 197             character = m_sourceString[m_position + 1];
 198             return true;
 199         }
 200 
 201         UChar current() const
 202         {
 203             ASSERT_WITH_SECURITY_IMPLICATION(m_position &lt; m_length);
 204             return m_sourceString[m_position];
 205         }
 206 
 207         void advance()
 208         {
 209             ++m_position;
 210         }
 211 
 212         bool isNewline(UChar character) const
 213         {
 214             // Don&#39;t attempt to canonicalize newline related characters.
 215             return (character == &#39;\n&#39; || character == &#39;\r&#39;);
 216         }
 217 
 218         void emit(UChar character)
 219         {
 220             m_builder.append(character);
 221         }
 222 
 223         enum ParseState {
 224             // Have not seen an ASCII non-whitespace character yet on
 225             // this line. Possible that we might see a preprocessor
 226             // directive.
 227             BeginningOfLine,
 228 
 229             // Have seen at least one ASCII non-whitespace character
 230             // on this line.
 231             MiddleOfLine,
 232 
 233             // Handling a preprocessor directive. Passes through all
 234             // characters up to the end of the line. Disables comment
 235             // processing.
 236             InPreprocessorDirective,
 237 
 238             // Handling a single-line comment. The comment text is
 239             // replaced with a single space.
 240             InSingleLineComment,
 241 
 242             // Handling a multi-line comment. Newlines are passed
 243             // through to preserve line numbers.
 244             InMultiLineComment
 245         };
 246 
 247         ParseState m_parseState;
 248         String m_sourceString;
 249         unsigned m_length;
 250         unsigned m_position;
 251         StringBuilder m_builder;
 252     };
 253 
 254     void StripComments::process(UChar c)
 255     {
 256         if (isNewline(c)) {
 257             // No matter what state we are in, pass through newlines
 258             // so we preserve line numbers.
 259             emit(c);
 260 
 261             if (m_parseState != InMultiLineComment)
 262                 m_parseState = BeginningOfLine;
 263 
 264             return;
 265         }
 266 
 267         UChar temp = 0;
 268         switch (m_parseState) {
 269         case BeginningOfLine:
 270             if (WTF::isASCIISpace(c)) {
 271                 emit(c);
 272                 break;
 273             }
 274 
 275             if (c == &#39;#&#39;) {
 276                 m_parseState = InPreprocessorDirective;
 277                 emit(c);
 278                 break;
 279             }
 280 
 281             // Transition to normal state and re-handle character.
 282             m_parseState = MiddleOfLine;
 283             process(c);
 284             break;
 285 
 286         case MiddleOfLine:
 287             if (c == &#39;/&#39; &amp;&amp; peek(temp)) {
 288                 if (temp == &#39;/&#39;) {
 289                     m_parseState = InSingleLineComment;
 290                     emit(&#39; &#39;);
 291                     advance();
 292                     break;
 293                 }
 294 
 295                 if (temp == &#39;*&#39;) {
 296                     m_parseState = InMultiLineComment;
 297                     // Emit the comment start in case the user has
 298                     // an unclosed comment and we want to later
 299                     // signal an error.
 300                     emit(&#39;/&#39;);
 301                     emit(&#39;*&#39;);
 302                     advance();
 303                     break;
 304                 }
 305             }
 306 
 307             emit(c);
 308             break;
 309 
 310         case InPreprocessorDirective:
 311             // No matter what the character is, just pass it
 312             // through. Do not parse comments in this state. This
 313             // might not be the right thing to do long term, but it
 314             // should handle the #error preprocessor directive.
 315             emit(c);
 316             break;
 317 
 318         case InSingleLineComment:
 319             // The newline code at the top of this function takes care
 320             // of resetting our state when we get out of the
 321             // single-line comment. Swallow all other characters.
 322             break;
 323 
 324         case InMultiLineComment:
 325             if (c == &#39;*&#39; &amp;&amp; peek(temp) &amp;&amp; temp == &#39;/&#39;) {
 326                 emit(&#39;*&#39;);
 327                 emit(&#39;/&#39;);
 328                 m_parseState = MiddleOfLine;
 329                 advance();
 330                 break;
 331             }
 332 
 333             // Swallow all other characters. Unclear whether we may
 334             // want or need to just emit a space per character to try
 335             // to preserve column numbers for debugging purposes.
 336             break;
 337         }
 338     }
 339 } // namespace anonymous
 340 
 341 // Returns false if no clipping is necessary, i.e., x, y, width, height stay the same.
<a name="6" id="anc6"></a><span class="line-modified"> 342 static bool clip2D(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height,</span>
<span class="line-modified"> 343     GCGLsizei sourceWidth, GCGLsizei sourceHeight,</span>
<span class="line-modified"> 344     GCGLint* clippedX, GCGLint* clippedY, GCGLsizei* clippedWidth, GCGLsizei*clippedHeight)</span>
 345 {
 346     ASSERT(clippedX &amp;&amp; clippedY &amp;&amp; clippedWidth &amp;&amp; clippedHeight);
 347 
<a name="7" id="anc7"></a><span class="line-modified"> 348     GCGLint left = std::max(x, 0);</span>
<span class="line-modified"> 349     GCGLint top = std::max(y, 0);</span>
<span class="line-modified"> 350     GCGLint right = 0;</span>
<span class="line-modified"> 351     GCGLint bottom = 0;</span>
 352 
<a name="8" id="anc8"></a><span class="line-modified"> 353     Checked&lt;GCGLint, RecordOverflow&gt; checkedInputRight = Checked&lt;GCGLint&gt;(x) + Checked&lt;GCGLsizei&gt;(width);</span>
<span class="line-modified"> 354     Checked&lt;GCGLint, RecordOverflow&gt; checkedInputBottom = Checked&lt;GCGLint&gt;(y) + Checked&lt;GCGLsizei&gt;(height);</span>
 355     if (!checkedInputRight.hasOverflowed() &amp;&amp; !checkedInputBottom.hasOverflowed()) {
 356         right = std::min(checkedInputRight.unsafeGet(), sourceWidth);
 357         bottom = std::min(checkedInputBottom.unsafeGet(), sourceHeight);
 358     }
 359 
 360     if (left &gt;= right || top &gt;= bottom) {
 361         *clippedX = 0;
 362         *clippedY = 0;
 363         *clippedWidth = 0;
 364         *clippedHeight = 0;
 365         return true;
 366     }
 367 
 368     *clippedX = left;
 369     *clippedY = top;
 370     *clippedWidth = right - left;
 371     *clippedHeight = bottom - top;
 372 
 373     return (*clippedX != x || *clippedY != y || *clippedWidth != width || *clippedHeight != height);
 374 }
 375 
<a name="9" id="anc9"></a>

























 376 class InspectorScopedShaderProgramHighlight {
 377 public:
 378     InspectorScopedShaderProgramHighlight(WebGLRenderingContextBase&amp; context, WebGLProgram* program)
 379         : m_context(context)
 380         , m_program(program)
 381     {
 382         showHightlight();
 383     }
 384 
 385     ~InspectorScopedShaderProgramHighlight()
 386     {
 387         hideHighlight();
 388     }
 389 
 390 private:
 391     void showHightlight()
 392     {
<a name="10" id="anc10"></a><span class="line-modified"> 393         if (!m_program || LIKELY(!InspectorInstrumentation::isWebGLProgramHighlighted(m_context, *m_program)))</span>
 394             return;
 395 
<a name="11" id="anc11"></a><span class="line-modified"> 396         if (hasBufferBinding(GraphicsContextGL::FRAMEBUFFER_BINDING)) {</span>
<span class="line-modified"> 397             if (!hasBufferBinding(GraphicsContextGL::RENDERBUFFER_BINDING))</span>
 398                 return;
<a name="12" id="anc12"></a><span class="line-modified"> 399             if (hasFramebufferParameterAttachment(GraphicsContextGL::DEPTH_ATTACHMENT))</span>
 400                 return;
<a name="13" id="anc13"></a><span class="line-modified"> 401             if (hasFramebufferParameterAttachment(GraphicsContextGL::STENCIL_ATTACHMENT))</span>
 402                 return;
 403 #if ENABLE(WEBGL2)
<a name="14" id="anc14"></a><span class="line-modified"> 404             if (hasFramebufferParameterAttachment(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT))</span>
 405                 return;
 406 #endif
 407         }
 408 
<a name="15" id="anc15"></a><span class="line-modified"> 409         saveBlendValue(GraphicsContextGL::BLEND_COLOR, m_savedBlend.color);</span>
<span class="line-modified"> 410         saveBlendValue(GraphicsContextGL::BLEND_EQUATION_RGB, m_savedBlend.equationRGB);</span>
<span class="line-modified"> 411         saveBlendValue(GraphicsContextGL::BLEND_EQUATION_ALPHA, m_savedBlend.equationAlpha);</span>
<span class="line-modified"> 412         saveBlendValue(GraphicsContextGL::BLEND_SRC_RGB, m_savedBlend.srcRGB);</span>
<span class="line-modified"> 413         saveBlendValue(GraphicsContextGL::BLEND_SRC_ALPHA, m_savedBlend.srcAlpha);</span>
<span class="line-modified"> 414         saveBlendValue(GraphicsContextGL::BLEND_DST_RGB, m_savedBlend.dstRGB);</span>
<span class="line-modified"> 415         saveBlendValue(GraphicsContextGL::BLEND_DST_ALPHA, m_savedBlend.dstAlpha);</span>
<span class="line-modified"> 416         saveBlendValue(GraphicsContextGL::BLEND, m_savedBlend.enabled);</span>
<span class="line-modified"> 417 </span>
<span class="line-modified"> 418         static const GCGLfloat red = 111.0 / 255.0;</span>
<span class="line-modified"> 419         static const GCGLfloat green = 168.0 / 255.0;</span>
<span class="line-modified"> 420         static const GCGLfloat blue = 220.0 / 255.0;</span>
<span class="line-modified"> 421         static const GCGLfloat alpha = 2.0 / 3.0;</span>
<span class="line-modified"> 422 </span>
<span class="line-modified"> 423         m_context.enable(GraphicsContextGL::BLEND);</span>
 424         m_context.blendColor(red, green, blue, alpha);
<a name="16" id="anc16"></a><span class="line-modified"> 425         m_context.blendEquation(GraphicsContextGL::FUNC_ADD);</span>
<span class="line-modified"> 426         m_context.blendFunc(GraphicsContextGL::CONSTANT_COLOR, GraphicsContextGL::ONE_MINUS_SRC_ALPHA);</span>
 427 
 428         m_didApply = true;
 429     }
 430 
 431     void hideHighlight()
 432     {
 433         if (!m_didApply)
 434             return;
 435 
 436         if (!m_savedBlend.enabled)
<a name="17" id="anc17"></a><span class="line-modified"> 437             m_context.disable(GraphicsContextGL::BLEND);</span>
 438 
 439         const RefPtr&lt;Float32Array&gt;&amp; color = m_savedBlend.color;
 440         m_context.blendColor(color-&gt;item(0), color-&gt;item(1), color-&gt;item(2), color-&gt;item(3));
 441         m_context.blendEquationSeparate(m_savedBlend.equationRGB, m_savedBlend.equationAlpha);
 442         m_context.blendFuncSeparate(m_savedBlend.srcRGB, m_savedBlend.dstRGB, m_savedBlend.srcAlpha, m_savedBlend.dstAlpha);
 443 
 444         m_savedBlend.color = nullptr;
 445 
 446         m_didApply = false;
 447     }
 448 
 449     template &lt;typename T&gt;
<a name="18" id="anc18"></a><span class="line-modified"> 450     void saveBlendValue(GCGLenum attachment, T&amp; destination)</span>
 451     {
 452         WebGLAny param = m_context.getParameter(attachment);
 453         if (WTF::holds_alternative&lt;T&gt;(param))
 454             destination = WTF::get&lt;T&gt;(param);
 455     }
 456 
<a name="19" id="anc19"></a><span class="line-modified"> 457     bool hasBufferBinding(GCGLenum pname)</span>
 458     {
 459         WebGLAny binding = m_context.getParameter(pname);
<a name="20" id="anc20"></a><span class="line-modified"> 460         if (pname == GraphicsContextGL::FRAMEBUFFER_BINDING)</span>
 461             return WTF::holds_alternative&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding);
<a name="21" id="anc21"></a><span class="line-modified"> 462         if (pname == GraphicsContextGL::RENDERBUFFER_BINDING)</span>
 463             return WTF::holds_alternative&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding);
 464         return false;
 465     }
 466 
<a name="22" id="anc22"></a><span class="line-modified"> 467     bool hasFramebufferParameterAttachment(GCGLenum attachment)</span>
 468     {
<a name="23" id="anc23"></a><span class="line-modified"> 469         WebGLAny attachmentParameter = m_context.getFramebufferAttachmentParameter(GraphicsContextGL::FRAMEBUFFER, attachment, GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE);</span>
 470         if (!WTF::holds_alternative&lt;unsigned&gt;(attachmentParameter))
 471             return false;
<a name="24" id="anc24"></a><span class="line-modified"> 472         if (WTF::get&lt;unsigned&gt;(attachmentParameter) != static_cast&lt;unsigned&gt;(GraphicsContextGL::RENDERBUFFER))</span>
 473             return false;
 474         return true;
 475     }
 476 
 477     struct {
 478         RefPtr&lt;Float32Array&gt; color;
 479         unsigned equationRGB { 0 };
 480         unsigned equationAlpha { 0 };
 481         unsigned srcRGB { 0 };
 482         unsigned srcAlpha { 0 };
 483         unsigned dstRGB { 0 };
 484         unsigned dstAlpha { 0 };
 485         bool enabled { false };
 486     } m_savedBlend;
 487 
 488     WebGLRenderingContextBase&amp; m_context;
 489     WebGLProgram* m_program { nullptr };
 490     bool m_didApply { false };
 491 };
 492 
<a name="25" id="anc25"></a><span class="line-modified"> 493 static bool isHighPerformanceContext(const RefPtr&lt;GraphicsContextGLOpenGL&gt;&amp; context)</span>
 494 {
 495     return context-&gt;powerPreferenceUsedForCreation() == WebGLPowerPreference::HighPerformance;
 496 }
 497 
 498 std::unique_ptr&lt;WebGLRenderingContextBase&gt; WebGLRenderingContextBase::create(CanvasBase&amp; canvas, WebGLContextAttributes&amp; attributes, const String&amp; type)
 499 {
 500 #if ENABLE(WEBGL2)
 501     if (type == &quot;webgl2&quot; &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().webGL2Enabled())
 502         return nullptr;
 503 #else
 504     UNUSED_PARAM(type);
 505 #endif
 506 
 507     bool isPendingPolicyResolution = false;
 508     HostWindow* hostWindow = nullptr;
 509 
 510     auto* canvasElement = is&lt;HTMLCanvasElement&gt;(canvas) ? &amp;downcast&lt;HTMLCanvasElement&gt;(canvas) : nullptr;
 511 
 512     if (canvasElement) {
 513         Document&amp; document = canvasElement-&gt;document();
 514         RefPtr&lt;Frame&gt; frame = document.frame();
 515         if (!frame)
 516             return nullptr;
 517 
 518         // The FrameLoaderClient might block creation of a new WebGL context despite the page settings; in
 519         // particular, if WebGL contexts were lost one or more times via the GL_ARB_robustness extension.
 520         if (!frame-&gt;loader().client().allowWebGL(frame-&gt;settings().webGLEnabled())) {
 521             canvasElement-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextcreationerrorEvent,
 522                 Event::CanBubble::No, Event::IsCancelable::Yes, &quot;Web page was not allowed to create a WebGL context.&quot;));
 523             return nullptr;
 524         }
 525 
 526         Document&amp; topDocument = document.topDocument();
 527         Page* page = topDocument.page();
 528         bool forcingPendingPolicy = frame-&gt;settings().isForcePendingWebGLPolicy();
 529 
 530         if (forcingPendingPolicy || (page &amp;&amp; !topDocument.url().isLocalFile())) {
 531             WebGLLoadPolicy policy = forcingPendingPolicy ? WebGLPendingCreation : page-&gt;mainFrame().loader().client().webGLPolicyForURL(topDocument.url());
 532 
 533             if (policy == WebGLBlockCreation) {
 534                 LOG(WebGL, &quot;The policy for this URL (%s) is to block WebGL.&quot;, topDocument.url().host().utf8().data());
 535                 return nullptr;
 536             }
 537 
 538             if (policy == WebGLPendingCreation) {
 539                 LOG(WebGL, &quot;WebGL policy is pending. May need to be resolved later.&quot;);
 540                 isPendingPolicyResolution = true;
 541             }
 542         }
 543 
 544         if (frame-&gt;settings().forceWebGLUsesLowPower()) {
<a name="26" id="anc26"></a><span class="line-modified"> 545             if (attributes.powerPreference == GraphicsContextGLPowerPreference::HighPerformance)</span>
 546                 LOG(WebGL, &quot;Overriding powerPreference from high-performance to low-power.&quot;);
<a name="27" id="anc27"></a><span class="line-modified"> 547             attributes.powerPreference = GraphicsContextGLPowerPreference::LowPower;</span>
 548         }
 549 
 550         if (page)
 551             attributes.devicePixelRatio = page-&gt;deviceScaleFactor();
 552 
 553         hostWindow = document.view()-&gt;root()-&gt;hostWindow();
 554     }
 555 
 556     attributes.noExtensions = true;
 557     attributes.shareResources = false;
 558 
 559     attributes.initialPowerPreference = attributes.powerPreference;
 560 
 561 
 562 #if ENABLE(WEBGL2)
 563     if (type == &quot;webgl2&quot;)
 564         attributes.isWebGL2 = true;
 565 #endif
 566 
 567     if (isPendingPolicyResolution) {
 568         LOG(WebGL, &quot;Create a WebGL context that looks real, but will require a policy resolution if used.&quot;);
 569         std::unique_ptr&lt;WebGLRenderingContextBase&gt; renderingContext = nullptr;
 570 #if ENABLE(WEBGL2)
 571         if (type == &quot;webgl2&quot;)
 572             renderingContext = WebGL2RenderingContext::create(canvas, attributes);
 573         else
 574 #endif
 575             renderingContext = WebGLRenderingContext::create(canvas, attributes);
 576         renderingContext-&gt;suspendIfNeeded();
 577         return renderingContext;
 578     }
 579 
<a name="28" id="anc28"></a><span class="line-modified"> 580     auto context = GraphicsContextGLOpenGL::create(attributes, hostWindow);</span>
 581     if (!context || !context-&gt;makeContextCurrent()) {
 582         if (canvasElement) {
 583             canvasElement-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextcreationerrorEvent,
 584                 Event::CanBubble::No, Event::IsCancelable::Yes, &quot;Could not create a WebGL context.&quot;));
 585         }
 586         return nullptr;
 587     }
 588 
 589     auto&amp; extensions = context-&gt;getExtensions();
 590     if (extensions.supports(&quot;GL_EXT_debug_marker&quot;_s))
 591         extensions.pushGroupMarkerEXT(&quot;WebGLRenderingContext&quot;_s);
 592 
<a name="29" id="anc29"></a><span class="line-modified"> 593 #if ENABLE(WEBGL2) &amp;&amp; PLATFORM(MAC) &amp;&amp; !USE(ANGLE)</span>
 594     // glTexStorage() was only added to Core in OpenGL 4.2.
 595     // However, according to https://developer.apple.com/opengl/capabilities/ all Apple GPUs support this extension.
 596     if (attributes.isWebGL2 &amp;&amp; !extensions.supports(&quot;GL_ARB_texture_storage&quot;))
 597         return nullptr;
 598 #endif
 599 
 600     std::unique_ptr&lt;WebGLRenderingContextBase&gt; renderingContext;
 601 #if ENABLE(WEBGL2)
 602     if (type == &quot;webgl2&quot;)
 603         renderingContext = WebGL2RenderingContext::create(canvas, context.releaseNonNull(), attributes);
 604     else
 605 #endif
 606         renderingContext = WebGLRenderingContext::create(canvas, context.releaseNonNull(), attributes);
 607     renderingContext-&gt;suspendIfNeeded();
 608 
 609     return renderingContext;
 610 }
 611 
 612 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, WebGLContextAttributes attributes)
 613     : GPUBasedCanvasRenderingContext(canvas)
<a name="30" id="anc30"></a><span class="line-modified"> 614     , m_dispatchContextLostEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)</span>
<span class="line-modified"> 615     , m_dispatchContextChangedEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextChangedEvent)</span>
<span class="line-added"> 616     , m_restoreTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::maybeRestoreContext)</span>
 617     , m_attributes(attributes)
 618     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 619     , m_isPendingPolicyResolution(true)
 620     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 621 {
<a name="31" id="anc31"></a><span class="line-added"> 622     m_dispatchContextLostEventTimer.suspendIfNeeded();</span>
<span class="line-added"> 623     m_dispatchContextChangedEventTimer.suspendIfNeeded();</span>
<span class="line-added"> 624     m_restoreTimer.suspendIfNeeded();</span>
<span class="line-added"> 625 </span>
 626     registerWithWebGLStateTracker();
 627     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 628 }
 629 
<a name="32" id="anc32"></a><span class="line-modified"> 630 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, WebGLContextAttributes attributes)</span>
 631     : GPUBasedCanvasRenderingContext(canvas)
 632     , m_context(WTFMove(context))
<a name="33" id="anc33"></a><span class="line-modified"> 633     , m_dispatchContextLostEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)</span>
<span class="line-modified"> 634     , m_dispatchContextChangedEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextChangedEvent)</span>
<span class="line-added"> 635     , m_restoreTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::maybeRestoreContext)</span>
 636     , m_generatedImageCache(4)
 637     , m_attributes(attributes)
 638     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 639     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 640 {
<a name="34" id="anc34"></a><span class="line-added"> 641     m_dispatchContextLostEventTimer.suspendIfNeeded();</span>
<span class="line-added"> 642     m_dispatchContextChangedEventTimer.suspendIfNeeded();</span>
<span class="line-added"> 643     m_restoreTimer.suspendIfNeeded();</span>
<span class="line-added"> 644 </span>
 645     m_contextGroup = WebGLContextGroup::create();
 646     m_contextGroup-&gt;addContext(*this);
 647 
 648     m_context-&gt;addClient(*this);
 649 
<a name="35" id="anc35"></a><span class="line-modified"> 650     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_VIEWPORT_DIMS, m_maxViewportDims);</span>
 651 
 652     setupFlags();
 653     initializeNewContext();
 654     registerWithWebGLStateTracker();
 655     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 656 
 657     addActivityStateChangeObserverIfNecessary();
 658 }
 659 
 660 WebGLCanvas WebGLRenderingContextBase::canvas()
 661 {
 662     auto&amp; base = canvasBase();
<a name="36" id="anc36"></a><span class="line-added"> 663 #if ENABLE(OFFSCREEN_CANVAS)</span>
 664     if (is&lt;OffscreenCanvas&gt;(base))
 665         return &amp;downcast&lt;OffscreenCanvas&gt;(base);
<a name="37" id="anc37"></a><span class="line-added"> 666 #endif</span>
 667     return &amp;downcast&lt;HTMLCanvasElement&gt;(base);
 668 }
 669 
<a name="38" id="anc38"></a><span class="line-added"> 670 #if ENABLE(OFFSCREEN_CANVAS)</span>
 671 OffscreenCanvas* WebGLRenderingContextBase::offscreenCanvas()
 672 {
 673     auto&amp; base = canvasBase();
 674     if (!is&lt;OffscreenCanvas&gt;(base))
 675         return nullptr;
 676     return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 677 }
<a name="39" id="anc39"></a><span class="line-added"> 678 #endif</span>
 679 
 680 // We check for context loss handling after a few seconds to give the JS a chance to register the event listeners
 681 // and to discard temporary GL contexts (e.g. feature detection).
 682 void WebGLRenderingContextBase::checkForContextLossHandling()
 683 {
 684     auto canvas = htmlCanvas();
 685     if (!canvas)
 686         return;
 687 
 688     if (!canvas-&gt;renderer())
 689         return;
 690 
 691     auto* page = canvas-&gt;document().page();
 692     if (!page)
 693         return;
 694 
 695     bool handlesContextLoss = canvas-&gt;hasEventListeners(eventNames().webglcontextlostEvent) &amp;&amp; canvas-&gt;hasEventListeners(eventNames().webglcontextrestoredEvent);
 696     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::pageHandlesWebGLContextLossKey(), handlesContextLoss ? DiagnosticLoggingKeys::yesKey() : DiagnosticLoggingKeys::noKey(), ShouldSample::No);
 697 }
 698 
 699 void WebGLRenderingContextBase::registerWithWebGLStateTracker()
 700 {
 701     auto canvas = htmlCanvas();
 702     if (!canvas)
 703         return;
 704 
 705     auto* page = canvas-&gt;document().page();
 706     if (!page)
 707         return;
 708 
 709     auto* tracker = page-&gt;webGLStateTracker();
 710     if (!tracker)
 711         return;
 712 
 713     m_trackerToken = tracker-&gt;token(m_attributes.initialPowerPreference);
 714 }
 715 
 716 void WebGLRenderingContextBase::initializeNewContext()
 717 {
 718     ASSERT(!m_contextLost);
 719     m_needsUpdate = true;
 720     m_markedCanvasDirty = false;
 721     m_activeTextureUnit = 0;
 722     m_packAlignment = 4;
 723     m_unpackAlignment = 4;
 724     m_unpackFlipY = false;
 725     m_unpackPremultiplyAlpha = false;
<a name="40" id="anc40"></a><span class="line-modified"> 726     m_unpackColorspaceConversion = GraphicsContextGL::BROWSER_DEFAULT_WEBGL;</span>
 727     m_boundArrayBuffer = nullptr;
 728     m_currentProgram = nullptr;
 729     m_framebufferBinding = nullptr;
 730     m_readFramebufferBinding = nullptr;
 731     m_renderbufferBinding = nullptr;
 732     m_depthMask = true;
 733     m_stencilEnabled = false;
 734     m_stencilMask = 0xFFFFFFFF;
 735     m_stencilMaskBack = 0xFFFFFFFF;
 736     m_stencilFuncRef = 0;
 737     m_stencilFuncRefBack = 0;
 738     m_stencilFuncMask = 0xFFFFFFFF;
 739     m_stencilFuncMaskBack = 0xFFFFFFFF;
 740     m_layerCleared = false;
 741     m_numGLErrorsToConsoleAllowed = maxGLErrorsAllowedToConsole;
 742 
 743     m_clearColor[0] = m_clearColor[1] = m_clearColor[2] = m_clearColor[3] = 0;
 744     m_scissorEnabled = false;
 745     m_clearDepth = 1;
 746     m_clearStencil = 0;
 747     m_colorMask[0] = m_colorMask[1] = m_colorMask[2] = m_colorMask[3] = true;
 748 
<a name="41" id="anc41"></a><span class="line-modified"> 749     GCGLint numCombinedTextureImageUnits = 0;</span>
<span class="line-modified"> 750     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_COMBINED_TEXTURE_IMAGE_UNITS, &amp;numCombinedTextureImageUnits);</span>
 751     m_textureUnits.clear();
 752     m_textureUnits.resize(numCombinedTextureImageUnits);
<a name="42" id="anc42"></a><span class="line-modified"> 753     for (GCGLint i = 0; i &lt; numCombinedTextureImageUnits; ++i)</span>
 754         m_unrenderableTextureUnits.add(i);
 755 
<a name="43" id="anc43"></a><span class="line-modified"> 756     GCGLint numVertexAttribs = 0;</span>
<span class="line-modified"> 757     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_VERTEX_ATTRIBS, &amp;numVertexAttribs);</span>
 758     m_maxVertexAttribs = numVertexAttribs;
 759 
 760     m_maxTextureSize = 0;
<a name="44" id="anc44"></a><span class="line-modified"> 761     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_TEXTURE_SIZE, &amp;m_maxTextureSize);</span>
 762     m_maxTextureLevel = WebGLTexture::computeLevelCount(m_maxTextureSize, m_maxTextureSize);
 763     m_maxCubeMapTextureSize = 0;
<a name="45" id="anc45"></a><span class="line-modified"> 764     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_CUBE_MAP_TEXTURE_SIZE, &amp;m_maxCubeMapTextureSize);</span>
 765     m_maxCubeMapTextureLevel = WebGLTexture::computeLevelCount(m_maxCubeMapTextureSize, m_maxCubeMapTextureSize);
 766     m_maxRenderbufferSize = 0;
<a name="46" id="anc46"></a><span class="line-modified"> 767     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_RENDERBUFFER_SIZE, &amp;m_maxRenderbufferSize);</span>
 768 
 769     // These two values from EXT_draw_buffers are lazily queried.
 770     m_maxDrawBuffers = 0;
 771     m_maxColorAttachments = 0;
 772 
<a name="47" id="anc47"></a><span class="line-modified"> 773     m_backDrawBuffer = GraphicsContextGL::BACK;</span>
 774     m_drawBuffersWebGLRequirementsChecked = false;
 775     m_drawBuffersSupported = false;
 776 
 777     m_vertexAttribValue.resize(m_maxVertexAttribs);
 778 
 779     if (!isGLES2NPOTStrict())
 780         createFallbackBlackTextures1x1();
 781 
 782     IntSize canvasSize = clampedCanvasSize();
 783     m_context-&gt;reshape(canvasSize.width(), canvasSize.height());
 784     m_context-&gt;viewport(0, 0, canvasSize.width(), canvasSize.height());
 785     m_context-&gt;scissor(0, 0, canvasSize.width(), canvasSize.height());
<a name="48" id="anc48"></a>


 786 }
 787 
 788 void WebGLRenderingContextBase::setupFlags()
 789 {
 790     ASSERT(m_context);
 791 
 792     auto canvas = htmlCanvas();
 793     if (canvas) {
 794         if (Page* page = canvas-&gt;document().page())
 795             m_synthesizedErrorsToConsole = page-&gt;settings().webGLErrorsToConsoleEnabled();
 796     }
 797 
 798     m_isGLES2Compliant = m_context-&gt;isGLES2Compliant();
 799     if (m_isGLES2Compliant) {
 800         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_texture_npot&quot;);
<a name="49" id="anc49"></a><span class="line-modified"> 801         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_packed_depth_stencil&quot;) || m_context-&gt;getExtensions().isEnabled(&quot;GL_ANGLE_depth_texture&quot;);</span>
 802     } else {
 803         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_ARB_texture_non_power_of_two&quot;);
<a name="50" id="anc50"></a><span class="line-modified"> 804         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_packed_depth_stencil&quot;) || m_context-&gt;getExtensions().isEnabled(&quot;GL_ANGLE_depth_texture&quot;);</span>
 805     }
 806     m_isRobustnessEXTSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_robustness&quot;);
 807 }
 808 
<a name="51" id="anc51"></a><span class="line-modified"> 809 void WebGLRenderingContextBase::addCompressedTextureFormat(GCGLenum format)</span>
 810 {
 811     if (!m_compressedTextureFormats.contains(format))
 812         m_compressedTextureFormats.append(format);
 813 }
 814 
 815 void WebGLRenderingContextBase::addActivityStateChangeObserverIfNecessary()
 816 {
 817     // We are only interested in visibility changes for contexts
 818     // that are using the high-performance GPU.
 819     if (!isHighPerformanceContext(m_context))
 820         return;
 821 
 822     auto* canvas = htmlCanvas();
 823     if (!canvas)
 824         return;
 825 
 826     auto* page = canvas-&gt;document().page();
 827     if (!page)
 828         return;
 829 
 830     page-&gt;addActivityStateChangeObserver(*this);
 831 
 832     // We won&#39;t get a state change right away, so
 833     // make sure the context knows if it visible or not.
 834     if (m_context)
 835         m_context-&gt;setContextVisibility(page-&gt;isVisible());
 836 }
 837 
 838 void WebGLRenderingContextBase::removeActivityStateChangeObserver()
 839 {
 840     auto* canvas = htmlCanvas();
 841     if (canvas) {
 842         if (auto* page = canvas-&gt;document().page())
 843             page-&gt;removeActivityStateChangeObserver(*this);
 844     }
 845 }
 846 
 847 WebGLRenderingContextBase::~WebGLRenderingContextBase()
 848 {
 849     // Remove all references to WebGLObjects so if they are the last reference
 850     // they will be freed before the last context is removed from the context group.
 851     m_boundArrayBuffer = nullptr;
 852     m_defaultVertexArrayObject = nullptr;
 853     m_boundVertexArrayObject = nullptr;
 854     m_vertexAttrib0Buffer = nullptr;
 855     m_currentProgram = nullptr;
 856     m_framebufferBinding = nullptr;
 857     m_readFramebufferBinding = nullptr;
 858     m_renderbufferBinding = nullptr;
 859 
 860     for (auto&amp; textureUnit : m_textureUnits) {
 861         textureUnit.texture2DBinding = nullptr;
 862         textureUnit.textureCubeMapBinding = nullptr;
 863     }
 864 
 865     m_blackTexture2D = nullptr;
 866     m_blackTextureCubeMap = nullptr;
 867 
 868     if (!m_isPendingPolicyResolution) {
 869         detachAndRemoveAllObjects();
<a name="52" id="anc52"></a><span class="line-modified"> 870         destroyGraphicsContextGL();</span>
 871         m_contextGroup-&gt;removeContext(*this);
 872     }
 873 
 874     {
 875         LockHolder lock(WebGLProgram::instancesMutex());
 876         for (auto&amp; entry : WebGLProgram::instances(lock)) {
 877             if (entry.value == this) {
 878                 // Don&#39;t remove any WebGLProgram from the instances list, as they may still exist.
 879                 // Only remove the association with a WebGL context.
 880                 entry.value = nullptr;
 881             }
 882         }
 883     }
 884 }
 885 
<a name="53" id="anc53"></a><span class="line-modified"> 886 void WebGLRenderingContextBase::destroyGraphicsContextGL()</span>
 887 {
 888     if (m_isPendingPolicyResolution)
 889         return;
 890 
 891     removeActivityStateChangeObserver();
 892 
 893     if (m_context) {
 894         m_context-&gt;removeClient(*this);
<a name="54" id="anc54"></a>

 895         m_context = nullptr;
 896     }
 897 }
 898 
 899 void WebGLRenderingContextBase::markContextChanged()
 900 {
 901     if (m_framebufferBinding)
 902         return;
 903 
 904     m_context-&gt;markContextChanged();
 905 
 906     m_layerCleared = false;
 907 
 908     auto* canvas = htmlCanvas();
 909     if (!canvas)
 910         return;
 911 
 912     RenderBox* renderBox = canvas-&gt;renderBox();
 913     if (isAccelerated() &amp;&amp; renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing()) {
 914         m_markedCanvasDirty = true;
 915         htmlCanvas()-&gt;clearCopiedImage();
 916         renderBox-&gt;contentChanged(CanvasPixelsChanged);
 917     } else {
 918         if (!m_markedCanvasDirty) {
 919             m_markedCanvasDirty = true;
 920             canvas-&gt;didDraw(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
 921         }
 922     }
 923 }
 924 
 925 void WebGLRenderingContextBase::markContextChangedAndNotifyCanvasObserver()
 926 {
 927     markContextChanged();
 928     if (!isAccelerated())
 929         return;
 930 
 931     auto* canvas = htmlCanvas();
 932     if (!canvas)
 933         return;
 934 
 935     RenderBox* renderBox = canvas-&gt;renderBox();
 936     if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing())
 937         canvas-&gt;notifyObserversCanvasChanged(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
 938 }
 939 
<a name="55" id="anc55"></a><span class="line-modified"> 940 bool WebGLRenderingContextBase::clearIfComposited(GCGLbitfield mask)</span>
 941 {
 942     if (isContextLostOrPending())
 943         return false;
 944 
 945     if (!m_context-&gt;layerComposited() || m_layerCleared
 946         || m_attributes.preserveDrawingBuffer || (mask &amp;&amp; m_framebufferBinding)
 947         || m_preventBufferClearForInspector)
 948         return false;
 949 
 950     auto contextAttributes = getContextAttributes();
 951     ASSERT(contextAttributes);
 952 
 953     // Determine if it&#39;s possible to combine the clear the user asked for and this clear.
 954     bool combinedClear = mask &amp;&amp; !m_scissorEnabled;
 955 
<a name="56" id="anc56"></a><span class="line-modified"> 956     m_context-&gt;disable(GraphicsContextGL::SCISSOR_TEST);</span>
<span class="line-modified"> 957     if (combinedClear &amp;&amp; (mask &amp; GraphicsContextGL::COLOR_BUFFER_BIT)) {</span>
 958         m_context-&gt;clearColor(m_colorMask[0] ? m_clearColor[0] : 0,
 959                               m_colorMask[1] ? m_clearColor[1] : 0,
 960                               m_colorMask[2] ? m_clearColor[2] : 0,
 961                               m_colorMask[3] ? m_clearColor[3] : 0);
<a name="57" id="anc57"></a><span class="line-modified"> 962     } else</span>
 963         m_context-&gt;clearColor(0, 0, 0, 0);
 964     m_context-&gt;colorMask(true, true, true, true);
<a name="58" id="anc58"></a><span class="line-modified"> 965     GCGLbitfield clearMask = GraphicsContextGL::COLOR_BUFFER_BIT;</span>
 966     if (contextAttributes-&gt;depth) {
<a name="59" id="anc59"></a><span class="line-modified"> 967         if (!combinedClear || !m_depthMask || !(mask &amp; GraphicsContextGL::DEPTH_BUFFER_BIT))</span>
 968             m_context-&gt;clearDepth(1.0f);
<a name="60" id="anc60"></a><span class="line-modified"> 969         clearMask |= GraphicsContextGL::DEPTH_BUFFER_BIT;</span>
 970         m_context-&gt;depthMask(true);
 971     }
 972     if (contextAttributes-&gt;stencil) {
<a name="61" id="anc61"></a><span class="line-modified"> 973         if (combinedClear &amp;&amp; (mask &amp; GraphicsContextGL::STENCIL_BUFFER_BIT))</span>
 974             m_context-&gt;clearStencil(m_clearStencil &amp; m_stencilMask);
 975         else
 976             m_context-&gt;clearStencil(0);
<a name="62" id="anc62"></a><span class="line-modified"> 977         clearMask |= GraphicsContextGL::STENCIL_BUFFER_BIT;</span>
<span class="line-modified"> 978         m_context-&gt;stencilMaskSeparate(GraphicsContextGL::FRONT, 0xFFFFFFFF);</span>
 979     }
 980     if (m_framebufferBinding)
<a name="63" id="anc63"></a><span class="line-modified"> 981         m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, 0);</span>
 982     m_context-&gt;clear(clearMask);
 983 
 984     restoreStateAfterClear();
 985     if (m_framebufferBinding)
<a name="64" id="anc64"></a><span class="line-modified"> 986         m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));</span>
 987     m_layerCleared = true;
 988 
 989     return combinedClear;
 990 }
 991 
 992 void WebGLRenderingContextBase::restoreStateAfterClear()
 993 {
 994     // Restore the state that the context set.
 995     if (m_scissorEnabled)
<a name="65" id="anc65"></a><span class="line-modified"> 996         m_context-&gt;enable(GraphicsContextGL::SCISSOR_TEST);</span>
 997     m_context-&gt;clearColor(m_clearColor[0], m_clearColor[1],
 998                           m_clearColor[2], m_clearColor[3]);
 999     m_context-&gt;colorMask(m_colorMask[0], m_colorMask[1],
1000                          m_colorMask[2], m_colorMask[3]);
1001     m_context-&gt;clearDepth(m_clearDepth);
1002     m_context-&gt;clearStencil(m_clearStencil);
<a name="66" id="anc66"></a><span class="line-modified">1003     m_context-&gt;stencilMaskSeparate(GraphicsContextGL::FRONT, m_stencilMask);</span>
1004     m_context-&gt;depthMask(m_depthMask);
1005 }
1006 
1007 void WebGLRenderingContextBase::markLayerComposited()
1008 {
1009     if (isContextLostOrPending())
1010         return;
1011     m_context-&gt;markLayerComposited();
1012 }
1013 
1014 void WebGLRenderingContextBase::paintRenderingResultsToCanvas()
1015 {
1016     if (isContextLostOrPending())
1017         return;
1018 
1019     auto* canvas = htmlCanvas();
1020     if (!canvas)
1021         return;
1022 
1023     if (canvas-&gt;document().printing())
1024         canvas-&gt;clearPresentationCopy();
1025 
1026     // Until the canvas is written to by the application, the clear that
1027     // happened after it was composited should be ignored by the compositor.
1028     if (m_context-&gt;layerComposited() &amp;&amp; !m_attributes.preserveDrawingBuffer) {
1029         m_context-&gt;paintCompositedResultsToCanvas(canvas-&gt;buffer());
1030 
1031         canvas-&gt;makePresentationCopy();
1032     } else
1033         canvas-&gt;clearPresentationCopy();
1034     clearIfComposited();
1035 
1036     if (!m_markedCanvasDirty &amp;&amp; !m_layerCleared)
1037         return;
1038 
1039     canvas-&gt;clearCopiedImage();
1040     m_markedCanvasDirty = false;
1041 
1042     m_context-&gt;paintRenderingResultsToCanvas(canvas-&gt;buffer());
1043 }
1044 
1045 RefPtr&lt;ImageData&gt; WebGLRenderingContextBase::paintRenderingResultsToImageData()
1046 {
1047     if (isContextLostOrPending())
1048         return nullptr;
1049     clearIfComposited();
1050     return m_context-&gt;paintRenderingResultsToImageData();
1051 }
1052 
1053 WebGLTexture::TextureExtensionFlag WebGLRenderingContextBase::textureExtensionFlags() const
1054 {
1055     return static_cast&lt;WebGLTexture::TextureExtensionFlag&gt;((m_oesTextureFloatLinear ? WebGLTexture::TextureExtensionFloatLinearEnabled : 0) | (m_oesTextureHalfFloatLinear ? WebGLTexture::TextureExtensionHalfFloatLinearEnabled : 0));
1056 }
1057 
1058 void WebGLRenderingContextBase::reshape(int width, int height)
1059 {
1060     if (isContextLostOrPending())
1061         return;
1062 
1063     // This is an approximation because at WebGLRenderingContext level we don&#39;t
1064     // know if the underlying FBO uses textures or renderbuffers.
<a name="67" id="anc67"></a><span class="line-modified">1065     GCGLint maxSize = std::min(m_maxTextureSize, m_maxRenderbufferSize);</span>
<span class="line-modified">1066     GCGLint maxWidth = std::min(maxSize, m_maxViewportDims[0]);</span>
<span class="line-modified">1067     GCGLint maxHeight = std::min(maxSize, m_maxViewportDims[1]);</span>
1068     width = clamp(width, 1, maxWidth);
1069     height = clamp(height, 1, maxHeight);
1070 
1071     if (m_needsUpdate) {
1072         notifyCanvasContentChanged();
1073         m_needsUpdate = false;
1074     }
1075 
1076     // We don&#39;t have to mark the canvas as dirty, since the newly created image buffer will also start off
1077     // clear (and this matches what reshape will do).
1078     m_context-&gt;reshape(width, height);
1079 
1080     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
<a name="68" id="anc68"></a><span class="line-modified">1081     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, objectOrZero(textureUnit.texture2DBinding.get()));</span>
1082     if (textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(textureExtensionFlags()))
1083         m_unrenderableTextureUnits.add(m_activeTextureUnit);
<a name="69" id="anc69"></a><span class="line-modified">1084     m_context-&gt;bindRenderbuffer(GraphicsContextGL::RENDERBUFFER, objectOrZero(m_renderbufferBinding.get()));</span>
1085     if (m_framebufferBinding)
<a name="70" id="anc70"></a><span class="line-modified">1086         m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));</span>
1087 }
1088 
1089 int WebGLRenderingContextBase::drawingBufferWidth() const
1090 {
1091     if (isContextLost())
1092         return 0;
1093 
1094     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution)
1095         return 0;
1096 
1097     return m_context-&gt;getInternalFramebufferSize().width();
1098 }
1099 
1100 int WebGLRenderingContextBase::drawingBufferHeight() const
1101 {
1102     if (isContextLost())
1103         return 0;
1104 
1105     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution)
1106         return 0;
1107 
1108     return m_context-&gt;getInternalFramebufferSize().height();
1109 }
1110 
<a name="71" id="anc71"></a><span class="line-modified">1111 unsigned WebGLRenderingContextBase::sizeInBytes(GCGLenum type)</span>
1112 {
1113     switch (type) {
<a name="72" id="anc72"></a><span class="line-modified">1114     case GraphicsContextGL::BYTE:</span>
<span class="line-modified">1115         return sizeof(GCGLbyte);</span>
<span class="line-modified">1116     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">1117         return sizeof(GCGLubyte);</span>
<span class="line-modified">1118     case GraphicsContextGL::SHORT:</span>
<span class="line-modified">1119         return sizeof(GCGLshort);</span>
<span class="line-modified">1120     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="line-modified">1121         return sizeof(GCGLushort);</span>
<span class="line-modified">1122     case GraphicsContextGL::INT:</span>
<span class="line-modified">1123         return sizeof(GCGLint);</span>
<span class="line-modified">1124     case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="line-modified">1125         return sizeof(GCGLuint);</span>
<span class="line-modified">1126     case GraphicsContextGL::FLOAT:</span>
<span class="line-modified">1127         return sizeof(GCGLfloat);</span>
1128     }
1129     ASSERT_NOT_REACHED();
1130     return 0;
1131 }
1132 
<a name="73" id="anc73"></a><span class="line-modified">1133 void WebGLRenderingContextBase::activeTexture(GCGLenum texture)</span>
1134 {
1135     if (isContextLostOrPending())
1136         return;
<a name="74" id="anc74"></a><span class="line-modified">1137     if (texture - GraphicsContextGL::TEXTURE0 &gt;= m_textureUnits.size()) {</span>
<span class="line-modified">1138         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;activeTexture&quot;, &quot;texture unit out of range&quot;);</span>
1139         return;
1140     }
<a name="75" id="anc75"></a><span class="line-modified">1141     m_activeTextureUnit = texture - GraphicsContextGL::TEXTURE0;</span>
1142     m_context-&gt;activeTexture(texture);
1143 }
1144 
1145 void WebGLRenderingContextBase::attachShader(WebGLProgram* program, WebGLShader* shader)
1146 {
1147     if (isContextLostOrPending() || !validateWebGLObject(&quot;attachShader&quot;, program) || !validateWebGLObject(&quot;attachShader&quot;, shader))
1148         return;
1149     if (!program-&gt;attachShader(shader)) {
<a name="76" id="anc76"></a><span class="line-modified">1150         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;attachShader&quot;, &quot;shader attachment already has shader&quot;);</span>
1151         return;
1152     }
1153     m_context-&gt;attachShader(objectOrZero(program), objectOrZero(shader));
1154     shader-&gt;onAttached();
1155 }
1156 
<a name="77" id="anc77"></a><span class="line-modified">1157 void WebGLRenderingContextBase::bindAttribLocation(WebGLProgram* program, GCGLuint index, const String&amp; name)</span>
1158 {
1159     if (isContextLostOrPending() || !validateWebGLObject(&quot;bindAttribLocation&quot;, program))
1160         return;
1161     if (!validateLocationLength(&quot;bindAttribLocation&quot;, name))
1162         return;
1163     if (!validateString(&quot;bindAttribLocation&quot;, name))
1164         return;
1165     if (isPrefixReserved(name)) {
<a name="78" id="anc78"></a><span class="line-modified">1166         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;bindAttribLocation&quot;, &quot;reserved prefix&quot;);</span>
1167         return;
1168     }
1169     if (index &gt;= m_maxVertexAttribs) {
<a name="79" id="anc79"></a><span class="line-modified">1170         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bindAttribLocation&quot;, &quot;index out of range&quot;);</span>
1171         return;
1172     }
1173     m_context-&gt;bindAttribLocation(objectOrZero(program), index, name);
1174 }
1175 
1176 bool WebGLRenderingContextBase::checkObjectToBeBound(const char* functionName, WebGLObject* object, bool&amp; deleted)
1177 {
1178     deleted = false;
1179     if (isContextLostOrPending())
1180         return false;
1181     if (object) {
1182         if (!object-&gt;validate(contextGroup(), *this)) {
<a name="80" id="anc80"></a><span class="line-modified">1183             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;object not from this context&quot;);</span>
1184             return false;
1185         }
1186         deleted = !object-&gt;object();
1187     }
1188     return true;
1189 }
1190 
<a name="81" id="anc81"></a><span class="line-modified">1191 bool WebGLRenderingContextBase::validateAndCacheBufferBinding(const char* functionName, GCGLenum target, WebGLBuffer* buffer)</span>
1192 {
1193     bool deleted;
<a name="82" id="anc82"></a><span class="line-modified">1194     if (!checkObjectToBeBound(functionName, buffer, deleted))</span>
<span class="line-modified">1195         return false;</span>
1196     if (deleted)
1197         buffer = nullptr;
<a name="83" id="anc83"></a><span class="line-modified">1198 </span>
<span class="line-modified">1199     if (buffer) {</span>
<span class="line-modified">1200         // In WebGL, a buffer may only be bound to one of the ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target in its lifetime.</span>
<span class="line-added">1201         if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER) {</span>
<span class="line-added">1202             if (buffer-&gt;arrayBufferOrElementArrayBuffer() &amp;&amp; target != buffer-&gt;arrayBufferOrElementArrayBuffer()) {</span>
<span class="line-added">1203                 synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;buffers can only be bound to one of ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER&quot;);</span>
<span class="line-added">1204                 return false;</span>
<span class="line-added">1205             }</span>
<span class="line-added">1206         }</span>
<span class="line-added">1207 </span>
<span class="line-added">1208         buffer-&gt;setTarget(target);</span>
1209     }
<a name="84" id="anc84"></a><span class="line-modified">1210 </span>
<span class="line-added">1211     if (target == GraphicsContextGL::ARRAY_BUFFER)</span>
1212         m_boundArrayBuffer = buffer;
<a name="85" id="anc85"></a><span class="line-modified">1213     else if (target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER)</span>
1214         m_boundVertexArrayObject-&gt;setElementArrayBuffer(buffer);
1215     else {
1216         bool success = false;
1217 #if ENABLE(WEBGL2)
1218         if (isWebGL2()) {
1219             success = true;
1220             switch (target) {
<a name="86" id="anc86"></a><span class="line-modified">1221             case GraphicsContextGL::COPY_READ_BUFFER:</span>
1222                 m_boundCopyReadBuffer = buffer;
1223                 break;
<a name="87" id="anc87"></a><span class="line-modified">1224             case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
1225                 m_boundCopyWriteBuffer = buffer;
1226                 break;
<a name="88" id="anc88"></a><span class="line-modified">1227             case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
1228                 m_boundPixelPackBuffer = buffer;
1229                 break;
<a name="89" id="anc89"></a><span class="line-modified">1230             case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
1231                 m_boundPixelUnpackBuffer = buffer;
1232                 break;
<a name="90" id="anc90"></a><span class="line-modified">1233             case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
1234                 m_boundTransformFeedbackBuffer = buffer;
1235                 break;
<a name="91" id="anc91"></a><span class="line-modified">1236             case GraphicsContextGL::UNIFORM_BUFFER:</span>
1237                 m_boundUniformBuffer = buffer;
1238                 break;
1239             default:
1240                 success = false;
1241                 break;
1242             }
1243         }
1244 #endif
1245         if (!success) {
<a name="92" id="anc92"></a><span class="line-modified">1246             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindBuffer&quot;, &quot;invalid target&quot;);</span>
<span class="line-modified">1247             return false;</span>
1248         }
1249     }
1250 
<a name="93" id="anc93"></a><span class="line-added">1251     return true;</span>
<span class="line-added">1252 }</span>
<span class="line-added">1253 </span>
<span class="line-added">1254 void WebGLRenderingContextBase::bindBuffer(GCGLenum target, WebGLBuffer* buffer)</span>
<span class="line-added">1255 {</span>
<span class="line-added">1256     if (!validateAndCacheBufferBinding(&quot;bindBuffer&quot;, target, buffer))</span>
<span class="line-added">1257         return;</span>
<span class="line-added">1258 </span>
1259     m_context-&gt;bindBuffer(target, objectOrZero(buffer));
<a name="94" id="anc94"></a>

1260 }
1261 
<a name="95" id="anc95"></a><span class="line-modified">1262 void WebGLRenderingContextBase::bindFramebuffer(GCGLenum target, WebGLFramebuffer* buffer)</span>
1263 {
1264     bool deleted;
1265     if (!checkObjectToBeBound(&quot;bindFramebuffer&quot;, buffer, deleted))
1266         return;
1267     if (deleted)
1268         buffer = 0;
1269 
1270     bool isWebGL2DrawFramebufferTarget = false;
1271 #if ENABLE(WEBGL2)
<a name="96" id="anc96"></a><span class="line-modified">1272     isWebGL2DrawFramebufferTarget = isWebGL2() &amp;&amp; target == GraphicsContextGL::DRAW_FRAMEBUFFER;</span>
1273 #endif
1274     bool success = false;
1275 
<a name="97" id="anc97"></a><span class="line-modified">1276     if (target == GraphicsContextGL::FRAMEBUFFER || isWebGL2DrawFramebufferTarget) {</span>
1277         m_framebufferBinding = buffer;
1278         success = true;
1279     }
1280 #if ENABLE(WEBGL2)
<a name="98" id="anc98"></a><span class="line-modified">1281     if (isWebGL2() &amp;&amp; (target == GraphicsContextGL::FRAMEBUFFER || target == GraphicsContextGL::READ_FRAMEBUFFER)) {</span>
1282         m_readFramebufferBinding = buffer;
1283         success = true;
1284     }
1285 #endif
1286 
1287     if (!success) {
<a name="99" id="anc99"></a><span class="line-modified">1288         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindFramebuffer&quot;, &quot;invalid target&quot;);</span>
1289         return;
1290     }
1291 
1292     m_context-&gt;bindFramebuffer(target, objectOrZero(buffer));
1293     if (buffer)
1294         buffer-&gt;setHasEverBeenBound();
1295     applyStencilTest();
1296 }
1297 
<a name="100" id="anc100"></a><span class="line-modified">1298 void WebGLRenderingContextBase::bindRenderbuffer(GCGLenum target, WebGLRenderbuffer* renderBuffer)</span>
1299 {
1300     bool deleted;
1301     if (!checkObjectToBeBound(&quot;bindRenderbuffer&quot;, renderBuffer, deleted))
1302         return;
1303     if (deleted)
1304         renderBuffer = 0;
<a name="101" id="anc101"></a><span class="line-modified">1305     if (target != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="line-modified">1306         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindRenderbuffer&quot;, &quot;invalid target&quot;);</span>
1307         return;
1308     }
1309     m_renderbufferBinding = renderBuffer;
1310     m_context-&gt;bindRenderbuffer(target, objectOrZero(renderBuffer));
1311     if (renderBuffer)
1312         renderBuffer-&gt;setHasEverBeenBound();
1313 }
1314 
<a name="102" id="anc102"></a><span class="line-modified">1315 void WebGLRenderingContextBase::bindTexture(GCGLenum target, WebGLTexture* texture)</span>
1316 {
1317     bool deleted;
1318     if (!checkObjectToBeBound(&quot;bindTexture&quot;, texture, deleted))
1319         return;
1320     if (deleted)
1321         texture = nullptr;
1322     if (texture &amp;&amp; texture-&gt;getTarget() &amp;&amp; texture-&gt;getTarget() != target) {
<a name="103" id="anc103"></a><span class="line-modified">1323         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;bindTexture&quot;, &quot;textures can not be used with multiple targets&quot;);</span>
1324         return;
1325     }
<a name="104" id="anc104"></a><span class="line-modified">1326     GCGLint maxLevel = 0;</span>
1327     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
<a name="105" id="anc105"></a><span class="line-modified">1328     if (target == GraphicsContextGL::TEXTURE_2D) {</span>
1329         textureUnit.texture2DBinding = texture;
1330         maxLevel = m_maxTextureLevel;
1331         if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
1332             m_unrenderableTextureUnits.add(m_activeTextureUnit);
1333         else
1334             m_unrenderableTextureUnits.remove(m_activeTextureUnit);
<a name="106" id="anc106"></a><span class="line-modified">1335     } else if (target == GraphicsContextGL::TEXTURE_CUBE_MAP) {</span>
1336         textureUnit.textureCubeMapBinding = texture;
1337         maxLevel = m_maxCubeMapTextureLevel;
1338         if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
1339             m_unrenderableTextureUnits.add(m_activeTextureUnit);
1340         else
1341             m_unrenderableTextureUnits.remove(m_activeTextureUnit);
1342     } else {
<a name="107" id="anc107"></a><span class="line-modified">1343         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindTexture&quot;, &quot;invalid target&quot;);</span>
1344         return;
1345     }
1346     m_context-&gt;bindTexture(target, objectOrZero(texture));
1347     if (texture)
1348         texture-&gt;setTarget(target, maxLevel);
1349 
1350     // Note: previously we used to automatically set the TEXTURE_WRAP_R
1351     // repeat mode to CLAMP_TO_EDGE for cube map textures, because OpenGL
1352     // ES 2.0 doesn&#39;t expose this flag (a bug in the specification) and
1353     // otherwise the application has no control over the seams in this
1354     // dimension. However, it appears that supporting this properly on all
1355     // platforms is fairly involved (will require a HashMap from texture ID
1356     // in all ports), and we have not had any complaints, so the logic has
1357     // been removed.
1358 }
1359 
<a name="108" id="anc108"></a><span class="line-modified">1360 void WebGLRenderingContextBase::blendColor(GCGLfloat red, GCGLfloat green, GCGLfloat blue, GCGLfloat alpha)</span>
1361 {
1362     if (isContextLostOrPending())
1363         return;
1364     m_context-&gt;blendColor(red, green, blue, alpha);
1365 }
1366 
<a name="109" id="anc109"></a><span class="line-modified">1367 void WebGLRenderingContextBase::blendEquation(GCGLenum mode)</span>
1368 {
1369     if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, mode))
1370         return;
1371     m_context-&gt;blendEquation(mode);
1372 }
1373 
<a name="110" id="anc110"></a><span class="line-modified">1374 void WebGLRenderingContextBase::blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha)</span>
1375 {
1376     if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, modeRGB) || !validateBlendEquation(&quot;blendEquation&quot;, modeAlpha))
1377         return;
1378     m_context-&gt;blendEquationSeparate(modeRGB, modeAlpha);
1379 }
1380 
1381 
<a name="111" id="anc111"></a><span class="line-modified">1382 void WebGLRenderingContextBase::blendFunc(GCGLenum sfactor, GCGLenum dfactor)</span>
1383 {
1384     if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, sfactor, dfactor))
1385         return;
1386     m_context-&gt;blendFunc(sfactor, dfactor);
1387 }
1388 
<a name="112" id="anc112"></a><span class="line-modified">1389 void WebGLRenderingContextBase::blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha)</span>
1390 {
1391     // Note: Alpha does not have the same restrictions as RGB.
1392     if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, srcRGB, dstRGB))
1393         return;
1394     m_context-&gt;blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
1395 }
1396 
<a name="113" id="anc113"></a><span class="line-modified">1397 void WebGLRenderingContextBase::bufferData(GCGLenum target, long long size, GCGLenum usage)</span>
1398 {
1399     if (isContextLostOrPending())
1400         return;
1401     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
1402     if (!buffer)
1403         return;
1404     if (size &lt; 0) {
<a name="114" id="anc114"></a><span class="line-modified">1405         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;size &lt; 0&quot;);</span>
1406         return;
1407     }
1408     if (!size) {
<a name="115" id="anc115"></a><span class="line-modified">1409         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;size == 0&quot;);</span>
1410         return;
1411     }
<a name="116" id="anc116"></a><span class="line-modified">1412     if (!buffer-&gt;associateBufferData(static_cast&lt;GCGLsizeiptr&gt;(size))) {</span>
<span class="line-modified">1413         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);</span>
1414         return;
1415     }
1416 
1417     m_context-&gt;moveErrorsToSyntheticErrorList();
<a name="117" id="anc117"></a><span class="line-modified">1418     m_context-&gt;bufferData(target, static_cast&lt;GCGLsizeiptr&gt;(size), usage);</span>
1419     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1420         // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1421         buffer-&gt;disassociateBufferData();
1422     }
1423 }
1424 
<a name="118" id="anc118"></a><span class="line-modified">1425 void WebGLRenderingContextBase::bufferData(GCGLenum target, Optional&lt;BufferDataSource&gt;&amp;&amp; data, GCGLenum usage)</span>
1426 {
1427     if (isContextLostOrPending())
1428         return;
1429     if (!data) {
<a name="119" id="anc119"></a><span class="line-modified">1430         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;null data&quot;);</span>
1431         return;
1432     }
1433     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
1434     if (!buffer)
1435         return;
1436 
1437     WTF::visit([&amp;](auto&amp; data) {
1438         if (!buffer-&gt;associateBufferData(data.get())) {
<a name="120" id="anc120"></a><span class="line-modified">1439             this-&gt;synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);</span>
1440             return;
1441         }
1442 
1443         m_context-&gt;moveErrorsToSyntheticErrorList();
1444         m_context-&gt;bufferData(target, data-&gt;byteLength(), data-&gt;data(), usage);
1445         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1446             // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1447             buffer-&gt;disassociateBufferData();
1448         }
1449     }, data.value());
1450 }
1451 
<a name="121" id="anc121"></a><span class="line-modified">1452 void WebGLRenderingContextBase::bufferSubData(GCGLenum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp; data)</span>
1453 {
1454     if (isContextLostOrPending())
1455         return;
<a name="122" id="anc122"></a><span class="line-modified">1456     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferSubData&quot;, target, GraphicsContextGL::STATIC_DRAW);</span>
1457     if (!buffer)
1458         return;
1459     if (offset &lt; 0) {
<a name="123" id="anc123"></a><span class="line-modified">1460         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset &lt; 0&quot;);</span>
1461         return;
1462     }
1463     if (!data)
1464         return;
1465 
1466     WTF::visit([&amp;](auto&amp; data) {
<a name="124" id="anc124"></a><span class="line-modified">1467         if (!buffer-&gt;associateBufferSubData(static_cast&lt;GCGLintptr&gt;(offset), data.get())) {</span>
<span class="line-modified">1468             this-&gt;synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset out of range&quot;);</span>
1469             return;
1470         }
1471 
1472         m_context-&gt;moveErrorsToSyntheticErrorList();
<a name="125" id="anc125"></a><span class="line-modified">1473         m_context-&gt;bufferSubData(target, static_cast&lt;GCGLintptr&gt;(offset), data-&gt;byteLength(), data-&gt;data());</span>
1474         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1475             // The bufferSubData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1476             buffer-&gt;disassociateBufferData();
1477         }
1478     }, data.value());
1479 }
1480 
<a name="126" id="anc126"></a><span class="line-modified">1481 GCGLenum WebGLRenderingContextBase::checkFramebufferStatus(GCGLenum target)</span>
1482 {
1483     if (isContextLostOrPending())
<a name="127" id="anc127"></a><span class="line-modified">1484         return GraphicsContextGL::FRAMEBUFFER_UNSUPPORTED;</span>
<span class="line-modified">1485     if (target != GraphicsContextGL::FRAMEBUFFER) {</span>
1486 #if ENABLE(WEBGL2)
<a name="128" id="anc128"></a><span class="line-modified">1487         if (isWebGL1() || (target != GraphicsContextGL::DRAW_FRAMEBUFFER &amp;&amp; target != GraphicsContextGL::READ_FRAMEBUFFER)) {</span>
1488 #endif
<a name="129" id="anc129"></a><span class="line-modified">1489             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;checkFramebufferStatus&quot;, &quot;invalid target&quot;);</span>
1490             return 0;
1491 #if ENABLE(WEBGL2)
1492         }
1493 #endif
1494     }
1495 
<a name="130" id="anc130"></a><span class="line-modified">1496     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
1497 
1498     if (!targetFramebuffer || !targetFramebuffer-&gt;object())
<a name="131" id="anc131"></a><span class="line-modified">1499         return GraphicsContextGL::FRAMEBUFFER_COMPLETE;</span>
1500     const char* reason = &quot;framebuffer incomplete&quot;;
<a name="132" id="anc132"></a><span class="line-modified">1501     GCGLenum result = targetFramebuffer-&gt;checkStatus(&amp;reason);</span>
<span class="line-modified">1502     if (result != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
1503         String str = &quot;WebGL: checkFramebufferStatus:&quot; + String(reason);
1504         printToConsole(MessageLevel::Warning, str);
1505         return result;
1506     }
1507     result = m_context-&gt;checkFramebufferStatus(target);
1508     return result;
1509 }
1510 
<a name="133" id="anc133"></a><span class="line-modified">1511 void WebGLRenderingContextBase::clearColor(GCGLfloat r, GCGLfloat g, GCGLfloat b, GCGLfloat a)</span>
1512 {
1513     if (isContextLostOrPending())
1514         return;
1515     if (std::isnan(r))
1516         r = 0;
1517     if (std::isnan(g))
1518         g = 0;
1519     if (std::isnan(b))
1520         b = 0;
1521     if (std::isnan(a))
1522         a = 1;
1523     m_clearColor[0] = r;
1524     m_clearColor[1] = g;
1525     m_clearColor[2] = b;
1526     m_clearColor[3] = a;
1527     m_context-&gt;clearColor(r, g, b, a);
1528 }
1529 
<a name="134" id="anc134"></a><span class="line-modified">1530 void WebGLRenderingContextBase::clearDepth(GCGLfloat depth)</span>
1531 {
1532     if (isContextLostOrPending())
1533         return;
1534     m_clearDepth = depth;
1535     m_context-&gt;clearDepth(depth);
1536 }
1537 
<a name="135" id="anc135"></a><span class="line-modified">1538 void WebGLRenderingContextBase::clearStencil(GCGLint s)</span>
1539 {
1540     if (isContextLostOrPending())
1541         return;
1542     m_clearStencil = s;
1543     m_context-&gt;clearStencil(s);
1544 }
1545 
<a name="136" id="anc136"></a><span class="line-modified">1546 void WebGLRenderingContextBase::colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha)</span>
1547 {
1548     if (isContextLostOrPending())
1549         return;
1550     m_colorMask[0] = red;
1551     m_colorMask[1] = green;
1552     m_colorMask[2] = blue;
1553     m_colorMask[3] = alpha;
1554     m_context-&gt;colorMask(red, green, blue, alpha);
1555 }
1556 
1557 void WebGLRenderingContextBase::compileShader(WebGLShader* shader)
1558 {
1559     if (isContextLostOrPending() || !validateWebGLObject(&quot;compileShader&quot;, shader))
1560         return;
1561     m_context-&gt;compileShader(objectOrZero(shader));
<a name="137" id="anc137"></a><span class="line-modified">1562     GCGLint value;</span>
<span class="line-modified">1563     m_context-&gt;getShaderiv(objectOrZero(shader), GraphicsContextGL::COMPILE_STATUS, &amp;value);</span>
1564     shader-&gt;setValid(value);
1565 
1566     auto* canvas = htmlCanvas();
1567 
1568     if (canvas &amp;&amp; m_synthesizedErrorsToConsole &amp;&amp; !value) {
1569         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
1570 
1571         for (auto&amp; error : getShaderInfoLog(shader).split(&#39;\n&#39;))
1572             canvas-&gt;document().addConsoleMessage(makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Error, &quot;WebGL: &quot; + error, stackTrace.copyRef()));
1573     }
1574 }
1575 
<a name="138" id="anc138"></a><span class="line-modified">1576 void WebGLRenderingContextBase::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, ArrayBufferView&amp; data)</span>
1577 {
1578     if (isContextLostOrPending())
1579         return;
1580     if (!validateTexFuncLevel(&quot;compressedTexImage2D&quot;, target, level))
1581         return;
1582 
1583     if (!validateCompressedTexFormat(internalformat)) {
<a name="139" id="anc139"></a><span class="line-modified">1584         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;compressedTexImage2D&quot;, &quot;invalid internalformat&quot;);</span>
1585         return;
1586     }
1587     if (border) {
<a name="140" id="anc140"></a><span class="line-modified">1588         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;compressedTexImage2D&quot;, &quot;border not 0&quot;);</span>
1589         return;
1590     }
1591     if (!validateCompressedTexDimensions(&quot;compressedTexImage2D&quot;, target, level, width, height, internalformat))
1592         return;
1593     if (!validateCompressedTexFuncData(&quot;compressedTexImage2D&quot;, width, height, internalformat, data))
1594         return;
1595 
1596     auto tex = validateTextureBinding(&quot;compressedTexImage2D&quot;, target, true);
1597     if (!tex)
1598         return;
1599     if (!validateNPOTTextureLevel(width, height, level, &quot;compressedTexImage2D&quot;))
1600         return;
1601     m_context-&gt;moveErrorsToSyntheticErrorList();
1602     m_context-&gt;compressedTexImage2D(target, level, internalformat, width, height,
1603         border, data.byteLength(), data.baseAddress());
1604     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1605         // The compressedTexImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
1606         tex-&gt;markInvalid(target, level);
1607         return;
1608     }
1609 
<a name="141" id="anc141"></a><span class="line-modified">1610     tex-&gt;setLevelInfo(target, level, internalformat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
1611     tex-&gt;setCompressed();
1612 }
1613 
<a name="142" id="anc142"></a><span class="line-modified">1614 void WebGLRenderingContextBase::compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; data)</span>
1615 {
1616     if (isContextLostOrPending())
1617         return;
1618     if (!validateTexFuncLevel(&quot;compressedTexSubImage2D&quot;, target, level))
1619         return;
1620     if (!validateCompressedTexFormat(format)) {
<a name="143" id="anc143"></a><span class="line-modified">1621         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;compressedTexSubImage2D&quot;, &quot;invalid format&quot;);</span>
1622         return;
1623     }
1624     if (!validateCompressedTexFuncData(&quot;compressedTexSubImage2D&quot;, width, height, format, data))
1625         return;
1626 
1627     auto tex = validateTextureBinding(&quot;compressedTexSubImage2D&quot;, target, true);
1628     if (!tex)
1629         return;
1630 
1631     if (format != tex-&gt;getInternalFormat(target, level)) {
<a name="144" id="anc144"></a><span class="line-modified">1632         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;compressedTexSubImage2D&quot;, &quot;format does not match texture format&quot;);</span>
1633         return;
1634     }
1635 
1636     if (!validateCompressedTexSubDimensions(&quot;compressedTexSubImage2D&quot;, target, level, xoffset, yoffset, width, height, format, tex.get()))
1637         return;
1638 
<a name="145" id="anc145"></a><span class="line-modified">1639     graphicsContextGL()-&gt;compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data.byteLength(), data.baseAddress());</span>
1640     tex-&gt;setCompressed();
1641 }
1642 
<a name="146" id="anc146"></a><span class="line-modified">1643 bool WebGLRenderingContextBase::validateSettableTexInternalFormat(const char* functionName, GCGLenum internalFormat)</span>
1644 {
1645     switch (internalFormat) {
<a name="147" id="anc147"></a><span class="line-modified">1646     case GraphicsContextGL::DEPTH_COMPONENT:</span>
<span class="line-modified">1647     case GraphicsContextGL::DEPTH_STENCIL:</span>
<span class="line-modified">1648     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="line-modified">1649     case GraphicsContextGL::DEPTH_COMPONENT24:</span>
<span class="line-modified">1650     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
<span class="line-modified">1651     case GraphicsContextGL::DEPTH24_STENCIL8:</span>
<span class="line-modified">1652     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
<span class="line-modified">1653     case GraphicsContextGL::STENCIL_INDEX8:</span>
<span class="line-modified">1654         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;format can not be set, only rendered to&quot;);</span>
1655         return false;
1656     default:
1657         return true;
1658     }
1659 }
1660 
<a name="148" id="anc148"></a><span class="line-modified">1661 void WebGLRenderingContextBase::copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)</span>
1662 {
1663     if (isContextLostOrPending())
1664         return;
1665     if (!validateTexFuncLevel(&quot;copyTexSubImage2D&quot;, target, level))
1666         return;
1667     auto tex = validateTextureBinding(&quot;copyTexSubImage2D&quot;, target, true);
1668     if (!tex)
1669         return;
1670     if (!validateSize(&quot;copyTexSubImage2D&quot;, xoffset, yoffset) || !validateSize(&quot;copyTexSubImage2D&quot;, width, height))
1671         return;
1672     // Before checking if it is in the range, check if overflow happens first.
1673     if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
<a name="149" id="anc149"></a><span class="line-modified">1674         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);</span>
1675         return;
1676     }
1677     if (xoffset + width &gt; tex-&gt;getWidth(target, level) || yoffset + height &gt; tex-&gt;getHeight(target, level)) {
<a name="150" id="anc150"></a><span class="line-modified">1678         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;rectangle out of range&quot;);</span>
1679         return;
1680     }
<a name="151" id="anc151"></a><span class="line-modified">1681     GCGLenum internalFormat = tex-&gt;getInternalFormat(target, level);</span>
1682     if (!validateSettableTexInternalFormat(&quot;copyTexSubImage2D&quot;, internalFormat))
1683         return;
1684     if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
<a name="152" id="anc152"></a><span class="line-modified">1685         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;copyTexSubImage2D&quot;, &quot;framebuffer is incompatible format&quot;);</span>
1686         return;
1687     }
1688     const char* reason = &quot;framebuffer incomplete&quot;;
<a name="153" id="anc153"></a><span class="line-modified">1689     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="line-modified">1690         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexSubImage2D&quot;, reason);</span>
1691         return;
1692     }
1693     clearIfComposited();
1694 
<a name="154" id="anc154"></a><span class="line-modified">1695     GCGLint clippedX, clippedY;</span>
<span class="line-modified">1696     GCGLsizei clippedWidth, clippedHeight;</span>
1697     if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
<a name="155" id="anc155"></a><span class="line-modified">1698         GCGLenum format;</span>
<span class="line-modified">1699         GCGLenum type;</span>
<span class="line-modified">1700         if (!GraphicsContextGLOpenGL::possibleFormatAndTypeForInternalFormat(tex-&gt;getInternalFormat(target, level), format, type)) {</span>
<span class="line-modified">1701             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;copyTexSubImage2D&quot;, &quot;Texture has unknown internal format&quot;);</span>
1702             return;
1703         }
1704         UniqueArray&lt;unsigned char&gt; zero;
1705         if (width &amp;&amp; height) {
1706             unsigned size;
<a name="156" id="anc156"></a><span class="line-modified">1707             GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;size, nullptr);</span>
<span class="line-modified">1708             if (error != GraphicsContextGL::NO_ERROR) {</span>
1709                 synthesizeGLError(error, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);
1710                 return;
1711             }
1712             zero = makeUniqueArray&lt;unsigned char&gt;(size);
1713             if (!zero) {
<a name="157" id="anc157"></a><span class="line-modified">1714                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;out of memory&quot;);</span>
1715                 return;
1716             }
1717             memset(zero.get(), 0, size);
1718         }
1719         m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, zero.get());
1720         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0)
1721             m_context-&gt;copyTexSubImage2D(target, level, xoffset + clippedX - x, yoffset + clippedY - y, clippedX, clippedY, clippedWidth, clippedHeight);
1722     } else
1723         m_context-&gt;copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
1724 }
1725 
1726 RefPtr&lt;WebGLBuffer&gt; WebGLRenderingContextBase::createBuffer()
1727 {
1728     if (isContextLostOrPending())
1729         return nullptr;
1730     auto buffer = WebGLBuffer::create(*this);
1731     addSharedObject(buffer.get());
1732     return buffer;
1733 }
1734 
1735 RefPtr&lt;WebGLFramebuffer&gt; WebGLRenderingContextBase::createFramebuffer()
1736 {
1737     if (isContextLostOrPending())
1738         return nullptr;
1739     auto buffer = WebGLFramebuffer::create(*this);
1740     addContextObject(buffer.get());
1741     return buffer;
1742 }
1743 
1744 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::createTexture()
1745 {
1746     if (isContextLostOrPending())
1747         return nullptr;
1748     auto texture = WebGLTexture::create(*this);
1749     addSharedObject(texture.get());
1750     return texture;
1751 }
1752 
1753 RefPtr&lt;WebGLProgram&gt; WebGLRenderingContextBase::createProgram()
1754 {
1755     if (isContextLostOrPending())
1756         return nullptr;
1757     auto program = WebGLProgram::create(*this);
1758     addSharedObject(program.get());
1759 
<a name="158" id="anc158"></a><span class="line-modified">1760     InspectorInstrumentation::didCreateWebGLProgram(*this, program.get());</span>
1761 
1762     return program;
1763 }
1764 
1765 RefPtr&lt;WebGLRenderbuffer&gt; WebGLRenderingContextBase::createRenderbuffer()
1766 {
1767     if (isContextLostOrPending())
1768         return nullptr;
1769     auto buffer = WebGLRenderbuffer::create(*this);
1770     addSharedObject(buffer.get());
1771     return buffer;
1772 }
1773 
<a name="159" id="anc159"></a><span class="line-modified">1774 RefPtr&lt;WebGLShader&gt; WebGLRenderingContextBase::createShader(GCGLenum type)</span>
1775 {
1776     if (isContextLostOrPending())
1777         return nullptr;
<a name="160" id="anc160"></a><span class="line-modified">1778     if (type != GraphicsContextGL::VERTEX_SHADER &amp;&amp; type != GraphicsContextGL::FRAGMENT_SHADER) {</span>
<span class="line-modified">1779         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;createShader&quot;, &quot;invalid shader type&quot;);</span>
1780         return nullptr;
1781     }
1782 
1783     auto shader = WebGLShader::create(*this, type);
1784     addSharedObject(shader.get());
1785     return shader;
1786 }
1787 
<a name="161" id="anc161"></a><span class="line-modified">1788 void WebGLRenderingContextBase::cullFace(GCGLenum mode)</span>
1789 {
1790     if (isContextLostOrPending())
1791         return;
1792     m_context-&gt;cullFace(mode);
1793 }
1794 
1795 bool WebGLRenderingContextBase::deleteObject(WebGLObject* object)
1796 {
1797     if (isContextLostOrPending() || !object)
1798         return false;
1799     if (!object-&gt;validate(contextGroup(), *this)) {
<a name="162" id="anc162"></a><span class="line-modified">1800         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;delete&quot;, &quot;object does not belong to this context&quot;);</span>
1801         return false;
1802     }
1803     if (object-&gt;isDeleted())
1804         return false;
1805     if (object-&gt;object())
1806         // We need to pass in context here because we want
1807         // things in this context unbound.
<a name="163" id="anc163"></a><span class="line-modified">1808         object-&gt;deleteObject(graphicsContextGL());</span>
1809     return true;
1810 }
1811 
<a name="164" id="anc164"></a><span class="line-added">1812 #define REMOVE_BUFFER_FROM_BINDING(binding) \</span>
<span class="line-added">1813     if (binding == buffer) \</span>
<span class="line-added">1814         binding = nullptr;</span>
<span class="line-added">1815 </span>
<span class="line-added">1816 void WebGLRenderingContextBase::uncacheDeletedBuffer(WebGLBuffer* buffer)</span>
<span class="line-added">1817 {</span>
<span class="line-added">1818     REMOVE_BUFFER_FROM_BINDING(m_boundArrayBuffer);</span>
<span class="line-added">1819     REMOVE_BUFFER_FROM_BINDING(m_boundCopyReadBuffer);</span>
<span class="line-added">1820     REMOVE_BUFFER_FROM_BINDING(m_boundCopyWriteBuffer);</span>
<span class="line-added">1821     REMOVE_BUFFER_FROM_BINDING(m_boundPixelPackBuffer);</span>
<span class="line-added">1822     REMOVE_BUFFER_FROM_BINDING(m_boundPixelUnpackBuffer);</span>
<span class="line-added">1823     REMOVE_BUFFER_FROM_BINDING(m_boundTransformFeedbackBuffer);</span>
<span class="line-added">1824     REMOVE_BUFFER_FROM_BINDING(m_boundUniformBuffer);</span>
<span class="line-added">1825 </span>
<span class="line-added">1826     m_boundVertexArrayObject-&gt;unbindBuffer(*buffer);</span>
<span class="line-added">1827 }</span>
<span class="line-added">1828 </span>
1829 void WebGLRenderingContextBase::deleteBuffer(WebGLBuffer* buffer)
1830 {
1831     if (!deleteObject(buffer))
1832         return;
<a name="165" id="anc165"></a>

1833 
<a name="166" id="anc166"></a><span class="line-modified">1834     uncacheDeletedBuffer(buffer);</span>
1835 }
1836 
1837 void WebGLRenderingContextBase::deleteFramebuffer(WebGLFramebuffer* framebuffer)
1838 {
1839     if (!deleteObject(framebuffer))
1840         return;
1841 #if ENABLE(WEBGL2)
1842     if (isWebGL2() &amp;&amp; framebuffer == m_readFramebufferBinding) {
1843         m_readFramebufferBinding = nullptr;
<a name="167" id="anc167"></a><span class="line-modified">1844         m_context-&gt;bindFramebuffer(GraphicsContextGL::READ_FRAMEBUFFER, 0);</span>
1845     }
1846 #endif
1847     if (framebuffer == m_framebufferBinding) {
1848         m_framebufferBinding = nullptr;
1849 #if ENABLE(WEBGL2)
1850         if (isWebGL2())
<a name="168" id="anc168"></a><span class="line-modified">1851             m_context-&gt;bindFramebuffer(GraphicsContextGL::DRAW_FRAMEBUFFER, 0);</span>
1852         else
1853 #endif
<a name="169" id="anc169"></a><span class="line-modified">1854             m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, 0);</span>
1855     }
1856 }
1857 
1858 void WebGLRenderingContextBase::deleteProgram(WebGLProgram* program)
1859 {
1860     if (program)
<a name="170" id="anc170"></a><span class="line-modified">1861         InspectorInstrumentation::willDestroyWebGLProgram(*program);</span>
1862 
1863     deleteObject(program);
1864     // We don&#39;t reset m_currentProgram to 0 here because the deletion of the
1865     // current program is delayed.
1866 }
1867 
1868 void WebGLRenderingContextBase::deleteRenderbuffer(WebGLRenderbuffer* renderbuffer)
1869 {
1870     if (!deleteObject(renderbuffer))
1871         return;
1872     if (renderbuffer == m_renderbufferBinding)
1873         m_renderbufferBinding = nullptr;
1874     if (m_framebufferBinding)
1875         m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(renderbuffer);
1876 }
1877 
1878 void WebGLRenderingContextBase::deleteShader(WebGLShader* shader)
1879 {
1880     deleteObject(shader);
1881 }
1882 
1883 void WebGLRenderingContextBase::deleteTexture(WebGLTexture* texture)
1884 {
1885     if (!deleteObject(texture))
1886         return;
1887 
1888     unsigned current = 0;
1889     for (auto&amp; textureUnit : m_textureUnits) {
1890         if (texture == textureUnit.texture2DBinding) {
1891             textureUnit.texture2DBinding = nullptr;
1892             m_unrenderableTextureUnits.remove(current);
1893         }
1894         if (texture == textureUnit.textureCubeMapBinding) {
1895             textureUnit.textureCubeMapBinding = nullptr;
1896             m_unrenderableTextureUnits.remove(current);
1897         }
1898         ++current;
1899     }
1900     if (m_framebufferBinding)
1901         m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(texture);
1902 }
1903 
<a name="171" id="anc171"></a><span class="line-modified">1904 void WebGLRenderingContextBase::depthFunc(GCGLenum func)</span>
1905 {
1906     if (isContextLostOrPending())
1907         return;
1908     m_context-&gt;depthFunc(func);
1909 }
1910 
<a name="172" id="anc172"></a><span class="line-modified">1911 void WebGLRenderingContextBase::depthMask(GCGLboolean flag)</span>
1912 {
1913     if (isContextLostOrPending())
1914         return;
1915     m_depthMask = flag;
1916     m_context-&gt;depthMask(flag);
1917 }
1918 
<a name="173" id="anc173"></a><span class="line-modified">1919 void WebGLRenderingContextBase::depthRange(GCGLfloat zNear, GCGLfloat zFar)</span>
1920 {
1921     if (isContextLostOrPending())
1922         return;
1923     if (zNear &gt; zFar) {
<a name="174" id="anc174"></a><span class="line-modified">1924         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;depthRange&quot;, &quot;zNear &gt; zFar&quot;);</span>
1925         return;
1926     }
1927     m_context-&gt;depthRange(zNear, zFar);
1928 }
1929 
1930 void WebGLRenderingContextBase::detachShader(WebGLProgram* program, WebGLShader* shader)
1931 {
1932     if (isContextLostOrPending() || !validateWebGLObject(&quot;detachShader&quot;, program) || !validateWebGLObject(&quot;detachShader&quot;, shader))
1933         return;
1934     if (!program-&gt;detachShader(shader)) {
<a name="175" id="anc175"></a><span class="line-modified">1935         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;detachShader&quot;, &quot;shader not attached&quot;);</span>
1936         return;
1937     }
1938     m_context-&gt;detachShader(objectOrZero(program), objectOrZero(shader));
<a name="176" id="anc176"></a><span class="line-modified">1939     shader-&gt;onDetached(graphicsContextGL());</span>
1940 }
1941 
<a name="177" id="anc177"></a><span class="line-modified">1942 void WebGLRenderingContextBase::disable(GCGLenum cap)</span>
1943 {
1944     if (isContextLostOrPending() || !validateCapability(&quot;disable&quot;, cap))
1945         return;
<a name="178" id="anc178"></a><span class="line-modified">1946     if (cap == GraphicsContextGL::STENCIL_TEST) {</span>
1947         m_stencilEnabled = false;
1948         applyStencilTest();
1949         return;
1950     }
<a name="179" id="anc179"></a><span class="line-modified">1951     if (cap == GraphicsContextGL::SCISSOR_TEST)</span>
1952         m_scissorEnabled = false;
1953     m_context-&gt;disable(cap);
1954 }
1955 
<a name="180" id="anc180"></a><span class="line-modified">1956 void WebGLRenderingContextBase::disableVertexAttribArray(GCGLuint index)</span>
1957 {
1958     if (isContextLostOrPending())
1959         return;
1960     if (index &gt;= m_maxVertexAttribs) {
<a name="181" id="anc181"></a><span class="line-modified">1961         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;disableVertexAttribArray&quot;, &quot;index out of range&quot;);</span>
1962         return;
1963     }
1964 
1965     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
1966     state.enabled = false;
1967 
1968     if (index &gt; 0 || isGLES2Compliant())
1969         m_context-&gt;disableVertexAttribArray(index);
1970 }
1971 
<a name="182" id="anc182"></a><span class="line-modified">1972 bool WebGLRenderingContextBase::validateNPOTTextureLevel(GCGLsizei width, GCGLsizei height, GCGLint level, const char* functionName)</span>
1973 {
1974     if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
<a name="183" id="anc183"></a><span class="line-modified">1975         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level &gt; 0 not power of 2&quot;);</span>
1976         return false;
1977     }
1978 
1979     return true;
1980 }
1981 
<a name="184" id="anc184"></a><span class="line-modified">1982 bool WebGLRenderingContextBase::validateElementArraySize(GCGLsizei count, GCGLenum type, GCGLintptr offset)</span>
1983 {
1984     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
1985 
1986     if (!elementArrayBuffer)
1987         return false;
1988 
1989     if (offset &lt; 0)
1990         return false;
1991 
<a name="185" id="anc185"></a><span class="line-modified">1992     if (type == GraphicsContextGL::UNSIGNED_INT) {</span>
1993         // For an unsigned int array, offset must be divisible by 4 for alignment reasons.
1994         if (offset % 4)
1995             return false;
1996 
1997         // Make uoffset an element offset.
1998         offset /= 4;
1999 
<a name="186" id="anc186"></a><span class="line-modified">2000         GCGLsizeiptr n = elementArrayBuffer-&gt;byteLength() / 4;</span>
2001         if (offset &gt; n || count &gt; n - offset)
2002             return false;
<a name="187" id="anc187"></a><span class="line-modified">2003     } else if (type == GraphicsContextGL::UNSIGNED_SHORT) {</span>
2004         // For an unsigned short array, offset must be divisible by 2 for alignment reasons.
2005         if (offset % 2)
2006             return false;
2007 
2008         // Make uoffset an element offset.
2009         offset /= 2;
2010 
<a name="188" id="anc188"></a><span class="line-modified">2011         GCGLsizeiptr n = elementArrayBuffer-&gt;byteLength() / 2;</span>
2012         if (offset &gt; n || count &gt; n - offset)
2013             return false;
<a name="189" id="anc189"></a><span class="line-modified">2014     } else if (type == GraphicsContextGL::UNSIGNED_BYTE) {</span>
<span class="line-modified">2015         GCGLsizeiptr n = elementArrayBuffer-&gt;byteLength();</span>
2016         if (offset &gt; n || count &gt; n - offset)
2017             return false;
2018     }
2019     return true;
2020 }
2021 
<a name="190" id="anc190"></a><span class="line-modified">2022 bool WebGLRenderingContextBase::validateIndexArrayPrecise(GCGLsizei count, GCGLenum type, GCGLintptr offset, unsigned&amp; numElementsRequired)</span>
2023 {
2024     ASSERT(count &gt;= 0 &amp;&amp; offset &gt;= 0);
2025     unsigned maxIndex = 0;
2026 
2027     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
2028 
2029     if (!elementArrayBuffer)
2030         return false;
2031 
2032     if (!count) {
2033         numElementsRequired = 0;
2034         return true;
2035     }
2036 
2037     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
2038     if (!buffer)
2039         return false;
2040 
2041     switch (type) {
<a name="191" id="anc191"></a><span class="line-modified">2042     case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="line-modified">2043         maxIndex = getMaxIndex&lt;GCGLuint&gt;(buffer, offset, count);</span>
2044         break;
<a name="192" id="anc192"></a><span class="line-modified">2045     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="line-modified">2046         maxIndex = getMaxIndex&lt;GCGLushort&gt;(buffer, offset, count);</span>
2047         break;
<a name="193" id="anc193"></a><span class="line-modified">2048     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">2049         maxIndex = getMaxIndex&lt;GCGLubyte&gt;(buffer, offset, count);</span>
2050         break;
2051     }
2052 
2053     // Then set the maxiumum index in the index array and make sure it is valid.
2054     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex, 1, 1);
2055     if (!checkedNumElementsRequired)
2056         return false;
2057     numElementsRequired = checkedNumElementsRequired.value();
2058     return true;
2059 }
2060 
2061 bool WebGLRenderingContextBase::validateVertexAttributes(unsigned elementCount, unsigned primitiveCount)
2062 {
<a name="194" id="anc194"></a><span class="line-modified">2063 #if USE(ANGLE)</span>
<span class="line-added">2064     UNUSED_PARAM(elementCount);</span>
<span class="line-added">2065     UNUSED_PARAM(primitiveCount);</span>
<span class="line-added">2066 #else</span>
2067     if (!m_currentProgram)
2068         return false;
2069 
2070     // Look in each enabled vertex attrib and check if they&#39;ve been bound to a buffer.
2071     for (unsigned i = 0; i &lt; m_maxVertexAttribs; ++i) {
2072         if (!m_boundVertexArrayObject-&gt;getVertexAttribState(i).validateBinding())
2073             return false;
2074     }
2075 
2076     if (!elementCount)
2077         return true;
2078 
2079     // Look in each consumed vertex attrib (by the current program).
2080     bool sawNonInstancedAttrib = false;
2081     bool sawEnabledAttrib = false;
2082     int numActiveAttribLocations = m_currentProgram-&gt;numActiveAttribLocations();
2083     for (int i = 0; i &lt; numActiveAttribLocations; ++i) {
2084         int loc = m_currentProgram-&gt;getActiveAttribLocation(i);
2085         if (loc &gt;= 0 &amp;&amp; loc &lt; static_cast&lt;int&gt;(m_maxVertexAttribs)) {
2086             const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(loc);
2087             if (state.enabled) {
2088                 sawEnabledAttrib = true;
2089                 // Avoid off-by-one errors in numElements computation.
2090                 // For the last element, we will only touch the data for the
2091                 // element and nothing beyond it.
2092                 int bytesRemaining = static_cast&lt;int&gt;(state.bufferBinding-&gt;byteLength() - state.offset);
2093                 if (bytesRemaining &lt;= 0)
2094                     return false;
2095                 unsigned numElements = 0;
2096                 ASSERT(state.stride &gt; 0);
2097                 if (bytesRemaining &gt;= state.bytesPerElement)
2098                     numElements = 1 + (bytesRemaining - state.bytesPerElement) / state.stride;
2099                 unsigned instancesRequired = 0;
2100                 if (state.divisor) {
2101                     instancesRequired = ceil(static_cast&lt;float&gt;(primitiveCount) / state.divisor);
2102                     if (instancesRequired &gt; numElements)
2103                         return false;
2104                 } else {
2105                     sawNonInstancedAttrib = true;
2106                     if (elementCount &gt; numElements)
2107                         return false;
2108                 }
2109             }
2110         }
2111     }
2112 
2113     if (!sawNonInstancedAttrib &amp;&amp; sawEnabledAttrib)
2114         return false;
2115 
2116     bool usingSimulatedArrayBuffer = m_currentProgram-&gt;isUsingVertexAttrib0();
2117 
2118     // Guard against access into non-existent buffers.
2119     if (elementCount &amp;&amp; !sawEnabledAttrib &amp;&amp; !usingSimulatedArrayBuffer)
2120         return false;
2121 
2122     if (elementCount &amp;&amp; sawEnabledAttrib) {
2123         if (!m_boundArrayBuffer &amp;&amp; !m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
2124             if (usingSimulatedArrayBuffer) {
2125                 auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
2126                 if (state.enabled &amp;&amp; state.isBound()) {
<a name="195" id="anc195"></a><span class="line-modified">2127                     if (state.bufferBinding-&gt;getTarget() == GraphicsContextGL::ARRAY_BUFFER || state.bufferBinding-&gt;getTarget() == GraphicsContextGL::ELEMENT_ARRAY_BUFFER)</span>
2128                         return !!state.bufferBinding-&gt;byteLength();
2129                 }
2130             }
2131             return false;
2132         }
2133     }
2134 #endif
2135 
2136     return true;
2137 }
2138 
2139 bool WebGLRenderingContextBase::validateWebGLObject(const char* functionName, WebGLObject* object)
2140 {
2141     if (!object || !object-&gt;object()) {
<a name="196" id="anc196"></a><span class="line-modified">2142         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no object or object deleted&quot;);</span>
2143         return false;
2144     }
2145     if (!object-&gt;validate(contextGroup(), *this)) {
<a name="197" id="anc197"></a><span class="line-modified">2146         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;object does not belong to this context&quot;);</span>
2147         return false;
2148     }
2149     return true;
2150 }
2151 
<a name="198" id="anc198"></a><span class="line-modified">2152 bool WebGLRenderingContextBase::validateDrawArrays(const char* functionName, GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primitiveCount)</span>
2153 {
2154     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
2155         return false;
2156 
2157     if (!validateStencilSettings(functionName))
2158         return false;
2159 
2160     if (first &lt; 0 || count &lt; 0) {
<a name="199" id="anc199"></a><span class="line-modified">2161         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;first or count &lt; 0&quot;);</span>
2162         return false;
2163     }
2164 
2165     if (!count) {
2166         markContextChanged();
2167         return false;
2168     }
2169 
2170     if (primitiveCount &lt; 0) {
<a name="200" id="anc200"></a><span class="line-modified">2171         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);</span>
2172         return false;
2173     }
2174 
2175     // Ensure we have a valid rendering state.
<a name="201" id="anc201"></a><span class="line-modified">2176     Checked&lt;GCGLint, RecordOverflow&gt; checkedSum = Checked&lt;GCGLint, RecordOverflow&gt;(first) + Checked&lt;GCGLint, RecordOverflow&gt;(count);</span>
<span class="line-modified">2177     Checked&lt;GCGLint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);</span>
2178     if (checkedSum.hasOverflowed() || checkedPrimitiveCount.hasOverflowed() || !validateVertexAttributes(checkedSum.unsafeGet(), checkedPrimitiveCount.unsafeGet())) {
<a name="202" id="anc202"></a><span class="line-modified">2179         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
2180         return false;
2181     }
2182     if (!validateSimulatedVertexAttrib0(checkedSum.unsafeGet() - 1)) {
<a name="203" id="anc203"></a><span class="line-modified">2183         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);</span>
2184         return false;
2185     }
2186 
2187     const char* reason = &quot;framebuffer incomplete&quot;;
<a name="204" id="anc204"></a><span class="line-modified">2188     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="line-modified">2189         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);</span>
2190         return false;
2191     }
2192 
2193     return true;
2194 }
2195 
<a name="205" id="anc205"></a><span class="line-modified">2196 bool WebGLRenderingContextBase::validateDrawElements(const char* functionName, GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, unsigned&amp; numElements, GCGLsizei primitiveCount)</span>
2197 {
2198     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
2199         return false;
2200 
2201     if (!validateStencilSettings(functionName))
2202         return false;
2203 
2204     switch (type) {
<a name="206" id="anc206"></a><span class="line-modified">2205     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">2206     case GraphicsContextGL::UNSIGNED_SHORT:</span>
2207         break;
<a name="207" id="anc207"></a><span class="line-modified">2208     case GraphicsContextGL::UNSIGNED_INT:</span>
2209         if (m_oesElementIndexUint || isWebGL2())
2210             break;
<a name="208" id="anc208"></a><span class="line-modified">2211         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid type&quot;);</span>
2212         return false;
2213     default:
<a name="209" id="anc209"></a><span class="line-modified">2214         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid type&quot;);</span>
2215         return false;
2216     }
2217 
2218     if (count &lt; 0 || offset &lt; 0) {
<a name="210" id="anc210"></a><span class="line-modified">2219         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;count or offset &lt; 0&quot;);</span>
2220         return false;
2221     }
2222 
2223     if (!count) {
2224         markContextChanged();
2225         return false;
2226     }
2227 
2228     if (primitiveCount &lt; 0) {
<a name="211" id="anc211"></a><span class="line-modified">2229         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);</span>
2230         return false;
2231     }
2232 
2233     if (!m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
<a name="212" id="anc212"></a><span class="line-modified">2234         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;no ELEMENT_ARRAY_BUFFER bound&quot;);</span>
2235         return false;
2236     }
2237 
2238     // Ensure we have a valid rendering state.
<a name="213" id="anc213"></a><span class="line-modified">2239     if (!validateElementArraySize(count, type, static_cast&lt;GCGLintptr&gt;(offset))) {</span>
<span class="line-modified">2240         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;request out of bounds for current ELEMENT_ARRAY_BUFFER&quot;);</span>
2241         return false;
2242     }
2243     if (!count)
2244         return false;
2245 
<a name="214" id="anc214"></a><span class="line-modified">2246     Checked&lt;GCGLint, RecordOverflow&gt; checkedCount(count);</span>
<span class="line-modified">2247     Checked&lt;GCGLint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);</span>
2248     if (checkedCount.hasOverflowed() || checkedPrimitiveCount.hasOverflowed()) {
<a name="215" id="anc215"></a><span class="line-modified">2249         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
2250         return false;
2251     }
2252 
2253     if (!validateIndexArrayConservative(type, numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {
<a name="216" id="anc216"></a><span class="line-modified">2254         if (!validateIndexArrayPrecise(checkedCount.unsafeGet(), type, static_cast&lt;GCGLintptr&gt;(offset), numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {</span>
<span class="line-modified">2255             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
2256             return false;
2257         }
2258     }
2259 
2260     if (!validateSimulatedVertexAttrib0(numElements)) {
<a name="217" id="anc217"></a><span class="line-modified">2261         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);</span>
2262         return false;
2263     }
2264 
2265     const char* reason = &quot;framebuffer incomplete&quot;;
<a name="218" id="anc218"></a><span class="line-modified">2266     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="line-modified">2267         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);</span>
2268         return false;
2269     }
2270 
2271     return true;
2272 }
2273 
<a name="219" id="anc219"></a><span class="line-modified">2274 void WebGLRenderingContextBase::drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count)</span>
2275 {
2276     if (!validateDrawArrays(&quot;drawArrays&quot;, mode, first, count, 0))
2277         return;
2278 
<a name="220" id="anc220"></a><span class="line-modified">2279     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isWebGLProgramDisabled(*this, *m_currentProgram))</span>
2280         return;
2281 
2282     clearIfComposited();
2283 
2284     bool vertexAttrib0Simulated = false;
2285     if (!isGLES2Compliant()) {
2286         auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
2287         if (!simulateVertexAttrib0Status) {
2288             // We were unable to simulate the attribute buffer.
<a name="221" id="anc221"></a><span class="line-modified">2289             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawArrays&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
2290             return;
2291         }
2292         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
2293     }
2294     bool usesFallbackTexture = false;
2295     if (!isGLES2NPOTStrict())
2296         usesFallbackTexture = checkTextureCompleteness(&quot;drawArrays&quot;, true);
2297 
2298     {
2299         InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
2300 
2301         m_context-&gt;drawArrays(mode, first, count);
2302     }
2303 
2304     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
2305         restoreStatesAfterVertexAttrib0Simulation();
2306     if (usesFallbackTexture)
2307         checkTextureCompleteness(&quot;drawArrays&quot;, false);
2308     markContextChangedAndNotifyCanvasObserver();
2309 }
2310 
2311 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
<a name="222" id="anc222"></a><span class="line-modified">2312 static GCGLuint getRestartIndex(GCGLenum type)</span>
2313 {
2314     switch (type) {
<a name="223" id="anc223"></a><span class="line-modified">2315     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">2316         return std::numeric_limits&lt;GCGLubyte&gt;::max();</span>
<span class="line-modified">2317     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="line-modified">2318         return std::numeric_limits&lt;GCGLushort&gt;::max();</span>
<span class="line-modified">2319     case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="line-modified">2320         return std::numeric_limits&lt;GCGLuint&gt;::max();</span>
2321     }
2322 
2323     return 0;
2324 }
2325 #endif
2326 
<a name="224" id="anc224"></a><span class="line-modified">2327 void WebGLRenderingContextBase::drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset)</span>
2328 {
2329     unsigned numElements = 0;
2330     if (!validateDrawElements(&quot;drawElements&quot;, mode, count, type, offset, numElements, 0))
2331         return;
2332 
<a name="225" id="anc225"></a><span class="line-modified">2333     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isWebGLProgramDisabled(*this, *m_currentProgram))</span>
2334         return;
2335 
2336     clearIfComposited();
2337 
2338     bool vertexAttrib0Simulated = false;
2339     if (!isGLES2Compliant()) {
2340         if (!numElements)
<a name="226" id="anc226"></a><span class="line-modified">2341             validateIndexArrayPrecise(count, type, static_cast&lt;GCGLintptr&gt;(offset), numElements);</span>
2342         auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
2343         if (!simulateVertexAttrib0Status) {
2344             // We were unable to simulate the attribute buffer.
<a name="227" id="anc227"></a><span class="line-modified">2345             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawElements&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
2346             return;
2347         }
2348         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
2349     }
2350 
2351     bool usesFallbackTexture = false;
2352     if (!isGLES2NPOTStrict())
2353         usesFallbackTexture = checkTextureCompleteness(&quot;drawElements&quot;, true);
2354 
2355 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
2356     if (isWebGL2())
2357         m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
2358 #endif
2359 
2360     {
2361         InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
2362 
<a name="228" id="anc228"></a><span class="line-modified">2363         m_context-&gt;drawElements(mode, count, type, static_cast&lt;GCGLintptr&gt;(offset));</span>
2364     }
2365 
2366     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
2367         restoreStatesAfterVertexAttrib0Simulation();
2368     if (usesFallbackTexture)
2369         checkTextureCompleteness(&quot;drawElements&quot;, false);
2370     markContextChangedAndNotifyCanvasObserver();
2371 }
2372 
<a name="229" id="anc229"></a><span class="line-modified">2373 void WebGLRenderingContextBase::enable(GCGLenum cap)</span>
2374 {
2375     if (isContextLostOrPending() || !validateCapability(&quot;enable&quot;, cap))
2376         return;
<a name="230" id="anc230"></a><span class="line-modified">2377     if (cap == GraphicsContextGL::STENCIL_TEST) {</span>
2378         m_stencilEnabled = true;
2379         applyStencilTest();
2380         return;
2381     }
<a name="231" id="anc231"></a><span class="line-modified">2382     if (cap == GraphicsContextGL::SCISSOR_TEST)</span>
2383         m_scissorEnabled = true;
2384     m_context-&gt;enable(cap);
2385 }
2386 
<a name="232" id="anc232"></a><span class="line-modified">2387 void WebGLRenderingContextBase::enableVertexAttribArray(GCGLuint index)</span>
2388 {
2389     if (isContextLostOrPending())
2390         return;
2391     if (index &gt;= m_maxVertexAttribs) {
<a name="233" id="anc233"></a><span class="line-modified">2392         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;enableVertexAttribArray&quot;, &quot;index out of range&quot;);</span>
2393         return;
2394     }
2395 
2396     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
2397     state.enabled = true;
2398 
2399     m_context-&gt;enableVertexAttribArray(index);
2400 }
2401 
2402 void WebGLRenderingContextBase::finish()
2403 {
2404     if (isContextLostOrPending())
2405         return;
2406     m_context-&gt;finish();
2407 }
2408 
2409 void WebGLRenderingContextBase::flush()
2410 {
2411     if (isContextLostOrPending())
2412         return;
2413     m_context-&gt;flush();
2414 }
2415 
<a name="234" id="anc234"></a><span class="line-modified">2416 void WebGLRenderingContextBase::framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, WebGLRenderbuffer* buffer)</span>
2417 {
2418     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferRenderbuffer&quot;, target, attachment))
2419         return;
<a name="235" id="anc235"></a><span class="line-modified">2420     if (renderbuffertarget != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="line-modified">2421         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;framebufferRenderbuffer&quot;, &quot;invalid target&quot;);</span>
2422         return;
2423     }
2424     if (buffer &amp;&amp; !buffer-&gt;validate(contextGroup(), *this)) {
<a name="236" id="anc236"></a><span class="line-modified">2425         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no buffer or buffer not from this context&quot;);</span>
<span class="line-added">2426         return;</span>
<span class="line-added">2427     }</span>
<span class="line-added">2428     if (buffer &amp;&amp; !buffer-&gt;hasEverBeenBound()) {</span>
<span class="line-added">2429         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;buffer has never been bound&quot;);</span>
2430         return;
2431     }
2432 
<a name="237" id="anc237"></a><span class="line-modified">2433     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
2434 
2435     // Don&#39;t allow the default framebuffer to be mutated; all current
2436     // implementations use an FBO internally in place of the default
2437     // FBO.
2438     if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
<a name="238" id="anc238"></a><span class="line-modified">2439         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no framebuffer bound&quot;);</span>
2440         return;
2441     }
<a name="239" id="anc239"></a><span class="line-modified">2442     PlatformGLObject bufferObject = objectOrZero(buffer);</span>
<span class="line-modified">2443 #if !USE(ANGLE)</span>
<span class="line-modified">2444     if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">2445         m_context-&gt;framebufferRenderbuffer(target, GraphicsContextGL::DEPTH_ATTACHMENT, renderbuffertarget, bufferObject);</span>
<span class="line-modified">2446         m_context-&gt;framebufferRenderbuffer(target, GraphicsContextGL::STENCIL_ATTACHMENT, renderbuffertarget, bufferObject);</span>
<span class="line-modified">2447     } else</span>
<span class="line-modified">2448 #endif</span>
2449         m_context-&gt;framebufferRenderbuffer(target, attachment, renderbuffertarget, bufferObject);
<a name="240" id="anc240"></a>
2450     targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, buffer);
2451     applyStencilTest();
2452 }
2453 
<a name="241" id="anc241"></a><span class="line-modified">2454 void WebGLRenderingContextBase::framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, WebGLTexture* texture, GCGLint level)</span>
2455 {
2456     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferTexture2D&quot;, target, attachment))
2457         return;
2458     if (level &amp;&amp; isWebGL1()) {
<a name="242" id="anc242"></a><span class="line-modified">2459         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;framebufferTexture2D&quot;, &quot;level not 0&quot;);</span>
2460         return;
2461     }
2462     if (texture &amp;&amp; !texture-&gt;validate(contextGroup(), *this)) {
<a name="243" id="anc243"></a><span class="line-modified">2463         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no texture or texture not from this context&quot;);</span>
2464         return;
2465     }
2466 
<a name="244" id="anc244"></a><span class="line-modified">2467     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
2468 
2469     // Don&#39;t allow the default framebuffer to be mutated; all current
2470     // implementations use an FBO internally in place of the default
2471     // FBO.
2472     if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
<a name="245" id="anc245"></a><span class="line-modified">2473         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no framebuffer bound&quot;);</span>
2474         return;
2475     }
<a name="246" id="anc246"></a><span class="line-modified">2476     PlatformGLObject textureObject = objectOrZero(texture);</span>
<span class="line-modified">2477 </span>
<span class="line-modified">2478 #if !USE_ANGLE</span>
<span class="line-modified">2479     if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">2480         m_context-&gt;framebufferTexture2D(target, GraphicsContextGL::DEPTH_ATTACHMENT, textarget, textureObject, level);</span>
<span class="line-modified">2481         m_context-&gt;framebufferTexture2D(target, GraphicsContextGL::STENCIL_ATTACHMENT, textarget, textureObject, level);</span>
<span class="line-modified">2482     } else</span>
<span class="line-modified">2483 #endif</span>





2484         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);
<a name="247" id="anc247"></a><span class="line-modified">2485 </span>
2486     targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, textarget, texture, level);
2487     applyStencilTest();
2488 }
2489 
<a name="248" id="anc248"></a><span class="line-modified">2490 void WebGLRenderingContextBase::frontFace(GCGLenum mode)</span>
2491 {
2492     if (isContextLostOrPending())
2493         return;
2494     m_context-&gt;frontFace(mode);
2495 }
2496 
<a name="249" id="anc249"></a><span class="line-modified">2497 void WebGLRenderingContextBase::generateMipmap(GCGLenum target)</span>
2498 {
2499     if (isContextLostOrPending())
2500         return;
2501     auto tex = validateTextureBinding(&quot;generateMipmap&quot;, target, false);
2502     if (!tex)
2503         return;
2504     if (!tex-&gt;canGenerateMipmaps()) {
<a name="250" id="anc250"></a><span class="line-modified">2505         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;level 0 not power of 2 or not all the same size&quot;);</span>
2506         return;
2507     }
2508     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=123916. Compressed textures should be allowed in WebGL 2:
2509     if (tex-&gt;isCompressed()) {
<a name="251" id="anc251"></a><span class="line-modified">2510         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;trying to generate mipmaps from compressed texture&quot;);</span>
2511         return;
2512     }
2513     if (!validateSettableTexInternalFormat(&quot;generateMipmap&quot;, tex-&gt;getInternalFormat(target, 0)))
2514         return;
2515 
2516     // generateMipmap won&#39;t work properly if minFilter is not NEAREST_MIPMAP_LINEAR
2517     // on Mac.  Remove the hack once this driver bug is fixed.
2518 #if OS(DARWIN)
2519     bool needToResetMinFilter = false;
<a name="252" id="anc252"></a><span class="line-modified">2520     if (tex-&gt;getMinFilter() != GraphicsContextGL::NEAREST_MIPMAP_LINEAR) {</span>
<span class="line-modified">2521         m_context-&gt;texParameteri(target, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::NEAREST_MIPMAP_LINEAR);</span>
2522         needToResetMinFilter = true;
2523     }
2524 #endif
2525     m_context-&gt;generateMipmap(target);
2526 #if OS(DARWIN)
2527     if (needToResetMinFilter)
<a name="253" id="anc253"></a><span class="line-modified">2528         m_context-&gt;texParameteri(target, GraphicsContextGL::TEXTURE_MIN_FILTER, tex-&gt;getMinFilter());</span>
2529 #endif
2530     tex-&gt;generateMipmapLevelInfo();
2531 }
2532 
<a name="254" id="anc254"></a><span class="line-modified">2533 RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveAttrib(WebGLProgram* program, GCGLuint index)</span>
2534 {
2535     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveAttrib&quot;, program))
2536         return nullptr;
<a name="255" id="anc255"></a><span class="line-modified">2537     GraphicsContextGL::ActiveInfo info;</span>
2538     if (!m_context-&gt;getActiveAttrib(objectOrZero(program), index, info))
2539         return nullptr;
2540 
2541     LOG(WebGL, &quot;Returning active attribute %d: %s&quot;, index, info.name.utf8().data());
2542 
2543     return WebGLActiveInfo::create(info.name, info.type, info.size);
2544 }
2545 
<a name="256" id="anc256"></a><span class="line-modified">2546 RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveUniform(WebGLProgram* program, GCGLuint index)</span>
2547 {
2548     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveUniform&quot;, program))
2549         return nullptr;
<a name="257" id="anc257"></a><span class="line-modified">2550     GraphicsContextGL::ActiveInfo info;</span>
2551     if (!m_context-&gt;getActiveUniform(objectOrZero(program), index, info))
2552         return nullptr;
2553     if (!isGLES2Compliant())
2554         if (info.size &gt; 1 &amp;&amp; !info.name.endsWith(&quot;[0]&quot;))
2555             info.name.append(&quot;[0]&quot;);
2556 
2557     LOG(WebGL, &quot;Returning active uniform %d: %s&quot;, index, info.name.utf8().data());
2558 
2559     return WebGLActiveInfo::create(info.name, info.type, info.size);
2560 }
2561 
2562 Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; WebGLRenderingContextBase::getAttachedShaders(WebGLProgram* program)
2563 {
2564     if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttachedShaders&quot;, program))
2565         return WTF::nullopt;
2566 
<a name="258" id="anc258"></a><span class="line-modified">2567     const GCGLenum shaderTypes[] = {</span>
<span class="line-modified">2568         GraphicsContextGL::VERTEX_SHADER,</span>
<span class="line-modified">2569         GraphicsContextGL::FRAGMENT_SHADER</span>
2570     };
2571     Vector&lt;RefPtr&lt;WebGLShader&gt;&gt; shaderObjects;
2572     for (auto shaderType : shaderTypes) {
2573         RefPtr&lt;WebGLShader&gt; shader = program-&gt;getAttachedShader(shaderType);
2574         if (shader)
2575             shaderObjects.append(shader);
2576     }
2577     return shaderObjects;
2578 }
2579 
<a name="259" id="anc259"></a><span class="line-modified">2580 GCGLint WebGLRenderingContextBase::getAttribLocation(WebGLProgram* program, const String&amp; name)</span>
2581 {
2582     if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttribLocation&quot;, program))
2583         return -1;
2584     if (!validateLocationLength(&quot;getAttribLocation&quot;, name))
2585         return -1;
2586     if (!validateString(&quot;getAttribLocation&quot;, name))
2587         return -1;
2588     if (isPrefixReserved(name))
2589         return -1;
2590     if (!program-&gt;getLinkStatus()) {
<a name="260" id="anc260"></a><span class="line-modified">2591         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getAttribLocation&quot;, &quot;program not linked&quot;);</span>
2592         return -1;
2593     }
2594     return m_context-&gt;getAttribLocation(objectOrZero(program), name);
2595 }
2596 
<a name="261" id="anc261"></a><span class="line-modified">2597 WebGLAny WebGLRenderingContextBase::getBufferParameter(GCGLenum target, GCGLenum pname)</span>
2598 {
2599     if (isContextLostOrPending())
2600         return nullptr;
2601 
2602     bool valid = false;
<a name="262" id="anc262"></a><span class="line-modified">2603     if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER)</span>
2604         valid = true;
2605 #if ENABLE(WEBGL2)
2606     if (isWebGL2()) {
2607         switch (target) {
<a name="263" id="anc263"></a><span class="line-modified">2608         case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="line-modified">2609         case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="line-modified">2610         case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">2611         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">2612         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">2613         case GraphicsContextGL::UNIFORM_BUFFER:</span>
2614             valid = true;
2615         }
2616     }
2617 #endif
2618     if (!valid) {
<a name="264" id="anc264"></a><span class="line-modified">2619         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid target&quot;);</span>
2620         return nullptr;
2621     }
2622 
<a name="265" id="anc265"></a><span class="line-modified">2623     if (pname != GraphicsContextGL::BUFFER_SIZE &amp;&amp; pname != GraphicsContextGL::BUFFER_USAGE) {</span>
<span class="line-modified">2624         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
2625         return nullptr;
2626     }
2627 
<a name="266" id="anc266"></a><span class="line-modified">2628     GCGLint value = 0;</span>
2629     m_context-&gt;getBufferParameteriv(target, pname, &amp;value);
<a name="267" id="anc267"></a><span class="line-modified">2630     if (pname == GraphicsContextGL::BUFFER_SIZE)</span>
2631         return value;
2632     return static_cast&lt;unsigned&gt;(value);
2633 }
2634 
2635 Optional&lt;WebGLContextAttributes&gt; WebGLRenderingContextBase::getContextAttributes()
2636 {
2637     if (isContextLostOrPending())
2638         return WTF::nullopt;
2639 
2640     // Also, we need to enforce requested values of &quot;false&quot; for depth
2641     // and stencil, regardless of the properties of the underlying
<a name="268" id="anc268"></a><span class="line-modified">2642     // GraphicsContextGLOpenGL.</span>
2643 
<a name="269" id="anc269"></a><span class="line-modified">2644     auto attributes = m_context-&gt;contextAttributes();</span>
2645     if (!m_attributes.depth)
2646         attributes.depth = false;
2647     if (!m_attributes.stencil)
2648         attributes.stencil = false;
2649     return attributes;
2650 }
2651 
<a name="270" id="anc270"></a><span class="line-modified">2652 GCGLenum WebGLRenderingContextBase::getError()</span>
2653 {
2654     if (m_isPendingPolicyResolution)
<a name="271" id="anc271"></a><span class="line-modified">2655         return GraphicsContextGL::NO_ERROR;</span>
2656     return m_context-&gt;getError();
2657 }
2658 
<a name="272" id="anc272"></a><span class="line-modified">2659 WebGLAny WebGLRenderingContextBase::getProgramParameter(WebGLProgram* program, GCGLenum pname)</span>
2660 {
2661     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramParameter&quot;, program))
2662         return nullptr;
2663 
<a name="273" id="anc273"></a><span class="line-modified">2664     GCGLint value = 0;</span>
2665     switch (pname) {
<a name="274" id="anc274"></a><span class="line-modified">2666     case GraphicsContextGL::DELETE_STATUS:</span>
2667         return program-&gt;isDeleted();
<a name="275" id="anc275"></a><span class="line-modified">2668     case GraphicsContextGL::VALIDATE_STATUS:</span>
2669         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2670         return static_cast&lt;bool&gt;(value);
<a name="276" id="anc276"></a><span class="line-modified">2671     case GraphicsContextGL::LINK_STATUS:</span>
2672         return program-&gt;getLinkStatus();
<a name="277" id="anc277"></a><span class="line-modified">2673     case GraphicsContextGL::ATTACHED_SHADERS:</span>
2674         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2675         return value;
<a name="278" id="anc278"></a><span class="line-modified">2676     case GraphicsContextGL::ACTIVE_ATTRIBUTES:</span>
<span class="line-modified">2677     case GraphicsContextGL::ACTIVE_UNIFORMS:</span>
2678 #if USE(ANGLE)
2679         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2680 #else
2681         m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), pname, &amp;value);
2682 #endif // USE(ANGLE)
2683         return value;
2684     default:
<a name="279" id="anc279"></a><span class="line-modified">2685 #if ENABLE(WEBGL2)</span>
<span class="line-added">2686         if (isWebGL2()) {</span>
<span class="line-added">2687             switch (pname) {</span>
<span class="line-added">2688             case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER_MODE:</span>
<span class="line-added">2689             case GraphicsContextGL::TRANSFORM_FEEDBACK_VARYINGS:</span>
<span class="line-added">2690             case GraphicsContextGL::ACTIVE_UNIFORM_BLOCKS:</span>
<span class="line-added">2691                 m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);</span>
<span class="line-added">2692                 return value;</span>
<span class="line-added">2693             default:</span>
<span class="line-added">2694                 break;</span>
<span class="line-added">2695             }</span>
<span class="line-added">2696         }</span>
<span class="line-added">2697 #endif // ENABLE(WEBGL2)</span>
<span class="line-added">2698         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getProgramParameter&quot;, &quot;invalid parameter name&quot;);</span>
2699         return nullptr;
2700     }
2701 }
2702 
2703 String WebGLRenderingContextBase::getProgramInfoLog(WebGLProgram* program)
2704 {
2705     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramInfoLog&quot;, program))
2706         return String();
2707     return ensureNotNull(m_context-&gt;getProgramInfoLog(objectOrZero(program)));
2708 }
2709 
<a name="280" id="anc280"></a><span class="line-modified">2710 WebGLAny WebGLRenderingContextBase::getRenderbufferParameter(GCGLenum target, GCGLenum pname)</span>
2711 {
2712     if (isContextLostOrPending())
2713         return nullptr;
<a name="281" id="anc281"></a><span class="line-modified">2714     if (target != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="line-modified">2715         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid target&quot;);</span>
2716         return nullptr;
2717     }
2718     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
<a name="282" id="anc282"></a><span class="line-modified">2719         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getRenderbufferParameter&quot;, &quot;no renderbuffer bound&quot;);</span>
2720         return nullptr;
2721     }
2722 
<a name="283" id="anc283"></a><span class="line-modified">2723     if (m_renderbufferBinding-&gt;getInternalFormat() == GraphicsContextGL::DEPTH_STENCIL</span>
2724         &amp;&amp; !m_renderbufferBinding-&gt;isValid()) {
2725         ASSERT(!isDepthStencilSupported());
2726         int value = 0;
2727         switch (pname) {
<a name="284" id="anc284"></a><span class="line-modified">2728         case GraphicsContextGL::RENDERBUFFER_WIDTH:</span>
2729             value = m_renderbufferBinding-&gt;getWidth();
2730             break;
<a name="285" id="anc285"></a><span class="line-modified">2731         case GraphicsContextGL::RENDERBUFFER_HEIGHT:</span>
2732             value = m_renderbufferBinding-&gt;getHeight();
2733             break;
<a name="286" id="anc286"></a><span class="line-modified">2734         case GraphicsContextGL::RENDERBUFFER_RED_SIZE:</span>
<span class="line-modified">2735         case GraphicsContextGL::RENDERBUFFER_GREEN_SIZE:</span>
<span class="line-modified">2736         case GraphicsContextGL::RENDERBUFFER_BLUE_SIZE:</span>
<span class="line-modified">2737         case GraphicsContextGL::RENDERBUFFER_ALPHA_SIZE:</span>
2738             value = 0;
2739             break;
<a name="287" id="anc287"></a><span class="line-modified">2740         case GraphicsContextGL::RENDERBUFFER_DEPTH_SIZE:</span>
2741             value = 24;
2742             break;
<a name="288" id="anc288"></a><span class="line-modified">2743         case GraphicsContextGL::RENDERBUFFER_STENCIL_SIZE:</span>
2744             value = 8;
2745             break;
<a name="289" id="anc289"></a><span class="line-modified">2746         case GraphicsContextGL::RENDERBUFFER_INTERNAL_FORMAT:</span>
2747             return m_renderbufferBinding-&gt;getInternalFormat();
2748         default:
<a name="290" id="anc290"></a><span class="line-modified">2749             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
2750             return nullptr;
2751         }
2752         return value;
2753     }
2754 
<a name="291" id="anc291"></a><span class="line-modified">2755     GCGLint value = 0;</span>
2756     switch (pname) {
<a name="292" id="anc292"></a><span class="line-modified">2757     case GraphicsContextGL::RENDERBUFFER_WIDTH:</span>
<span class="line-modified">2758     case GraphicsContextGL::RENDERBUFFER_HEIGHT:</span>
<span class="line-modified">2759     case GraphicsContextGL::RENDERBUFFER_RED_SIZE:</span>
<span class="line-modified">2760     case GraphicsContextGL::RENDERBUFFER_GREEN_SIZE:</span>
<span class="line-modified">2761     case GraphicsContextGL::RENDERBUFFER_BLUE_SIZE:</span>
<span class="line-modified">2762     case GraphicsContextGL::RENDERBUFFER_ALPHA_SIZE:</span>
<span class="line-modified">2763     case GraphicsContextGL::RENDERBUFFER_DEPTH_SIZE:</span>
<span class="line-modified">2764     case GraphicsContextGL::RENDERBUFFER_STENCIL_SIZE:</span>
2765         m_context-&gt;getRenderbufferParameteriv(target, pname, &amp;value);
2766         return value;
<a name="293" id="anc293"></a><span class="line-modified">2767     case GraphicsContextGL::RENDERBUFFER_INTERNAL_FORMAT:</span>
2768         return m_renderbufferBinding-&gt;getInternalFormat();
2769     default:
<a name="294" id="anc294"></a><span class="line-modified">2770         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
2771         return nullptr;
2772     }
2773 }
2774 
<a name="295" id="anc295"></a><span class="line-modified">2775 WebGLAny WebGLRenderingContextBase::getShaderParameter(WebGLShader* shader, GCGLenum pname)</span>
2776 {
2777     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderParameter&quot;, shader))
2778         return nullptr;
<a name="296" id="anc296"></a><span class="line-modified">2779     GCGLint value = 0;</span>
2780     switch (pname) {
<a name="297" id="anc297"></a><span class="line-modified">2781     case GraphicsContextGL::DELETE_STATUS:</span>
2782         return shader-&gt;isDeleted();
<a name="298" id="anc298"></a><span class="line-modified">2783     case GraphicsContextGL::COMPILE_STATUS:</span>
2784         m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
2785         return static_cast&lt;bool&gt;(value);
<a name="299" id="anc299"></a><span class="line-modified">2786     case GraphicsContextGL::SHADER_TYPE:</span>
2787         m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
2788         return static_cast&lt;unsigned&gt;(value);
2789     default:
<a name="300" id="anc300"></a><span class="line-modified">2790         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getShaderParameter&quot;, &quot;invalid parameter name&quot;);</span>
2791         return nullptr;
2792     }
2793 }
2794 
2795 String WebGLRenderingContextBase::getShaderInfoLog(WebGLShader* shader)
2796 {
2797     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderInfoLog&quot;, shader))
2798         return String();
2799     return ensureNotNull(m_context-&gt;getShaderInfoLog(objectOrZero(shader)));
2800 }
2801 
<a name="301" id="anc301"></a><span class="line-modified">2802 RefPtr&lt;WebGLShaderPrecisionFormat&gt; WebGLRenderingContextBase::getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType)</span>
2803 {
2804     if (isContextLostOrPending())
2805         return nullptr;
2806     switch (shaderType) {
<a name="302" id="anc302"></a><span class="line-modified">2807     case GraphicsContextGL::VERTEX_SHADER:</span>
<span class="line-modified">2808     case GraphicsContextGL::FRAGMENT_SHADER:</span>
2809         break;
2810     default:
<a name="303" id="anc303"></a><span class="line-modified">2811         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid shader type&quot;);</span>
2812         return nullptr;
2813     }
2814     switch (precisionType) {
<a name="304" id="anc304"></a><span class="line-modified">2815     case GraphicsContextGL::LOW_FLOAT:</span>
<span class="line-modified">2816     case GraphicsContextGL::MEDIUM_FLOAT:</span>
<span class="line-modified">2817     case GraphicsContextGL::HIGH_FLOAT:</span>
<span class="line-modified">2818     case GraphicsContextGL::LOW_INT:</span>
<span class="line-modified">2819     case GraphicsContextGL::MEDIUM_INT:</span>
<span class="line-modified">2820     case GraphicsContextGL::HIGH_INT:</span>
2821         break;
2822     default:
<a name="305" id="anc305"></a><span class="line-modified">2823         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid precision type&quot;);</span>
2824         return nullptr;
2825     }
2826 
<a name="306" id="anc306"></a><span class="line-modified">2827     GCGLint range[2] = {0, 0};</span>
<span class="line-modified">2828     GCGLint precision = 0;</span>
2829     m_context-&gt;getShaderPrecisionFormat(shaderType, precisionType, range, &amp;precision);
2830     return WebGLShaderPrecisionFormat::create(range[0], range[1], precision);
2831 }
2832 
2833 String WebGLRenderingContextBase::getShaderSource(WebGLShader* shader)
2834 {
2835     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderSource&quot;, shader))
2836         return String();
2837     return ensureNotNull(shader-&gt;getSource());
2838 }
2839 
<a name="307" id="anc307"></a><span class="line-modified">2840 WebGLAny WebGLRenderingContextBase::getTexParameter(GCGLenum target, GCGLenum pname)</span>
2841 {
2842     if (isContextLostOrPending())
2843         return nullptr;
2844     auto tex = validateTextureBinding(&quot;getTexParameter&quot;, target, false);
2845     if (!tex)
2846         return nullptr;
<a name="308" id="anc308"></a><span class="line-modified">2847     GCGLint value = 0;</span>
<span class="line-added">2848     GCGLfloat fValue = 0;</span>
2849     switch (pname) {
<a name="309" id="anc309"></a><span class="line-modified">2850     case GraphicsContextGL::TEXTURE_MAG_FILTER:</span>
<span class="line-modified">2851     case GraphicsContextGL::TEXTURE_MIN_FILTER:</span>
<span class="line-modified">2852     case GraphicsContextGL::TEXTURE_WRAP_S:</span>
<span class="line-modified">2853     case GraphicsContextGL::TEXTURE_WRAP_T:</span>
2854         m_context-&gt;getTexParameteriv(target, pname, &amp;value);
2855         return static_cast&lt;unsigned&gt;(value);
<a name="310" id="anc310"></a><span class="line-modified">2856     case ExtensionsGL::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
2857         if (m_extTextureFilterAnisotropic) {
<a name="311" id="anc311"></a><span class="line-modified">2858             m_context-&gt;getTexParameterfv(target, pname, &amp;fValue);</span>
<span class="line-modified">2859             return static_cast&lt;float&gt;(fValue);</span>
2860         }
<a name="312" id="anc312"></a><span class="line-modified">2861         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);</span>
2862         return nullptr;
2863     default:
<a name="313" id="anc313"></a><span class="line-modified">2864         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name&quot;);</span>
2865         return nullptr;
2866     }
2867 }
2868 
2869 WebGLAny WebGLRenderingContextBase::getUniform(WebGLProgram* program, const WebGLUniformLocation* uniformLocation)
2870 {
2871     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniform&quot;, program))
2872         return nullptr;
2873     if (!uniformLocation || uniformLocation-&gt;program() != program) {
<a name="314" id="anc314"></a><span class="line-modified">2874         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getUniform&quot;, &quot;no uniformlocation or not valid for this program&quot;);</span>
2875         return nullptr;
2876     }
<a name="315" id="anc315"></a><span class="line-modified">2877     GCGLint location = uniformLocation-&gt;location();</span>
2878 
<a name="316" id="anc316"></a><span class="line-modified">2879     GCGLenum baseType;</span>
2880     unsigned length;
2881     switch (uniformLocation-&gt;type()) {
<a name="317" id="anc317"></a><span class="line-modified">2882     case GraphicsContextGL::BOOL:</span>
<span class="line-modified">2883         baseType = GraphicsContextGL::BOOL;</span>
2884         length = 1;
2885         break;
<a name="318" id="anc318"></a><span class="line-modified">2886     case GraphicsContextGL::BOOL_VEC2:</span>
<span class="line-modified">2887         baseType = GraphicsContextGL::BOOL;</span>
2888         length = 2;
2889         break;
<a name="319" id="anc319"></a><span class="line-modified">2890     case GraphicsContextGL::BOOL_VEC3:</span>
<span class="line-modified">2891         baseType = GraphicsContextGL::BOOL;</span>
2892         length = 3;
2893         break;
<a name="320" id="anc320"></a><span class="line-modified">2894     case GraphicsContextGL::BOOL_VEC4:</span>
<span class="line-modified">2895         baseType = GraphicsContextGL::BOOL;</span>
2896         length = 4;
2897         break;
<a name="321" id="anc321"></a><span class="line-modified">2898     case GraphicsContextGL::INT:</span>
<span class="line-modified">2899         baseType = GraphicsContextGL::INT;</span>
2900         length = 1;
2901         break;
<a name="322" id="anc322"></a><span class="line-modified">2902     case GraphicsContextGL::INT_VEC2:</span>
<span class="line-modified">2903         baseType = GraphicsContextGL::INT;</span>
2904         length = 2;
2905         break;
<a name="323" id="anc323"></a><span class="line-modified">2906     case GraphicsContextGL::INT_VEC3:</span>
<span class="line-modified">2907         baseType = GraphicsContextGL::INT;</span>
2908         length = 3;
2909         break;
<a name="324" id="anc324"></a><span class="line-modified">2910     case GraphicsContextGL::INT_VEC4:</span>
<span class="line-modified">2911         baseType = GraphicsContextGL::INT;</span>
2912         length = 4;
2913         break;
<a name="325" id="anc325"></a><span class="line-modified">2914     case GraphicsContextGL::FLOAT:</span>
<span class="line-modified">2915         baseType = GraphicsContextGL::FLOAT;</span>
2916         length = 1;
2917         break;
<a name="326" id="anc326"></a><span class="line-modified">2918     case GraphicsContextGL::FLOAT_VEC2:</span>
<span class="line-modified">2919         baseType = GraphicsContextGL::FLOAT;</span>
2920         length = 2;
2921         break;
<a name="327" id="anc327"></a><span class="line-modified">2922     case GraphicsContextGL::FLOAT_VEC3:</span>
<span class="line-modified">2923         baseType = GraphicsContextGL::FLOAT;</span>
2924         length = 3;
2925         break;
<a name="328" id="anc328"></a><span class="line-modified">2926     case GraphicsContextGL::FLOAT_VEC4:</span>
<span class="line-modified">2927         baseType = GraphicsContextGL::FLOAT;</span>
2928         length = 4;
2929         break;
<a name="329" id="anc329"></a><span class="line-modified">2930     case GraphicsContextGL::FLOAT_MAT2:</span>
<span class="line-modified">2931         baseType = GraphicsContextGL::FLOAT;</span>
2932         length = 4;
2933         break;
<a name="330" id="anc330"></a><span class="line-modified">2934     case GraphicsContextGL::FLOAT_MAT3:</span>
<span class="line-modified">2935         baseType = GraphicsContextGL::FLOAT;</span>
2936         length = 9;
2937         break;
<a name="331" id="anc331"></a><span class="line-modified">2938     case GraphicsContextGL::FLOAT_MAT4:</span>
<span class="line-modified">2939         baseType = GraphicsContextGL::FLOAT;</span>
2940         length = 16;
2941         break;
<a name="332" id="anc332"></a><span class="line-modified">2942     case GraphicsContextGL::SAMPLER_2D:</span>
<span class="line-modified">2943     case GraphicsContextGL::SAMPLER_CUBE:</span>
<span class="line-modified">2944         baseType = GraphicsContextGL::INT;</span>
2945         length = 1;
2946         break;
2947     default:
2948         // Can&#39;t handle this type
<a name="333" id="anc333"></a><span class="line-modified">2949         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getUniform&quot;, &quot;unhandled type&quot;);</span>
2950         return nullptr;
2951     }
2952     switch (baseType) {
<a name="334" id="anc334"></a><span class="line-modified">2953     case GraphicsContextGL::FLOAT: {</span>
<span class="line-modified">2954         GCGLfloat value[16] = {0};</span>
2955         if (m_isRobustnessEXTSupported)
<a name="335" id="anc335"></a><span class="line-modified">2956             m_context-&gt;getExtensions().getnUniformfvEXT(objectOrZero(program), location, 16 * sizeof(GCGLfloat), value);</span>
2957         else
2958             m_context-&gt;getUniformfv(objectOrZero(program), location, value);
2959         if (length == 1)
2960             return value[0];
2961         return Float32Array::tryCreate(value, length);
2962     }
<a name="336" id="anc336"></a><span class="line-modified">2963     case GraphicsContextGL::INT: {</span>
<span class="line-modified">2964         GCGLint value[4] = {0};</span>
2965         if (m_isRobustnessEXTSupported)
<a name="337" id="anc337"></a><span class="line-modified">2966             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GCGLint), value);</span>
2967         else
2968             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2969         if (length == 1)
2970             return value[0];
2971         return Int32Array::tryCreate(value, length);
2972     }
<a name="338" id="anc338"></a><span class="line-modified">2973     case GraphicsContextGL::BOOL: {</span>
<span class="line-modified">2974         GCGLint value[4] = {0};</span>
2975         if (m_isRobustnessEXTSupported)
<a name="339" id="anc339"></a><span class="line-modified">2976             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GCGLint), value);</span>
2977         else
2978             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2979         if (length &gt; 1) {
2980             Vector&lt;bool&gt; vector(length);
2981             for (unsigned j = 0; j &lt; length; j++)
2982                 vector[j] = value[j];
2983             return vector;
2984         }
2985         return static_cast&lt;bool&gt;(value[0]);
2986     }
2987     default:
2988         notImplemented();
2989     }
2990 
2991     // If we get here, something went wrong in our unfortunately complex logic above
<a name="340" id="anc340"></a><span class="line-modified">2992     synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getUniform&quot;, &quot;unknown error&quot;);</span>
2993     return nullptr;
2994 }
2995 
2996 RefPtr&lt;WebGLUniformLocation&gt; WebGLRenderingContextBase::getUniformLocation(WebGLProgram* program, const String&amp; name)
2997 {
2998     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniformLocation&quot;, program))
2999         return nullptr;
3000     if (!validateLocationLength(&quot;getUniformLocation&quot;, name))
3001         return nullptr;
3002     if (!validateString(&quot;getUniformLocation&quot;, name))
3003         return nullptr;
3004     if (isPrefixReserved(name))
3005         return nullptr;
3006     if (!program-&gt;getLinkStatus()) {
<a name="341" id="anc341"></a><span class="line-modified">3007         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getUniformLocation&quot;, &quot;program not linked&quot;);</span>
3008         return nullptr;
3009     }
<a name="342" id="anc342"></a><span class="line-modified">3010     GCGLint uniformLocation = m_context-&gt;getUniformLocation(objectOrZero(program), name);</span>
3011     if (uniformLocation == -1)
3012         return nullptr;
3013 
<a name="343" id="anc343"></a><span class="line-modified">3014     GCGLint activeUniforms = 0;</span>
3015 #if USE(ANGLE)
<a name="344" id="anc344"></a><span class="line-modified">3016     m_context-&gt;getProgramiv(objectOrZero(program), GraphicsContextGL::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
3017 #else
<a name="345" id="anc345"></a><span class="line-modified">3018     m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), GraphicsContextGL::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
3019 #endif
<a name="346" id="anc346"></a><span class="line-modified">3020     for (GCGLint i = 0; i &lt; activeUniforms; i++) {</span>
<span class="line-modified">3021         GraphicsContextGL::ActiveInfo info;</span>
3022         if (!m_context-&gt;getActiveUniform(objectOrZero(program), i, info))
3023             return nullptr;
3024         // Strip &quot;[0]&quot; from the name if it&#39;s an array.
3025         if (info.name.endsWith(&quot;[0]&quot;))
3026             info.name = info.name.left(info.name.length() - 3);
3027         // If it&#39;s an array, we need to iterate through each element, appending &quot;[index]&quot; to the name.
<a name="347" id="anc347"></a><span class="line-modified">3028         for (GCGLint index = 0; index &lt; info.size; ++index) {</span>
3029             String uniformName = makeString(info.name, &#39;[&#39;, index, &#39;]&#39;);
3030 
3031             if (name == uniformName || name == info.name)
3032                 return WebGLUniformLocation::create(program, uniformLocation, info.type);
3033         }
3034     }
3035     return nullptr;
3036 }
3037 
<a name="348" id="anc348"></a><span class="line-modified">3038 WebGLAny WebGLRenderingContextBase::getVertexAttrib(GCGLuint index, GCGLenum pname)</span>
3039 {
3040     if (isContextLostOrPending())
3041         return nullptr;
3042 
3043     if (index &gt;= m_maxVertexAttribs) {
<a name="349" id="anc349"></a><span class="line-modified">3044         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getVertexAttrib&quot;, &quot;index out of range&quot;);</span>
3045         return nullptr;
3046     }
3047 
3048     const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
3049 
<a name="350" id="anc350"></a><span class="line-modified">3050     if ((isWebGL2() || m_angleInstancedArrays) &amp;&amp; pname == GraphicsContextGL::VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)</span>
3051         return state.divisor;
3052 
3053     switch (pname) {
<a name="351" id="anc351"></a><span class="line-modified">3054     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:</span>
3055         if ((!isGLES2Compliant() &amp;&amp; !index &amp;&amp; m_boundVertexArrayObject-&gt;getVertexAttribState(0).bufferBinding == m_vertexAttrib0Buffer)
3056             || !state.bufferBinding
3057             || !state.bufferBinding-&gt;object())
3058             return nullptr;
3059         return state.bufferBinding;
<a name="352" id="anc352"></a><span class="line-modified">3060     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_ENABLED:</span>
3061         return state.enabled;
<a name="353" id="anc353"></a><span class="line-modified">3062     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_NORMALIZED:</span>
3063         return state.normalized;
<a name="354" id="anc354"></a><span class="line-modified">3064     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_SIZE:</span>
3065         return state.size;
<a name="355" id="anc355"></a><span class="line-modified">3066     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_STRIDE:</span>
3067         return state.originalStride;
<a name="356" id="anc356"></a><span class="line-modified">3068     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_TYPE:</span>
3069         return state.type;
<a name="357" id="anc357"></a><span class="line-modified">3070     case GraphicsContextGL::CURRENT_VERTEX_ATTRIB:</span>
3071         return Float32Array::tryCreate(m_vertexAttribValue[index].value, 4);
3072     default:
<a name="358" id="anc358"></a><span class="line-modified">3073         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getVertexAttrib&quot;, &quot;invalid parameter name&quot;);</span>
3074         return nullptr;
3075     }
3076 }
3077 
<a name="359" id="anc359"></a><span class="line-modified">3078 long long WebGLRenderingContextBase::getVertexAttribOffset(GCGLuint index, GCGLenum pname)</span>
3079 {
3080     if (isContextLostOrPending())
3081         return 0;
3082     return m_context-&gt;getVertexAttribOffset(index, pname);
3083 }
3084 
3085 bool WebGLRenderingContextBase::extensionIsEnabled(const String&amp; name)
3086 {
3087 #define CHECK_EXTENSION(variable, nameLiteral) \
3088     if (equalIgnoringASCIICase(name, nameLiteral)) \
3089         return variable != nullptr;
3090 
3091     CHECK_EXTENSION(m_extFragDepth, &quot;EXT_frag_depth&quot;);
3092     CHECK_EXTENSION(m_extBlendMinMax, &quot;EXT_blend_minmax&quot;);
3093     CHECK_EXTENSION(m_extsRGB, &quot;EXT_sRGB&quot;);
3094     CHECK_EXTENSION(m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;);
3095     CHECK_EXTENSION(m_extTextureFilterAnisotropic, &quot;WEBKIT_EXT_texture_filter_anisotropic&quot;);
3096     CHECK_EXTENSION(m_extShaderTextureLOD, &quot;EXT_shader_texture_lod&quot;);
3097     CHECK_EXTENSION(m_oesTextureFloat, &quot;OES_texture_float&quot;);
3098     CHECK_EXTENSION(m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;);
3099     CHECK_EXTENSION(m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;);
3100     CHECK_EXTENSION(m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;);
3101     CHECK_EXTENSION(m_oesStandardDerivatives, &quot;OES_standard_derivatives&quot;);
3102     CHECK_EXTENSION(m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;);
3103     CHECK_EXTENSION(m_oesElementIndexUint, &quot;OES_element_index_uint&quot;);
3104     CHECK_EXTENSION(m_webglLoseContext, &quot;WEBGL_lose_context&quot;);
3105     CHECK_EXTENSION(m_webglDebugRendererInfo, &quot;WEBGL_debug_renderer_info&quot;);
3106     CHECK_EXTENSION(m_webglDebugShaders, &quot;WEBGL_debug_shaders&quot;);
<a name="360" id="anc360"></a><span class="line-added">3107     CHECK_EXTENSION(m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;);</span>
3108     CHECK_EXTENSION(m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;);
<a name="361" id="anc361"></a><span class="line-added">3109     CHECK_EXTENSION(m_webglCompressedTextureETC, &quot;WEBGL_compressed_texture_etc&quot;);</span>
<span class="line-added">3110     CHECK_EXTENSION(m_webglCompressedTextureETC1, &quot;WEBGL_compressed_texture_etc1&quot;);</span>
3111     CHECK_EXTENSION(m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;);
3112     CHECK_EXTENSION(m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;);
3113     CHECK_EXTENSION(m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;);
3114     CHECK_EXTENSION(m_webglDrawBuffers, &quot;WEBGL_draw_buffers&quot;);
3115     CHECK_EXTENSION(m_angleInstancedArrays, &quot;ANGLE_instanced_arrays&quot;);
3116     return false;
3117 }
3118 
<a name="362" id="anc362"></a><span class="line-modified">3119 GCGLboolean WebGLRenderingContextBase::isBuffer(WebGLBuffer* buffer)</span>
3120 {
3121     if (!buffer || isContextLostOrPending())
3122         return 0;
3123 
3124     if (!buffer-&gt;hasEverBeenBound())
3125         return 0;
3126 
3127     return m_context-&gt;isBuffer(buffer-&gt;object());
3128 }
3129 
3130 bool WebGLRenderingContextBase::isContextLost() const
3131 {
3132     return m_contextLost;
3133 }
3134 
3135 bool WebGLRenderingContextBase::isContextLostOrPending()
3136 {
3137     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution) {
3138         LOG(WebGL, &quot;Context is being used. Attempt to resolve the policy.&quot;);
3139         auto* canvas = htmlCanvas();
3140         if (canvas) {
3141             Document&amp; document = canvas-&gt;document().topDocument();
3142             Page* page = document.page();
3143             if (page &amp;&amp; !document.url().isLocalFile())
3144                 page-&gt;mainFrame().loader().client().resolveWebGLPolicyForURL(document.url());
3145             // FIXME: We don&#39;t currently do anything with the result from resolution. A more
3146             // complete implementation might try to construct a real context, etc and proceed
3147             // with normal operation.
3148             // https://bugs.webkit.org/show_bug.cgi?id=129122
3149         }
3150         m_hasRequestedPolicyResolution = true;
3151     }
3152 
3153     return m_contextLost || m_isPendingPolicyResolution;
3154 }
3155 
<a name="363" id="anc363"></a><span class="line-modified">3156 GCGLboolean WebGLRenderingContextBase::isEnabled(GCGLenum cap)</span>
3157 {
3158     if (isContextLostOrPending() || !validateCapability(&quot;isEnabled&quot;, cap))
3159         return 0;
<a name="364" id="anc364"></a><span class="line-modified">3160     if (cap == GraphicsContextGL::STENCIL_TEST)</span>
3161         return m_stencilEnabled;
3162     return m_context-&gt;isEnabled(cap);
3163 }
3164 
<a name="365" id="anc365"></a><span class="line-modified">3165 GCGLboolean WebGLRenderingContextBase::isFramebuffer(WebGLFramebuffer* framebuffer)</span>
3166 {
3167     if (!framebuffer || isContextLostOrPending())
3168         return 0;
3169 
3170     if (!framebuffer-&gt;hasEverBeenBound())
3171         return 0;
3172 
3173     return m_context-&gt;isFramebuffer(framebuffer-&gt;object());
3174 }
3175 
<a name="366" id="anc366"></a><span class="line-modified">3176 GCGLboolean WebGLRenderingContextBase::isProgram(WebGLProgram* program)</span>
3177 {
3178     if (!program || isContextLostOrPending())
3179         return 0;
3180 
3181     return m_context-&gt;isProgram(program-&gt;object());
3182 }
3183 
<a name="367" id="anc367"></a><span class="line-modified">3184 GCGLboolean WebGLRenderingContextBase::isRenderbuffer(WebGLRenderbuffer* renderbuffer)</span>
3185 {
3186     if (!renderbuffer || isContextLostOrPending())
3187         return 0;
3188 
3189     if (!renderbuffer-&gt;hasEverBeenBound())
3190         return 0;
3191 
3192     return m_context-&gt;isRenderbuffer(renderbuffer-&gt;object());
3193 }
3194 
<a name="368" id="anc368"></a><span class="line-modified">3195 GCGLboolean WebGLRenderingContextBase::isShader(WebGLShader* shader)</span>
3196 {
3197     if (!shader || isContextLostOrPending())
3198         return 0;
3199 
3200     return m_context-&gt;isShader(shader-&gt;object());
3201 }
3202 
<a name="369" id="anc369"></a><span class="line-modified">3203 GCGLboolean WebGLRenderingContextBase::isTexture(WebGLTexture* texture)</span>
3204 {
3205     if (!texture || isContextLostOrPending())
3206         return 0;
3207 
3208     if (!texture-&gt;hasEverBeenBound())
3209         return 0;
3210 
3211     return m_context-&gt;isTexture(texture-&gt;object());
3212 }
3213 
<a name="370" id="anc370"></a><span class="line-modified">3214 void WebGLRenderingContextBase::lineWidth(GCGLfloat width)</span>
3215 {
3216     if (isContextLostOrPending())
3217         return;
3218     m_context-&gt;lineWidth(width);
3219 }
3220 
3221 void WebGLRenderingContextBase::linkProgram(WebGLProgram* program)
3222 {
3223     if (!linkProgramWithoutInvalidatingAttribLocations(program))
3224         return;
3225 
3226     program-&gt;increaseLinkCount();
3227 }
3228 
3229 bool WebGLRenderingContextBase::linkProgramWithoutInvalidatingAttribLocations(WebGLProgram* program)
3230 {
3231     if (isContextLostOrPending() || !validateWebGLObject(&quot;linkProgram&quot;, program))
3232         return false;
3233 
<a name="371" id="anc371"></a><span class="line-modified">3234     RefPtr&lt;WebGLShader&gt; vertexShader = program-&gt;getAttachedShader(GraphicsContextGL::VERTEX_SHADER);</span>
<span class="line-modified">3235     RefPtr&lt;WebGLShader&gt; fragmentShader = program-&gt;getAttachedShader(GraphicsContextGL::FRAGMENT_SHADER);</span>
3236     if (!vertexShader || !vertexShader-&gt;isValid() || !fragmentShader || !fragmentShader-&gt;isValid()) {
3237         program-&gt;setLinkStatus(false);
3238         return false;
3239     }
3240 
3241 #if !USE(ANGLE)
3242     if (!m_context-&gt;precisionsMatch(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))
3243         || !m_context-&gt;checkVaryingsPacking(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))) {
3244         program-&gt;setLinkStatus(false);
3245         return false;
3246     }
3247 #endif
3248 
3249     m_context-&gt;linkProgram(objectOrZero(program));
3250     return true;
3251 }
3252 
<a name="372" id="anc372"></a><span class="line-modified">3253 void WebGLRenderingContextBase::pixelStorei(GCGLenum pname, GCGLint param)</span>
3254 {
3255     if (isContextLostOrPending())
3256         return;
3257     switch (pname) {
<a name="373" id="anc373"></a><span class="line-modified">3258     case GraphicsContextGL::UNPACK_FLIP_Y_WEBGL:</span>
3259         m_unpackFlipY = param;
3260         break;
<a name="374" id="anc374"></a><span class="line-modified">3261     case GraphicsContextGL::UNPACK_PREMULTIPLY_ALPHA_WEBGL:</span>
3262         m_unpackPremultiplyAlpha = param;
3263         break;
<a name="375" id="anc375"></a><span class="line-modified">3264     case GraphicsContextGL::UNPACK_COLORSPACE_CONVERSION_WEBGL:</span>
<span class="line-modified">3265         if (param == GraphicsContextGL::BROWSER_DEFAULT_WEBGL || param == GraphicsContextGL::NONE)</span>
<span class="line-modified">3266             m_unpackColorspaceConversion = static_cast&lt;GCGLenum&gt;(param);</span>
3267         else {
<a name="376" id="anc376"></a><span class="line-modified">3268             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for UNPACK_COLORSPACE_CONVERSION_WEBGL&quot;);</span>
3269             return;
3270         }
3271         break;
<a name="377" id="anc377"></a><span class="line-modified">3272     case GraphicsContextGL::PACK_ALIGNMENT:</span>
<span class="line-modified">3273     case GraphicsContextGL::UNPACK_ALIGNMENT:</span>
3274         if (param == 1 || param == 2 || param == 4 || param == 8) {
<a name="378" id="anc378"></a><span class="line-modified">3275             if (pname == GraphicsContextGL::PACK_ALIGNMENT)</span>
3276                 m_packAlignment = param;
<a name="379" id="anc379"></a><span class="line-modified">3277             else // GraphicsContextGL::UNPACK_ALIGNMENT:</span>
3278                 m_unpackAlignment = param;
3279             m_context-&gt;pixelStorei(pname, param);
3280         } else {
<a name="380" id="anc380"></a><span class="line-modified">3281             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for alignment&quot;);</span>
3282             return;
3283         }
3284         break;
3285     default:
<a name="381" id="anc381"></a><span class="line-modified">3286         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;pixelStorei&quot;, &quot;invalid parameter name&quot;);</span>
3287         return;
3288     }
3289 }
3290 
<a name="382" id="anc382"></a><span class="line-modified">3291 void WebGLRenderingContextBase::polygonOffset(GCGLfloat factor, GCGLfloat units)</span>
3292 {
3293     if (isContextLostOrPending())
3294         return;
3295     m_context-&gt;polygonOffset(factor, units);
3296 }
3297 
3298 enum class InternalFormatTheme {
3299     None,
3300     NormalizedFixedPoint,
3301     Packed,
3302     SignedNormalizedFixedPoint,
3303     FloatingPoint,
3304     SignedInteger,
3305     UnsignedInteger
3306 };
3307 
<a name="383" id="anc383"></a><span class="line-modified">3308 static InternalFormatTheme internalFormatTheme(GCGLenum internalFormat)</span>
3309 {
3310     switch (internalFormat) {
<a name="384" id="anc384"></a><span class="line-modified">3311     case GraphicsContextGL::RGB:</span>
<span class="line-modified">3312     case GraphicsContextGL::RGBA:</span>
<span class="line-modified">3313     case GraphicsContextGL::LUMINANCE_ALPHA:</span>
<span class="line-modified">3314     case GraphicsContextGL::LUMINANCE:</span>
<span class="line-modified">3315     case GraphicsContextGL::ALPHA:</span>
<span class="line-modified">3316     case GraphicsContextGL::R8:</span>
<span class="line-modified">3317     case GraphicsContextGL::RG8:</span>
<span class="line-modified">3318     case GraphicsContextGL::RGB8:</span>
<span class="line-modified">3319     case GraphicsContextGL::SRGB8:</span>
<span class="line-modified">3320     case GraphicsContextGL::RGBA8:</span>
<span class="line-modified">3321     case GraphicsContextGL::SRGB8_ALPHA8:</span>
<span class="line-modified">3322     case GraphicsContextGL::SRGB_ALPHA:</span>
3323         return InternalFormatTheme::NormalizedFixedPoint;
<a name="385" id="anc385"></a><span class="line-modified">3324     case GraphicsContextGL::RGB565:</span>
<span class="line-modified">3325     case GraphicsContextGL::RGB5_A1:</span>
<span class="line-modified">3326     case GraphicsContextGL::RGBA4:</span>
<span class="line-modified">3327     case GraphicsContextGL::RGB9_E5:</span>
<span class="line-modified">3328     case GraphicsContextGL::RGB10_A2:</span>
<span class="line-modified">3329     case GraphicsContextGL::R11F_G11F_B10F:</span>
<span class="line-modified">3330     case GraphicsContextGL::RGB10_A2UI:</span>
3331         return InternalFormatTheme::Packed;
<a name="386" id="anc386"></a><span class="line-modified">3332     case GraphicsContextGL::R8_SNORM:</span>
<span class="line-modified">3333     case GraphicsContextGL::RG8_SNORM:</span>
<span class="line-modified">3334     case GraphicsContextGL::RGB8_SNORM:</span>
<span class="line-modified">3335     case GraphicsContextGL::RGBA8_SNORM:</span>
3336         return InternalFormatTheme::SignedNormalizedFixedPoint;
<a name="387" id="anc387"></a><span class="line-modified">3337     case GraphicsContextGL::R16F:</span>
<span class="line-modified">3338     case GraphicsContextGL::R32F:</span>
<span class="line-modified">3339     case GraphicsContextGL::RG16F:</span>
<span class="line-modified">3340     case GraphicsContextGL::RG32F:</span>
<span class="line-modified">3341     case GraphicsContextGL::RGB16F:</span>
<span class="line-modified">3342     case GraphicsContextGL::RGB32F:</span>
<span class="line-modified">3343     case GraphicsContextGL::RGBA16F:</span>
<span class="line-modified">3344     case GraphicsContextGL::RGBA32F:</span>
3345         return InternalFormatTheme::FloatingPoint;
<a name="388" id="anc388"></a><span class="line-modified">3346     case GraphicsContextGL::R8I:</span>
<span class="line-modified">3347     case GraphicsContextGL::R16I:</span>
<span class="line-modified">3348     case GraphicsContextGL::R32I:</span>
<span class="line-modified">3349     case GraphicsContextGL::RG8I:</span>
<span class="line-modified">3350     case GraphicsContextGL::RG16I:</span>
<span class="line-modified">3351     case GraphicsContextGL::RG32I:</span>
<span class="line-modified">3352     case GraphicsContextGL::RGB8I:</span>
<span class="line-modified">3353     case GraphicsContextGL::RGB16I:</span>
<span class="line-modified">3354     case GraphicsContextGL::RGB32I:</span>
<span class="line-modified">3355     case GraphicsContextGL::RGBA8I:</span>
<span class="line-modified">3356     case GraphicsContextGL::RGBA16I:</span>
<span class="line-modified">3357     case GraphicsContextGL::RGBA32I:</span>
3358         return InternalFormatTheme::SignedInteger;
<a name="389" id="anc389"></a><span class="line-modified">3359     case GraphicsContextGL::R8UI:</span>
<span class="line-modified">3360     case GraphicsContextGL::R16UI:</span>
<span class="line-modified">3361     case GraphicsContextGL::R32UI:</span>
<span class="line-modified">3362     case GraphicsContextGL::RG8UI:</span>
<span class="line-modified">3363     case GraphicsContextGL::RG16UI:</span>
<span class="line-modified">3364     case GraphicsContextGL::RG32UI:</span>
<span class="line-modified">3365     case GraphicsContextGL::RGB8UI:</span>
<span class="line-modified">3366     case GraphicsContextGL::RGB16UI:</span>
<span class="line-modified">3367     case GraphicsContextGL::RGB32UI:</span>
<span class="line-modified">3368     case GraphicsContextGL::RGBA8UI:</span>
<span class="line-modified">3369     case GraphicsContextGL::RGBA16UI:</span>
<span class="line-modified">3370     case GraphicsContextGL::RGBA32UI:</span>
3371         return InternalFormatTheme::UnsignedInteger;
3372     default:
3373         return InternalFormatTheme::None;
3374     }
3375 }
3376 
<a name="390" id="anc390"></a><span class="line-modified">3377 static int numberOfComponentsForFormat(GCGLenum format)</span>
3378 {
3379     switch (format) {
<a name="391" id="anc391"></a><span class="line-modified">3380     case GraphicsContextGL::RED:</span>
<span class="line-modified">3381     case GraphicsContextGL::RED_INTEGER:</span>
3382         return 1;
<a name="392" id="anc392"></a><span class="line-modified">3383     case GraphicsContextGL::RG:</span>
<span class="line-modified">3384     case GraphicsContextGL::RG_INTEGER:</span>
3385         return 2;
<a name="393" id="anc393"></a><span class="line-modified">3386     case GraphicsContextGL::RGB:</span>
<span class="line-modified">3387     case GraphicsContextGL::RGB_INTEGER:</span>
3388         return 3;
<a name="394" id="anc394"></a><span class="line-modified">3389     case GraphicsContextGL::RGBA:</span>
<span class="line-modified">3390     case GraphicsContextGL::RGBA_INTEGER:</span>
3391         return 4;
3392     default:
3393         return 0;
3394     }
3395 }
3396 
<a name="395" id="anc395"></a><span class="line-modified">3397 static int numberOfComponentsForInternalFormat(GCGLenum internalFormat)</span>
3398 {
3399     switch (internalFormat) {
<a name="396" id="anc396"></a><span class="line-modified">3400     case GraphicsContextGL::LUMINANCE:</span>
<span class="line-modified">3401     case GraphicsContextGL::ALPHA:</span>
<span class="line-modified">3402     case GraphicsContextGL::R8:</span>
<span class="line-modified">3403     case GraphicsContextGL::R8_SNORM:</span>
<span class="line-modified">3404     case GraphicsContextGL::R16F:</span>
<span class="line-modified">3405     case GraphicsContextGL::R32F:</span>
<span class="line-modified">3406     case GraphicsContextGL::R8UI:</span>
<span class="line-modified">3407     case GraphicsContextGL::R8I:</span>
<span class="line-modified">3408     case GraphicsContextGL::R16UI:</span>
<span class="line-modified">3409     case GraphicsContextGL::R16I:</span>
<span class="line-modified">3410     case GraphicsContextGL::R32UI:</span>
<span class="line-modified">3411     case GraphicsContextGL::R32I:</span>
<span class="line-modified">3412     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="line-modified">3413     case GraphicsContextGL::DEPTH_COMPONENT24:</span>
<span class="line-modified">3414     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
3415         return 1;
<a name="397" id="anc397"></a><span class="line-modified">3416     case GraphicsContextGL::RG8:</span>
<span class="line-modified">3417     case GraphicsContextGL::LUMINANCE_ALPHA:</span>
<span class="line-modified">3418     case GraphicsContextGL::RG8_SNORM:</span>
<span class="line-modified">3419     case GraphicsContextGL::RG16F:</span>
<span class="line-modified">3420     case GraphicsContextGL::RG32F:</span>
<span class="line-modified">3421     case GraphicsContextGL::RG8UI:</span>
<span class="line-modified">3422     case GraphicsContextGL::RG8I:</span>
<span class="line-modified">3423     case GraphicsContextGL::RG16UI:</span>
<span class="line-modified">3424     case GraphicsContextGL::RG16I:</span>
<span class="line-modified">3425     case GraphicsContextGL::RG32UI:</span>
<span class="line-modified">3426     case GraphicsContextGL::RG32I:</span>
<span class="line-modified">3427     case GraphicsContextGL::DEPTH24_STENCIL8:</span>
<span class="line-modified">3428     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
3429         return 2;
<a name="398" id="anc398"></a><span class="line-modified">3430     case GraphicsContextGL::RGB:</span>
<span class="line-modified">3431     case GraphicsContextGL::RGB8:</span>
<span class="line-modified">3432     case GraphicsContextGL::SRGB8:</span>
<span class="line-modified">3433     case GraphicsContextGL::RGB565:</span>
<span class="line-modified">3434     case GraphicsContextGL::RGB8_SNORM:</span>
<span class="line-modified">3435     case GraphicsContextGL::R11F_G11F_B10F:</span>
<span class="line-modified">3436     case GraphicsContextGL::RGB9_E5:</span>
<span class="line-modified">3437     case GraphicsContextGL::RGB16F:</span>
<span class="line-modified">3438     case GraphicsContextGL::RGB32F:</span>
<span class="line-modified">3439     case GraphicsContextGL::RGB8UI:</span>
<span class="line-modified">3440     case GraphicsContextGL::RGB8I:</span>
<span class="line-modified">3441     case GraphicsContextGL::RGB16UI:</span>
<span class="line-modified">3442     case GraphicsContextGL::RGB16I:</span>
<span class="line-modified">3443     case GraphicsContextGL::RGB32UI:</span>
<span class="line-modified">3444     case GraphicsContextGL::RGB32I:</span>
3445         return 3;
<a name="399" id="anc399"></a><span class="line-modified">3446     case GraphicsContextGL::RGBA:</span>
<span class="line-modified">3447     case GraphicsContextGL::RGBA8:</span>
<span class="line-modified">3448     case GraphicsContextGL::SRGB_ALPHA:</span>
<span class="line-modified">3449     case GraphicsContextGL::SRGB8_ALPHA8:</span>
<span class="line-modified">3450     case GraphicsContextGL::RGBA8_SNORM:</span>
<span class="line-modified">3451     case GraphicsContextGL::RGB5_A1:</span>
<span class="line-modified">3452     case GraphicsContextGL::RGBA4:</span>
<span class="line-modified">3453     case GraphicsContextGL::RGB10_A2:</span>
<span class="line-modified">3454     case GraphicsContextGL::RGBA16F:</span>
<span class="line-modified">3455     case GraphicsContextGL::RGBA32F:</span>
<span class="line-modified">3456     case GraphicsContextGL::RGBA8UI:</span>
<span class="line-modified">3457     case GraphicsContextGL::RGBA8I:</span>
<span class="line-modified">3458     case GraphicsContextGL::RGB10_A2UI:</span>
<span class="line-modified">3459     case GraphicsContextGL::RGBA16UI:</span>
<span class="line-modified">3460     case GraphicsContextGL::RGBA16I:</span>
<span class="line-modified">3461     case GraphicsContextGL::RGBA32UI:</span>
<span class="line-modified">3462     case GraphicsContextGL::RGBA32I:</span>
3463         return 4;
3464     default:
3465         return 0;
3466     }
3467 }
3468 
<a name="400" id="anc400"></a><span class="line-modified">3469 void WebGLRenderingContextBase::readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, ArrayBufferView&amp; pixels)</span>
3470 {
3471     if (isContextLostOrPending())
3472         return;
3473     // Due to WebGL&#39;s same-origin restrictions, it is not possible to
3474     // taint the origin using the WebGL API.
3475     ASSERT(canvasBase().originClean());
3476 
<a name="401" id="anc401"></a><span class="line-modified">3477     GCGLenum internalFormat = 0;</span>
3478     if (m_framebufferBinding) {
3479         const char* reason = &quot;framebuffer incomplete&quot;;
<a name="402" id="anc402"></a><span class="line-modified">3480         if (!m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="line-modified">3481             synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;readPixels&quot;, reason);</span>
3482             return;
3483         }
3484         // FIXME: readBuffer() should affect this
3485         internalFormat = m_framebufferBinding-&gt;getColorBufferFormat();
3486     } else {
3487         if (m_attributes.alpha)
<a name="403" id="anc403"></a><span class="line-modified">3488             internalFormat = GraphicsContextGL::RGBA8;</span>
3489         else
<a name="404" id="anc404"></a><span class="line-modified">3490             internalFormat = GraphicsContextGL::RGB8;</span>
3491     }
3492 
3493     if (!internalFormat) {
<a name="405" id="anc405"></a><span class="line-modified">3494         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;readPixels&quot;, &quot;Missing attachment&quot;);</span>
3495         return;
3496     }
3497 
3498     if (isWebGL1()) {
3499         switch (format) {
<a name="406" id="anc406"></a><span class="line-modified">3500         case GraphicsContextGL::ALPHA:</span>
<span class="line-modified">3501         case GraphicsContextGL::RGB:</span>
<span class="line-modified">3502         case GraphicsContextGL::RGBA:</span>
3503             break;
3504         default:
<a name="407" id="anc407"></a><span class="line-modified">3505             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid format&quot;);</span>
3506             return;
3507         }
3508         switch (type) {
<a name="408" id="anc408"></a><span class="line-modified">3509         case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">3510         case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:</span>
<span class="line-modified">3511         case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="line-modified">3512         case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:</span>
3513             break;
<a name="409" id="anc409"></a><span class="line-modified">3514         case GraphicsContextGL::FLOAT:</span>
3515             if (!m_oesTextureFloat &amp;&amp; !m_oesTextureHalfFloat) {
<a name="410" id="anc410"></a><span class="line-modified">3516                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
3517                 return;
3518             }
3519             break;
3520         default:
<a name="411" id="anc411"></a><span class="line-modified">3521             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
3522             return;
3523         }
<a name="412" id="anc412"></a><span class="line-modified">3524         if (format != GraphicsContextGL::RGBA || (type != GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; type != GraphicsContextGL::FLOAT)) {</span>
<span class="line-modified">3525             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;readPixels&quot;, &quot;format not RGBA or type not UNSIGNED_BYTE|FLOAT&quot;);</span>
3526             return;
3527         }
3528     }
3529 
3530     InternalFormatTheme internalFormatTheme = WebCore::internalFormatTheme(internalFormat);
3531     int internalFormatComponentCount = numberOfComponentsForInternalFormat(internalFormat);
3532     if (internalFormatTheme == InternalFormatTheme::None || !internalFormatComponentCount) {
<a name="413" id="anc413"></a><span class="line-modified">3533         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);</span>
3534         return;
3535     }
3536 
3537 #define CHECK_COMPONENT_COUNT \
3538     if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \
<a name="414" id="anc414"></a><span class="line-modified">3539         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
3540         return; \
3541     }
3542 
3543 #define INTERNAL_FORMAT_CHECK(typeMacro, pixelTypeMacro) \
<a name="415" id="anc415"></a><span class="line-modified">3544     if (type != GraphicsContextGLOpenGL::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3545         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
3546         return; \
3547     } \
<a name="416" id="anc416"></a><span class="line-modified">3548     if (format != GraphicsContextGL::RED &amp;&amp; format != GraphicsContextGL::RG &amp;&amp; format != GraphicsContextGL::RGB &amp;&amp; format != GraphicsContextGL::RGBA) { \</span>
<span class="line-modified">3549         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
3550         return; \
3551     } \
3552     CHECK_COMPONENT_COUNT
3553 
3554 #define INTERNAL_FORMAT_INTEGER_CHECK(typeMacro, pixelTypeMacro) \
<a name="417" id="anc417"></a><span class="line-modified">3555     if (type != GraphicsContextGLOpenGL::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3556         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
3557         return; \
3558     } \
<a name="418" id="anc418"></a><span class="line-modified">3559     if (format != GraphicsContextGL::RED_INTEGER &amp;&amp; format != GraphicsContextGL::RG_INTEGER &amp;&amp; format != GraphicsContextGL::RGB_INTEGER &amp;&amp; format != GraphicsContextGL::RGBA_INTEGER) { \</span>
<span class="line-modified">3560         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
3561         return; \
3562     } \
3563     CHECK_COMPONENT_COUNT
3564 
<a name="419" id="anc419"></a><span class="line-modified">3565 #define CASE_PACKED_INTERNAL_FORMAT_CHECK(internalFormatMacro, formatMacro, type0Macro, pixelType0Macro, type1Macro, pixelType1Macro) case GraphicsContextGLOpenGL::internalFormatMacro: \</span>
<span class="line-modified">3566     if (!(type == GraphicsContextGLOpenGL::type0Macro &amp;&amp; pixels.getType() == JSC::pixelType0Macro) \</span>
<span class="line-modified">3567         &amp;&amp; !(type == GraphicsContextGLOpenGL::type1Macro &amp;&amp; pixels.getType() == JSC::pixelType1Macro)) { \</span>
<span class="line-modified">3568         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
3569         return; \
3570     } \
<a name="420" id="anc420"></a><span class="line-modified">3571     if (format != GraphicsContextGLOpenGL::formatMacro) { \</span>
<span class="line-modified">3572         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Invalid format&quot;); \</span>
3573         return; \
3574     } \
3575     break;
3576 
3577     switch (internalFormatTheme) {
3578     case InternalFormatTheme::NormalizedFixedPoint:
<a name="421" id="anc421"></a><span class="line-modified">3579         if (type == GraphicsContextGL::FLOAT) {</span>
3580             INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);
3581         } else {
3582             INTERNAL_FORMAT_CHECK(UNSIGNED_BYTE, TypeUint8);
3583         }
3584         break;
3585     case InternalFormatTheme::SignedNormalizedFixedPoint:
3586         INTERNAL_FORMAT_CHECK(BYTE, TypeInt8);
3587         break;
3588     case InternalFormatTheme::FloatingPoint:
3589         INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);
3590         break;
3591     case InternalFormatTheme::SignedInteger:
3592         INTERNAL_FORMAT_INTEGER_CHECK(INT, TypeInt32);
3593         break;
3594     case InternalFormatTheme::UnsignedInteger:
3595         INTERNAL_FORMAT_INTEGER_CHECK(UNSIGNED_INT, TypeUint32);
3596         break;
3597     case InternalFormatTheme::Packed:
3598         switch (internalFormat) {
3599             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB565        , RGB         , UNSIGNED_SHORT_5_6_5        , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );
3600             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB5_A1       , RGBA        , UNSIGNED_SHORT_5_5_5_1      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );
3601             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGBA4         , RGBA        , UNSIGNED_SHORT_4_4_4_4      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );
3602             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB9_E5       , RGB         , UNSIGNED_INT_5_9_9_9_REV    , TypeUint32, UNSIGNED_INT_5_9_9_9_REV   , TypeUint32 );
3603             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2      , RGBA        , UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );
3604             CASE_PACKED_INTERNAL_FORMAT_CHECK(R11F_G11F_B10F, RGB         , UNSIGNED_INT_10F_11F_11F_REV, TypeUint32, FLOAT                      , TypeFloat32);
3605             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2UI    , RGBA_INTEGER, UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );
3606         }
3607         break;
3608     case InternalFormatTheme::None:
3609         ASSERT_NOT_REACHED();
3610     }
3611 #undef CHECK_COMPONENT_COUNT
3612 #undef INTERNAL_FORMAT_CHECK
3613 #undef INTERNAL_FORMAT_INTEGER_CHECK
3614 #undef CASE_PACKED_INTERNAL_FORMAT_CHECK
3615 
3616     // Calculate array size, taking into consideration of PACK_ALIGNMENT.
3617     unsigned totalBytesRequired = 0;
3618     unsigned padding = 0;
3619     if (!m_isRobustnessEXTSupported) {
<a name="422" id="anc422"></a><span class="line-modified">3620         GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_packAlignment, &amp;totalBytesRequired, &amp;padding);</span>
<span class="line-modified">3621         if (error != GraphicsContextGL::NO_ERROR) {</span>
3622             synthesizeGLError(error, &quot;readPixels&quot;, &quot;invalid dimensions&quot;);
3623             return;
3624         }
3625         if (pixels.byteLength() &lt; totalBytesRequired) {
<a name="423" id="anc423"></a><span class="line-modified">3626             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;readPixels&quot;, &quot;ArrayBufferView not large enough for dimensions&quot;);</span>
3627             return;
3628         }
3629     }
3630 
3631     clearIfComposited();
3632     void* data = pixels.baseAddress();
3633 
3634     if (m_isRobustnessEXTSupported)
3635         m_context-&gt;getExtensions().readnPixelsEXT(x, y, width, height, format, type, pixels.byteLength(), data);
3636     else
3637         m_context-&gt;readPixels(x, y, width, height, format, type, data);
3638 }
3639 
3640 void WebGLRenderingContextBase::releaseShaderCompiler()
3641 {
3642     if (isContextLostOrPending())
3643         return;
3644     m_context-&gt;releaseShaderCompiler();
3645 }
3646 
<a name="424" id="anc424"></a><span class="line-modified">3647 void WebGLRenderingContextBase::sampleCoverage(GCGLfloat value, GCGLboolean invert)</span>
3648 {
3649     if (isContextLostOrPending())
3650         return;
3651     m_context-&gt;sampleCoverage(value, invert);
3652 }
3653 
<a name="425" id="anc425"></a><span class="line-modified">3654 void WebGLRenderingContextBase::scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)</span>
3655 {
3656     if (isContextLostOrPending())
3657         return;
3658     if (!validateSize(&quot;scissor&quot;, width, height))
3659         return;
3660     m_context-&gt;scissor(x, y, width, height);
3661 }
3662 
3663 void WebGLRenderingContextBase::shaderSource(WebGLShader* shader, const String&amp; string)
3664 {
3665     if (isContextLostOrPending() || !validateWebGLObject(&quot;shaderSource&quot;, shader))
3666         return;
<a name="426" id="anc426"></a><span class="line-added">3667 #if USE(ANGLE)</span>
<span class="line-added">3668     m_context-&gt;shaderSource(objectOrZero(shader), string);</span>
<span class="line-added">3669 #else</span>
3670     String stringWithoutComments = StripComments(string).result();
3671     if (!validateString(&quot;shaderSource&quot;, stringWithoutComments))
3672         return;
<a name="427" id="anc427"></a>
3673     m_context-&gt;shaderSource(objectOrZero(shader), stringWithoutComments);
<a name="428" id="anc428"></a><span class="line-added">3674 #endif</span>
<span class="line-added">3675     shader-&gt;setSource(string);</span>
3676 }
3677 
<a name="429" id="anc429"></a><span class="line-modified">3678 void WebGLRenderingContextBase::stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask)</span>
3679 {
3680     if (isContextLostOrPending())
3681         return;
3682     if (!validateStencilFunc(&quot;stencilFunc&quot;, func))
3683         return;
3684     m_stencilFuncRef = ref;
3685     m_stencilFuncRefBack = ref;
3686     m_stencilFuncMask = mask;
3687     m_stencilFuncMaskBack = mask;
3688     m_context-&gt;stencilFunc(func, ref, mask);
3689 }
3690 
<a name="430" id="anc430"></a><span class="line-modified">3691 void WebGLRenderingContextBase::stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask)</span>
3692 {
3693     if (isContextLostOrPending())
3694         return;
3695     if (!validateStencilFunc(&quot;stencilFuncSeparate&quot;, func))
3696         return;
3697     switch (face) {
<a name="431" id="anc431"></a><span class="line-modified">3698     case GraphicsContextGL::FRONT_AND_BACK:</span>
3699         m_stencilFuncRef = ref;
3700         m_stencilFuncRefBack = ref;
3701         m_stencilFuncMask = mask;
3702         m_stencilFuncMaskBack = mask;
3703         break;
<a name="432" id="anc432"></a><span class="line-modified">3704     case GraphicsContextGL::FRONT:</span>
3705         m_stencilFuncRef = ref;
3706         m_stencilFuncMask = mask;
3707         break;
<a name="433" id="anc433"></a><span class="line-modified">3708     case GraphicsContextGL::BACK:</span>
3709         m_stencilFuncRefBack = ref;
3710         m_stencilFuncMaskBack = mask;
3711         break;
3712     default:
<a name="434" id="anc434"></a><span class="line-modified">3713         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;stencilFuncSeparate&quot;, &quot;invalid face&quot;);</span>
3714         return;
3715     }
3716     m_context-&gt;stencilFuncSeparate(face, func, ref, mask);
3717 }
3718 
<a name="435" id="anc435"></a><span class="line-modified">3719 void WebGLRenderingContextBase::stencilMask(GCGLuint mask)</span>
3720 {
3721     if (isContextLostOrPending())
3722         return;
3723     m_stencilMask = mask;
3724     m_stencilMaskBack = mask;
3725     m_context-&gt;stencilMask(mask);
3726 }
3727 
<a name="436" id="anc436"></a><span class="line-modified">3728 void WebGLRenderingContextBase::stencilMaskSeparate(GCGLenum face, GCGLuint mask)</span>
3729 {
3730     if (isContextLostOrPending())
3731         return;
3732     switch (face) {
<a name="437" id="anc437"></a><span class="line-modified">3733     case GraphicsContextGL::FRONT_AND_BACK:</span>
3734         m_stencilMask = mask;
3735         m_stencilMaskBack = mask;
3736         break;
<a name="438" id="anc438"></a><span class="line-modified">3737     case GraphicsContextGL::FRONT:</span>
3738         m_stencilMask = mask;
3739         break;
<a name="439" id="anc439"></a><span class="line-modified">3740     case GraphicsContextGL::BACK:</span>
3741         m_stencilMaskBack = mask;
3742         break;
3743     default:
<a name="440" id="anc440"></a><span class="line-modified">3744         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;stencilMaskSeparate&quot;, &quot;invalid face&quot;);</span>
3745         return;
3746     }
3747     m_context-&gt;stencilMaskSeparate(face, mask);
3748 }
3749 
<a name="441" id="anc441"></a><span class="line-modified">3750 void WebGLRenderingContextBase::stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass)</span>
3751 {
3752     if (isContextLostOrPending())
3753         return;
3754     m_context-&gt;stencilOp(fail, zfail, zpass);
3755 }
3756 
<a name="442" id="anc442"></a><span class="line-modified">3757 void WebGLRenderingContextBase::stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass)</span>
3758 {
3759     if (isContextLostOrPending())
3760         return;
3761     m_context-&gt;stencilOpSeparate(face, fail, zfail, zpass);
3762 }
3763 
<a name="443" id="anc443"></a><span class="line-modified">3764 void WebGLRenderingContextBase::texImage2DBase(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels)</span>
3765 {
3766     // FIXME: For now we ignore any errors returned.
3767     auto tex = validateTextureBinding(&quot;texImage2D&quot;, target, true);
3768     ASSERT(validateTexFuncParameters(&quot;texImage2D&quot;, TexImage, target, level, internalFormat, width, height, border, format, type));
3769     ASSERT(tex);
3770     ASSERT(validateNPOTTextureLevel(width, height, level, &quot;texImage2D&quot;));
3771     if (!pixels) {
3772         if (!m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border, format, type, m_unpackAlignment))
3773             return;
3774     } else {
3775         ASSERT(validateSettableTexInternalFormat(&quot;texImage2D&quot;, internalFormat));
3776         m_context-&gt;moveErrorsToSyntheticErrorList();
3777         m_context-&gt;texImage2D(target, level, internalFormat, width, height,
3778                               border, format, type, pixels);
3779         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
3780             // The texImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
3781             tex-&gt;markInvalid(target, level);
3782             return;
3783         }
3784     }
3785     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, type);
3786 }
3787 
<a name="444" id="anc444"></a><span class="line-modified">3788 void WebGLRenderingContextBase::texImage2DImpl(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Image* image, GraphicsContextGL::DOMSource domSource, bool flipY, bool premultiplyAlpha)</span>
3789 {
3790     Vector&lt;uint8_t&gt; data;
<a name="445" id="anc445"></a><span class="line-modified">3791     GraphicsContextGLOpenGL::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContextGL::NONE);</span>
3792     if (!imageExtractor.extractSucceeded()) {
<a name="446" id="anc446"></a><span class="line-modified">3793         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
3794         return;
3795     }
<a name="447" id="anc447"></a><span class="line-modified">3796     GraphicsContextGL::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();</span>
<span class="line-modified">3797     GraphicsContextGL::AlphaOp alphaOp = imageExtractor.imageAlphaOp();</span>
3798     const void* imagePixelData = imageExtractor.imagePixelData();
3799 
3800     bool needConversion = true;
<a name="448" id="anc448"></a><span class="line-modified">3801     if (type == GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContextGL::DataFormat::RGBA8 &amp;&amp; format == GraphicsContextGL::RGBA &amp;&amp; alphaOp == GraphicsContextGL::AlphaOp::DoNothing &amp;&amp; !flipY)</span>
3802         needConversion = false;
3803     else {
3804         if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
<a name="449" id="anc449"></a><span class="line-modified">3805             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;packImage error&quot;);</span>
3806             return;
3807         }
3808     }
3809 
3810     if (m_unpackAlignment != 1)
<a name="450" id="anc450"></a><span class="line-modified">3811         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
3812     texImage2DBase(target, level, internalformat, image-&gt;width(), image-&gt;height(), 0, format, type, needConversion ? data.data() : imagePixelData);
3813     if (m_unpackAlignment != 1)
<a name="451" id="anc451"></a><span class="line-modified">3814         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3815 }
3816 
<a name="452" id="anc452"></a><span class="line-modified">3817 bool WebGLRenderingContextBase::validateTexFunc(const char* functionName, TexFuncValidationFunctionType functionType, TexFuncValidationSourceType sourceType, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLint xoffset, GCGLint yoffset)</span>
3818 {
3819     if (!validateTexFuncParameters(functionName, functionType, target, level, internalFormat, width, height, border, format, type))
3820         return false;
3821 
3822     auto texture = validateTextureBinding(functionName, target, true);
3823     if (!texture)
3824         return false;
3825 
3826     if (functionType != TexSubImage) {
3827         if (functionType == TexImage &amp;&amp; texture-&gt;immutable()) {
<a name="453" id="anc453"></a><span class="line-modified">3828             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;texStorage() called on this texture previously&quot;);</span>
3829             return false;
3830         }
3831         if (!validateNPOTTextureLevel(width, height, level, functionName))
3832             return false;
3833         // For SourceArrayBufferView, function validateTexFuncData() would handle whether to validate the SettableTexFormat
3834         // by checking if the ArrayBufferView is null or not.
3835         if (sourceType != SourceArrayBufferView) {
3836             if (!validateSettableTexInternalFormat(functionName, internalFormat))
3837                 return false;
3838         }
3839     } else {
3840         if (!validateSettableTexInternalFormat(functionName, internalFormat))
3841             return false;
3842         if (!validateSize(functionName, xoffset, yoffset))
3843             return false;
3844         // Before checking if it is in the range, check if overflow happens first.
3845         if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
<a name="454" id="anc454"></a><span class="line-modified">3846             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;bad dimensions&quot;);</span>
3847             return false;
3848         }
3849         if (xoffset + width &gt; texture-&gt;getWidth(target, level) || yoffset + height &gt; texture-&gt;getHeight(target, level)) {
<a name="455" id="anc455"></a><span class="line-modified">3850             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;dimensions out of range&quot;);</span>
3851             return false;
3852         }
3853         if (texture-&gt;getInternalFormat(target, level) != internalFormat || (isWebGL1() &amp;&amp; texture-&gt;getType(target, level) != type)) {
<a name="456" id="anc456"></a><span class="line-modified">3854             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;type and format do not match texture&quot;);</span>
3855             return false;
3856         }
3857     }
3858 
3859     return true;
3860 }
3861 
<a name="457" id="anc457"></a><span class="line-modified">3862 void WebGLRenderingContextBase::texImage2D(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)</span>
3863 {
3864     if (isContextLostOrPending() || !validateTexFuncData(&quot;texImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullAllowed)
3865         || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceArrayBufferView, target, level, internalFormat, width, height, border, format, type, 0, 0))
3866         return;
3867     void* data = pixels ? pixels-&gt;baseAddress() : 0;
3868     Vector&lt;uint8_t&gt; tempData;
3869     bool changeUnpackAlignment = false;
3870     if (data &amp;&amp; (m_unpackFlipY || m_unpackPremultiplyAlpha)) {
3871         if (!m_context-&gt;extractTextureData(width, height, format, type,
3872                                            m_unpackAlignment,
3873                                            m_unpackFlipY, m_unpackPremultiplyAlpha,
3874                                            data,
3875                                            tempData))
3876             return;
3877         data = tempData.data();
3878         changeUnpackAlignment = true;
3879     }
3880     if (changeUnpackAlignment)
<a name="458" id="anc458"></a><span class="line-modified">3881         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
3882     texImage2DBase(target, level, internalFormat, width, height, border, format, type, data);
3883     if (changeUnpackAlignment)
<a name="459" id="anc459"></a><span class="line-modified">3884         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3885 }
3886 
<a name="460" id="anc460"></a><span class="line-modified">3887 void WebGLRenderingContextBase::texSubImage2DImpl(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Image* image, GraphicsContextGL::DOMSource domSource, bool flipY, bool premultiplyAlpha)</span>
3888 {
3889     Vector&lt;uint8_t&gt; data;
<a name="461" id="anc461"></a><span class="line-modified">3890     GraphicsContextGLOpenGL::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContextGL::NONE);</span>
3891     if (!imageExtractor.extractSucceeded()) {
<a name="462" id="anc462"></a><span class="line-modified">3892         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image&quot;);</span>
3893         return;
3894     }
<a name="463" id="anc463"></a><span class="line-modified">3895     GraphicsContextGL::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();</span>
<span class="line-modified">3896     GraphicsContextGL::AlphaOp alphaOp = imageExtractor.imageAlphaOp();</span>
3897     const void* imagePixelData = imageExtractor.imagePixelData();
3898 
3899     bool needConversion = true;
<a name="464" id="anc464"></a><span class="line-modified">3900     if (type == GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContextGL::DataFormat::RGBA8 &amp;&amp; format == GraphicsContextGL::RGBA &amp;&amp; alphaOp == GraphicsContextGL::AlphaOp::DoNothing &amp;&amp; !flipY)</span>
3901         needConversion = false;
3902     else {
3903         if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
<a name="465" id="anc465"></a><span class="line-modified">3904             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
3905             return;
3906         }
3907     }
3908 
3909     if (m_unpackAlignment != 1)
<a name="466" id="anc466"></a><span class="line-modified">3910         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
3911 
3912     texSubImage2DBase(target, level, xoffset, yoffset, image-&gt;width(), image-&gt;height(), format, format, type, needConversion ? data.data() : imagePixelData);
3913 
3914     if (m_unpackAlignment != 1)
<a name="467" id="anc467"></a><span class="line-modified">3915         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3916 }
3917 
<a name="468" id="anc468"></a><span class="line-modified">3918 void WebGLRenderingContextBase::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)</span>
3919 {
3920     if (isContextLostOrPending())
3921         return;
3922 
3923     auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3924     if (!texture)
3925         return;
3926 
<a name="469" id="anc469"></a><span class="line-modified">3927     GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
3928     if (!internalFormat) {
<a name="470" id="anc470"></a><span class="line-modified">3929         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
3930         return;
3931     }
3932 
3933     if (!validateTexFuncData(&quot;texSubImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullNotAllowed))
3934         return;
3935 
3936     if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceArrayBufferView, target, level, internalFormat, width, height, 0, format, type, xoffset, yoffset))
3937         return;
3938 
3939     void* data = pixels-&gt;baseAddress();
3940     Vector&lt;uint8_t&gt; tempData;
3941     bool changeUnpackAlignment = false;
3942     if (data &amp;&amp; (m_unpackFlipY || m_unpackPremultiplyAlpha)) {
3943         if (!m_context-&gt;extractTextureData(width, height, format, type, m_unpackAlignment, m_unpackFlipY, m_unpackPremultiplyAlpha, data, tempData))
3944             return;
3945         data = tempData.data();
3946         changeUnpackAlignment = true;
3947     }
3948     if (changeUnpackAlignment)
<a name="471" id="anc471"></a><span class="line-modified">3949         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
3950 
3951     texSubImage2DBase(target, level, xoffset, yoffset, width, height, internalFormat, format, type, data);
3952 
3953     if (changeUnpackAlignment)
<a name="472" id="anc472"></a><span class="line-modified">3954         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3955 }
3956 
<a name="473" id="anc473"></a><span class="line-modified">3957 ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt;&amp;&amp; source)</span>
3958 {
3959     if (!source) {
<a name="474" id="anc474"></a><span class="line-modified">3960         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;source is null&quot;);</span>
3961         return { };
3962     }
3963 
3964     if (isContextLostOrPending())
3965         return { };
3966 
3967     auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
3968         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3969         if (!texture)
3970             return { };
3971 
<a name="475" id="anc475"></a><span class="line-modified">3972         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
3973         if (!internalFormat) {
<a name="476" id="anc476"></a><span class="line-modified">3974             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
3975             return { };
3976         }
3977 
3978         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageBitmap, target, level, internalFormat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, xoffset, yoffset))
3979             return { };
3980 
3981         ImageBuffer* buffer = bitmap-&gt;buffer();
3982         if (!buffer)
3983             return { };
3984 
<a name="477" id="anc477"></a><span class="line-modified">3985         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(DontCopyBackingStore);</span>
3986         if (image)
<a name="478" id="anc478"></a><span class="line-modified">3987             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
3988         return { };
3989     }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
3990         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3991         if (!texture)
3992             return { };
3993 
<a name="479" id="anc479"></a><span class="line-modified">3994         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
3995         if (!internalFormat) {
<a name="480" id="anc480"></a><span class="line-modified">3996             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
3997             return { };
3998         }
3999 
4000         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageData, target, level, internalFormat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, xoffset, yoffset))
4001             return { };
4002 
4003         Vector&lt;uint8_t&gt; data;
4004         bool needConversion = true;
4005         // The data from ImageData is always of format RGBA8.
4006         // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
<a name="481" id="anc481"></a><span class="line-modified">4007         if (format == GraphicsContextGL::RGBA &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; !m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha)</span>
4008             needConversion = false;
4009         else {
4010             if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
<a name="482" id="anc482"></a><span class="line-modified">4011                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image data&quot;);</span>
4012                 return { };
4013             }
4014         }
4015         if (m_unpackAlignment != 1)
<a name="483" id="anc483"></a><span class="line-modified">4016             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
4017 
4018         texSubImage2DBase(target, level, xoffset, yoffset, pixels-&gt;width(), pixels-&gt;height(), format, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
4019 
4020         if (m_unpackAlignment != 1)
<a name="484" id="anc484"></a><span class="line-modified">4021             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
4022 
4023         return { };
4024     } , [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
4025         if (isContextLostOrPending())
4026             return { };
4027         auto validationResult = validateHTMLImageElement(&quot;texSubImage2D&quot;, image.get());
4028         if (validationResult.hasException())
4029             return validationResult.releaseException();
4030         if (!validationResult.returnValue())
4031             return { };
4032 
4033         RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
4034         if (!imageForRender)
4035             return { };
4036 
<a name="485" id="anc485"></a><span class="line-modified">4037         if (imageForRender-&gt;isSVGImage() || imageForRender-&gt;orientation() != ImageOrientation::None)</span>
4038             imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
4039 
4040         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4041         if (!texture)
4042             return { };
4043 
<a name="486" id="anc486"></a><span class="line-modified">4044         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
4045         if (!internalFormat) {
<a name="487" id="anc487"></a><span class="line-modified">4046             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
4047             return { };
4048         }
4049 
4050         if (!imageForRender || !validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLImageElement, target, level, internalFormat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, xoffset, yoffset))
4051             return { };
4052 
<a name="488" id="anc488"></a><span class="line-modified">4053         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, imageForRender.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4054         return { };
4055     }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
4056         if (isContextLostOrPending())
4057             return { };
4058         auto validationResult = validateHTMLCanvasElement(&quot;texSubImage2D&quot;, canvas.get());
4059         if (validationResult.hasException())
4060             return validationResult.releaseException();
4061         if (!validationResult.returnValue())
4062             return { };
4063 
4064         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4065         if (!texture)
4066             return { };
4067 
<a name="489" id="anc489"></a><span class="line-modified">4068         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
4069         if (!internalFormat) {
<a name="490" id="anc490"></a><span class="line-modified">4070             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
4071             return { };
4072         }
4073 
4074         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLCanvasElement, target, level, internalFormat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, xoffset, yoffset))
4075             return { };
4076 
4077         RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
4078         if (imageData)
4079             texSubImage2D(target, level, xoffset, yoffset, format, type, TexImageSource(imageData.get()));
4080         else
<a name="491" id="anc491"></a><span class="line-modified">4081             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, canvas-&gt;copiedImage(), GraphicsContextGL::DOMSource::Canvas, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4082         return { };
4083     }
4084 #if ENABLE(VIDEO)
4085     , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
4086         if (isContextLostOrPending())
4087             return { };
4088         auto validationResult = validateHTMLVideoElement(&quot;texSubImage2D&quot;, video.get());
4089         if (validationResult.hasException())
4090             return validationResult.releaseException();
4091         if (!validationResult.returnValue())
4092             return { };
4093 
4094         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4095         if (!texture)
4096             return { };
4097 
<a name="492" id="anc492"></a><span class="line-modified">4098         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
4099         if (!internalFormat) {
<a name="493" id="anc493"></a><span class="line-modified">4100             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
4101             return { };
4102         }
4103 
4104         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLVideoElement, target, level, internalFormat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, xoffset, yoffset))
4105             return { };
4106 
<a name="494" id="anc494"></a><span class="line-modified">4107         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), DontCopyBackingStore);</span>
4108         if (!image)
4109             return { };
<a name="495" id="anc495"></a><span class="line-modified">4110         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContextGL::DOMSource::Video, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4111         return { };
4112     }
4113 #endif
4114     );
4115 
4116     return WTF::visit(visitor, source.value());
4117 }
4118 
<a name="496" id="anc496"></a><span class="line-modified">4119 bool WebGLRenderingContextBase::validateArrayBufferType(const char* functionName, GCGLenum type, Optional&lt;JSC::TypedArrayType&gt; arrayType)</span>
4120 {
4121 #define TYPE_VALIDATION_CASE(arrayTypeMacro) if (arrayType &amp;&amp; arrayType.value() != JSC::arrayTypeMacro) { \
<a name="497" id="anc497"></a><span class="line-modified">4122             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;ArrayBufferView not &quot; #arrayTypeMacro); \</span>
4123             return false; \
4124         } \
4125         break;
4126 
4127     switch (type) {
<a name="498" id="anc498"></a><span class="line-modified">4128     case GraphicsContextGL::UNSIGNED_BYTE:</span>
4129         TYPE_VALIDATION_CASE(TypeUint8);
<a name="499" id="anc499"></a><span class="line-modified">4130     case GraphicsContextGL::BYTE:</span>
4131         TYPE_VALIDATION_CASE(TypeInt8);
<a name="500" id="anc500"></a><span class="line-modified">4132     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="line-modified">4133     case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:</span>
<span class="line-modified">4134     case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="line-modified">4135     case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:</span>
4136         TYPE_VALIDATION_CASE(TypeUint16);
<a name="501" id="anc501"></a><span class="line-modified">4137     case GraphicsContextGL::SHORT:</span>
4138         TYPE_VALIDATION_CASE(TypeInt16);
<a name="502" id="anc502"></a><span class="line-modified">4139     case GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV:</span>
<span class="line-modified">4140     case GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV:</span>
<span class="line-modified">4141     case GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV:</span>
<span class="line-modified">4142     case GraphicsContextGL::UNSIGNED_INT_24_8:</span>
<span class="line-modified">4143     case GraphicsContextGL::UNSIGNED_INT:</span>
4144         TYPE_VALIDATION_CASE(TypeUint32);
<a name="503" id="anc503"></a><span class="line-modified">4145     case GraphicsContextGL::INT:</span>
4146         TYPE_VALIDATION_CASE(TypeInt32);
<a name="504" id="anc504"></a><span class="line-modified">4147     case GraphicsContextGL::FLOAT: // OES_texture_float</span>
4148         TYPE_VALIDATION_CASE(TypeFloat32);
<a name="505" id="anc505"></a><span class="line-modified">4149     case GraphicsContextGL::HALF_FLOAT_OES: // OES_texture_half_float</span>
<span class="line-modified">4150     case GraphicsContextGL::HALF_FLOAT:</span>
<span class="line-modified">4151     case GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV:</span>
<span class="line-modified">4152         TYPE_VALIDATION_CASE(TypeUint16);</span>






4153     default:
4154         ASSERT_NOT_REACHED();
4155         return false;
4156     }
4157 #undef TYPE_VALIDATION_CASE
4158     return true;
4159 }
4160 
<a name="506" id="anc506"></a><span class="line-modified">4161 bool WebGLRenderingContextBase::validateTexFuncData(const char* functionName, GCGLint level, GCGLsizei width, GCGLsizei height, GCGLenum internalFormat, GCGLenum format, GCGLenum type, ArrayBufferView* pixels, NullDisposition disposition)</span>
4162 {
4163     if (!pixels) {
4164         if (disposition == NullAllowed)
4165             return true;
<a name="507" id="anc507"></a><span class="line-modified">4166         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no pixels&quot;);</span>
4167         return false;
4168     }
4169 
4170     if (!validateTexFuncFormatAndType(functionName, internalFormat, format, type, level))
4171         return false;
4172     if (!validateSettableTexInternalFormat(functionName, internalFormat))
4173         return false;
4174     if (!validateArrayBufferType(functionName, type, pixels ? Optional&lt;JSC::TypedArrayType&gt;(pixels-&gt;getType()) : WTF::nullopt))
4175         return false;
4176 
4177     unsigned totalBytesRequired;
<a name="508" id="anc508"></a><span class="line-modified">4178     GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;totalBytesRequired, nullptr);</span>
<span class="line-modified">4179     if (error != GraphicsContextGL::NO_ERROR) {</span>
4180         synthesizeGLError(error, functionName, &quot;invalid texture dimensions&quot;);
4181         return false;
4182     }
4183     if (pixels-&gt;byteLength() &lt; totalBytesRequired) {
<a name="509" id="anc509"></a><span class="line-modified">4184         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;ArrayBufferView not big enough for request&quot;);</span>
4185         return false;
4186     }
4187     return true;
4188 }
4189 
4190 bool WebGLRenderingContextBase::validateTexFuncParameters(const char* functionName,
4191     TexFuncValidationFunctionType functionType,
<a name="510" id="anc510"></a><span class="line-modified">4192     GCGLenum target, GCGLint level,</span>
<span class="line-modified">4193     GCGLenum internalformat,</span>
<span class="line-modified">4194     GCGLsizei width, GCGLsizei height, GCGLint border,</span>
<span class="line-modified">4195     GCGLenum format, GCGLenum type)</span>
4196 {
4197     // We absolutely have to validate the format and type combination.
4198     // The texImage2D entry points taking HTMLImage, etc. will produce
4199     // temporary data based on this combination, so it must be legal.
4200     if (!validateTexFuncFormatAndType(functionName, internalformat, format, type, level) || !validateTexFuncLevel(functionName, target, level))
4201         return false;
4202 
4203     if (width &lt; 0 || height &lt; 0) {
<a name="511" id="anc511"></a><span class="line-modified">4204         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);</span>
4205         return false;
4206     }
4207 
<a name="512" id="anc512"></a><span class="line-modified">4208     GCGLint maxTextureSizeForLevel = pow(2.0, m_maxTextureLevel - 1 - level);</span>
4209     switch (target) {
<a name="513" id="anc513"></a><span class="line-modified">4210     case GraphicsContextGL::TEXTURE_2D:</span>
4211         if (width &gt; maxTextureSizeForLevel || height &gt; maxTextureSizeForLevel) {
<a name="514" id="anc514"></a><span class="line-modified">4212             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height out of range&quot;);</span>
4213             return false;
4214         }
4215         break;
<a name="515" id="anc515"></a><span class="line-modified">4216     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="line-modified">4217     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="line-modified">4218     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="line-modified">4219     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="line-modified">4220     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="line-modified">4221     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
4222         if (functionType != TexSubImage &amp;&amp; width != height) {
<a name="516" id="anc516"></a><span class="line-modified">4223             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width != height for cube map&quot;);</span>
4224             return false;
4225         }
4226         // No need to check height here. For texImage width == height.
4227         // For texSubImage that will be checked when checking yoffset + height is in range.
4228         if (width &gt; maxTextureSizeForLevel) {
<a name="517" id="anc517"></a><span class="line-modified">4229             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height out of range for cube map&quot;);</span>
4230             return false;
4231         }
4232         break;
4233     default:
<a name="518" id="anc518"></a><span class="line-modified">4234         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
4235         return false;
4236     }
4237 
4238     if (border) {
<a name="519" id="anc519"></a><span class="line-modified">4239         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;border != 0&quot;);</span>
4240         return false;
4241     }
4242 
4243     return true;
4244 }
4245 
<a name="520" id="anc520"></a><span class="line-modified">4246 bool WebGLRenderingContextBase::validateTexFuncFormatAndType(const char* functionName, GCGLenum internalFormat, GCGLenum format, GCGLenum type, GCGLint level)</span>
4247 {
4248     switch (format) {
<a name="521" id="anc521"></a><span class="line-modified">4249     case GraphicsContextGL::ALPHA:</span>
<span class="line-modified">4250     case GraphicsContextGL::LUMINANCE:</span>
<span class="line-modified">4251     case GraphicsContextGL::LUMINANCE_ALPHA:</span>
<span class="line-modified">4252     case GraphicsContextGL::RGB:</span>
<span class="line-modified">4253     case GraphicsContextGL::RGBA:</span>
4254         break;
<a name="522" id="anc522"></a><span class="line-modified">4255     case GraphicsContextGL::DEPTH_STENCIL:</span>
<span class="line-modified">4256     case GraphicsContextGL::DEPTH_COMPONENT:</span>
4257         if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
<a name="523" id="anc523"></a><span class="line-modified">4258             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;depth texture formats not enabled&quot;);</span>
4259             return false;
4260         }
4261         if (level &gt; 0) {
<a name="524" id="anc524"></a><span class="line-modified">4262             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;level must be 0 for depth formats&quot;);</span>
4263             return false;
4264         }
4265         break;
<a name="525" id="anc525"></a><span class="line-modified">4266     case ExtensionsGL::SRGB_EXT:</span>
<span class="line-modified">4267     case ExtensionsGL::SRGB_ALPHA_EXT:</span>
4268         if (!m_extsRGB) {
<a name="526" id="anc526"></a><span class="line-modified">4269             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;sRGB texture formats not enabled&quot;);</span>
4270             return false;
4271         }
4272         break;
4273     default:
4274 #if ENABLE(WEBGL2)
4275         if (!isWebGL1()) {
4276             switch (format) {
<a name="527" id="anc527"></a><span class="line-modified">4277             case GraphicsContextGL::RED:</span>
<span class="line-modified">4278             case GraphicsContextGL::RED_INTEGER:</span>
<span class="line-modified">4279             case GraphicsContextGL::RG:</span>
<span class="line-modified">4280             case GraphicsContextGL::RG_INTEGER:</span>
<span class="line-modified">4281             case GraphicsContextGL::RGB_INTEGER:</span>
<span class="line-modified">4282             case GraphicsContextGL::RGBA_INTEGER:</span>
4283                 break;
4284             default:
<a name="528" id="anc528"></a><span class="line-modified">4285                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);</span>
4286                 return false;
4287             }
4288         } else
4289 #endif
4290         {
<a name="529" id="anc529"></a><span class="line-modified">4291             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);</span>
4292             return false;
4293         }
4294     }
4295 
4296     switch (type) {
<a name="530" id="anc530"></a><span class="line-modified">4297     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">4298     case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:</span>
<span class="line-modified">4299     case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="line-modified">4300     case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:</span>
4301         break;
<a name="531" id="anc531"></a><span class="line-modified">4302     case GraphicsContextGL::FLOAT:</span>
4303         if (!m_oesTextureFloat &amp;&amp; isWebGL1()) {
<a name="532" id="anc532"></a><span class="line-modified">4304             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4305             return false;
4306         }
4307         break;
<a name="533" id="anc533"></a><span class="line-modified">4308     case GraphicsContextGL::HALF_FLOAT:</span>
<span class="line-modified">4309     case GraphicsContextGL::HALF_FLOAT_OES:</span>
4310         if (!m_oesTextureHalfFloat &amp;&amp; isWebGL1()) {
<a name="534" id="anc534"></a><span class="line-modified">4311             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4312             return false;
4313         }
4314         break;
<a name="535" id="anc535"></a><span class="line-modified">4315     case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="line-modified">4316     case GraphicsContextGL::UNSIGNED_INT_24_8:</span>
<span class="line-modified">4317     case GraphicsContextGL::UNSIGNED_SHORT:</span>
4318         if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
<a name="536" id="anc536"></a><span class="line-modified">4319             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4320             return false;
4321         }
4322         break;
4323     default:
4324 #if ENABLE(WEBGL2)
4325         if (!isWebGL1()) {
4326             switch (type) {
<a name="537" id="anc537"></a><span class="line-modified">4327             case GraphicsContextGL::BYTE:</span>
<span class="line-modified">4328             case GraphicsContextGL::SHORT:</span>
<span class="line-modified">4329             case GraphicsContextGL::INT:</span>
<span class="line-modified">4330             case GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV:</span>
<span class="line-modified">4331             case GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV:</span>
<span class="line-modified">4332             case GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV:</span>
<span class="line-modified">4333             case GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV:</span>
4334                 break;
4335             default:
<a name="538" id="anc538"></a><span class="line-modified">4336                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4337                 return false;
4338             }
4339         } else
4340 #endif
4341         {
<a name="539" id="anc539"></a><span class="line-modified">4342             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4343             return false;
4344         }
4345     }
4346 
4347     // Verify that the combination of internalformat, format, and type is supported.
<a name="540" id="anc540"></a><span class="line-modified">4348 #define INTERNAL_FORMAT_CASE(internalFormatMacro, formatMacro, type0, type1, type2, type3, type4) case GraphicsContextGLOpenGL::internalFormatMacro: \</span>
<span class="line-modified">4349     if (format != GraphicsContextGLOpenGL::formatMacro) { \</span>
<span class="line-modified">4350         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid format for internalformat&quot;); \</span>
4351         return false; \
4352     } \
4353     if (type != type0 &amp;&amp; type != type1 &amp;&amp; type != type2 &amp;&amp; type != type3 &amp;&amp; type != type4) { \
<a name="541" id="anc541"></a><span class="line-modified">4354         if (type != GraphicsContextGL::HALF_FLOAT_OES || (type0 != GraphicsContextGL::HALF_FLOAT &amp;&amp; type1 != GraphicsContextGL::HALF_FLOAT &amp;&amp; type2 != GraphicsContextGL::HALF_FLOAT &amp;&amp; type3 != GraphicsContextGL::HALF_FLOAT)) { \</span>
<span class="line-modified">4355             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid type for internalformat&quot;); \</span>
4356             return false; \
4357         } \
4358     } \
4359     break;
4360     switch (internalFormat) {
<a name="542" id="anc542"></a><span class="line-modified">4361     INTERNAL_FORMAT_CASE(RGB               , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_5_6_5  , GraphicsContextGL::HALF_FLOAT                  , GraphicsContextGL::FLOAT     , 0                       );</span>
<span class="line-modified">4362     INTERNAL_FORMAT_CASE(RGBA              , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4, GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1      , GraphicsContextGL::HALF_FLOAT, GraphicsContextGL::FLOAT);</span>
<span class="line-modified">4363     INTERNAL_FORMAT_CASE(LUMINANCE_ALPHA   , LUMINANCE_ALPHA, GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4364     INTERNAL_FORMAT_CASE(LUMINANCE         , LUMINANCE      , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4365     INTERNAL_FORMAT_CASE(ALPHA             , ALPHA          , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4366     INTERNAL_FORMAT_CASE(R8                , RED            , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4367     INTERNAL_FORMAT_CASE(R8_SNORM          , RED            , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4368     INTERNAL_FORMAT_CASE(R16F              , RED            , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4369     INTERNAL_FORMAT_CASE(R32F              , RED            , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4370     INTERNAL_FORMAT_CASE(R8UI              , RED_INTEGER    , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4371     INTERNAL_FORMAT_CASE(R8I               , RED_INTEGER    , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4372     INTERNAL_FORMAT_CASE(R16UI             , RED_INTEGER    , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4373     INTERNAL_FORMAT_CASE(R16I              , RED_INTEGER    , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4374     INTERNAL_FORMAT_CASE(R32UI             , RED_INTEGER    , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4375     INTERNAL_FORMAT_CASE(R32I              , RED_INTEGER    , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4376     INTERNAL_FORMAT_CASE(RG8               , RG             , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4377     INTERNAL_FORMAT_CASE(RG8_SNORM         , RG             , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4378     INTERNAL_FORMAT_CASE(RG16F             , RG             , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4379     INTERNAL_FORMAT_CASE(RG32F             , RG             , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4380     INTERNAL_FORMAT_CASE(RG8UI             , RG_INTEGER     , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4381     INTERNAL_FORMAT_CASE(RG8I              , RG_INTEGER     , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4382     INTERNAL_FORMAT_CASE(RG16UI            , RG_INTEGER     , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4383     INTERNAL_FORMAT_CASE(RG16I             , RG_INTEGER     , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4384     INTERNAL_FORMAT_CASE(RG32UI            , RG_INTEGER     , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4385     INTERNAL_FORMAT_CASE(RG32I             , RG_INTEGER     , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4386     INTERNAL_FORMAT_CASE(RGB8              , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4387     INTERNAL_FORMAT_CASE(SRGB8             , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4388     INTERNAL_FORMAT_CASE(RGB565            , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_5_6_5  , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4389     INTERNAL_FORMAT_CASE(RGB8_SNORM        , RGB            , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4390     INTERNAL_FORMAT_CASE(R11F_G11F_B10F    , RGB            , GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV  , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4391     INTERNAL_FORMAT_CASE(RGB9_E5           , RGB            , GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV      , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4392     INTERNAL_FORMAT_CASE(RGB16F            , RGB            , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4393     INTERNAL_FORMAT_CASE(RGB32F            , RGB            , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4394     INTERNAL_FORMAT_CASE(RGB8UI            , RGB_INTEGER    , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4395     INTERNAL_FORMAT_CASE(RGB8I             , RGB_INTEGER    , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4396     INTERNAL_FORMAT_CASE(RGB16UI           , RGB_INTEGER    , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4397     INTERNAL_FORMAT_CASE(RGB16I            , RGB_INTEGER    , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4398     INTERNAL_FORMAT_CASE(RGB32UI           , RGB_INTEGER    , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4399     INTERNAL_FORMAT_CASE(RGB32I            , RGB_INTEGER    , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4400     INTERNAL_FORMAT_CASE(RGBA8             , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4401     INTERNAL_FORMAT_CASE(SRGB8_ALPHA8      , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4402     INTERNAL_FORMAT_CASE(RGBA8_SNORM       , RGBA           , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4403     INTERNAL_FORMAT_CASE(RGB5_A1           , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1, GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV , 0                            , 0                       );</span>
<span class="line-modified">4404     INTERNAL_FORMAT_CASE(RGBA4             , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4, 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4405     INTERNAL_FORMAT_CASE(RGB10_A2          , RGBA           , GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4406     INTERNAL_FORMAT_CASE(RGBA16F           , RGBA           , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4407     INTERNAL_FORMAT_CASE(RGBA32F           , RGBA           , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4408     INTERNAL_FORMAT_CASE(RGBA8UI           , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4409     INTERNAL_FORMAT_CASE(RGBA8I            , RGBA_INTEGER   , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4410     INTERNAL_FORMAT_CASE(RGB10_A2UI        , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4411     INTERNAL_FORMAT_CASE(RGBA16UI          , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4412     INTERNAL_FORMAT_CASE(RGBA16I           , RGBA_INTEGER   , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4413     INTERNAL_FORMAT_CASE(RGBA32I           , RGBA_INTEGER   , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4414     INTERNAL_FORMAT_CASE(RGBA32UI          , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4415     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT   , DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_SHORT                , GraphicsContextGL::UNSIGNED_INT          , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4416     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT16 , DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_SHORT                , GraphicsContextGL::UNSIGNED_INT          , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4417     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT24 , DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4418     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT32F, DEPTH_COMPONENT, GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4419     INTERNAL_FORMAT_CASE(DEPTH_STENCIL     , DEPTH_STENCIL  , GraphicsContextGL::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4420     INTERNAL_FORMAT_CASE(DEPTH24_STENCIL8  , DEPTH_STENCIL  , GraphicsContextGL::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4421     INTERNAL_FORMAT_CASE(DEPTH32F_STENCIL8 , DEPTH_STENCIL  , GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV, 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4422     case ExtensionsGL::SRGB_EXT:</span>
4423         if (format != internalFormat) {
<a name="543" id="anc543"></a><span class="line-modified">4424             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);</span>
4425             return false;
4426         }
<a name="544" id="anc544"></a><span class="line-modified">4427         if (type != GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; type != GraphicsContextGL::UNSIGNED_SHORT_5_6_5 &amp;&amp; type != GraphicsContextGL::FLOAT &amp;&amp; type != GraphicsContextGL::HALF_FLOAT_OES &amp;&amp; type != GraphicsContextGL::HALF_FLOAT) {</span>
<span class="line-modified">4428             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);</span>
4429             return false;
4430         }
4431         break;
<a name="545" id="anc545"></a><span class="line-modified">4432     case ExtensionsGL::SRGB_ALPHA_EXT:</span>
4433         if (format != internalFormat) {
<a name="546" id="anc546"></a><span class="line-modified">4434             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);</span>
4435             return false;
4436         }
<a name="547" id="anc547"></a><span class="line-modified">4437         if (type != GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; type != GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4 &amp;&amp; type != GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1 &amp;&amp; type != GraphicsContextGL::FLOAT &amp;&amp; type != GraphicsContextGL::HALF_FLOAT_OES &amp;&amp; type != GraphicsContextGL::HALF_FLOAT) {</span>
<span class="line-modified">4438             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);</span>
4439             return false;
4440         }
4441         break;
4442     default:
<a name="548" id="anc548"></a><span class="line-modified">4443         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;Unknown internal format&quot;);</span>
4444         return false;
4445     }
4446 #undef INTERNAL_FORMAT_CASE
4447 
4448     return true;
4449 }
4450 
<a name="549" id="anc549"></a><span class="line-modified">4451 void WebGLRenderingContextBase::texSubImage2DBase(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum internalFormat, GCGLenum format, GCGLenum type, const void* pixels)</span>
4452 {
4453     ASSERT(!isContextLost());
4454     ASSERT(validateTexFuncParameters(&quot;texSubImage2D&quot;, TexSubImage, target, level, internalFormat, width, height, 0, format, type));
4455     ASSERT(validateSize(&quot;texSubImage2D&quot;, xoffset, yoffset));
4456     ASSERT(validateSettableTexInternalFormat(&quot;texSubImage2D&quot;, internalFormat));
4457     auto tex = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4458     if (!tex) {
4459         ASSERT_NOT_REACHED();
4460         return;
4461     }
4462     ASSERT((xoffset + width) &gt;= 0);
4463     ASSERT((yoffset + height) &gt;= 0);
4464     ASSERT(tex-&gt;getWidth(target, level) &gt;= (xoffset + width));
4465     ASSERT(tex-&gt;getHeight(target, level) &gt;= (yoffset + height));
4466     ASSERT_UNUSED(internalFormat, tex-&gt;getInternalFormat(target, level) == internalFormat);
4467     m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
4468 }
4469 
<a name="550" id="anc550"></a><span class="line-modified">4470 void WebGLRenderingContextBase::copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border)</span>
4471 {
4472     if (isContextLostOrPending())
4473         return;
<a name="551" id="anc551"></a><span class="line-modified">4474     if (!validateTexFuncParameters(&quot;copyTexImage2D&quot;, CopyTexImage, target, level, internalFormat, width, height, border, internalFormat, GraphicsContextGL::UNSIGNED_BYTE))</span>
4475         return;
4476     if (!validateSettableTexInternalFormat(&quot;copyTexImage2D&quot;, internalFormat))
4477         return;
4478     auto tex = validateTextureBinding(&quot;copyTexImage2D&quot;, target, true);
4479     if (!tex)
4480         return;
4481     if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
<a name="552" id="anc552"></a><span class="line-modified">4482         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;copyTexImage2D&quot;, &quot;framebuffer is incompatible format&quot;);</span>
4483         return;
4484     }
4485     if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
<a name="553" id="anc553"></a><span class="line-modified">4486         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexImage2D&quot;, &quot;level &gt; 0 not power of 2&quot;);</span>
4487         return;
4488     }
4489     const char* reason = &quot;framebuffer incomplete&quot;;
<a name="554" id="anc554"></a><span class="line-modified">4490     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="line-modified">4491         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexImage2D&quot;, reason);</span>
4492         return;
4493     }
4494     clearIfComposited();
4495 
<a name="555" id="anc555"></a><span class="line-modified">4496     GCGLint clippedX, clippedY;</span>
<span class="line-modified">4497     GCGLsizei clippedWidth, clippedHeight;</span>
4498     if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
4499         m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border,
<a name="556" id="anc556"></a><span class="line-modified">4500             internalFormat, GraphicsContextGL::UNSIGNED_BYTE, m_unpackAlignment);</span>
4501         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0) {
4502             m_context-&gt;copyTexSubImage2D(target, level, clippedX - x, clippedY - y,
4503                 clippedX, clippedY, clippedWidth, clippedHeight);
4504         }
4505     } else
4506         m_context-&gt;copyTexImage2D(target, level, internalFormat, x, y, width, height, border);
4507 
4508     // FIXME: if the framebuffer is not complete, none of the below should be executed.
<a name="557" id="anc557"></a><span class="line-modified">4509     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
4510 }
4511 
<a name="558" id="anc558"></a><span class="line-modified">4512 static bool isRGBFormat(GCGLenum internalFormat)</span>
4513 {
<a name="559" id="anc559"></a><span class="line-modified">4514     return internalFormat == GraphicsContextGL::RGB</span>
<span class="line-modified">4515         || internalFormat == GraphicsContextGL::RGBA</span>
<span class="line-modified">4516         || internalFormat == GraphicsContextGL::RGB8</span>
<span class="line-modified">4517         || internalFormat == GraphicsContextGL::RGBA8;</span>
4518 }
4519 
<a name="560" id="anc560"></a><span class="line-modified">4520 ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt; source)</span>
4521 {
4522     if (!source) {
<a name="561" id="anc561"></a><span class="line-modified">4523         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;source is null&quot;);</span>
4524         return { };
4525     }
4526 
4527     auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
4528         if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageBitmap, target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, 0, 0))
4529             return { };
4530 
4531         ImageBuffer* buffer = bitmap-&gt;buffer();
4532         if (!buffer)
4533             return { };
4534 
4535         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4536         // If possible, copy from the bitmap directly to the texture
4537         // via the GPU, without a read-back to system memory.
4538         //
4539         // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
4540         // ImageBuffer::copyToPlatformTexture implementations are fully functional.
4541         if (texture
<a name="562" id="anc562"></a><span class="line-modified">4542             &amp;&amp; (format == GraphicsContextGL::RGB || format == GraphicsContextGL::RGBA)</span>
<span class="line-modified">4543             &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE) {</span>
4544             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4545             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4546                 if (buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4547                     texture-&gt;setLevelInfo(target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), type);
4548                     return { };
4549                 }
4550             }
4551         }
4552 
4553         // Normal pure SW path.
<a name="563" id="anc563"></a><span class="line-modified">4554         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(DontCopyBackingStore);</span>
4555         if (image)
<a name="564" id="anc564"></a><span class="line-modified">4556             texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4557         return { };
4558     }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
4559         if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageData, target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, 0, 0))
4560             return { };
4561         Vector&lt;uint8_t&gt; data;
4562         bool needConversion = true;
4563         // The data from ImageData is always of format RGBA8.
4564         // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
<a name="565" id="anc565"></a><span class="line-modified">4565         if (!m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha &amp;&amp; format == GraphicsContextGL::RGBA &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE)</span>
4566             needConversion = false;
4567         else {
4568             if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
<a name="566" id="anc566"></a><span class="line-modified">4569                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
4570                 return { };
4571             }
4572         }
4573         if (m_unpackAlignment != 1)
<a name="567" id="anc567"></a><span class="line-modified">4574             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
4575         texImage2DBase(target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
4576         if (m_unpackAlignment != 1)
<a name="568" id="anc568"></a><span class="line-modified">4577             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
4578         return { };
4579     }, [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
4580         if (isContextLostOrPending())
4581             return { };
4582         auto validationResult = validateHTMLImageElement(&quot;texImage2D&quot;, image.get());
4583         if (validationResult.hasException())
4584             return validationResult.releaseException();
4585         if (!validationResult.returnValue())
4586             return { };
4587 
4588         RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
4589         if (!imageForRender)
4590             return { };
4591 
<a name="569" id="anc569"></a><span class="line-modified">4592         if (imageForRender-&gt;isSVGImage() || imageForRender-&gt;orientation() != ImageOrientation::None)</span>
4593             imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
4594 
4595         if (!imageForRender || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLImageElement, target, level, internalformat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, 0, 0))
4596             return { };
4597 
<a name="570" id="anc570"></a><span class="line-modified">4598         texImage2DImpl(target, level, internalformat, format, type, imageForRender.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4599         return { };
4600     }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
4601         if (isContextLostOrPending())
4602             return { };
4603         auto validationResult = validateHTMLCanvasElement(&quot;texImage2D&quot;, canvas.get());
4604         if (validationResult.hasException())
4605             return validationResult.releaseException();
4606         if (!validationResult.returnValue())
4607             return { };
4608         if (!validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLCanvasElement, target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, 0, 0))
4609             return { };
4610 
4611         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4612         // If possible, copy from the canvas element directly to the texture
4613         // via the GPU, without a read-back to system memory.
4614         //
4615         // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
4616         // ImageBuffer::copyToPlatformTexture implementations are fully functional.
4617         if (texture
<a name="571" id="anc571"></a><span class="line-modified">4618             &amp;&amp; (format == GraphicsContextGL::RGB || format == GraphicsContextGL::RGBA)</span>
<span class="line-modified">4619             &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE) {</span>
4620             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4621             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4622                 ImageBuffer* buffer = canvas-&gt;buffer();
4623                 if (buffer &amp;&amp; buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4624                     texture-&gt;setLevelInfo(target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), type);
4625                     return { };
4626                 }
4627             }
4628         }
4629 
4630         RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
4631         if (imageData)
4632             texImage2D(target, level, internalformat, format, type, TexImageSource(imageData.get()));
4633         else
<a name="572" id="anc572"></a><span class="line-modified">4634             texImage2DImpl(target, level, internalformat, format, type, canvas-&gt;copiedImage(), GraphicsContextGL::DOMSource::Canvas, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4635         return { };
4636     }
4637 #if ENABLE(VIDEO)
4638     , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
4639         if (isContextLostOrPending())
4640             return { };
4641         auto validationResult = validateHTMLVideoElement(&quot;texImage2D&quot;, video.get());
4642         if (validationResult.hasException())
4643             return validationResult.releaseException();
4644         if (!validationResult.returnValue())
4645             return { };
4646         if (!validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLVideoElement, target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, 0, 0))
4647             return { };
4648 
4649         // Go through the fast path doing a GPU-GPU textures copy without a readback to system memory if possible.
4650         // Otherwise, it will fall back to the normal SW path.
4651         // FIXME: The current restrictions require that format shoud be RGB or RGBA,
4652         // type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
4653         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
<a name="573" id="anc573"></a><span class="line-modified">4654         if (GraphicsContextGL::TEXTURE_2D == target &amp;&amp; texture</span>
<span class="line-modified">4655             &amp;&amp; (format == GraphicsContextGL::RGB || format == GraphicsContextGL::RGBA)</span>
<span class="line-modified">4656             &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE</span>
4657             &amp;&amp; !level) {
4658             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4659             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4660                 if (video-&gt;copyVideoTextureToPlatformTexture(m_context.get(), texture-&gt;object(), target, level, internalformat, format, type, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4661                     texture-&gt;setLevelInfo(target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), type);
4662                     return { };
4663                 }
4664             }
4665         }
4666 
4667         // Normal pure SW path.
<a name="574" id="anc574"></a><span class="line-modified">4668         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), DontCopyBackingStore);</span>
4669         if (!image)
4670             return { };
<a name="575" id="anc575"></a><span class="line-modified">4671         texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContextGL::DOMSource::Video, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4672         return { };
4673     }
4674 #endif
4675     );
4676 
4677     return WTF::visit(visitor, source.value());
4678 }
4679 
4680 RefPtr&lt;Image&gt; WebGLRenderingContextBase::drawImageIntoBuffer(Image&amp; image, int width, int height, int deviceScaleFactor)
4681 {
4682     IntSize size(width, height);
4683     size.scale(deviceScaleFactor);
4684     ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
4685     if (!buf) {
<a name="576" id="anc576"></a><span class="line-modified">4686         synthesizeGLError(GraphicsContextGL::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);</span>
4687         return nullptr;
4688     }
4689 
4690     FloatRect srcRect(FloatPoint(), image.size());
4691     FloatRect destRect(FloatPoint(), size);
4692     buf-&gt;context().drawImage(image, destRect, srcRect);
<a name="577" id="anc577"></a><span class="line-modified">4693     return buf-&gt;copyImage(DontCopyBackingStore);</span>
4694 }
4695 
4696 #if ENABLE(VIDEO)
4697 
4698 RefPtr&lt;Image&gt; WebGLRenderingContextBase::videoFrameToImage(HTMLVideoElement* video, BackingStoreCopy backingStoreCopy)
4699 {
4700     IntSize size(video-&gt;videoWidth(), video-&gt;videoHeight());
4701     ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
4702     if (!buf) {
<a name="578" id="anc578"></a><span class="line-modified">4703         synthesizeGLError(GraphicsContextGL::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);</span>
4704         return nullptr;
4705     }
4706     FloatRect destRect(0, 0, size.width(), size.height());
4707     // FIXME: Turn this into a GPU-GPU texture copy instead of CPU readback.
4708     video-&gt;paintCurrentFrameInContext(buf-&gt;context(), destRect);
4709     return buf-&gt;copyImage(backingStoreCopy);
4710 }
4711 
4712 #endif
4713 
<a name="579" id="anc579"></a><span class="line-modified">4714 void WebGLRenderingContextBase::texParameter(GCGLenum target, GCGLenum pname, GCGLfloat paramf, GCGLint parami, bool isFloat)</span>
4715 {
4716     if (isContextLostOrPending())
4717         return;
4718     auto tex = validateTextureBinding(&quot;texParameter&quot;, target, false);
4719     if (!tex)
4720         return;
4721     switch (pname) {
<a name="580" id="anc580"></a><span class="line-modified">4722     case GraphicsContextGL::TEXTURE_MIN_FILTER:</span>
<span class="line-modified">4723     case GraphicsContextGL::TEXTURE_MAG_FILTER:</span>
4724         break;
<a name="581" id="anc581"></a><span class="line-modified">4725     case GraphicsContextGL::TEXTURE_WRAP_S:</span>
<span class="line-modified">4726     case GraphicsContextGL::TEXTURE_WRAP_T:</span>
<span class="line-modified">4727         if ((isFloat &amp;&amp; paramf != GraphicsContextGL::CLAMP_TO_EDGE &amp;&amp; paramf != GraphicsContextGL::MIRRORED_REPEAT &amp;&amp; paramf != GraphicsContextGL::REPEAT)</span>
<span class="line-modified">4728             || (!isFloat &amp;&amp; parami != GraphicsContextGL::CLAMP_TO_EDGE &amp;&amp; parami != GraphicsContextGL::MIRRORED_REPEAT &amp;&amp; parami != GraphicsContextGL::REPEAT)) {</span>
<span class="line-modified">4729             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter&quot;);</span>
4730             return;
4731         }
4732         break;
<a name="582" id="anc582"></a><span class="line-modified">4733     case ExtensionsGL::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
4734         if (!m_extTextureFilterAnisotropic) {
<a name="583" id="anc583"></a><span class="line-modified">4735             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter, EXT_texture_filter_anisotropic not enabled&quot;);</span>
4736             return;
4737         }
4738         break;
4739     default:
<a name="584" id="anc584"></a><span class="line-modified">4740         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter name&quot;);</span>
4741         return;
4742     }
4743     if (isFloat) {
4744         tex-&gt;setParameterf(pname, paramf);
4745         m_context-&gt;texParameterf(target, pname, paramf);
4746     } else {
4747         tex-&gt;setParameteri(pname, parami);
4748         m_context-&gt;texParameteri(target, pname, parami);
4749     }
4750 }
4751 
<a name="585" id="anc585"></a><span class="line-modified">4752 void WebGLRenderingContextBase::texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat param)</span>
4753 {
4754     texParameter(target, pname, param, 0, true);
4755 }
4756 
<a name="586" id="anc586"></a><span class="line-modified">4757 void WebGLRenderingContextBase::texParameteri(GCGLenum target, GCGLenum pname, GCGLint param)</span>
4758 {
4759     texParameter(target, pname, 0, param, false);
4760 }
4761 
<a name="587" id="anc587"></a><span class="line-modified">4762 void WebGLRenderingContextBase::uniform1f(const WebGLUniformLocation* location, GCGLfloat x)</span>
4763 {
4764     if (isContextLostOrPending() || !location)
4765         return;
4766 
4767     if (location-&gt;program() != m_currentProgram) {
<a name="588" id="anc588"></a><span class="line-modified">4768         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform1f&quot;, &quot;location not for current program&quot;);</span>
4769         return;
4770     }
4771 
4772     m_context-&gt;uniform1f(location-&gt;location(), x);
4773 }
4774 
<a name="589" id="anc589"></a><span class="line-modified">4775 void WebGLRenderingContextBase::uniform2f(const WebGLUniformLocation* location, GCGLfloat x, GCGLfloat y)</span>
4776 {
4777     if (isContextLostOrPending() || !location)
4778         return;
4779 
4780     if (location-&gt;program() != m_currentProgram) {
<a name="590" id="anc590"></a><span class="line-modified">4781         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform2f&quot;, &quot;location not for current program&quot;);</span>
4782         return;
4783     }
4784 
4785     m_context-&gt;uniform2f(location-&gt;location(), x, y);
4786 }
4787 
<a name="591" id="anc591"></a><span class="line-modified">4788 void WebGLRenderingContextBase::uniform3f(const WebGLUniformLocation* location, GCGLfloat x, GCGLfloat y, GCGLfloat z)</span>
4789 {
4790     if (isContextLostOrPending() || !location)
4791         return;
4792 
4793     if (location-&gt;program() != m_currentProgram) {
<a name="592" id="anc592"></a><span class="line-modified">4794         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform3f&quot;, &quot;location not for current program&quot;);</span>
4795         return;
4796     }
4797 
4798     m_context-&gt;uniform3f(location-&gt;location(), x, y, z);
4799 }
4800 
<a name="593" id="anc593"></a><span class="line-modified">4801 void WebGLRenderingContextBase::uniform4f(const WebGLUniformLocation* location, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w)</span>
4802 {
4803     if (isContextLostOrPending() || !location)
4804         return;
4805 
4806     if (location-&gt;program() != m_currentProgram) {
<a name="594" id="anc594"></a><span class="line-modified">4807         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform4f&quot;, &quot;location not for current program&quot;);</span>
4808         return;
4809     }
4810 
4811     m_context-&gt;uniform4f(location-&gt;location(), x, y, z, w);
4812 }
4813 
<a name="595" id="anc595"></a><span class="line-modified">4814 void WebGLRenderingContextBase::uniform1i(const WebGLUniformLocation* location, GCGLint x)</span>
4815 {
4816     if (isContextLostOrPending() || !location)
4817         return;
4818 
4819     if (location-&gt;program() != m_currentProgram) {
<a name="596" id="anc596"></a><span class="line-modified">4820         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform1i&quot;, &quot;location not for current program&quot;);</span>
4821         return;
4822     }
4823 
<a name="597" id="anc597"></a><span class="line-modified">4824     if ((location-&gt;type() == GraphicsContextGL::SAMPLER_2D || location-&gt;type() == GraphicsContextGL::SAMPLER_CUBE) &amp;&amp; x &gt;= (int)m_textureUnits.size()) {</span>
<span class="line-modified">4825         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;uniform1i&quot;, &quot;invalid texture unit&quot;);</span>
4826         return;
4827     }
4828 
4829     m_context-&gt;uniform1i(location-&gt;location(), x);
4830 }
4831 
<a name="598" id="anc598"></a><span class="line-modified">4832 void WebGLRenderingContextBase::uniform2i(const WebGLUniformLocation* location, GCGLint x, GCGLint y)</span>
4833 {
4834     if (isContextLostOrPending() || !location)
4835         return;
4836 
4837     if (location-&gt;program() != m_currentProgram) {
<a name="599" id="anc599"></a><span class="line-modified">4838         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform2i&quot;, &quot;location not for current program&quot;);</span>
4839         return;
4840     }
4841 
4842     m_context-&gt;uniform2i(location-&gt;location(), x, y);
4843 }
4844 
<a name="600" id="anc600"></a><span class="line-modified">4845 void WebGLRenderingContextBase::uniform3i(const WebGLUniformLocation* location, GCGLint x, GCGLint y, GCGLint z)</span>
4846 {
4847     if (isContextLostOrPending() || !location)
4848         return;
4849 
4850     if (location-&gt;program() != m_currentProgram) {
<a name="601" id="anc601"></a><span class="line-modified">4851         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform3i&quot;, &quot;location not for current program&quot;);</span>
4852         return;
4853     }
4854 
4855     m_context-&gt;uniform3i(location-&gt;location(), x, y, z);
4856 }
4857 
<a name="602" id="anc602"></a><span class="line-modified">4858 void WebGLRenderingContextBase::uniform4i(const WebGLUniformLocation* location, GCGLint x, GCGLint y, GCGLint z, GCGLint w)</span>
4859 {
4860     if (isContextLostOrPending() || !location)
4861         return;
4862 
4863     if (location-&gt;program() != m_currentProgram) {
<a name="603" id="anc603"></a><span class="line-modified">4864         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform4i&quot;, &quot;location not for current program&quot;);</span>
4865         return;
4866     }
4867 
4868     m_context-&gt;uniform4i(location-&gt;location(), x, y, z, w);
4869 }
4870 
4871 void WebGLRenderingContextBase::uniform1fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4872 {
4873     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform1fv&quot;, location, v, 1))
4874         return;
4875 
4876     m_context-&gt;uniform1fv(location-&gt;location(), v.length(), v.data());
4877 }
4878 
4879 void WebGLRenderingContextBase::uniform2fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4880 {
4881     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform2fv&quot;, location, v, 2))
4882         return;
4883 
4884     m_context-&gt;uniform2fv(location-&gt;location(), v.length() / 2, v.data());
4885 }
4886 
4887 void WebGLRenderingContextBase::uniform3fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4888 {
4889     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform3fv&quot;, location, v, 3))
4890         return;
4891 
4892     m_context-&gt;uniform3fv(location-&gt;location(), v.length() / 3, v.data());
4893 }
4894 
4895 void WebGLRenderingContextBase::uniform4fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4896 {
4897     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform4fv&quot;, location, v, 4))
4898         return;
4899 
4900     m_context-&gt;uniform4fv(location-&gt;location(), v.length() / 4, v.data());
4901 }
4902 
4903 void WebGLRenderingContextBase::uniform1iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4904 {
4905     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform1iv&quot;, location, v, 1))
4906         return;
4907 
4908     auto data = v.data();
4909     auto length = v.length();
4910 
<a name="604" id="anc604"></a><span class="line-modified">4911     if (location-&gt;type() == GraphicsContextGL::SAMPLER_2D || location-&gt;type() == GraphicsContextGL::SAMPLER_CUBE) {</span>
4912         for (auto i = 0; i &lt; length; ++i) {
4913             if (data[i] &gt;= static_cast&lt;int&gt;(m_textureUnits.size())) {
4914                 LOG(WebGL, &quot;Texture unit size=%zu, v[%d]=%d. Location type = %04X.&quot;, m_textureUnits.size(), i, data[i], location-&gt;type());
<a name="605" id="anc605"></a><span class="line-modified">4915                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;uniform1iv&quot;, &quot;invalid texture unit&quot;);</span>
4916                 return;
4917             }
4918         }
4919     }
4920 
4921     m_context-&gt;uniform1iv(location-&gt;location(), length, data);
4922 }
4923 
4924 void WebGLRenderingContextBase::uniform2iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4925 {
4926     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform2iv&quot;, location, v, 2))
4927         return;
4928 
4929     m_context-&gt;uniform2iv(location-&gt;location(), v.length() / 2, v.data());
4930 }
4931 
4932 void WebGLRenderingContextBase::uniform3iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4933 {
4934     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform3iv&quot;, location, v, 3))
4935         return;
4936 
4937     m_context-&gt;uniform3iv(location-&gt;location(), v.length() / 3, v.data());
4938 }
4939 
4940 void WebGLRenderingContextBase::uniform4iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4941 {
4942     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform4iv&quot;, location, v, 4))
4943         return;
4944 
4945     m_context-&gt;uniform4iv(location-&gt;location(), v.length() / 4, v.data());
4946 }
4947 
<a name="606" id="anc606"></a><span class="line-modified">4948 void WebGLRenderingContextBase::uniformMatrix2fv(const WebGLUniformLocation* location, GCGLboolean transpose, Float32List&amp;&amp; v)</span>
4949 {
4950     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix2fv&quot;, location, transpose, v, 4))
4951         return;
4952     m_context-&gt;uniformMatrix2fv(location-&gt;location(), v.length() / 4, transpose, v.data());
4953 }
4954 
<a name="607" id="anc607"></a><span class="line-modified">4955 void WebGLRenderingContextBase::uniformMatrix3fv(const WebGLUniformLocation* location, GCGLboolean transpose, Float32List&amp;&amp; v)</span>
4956 {
4957     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix3fv&quot;, location, transpose, v, 9))
4958         return;
4959     m_context-&gt;uniformMatrix3fv(location-&gt;location(), v.length() / 9, transpose, v.data());
4960 }
4961 
<a name="608" id="anc608"></a><span class="line-modified">4962 void WebGLRenderingContextBase::uniformMatrix4fv(const WebGLUniformLocation* location, GCGLboolean transpose, Float32List&amp;&amp; v)</span>
4963 {
4964     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix4fv&quot;, location, transpose, v, 16))
4965         return;
4966     m_context-&gt;uniformMatrix4fv(location-&gt;location(), v.length() / 16, transpose, v.data());
4967 }
4968 
4969 void WebGLRenderingContextBase::useProgram(WebGLProgram* program)
4970 {
4971     bool deleted;
4972     if (!checkObjectToBeBound(&quot;useProgram&quot;, program, deleted))
4973         return;
4974     if (deleted)
4975         program = 0;
4976     if (program &amp;&amp; !program-&gt;getLinkStatus()) {
<a name="609" id="anc609"></a><span class="line-modified">4977         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;useProgram&quot;, &quot;program not valid&quot;);</span>
4978         return;
4979     }
4980     if (m_currentProgram != program) {
4981         if (m_currentProgram)
<a name="610" id="anc610"></a><span class="line-modified">4982             m_currentProgram-&gt;onDetached(graphicsContextGL());</span>
4983         m_currentProgram = program;
4984         m_context-&gt;useProgram(objectOrZero(program));
4985         if (program)
4986             program-&gt;onAttached();
4987     }
4988 }
4989 
4990 void WebGLRenderingContextBase::validateProgram(WebGLProgram* program)
4991 {
4992     if (isContextLostOrPending() || !validateWebGLObject(&quot;validateProgram&quot;, program))
4993         return;
4994     m_context-&gt;validateProgram(objectOrZero(program));
4995 }
4996 
<a name="611" id="anc611"></a><span class="line-modified">4997 void WebGLRenderingContextBase::vertexAttrib1f(GCGLuint index, GCGLfloat v0)</span>
4998 {
4999     vertexAttribfImpl(&quot;vertexAttrib1f&quot;, index, 1, v0, 0.0f, 0.0f, 1.0f);
5000 }
5001 
<a name="612" id="anc612"></a><span class="line-modified">5002 void WebGLRenderingContextBase::vertexAttrib2f(GCGLuint index, GCGLfloat v0, GCGLfloat v1)</span>
5003 {
5004     vertexAttribfImpl(&quot;vertexAttrib2f&quot;, index, 2, v0, v1, 0.0f, 1.0f);
5005 }
5006 
<a name="613" id="anc613"></a><span class="line-modified">5007 void WebGLRenderingContextBase::vertexAttrib3f(GCGLuint index, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2)</span>
5008 {
5009     vertexAttribfImpl(&quot;vertexAttrib3f&quot;, index, 3, v0, v1, v2, 1.0f);
5010 }
5011 
<a name="614" id="anc614"></a><span class="line-modified">5012 void WebGLRenderingContextBase::vertexAttrib4f(GCGLuint index, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2, GCGLfloat v3)</span>
5013 {
5014     vertexAttribfImpl(&quot;vertexAttrib4f&quot;, index, 4, v0, v1, v2, v3);
5015 }
5016 
<a name="615" id="anc615"></a><span class="line-modified">5017 void WebGLRenderingContextBase::vertexAttrib1fv(GCGLuint index, Float32List&amp;&amp; v)</span>
5018 {
5019     vertexAttribfvImpl(&quot;vertexAttrib1fv&quot;, index, WTFMove(v), 1);
5020 }
5021 
<a name="616" id="anc616"></a><span class="line-modified">5022 void WebGLRenderingContextBase::vertexAttrib2fv(GCGLuint index, Float32List&amp;&amp; v)</span>
5023 {
5024     vertexAttribfvImpl(&quot;vertexAttrib2fv&quot;, index, WTFMove(v), 2);
5025 }
5026 
<a name="617" id="anc617"></a><span class="line-modified">5027 void WebGLRenderingContextBase::vertexAttrib3fv(GCGLuint index, Float32List&amp;&amp; v)</span>
5028 {
5029     vertexAttribfvImpl(&quot;vertexAttrib3fv&quot;, index, WTFMove(v), 3);
5030 }
5031 
<a name="618" id="anc618"></a><span class="line-modified">5032 void WebGLRenderingContextBase::vertexAttrib4fv(GCGLuint index, Float32List&amp;&amp; v)</span>
5033 {
5034     vertexAttribfvImpl(&quot;vertexAttrib4fv&quot;, index, WTFMove(v), 4);
5035 }
5036 
<a name="619" id="anc619"></a><span class="line-modified">5037 void WebGLRenderingContextBase::vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized, GCGLsizei stride, long long offset)</span>
5038 {
5039     if (isContextLostOrPending())
5040         return;
5041     switch (type) {
<a name="620" id="anc620"></a><span class="line-modified">5042     case GraphicsContextGL::BYTE:</span>
<span class="line-modified">5043     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">5044     case GraphicsContextGL::SHORT:</span>
<span class="line-modified">5045     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="line-modified">5046     case GraphicsContextGL::FLOAT:</span>
5047         break;
5048     default:
<a name="621" id="anc621"></a><span class="line-modified">5049         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);</span>
5050         return;
5051     }
5052     if (index &gt;= m_maxVertexAttribs) {
<a name="622" id="anc622"></a><span class="line-modified">5053         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;index out of range&quot;);</span>
5054         return;
5055     }
5056     if (size &lt; 1 || size &gt; 4) {
<a name="623" id="anc623"></a><span class="line-modified">5057         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad size&quot;);</span>
5058         return;
5059     }
5060     if (stride &lt; 0 || stride &gt; 255) {
<a name="624" id="anc624"></a><span class="line-modified">5061         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad stride&quot;);</span>
5062         return;
5063     }
5064     if (offset &lt; 0 || offset &gt; std::numeric_limits&lt;int32_t&gt;::max()) {
<a name="625" id="anc625"></a><span class="line-modified">5065         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad offset&quot;);</span>
5066         return;
5067     }
5068     if (!m_boundArrayBuffer &amp;&amp; offset) {
<a name="626" id="anc626"></a><span class="line-modified">5069         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;no bound ARRAY_BUFFER&quot;);</span>
5070         return;
5071     }
5072     // Determine the number of elements the bound buffer can hold, given the offset, size, type and stride
5073     auto typeSize = sizeInBytes(type);
5074     if (!typeSize) {
<a name="627" id="anc627"></a><span class="line-modified">5075         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);</span>
5076         return;
5077     }
<a name="628" id="anc628"></a><span class="line-modified">5078     if ((stride % typeSize) || (static_cast&lt;GCGLintptr&gt;(offset) % typeSize)) {</span>
<span class="line-modified">5079         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;stride or offset not valid for type&quot;);</span>
5080         return;
5081     }
<a name="629" id="anc629"></a><span class="line-modified">5082     GCGLsizei bytesPerElement = size * typeSize;</span>
5083 
<a name="630" id="anc630"></a><span class="line-modified">5084     m_boundVertexArrayObject-&gt;setVertexAttribState(index, bytesPerElement, size, type, normalized, stride, static_cast&lt;GCGLintptr&gt;(offset), m_boundArrayBuffer.get());</span>
<span class="line-modified">5085     m_context-&gt;vertexAttribPointer(index, size, type, normalized, stride, static_cast&lt;GCGLintptr&gt;(offset));</span>
5086 }
5087 
<a name="631" id="anc631"></a><span class="line-modified">5088 void WebGLRenderingContextBase::viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)</span>
5089 {
5090     if (isContextLostOrPending())
5091         return;
5092     if (!validateSize(&quot;viewport&quot;, width, height))
5093         return;
5094     m_context-&gt;viewport(x, y, width, height);
5095 }
5096 
5097 void WebGLRenderingContextBase::forceLostContext(WebGLRenderingContextBase::LostContextMode mode)
5098 {
5099     if (isContextLostOrPending()) {
<a name="632" id="anc632"></a><span class="line-modified">5100         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;loseContext&quot;, &quot;context already lost&quot;);</span>
5101         return;
5102     }
5103 
5104     m_contextGroup-&gt;loseContextGroup(mode);
5105 }
5106 
5107 void WebGLRenderingContextBase::loseContextImpl(WebGLRenderingContextBase::LostContextMode mode)
5108 {
5109     if (isContextLost())
5110         return;
5111 
5112     m_contextLost = true;
5113     m_contextLostMode = mode;
5114 
5115     if (mode == RealLostContext) {
5116         // Inform the embedder that a lost context was received. In response, the embedder might
5117         // decide to take action such as asking the user for permission to use WebGL again.
5118         auto* canvas = htmlCanvas();
5119         if (canvas) {
5120             if (RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame())
5121                 frame-&gt;loader().client().didLoseWebGLContext(m_context-&gt;getExtensions().getGraphicsResetStatusARB());
5122         }
5123     }
5124 
5125     detachAndRemoveAllObjects();
5126 
5127     // There is no direct way to clear errors from a GL implementation and
5128     // looping until getError() becomes NO_ERROR might cause an infinite loop if
5129     // the driver or context implementation had a bug. So, loop a reasonably
5130     // large number of times to clear any existing errors.
5131     for (int i = 0; i &lt; 100; ++i) {
<a name="633" id="anc633"></a><span class="line-modified">5132         if (m_context-&gt;getError() == GraphicsContextGL::NO_ERROR)</span>
5133             break;
5134     }
5135     ConsoleDisplayPreference display = (mode == RealLostContext) ? DisplayInConsole: DontDisplayInConsole;
<a name="634" id="anc634"></a><span class="line-modified">5136     synthesizeGLError(GraphicsContextGL::CONTEXT_LOST_WEBGL, &quot;loseContext&quot;, &quot;context lost&quot;, display);</span>
5137 
5138     // Don&#39;t allow restoration unless the context lost event has both been
5139     // dispatched and its default behavior prevented.
5140     m_restoreAllowed = false;
5141 
5142     // Always defer the dispatch of the context lost event, to implement
5143     // the spec behavior of queueing a task.
5144     m_dispatchContextLostEventTimer.startOneShot(0_s);
5145 }
5146 
5147 void WebGLRenderingContextBase::forceRestoreContext()
5148 {
5149     if (!isContextLostOrPending()) {
<a name="635" id="anc635"></a><span class="line-modified">5150         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context not lost&quot;);</span>
5151         return;
5152     }
5153 
5154     if (!m_restoreAllowed) {
5155         if (m_contextLostMode == SyntheticLostContext)
<a name="636" id="anc636"></a><span class="line-modified">5156             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context restoration not allowed&quot;);</span>
5157         return;
5158     }
5159 
5160     if (!m_restoreTimer.isActive())
5161         m_restoreTimer.startOneShot(0_s);
5162 }
5163 
5164 PlatformLayer* WebGLRenderingContextBase::platformLayer() const
5165 {
5166     return (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) ? m_context-&gt;platformLayer() : 0;
5167 }
5168 
5169 void WebGLRenderingContextBase::removeSharedObject(WebGLSharedObject&amp; object)
5170 {
5171     if (m_isPendingPolicyResolution)
5172         return;
5173 
5174     m_contextGroup-&gt;removeObject(object);
5175 }
5176 
5177 void WebGLRenderingContextBase::addSharedObject(WebGLSharedObject&amp; object)
5178 {
5179     if (m_isPendingPolicyResolution)
5180         return;
5181 
5182     ASSERT(!isContextLost());
5183     m_contextGroup-&gt;addObject(object);
5184 }
5185 
5186 void WebGLRenderingContextBase::removeContextObject(WebGLContextObject&amp; object)
5187 {
5188     if (m_isPendingPolicyResolution)
5189         return;
5190 
5191     m_contextObjects.remove(&amp;object);
5192 }
5193 
5194 void WebGLRenderingContextBase::addContextObject(WebGLContextObject&amp; object)
5195 {
5196     if (m_isPendingPolicyResolution)
5197         return;
5198 
5199     ASSERT(!isContextLost());
5200     m_contextObjects.add(&amp;object);
5201 }
5202 
5203 void WebGLRenderingContextBase::detachAndRemoveAllObjects()
5204 {
5205     if (m_isPendingPolicyResolution)
5206         return;
5207 
5208     while (m_contextObjects.size() &gt; 0) {
5209         HashSet&lt;WebGLContextObject*&gt;::iterator it = m_contextObjects.begin();
5210         (*it)-&gt;detachContext();
5211     }
5212 }
5213 
5214 bool WebGLRenderingContextBase::hasPendingActivity() const
5215 {
5216     return false;
5217 }
5218 
5219 void WebGLRenderingContextBase::stop()
5220 {
5221     if (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) {
5222         forceLostContext(SyntheticLostContext);
<a name="637" id="anc637"></a><span class="line-modified">5223         destroyGraphicsContextGL();</span>
5224     }
5225 }
5226 
5227 const char* WebGLRenderingContextBase::activeDOMObjectName() const
5228 {
5229     return &quot;WebGLRenderingContext&quot;;
5230 }
5231 
<a name="638" id="anc638"></a><span class="line-modified">5232 void WebGLRenderingContextBase::suspend(ReasonForSuspension)</span>
5233 {
<a name="639" id="anc639"></a><span class="line-modified">5234     m_isSuspended = true;</span>

5235 }
5236 
<a name="640" id="anc640"></a><span class="line-modified">5237 void WebGLRenderingContextBase::resume()</span>
5238 {
<a name="641" id="anc641"></a><span class="line-modified">5239     m_isSuspended = false;</span>
<span class="line-added">5240 }</span>
<span class="line-added">5241 </span>
<span class="line-added">5242 bool WebGLRenderingContextBase::getBooleanParameter(GCGLenum pname)</span>
<span class="line-added">5243 {</span>
<span class="line-added">5244     GCGLboolean value = 0;</span>
5245     m_context-&gt;getBooleanv(pname, &amp;value);
5246     return value;
5247 }
5248 
<a name="642" id="anc642"></a><span class="line-modified">5249 Vector&lt;bool&gt; WebGLRenderingContextBase::getBooleanArrayParameter(GCGLenum pname)</span>
5250 {
<a name="643" id="anc643"></a><span class="line-modified">5251     if (pname != GraphicsContextGL::COLOR_WRITEMASK) {</span>
5252         notImplemented();
5253         return { };
5254     }
<a name="644" id="anc644"></a><span class="line-modified">5255     GCGLboolean value[4] = { 0 };</span>
5256     m_context-&gt;getBooleanv(pname, value);
5257     Vector&lt;bool&gt; vector(4);
5258     for (unsigned i = 0; i &lt; 4; ++i)
5259         vector[i] = value[i];
5260     return vector;
5261 }
5262 
<a name="645" id="anc645"></a><span class="line-modified">5263 float WebGLRenderingContextBase::getFloatParameter(GCGLenum pname)</span>
5264 {
<a name="646" id="anc646"></a><span class="line-modified">5265     GCGLfloat value = 0;</span>
5266     m_context-&gt;getFloatv(pname, &amp;value);
5267     return value;
5268 }
5269 
<a name="647" id="anc647"></a><span class="line-modified">5270 int WebGLRenderingContextBase::getIntParameter(GCGLenum pname)</span>
5271 {
<a name="648" id="anc648"></a><span class="line-modified">5272     GCGLint value = 0;</span>
5273     m_context-&gt;getIntegerv(pname, &amp;value);
5274     return value;
5275 }
5276 
<a name="649" id="anc649"></a><span class="line-modified">5277 unsigned WebGLRenderingContextBase::getUnsignedIntParameter(GCGLenum pname)</span>
5278 {
<a name="650" id="anc650"></a><span class="line-modified">5279     GCGLint value = 0;</span>
5280     m_context-&gt;getIntegerv(pname, &amp;value);
5281     return value;
5282 }
5283 
<a name="651" id="anc651"></a><span class="line-modified">5284 long long WebGLRenderingContextBase::getInt64Parameter(GCGLenum pname)</span>
5285 {
<a name="652" id="anc652"></a><span class="line-modified">5286     GCGLint64 value = 0;</span>
5287     m_context-&gt;getInteger64v(pname, &amp;value);
5288     return value;
5289 }
5290 
<a name="653" id="anc653"></a><span class="line-modified">5291 RefPtr&lt;Float32Array&gt; WebGLRenderingContextBase::getWebGLFloatArrayParameter(GCGLenum pname)</span>
5292 {
<a name="654" id="anc654"></a><span class="line-modified">5293     GCGLfloat value[4] = {0};</span>
5294     m_context-&gt;getFloatv(pname, value);
5295     unsigned length = 0;
5296     switch (pname) {
<a name="655" id="anc655"></a><span class="line-modified">5297     case GraphicsContextGL::ALIASED_POINT_SIZE_RANGE:</span>
<span class="line-modified">5298     case GraphicsContextGL::ALIASED_LINE_WIDTH_RANGE:</span>
<span class="line-modified">5299     case GraphicsContextGL::DEPTH_RANGE:</span>
5300         length = 2;
5301         break;
<a name="656" id="anc656"></a><span class="line-modified">5302     case GraphicsContextGL::BLEND_COLOR:</span>
<span class="line-modified">5303     case GraphicsContextGL::COLOR_CLEAR_VALUE:</span>
5304         length = 4;
5305         break;
5306     default:
5307         notImplemented();
5308     }
5309     return Float32Array::tryCreate(value, length);
5310 }
5311 
<a name="657" id="anc657"></a><span class="line-modified">5312 RefPtr&lt;Int32Array&gt; WebGLRenderingContextBase::getWebGLIntArrayParameter(GCGLenum pname)</span>
5313 {
<a name="658" id="anc658"></a><span class="line-modified">5314     GCGLint value[4] = {0};</span>
5315     m_context-&gt;getIntegerv(pname, value);
5316     unsigned length = 0;
5317     switch (pname) {
<a name="659" id="anc659"></a><span class="line-modified">5318     case GraphicsContextGL::MAX_VIEWPORT_DIMS:</span>
5319         length = 2;
5320         break;
<a name="660" id="anc660"></a><span class="line-modified">5321     case GraphicsContextGL::SCISSOR_BOX:</span>
<span class="line-modified">5322     case GraphicsContextGL::VIEWPORT:</span>
5323         length = 4;
5324         break;
5325     default:
5326         notImplemented();
5327     }
5328     return Int32Array::tryCreate(value, length);
5329 }
5330 
5331 bool WebGLRenderingContextBase::checkTextureCompleteness(const char* functionName, bool prepareToDraw)
5332 {
5333     bool resetActiveUnit = false;
5334     bool usesAtLeastOneBlackTexture = false;
5335     WebGLTexture::TextureExtensionFlag extensions = textureExtensionFlags();
5336 
5337     Vector&lt;unsigned&gt; noLongerUnrenderable;
5338     for (unsigned badTexture : m_unrenderableTextureUnits) {
5339         ASSERT(badTexture &lt; m_textureUnits.size());
5340         auto&amp; textureUnit = m_textureUnits[badTexture];
5341         bool needsToUseBlack2DTexture = textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(extensions);
5342         bool needsToUseBlack3DTexture = textureUnit.textureCubeMapBinding &amp;&amp; textureUnit.textureCubeMapBinding-&gt;needToUseBlackTexture(extensions);
5343 
5344         if (!needsToUseBlack2DTexture &amp;&amp; !needsToUseBlack3DTexture) {
5345             noLongerUnrenderable.append(badTexture);
5346             continue;
5347         }
5348 
5349         usesAtLeastOneBlackTexture = true;
5350 
5351         if (badTexture != m_activeTextureUnit) {
<a name="661" id="anc661"></a><span class="line-modified">5352             m_context-&gt;activeTexture(badTexture + GraphicsContextGL::TEXTURE0);</span>
5353             resetActiveUnit = true;
5354         } else if (resetActiveUnit) {
<a name="662" id="anc662"></a><span class="line-modified">5355             m_context-&gt;activeTexture(badTexture + GraphicsContextGL::TEXTURE0);</span>
5356             resetActiveUnit = false;
5357         }
5358         RefPtr&lt;WebGLTexture&gt; tex2D;
5359         RefPtr&lt;WebGLTexture&gt; texCubeMap;
5360         if (prepareToDraw) {
5361             printToConsole(MessageLevel::Error, makeString(&quot;WebGL: &quot;, functionName, &quot;: texture bound to texture unit &quot;, badTexture,
5362                 &quot; is not renderable. It maybe non-power-of-2 and have incompatible texture filtering or is not &#39;texture complete&#39;,&quot;
5363                 &quot; or it is a float/half-float type with linear filtering and without the relevant float/half-float linear extension enabled.&quot;));
5364             tex2D = m_blackTexture2D.get();
5365             texCubeMap = m_blackTextureCubeMap.get();
5366         } else {
5367             tex2D = textureUnit.texture2DBinding.get();
5368             texCubeMap = textureUnit.textureCubeMapBinding.get();
5369         }
5370         if (needsToUseBlack2DTexture)
<a name="663" id="anc663"></a><span class="line-modified">5371             m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, objectOrZero(tex2D.get()));</span>
5372         if (needsToUseBlack3DTexture)
<a name="664" id="anc664"></a><span class="line-modified">5373             m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_CUBE_MAP, objectOrZero(texCubeMap.get()));</span>
5374     }
5375     if (resetActiveUnit)
<a name="665" id="anc665"></a><span class="line-modified">5376         m_context-&gt;activeTexture(m_activeTextureUnit + GraphicsContextGL::TEXTURE0);</span>
5377 
5378     for (unsigned renderable : noLongerUnrenderable)
5379         m_unrenderableTextureUnits.remove(renderable);
5380 
5381     return usesAtLeastOneBlackTexture;
5382 }
5383 
5384 void WebGLRenderingContextBase::createFallbackBlackTextures1x1()
5385 {
5386     unsigned char black[] = {0, 0, 0, 255};
5387     m_blackTexture2D = createTexture();
<a name="666" id="anc666"></a><span class="line-modified">5388     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, m_blackTexture2D-&gt;object());</span>
<span class="line-modified">5389     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5390         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5391     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, 0);</span>
5392     m_blackTextureCubeMap = createTexture();
<a name="667" id="anc667"></a><span class="line-modified">5393     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_CUBE_MAP, m_blackTextureCubeMap-&gt;object());</span>
<span class="line-modified">5394     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5395         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5396     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5397         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5398     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5399         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5400     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5401         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5402     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5403         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5404     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5405         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5406     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_CUBE_MAP, 0);</span>
<span class="line-modified">5407 }</span>
<span class="line-modified">5408 </span>
<span class="line-modified">5409 bool WebGLRenderingContextBase::isTexInternalFormatColorBufferCombinationValid(GCGLenum texInternalFormat, GCGLenum colorBufferFormat)</span>
<span class="line-modified">5410 {</span>
<span class="line-modified">5411     auto need = GraphicsContextGLOpenGL::getChannelBitsByFormat(texInternalFormat);</span>
<span class="line-modified">5412     auto have = GraphicsContextGLOpenGL::getChannelBitsByFormat(colorBufferFormat);</span>

5413     return (need &amp; have) == need;
5414 }
5415 
<a name="668" id="anc668"></a><span class="line-modified">5416 GCGLenum WebGLRenderingContextBase::getBoundFramebufferColorFormat()</span>
5417 {
5418     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5419         return m_framebufferBinding-&gt;getColorBufferFormat();
5420     if (m_attributes.alpha)
<a name="669" id="anc669"></a><span class="line-modified">5421         return GraphicsContextGL::RGBA;</span>
<span class="line-modified">5422     return GraphicsContextGL::RGB;</span>
5423 }
5424 
5425 int WebGLRenderingContextBase::getBoundFramebufferWidth()
5426 {
5427     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5428         return m_framebufferBinding-&gt;getColorBufferWidth();
5429     return m_context-&gt;getInternalFramebufferSize().width();
5430 }
5431 
5432 int WebGLRenderingContextBase::getBoundFramebufferHeight()
5433 {
5434     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5435         return m_framebufferBinding-&gt;getColorBufferHeight();
5436     return m_context-&gt;getInternalFramebufferSize().height();
5437 }
5438 
<a name="670" id="anc670"></a><span class="line-modified">5439 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::validateTextureBinding(const char* functionName, GCGLenum target, bool useSixEnumsForCubeMap)</span>
5440 {
5441     RefPtr&lt;WebGLTexture&gt; texture;
5442     switch (target) {
<a name="671" id="anc671"></a><span class="line-modified">5443     case GraphicsContextGL::TEXTURE_2D:</span>
5444         texture = m_textureUnits[m_activeTextureUnit].texture2DBinding;
5445         break;
<a name="672" id="anc672"></a><span class="line-modified">5446     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="line-modified">5447     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="line-modified">5448     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="line-modified">5449     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="line-modified">5450     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="line-modified">5451     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
5452         if (!useSixEnumsForCubeMap) {
<a name="673" id="anc673"></a><span class="line-modified">5453             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
5454             return nullptr;
5455         }
5456         texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
5457         break;
<a name="674" id="anc674"></a><span class="line-modified">5458     case GraphicsContextGL::TEXTURE_CUBE_MAP:</span>
5459         if (useSixEnumsForCubeMap) {
<a name="675" id="anc675"></a><span class="line-modified">5460             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
5461             return nullptr;
5462         }
5463         texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
5464         break;
5465     default:
<a name="676" id="anc676"></a><span class="line-modified">5466         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
5467         return nullptr;
5468     }
5469 
5470     if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
5471         m_unrenderableTextureUnits.add(m_activeTextureUnit);
5472 
5473     if (!texture)
<a name="677" id="anc677"></a><span class="line-modified">5474         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;no texture&quot;);</span>
5475     return texture;
5476 }
5477 
5478 bool WebGLRenderingContextBase::validateLocationLength(const char* functionName, const String&amp; string)
5479 {
5480     const unsigned maxWebGLLocationLength = 256;
5481     if (string.length() &gt; maxWebGLLocationLength) {
<a name="678" id="anc678"></a><span class="line-modified">5482         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;location length &gt; 256&quot;);</span>
5483         return false;
5484     }
5485     return true;
5486 }
5487 
<a name="679" id="anc679"></a><span class="line-modified">5488 bool WebGLRenderingContextBase::validateSize(const char* functionName, GCGLint x, GCGLint y)</span>
5489 {
5490     if (x &lt; 0 || y &lt; 0) {
<a name="680" id="anc680"></a><span class="line-modified">5491         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;size &lt; 0&quot;);</span>
5492         return false;
5493     }
5494     return true;
5495 }
5496 
5497 bool WebGLRenderingContextBase::validateString(const char* functionName, const String&amp; string)
5498 {
5499     for (size_t i = 0; i &lt; string.length(); ++i) {
5500         if (!validateCharacter(string[i])) {
<a name="681" id="anc681"></a><span class="line-modified">5501             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;string not ASCII&quot;);</span>
5502             return false;
5503         }
5504     }
5505     return true;
5506 }
5507 
<a name="682" id="anc682"></a><span class="line-modified">5508 bool WebGLRenderingContextBase::validateTexFuncLevel(const char* functionName, GCGLenum target, GCGLint level)</span>
5509 {
5510     if (level &lt; 0) {
<a name="683" id="anc683"></a><span class="line-modified">5511         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level &lt; 0&quot;);</span>
5512         return false;
5513     }
5514     switch (target) {
<a name="684" id="anc684"></a><span class="line-modified">5515     case GraphicsContextGL::TEXTURE_2D:</span>
5516         if (level &gt;= m_maxTextureLevel) {
<a name="685" id="anc685"></a><span class="line-modified">5517             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level out of range&quot;);</span>
5518             return false;
5519         }
5520         break;
<a name="686" id="anc686"></a><span class="line-modified">5521     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="line-modified">5522     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="line-modified">5523     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="line-modified">5524     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="line-modified">5525     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="line-modified">5526     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
5527         if (level &gt;= m_maxCubeMapTextureLevel) {
<a name="687" id="anc687"></a><span class="line-modified">5528             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level out of range&quot;);</span>
5529             return false;
5530         }
5531         break;
5532     }
5533     // This function only checks if level is legal, so we return true and don&#39;t
5534     // generate INVALID_ENUM if target is illegal.
5535     return true;
5536 }
5537 
<a name="688" id="anc688"></a><span class="line-modified">5538 bool WebGLRenderingContextBase::validateCompressedTexFormat(GCGLenum format)</span>
5539 {
5540     return m_compressedTextureFormats.contains(format);
5541 }
5542 
5543 struct BlockParameters {
5544     const int width;
5545     const int height;
5546     const int size;
5547 };
5548 
<a name="689" id="anc689"></a><span class="line-modified">5549 static inline unsigned calculateBytesForASTC(GCGLsizei width, GCGLsizei height, const BlockParameters&amp; parameters)</span>
5550 {
5551     return ((width + parameters.width - 1) / parameters.width) * ((height + parameters.height - 1) / parameters.height) * parameters.size;
5552 }
5553 
<a name="690" id="anc690"></a><span class="line-modified">5554 bool WebGLRenderingContextBase::validateCompressedTexFuncData(const char* functionName, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; pixels)</span>
5555 {
5556     if (width &lt; 0 || height &lt; 0) {
<a name="691" id="anc691"></a><span class="line-modified">5557         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);</span>
5558         return false;
5559     }
5560 
5561     unsigned bytesRequired = 0;
5562 
5563     // Block parameters for ASTC formats
5564     const int kASTCBlockSize = 16;
5565     static const BlockParameters ASTCParameters[] {
5566         BlockParameters { 4, 4, kASTCBlockSize },
5567         BlockParameters { 5, 4, kASTCBlockSize },
5568         BlockParameters { 5, 5, kASTCBlockSize },
5569         BlockParameters { 6, 5, kASTCBlockSize },
5570         BlockParameters { 6, 6, kASTCBlockSize },
5571         BlockParameters { 8, 5, kASTCBlockSize },
5572         BlockParameters { 8, 6, kASTCBlockSize },
5573         BlockParameters { 8, 8, kASTCBlockSize },
5574         BlockParameters { 10, 5, kASTCBlockSize },
5575         BlockParameters { 10, 6, kASTCBlockSize },
5576         BlockParameters { 10, 8, kASTCBlockSize },
5577         BlockParameters { 10, 10, kASTCBlockSize },
5578         BlockParameters { 12, 10, kASTCBlockSize },
5579         BlockParameters { 12, 12, kASTCBlockSize }
5580     };
<a name="692" id="anc692"></a><span class="line-modified">5581     const GCGLenum ASTCEnumStartRGBA = ExtensionsGL::COMPRESSED_RGBA_ASTC_4x4_KHR;</span>
<span class="line-modified">5582     const GCGLenum ASTCEnumStartSRGB8 = ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;</span>
<span class="line-added">5583 </span>
<span class="line-added">5584     const int kEACAndETC2BlockSize = 4;</span>
5585 
5586     switch (format) {
<a name="693" id="anc693"></a><span class="line-modified">5587     case ExtensionsGL::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="line-modified">5588     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="line-modified">5589     case ExtensionsGL::COMPRESSED_ATC_RGB_AMD:</span>
<span class="line-modified">5590     case ExtensionsGL::ETC1_RGB8_OES: {</span>
<span class="line-modified">5591         const int kBlockSize = 8;</span>
<span class="line-modified">5592         const int kBlockWidth = 4;</span>
<span class="line-modified">5593         const int kBlockHeight = 4;</span>
<span class="line-modified">5594         int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;</span>
<span class="line-modified">5595         int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;</span>
<span class="line-modified">5596         bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;</span>

5597         break;
<a name="694" id="anc694"></a><span class="line-modified">5598     }</span>
<span class="line-modified">5599     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="line-modified">5600     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT5_EXT:</span>
<span class="line-modified">5601     case ExtensionsGL::COMPRESSED_ATC_RGBA_EXPLICIT_ALPHA_AMD:</span>
<span class="line-added">5602     case ExtensionsGL::COMPRESSED_ATC_RGBA_INTERPOLATED_ALPHA_AMD:</span>
5603         {
5604             const int kBlockSize = 16;
5605             const int kBlockWidth = 4;
5606             const int kBlockHeight = 4;
5607             int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;
5608             int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;
5609             bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;
5610         }
5611         break;
<a name="695" id="anc695"></a><span class="line-modified">5612     case ExtensionsGL::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5613     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
5614         {
5615             const int kBlockSize = 8;
5616             const int kBlockWidth = 8;
5617             const int kBlockHeight = 8;
5618             bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 4 + 7) / kBlockSize;
5619         }
5620         break;
<a name="696" id="anc696"></a><span class="line-modified">5621     case ExtensionsGL::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="line-modified">5622     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:</span>
5623         {
5624             const int kBlockSize = 8;
5625             const int kBlockWidth = 16;
5626             const int kBlockHeight = 8;
5627             bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 2 + 7) / kBlockSize;
5628         }
5629         break;
<a name="697" id="anc697"></a><span class="line-modified">5630     case ExtensionsGL::COMPRESSED_RGBA_ASTC_4x4_KHR:</span>
<span class="line-modified">5631     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x4_KHR:</span>
<span class="line-modified">5632     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x5_KHR:</span>
<span class="line-modified">5633     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x5_KHR:</span>
<span class="line-modified">5634     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x6_KHR:</span>
<span class="line-modified">5635     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x5_KHR:</span>
<span class="line-modified">5636     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x6_KHR:</span>
<span class="line-modified">5637     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x8_KHR:</span>
<span class="line-modified">5638     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x5_KHR:</span>
<span class="line-modified">5639     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x6_KHR:</span>
<span class="line-modified">5640     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x8_KHR:</span>
<span class="line-modified">5641     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x10_KHR:</span>
<span class="line-modified">5642     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x10_KHR:</span>
<span class="line-modified">5643     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x12_KHR:</span>
5644         bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartRGBA]);
5645         break;
<a name="698" id="anc698"></a><span class="line-modified">5646     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:</span>
<span class="line-modified">5647     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:</span>
<span class="line-modified">5648     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:</span>
<span class="line-modified">5649     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:</span>
<span class="line-modified">5650     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:</span>
<span class="line-modified">5651     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:</span>
<span class="line-modified">5652     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:</span>
<span class="line-modified">5653     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:</span>
<span class="line-modified">5654     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:</span>
<span class="line-modified">5655     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:</span>
<span class="line-modified">5656     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:</span>
<span class="line-modified">5657     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:</span>
<span class="line-modified">5658     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:</span>
<span class="line-modified">5659     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:</span>
5660         bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartSRGB8]);
5661         break;
<a name="699" id="anc699"></a><span class="line-added">5662     case ExtensionsGL::COMPRESSED_R11_EAC:</span>
<span class="line-added">5663     case ExtensionsGL::COMPRESSED_SIGNED_R11_EAC:</span>
<span class="line-added">5664     case ExtensionsGL::COMPRESSED_RGB8_ETC2:</span>
<span class="line-added">5665     case ExtensionsGL::COMPRESSED_SRGB8_ETC2:</span>
<span class="line-added">5666     case ExtensionsGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-added">5667     case ExtensionsGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: {</span>
<span class="line-added">5668         Checked&lt;unsigned, RecordOverflow&gt; checkedBytesRequired = (width + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;</span>
<span class="line-added">5669         checkedBytesRequired *= (height + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;</span>
<span class="line-added">5670         checkedBytesRequired *= 8;</span>
<span class="line-added">5671         if (checkedBytesRequired.hasOverflowed()) {</span>
<span class="line-added">5672             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;too large dimensions&quot;);</span>
<span class="line-added">5673             return false;</span>
<span class="line-added">5674         }</span>
<span class="line-added">5675         bytesRequired = checkedBytesRequired.unsafeGet();</span>
<span class="line-added">5676         break;</span>
<span class="line-added">5677     }</span>
<span class="line-added">5678     case ExtensionsGL::COMPRESSED_RG11_EAC:</span>
<span class="line-added">5679     case ExtensionsGL::COMPRESSED_SIGNED_RG11_EAC:</span>
<span class="line-added">5680     case ExtensionsGL::COMPRESSED_RGBA8_ETC2_EAC:</span>
<span class="line-added">5681     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: {</span>
<span class="line-added">5682         Checked&lt;unsigned, RecordOverflow&gt; checkedBytesRequired = (width + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;</span>
<span class="line-added">5683         checkedBytesRequired *= (height + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;</span>
<span class="line-added">5684         checkedBytesRequired *= 16;</span>
<span class="line-added">5685         if (checkedBytesRequired.hasOverflowed()) {</span>
<span class="line-added">5686             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;too large dimensions&quot;);</span>
<span class="line-added">5687             return false;</span>
<span class="line-added">5688         }</span>
<span class="line-added">5689         bytesRequired = checkedBytesRequired.unsafeGet();</span>
<span class="line-added">5690         break;</span>
<span class="line-added">5691     }</span>
5692     default:
<a name="700" id="anc700"></a><span class="line-modified">5693         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid format&quot;);</span>
5694         return false;
5695     }
5696 
5697     if (pixels.byteLength() != bytesRequired) {
<a name="701" id="anc701"></a><span class="line-modified">5698         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;length of ArrayBufferView is not correct for dimensions&quot;);</span>
5699         return false;
5700     }
5701 
5702     return true;
5703 }
5704 
<a name="702" id="anc702"></a><span class="line-modified">5705 bool WebGLRenderingContextBase::validateCompressedTexDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLsizei width, GCGLsizei height, GCGLenum format)</span>
5706 {
5707     switch (format) {
<a name="703" id="anc703"></a><span class="line-modified">5708     case ExtensionsGL::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="line-modified">5709     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="line-modified">5710     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="line-modified">5711     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT5_EXT: {</span>
<span class="line-modified">5712         const GCGLsizei kBlockWidth = 4;</span>
<span class="line-modified">5713         const GCGLsizei kBlockHeight = 4;</span>
<span class="line-modified">5714         const GCGLint maxTextureSize = target ? m_maxTextureSize : m_maxCubeMapTextureSize;</span>
<span class="line-modified">5715         const GCGLsizei maxCompressedDimension = maxTextureSize &gt;&gt; level;</span>
5716         bool widthValid = (level &amp;&amp; width == 1) || (level &amp;&amp; width == 2) || (!(width % kBlockWidth) &amp;&amp; width &lt;= maxCompressedDimension);
5717         bool heightValid = (level &amp;&amp; height == 1) || (level &amp;&amp; height == 2) || (!(height % kBlockHeight) &amp;&amp; height &lt;= maxCompressedDimension);
5718         if (!widthValid || !heightValid) {
<a name="704" id="anc704"></a><span class="line-modified">5719             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);</span>
5720             return false;
5721         }
5722         return true;
5723     }
<a name="705" id="anc705"></a><span class="line-modified">5724     case ExtensionsGL::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5725     case ExtensionsGL::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="line-modified">5726     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5727     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:</span>
5728         // Height and width must be powers of 2.
5729         if ((width &amp; (width - 1)) || (height &amp; (height - 1))) {
<a name="706" id="anc706"></a><span class="line-modified">5730             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);</span>
5731             return false;
5732         }
5733         return true;
<a name="707" id="anc707"></a><span class="line-modified">5734     case ExtensionsGL::COMPRESSED_RGBA_ASTC_4x4_KHR:</span>
<span class="line-modified">5735     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x4_KHR:</span>
<span class="line-modified">5736     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x5_KHR:</span>
<span class="line-modified">5737     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x5_KHR:</span>
<span class="line-modified">5738     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x6_KHR:</span>
<span class="line-modified">5739     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x5_KHR:</span>
<span class="line-modified">5740     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x6_KHR:</span>
<span class="line-modified">5741     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x8_KHR:</span>
<span class="line-modified">5742     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x5_KHR:</span>
<span class="line-modified">5743     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x6_KHR:</span>
<span class="line-modified">5744     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x8_KHR:</span>
<span class="line-modified">5745     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x10_KHR:</span>
<span class="line-modified">5746     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x10_KHR:</span>
<span class="line-modified">5747     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x12_KHR:</span>
<span class="line-modified">5748     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:</span>
<span class="line-modified">5749     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:</span>
<span class="line-modified">5750     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:</span>
<span class="line-modified">5751     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:</span>
<span class="line-modified">5752     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:</span>
<span class="line-modified">5753     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:</span>
<span class="line-modified">5754     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:</span>
<span class="line-modified">5755     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:</span>
<span class="line-modified">5756     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:</span>
<span class="line-modified">5757     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:</span>
<span class="line-modified">5758     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:</span>
<span class="line-modified">5759     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:</span>
<span class="line-modified">5760     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:</span>
<span class="line-modified">5761     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:</span>
<span class="line-modified">5762     case ExtensionsGL::ETC1_RGB8_OES:</span>
<span class="line-added">5763     case ExtensionsGL::COMPRESSED_R11_EAC:</span>
<span class="line-added">5764     case ExtensionsGL::COMPRESSED_SIGNED_R11_EAC:</span>
<span class="line-added">5765     case ExtensionsGL::COMPRESSED_RG11_EAC:</span>
<span class="line-added">5766     case ExtensionsGL::COMPRESSED_SIGNED_RG11_EAC:</span>
<span class="line-added">5767     case ExtensionsGL::COMPRESSED_RGB8_ETC2:</span>
<span class="line-added">5768     case ExtensionsGL::COMPRESSED_SRGB8_ETC2:</span>
<span class="line-added">5769     case ExtensionsGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-added">5770     case ExtensionsGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-added">5771     case ExtensionsGL::COMPRESSED_RGBA8_ETC2_EAC:</span>
<span class="line-added">5772     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:</span>
<span class="line-added">5773         // No height and width restrictions on ASTC, ETC1 or ETC2.</span>
5774         return true;
5775     default:
5776         return false;
5777     }
5778 }
5779 
<a name="708" id="anc708"></a><span class="line-modified">5780 bool WebGLRenderingContextBase::validateCompressedTexSubDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, WebGLTexture* tex)</span>

5781 {
5782     if (xoffset &lt; 0 || yoffset &lt; 0) {
<a name="709" id="anc709"></a><span class="line-modified">5783         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;xoffset or yoffset &lt; 0&quot;);</span>
<span class="line-modified">5784         return false;</span>
5785     }
5786 
5787     switch (format) {
<a name="710" id="anc710"></a><span class="line-modified">5788     case ExtensionsGL::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="line-modified">5789     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="line-modified">5790     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="line-modified">5791     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT5_EXT: {</span>
5792         const int kBlockWidth = 4;
5793         const int kBlockHeight = 4;
5794         if ((xoffset % kBlockWidth) || (yoffset % kBlockHeight)) {
<a name="711" id="anc711"></a><span class="line-modified">5795             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;xoffset or yoffset not multiple of 4&quot;);</span>
5796             return false;
5797         }
5798         if (width - xoffset &gt; tex-&gt;getWidth(target, level)
5799             || height - yoffset &gt; tex-&gt;getHeight(target, level)) {
<a name="712" id="anc712"></a><span class="line-modified">5800             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;dimensions out of range&quot;);</span>
5801             return false;
5802         }
5803         return validateCompressedTexDimensions(functionName, target, level, width, height, format);
5804     }
<a name="713" id="anc713"></a><span class="line-modified">5805     case ExtensionsGL::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5806     case ExtensionsGL::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="line-modified">5807     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5808     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: {</span>
5809         if (xoffset || yoffset) {
<a name="714" id="anc714"></a><span class="line-modified">5810             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;xoffset and yoffset must be zero&quot;);</span>
5811             return false;
5812         }
5813         if (width != tex-&gt;getWidth(target, level)
5814             || height != tex-&gt;getHeight(target, level)) {
<a name="715" id="anc715"></a><span class="line-modified">5815             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;dimensions must match existing level&quot;);</span>
5816             return false;
5817         }
5818         return validateCompressedTexDimensions(functionName, target, level, width, height, format);
5819     }
<a name="716" id="anc716"></a><span class="line-added">5820     case ExtensionsGL::ETC1_RGB8_OES:</span>
<span class="line-added">5821         // Not supported for ETC1_RGB8_OES textures.</span>
<span class="line-added">5822         return false;</span>
<span class="line-added">5823     case ExtensionsGL::COMPRESSED_R11_EAC:</span>
<span class="line-added">5824     case ExtensionsGL::COMPRESSED_SIGNED_R11_EAC:</span>
<span class="line-added">5825     case ExtensionsGL::COMPRESSED_RG11_EAC:</span>
<span class="line-added">5826     case ExtensionsGL::COMPRESSED_SIGNED_RG11_EAC:</span>
<span class="line-added">5827     case ExtensionsGL::COMPRESSED_RGB8_ETC2:</span>
<span class="line-added">5828     case ExtensionsGL::COMPRESSED_SRGB8_ETC2:</span>
<span class="line-added">5829     case ExtensionsGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-added">5830     case ExtensionsGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-added">5831     case ExtensionsGL::COMPRESSED_RGBA8_ETC2_EAC:</span>
<span class="line-added">5832     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: {</span>
<span class="line-added">5833         if (target == GraphicsContextGL::TEXTURE_3D) {</span>
<span class="line-added">5834             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;not supported on TEXTURE_3D textures&quot;);</span>
<span class="line-added">5835             return false;</span>
<span class="line-added">5836         }</span>
<span class="line-added">5837         const int kBlockSize = 4;</span>
<span class="line-added">5838         int texWidth = tex-&gt;getWidth(target, level);</span>
<span class="line-added">5839         int texHeight = tex-&gt;getHeight(target, level);</span>
<span class="line-added">5840         if ((xoffset % kBlockSize) || (yoffset % kBlockSize)</span>
<span class="line-added">5841             || ((width % kBlockSize) &amp;&amp; xoffset + width != texWidth)</span>
<span class="line-added">5842             || ((height % kBlockSize) &amp;&amp; yoffset + height != texHeight)) {</span>
<span class="line-added">5843             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;dimensions must match existing texture level dimensions&quot;);</span>
<span class="line-added">5844             return false;</span>
<span class="line-added">5845         }</span>
<span class="line-added">5846         return true;</span>
<span class="line-added">5847     }</span>
5848     default:
5849         return false;
5850     }
5851 }
5852 
<a name="717" id="anc717"></a><span class="line-modified">5853 bool WebGLRenderingContextBase::validateDrawMode(const char* functionName, GCGLenum mode)</span>
5854 {
5855     switch (mode) {
<a name="718" id="anc718"></a><span class="line-modified">5856     case GraphicsContextGL::POINTS:</span>
<span class="line-modified">5857     case GraphicsContextGL::LINE_STRIP:</span>
<span class="line-modified">5858     case GraphicsContextGL::LINE_LOOP:</span>
<span class="line-modified">5859     case GraphicsContextGL::LINES:</span>
<span class="line-modified">5860     case GraphicsContextGL::TRIANGLE_STRIP:</span>
<span class="line-modified">5861     case GraphicsContextGL::TRIANGLE_FAN:</span>
<span class="line-modified">5862     case GraphicsContextGL::TRIANGLES:</span>
5863         return true;
5864     default:
<a name="719" id="anc719"></a><span class="line-modified">5865         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid draw mode&quot;);</span>
5866         return false;
5867     }
5868 }
5869 
5870 bool WebGLRenderingContextBase::validateStencilSettings(const char* functionName)
5871 {
5872     if (m_stencilMask != m_stencilMaskBack || m_stencilFuncRef != m_stencilFuncRefBack || m_stencilFuncMask != m_stencilFuncMaskBack) {
<a name="720" id="anc720"></a><span class="line-modified">5873         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;front and back stencils settings do not match&quot;);</span>
5874         return false;
5875     }
5876     return true;
5877 }
5878 
<a name="721" id="anc721"></a><span class="line-modified">5879 bool WebGLRenderingContextBase::validateStencilFunc(const char* functionName, GCGLenum func)</span>
5880 {
5881     switch (func) {
<a name="722" id="anc722"></a><span class="line-modified">5882     case GraphicsContextGL::NEVER:</span>
<span class="line-modified">5883     case GraphicsContextGL::LESS:</span>
<span class="line-modified">5884     case GraphicsContextGL::LEQUAL:</span>
<span class="line-modified">5885     case GraphicsContextGL::GREATER:</span>
<span class="line-modified">5886     case GraphicsContextGL::GEQUAL:</span>
<span class="line-modified">5887     case GraphicsContextGL::EQUAL:</span>
<span class="line-modified">5888     case GraphicsContextGL::NOTEQUAL:</span>
<span class="line-modified">5889     case GraphicsContextGL::ALWAYS:</span>
5890         return true;
5891     default:
<a name="723" id="anc723"></a><span class="line-modified">5892         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid function&quot;);</span>
5893         return false;
5894     }
5895 }
5896 
5897 void WebGLRenderingContextBase::printToConsole(MessageLevel level, const String&amp; message)
5898 {
5899     if (!m_synthesizedErrorsToConsole || !m_numGLErrorsToConsoleAllowed)
5900         return;
5901 
5902     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; consoleMessage;
5903 
5904     // Error messages can occur during function calls, so show stack traces for them.
5905     if (level == MessageLevel::Error) {
5906         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
5907         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message, WTFMove(stackTrace));
5908     } else
5909         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message);
5910 
5911     auto* canvas = htmlCanvas();
5912     if (canvas)
5913         canvas-&gt;document().addConsoleMessage(WTFMove(consoleMessage));
5914 
5915     --m_numGLErrorsToConsoleAllowed;
5916     if (!m_numGLErrorsToConsoleAllowed)
5917         printToConsole(MessageLevel::Warning, &quot;WebGL: too many errors, no more errors will be reported to the console for this context.&quot;);
5918 }
5919 
<a name="724" id="anc724"></a><span class="line-modified">5920 bool WebGLRenderingContextBase::validateBlendFuncFactors(const char* functionName, GCGLenum src, GCGLenum dst)</span>
5921 {
<a name="725" id="anc725"></a><span class="line-modified">5922     if (((src == GraphicsContextGL::CONSTANT_COLOR || src == GraphicsContextGL::ONE_MINUS_CONSTANT_COLOR)</span>
<span class="line-modified">5923         &amp;&amp; (dst == GraphicsContextGL::CONSTANT_ALPHA || dst == GraphicsContextGL::ONE_MINUS_CONSTANT_ALPHA))</span>
<span class="line-modified">5924         || ((dst == GraphicsContextGL::CONSTANT_COLOR || dst == GraphicsContextGL::ONE_MINUS_CONSTANT_COLOR)</span>
<span class="line-modified">5925             &amp;&amp; (src == GraphicsContextGL::CONSTANT_ALPHA || src == GraphicsContextGL::ONE_MINUS_CONSTANT_ALPHA))) {</span>
<span class="line-modified">5926         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;incompatible src and dst&quot;);</span>
5927         return false;
5928     }
5929     return true;
5930 }
5931 
<a name="726" id="anc726"></a><span class="line-modified">5932 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Float32List&amp; v, GCGLsizei requiredMinSize)</span>
5933 {
5934     return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
5935 }
5936 
<a name="727" id="anc727"></a><span class="line-modified">5937 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Int32List&amp; v, GCGLsizei requiredMinSize)</span>
5938 {
5939     return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
5940 }
5941 
<a name="728" id="anc728"></a><span class="line-modified">5942 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, void* v, GCGLsizei size, GCGLsizei requiredMinSize)</span>
5943 {
5944     return validateUniformMatrixParameters(functionName, location, false, v, size, requiredMinSize);
5945 }
5946 
<a name="729" id="anc729"></a><span class="line-modified">5947 bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GCGLboolean transpose, const Float32List&amp; v, GCGLsizei requiredMinSize)</span>
5948 {
5949     return validateUniformMatrixParameters(functionName, location, transpose, v.data(), v.length(), requiredMinSize);
5950 }
5951 
<a name="730" id="anc730"></a><span class="line-modified">5952 bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GCGLboolean transpose, const void* v, GCGLsizei size, GCGLsizei requiredMinSize)</span>
5953 {
5954     if (!location)
5955         return false;
5956     if (location-&gt;program() != m_currentProgram) {
<a name="731" id="anc731"></a><span class="line-modified">5957         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;location is not from current program&quot;);</span>
5958         return false;
5959     }
5960     if (!v) {
<a name="732" id="anc732"></a><span class="line-modified">5961         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no array&quot;);</span>
5962         return false;
5963     }
5964     if (transpose) {
<a name="733" id="anc733"></a><span class="line-modified">5965         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;transpose not FALSE&quot;);</span>
5966         return false;
5967     }
5968     if (size &lt; requiredMinSize || (size % requiredMinSize)) {
<a name="734" id="anc734"></a><span class="line-modified">5969         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;invalid size&quot;);</span>
5970         return false;
5971     }
5972     return true;
5973 }
5974 
<a name="735" id="anc735"></a><span class="line-modified">5975 WebGLBuffer* WebGLRenderingContextBase::validateBufferDataParameters(const char* functionName, GCGLenum target, GCGLenum usage)</span>
5976 {
5977     Optional&lt;WebGLBuffer*&gt; buffer;
5978     switch (target) {
<a name="736" id="anc736"></a><span class="line-modified">5979     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:</span>
5980         buffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
5981         break;
<a name="737" id="anc737"></a><span class="line-modified">5982     case GraphicsContextGL::ARRAY_BUFFER:</span>
5983         buffer = m_boundArrayBuffer.get();
5984         break;
5985     default:
5986 #if ENABLE(WEBGL2)
5987         if (isWebGL2()) {
5988             switch (target) {
<a name="738" id="anc738"></a><span class="line-modified">5989             case GraphicsContextGL::COPY_READ_BUFFER:</span>
5990                 buffer = m_boundCopyReadBuffer.get();
5991                 break;
<a name="739" id="anc739"></a><span class="line-modified">5992             case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
5993                 buffer = m_boundCopyWriteBuffer.get();
5994                 break;
<a name="740" id="anc740"></a><span class="line-modified">5995             case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
5996                 buffer = m_boundPixelPackBuffer.get();
5997                 break;
<a name="741" id="anc741"></a><span class="line-modified">5998             case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
5999                 buffer = m_boundPixelUnpackBuffer.get();
6000                 break;
<a name="742" id="anc742"></a><span class="line-modified">6001             case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
6002                 buffer = m_boundTransformFeedbackBuffer.get();
6003                 break;
<a name="743" id="anc743"></a><span class="line-modified">6004             case GraphicsContextGL::UNIFORM_BUFFER:</span>
6005                 buffer = m_boundUniformBuffer.get();
6006                 break;
6007             }
6008             if (buffer)
6009                 break;
6010         }
6011 #endif
<a name="744" id="anc744"></a><span class="line-modified">6012         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
6013         return nullptr;
6014     }
6015     if (!buffer || !buffer.value()) {
<a name="745" id="anc745"></a><span class="line-modified">6016         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;no buffer&quot;);</span>
6017         return nullptr;
6018     }
6019     switch (usage) {
<a name="746" id="anc746"></a><span class="line-modified">6020     case GraphicsContextGL::STREAM_DRAW:</span>
<span class="line-modified">6021     case GraphicsContextGL::STATIC_DRAW:</span>
<span class="line-modified">6022     case GraphicsContextGL::DYNAMIC_DRAW:</span>
6023         return buffer.value();
6024     }
<a name="747" id="anc747"></a><span class="line-modified">6025     synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid usage&quot;);</span>
6026     return nullptr;
6027 }
6028 
6029 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLImageElement(const char* functionName, HTMLImageElement* image)
6030 {
6031     if (!image || !image-&gt;cachedImage()) {
<a name="748" id="anc748"></a><span class="line-modified">6032         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no image&quot;);</span>
6033         return false;
6034     }
6035     const URL&amp; url = image-&gt;cachedImage()-&gt;response().url();
6036     if (url.isNull() || url.isEmpty() || !url.isValid()) {
<a name="749" id="anc749"></a><span class="line-modified">6037         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;invalid image&quot;);</span>
6038         return false;
6039     }
6040     if (wouldTaintOrigin(image))
6041         return Exception { SecurityError };
6042     return true;
6043 }
6044 
6045 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement* canvas)
6046 {
6047     if (!canvas || !canvas-&gt;buffer()) {
<a name="750" id="anc750"></a><span class="line-modified">6048         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no canvas&quot;);</span>
6049         return false;
6050     }
6051     if (wouldTaintOrigin(canvas))
6052         return Exception { SecurityError };
6053     return true;
6054 }
6055 
6056 #if ENABLE(VIDEO)
6057 
6058 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLVideoElement(const char* functionName, HTMLVideoElement* video)
6059 {
6060     if (!video || !video-&gt;videoWidth() || !video-&gt;videoHeight()) {
<a name="751" id="anc751"></a><span class="line-modified">6061         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no video&quot;);</span>
6062         return false;
6063     }
6064     if (wouldTaintOrigin(video))
6065         return Exception { SecurityError };
6066     return true;
6067 }
6068 
6069 #endif
6070 
<a name="752" id="anc752"></a><span class="line-modified">6071 void WebGLRenderingContextBase::vertexAttribfImpl(const char* functionName, GCGLuint index, GCGLsizei expectedSize, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2, GCGLfloat v3)</span>
6072 {
6073     if (isContextLostOrPending())
6074         return;
6075     if (index &gt;= m_maxVertexAttribs) {
<a name="753" id="anc753"></a><span class="line-modified">6076         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;index out of range&quot;);</span>
6077         return;
6078     }
6079     // In GL, we skip setting vertexAttrib0 values.
6080     if (index || isGLES2Compliant()) {
6081         switch (expectedSize) {
6082         case 1:
6083             m_context-&gt;vertexAttrib1f(index, v0);
6084             break;
6085         case 2:
6086             m_context-&gt;vertexAttrib2f(index, v0, v1);
6087             break;
6088         case 3:
6089             m_context-&gt;vertexAttrib3f(index, v0, v1, v2);
6090             break;
6091         case 4:
6092             m_context-&gt;vertexAttrib4f(index, v0, v1, v2, v3);
6093             break;
6094         }
6095     }
6096     VertexAttribValue&amp; attribValue = m_vertexAttribValue[index];
6097     attribValue.value[0] = v0;
6098     attribValue.value[1] = v1;
6099     attribValue.value[2] = v2;
6100     attribValue.value[3] = v3;
6101 }
6102 
<a name="754" id="anc754"></a><span class="line-modified">6103 void WebGLRenderingContextBase::vertexAttribfvImpl(const char* functionName, GCGLuint index, Float32List&amp;&amp; list, GCGLsizei expectedSize)</span>
6104 {
6105     if (isContextLostOrPending())
6106         return;
6107 
6108     auto data = list.data();
6109     if (!data) {
<a name="755" id="anc755"></a><span class="line-modified">6110         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no array&quot;);</span>
6111         return;
6112     }
6113 
6114     int size = list.length();
6115     if (size &lt; expectedSize) {
<a name="756" id="anc756"></a><span class="line-modified">6116         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;invalid size&quot;);</span>
6117         return;
6118     }
6119     if (index &gt;= m_maxVertexAttribs) {
<a name="757" id="anc757"></a><span class="line-modified">6120         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;index out of range&quot;);</span>
6121         return;
6122     }
6123     // In GL, we skip setting vertexAttrib0 values.
6124     if (index || isGLES2Compliant()) {
6125         switch (expectedSize) {
6126         case 1:
6127             m_context-&gt;vertexAttrib1fv(index, data);
6128             break;
6129         case 2:
6130             m_context-&gt;vertexAttrib2fv(index, data);
6131             break;
6132         case 3:
6133             m_context-&gt;vertexAttrib3fv(index, data);
6134             break;
6135         case 4:
6136             m_context-&gt;vertexAttrib4fv(index, data);
6137             break;
6138         }
6139     }
6140     VertexAttribValue&amp; attribValue = m_vertexAttribValue[index];
6141     attribValue.initValue();
6142     for (int ii = 0; ii &lt; expectedSize; ++ii)
6143         attribValue.value[ii] = data[ii];
6144 }
6145 
6146 void WebGLRenderingContextBase::initVertexAttrib0()
6147 {
6148     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6149 
6150     m_vertexAttrib0Buffer = createBuffer();
<a name="758" id="anc758"></a><span class="line-modified">6151     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());</span>
<span class="line-modified">6152     m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, 0, GraphicsContextGL::DYNAMIC_DRAW);</span>
<span class="line-modified">6153     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContextGL::FLOAT, false, 0, 0);</span>
6154     state.bufferBinding = m_vertexAttrib0Buffer;
<a name="759" id="anc759"></a><span class="line-modified">6155     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, 0);</span>
6156     m_context-&gt;enableVertexAttribArray(0);
6157     m_vertexAttrib0BufferSize = 0;
6158     m_vertexAttrib0BufferValue[0] = 0.0f;
6159     m_vertexAttrib0BufferValue[1] = 0.0f;
6160     m_vertexAttrib0BufferValue[2] = 0.0f;
6161     m_vertexAttrib0BufferValue[3] = 1.0f;
6162     m_forceAttrib0BufferRefill = false;
6163     m_vertexAttrib0UsedBefore = false;
6164 }
6165 
<a name="760" id="anc760"></a><span class="line-modified">6166 bool WebGLRenderingContextBase::validateSimulatedVertexAttrib0(GCGLuint numVertex)</span>
6167 {
6168     if (!m_currentProgram)
6169         return true;
6170 
6171     bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
6172     if (!usingVertexAttrib0)
6173         return true;
6174 
6175     auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6176     if (state.enabled)
6177         return true;
6178 
<a name="761" id="anc761"></a><span class="line-modified">6179     auto bufferSize = checkedAddAndMultiply&lt;GCGLuint&gt;(numVertex, 1, 4);</span>
6180     if (!bufferSize)
6181         return false;
6182 
<a name="762" id="anc762"></a><span class="line-modified">6183     Checked&lt;GCGLsizeiptr, RecordOverflow&gt; bufferDataSize(bufferSize.value());</span>
<span class="line-modified">6184     bufferDataSize *= Checked&lt;GCGLsizeiptr&gt;(sizeof(GCGLfloat));</span>
6185     return !bufferDataSize.hasOverflowed() &amp;&amp; bufferDataSize.unsafeGet() &gt; 0;
6186 }
6187 
<a name="763" id="anc763"></a><span class="line-modified">6188 Optional&lt;bool&gt; WebGLRenderingContextBase::simulateVertexAttrib0(GCGLuint numVertex)</span>
6189 {
6190     if (!m_currentProgram)
6191         return false;
6192     bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
6193     if (usingVertexAttrib0)
6194         m_vertexAttrib0UsedBefore = true;
6195 
6196     auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6197     if (state.enabled &amp;&amp; usingVertexAttrib0)
6198         return false;
6199     if (!usingVertexAttrib0 &amp;&amp; !m_vertexAttrib0UsedBefore)
6200         return false;
6201     m_vertexAttrib0UsedBefore = true;
<a name="764" id="anc764"></a><span class="line-modified">6202     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());</span>
6203 
6204     // We know bufferSize and bufferDataSize won&#39;t overflow or go negative, thanks to validateSimulatedVertexAttrib0
<a name="765" id="anc765"></a><span class="line-modified">6205     GCGLuint bufferSize = (numVertex + 1) * 4;</span>
<span class="line-modified">6206     GCGLsizeiptr bufferDataSize = bufferSize * sizeof(GCGLfloat);</span>
6207 
6208     if (bufferDataSize &gt; m_vertexAttrib0BufferSize) {
6209         m_context-&gt;moveErrorsToSyntheticErrorList();
<a name="766" id="anc766"></a><span class="line-modified">6210         m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, bufferDataSize, 0, GraphicsContextGL::DYNAMIC_DRAW);</span>
<span class="line-modified">6211         if (m_context-&gt;getError() != GraphicsContextGL::NO_ERROR) {</span>
6212             // We were unable to create a buffer.
6213             m_vertexAttrib0UsedBefore = false;
6214             m_vertexAttrib0BufferSize = 0;
6215             m_forceAttrib0BufferRefill = true;
6216             return WTF::nullopt;
6217         }
6218         m_vertexAttrib0BufferSize = bufferDataSize;
6219         m_forceAttrib0BufferRefill = true;
6220     }
6221 
6222     auto&amp; attribValue = m_vertexAttribValue[0];
6223 
6224     if (usingVertexAttrib0
6225         &amp;&amp; (m_forceAttrib0BufferRefill
6226             || attribValue.value[0] != m_vertexAttrib0BufferValue[0]
6227             || attribValue.value[1] != m_vertexAttrib0BufferValue[1]
6228             || attribValue.value[2] != m_vertexAttrib0BufferValue[2]
6229             || attribValue.value[3] != m_vertexAttrib0BufferValue[3])) {
6230 
<a name="767" id="anc767"></a><span class="line-modified">6231         auto bufferData = makeUniqueArray&lt;GCGLfloat&gt;(bufferSize);</span>
<span class="line-modified">6232         for (GCGLuint ii = 0; ii &lt; numVertex + 1; ++ii) {</span>
6233             bufferData[ii * 4] = attribValue.value[0];
6234             bufferData[ii * 4 + 1] = attribValue.value[1];
6235             bufferData[ii * 4 + 2] = attribValue.value[2];
6236             bufferData[ii * 4 + 3] = attribValue.value[3];
6237         }
6238         m_vertexAttrib0BufferValue[0] = attribValue.value[0];
6239         m_vertexAttrib0BufferValue[1] = attribValue.value[1];
6240         m_vertexAttrib0BufferValue[2] = attribValue.value[2];
6241         m_vertexAttrib0BufferValue[3] = attribValue.value[3];
6242         m_forceAttrib0BufferRefill = false;
<a name="768" id="anc768"></a><span class="line-modified">6243         m_context-&gt;bufferSubData(GraphicsContextGL::ARRAY_BUFFER, 0, bufferDataSize, bufferData.get());</span>
6244     }
<a name="769" id="anc769"></a><span class="line-modified">6245     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContextGL::FLOAT, 0, 0, 0);</span>
6246     return true;
6247 }
6248 
6249 void WebGLRenderingContextBase::restoreStatesAfterVertexAttrib0Simulation()
6250 {
6251     const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6252     if (state.bufferBinding != m_vertexAttrib0Buffer) {
<a name="770" id="anc770"></a><span class="line-modified">6253         m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, objectOrZero(state.bufferBinding.get()));</span>
6254         m_context-&gt;vertexAttribPointer(0, state.size, state.type, state.normalized, state.originalStride, state.offset);
6255     }
<a name="771" id="anc771"></a><span class="line-modified">6256     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, objectOrZero(m_boundArrayBuffer.get()));</span>
6257 }
6258 
6259 void WebGLRenderingContextBase::dispatchContextLostEvent()
6260 {
<a name="772" id="anc772"></a><span class="line-added">6261     RELEASE_ASSERT(!m_isSuspended);</span>
6262     auto* canvas = htmlCanvas();
6263     if (!canvas)
6264         return;
6265 
6266     Ref&lt;WebGLContextEvent&gt; event = WebGLContextEvent::create(eventNames().webglcontextlostEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString());
6267     canvas-&gt;dispatchEvent(event);
6268     m_restoreAllowed = event-&gt;defaultPrevented();
6269     if (m_contextLostMode == RealLostContext &amp;&amp; m_restoreAllowed)
6270         m_restoreTimer.startOneShot(0_s);
6271 }
6272 
6273 void WebGLRenderingContextBase::maybeRestoreContext()
6274 {
<a name="773" id="anc773"></a><span class="line-added">6275     RELEASE_ASSERT(!m_isSuspended);</span>
6276     ASSERT(m_contextLost);
6277     if (!m_contextLost)
6278         return;
6279 
6280     // The rendering context is not restored unless the default behavior of the
6281     // webglcontextlost event was prevented earlier.
6282     //
6283     // Because of the way m_restoreTimer is set up for real vs. synthetic lost
6284     // context events, we don&#39;t have to worry about this test short-circuiting
6285     // the retry loop for real context lost events.
6286     if (!m_restoreAllowed)
6287         return;
6288 
6289     int contextLostReason = m_context-&gt;getExtensions().getGraphicsResetStatusARB();
6290 
6291     switch (contextLostReason) {
<a name="774" id="anc774"></a><span class="line-modified">6292     case GraphicsContextGL::NO_ERROR:</span>
<span class="line-modified">6293         // The GraphicsContextGLOpenGL implementation might not fully</span>
6294         // support GL_ARB_robustness semantics yet. Alternatively, the
6295         // WEBGL_lose_context extension might have been used to force
6296         // a lost context.
6297         break;
<a name="775" id="anc775"></a><span class="line-modified">6298     case ExtensionsGL::GUILTY_CONTEXT_RESET_ARB:</span>
6299         // The rendering context is not restored if this context was
6300         // guilty of causing the graphics reset.
6301         printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page caused the graphics card to reset; not restoring the context&quot;);
6302         return;
<a name="776" id="anc776"></a><span class="line-modified">6303     case ExtensionsGL::INNOCENT_CONTEXT_RESET_ARB:</span>
6304         // Always allow the context to be restored.
6305         break;
<a name="777" id="anc777"></a><span class="line-modified">6306     case ExtensionsGL::UNKNOWN_CONTEXT_RESET_ARB:</span>
6307         // Warn. Ideally, prompt the user telling them that WebGL
6308         // content on the page might have caused the graphics card to
6309         // reset and ask them whether they want to continue running
6310         // the content. Only if they say &quot;yes&quot; should we start
6311         // attempting to restore the context.
6312         printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page might have caused the graphics card to reset&quot;);
6313         break;
6314     }
6315 
6316     auto* canvas = htmlCanvas();
6317     if (!canvas)
6318         return;
6319 
6320     RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame();
6321     if (!frame)
6322         return;
6323 
6324     if (!frame-&gt;loader().client().allowWebGL(frame-&gt;settings().webGLEnabled()))
6325         return;
6326 
6327     RefPtr&lt;FrameView&gt; view = frame-&gt;view();
6328     if (!view)
6329         return;
6330     RefPtr&lt;ScrollView&gt; root = view-&gt;root();
6331     if (!root)
6332         return;
6333     HostWindow* hostWindow = root-&gt;hostWindow();
6334     if (!hostWindow)
6335         return;
6336 
<a name="778" id="anc778"></a><span class="line-modified">6337     RefPtr&lt;GraphicsContextGLOpenGL&gt; context(GraphicsContextGLOpenGL::create(m_attributes, hostWindow));</span>
6338     if (!context) {
6339         if (m_contextLostMode == RealLostContext)
6340             m_restoreTimer.startOneShot(secondsBetweenRestoreAttempts);
6341         else
6342             // This likely shouldn&#39;t happen but is the best way to report it to the WebGL app.
<a name="779" id="anc779"></a><span class="line-modified">6343             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;&quot;, &quot;error restoring context&quot;);</span>
6344         return;
6345     }
6346 
6347     m_context = context;
6348     addActivityStateChangeObserverIfNecessary();
6349     m_contextLost = false;
6350     setupFlags();
6351     initializeNewContext();
6352     initializeVertexArrayObjects();
6353     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextrestoredEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
6354 }
6355 
6356 void WebGLRenderingContextBase::simulateContextChanged()
6357 {
6358     if (m_context)
6359         m_context-&gt;simulateContextChanged();
6360 }
6361 
6362 String WebGLRenderingContextBase::ensureNotNull(const String&amp; text) const
6363 {
6364     if (text.isNull())
6365         return WTF::emptyString();
6366     return text;
6367 }
6368 
6369 WebGLRenderingContextBase::LRUImageBufferCache::LRUImageBufferCache(int capacity)
6370     : m_buffers(capacity)
6371 {
6372 }
6373 
6374 ImageBuffer* WebGLRenderingContextBase::LRUImageBufferCache::imageBuffer(const IntSize&amp; size)
6375 {
6376     size_t i;
6377     for (i = 0; i &lt; m_buffers.size(); ++i) {
6378         ImageBuffer* buf = m_buffers[i].get();
6379         if (!buf)
6380             break;
6381         if (buf-&gt;logicalSize() != size)
6382             continue;
6383         bubbleToFront(i);
6384         buf-&gt;context().clearRect(FloatRect({ }, FloatSize(size)));
6385         return buf;
6386     }
6387 
6388     // FIXME (149423): Should this ImageBuffer be unconditionally unaccelerated?
<a name="780" id="anc780"></a><span class="line-modified">6389     std::unique_ptr&lt;ImageBuffer&gt; temp = ImageBuffer::create(size, RenderingMode::Unaccelerated);</span>
6390     if (!temp)
6391         return nullptr;
6392     ASSERT(m_buffers.size() &gt; 0);
6393     i = std::min(m_buffers.size() - 1, i);
6394     m_buffers[i] = WTFMove(temp);
6395 
6396     ImageBuffer* buf = m_buffers[i].get();
6397     bubbleToFront(i);
6398     return buf;
6399 }
6400 
6401 void WebGLRenderingContextBase::LRUImageBufferCache::bubbleToFront(size_t idx)
6402 {
6403     for (size_t i = idx; i &gt; 0; --i)
6404         m_buffers[i].swap(m_buffers[i-1]);
6405 }
6406 
6407 namespace {
6408 
<a name="781" id="anc781"></a><span class="line-modified">6409     String GetErrorString(GCGLenum error)</span>
6410     {
6411         switch (error) {
<a name="782" id="anc782"></a><span class="line-modified">6412         case GraphicsContextGL::INVALID_ENUM:</span>
6413             return &quot;INVALID_ENUM&quot;_s;
<a name="783" id="anc783"></a><span class="line-modified">6414         case GraphicsContextGL::INVALID_VALUE:</span>
6415             return &quot;INVALID_VALUE&quot;_s;
<a name="784" id="anc784"></a><span class="line-modified">6416         case GraphicsContextGL::INVALID_OPERATION:</span>
6417             return &quot;INVALID_OPERATION&quot;_s;
<a name="785" id="anc785"></a><span class="line-modified">6418         case GraphicsContextGL::OUT_OF_MEMORY:</span>
6419             return &quot;OUT_OF_MEMORY&quot;_s;
<a name="786" id="anc786"></a><span class="line-modified">6420         case GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION:</span>
6421             return &quot;INVALID_FRAMEBUFFER_OPERATION&quot;_s;
<a name="787" id="anc787"></a><span class="line-modified">6422         case GraphicsContextGL::CONTEXT_LOST_WEBGL:</span>
6423             return &quot;CONTEXT_LOST_WEBGL&quot;_s;
6424         default:
6425             return makeString(&quot;WebGL ERROR(&quot;, hex(error, 4, Lowercase), &#39;)&#39;);
6426         }
6427     }
6428 
6429 } // namespace anonymous
6430 
<a name="788" id="anc788"></a><span class="line-modified">6431 void WebGLRenderingContextBase::synthesizeGLError(GCGLenum error, const char* functionName, const char* description, ConsoleDisplayPreference display)</span>
6432 {
6433     if (m_synthesizedErrorsToConsole &amp;&amp; display == DisplayInConsole) {
6434         String str = &quot;WebGL: &quot; + GetErrorString(error) +  &quot;: &quot; + String(functionName) + &quot;: &quot; + String(description);
6435         printToConsole(MessageLevel::Error, str);
6436     }
6437     m_context-&gt;synthesizeGLError(error);
6438 }
6439 
6440 void WebGLRenderingContextBase::applyStencilTest()
6441 {
6442     bool haveStencilBuffer = false;
6443 
6444     if (m_framebufferBinding)
6445         haveStencilBuffer = m_framebufferBinding-&gt;hasStencilBuffer();
6446     else {
6447         auto attributes = getContextAttributes();
6448         ASSERT(attributes);
6449         haveStencilBuffer = attributes-&gt;stencil;
6450     }
<a name="789" id="anc789"></a><span class="line-modified">6451     enableOrDisable(GraphicsContextGL::STENCIL_TEST, m_stencilEnabled &amp;&amp; haveStencilBuffer);</span>
6452 }
6453 
<a name="790" id="anc790"></a><span class="line-modified">6454 void WebGLRenderingContextBase::enableOrDisable(GCGLenum capability, bool enable)</span>
6455 {
6456     if (enable)
6457         m_context-&gt;enable(capability);
6458     else
6459         m_context-&gt;disable(capability);
6460 }
6461 
6462 IntSize WebGLRenderingContextBase::clampedCanvasSize()
6463 {
6464     return IntSize(clamp(canvasBase().width(), 1, m_maxViewportDims[0]),
6465         clamp(canvasBase().height(), 1, m_maxViewportDims[1]));
6466 }
6467 
<a name="791" id="anc791"></a><span class="line-modified">6468 GCGLint WebGLRenderingContextBase::getMaxDrawBuffers()</span>
6469 {
6470     if (!supportsDrawBuffers())
6471         return 0;
6472     if (!m_maxDrawBuffers)
<a name="792" id="anc792"></a><span class="line-modified">6473         m_context-&gt;getIntegerv(ExtensionsGL::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);</span>
6474     if (!m_maxColorAttachments)
<a name="793" id="anc793"></a><span class="line-modified">6475         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
6476     // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
6477     return std::min(m_maxDrawBuffers, m_maxColorAttachments);
6478 }
6479 
<a name="794" id="anc794"></a><span class="line-modified">6480 GCGLint WebGLRenderingContextBase::getMaxColorAttachments()</span>
6481 {
6482     if (!supportsDrawBuffers())
6483         return 0;
6484     if (!m_maxColorAttachments)
<a name="795" id="anc795"></a><span class="line-modified">6485         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
6486     return m_maxColorAttachments;
6487 }
6488 
<a name="796" id="anc796"></a><span class="line-modified">6489 void WebGLRenderingContextBase::setBackDrawBuffer(GCGLenum buf)</span>
6490 {
6491     m_backDrawBuffer = buf;
6492 }
6493 
6494 void WebGLRenderingContextBase::restoreCurrentFramebuffer()
6495 {
<a name="797" id="anc797"></a><span class="line-modified">6496     bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_framebufferBinding.get());</span>
6497 }
6498 
6499 void WebGLRenderingContextBase::restoreCurrentTexture2D()
6500 {
6501     auto texture = m_textureUnits[m_activeTextureUnit].texture2DBinding.get();
<a name="798" id="anc798"></a><span class="line-modified">6502     bindTexture(GraphicsContextGL::TEXTURE_2D, texture);</span>
6503     if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
6504         m_unrenderableTextureUnits.add(m_activeTextureUnit);
6505 }
6506 
6507 bool WebGLRenderingContextBase::supportsDrawBuffers()
6508 {
6509     if (!m_drawBuffersWebGLRequirementsChecked) {
6510         m_drawBuffersWebGLRequirementsChecked = true;
6511         m_drawBuffersSupported = WebGLDrawBuffers::supported(*this);
6512     }
6513     return m_drawBuffersSupported;
6514 }
6515 
<a name="799" id="anc799"></a><span class="line-modified">6516 void WebGLRenderingContextBase::drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount)</span>
6517 {
6518     if (!primcount) {
6519         markContextChanged();
6520         return;
6521     }
6522 
6523     if (!validateDrawArrays(&quot;drawArraysInstanced&quot;, mode, first, count, primcount))
6524         return;
6525 
6526     clearIfComposited();
6527 
6528     bool vertexAttrib0Simulated = false;
6529     if (!isGLES2Compliant()) {
6530         auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
6531         if (!simulateVertexAttrib0Status) {
6532             // We were unable to simulate the attribute buffer.
<a name="800" id="anc800"></a><span class="line-modified">6533             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
6534             return;
6535         }
6536         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
6537     }
6538     if (!isGLES2NPOTStrict())
6539         checkTextureCompleteness(&quot;drawArraysInstanced&quot;, true);
6540 
6541     m_context-&gt;drawArraysInstanced(mode, first, count, primcount);
6542 
6543     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
6544         restoreStatesAfterVertexAttrib0Simulation();
6545     if (!isGLES2NPOTStrict())
6546         checkTextureCompleteness(&quot;drawArraysInstanced&quot;, false);
6547     markContextChangedAndNotifyCanvasObserver();
6548 }
6549 
<a name="801" id="anc801"></a><span class="line-modified">6550 void WebGLRenderingContextBase::drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, GCGLsizei primcount)</span>
6551 {
6552     if (!primcount) {
6553         markContextChanged();
6554         return;
6555     }
6556 
6557     unsigned numElements = 0;
6558     if (!validateDrawElements(&quot;drawElementsInstanced&quot;, mode, count, type, offset, numElements, primcount))
6559         return;
6560 
6561     clearIfComposited();
6562 
6563     bool vertexAttrib0Simulated = false;
6564     if (!isGLES2Compliant()) {
6565         if (!numElements)
<a name="802" id="anc802"></a><span class="line-modified">6566             validateIndexArrayPrecise(count, type, static_cast&lt;GCGLintptr&gt;(offset), numElements);</span>
6567         auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
6568         if (!simulateVertexAttrib0Status) {
6569             // We were unable to simulate the attribute buffer.
<a name="803" id="anc803"></a><span class="line-modified">6570             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
6571             return;
6572         }
6573         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
6574     }
6575     if (!isGLES2NPOTStrict())
6576         checkTextureCompleteness(&quot;drawElementsInstanced&quot;, true);
6577 
6578 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
6579     if (isWebGL2())
6580         m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
6581 #endif
6582 
<a name="804" id="anc804"></a><span class="line-modified">6583     m_context-&gt;drawElementsInstanced(mode, count, type, static_cast&lt;GCGLintptr&gt;(offset), primcount);</span>
6584 
6585     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
6586         restoreStatesAfterVertexAttrib0Simulation();
6587     if (!isGLES2NPOTStrict())
6588         checkTextureCompleteness(&quot;drawElementsInstanced&quot;, false);
6589     markContextChangedAndNotifyCanvasObserver();
6590 }
6591 
<a name="805" id="anc805"></a><span class="line-modified">6592 void WebGLRenderingContextBase::vertexAttribDivisor(GCGLuint index, GCGLuint divisor)</span>
6593 {
6594     if (isContextLostOrPending())
6595         return;
6596 
6597     if (index &gt;= m_maxVertexAttribs) {
<a name="806" id="anc806"></a><span class="line-modified">6598         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribDivisor&quot;, &quot;index out of range&quot;);</span>
6599         return;
6600     }
6601 
6602     m_boundVertexArrayObject-&gt;setVertexAttribDivisor(index, divisor);
6603     m_context-&gt;vertexAttribDivisor(index, divisor);
6604 }
6605 
6606 bool WebGLRenderingContextBase::enableSupportedExtension(ASCIILiteral extensionNameLiteral)
6607 {
6608     ASSERT(m_context);
6609     auto&amp; extensions = m_context-&gt;getExtensions();
6610     String extensionName { extensionNameLiteral };
6611     if (!extensions.supports(extensionName))
6612         return false;
6613     extensions.ensureEnabled(extensionName);
6614     return true;
6615 }
6616 
6617 void WebGLRenderingContextBase::activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState)
6618 {
6619     if (!m_context)
6620         return;
6621 
6622     auto changed = oldActivityState ^ newActivityState;
6623     if (changed &amp; ActivityState::IsVisible)
6624         m_context-&gt;setContextVisibility(newActivityState.contains(ActivityState::IsVisible));
6625 }
6626 
6627 void WebGLRenderingContextBase::setFailNextGPUStatusCheck()
6628 {
6629     if (!m_context)
6630         return;
6631 
6632     m_context-&gt;setFailNextGPUStatusCheck();
6633 }
6634 
6635 void WebGLRenderingContextBase::didComposite()
6636 {
6637     if (UNLIKELY(callTracingActive()))
6638         InspectorInstrumentation::didFinishRecordingCanvasFrame(*this);
6639 }
6640 
6641 void WebGLRenderingContextBase::forceContextLost()
6642 {
6643     forceLostContext(WebGLRenderingContextBase::RealLostContext);
6644 }
6645 
6646 void WebGLRenderingContextBase::recycleContext()
6647 {
6648     printToConsole(MessageLevel::Error, &quot;There are too many active WebGL contexts on this page, the oldest context will be lost.&quot;);
6649     // Using SyntheticLostContext means the developer won&#39;t be able to force the restoration
6650     // of the context by calling preventDefault() in a &quot;webglcontextlost&quot; event handler.
6651     forceLostContext(SyntheticLostContext);
<a name="807" id="anc807"></a><span class="line-modified">6652     destroyGraphicsContextGL();</span>
6653 }
6654 
6655 void WebGLRenderingContextBase::dispatchContextChangedNotification()
6656 {
<a name="808" id="anc808"></a><span class="line-added">6657     if (!m_dispatchContextChangedEventTimer.isActive())</span>
<span class="line-added">6658         m_dispatchContextChangedEventTimer.startOneShot(0_s);</span>
<span class="line-added">6659 }</span>
<span class="line-added">6660 </span>
<span class="line-added">6661 void WebGLRenderingContextBase::dispatchContextChangedEvent()</span>
<span class="line-added">6662 {</span>
<span class="line-added">6663     RELEASE_ASSERT(!m_isSuspended);</span>
6664     auto* canvas = htmlCanvas();
6665     if (!canvas)
6666         return;
6667 
6668     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextchangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
6669 }
6670 
6671 
6672 } // namespace WebCore
6673 
6674 #endif // ENABLE(WEBGL)
<a name="809" id="anc809"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="809" type="hidden" />
</body>
</html>
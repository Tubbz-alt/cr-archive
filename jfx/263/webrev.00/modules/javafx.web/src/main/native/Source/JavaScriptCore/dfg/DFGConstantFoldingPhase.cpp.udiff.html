<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGConstantFoldingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGCompilationKey.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGDesiredGlobalProperties.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGConstantFoldingPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -34,11 +34,11 @@</span>
  #include &quot;DFGBasicBlockInlines.h&quot;
  #include &quot;DFGGraph.h&quot;
  #include &quot;DFGInPlaceAbstractState.h&quot;
  #include &quot;DFGInsertionSet.h&quot;
  #include &quot;DFGPhase.h&quot;
<span class="udiff-line-modified-removed">- #include &quot;GetByIdStatus.h&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;GetByStatus.h&quot;</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;PutByIdStatus.h&quot;
  #include &quot;StructureCache.h&quot;
  
  namespace JSC { namespace DFG {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -56,11 +56,11 @@</span>
      bool run()
      {
          bool changed = false;
  
          for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
<span class="udiff-line-modified-removed">-             if (block-&gt;cfaFoundConstants)</span>
<span class="udiff-line-modified-added">+             if (block-&gt;cfaThinksShouldTryConstantFolding)</span>
                  changed |= foldConstants(block);
          }
  
          if (changed &amp;&amp; m_graph.m_form == SSA) {
              // It&#39;s now possible that we have Upsilons pointed at JSConstants. Fix that.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -274,10 +274,23 @@</span>
                      }
                  }
                  break;
              }
  
<span class="udiff-line-added">+             case CheckArrayOrEmpty: {</span>
<span class="udiff-line-added">+                 const AbstractValue&amp; value = m_state.forNode(node-&gt;child1());</span>
<span class="udiff-line-added">+                 if (!(value.m_type &amp; SpecEmpty)) {</span>
<span class="udiff-line-added">+                     node-&gt;convertCheckArrayOrEmptyToCheckArray();</span>
<span class="udiff-line-added">+                     changed = true;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 // Even if the input includes SpecEmpty, we can fall through to CheckArray and remove the node.</span>
<span class="udiff-line-added">+                 // CheckArrayOrEmpty can be removed when arrayMode meets the requirement. In that case, CellUse&#39;s</span>
<span class="udiff-line-added">+                 // check just remains, and it works as CheckArrayOrEmpty without ArrayMode checking.</span>
<span class="udiff-line-added">+                 ASSERT(typeFilterFor(node-&gt;child1().useKind()) &amp; SpecEmpty);</span>
<span class="udiff-line-added">+                 FALLTHROUGH;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              case CheckArray:
              case Arrayify: {
                  if (!node-&gt;arrayMode().alreadyChecked(m_graph, node, m_state.forNode(node-&gt;child1())))
                      break;
                  node-&gt;remove(m_graph);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -309,11 +322,11 @@</span>
                  node-&gt;remove(m_graph);
                  eliminated = true;
                  break;
              }
  
<span class="udiff-line-modified-removed">-             case CheckStringIdent: {</span>
<span class="udiff-line-modified-added">+             case CheckIdent: {</span>
                  UniquedStringImpl* uid = node-&gt;uidOperand();
                  const UniquedStringImpl* constantUid = nullptr;
  
                  JSValue childConstant = m_state.forNode(node-&gt;child1()).value();
                  if (childConstant) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -324,10 +337,13 @@</span>
                              // So here, we check the propagated value is actually an atomic string.
                              // And if it&#39;s not, we just ignore.
                              if (impl-&gt;isAtom())
                                  constantUid = static_cast&lt;const UniquedStringImpl*&gt;(impl);
                          }
<span class="udiff-line-added">+                     } else if (childConstant.isSymbol()) {</span>
<span class="udiff-line-added">+                         Symbol* symbol = jsCast&lt;Symbol*&gt;(childConstant);</span>
<span class="udiff-line-added">+                         constantUid = &amp;symbol-&gt;uid();</span>
                      }
                  }
  
                  if (constantUid == uid) {
                      node-&gt;remove(m_graph);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -378,11 +394,11 @@</span>
                  // we emitted a GetStack on arg6 we would have out-of-bounds access crashes anywhere that
                  // uses an Operands&lt;&gt; map. There is not much cost to continuing to use a
                  // GetMyArgumentByVal in such statically-out-of-bounds accesses; we just lose CFA unless
                  // GCSE removes the access entirely.
                  if (inlineCallFrame) {
<span class="udiff-line-modified-removed">-                     if (index &gt;= inlineCallFrame-&gt;argumentCountIncludingThis - 1)</span>
<span class="udiff-line-modified-added">+                     if (index &gt;= static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1))</span>
                          break;
                  } else {
                      if (index &gt;= m_state.numberOfArguments() - 1)
                          break;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -396,14 +412,14 @@</span>
                              inlineCallFrame-&gt;stackOffset +
                              CallFrame::argumentOffset(index)),
                          FlushedJSValue);
                  } else {
                      data = m_graph.m_stackAccessData.add(
<span class="udiff-line-modified-removed">-                         virtualRegisterForArgument(index + 1), FlushedJSValue);</span>
<span class="udiff-line-modified-added">+                         virtualRegisterForArgumentIncludingThis(index + 1), FlushedJSValue);</span>
                  }
  
<span class="udiff-line-modified-removed">-                 if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs() &amp;&amp; index &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1) {</span>
<span class="udiff-line-modified-added">+                 if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs() &amp;&amp; index &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1)) {</span>
                      node-&gt;convertToGetStack(data);
                      eliminated = true;
                      break;
                  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -544,11 +560,11 @@</span>
  
                  if (!baseValue.m_structure.isFinite()
                      || (node-&gt;child1().useKind() == UntypedUse || (baseValue.m_type &amp; ~SpecCell)))
                      break;
  
<span class="udiff-line-modified-removed">-                 GetByIdStatus status = GetByIdStatus::computeFor(</span>
<span class="udiff-line-modified-added">+                 GetByStatus status = GetByStatus::computeFor(</span>
                      baseValue.m_structure.toStructureSet(), m_graph.identifiers()[identifierNumber]);
                  if (!status.isSimple())
                      break;
  
                  for (unsigned i = status.numVariants(); i--;) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -559,12 +575,12 @@</span>
                      }
                  }
  
                  auto addFilterStatus = [&amp;] () {
                      m_insertionSet.insertNode(
<span class="udiff-line-modified-removed">-                         indexInBlock, SpecNone, FilterGetByIdStatus, node-&gt;origin,</span>
<span class="udiff-line-modified-removed">-                         OpInfo(m_graph.m_plan.recordedStatuses().addGetByIdStatus(node-&gt;origin.semantic, status)),</span>
<span class="udiff-line-modified-added">+                         indexInBlock, SpecNone, FilterGetByStatus, node-&gt;origin,</span>
<span class="udiff-line-modified-added">+                         OpInfo(m_graph.m_plan.recordedStatuses().addGetByStatus(node-&gt;origin.semantic, status)),</span>
                          Edge(child));
                  };
  
                  if (status.numVariants() == 1) {
                      addFilterStatus();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -601,13 +617,10 @@</span>
                  ASSERT(childEdge.useKind() == CellUse);
  
                  AbstractValue baseValue = m_state.forNode(child);
                  AbstractValue valueValue = m_state.forNode(node-&gt;child2());
  
<span class="udiff-line-removed">-                 m_interpreter.execute(indexInBlock); // Push CFA over this node after we get the state before.</span>
<span class="udiff-line-removed">-                 alreadyHandled = true; // Don&#39;t allow the default constant folder to do things to this.</span>
<span class="udiff-line-removed">- </span>
                  if (!baseValue.m_structure.isFinite())
                      break;
  
                  PutByIdStatus status = PutByIdStatus::computeFor(
                      m_graph.globalObjectFor(origin.semantic),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -624,13 +637,13 @@</span>
                      break;
  
                  changed = true;
  
                  bool allGood = true;
<span class="udiff-line-added">+                 RegisteredStructureSet newSet;</span>
<span class="udiff-line-added">+                 TransitionVector transitions;</span>
                  for (const PutByIdVariant&amp; variant : status.variants()) {
<span class="udiff-line-removed">-                     if (!allGood)</span>
<span class="udiff-line-removed">-                         break;</span>
                      for (const ObjectPropertyCondition&amp; condition : variant.conditionSet()) {
                          if (m_graph.watchCondition(condition))
                              continue;
  
                          Structure* structure = condition.object()-&gt;structure(m_graph.m_vm);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -643,15 +656,37 @@</span>
                              indexInBlock, SpecNone, CheckStructure, node-&gt;origin,
                              OpInfo(m_graph.addStructureSet(structure)),
                              m_insertionSet.insertConstantForUse(
                                  indexInBlock, node-&gt;origin, condition.object(), KnownCellUse));
                      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (!allGood)</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (variant.kind() == PutByIdVariant::Transition) {</span>
<span class="udiff-line-added">+                         RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());</span>
<span class="udiff-line-added">+                         transitions.append(</span>
<span class="udiff-line-added">+                             Transition(</span>
<span class="udiff-line-added">+                                 m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));</span>
<span class="udiff-line-added">+                         newSet.add(newStructure);</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         ASSERT(variant.kind() == PutByIdVariant::Replace);</span>
<span class="udiff-line-added">+                         newSet.merge(*m_graph.addStructureSet(variant.oldStructure()));</span>
<span class="udiff-line-added">+                     }</span>
                  }
  
                  if (!allGood)
                      break;
  
<span class="udiff-line-added">+                 // Push CFA over this node after we get the state before.</span>
<span class="udiff-line-added">+                 m_interpreter.didFoldClobberWorld();</span>
<span class="udiff-line-added">+                 m_interpreter.observeTransitions(indexInBlock, transitions);</span>
<span class="udiff-line-added">+                 if (m_state.forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)</span>
<span class="udiff-line-added">+                     m_state.setIsValid(false);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 alreadyHandled = true; // Don&#39;t allow the default constant folder to do things to this.</span>
<span class="udiff-line-added">+ </span>
                  m_insertionSet.insertNode(
                      indexInBlock, SpecNone, FilterPutByIdStatus, node-&gt;origin,
                      OpInfo(m_graph.m_plan.recordedStatuses().addPutByIdStatus(node-&gt;origin.semantic, status)),
                      Edge(child));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -693,10 +728,19 @@</span>
                  node-&gt;convertToIdentity();
                  changed = true;
                  break;
              }
  
<span class="udiff-line-added">+             case ToPropertyKey: {</span>
<span class="udiff-line-added">+                 if (m_state.forNode(node-&gt;child1()).m_type &amp; ~(SpecString | SpecSymbol))</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 node-&gt;convertToIdentity();</span>
<span class="udiff-line-added">+                 changed = true;</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              case ToThis: {
                  ToThisResult result = isToThisAnIdentity(m_graph.m_vm, m_graph.isStrictModeFor(node-&gt;origin.semantic), m_state.forNode(node-&gt;child1()));
                  if (result == ToThisResult::Identity) {
                      node-&gt;convertToIdentity();
                      changed = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -747,10 +791,78 @@</span>
                      }
                  }
                  break;
              }
  
<span class="udiff-line-added">+             case CreatePromise: {</span>
<span class="udiff-line-added">+                 JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="udiff-line-added">+                 if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {</span>
<span class="udiff-line-added">+                     if (base == (node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor())) {</span>
<span class="udiff-line-added">+                         node-&gt;convertToNewPromise(m_graph.registerStructure(node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure()));</span>
<span class="udiff-line-added">+                         changed = true;</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {</span>
<span class="udiff-line-added">+                         if (FunctionRareData* rareData = function-&gt;rareData()) {</span>
<span class="udiff-line-added">+                             if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="udiff-line-added">+                                 Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="udiff-line-added">+                                 if (structure</span>
<span class="udiff-line-added">+                                     &amp;&amp; structure-&gt;classInfo() == (node-&gt;isInternalPromise() ? JSInternalPromise::info() : JSPromise::info())</span>
<span class="udiff-line-added">+                                     &amp;&amp; structure-&gt;globalObject() == globalObject</span>
<span class="udiff-line-added">+                                     &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="udiff-line-added">+                                     m_graph.freeze(rareData);</span>
<span class="udiff-line-added">+                                     m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="udiff-line-added">+                                     node-&gt;convertToNewPromise(m_graph.registerStructure(structure));</span>
<span class="udiff-line-added">+                                     changed = true;</span>
<span class="udiff-line-added">+                                     break;</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             case CreateGenerator:</span>
<span class="udiff-line-added">+             case CreateAsyncGenerator: {</span>
<span class="udiff-line-added">+                 auto foldConstant = [&amp;] (NodeType newOp, const ClassInfo* classInfo) {</span>
<span class="udiff-line-added">+                     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="udiff-line-added">+                     if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {</span>
<span class="udiff-line-added">+                         if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {</span>
<span class="udiff-line-added">+                             if (FunctionRareData* rareData = function-&gt;rareData()) {</span>
<span class="udiff-line-added">+                                 if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="udiff-line-added">+                                     Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="udiff-line-added">+                                     if (structure</span>
<span class="udiff-line-added">+                                         &amp;&amp; structure-&gt;classInfo() == classInfo</span>
<span class="udiff-line-added">+                                         &amp;&amp; structure-&gt;globalObject() == globalObject</span>
<span class="udiff-line-added">+                                         &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="udiff-line-added">+                                         m_graph.freeze(rareData);</span>
<span class="udiff-line-added">+                                         m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="udiff-line-added">+                                         node-&gt;convertToNewInternalFieldObject(newOp, m_graph.registerStructure(structure));</span>
<span class="udiff-line-added">+                                         changed = true;</span>
<span class="udiff-line-added">+                                         return;</span>
<span class="udiff-line-added">+                                     }</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 switch (node-&gt;op()) {</span>
<span class="udiff-line-added">+                 case CreateGenerator:</span>
<span class="udiff-line-added">+                     foldConstant(NewGenerator, JSGenerator::info());</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case CreateAsyncGenerator:</span>
<span class="udiff-line-added">+                     foldConstant(NewAsyncGenerator, JSAsyncGenerator::info());</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 default:</span>
<span class="udiff-line-added">+                     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              case ObjectCreate: {
                  if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {
                      JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
                      Structure* structure = nullptr;
                      if (base.isNull())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -784,19 +896,48 @@</span>
                      }
                  }
                  break;
              }
  
<span class="udiff-line-added">+             case NewArrayWithSpread: {</span>
<span class="udiff-line-added">+                 if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {</span>
<span class="udiff-line-added">+                     BitVector* bitVector = node-&gt;bitVector();</span>
<span class="udiff-line-added">+                     if (node-&gt;numChildren() == 1 &amp;&amp; bitVector-&gt;get(0)) {</span>
<span class="udiff-line-added">+                         Edge use = m_graph.varArgChild(node, 0);</span>
<span class="udiff-line-added">+                         if (use-&gt;op() == PhantomSpread) {</span>
<span class="udiff-line-added">+                             if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {</span>
<span class="udiff-line-added">+                                 auto* immutableButterfly = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();</span>
<span class="udiff-line-added">+                                 if (hasContiguous(immutableButterfly-&gt;indexingType())) {</span>
<span class="udiff-line-added">+                                     node-&gt;convertToNewArrayBuffer(m_graph.freeze(immutableButterfly));</span>
<span class="udiff-line-added">+                                     changed = true;</span>
<span class="udiff-line-added">+                                     break;</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              case ToNumber: {
                  if (m_state.forNode(node-&gt;child1()).m_type &amp; ~SpecBytecodeNumber)
                      break;
  
                  node-&gt;convertToIdentity();
                  changed = true;
                  break;
              }
  
<span class="udiff-line-added">+             case ToNumeric: {</span>
<span class="udiff-line-added">+                 if (m_state.forNode(node-&gt;child1()).m_type &amp; ~(SpecBytecodeNumber | SpecBigInt))</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 node-&gt;convertToIdentity();</span>
<span class="udiff-line-added">+                 changed = true;</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              case NormalizeMapKey: {
                  SpeculatedType typeMaybeNormalized = (SpecFullNumber &amp; ~SpecInt32Only);
                  if (m_state.forNode(node-&gt;child1()).m_type &amp; typeMaybeNormalized)
                      break;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -953,10 +1094,11 @@</span>
              case PhantomNewObject:
              case PhantomNewFunction:
              case PhantomNewGeneratorFunction:
              case PhantomNewAsyncGeneratorFunction:
              case PhantomNewAsyncFunction:
<span class="udiff-line-added">+             case PhantomNewArrayIterator:</span>
              case PhantomCreateActivation:
              case PhantomDirectArguments:
              case PhantomClonedArguments:
              case PhantomCreateRest:
              case PhantomSpread:
</pre>
<center><a href="DFGCompilationKey.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGDesiredGlobalProperties.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
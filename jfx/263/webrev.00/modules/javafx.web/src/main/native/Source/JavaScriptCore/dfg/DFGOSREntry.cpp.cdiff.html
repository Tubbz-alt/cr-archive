<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSREntry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGOSRAvailabilityAnalysisPhase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOSREntry.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSREntry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  #include &quot;config.h&quot;
  #include &quot;DFGOSREntry.h&quot;
  
  #if ENABLE(DFG_JIT)
  
<span class="line-added">+ #include &quot;BytecodeStructs.h&quot;</span>
  #include &quot;CallFrame.h&quot;
  #include &quot;CodeBlock.h&quot;
  #include &quot;DFGJITCode.h&quot;
  #include &quot;DFGNode.h&quot;
  #include &quot;InterpreterInlines.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,11 ***</span>
  
  namespace JSC { namespace DFG {
  
  void OSREntryData::dumpInContext(PrintStream&amp; out, DumpContext* context) const
  {
<span class="line-modified">!     out.print(&quot;bc#&quot;, m_bytecodeIndex, &quot;, machine code = &quot;, RawPointer(m_machineCode.executableAddress()));</span>
      out.print(&quot;, stack rules = [&quot;);
  
      auto printOperand = [&amp;] (VirtualRegister reg) {
          out.print(inContext(m_expectedValues.operand(reg), context), &quot; (&quot;);
          VirtualRegister toReg;
<span class="line-new-header">--- 41,11 ---</span>
  
  namespace JSC { namespace DFG {
  
  void OSREntryData::dumpInContext(PrintStream&amp; out, DumpContext* context) const
  {
<span class="line-modified">!     out.print(m_bytecodeIndex, &quot;, machine code = &quot;, RawPointer(m_machineCode.executableAddress()));</span>
      out.print(&quot;, stack rules = [&quot;);
  
      auto printOperand = [&amp;] (VirtualRegister reg) {
          out.print(inContext(m_expectedValues.operand(reg), context), &quot; (&quot;);
          VirtualRegister toReg;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,11 ***</span>
      };
  
      CommaPrinter comma;
      for (size_t argumentIndex = m_expectedValues.numberOfArguments(); argumentIndex--;) {
          out.print(comma, &quot;arg&quot;, argumentIndex, &quot;:&quot;);
<span class="line-modified">!         printOperand(virtualRegisterForArgument(argumentIndex));</span>
      }
      for (size_t localIndex = 0; localIndex &lt; m_expectedValues.numberOfLocals(); ++localIndex) {
          out.print(comma, &quot;loc&quot;, localIndex, &quot;:&quot;);
          printOperand(virtualRegisterForLocal(localIndex));
      }
<span class="line-new-header">--- 75,11 ---</span>
      };
  
      CommaPrinter comma;
      for (size_t argumentIndex = m_expectedValues.numberOfArguments(); argumentIndex--;) {
          out.print(comma, &quot;arg&quot;, argumentIndex, &quot;:&quot;);
<span class="line-modified">!         printOperand(virtualRegisterForArgumentIncludingThis(argumentIndex));</span>
      }
      for (size_t localIndex = 0; localIndex &lt; m_expectedValues.numberOfLocals(); ++localIndex) {
          out.print(comma, &quot;loc&quot;, localIndex, &quot;:&quot;);
          printOperand(virtualRegisterForLocal(localIndex));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,28 ***</span>
  {
      dumpInContext(out, nullptr);
  }
  
  SUPPRESS_ASAN
<span class="line-modified">! void* prepareOSREntry(ExecState* exec, CodeBlock* codeBlock, unsigned bytecodeIndex)</span>
  {
      ASSERT(JITCode::isOptimizingJIT(codeBlock-&gt;jitType()));
      ASSERT(codeBlock-&gt;alternative());
      ASSERT(codeBlock-&gt;alternative()-&gt;jitType() == JITType::BaselineJIT);
      ASSERT(!codeBlock-&gt;jitCodeMap());
      ASSERT(codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;isStillValid);
  
      if (!Options::useOSREntryToDFG())
          return nullptr;
  
<span class="line-modified">!     if (Options::verboseOSR()) {</span>
<span class="line-modified">!         dataLog(</span>
<span class="line-modified">!             &quot;DFG OSR in &quot;, *codeBlock-&gt;alternative(), &quot; -&gt; &quot;, *codeBlock,</span>
<span class="line-removed">-             &quot; from bc#&quot;, bytecodeIndex, &quot;\n&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
  
      sanitizeStackForVM(vm);
  
      if (bytecodeIndex)
          codeBlock-&gt;ownerExecutable()-&gt;setDidTryToEnterInLoop(true);
<span class="line-new-header">--- 91,24 ---</span>
  {
      dumpInContext(out, nullptr);
  }
  
  SUPPRESS_ASAN
<span class="line-modified">! void* prepareOSREntry(VM&amp; vm, CallFrame* callFrame, CodeBlock* codeBlock, BytecodeIndex bytecodeIndex)</span>
  {
      ASSERT(JITCode::isOptimizingJIT(codeBlock-&gt;jitType()));
      ASSERT(codeBlock-&gt;alternative());
      ASSERT(codeBlock-&gt;alternative()-&gt;jitType() == JITType::BaselineJIT);
      ASSERT(!codeBlock-&gt;jitCodeMap());
      ASSERT(codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;isStillValid);
  
      if (!Options::useOSREntryToDFG())
          return nullptr;
  
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">!         &quot;DFG OSR in &quot;, *codeBlock-&gt;alternative(), &quot; -&gt; &quot;, *codeBlock,</span>
<span class="line-modified">!         &quot; from &quot;, bytecodeIndex);</span>
  
      sanitizeStackForVM(vm);
  
      if (bytecodeIndex)
          codeBlock-&gt;ownerExecutable()-&gt;setDidTryToEnterInLoop(true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,21 ***</span>
          //   hot loop and attempt to OSR enter. And we&#39;ll tell it that it can&#39;t. It
          //   might be worth addressing this case, but I just think this case will
          //   be super rare. For now, if it does happen, it&#39;ll cause some compilation
          //   thrashing.
  
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLog(&quot;    OSR failed because the target code block is not DFG.\n&quot;);</span>
          return nullptr;
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
      OSREntryData* entry = jitCode-&gt;osrEntryDataForBytecodeIndex(bytecodeIndex);
  
      if (!entry) {
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLogF(&quot;    OSR failed because the entrypoint was optimized out.\n&quot;);</span>
          return nullptr;
      }
  
      ASSERT(entry-&gt;m_bytecodeIndex == bytecodeIndex);
  
<span class="line-new-header">--- 131,19 ---</span>
          //   hot loop and attempt to OSR enter. And we&#39;ll tell it that it can&#39;t. It
          //   might be worth addressing this case, but I just think this case will
          //   be super rare. For now, if it does happen, it&#39;ll cause some compilation
          //   thrashing.
  
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), &quot;    OSR failed because the target code block is not DFG.&quot;);</span>
          return nullptr;
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
      OSREntryData* entry = jitCode-&gt;osrEntryDataForBytecodeIndex(bytecodeIndex);
  
      if (!entry) {
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), &quot;    OSR failed because the entrypoint was optimized out.&quot;);</span>
          return nullptr;
      }
  
      ASSERT(entry-&gt;m_bytecodeIndex == bytecodeIndex);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 177,27 ***</span>
      //    OSR at this time.
  
      for (size_t argument = 0; argument &lt; entry-&gt;m_expectedValues.numberOfArguments(); ++argument) {
          JSValue value;
          if (!argument)
<span class="line-modified">!             value = exec-&gt;thisValue();</span>
          else
<span class="line-modified">!             value = exec-&gt;argument(argument - 1);</span>
  
          if (!entry-&gt;m_expectedValues.argument(argument).validateOSREntryValue(value, FlushedJSValue)) {
<span class="line-modified">!             if (Options::verboseOSR()) {</span>
<span class="line-modified">!                 dataLog(</span>
<span class="line-modified">!                     &quot;    OSR failed because argument &quot;, argument, &quot; is &quot;, value,</span>
<span class="line-removed">-                     &quot;, expected &quot;, entry-&gt;m_expectedValues.argument(argument), &quot;.\n&quot;);</span>
<span class="line-removed">-             }</span>
              return nullptr;
          }
      }
  
      for (size_t local = 0; local &lt; entry-&gt;m_expectedValues.numberOfLocals(); ++local) {
          int localOffset = virtualRegisterForLocal(local).offset();
<span class="line-modified">!         JSValue value = exec-&gt;registers()[localOffset].asanUnsafeJSValue();</span>
          FlushFormat format = FlushedJSValue;
  
          if (entry-&gt;m_localsForcedAnyInt.get(local)) {
              if (!value.isAnyInt()) {
                  dataLogLnIf(Options::verboseOSR(),
<span class="line-new-header">--- 172,25 ---</span>
      //    OSR at this time.
  
      for (size_t argument = 0; argument &lt; entry-&gt;m_expectedValues.numberOfArguments(); ++argument) {
          JSValue value;
          if (!argument)
<span class="line-modified">!             value = callFrame-&gt;thisValue();</span>
          else
<span class="line-modified">!             value = callFrame-&gt;argument(argument - 1);</span>
  
          if (!entry-&gt;m_expectedValues.argument(argument).validateOSREntryValue(value, FlushedJSValue)) {
<span class="line-modified">!             dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">!                 &quot;    OSR failed because argument &quot;, argument, &quot; is &quot;, value,</span>
<span class="line-modified">!                 &quot;, expected &quot;, entry-&gt;m_expectedValues.argument(argument));</span>
              return nullptr;
          }
      }
  
      for (size_t local = 0; local &lt; entry-&gt;m_expectedValues.numberOfLocals(); ++local) {
          int localOffset = virtualRegisterForLocal(local).offset();
<span class="line-modified">!         JSValue value = callFrame-&gt;registers()[localOffset].asanUnsafeJSValue();</span>
          FlushFormat format = FlushedJSValue;
  
          if (entry-&gt;m_localsForcedAnyInt.get(local)) {
              if (!value.isAnyInt()) {
                  dataLogLnIf(Options::verboseOSR(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,18 ***</span>
      //    boundaries to start throwing RangeErrors. Although that would be possible,
      //    it seems silly: you&#39;d be diverting the program to error handling when it
      //    would have otherwise just kept running albeit less quickly.
  
      unsigned frameSizeForCheck = jitCode-&gt;common.requiredRegisterCountForExecutionAndExit();
<span class="line-modified">!     if (UNLIKELY(!vm.ensureStackCapacityFor(&amp;exec-&gt;registers()[virtualRegisterForLocal(frameSizeForCheck - 1).offset()]))) {</span>
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLogF(&quot;    OSR failed because stack growth failed.\n&quot;);</span>
          return nullptr;
      }
  
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLogF(&quot;    OSR should succeed.\n&quot;);</span>
  
      // At this point we&#39;re committed to entering. We will do some work to set things up,
      // but we also rely on our caller recognizing that when we return a non-null pointer,
      // that means that we&#39;re already past the point of no return and we must succeed at
      // entering.
<span class="line-new-header">--- 229,16 ---</span>
      //    boundaries to start throwing RangeErrors. Although that would be possible,
      //    it seems silly: you&#39;d be diverting the program to error handling when it
      //    would have otherwise just kept running albeit less quickly.
  
      unsigned frameSizeForCheck = jitCode-&gt;common.requiredRegisterCountForExecutionAndExit();
<span class="line-modified">!     if (UNLIKELY(!vm.ensureStackCapacityFor(&amp;callFrame-&gt;registers()[virtualRegisterForLocal(frameSizeForCheck - 1).offset()]))) {</span>
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), &quot;    OSR failed because stack growth failed.&quot;);</span>
          return nullptr;
      }
  
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), &quot;    OSR should succeed.&quot;);</span>
  
      // At this point we&#39;re committed to entering. We will do some work to set things up,
      // but we also rely on our caller recognizing that when we return a non-null pointer,
      // that means that we&#39;re already past the point of no return and we must succeed at
      // entering.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,33 ***</span>
  
      *bitwise_cast&lt;size_t*&gt;(scratch + 0) = frameSize;
  
      void* targetPC = entry-&gt;m_machineCode.executableAddress();
      RELEASE_ASSERT(codeBlock-&gt;jitCode()-&gt;contains(entry-&gt;m_machineCode.untaggedExecutableAddress()));
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLogF(&quot;    OSR using target PC %p.\n&quot;, targetPC);</span>
      RELEASE_ASSERT(targetPC);
<span class="line-modified">!     *bitwise_cast&lt;void**&gt;(scratch + 1) = retagCodePtr(targetPC, OSREntryPtrTag, bitwise_cast&lt;PtrTag&gt;(exec));</span>
  
      Register* pivot = scratch + 2 + CallFrame::headerSizeInRegisters;
  
      for (int index = -CallFrame::headerSizeInRegisters; index &lt; static_cast&lt;int&gt;(baselineFrameSize); ++index) {
          VirtualRegister reg(-1 - index);
  
          if (reg.isLocal()) {
              if (entry-&gt;m_localsForcedDouble.get(reg.toLocal())) {
<span class="line-modified">!                 *bitwise_cast&lt;double*&gt;(pivot + index) = exec-&gt;registers()[reg.offset()].asanUnsafeJSValue().asNumber();</span>
                  continue;
              }
  
              if (entry-&gt;m_localsForcedAnyInt.get(reg.toLocal())) {
<span class="line-modified">!                 *bitwise_cast&lt;int64_t*&gt;(pivot + index) = exec-&gt;registers()[reg.offset()].asanUnsafeJSValue().asAnyInt() &lt;&lt; JSValue::int52ShiftAmount;</span>
                  continue;
              }
          }
  
<span class="line-modified">!         pivot[index] = exec-&gt;registers()[reg.offset()].asanUnsafeJSValue();</span>
      }
  
      // 4) Reshuffle those registers that need reshuffling.
      Vector&lt;JSValue&gt; temporaryLocals(entry-&gt;m_reshufflings.size());
      for (unsigned i = entry-&gt;m_reshufflings.size(); i--;)
<span class="line-new-header">--- 253,32 ---</span>
  
      *bitwise_cast&lt;size_t*&gt;(scratch + 0) = frameSize;
  
      void* targetPC = entry-&gt;m_machineCode.executableAddress();
      RELEASE_ASSERT(codeBlock-&gt;jitCode()-&gt;contains(entry-&gt;m_machineCode.untaggedExecutableAddress()));
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), &quot;    OSR using target PC &quot;, RawPointer(targetPC));</span>
      RELEASE_ASSERT(targetPC);
<span class="line-modified">!     *bitwise_cast&lt;void**&gt;(scratch + 1) = retagCodePtr(targetPC, OSREntryPtrTag, bitwise_cast&lt;PtrTag&gt;(callFrame));</span>
  
      Register* pivot = scratch + 2 + CallFrame::headerSizeInRegisters;
  
      for (int index = -CallFrame::headerSizeInRegisters; index &lt; static_cast&lt;int&gt;(baselineFrameSize); ++index) {
          VirtualRegister reg(-1 - index);
  
          if (reg.isLocal()) {
              if (entry-&gt;m_localsForcedDouble.get(reg.toLocal())) {
<span class="line-modified">!                 *bitwise_cast&lt;double*&gt;(pivot + index) = callFrame-&gt;registers()[reg.offset()].asanUnsafeJSValue().asNumber();</span>
                  continue;
              }
  
              if (entry-&gt;m_localsForcedAnyInt.get(reg.toLocal())) {
<span class="line-modified">!                 *bitwise_cast&lt;int64_t*&gt;(pivot + index) = callFrame-&gt;registers()[reg.offset()].asanUnsafeJSValue().asAnyInt() &lt;&lt; JSValue::int52ShiftAmount;</span>
                  continue;
              }
          }
  
<span class="line-modified">!         pivot[index] = callFrame-&gt;registers()[reg.offset()].asanUnsafeJSValue();</span>
      }
  
      // 4) Reshuffle those registers that need reshuffling.
      Vector&lt;JSValue&gt; temporaryLocals(entry-&gt;m_reshufflings.size());
      for (unsigned i = entry-&gt;m_reshufflings.size(); i--;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,36 ***</span>
          RegisterAtOffset currentEntry = registerSaveLocations-&gt;at(i);
          if (dontSaveRegisters.get(currentEntry.reg()))
              continue;
          RegisterAtOffset* calleeSavesEntry = allCalleeSaves-&gt;find(currentEntry.reg());
  
<span class="line-modified">!         *(bitwise_cast&lt;intptr_t*&gt;(pivot - 1) - currentEntry.offsetAsIndex()) = record-&gt;calleeSaveRegistersBuffer[calleeSavesEntry-&gt;offsetAsIndex()];</span>
      }
  #endif
  
      // 7) Fix the call frame to have the right code block.
  
<span class="line-modified">!     *bitwise_cast&lt;CodeBlock**&gt;(pivot - 1 - CallFrameSlot::codeBlock) = codeBlock;</span>
  
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLogF(&quot;    OSR returning data buffer %p.\n&quot;, scratch);</span>
      return scratch;
  }
  
<span class="line-modified">! MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; prepareCatchOSREntry(ExecState* exec, CodeBlock* codeBlock, unsigned bytecodeIndex)</span>
  {
<span class="line-modified">!     ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT || codeBlock-&gt;jitType() == JITType::FTLJIT);</span>
<span class="line-modified">!     ASSERT(codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;isStillValid);</span>
  
<span class="line-modified">!     if (!Options::useOSREntryToDFG() &amp;&amp; codeBlock-&gt;jitCode()-&gt;jitType() == JITType::DFGJIT)</span>
          return nullptr;
<span class="line-modified">!     if (!Options::useOSREntryToFTL() &amp;&amp; codeBlock-&gt;jitCode()-&gt;jitType() == JITType::FTLJIT)</span>
          return nullptr;
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     CommonData* dfgCommon = codeBlock-&gt;jitCode()-&gt;dfgCommon();</span>
      RELEASE_ASSERT(dfgCommon);
      DFG::CatchEntrypointData* catchEntrypoint = dfgCommon-&gt;catchOSREntryDataForBytecodeIndex(bytecodeIndex);
      if (!catchEntrypoint) {
          // This can be null under some circumstances. The most common is that we didn&#39;t
          // compile this op_catch as an entrypoint since it had never executed when starting
<span class="line-new-header">--- 306,57 ---</span>
          RegisterAtOffset currentEntry = registerSaveLocations-&gt;at(i);
          if (dontSaveRegisters.get(currentEntry.reg()))
              continue;
          RegisterAtOffset* calleeSavesEntry = allCalleeSaves-&gt;find(currentEntry.reg());
  
<span class="line-modified">!         if constexpr (CallerFrameAndPC::sizeInRegisters == 2)</span>
<span class="line-added">+             *(bitwise_cast&lt;intptr_t*&gt;(pivot - 1) - currentEntry.offsetAsIndex()) = record-&gt;calleeSaveRegistersBuffer[calleeSavesEntry-&gt;offsetAsIndex()];</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             // We need to adjust 4-bytes on 32-bits, otherwise we will clobber some parts of</span>
<span class="line-added">+             // pivot[-1] when currentEntry.offsetAsIndex() returns -1. This region contains</span>
<span class="line-added">+             // CallerFrameAndPC and if it is cloberred, we will have a corrupted stack.</span>
<span class="line-added">+             // Also, we need to store callee-save registers swapped in pairs on scratch buffer,</span>
<span class="line-added">+             // otherwise they will be swapped when copied to call frame during OSR Entry code.</span>
<span class="line-added">+             // Here is how we would like to have the buffer configured:</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // pivot[-4] = ArgumentCountIncludingThis</span>
<span class="line-added">+             // pivot[-3] = Callee</span>
<span class="line-added">+             // pivot[-2] = CodeBlock</span>
<span class="line-added">+             // pivot[-1] = CallerFrameAndReturnPC</span>
<span class="line-added">+             // pivot[0]  = csr1/csr0</span>
<span class="line-added">+             // pivot[1]  = csr3/csr2</span>
<span class="line-added">+             // ...</span>
<span class="line-added">+             ASSERT(sizeof(intptr_t) == 4);</span>
<span class="line-added">+             ASSERT(CallerFrameAndPC::sizeInRegisters == 1);</span>
<span class="line-added">+             ASSERT(currentEntry.offsetAsIndex() &lt; 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+             int offsetAsIndex = currentEntry.offsetAsIndex();</span>
<span class="line-added">+             int properIndex = offsetAsIndex % 2 ? offsetAsIndex - 1 : offsetAsIndex + 1;</span>
<span class="line-added">+             *(bitwise_cast&lt;intptr_t*&gt;(pivot - 1) + 1 - properIndex) = record-&gt;calleeSaveRegistersBuffer[calleeSavesEntry-&gt;offsetAsIndex()];</span>
<span class="line-added">+         }</span>
      }
  #endif
  
      // 7) Fix the call frame to have the right code block.
  
<span class="line-modified">!     *bitwise_cast&lt;CodeBlock**&gt;(pivot - (CallFrameSlot::codeBlock + 1)) = codeBlock;</span>
  
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), &quot;    OSR returning data buffer &quot;, RawPointer(scratch));</span>
      return scratch;
  }
  
<span class="line-modified">! MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; prepareCatchOSREntry(VM&amp; vm, CallFrame* callFrame, CodeBlock* baselineCodeBlock, CodeBlock* optimizedCodeBlock, BytecodeIndex bytecodeIndex)</span>
  {
<span class="line-modified">!     ASSERT(optimizedCodeBlock-&gt;jitType() == JITType::DFGJIT || optimizedCodeBlock-&gt;jitType() == JITType::FTLJIT);</span>
<span class="line-modified">!     ASSERT(optimizedCodeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;isStillValid);</span>
  
<span class="line-modified">!     if (!Options::useOSREntryToDFG() &amp;&amp; optimizedCodeBlock-&gt;jitCode()-&gt;jitType() == JITType::DFGJIT)</span>
          return nullptr;
<span class="line-modified">!     if (!Options::useOSREntryToFTL() &amp;&amp; optimizedCodeBlock-&gt;jitCode()-&gt;jitType() == JITType::FTLJIT)</span>
          return nullptr;
  
<span class="line-modified">!     CommonData* dfgCommon = optimizedCodeBlock-&gt;jitCode()-&gt;dfgCommon();</span>
      RELEASE_ASSERT(dfgCommon);
      DFG::CatchEntrypointData* catchEntrypoint = dfgCommon-&gt;catchOSREntryDataForBytecodeIndex(bytecodeIndex);
      if (!catchEntrypoint) {
          // This can be null under some circumstances. The most common is that we didn&#39;t
          // compile this op_catch as an entrypoint since it had never executed when starting
</pre>
<hr />
<pre>
<span class="line-old-header">*** 353,11 ***</span>
          return nullptr;
      }
  
      // We&#39;re only allowed to OSR enter if we&#39;ve proven we have compatible argument types.
      for (unsigned argument = 0; argument &lt; catchEntrypoint-&gt;argumentFormats.size(); ++argument) {
<span class="line-modified">!         JSValue value = exec-&gt;uncheckedR(virtualRegisterForArgument(argument)).jsValue();</span>
          switch (catchEntrypoint-&gt;argumentFormats[argument]) {
          case DFG::FlushedInt32:
              if (!value.isInt32())
                  return nullptr;
              break;
<span class="line-new-header">--- 364,11 ---</span>
          return nullptr;
      }
  
      // We&#39;re only allowed to OSR enter if we&#39;ve proven we have compatible argument types.
      for (unsigned argument = 0; argument &lt; catchEntrypoint-&gt;argumentFormats.size(); ++argument) {
<span class="line-modified">!         JSValue value = callFrame-&gt;uncheckedR(virtualRegisterForArgumentIncludingThis(argument)).jsValue();</span>
          switch (catchEntrypoint-&gt;argumentFormats[argument]) {
          case DFG::FlushedInt32:
              if (!value.isInt32())
                  return nullptr;
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 379,22 ***</span>
              RELEASE_ASSERT_NOT_REACHED();
          }
      }
  
      unsigned frameSizeForCheck = dfgCommon-&gt;requiredRegisterCountForExecutionAndExit();
<span class="line-modified">!     if (UNLIKELY(!vm.ensureStackCapacityFor(&amp;exec-&gt;registers()[virtualRegisterForLocal(frameSizeForCheck).offset()])))</span>
          return nullptr;
  
<span class="line-modified">!     auto instruction = exec-&gt;codeBlock()-&gt;instructions().at(exec-&gt;bytecodeOffset());</span>
      ASSERT(instruction-&gt;is&lt;OpCatch&gt;());
<span class="line-modified">!     ValueProfileAndOperandBuffer* buffer = instruction-&gt;as&lt;OpCatch&gt;().metadata(exec).m_buffer;</span>
      JSValue* dataBuffer = reinterpret_cast&lt;JSValue*&gt;(dfgCommon-&gt;catchOSREntryBuffer-&gt;dataBuffer());
      unsigned index = 0;
<span class="line-modified">!     buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {</span>
          if (!VirtualRegister(profile.m_operand).isLocal())
              return;
<span class="line-modified">!         dataBuffer[index] = exec-&gt;uncheckedR(profile.m_operand).jsValue();</span>
          ++index;
      });
  
      // The active length of catchOSREntryBuffer will be zeroed by ClearCatchLocals node.
      dfgCommon-&gt;catchOSREntryBuffer-&gt;setActiveLength(sizeof(JSValue) * index);
<span class="line-new-header">--- 390,22 ---</span>
              RELEASE_ASSERT_NOT_REACHED();
          }
      }
  
      unsigned frameSizeForCheck = dfgCommon-&gt;requiredRegisterCountForExecutionAndExit();
<span class="line-modified">!     if (UNLIKELY(!vm.ensureStackCapacityFor(&amp;callFrame-&gt;registers()[virtualRegisterForLocal(frameSizeForCheck).offset()])))</span>
          return nullptr;
  
<span class="line-modified">!     auto instruction = baselineCodeBlock-&gt;instructions().at(callFrame-&gt;bytecodeIndex());</span>
      ASSERT(instruction-&gt;is&lt;OpCatch&gt;());
<span class="line-modified">!     ValueProfileAndVirtualRegisterBuffer* buffer = instruction-&gt;as&lt;OpCatch&gt;().metadata(baselineCodeBlock).m_buffer;</span>
      JSValue* dataBuffer = reinterpret_cast&lt;JSValue*&gt;(dfgCommon-&gt;catchOSREntryBuffer-&gt;dataBuffer());
      unsigned index = 0;
<span class="line-modified">!     buffer-&gt;forEach([&amp;] (ValueProfileAndVirtualRegister&amp; profile) {</span>
          if (!VirtualRegister(profile.m_operand).isLocal())
              return;
<span class="line-modified">!         dataBuffer[index] = callFrame-&gt;uncheckedR(profile.m_operand).jsValue();</span>
          ++index;
      });
  
      // The active length of catchOSREntryBuffer will be zeroed by ClearCatchLocals node.
      dfgCommon-&gt;catchOSREntryBuffer-&gt;setActiveLength(sizeof(JSValue) * index);
</pre>
<center><a href="DFGOSRAvailabilityAnalysisPhase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOSREntry.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
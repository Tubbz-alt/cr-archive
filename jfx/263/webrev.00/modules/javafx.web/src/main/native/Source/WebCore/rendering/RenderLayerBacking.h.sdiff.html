<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayerBacking.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerCompositor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;FloatPoint.h&quot;
 29 #include &quot;FloatPoint3D.h&quot;
 30 #include &quot;GraphicsLayer.h&quot;
 31 #include &quot;GraphicsLayerClient.h&quot;
 32 #include &quot;RenderLayer.h&quot;
 33 #include &quot;RenderLayerCompositor.h&quot;
 34 #include &quot;ScrollingCoordinator.h&quot;
 35 
 36 namespace WebCore {
 37 

 38 class KeyframeList;
 39 class PaintedContentsInfo;
 40 class RenderLayerCompositor;
 41 class TiledBacking;
 42 class TransformationMatrix;
 43 









 44 enum CompositingLayerType {
 45     NormalCompositingLayer, // non-tiled layer with backing store
 46     TiledCompositingLayer, // tiled layer (always has backing store)
 47     MediaCompositingLayer, // layer that contains an image, video, WebGL or plugin
 48     ContainerCompositingLayer // layer with no backing store
 49 };
 50 
 51 // RenderLayerBacking controls the compositing behavior for a single RenderLayer.
 52 // It holds the various GraphicsLayers, and makes decisions about intra-layer rendering
 53 // optimizations.
 54 //
 55 // There is one RenderLayerBacking for each RenderLayer that is composited.
 56 
 57 class RenderLayerBacking final : public GraphicsLayerClient {
 58     WTF_MAKE_NONCOPYABLE(RenderLayerBacking); WTF_MAKE_FAST_ALLOCATED;
 59 public:
 60     explicit RenderLayerBacking(RenderLayer&amp;);
 61     ~RenderLayerBacking();
 62 
 63 #if PLATFORM(IOS_FAMILY)
 64     void layerWillBeDestroyed();
 65 #endif
 66 
 67     // Do cleanup while layer-&gt;backing() is still valid.
 68     void willBeDestroyed();
 69 
 70     RenderLayer&amp; owningLayer() const { return m_owningLayer; }
 71 
 72     // Included layers are non-z-order descendant layers that are painted into this backing.
 73     const Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp; backingSharingLayers() const { return m_backingSharingLayers; }
 74     void setBackingSharingLayers(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp;&amp;);
 75 
 76     bool hasBackingSharingLayers() const { return !m_backingSharingLayers.isEmpty(); }
 77 
 78     void removeBackingSharingLayer(RenderLayer&amp;);
 79     void clearBackingSharingLayers();
 80 
 81     void updateConfigurationAfterStyleChange();
 82 
 83     // Returns true if layer configuration changed.
<span class="line-modified"> 84     bool updateConfiguration();</span>
 85 
 86     // Update graphics layer position and bounds.
<span class="line-modified"> 87     void updateGeometry();</span>
 88 
 89     // Update state the requires that descendant layers have been updated.
 90     void updateAfterDescendants();
 91 
 92     // Update contents and clipping structure.
 93     void updateDrawsContent();
 94 
 95     void updateAfterLayout(bool needsClippingUpdate, bool needsFullRepaint);
 96 
 97     GraphicsLayer* graphicsLayer() const { return m_graphicsLayer.get(); }
 98 
 99     // Layer to clip children
100     bool hasClippingLayer() const { return (m_childContainmentLayer &amp;&amp; !m_isFrameLayerWithTiledBacking); }
101     GraphicsLayer* clippingLayer() const { return !m_isFrameLayerWithTiledBacking ? m_childContainmentLayer.get() : nullptr; }
102 
103     bool hasAncestorClippingLayers() const { return !!m_ancestorClippingStack; }
104     LayerAncestorClippingStack* ancestorClippingStack() const { return m_ancestorClippingStack.get(); }
105     bool updateAncestorClippingStack(Vector&lt;CompositedClipData&gt;&amp;&amp;);
106 
107     GraphicsLayer* contentsContainmentLayer() const { return m_contentsContainmentLayer.get(); }
</pre>
<hr />
<pre>
213     void updateEventRegion();
214 
215     void updateAfterWidgetResize();
216     void positionOverflowControlsLayers();
217 
218     bool isFrameLayerWithTiledBacking() const { return m_isFrameLayerWithTiledBacking; }
219 
220     WEBCORE_EXPORT TiledBacking* tiledBacking() const;
221     void adjustTiledBackingCoverage();
222     void setTiledBackingHasMargins(bool hasExtendedBackgroundOnLeftAndRight, bool hasExtendedBackgroundOnTopAndBottom);
223 
224     void updateDebugIndicators(bool showBorder, bool showRepaintCounter);
225     bool paintsSubpixelAntialiasedText() const { return m_paintsSubpixelAntialiasedText; }
226 
227     // GraphicsLayerClient interface
228     void tiledBackingUsageChanged(const GraphicsLayer*, bool /*usingTiledBacking*/) override;
229     void notifyAnimationStarted(const GraphicsLayer*, const String&amp; animationKey, MonotonicTime startTime) override;
230     void notifyFlushRequired(const GraphicsLayer*) override;
231     void notifyFlushBeforeDisplayRefresh(const GraphicsLayer*) override;
232 
<span class="line-modified">233     void paintContents(const GraphicsLayer*, GraphicsContext&amp;, OptionSet&lt;GraphicsLayerPaintingPhase&gt;, const FloatRect&amp; clip, GraphicsLayerPaintBehavior) override;</span>
234 
235     float deviceScaleFactor() const override;
236     float contentsScaleMultiplierForNewTiles(const GraphicsLayer*) const override;
237 
238     bool paintsOpaquelyAtNonIntegralScales(const GraphicsLayer*) const override;
239 
240     float pageScaleFactor() const override;
241     float zoomedOutPageScaleFactor() const override;
242 
243     void didChangePlatformLayerForLayer(const GraphicsLayer*) override;
244     bool getCurrentTransform(const GraphicsLayer*, TransformationMatrix&amp;) const override;
245 
246     bool isTrackingRepaints() const override;
247     bool shouldSkipLayerInDump(const GraphicsLayer*, LayerTreeAsTextBehavior) const override;
248     bool shouldDumpPropertyForLayer(const GraphicsLayer*, const char* propertyName, LayerTreeAsTextBehavior) const override;
249 
250     bool shouldAggressivelyRetainTiles(const GraphicsLayer*) const override;
251     bool shouldTemporarilyRetainTileCohorts(const GraphicsLayer*) const override;
252     bool useGiantTiles() const override;
253     void logFilledVisibleFreshTile(unsigned) override;
</pre>
<hr />
<pre>
359     // Returns true if this layer has content that needs to be rendered by painting into the backing store.
360     bool containsPaintedContent(PaintedContentsInfo&amp;) const;
361     // Returns true if the RenderLayer just contains an image that we can composite directly.
362     bool isDirectlyCompositedImage() const;
363     void updateImageContents(PaintedContentsInfo&amp;);
364 
365     void updateDirectlyCompositedBoxDecorations(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
366     void updateDirectlyCompositedBackgroundColor(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
367     void updateDirectlyCompositedBackgroundImage(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
368 
369     void resetContentsRect();
370 
371     bool isPaintDestinationForDescendantLayers(RenderLayer::PaintedContentRequest&amp;) const;
372     bool hasVisibleNonCompositedDescendants() const;
373 
374     bool shouldClipCompositedBounds() const;
375 
376     bool hasTiledBackingFlatteningLayer() const { return (m_childContainmentLayer &amp;&amp; m_isFrameLayerWithTiledBacking); }
377     GraphicsLayer* tileCacheFlatteningLayer() const { return m_isFrameLayerWithTiledBacking ? m_childContainmentLayer.get() : nullptr; }
378 
<span class="line-modified">379     void paintIntoLayer(const GraphicsLayer*, GraphicsContext&amp;, const IntRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;GraphicsLayerPaintingPhase&gt;);</span>

380 
381     void paintDebugOverlays(const GraphicsLayer*, GraphicsContext&amp;);
382 
383     static CSSPropertyID graphicsLayerToCSSProperty(AnimatedPropertyID);
384     static AnimatedPropertyID cssToGraphicsLayerProperty(CSSPropertyID);
385 
386     bool canIssueSetNeedsDisplay() const { return !paintsIntoWindow() &amp;&amp; !paintsIntoCompositedAncestor(); }
387     LayoutRect computeParentGraphicsLayerRect(const RenderLayer* compositedAncestor) const;
<span class="line-modified">388     LayoutRect computePrimaryGraphicsLayerRect(const LayoutRect&amp; parentGraphicsLayerRect) const;</span>
389 



390     RenderLayer&amp; m_owningLayer;
391 
392     // A list other layers that paint into this backing store, later than m_owningLayer in paint order.
393     Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt; m_backingSharingLayers;
394 
395     std::unique_ptr&lt;LayerAncestorClippingStack&gt; m_ancestorClippingStack; // Only used if we are clipped by an ancestor which is not a stacking context.
396 
397     RefPtr&lt;GraphicsLayer&gt; m_contentsContainmentLayer; // Only used if we have a background layer; takes the transform.
398     RefPtr&lt;GraphicsLayer&gt; m_graphicsLayer;
399     RefPtr&lt;GraphicsLayer&gt; m_foregroundLayer; // Only used in cases where we need to draw the foreground separately.
400     RefPtr&lt;GraphicsLayer&gt; m_backgroundLayer; // Only used in cases where we need to draw the background separately.
401     RefPtr&lt;GraphicsLayer&gt; m_childContainmentLayer; // Only used if we have clipping on a stacking context with compositing children, or if the layer has a tile cache.
402     RefPtr&lt;GraphicsLayer&gt; m_maskLayer; // Only used if we have a mask and/or clip-path.
403     RefPtr&lt;GraphicsLayer&gt; m_childClippingMaskLayer; // Only used if we have to clip child layers or accelerated contents with border radius or clip-path.
404 
405     RefPtr&lt;GraphicsLayer&gt; m_layerForHorizontalScrollbar;
406     RefPtr&lt;GraphicsLayer&gt; m_layerForVerticalScrollbar;
407     RefPtr&lt;GraphicsLayer&gt; m_layerForScrollCorner;
408 
409     RefPtr&lt;GraphicsLayer&gt; m_scrollContainerLayer; // Only used if the layer is using composited scrolling.
</pre>
</td>
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;FloatPoint.h&quot;
 29 #include &quot;FloatPoint3D.h&quot;
 30 #include &quot;GraphicsLayer.h&quot;
 31 #include &quot;GraphicsLayerClient.h&quot;
 32 #include &quot;RenderLayer.h&quot;
 33 #include &quot;RenderLayerCompositor.h&quot;
 34 #include &quot;ScrollingCoordinator.h&quot;
 35 
 36 namespace WebCore {
 37 
<span class="line-added"> 38 class EventRegionContext;</span>
 39 class KeyframeList;
 40 class PaintedContentsInfo;
 41 class RenderLayerCompositor;
 42 class TiledBacking;
 43 class TransformationMatrix;
 44 
<span class="line-added"> 45 </span>
<span class="line-added"> 46 #if __WORDSIZE == 64</span>
<span class="line-added"> 47 #define USE_OWNING_LAYER_BEAR_TRAP 1</span>
<span class="line-added"> 48 #define BEAR_TRAP_VALUE 0xEEEEEEEEEEEEEEEE</span>
<span class="line-added"> 49 #else</span>
<span class="line-added"> 50 #define USE_OWNING_LAYER_BEAR_TRAP 0</span>
<span class="line-added"> 51 #endif</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53 </span>
 54 enum CompositingLayerType {
 55     NormalCompositingLayer, // non-tiled layer with backing store
 56     TiledCompositingLayer, // tiled layer (always has backing store)
 57     MediaCompositingLayer, // layer that contains an image, video, WebGL or plugin
 58     ContainerCompositingLayer // layer with no backing store
 59 };
 60 
 61 // RenderLayerBacking controls the compositing behavior for a single RenderLayer.
 62 // It holds the various GraphicsLayers, and makes decisions about intra-layer rendering
 63 // optimizations.
 64 //
 65 // There is one RenderLayerBacking for each RenderLayer that is composited.
 66 
 67 class RenderLayerBacking final : public GraphicsLayerClient {
 68     WTF_MAKE_NONCOPYABLE(RenderLayerBacking); WTF_MAKE_FAST_ALLOCATED;
 69 public:
 70     explicit RenderLayerBacking(RenderLayer&amp;);
 71     ~RenderLayerBacking();
 72 
 73 #if PLATFORM(IOS_FAMILY)
 74     void layerWillBeDestroyed();
 75 #endif
 76 
 77     // Do cleanup while layer-&gt;backing() is still valid.
 78     void willBeDestroyed();
 79 
 80     RenderLayer&amp; owningLayer() const { return m_owningLayer; }
 81 
 82     // Included layers are non-z-order descendant layers that are painted into this backing.
 83     const Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp; backingSharingLayers() const { return m_backingSharingLayers; }
 84     void setBackingSharingLayers(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp;&amp;);
 85 
 86     bool hasBackingSharingLayers() const { return !m_backingSharingLayers.isEmpty(); }
 87 
 88     void removeBackingSharingLayer(RenderLayer&amp;);
 89     void clearBackingSharingLayers();
 90 
 91     void updateConfigurationAfterStyleChange();
 92 
 93     // Returns true if layer configuration changed.
<span class="line-modified"> 94     bool updateConfiguration(const RenderLayer* compositingAncestor);</span>
 95 
 96     // Update graphics layer position and bounds.
<span class="line-modified"> 97     void updateGeometry(const RenderLayer* compositingAncestor);</span>
 98 
 99     // Update state the requires that descendant layers have been updated.
100     void updateAfterDescendants();
101 
102     // Update contents and clipping structure.
103     void updateDrawsContent();
104 
105     void updateAfterLayout(bool needsClippingUpdate, bool needsFullRepaint);
106 
107     GraphicsLayer* graphicsLayer() const { return m_graphicsLayer.get(); }
108 
109     // Layer to clip children
110     bool hasClippingLayer() const { return (m_childContainmentLayer &amp;&amp; !m_isFrameLayerWithTiledBacking); }
111     GraphicsLayer* clippingLayer() const { return !m_isFrameLayerWithTiledBacking ? m_childContainmentLayer.get() : nullptr; }
112 
113     bool hasAncestorClippingLayers() const { return !!m_ancestorClippingStack; }
114     LayerAncestorClippingStack* ancestorClippingStack() const { return m_ancestorClippingStack.get(); }
115     bool updateAncestorClippingStack(Vector&lt;CompositedClipData&gt;&amp;&amp;);
116 
117     GraphicsLayer* contentsContainmentLayer() const { return m_contentsContainmentLayer.get(); }
</pre>
<hr />
<pre>
223     void updateEventRegion();
224 
225     void updateAfterWidgetResize();
226     void positionOverflowControlsLayers();
227 
228     bool isFrameLayerWithTiledBacking() const { return m_isFrameLayerWithTiledBacking; }
229 
230     WEBCORE_EXPORT TiledBacking* tiledBacking() const;
231     void adjustTiledBackingCoverage();
232     void setTiledBackingHasMargins(bool hasExtendedBackgroundOnLeftAndRight, bool hasExtendedBackgroundOnTopAndBottom);
233 
234     void updateDebugIndicators(bool showBorder, bool showRepaintCounter);
235     bool paintsSubpixelAntialiasedText() const { return m_paintsSubpixelAntialiasedText; }
236 
237     // GraphicsLayerClient interface
238     void tiledBackingUsageChanged(const GraphicsLayer*, bool /*usingTiledBacking*/) override;
239     void notifyAnimationStarted(const GraphicsLayer*, const String&amp; animationKey, MonotonicTime startTime) override;
240     void notifyFlushRequired(const GraphicsLayer*) override;
241     void notifyFlushBeforeDisplayRefresh(const GraphicsLayer*) override;
242 
<span class="line-modified">243     void paintContents(const GraphicsLayer*, GraphicsContext&amp;, const FloatRect&amp; clip, GraphicsLayerPaintBehavior) override;</span>
244 
245     float deviceScaleFactor() const override;
246     float contentsScaleMultiplierForNewTiles(const GraphicsLayer*) const override;
247 
248     bool paintsOpaquelyAtNonIntegralScales(const GraphicsLayer*) const override;
249 
250     float pageScaleFactor() const override;
251     float zoomedOutPageScaleFactor() const override;
252 
253     void didChangePlatformLayerForLayer(const GraphicsLayer*) override;
254     bool getCurrentTransform(const GraphicsLayer*, TransformationMatrix&amp;) const override;
255 
256     bool isTrackingRepaints() const override;
257     bool shouldSkipLayerInDump(const GraphicsLayer*, LayerTreeAsTextBehavior) const override;
258     bool shouldDumpPropertyForLayer(const GraphicsLayer*, const char* propertyName, LayerTreeAsTextBehavior) const override;
259 
260     bool shouldAggressivelyRetainTiles(const GraphicsLayer*) const override;
261     bool shouldTemporarilyRetainTileCohorts(const GraphicsLayer*) const override;
262     bool useGiantTiles() const override;
263     void logFilledVisibleFreshTile(unsigned) override;
</pre>
<hr />
<pre>
369     // Returns true if this layer has content that needs to be rendered by painting into the backing store.
370     bool containsPaintedContent(PaintedContentsInfo&amp;) const;
371     // Returns true if the RenderLayer just contains an image that we can composite directly.
372     bool isDirectlyCompositedImage() const;
373     void updateImageContents(PaintedContentsInfo&amp;);
374 
375     void updateDirectlyCompositedBoxDecorations(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
376     void updateDirectlyCompositedBackgroundColor(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
377     void updateDirectlyCompositedBackgroundImage(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
378 
379     void resetContentsRect();
380 
381     bool isPaintDestinationForDescendantLayers(RenderLayer::PaintedContentRequest&amp;) const;
382     bool hasVisibleNonCompositedDescendants() const;
383 
384     bool shouldClipCompositedBounds() const;
385 
386     bool hasTiledBackingFlatteningLayer() const { return (m_childContainmentLayer &amp;&amp; m_isFrameLayerWithTiledBacking); }
387     GraphicsLayer* tileCacheFlatteningLayer() const { return m_isFrameLayerWithTiledBacking ? m_childContainmentLayer.get() : nullptr; }
388 
<span class="line-modified">389     void paintIntoLayer(const GraphicsLayer*, GraphicsContext&amp;, const IntRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt;, EventRegionContext* = nullptr);</span>
<span class="line-added">390     OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlagsForLayer(const GraphicsLayer&amp;) const;</span>
391 
392     void paintDebugOverlays(const GraphicsLayer*, GraphicsContext&amp;);
393 
394     static CSSPropertyID graphicsLayerToCSSProperty(AnimatedPropertyID);
395     static AnimatedPropertyID cssToGraphicsLayerProperty(CSSPropertyID);
396 
397     bool canIssueSetNeedsDisplay() const { return !paintsIntoWindow() &amp;&amp; !paintsIntoCompositedAncestor(); }
398     LayoutRect computeParentGraphicsLayerRect(const RenderLayer* compositedAncestor) const;
<span class="line-modified">399     LayoutRect computePrimaryGraphicsLayerRect(const RenderLayer* compositedAncestor, const LayoutRect&amp; parentGraphicsLayerRect) const;</span>
400 
<span class="line-added">401 #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">402     uintptr_t m_owningLayerBearTrap { BEAR_TRAP_VALUE }; // webkit.org/b.206915</span>
<span class="line-added">403 #endif</span>
404     RenderLayer&amp; m_owningLayer;
405 
406     // A list other layers that paint into this backing store, later than m_owningLayer in paint order.
407     Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt; m_backingSharingLayers;
408 
409     std::unique_ptr&lt;LayerAncestorClippingStack&gt; m_ancestorClippingStack; // Only used if we are clipped by an ancestor which is not a stacking context.
410 
411     RefPtr&lt;GraphicsLayer&gt; m_contentsContainmentLayer; // Only used if we have a background layer; takes the transform.
412     RefPtr&lt;GraphicsLayer&gt; m_graphicsLayer;
413     RefPtr&lt;GraphicsLayer&gt; m_foregroundLayer; // Only used in cases where we need to draw the foreground separately.
414     RefPtr&lt;GraphicsLayer&gt; m_backgroundLayer; // Only used in cases where we need to draw the background separately.
415     RefPtr&lt;GraphicsLayer&gt; m_childContainmentLayer; // Only used if we have clipping on a stacking context with compositing children, or if the layer has a tile cache.
416     RefPtr&lt;GraphicsLayer&gt; m_maskLayer; // Only used if we have a mask and/or clip-path.
417     RefPtr&lt;GraphicsLayer&gt; m_childClippingMaskLayer; // Only used if we have to clip child layers or accelerated contents with border radius or clip-path.
418 
419     RefPtr&lt;GraphicsLayer&gt; m_layerForHorizontalScrollbar;
420     RefPtr&lt;GraphicsLayer&gt; m_layerForVerticalScrollbar;
421     RefPtr&lt;GraphicsLayer&gt; m_layerForScrollCorner;
422 
423     RefPtr&lt;GraphicsLayer&gt; m_scrollContainerLayer; // Only used if the layer is using composited scrolling.
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayerBacking.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerCompositor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
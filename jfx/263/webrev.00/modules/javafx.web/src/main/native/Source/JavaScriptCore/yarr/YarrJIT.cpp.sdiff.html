<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="YarrInterpreter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrJIT.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  37 #if ENABLE(YARR_JIT)
  38 
  39 namespace JSC { namespace Yarr {
  40 
  41 template&lt;YarrJITCompileMode compileMode&gt;
  42 class YarrGenerator : public YarrJITInfo, private MacroAssembler {
  43 
  44 #if CPU(ARM_THUMB2)
  45     static const RegisterID input = ARMRegisters::r0;
  46     static const RegisterID index = ARMRegisters::r1;
  47     static const RegisterID length = ARMRegisters::r2;
  48     static const RegisterID output = ARMRegisters::r3;
  49 
  50     static const RegisterID regT0 = ARMRegisters::r4;
  51     static const RegisterID regT1 = ARMRegisters::r5;
  52     static const RegisterID initialStart = ARMRegisters::r8;
  53 
  54     static const RegisterID returnRegister = ARMRegisters::r0;
  55     static const RegisterID returnRegister2 = ARMRegisters::r1;
  56 
<span class="line-removed">  57 #define HAVE_INITIAL_START_REG</span>
  58 #elif CPU(ARM64)
  59     // Argument registers
  60     static const RegisterID input = ARM64Registers::x0;
  61     static const RegisterID index = ARM64Registers::x1;
  62     static const RegisterID length = ARM64Registers::x2;
  63     static const RegisterID output = ARM64Registers::x3;
  64     static const RegisterID freelistRegister = ARM64Registers::x4;
<span class="line-modified">  65     static const RegisterID freelistSizeRegister = ARM64Registers::x5;</span>
  66 
  67     // Scratch registers
  68     static const RegisterID regT0 = ARM64Registers::x6;
  69     static const RegisterID regT1 = ARM64Registers::x7;
  70     static const RegisterID regT2 = ARM64Registers::x8;
  71     static const RegisterID remainingMatchCount = ARM64Registers::x9;
  72     static const RegisterID regUnicodeInputAndTrail = ARM64Registers::x10;

  73     static const RegisterID initialStart = ARM64Registers::x11;
  74     static const RegisterID supplementaryPlanesBase = ARM64Registers::x12;
  75     static const RegisterID leadingSurrogateTag = ARM64Registers::x13;
  76     static const RegisterID trailingSurrogateTag = ARM64Registers::x14;
  77     static const RegisterID endOfStringAddress = ARM64Registers::x15;
  78 
  79     static const RegisterID returnRegister = ARM64Registers::x0;
  80     static const RegisterID returnRegister2 = ARM64Registers::x1;
  81 
  82     const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);
<span class="line-removed">  83 #define HAVE_INITIAL_START_REG</span>
  84 #define JIT_UNICODE_EXPRESSIONS
  85 #elif CPU(MIPS)
  86     static const RegisterID input = MIPSRegisters::a0;
  87     static const RegisterID index = MIPSRegisters::a1;
  88     static const RegisterID length = MIPSRegisters::a2;
  89     static const RegisterID output = MIPSRegisters::a3;
  90 
  91     static const RegisterID regT0 = MIPSRegisters::t4;
  92     static const RegisterID regT1 = MIPSRegisters::t5;
  93     static const RegisterID initialStart = MIPSRegisters::t6;
  94 
  95     static const RegisterID returnRegister = MIPSRegisters::v0;
  96     static const RegisterID returnRegister2 = MIPSRegisters::v1;
  97 
<span class="line-removed">  98 #define HAVE_INITIAL_START_REG</span>
<span class="line-removed">  99 #elif CPU(X86)</span>
<span class="line-removed"> 100     static const RegisterID input = X86Registers::eax;</span>
<span class="line-removed"> 101     static const RegisterID index = X86Registers::edx;</span>
<span class="line-removed"> 102     static const RegisterID length = X86Registers::ecx;</span>
<span class="line-removed"> 103     static const RegisterID output = X86Registers::edi;</span>
<span class="line-removed"> 104 </span>
<span class="line-removed"> 105     static const RegisterID regT0 = X86Registers::ebx;</span>
<span class="line-removed"> 106     static const RegisterID regT1 = X86Registers::esi;</span>
<span class="line-removed"> 107 </span>
<span class="line-removed"> 108     static const RegisterID returnRegister = X86Registers::eax;</span>
<span class="line-removed"> 109     static const RegisterID returnRegister2 = X86Registers::edx;</span>
 110 #elif CPU(X86_64)
 111 #if !OS(WINDOWS)
 112     // Argument registers
 113     static const RegisterID input = X86Registers::edi;
 114     static const RegisterID index = X86Registers::esi;
 115     static const RegisterID length = X86Registers::edx;
 116     static const RegisterID output = X86Registers::ecx;
 117     static const RegisterID freelistRegister = X86Registers::r8;
 118     static const RegisterID freelistSizeRegister = X86Registers::r9; // Only used during initialization.
 119 #else
 120     // If the return value doesn&#39;t fit in 64bits, its destination is pointed by rcx and the parameters are shifted.
 121     // http://msdn.microsoft.com/en-us/library/7572ztz4.aspx
 122     COMPILE_ASSERT(sizeof(MatchResult) &gt; sizeof(void*), MatchResult_does_not_fit_in_64bits);
 123     static const RegisterID input = X86Registers::edx;
 124     static const RegisterID index = X86Registers::r8;
 125     static const RegisterID length = X86Registers::r9;
 126     static const RegisterID output = X86Registers::r10;
 127 #endif
 128 
 129     // Scratch registers
 130     static const RegisterID regT0 = X86Registers::eax;
 131 #if !OS(WINDOWS)
 132     static const RegisterID regT1 = X86Registers::r9;
 133     static const RegisterID regT2 = X86Registers::r10;
 134 #else
 135     static const RegisterID regT1 = X86Registers::ecx;
 136     static const RegisterID regT2 = X86Registers::edi;
 137 #endif
 138 
 139     static const RegisterID initialStart = X86Registers::ebx;
 140 #if !OS(WINDOWS)
 141     static const RegisterID remainingMatchCount = X86Registers::r12;
 142 #else
 143     static const RegisterID remainingMatchCount = X86Registers::esi;
 144 #endif
 145     static const RegisterID regUnicodeInputAndTrail = X86Registers::r13;
<span class="line-modified"> 146     static const RegisterID leadingSurrogateTag = X86Registers::r14;</span>
 147     static const RegisterID endOfStringAddress = X86Registers::r15;
 148 
 149     static const RegisterID returnRegister = X86Registers::eax;
 150     static const RegisterID returnRegister2 = X86Registers::edx;
 151 
 152     const TrustedImm32 supplementaryPlanesBase = TrustedImm32(0x10000);

 153     const TrustedImm32 trailingSurrogateTag = TrustedImm32(0xdc00);
 154     const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);
<span class="line-removed"> 155 #define HAVE_INITIAL_START_REG</span>
 156 #define JIT_UNICODE_EXPRESSIONS
 157 #endif
 158 
 159 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 160     struct ParenContextSizes {
 161         size_t m_numSubpatterns;
 162         size_t m_frameSlots;
 163 
 164         ParenContextSizes(size_t numSubpatterns, size_t frameSlots)
 165             : m_numSubpatterns(numSubpatterns)
 166             , m_frameSlots(frameSlots)
 167         {
 168         }
 169 
 170         size_t numSubpatterns() { return m_numSubpatterns; }
 171 
 172         size_t frameSlots() { return m_frameSlots; }
 173     };
 174 
 175     struct ParenContext {
</pre>
<hr />
<pre>
 526                 negativeCharacterOffset -= offsetAdjustAmount;
 527             }
 528         }
 529 
 530         Checked&lt;int32_t&gt; characterOffset(-static_cast&lt;int32_t&gt;(negativeCharacterOffset.unsafeGet()));
 531 
 532         if (m_charSize == Char8)
 533             return BaseIndex(input, indexReg, TimesOne, (characterOffset * static_cast&lt;int32_t&gt;(sizeof(char))).unsafeGet());
 534 
 535         return BaseIndex(input, indexReg, TimesTwo, (characterOffset * static_cast&lt;int32_t&gt;(sizeof(UChar))).unsafeGet());
 536     }
 537 
 538 #ifdef JIT_UNICODE_EXPRESSIONS
 539     void tryReadUnicodeCharImpl(RegisterID resultReg)
 540     {
 541         ASSERT(m_charSize == Char16);
 542 
 543         JumpList notUnicode;
 544 
 545         load16Unaligned(regUnicodeInputAndTrail, resultReg);
<span class="line-modified"> 546         and32(surrogateTagMask, resultReg, regT2);</span>
<span class="line-modified"> 547         notUnicode.append(branch32(NotEqual, regT2, leadingSurrogateTag));</span>




 548         addPtr(TrustedImm32(2), regUnicodeInputAndTrail);
 549         notUnicode.append(branchPtr(AboveOrEqual, regUnicodeInputAndTrail, endOfStringAddress));


 550         load16Unaligned(Address(regUnicodeInputAndTrail), regUnicodeInputAndTrail);
<span class="line-modified"> 551         and32(surrogateTagMask, regUnicodeInputAndTrail, regT2);</span>
<span class="line-modified"> 552         notUnicode.append(branch32(NotEqual, regT2, trailingSurrogateTag));</span>
<span class="line-modified"> 553         sub32(leadingSurrogateTag, resultReg);</span>
<span class="line-modified"> 554         sub32(trailingSurrogateTag, regUnicodeInputAndTrail);</span>
 555         lshift32(TrustedImm32(10), resultReg);
<span class="line-modified"> 556         or32(regUnicodeInputAndTrail, resultReg);</span>
<span class="line-removed"> 557         add32(supplementaryPlanesBase, resultReg);</span>
 558         notUnicode.link(this);
 559     }
 560 
 561     void tryReadUnicodeChar(BaseIndex address, RegisterID resultReg)
 562     {
 563         ASSERT(m_charSize == Char16);
 564 
 565         getEffectiveAddress(address, regUnicodeInputAndTrail);
 566 
 567         if (resultReg == regT0)
 568             m_tryReadUnicodeCharacterCalls.append(nearCall());
 569         else
 570             tryReadUnicodeCharImpl(resultReg);
 571     }
 572 #endif
 573 
<span class="line-removed"> 574     void readCharacterDontDecodeSurrogates(Checked&lt;unsigned&gt; negativeCharacterOffset, RegisterID resultReg, RegisterID indexReg = index)</span>
<span class="line-removed"> 575     {</span>
<span class="line-removed"> 576         BaseIndex address = negativeOffsetIndexedAddress(negativeCharacterOffset, resultReg, indexReg);</span>
<span class="line-removed"> 577 </span>
<span class="line-removed"> 578         if (m_charSize == Char8)</span>
<span class="line-removed"> 579             load8(address, resultReg);</span>
<span class="line-removed"> 580         else</span>
<span class="line-removed"> 581             load16Unaligned(address, resultReg);</span>
<span class="line-removed"> 582     }</span>
<span class="line-removed"> 583 </span>
 584     void readCharacter(Checked&lt;unsigned&gt; negativeCharacterOffset, RegisterID resultReg, RegisterID indexReg = index)
 585     {
 586         BaseIndex address = negativeOffsetIndexedAddress(negativeCharacterOffset, resultReg, indexReg);
 587 
 588         if (m_charSize == Char8)
 589             load8(address, resultReg);
 590 #ifdef JIT_UNICODE_EXPRESSIONS
 591         else if (m_decodeSurrogatePairs)
 592             tryReadUnicodeChar(address, resultReg);
 593 #endif
 594         else
 595             load16Unaligned(address, resultReg);
 596     }
 597 
 598     Jump jumpIfCharNotEquals(UChar32 ch, Checked&lt;unsigned&gt; negativeCharacterOffset, RegisterID character)
 599     {
 600         readCharacter(negativeCharacterOffset, character);
 601 
 602         // For case-insesitive compares, non-ascii characters that have different
 603         // upper &amp; lower case representations are converted to a character class.
</pre>
<hr />
<pre>
 639 
 640     void loadFromFrameAndJump(unsigned frameLocation)
 641     {
 642         farJump(Address(stackPointerRegister, frameLocation * sizeof(void*)), YarrBacktrackPtrTag);
 643     }
 644 
 645     unsigned alignCallFrameSizeInBytes(unsigned callFrameSize)
 646     {
 647         if (!callFrameSize)
 648             return 0;
 649 
 650         callFrameSize *= sizeof(void*);
 651         if (callFrameSize / sizeof(void*) != m_pattern.m_body-&gt;m_callFrameSize)
 652             CRASH();
 653         callFrameSize = (callFrameSize + 0x3f) &amp; ~0x3f;
 654         return callFrameSize;
 655     }
 656     void initCallFrame()
 657     {
 658         unsigned callFrameSizeInBytes = alignCallFrameSizeInBytes(m_pattern.m_body-&gt;m_callFrameSize);
<span class="line-modified"> 659         if (callFrameSizeInBytes) {</span>
<span class="line-modified"> 660 #if CPU(X86_64) || CPU(ARM64)</span>
<span class="line-removed"> 661             if (Options::zeroStackFrame()) {</span>
<span class="line-removed"> 662                 // We need to start from the stack pointer, because we could have spilled callee saves</span>
<span class="line-removed"> 663                 move(stackPointerRegister, regT0);</span>
<span class="line-removed"> 664                 subPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);</span>
<span class="line-removed"> 665                 if (callFrameSizeInBytes &lt;= 128) {</span>
<span class="line-removed"> 666                     for (unsigned offset = 0; offset &lt; callFrameSizeInBytes; offset += sizeof(intptr_t))</span>
<span class="line-removed"> 667                         storePtr(TrustedImm32(0), Address(regT0, -8 - offset));</span>
<span class="line-removed"> 668                 } else {</span>
<span class="line-removed"> 669                     Label zeroLoop = label();</span>
<span class="line-removed"> 670                     subPtr(TrustedImm32(sizeof(intptr_t) * 2), regT0);</span>
<span class="line-removed"> 671 #if CPU(ARM64)</span>
<span class="line-removed"> 672                     storePair64(ARM64Registers::zr, ARM64Registers::zr, regT0);</span>
<span class="line-removed"> 673 #else</span>
<span class="line-removed"> 674                     storePtr(TrustedImm32(0), Address(regT0));</span>
<span class="line-removed"> 675                     storePtr(TrustedImm32(0), Address(regT0, sizeof(intptr_t)));</span>
<span class="line-removed"> 676 #endif</span>
<span class="line-removed"> 677                     branchPtr(NotEqual, regT0, stackPointerRegister).linkTo(zeroLoop, this);</span>
<span class="line-removed"> 678                 }</span>
<span class="line-removed"> 679             } else</span>
<span class="line-removed"> 680 #endif</span>
<span class="line-removed"> 681                 subPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);</span>
<span class="line-removed"> 682 </span>
<span class="line-removed"> 683         }</span>
 684     }
 685     void removeCallFrame()
 686     {
 687         unsigned callFrameSizeInBytes = alignCallFrameSizeInBytes(m_pattern.m_body-&gt;m_callFrameSize);
 688         if (callFrameSizeInBytes)
 689             addPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);
 690     }
 691 
 692     void generateFailReturn()
 693     {
 694         move(TrustedImmPtr((void*)WTF::notFound), returnRegister);
 695         move(TrustedImm32(0), returnRegister2);
 696         generateReturn();
 697     }
 698 
 699     void generateJITFailReturn()
 700     {
 701         if (m_abortExecution.empty() &amp;&amp; m_hitMatchLimit.empty())
 702             return;
 703 
</pre>
<hr />
<pre>
1133 
1134         op.m_jumps.append(wordCharThenWordChar);
1135 
1136         nonWordCharThenWordChar.link(this);
1137         wordCharThenNonWordChar.link(this);
1138     }
1139     void backtrackAssertionWordBoundary(size_t opIndex)
1140     {
1141         backtrackTermDefault(opIndex);
1142     }
1143 
1144 #if ENABLE(YARR_JIT_BACKREFERENCES)
1145     void matchBackreference(size_t opIndex, JumpList&amp; characterMatchFails, RegisterID character, RegisterID patternIndex, RegisterID patternCharacter)
1146     {
1147         YarrOp&amp; op = m_ops[opIndex];
1148         PatternTerm* term = op.m_term;
1149         unsigned subpatternId = term-&gt;backReferenceSubpatternId;
1150 
1151         Label loop(this);
1152 
<span class="line-modified">1153         readCharacterDontDecodeSurrogates(0, patternCharacter, patternIndex);</span>
<span class="line-modified">1154         readCharacterDontDecodeSurrogates(m_checkedOffset - term-&gt;inputPosition, character);</span>
1155 
1156         if (!m_pattern.ignoreCase())
1157             characterMatchFails.append(branch32(NotEqual, character, patternCharacter));
1158         else {
1159             Jump charactersMatch = branch32(Equal, character, patternCharacter);
1160             ExtendedAddress characterTableEntry(character, reinterpret_cast&lt;intptr_t&gt;(&amp;canonicalTableLChar));
1161             load16(characterTableEntry, character);
1162             ExtendedAddress patternTableEntry(patternCharacter, reinterpret_cast&lt;intptr_t&gt;(&amp;canonicalTableLChar));
1163             load16(patternTableEntry, patternCharacter);
1164             characterMatchFails.append(branch32(NotEqual, character, patternCharacter));
1165             charactersMatch.link(this);
1166         }
1167 
<span class="line-removed">1168 </span>
1169         add32(TrustedImm32(1), index);
1170         add32(TrustedImm32(1), patternIndex);
1171 







1172         branch32(NotEqual, patternIndex, Address(output, ((subpatternId &lt;&lt; 1) + 1) * sizeof(int))).linkTo(loop, this);
1173     }
1174 
1175     void generateBackReference(size_t opIndex)
1176     {
1177         YarrOp&amp; op = m_ops[opIndex];
1178         PatternTerm* term = op.m_term;
1179 
1180         if (m_pattern.ignoreCase() &amp;&amp; m_charSize != Char8) {
1181             m_failureReason = JITFailureReason::BackReference;
1182             return;
1183         }
1184 
1185         unsigned subpatternId = term-&gt;backReferenceSubpatternId;
1186         unsigned parenthesesFrameLocation = term-&gt;frameLocation;
1187 
1188         const RegisterID characterOrTemp = regT0;
1189         const RegisterID patternIndex = regT1;
1190         const RegisterID patternTemp = regT2;
1191 
</pre>
<hr />
<pre>
2014         add32(TrustedImm32(1), countRegister);
2015 
2016         jump(op.m_reentry);
2017 
2018         if (!nonGreedyFailuresDecrementIndex.empty()) {
2019             nonGreedyFailuresDecrementIndex.link(this);
2020             breakpoint();
2021         }
2022         nonGreedyFailures.link(this);
2023         sub32(countRegister, index);
2024         m_backtrackingState.fallthrough();
2025     }
2026 
2027     void generateDotStarEnclosure(size_t opIndex)
2028     {
2029         YarrOp&amp; op = m_ops[opIndex];
2030         PatternTerm* term = op.m_term;
2031 
2032         const RegisterID character = regT0;
2033         const RegisterID matchPos = regT1;
<span class="line-removed">2034 #ifndef HAVE_INITIAL_START_REG</span>
<span class="line-removed">2035         const RegisterID initialStart = character;</span>
<span class="line-removed">2036 #endif</span>
<span class="line-removed">2037 </span>
2038         JumpList foundBeginningNewLine;
2039         JumpList saveStartIndex;
2040         JumpList foundEndingNewLine;
2041 
2042         if (m_pattern.dotAll()) {
2043             move(TrustedImm32(0), matchPos);
2044             setMatchStart(matchPos);
2045             move(length, index);
2046             return;
2047         }
2048 
2049         ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
2050         getMatchStart(matchPos);
2051 
<span class="line-removed">2052 #ifndef HAVE_INITIAL_START_REG</span>
<span class="line-removed">2053         loadFromFrame(m_pattern.m_initialStartValueFrameLocation, initialStart);</span>
<span class="line-removed">2054 #endif</span>
2055         saveStartIndex.append(branch32(BelowOrEqual, matchPos, initialStart));
2056         Label findBOLLoop(this);
2057         sub32(TrustedImm32(1), matchPos);
2058         if (m_charSize == Char8)
2059             load8(BaseIndex(input, matchPos, TimesOne, 0), character);
2060         else
2061             load16(BaseIndex(input, matchPos, TimesTwo, 0), character);
2062         matchCharacterClass(character, foundBeginningNewLine, m_pattern.newlineCharacterClass());
2063 
<span class="line-removed">2064 #ifndef HAVE_INITIAL_START_REG</span>
<span class="line-removed">2065         loadFromFrame(m_pattern.m_initialStartValueFrameLocation, initialStart);</span>
<span class="line-removed">2066 #endif</span>
2067         branch32(Above, matchPos, initialStart).linkTo(findBOLLoop, this);
2068         saveStartIndex.append(jump());
2069 
2070         foundBeginningNewLine.link(this);
2071         add32(TrustedImm32(1), matchPos); // Advance past newline
2072         saveStartIndex.link(this);
2073 
2074         if (!m_pattern.multiline() &amp;&amp; term-&gt;anchors.bolAnchor)
2075             op.m_jumps.append(branchTest32(NonZero, matchPos));
2076 
2077         ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
2078         setMatchStart(matchPos);
2079 
2080         move(index, matchPos);
2081 
2082         Label findEOLLoop(this);
2083         foundEndingNewLine.append(branch32(Equal, matchPos, length));
2084         if (m_charSize == Char8)
2085             load8(BaseIndex(input, matchPos, TimesOne, 0), character);
2086         else
</pre>
<hr />
<pre>
3734 
3735         if (m_pattern.m_saveInitialStartValue)
3736             push(X86Registers::ebx);
3737 
3738 #if OS(WINDOWS)
3739         push(X86Registers::edi);
3740 #endif
3741 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3742         if (m_containsNestedSubpatterns) {
3743 #if OS(WINDOWS)
3744             push(X86Registers::esi);
3745 #endif
3746             push(X86Registers::r12);
3747         }
3748 #endif
3749 
3750         if (m_decodeSurrogatePairs) {
3751             push(X86Registers::r13);
3752             push(X86Registers::r14);
3753             push(X86Registers::r15);
<span class="line-removed">3754 </span>
<span class="line-removed">3755             move(TrustedImm32(0xd800), leadingSurrogateTag);</span>
3756         }
3757         // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
3758         zeroExtend32ToPtr(index, index);
3759         zeroExtend32ToPtr(length, length);
3760 #if OS(WINDOWS)
3761         if (compileMode == IncludeSubpatterns)
3762             loadPtr(Address(X86Registers::ebp, 6 * sizeof(void*)), output);
3763         // rcx is the pointer to the allocated space for result in x64 Windows.
3764         push(X86Registers::ecx);
3765 #endif
<span class="line-removed">3766 #elif CPU(X86)</span>
<span class="line-removed">3767         push(X86Registers::ebp);</span>
<span class="line-removed">3768         move(stackPointerRegister, X86Registers::ebp);</span>
<span class="line-removed">3769         // TODO: do we need spill registers to fill the output pointer if there are no sub captures?</span>
<span class="line-removed">3770         push(X86Registers::ebx);</span>
<span class="line-removed">3771         push(X86Registers::edi);</span>
<span class="line-removed">3772         push(X86Registers::esi);</span>
<span class="line-removed">3773         // load output into edi (2 = saved ebp + return address).</span>
<span class="line-removed">3774     #if COMPILER(MSVC)</span>
<span class="line-removed">3775         loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), input);</span>
<span class="line-removed">3776         loadPtr(Address(X86Registers::ebp, 3 * sizeof(void*)), index);</span>
<span class="line-removed">3777         loadPtr(Address(X86Registers::ebp, 4 * sizeof(void*)), length);</span>
<span class="line-removed">3778         if (compileMode == IncludeSubpatterns)</span>
<span class="line-removed">3779             loadPtr(Address(X86Registers::ebp, 5 * sizeof(void*)), output);</span>
<span class="line-removed">3780     #else</span>
<span class="line-removed">3781         if (compileMode == IncludeSubpatterns)</span>
<span class="line-removed">3782             loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), output);</span>
<span class="line-removed">3783     #endif</span>
3784 #elif CPU(ARM64)
3785         tagReturnAddress();
3786         if (m_decodeSurrogatePairs) {
3787             pushPair(framePointerRegister, linkRegister);
3788             move(TrustedImm32(0x10000), supplementaryPlanesBase);
3789             move(TrustedImm32(0xd800), leadingSurrogateTag);
3790             move(TrustedImm32(0xdc00), trailingSurrogateTag);
3791         }
3792 
3793         // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
3794         zeroExtend32ToPtr(index, index);
3795         zeroExtend32ToPtr(length, length);
3796 #elif CPU(ARM_THUMB2)
3797         push(ARMRegisters::r4);
3798         push(ARMRegisters::r5);
3799         push(ARMRegisters::r6);
3800         push(ARMRegisters::r8);
3801 #elif CPU(MIPS)
3802         // Do nothing.
3803 #endif
</pre>
<hr />
<pre>
3821             pop(X86Registers::r15);
3822             pop(X86Registers::r14);
3823             pop(X86Registers::r13);
3824         }
3825 
3826 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3827         if (m_containsNestedSubpatterns) {
3828             pop(X86Registers::r12);
3829 #if OS(WINDOWS)
3830             pop(X86Registers::esi);
3831 #endif
3832         }
3833 #endif
3834 #if OS(WINDOWS)
3835         pop(X86Registers::edi);
3836 #endif
3837 
3838         if (m_pattern.m_saveInitialStartValue)
3839             pop(X86Registers::ebx);
3840         pop(X86Registers::ebp);
<span class="line-removed">3841 #elif CPU(X86)</span>
<span class="line-removed">3842         pop(X86Registers::esi);</span>
<span class="line-removed">3843         pop(X86Registers::edi);</span>
<span class="line-removed">3844         pop(X86Registers::ebx);</span>
<span class="line-removed">3845         pop(X86Registers::ebp);</span>
3846 #elif CPU(ARM64)
3847         if (m_decodeSurrogatePairs)
3848             popPair(framePointerRegister, linkRegister);
3849 #elif CPU(ARM_THUMB2)
3850         pop(ARMRegisters::r8);
3851         pop(ARMRegisters::r6);
3852         pop(ARMRegisters::r5);
3853         pop(ARMRegisters::r4);
3854 #elif CPU(MIPS)
3855         // Do nothing
3856 #endif
3857         ret();
3858     }
3859 
3860 public:
3861     YarrGenerator(VM* vm, YarrPattern&amp; pattern, String&amp; patternString, YarrCodeBlock&amp; codeBlock, YarrCharSize charSize)
3862         : m_vm(vm)
3863         , m_pattern(pattern)
3864         , m_patternString(patternString)
3865         , m_codeBlock(codeBlock)
</pre>
<hr />
<pre>
3934         if (compileMode == IncludeSubpatterns) {
3935             for (unsigned i = 0; i &lt; m_pattern.m_numSubpatterns + 1; ++i)
3936                 store32(TrustedImm32(-1), Address(output, (i &lt;&lt; 1) * sizeof(int)));
3937         }
3938 
3939         if (!m_pattern.m_body-&gt;m_hasFixedSize)
3940             setMatchStart(index);
3941 
3942         initCallFrame();
3943 
3944 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3945         if (m_containsNestedSubpatterns) {
3946             initParenContextFreeList();
3947             if (m_failureReason) {
3948                 codeBlock.setFallBackWithFailureReason(*m_failureReason);
3949                 return;
3950             }
3951         }
3952 #endif
3953 
<span class="line-modified">3954         if (m_pattern.m_saveInitialStartValue) {</span>
<span class="line-removed">3955 #ifdef HAVE_INITIAL_START_REG</span>
3956             move(index, initialStart);
<span class="line-removed">3957 #else</span>
<span class="line-removed">3958             storeToFrame(index, m_pattern.m_initialStartValueFrameLocation);</span>
<span class="line-removed">3959 #endif</span>
<span class="line-removed">3960         }</span>
3961 
3962         generate();
3963         if (m_disassembler)
3964             m_disassembler-&gt;setEndOfGenerate(label());
3965         backtrack();
3966         if (m_disassembler)
3967             m_disassembler-&gt;setEndOfBacktrack(label());
3968 
3969         generateTryReadUnicodeCharacterHelper();
3970 
3971         generateJITFailReturn();
3972 
3973         if (m_disassembler)
3974             m_disassembler-&gt;setEndOfCode(label());
3975 
3976         LinkBuffer linkBuffer(*this, REGEXP_CODE_ID, JITCompilationCanFail);
3977         if (linkBuffer.didFailToAllocate()) {
3978             codeBlock.setFallBackWithFailureReason(JITFailureReason::ExecutableMemoryAllocationFailure);
3979             return;
3980         }
</pre>
<hr />
<pre>
4278     case JITFailureReason::FixedCountParenthesizedSubpattern:
4279         dataLog(&quot;Can&#39;t JIT a pattern containing fixed count parenthesized subpatterns\n&quot;);
4280         break;
4281     case JITFailureReason::ParenthesisNestedTooDeep:
4282         dataLog(&quot;Can&#39;t JIT pattern due to parentheses nested too deeply\n&quot;);
4283         break;
4284     case JITFailureReason::ExecutableMemoryAllocationFailure:
4285         dataLog(&quot;Can&#39;t JIT because of failure of allocation of executable memory\n&quot;);
4286         break;
4287     }
4288 }
4289 
4290 void jitCompile(YarrPattern&amp; pattern, String&amp; patternString, YarrCharSize charSize, VM* vm, YarrCodeBlock&amp; codeBlock, YarrJITCompileMode mode)
4291 {
4292     if (mode == MatchOnly)
4293         YarrGenerator&lt;MatchOnly&gt;(vm, pattern, patternString, codeBlock, charSize).compile();
4294     else
4295         YarrGenerator&lt;IncludeSubpatterns&gt;(vm, pattern, patternString, codeBlock, charSize).compile();
4296 
4297     if (auto failureReason = codeBlock.failureReason()) {
<span class="line-modified">4298         if (Options::dumpCompiledRegExpPatterns()) {</span>
4299             pattern.dumpPatternString(WTF::dataFile(), patternString);
4300             dataLog(&quot; : &quot;);
4301             dumpCompileFailure(*failureReason);
4302         }
4303     }
4304 }
4305 
4306 }}
4307 
4308 #endif
</pre>
</td>
<td>
<hr />
<pre>
  37 #if ENABLE(YARR_JIT)
  38 
  39 namespace JSC { namespace Yarr {
  40 
  41 template&lt;YarrJITCompileMode compileMode&gt;
  42 class YarrGenerator : public YarrJITInfo, private MacroAssembler {
  43 
  44 #if CPU(ARM_THUMB2)
  45     static const RegisterID input = ARMRegisters::r0;
  46     static const RegisterID index = ARMRegisters::r1;
  47     static const RegisterID length = ARMRegisters::r2;
  48     static const RegisterID output = ARMRegisters::r3;
  49 
  50     static const RegisterID regT0 = ARMRegisters::r4;
  51     static const RegisterID regT1 = ARMRegisters::r5;
  52     static const RegisterID initialStart = ARMRegisters::r8;
  53 
  54     static const RegisterID returnRegister = ARMRegisters::r0;
  55     static const RegisterID returnRegister2 = ARMRegisters::r1;
  56 

  57 #elif CPU(ARM64)
  58     // Argument registers
  59     static const RegisterID input = ARM64Registers::x0;
  60     static const RegisterID index = ARM64Registers::x1;
  61     static const RegisterID length = ARM64Registers::x2;
  62     static const RegisterID output = ARM64Registers::x3;
  63     static const RegisterID freelistRegister = ARM64Registers::x4;
<span class="line-modified">  64     static const RegisterID freelistSizeRegister = ARM64Registers::x5; // Only used during initialization.</span>
  65 
  66     // Scratch registers
  67     static const RegisterID regT0 = ARM64Registers::x6;
  68     static const RegisterID regT1 = ARM64Registers::x7;
  69     static const RegisterID regT2 = ARM64Registers::x8;
  70     static const RegisterID remainingMatchCount = ARM64Registers::x9;
  71     static const RegisterID regUnicodeInputAndTrail = ARM64Registers::x10;
<span class="line-added">  72     static const RegisterID unicodeTemp = ARM64Registers::x5;</span>
  73     static const RegisterID initialStart = ARM64Registers::x11;
  74     static const RegisterID supplementaryPlanesBase = ARM64Registers::x12;
  75     static const RegisterID leadingSurrogateTag = ARM64Registers::x13;
  76     static const RegisterID trailingSurrogateTag = ARM64Registers::x14;
  77     static const RegisterID endOfStringAddress = ARM64Registers::x15;
  78 
  79     static const RegisterID returnRegister = ARM64Registers::x0;
  80     static const RegisterID returnRegister2 = ARM64Registers::x1;
  81 
  82     const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);

  83 #define JIT_UNICODE_EXPRESSIONS
  84 #elif CPU(MIPS)
  85     static const RegisterID input = MIPSRegisters::a0;
  86     static const RegisterID index = MIPSRegisters::a1;
  87     static const RegisterID length = MIPSRegisters::a2;
  88     static const RegisterID output = MIPSRegisters::a3;
  89 
  90     static const RegisterID regT0 = MIPSRegisters::t4;
  91     static const RegisterID regT1 = MIPSRegisters::t5;
  92     static const RegisterID initialStart = MIPSRegisters::t6;
  93 
  94     static const RegisterID returnRegister = MIPSRegisters::v0;
  95     static const RegisterID returnRegister2 = MIPSRegisters::v1;
  96 












  97 #elif CPU(X86_64)
  98 #if !OS(WINDOWS)
  99     // Argument registers
 100     static const RegisterID input = X86Registers::edi;
 101     static const RegisterID index = X86Registers::esi;
 102     static const RegisterID length = X86Registers::edx;
 103     static const RegisterID output = X86Registers::ecx;
 104     static const RegisterID freelistRegister = X86Registers::r8;
 105     static const RegisterID freelistSizeRegister = X86Registers::r9; // Only used during initialization.
 106 #else
 107     // If the return value doesn&#39;t fit in 64bits, its destination is pointed by rcx and the parameters are shifted.
 108     // http://msdn.microsoft.com/en-us/library/7572ztz4.aspx
 109     COMPILE_ASSERT(sizeof(MatchResult) &gt; sizeof(void*), MatchResult_does_not_fit_in_64bits);
 110     static const RegisterID input = X86Registers::edx;
 111     static const RegisterID index = X86Registers::r8;
 112     static const RegisterID length = X86Registers::r9;
 113     static const RegisterID output = X86Registers::r10;
 114 #endif
 115 
 116     // Scratch registers
 117     static const RegisterID regT0 = X86Registers::eax;
 118 #if !OS(WINDOWS)
 119     static const RegisterID regT1 = X86Registers::r9;
 120     static const RegisterID regT2 = X86Registers::r10;
 121 #else
 122     static const RegisterID regT1 = X86Registers::ecx;
 123     static const RegisterID regT2 = X86Registers::edi;
 124 #endif
 125 
 126     static const RegisterID initialStart = X86Registers::ebx;
 127 #if !OS(WINDOWS)
 128     static const RegisterID remainingMatchCount = X86Registers::r12;
 129 #else
 130     static const RegisterID remainingMatchCount = X86Registers::esi;
 131 #endif
 132     static const RegisterID regUnicodeInputAndTrail = X86Registers::r13;
<span class="line-modified"> 133     static const RegisterID unicodeTemp = X86Registers::r14;</span>
 134     static const RegisterID endOfStringAddress = X86Registers::r15;
 135 
 136     static const RegisterID returnRegister = X86Registers::eax;
 137     static const RegisterID returnRegister2 = X86Registers::edx;
 138 
 139     const TrustedImm32 supplementaryPlanesBase = TrustedImm32(0x10000);
<span class="line-added"> 140     const TrustedImm32 leadingSurrogateTag = TrustedImm32(0xd800);</span>
 141     const TrustedImm32 trailingSurrogateTag = TrustedImm32(0xdc00);
 142     const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);

 143 #define JIT_UNICODE_EXPRESSIONS
 144 #endif
 145 
 146 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 147     struct ParenContextSizes {
 148         size_t m_numSubpatterns;
 149         size_t m_frameSlots;
 150 
 151         ParenContextSizes(size_t numSubpatterns, size_t frameSlots)
 152             : m_numSubpatterns(numSubpatterns)
 153             , m_frameSlots(frameSlots)
 154         {
 155         }
 156 
 157         size_t numSubpatterns() { return m_numSubpatterns; }
 158 
 159         size_t frameSlots() { return m_frameSlots; }
 160     };
 161 
 162     struct ParenContext {
</pre>
<hr />
<pre>
 513                 negativeCharacterOffset -= offsetAdjustAmount;
 514             }
 515         }
 516 
 517         Checked&lt;int32_t&gt; characterOffset(-static_cast&lt;int32_t&gt;(negativeCharacterOffset.unsafeGet()));
 518 
 519         if (m_charSize == Char8)
 520             return BaseIndex(input, indexReg, TimesOne, (characterOffset * static_cast&lt;int32_t&gt;(sizeof(char))).unsafeGet());
 521 
 522         return BaseIndex(input, indexReg, TimesTwo, (characterOffset * static_cast&lt;int32_t&gt;(sizeof(UChar))).unsafeGet());
 523     }
 524 
 525 #ifdef JIT_UNICODE_EXPRESSIONS
 526     void tryReadUnicodeCharImpl(RegisterID resultReg)
 527     {
 528         ASSERT(m_charSize == Char16);
 529 
 530         JumpList notUnicode;
 531 
 532         load16Unaligned(regUnicodeInputAndTrail, resultReg);
<span class="line-modified"> 533 </span>
<span class="line-modified"> 534         // Is the character a leading surrogate?</span>
<span class="line-added"> 535         and32(surrogateTagMask, resultReg, unicodeTemp);</span>
<span class="line-added"> 536         notUnicode.append(branch32(NotEqual, unicodeTemp, leadingSurrogateTag));</span>
<span class="line-added"> 537 </span>
<span class="line-added"> 538         // Is the input long enough to read a trailing surrogate?</span>
 539         addPtr(TrustedImm32(2), regUnicodeInputAndTrail);
 540         notUnicode.append(branchPtr(AboveOrEqual, regUnicodeInputAndTrail, endOfStringAddress));
<span class="line-added"> 541 </span>
<span class="line-added"> 542         // Is the character a trailing surrogate?</span>
 543         load16Unaligned(Address(regUnicodeInputAndTrail), regUnicodeInputAndTrail);
<span class="line-modified"> 544         and32(surrogateTagMask, regUnicodeInputAndTrail, unicodeTemp);</span>
<span class="line-modified"> 545         notUnicode.append(branch32(NotEqual, unicodeTemp, trailingSurrogateTag));</span>
<span class="line-modified"> 546 </span>
<span class="line-modified"> 547         // Combine leading and trailing surrogates to produce a code point.</span>
 548         lshift32(TrustedImm32(10), resultReg);
<span class="line-modified"> 549         getEffectiveAddress(BaseIndex(resultReg, regUnicodeInputAndTrail, TimesOne, -U16_SURROGATE_OFFSET), resultReg);</span>

 550         notUnicode.link(this);
 551     }
 552 
 553     void tryReadUnicodeChar(BaseIndex address, RegisterID resultReg)
 554     {
 555         ASSERT(m_charSize == Char16);
 556 
 557         getEffectiveAddress(address, regUnicodeInputAndTrail);
 558 
 559         if (resultReg == regT0)
 560             m_tryReadUnicodeCharacterCalls.append(nearCall());
 561         else
 562             tryReadUnicodeCharImpl(resultReg);
 563     }
 564 #endif
 565 










 566     void readCharacter(Checked&lt;unsigned&gt; negativeCharacterOffset, RegisterID resultReg, RegisterID indexReg = index)
 567     {
 568         BaseIndex address = negativeOffsetIndexedAddress(negativeCharacterOffset, resultReg, indexReg);
 569 
 570         if (m_charSize == Char8)
 571             load8(address, resultReg);
 572 #ifdef JIT_UNICODE_EXPRESSIONS
 573         else if (m_decodeSurrogatePairs)
 574             tryReadUnicodeChar(address, resultReg);
 575 #endif
 576         else
 577             load16Unaligned(address, resultReg);
 578     }
 579 
 580     Jump jumpIfCharNotEquals(UChar32 ch, Checked&lt;unsigned&gt; negativeCharacterOffset, RegisterID character)
 581     {
 582         readCharacter(negativeCharacterOffset, character);
 583 
 584         // For case-insesitive compares, non-ascii characters that have different
 585         // upper &amp; lower case representations are converted to a character class.
</pre>
<hr />
<pre>
 621 
 622     void loadFromFrameAndJump(unsigned frameLocation)
 623     {
 624         farJump(Address(stackPointerRegister, frameLocation * sizeof(void*)), YarrBacktrackPtrTag);
 625     }
 626 
 627     unsigned alignCallFrameSizeInBytes(unsigned callFrameSize)
 628     {
 629         if (!callFrameSize)
 630             return 0;
 631 
 632         callFrameSize *= sizeof(void*);
 633         if (callFrameSize / sizeof(void*) != m_pattern.m_body-&gt;m_callFrameSize)
 634             CRASH();
 635         callFrameSize = (callFrameSize + 0x3f) &amp; ~0x3f;
 636         return callFrameSize;
 637     }
 638     void initCallFrame()
 639     {
 640         unsigned callFrameSizeInBytes = alignCallFrameSizeInBytes(m_pattern.m_body-&gt;m_callFrameSize);
<span class="line-modified"> 641         if (callFrameSizeInBytes)</span>
<span class="line-modified"> 642             subPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);</span>























 643     }
 644     void removeCallFrame()
 645     {
 646         unsigned callFrameSizeInBytes = alignCallFrameSizeInBytes(m_pattern.m_body-&gt;m_callFrameSize);
 647         if (callFrameSizeInBytes)
 648             addPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);
 649     }
 650 
 651     void generateFailReturn()
 652     {
 653         move(TrustedImmPtr((void*)WTF::notFound), returnRegister);
 654         move(TrustedImm32(0), returnRegister2);
 655         generateReturn();
 656     }
 657 
 658     void generateJITFailReturn()
 659     {
 660         if (m_abortExecution.empty() &amp;&amp; m_hitMatchLimit.empty())
 661             return;
 662 
</pre>
<hr />
<pre>
1092 
1093         op.m_jumps.append(wordCharThenWordChar);
1094 
1095         nonWordCharThenWordChar.link(this);
1096         wordCharThenNonWordChar.link(this);
1097     }
1098     void backtrackAssertionWordBoundary(size_t opIndex)
1099     {
1100         backtrackTermDefault(opIndex);
1101     }
1102 
1103 #if ENABLE(YARR_JIT_BACKREFERENCES)
1104     void matchBackreference(size_t opIndex, JumpList&amp; characterMatchFails, RegisterID character, RegisterID patternIndex, RegisterID patternCharacter)
1105     {
1106         YarrOp&amp; op = m_ops[opIndex];
1107         PatternTerm* term = op.m_term;
1108         unsigned subpatternId = term-&gt;backReferenceSubpatternId;
1109 
1110         Label loop(this);
1111 
<span class="line-modified">1112         readCharacter(0, patternCharacter, patternIndex);</span>
<span class="line-modified">1113         readCharacter(m_checkedOffset - term-&gt;inputPosition, character);</span>
1114 
1115         if (!m_pattern.ignoreCase())
1116             characterMatchFails.append(branch32(NotEqual, character, patternCharacter));
1117         else {
1118             Jump charactersMatch = branch32(Equal, character, patternCharacter);
1119             ExtendedAddress characterTableEntry(character, reinterpret_cast&lt;intptr_t&gt;(&amp;canonicalTableLChar));
1120             load16(characterTableEntry, character);
1121             ExtendedAddress patternTableEntry(patternCharacter, reinterpret_cast&lt;intptr_t&gt;(&amp;canonicalTableLChar));
1122             load16(patternTableEntry, patternCharacter);
1123             characterMatchFails.append(branch32(NotEqual, character, patternCharacter));
1124             charactersMatch.link(this);
1125         }
1126 

1127         add32(TrustedImm32(1), index);
1128         add32(TrustedImm32(1), patternIndex);
1129 
<span class="line-added">1130         if (m_decodeSurrogatePairs) {</span>
<span class="line-added">1131             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-added">1132             add32(TrustedImm32(1), index);</span>
<span class="line-added">1133             add32(TrustedImm32(1), patternIndex);</span>
<span class="line-added">1134             isBMPChar.link(this);</span>
<span class="line-added">1135         }</span>
<span class="line-added">1136 </span>
1137         branch32(NotEqual, patternIndex, Address(output, ((subpatternId &lt;&lt; 1) + 1) * sizeof(int))).linkTo(loop, this);
1138     }
1139 
1140     void generateBackReference(size_t opIndex)
1141     {
1142         YarrOp&amp; op = m_ops[opIndex];
1143         PatternTerm* term = op.m_term;
1144 
1145         if (m_pattern.ignoreCase() &amp;&amp; m_charSize != Char8) {
1146             m_failureReason = JITFailureReason::BackReference;
1147             return;
1148         }
1149 
1150         unsigned subpatternId = term-&gt;backReferenceSubpatternId;
1151         unsigned parenthesesFrameLocation = term-&gt;frameLocation;
1152 
1153         const RegisterID characterOrTemp = regT0;
1154         const RegisterID patternIndex = regT1;
1155         const RegisterID patternTemp = regT2;
1156 
</pre>
<hr />
<pre>
1979         add32(TrustedImm32(1), countRegister);
1980 
1981         jump(op.m_reentry);
1982 
1983         if (!nonGreedyFailuresDecrementIndex.empty()) {
1984             nonGreedyFailuresDecrementIndex.link(this);
1985             breakpoint();
1986         }
1987         nonGreedyFailures.link(this);
1988         sub32(countRegister, index);
1989         m_backtrackingState.fallthrough();
1990     }
1991 
1992     void generateDotStarEnclosure(size_t opIndex)
1993     {
1994         YarrOp&amp; op = m_ops[opIndex];
1995         PatternTerm* term = op.m_term;
1996 
1997         const RegisterID character = regT0;
1998         const RegisterID matchPos = regT1;




1999         JumpList foundBeginningNewLine;
2000         JumpList saveStartIndex;
2001         JumpList foundEndingNewLine;
2002 
2003         if (m_pattern.dotAll()) {
2004             move(TrustedImm32(0), matchPos);
2005             setMatchStart(matchPos);
2006             move(length, index);
2007             return;
2008         }
2009 
2010         ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
2011         getMatchStart(matchPos);
2012 



2013         saveStartIndex.append(branch32(BelowOrEqual, matchPos, initialStart));
2014         Label findBOLLoop(this);
2015         sub32(TrustedImm32(1), matchPos);
2016         if (m_charSize == Char8)
2017             load8(BaseIndex(input, matchPos, TimesOne, 0), character);
2018         else
2019             load16(BaseIndex(input, matchPos, TimesTwo, 0), character);
2020         matchCharacterClass(character, foundBeginningNewLine, m_pattern.newlineCharacterClass());
2021 



2022         branch32(Above, matchPos, initialStart).linkTo(findBOLLoop, this);
2023         saveStartIndex.append(jump());
2024 
2025         foundBeginningNewLine.link(this);
2026         add32(TrustedImm32(1), matchPos); // Advance past newline
2027         saveStartIndex.link(this);
2028 
2029         if (!m_pattern.multiline() &amp;&amp; term-&gt;anchors.bolAnchor)
2030             op.m_jumps.append(branchTest32(NonZero, matchPos));
2031 
2032         ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
2033         setMatchStart(matchPos);
2034 
2035         move(index, matchPos);
2036 
2037         Label findEOLLoop(this);
2038         foundEndingNewLine.append(branch32(Equal, matchPos, length));
2039         if (m_charSize == Char8)
2040             load8(BaseIndex(input, matchPos, TimesOne, 0), character);
2041         else
</pre>
<hr />
<pre>
3689 
3690         if (m_pattern.m_saveInitialStartValue)
3691             push(X86Registers::ebx);
3692 
3693 #if OS(WINDOWS)
3694         push(X86Registers::edi);
3695 #endif
3696 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3697         if (m_containsNestedSubpatterns) {
3698 #if OS(WINDOWS)
3699             push(X86Registers::esi);
3700 #endif
3701             push(X86Registers::r12);
3702         }
3703 #endif
3704 
3705         if (m_decodeSurrogatePairs) {
3706             push(X86Registers::r13);
3707             push(X86Registers::r14);
3708             push(X86Registers::r15);


3709         }
3710         // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
3711         zeroExtend32ToPtr(index, index);
3712         zeroExtend32ToPtr(length, length);
3713 #if OS(WINDOWS)
3714         if (compileMode == IncludeSubpatterns)
3715             loadPtr(Address(X86Registers::ebp, 6 * sizeof(void*)), output);
3716         // rcx is the pointer to the allocated space for result in x64 Windows.
3717         push(X86Registers::ecx);
3718 #endif


















3719 #elif CPU(ARM64)
3720         tagReturnAddress();
3721         if (m_decodeSurrogatePairs) {
3722             pushPair(framePointerRegister, linkRegister);
3723             move(TrustedImm32(0x10000), supplementaryPlanesBase);
3724             move(TrustedImm32(0xd800), leadingSurrogateTag);
3725             move(TrustedImm32(0xdc00), trailingSurrogateTag);
3726         }
3727 
3728         // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
3729         zeroExtend32ToPtr(index, index);
3730         zeroExtend32ToPtr(length, length);
3731 #elif CPU(ARM_THUMB2)
3732         push(ARMRegisters::r4);
3733         push(ARMRegisters::r5);
3734         push(ARMRegisters::r6);
3735         push(ARMRegisters::r8);
3736 #elif CPU(MIPS)
3737         // Do nothing.
3738 #endif
</pre>
<hr />
<pre>
3756             pop(X86Registers::r15);
3757             pop(X86Registers::r14);
3758             pop(X86Registers::r13);
3759         }
3760 
3761 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3762         if (m_containsNestedSubpatterns) {
3763             pop(X86Registers::r12);
3764 #if OS(WINDOWS)
3765             pop(X86Registers::esi);
3766 #endif
3767         }
3768 #endif
3769 #if OS(WINDOWS)
3770         pop(X86Registers::edi);
3771 #endif
3772 
3773         if (m_pattern.m_saveInitialStartValue)
3774             pop(X86Registers::ebx);
3775         pop(X86Registers::ebp);





3776 #elif CPU(ARM64)
3777         if (m_decodeSurrogatePairs)
3778             popPair(framePointerRegister, linkRegister);
3779 #elif CPU(ARM_THUMB2)
3780         pop(ARMRegisters::r8);
3781         pop(ARMRegisters::r6);
3782         pop(ARMRegisters::r5);
3783         pop(ARMRegisters::r4);
3784 #elif CPU(MIPS)
3785         // Do nothing
3786 #endif
3787         ret();
3788     }
3789 
3790 public:
3791     YarrGenerator(VM* vm, YarrPattern&amp; pattern, String&amp; patternString, YarrCodeBlock&amp; codeBlock, YarrCharSize charSize)
3792         : m_vm(vm)
3793         , m_pattern(pattern)
3794         , m_patternString(patternString)
3795         , m_codeBlock(codeBlock)
</pre>
<hr />
<pre>
3864         if (compileMode == IncludeSubpatterns) {
3865             for (unsigned i = 0; i &lt; m_pattern.m_numSubpatterns + 1; ++i)
3866                 store32(TrustedImm32(-1), Address(output, (i &lt;&lt; 1) * sizeof(int)));
3867         }
3868 
3869         if (!m_pattern.m_body-&gt;m_hasFixedSize)
3870             setMatchStart(index);
3871 
3872         initCallFrame();
3873 
3874 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3875         if (m_containsNestedSubpatterns) {
3876             initParenContextFreeList();
3877             if (m_failureReason) {
3878                 codeBlock.setFallBackWithFailureReason(*m_failureReason);
3879                 return;
3880             }
3881         }
3882 #endif
3883 
<span class="line-modified">3884         if (m_pattern.m_saveInitialStartValue)</span>

3885             move(index, initialStart);




3886 
3887         generate();
3888         if (m_disassembler)
3889             m_disassembler-&gt;setEndOfGenerate(label());
3890         backtrack();
3891         if (m_disassembler)
3892             m_disassembler-&gt;setEndOfBacktrack(label());
3893 
3894         generateTryReadUnicodeCharacterHelper();
3895 
3896         generateJITFailReturn();
3897 
3898         if (m_disassembler)
3899             m_disassembler-&gt;setEndOfCode(label());
3900 
3901         LinkBuffer linkBuffer(*this, REGEXP_CODE_ID, JITCompilationCanFail);
3902         if (linkBuffer.didFailToAllocate()) {
3903             codeBlock.setFallBackWithFailureReason(JITFailureReason::ExecutableMemoryAllocationFailure);
3904             return;
3905         }
</pre>
<hr />
<pre>
4203     case JITFailureReason::FixedCountParenthesizedSubpattern:
4204         dataLog(&quot;Can&#39;t JIT a pattern containing fixed count parenthesized subpatterns\n&quot;);
4205         break;
4206     case JITFailureReason::ParenthesisNestedTooDeep:
4207         dataLog(&quot;Can&#39;t JIT pattern due to parentheses nested too deeply\n&quot;);
4208         break;
4209     case JITFailureReason::ExecutableMemoryAllocationFailure:
4210         dataLog(&quot;Can&#39;t JIT because of failure of allocation of executable memory\n&quot;);
4211         break;
4212     }
4213 }
4214 
4215 void jitCompile(YarrPattern&amp; pattern, String&amp; patternString, YarrCharSize charSize, VM* vm, YarrCodeBlock&amp; codeBlock, YarrJITCompileMode mode)
4216 {
4217     if (mode == MatchOnly)
4218         YarrGenerator&lt;MatchOnly&gt;(vm, pattern, patternString, codeBlock, charSize).compile();
4219     else
4220         YarrGenerator&lt;IncludeSubpatterns&gt;(vm, pattern, patternString, codeBlock, charSize).compile();
4221 
4222     if (auto failureReason = codeBlock.failureReason()) {
<span class="line-modified">4223         if (UNLIKELY(Options::dumpCompiledRegExpPatterns())) {</span>
4224             pattern.dumpPatternString(WTF::dataFile(), patternString);
4225             dataLog(&quot; : &quot;);
4226             dumpCompileFailure(*failureReason);
4227         }
4228     }
4229 }
4230 
4231 }}
4232 
4233 #endif
</pre>
</td>
</tr>
</table>
<center><a href="YarrInterpreter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrJIT.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
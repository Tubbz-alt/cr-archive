<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  3  *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Lesser General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Lesser General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Lesser General Public
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &lt;wtf/StackBounds.h&gt;
 23 
 24 #include &lt;mutex&gt;
 25 #include &lt;wtf/NoTailCalls.h&gt;
 26 
 27 #if OS(DARWIN)
 28 
 29 #include &lt;mach/task.h&gt;
 30 #include &lt;mach/thread_act.h&gt;
 31 #include &lt;pthread.h&gt;
 32 
 33 #elif OS(WINDOWS)
 34 
 35 #include &lt;windows.h&gt;
 36 
 37 #elif OS(UNIX)
 38 
 39 #include &lt;pthread.h&gt;
 40 #if HAVE(PTHREAD_NP_H)
 41 #include &lt;pthread_np.h&gt;
 42 #endif
 43 
 44 #endif
 45 
 46 namespace WTF {
 47 
 48 #if PLATFORM(JAVA)
 49 // 16K is a safe value to guard java stack red zone
 50 #define JAVA_RED_ZONE 0x4000
 51 #endif
 52 
 53 #if OS(DARWIN)
 54 
 55 StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
 56 {
 57     void* origin = pthread_get_stackaddr_np(thread);
 58     rlim_t size = pthread_get_stacksize_np(thread);
 59     void* bound = static_cast&lt;char*&gt;(origin) - size;
 60     return StackBounds { origin, bound };
 61 }
 62 
 63 StackBounds StackBounds::currentThreadStackBoundsInternal()
 64 {
 65     if (pthread_main_np()) {
 66         // FIXME: &lt;rdar://problem/13741204&gt;
 67         // pthread_get_size lies to us when we&#39;re the main thread, use get_rlimit instead
 68         void* origin = pthread_get_stackaddr_np(pthread_self());
 69         rlimit limit;
 70         getrlimit(RLIMIT_STACK, &amp;limit);
 71         rlim_t size = limit.rlim_cur;
 72         void* bound = static_cast&lt;char*&gt;(origin) - size;
 73 #if PLATFORM(JAVA)
 74         bound = static_cast&lt;char*&gt;(bound) + JAVA_RED_ZONE;
 75 #endif
 76         return StackBounds { origin, bound };
 77     }
 78     return newThreadStackBounds(pthread_self());
 79 }
 80 
 81 #elif OS(UNIX)
 82 
 83 #if OS(OPENBSD)
 84 
 85 StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
 86 {
 87     stack_t stack;
 88     pthread_stackseg_np(thread, &amp;stack);
 89     void* origin = stack.ss_sp;
 90     void* bound = static_cast&lt;char*&gt;(origin) - stack.ss_size;
 91     return StackBounds { origin, bound };
 92 }
 93 
 94 #else // !OS(OPENBSD)
 95 
 96 StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
 97 {
 98     void* bound = nullptr;
 99     size_t stackSize = 0;
100 
101     pthread_attr_t sattr;
102     pthread_attr_init(&amp;sattr);
103 #if HAVE(PTHREAD_NP_H) || OS(NETBSD)
104     // e.g. on FreeBSD 5.4, neundorf@kde.org
105     pthread_attr_get_np(thread, &amp;sattr);
106 #else
107     // FIXME: this function is non-portable; other POSIX systems may have different np alternatives
108     pthread_getattr_np(thread, &amp;sattr);
109 #endif
110     int rc = pthread_attr_getstack(&amp;sattr, &amp;bound, &amp;stackSize);
111     UNUSED_PARAM(rc);
112     ASSERT(bound);
113     pthread_attr_destroy(&amp;sattr);
114     void* origin = static_cast&lt;char*&gt;(bound) + stackSize;
115 #if PLATFORM(JAVA)
116     bound = static_cast&lt;char*&gt;(bound) + JAVA_RED_ZONE;
117 #endif
118     // pthread_attr_getstack&#39;s bound is the lowest accessible pointer of the stack.
119     return StackBounds { origin, bound };
120 }
121 
122 #endif // OS(OPENBSD)
123 
124 StackBounds StackBounds::currentThreadStackBoundsInternal()
125 {
126     return newThreadStackBounds(pthread_self());
127 }
128 
129 #elif OS(WINDOWS)
130 
131 StackBounds StackBounds::currentThreadStackBoundsInternal()
132 {
133     MEMORY_BASIC_INFORMATION stackOrigin { };
134     VirtualQuery(&amp;stackOrigin, &amp;stackOrigin, sizeof(stackOrigin));
135     // stackOrigin.AllocationBase points to the reserved stack memory base address.
136 
137     const LPVOID theAllocBase = stackOrigin.AllocationBase;
138     void* origin = static_cast&lt;char*&gt;(stackOrigin.BaseAddress) + stackOrigin.RegionSize;
139 
140     // The stack on Windows consists out of three parts (uncommitted memory, a guard page and present
141     // committed memory). The 3 regions have different BaseAddresses but all have the same AllocationBase
142     // since they are all from the same VirtualAlloc. The 3 regions are laid out in memory (from high to
143     // low) as follows:
144     //
145     //    High |-------------------|  -----
146     //         | committedMemory   |    ^
147     //         |-------------------|    |
148     //         | guardPage         | reserved memory for the stack
149     //         |-------------------|    |
150     //         | uncommittedMemory |    v
151     //    Low  |-------------------|  ----- &lt;--- stackOrigin.AllocationBase
152     //
153     // See http://msdn.microsoft.com/en-us/library/ms686774%28VS.85%29.aspx for more information.
154 
155     // look for uncommited memory block.
156     MEMORY_BASIC_INFORMATION uncommittedMemory;
157     LPVOID a = stackOrigin.AllocationBase;
158 
159     do {
160         size_t ret = VirtualQuery(a, &amp;uncommittedMemory, sizeof(uncommittedMemory));
161         ASSERT(ret != 0);
162         a = (LPVOID)((static_cast&lt;char*&gt;(a)) + uncommittedMemory.RegionSize);
163     } while (theAllocBase == uncommittedMemory.AllocationBase &amp;&amp;
164         uncommittedMemory.State != MEM_RESERVE);
165 
166     MEMORY_BASIC_INFORMATION guardPage;
167     VirtualQuery(static_cast&lt;char*&gt;(uncommittedMemory.BaseAddress) + uncommittedMemory.RegionSize, &amp;guardPage, sizeof(guardPage));
168     ASSERT(guardPage.Protect &amp; PAGE_GUARD);
169 
170     void* endOfStack = stackOrigin.AllocationBase;
171 
172 #ifndef NDEBUG
173     MEMORY_BASIC_INFORMATION committedMemory;
174     VirtualQuery(static_cast&lt;char*&gt;(guardPage.BaseAddress) + guardPage.RegionSize, &amp;committedMemory, sizeof(committedMemory));
175     ASSERT(committedMemory.State == MEM_COMMIT);
176 
177     void* computedEnd = static_cast&lt;char*&gt;(origin) - (uncommittedMemory.RegionSize + guardPage.RegionSize + committedMemory.RegionSize);
178 
179     ASSERT(stackOrigin.AllocationBase == uncommittedMemory.AllocationBase);
180     ASSERT(stackOrigin.AllocationBase == guardPage.AllocationBase);
181     ASSERT(stackOrigin.AllocationBase == committedMemory.AllocationBase);
182 #if !PLATFORM(JAVA)
183     ASSERT(stackOrigin.AllocationBase == uncommittedMemory.BaseAddress);
184     ASSERT(endOfStack == computedEnd);
185 #endif
186 #endif // NDEBUG
187     void* bound = static_cast&lt;char*&gt;(endOfStack) + guardPage.RegionSize;
188 #if PLATFORM(JAVA)
189     bound = static_cast&lt;char*&gt;(bound) + JAVA_RED_ZONE;
190 #endif
191     return StackBounds { origin, bound };
192 }
193 
194 #else
195 #error Need a way to get the stack bounds on this platform
196 #endif
197 
198 } // namespace WTF
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/loader/CrossOriginAccessControl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CookieJar.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CrossOriginAccessControl.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/CrossOriginAccessControl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,13 ***</span>
  
  #include &quot;CachedResourceRequest.h&quot;
  #include &quot;CrossOriginPreflightResultCache.h&quot;
  #include &quot;HTTPHeaderNames.h&quot;
  #include &quot;HTTPParsers.h&quot;
  #include &quot;ResourceRequest.h&quot;
  #include &quot;ResourceResponse.h&quot;
<span class="line-removed">- #include &quot;SchemeRegistry.h&quot;</span>
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;SecurityPolicy.h&quot;
  #include &lt;mutex&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/text/AtomString.h&gt;
<span class="line-new-header">--- 29,13 ---</span>
  
  #include &quot;CachedResourceRequest.h&quot;
  #include &quot;CrossOriginPreflightResultCache.h&quot;
  #include &quot;HTTPHeaderNames.h&quot;
  #include &quot;HTTPParsers.h&quot;
<span class="line-added">+ #include &quot;LegacySchemeRegistry.h&quot;</span>
  #include &quot;ResourceRequest.h&quot;
  #include &quot;ResourceResponse.h&quot;
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;SecurityPolicy.h&quot;
  #include &lt;mutex&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/text/AtomString.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,54 ***</span>
      }
  
      return preflightRequest;
  }
  
<span class="line-modified">! CachedResourceRequest createPotentialAccessControlRequest(ResourceRequest&amp;&amp; request, Document&amp; document, const String&amp; crossOriginAttribute, ResourceLoaderOptions&amp;&amp; options)</span>
  {
<span class="line-modified">!     // FIXME: This does not match the algorithm &quot;create a potential-CORS request&quot;:</span>
<span class="line-modified">!     // &lt;https://html.spec.whatwg.org/multipage/urls-and-fetching.html#create-a-potential-cors-request&gt; (31 August 2018).</span>
<span class="line-modified">!     auto cachedRequest = CachedResourceRequest { WTFMove(request), WTFMove(options) };</span>
<span class="line-modified">!     cachedRequest.deprecatedSetAsPotentiallyCrossOrigin(crossOriginAttribute, document);</span>
      return cachedRequest;
  }
  
<span class="line-modified">! bool isValidCrossOriginRedirectionURL(const URL&amp; redirectURL)</span>
  {
<span class="line-modified">!     return SchemeRegistry::shouldTreatURLSchemeAsCORSEnabled(redirectURL.protocol().toStringWithoutCopying())</span>
<span class="line-modified">!         &amp;&amp; redirectURL.user().isEmpty()</span>
<span class="line-modified">!         &amp;&amp; redirectURL.pass().isEmpty();</span>
  }
  
<span class="line-modified">! HTTPHeaderNameSet httpHeadersToKeepFromCleaning(const HTTPHeaderMap&amp; headers)</span>
  {
<span class="line-modified">!     HTTPHeaderNameSet headersToKeep;</span>
      if (headers.contains(HTTPHeaderName::ContentType))
<span class="line-modified">!         headersToKeep.add(HTTPHeaderName::ContentType);</span>
      if (headers.contains(HTTPHeaderName::Referer))
<span class="line-modified">!         headersToKeep.add(HTTPHeaderName::Referer);</span>
      if (headers.contains(HTTPHeaderName::Origin))
<span class="line-modified">!         headersToKeep.add(HTTPHeaderName::Origin);</span>
      if (headers.contains(HTTPHeaderName::UserAgent))
<span class="line-modified">!         headersToKeep.add(HTTPHeaderName::UserAgent);</span>
      if (headers.contains(HTTPHeaderName::AcceptEncoding))
<span class="line-modified">!         headersToKeep.add(HTTPHeaderName::AcceptEncoding);</span>
      return headersToKeep;
  }
  
<span class="line-modified">! void cleanHTTPRequestHeadersForAccessControl(ResourceRequest&amp; request, const HashSet&lt;HTTPHeaderName, WTF::IntHash&lt;HTTPHeaderName&gt;, WTF::StrongEnumHashTraits&lt;HTTPHeaderName&gt;&gt;&amp; headersToKeep)</span>
  {
      // Remove headers that may have been added by the network layer that cause access control to fail.
<span class="line-modified">!     if (!headersToKeep.contains(HTTPHeaderName::ContentType) &amp;&amp; !isCrossOriginSafeRequestHeader(HTTPHeaderName::ContentType, request.httpContentType()))</span>
<span class="line-modified">!         request.clearHTTPContentType();</span>
<span class="line-modified">!     if (!headersToKeep.contains(HTTPHeaderName::Referer))</span>
          request.clearHTTPReferrer();
<span class="line-modified">!     if (!headersToKeep.contains(HTTPHeaderName::Origin))</span>
          request.clearHTTPOrigin();
<span class="line-modified">!     if (!headersToKeep.contains(HTTPHeaderName::UserAgent))</span>
          request.clearHTTPUserAgent();
<span class="line-modified">!     if (!headersToKeep.contains(HTTPHeaderName::AcceptEncoding))</span>
          request.clearHTTPAcceptEncoding();
  }
  
  bool passesAccessControlCheck(const ResourceResponse&amp; response, StoredCredentialsPolicy storedCredentialsPolicy, SecurityOrigin&amp; securityOrigin, String&amp; errorDescription)
  {
<span class="line-new-header">--- 116,87 ---</span>
      }
  
      return preflightRequest;
  }
  
<span class="line-modified">! // https://html.spec.whatwg.org/multipage/urls-and-fetching.html#create-a-potential-cors-request</span>
<span class="line-added">+ CachedResourceRequest createPotentialAccessControlRequest(ResourceRequest&amp;&amp; request, ResourceLoaderOptions&amp;&amp; options, Document&amp; document, const String&amp; crossOriginAttribute, SameOriginFlag sameOriginFlag)</span>
  {
<span class="line-modified">!     ASSERT(options.mode == FetchOptions::Mode::NoCors);</span>
<span class="line-modified">!     if (!crossOriginAttribute.isNull())</span>
<span class="line-modified">!         options.mode = FetchOptions::Mode::Cors;</span>
<span class="line-modified">!     else if (sameOriginFlag == SameOriginFlag::Yes)</span>
<span class="line-added">+         options.mode = FetchOptions::Mode::SameOrigin;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (crossOriginAttribute.isNull()) {</span>
<span class="line-added">+         CachedResourceRequest cachedRequest { WTFMove(request), WTFMove(options) };</span>
<span class="line-added">+         cachedRequest.setOrigin(document.securityOrigin());</span>
<span class="line-added">+         return cachedRequest;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     FetchOptions::Credentials credentials = equalLettersIgnoringASCIICase(crossOriginAttribute, &quot;omit&quot;)</span>
<span class="line-added">+         ? FetchOptions::Credentials::Omit : equalLettersIgnoringASCIICase(crossOriginAttribute, &quot;use-credentials&quot;)</span>
<span class="line-added">+         ? FetchOptions::Credentials::Include : FetchOptions::Credentials::SameOrigin;</span>
<span class="line-added">+     options.credentials = credentials;</span>
<span class="line-added">+     switch (credentials) {</span>
<span class="line-added">+     case FetchOptions::Credentials::Include:</span>
<span class="line-added">+         options.storedCredentialsPolicy = StoredCredentialsPolicy::Use;</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case FetchOptions::Credentials::SameOrigin:</span>
<span class="line-added">+         options.storedCredentialsPolicy = document.securityOrigin().canRequest(request.url()) ? StoredCredentialsPolicy::Use : StoredCredentialsPolicy::DoNotUse;</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case FetchOptions::Credentials::Omit:</span>
<span class="line-added">+         options.storedCredentialsPolicy = StoredCredentialsPolicy::DoNotUse;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     CachedResourceRequest cachedRequest { WTFMove(request), WTFMove(options) };</span>
<span class="line-added">+     updateRequestForAccessControl(cachedRequest.resourceRequest(), document.securityOrigin(), options.storedCredentialsPolicy);</span>
      return cachedRequest;
  }
  
<span class="line-modified">! String validateCrossOriginRedirectionURL(const URL&amp; redirectURL)</span>
  {
<span class="line-modified">!     if (!LegacySchemeRegistry::shouldTreatURLSchemeAsCORSEnabled(redirectURL.protocol().toStringWithoutCopying()))</span>
<span class="line-modified">!         return makeString(&quot;not allowed to follow a cross-origin CORS redirection with non CORS scheme&quot;);</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (redirectURL.hasUsername() || redirectURL.hasPassword())</span>
<span class="line-added">+         return makeString(&quot;redirection URL &quot;, redirectURL.string(), &quot; has credentials&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return { };</span>
  }
  
<span class="line-modified">! OptionSet&lt;HTTPHeadersToKeepFromCleaning&gt; httpHeadersToKeepFromCleaning(const HTTPHeaderMap&amp; headers)</span>
  {
<span class="line-modified">!     OptionSet&lt;HTTPHeadersToKeepFromCleaning&gt; headersToKeep;</span>
      if (headers.contains(HTTPHeaderName::ContentType))
<span class="line-modified">!         headersToKeep.add(HTTPHeadersToKeepFromCleaning::ContentType);</span>
      if (headers.contains(HTTPHeaderName::Referer))
<span class="line-modified">!         headersToKeep.add(HTTPHeadersToKeepFromCleaning::Referer);</span>
      if (headers.contains(HTTPHeaderName::Origin))
<span class="line-modified">!         headersToKeep.add(HTTPHeadersToKeepFromCleaning::Origin);</span>
      if (headers.contains(HTTPHeaderName::UserAgent))
<span class="line-modified">!         headersToKeep.add(HTTPHeadersToKeepFromCleaning::UserAgent);</span>
      if (headers.contains(HTTPHeaderName::AcceptEncoding))
<span class="line-modified">!         headersToKeep.add(HTTPHeadersToKeepFromCleaning::AcceptEncoding);</span>
      return headersToKeep;
  }
  
<span class="line-modified">! void cleanHTTPRequestHeadersForAccessControl(ResourceRequest&amp; request, OptionSet&lt;HTTPHeadersToKeepFromCleaning&gt; headersToKeep)</span>
  {
      // Remove headers that may have been added by the network layer that cause access control to fail.
<span class="line-modified">!     if (!headersToKeep.contains(HTTPHeadersToKeepFromCleaning::ContentType)) {</span>
<span class="line-modified">!         auto contentType = request.httpContentType();</span>
<span class="line-modified">!         if (!contentType.isNull() &amp;&amp; !isCrossOriginSafeRequestHeader(HTTPHeaderName::ContentType, contentType))</span>
<span class="line-added">+             request.clearHTTPContentType();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (!headersToKeep.contains(HTTPHeadersToKeepFromCleaning::Referer))</span>
          request.clearHTTPReferrer();
<span class="line-modified">!     if (!headersToKeep.contains(HTTPHeadersToKeepFromCleaning::Origin))</span>
          request.clearHTTPOrigin();
<span class="line-modified">!     if (!headersToKeep.contains(HTTPHeadersToKeepFromCleaning::UserAgent))</span>
          request.clearHTTPUserAgent();
<span class="line-modified">!     if (!headersToKeep.contains(HTTPHeadersToKeepFromCleaning::AcceptEncoding))</span>
          request.clearHTTPAcceptEncoding();
  }
  
  bool passesAccessControlCheck(const ResourceResponse&amp; response, StoredCredentialsPolicy storedCredentialsPolicy, SecurityOrigin&amp; securityOrigin, String&amp; errorDescription)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,6 ***</span>
<span class="line-new-header">--- 278,13 ---</span>
      if (shouldCrossOriginResourcePolicyCancelLoad(origin, response))
          return ResourceError { errorDomainWebKitInternal, 0, requestURL, makeString(&quot;Cancelled load to &quot;, response.url().stringCenterEllipsizedToLength(), &quot; because it violates the resource&#39;s Cross-Origin-Resource-Policy response header.&quot;), ResourceError::Type::AccessControl };
      return WTF::nullopt;
  }
  
<span class="line-added">+ Optional&lt;ResourceError&gt; validateRangeRequestedFlag(const ResourceRequest&amp; request, const ResourceResponse&amp; response)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (response.isRangeRequested() &amp;&amp; response.httpStatusCode() == 206 &amp;&amp; response.type() == ResourceResponse::Type::Opaque &amp;&amp; !request.hasHTTPHeaderField(HTTPHeaderName::Range))</span>
<span class="line-added">+         return ResourceError({ }, 0, response.url(), { }, ResourceError::Type::General);</span>
<span class="line-added">+     return WTF::nullopt;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace WebCore
</pre>
<center><a href="CookieJar.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CrossOriginAccessControl.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
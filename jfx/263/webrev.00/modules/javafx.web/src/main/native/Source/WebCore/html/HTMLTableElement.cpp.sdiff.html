<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTableElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLTableCellElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLTableRowsCollection.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTableElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
294     else if (equalLettersIgnoringASCIICase(value, &quot;vsides&quot;))
295         borderLeft = borderRight = true;
296     else if (equalLettersIgnoringASCIICase(value, &quot;lhs&quot;))
297         borderLeft = true;
298     else if (equalLettersIgnoringASCIICase(value, &quot;rhs&quot;))
299         borderRight = true;
300     else if (equalLettersIgnoringASCIICase(value, &quot;box&quot;) || equalLettersIgnoringASCIICase(value, &quot;border&quot;))
301         borderTop = borderBottom = borderLeft = borderRight = true;
302     else if (!equalLettersIgnoringASCIICase(value, &quot;void&quot;))
303         return false;
304     return true;
305 }
306 
307 void HTMLTableElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
308 {
309     if (name == widthAttr)
310         addHTMLLengthToStyle(style, CSSPropertyWidth, value);
311     else if (name == heightAttr)
312         addHTMLLengthToStyle(style, CSSPropertyHeight, value);
313     else if (name == borderAttr)
<span class="line-modified">314         addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderWidth, parseBorderWidthAttribute(value), CSSPrimitiveValue::CSS_PX);</span>
315     else if (name == bordercolorAttr) {
316         if (!value.isEmpty())
317             addHTMLColorToStyle(style, CSSPropertyBorderColor, value);
318     } else if (name == bgcolorAttr)
319         addHTMLColorToStyle(style, CSSPropertyBackgroundColor, value);
320     else if (name == backgroundAttr) {
321         String url = stripLeadingAndTrailingHTMLSpaces(value);
322         if (!url.isEmpty())
323             style.setProperty(CSSProperty(CSSPropertyBackgroundImage, CSSImageValue::create(document().completeURL(url), LoadedFromOpaqueSource::No)));
324     } else if (name == valignAttr) {
325         if (!value.isEmpty())
326             addPropertyToPresentationAttributeStyle(style, CSSPropertyVerticalAlign, value);
327     } else if (name == cellspacingAttr) {
328         if (!value.isEmpty())
329             addHTMLLengthToStyle(style, CSSPropertyBorderSpacing, value);
330     } else if (name == vspaceAttr) {
331         addHTMLLengthToStyle(style, CSSPropertyMarginTop, value);
332         addHTMLLengthToStyle(style, CSSPropertyMarginBottom, value);
333     } else if (name == hspaceAttr) {
334         addHTMLLengthToStyle(style, CSSPropertyMarginLeft, value);
</pre>
<hr />
<pre>
477 {
478     auto style = MutableStyleProperties::create();
479 
480     auto&amp; cssValuePool = CSSValuePool::singleton();
481     switch (cellBorders()) {
482     case SolidBordersColsOnly:
483         style-&gt;setProperty(CSSPropertyBorderLeftWidth, CSSValueThin);
484         style-&gt;setProperty(CSSPropertyBorderRightWidth, CSSValueThin);
485         style-&gt;setProperty(CSSPropertyBorderLeftStyle, CSSValueSolid);
486         style-&gt;setProperty(CSSPropertyBorderRightStyle, CSSValueSolid);
487         style-&gt;setProperty(CSSPropertyBorderColor, cssValuePool.createInheritedValue());
488         break;
489     case SolidBordersRowsOnly:
490         style-&gt;setProperty(CSSPropertyBorderTopWidth, CSSValueThin);
491         style-&gt;setProperty(CSSPropertyBorderBottomWidth, CSSValueThin);
492         style-&gt;setProperty(CSSPropertyBorderTopStyle, CSSValueSolid);
493         style-&gt;setProperty(CSSPropertyBorderBottomStyle, CSSValueSolid);
494         style-&gt;setProperty(CSSPropertyBorderColor, cssValuePool.createInheritedValue());
495         break;
496     case SolidBorders:
<span class="line-modified">497         style-&gt;setProperty(CSSPropertyBorderWidth, cssValuePool.createValue(1, CSSPrimitiveValue::CSS_PX));</span>
498         style-&gt;setProperty(CSSPropertyBorderStyle, cssValuePool.createIdentifierValue(CSSValueSolid));
499         style-&gt;setProperty(CSSPropertyBorderColor, cssValuePool.createInheritedValue());
500         break;
501     case InsetBorders:
<span class="line-modified">502         style-&gt;setProperty(CSSPropertyBorderWidth, cssValuePool.createValue(1, CSSPrimitiveValue::CSS_PX));</span>
503         style-&gt;setProperty(CSSPropertyBorderStyle, cssValuePool.createIdentifierValue(CSSValueInset));
504         style-&gt;setProperty(CSSPropertyBorderColor, cssValuePool.createInheritedValue());
505         break;
506     case NoBorders:
507         // If &#39;rules=none&#39; then allow any borders set at cell level to take effect.
508         break;
509     }
510 
511     if (m_padding)
<span class="line-modified">512         style-&gt;setProperty(CSSPropertyPadding, cssValuePool.createValue(m_padding, CSSPrimitiveValue::CSS_PX));</span>
513 
514     return style;
515 }
516 
517 const StyleProperties* HTMLTableElement::additionalCellStyle()
518 {
519     if (!m_sharedCellStyle)
520         m_sharedCellStyle = createSharedCellStyle();
521     return m_sharedCellStyle.get();
522 }
523 
524 static StyleProperties* leakGroupBorderStyle(int rows)
525 {
526     auto style = MutableStyleProperties::create();
527     if (rows) {
528         style-&gt;setProperty(CSSPropertyBorderTopWidth, CSSValueThin);
529         style-&gt;setProperty(CSSPropertyBorderBottomWidth, CSSValueThin);
530         style-&gt;setProperty(CSSPropertyBorderTopStyle, CSSValueSolid);
531         style-&gt;setProperty(CSSPropertyBorderBottomStyle, CSSValueSolid);
532     } else {
</pre>
</td>
<td>
<hr />
<pre>
294     else if (equalLettersIgnoringASCIICase(value, &quot;vsides&quot;))
295         borderLeft = borderRight = true;
296     else if (equalLettersIgnoringASCIICase(value, &quot;lhs&quot;))
297         borderLeft = true;
298     else if (equalLettersIgnoringASCIICase(value, &quot;rhs&quot;))
299         borderRight = true;
300     else if (equalLettersIgnoringASCIICase(value, &quot;box&quot;) || equalLettersIgnoringASCIICase(value, &quot;border&quot;))
301         borderTop = borderBottom = borderLeft = borderRight = true;
302     else if (!equalLettersIgnoringASCIICase(value, &quot;void&quot;))
303         return false;
304     return true;
305 }
306 
307 void HTMLTableElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
308 {
309     if (name == widthAttr)
310         addHTMLLengthToStyle(style, CSSPropertyWidth, value);
311     else if (name == heightAttr)
312         addHTMLLengthToStyle(style, CSSPropertyHeight, value);
313     else if (name == borderAttr)
<span class="line-modified">314         addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderWidth, parseBorderWidthAttribute(value), CSSUnitType::CSS_PX);</span>
315     else if (name == bordercolorAttr) {
316         if (!value.isEmpty())
317             addHTMLColorToStyle(style, CSSPropertyBorderColor, value);
318     } else if (name == bgcolorAttr)
319         addHTMLColorToStyle(style, CSSPropertyBackgroundColor, value);
320     else if (name == backgroundAttr) {
321         String url = stripLeadingAndTrailingHTMLSpaces(value);
322         if (!url.isEmpty())
323             style.setProperty(CSSProperty(CSSPropertyBackgroundImage, CSSImageValue::create(document().completeURL(url), LoadedFromOpaqueSource::No)));
324     } else if (name == valignAttr) {
325         if (!value.isEmpty())
326             addPropertyToPresentationAttributeStyle(style, CSSPropertyVerticalAlign, value);
327     } else if (name == cellspacingAttr) {
328         if (!value.isEmpty())
329             addHTMLLengthToStyle(style, CSSPropertyBorderSpacing, value);
330     } else if (name == vspaceAttr) {
331         addHTMLLengthToStyle(style, CSSPropertyMarginTop, value);
332         addHTMLLengthToStyle(style, CSSPropertyMarginBottom, value);
333     } else if (name == hspaceAttr) {
334         addHTMLLengthToStyle(style, CSSPropertyMarginLeft, value);
</pre>
<hr />
<pre>
477 {
478     auto style = MutableStyleProperties::create();
479 
480     auto&amp; cssValuePool = CSSValuePool::singleton();
481     switch (cellBorders()) {
482     case SolidBordersColsOnly:
483         style-&gt;setProperty(CSSPropertyBorderLeftWidth, CSSValueThin);
484         style-&gt;setProperty(CSSPropertyBorderRightWidth, CSSValueThin);
485         style-&gt;setProperty(CSSPropertyBorderLeftStyle, CSSValueSolid);
486         style-&gt;setProperty(CSSPropertyBorderRightStyle, CSSValueSolid);
487         style-&gt;setProperty(CSSPropertyBorderColor, cssValuePool.createInheritedValue());
488         break;
489     case SolidBordersRowsOnly:
490         style-&gt;setProperty(CSSPropertyBorderTopWidth, CSSValueThin);
491         style-&gt;setProperty(CSSPropertyBorderBottomWidth, CSSValueThin);
492         style-&gt;setProperty(CSSPropertyBorderTopStyle, CSSValueSolid);
493         style-&gt;setProperty(CSSPropertyBorderBottomStyle, CSSValueSolid);
494         style-&gt;setProperty(CSSPropertyBorderColor, cssValuePool.createInheritedValue());
495         break;
496     case SolidBorders:
<span class="line-modified">497         style-&gt;setProperty(CSSPropertyBorderWidth, cssValuePool.createValue(1, CSSUnitType::CSS_PX));</span>
498         style-&gt;setProperty(CSSPropertyBorderStyle, cssValuePool.createIdentifierValue(CSSValueSolid));
499         style-&gt;setProperty(CSSPropertyBorderColor, cssValuePool.createInheritedValue());
500         break;
501     case InsetBorders:
<span class="line-modified">502         style-&gt;setProperty(CSSPropertyBorderWidth, cssValuePool.createValue(1, CSSUnitType::CSS_PX));</span>
503         style-&gt;setProperty(CSSPropertyBorderStyle, cssValuePool.createIdentifierValue(CSSValueInset));
504         style-&gt;setProperty(CSSPropertyBorderColor, cssValuePool.createInheritedValue());
505         break;
506     case NoBorders:
507         // If &#39;rules=none&#39; then allow any borders set at cell level to take effect.
508         break;
509     }
510 
511     if (m_padding)
<span class="line-modified">512         style-&gt;setProperty(CSSPropertyPadding, cssValuePool.createValue(m_padding, CSSUnitType::CSS_PX));</span>
513 
514     return style;
515 }
516 
517 const StyleProperties* HTMLTableElement::additionalCellStyle()
518 {
519     if (!m_sharedCellStyle)
520         m_sharedCellStyle = createSharedCellStyle();
521     return m_sharedCellStyle.get();
522 }
523 
524 static StyleProperties* leakGroupBorderStyle(int rows)
525 {
526     auto style = MutableStyleProperties::create();
527     if (rows) {
528         style-&gt;setProperty(CSSPropertyBorderTopWidth, CSSValueThin);
529         style-&gt;setProperty(CSSPropertyBorderBottomWidth, CSSValueThin);
530         style-&gt;setProperty(CSSPropertyBorderTopStyle, CSSValueSolid);
531         style-&gt;setProperty(CSSPropertyBorderBottomStyle, CSSValueSolid);
532     } else {
</pre>
</td>
</tr>
</table>
<center><a href="HTMLTableCellElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLTableRowsCollection.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
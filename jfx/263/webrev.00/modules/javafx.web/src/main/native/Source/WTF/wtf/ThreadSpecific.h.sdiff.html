<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/ThreadSpecific.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ThreadSafeRefCounted.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Threading.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/ThreadSpecific.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 83             // needs to access the value, to avoid recursion.
 84             owner-&gt;setInTLS(this);
 85             new (NotNull, storagePointer()) T();
 86         }
 87 
 88         ~Data()
 89         {
 90             storagePointer()-&gt;~T();
 91             owner-&gt;setInTLS(nullptr);
 92         }
 93 
 94         PointerType storagePointer() const { return const_cast&lt;PointerType&gt;(reinterpret_cast&lt;const T*&gt;(&amp;m_storage)); }
 95 
 96         typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_storage;
 97         ThreadSpecific&lt;T, canBeGCThread&gt;* owner;
 98     };
 99 
100     T* get();
101     T* set();
102     void setInTLS(Data*);
<span class="line-modified">103     void static THREAD_SPECIFIC_CALL destroy(void* ptr);</span>
104 
105 #if USE(PTHREADS)
106     pthread_key_t m_key { };
107 #elif OS(WINDOWS)
<span class="line-modified">108     int m_index;</span>
109 #endif
110 };
111 
112 #if USE(PTHREADS)
113 
114 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
115 inline ThreadSpecific&lt;T, canBeGCThread&gt;::ThreadSpecific()
116 {
117     int error = pthread_key_create(&amp;m_key, destroy);
118     if (error)
119         CRASH();
120 }
121 
122 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
123 inline T* ThreadSpecific&lt;T, canBeGCThread&gt;::get()
124 {
125     Data* data = static_cast&lt;Data*&gt;(pthread_getspecific(m_key));
126     if (data)
127         return data-&gt;storagePointer();
128     return nullptr;
129 }
130 
131 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
132 inline void ThreadSpecific&lt;T, canBeGCThread&gt;::setInTLS(Data* data)
133 {
134     pthread_setspecific(m_key, data);
135 }
136 
137 #elif OS(WINDOWS)
138 
<span class="line-removed">139 // The maximum number of FLS keys that can be created. For simplification, we assume that:</span>
<span class="line-removed">140 // 1) Once the instance of ThreadSpecific&lt;&gt; is created, it will not be destructed until the program dies.</span>
<span class="line-removed">141 // 2) We do not need to hold many instances of ThreadSpecific&lt;&gt; data. This fixed number should be far enough.</span>
<span class="line-removed">142 static constexpr int maxFlsKeySize = 128;</span>
<span class="line-removed">143 </span>
<span class="line-removed">144 WTF_EXPORT_PRIVATE long&amp; flsKeyCount();</span>
<span class="line-removed">145 WTF_EXPORT_PRIVATE DWORD* flsKeys();</span>
<span class="line-removed">146 </span>
147 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
148 inline ThreadSpecific&lt;T, canBeGCThread&gt;::ThreadSpecific()
<span class="line-modified">149     : m_index(-1)</span>
150 {
<span class="line-modified">151     DWORD flsKey = FlsAlloc(destroy);</span>
<span class="line-modified">152     if (flsKey == FLS_OUT_OF_INDEXES)</span>
<span class="line-removed">153         CRASH();</span>
<span class="line-removed">154 </span>
<span class="line-removed">155     m_index = InterlockedIncrement(&amp;flsKeyCount()) - 1;</span>
<span class="line-removed">156     if (m_index &gt;= maxFlsKeySize)</span>
157         CRASH();
<span class="line-removed">158     flsKeys()[m_index] = flsKey;</span>
<span class="line-removed">159 }</span>
<span class="line-removed">160 </span>
<span class="line-removed">161 template&lt;typename T, CanBeGCThread canBeGCThread&gt;</span>
<span class="line-removed">162 inline ThreadSpecific&lt;T, canBeGCThread&gt;::~ThreadSpecific()</span>
<span class="line-removed">163 {</span>
<span class="line-removed">164     FlsFree(flsKeys()[m_index]);</span>
165 }
166 
167 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
168 inline T* ThreadSpecific&lt;T, canBeGCThread&gt;::get()
169 {
<span class="line-modified">170     Data* data = static_cast&lt;Data*&gt;(FlsGetValue(flsKeys()[m_index]));</span>
<span class="line-modified">171     if (data)</span>
<span class="line-modified">172         return data-&gt;storagePointer();</span>
<span class="line-modified">173     return nullptr;</span>
174 }
175 
176 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
177 inline void ThreadSpecific&lt;T, canBeGCThread&gt;::setInTLS(Data* data)
178 {
<span class="line-modified">179     FlsSetValue(flsKeys()[m_index], data);</span>
180 }
181 
182 #else
183 #error ThreadSpecific is not implemented for this platform.
184 #endif
185 
186 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
<span class="line-modified">187 inline void THREAD_SPECIFIC_CALL ThreadSpecific&lt;T, canBeGCThread&gt;::destroy(void* ptr)</span>
188 {
189     Data* data = static_cast&lt;Data*&gt;(ptr);
190 
191 #if USE(PTHREADS)
192     // We want get() to keep working while data destructor works, because it can be called indirectly by the destructor.
193     // Some pthreads implementations zero out the pointer before calling destroy(), so we temporarily reset it.
194     pthread_setspecific(data-&gt;owner-&gt;m_key, ptr);
195 #endif
196 
197     delete data;
198 }
199 
200 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
201 inline T* ThreadSpecific&lt;T, canBeGCThread&gt;::set()
202 {
203     RELEASE_ASSERT(canBeGCThread == CanBeGCThread::True || !Thread::mayBeGCThread());
204     ASSERT(!get());
205     Data* data = new Data(this); // Data will set itself into TLS.
206     ASSERT(get() == data-&gt;storagePointer());
207     return data-&gt;storagePointer();
</pre>
</td>
<td>
<hr />
<pre>
 83             // needs to access the value, to avoid recursion.
 84             owner-&gt;setInTLS(this);
 85             new (NotNull, storagePointer()) T();
 86         }
 87 
 88         ~Data()
 89         {
 90             storagePointer()-&gt;~T();
 91             owner-&gt;setInTLS(nullptr);
 92         }
 93 
 94         PointerType storagePointer() const { return const_cast&lt;PointerType&gt;(reinterpret_cast&lt;const T*&gt;(&amp;m_storage)); }
 95 
 96         typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_storage;
 97         ThreadSpecific&lt;T, canBeGCThread&gt;* owner;
 98     };
 99 
100     T* get();
101     T* set();
102     void setInTLS(Data*);
<span class="line-modified">103     void static destroy(void* ptr);</span>
104 
105 #if USE(PTHREADS)
106     pthread_key_t m_key { };
107 #elif OS(WINDOWS)
<span class="line-modified">108     int m_key;</span>
109 #endif
110 };
111 
112 #if USE(PTHREADS)
113 
114 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
115 inline ThreadSpecific&lt;T, canBeGCThread&gt;::ThreadSpecific()
116 {
117     int error = pthread_key_create(&amp;m_key, destroy);
118     if (error)
119         CRASH();
120 }
121 
122 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
123 inline T* ThreadSpecific&lt;T, canBeGCThread&gt;::get()
124 {
125     Data* data = static_cast&lt;Data*&gt;(pthread_getspecific(m_key));
126     if (data)
127         return data-&gt;storagePointer();
128     return nullptr;
129 }
130 
131 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
132 inline void ThreadSpecific&lt;T, canBeGCThread&gt;::setInTLS(Data* data)
133 {
134     pthread_setspecific(m_key, data);
135 }
136 
137 #elif OS(WINDOWS)
138 








139 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
140 inline ThreadSpecific&lt;T, canBeGCThread&gt;::ThreadSpecific()
<span class="line-modified">141     : m_key(-1)</span>
142 {
<span class="line-modified">143     bool ok = Thread::SpecificStorage::allocateKey(m_key, destroy);</span>
<span class="line-modified">144     if (!ok)</span>




145         CRASH();







146 }
147 
148 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
149 inline T* ThreadSpecific&lt;T, canBeGCThread&gt;::get()
150 {
<span class="line-modified">151     auto data = static_cast&lt;Data*&gt;(Thread::current().specificStorage().get(m_key));</span>
<span class="line-modified">152     if (!data)</span>
<span class="line-modified">153         return nullptr;</span>
<span class="line-modified">154     return data-&gt;storagePointer();</span>
155 }
156 
157 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
158 inline void ThreadSpecific&lt;T, canBeGCThread&gt;::setInTLS(Data* data)
159 {
<span class="line-modified">160     return Thread::current().specificStorage().set(m_key, data);</span>
161 }
162 
163 #else
164 #error ThreadSpecific is not implemented for this platform.
165 #endif
166 
167 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
<span class="line-modified">168 inline void ThreadSpecific&lt;T, canBeGCThread&gt;::destroy(void* ptr)</span>
169 {
170     Data* data = static_cast&lt;Data*&gt;(ptr);
171 
172 #if USE(PTHREADS)
173     // We want get() to keep working while data destructor works, because it can be called indirectly by the destructor.
174     // Some pthreads implementations zero out the pointer before calling destroy(), so we temporarily reset it.
175     pthread_setspecific(data-&gt;owner-&gt;m_key, ptr);
176 #endif
177 
178     delete data;
179 }
180 
181 template&lt;typename T, CanBeGCThread canBeGCThread&gt;
182 inline T* ThreadSpecific&lt;T, canBeGCThread&gt;::set()
183 {
184     RELEASE_ASSERT(canBeGCThread == CanBeGCThread::True || !Thread::mayBeGCThread());
185     ASSERT(!get());
186     Data* data = new Data(this); // Data will set itself into TLS.
187     ASSERT(get() == data-&gt;storagePointer());
188     return data-&gt;storagePointer();
</pre>
</td>
</tr>
</table>
<center><a href="ThreadSafeRefCounted.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Threading.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
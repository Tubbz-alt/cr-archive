<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWrapper.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.
  4  *  Copyright (C) 2007 Samuel Weinig &lt;sam@webkit.org&gt;
  5  *  Copyright (C) 2009 Google, Inc. All rights reserved.
  6  *
  7  *  This library is free software; you can redistribute it and/or
  8  *  modify it under the terms of the GNU Lesser General Public
  9  *  License as published by the Free Software Foundation; either
 10  *  version 2 of the License, or (at your option) any later version.
 11  *
 12  *  This library is distributed in the hope that it will be useful,
 13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  *  Lesser General Public License for more details.
 16  *
 17  *  You should have received a copy of the GNU Lesser General Public
 18  *  License along with this library; if not, write to the Free Software
 19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;JSDOMGlobalObject.h&quot;
 25 #include &quot;NodeConstants.h&quot;
 26 #include &lt;JavaScriptCore/JSDestructibleObject.h&gt;
 27 
 28 namespace WebCore {
 29 
 30 class ScriptExecutionContext;
 31 
 32 // JSC allows us to extend JSType. If the highest 3 bits are set, we can add any Object types and they are
 33 // recognized as OtherObj in JSC. And we encode Node type into JSType if the given JSType is subclass of Node.
 34 // offset | 7 | 6 | 5 | 4   3   2   1   0  |
 35 // value  | 1 | 1 | 1 | Non-node DOM types |
 36 // If the given JSType is a subclass of Node, the format is the following.
 37 // offset | 7 | 6 | 5 | 4 | 3   2   1   0  |
 38 // value  | 1 | 1 | 1 | 1 |    NodeType    |
 39 
 40 static const uint8_t JSDOMWrapperType                = 0b11101110;
 41 static const uint8_t JSEventType                     = 0b11101111;
 42 static const uint8_t JSNodeType                      = 0b11110000;
 43 static const uint8_t JSNodeTypeMask                  = 0b00001111;
 44 static const uint8_t JSTextNodeType                  = JSNodeType | NodeConstants::TEXT_NODE;
 45 static const uint8_t JSProcessingInstructionNodeType = JSNodeType | NodeConstants::PROCESSING_INSTRUCTION_NODE;
 46 static const uint8_t JSDocumentTypeNodeType          = JSNodeType | NodeConstants::DOCUMENT_TYPE_NODE;
 47 static const uint8_t JSDocumentFragmentNodeType      = JSNodeType | NodeConstants::DOCUMENT_FRAGMENT_NODE;
 48 static const uint8_t JSDocumentWrapperType           = JSNodeType | NodeConstants::DOCUMENT_NODE;
 49 static const uint8_t JSCommentNodeType               = JSNodeType | NodeConstants::COMMENT_NODE;
 50 static const uint8_t JSCDATASectionNodeType          = JSNodeType | NodeConstants::CDATA_SECTION_NODE;
 51 static const uint8_t JSAttrNodeType                  = JSNodeType | NodeConstants::ATTRIBUTE_NODE;
 52 static const uint8_t JSElementType                   = 0b11110000 | NodeConstants::ELEMENT_NODE;
 53 
 54 static_assert(JSDOMWrapperType &gt; JSC::LastJSCObjectType, &quot;JSC::JSType offers the highest bit.&quot;);
 55 static_assert(NodeConstants::LastNodeType &lt;= JSNodeTypeMask, &quot;NodeType should be represented in 4bit.&quot;);
 56 
 57 class JSDOMObject : public JSC::JSDestructibleObject {
 58 public:
 59     typedef JSC::JSDestructibleObject Base;
 60     static constexpr bool isDOMWrapper = false;
 61 
 62     JSDOMGlobalObject* globalObject() const { return JSC::jsCast&lt;JSDOMGlobalObject*&gt;(JSC::JSNonFinalObject::globalObject()); }
 63     ScriptExecutionContext* scriptExecutionContext() const { return globalObject()-&gt;scriptExecutionContext(); }
 64 
 65 protected:
 66     WEBCORE_EXPORT JSDOMObject(JSC::Structure*, JSC::JSGlobalObject&amp;);
 67 };
 68 
 69 WEBCORE_EXPORT JSC::CompleteSubspace* outputConstraintSubspaceFor(JSC::VM&amp;);
 70 
 71 template&lt;typename ImplementationClass&gt; class JSDOMWrapper : public JSDOMObject {
 72 public:
 73     typedef JSDOMObject Base;
 74     typedef ImplementationClass DOMWrapped;
 75     static constexpr bool isDOMWrapper = true;
 76 
 77     ImplementationClass&amp; wrapped() const { return m_wrapped; }
 78     static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSDOMWrapper&lt;ImplementationClass&gt;, m_wrapped); }
 79 
 80 protected:
 81     JSDOMWrapper(JSC::Structure* structure, JSC::JSGlobalObject&amp; globalObject, Ref&lt;ImplementationClass&gt;&amp;&amp; impl)
 82         : Base(structure, globalObject)
 83         , m_wrapped(WTFMove(impl)) { }
 84 
 85 private:
 86     Ref&lt;ImplementationClass&gt; m_wrapped;
 87 };
 88 
 89 template&lt;typename ImplementationClass&gt; struct JSDOMWrapperConverterTraits;
 90 
 91 template&lt;typename JSClass, typename Enable = void&gt;
 92 struct JSDOMObjectInspector {
 93 public:
 94     static constexpr bool isSimpleWrapper = false;
 95     static constexpr bool isComplexWrapper = false;
 96     static constexpr bool isBuiltin = true;
 97 };
 98 
 99 template&lt;typename JSClass&gt;
100 struct JSDOMObjectInspector&lt;JSClass, typename std::enable_if&lt;JSClass::isDOMWrapper&gt;::type&gt; {
101 private:
102     template&lt;typename T&gt; static constexpr auto test(int) -&gt; decltype(T::create(), bool()) { return true; }
103     template&lt;typename T&gt; static constexpr bool test(...) { return false; }
104 
105 public:
106     static constexpr bool isSimpleWrapper = test&lt;typename JSClass::DOMWrapped&gt;(0);
107     static constexpr bool isComplexWrapper = !isSimpleWrapper;
108     static constexpr bool isBuiltin = false;
109 };
110 
111 JSC::JSValue cloneAcrossWorlds(JSC::JSGlobalObject&amp;, const JSDOMObject&amp; owner, JSC::JSValue);
112 
113 } // namespace WebCore
    </pre>
  </body>
</html>
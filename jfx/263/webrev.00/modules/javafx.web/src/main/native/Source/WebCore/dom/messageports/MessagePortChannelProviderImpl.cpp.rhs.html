<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannelProviderImpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MessagePortChannelProviderImpl.h&quot;
 28 
 29 #include &quot;MessagePort.h&quot;
<a name="1" id="anc1"></a>
 30 #include &lt;wtf/MainThread.h&gt;
 31 #include &lt;wtf/RunLoop.h&gt;
 32 
 33 namespace WebCore {
 34 
<a name="2" id="anc2"></a><span class="line-added"> 35 static inline MessagePortChannelRegistry::CheckProcessLocalPortForActivityCallback checkActivityCallback()</span>
<span class="line-added"> 36 {</span>
<span class="line-added"> 37     return [](auto&amp; messagePortIdentifier, auto, auto&amp;&amp; callback) {</span>
<span class="line-added"> 38         ASSERT(isMainThread());</span>
<span class="line-added"> 39         callback(MessagePort::isExistingMessagePortLocallyReachable(messagePortIdentifier) ? MessagePortChannelProvider::HasActivity::Yes : MessagePortChannelProvider::HasActivity::No);</span>
<span class="line-added"> 40     };</span>
<span class="line-added"> 41 }</span>
<span class="line-added"> 42 </span>
 43 MessagePortChannelProviderImpl::MessagePortChannelProviderImpl()
<a name="3" id="anc3"></a><span class="line-modified"> 44     : m_registry(checkActivityCallback())</span>
 45 {
 46 }
 47 
 48 MessagePortChannelProviderImpl::~MessagePortChannelProviderImpl()
 49 {
 50     ASSERT_NOT_REACHED();
 51 }
 52 
 53 void MessagePortChannelProviderImpl::performActionOnMainThread(Function&lt;void()&gt;&amp;&amp; action)
 54 {
 55     if (isMainThread())
 56         action();
 57     else
 58         callOnMainThread(WTFMove(action));
 59 }
 60 
 61 void MessagePortChannelProviderImpl::createNewMessagePortChannel(const MessagePortIdentifier&amp; local, const MessagePortIdentifier&amp; remote)
 62 {
 63     performActionOnMainThread([registry = &amp;m_registry, local, remote] {
 64         registry-&gt;didCreateMessagePortChannel(local, remote);
 65     });
 66 }
 67 
 68 void MessagePortChannelProviderImpl::entangleLocalPortInThisProcessToRemote(const MessagePortIdentifier&amp; local, const MessagePortIdentifier&amp; remote)
 69 {
 70     performActionOnMainThread([registry = &amp;m_registry, local, remote] {
 71         registry-&gt;didEntangleLocalToRemote(local, remote, Process::identifier());
 72     });
 73 }
 74 
 75 void MessagePortChannelProviderImpl::messagePortDisentangled(const MessagePortIdentifier&amp; local)
 76 {
 77     performActionOnMainThread([registry = &amp;m_registry, local] {
 78         registry-&gt;didDisentangleMessagePort(local);
 79     });
 80 }
 81 
 82 void MessagePortChannelProviderImpl::messagePortClosed(const MessagePortIdentifier&amp; local)
 83 {
 84     performActionOnMainThread([registry = &amp;m_registry, local] {
 85         registry-&gt;didCloseMessagePort(local);
 86     });
 87 }
 88 
 89 void MessagePortChannelProviderImpl::postMessageToRemote(MessageWithMessagePorts&amp;&amp; message, const MessagePortIdentifier&amp; remoteTarget)
 90 {
 91     performActionOnMainThread([registry = &amp;m_registry, message = WTFMove(message), remoteTarget]() mutable {
 92         if (registry-&gt;didPostMessageToRemote(WTFMove(message), remoteTarget))
 93             MessagePort::notifyMessageAvailable(remoteTarget);
 94     });
 95 }
 96 
<a name="4" id="anc4"></a><span class="line-modified"> 97 void MessagePortChannelProviderImpl::takeAllMessagesForPort(const MessagePortIdentifier&amp; port, CompletionHandler&lt;void(Vector&lt;MessageWithMessagePorts&gt;&amp;&amp;, Function&lt;void()&gt;&amp;&amp;)&gt;&amp;&amp; outerCallback)</span>
 98 {
 99     // It is the responsibility of outerCallback to get itself to the appropriate thread (e.g. WebWorker thread)
<a name="5" id="anc5"></a><span class="line-modified">100     auto callback = [outerCallback = WTFMove(outerCallback)](Vector&lt;MessageWithMessagePorts&gt;&amp;&amp; messages, Function&lt;void()&gt;&amp;&amp; messageDeliveryCallback) mutable {</span>
101         ASSERT(isMainThread());
102         outerCallback(WTFMove(messages), WTFMove(messageDeliveryCallback));
103     };
104 
105     performActionOnMainThread([registry = &amp;m_registry, port, callback = WTFMove(callback)]() mutable {
106         registry-&gt;takeAllMessagesForPort(port, WTFMove(callback));
107     });
108 }
109 
<a name="6" id="anc6"></a><span class="line-modified">110 void MessagePortChannelProviderImpl::checkRemotePortForActivity(const MessagePortIdentifier&amp; remoteTarget, CompletionHandler&lt;void(HasActivity)&gt;&amp;&amp; outerCallback)</span>
111 {
112     auto callback = Function&lt;void(HasActivity)&gt; { [outerCallback = WTFMove(outerCallback)](HasActivity hasActivity) mutable {
113         ASSERT(isMainThread());
114         outerCallback(hasActivity);
115     } };
116 
117     performActionOnMainThread([registry = &amp;m_registry, remoteTarget, callback = WTFMove(callback)]() mutable {
118         registry-&gt;checkRemotePortForActivity(remoteTarget, WTFMove(callback));
119     });
120 }
121 
<a name="7" id="anc7"></a>







122 } // namespace WebCore
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2007, 2008 Rob Buis &lt;buis@kde.org&gt;
  3  * Copyright (C) 2007 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  4  * Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  5  * Copyright (C) 2009 Google, Inc.  All rights reserved.
  6  * Copyright (C) 2009 Dirk Schulze &lt;krit@webkit.org&gt;
  7  * Copyright (C) Research In Motion Limited 2009-2010. All rights reserved.
  8  * Copyright (C) 2018 Adobe Systems Incorporated. All rights reserved.
  9  *
 10  * This library is free software; you can redistribute it and/or
 11  * modify it under the terms of the GNU Library General Public
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SVGRenderSupport.h&quot;
 28 
 29 #include &quot;NodeRenderStyle.h&quot;
 30 #include &quot;RenderChildIterator.h&quot;
 31 #include &quot;RenderElement.h&quot;
 32 #include &quot;RenderGeometryMap.h&quot;
 33 #include &quot;RenderIterator.h&quot;
 34 #include &quot;RenderLayer.h&quot;
 35 #include &quot;RenderSVGImage.h&quot;
 36 #include &quot;RenderSVGResourceClipper.h&quot;
 37 #include &quot;RenderSVGResourceFilter.h&quot;
 38 #include &quot;RenderSVGResourceMarker.h&quot;
 39 #include &quot;RenderSVGResourceMasker.h&quot;
 40 #include &quot;RenderSVGRoot.h&quot;
 41 #include &quot;RenderSVGText.h&quot;
 42 #include &quot;RenderSVGTransformableContainer.h&quot;
 43 #include &quot;RenderSVGViewportContainer.h&quot;
 44 #include &quot;SVGGeometryElement.h&quot;
 45 #include &quot;SVGResources.h&quot;
 46 #include &quot;SVGResourcesCache.h&quot;
 47 #include &quot;TransformState.h&quot;
 48 
 49 namespace WebCore {
 50 
 51 LayoutRect SVGRenderSupport::clippedOverflowRectForRepaint(const RenderElement&amp; renderer, const RenderLayerModelObject* repaintContainer)
 52 {
 53     // Return early for any cases where we don&#39;t actually paint
 54     if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !renderer.enclosingLayer()-&gt;hasVisibleContent())
 55         return LayoutRect();
 56 
 57     // Pass our local paint rect to computeFloatVisibleRectInContainer() which will
 58     // map to parent coords and recurse up the parent chain.
 59     FloatRect repaintRect = renderer.repaintRectInLocalCoordinates();
 60     const SVGRenderStyle&amp; svgStyle = renderer.style().svgStyle();
 61     if (const ShadowData* shadow = svgStyle.shadow())
 62         shadow-&gt;adjustRectForShadow(repaintRect);
 63     return enclosingLayoutRect(renderer.computeFloatRectForRepaint(repaintRect, repaintContainer));
 64 }
 65 
 66 Optional&lt;FloatRect&gt; SVGRenderSupport::computeFloatVisibleRectInContainer(const RenderElement&amp; renderer, const FloatRect&amp; rect, const RenderLayerModelObject* container, RenderObject::VisibleRectContext context)
 67 {
 68     // Ensure our parent is an SVG object.
 69     ASSERT(renderer.parent());
 70     auto&amp; parent = *renderer.parent();
 71     if (!is&lt;SVGElement&gt;(parent.element()))
 72         return FloatRect();
 73 
 74     FloatRect adjustedRect = rect;
 75     const SVGRenderStyle&amp; svgStyle = renderer.style().svgStyle();
 76     if (const ShadowData* shadow = svgStyle.shadow())
 77         shadow-&gt;adjustRectForShadow(adjustedRect);
 78     adjustedRect.inflate(renderer.style().outlineWidth());
 79 
 80     // Translate to coords in our parent renderer, and then call computeFloatVisibleRectInContainer() on our parent.
 81     adjustedRect = renderer.localToParentTransform().mapRect(adjustedRect);
 82 
 83     return parent.computeFloatVisibleRectInContainer(adjustedRect, container, context);
 84 }
 85 
 86 const RenderElement&amp; SVGRenderSupport::localToParentTransform(const RenderElement&amp; renderer, AffineTransform &amp;transform)
 87 {
 88     ASSERT(renderer.parent());
 89     auto&amp; parent = *renderer.parent();
 90 
 91     // At the SVG/HTML boundary (aka RenderSVGRoot), we apply the localToBorderBoxTransform
 92     // to map an element from SVG viewport coordinates to CSS box coordinates.
 93     if (is&lt;RenderSVGRoot&gt;(parent))
 94         transform = downcast&lt;RenderSVGRoot&gt;(parent).localToBorderBoxTransform() * renderer.localToParentTransform();
 95     else
 96         transform = renderer.localToParentTransform();
 97 
 98     return parent;
 99 }
100 
101 void SVGRenderSupport::mapLocalToContainer(const RenderElement&amp; renderer, const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, bool* wasFixed)
102 {
103     AffineTransform transform;
104     auto&amp; parent = localToParentTransform(renderer, transform);
105 
106     transformState.applyTransform(transform);
107 
108     MapCoordinatesFlags mode = UseTransforms;
109     parent.mapLocalToContainer(repaintContainer, transformState, mode, wasFixed);
110 }
111 
112 const RenderElement* SVGRenderSupport::pushMappingToContainer(const RenderElement&amp; renderer, const RenderLayerModelObject* ancestorToStopAt, RenderGeometryMap&amp; geometryMap)
113 {
114     ASSERT_UNUSED(ancestorToStopAt, ancestorToStopAt != &amp;renderer);
115 
116     AffineTransform transform;
117     auto&amp; parent = localToParentTransform(renderer, transform);
118 
119     geometryMap.push(&amp;renderer, transform);
120     return &amp;parent;
121 }
122 
123 bool SVGRenderSupport::checkForSVGRepaintDuringLayout(const RenderElement&amp; renderer)
124 {
125     if (!renderer.checkForRepaintDuringLayout())
126         return false;
127     // When a parent container is transformed in SVG, all children will be painted automatically
128     // so we are able to skip redundant repaint checks.
129     auto parent = renderer.parent();
130     return !(is&lt;RenderSVGContainer&gt;(parent) &amp;&amp; downcast&lt;RenderSVGContainer&gt;(*parent).didTransformToRootUpdate());
131 }
132 
133 // Update a bounding box taking into account the validity of the other bounding box.
134 static inline void updateObjectBoundingBox(FloatRect&amp; objectBoundingBox, bool&amp; objectBoundingBoxValid, const RenderObject* other, FloatRect otherBoundingBox)
135 {
136     bool otherValid = is&lt;RenderSVGContainer&gt;(*other) ? downcast&lt;RenderSVGContainer&gt;(*other).isObjectBoundingBoxValid() : true;
137     if (!otherValid)
138         return;
139 
140     if (!objectBoundingBoxValid) {
141         objectBoundingBox = otherBoundingBox;
142         objectBoundingBoxValid = true;
143         return;
144     }
145 
146     objectBoundingBox.uniteEvenIfEmpty(otherBoundingBox);
147 }
148 
149 void SVGRenderSupport::computeContainerBoundingBoxes(const RenderElement&amp; container, FloatRect&amp; objectBoundingBox, bool&amp; objectBoundingBoxValid, FloatRect&amp; strokeBoundingBox, FloatRect&amp; repaintBoundingBox)
150 {
151     objectBoundingBox = FloatRect();
152     objectBoundingBoxValid = false;
153     strokeBoundingBox = FloatRect();
154 
155     // When computing the strokeBoundingBox, we use the repaintRects of the container&#39;s children so that the container&#39;s stroke includes
156     // the resources applied to the children (such as clips and filters). This allows filters applied to containers to correctly bound
157     // the children, and also improves inlining of SVG content, as the stroke bound is used in that situation also.
158     for (auto&amp; current : childrenOfType&lt;RenderObject&gt;(container)) {
159         if (current.isSVGHiddenContainer())
160             continue;
161 
162         // Don&#39;t include elements in the union that do not render.
163         if (is&lt;RenderSVGShape&gt;(current) &amp;&amp; downcast&lt;RenderSVGShape&gt;(current).isRenderingDisabled())
164             continue;
165 
166         const AffineTransform&amp; transform = current.localToParentTransform();
167         if (transform.isIdentity()) {
168             updateObjectBoundingBox(objectBoundingBox, objectBoundingBoxValid, &amp;current, current.objectBoundingBox());
169             strokeBoundingBox.unite(current.repaintRectInLocalCoordinates());
170         } else {
171             updateObjectBoundingBox(objectBoundingBox, objectBoundingBoxValid, &amp;current, transform.mapRect(current.objectBoundingBox()));
172             strokeBoundingBox.unite(transform.mapRect(current.repaintRectInLocalCoordinates()));
173         }
174     }
175 
176     repaintBoundingBox = strokeBoundingBox;
177 }
178 
179 bool SVGRenderSupport::paintInfoIntersectsRepaintRect(const FloatRect&amp; localRepaintRect, const AffineTransform&amp; localTransform, const PaintInfo&amp; paintInfo)
180 {
181     if (localTransform.isIdentity())
182         return localRepaintRect.intersects(paintInfo.rect);
183 
184     return localTransform.mapRect(localRepaintRect).intersects(paintInfo.rect);
185 }
186 
187 RenderSVGRoot* SVGRenderSupport::findTreeRootObject(RenderElement&amp; start)
188 {
189     return lineageOfType&lt;RenderSVGRoot&gt;(start).first();
190 }
191 
192 const RenderSVGRoot* SVGRenderSupport::findTreeRootObject(const RenderElement&amp; start)
193 {
194     return lineageOfType&lt;RenderSVGRoot&gt;(start).first();
195 }
196 
197 static inline void invalidateResourcesOfChildren(RenderElement&amp; renderer)
198 {
199     ASSERT(!renderer.needsLayout());
200     if (auto* resources = SVGResourcesCache::cachedResourcesForRenderer(renderer))
201         resources-&gt;removeClientFromCache(renderer, false);
202 
203     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(renderer))
204         invalidateResourcesOfChildren(child);
205 }
206 
207 static inline bool layoutSizeOfNearestViewportChanged(const RenderElement&amp; renderer)
208 {
209     const RenderElement* start = &amp;renderer;
210     while (start &amp;&amp; !is&lt;RenderSVGRoot&gt;(*start) &amp;&amp; !is&lt;RenderSVGViewportContainer&gt;(*start))
211         start = start-&gt;parent();
212 
213     ASSERT(start);
214     if (is&lt;RenderSVGViewportContainer&gt;(*start))
215         return downcast&lt;RenderSVGViewportContainer&gt;(*start).isLayoutSizeChanged();
216 
217     return downcast&lt;RenderSVGRoot&gt;(*start).isLayoutSizeChanged();
218 }
219 
220 bool SVGRenderSupport::transformToRootChanged(RenderElement* ancestor)
221 {
222     while (ancestor &amp;&amp; !is&lt;RenderSVGRoot&gt;(*ancestor)) {
223         if (is&lt;RenderSVGTransformableContainer&gt;(*ancestor))
224             return downcast&lt;RenderSVGTransformableContainer&gt;(*ancestor).didTransformToRootUpdate();
225         if (is&lt;RenderSVGViewportContainer&gt;(*ancestor))
226             return downcast&lt;RenderSVGViewportContainer&gt;(*ancestor).didTransformToRootUpdate();
227         ancestor = ancestor-&gt;parent();
228     }
229 
230     return false;
231 }
232 
233 void SVGRenderSupport::layoutDifferentRootIfNeeded(const RenderElement&amp; renderer)
234 {
235     if (auto* resources = SVGResourcesCache::cachedResourcesForRenderer(renderer)) {
236         auto* svgRoot = SVGRenderSupport::findTreeRootObject(renderer);
237         ASSERT(svgRoot);
238         resources-&gt;layoutDifferentRootIfNeeded(svgRoot);
239     }
240 }
241 
242 void SVGRenderSupport::layoutChildren(RenderElement&amp; start, bool selfNeedsLayout)
243 {
244     bool layoutSizeChanged = layoutSizeOfNearestViewportChanged(start);
245     bool transformChanged = transformToRootChanged(&amp;start);
246     HashSet&lt;RenderElement*&gt; elementsThatDidNotReceiveLayout;
247 
248     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(start)) {
249         bool needsLayout = selfNeedsLayout;
250         bool childEverHadLayout = child.everHadLayout();
251 
252         if (transformChanged) {
253             // If the transform changed we need to update the text metrics (note: this also happens for layoutSizeChanged=true).
254             if (is&lt;RenderSVGText&gt;(child))
255                 downcast&lt;RenderSVGText&gt;(child).setNeedsTextMetricsUpdate();
256             needsLayout = true;
257         }
258 
259         if (layoutSizeChanged &amp;&amp; is&lt;SVGElement&gt;(*child.node())) {
260             // When selfNeedsLayout is false and the layout size changed, we have to check whether this child uses relative lengths
261             auto&amp; element = downcast&lt;SVGElement&gt;(*child.node());
262             if (element.hasRelativeLengths()) {
263                 // When the layout size changed and when using relative values tell the RenderSVGShape to update its shape object
264                 if (is&lt;RenderSVGShape&gt;(child))
265                     downcast&lt;RenderSVGShape&gt;(child).setNeedsShapeUpdate();
266                 else if (is&lt;RenderSVGText&gt;(child)) {
267                     auto&amp; svgText = downcast&lt;RenderSVGText&gt;(child);
268                     svgText.setNeedsTextMetricsUpdate();
269                     svgText.setNeedsPositioningValuesUpdate();
270                 }
271 
272                 needsLayout = true;
273             }
274         }
275 
276         if (needsLayout)
277             child.setNeedsLayout(MarkOnlyThis);
278 
279         if (child.needsLayout()) {
280             layoutDifferentRootIfNeeded(downcast&lt;RenderElement&gt;(child));
281             downcast&lt;RenderElement&gt;(child).layout();
282             // Renderers are responsible for repainting themselves when changing, except
283             // for the initial paint to avoid potential double-painting caused by non-sensical &quot;old&quot; bounds.
284             // We could handle this in the individual objects, but for now it&#39;s easier to have
285             // parent containers call repaint().  (RenderBlock::layout* has similar logic.)
286             if (!childEverHadLayout)
287                 child.repaint();
288         } else if (layoutSizeChanged &amp;&amp; is&lt;RenderElement&gt;(child))
289             elementsThatDidNotReceiveLayout.add(&amp;downcast&lt;RenderElement&gt;(child));
290 
291         ASSERT(!child.needsLayout());
292     }
293 
294     if (!layoutSizeChanged) {
295         ASSERT(elementsThatDidNotReceiveLayout.isEmpty());
296         return;
297     }
298 
299     // If the layout size changed, invalidate all resources of all children that didn&#39;t go through the layout() code path.
300     for (auto* element : elementsThatDidNotReceiveLayout)
301         invalidateResourcesOfChildren(*element);
302 }
303 
304 bool SVGRenderSupport::isOverflowHidden(const RenderElement&amp; renderer)
305 {
306     // RenderSVGRoot should never query for overflow state - it should always clip itself to the initial viewport size.
307     ASSERT(!renderer.isDocumentElementRenderer());
308 
309     return renderer.style().overflowX() == Overflow::Hidden || renderer.style().overflowX() == Overflow::Scroll;
310 }
311 
312 void SVGRenderSupport::intersectRepaintRectWithResources(const RenderElement&amp; renderer, FloatRect&amp; repaintRect)
313 {
314     auto* resources = SVGResourcesCache::cachedResourcesForRenderer(renderer);
315     if (!resources)
316         return;
317 
318     if (RenderSVGResourceFilter* filter = resources-&gt;filter())
319         repaintRect = filter-&gt;resourceBoundingBox(renderer);
320 
321     if (RenderSVGResourceClipper* clipper = resources-&gt;clipper())
322         repaintRect.intersect(clipper-&gt;resourceBoundingBox(renderer));
323 
324     if (RenderSVGResourceMasker* masker = resources-&gt;masker())
325         repaintRect.intersect(masker-&gt;resourceBoundingBox(renderer));
326 }
327 
328 bool SVGRenderSupport::filtersForceContainerLayout(const RenderElement&amp; renderer)
329 {
330     // If any of this container&#39;s children need to be laid out, and a filter is applied
331     // to the container, we need to repaint the entire container.
332     if (!renderer.normalChildNeedsLayout())
333         return false;
334 
335     auto* resources = SVGResourcesCache::cachedResourcesForRenderer(renderer);
336     if (!resources || !resources-&gt;filter())
337         return false;
338 
339     return true;
340 }
341 
342 inline FloatRect clipPathReferenceBox(const RenderElement&amp; renderer, CSSBoxType boxType)
343 {
344     FloatRect referenceBox;
345     switch (boxType) {
346     case CSSBoxType::BorderBox:
347     case CSSBoxType::MarginBox:
348     case CSSBoxType::StrokeBox:
349         // FIXME: strokeBoundingBox() takes dasharray into account but shouldn&#39;t.
350         referenceBox = renderer.strokeBoundingBox();
351         break;
352     case CSSBoxType::ViewBox:
353         if (renderer.element()) {
354             FloatSize viewportSize;
355             SVGLengthContext(downcast&lt;SVGElement&gt;(renderer.element())).determineViewport(viewportSize);
356             referenceBox.setSize(viewportSize);
357             break;
358         }
359         FALLTHROUGH;
360     case CSSBoxType::ContentBox:
361     case CSSBoxType::FillBox:
362     case CSSBoxType::PaddingBox:
363     case CSSBoxType::BoxMissing:
364         referenceBox = renderer.objectBoundingBox();
365         break;
366     }
367     return referenceBox;
368 }
369 
370 inline bool isPointInCSSClippingArea(const RenderElement&amp; renderer, const FloatPoint&amp; point)
371 {
372     ClipPathOperation* clipPathOperation = renderer.style().clipPath();
373     if (is&lt;ShapeClipPathOperation&gt;(clipPathOperation)) {
374         auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*clipPathOperation);
375         FloatRect referenceBox = clipPathReferenceBox(renderer, clipPath.referenceBox());
376         if (!referenceBox.contains(point))
377             return false;
378         return clipPath.pathForReferenceRect(referenceBox).contains(point, clipPath.windRule());
379     }
380     if (is&lt;BoxClipPathOperation&gt;(clipPathOperation)) {
381         auto&amp; clipPath = downcast&lt;BoxClipPathOperation&gt;(*clipPathOperation);
382         FloatRect referenceBox = clipPathReferenceBox(renderer, clipPath.referenceBox());
383         if (!referenceBox.contains(point))
384             return false;
385         return clipPath.pathForReferenceRect(FloatRoundedRect {referenceBox}).contains(point);
386     }
387 
388     return true;
389 }
390 
391 void SVGRenderSupport::clipContextToCSSClippingArea(GraphicsContext&amp; context, const RenderElement&amp; renderer)
392 {
393     ClipPathOperation* clipPathOperation = renderer.style().clipPath();
394     if (is&lt;ShapeClipPathOperation&gt;(clipPathOperation)) {
395         auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*clipPathOperation);
396         FloatRect referenceBox = clipPathReferenceBox(renderer, clipPath.referenceBox());
397         context.clipPath(clipPath.pathForReferenceRect(referenceBox), clipPath.windRule());
398     }
399     if (is&lt;BoxClipPathOperation&gt;(clipPathOperation)) {
400         auto&amp; clipPath = downcast&lt;BoxClipPathOperation&gt;(*clipPathOperation);
401         FloatRect referenceBox = clipPathReferenceBox(renderer, clipPath.referenceBox());
402         context.clipPath(clipPath.pathForReferenceRect(FloatRoundedRect {referenceBox}));
403     }
404 }
405 
406 bool SVGRenderSupport::pointInClippingArea(const RenderElement&amp; renderer, const FloatPoint&amp; point)
407 {
408     ClipPathOperation* clipPathOperation = renderer.style().clipPath();
409     if (is&lt;ShapeClipPathOperation&gt;(clipPathOperation) || is&lt;BoxClipPathOperation&gt;(clipPathOperation))
410         return isPointInCSSClippingArea(renderer, point);
411 
412     // We just take clippers into account to determine if a point is on the node. The Specification may
413     // change later and we also need to check maskers.
414     auto* resources = SVGResourcesCache::cachedResourcesForRenderer(renderer);
415     if (!resources)
416         return true;
417 
418     if (RenderSVGResourceClipper* clipper = resources-&gt;clipper())
419         return clipper-&gt;hitTestClipContent(renderer.objectBoundingBox(), point);
420 
421     return true;
422 }
423 
424 void SVGRenderSupport::applyStrokeStyleToContext(GraphicsContext* context, const RenderStyle&amp; style, const RenderElement&amp; renderer)
425 {
426     ASSERT(context);
427 
428     Element* element = renderer.element();
429     if (!is&lt;SVGElement&gt;(element)) {
430         ASSERT_NOT_REACHED();
431         return;
432     }
433 
434     const SVGRenderStyle&amp; svgStyle = style.svgStyle();
435 
436     SVGLengthContext lengthContext(downcast&lt;SVGElement&gt;(renderer.element()));
437     context-&gt;setStrokeThickness(lengthContext.valueForLength(style.strokeWidth()));
438     context-&gt;setLineCap(style.capStyle());
439     context-&gt;setLineJoin(style.joinStyle());
440     if (style.joinStyle() == MiterJoin)
441         context-&gt;setMiterLimit(style.strokeMiterLimit());
442 
443     const Vector&lt;SVGLengthValue&gt;&amp; dashes = svgStyle.strokeDashArray();
444     if (dashes.isEmpty())
445         context-&gt;setStrokeStyle(SolidStroke);
446     else {
447         DashArray dashArray;
448         dashArray.reserveInitialCapacity(dashes.size());
449         bool canSetLineDash = false;
450         float scaleFactor = 1;
451 
452         if (is&lt;SVGGeometryElement&gt;(element)) {
453             ASSERT(renderer.isSVGShape());
454             // FIXME: A value of zero is valid. Need to differentiate this case from being unspecified.
455             if (float pathLength = downcast&lt;SVGGeometryElement&gt;(element)-&gt;pathLength())
456                 scaleFactor = downcast&lt;RenderSVGShape&gt;(renderer).getTotalLength() / pathLength;
457         }
458 
459         for (auto&amp; dash : dashes) {
460             dashArray.uncheckedAppend(dash.value(lengthContext) * scaleFactor);
461             if (dashArray.last() &gt; 0)
462                 canSetLineDash = true;
463         }
464 
465         if (canSetLineDash)
466             context-&gt;setLineDash(dashArray, lengthContext.valueForLength(svgStyle.strokeDashOffset()) * scaleFactor);
467         else
468             context-&gt;setStrokeStyle(SolidStroke);
469     }
470 }
471 
472 void SVGRenderSupport::styleChanged(RenderElement&amp; renderer, const RenderStyle* oldStyle)
473 {
474 #if ENABLE(CSS_COMPOSITING)
475     if (renderer.element() &amp;&amp; renderer.element()-&gt;isSVGElement() &amp;&amp; (!oldStyle || renderer.style().hasBlendMode() != oldStyle-&gt;hasBlendMode()))
476         SVGRenderSupport::updateMaskedAncestorShouldIsolateBlending(renderer);
477 #else
478     UNUSED_PARAM(renderer);
479     UNUSED_PARAM(oldStyle);
480 #endif
481 }
482 
483 #if ENABLE(CSS_COMPOSITING)
484 bool SVGRenderSupport::isolatesBlending(const RenderStyle&amp; style)
485 {
486     return style.svgStyle().isolatesBlending() || style.hasFilter() || style.hasBlendMode() || style.opacity() &lt; 1.0f;
487 }
488 
489 void SVGRenderSupport::updateMaskedAncestorShouldIsolateBlending(const RenderElement&amp; renderer)
490 {
491     ASSERT(renderer.element());
492     ASSERT(renderer.element()-&gt;isSVGElement());
493 
494     bool maskedAncestorShouldIsolateBlending = renderer.style().hasBlendMode();
495     for (auto* ancestor = renderer.element()-&gt;parentElement(); ancestor &amp;&amp; ancestor-&gt;isSVGElement(); ancestor = ancestor-&gt;parentElement()) {
496         if (!downcast&lt;SVGElement&gt;(*ancestor).isSVGGraphicsElement())
497             continue;
498 
499         const auto* style = ancestor-&gt;computedStyle();
500         if (!style || !isolatesBlending(*style))
501             continue;
502 
503         if (ancestor-&gt;computedStyle()-&gt;svgStyle().hasMasker())
504             downcast&lt;SVGGraphicsElement&gt;(*ancestor).setShouldIsolateBlending(maskedAncestorShouldIsolateBlending);
505 
506         return;
507     }
508 }
509 #endif
510 }
    </pre>
  </body>
</html>
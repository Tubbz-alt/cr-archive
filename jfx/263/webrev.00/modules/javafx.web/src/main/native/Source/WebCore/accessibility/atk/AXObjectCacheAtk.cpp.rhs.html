<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/AXObjectCacheAtk.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008 Nuanti Ltd.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;AXObjectCache.h&quot;
 22 
 23 #if ENABLE(ACCESSIBILITY)
 24 
 25 #include &quot;AccessibilityObject.h&quot;
 26 #include &quot;AccessibilityRenderObject.h&quot;
 27 #include &quot;Document.h&quot;
 28 #include &quot;Element.h&quot;
 29 #include &quot;HTMLSelectElement.h&quot;
 30 #include &quot;Range.h&quot;
 31 #include &quot;TextIterator.h&quot;
 32 #include &quot;WebKitAccessible.h&quot;
 33 #include &lt;wtf/NeverDestroyed.h&gt;
 34 #include &lt;wtf/glib/GRefPtr.h&gt;
 35 #include &lt;wtf/text/CString.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 static AtkObject* wrapperParent(WebKitAccessible* wrapper)
 40 {
 41     // Look for the right object to emit the signal from, but using the implementation
 42     // of atk_object_get_parent from AtkObject class (which uses a cached pointer if set)
 43     // since the accessibility hierarchy in WebCore will no longer be navigable.
 44     gpointer webkitAccessibleClass = g_type_class_peek_parent(WEBKIT_ACCESSIBLE_GET_CLASS(wrapper));
 45     gpointer atkObjectClass = g_type_class_peek_parent(webkitAccessibleClass);
 46     AtkObject* atkParent = ATK_OBJECT_CLASS(atkObjectClass)-&gt;get_parent(ATK_OBJECT(wrapper));
 47     // We don&#39;t want to emit any signal from an object outside WebKit&#39;s world.
 48     return WEBKIT_IS_ACCESSIBLE(atkParent) ? atkParent : nullptr;
 49 }
 50 
<a name="1" id="anc1"></a><span class="line-modified"> 51 void AXObjectCache::detachWrapper(AXCoreObject* obj, AccessibilityDetachmentType detachmentType)</span>
 52 {
 53     auto* wrapper = obj-&gt;wrapper();
 54     ASSERT(wrapper);
 55 
 56     // If an object is being detached NOT because of the AXObjectCache being destroyed,
 57     // then it&#39;s being removed from the accessibility tree and we should emit a signal.
 58     if (detachmentType != AccessibilityDetachmentType::CacheDestroyed &amp;&amp; obj-&gt;document() &amp;&amp; wrapperParent(wrapper))
 59         m_deferredDetachedWrapperList.add(wrapper);
 60 
 61     webkitAccessibleDetach(WEBKIT_ACCESSIBLE(wrapper));
 62 }
 63 
<a name="2" id="anc2"></a><span class="line-modified"> 64 void AXObjectCache::attachWrapper(AXCoreObject* obj)</span>
 65 {
<a name="3" id="anc3"></a><span class="line-modified"> 66     // FIXME: at the moment, only allow to attach AccessibilityObjects.</span>
<span class="line-modified"> 67     if (!is&lt;AccessibilityObject&gt;(obj))</span>
<span class="line-added"> 68         return;</span>
<span class="line-added"> 69     AccessibilityObject* accessibilityObject = downcast&lt;AccessibilityObject&gt;(obj);</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71     GRefPtr&lt;WebKitAccessible&gt; wrapper = adoptGRef(webkitAccessibleNew(accessibilityObject));</span>
<span class="line-added"> 72     accessibilityObject-&gt;setWrapper(wrapper.get());</span>
 73 
 74     // If an object is being attached and we are not in the middle of a layout update, then
 75     // we should report ATs by emitting the children-changed::add signal from the parent.
<a name="4" id="anc4"></a><span class="line-modified"> 76     Document* document = accessibilityObject-&gt;document();</span>
 77     if (!document || document-&gt;childNeedsStyleRecalc())
 78         return;
 79 
 80     // Don&#39;t emit the signal when the actual object being added is not going to be exposed.
<a name="5" id="anc5"></a><span class="line-modified"> 81     if (accessibilityObject-&gt;accessibilityIsIgnoredByDefault())</span>
 82         return;
 83 
 84     // Don&#39;t emit the signal if the object being added is not -- or not yet -- rendered,
 85     // which can occur in nested iframes. In these instances we don&#39;t want to ignore the
 86     // child. But if an assistive technology is listening, AT-SPI2 will attempt to create
 87     // and cache the state set for the child upon emission of the signal. If the object
 88     // has not yet been rendered, this will result in a crash.
<a name="6" id="anc6"></a><span class="line-modified"> 89     if (!accessibilityObject-&gt;renderer())</span>
 90         return;
 91 
<a name="7" id="anc7"></a><span class="line-modified"> 92     m_deferredAttachedWrapperObjectList.add(accessibilityObject);</span>
 93 }
 94 
 95 void AXObjectCache::platformPerformDeferredCacheUpdate()
 96 {
 97     for (auto&amp; coreObject : m_deferredAttachedWrapperObjectList) {
 98         auto* wrapper = coreObject-&gt;wrapper();
 99         if (!wrapper)
100             continue;
101 
102         // Don&#39;t emit the signal for objects whose parents won&#39;t be exposed directly.
103         auto* coreParent = coreObject-&gt;parentObjectUnignored();
104         if (!coreParent || coreParent-&gt;accessibilityIsIgnoredByDefault())
105             continue;
106 
107         // Look for the right object to emit the signal from.
108         auto* atkParent = coreParent-&gt;wrapper();
109         if (!atkParent)
110             continue;
111 
112         size_t index = coreParent-&gt;children(false).find(coreObject);
113         g_signal_emit_by_name(atkParent, &quot;children-changed::add&quot;, index != notFound ? index : -1, wrapper);
114     }
115     m_deferredAttachedWrapperObjectList.clear();
116 
117     for (auto&amp; wrapper : m_deferredDetachedWrapperList) {
118         if (auto* atkParent = wrapperParent(wrapper.get())) {
119             // The accessibility hierarchy is already invalid, so the parent-children relationships
120             // in the AccessibilityObject tree are not there anymore, so we can&#39;t know the offset.
121             g_signal_emit_by_name(atkParent, &quot;children-changed::remove&quot;, -1, wrapper.get());
122         }
123     }
124     m_deferredDetachedWrapperList.clear();
125 }
126 
<a name="8" id="anc8"></a><span class="line-modified">127 static AXCoreObject* getListObject(AXCoreObject* object)</span>
128 {
129     // Only list boxes and menu lists supported so far.
130     if (!object-&gt;isListBox() &amp;&amp; !object-&gt;isMenuList())
131         return 0;
132 
133     // For list boxes the list object is just itself.
134     if (object-&gt;isListBox())
135         return object;
136 
137     // For menu lists we need to return the first accessible child,
138     // with role MenuListPopupRole, since that&#39;s the one holding the list
139     // of items with role MenuListOptionRole.
140     const AccessibilityObject::AccessibilityChildrenVector&amp; children = object-&gt;children();
141     if (!children.size())
142         return 0;
143 
<a name="9" id="anc9"></a><span class="line-modified">144     AXCoreObject* listObject = children.at(0).get();</span>
145     if (!listObject-&gt;isMenuListPopup())
146         return 0;
147 
148     return listObject;
149 }
150 
<a name="10" id="anc10"></a><span class="line-modified">151 static void notifyChildrenSelectionChange(AXCoreObject* object)</span>
152 {
153     // This static variables are needed to keep track of the old
154     // focused object and its associated list object, as per previous
155     // calls to this function, in order to properly decide whether to
156     // emit some signals or not.
<a name="11" id="anc11"></a><span class="line-modified">157     static NeverDestroyed&lt;RefPtr&lt;AXCoreObject&gt;&gt; oldListObject;</span>
<span class="line-modified">158     static NeverDestroyed&lt;RefPtr&lt;AXCoreObject&gt;&gt; oldFocusedObject;</span>
159 
160     // Only list boxes and menu lists supported so far.
161     if (!object || !(object-&gt;isListBox() || object-&gt;isMenuList()))
162         return;
163 
164     // Only support HTML select elements so far (ARIA selectors not supported).
165     Node* node = object-&gt;node();
166     if (!is&lt;HTMLSelectElement&gt;(node))
167         return;
168 
169     // Emit signal from the listbox&#39;s point of view first.
170     g_signal_emit_by_name(object-&gt;wrapper(), &quot;selection-changed&quot;);
171 
172     // Find the item where the selection change was triggered from.
173     HTMLSelectElement&amp; select = downcast&lt;HTMLSelectElement&gt;(*node);
174     int changedItemIndex = select.activeSelectionStartListIndex();
175 
<a name="12" id="anc12"></a><span class="line-modified">176     AXCoreObject* listObject = getListObject(object);</span>
177     if (!listObject) {
178         oldListObject.get() = nullptr;
179         return;
180     }
181 
182     const AccessibilityObject::AccessibilityChildrenVector&amp; items = listObject-&gt;children();
183     if (changedItemIndex &lt; 0 || changedItemIndex &gt;= static_cast&lt;int&gt;(items.size()))
184         return;
<a name="13" id="anc13"></a><span class="line-modified">185     AXCoreObject* item = items.at(changedItemIndex).get();</span>
186 
187     // Ensure the current list object is the same than the old one so
188     // further comparisons make sense. Otherwise, just reset
189     // oldFocusedObject so it won&#39;t be taken into account.
190     if (oldListObject.get() != listObject)
191         oldFocusedObject.get() = nullptr;
192 
193     WebKitAccessible* axItem = item ? item-&gt;wrapper() : nullptr;
194     WebKitAccessible* axOldFocusedObject = oldFocusedObject.get() ? oldFocusedObject.get()-&gt;wrapper() : nullptr;
195 
196     // Old focused object just lost focus, so emit the events.
197     if (axOldFocusedObject &amp;&amp; axItem != axOldFocusedObject) {
198         g_signal_emit_by_name(axOldFocusedObject, &quot;focus-event&quot;, false);
199         atk_object_notify_state_change(ATK_OBJECT(axOldFocusedObject), ATK_STATE_FOCUSED, false);
200     }
201 
202     // Emit needed events for the currently (un)selected item.
203     if (axItem) {
204         bool isSelected = item-&gt;isSelected();
205         atk_object_notify_state_change(ATK_OBJECT(axItem), ATK_STATE_SELECTED, isSelected);
206         // When the selection changes in a collapsed widget such as a combo box
207         // whose child menu is not showing, that collapsed widget retains focus.
208         if (!object-&gt;isCollapsed()) {
209             g_signal_emit_by_name(axItem, &quot;focus-event&quot;, isSelected);
210             atk_object_notify_state_change(ATK_OBJECT(axItem), ATK_STATE_FOCUSED, isSelected);
211         }
212     }
213 
214     // Update pointers to the previously involved objects.
215     oldListObject.get() = listObject;
216     oldFocusedObject.get() = item;
217 }
218 
<a name="14" id="anc14"></a><span class="line-modified">219 void AXObjectCache::postPlatformNotification(AXCoreObject* coreObject, AXNotification notification)</span>
220 {
221     auto* axObject = ATK_OBJECT(coreObject-&gt;wrapper());
222     if (!axObject)
223         return;
224 
225     switch (notification) {
226     case AXCheckedStateChanged:
227         if (!coreObject-&gt;isCheckboxOrRadio() &amp;&amp; !coreObject-&gt;isSwitch())
228             return;
229         atk_object_notify_state_change(axObject, ATK_STATE_CHECKED, coreObject-&gt;isChecked());
230         break;
231 
232     case AXSelectedChildrenChanged:
233     case AXMenuListValueChanged:
234         // Accessible focus claims should not be made if the associated widget is not focused.
235         if (notification == AXMenuListValueChanged &amp;&amp; coreObject-&gt;isMenuList() &amp;&amp; coreObject-&gt;isFocused()) {
236             g_signal_emit_by_name(axObject, &quot;focus-event&quot;, true);
237             atk_object_notify_state_change(axObject, ATK_STATE_FOCUSED, true);
238         }
239         notifyChildrenSelectionChange(coreObject);
240         break;
241 
242     case AXValueChanged:
243         if (ATK_IS_VALUE(axObject)) {
244             AtkPropertyValues propertyValues;
245             propertyValues.property_name = &quot;accessible-value&quot;;
246 
247             memset(&amp;propertyValues.new_value,  0, sizeof(GValue));
248 
249             double value;
250             atk_value_get_value_and_text(ATK_VALUE(axObject), &amp;value, nullptr);
251             g_value_set_double(g_value_init(&amp;propertyValues.new_value, G_TYPE_DOUBLE), value);
252 
253             g_signal_emit_by_name(axObject, &quot;property-change::accessible-value&quot;, &amp;propertyValues, NULL);
254         }
255         break;
256 
257     case AXInvalidStatusChanged:
258         atk_object_notify_state_change(axObject, ATK_STATE_INVALID_ENTRY, coreObject-&gt;invalidStatus() != &quot;false&quot;);
259         break;
260 
261     case AXElementBusyChanged:
262         atk_object_notify_state_change(axObject, ATK_STATE_BUSY, coreObject-&gt;isBusy());
263         break;
264 
265     case AXCurrentChanged:
266         atk_object_notify_state_change(axObject, ATK_STATE_ACTIVE, coreObject-&gt;currentState() != AccessibilityCurrentState::False);
267         break;
268 
269     case AXRowExpanded:
270         atk_object_notify_state_change(axObject, ATK_STATE_EXPANDED, true);
271         break;
272 
273     case AXRowCollapsed:
274         atk_object_notify_state_change(axObject, ATK_STATE_EXPANDED, false);
275         break;
276 
277     case AXExpandedChanged:
278         atk_object_notify_state_change(axObject, ATK_STATE_EXPANDED, coreObject-&gt;isExpanded());
279         break;
280 
281     case AXDisabledStateChanged: {
282         bool enabledState = coreObject-&gt;isEnabled();
283         atk_object_notify_state_change(axObject, ATK_STATE_ENABLED, enabledState);
284         atk_object_notify_state_change(axObject, ATK_STATE_SENSITIVE, enabledState);
285         break;
286     }
287 
288     case AXPressedStateChanged:
289         atk_object_notify_state_change(axObject, ATK_STATE_PRESSED, coreObject-&gt;isPressed());
290         break;
291 
292     case AXReadOnlyStatusChanged:
293         atk_object_notify_state_change(axObject, ATK_STATE_READ_ONLY, !coreObject-&gt;canSetValueAttribute());
294         break;
295 
296     case AXRequiredStatusChanged:
297         atk_object_notify_state_change(axObject, ATK_STATE_REQUIRED, coreObject-&gt;isRequired());
298         break;
299 
300     case AXActiveDescendantChanged:
<a name="15" id="anc15"></a><span class="line-modified">301         if (AXCoreObject* descendant = coreObject-&gt;activeDescendant())</span>
302             platformHandleFocusedUIElementChanged(nullptr, descendant-&gt;node());
303         break;
304 
305     default:
306         break;
307     }
308 }
309 
310 void AXObjectCache::nodeTextChangePlatformNotification(AccessibilityObject* object, AXTextChange textChange, unsigned offset, const String&amp; text)
311 {
312     if (!object || text.isEmpty())
313         return;
314 
<a name="16" id="anc16"></a><span class="line-modified">315     AXCoreObject* parentObject = object-&gt;isNonNativeTextControl() ? object : object-&gt;parentObjectUnignored();</span>
316     if (!parentObject)
317         return;
318 
319     auto* wrapper = parentObject-&gt;wrapper();
320     if (!wrapper || !ATK_IS_TEXT(wrapper))
321         return;
322 
323     Node* node = object-&gt;node();
324     if (!node)
325         return;
326 
327     // Ensure document&#39;s layout is up-to-date before using TextIterator.
328     Document&amp; document = node-&gt;document();
329     document.updateLayout();
330 
331     // Select the right signal to be emitted
332     CString detail;
333     switch (textChange) {
334     case AXTextInserted:
335         detail = &quot;text-insert&quot;;
336         break;
337     case AXTextDeleted:
338         detail = &quot;text-remove&quot;;
339         break;
340     case AXTextAttributesChanged:
341         detail = &quot;text-attributes-changed&quot;;
342         break;
343     }
344 
345     String textToEmit = text;
346     unsigned offsetToEmit = offset;
347 
348     // If the object we&#39;re emitting the signal from represents a
349     // password field, we will emit the masked text.
350     if (parentObject-&gt;isPasswordField()) {
351         String maskedText = parentObject-&gt;passwordFieldValue();
352         textToEmit = maskedText.substring(offset, text.length());
353     } else {
354         // Consider previous text objects that might be present for
355         // the current accessibility object to ensure we emit the
356         // right offset (e.g. multiline text areas).
357         auto range = Range::create(document, node-&gt;parentNode(), 0, node, 0);
358         offsetToEmit = offset + TextIterator::rangeLength(range.ptr());
359     }
360 
361     g_signal_emit_by_name(wrapper, detail.data(), offsetToEmit, textToEmit.length(), textToEmit.utf8().data());
362 }
363 
364 void AXObjectCache::frameLoadingEventPlatformNotification(AccessibilityObject* object, AXLoadingEvent loadingEvent)
365 {
366     if (!object)
367         return;
368 
369     auto* axObject = ATK_OBJECT(object-&gt;wrapper());
370     if (!axObject || !ATK_IS_DOCUMENT(axObject))
371         return;
372 
373     switch (loadingEvent) {
374     case AXObjectCache::AXLoadingStarted:
375         atk_object_notify_state_change(axObject, ATK_STATE_BUSY, true);
376         break;
377     case AXObjectCache::AXLoadingReloaded:
378         atk_object_notify_state_change(axObject, ATK_STATE_BUSY, true);
379         g_signal_emit_by_name(axObject, &quot;reload&quot;);
380         break;
381     case AXObjectCache::AXLoadingFailed:
382         g_signal_emit_by_name(axObject, &quot;load-stopped&quot;);
383         atk_object_notify_state_change(axObject, ATK_STATE_BUSY, false);
384         break;
385     case AXObjectCache::AXLoadingFinished:
386         g_signal_emit_by_name(axObject, &quot;load-complete&quot;);
387         atk_object_notify_state_change(axObject, ATK_STATE_BUSY, false);
388         break;
389     }
390 }
391 
392 void AXObjectCache::platformHandleFocusedUIElementChanged(Node* oldFocusedNode, Node* newFocusedNode)
393 {
394     RefPtr&lt;AccessibilityObject&gt; oldObject = getOrCreate(oldFocusedNode);
395     if (oldObject) {
396         auto* axObject = oldObject-&gt;wrapper();
397         g_signal_emit_by_name(axObject, &quot;focus-event&quot;, false);
398         atk_object_notify_state_change(ATK_OBJECT(axObject), ATK_STATE_FOCUSED, false);
399     }
400     RefPtr&lt;AccessibilityObject&gt; newObject = getOrCreate(newFocusedNode);
401     if (newObject) {
402         auto* axObject = newObject-&gt;wrapper();
403         g_signal_emit_by_name(axObject, &quot;focus-event&quot;, true);
404         atk_object_notify_state_change(ATK_OBJECT(axObject), ATK_STATE_FOCUSED, true);
405     }
406 }
407 
408 void AXObjectCache::handleScrolledToAnchor(const Node*)
409 {
410 }
411 
412 } // namespace WebCore
413 
414 #endif
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
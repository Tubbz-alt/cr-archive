<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/preprocess-idls.pl</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="generate-bindings.pl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../bridge/NP_jsobject.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/preprocess-idls.pl</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 57            &#39;supplementalMakefileDeps=s&#39; =&gt; \$supplementalMakefileDeps);
 58 
 59 die(&#39;Must specify #define macros using --defines.&#39;) unless defined($defines);
 60 die(&#39;Must specify an output file using --supplementalDependencyFile.&#39;) unless defined($supplementalDependencyFile);
 61 die(&#39;Must specify an output file using --windowConstructorsFile.&#39;) unless defined($windowConstructorsFile);
 62 die(&#39;Must specify an output file using --workerGlobalScopeConstructorsFile.&#39;) unless defined($workerGlobalScopeConstructorsFile);
 63 die(&#39;Must specify an output file using --dedicatedWorkerGlobalScopeConstructorsFile.&#39;) unless defined($dedicatedWorkerGlobalScopeConstructorsFile);
 64 die(&#39;Must specify an output file using --serviceWorkerGlobalScopeConstructorsFile.&#39;) unless defined($serviceWorkerGlobalScopeConstructorsFile);
 65 die(&#39;Must specify an output file using --workletGlobalScopeConstructorsFile.&#39;) unless defined($workletGlobalScopeConstructorsFile);
 66 die(&#39;Must specify an output file using --paintWorkletGlobalScopeConstructorsFile.&#39;) unless defined($paintWorkletGlobalScopeConstructorsFile);
 67 die(&#39;Must specify an output file using --testGlobalScopeConstructorsFile.&#39;) unless defined($testGlobalScopeConstructorsFile) || !defined($testGlobalContextName);
 68 die(&#39;Must specify the file listing all IDLs using --idlFilesList.&#39;) unless defined($idlFilesList);
 69 
 70 $supplementalDependencyFile = CygwinPathIfNeeded($supplementalDependencyFile);
 71 $windowConstructorsFile = CygwinPathIfNeeded($windowConstructorsFile);
 72 $workerGlobalScopeConstructorsFile = CygwinPathIfNeeded($workerGlobalScopeConstructorsFile);
 73 $dedicatedWorkerGlobalScopeConstructorsFile = CygwinPathIfNeeded($dedicatedWorkerGlobalScopeConstructorsFile);
 74 $serviceWorkerGlobalScopeConstructorsFile = CygwinPathIfNeeded($serviceWorkerGlobalScopeConstructorsFile);
 75 $workletGlobalScopeConstructorsFile = CygwinPathIfNeeded($workletGlobalScopeConstructorsFile);
 76 $paintWorkletGlobalScopeConstructorsFile = CygwinPathIfNeeded($paintWorkletGlobalScopeConstructorsFile);
<span class="line-modified"> 77 $supplementalMakefileDeps = CygwinPathIfNeeded($supplementalMakefileDeps);</span>
 78 
<span class="line-modified"> 79 open FH, &quot;&lt; $idlFilesList&quot; or die &quot;Cannot open $idlFilesList\n&quot;;</span>
<span class="line-modified"> 80 my @idlFilesIn = &lt;FH&gt;;</span>
<span class="line-modified"> 81 chomp(@idlFilesIn);</span>
<span class="line-modified"> 82 my @idlFiles = ();</span>
<span class="line-removed"> 83 foreach (@idlFilesIn) {</span>
<span class="line-removed"> 84     push @idlFiles, CygwinPathIfNeeded($_);</span>
<span class="line-removed"> 85 }</span>
<span class="line-removed"> 86 close FH;</span>
 87 
 88 my %interfaceNameToIdlFile;
 89 my %idlFileToInterfaceName;
 90 my %supplementalDependencies;
 91 my %supplementals;
 92 my $windowConstructorsCode = &quot;&quot;;
 93 my $workerGlobalScopeConstructorsCode = &quot;&quot;;
 94 my $dedicatedWorkerGlobalScopeConstructorsCode = &quot;&quot;;
 95 my $serviceWorkerGlobalScopeConstructorsCode = &quot;&quot;;
 96 my $workletGlobalScopeConstructorsCode = &quot;&quot;;
 97 my $paintWorkletGlobalScopeConstructorsCode = &quot;&quot;;
 98 my $testGlobalScopeConstructorsCode = &quot;&quot;;
 99 
100 # Get rid of duplicates in idlFiles array.
101 my %idlFileHash = map { $_, 1 } @idlFiles;
102 
103 # Populate $idlFileToInterfaceName and $interfaceNameToIdlFile.
104 foreach my $idlFile (sort keys %idlFileHash) {

105     my $fullPath = Cwd::realpath($idlFile);
106     my $interfaceName = fileparse(basename($idlFile), &quot;.idl&quot;);
107     $idlFileToInterfaceName{$fullPath} = $interfaceName;
108     $interfaceNameToIdlFile{$interfaceName} = $fullPath;
109 }
110 
111 # Parse all IDL files.
112 foreach my $idlFile (sort keys %idlFileHash) {

113     my $fullPath = Cwd::realpath($idlFile);
114     my $idlFileContents = getFileContents($fullPath);
115     # Handle partial names.
116     my $partialNames = getPartialNamesFromIDL($idlFileContents);
117     if (@{$partialNames}) {
118         $supplementalDependencies{$fullPath} = $partialNames;
119         next;
120     }
121 
122     $supplementals{$fullPath} = [];
123 
124     # Skip if the IDL file does not contain an interface, a callback interface or an exception.
125     # The IDL may contain a dictionary.
126     next unless containsInterfaceOrExceptionFromIDL($idlFileContents);
127 
128     my $interfaceName = fileparse(basename($idlFile), &quot;.idl&quot;);
129     # Handle implements statements.
130     my $implementedInterfaces = getImplementedInterfacesFromIDL($idlFileContents, $interfaceName);
131     foreach my $implementedInterface (@{$implementedInterfaces}) {
132         my $implementedIdlFile = $interfaceNameToIdlFile{$implementedInterface};
</pre>
<hr />
<pre>
211 WriteFileIfChanged($supplementalDependencyFile, $dependencies);
212 
213 if ($supplementalMakefileDeps) {
214     my $makefileDeps = &quot;&quot;;
215     foreach my $idlFile (sort keys %supplementals) {
216         my $basename = $idlFileToInterfaceName{$idlFile};
217 
218         my @dependencies = map { basename($_) } @{$supplementals{$idlFile}};
219 
220         $makefileDeps .= &quot;JS${basename}.h: @{dependencies}\n&quot;;
221         $makefileDeps .= &quot;DOM${basename}.h: @{dependencies}\n&quot;;
222         $makefileDeps .= &quot;WebDOM${basename}.h: @{dependencies}\n&quot;;
223         foreach my $dependency (@dependencies) {
224             $makefileDeps .= &quot;${dependency}:\n&quot;;
225         }
226     }
227 
228     WriteFileIfChanged($supplementalMakefileDeps, $makefileDeps);
229 }
230 
<span class="line-removed">231 my $cygwinPathAdded;</span>
232 sub CygwinPathIfNeeded
233 {
234     my $path = shift;
<span class="line-modified">235     if ($path &amp;&amp; $Config{osname} eq &quot;cygwin&quot;) {</span>
<span class="line-removed">236         if (not $cygwinPathAdded) {</span>
<span class="line-removed">237             $ENV{PATH} = &quot;$ENV{PATH}:/cygdrive/c/cygwin/bin&quot;;</span>
<span class="line-removed">238             $cygwinPathAdded = 1; </span>
<span class="line-removed">239         }</span>
<span class="line-removed">240         chomp($path = `cygpath -u &#39;$path&#39;`);</span>
<span class="line-removed">241         $path =~ s/[\r\n]//;</span>
<span class="line-removed">242     }</span>
243     return $path;
244 }
245 
246 sub WriteFileIfChanged
247 {
248     my $fileName = shift;
249     my $contents = shift;
250 
251     if (-f $fileName) {
252         open FH, &quot;&lt;&quot;, $fileName or die &quot;Couldn&#39;t open $fileName: $!\n&quot;;
253         my @lines = &lt;FH&gt;;
254         my $oldContents = join &quot;&quot;, @lines;
255         close FH;
256         return if $contents eq $oldContents;
257     }
258     open FH, &quot;&gt;&quot;, $fileName or die &quot;Couldn&#39;t open $fileName: $!\n&quot;;
259     print FH $contents;
260     close FH;
261 }
262 
</pre>
<hr />
<pre>
266     my $attributesCode = shift;
267     my $destinationFile = shift;
268 
269     my $contents = &quot;partial interface ${interfaceName} {\n$attributesCode};\n&quot;;
270     WriteFileIfChanged($destinationFile, $contents);
271 
272     my $fullPath = Cwd::realpath($destinationFile);
273     $supplementalDependencies{$fullPath} = [$interfaceName] if $interfaceNameToIdlFile{$interfaceName};
274 }
275 
276 sub GenerateConstructorAttributes
277 {
278     my $interfaceName = shift;
279     my $extendedAttributes = shift;
280 
281     my $code = &quot;    &quot;;
282     my @extendedAttributesList;
283     foreach my $attributeName (sort keys %{$extendedAttributes}) {
284       next unless ($attributeName eq &quot;Conditional&quot; || $attributeName eq &quot;EnabledAtRuntime&quot; || $attributeName eq &quot;EnabledForWorld&quot;
285         || $attributeName eq &quot;EnabledBySetting&quot; || $attributeName eq &quot;SecureContext&quot; || $attributeName eq &quot;PrivateIdentifier&quot;
<span class="line-modified">286         || $attributeName eq &quot;PublicIdentifier&quot; || $attributeName eq &quot;DisabledByQuirk&quot; || $attributeName eq &quot;EnabledByQuirk&quot; || $attributeName eq &quot;EnabledForContext&quot; || $attributeName eq &quot;CustomEnabled&quot;);</span>

287       my $extendedAttribute = $attributeName;
288       $extendedAttribute .= &quot;=&quot; . $extendedAttributes-&gt;{$attributeName} unless $extendedAttributes-&gt;{$attributeName} eq &quot;VALUE_IS_MISSING&quot;;
289       push(@extendedAttributesList, $extendedAttribute);
290     }
291     $code .= &quot;[&quot; . join(&#39;, &#39;, @extendedAttributesList) . &quot;] &quot; if @extendedAttributesList;
292 
293     my $originalInterfaceName = $interfaceName;
294     $interfaceName = $extendedAttributes-&gt;{&quot;InterfaceName&quot;} if $extendedAttributes-&gt;{&quot;InterfaceName&quot;};
295     $code .= &quot;attribute &quot; . $originalInterfaceName . &quot;Constructor $interfaceName;\n&quot;;
296 
297     # In addition to the regular property, for every [NamedConstructor] extended attribute on an interface,
298     # a corresponding property MUST exist on the ECMAScript global object.
299     if ($extendedAttributes-&gt;{&quot;NamedConstructor&quot;}) {
300         my $constructorName = $extendedAttributes-&gt;{&quot;NamedConstructor&quot;};
301         $constructorName =~ s/\(.*//g; # Extract function name.
302         $code .= &quot;    &quot;;
303         $code .= &quot;[&quot; . join(&#39;, &#39;, @extendedAttributesList) . &quot;] &quot; if @extendedAttributesList;
304         $code .= &quot;attribute &quot; . $originalInterfaceName . &quot;NamedConstructor $constructorName;\n&quot;;
305     }
306     
</pre>
</td>
<td>
<hr />
<pre>
 57            &#39;supplementalMakefileDeps=s&#39; =&gt; \$supplementalMakefileDeps);
 58 
 59 die(&#39;Must specify #define macros using --defines.&#39;) unless defined($defines);
 60 die(&#39;Must specify an output file using --supplementalDependencyFile.&#39;) unless defined($supplementalDependencyFile);
 61 die(&#39;Must specify an output file using --windowConstructorsFile.&#39;) unless defined($windowConstructorsFile);
 62 die(&#39;Must specify an output file using --workerGlobalScopeConstructorsFile.&#39;) unless defined($workerGlobalScopeConstructorsFile);
 63 die(&#39;Must specify an output file using --dedicatedWorkerGlobalScopeConstructorsFile.&#39;) unless defined($dedicatedWorkerGlobalScopeConstructorsFile);
 64 die(&#39;Must specify an output file using --serviceWorkerGlobalScopeConstructorsFile.&#39;) unless defined($serviceWorkerGlobalScopeConstructorsFile);
 65 die(&#39;Must specify an output file using --workletGlobalScopeConstructorsFile.&#39;) unless defined($workletGlobalScopeConstructorsFile);
 66 die(&#39;Must specify an output file using --paintWorkletGlobalScopeConstructorsFile.&#39;) unless defined($paintWorkletGlobalScopeConstructorsFile);
 67 die(&#39;Must specify an output file using --testGlobalScopeConstructorsFile.&#39;) unless defined($testGlobalScopeConstructorsFile) || !defined($testGlobalContextName);
 68 die(&#39;Must specify the file listing all IDLs using --idlFilesList.&#39;) unless defined($idlFilesList);
 69 
 70 $supplementalDependencyFile = CygwinPathIfNeeded($supplementalDependencyFile);
 71 $windowConstructorsFile = CygwinPathIfNeeded($windowConstructorsFile);
 72 $workerGlobalScopeConstructorsFile = CygwinPathIfNeeded($workerGlobalScopeConstructorsFile);
 73 $dedicatedWorkerGlobalScopeConstructorsFile = CygwinPathIfNeeded($dedicatedWorkerGlobalScopeConstructorsFile);
 74 $serviceWorkerGlobalScopeConstructorsFile = CygwinPathIfNeeded($serviceWorkerGlobalScopeConstructorsFile);
 75 $workletGlobalScopeConstructorsFile = CygwinPathIfNeeded($workletGlobalScopeConstructorsFile);
 76 $paintWorkletGlobalScopeConstructorsFile = CygwinPathIfNeeded($paintWorkletGlobalScopeConstructorsFile);
<span class="line-modified"> 77 $supplementalMakefileDeps = CygwinPathIfNeeded($supplementalMakefileDeps) if defined($supplementalMakefileDeps);</span>
 78 
<span class="line-modified"> 79 my @idlFiles;</span>
<span class="line-modified"> 80 open(my $fh, &#39;&lt;&#39;, $idlFilesList) or die &quot;Cannot open $idlFilesList&quot;;</span>
<span class="line-modified"> 81 @idlFiles = map { CygwinPathIfNeeded(s/\r?\n?$//r) } &lt;$fh&gt;;</span>
<span class="line-modified"> 82 close($fh) or die;</span>




 83 
 84 my %interfaceNameToIdlFile;
 85 my %idlFileToInterfaceName;
 86 my %supplementalDependencies;
 87 my %supplementals;
 88 my $windowConstructorsCode = &quot;&quot;;
 89 my $workerGlobalScopeConstructorsCode = &quot;&quot;;
 90 my $dedicatedWorkerGlobalScopeConstructorsCode = &quot;&quot;;
 91 my $serviceWorkerGlobalScopeConstructorsCode = &quot;&quot;;
 92 my $workletGlobalScopeConstructorsCode = &quot;&quot;;
 93 my $paintWorkletGlobalScopeConstructorsCode = &quot;&quot;;
 94 my $testGlobalScopeConstructorsCode = &quot;&quot;;
 95 
 96 # Get rid of duplicates in idlFiles array.
 97 my %idlFileHash = map { $_, 1 } @idlFiles;
 98 
 99 # Populate $idlFileToInterfaceName and $interfaceNameToIdlFile.
100 foreach my $idlFile (sort keys %idlFileHash) {
<span class="line-added">101     $idlFile =~ s/\s*$//g;</span>
102     my $fullPath = Cwd::realpath($idlFile);
103     my $interfaceName = fileparse(basename($idlFile), &quot;.idl&quot;);
104     $idlFileToInterfaceName{$fullPath} = $interfaceName;
105     $interfaceNameToIdlFile{$interfaceName} = $fullPath;
106 }
107 
108 # Parse all IDL files.
109 foreach my $idlFile (sort keys %idlFileHash) {
<span class="line-added">110     $idlFile =~ s/\s*$//g;</span>
111     my $fullPath = Cwd::realpath($idlFile);
112     my $idlFileContents = getFileContents($fullPath);
113     # Handle partial names.
114     my $partialNames = getPartialNamesFromIDL($idlFileContents);
115     if (@{$partialNames}) {
116         $supplementalDependencies{$fullPath} = $partialNames;
117         next;
118     }
119 
120     $supplementals{$fullPath} = [];
121 
122     # Skip if the IDL file does not contain an interface, a callback interface or an exception.
123     # The IDL may contain a dictionary.
124     next unless containsInterfaceOrExceptionFromIDL($idlFileContents);
125 
126     my $interfaceName = fileparse(basename($idlFile), &quot;.idl&quot;);
127     # Handle implements statements.
128     my $implementedInterfaces = getImplementedInterfacesFromIDL($idlFileContents, $interfaceName);
129     foreach my $implementedInterface (@{$implementedInterfaces}) {
130         my $implementedIdlFile = $interfaceNameToIdlFile{$implementedInterface};
</pre>
<hr />
<pre>
209 WriteFileIfChanged($supplementalDependencyFile, $dependencies);
210 
211 if ($supplementalMakefileDeps) {
212     my $makefileDeps = &quot;&quot;;
213     foreach my $idlFile (sort keys %supplementals) {
214         my $basename = $idlFileToInterfaceName{$idlFile};
215 
216         my @dependencies = map { basename($_) } @{$supplementals{$idlFile}};
217 
218         $makefileDeps .= &quot;JS${basename}.h: @{dependencies}\n&quot;;
219         $makefileDeps .= &quot;DOM${basename}.h: @{dependencies}\n&quot;;
220         $makefileDeps .= &quot;WebDOM${basename}.h: @{dependencies}\n&quot;;
221         foreach my $dependency (@dependencies) {
222             $makefileDeps .= &quot;${dependency}:\n&quot;;
223         }
224     }
225 
226     WriteFileIfChanged($supplementalMakefileDeps, $makefileDeps);
227 }
228 

229 sub CygwinPathIfNeeded
230 {
231     my $path = shift;
<span class="line-modified">232     return Cygwin::win_to_posix_path($path) if ($^O eq &#39;cygwin&#39;);</span>







233     return $path;
234 }
235 
236 sub WriteFileIfChanged
237 {
238     my $fileName = shift;
239     my $contents = shift;
240 
241     if (-f $fileName) {
242         open FH, &quot;&lt;&quot;, $fileName or die &quot;Couldn&#39;t open $fileName: $!\n&quot;;
243         my @lines = &lt;FH&gt;;
244         my $oldContents = join &quot;&quot;, @lines;
245         close FH;
246         return if $contents eq $oldContents;
247     }
248     open FH, &quot;&gt;&quot;, $fileName or die &quot;Couldn&#39;t open $fileName: $!\n&quot;;
249     print FH $contents;
250     close FH;
251 }
252 
</pre>
<hr />
<pre>
256     my $attributesCode = shift;
257     my $destinationFile = shift;
258 
259     my $contents = &quot;partial interface ${interfaceName} {\n$attributesCode};\n&quot;;
260     WriteFileIfChanged($destinationFile, $contents);
261 
262     my $fullPath = Cwd::realpath($destinationFile);
263     $supplementalDependencies{$fullPath} = [$interfaceName] if $interfaceNameToIdlFile{$interfaceName};
264 }
265 
266 sub GenerateConstructorAttributes
267 {
268     my $interfaceName = shift;
269     my $extendedAttributes = shift;
270 
271     my $code = &quot;    &quot;;
272     my @extendedAttributesList;
273     foreach my $attributeName (sort keys %{$extendedAttributes}) {
274       next unless ($attributeName eq &quot;Conditional&quot; || $attributeName eq &quot;EnabledAtRuntime&quot; || $attributeName eq &quot;EnabledForWorld&quot;
275         || $attributeName eq &quot;EnabledBySetting&quot; || $attributeName eq &quot;SecureContext&quot; || $attributeName eq &quot;PrivateIdentifier&quot;
<span class="line-modified">276         || $attributeName eq &quot;PublicIdentifier&quot; || $attributeName eq &quot;DisabledByQuirk&quot; || $attributeName eq &quot;EnabledByQuirk&quot;</span>
<span class="line-added">277         || $attributeName eq &quot;EnabledForContext&quot; || $attributeName eq &quot;CustomEnabled&quot;) || $attributeName eq &quot;ConstructorEnabledBySetting&quot;;</span>
278       my $extendedAttribute = $attributeName;
279       $extendedAttribute .= &quot;=&quot; . $extendedAttributes-&gt;{$attributeName} unless $extendedAttributes-&gt;{$attributeName} eq &quot;VALUE_IS_MISSING&quot;;
280       push(@extendedAttributesList, $extendedAttribute);
281     }
282     $code .= &quot;[&quot; . join(&#39;, &#39;, @extendedAttributesList) . &quot;] &quot; if @extendedAttributesList;
283 
284     my $originalInterfaceName = $interfaceName;
285     $interfaceName = $extendedAttributes-&gt;{&quot;InterfaceName&quot;} if $extendedAttributes-&gt;{&quot;InterfaceName&quot;};
286     $code .= &quot;attribute &quot; . $originalInterfaceName . &quot;Constructor $interfaceName;\n&quot;;
287 
288     # In addition to the regular property, for every [NamedConstructor] extended attribute on an interface,
289     # a corresponding property MUST exist on the ECMAScript global object.
290     if ($extendedAttributes-&gt;{&quot;NamedConstructor&quot;}) {
291         my $constructorName = $extendedAttributes-&gt;{&quot;NamedConstructor&quot;};
292         $constructorName =~ s/\(.*//g; # Extract function name.
293         $code .= &quot;    &quot;;
294         $code .= &quot;[&quot; . join(&#39;, &#39;, @extendedAttributesList) . &quot;] &quot; if @extendedAttributesList;
295         $code .= &quot;attribute &quot; . $originalInterfaceName . &quot;NamedConstructor $constructorName;\n&quot;;
296     }
297     
</pre>
</td>
</tr>
</table>
<center><a href="generate-bindings.pl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../bridge/NP_jsobject.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoCellSetInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IsoCellSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoSubspace.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoCellSetInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,30 ***</span>
<span class="line-new-header">--- 31,36 ---</span>
  
  namespace JSC {
  
  inline bool IsoCellSet::add(HeapCell* cell)
  {
<span class="line-added">+     if (cell-&gt;isPreciseAllocation())</span>
<span class="line-added">+         return !m_lowerTierBits.concurrentTestAndSet(cell-&gt;preciseAllocation().lowerTierIndex());</span>
      AtomIndices atomIndices(cell);
      auto&amp; bitsPtrRef = m_bits[atomIndices.blockIndex];
      auto* bits = bitsPtrRef.get();
      if (UNLIKELY(!bits))
          bits = addSlow(atomIndices.blockIndex);
      return !bits-&gt;concurrentTestAndSet(atomIndices.atomNumber);
  }
  
  inline bool IsoCellSet::remove(HeapCell* cell)
  {
<span class="line-added">+     if (cell-&gt;isPreciseAllocation())</span>
<span class="line-added">+         return !m_lowerTierBits.concurrentTestAndClear(cell-&gt;preciseAllocation().lowerTierIndex());</span>
      AtomIndices atomIndices(cell);
      auto&amp; bitsPtrRef = m_bits[atomIndices.blockIndex];
      auto* bits = bitsPtrRef.get();
      if (!bits)
          return false;
      return bits-&gt;concurrentTestAndClear(atomIndices.atomNumber);
  }
  
  inline bool IsoCellSet::contains(HeapCell* cell) const
  {
<span class="line-added">+     if (cell-&gt;isPreciseAllocation())</span>
<span class="line-added">+         return !m_lowerTierBits.get(cell-&gt;preciseAllocation().lowerTierIndex());</span>
      AtomIndices atomIndices(cell);
      auto* bits = m_bits[atomIndices.blockIndex].get();
      if (bits)
          return bits-&gt;get(atomIndices.atomNumber);
      return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,22 ***</span>
  
  template&lt;typename Func&gt;
  void IsoCellSet::forEachMarkedCell(const Func&amp; func)
  {
      BlockDirectory&amp; directory = m_subspace.m_directory;
<span class="line-modified">!     (directory.m_markingNotEmpty &amp; m_blocksWithBits).forEachSetBit(</span>
<span class="line-modified">!         [&amp;] (size_t blockIndex) {</span>
              MarkedBlock::Handle* block = directory.m_blocks[blockIndex];
  
              auto* bits = m_bits[blockIndex].get();
              block-&gt;forEachMarkedCell(
<span class="line-modified">!                 [&amp;] (size_t atomNumber, HeapCell* cell, HeapCell::Kind kind) -&gt; IterationStatus {</span>
                      if (bits-&gt;get(atomNumber))
                          func(cell, kind);
                      return IterationStatus::Continue;
                  });
          });
  }
  
  template&lt;typename Func&gt;
  Ref&lt;SharedTask&lt;void(SlotVisitor&amp;)&gt;&gt; IsoCellSet::forEachMarkedCellInParallel(const Func&amp; func)
  {
<span class="line-new-header">--- 68,29 ---</span>
  
  template&lt;typename Func&gt;
  void IsoCellSet::forEachMarkedCell(const Func&amp; func)
  {
      BlockDirectory&amp; directory = m_subspace.m_directory;
<span class="line-modified">!     (directory.m_bits.markingNotEmpty() &amp; m_blocksWithBits).forEachSetBit(</span>
<span class="line-modified">!         [&amp;] (unsigned blockIndex) {</span>
              MarkedBlock::Handle* block = directory.m_blocks[blockIndex];
  
              auto* bits = m_bits[blockIndex].get();
              block-&gt;forEachMarkedCell(
<span class="line-modified">!                 [&amp;] (unsigned atomNumber, HeapCell* cell, HeapCell::Kind kind) -&gt; IterationStatus {</span>
                      if (bits-&gt;get(atomNumber))
                          func(cell, kind);
                      return IterationStatus::Continue;
                  });
          });
<span class="line-added">+ </span>
<span class="line-added">+     CellAttributes attributes = m_subspace.attributes();</span>
<span class="line-added">+     m_subspace.forEachPreciseAllocation(</span>
<span class="line-added">+         [&amp;] (PreciseAllocation* allocation) {</span>
<span class="line-added">+             if (m_lowerTierBits.get(allocation-&gt;lowerTierIndex()) &amp;&amp; allocation-&gt;isMarked())</span>
<span class="line-added">+                 func(allocation-&gt;cell(), attributes.cellKind);</span>
<span class="line-added">+         });</span>
  }
  
  template&lt;typename Func&gt;
  Ref&lt;SharedTask&lt;void(SlotVisitor&amp;)&gt;&gt; IsoCellSet::forEachMarkedCellInParallel(const Func&amp; func)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,48 ***</span>
          }
  
          void run(SlotVisitor&amp; visitor) override
          {
              while (MarkedBlock::Handle* handle = m_blockSource-&gt;run()) {
<span class="line-modified">!                 size_t blockIndex = handle-&gt;index();</span>
                  auto* bits = m_set.m_bits[blockIndex].get();
                  handle-&gt;forEachMarkedCell(
<span class="line-modified">!                     [&amp;] (size_t atomNumber, HeapCell* cell, HeapCell::Kind kind) -&gt; IterationStatus {</span>
                          if (bits-&gt;get(atomNumber))
                              m_func(visitor, cell, kind);
                          return IterationStatus::Continue;
                      });
              }
          }
  
      private:
          IsoCellSet&amp; m_set;
          Ref&lt;SharedTask&lt;MarkedBlock::Handle*()&gt;&gt; m_blockSource;
          Func m_func;
          Lock m_lock;
      };
  
      return adoptRef(*new Task(*this, func));
  }
  
  template&lt;typename Func&gt;
  void IsoCellSet::forEachLiveCell(const Func&amp; func)
  {
      BlockDirectory&amp; directory = m_subspace.m_directory;
      m_blocksWithBits.forEachSetBit(
<span class="line-modified">!         [&amp;] (size_t blockIndex) {</span>
              MarkedBlock::Handle* block = directory.m_blocks[blockIndex];
  
<span class="line-removed">-             // FIXME: We could optimize this by checking our bits before querying isLive.</span>
<span class="line-removed">-             // OOPS! (need bug URL)</span>
              auto* bits = m_bits[blockIndex].get();
<span class="line-modified">!             block-&gt;forEachLiveCell(</span>
<span class="line-modified">!                 [&amp;] (size_t atomNumber, HeapCell* cell, HeapCell::Kind kind) -&gt; IterationStatus {</span>
<span class="line-modified">!                     if (bits-&gt;get(atomNumber))</span>
                          func(cell, kind);
                      return IterationStatus::Continue;
                  });
          });
  }
  
  } // namespace JSC
  
<span class="line-new-header">--- 104,73 ---</span>
          }
  
          void run(SlotVisitor&amp; visitor) override
          {
              while (MarkedBlock::Handle* handle = m_blockSource-&gt;run()) {
<span class="line-modified">!                 unsigned blockIndex = handle-&gt;index();</span>
                  auto* bits = m_set.m_bits[blockIndex].get();
                  handle-&gt;forEachMarkedCell(
<span class="line-modified">!                     [&amp;] (unsigned atomNumber, HeapCell* cell, HeapCell::Kind kind) -&gt; IterationStatus {</span>
                          if (bits-&gt;get(atomNumber))
                              m_func(visitor, cell, kind);
                          return IterationStatus::Continue;
                      });
              }
<span class="line-added">+ </span>
<span class="line-added">+             {</span>
<span class="line-added">+                 auto locker = holdLock(m_lock);</span>
<span class="line-added">+                 if (!m_needToVisitPreciseAllocations)</span>
<span class="line-added">+                     return;</span>
<span class="line-added">+                 m_needToVisitPreciseAllocations = false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             CellAttributes attributes = m_set.m_subspace.attributes();</span>
<span class="line-added">+             m_set.m_subspace.forEachPreciseAllocation(</span>
<span class="line-added">+                 [&amp;] (PreciseAllocation* allocation) {</span>
<span class="line-added">+                     if (m_set.m_lowerTierBits.get(allocation-&gt;lowerTierIndex()) &amp;&amp; allocation-&gt;isMarked())</span>
<span class="line-added">+                         m_func(visitor, allocation-&gt;cell(), attributes.cellKind);</span>
<span class="line-added">+                 });</span>
          }
  
      private:
          IsoCellSet&amp; m_set;
          Ref&lt;SharedTask&lt;MarkedBlock::Handle*()&gt;&gt; m_blockSource;
          Func m_func;
          Lock m_lock;
<span class="line-added">+         bool m_needToVisitPreciseAllocations { true };</span>
      };
  
      return adoptRef(*new Task(*this, func));
  }
  
  template&lt;typename Func&gt;
  void IsoCellSet::forEachLiveCell(const Func&amp; func)
  {
      BlockDirectory&amp; directory = m_subspace.m_directory;
      m_blocksWithBits.forEachSetBit(
<span class="line-modified">!         [&amp;] (unsigned blockIndex) {</span>
              MarkedBlock::Handle* block = directory.m_blocks[blockIndex];
  
              auto* bits = m_bits[blockIndex].get();
<span class="line-modified">!             block-&gt;forEachCell(</span>
<span class="line-modified">!                 [&amp;] (unsigned atomNumber, HeapCell* cell, HeapCell::Kind kind) -&gt; IterationStatus {</span>
<span class="line-modified">!                     if (bits-&gt;get(atomNumber) &amp;&amp; block-&gt;isLive(cell))</span>
                          func(cell, kind);
                      return IterationStatus::Continue;
                  });
          });
<span class="line-added">+ </span>
<span class="line-added">+     CellAttributes attributes = m_subspace.attributes();</span>
<span class="line-added">+     m_subspace.forEachPreciseAllocation(</span>
<span class="line-added">+         [&amp;] (PreciseAllocation* allocation) {</span>
<span class="line-added">+             if (m_lowerTierBits.get(allocation-&gt;lowerTierIndex()) &amp;&amp; allocation-&gt;isLive())</span>
<span class="line-added">+                 func(allocation-&gt;cell(), attributes.cellKind);</span>
<span class="line-added">+         });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline void IsoCellSet::clearLowerTierCell(unsigned index)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_lowerTierBits.concurrentTestAndClear(index);</span>
  }
  
  } // namespace JSC
  
</pre>
<center><a href="IsoCellSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoSubspace.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedBytecode.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CachePayload.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CachedTypes.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedBytecode.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
34 #include &lt;wtf/Vector.h&gt;
35 
36 namespace JSC {
37 
38 class UnlinkedFunctionExecutable;
39 
40 class CachedBytecode : public RefCounted&lt;CachedBytecode&gt; {
41     WTF_MAKE_NONCOPYABLE(CachedBytecode);
42 
43 public:
44     static Ref&lt;CachedBytecode&gt; create()
45     {
46         return adoptRef(*new CachedBytecode(CachePayload::makeEmptyPayload()));
47     }
48 
49     static Ref&lt;CachedBytecode&gt; create(FileSystem::MappedFileData&amp;&amp; data, LeafExecutableMap&amp;&amp; leafExecutables = { })
50     {
51         return adoptRef(*new CachedBytecode(CachePayload::makeMappedPayload(WTFMove(data)), WTFMove(leafExecutables)));
52     }
53 
<span class="line-modified">54     static Ref&lt;CachedBytecode&gt; create(MallocPtr&lt;uint8_t&gt;&amp;&amp; data, size_t size, LeafExecutableMap&amp;&amp; leafExecutables)</span>
55     {
56         return adoptRef(*new CachedBytecode(CachePayload::makeMallocPayload(WTFMove(data), size), WTFMove(leafExecutables)));
57     }
58 
59     LeafExecutableMap&amp; leafExecutables() { return m_leafExecutables; }
60 
61     JS_EXPORT_PRIVATE void addGlobalUpdate(Ref&lt;CachedBytecode&gt;);
62     JS_EXPORT_PRIVATE void addFunctionUpdate(const UnlinkedFunctionExecutable*, CodeSpecializationKind, Ref&lt;CachedBytecode&gt;);
63 
64     using ForEachUpdateCallback = Function&lt;void(off_t, const void*, size_t)&gt;;
65     JS_EXPORT_PRIVATE void commitUpdates(const ForEachUpdateCallback&amp;) const;
66 
67     const uint8_t* data() const { return m_payload.data(); }
68     size_t size() const { return m_payload.size(); }
69     bool hasUpdates() const { return !m_updates.isEmpty(); }
70     size_t sizeForUpdate() const { return m_size; }
71 
72 private:
73     CachedBytecode(CachePayload&amp;&amp; payload, LeafExecutableMap&amp;&amp; leafExecutables = { })
74         : m_size(payload.size())
</pre>
</td>
<td>
<hr />
<pre>
34 #include &lt;wtf/Vector.h&gt;
35 
36 namespace JSC {
37 
38 class UnlinkedFunctionExecutable;
39 
40 class CachedBytecode : public RefCounted&lt;CachedBytecode&gt; {
41     WTF_MAKE_NONCOPYABLE(CachedBytecode);
42 
43 public:
44     static Ref&lt;CachedBytecode&gt; create()
45     {
46         return adoptRef(*new CachedBytecode(CachePayload::makeEmptyPayload()));
47     }
48 
49     static Ref&lt;CachedBytecode&gt; create(FileSystem::MappedFileData&amp;&amp; data, LeafExecutableMap&amp;&amp; leafExecutables = { })
50     {
51         return adoptRef(*new CachedBytecode(CachePayload::makeMappedPayload(WTFMove(data)), WTFMove(leafExecutables)));
52     }
53 
<span class="line-modified">54     static Ref&lt;CachedBytecode&gt; create(MallocPtr&lt;uint8_t, VMMalloc&gt;&amp;&amp; data, size_t size, LeafExecutableMap&amp;&amp; leafExecutables)</span>
55     {
56         return adoptRef(*new CachedBytecode(CachePayload::makeMallocPayload(WTFMove(data), size), WTFMove(leafExecutables)));
57     }
58 
59     LeafExecutableMap&amp; leafExecutables() { return m_leafExecutables; }
60 
61     JS_EXPORT_PRIVATE void addGlobalUpdate(Ref&lt;CachedBytecode&gt;);
62     JS_EXPORT_PRIVATE void addFunctionUpdate(const UnlinkedFunctionExecutable*, CodeSpecializationKind, Ref&lt;CachedBytecode&gt;);
63 
64     using ForEachUpdateCallback = Function&lt;void(off_t, const void*, size_t)&gt;;
65     JS_EXPORT_PRIVATE void commitUpdates(const ForEachUpdateCallback&amp;) const;
66 
67     const uint8_t* data() const { return m_payload.data(); }
68     size_t size() const { return m_payload.size(); }
69     bool hasUpdates() const { return !m_updates.isEmpty(); }
70     size_t sizeForUpdate() const { return m_size; }
71 
72 private:
73     CachedBytecode(CachePayload&amp;&amp; payload, LeafExecutableMap&amp;&amp; leafExecutables = { })
74         : m_size(payload.size())
</pre>
</td>
</tr>
</table>
<center><a href="CachePayload.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CachedTypes.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
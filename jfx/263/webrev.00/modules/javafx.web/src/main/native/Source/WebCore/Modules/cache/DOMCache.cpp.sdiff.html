<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/cache/DOMCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CacheStorageConnection.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DOMCache.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/cache/DOMCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DOMCache.h&quot;
 28 
 29 #include &quot;CacheQueryOptions.h&quot;

 30 #include &quot;FetchResponse.h&quot;
 31 #include &quot;HTTPParsers.h&quot;
 32 #include &quot;JSFetchRequest.h&quot;
 33 #include &quot;JSFetchResponse.h&quot;
 34 #include &quot;ReadableStreamChunk.h&quot;
 35 #include &quot;ScriptExecutionContext.h&quot;
 36 #include &lt;wtf/CompletionHandler.h&gt;
 37 #include &lt;wtf/URL.h&gt;
 38 
 39 namespace WebCore {
 40 using namespace WebCore::DOMCacheEngine;
 41 
 42 DOMCache::DOMCache(ScriptExecutionContext&amp; context, String&amp;&amp; name, uint64_t identifier, Ref&lt;CacheStorageConnection&gt;&amp;&amp; connection)
 43     : ActiveDOMObject(&amp;context)
 44     , m_name(WTFMove(name))
 45     , m_identifier(identifier)
 46     , m_connection(WTFMove(connection))
 47 {
 48     suspendIfNeeded();
 49     m_connection-&gt;reference(m_identifier);
 50 }
 51 
 52 DOMCache::~DOMCache()
 53 {
 54     if (!m_isStopped)
 55         m_connection-&gt;dereference(m_identifier);
 56 }
 57 
 58 void DOMCache::match(RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 59 {
<span class="line-modified"> 60     doMatch(WTFMove(info), WTFMove(options), [promise = WTFMove(promise)](ExceptionOr&lt;FetchResponse*&gt;&amp;&amp; result) mutable {</span>
<span class="line-modified"> 61         if (result.hasException()) {</span>
<span class="line-modified"> 62             promise-&gt;reject(result.releaseException());</span>
<span class="line-modified"> 63             return;</span>
<span class="line-modified"> 64         }</span>
<span class="line-modified"> 65         if (!result.returnValue()) {</span>
<span class="line-modified"> 66             promise-&gt;resolve();</span>
<span class="line-modified"> 67             return;</span>
<span class="line-modified"> 68         }</span>
<span class="line-modified"> 69         promise-&gt;resolve&lt;IDLInterface&lt;FetchResponse&gt;&gt;(*result.returnValue());</span>


 70     });
 71 }
 72 
 73 void DOMCache::doMatch(RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, MatchCallback&amp;&amp; callback)
 74 {
 75     if (UNLIKELY(!scriptExecutionContext()))
 76         return;
 77 
 78     auto requestOrException = requestFromInfo(WTFMove(info), options.ignoreMethod);
 79     if (requestOrException.hasException()) {
 80         callback(nullptr);
 81         return;
 82     }
 83     auto request = requestOrException.releaseReturnValue();
 84 
 85     queryCache(request.get(), WTFMove(options), [this, callback = WTFMove(callback)](ExceptionOr&lt;Vector&lt;CacheStorageRecord&gt;&gt;&amp;&amp; result) mutable {
 86         if (result.hasException()) {
 87             callback(result.releaseException());
 88             return;
 89         }
 90         if (result.returnValue().isEmpty()) {
 91             callback(nullptr);
 92             return;
 93         }
<span class="line-modified"> 94         callback(result.returnValue()[0].response-&gt;clone(*scriptExecutionContext()).releaseReturnValue().ptr());</span>
 95     });
 96 }
 97 
 98 Vector&lt;Ref&lt;FetchResponse&gt;&gt; DOMCache::cloneResponses(const Vector&lt;CacheStorageRecord&gt;&amp; records)
 99 {
100     auto&amp; context = *scriptExecutionContext();
101     return WTF::map(records, [&amp;context] (const auto&amp; record) {
102         return record.response-&gt;clone(context).releaseReturnValue();
103     });
104 }
105 
106 void DOMCache::matchAll(Optional&lt;RequestInfo&gt;&amp;&amp; info, CacheQueryOptions&amp;&amp; options, MatchAllPromise&amp;&amp; promise)
107 {
108     if (UNLIKELY(!scriptExecutionContext()))
109         return;
110 
111     RefPtr&lt;FetchRequest&gt; request;
112     if (info) {
113         auto requestOrException = requestFromInfo(WTFMove(info.value()), options.ignoreMethod);
114         if (requestOrException.hasException()) {
115             promise.resolve({ });
116             return;
117         }
118         request = requestOrException.releaseReturnValue();
119     }
120 
121     if (!request) {
122         retrieveRecords(URL { }, [this, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
<span class="line-modified">123             if (exception) {</span>
<span class="line-modified">124                 promise.reject(WTFMove(exception.value()));</span>
<span class="line-modified">125                 return;</span>
<span class="line-modified">126             }</span>
<span class="line-modified">127             promise.resolve(cloneResponses(m_records));</span>


128         });
129         return;
130     }
131     queryCache(request.releaseNonNull(), WTFMove(options), [this, promise = WTFMove(promise)](ExceptionOr&lt;Vector&lt;CacheStorageRecord&gt;&gt;&amp;&amp; result) mutable {
<span class="line-modified">132         if (result.hasException()) {</span>
<span class="line-modified">133             promise.reject(result.releaseException());</span>
<span class="line-modified">134             return;</span>
<span class="line-modified">135         }</span>
<span class="line-modified">136         promise.resolve(cloneResponses(result.releaseReturnValue()));</span>


137     });
138 }
139 
140 void DOMCache::add(RequestInfo&amp;&amp; info, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
141 {
142     addAll(Vector&lt;RequestInfo&gt; { WTFMove(info) }, WTFMove(promise));
143 }
144 
145 static inline bool hasResponseVaryStarHeaderValue(const FetchResponse&amp; response)
146 {
147     auto varyValue = response.headers().internalHeaders().get(WebCore::HTTPHeaderName::Vary);
148     bool hasStar = false;
149     varyValue.split(&#39;,&#39;, [&amp;](StringView view) {
150         if (!hasStar &amp;&amp; stripLeadingAndTrailingHTTPSpaces(view) == &quot;*&quot;)
151             hasStar = true;
152     });
153     return hasStar;
154 }
155 
156 class FetchTasksHandler : public RefCounted&lt;FetchTasksHandler&gt; {
</pre>
<hr />
<pre>
216     return request.releaseNonNull();
217 }
218 
219 void DOMCache::addAll(Vector&lt;RequestInfo&gt;&amp;&amp; infos, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
220 {
221     if (UNLIKELY(!scriptExecutionContext()))
222         return;
223 
224     Vector&lt;Ref&lt;FetchRequest&gt;&gt; requests;
225     requests.reserveInitialCapacity(infos.size());
226     for (auto&amp; info : infos) {
227         bool ignoreMethod = false;
228         auto requestOrException = requestFromInfo(WTFMove(info), ignoreMethod);
229         if (requestOrException.hasException()) {
230             promise.reject(requestOrException.releaseException());
231             return;
232         }
233         requests.uncheckedAppend(requestOrException.releaseReturnValue());
234     }
235 
<span class="line-modified">236     auto taskHandler = FetchTasksHandler::create(*this, [this, promise = WTFMove(promise)](ExceptionOr&lt;Vector&lt;Record&gt;&gt;&amp;&amp; result) mutable {</span>
237         if (result.hasException()) {
<span class="line-modified">238             promise.reject(result.releaseException());</span>


239             return;
240         }
<span class="line-modified">241         batchPutOperation(result.releaseReturnValue(), [promise = WTFMove(promise)](ExceptionOr&lt;void&gt;&amp;&amp; result) mutable {</span>
<span class="line-modified">242             promise.settle(WTFMove(result));</span>


243         });
244     });
245 
246     for (auto&amp; request : requests) {
247         auto&amp; requestReference = request.get();
248         FetchResponse::fetch(*scriptExecutionContext(), requestReference, [this, request = WTFMove(request), taskHandler = taskHandler.copyRef()](ExceptionOr&lt;FetchResponse&amp;&gt;&amp;&amp; result) mutable {
249 
250             if (taskHandler-&gt;isDone())
251                 return;
252 
253             if (result.hasException()) {
254                 taskHandler-&gt;error(result.releaseException());
255                 return;
256             }
257 
258             auto&amp; response = result.releaseReturnValue();
259 
260             if (!response.ok()) {
261                 taskHandler-&gt;error(Exception { TypeError, &quot;Response is not OK&quot;_s });
262                 return;
</pre>
<hr />
<pre>
285                 if (taskHandler-&gt;isDone())
286                     return;
287 
288                 if (result.hasException()) {
289                     taskHandler-&gt;error(result.releaseException());
290                     return;
291                 }
292 
293                 if (auto chunk = result.returnValue())
294                     data-&gt;append(reinterpret_cast&lt;const char*&gt;(chunk-&gt;data), chunk-&gt;size);
295                 else
296                     taskHandler-&gt;addResponseBody(recordPosition, response, WTFMove(data));
297             });
298         });
299     }
300 }
301 
302 void DOMCache::putWithResponseData(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise, Ref&lt;FetchRequest&gt;&amp;&amp; request, Ref&lt;FetchResponse&gt;&amp;&amp; response, ExceptionOr&lt;RefPtr&lt;SharedBuffer&gt;&gt;&amp;&amp; responseBody)
303 {
304     if (responseBody.hasException()) {
<span class="line-modified">305         promise.reject(responseBody.releaseException());</span>


306         return;
307     }
308 
309     DOMCacheEngine::ResponseBody body;
310     if (auto buffer = responseBody.releaseReturnValue())
311         body = buffer.releaseNonNull();
<span class="line-modified">312     batchPutOperation(request.get(), response.get(), WTFMove(body), [promise = WTFMove(promise)](ExceptionOr&lt;void&gt;&amp;&amp; result) mutable {</span>
<span class="line-modified">313         promise.settle(WTFMove(result));</span>


314     });
315 }
316 
317 void DOMCache::put(RequestInfo&amp;&amp; info, Ref&lt;FetchResponse&gt;&amp;&amp; response, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
318 {
319     if (UNLIKELY(!scriptExecutionContext()))
320         return;
321 
322     bool ignoreMethod = false;
323     auto requestOrException = requestFromInfo(WTFMove(info), ignoreMethod);
324     if (requestOrException.hasException()) {
325         promise.reject(requestOrException.releaseException());
326         return;
327     }
328     auto request = requestOrException.releaseReturnValue();
329 
330     if (auto exception = response-&gt;loadingException()) {
331         promise.reject(*exception);
332         return;
333     }
</pre>
<hr />
<pre>
356     if (response-&gt;isBlobBody())
357         response-&gt;readableStream(*scriptExecutionContext()-&gt;execState());
358 
359     if (response-&gt;isBodyReceivedByChunk()) {
360         auto&amp; responseRef = response.get();
361         responseRef.consumeBodyReceivedByChunk([promise = WTFMove(promise), request = WTFMove(request), response = WTFMove(response), data = SharedBuffer::create(), pendingActivity = makePendingActivity(*this), this](auto&amp;&amp; result) mutable {
362 
363             if (result.hasException()) {
364                 this-&gt;putWithResponseData(WTFMove(promise), WTFMove(request), WTFMove(response), result.releaseException().isolatedCopy());
365                 return;
366             }
367 
368             if (auto chunk = result.returnValue())
369                 data-&gt;append(reinterpret_cast&lt;const char*&gt;(chunk-&gt;data), chunk-&gt;size);
370             else
371                 this-&gt;putWithResponseData(WTFMove(promise), WTFMove(request), WTFMove(response), RefPtr&lt;SharedBuffer&gt; { WTFMove(data) });
372         });
373         return;
374     }
375 
<span class="line-modified">376     batchPutOperation(request.get(), response.get(), response-&gt;consumeBody(), [promise = WTFMove(promise)](ExceptionOr&lt;void&gt;&amp;&amp; result) mutable {</span>
<span class="line-modified">377         promise.settle(WTFMove(result));</span>


378     });
379 }
380 
381 void DOMCache::remove(RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
382 {
383     if (UNLIKELY(!scriptExecutionContext()))
384         return;
385 
386     auto requestOrException = requestFromInfo(WTFMove(info), options.ignoreMethod);
387     if (requestOrException.hasException()) {
388         promise.resolve(false);
389         return;
390     }
391 
<span class="line-modified">392     batchDeleteOperation(requestOrException.releaseReturnValue(), WTFMove(options), [promise = WTFMove(promise)](ExceptionOr&lt;bool&gt;&amp;&amp; result) mutable {</span>
<span class="line-modified">393         promise.settle(WTFMove(result));</span>


394     });
395 }
396 
397 static inline Ref&lt;FetchRequest&gt; copyRequestRef(const CacheStorageRecord&amp; record)
398 {
399     return record.request.copyRef();
400 }
401 
402 void DOMCache::keys(Optional&lt;RequestInfo&gt;&amp;&amp; info, CacheQueryOptions&amp;&amp; options, KeysPromise&amp;&amp; promise)
403 {
404     if (UNLIKELY(!scriptExecutionContext()))
405         return;
406 
407     RefPtr&lt;FetchRequest&gt; request;
408     if (info) {
409         auto requestOrException = requestFromInfo(WTFMove(info.value()), options.ignoreMethod);
410         if (requestOrException.hasException()) {
411             promise.resolve(Vector&lt;Ref&lt;FetchRequest&gt;&gt; { });
412             return;
413         }
414         request = requestOrException.releaseReturnValue();
415     }
416 
417     if (!request) {
418         retrieveRecords(URL { }, [this, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
<span class="line-modified">419             if (exception) {</span>
<span class="line-modified">420                 promise.reject(WTFMove(exception.value()));</span>
<span class="line-modified">421                 return;</span>
<span class="line-modified">422             }</span>
<span class="line-modified">423             promise.resolve(WTF::map(m_records, copyRequestRef));</span>


424         });
425         return;
426     }
427 
<span class="line-modified">428     queryCache(request.releaseNonNull(), WTFMove(options), [promise = WTFMove(promise)](ExceptionOr&lt;Vector&lt;CacheStorageRecord&gt;&gt;&amp;&amp; result) mutable {</span>
<span class="line-modified">429         if (result.hasException()) {</span>
<span class="line-modified">430             promise.reject(result.releaseException());</span>
<span class="line-modified">431             return;</span>
<span class="line-modified">432         }</span>

433 
<span class="line-modified">434         promise.resolve(WTF::map(result.releaseReturnValue(), copyRequestRef));</span>

435     });
436 }
437 
438 void DOMCache::retrieveRecords(const URL&amp; url, WTF::Function&lt;void(Optional&lt;Exception&gt;&amp;&amp;)&gt;&amp;&amp; callback)
439 {
440     URL retrieveURL = url;
441     retrieveURL.removeQueryAndFragmentIdentifier();
442 
443     m_connection-&gt;retrieveRecords(m_identifier, retrieveURL, [this, pendingActivity = makePendingActivity(*this), callback = WTFMove(callback)](RecordsOrError&amp;&amp; result) {
444         if (m_isStopped)
445             return;
446 
447         if (!result.has_value()) {
448             callback(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
449             return;
450         }
451 
452         updateRecords(WTFMove(result.value()));
453         callback(WTF::nullopt);
454     });
</pre>
<hr />
<pre>
534         if (m_isStopped)
535             return;
536         if (!result.has_value()) {
537             callback(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
538             return;
539         }
540         callback({ });
541     });
542 }
543 
544 void DOMCache::updateRecords(Vector&lt;Record&gt;&amp;&amp; records)
545 {
546     ASSERT(scriptExecutionContext());
547     Vector&lt;CacheStorageRecord&gt; newRecords;
548 
549     for (auto&amp; record : records) {
550         size_t index = m_records.findMatching([&amp;](const auto&amp; item) { return item.identifier == record.identifier; });
551         if (index != notFound) {
552             auto&amp; current = m_records[index];
553             if (current.updateResponseCounter != record.updateResponseCounter) {

554                 auto response = FetchResponse::create(*scriptExecutionContext(), WTF::nullopt, record.responseHeadersGuard, WTFMove(record.response));
555                 response-&gt;setBodyData(WTFMove(record.responseBody), record.responseBodySize);
556 
557                 current.response = WTFMove(response);
558                 current.updateResponseCounter = record.updateResponseCounter;
559             }
560             newRecords.append(WTFMove(current));
561         } else {
562             auto requestHeaders = FetchHeaders::create(record.requestHeadersGuard, HTTPHeaderMap { record.request.httpHeaderFields() });
563             auto request = FetchRequest::create(*scriptExecutionContext(), WTF::nullopt, WTFMove(requestHeaders),  WTFMove(record.request), WTFMove(record.options), WTFMove(record.referrer));
564 

565             auto response = FetchResponse::create(*scriptExecutionContext(), WTF::nullopt, record.responseHeadersGuard, WTFMove(record.response));
566             response-&gt;setBodyData(WTFMove(record.responseBody), record.responseBodySize);
567 
568             newRecords.append(CacheStorageRecord { record.identifier, record.updateResponseCounter, WTFMove(request), WTFMove(response) });
569         }
570     }
571     m_records = WTFMove(newRecords);
572 }
573 
574 void DOMCache::stop()
575 {
576     if (m_isStopped)
577         return;
578     m_isStopped = true;
579     m_connection-&gt;dereference(m_identifier);
580 }
581 
582 const char* DOMCache::activeDOMObjectName() const
583 {
584     return &quot;Cache&quot;;
585 }
586 
<span class="line-removed">587 bool DOMCache::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">588 {</span>
<span class="line-removed">589     return m_records.isEmpty() &amp;&amp; !hasPendingActivity();</span>
<span class="line-removed">590 }</span>
<span class="line-removed">591 </span>
<span class="line-removed">592 </span>
593 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DOMCache.h&quot;
 28 
 29 #include &quot;CacheQueryOptions.h&quot;
<span class="line-added"> 30 #include &quot;EventLoop.h&quot;</span>
 31 #include &quot;FetchResponse.h&quot;
 32 #include &quot;HTTPParsers.h&quot;
 33 #include &quot;JSFetchRequest.h&quot;
 34 #include &quot;JSFetchResponse.h&quot;
 35 #include &quot;ReadableStreamChunk.h&quot;
 36 #include &quot;ScriptExecutionContext.h&quot;
 37 #include &lt;wtf/CompletionHandler.h&gt;
 38 #include &lt;wtf/URL.h&gt;
 39 
 40 namespace WebCore {
 41 using namespace WebCore::DOMCacheEngine;
 42 
 43 DOMCache::DOMCache(ScriptExecutionContext&amp; context, String&amp;&amp; name, uint64_t identifier, Ref&lt;CacheStorageConnection&gt;&amp;&amp; connection)
 44     : ActiveDOMObject(&amp;context)
 45     , m_name(WTFMove(name))
 46     , m_identifier(identifier)
 47     , m_connection(WTFMove(connection))
 48 {
 49     suspendIfNeeded();
 50     m_connection-&gt;reference(m_identifier);
 51 }
 52 
 53 DOMCache::~DOMCache()
 54 {
 55     if (!m_isStopped)
 56         m_connection-&gt;dereference(m_identifier);
 57 }
 58 
 59 void DOMCache::match(RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 60 {
<span class="line-modified"> 61     doMatch(WTFMove(info), WTFMove(options), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](ExceptionOr&lt;RefPtr&lt;FetchResponse&gt;&gt;&amp;&amp; result) mutable {</span>
<span class="line-modified"> 62         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), result = WTFMove(result)]() mutable {</span>
<span class="line-modified"> 63             if (result.hasException()) {</span>
<span class="line-modified"> 64                 promise-&gt;reject(result.releaseException());</span>
<span class="line-modified"> 65                 return;</span>
<span class="line-modified"> 66             }</span>
<span class="line-modified"> 67             if (!result.returnValue()) {</span>
<span class="line-modified"> 68                 promise-&gt;resolve();</span>
<span class="line-modified"> 69                 return;</span>
<span class="line-modified"> 70             }</span>
<span class="line-added"> 71             promise-&gt;resolve&lt;IDLInterface&lt;FetchResponse&gt;&gt;(*result.returnValue());</span>
<span class="line-added"> 72         });</span>
 73     });
 74 }
 75 
 76 void DOMCache::doMatch(RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, MatchCallback&amp;&amp; callback)
 77 {
 78     if (UNLIKELY(!scriptExecutionContext()))
 79         return;
 80 
 81     auto requestOrException = requestFromInfo(WTFMove(info), options.ignoreMethod);
 82     if (requestOrException.hasException()) {
 83         callback(nullptr);
 84         return;
 85     }
 86     auto request = requestOrException.releaseReturnValue();
 87 
 88     queryCache(request.get(), WTFMove(options), [this, callback = WTFMove(callback)](ExceptionOr&lt;Vector&lt;CacheStorageRecord&gt;&gt;&amp;&amp; result) mutable {
 89         if (result.hasException()) {
 90             callback(result.releaseException());
 91             return;
 92         }
 93         if (result.returnValue().isEmpty()) {
 94             callback(nullptr);
 95             return;
 96         }
<span class="line-modified"> 97         callback(RefPtr&lt;FetchResponse&gt;(result.returnValue()[0].response-&gt;clone(*scriptExecutionContext()).releaseReturnValue()));</span>
 98     });
 99 }
100 
101 Vector&lt;Ref&lt;FetchResponse&gt;&gt; DOMCache::cloneResponses(const Vector&lt;CacheStorageRecord&gt;&amp; records)
102 {
103     auto&amp; context = *scriptExecutionContext();
104     return WTF::map(records, [&amp;context] (const auto&amp; record) {
105         return record.response-&gt;clone(context).releaseReturnValue();
106     });
107 }
108 
109 void DOMCache::matchAll(Optional&lt;RequestInfo&gt;&amp;&amp; info, CacheQueryOptions&amp;&amp; options, MatchAllPromise&amp;&amp; promise)
110 {
111     if (UNLIKELY(!scriptExecutionContext()))
112         return;
113 
114     RefPtr&lt;FetchRequest&gt; request;
115     if (info) {
116         auto requestOrException = requestFromInfo(WTFMove(info.value()), options.ignoreMethod);
117         if (requestOrException.hasException()) {
118             promise.resolve({ });
119             return;
120         }
121         request = requestOrException.releaseReturnValue();
122     }
123 
124     if (!request) {
125         retrieveRecords(URL { }, [this, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
<span class="line-modified">126             queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, promise = WTFMove(promise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-modified">127                 if (exception) {</span>
<span class="line-modified">128                     promise.reject(WTFMove(exception.value()));</span>
<span class="line-modified">129                     return;</span>
<span class="line-modified">130                 }</span>
<span class="line-added">131                 promise.resolve(cloneResponses(m_records));</span>
<span class="line-added">132             });</span>
133         });
134         return;
135     }
136     queryCache(request.releaseNonNull(), WTFMove(options), [this, promise = WTFMove(promise)](ExceptionOr&lt;Vector&lt;CacheStorageRecord&gt;&gt;&amp;&amp; result) mutable {
<span class="line-modified">137         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, promise = WTFMove(promise), result = WTFMove(result)]() mutable {</span>
<span class="line-modified">138             if (result.hasException()) {</span>
<span class="line-modified">139                 promise.reject(result.releaseException());</span>
<span class="line-modified">140                 return;</span>
<span class="line-modified">141             }</span>
<span class="line-added">142             promise.resolve(cloneResponses(result.releaseReturnValue()));</span>
<span class="line-added">143         });</span>
144     });
145 }
146 
147 void DOMCache::add(RequestInfo&amp;&amp; info, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
148 {
149     addAll(Vector&lt;RequestInfo&gt; { WTFMove(info) }, WTFMove(promise));
150 }
151 
152 static inline bool hasResponseVaryStarHeaderValue(const FetchResponse&amp; response)
153 {
154     auto varyValue = response.headers().internalHeaders().get(WebCore::HTTPHeaderName::Vary);
155     bool hasStar = false;
156     varyValue.split(&#39;,&#39;, [&amp;](StringView view) {
157         if (!hasStar &amp;&amp; stripLeadingAndTrailingHTTPSpaces(view) == &quot;*&quot;)
158             hasStar = true;
159     });
160     return hasStar;
161 }
162 
163 class FetchTasksHandler : public RefCounted&lt;FetchTasksHandler&gt; {
</pre>
<hr />
<pre>
223     return request.releaseNonNull();
224 }
225 
226 void DOMCache::addAll(Vector&lt;RequestInfo&gt;&amp;&amp; infos, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
227 {
228     if (UNLIKELY(!scriptExecutionContext()))
229         return;
230 
231     Vector&lt;Ref&lt;FetchRequest&gt;&gt; requests;
232     requests.reserveInitialCapacity(infos.size());
233     for (auto&amp; info : infos) {
234         bool ignoreMethod = false;
235         auto requestOrException = requestFromInfo(WTFMove(info), ignoreMethod);
236         if (requestOrException.hasException()) {
237             promise.reject(requestOrException.releaseException());
238             return;
239         }
240         requests.uncheckedAppend(requestOrException.releaseReturnValue());
241     }
242 
<span class="line-modified">243     auto taskHandler = FetchTasksHandler::create(*this, [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](ExceptionOr&lt;Vector&lt;Record&gt;&gt;&amp;&amp; result) mutable {</span>
244         if (result.hasException()) {
<span class="line-modified">245             queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), exception = result.releaseException()]() mutable {</span>
<span class="line-added">246                 promise.reject(WTFMove(exception));</span>
<span class="line-added">247             });</span>
248             return;
249         }
<span class="line-modified">250         batchPutOperation(result.releaseReturnValue(), [this, protectedThis = WTFMove(protectedThis), promise = WTFMove(promise)](ExceptionOr&lt;void&gt;&amp;&amp; result) mutable {</span>
<span class="line-modified">251             queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), result = WTFMove(result)]() mutable {</span>
<span class="line-added">252                 promise.settle(WTFMove(result));</span>
<span class="line-added">253             });</span>
254         });
255     });
256 
257     for (auto&amp; request : requests) {
258         auto&amp; requestReference = request.get();
259         FetchResponse::fetch(*scriptExecutionContext(), requestReference, [this, request = WTFMove(request), taskHandler = taskHandler.copyRef()](ExceptionOr&lt;FetchResponse&amp;&gt;&amp;&amp; result) mutable {
260 
261             if (taskHandler-&gt;isDone())
262                 return;
263 
264             if (result.hasException()) {
265                 taskHandler-&gt;error(result.releaseException());
266                 return;
267             }
268 
269             auto&amp; response = result.releaseReturnValue();
270 
271             if (!response.ok()) {
272                 taskHandler-&gt;error(Exception { TypeError, &quot;Response is not OK&quot;_s });
273                 return;
</pre>
<hr />
<pre>
296                 if (taskHandler-&gt;isDone())
297                     return;
298 
299                 if (result.hasException()) {
300                     taskHandler-&gt;error(result.releaseException());
301                     return;
302                 }
303 
304                 if (auto chunk = result.returnValue())
305                     data-&gt;append(reinterpret_cast&lt;const char*&gt;(chunk-&gt;data), chunk-&gt;size);
306                 else
307                     taskHandler-&gt;addResponseBody(recordPosition, response, WTFMove(data));
308             });
309         });
310     }
311 }
312 
313 void DOMCache::putWithResponseData(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise, Ref&lt;FetchRequest&gt;&amp;&amp; request, Ref&lt;FetchResponse&gt;&amp;&amp; response, ExceptionOr&lt;RefPtr&lt;SharedBuffer&gt;&gt;&amp;&amp; responseBody)
314 {
315     if (responseBody.hasException()) {
<span class="line-modified">316         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), exception = responseBody.releaseException()]() mutable {</span>
<span class="line-added">317             promise.reject(WTFMove(exception));</span>
<span class="line-added">318         });</span>
319         return;
320     }
321 
322     DOMCacheEngine::ResponseBody body;
323     if (auto buffer = responseBody.releaseReturnValue())
324         body = buffer.releaseNonNull();
<span class="line-modified">325     batchPutOperation(request.get(), response.get(), WTFMove(body), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](ExceptionOr&lt;void&gt;&amp;&amp; result) mutable {</span>
<span class="line-modified">326         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), result = WTFMove(result)]() mutable {</span>
<span class="line-added">327             promise.settle(WTFMove(result));</span>
<span class="line-added">328         });</span>
329     });
330 }
331 
332 void DOMCache::put(RequestInfo&amp;&amp; info, Ref&lt;FetchResponse&gt;&amp;&amp; response, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
333 {
334     if (UNLIKELY(!scriptExecutionContext()))
335         return;
336 
337     bool ignoreMethod = false;
338     auto requestOrException = requestFromInfo(WTFMove(info), ignoreMethod);
339     if (requestOrException.hasException()) {
340         promise.reject(requestOrException.releaseException());
341         return;
342     }
343     auto request = requestOrException.releaseReturnValue();
344 
345     if (auto exception = response-&gt;loadingException()) {
346         promise.reject(*exception);
347         return;
348     }
</pre>
<hr />
<pre>
371     if (response-&gt;isBlobBody())
372         response-&gt;readableStream(*scriptExecutionContext()-&gt;execState());
373 
374     if (response-&gt;isBodyReceivedByChunk()) {
375         auto&amp; responseRef = response.get();
376         responseRef.consumeBodyReceivedByChunk([promise = WTFMove(promise), request = WTFMove(request), response = WTFMove(response), data = SharedBuffer::create(), pendingActivity = makePendingActivity(*this), this](auto&amp;&amp; result) mutable {
377 
378             if (result.hasException()) {
379                 this-&gt;putWithResponseData(WTFMove(promise), WTFMove(request), WTFMove(response), result.releaseException().isolatedCopy());
380                 return;
381             }
382 
383             if (auto chunk = result.returnValue())
384                 data-&gt;append(reinterpret_cast&lt;const char*&gt;(chunk-&gt;data), chunk-&gt;size);
385             else
386                 this-&gt;putWithResponseData(WTFMove(promise), WTFMove(request), WTFMove(response), RefPtr&lt;SharedBuffer&gt; { WTFMove(data) });
387         });
388         return;
389     }
390 
<span class="line-modified">391     batchPutOperation(request.get(), response.get(), response-&gt;consumeBody(), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](ExceptionOr&lt;void&gt;&amp;&amp; result) mutable {</span>
<span class="line-modified">392         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), result = WTFMove(result)]() mutable {</span>
<span class="line-added">393             promise.settle(WTFMove(result));</span>
<span class="line-added">394         });</span>
395     });
396 }
397 
398 void DOMCache::remove(RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
399 {
400     if (UNLIKELY(!scriptExecutionContext()))
401         return;
402 
403     auto requestOrException = requestFromInfo(WTFMove(info), options.ignoreMethod);
404     if (requestOrException.hasException()) {
405         promise.resolve(false);
406         return;
407     }
408 
<span class="line-modified">409     batchDeleteOperation(requestOrException.releaseReturnValue(), WTFMove(options), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](ExceptionOr&lt;bool&gt;&amp;&amp; result) mutable {</span>
<span class="line-modified">410         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), result = WTFMove(result)]() mutable {</span>
<span class="line-added">411             promise.settle(WTFMove(result));</span>
<span class="line-added">412         });</span>
413     });
414 }
415 
416 static inline Ref&lt;FetchRequest&gt; copyRequestRef(const CacheStorageRecord&amp; record)
417 {
418     return record.request.copyRef();
419 }
420 
421 void DOMCache::keys(Optional&lt;RequestInfo&gt;&amp;&amp; info, CacheQueryOptions&amp;&amp; options, KeysPromise&amp;&amp; promise)
422 {
423     if (UNLIKELY(!scriptExecutionContext()))
424         return;
425 
426     RefPtr&lt;FetchRequest&gt; request;
427     if (info) {
428         auto requestOrException = requestFromInfo(WTFMove(info.value()), options.ignoreMethod);
429         if (requestOrException.hasException()) {
430             promise.resolve(Vector&lt;Ref&lt;FetchRequest&gt;&gt; { });
431             return;
432         }
433         request = requestOrException.releaseReturnValue();
434     }
435 
436     if (!request) {
437         retrieveRecords(URL { }, [this, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
<span class="line-modified">438             queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, promise = WTFMove(promise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-modified">439                 if (exception) {</span>
<span class="line-modified">440                     promise.reject(WTFMove(exception.value()));</span>
<span class="line-modified">441                     return;</span>
<span class="line-modified">442                 }</span>
<span class="line-added">443                 promise.resolve(WTF::map(m_records, copyRequestRef));</span>
<span class="line-added">444             });</span>
445         });
446         return;
447     }
448 
<span class="line-modified">449     queryCache(request.releaseNonNull(), WTFMove(options), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](auto&amp;&amp; result) mutable {</span>
<span class="line-modified">450         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), result = WTFMove(result)]() mutable {</span>
<span class="line-modified">451             if (result.hasException()) {</span>
<span class="line-modified">452                 promise.reject(result.releaseException());</span>
<span class="line-modified">453                 return;</span>
<span class="line-added">454             }</span>
455 
<span class="line-modified">456             promise.resolve(WTF::map(result.releaseReturnValue(), copyRequestRef));</span>
<span class="line-added">457         });</span>
458     });
459 }
460 
461 void DOMCache::retrieveRecords(const URL&amp; url, WTF::Function&lt;void(Optional&lt;Exception&gt;&amp;&amp;)&gt;&amp;&amp; callback)
462 {
463     URL retrieveURL = url;
464     retrieveURL.removeQueryAndFragmentIdentifier();
465 
466     m_connection-&gt;retrieveRecords(m_identifier, retrieveURL, [this, pendingActivity = makePendingActivity(*this), callback = WTFMove(callback)](RecordsOrError&amp;&amp; result) {
467         if (m_isStopped)
468             return;
469 
470         if (!result.has_value()) {
471             callback(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
472             return;
473         }
474 
475         updateRecords(WTFMove(result.value()));
476         callback(WTF::nullopt);
477     });
</pre>
<hr />
<pre>
557         if (m_isStopped)
558             return;
559         if (!result.has_value()) {
560             callback(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
561             return;
562         }
563         callback({ });
564     });
565 }
566 
567 void DOMCache::updateRecords(Vector&lt;Record&gt;&amp;&amp; records)
568 {
569     ASSERT(scriptExecutionContext());
570     Vector&lt;CacheStorageRecord&gt; newRecords;
571 
572     for (auto&amp; record : records) {
573         size_t index = m_records.findMatching([&amp;](const auto&amp; item) { return item.identifier == record.identifier; });
574         if (index != notFound) {
575             auto&amp; current = m_records[index];
576             if (current.updateResponseCounter != record.updateResponseCounter) {
<span class="line-added">577                 record.response.setSource(ResourceResponse::Source::DOMCache);</span>
578                 auto response = FetchResponse::create(*scriptExecutionContext(), WTF::nullopt, record.responseHeadersGuard, WTFMove(record.response));
579                 response-&gt;setBodyData(WTFMove(record.responseBody), record.responseBodySize);
580 
581                 current.response = WTFMove(response);
582                 current.updateResponseCounter = record.updateResponseCounter;
583             }
584             newRecords.append(WTFMove(current));
585         } else {
586             auto requestHeaders = FetchHeaders::create(record.requestHeadersGuard, HTTPHeaderMap { record.request.httpHeaderFields() });
587             auto request = FetchRequest::create(*scriptExecutionContext(), WTF::nullopt, WTFMove(requestHeaders),  WTFMove(record.request), WTFMove(record.options), WTFMove(record.referrer));
588 
<span class="line-added">589             record.response.setSource(ResourceResponse::Source::DOMCache);</span>
590             auto response = FetchResponse::create(*scriptExecutionContext(), WTF::nullopt, record.responseHeadersGuard, WTFMove(record.response));
591             response-&gt;setBodyData(WTFMove(record.responseBody), record.responseBodySize);
592 
593             newRecords.append(CacheStorageRecord { record.identifier, record.updateResponseCounter, WTFMove(request), WTFMove(response) });
594         }
595     }
596     m_records = WTFMove(newRecords);
597 }
598 
599 void DOMCache::stop()
600 {
601     if (m_isStopped)
602         return;
603     m_isStopped = true;
604     m_connection-&gt;dereference(m_identifier);
605 }
606 
607 const char* DOMCache::activeDOMObjectName() const
608 {
609     return &quot;Cache&quot;;
610 }
611 






612 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="CacheStorageConnection.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DOMCache.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
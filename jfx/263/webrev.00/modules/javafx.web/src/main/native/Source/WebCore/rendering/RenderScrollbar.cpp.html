<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderScrollbar.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008, 2009, 2013, 2015 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderScrollbar.h&quot;
 28 
 29 #include &quot;Frame.h&quot;
 30 #include &quot;FrameView.h&quot;
 31 #include &quot;RenderScrollbarPart.h&quot;
 32 #include &quot;RenderScrollbarTheme.h&quot;
 33 #include &quot;RenderWidget.h&quot;
 34 #include &quot;StyleInheritedData.h&quot;
 35 #include &quot;StyleResolver.h&quot;
 36 
 37 namespace WebCore {
 38 
 39 Ref&lt;Scrollbar&gt; RenderScrollbar::createCustomScrollbar(ScrollableArea&amp; scrollableArea, ScrollbarOrientation orientation, Element* ownerElement, Frame* owningFrame)
 40 {
 41     return adoptRef(*new RenderScrollbar(scrollableArea, orientation, ownerElement, owningFrame));
 42 }
 43 
 44 RenderScrollbar::RenderScrollbar(ScrollableArea&amp; scrollableArea, ScrollbarOrientation orientation, Element* ownerElement, Frame* owningFrame)
 45     : Scrollbar(scrollableArea, orientation, RegularScrollbar, RenderScrollbarTheme::renderScrollbarTheme(), true)
 46     , m_ownerElement(ownerElement)
 47     , m_owningFrame(owningFrame)
 48 {
 49     ASSERT(ownerElement || owningFrame);
 50 
 51     // FIXME: We need to do this because RenderScrollbar::styleChanged is called as soon as the scrollbar is created.
 52 
 53     // Update the scrollbar size.
 54     int width = 0;
 55     int height = 0;
 56     updateScrollbarPart(ScrollbarBGPart);
 57     if (RenderScrollbarPart* part = m_parts.get(ScrollbarBGPart)) {
 58         part-&gt;layout();
 59         width = part-&gt;width();
 60         height = part-&gt;height();
 61     } else if (this-&gt;orientation() == HorizontalScrollbar)
 62         width = this-&gt;width();
 63     else
 64         height = this-&gt;height();
 65 
 66     setFrameRect(IntRect(0, 0, width, height));
 67 }
 68 
 69 RenderScrollbar::~RenderScrollbar() = default;
 70 
 71 RenderBox* RenderScrollbar::owningRenderer() const
 72 {
 73     if (m_owningFrame) {
 74         RenderWidget* currentRenderer = m_owningFrame-&gt;ownerRenderer();
 75         return currentRenderer;
 76     }
 77     ASSERT(m_ownerElement);
 78     if (m_ownerElement-&gt;renderer())
 79         return &amp;m_ownerElement-&gt;renderer()-&gt;enclosingBox();
 80     return nullptr;
 81 }
 82 
 83 void RenderScrollbar::setParent(ScrollView* parent)
 84 {
 85     Scrollbar::setParent(parent);
 86     if (!parent)
 87         m_parts.clear();
 88 }
 89 
 90 void RenderScrollbar::setEnabled(bool e)
 91 {
 92     bool wasEnabled = enabled();
 93     Scrollbar::setEnabled(e);
 94     if (wasEnabled != e)
 95         updateScrollbarParts();
 96 }
 97 
 98 void RenderScrollbar::styleChanged()
 99 {
100     updateScrollbarParts();
101 }
102 
103 void RenderScrollbar::paint(GraphicsContext&amp; context, const IntRect&amp; damageRect, Widget::SecurityOriginPaintPolicy)
104 {
105     if (context.invalidatingControlTints()) {
106         updateScrollbarParts();
107         return;
108     }
109     Scrollbar::paint(context, damageRect);
110 }
111 
112 void RenderScrollbar::setHoveredPart(ScrollbarPart part)
113 {
114     if (part == m_hoveredPart)
115         return;
116 
117     ScrollbarPart oldPart = m_hoveredPart;
118     m_hoveredPart = part;
119 
120     updateScrollbarPart(oldPart);
121     updateScrollbarPart(m_hoveredPart);
122 
123     updateScrollbarPart(ScrollbarBGPart);
124     updateScrollbarPart(TrackBGPart);
125 }
126 
127 void RenderScrollbar::setPressedPart(ScrollbarPart part)
128 {
129     ScrollbarPart oldPart = m_pressedPart;
130     Scrollbar::setPressedPart(part);
131 
132     updateScrollbarPart(oldPart);
133     updateScrollbarPart(part);
134 
135     updateScrollbarPart(ScrollbarBGPart);
136     updateScrollbarPart(TrackBGPart);
137 }
138 
139 std::unique_ptr&lt;RenderStyle&gt; RenderScrollbar::getScrollbarPseudoStyle(ScrollbarPart partType, PseudoId pseudoId) const
140 {
141     if (!owningRenderer())
142         return nullptr;
143 
144     StyleScrollbarState scrollbarState;
145     scrollbarState.scrollbarPart = partType;
146     scrollbarState.hoveredPart = hoveredPart();
147     scrollbarState.pressedPart = pressedPart();
148     scrollbarState.orientation = orientation();
149     scrollbarState.buttonsPlacement = theme().buttonsPlacement();
150     scrollbarState.enabled = enabled();
151     scrollbarState.scrollCornerIsVisible = scrollableArea().isScrollCornerVisible();
152 
153     std::unique_ptr&lt;RenderStyle&gt; result = owningRenderer()-&gt;getUncachedPseudoStyle({ pseudoId, scrollbarState }, &amp;owningRenderer()-&gt;style());
154     // Scrollbars for root frames should always have background color
155     // unless explicitly specified as transparent. So we force it.
156     // This is because WebKit assumes scrollbar to be always painted and missing background
157     // causes visual artifact like non-repainted dirty region.
158     if (result &amp;&amp; m_owningFrame &amp;&amp; m_owningFrame-&gt;view() &amp;&amp; !m_owningFrame-&gt;view()-&gt;isTransparent() &amp;&amp; !result-&gt;hasBackground())
159         result-&gt;setBackgroundColor(Color::white);
160 
161     return result;
162 }
163 
164 void RenderScrollbar::updateScrollbarParts()
165 {
166     updateScrollbarPart(ScrollbarBGPart);
167     updateScrollbarPart(BackButtonStartPart);
168     updateScrollbarPart(ForwardButtonStartPart);
169     updateScrollbarPart(BackTrackPart);
170     updateScrollbarPart(ThumbPart);
171     updateScrollbarPart(ForwardTrackPart);
172     updateScrollbarPart(BackButtonEndPart);
173     updateScrollbarPart(ForwardButtonEndPart);
174     updateScrollbarPart(TrackBGPart);
175 
176     // See if the scrollbar&#39;s thickness changed.  If so, we need to mark our owning object as needing a layout.
177     bool isHorizontal = orientation() == HorizontalScrollbar;
178     int oldThickness = isHorizontal ? height() : width();
179     int newThickness = 0;
180     RenderScrollbarPart* part = m_parts.get(ScrollbarBGPart);
181     if (part) {
182         part-&gt;layout();
183         newThickness = isHorizontal ? part-&gt;height() : part-&gt;width();
184     }
185 
186     if (newThickness != oldThickness) {
187         setFrameRect(IntRect(location(), IntSize(isHorizontal ? width() : newThickness, isHorizontal ? newThickness : height())));
188         if (RenderBox* box = owningRenderer())
189             box-&gt;setChildNeedsLayout();
190     }
191 }
192 
193 static PseudoId pseudoForScrollbarPart(ScrollbarPart part)
194 {
195     switch (part) {
196         case BackButtonStartPart:
197         case ForwardButtonStartPart:
198         case BackButtonEndPart:
199         case ForwardButtonEndPart:
200             return PseudoId::ScrollbarButton;
201         case BackTrackPart:
202         case ForwardTrackPart:
203             return PseudoId::ScrollbarTrackPiece;
204         case ThumbPart:
205             return PseudoId::ScrollbarThumb;
206         case TrackBGPart:
207             return PseudoId::ScrollbarTrack;
208         case ScrollbarBGPart:
209             return PseudoId::Scrollbar;
210         case NoPart:
211         case AllParts:
212             break;
213     }
214     ASSERT_NOT_REACHED();
215     return PseudoId::Scrollbar;
216 }
217 
218 void RenderScrollbar::updateScrollbarPart(ScrollbarPart partType)
219 {
220     if (partType == NoPart)
221         return;
222 
223     std::unique_ptr&lt;RenderStyle&gt; partStyle = getScrollbarPseudoStyle(partType, pseudoForScrollbarPart(partType));
224     bool needRenderer = partStyle &amp;&amp; partStyle-&gt;display() != DisplayType::None;
225 
226     if (needRenderer &amp;&amp; partStyle-&gt;display() != DisplayType::Block) {
227         // See if we are a button that should not be visible according to OS settings.
228         ScrollbarButtonsPlacement buttonsPlacement = theme().buttonsPlacement();
229         switch (partType) {
230             case BackButtonStartPart:
231                 needRenderer = (buttonsPlacement == ScrollbarButtonsSingle || buttonsPlacement == ScrollbarButtonsDoubleStart ||
232                                 buttonsPlacement == ScrollbarButtonsDoubleBoth);
233                 break;
234             case ForwardButtonStartPart:
235                 needRenderer = (buttonsPlacement == ScrollbarButtonsDoubleStart || buttonsPlacement == ScrollbarButtonsDoubleBoth);
236                 break;
237             case BackButtonEndPart:
238                 needRenderer = (buttonsPlacement == ScrollbarButtonsDoubleEnd || buttonsPlacement == ScrollbarButtonsDoubleBoth);
239                 break;
240             case ForwardButtonEndPart:
241                 needRenderer = (buttonsPlacement == ScrollbarButtonsSingle || buttonsPlacement == ScrollbarButtonsDoubleEnd ||
242                                 buttonsPlacement == ScrollbarButtonsDoubleBoth);
243                 break;
244             default:
245                 break;
246         }
247     }
248 
249     if (!needRenderer) {
250         m_parts.remove(partType);
251         return;
252     }
253 
254     if (auto&amp; partRendererSlot = m_parts.add(partType, nullptr).iterator-&gt;value)
255         partRendererSlot-&gt;setStyle(WTFMove(*partStyle));
256     else {
257         partRendererSlot = createRenderer&lt;RenderScrollbarPart&gt;(owningRenderer()-&gt;document(), WTFMove(*partStyle), this, partType);
258         partRendererSlot-&gt;initializeStyle();
259     }
260 }
261 
262 void RenderScrollbar::paintPart(GraphicsContext&amp; graphicsContext, ScrollbarPart partType, const IntRect&amp; rect)
263 {
264     RenderScrollbarPart* partRenderer = m_parts.get(partType);
265     if (!partRenderer)
266         return;
267     partRenderer-&gt;paintIntoRect(graphicsContext, location(), rect);
268 }
269 
270 IntRect RenderScrollbar::buttonRect(ScrollbarPart partType)
271 {
272     RenderScrollbarPart* partRenderer = m_parts.get(partType);
273     if (!partRenderer)
274         return IntRect();
275 
276     partRenderer-&gt;layout();
277 
278     bool isHorizontal = orientation() == HorizontalScrollbar;
279     IntSize pixelSnappedIntSize = snappedIntRect(partRenderer-&gt;frameRect()).size();
280     if (partType == BackButtonStartPart)
281         return IntRect(location(), IntSize(isHorizontal ? pixelSnappedIntSize.width() : width(), isHorizontal ? height() : pixelSnappedIntSize.height()));
282     if (partType == ForwardButtonEndPart)
283         return IntRect(isHorizontal ? x() + width() - pixelSnappedIntSize.width() : x(), isHorizontal ? y() : y() + height() - pixelSnappedIntSize.height(),
284                        isHorizontal ? pixelSnappedIntSize.width() : width(),
285                        isHorizontal ? height() : pixelSnappedIntSize.height());
286 
287     if (partType == ForwardButtonStartPart) {
288         IntRect previousButton = buttonRect(BackButtonStartPart);
289         return IntRect(isHorizontal ? x() + previousButton.width() : x(),
290                        isHorizontal ? y() : y() + previousButton.height(),
291                        isHorizontal ? pixelSnappedIntSize.width() : width(),
292                        isHorizontal ? height() : pixelSnappedIntSize.height());
293     }
294 
295     IntRect followingButton = buttonRect(ForwardButtonEndPart);
296     return IntRect(isHorizontal ? x() + width() - followingButton.width() - pixelSnappedIntSize.width() : x(),
297                    isHorizontal ? y() : y() + height() - followingButton.height() - pixelSnappedIntSize.height(),
298                    isHorizontal ? pixelSnappedIntSize.width() : width(),
299                    isHorizontal ? height() : pixelSnappedIntSize.height());
300 }
301 
302 IntRect RenderScrollbar::trackRect(int startLength, int endLength)
303 {
304     RenderScrollbarPart* part = m_parts.get(TrackBGPart);
305     if (part)
306         part-&gt;layout();
307 
308     if (orientation() == HorizontalScrollbar) {
309         int marginLeft = part ? static_cast&lt;int&gt;(part-&gt;marginLeft()) : 0;
310         int marginRight = part ? static_cast&lt;int&gt;(part-&gt;marginRight()) : 0;
311         startLength += marginLeft;
312         endLength += marginRight;
313         int totalLength = startLength + endLength;
314         return IntRect(x() + startLength, y(), width() - totalLength, height());
315     }
316 
317     int marginTop = part ? static_cast&lt;int&gt;(part-&gt;marginTop()) : 0;
318     int marginBottom = part ? static_cast&lt;int&gt;(part-&gt;marginBottom()) : 0;
319     startLength += marginTop;
320     endLength += marginBottom;
321     int totalLength = startLength + endLength;
322 
323     return IntRect(x(), y() + startLength, width(), height() - totalLength);
324 }
325 
326 IntRect RenderScrollbar::trackPieceRectWithMargins(ScrollbarPart partType, const IntRect&amp; oldRect)
327 {
328     RenderScrollbarPart* partRenderer = m_parts.get(partType);
329     if (!partRenderer)
330         return oldRect;
331 
332     partRenderer-&gt;layout();
333 
334     IntRect rect = oldRect;
335     if (orientation() == HorizontalScrollbar) {
336         rect.setX(rect.x() + partRenderer-&gt;marginLeft());
337         rect.setWidth(rect.width() - partRenderer-&gt;horizontalMarginExtent());
338     } else {
339         rect.setY(rect.y() + partRenderer-&gt;marginTop());
340         rect.setHeight(rect.height() - partRenderer-&gt;verticalMarginExtent());
341     }
342     return rect;
343 }
344 
345 int RenderScrollbar::minimumThumbLength()
346 {
347     RenderScrollbarPart* partRenderer = m_parts.get(ThumbPart);
348     if (!partRenderer)
349         return 0;
350     partRenderer-&gt;layout();
351     return orientation() == HorizontalScrollbar ? partRenderer-&gt;width() : partRenderer-&gt;height();
352 }
353 
354 float RenderScrollbar::opacity()
355 {
356     RenderScrollbarPart* partRenderer = m_parts.get(ScrollbarBGPart);
357     if (!partRenderer)
358         return 1;
359 
360     return partRenderer-&gt;style().opacity();
361 }
362 
363 bool RenderScrollbar::isHiddenByStyle() const
364 {
365     std::unique_ptr&lt;RenderStyle&gt; partStyle = getScrollbarPseudoStyle(ScrollbarBGPart, pseudoForScrollbarPart(ScrollbarBGPart));
366     return partStyle &amp;&amp; partStyle-&gt;display() == DisplayType::None;
367 }
368 
369 }
    </pre>
  </body>
</html>
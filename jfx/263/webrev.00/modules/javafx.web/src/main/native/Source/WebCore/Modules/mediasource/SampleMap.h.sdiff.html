<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/SampleMap.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SampleMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SourceBuffer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/SampleMap.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 76     typedef std::pair&lt;MediaTime, MediaTime&gt; KeyType;
 77     using MapType = StdMap&lt;KeyType, RefPtr&lt;MediaSample&gt;&gt;;
 78     typedef MapType::iterator iterator;
 79     typedef MapType::const_iterator const_iterator;
 80     typedef MapType::reverse_iterator reverse_iterator;
 81     typedef MapType::const_reverse_iterator const_reverse_iterator;
 82     typedef std::pair&lt;iterator, iterator&gt; iterator_range;
 83     typedef std::pair&lt;reverse_iterator, reverse_iterator&gt; reverse_iterator_range;
 84     typedef MapType::value_type value_type;
 85 
 86     iterator begin() { return m_samples.begin(); }
 87     const_iterator begin() const { return m_samples.begin(); }
 88     iterator end() { return m_samples.end(); }
 89     const_iterator end() const { return m_samples.end(); }
 90     reverse_iterator rbegin() { return m_samples.rbegin(); }
 91     const_reverse_iterator rbegin() const { return m_samples.rbegin(); }
 92     reverse_iterator rend() { return m_samples.rend(); }
 93     const_reverse_iterator rend() const { return m_samples.rend(); }
 94 
 95     WEBCORE_EXPORT iterator findSampleWithDecodeKey(const KeyType&amp;);

 96     WEBCORE_EXPORT reverse_iterator reverseFindSampleWithDecodeKey(const KeyType&amp;);
 97     WEBCORE_EXPORT reverse_iterator findSyncSamplePriorToPresentationTime(const MediaTime&amp;, const MediaTime&amp; threshold = MediaTime::positiveInfiniteTime());
 98     WEBCORE_EXPORT reverse_iterator findSyncSamplePriorToDecodeIterator(reverse_iterator);
 99     WEBCORE_EXPORT iterator findSyncSampleAfterPresentationTime(const MediaTime&amp;, const MediaTime&amp; threshold = MediaTime::positiveInfiniteTime());
100     WEBCORE_EXPORT iterator findSyncSampleAfterDecodeIterator(iterator);
101     WEBCORE_EXPORT reverse_iterator_range findDependentSamples(MediaSample*);
102     WEBCORE_EXPORT iterator_range findSamplesBetweenDecodeKeys(const KeyType&amp;, const KeyType&amp;);
103 
104 private:
105     MapType m_samples;
106     PresentationOrderSampleMap m_presentationOrder;
107 };
108 
109 class SampleMap {
110 public:
111     SampleMap() = default;
112 
113     WEBCORE_EXPORT bool empty() const;
114     size_t size() const { return m_decodeOrder.m_samples.size(); }
115     WEBCORE_EXPORT void clear();
</pre>
</td>
<td>
<hr />
<pre>
 76     typedef std::pair&lt;MediaTime, MediaTime&gt; KeyType;
 77     using MapType = StdMap&lt;KeyType, RefPtr&lt;MediaSample&gt;&gt;;
 78     typedef MapType::iterator iterator;
 79     typedef MapType::const_iterator const_iterator;
 80     typedef MapType::reverse_iterator reverse_iterator;
 81     typedef MapType::const_reverse_iterator const_reverse_iterator;
 82     typedef std::pair&lt;iterator, iterator&gt; iterator_range;
 83     typedef std::pair&lt;reverse_iterator, reverse_iterator&gt; reverse_iterator_range;
 84     typedef MapType::value_type value_type;
 85 
 86     iterator begin() { return m_samples.begin(); }
 87     const_iterator begin() const { return m_samples.begin(); }
 88     iterator end() { return m_samples.end(); }
 89     const_iterator end() const { return m_samples.end(); }
 90     reverse_iterator rbegin() { return m_samples.rbegin(); }
 91     const_reverse_iterator rbegin() const { return m_samples.rbegin(); }
 92     reverse_iterator rend() { return m_samples.rend(); }
 93     const_reverse_iterator rend() const { return m_samples.rend(); }
 94 
 95     WEBCORE_EXPORT iterator findSampleWithDecodeKey(const KeyType&amp;);
<span class="line-added"> 96     WEBCORE_EXPORT iterator findSampleAfterDecodeKey(const KeyType&amp;);</span>
 97     WEBCORE_EXPORT reverse_iterator reverseFindSampleWithDecodeKey(const KeyType&amp;);
 98     WEBCORE_EXPORT reverse_iterator findSyncSamplePriorToPresentationTime(const MediaTime&amp;, const MediaTime&amp; threshold = MediaTime::positiveInfiniteTime());
 99     WEBCORE_EXPORT reverse_iterator findSyncSamplePriorToDecodeIterator(reverse_iterator);
100     WEBCORE_EXPORT iterator findSyncSampleAfterPresentationTime(const MediaTime&amp;, const MediaTime&amp; threshold = MediaTime::positiveInfiniteTime());
101     WEBCORE_EXPORT iterator findSyncSampleAfterDecodeIterator(iterator);
102     WEBCORE_EXPORT reverse_iterator_range findDependentSamples(MediaSample*);
103     WEBCORE_EXPORT iterator_range findSamplesBetweenDecodeKeys(const KeyType&amp;, const KeyType&amp;);
104 
105 private:
106     MapType m_samples;
107     PresentationOrderSampleMap m_presentationOrder;
108 };
109 
110 class SampleMap {
111 public:
112     SampleMap() = default;
113 
114     WEBCORE_EXPORT bool empty() const;
115     size_t size() const { return m_decodeOrder.m_samples.size(); }
116     WEBCORE_EXPORT void clear();
</pre>
</td>
</tr>
</table>
<center><a href="SampleMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SourceBuffer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
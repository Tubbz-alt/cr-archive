diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.cpp b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.cpp
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.cpp
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.cpp
@@ -33,10 +33,14 @@
 #include "Vector.h"
 #include "bmalloc.h"
 #include <cstdio>
 #include <mutex>
 
+#if BOS(DARWIN)
+#include <mach/mach.h>
+#endif
+
 #if GIGACAGE_ENABLED
 
 namespace Gigacage {
 
 struct Callback {
@@ -55,11 +59,11 @@
 }
 
 namespace bmalloc {
 
 struct PrimitiveDisableCallbacks : public StaticPerProcess<PrimitiveDisableCallbacks> {
-    PrimitiveDisableCallbacks(std::lock_guard<Mutex>&) { }
+    PrimitiveDisableCallbacks(const LockHolder&) { }
 
     Vector<Gigacage::Callback> callbacks;
 };
 DECLARE_STATIC_PER_PROCESS_STORAGE(PrimitiveDisableCallbacks);
 DEFINE_STATIC_PER_PROCESS_STORAGE(PrimitiveDisableCallbacks);
@@ -71,59 +75,87 @@
 // This is exactly 32GB because inside JSC, indexed accesses for arrays, typed arrays, etc,
 // use unsigned 32-bit ints as indices. The items those indices access are 8 bytes or less
 // in size. 2^32 * 8 = 32GB. This means if an access on a caged type happens to go out of
 // bounds, the access is guaranteed to land somewhere else in the cage or inside the runway.
 // If this were less than 32GB, those OOB accesses could reach outside of the cage.
-constexpr size_t gigacageRunway = 32llu * 1024 * 1024 * 1024;
+constexpr size_t gigacageRunway = 32llu * bmalloc::Sizes::GB;
 
-// Note: g_gigacageBasePtrs[0] is reserved for storing the wasEnabled flag.
-// The first gigacageBasePtr will start at g_gigacageBasePtrs[sizeof(void*)].
-// This is done so that the wasEnabled flag will also be protected along with the
-// gigacageBasePtrs.
-alignas(gigacageBasePtrsSize) char g_gigacageBasePtrs[gigacageBasePtrsSize];
+alignas(configSizeToProtect) Config g_gigacageConfig;
 
 using namespace bmalloc;
 
 namespace {
 
-bool s_isDisablingPrimitiveGigacageDisabled;
+#if BOS(DARWIN)
+enum {
+    AllowPermissionChangesAfterThis = false,
+    DisallowPermissionChangesAfterThis = true
+};
+#endif
+
+static void freezeGigacageConfig()
+{
+    int result;
+#if BOS(DARWIN)
+    result = vm_protect(mach_task_self(), reinterpret_cast<vm_address_t>(&g_gigacageConfig), configSizeToProtect, AllowPermissionChangesAfterThis, VM_PROT_READ);
+#else
+    result = mprotect(&g_gigacageConfig, configSizeToProtect, PROT_READ);
+#endif
+    RELEASE_BASSERT(!result);
+}
 
-void protectGigacageBasePtrs()
+static void unfreezeGigacageConfig()
 {
-    uintptr_t basePtrs = reinterpret_cast<uintptr_t>(g_gigacageBasePtrs);
-    // We might only get page size alignment, but that's also the minimum we need.
-    RELEASE_BASSERT(!(basePtrs & (vmPageSize() - 1)));
-    mprotect(g_gigacageBasePtrs, gigacageBasePtrsSize, PROT_READ);
+    RELEASE_BASSERT(!g_gigacageConfig.isPermanentlyFrozen);
+    int result;
+#if BOS(DARWIN)
+    result = vm_protect(mach_task_self(), reinterpret_cast<vm_address_t>(&g_gigacageConfig), configSizeToProtect, AllowPermissionChangesAfterThis, VM_PROT_READ | VM_PROT_WRITE);
+#else
+    result = mprotect(&g_gigacageConfig, configSizeToProtect, PROT_READ | PROT_WRITE);
+#endif
+    RELEASE_BASSERT(!result);
 }
 
-void unprotectGigacageBasePtrs()
+static void permanentlyFreezeGigacageConfig()
 {
-    mprotect(g_gigacageBasePtrs, gigacageBasePtrsSize, PROT_READ | PROT_WRITE);
+    if (!g_gigacageConfig.isPermanentlyFrozen) {
+        unfreezeGigacageConfig();
+        g_gigacageConfig.isPermanentlyFrozen = true;
+    }
+
+    // There's no going back now!
+    int result;
+#if BOS(DARWIN)
+    result = vm_protect(mach_task_self(), reinterpret_cast<vm_address_t>(&g_gigacageConfig), configSizeToProtect, DisallowPermissionChangesAfterThis, VM_PROT_READ);
+#else
+    result = mprotect(&g_gigacageConfig, configSizeToProtect, PROT_READ);
+#endif
+    RELEASE_BASSERT(!result);
 }
 
-class UnprotectGigacageBasePtrsScope {
+class UnfreezeGigacageConfigScope {
 public:
-    UnprotectGigacageBasePtrsScope()
+    UnfreezeGigacageConfigScope()
     {
-        unprotectGigacageBasePtrs();
+        unfreezeGigacageConfig();
     }
 
-    ~UnprotectGigacageBasePtrsScope()
+    ~UnfreezeGigacageConfigScope()
     {
-        protectGigacageBasePtrs();
+        freezeGigacageConfig();
     }
 };
 
 size_t runwaySize(Kind kind)
 {
     switch (kind) {
-    case Kind::ReservedForFlagsAndNotABasePtr:
-        RELEASE_BASSERT_NOT_REACHED();
     case Kind::Primitive:
         return gigacageRunway;
     case Kind::JSValue:
         return 0;
+    case Kind::NumberOfKinds:
+        RELEASE_BASSERT_NOT_REACHED();
     }
     return 0;
 }
 
 } // anonymous namespace
@@ -132,24 +164,31 @@
 {
     static std::once_flag onceFlag;
     std::call_once(
         onceFlag,
         [] {
+            RELEASE_BASSERT(!g_gigacageConfig.ensureGigacageHasBeenCalled);
+            g_gigacageConfig.ensureGigacageHasBeenCalled = true;
+
             if (!shouldBeEnabled())
                 return;
 
-            Kind shuffledKinds[numKinds];
-            for (unsigned i = 0; i < numKinds; ++i)
-                shuffledKinds[i] = static_cast<Kind>(i + 1); // + 1 to skip Kind::ReservedForFlagsAndNotABasePtr.
+            // We might only get page size alignment, but that's also the minimum
+            // alignment we need for freezing the Config.
+            RELEASE_BASSERT(!(reinterpret_cast<size_t>(&g_gigacageConfig) & (vmPageSize() - 1)));
+
+            Kind shuffledKinds[NumberOfKinds];
+            for (unsigned i = 0; i < NumberOfKinds; ++i)
+                shuffledKinds[i] = static_cast<Kind>(i);
 
             // We just go ahead and assume that 64 bits is enough randomness. That's trivially true right
             // now, but would stop being true if we went crazy with gigacages. Based on my math, 21 is the
             // largest value of n so that n! <= 2^64.
-            static_assert(numKinds <= 21, "too many kinds");
+            static_assert(NumberOfKinds <= 21, "too many kinds");
             uint64_t random;
             cryptoRandom(reinterpret_cast<unsigned char*>(&random), sizeof(random));
-            for (unsigned i = numKinds; i--;) {
+            for (unsigned i = NumberOfKinds; i--;) {
                 unsigned limit = i + 1;
                 unsigned j = static_cast<unsigned>(random % limit);
                 random /= limit;
                 std::swap(shuffledKinds[i], shuffledKinds[j]);
             }
@@ -182,103 +221,118 @@
             }
 
             size_t nextCage = 0;
             for (Kind kind : shuffledKinds) {
                 nextCage = alignTo(kind, nextCage);
-                basePtr(kind) = reinterpret_cast<char*>(base) + nextCage;
+                g_gigacageConfig.setBasePtr(kind, reinterpret_cast<char*>(base) + nextCage);
                 nextCage = bump(kind, nextCage);
                 if (runwaySize(kind) > 0) {
                     char* runway = reinterpret_cast<char*>(base) + nextCage;
                     // Make OOB accesses into the runway crash.
                     vmRevokePermissions(runway, runwaySize(kind));
                     nextCage += runwaySize(kind);
                 }
             }
 
+            g_gigacageConfig.start = base;
+            g_gigacageConfig.totalSize = totalSize;
             vmDeallocatePhysicalPages(base, totalSize);
-            setWasEnabled();
-            protectGigacageBasePtrs();
+            g_gigacageConfig.isEnabled = true;
+            freezeGigacageConfig();
         });
 }
 
 void disablePrimitiveGigacage()
 {
+    if (g_gigacageConfig.disablingPrimitiveGigacageIsForbidden)
+        fprintf(stderr, "FATAL: Disabling Primitive gigacage is forbidden, but we don't want that in this process.\n");
+
+    RELEASE_BASSERT(!g_gigacageConfig.disablingPrimitiveGigacageIsForbidden);
+    RELEASE_BASSERT(!g_gigacageConfig.isPermanentlyFrozen);
+
     ensureGigacage();
-    if (!basePtrs().primitive) {
+    if (!g_gigacageConfig.basePtrs[Primitive]) {
         // It was never enabled. That means that we never even saved any callbacks. Or, we had already disabled
         // it before, and already called the callbacks.
         return;
     }
 
     PrimitiveDisableCallbacks& callbacks = *PrimitiveDisableCallbacks::get();
-    std::unique_lock<Mutex> lock(PrimitiveDisableCallbacks::mutex());
+    UniqueLockHolder lock(PrimitiveDisableCallbacks::mutex());
     for (Callback& callback : callbacks.callbacks)
         callback.function(callback.argument);
     callbacks.callbacks.shrink(0);
-    UnprotectGigacageBasePtrsScope unprotectScope;
-    basePtrs().primitive = nullptr;
+    UnfreezeGigacageConfigScope unfreezeScope;
+    g_gigacageConfig.basePtrs[Primitive] = nullptr;
 }
 
 void addPrimitiveDisableCallback(void (*function)(void*), void* argument)
 {
     ensureGigacage();
-    if (!basePtrs().primitive) {
+    if (!g_gigacageConfig.basePtrs[Primitive]) {
         // It was already disabled or we were never able to enable it.
         function(argument);
         return;
     }
 
     PrimitiveDisableCallbacks& callbacks = *PrimitiveDisableCallbacks::get();
-    std::unique_lock<Mutex> lock(PrimitiveDisableCallbacks::mutex());
+    UniqueLockHolder lock(PrimitiveDisableCallbacks::mutex());
     callbacks.callbacks.push(Callback(function, argument));
 }
 
 void removePrimitiveDisableCallback(void (*function)(void*), void* argument)
 {
     PrimitiveDisableCallbacks& callbacks = *PrimitiveDisableCallbacks::get();
-    std::unique_lock<Mutex> lock(PrimitiveDisableCallbacks::mutex());
+    UniqueLockHolder lock(PrimitiveDisableCallbacks::mutex());
     for (size_t i = 0; i < callbacks.callbacks.size(); ++i) {
         if (callbacks.callbacks[i].function == function
             && callbacks.callbacks[i].argument == argument) {
             callbacks.callbacks[i] = callbacks.callbacks.last();
             callbacks.callbacks.pop();
             return;
         }
     }
 }
 
-static void primitiveGigacageDisabled(void*)
+static bool verifyGigacageIsEnabled()
 {
-    if (GIGACAGE_ALLOCATION_CAN_FAIL && !wasEnabled())
-        return;
-
-    static bool s_false;
-    fprintf(stderr, "FATAL: Primitive gigacage disabled, but we don't want that in this process.\n");
-    if (!s_false)
-        BCRASH();
+    bool isEnabled = g_gigacageConfig.isEnabled;
+    for (size_t i = 0; i < NumberOfKinds; ++i)
+        isEnabled = isEnabled && g_gigacageConfig.basePtrs[i];
+    isEnabled = isEnabled && g_gigacageConfig.start;
+    isEnabled = isEnabled && g_gigacageConfig.totalSize;
+    return isEnabled;
 }
 
-void disableDisablingPrimitiveGigacageIfShouldBeEnabled()
+void forbidDisablingPrimitiveGigacage()
 {
-    if (shouldBeEnabled()) {
-        addPrimitiveDisableCallback(primitiveGigacageDisabled, nullptr);
-        s_isDisablingPrimitiveGigacageDisabled = true;
+    ensureGigacage();
+    RELEASE_BASSERT(g_gigacageConfig.shouldBeEnabledHasBeenCalled
+        && (GIGACAGE_ALLOCATION_CAN_FAIL || !g_gigacageConfig.shouldBeEnabled || verifyGigacageIsEnabled()));
+
+    if (!g_gigacageConfig.disablingPrimitiveGigacageIsForbidden) {
+        unfreezeGigacageConfig();
+        g_gigacageConfig.disablingPrimitiveGigacageIsForbidden = true;
     }
+    permanentlyFreezeGigacageConfig();
+    RELEASE_BASSERT(isDisablingPrimitiveGigacageForbidden());
 }
 
-bool isDisablingPrimitiveGigacageDisabled()
+BNO_INLINE bool isDisablingPrimitiveGigacageForbidden()
 {
-    return s_isDisablingPrimitiveGigacageDisabled;
+    return g_gigacageConfig.disablingPrimitiveGigacageIsForbidden;
 }
 
 bool shouldBeEnabled()
 {
-    static bool cached = false;
     static std::once_flag onceFlag;
     std::call_once(
         onceFlag,
         [] {
+            RELEASE_BASSERT(!g_gigacageConfig.shouldBeEnabledHasBeenCalled);
+            g_gigacageConfig.shouldBeEnabledHasBeenCalled = true;
+
             bool debugHeapEnabled = Environment::get()->isDebugHeapEnabled();
             if (debugHeapEnabled)
                 return;
 
             if (!gigacageEnabledForProcess())
@@ -290,15 +344,13 @@
                     return;
                 } else if (strcasecmp(gigacageEnabled, "yes") && strcasecmp(gigacageEnabled, "true") && strcasecmp(gigacageEnabled, "1"))
                     fprintf(stderr, "Warning: invalid argument to GIGACAGE_ENABLED: %s\n", gigacageEnabled);
             }
 
-            cached = true;
+            g_gigacageConfig.shouldBeEnabled = true;
         });
-    return cached;
+    return g_gigacageConfig.shouldBeEnabled;
 }
 
 } // namespace Gigacage
 
 #endif // GIGACAGE_ENABLED
-
-

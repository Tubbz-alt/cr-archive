diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.cpp
@@ -24,28 +24,39 @@
  */
 
 #include "config.h"
 #include "ArrayBuffer.h"
 
-#include "ArrayBufferNeuteringWatchpointSet.h"
 #include "JSArrayBufferView.h"
 #include "JSCInlines.h"
 #include <wtf/Gigacage.h>
 
 namespace JSC {
 
+Ref<SharedTask<void(void*)>> ArrayBuffer::primitiveGigacageDestructor()
+{
+    static LazyNeverDestroyed<Ref<SharedTask<void(void*)>>> destructor;
+    static std::once_flag onceKey;
+    std::call_once(onceKey, [&] {
+        destructor.construct(createSharedTask<void(void*)>([] (void* p) { Gigacage::free(Gigacage::Primitive, p); }));
+    });
+    return destructor.get().copyRef();
+}
+
 SharedArrayBufferContents::SharedArrayBufferContents(void* data, unsigned size, ArrayBufferDestructorFunction&& destructor)
     : m_data(data, size)
     , m_destructor(WTFMove(destructor))
     , m_sizeInBytes(size)
 {
 }
 
 SharedArrayBufferContents::~SharedArrayBufferContents()
 {
-    // FIXME: we shouldn't use getUnsafe here https://bugs.webkit.org/show_bug.cgi?id=197698
-    m_destructor(m_data.getUnsafe());
+    if (m_destructor) {
+        // FIXME: we shouldn't use getUnsafe here https://bugs.webkit.org/show_bug.cgi?id=197698
+        m_destructor->run(m_data.getUnsafe());
+    }
 }
 
 ArrayBufferContents::ArrayBufferContents()
 {
     reset();
@@ -82,19 +93,21 @@
     reset();
 }
 
 void ArrayBufferContents::destroy()
 {
-    // FIXME: We shouldn't use getUnsafe here: https://bugs.webkit.org/show_bug.cgi?id=197698
-    m_destructor(m_data.getUnsafe());
+    if (m_destructor) {
+        // FIXME: We shouldn't use getUnsafe here: https://bugs.webkit.org/show_bug.cgi?id=197698
+        m_destructor->run(m_data.getUnsafe());
+    }
 }
 
 void ArrayBufferContents::reset()
 {
-    m_destructor = [] (void*) { };
-    m_shared = nullptr;
     m_data = nullptr;
+    m_destructor = nullptr;
+    m_shared = nullptr;
     m_sizeInBytes = 0;
 }
 
 void ArrayBufferContents::tryAllocate(unsigned numElements, unsigned elementByteSize, InitializationPolicy policy)
 {
@@ -121,17 +134,17 @@
     if (policy == ZeroInitialize)
         memset(data, 0, allocationSize);
 
     m_sizeInBytes = sizeInBytes;
     RELEASE_ASSERT(m_sizeInBytes <= MAX_ARRAY_BUFFER_SIZE);
-    m_destructor = [] (void* p) { Gigacage::free(Gigacage::Primitive, p); };
+    m_destructor = ArrayBuffer::primitiveGigacageDestructor();
 }
 
 void ArrayBufferContents::makeShared()
 {
     m_shared = adoptRef(new SharedArrayBufferContents(data(), sizeInBytes(), WTFMove(m_destructor)));
-    m_destructor = [] (void*) { };
+    m_destructor = nullptr;
 }
 
 void ArrayBufferContents::transferTo(ArrayBufferContents& other)
 {
     other.clear();
@@ -156,13 +169,13 @@
 
 void ArrayBufferContents::shareWith(ArrayBufferContents& other)
 {
     ASSERT(!other.m_data);
     ASSERT(m_shared);
-    other.m_destructor = [] (void*) { };
-    other.m_shared = m_shared;
     other.m_data = m_data;
+    other.m_destructor = nullptr;
+    other.m_shared = m_shared;
     other.m_sizeInBytes = m_sizeInBytes;
     RELEASE_ASSERT(other.m_sizeInBytes <= MAX_ARRAY_BUFFER_SIZE);
 }
 
 Ref<ArrayBuffer> ArrayBuffer::create(unsigned numElements, unsigned elementByteSize)
@@ -195,11 +208,11 @@
 // Current this is only used from:
 // - JSGenericTypedArrayView<>::slowDownAndWasteMemory. But in that case, the memory should have already come
 //   from the cage.
 Ref<ArrayBuffer> ArrayBuffer::createAdopted(const void* data, unsigned byteLength)
 {
-    return createFromBytes(data, byteLength, [] (void* p) { Gigacage::free(Gigacage::Primitive, p); });
+    return createFromBytes(data, byteLength, ArrayBuffer::primitiveGigacageDestructor());
 }
 
 // FIXME: We cannot use this except if the memory comes from the cage.
 // Currently this is only used from:
 // - The C API. We could support that by either having the system switch to a mode where typed arrays are no
@@ -293,25 +306,26 @@
     if (index < 0)
         index = currentLength + index;
     return clampValue(index, 0, currentLength);
 }
 
-Ref<ArrayBuffer> ArrayBuffer::slice(double begin, double end) const
+RefPtr<ArrayBuffer> ArrayBuffer::slice(double begin, double end) const
 {
     return sliceImpl(clampIndex(begin), clampIndex(end));
 }
 
-Ref<ArrayBuffer> ArrayBuffer::slice(double begin) const
+RefPtr<ArrayBuffer> ArrayBuffer::slice(double begin) const
 {
     return sliceImpl(clampIndex(begin), byteLength());
 }
 
-Ref<ArrayBuffer> ArrayBuffer::sliceImpl(unsigned begin, unsigned end) const
+RefPtr<ArrayBuffer> ArrayBuffer::sliceImpl(unsigned begin, unsigned end) const
 {
     unsigned size = begin <= end ? end - begin : 0;
-    auto result = ArrayBuffer::create(static_cast<const char*>(data()) + begin, size);
-    result->setSharingMode(sharingMode());
+    auto result = ArrayBuffer::tryCreate(static_cast<const char*>(data()) + begin, size);
+    if (result)
+        result->setSharingMode(sharingMode());
     return result;
 }
 
 void ArrayBuffer::makeShared()
 {
@@ -367,32 +381,31 @@
             return false;
         return true;
     }
 
     m_contents.transferTo(result);
-    notifyIncommingReferencesOfTransfer(vm);
+    notifyNeutering(vm);
     return true;
 }
 
 // We allow neutering wasm memory ArrayBuffers even though they are locked.
 void ArrayBuffer::neuter(VM& vm)
 {
     ASSERT(isWasmMemory());
     ArrayBufferContents unused;
     m_contents.transferTo(unused);
-    notifyIncommingReferencesOfTransfer(vm);
+    notifyNeutering(vm);
 }
 
-void ArrayBuffer::notifyIncommingReferencesOfTransfer(VM& vm)
+void ArrayBuffer::notifyNeutering(VM& vm)
 {
     for (size_t i = numberOfIncomingReferences(); i--;) {
         JSCell* cell = incomingReferenceAt(i);
         if (JSArrayBufferView* view = jsDynamicCast<JSArrayBufferView*>(vm, cell))
             view->neuter();
-        else if (ArrayBufferNeuteringWatchpointSet* watchpoint = jsDynamicCast<ArrayBufferNeuteringWatchpointSet*>(vm, cell))
-            watchpoint->fireAll();
     }
+    m_neuteringWatchpointSet.fireAll(vm, "Array buffer was neutered");
 }
 
 ASCIILiteral errorMesasgeForTransfer(ArrayBuffer* buffer)
 {
     ASSERT(buffer->isLocked());

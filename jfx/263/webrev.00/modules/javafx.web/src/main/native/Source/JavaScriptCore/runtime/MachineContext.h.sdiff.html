<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/MachineContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Lookup.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MapConstructor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/MachineContext.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41 
 42 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
 43 template&lt;typename T = void*&gt; void setStackPointer(PlatformRegisters&amp;, T);
 44 template&lt;typename T = void*&gt; T framePointer(const PlatformRegisters&amp;);
 45 template&lt;typename T = void*&gt; void setFramePointer(PlatformRegisters&amp;, T);
 46 inline MacroAssemblerCodePtr&lt;PlatformRegistersLRPtrTag&gt; linkRegister(const PlatformRegisters&amp;);
 47 inline void setLinkRegister(PlatformRegisters&amp;, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt;);
 48 inline Optional&lt;MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;&gt; instructionPointer(const PlatformRegisters&amp;);
 49 inline void setInstructionPointer(PlatformRegisters&amp;, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt;);
 50 
 51 template&lt;size_t N&gt; void*&amp; argumentPointer(PlatformRegisters&amp;);
 52 template&lt;size_t N&gt; void* argumentPointer(const PlatformRegisters&amp;);
 53 #if !ENABLE(C_LOOP)
 54 void*&amp; llintInstructionPointer(PlatformRegisters&amp;);
 55 void* llintInstructionPointer(const PlatformRegisters&amp;);
 56 #endif // !ENABLE(C_LOOP)
 57 
 58 #if HAVE(MACHINE_CONTEXT)
 59 
 60 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE)


 61 static inline void*&amp; stackPointerImpl(mcontext_t&amp;);
<span class="line-removed"> 62 static inline void*&amp; framePointerImpl(mcontext_t&amp;);</span>
 63 static inline void*&amp; instructionPointerImpl(mcontext_t&amp;);



 64 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
 65 
 66 template&lt;typename T = void*&gt; T stackPointer(const mcontext_t&amp;);
 67 template&lt;typename T = void*&gt; void setStackPointer(mcontext_t&amp;, T);
 68 template&lt;typename T = void*&gt; T framePointer(const mcontext_t&amp;);
 69 template&lt;typename T = void*&gt; void setFramePointer(mcontext_t&amp;, T);
 70 inline MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt; instructionPointer(const mcontext_t&amp;);
 71 inline void setInstructionPointer(mcontext_t&amp;, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt;);
 72 
 73 template&lt;size_t N&gt; void*&amp; argumentPointer(mcontext_t&amp;);
 74 template&lt;size_t N&gt; void* argumentPointer(const mcontext_t&amp;);
 75 #if !ENABLE(C_LOOP)
 76 void*&amp; llintInstructionPointer(mcontext_t&amp;);
 77 void* llintInstructionPointer(const mcontext_t&amp;);
 78 #endif // !ENABLE(C_LOOP)
 79 #endif // HAVE(MACHINE_CONTEXT)
 80 #endif // OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
 81 
 82 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
 83 
<span class="line-modified"> 84 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE)</span>
 85 static inline void*&amp; stackPointerImpl(PlatformRegisters&amp; regs)
 86 {
 87 #if OS(DARWIN)
 88 #if __DARWIN_UNIX03
 89 
 90 #if CPU(X86)
 91     return reinterpret_cast&lt;void*&amp;&gt;(regs.__esp);
 92 #elif CPU(X86_64)
 93     return reinterpret_cast&lt;void*&amp;&gt;(regs.__rsp);
 94 #elif CPU(PPC) || CPU(PPC64)
 95     return reinterpret_cast&lt;void*&amp;&gt;(regs.__r1);
<span class="line-modified"> 96 #elif CPU(ARM_THUMB2) || CPU(ARM) || CPU(ARM64)</span>
 97     return reinterpret_cast&lt;void*&amp;&gt;(regs.__sp);
 98 #else
 99 #error Unknown Architecture
100 #endif
101 
102 #else // !__DARWIN_UNIX03
103 
104 #if CPU(X86)
105     return reinterpret_cast&lt;void*&amp;&gt;(regs.esp);
106 #elif CPU(X86_64)
107     return reinterpret_cast&lt;void*&amp;&gt;(regs.rsp);
108 #elif CPU(PPC) || CPU(PPC64)
109     return reinterpret_cast&lt;void*&amp;&gt;(regs.r1);
110 #else
111 #error Unknown Architecture
112 #endif
113 
114 #endif // __DARWIN_UNIX03
115 
116 #elif OS(WINDOWS)
</pre>
<hr />
<pre>
123     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Esp);
124 #elif CPU(X86_64)
125     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Rsp);
126 #else
127 #error Unknown Architecture
128 #endif
129 
130 #elif HAVE(MACHINE_CONTEXT)
131     return stackPointerImpl(regs.machineContext);
132 #endif
133 }
134 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
135 
136 template&lt;typename T&gt;
137 inline T stackPointer(const PlatformRegisters&amp; regs)
138 {
139 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
140     void* value = WTF_READ_PLATFORM_REGISTERS_SP_WITH_PROFILE(regs);
141     assertIsNotTagged(value);
142     return bitwise_cast&lt;T&gt;(value);


143 #else
144     return bitwise_cast&lt;T&gt;(stackPointerImpl(const_cast&lt;PlatformRegisters&amp;&gt;(regs)));
145 #endif
146 }
147 
148 template&lt;typename T&gt;
149 inline void setStackPointer(PlatformRegisters&amp; regs, T value)
150 {
151 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
152     assertIsNotTagged(bitwise_cast&lt;void*&gt;(value));
153     WTF_WRITE_PLATFORM_REGISTERS_SP_WITH_PROFILE(regs, bitwise_cast&lt;void*&gt;(value));


154 #else
155     stackPointerImpl(regs) = bitwise_cast&lt;void*&gt;(value);
156 #endif
157 }
158 
159 #else // not OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
160 
161 template&lt;typename T&gt;
162 inline T stackPointer(const PlatformRegisters&amp; regs)
163 {
164     return bitwise_cast&lt;T&gt;(regs.stackPointer);
165 }
166 #endif // OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
167 
168 #if HAVE(MACHINE_CONTEXT)
169 
<span class="line-modified">170 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE)</span>
171 static inline void*&amp; stackPointerImpl(mcontext_t&amp; machineContext)
172 {
173 #if OS(DARWIN)
174     return stackPointerImpl(machineContext-&gt;__ss);
175 #elif OS(FREEBSD)
176 
177 #if CPU(X86)
178     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_esp);
179 #elif CPU(X86_64)
180     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_rsp);
181 #elif CPU(ARM)
182     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.__gregs[_REG_SP]);
183 #elif CPU(ARM64)
184     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_gpregs.gp_sp);
185 #elif CPU(MIPS)
186     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_regs[29]);
187 #else
188 #error Unknown Architecture
189 #endif
190 
</pre>
<hr />
<pre>
197 #elif CPU(ARM)
198     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.arm_sp);
199 #elif CPU(ARM64)
200     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.sp);
201 #elif CPU(MIPS)
202     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[29]);
203 #else
204 #error Unknown Architecture
205 #endif
206 #endif
207 }
208 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
209 
210 template&lt;typename T&gt;
211 inline T stackPointer(const mcontext_t&amp; machineContext)
212 {
213 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
214     void* value = WTF_READ_MACHINE_CONTEXT_SP_WITH_PROFILE(machineContext);
215     assertIsNotTagged(value);
216     return bitwise_cast&lt;T&gt;(value);


217 #else
218     return bitwise_cast&lt;T&gt;(stackPointerImpl(const_cast&lt;mcontext_t&amp;&gt;(machineContext)));
219 #endif
220 }
221 
222 template&lt;typename T&gt;
223 inline void setStackPointer(mcontext_t&amp; machineContext, T value)
224 {
225 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
226     assertIsNotTagged(bitwise_cast&lt;void*&gt;(value));
227     WTF_WRITE_MACHINE_CONTEXT_SP_WITH_PROFILE(machineContext, bitwise_cast&lt;void*&gt;(value));


228 #else
229     stackPointerImpl(machineContext) = bitwise_cast&lt;void*&gt;(value);
230 #endif
231 }
232 #endif // HAVE(MACHINE_CONTEXT)
233 
234 
235 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
236 
237 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE)
238 static inline void*&amp; framePointerImpl(PlatformRegisters&amp; regs)
239 {
240 #if OS(DARWIN)
241 
242 #if __DARWIN_UNIX03
243 
244 #if CPU(X86)
245     return reinterpret_cast&lt;void*&amp;&gt;(regs.__ebp);
246 #elif CPU(X86_64)
247     return reinterpret_cast&lt;void*&amp;&gt;(regs.__rbp);
</pre>
<hr />
<pre>
368 #else
369     return bitwise_cast&lt;T&gt;(framePointerImpl(const_cast&lt;mcontext_t&amp;&gt;(machineContext)));
370 #endif
371 }
372 
373 template&lt;typename T&gt;
374 inline void setFramePointer(mcontext_t&amp; machineContext, T value)
375 {
376 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
377     assertIsNotTagged(bitwise_cast&lt;void*&gt;(value));
378     WTF_WRITE_MACHINE_CONTEXT_FP_WITH_PROFILE(machineContext, bitwise_cast&lt;void*&gt;(value));
379 #else
380     framePointerImpl(machineContext) = bitwise_cast&lt;void*&gt;(value);
381 #endif
382 }
383 #endif // HAVE(MACHINE_CONTEXT)
384 
385 
386 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
387 
<span class="line-modified">388 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE)</span>
389 static inline void*&amp; instructionPointerImpl(PlatformRegisters&amp; regs)
390 {
391 #if OS(DARWIN)
392 #if __DARWIN_UNIX03
393 
394 #if CPU(X86)
395     return reinterpret_cast&lt;void*&amp;&gt;(regs.__eip);
396 #elif CPU(X86_64)
397     return reinterpret_cast&lt;void*&amp;&gt;(regs.__rip);
<span class="line-modified">398 #elif CPU(ARM_THUMB2) || CPU(ARM) || CPU(ARM64)</span>
399     return reinterpret_cast&lt;void*&amp;&gt;(regs.__pc);
400 #else
401 #error Unknown Architecture
402 #endif
403 
404 #else // !__DARWIN_UNIX03
405 #if CPU(X86)
406     return reinterpret_cast&lt;void*&amp;&gt;(regs.eip);
407 #elif CPU(X86_64)
408     return reinterpret_cast&lt;void*&amp;&gt;(regs.rip);
409 #else
410 #error Unknown Architecture
411 #endif
412 
413 #endif // __DARWIN_UNIX03
414 
415 #elif OS(WINDOWS)
416 
417 #if CPU(ARM)
418     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Pc);
419 #elif CPU(MIPS)
420 #error Dont know what to do with mips. Do we even need this?
421 #elif CPU(X86)
422     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Eip);
423 #elif CPU(X86_64)
424     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Rip);
425 #else
426 #error Unknown Architecture
427 #endif
428 
429 #elif HAVE(MACHINE_CONTEXT)
430     return instructionPointerImpl(regs.machineContext);
431 #endif
432 }
433 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
434 
435 inline Optional&lt;MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;&gt; instructionPointer(const PlatformRegisters&amp; regs)
436 {
437 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
438     void* value = WTF_READ_PLATFORM_REGISTERS_PC_WITH_PROFILE(regs);


439 #else
440     void* value = instructionPointerImpl(const_cast&lt;PlatformRegisters&amp;&gt;(regs));
441 #endif
442     if (!value)
443         return MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;(nullptr);
444     if (!usesPointerTagging())
445         return MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;(value);
446     if (isTaggedWith(value, PlatformRegistersPCPtrTag))
447         return MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;(value);
448     return WTF::nullopt;
449 }
450 
451 inline void setInstructionPointer(PlatformRegisters&amp; regs, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt; value)
452 {
453 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
454     WTF_WRITE_PLATFORM_REGISTERS_PC_WITH_PROFILE(regs, value.executableAddress());


455 #else
456     instructionPointerImpl(regs) = value.executableAddress();
457 #endif
458 }
459 #endif // OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
460 
461 
462 #if HAVE(MACHINE_CONTEXT)
463 
<span class="line-modified">464 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE)</span>
465 static inline void*&amp; instructionPointerImpl(mcontext_t&amp; machineContext)
466 {
467 #if OS(DARWIN)
468     return instructionPointerImpl(machineContext-&gt;__ss);
469 #elif OS(FREEBSD)
470 
471 #if CPU(X86)
472     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_eip);
473 #elif CPU(X86_64)
474     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_rip);
475 #elif CPU(ARM)
476     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.__gregs[_REG_PC]);
477 #elif CPU(ARM64)
478     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_gpregs.gp_elr);
479 #elif CPU(MIPS)
480     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_pc);
481 #else
482 #error Unknown Architecture
483 #endif
484 
</pre>
<hr />
<pre>
490 #elif CPU(X86_64)
491     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[REG_RIP]);
492 #elif CPU(ARM)
493     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.arm_pc);
494 #elif CPU(ARM64)
495     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.pc);
496 #elif CPU(MIPS)
497     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.pc);
498 #else
499 #error Unknown Architecture
500 #endif
501 
502 #else
503 #error Need a way to get the instruction pointer for another thread on this platform
504 #endif
505 }
506 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
507 
508 inline MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt; instructionPointer(const mcontext_t&amp; machineContext)
509 {




510 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
511     void* value = WTF_READ_MACHINE_CONTEXT_PC_WITH_PROFILE(machineContext);
512 #else
513     void* value = instructionPointerImpl(const_cast&lt;mcontext_t&amp;&gt;(machineContext));
514 #endif

515     return MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;(value);

516 }
517 
518 inline void setInstructionPointer(mcontext_t&amp; machineContext, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt; value)
519 {
520 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
521     WTF_WRITE_MACHINE_CONTEXT_PC_WITH_PROFILE(machineContext, value.executableAddress());


522 #else
523     instructionPointerImpl(machineContext) = value.executableAddress();
524 #endif
525 }
526 #endif // HAVE(MACHINE_CONTEXT)
527 
528 
529 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
530 
531 #if OS(DARWIN) &amp;&amp; __DARWIN_UNIX03 &amp;&amp; CPU(ARM64)
<span class="line-removed">532 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE)</span>
<span class="line-removed">533 inline void*&amp; linkRegisterImpl(PlatformRegisters&amp; regs)</span>
<span class="line-removed">534 {</span>
<span class="line-removed">535     return reinterpret_cast&lt;void*&amp;&gt;(regs.__lr);</span>
<span class="line-removed">536 }</span>
<span class="line-removed">537 #endif // USE(PLATFORM_REGISTERS_WITH_PROFILE)</span>
<span class="line-removed">538 </span>
539 
540 inline MacroAssemblerCodePtr&lt;PlatformRegistersLRPtrTag&gt; linkRegister(const PlatformRegisters&amp; regs)
541 {
542 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
543     void* value = WTF_READ_PLATFORM_REGISTERS_LR_WITH_PROFILE(regs);
544 #else
<span class="line-modified">545     void* value = linkRegisterImpl(const_cast&lt;PlatformRegisters&amp;&gt;(regs));</span>
546 #endif
547     return MacroAssemblerCodePtr&lt;PlatformRegistersLRPtrTag&gt;(value);
548 }
549 
550 inline void setLinkRegister(PlatformRegisters&amp; regs, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt; value)
551 {
552 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
553     WTF_WRITE_PLATFORM_REGISTERS_PC_WITH_PROFILE(regs, value.executableAddress());
554 #else
<span class="line-modified">555     linkRegisterImpl(regs) = value.executableAddress();</span>
556 #endif
557 }
558 #endif // OS(DARWIN) &amp;&amp; __DARWIN_UNIX03 &amp;&amp; CPU(ARM64)
559 
560 #if HAVE(MACHINE_CONTEXT)
561 template&lt;&gt; void*&amp; argumentPointer&lt;1&gt;(mcontext_t&amp;);
562 #endif
563 
564 template&lt;&gt;
565 inline void*&amp; argumentPointer&lt;1&gt;(PlatformRegisters&amp; regs)
566 {
567 #if OS(DARWIN)
568 #if __DARWIN_UNIX03
569 
570 #if CPU(X86)
571     return reinterpret_cast&lt;void*&amp;&gt;(regs.__edx);
572 #elif CPU(X86_64)
573     return reinterpret_cast&lt;void*&amp;&gt;(regs.__rsi);
574 #elif CPU(ARM_THUMB2) || CPU(ARM)
575     return reinterpret_cast&lt;void*&amp;&gt;(regs.__r[1]);
</pre>
</td>
<td>
<hr />
<pre>
 41 
 42 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
 43 template&lt;typename T = void*&gt; void setStackPointer(PlatformRegisters&amp;, T);
 44 template&lt;typename T = void*&gt; T framePointer(const PlatformRegisters&amp;);
 45 template&lt;typename T = void*&gt; void setFramePointer(PlatformRegisters&amp;, T);
 46 inline MacroAssemblerCodePtr&lt;PlatformRegistersLRPtrTag&gt; linkRegister(const PlatformRegisters&amp;);
 47 inline void setLinkRegister(PlatformRegisters&amp;, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt;);
 48 inline Optional&lt;MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;&gt; instructionPointer(const PlatformRegisters&amp;);
 49 inline void setInstructionPointer(PlatformRegisters&amp;, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt;);
 50 
 51 template&lt;size_t N&gt; void*&amp; argumentPointer(PlatformRegisters&amp;);
 52 template&lt;size_t N&gt; void* argumentPointer(const PlatformRegisters&amp;);
 53 #if !ENABLE(C_LOOP)
 54 void*&amp; llintInstructionPointer(PlatformRegisters&amp;);
 55 void* llintInstructionPointer(const PlatformRegisters&amp;);
 56 #endif // !ENABLE(C_LOOP)
 57 
 58 #if HAVE(MACHINE_CONTEXT)
 59 
 60 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE)
<span class="line-added"> 61 </span>
<span class="line-added"> 62 #if !USE(DARWIN_REGISTER_MACROS)</span>
 63 static inline void*&amp; stackPointerImpl(mcontext_t&amp;);

 64 static inline void*&amp; instructionPointerImpl(mcontext_t&amp;);
<span class="line-added"> 65 #endif // !USE(DARWIN_REGISTER_MACROS)</span>
<span class="line-added"> 66 </span>
<span class="line-added"> 67 static inline void*&amp; framePointerImpl(mcontext_t&amp;);</span>
 68 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
 69 
 70 template&lt;typename T = void*&gt; T stackPointer(const mcontext_t&amp;);
 71 template&lt;typename T = void*&gt; void setStackPointer(mcontext_t&amp;, T);
 72 template&lt;typename T = void*&gt; T framePointer(const mcontext_t&amp;);
 73 template&lt;typename T = void*&gt; void setFramePointer(mcontext_t&amp;, T);
 74 inline MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt; instructionPointer(const mcontext_t&amp;);
 75 inline void setInstructionPointer(mcontext_t&amp;, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt;);
 76 
 77 template&lt;size_t N&gt; void*&amp; argumentPointer(mcontext_t&amp;);
 78 template&lt;size_t N&gt; void* argumentPointer(const mcontext_t&amp;);
 79 #if !ENABLE(C_LOOP)
 80 void*&amp; llintInstructionPointer(mcontext_t&amp;);
 81 void* llintInstructionPointer(const mcontext_t&amp;);
 82 #endif // !ENABLE(C_LOOP)
 83 #endif // HAVE(MACHINE_CONTEXT)
 84 #endif // OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
 85 
 86 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
 87 
<span class="line-modified"> 88 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE) &amp;&amp; !USE(DARWIN_REGISTER_MACROS)</span>
 89 static inline void*&amp; stackPointerImpl(PlatformRegisters&amp; regs)
 90 {
 91 #if OS(DARWIN)
 92 #if __DARWIN_UNIX03
 93 
 94 #if CPU(X86)
 95     return reinterpret_cast&lt;void*&amp;&gt;(regs.__esp);
 96 #elif CPU(X86_64)
 97     return reinterpret_cast&lt;void*&amp;&gt;(regs.__rsp);
 98 #elif CPU(PPC) || CPU(PPC64)
 99     return reinterpret_cast&lt;void*&amp;&gt;(regs.__r1);
<span class="line-modified">100 #elif CPU(ARM_THUMB2) || CPU(ARM)</span>
101     return reinterpret_cast&lt;void*&amp;&gt;(regs.__sp);
102 #else
103 #error Unknown Architecture
104 #endif
105 
106 #else // !__DARWIN_UNIX03
107 
108 #if CPU(X86)
109     return reinterpret_cast&lt;void*&amp;&gt;(regs.esp);
110 #elif CPU(X86_64)
111     return reinterpret_cast&lt;void*&amp;&gt;(regs.rsp);
112 #elif CPU(PPC) || CPU(PPC64)
113     return reinterpret_cast&lt;void*&amp;&gt;(regs.r1);
114 #else
115 #error Unknown Architecture
116 #endif
117 
118 #endif // __DARWIN_UNIX03
119 
120 #elif OS(WINDOWS)
</pre>
<hr />
<pre>
127     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Esp);
128 #elif CPU(X86_64)
129     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Rsp);
130 #else
131 #error Unknown Architecture
132 #endif
133 
134 #elif HAVE(MACHINE_CONTEXT)
135     return stackPointerImpl(regs.machineContext);
136 #endif
137 }
138 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
139 
140 template&lt;typename T&gt;
141 inline T stackPointer(const PlatformRegisters&amp; regs)
142 {
143 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
144     void* value = WTF_READ_PLATFORM_REGISTERS_SP_WITH_PROFILE(regs);
145     assertIsNotTagged(value);
146     return bitwise_cast&lt;T&gt;(value);
<span class="line-added">147 #elif USE(DARWIN_REGISTER_MACROS)</span>
<span class="line-added">148     return bitwise_cast&lt;T&gt;(reinterpret_cast&lt;void*&gt;(__darwin_arm_thread_state64_get_sp(regs)));</span>
149 #else
150     return bitwise_cast&lt;T&gt;(stackPointerImpl(const_cast&lt;PlatformRegisters&amp;&gt;(regs)));
151 #endif
152 }
153 
154 template&lt;typename T&gt;
155 inline void setStackPointer(PlatformRegisters&amp; regs, T value)
156 {
157 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
158     assertIsNotTagged(bitwise_cast&lt;void*&gt;(value));
159     WTF_WRITE_PLATFORM_REGISTERS_SP_WITH_PROFILE(regs, bitwise_cast&lt;void*&gt;(value));
<span class="line-added">160 #elif USE(DARWIN_REGISTER_MACROS)</span>
<span class="line-added">161     __darwin_arm_thread_state64_set_sp(regs, value);</span>
162 #else
163     stackPointerImpl(regs) = bitwise_cast&lt;void*&gt;(value);
164 #endif
165 }
166 
167 #else // not OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
168 
169 template&lt;typename T&gt;
170 inline T stackPointer(const PlatformRegisters&amp; regs)
171 {
172     return bitwise_cast&lt;T&gt;(regs.stackPointer);
173 }
174 #endif // OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
175 
176 #if HAVE(MACHINE_CONTEXT)
177 
<span class="line-modified">178 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE) &amp;&amp; !USE(DARWIN_REGISTER_MACROS)</span>
179 static inline void*&amp; stackPointerImpl(mcontext_t&amp; machineContext)
180 {
181 #if OS(DARWIN)
182     return stackPointerImpl(machineContext-&gt;__ss);
183 #elif OS(FREEBSD)
184 
185 #if CPU(X86)
186     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_esp);
187 #elif CPU(X86_64)
188     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_rsp);
189 #elif CPU(ARM)
190     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.__gregs[_REG_SP]);
191 #elif CPU(ARM64)
192     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_gpregs.gp_sp);
193 #elif CPU(MIPS)
194     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_regs[29]);
195 #else
196 #error Unknown Architecture
197 #endif
198 
</pre>
<hr />
<pre>
205 #elif CPU(ARM)
206     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.arm_sp);
207 #elif CPU(ARM64)
208     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.sp);
209 #elif CPU(MIPS)
210     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[29]);
211 #else
212 #error Unknown Architecture
213 #endif
214 #endif
215 }
216 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
217 
218 template&lt;typename T&gt;
219 inline T stackPointer(const mcontext_t&amp; machineContext)
220 {
221 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
222     void* value = WTF_READ_MACHINE_CONTEXT_SP_WITH_PROFILE(machineContext);
223     assertIsNotTagged(value);
224     return bitwise_cast&lt;T&gt;(value);
<span class="line-added">225 #elif USE(DARWIN_REGISTER_MACROS)</span>
<span class="line-added">226     return stackPointer(machineContext-&gt;__ss);</span>
227 #else
228     return bitwise_cast&lt;T&gt;(stackPointerImpl(const_cast&lt;mcontext_t&amp;&gt;(machineContext)));
229 #endif
230 }
231 
232 template&lt;typename T&gt;
233 inline void setStackPointer(mcontext_t&amp; machineContext, T value)
234 {
235 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
236     assertIsNotTagged(bitwise_cast&lt;void*&gt;(value));
237     WTF_WRITE_MACHINE_CONTEXT_SP_WITH_PROFILE(machineContext, bitwise_cast&lt;void*&gt;(value));
<span class="line-added">238 #elif USE(DARWIN_REGISTER_MACROS)</span>
<span class="line-added">239     return setStackPointer(machineContext-&gt;__ss, value);</span>
240 #else
241     stackPointerImpl(machineContext) = bitwise_cast&lt;void*&gt;(value);
242 #endif
243 }
244 #endif // HAVE(MACHINE_CONTEXT)
245 
246 
247 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
248 
249 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE)
250 static inline void*&amp; framePointerImpl(PlatformRegisters&amp; regs)
251 {
252 #if OS(DARWIN)
253 
254 #if __DARWIN_UNIX03
255 
256 #if CPU(X86)
257     return reinterpret_cast&lt;void*&amp;&gt;(regs.__ebp);
258 #elif CPU(X86_64)
259     return reinterpret_cast&lt;void*&amp;&gt;(regs.__rbp);
</pre>
<hr />
<pre>
380 #else
381     return bitwise_cast&lt;T&gt;(framePointerImpl(const_cast&lt;mcontext_t&amp;&gt;(machineContext)));
382 #endif
383 }
384 
385 template&lt;typename T&gt;
386 inline void setFramePointer(mcontext_t&amp; machineContext, T value)
387 {
388 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
389     assertIsNotTagged(bitwise_cast&lt;void*&gt;(value));
390     WTF_WRITE_MACHINE_CONTEXT_FP_WITH_PROFILE(machineContext, bitwise_cast&lt;void*&gt;(value));
391 #else
392     framePointerImpl(machineContext) = bitwise_cast&lt;void*&gt;(value);
393 #endif
394 }
395 #endif // HAVE(MACHINE_CONTEXT)
396 
397 
398 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
399 
<span class="line-modified">400 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE) &amp;&amp; !USE(DARWIN_REGISTER_MACROS)</span>
401 static inline void*&amp; instructionPointerImpl(PlatformRegisters&amp; regs)
402 {
403 #if OS(DARWIN)
404 #if __DARWIN_UNIX03
405 
406 #if CPU(X86)
407     return reinterpret_cast&lt;void*&amp;&gt;(regs.__eip);
408 #elif CPU(X86_64)
409     return reinterpret_cast&lt;void*&amp;&gt;(regs.__rip);
<span class="line-modified">410 #elif CPU(ARM_THUMB2) || CPU(ARM)</span>
411     return reinterpret_cast&lt;void*&amp;&gt;(regs.__pc);
412 #else
413 #error Unknown Architecture
414 #endif
415 
416 #else // !__DARWIN_UNIX03
417 #if CPU(X86)
418     return reinterpret_cast&lt;void*&amp;&gt;(regs.eip);
419 #elif CPU(X86_64)
420     return reinterpret_cast&lt;void*&amp;&gt;(regs.rip);
421 #else
422 #error Unknown Architecture
423 #endif
424 
425 #endif // __DARWIN_UNIX03
426 
427 #elif OS(WINDOWS)
428 
429 #if CPU(ARM)
430     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Pc);
431 #elif CPU(MIPS)
432 #error Dont know what to do with mips. Do we even need this?
433 #elif CPU(X86)
434     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Eip);
435 #elif CPU(X86_64)
436     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Rip);
437 #else
438 #error Unknown Architecture
439 #endif
440 
441 #elif HAVE(MACHINE_CONTEXT)
442     return instructionPointerImpl(regs.machineContext);
443 #endif
444 }
445 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
446 
447 inline Optional&lt;MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;&gt; instructionPointer(const PlatformRegisters&amp; regs)
448 {
449 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
450     void* value = WTF_READ_PLATFORM_REGISTERS_PC_WITH_PROFILE(regs);
<span class="line-added">451 #elif USE(DARWIN_REGISTER_MACROS)</span>
<span class="line-added">452     void* value = __darwin_arm_thread_state64_get_pc_fptr(regs);</span>
453 #else
454     void* value = instructionPointerImpl(const_cast&lt;PlatformRegisters&amp;&gt;(regs));
455 #endif
456     if (!value)
457         return MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;(nullptr);
458     if (!usesPointerTagging())
459         return MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;(value);
460     if (isTaggedWith(value, PlatformRegistersPCPtrTag))
461         return MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;(value);
462     return WTF::nullopt;
463 }
464 
465 inline void setInstructionPointer(PlatformRegisters&amp; regs, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt; value)
466 {
467 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
468     WTF_WRITE_PLATFORM_REGISTERS_PC_WITH_PROFILE(regs, value.executableAddress());
<span class="line-added">469 #elif USE(DARWIN_REGISTER_MACROS)</span>
<span class="line-added">470     __darwin_arm_thread_state64_set_pc_fptr(regs, value.executableAddress());</span>
471 #else
472     instructionPointerImpl(regs) = value.executableAddress();
473 #endif
474 }
475 #endif // OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
476 
477 
478 #if HAVE(MACHINE_CONTEXT)
479 
<span class="line-modified">480 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE) &amp;&amp; !USE(DARWIN_REGISTER_MACROS)</span>
481 static inline void*&amp; instructionPointerImpl(mcontext_t&amp; machineContext)
482 {
483 #if OS(DARWIN)
484     return instructionPointerImpl(machineContext-&gt;__ss);
485 #elif OS(FREEBSD)
486 
487 #if CPU(X86)
488     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_eip);
489 #elif CPU(X86_64)
490     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_rip);
491 #elif CPU(ARM)
492     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.__gregs[_REG_PC]);
493 #elif CPU(ARM64)
494     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_gpregs.gp_elr);
495 #elif CPU(MIPS)
496     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_pc);
497 #else
498 #error Unknown Architecture
499 #endif
500 
</pre>
<hr />
<pre>
506 #elif CPU(X86_64)
507     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[REG_RIP]);
508 #elif CPU(ARM)
509     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.arm_pc);
510 #elif CPU(ARM64)
511     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.pc);
512 #elif CPU(MIPS)
513     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.pc);
514 #else
515 #error Unknown Architecture
516 #endif
517 
518 #else
519 #error Need a way to get the instruction pointer for another thread on this platform
520 #endif
521 }
522 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
523 
524 inline MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt; instructionPointer(const mcontext_t&amp; machineContext)
525 {
<span class="line-added">526 #if USE(DARWIN_REGISTER_MACROS)</span>
<span class="line-added">527     return *instructionPointer(machineContext-&gt;__ss);</span>
<span class="line-added">528 #else</span>
<span class="line-added">529 </span>
530 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
531     void* value = WTF_READ_MACHINE_CONTEXT_PC_WITH_PROFILE(machineContext);
532 #else
533     void* value = instructionPointerImpl(const_cast&lt;mcontext_t&amp;&gt;(machineContext));
534 #endif
<span class="line-added">535 </span>
536     return MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;(value);
<span class="line-added">537 #endif</span>
538 }
539 
540 inline void setInstructionPointer(mcontext_t&amp; machineContext, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt; value)
541 {
542 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
543     WTF_WRITE_MACHINE_CONTEXT_PC_WITH_PROFILE(machineContext, value.executableAddress());
<span class="line-added">544 #elif USE(DARWIN_REGISTER_MACROS)</span>
<span class="line-added">545     setInstructionPointer(machineContext-&gt;__ss, value);</span>
546 #else
547     instructionPointerImpl(machineContext) = value.executableAddress();
548 #endif
549 }
550 #endif // HAVE(MACHINE_CONTEXT)
551 
552 
553 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
554 
555 #if OS(DARWIN) &amp;&amp; __DARWIN_UNIX03 &amp;&amp; CPU(ARM64)







556 
557 inline MacroAssemblerCodePtr&lt;PlatformRegistersLRPtrTag&gt; linkRegister(const PlatformRegisters&amp; regs)
558 {
559 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
560     void* value = WTF_READ_PLATFORM_REGISTERS_LR_WITH_PROFILE(regs);
561 #else
<span class="line-modified">562     void* value = __darwin_arm_thread_state64_get_lr_fptr(regs);</span>
563 #endif
564     return MacroAssemblerCodePtr&lt;PlatformRegistersLRPtrTag&gt;(value);
565 }
566 
567 inline void setLinkRegister(PlatformRegisters&amp; regs, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt; value)
568 {
569 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
570     WTF_WRITE_PLATFORM_REGISTERS_PC_WITH_PROFILE(regs, value.executableAddress());
571 #else
<span class="line-modified">572     __darwin_arm_thread_state64_set_lr_fptr(regs, value.executableAddress());</span>
573 #endif
574 }
575 #endif // OS(DARWIN) &amp;&amp; __DARWIN_UNIX03 &amp;&amp; CPU(ARM64)
576 
577 #if HAVE(MACHINE_CONTEXT)
578 template&lt;&gt; void*&amp; argumentPointer&lt;1&gt;(mcontext_t&amp;);
579 #endif
580 
581 template&lt;&gt;
582 inline void*&amp; argumentPointer&lt;1&gt;(PlatformRegisters&amp; regs)
583 {
584 #if OS(DARWIN)
585 #if __DARWIN_UNIX03
586 
587 #if CPU(X86)
588     return reinterpret_cast&lt;void*&amp;&gt;(regs.__edx);
589 #elif CPU(X86_64)
590     return reinterpret_cast&lt;void*&amp;&gt;(regs.__rsi);
591 #elif CPU(ARM_THUMB2) || CPU(ARM)
592     return reinterpret_cast&lt;void*&amp;&gt;(regs.__r[1]);
</pre>
</td>
</tr>
</table>
<center><a href="Lookup.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MapConstructor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoPage.h b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoPage.h
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoPage.h
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoPage.h
@@ -26,11 +26,13 @@
 #pragma once
 
 #include "Bits.h"
 #include "DeferredTrigger.h"
 #include "FreeList.h"
+#include "Mutex.h"
 #include <climits>
+#include <mutex>
 
 namespace bmalloc {
 
 class IsoHeapImplBase;
 template<typename Config> class IsoDirectoryBase;
@@ -40,21 +42,25 @@
 public:
     static constexpr size_t pageSize = 16384;
 
     explicit IsoPageBase(bool isShared)
         : m_isShared(isShared)
+        , m_eligibilityHasBeenNoted(true)
+        , m_isInUseForAllocation(false)
     {
     }
 
     static IsoPageBase* pageFor(void*);
 
     bool isShared() const { return m_isShared; }
 
 protected:
     BEXPORT static void* allocatePageMemory();
 
-    bool m_isShared { false };
+    bool m_isShared : 1;
+    bool m_eligibilityHasBeenNoted : 1;
+    bool m_isInUseForAllocation : 1;
 };
 
 template<typename Config>
 class IsoPage : public IsoPageBase {
 public:
@@ -69,23 +75,23 @@
 
     static IsoPage* pageFor(void*);
 
     unsigned index() const { return m_index; }
 
-    void free(void*);
+    void free(const LockHolder&, void*);
 
     // Called after this page is already selected for allocation.
-    FreeList startAllocating();
+    FreeList startAllocating(const LockHolder&);
 
     // Called after the allocator picks another page to replace this one.
-    void stopAllocating(FreeList freeList);
+    void stopAllocating(const LockHolder&, FreeList);
 
     IsoDirectoryBase<Config>& directory() { return m_directory; }
     bool isInUseForAllocation() const { return m_isInUseForAllocation; }
 
     template<typename Func>
-    void forEachLiveObject(const Func&);
+    void forEachLiveObject(const LockHolder&, const Func&);
 
     IsoHeapImpl<Config>& heap();
 
 private:
     static constexpr unsigned indexOfFirstObject()
@@ -109,19 +115,16 @@
     // We manage the bitvector ourselves. This bitvector works in a special way to enable very fast
     // freeing.
 
     // This must have a trivial destructor.
 
-    bool m_eligibilityHasBeenNoted { true };
-    bool m_isInUseForAllocation { false };
     DeferredTrigger<IsoPageTrigger::Eligible> m_eligibilityTrigger;
     DeferredTrigger<IsoPageTrigger::Empty> m_emptyTrigger;
-
-    IsoDirectoryBase<Config>& m_directory;
+    uint8_t m_numNonEmptyWords { 0 };
+    static_assert(bitsArrayLength(numObjects) <= UINT8_MAX);
     unsigned m_index { UINT_MAX };
-
+    IsoDirectoryBase<Config>& m_directory;
     unsigned m_allocBits[bitsArrayLength(numObjects)];
-    unsigned m_numNonEmptyWords { 0 };
 };
 
 } // namespace bmalloc
 

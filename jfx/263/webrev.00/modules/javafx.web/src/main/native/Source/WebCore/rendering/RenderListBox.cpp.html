<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderListBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.
  3  *               2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;RenderListBox.h&quot;
 32 
 33 #include &quot;AXObjectCache.h&quot;
 34 #include &quot;CSSFontSelector.h&quot;
 35 #include &quot;DeprecatedGlobalSettings.h&quot;
 36 #include &quot;Document.h&quot;
 37 #include &quot;EventHandler.h&quot;
 38 #include &quot;FocusController.h&quot;
 39 #include &quot;Frame.h&quot;
 40 #include &quot;FrameSelection.h&quot;
 41 #include &quot;FrameView.h&quot;
 42 #include &quot;GraphicsContext.h&quot;
 43 #include &quot;HTMLNames.h&quot;
 44 #include &quot;HTMLOptionElement.h&quot;
 45 #include &quot;HTMLOptGroupElement.h&quot;
 46 #include &quot;HTMLSelectElement.h&quot;
 47 #include &quot;HitTestResult.h&quot;
 48 #include &quot;NodeRenderStyle.h&quot;
 49 #include &quot;Page.h&quot;
 50 #include &quot;PaintInfo.h&quot;
 51 #include &quot;RenderLayer.h&quot;
 52 #include &quot;RenderLayoutState.h&quot;
 53 #include &quot;RenderScrollbar.h&quot;
 54 #include &quot;RenderText.h&quot;
 55 #include &quot;RenderTheme.h&quot;
 56 #include &quot;RenderView.h&quot;
 57 #include &quot;ScrollAnimator.h&quot;
 58 #include &quot;Scrollbar.h&quot;
 59 #include &quot;ScrollbarTheme.h&quot;
 60 #include &quot;Settings.h&quot;
 61 #include &quot;SpatialNavigation.h&quot;
 62 #include &quot;StyleResolver.h&quot;
 63 #include &quot;StyleTreeResolver.h&quot;
 64 #include &quot;WheelEventTestMonitor.h&quot;
 65 #include &lt;math.h&gt;
 66 #include &lt;wtf/IsoMallocInlines.h&gt;
 67 #include &lt;wtf/StackStats.h&gt;
 68 
 69 namespace WebCore {
 70 
 71 using namespace HTMLNames;
 72 
 73 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderListBox);
 74 
 75 const int rowSpacing = 1;
 76 
 77 const int optionsSpacingHorizontal = 2;
 78 
 79 // The minSize constant was originally defined to render scrollbars correctly.
 80 // This might vary for different platforms.
 81 const int minSize = 4;
 82 
 83 // Default size when the multiple attribute is present but size attribute is absent.
 84 const int defaultSize = 4;
 85 
 86 // FIXME: This hardcoded baselineAdjustment is what we used to do for the old
 87 // widget, but I&#39;m not sure this is right for the new control.
 88 const int baselineAdjustment = 7;
 89 
 90 RenderListBox::RenderListBox(HTMLSelectElement&amp; element, RenderStyle&amp;&amp; style)
 91     : RenderBlockFlow(element, WTFMove(style))
 92     , m_optionsChanged(true)
 93     , m_scrollToRevealSelectionAfterLayout(false)
 94     , m_inAutoscroll(false)
 95     , m_optionsWidth(0)
 96     , m_indexOffset(0)
 97 {
 98     view().frameView().addScrollableArea(this);
 99 }
100 
101 RenderListBox::~RenderListBox()
102 {
103     // Do not add any code here. Add it to willBeDestroyed() instead.
104 }
105 
106 void RenderListBox::willBeDestroyed()
107 {
108     setHasVerticalScrollbar(false);
109     view().frameView().removeScrollableArea(this);
110     RenderBlockFlow::willBeDestroyed();
111 }
112 
113 HTMLSelectElement&amp; RenderListBox::selectElement() const
114 {
115     return downcast&lt;HTMLSelectElement&gt;(nodeForNonAnonymous());
116 }
117 
118 static FontCascade bolder(Document&amp; document, const FontCascade&amp; font)
119 {
120     auto description = font.fontDescription();
121     description.setWeight(description.bolderWeight());
122     auto result = FontCascade { WTFMove(description), font.letterSpacing(), font.wordSpacing() };
123     result.update(&amp;document.fontSelector());
124     return result;
125 }
126 
127 void RenderListBox::updateFromElement()
128 {
129     if (m_optionsChanged) {
130         float width = 0;
131         auto&amp; normalFont = style().fontCascade();
132         Optional&lt;FontCascade&gt; boldFont;
133         for (auto* element : selectElement().listItems()) {
134             String text;
135             WTF::Function&lt;const FontCascade&amp;()&gt; selectFont = [&amp;normalFont] () -&gt; const FontCascade&amp; {
136                 return normalFont;
137             };
138             if (is&lt;HTMLOptionElement&gt;(*element))
139                 text = downcast&lt;HTMLOptionElement&gt;(*element).textIndentedToRespectGroupLabel();
140             else if (is&lt;HTMLOptGroupElement&gt;(*element)) {
141                 text = downcast&lt;HTMLOptGroupElement&gt;(*element).groupLabelText();
142                 selectFont = [this, &amp;normalFont, &amp;boldFont] () -&gt; const FontCascade&amp; {
143                     if (!boldFont)
144                         boldFont = bolder(document(), normalFont);
145                     return boldFont.value();
146                 };
147             }
148             if (text.isEmpty())
149                 continue;
150             text = applyTextTransform(style(), text, &#39; &#39;);
151             auto textRun = constructTextRun(text, style(), AllowTrailingExpansion);
152             width = std::max(width, selectFont().width(textRun));
153         }
154         // FIXME: Is ceiling right here, or should we be doing some kind of rounding instead?
155         m_optionsWidth = static_cast&lt;int&gt;(std::ceil(width));
156         m_optionsChanged = false;
157 
158         setHasVerticalScrollbar(true);
159 
160         computeFirstIndexesVisibleInPaddingTopBottomAreas();
161 
162         setNeedsLayoutAndPrefWidthsRecalc();
163     }
164 }
165 
166 void RenderListBox::selectionChanged()
167 {
168     repaint();
169     if (!m_inAutoscroll) {
170         if (m_optionsChanged || needsLayout())
171             m_scrollToRevealSelectionAfterLayout = true;
172         else
173             scrollToRevealSelection();
174     }
175 
176     if (AXObjectCache* cache = document().existingAXObjectCache())
177         cache-&gt;deferSelectedChildrenChangedIfNeeded(selectElement());
178 }
179 
180 void RenderListBox::layout()
181 {
182     StackStats::LayoutCheckPoint layoutCheckPoint;
183     RenderBlockFlow::layout();
184 
185     if (m_vBar) {
186         bool enabled = numVisibleItems() &lt; numItems();
187         m_vBar-&gt;setEnabled(enabled);
188         m_vBar-&gt;setSteps(1, std::max(1, numVisibleItems() - 1), itemHeight());
189         m_vBar-&gt;setProportion(numVisibleItems(), numItems());
190         if (!enabled) {
191             scrollToOffsetWithoutAnimation(VerticalScrollbar, 0);
192             m_indexOffset = 0;
193         }
194     }
195 
196     if (m_scrollToRevealSelectionAfterLayout) {
197         LayoutStateDisabler layoutStateDisabler(view().frameView().layoutContext());
198         scrollToRevealSelection();
199     }
200 }
201 
202 void RenderListBox::scrollToRevealSelection()
203 {
204     m_scrollToRevealSelectionAfterLayout = false;
205 
206     int firstIndex = selectElement().activeSelectionStartListIndex();
207     if (firstIndex &gt;= 0 &amp;&amp; !listIndexIsVisible(selectElement().activeSelectionEndListIndex()))
208         scrollToRevealElementAtListIndex(firstIndex);
209 }
210 
211 void RenderListBox::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
212 {
213     maxLogicalWidth = m_optionsWidth + 2 * optionsSpacingHorizontal;
214     if (m_vBar)
215         maxLogicalWidth += m_vBar-&gt;width();
216     if (!style().width().isPercentOrCalculated())
217         minLogicalWidth = maxLogicalWidth;
218 }
219 
220 void RenderListBox::computePreferredLogicalWidths()
221 {
222     // Nested style recal do not fire post recal callbacks. see webkit.org/b/153767
223     ASSERT(!m_optionsChanged || Style::postResolutionCallbacksAreSuspended());
224 
225     m_minPreferredLogicalWidth = 0;
226     m_maxPreferredLogicalWidth = 0;
227 
228     if (style().width().isFixed() &amp;&amp; style().width().value() &gt; 0)
229         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = adjustContentBoxLogicalWidthForBoxSizing(style().width().value());
230     else
231         computeIntrinsicLogicalWidths(m_minPreferredLogicalWidth, m_maxPreferredLogicalWidth);
232 
233     if (style().minWidth().isFixed() &amp;&amp; style().minWidth().value() &gt; 0) {
234         m_maxPreferredLogicalWidth = std::max(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(style().minWidth().value()));
235         m_minPreferredLogicalWidth = std::max(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(style().minWidth().value()));
236     }
237 
238     if (style().maxWidth().isFixed()) {
239         m_maxPreferredLogicalWidth = std::min(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(style().maxWidth().value()));
240         m_minPreferredLogicalWidth = std::min(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(style().maxWidth().value()));
241     }
242 
243     LayoutUnit toAdd = horizontalBorderAndPaddingExtent();
244     m_minPreferredLogicalWidth += toAdd;
245     m_maxPreferredLogicalWidth += toAdd;
246 
247     setPreferredLogicalWidthsDirty(false);
248 }
249 
250 int RenderListBox::size() const
251 {
252     int specifiedSize = selectElement().size();
253     if (specifiedSize &gt; 1)
254         return std::max(minSize, specifiedSize);
255 
256     return defaultSize;
257 }
258 
259 int RenderListBox::numVisibleItems(ConsiderPadding considerPadding) const
260 {
261     // Only count fully visible rows. But don&#39;t return 0 even if only part of a row shows.
262     int visibleItemsExcludingPadding = std::max&lt;int&gt;(1, (contentHeight() + rowSpacing) / itemHeight());
263     if (considerPadding == ConsiderPadding::No)
264         return visibleItemsExcludingPadding;
265 
266     return numberOfVisibleItemsInPaddingTop() + visibleItemsExcludingPadding + numberOfVisibleItemsInPaddingBottom();
267 }
268 
269 int RenderListBox::numItems() const
270 {
271     return selectElement().listItems().size();
272 }
273 
274 LayoutUnit RenderListBox::listHeight() const
275 {
276     return itemHeight() * numItems() - rowSpacing;
277 }
278 
279 RenderBox::LogicalExtentComputedValues RenderListBox::computeLogicalHeight(LayoutUnit, LayoutUnit logicalTop) const
280 {
281     LayoutUnit height = itemHeight() * size() - rowSpacing;
282     cacheIntrinsicContentLogicalHeightForFlexItem(height);
283     height += verticalBorderAndPaddingExtent();
284     return RenderBox::computeLogicalHeight(height, logicalTop);
285 }
286 
287 int RenderListBox::baselinePosition(FontBaseline baselineType, bool firstLine, LineDirectionMode lineDirection, LinePositionMode linePositionMode) const
288 {
289     return RenderBox::baselinePosition(baselineType, firstLine, lineDirection, linePositionMode) - baselineAdjustment;
290 }
291 
292 LayoutRect RenderListBox::itemBoundingBoxRect(const LayoutPoint&amp; additionalOffset, int index)
293 {
294     LayoutUnit x = additionalOffset.x() + borderLeft() + paddingLeft();
295     if (shouldPlaceBlockDirectionScrollbarOnLeft() &amp;&amp; m_vBar)
296         x += m_vBar-&gt;occupiedWidth();
297     LayoutUnit y = additionalOffset.y() + borderTop() + paddingTop() + itemHeight() * (index - m_indexOffset);
298     return LayoutRect(x, y, contentWidth(), itemHeight());
299 }
300 
301 void RenderListBox::paintItem(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, const PaintFunction&amp; paintFunction)
302 {
303     int listItemsSize = numItems();
304     int firstVisibleItem = m_indexOfFirstVisibleItemInsidePaddingTopArea.valueOr(m_indexOffset);
305     int endIndex = firstVisibleItem + numVisibleItems(ConsiderPadding::Yes);
306     for (int i = firstVisibleItem; i &lt; listItemsSize &amp;&amp; i &lt; endIndex; ++i)
307         paintFunction(paintInfo, paintOffset, i);
308 }
309 
310 void RenderListBox::paintObject(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
311 {
312     if (style().visibility() != Visibility::Visible)
313         return;
314 
315     if (paintInfo.phase == PaintPhase::Foreground) {
316         paintItem(paintInfo, paintOffset, [this](PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, int listItemIndex) {
317             paintItemForeground(paintInfo, paintOffset, listItemIndex);
318         });
319     }
320 
321     // Paint the children.
322     RenderBlockFlow::paintObject(paintInfo, paintOffset);
323 
324     switch (paintInfo.phase) {
325     // Depending on whether we have overlay scrollbars they
326     // get rendered in the foreground or background phases
327     case PaintPhase::Foreground:
328         if (m_vBar-&gt;isOverlayScrollbar())
329             paintScrollbar(paintInfo, paintOffset);
330         break;
331     case PaintPhase::BlockBackground:
332         if (!m_vBar-&gt;isOverlayScrollbar())
333             paintScrollbar(paintInfo, paintOffset);
334         break;
335     case PaintPhase::ChildBlockBackground:
336     case PaintPhase::ChildBlockBackgrounds: {
337         paintItem(paintInfo, paintOffset, [this](PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, int listItemIndex) {
338             paintItemBackground(paintInfo, paintOffset, listItemIndex);
339         });
340         break;
341     }
342     default:
343         break;
344     }
345 }
346 
347 void RenderListBox::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject* paintContainer)
348 {
349     if (!selectElement().allowsNonContiguousSelection())
350         return RenderBlockFlow::addFocusRingRects(rects, additionalOffset, paintContainer);
351 
352     // Focus the last selected item.
353     int selectedItem = selectElement().activeSelectionEndListIndex();
354     if (selectedItem &gt;= 0) {
355         rects.append(snappedIntRect(itemBoundingBoxRect(additionalOffset, selectedItem)));
356         return;
357     }
358 
359     // No selected items, find the first non-disabled item.
360     int size = numItems();
361     const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement().listItems();
362     for (int i = 0; i &lt; size; ++i) {
363         HTMLElement* element = listItems[i];
364         if (is&lt;HTMLOptionElement&gt;(*element) &amp;&amp; !element-&gt;isDisabledFormControl()) {
365             selectElement().setActiveSelectionEndIndex(i);
366             rects.append(itemBoundingBoxRect(additionalOffset, i));
367             return;
368         }
369     }
370 }
371 
372 void RenderListBox::paintScrollbar(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
373 {
374     if (!m_vBar)
375         return;
376 
377     LayoutUnit left = paintOffset.x() + (shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - m_vBar-&gt;width());
378     LayoutUnit top = paintOffset.y() + borderTop();
379     LayoutUnit width = m_vBar-&gt;width();
380     LayoutUnit height = this-&gt;height() - (borderTop() + borderBottom());
381     IntRect scrollRect = snappedIntRect(left, top, width, height);
382     m_vBar-&gt;setFrameRect(scrollRect);
383     m_vBar-&gt;paint(paintInfo.context(), snappedIntRect(paintInfo.rect));
384 }
385 
386 static LayoutSize itemOffsetForAlignment(TextRun textRun, const RenderStyle* itemStyle, FontCascade itemFont, LayoutRect itemBoudingBox)
387 {
388     TextAlignMode actualAlignment = itemStyle-&gt;textAlign();
389     // FIXME: Firefox doesn&#39;t respect TextAlignMode::Justify. Should we?
390     // FIXME: Handle TextAlignMode::End here
391     if (actualAlignment == TextAlignMode::Start || actualAlignment == TextAlignMode::Justify)
392         actualAlignment = itemStyle-&gt;isLeftToRightDirection() ? TextAlignMode::Left : TextAlignMode::Right;
393 
394     LayoutSize offset = LayoutSize(0, itemFont.fontMetrics().ascent());
395     if (actualAlignment == TextAlignMode::Right || actualAlignment == TextAlignMode::WebKitRight) {
396         float textWidth = itemFont.width(textRun);
397         offset.setWidth(itemBoudingBox.width() - textWidth - optionsSpacingHorizontal);
398     } else if (actualAlignment == TextAlignMode::Center || actualAlignment == TextAlignMode::WebKitCenter) {
399         float textWidth = itemFont.width(textRun);
400         offset.setWidth((itemBoudingBox.width() - textWidth) / 2);
401     } else
402         offset.setWidth(optionsSpacingHorizontal);
403     return offset;
404 }
405 
406 void RenderListBox::paintItemForeground(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, int listIndex)
407 {
408     const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement().listItems();
409     HTMLElement* listItemElement = listItems[listIndex];
410 
411     auto&amp; itemStyle = *listItemElement-&gt;computedStyle();
412 
413     if (itemStyle.visibility() == Visibility::Hidden)
414         return;
415 
416     String itemText;
417     bool isOptionElement = is&lt;HTMLOptionElement&gt;(*listItemElement);
418     if (isOptionElement)
419         itemText = downcast&lt;HTMLOptionElement&gt;(*listItemElement).textIndentedToRespectGroupLabel();
420     else if (is&lt;HTMLOptGroupElement&gt;(*listItemElement))
421         itemText = downcast&lt;HTMLOptGroupElement&gt;(*listItemElement).groupLabelText();
422     itemText = applyTextTransform(style(), itemText, &#39; &#39;);
423 
424     if (itemText.isNull())
425         return;
426 
427     Color textColor = itemStyle.visitedDependentColorWithColorFilter(CSSPropertyColor);
428     if (isOptionElement &amp;&amp; downcast&lt;HTMLOptionElement&gt;(*listItemElement).selected()) {
429         if (frame().selection().isFocusedAndActive() &amp;&amp; document().focusedElement() == &amp;selectElement())
430             textColor = theme().activeListBoxSelectionForegroundColor(styleColorOptions());
431         // Honor the foreground color for disabled items
432         else if (!listItemElement-&gt;isDisabledFormControl() &amp;&amp; !selectElement().isDisabledFormControl())
433             textColor = theme().inactiveListBoxSelectionForegroundColor(styleColorOptions());
434     }
435 
436     paintInfo.context().setFillColor(textColor);
437 
438     TextRun textRun(itemText, 0, 0, AllowTrailingExpansion, itemStyle.direction(), isOverride(itemStyle.unicodeBidi()), true);
439     FontCascade itemFont = style().fontCascade();
440     LayoutRect r = itemBoundingBoxRect(paintOffset, listIndex);
441     r.move(itemOffsetForAlignment(textRun, &amp;itemStyle, itemFont, r));
442 
443     if (is&lt;HTMLOptGroupElement&gt;(*listItemElement)) {
444         auto description = itemFont.fontDescription();
445         description.setWeight(description.bolderWeight());
446         itemFont = FontCascade(WTFMove(description), itemFont.letterSpacing(), itemFont.wordSpacing());
447         itemFont.update(&amp;document().fontSelector());
448     }
449 
450     // Draw the item text
451     paintInfo.context().drawBidiText(itemFont, textRun, roundedIntPoint(r.location()));
452 }
453 
454 void RenderListBox::paintItemBackground(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, int listIndex)
455 {
456     const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement().listItems();
457     HTMLElement* listItemElement = listItems[listIndex];
458     auto&amp; itemStyle = *listItemElement-&gt;computedStyle();
459 
460     Color backColor;
461     if (is&lt;HTMLOptionElement&gt;(*listItemElement) &amp;&amp; downcast&lt;HTMLOptionElement&gt;(*listItemElement).selected()) {
462         if (frame().selection().isFocusedAndActive() &amp;&amp; document().focusedElement() == &amp;selectElement())
463             backColor = theme().activeListBoxSelectionBackgroundColor(styleColorOptions());
464         else
465             backColor = theme().inactiveListBoxSelectionBackgroundColor(styleColorOptions());
466     } else
467         backColor = itemStyle.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
468 
469     // Draw the background for this list box item
470     if (itemStyle.visibility() == Visibility::Hidden)
471         return;
472 
473     LayoutRect itemRect = itemBoundingBoxRect(paintOffset, listIndex);
474     itemRect.intersect(controlClipRect(paintOffset));
475     paintInfo.context().fillRect(snappedIntRect(itemRect), backColor);
476 }
477 
478 bool RenderListBox::isPointInOverflowControl(HitTestResult&amp; result, const LayoutPoint&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset)
479 {
480     if (!m_vBar || !m_vBar-&gt;shouldParticipateInHitTesting())
481         return false;
482 
483     LayoutUnit x = accumulatedOffset.x() + (shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - m_vBar-&gt;width());
484     LayoutUnit y = accumulatedOffset.y() + borderTop();
485     LayoutUnit width = m_vBar-&gt;width();
486     LayoutUnit height = this-&gt;height() - borderTop() - borderBottom();
487     LayoutRect vertRect(x, y, width, height);
488 
489     if (!vertRect.contains(locationInContainer))
490         return false;
491 
492     result.setScrollbar(m_vBar.get());
493     return true;
494 }
495 
496 int RenderListBox::listIndexAtOffset(const LayoutSize&amp; offset)
497 {
498     if (!numItems())
499         return -1;
500 
501     if (offset.height() &lt; borderTop() || offset.height() &gt; height() - borderBottom())
502         return -1;
503 
504     int scrollbarWidth = m_vBar ? m_vBar-&gt;width() : 0;
505     if (shouldPlaceBlockDirectionScrollbarOnLeft() &amp;&amp; (offset.width() &lt; borderLeft() + paddingLeft() + scrollbarWidth || offset.width() &gt; width() - borderRight() - paddingRight()))
506         return -1;
507     if (!shouldPlaceBlockDirectionScrollbarOnLeft() &amp;&amp; (offset.width() &lt; borderLeft() + paddingLeft() || offset.width() &gt; width() - borderRight() - paddingRight() - scrollbarWidth))
508         return -1;
509 
510     int newOffset = (offset.height() - borderTop() - paddingTop()) / itemHeight() + m_indexOffset;
511     return newOffset &lt; numItems() ? newOffset : -1;
512 }
513 
514 void RenderListBox::panScroll(const IntPoint&amp; panStartMousePosition)
515 {
516     const int maxSpeed = 20;
517     const int iconRadius = 7;
518     const int speedReducer = 4;
519 
520     // FIXME: This doesn&#39;t work correctly with transforms.
521     FloatPoint absOffset = localToAbsolute();
522 
523     IntPoint lastKnownMousePosition = frame().eventHandler().lastKnownMousePosition();
524     // We need to check if the last known mouse position is out of the window. When the mouse is out of the window, the position is incoherent
525     static IntPoint previousMousePosition;
526     if (lastKnownMousePosition.y() &lt; 0)
527         lastKnownMousePosition = previousMousePosition;
528     else
529         previousMousePosition = lastKnownMousePosition;
530 
531     int yDelta = lastKnownMousePosition.y() - panStartMousePosition.y();
532 
533     // If the point is too far from the center we limit the speed
534     yDelta = std::max&lt;int&gt;(std::min&lt;int&gt;(yDelta, maxSpeed), -maxSpeed);
535 
536     if (abs(yDelta) &lt; iconRadius) // at the center we let the space for the icon
537         return;
538 
539     if (yDelta &gt; 0)
540         //offsetY = view()-&gt;viewHeight();
541         absOffset.move(0, listHeight());
542     else if (yDelta &lt; 0)
543         yDelta--;
544 
545     // Let&#39;s attenuate the speed
546     yDelta /= speedReducer;
547 
548     IntPoint scrollPoint(0, 0);
549     scrollPoint.setY(absOffset.y() + yDelta);
550     int newOffset = scrollToward(scrollPoint);
551     if (newOffset &lt; 0)
552         return;
553 
554     m_inAutoscroll = true;
555     selectElement().updateListBoxSelection(!selectElement().multiple());
556     m_inAutoscroll = false;
557 }
558 
559 int RenderListBox::scrollToward(const IntPoint&amp; destination)
560 {
561     // FIXME: This doesn&#39;t work correctly with transforms.
562     FloatPoint absPos = localToAbsolute();
563     IntSize positionOffset = roundedIntSize(destination - absPos);
564 
565     int rows = numVisibleItems();
566     int offset = m_indexOffset;
567 
568     if (positionOffset.height() &lt; borderTop() + paddingTop() &amp;&amp; scrollToRevealElementAtListIndex(offset - 1))
569         return offset - 1;
570 
571     if (positionOffset.height() &gt; height() - paddingBottom() - borderBottom() &amp;&amp; scrollToRevealElementAtListIndex(offset + rows))
572         return offset + rows - 1;
573 
574     return listIndexAtOffset(positionOffset);
575 }
576 
577 void RenderListBox::autoscroll(const IntPoint&amp;)
578 {
579     IntPoint pos = frame().view()-&gt;windowToContents(frame().eventHandler().lastKnownMousePosition());
580 
581     int endIndex = scrollToward(pos);
582     if (selectElement().isDisabledFormControl())
583         return;
584 
585     if (endIndex &gt;= 0) {
586         m_inAutoscroll = true;
587 
588         if (!selectElement().multiple())
589             selectElement().setActiveSelectionAnchorIndex(endIndex);
590 
591         selectElement().setActiveSelectionEndIndex(endIndex);
592         selectElement().updateListBoxSelection(!selectElement().multiple());
593         m_inAutoscroll = false;
594     }
595 }
596 
597 void RenderListBox::stopAutoscroll()
598 {
599     if (selectElement().isDisabledFormControl())
600         return;
601 
602     selectElement().listBoxOnChange();
603 }
604 
605 bool RenderListBox::scrollToRevealElementAtListIndex(int index)
606 {
607     if (index &lt; 0 || index &gt;= numItems() || listIndexIsVisible(index))
608         return false;
609 
610     int newOffset;
611     if (index &lt; m_indexOffset)
612         newOffset = index;
613     else
614         newOffset = index - numVisibleItems() + 1;
615 
616     scrollToOffsetWithoutAnimation(VerticalScrollbar, newOffset);
617 
618     return true;
619 }
620 
621 bool RenderListBox::listIndexIsVisible(int index)
622 {
623     int firstIndex = m_indexOfFirstVisibleItemInsidePaddingTopArea.valueOr(m_indexOffset);
624     int endIndex = m_indexOfFirstVisibleItemInsidePaddingBottomArea
625         ? m_indexOfFirstVisibleItemInsidePaddingBottomArea.value() + numberOfVisibleItemsInPaddingBottom()
626         : m_indexOffset + numVisibleItems();
627 
628     return index &gt;= firstIndex &amp;&amp; index &lt; endIndex;
629 }
630 
631 bool RenderListBox::scroll(ScrollDirection direction, ScrollGranularity granularity, float multiplier, Element**, RenderBox*, const IntPoint&amp;)
632 {
633     return ScrollableArea::scroll(direction, granularity, multiplier);
634 }
635 
636 bool RenderListBox::logicalScroll(ScrollLogicalDirection direction, ScrollGranularity granularity, float multiplier, Element**)
637 {
638     return ScrollableArea::scroll(logicalToPhysical(direction, style().isHorizontalWritingMode(), style().isFlippedBlocksWritingMode()), granularity, multiplier);
639 }
640 
641 void RenderListBox::valueChanged(unsigned listIndex)
642 {
643     selectElement().setSelectedIndex(selectElement().listToOptionIndex(listIndex));
644     selectElement().dispatchFormControlChangeEvent();
645 }
646 
647 ScrollPosition RenderListBox::scrollPosition() const
648 {
649     return { 0, m_indexOffset };
650 }
651 
652 ScrollPosition RenderListBox::minimumScrollPosition() const
653 {
654     return { 0, 0 };
655 }
656 
657 ScrollPosition RenderListBox::maximumScrollPosition() const
658 {
659     return { 0, numItems() - numVisibleItems() };
660 }
661 
662 void RenderListBox::setScrollOffset(const ScrollOffset&amp; offset)
663 {
664     scrollTo(offset.y());
665 }
666 
667 int RenderListBox::maximumNumberOfItemsThatFitInPaddingBottomArea() const
668 {
669     return paddingBottom() / itemHeight();
670 }
671 
672 int RenderListBox::numberOfVisibleItemsInPaddingTop() const
673 {
674     if (!m_indexOfFirstVisibleItemInsidePaddingTopArea)
675         return 0;
676 
677     return m_indexOffset - m_indexOfFirstVisibleItemInsidePaddingTopArea.value();
678 }
679 
680 int RenderListBox::numberOfVisibleItemsInPaddingBottom() const
681 {
682     if (!m_indexOfFirstVisibleItemInsidePaddingBottomArea)
683         return 0;
684 
685     return std::min(maximumNumberOfItemsThatFitInPaddingBottomArea(), numItems() - m_indexOffset - numVisibleItems());
686 }
687 
688 void RenderListBox::computeFirstIndexesVisibleInPaddingTopBottomAreas()
689 {
690     m_indexOfFirstVisibleItemInsidePaddingTopArea = WTF::nullopt;
691     m_indexOfFirstVisibleItemInsidePaddingBottomArea = WTF::nullopt;
692 
693     int maximumNumberOfItemsThatFitInPaddingTopArea = paddingTop() / itemHeight();
694     if (maximumNumberOfItemsThatFitInPaddingTopArea) {
695         if (m_indexOffset)
696             m_indexOfFirstVisibleItemInsidePaddingTopArea = std::max(0, m_indexOffset - maximumNumberOfItemsThatFitInPaddingTopArea);
697     }
698 
699     if (maximumNumberOfItemsThatFitInPaddingBottomArea()) {
700         if (numItems() &gt; (m_indexOffset + numVisibleItems()))
701             m_indexOfFirstVisibleItemInsidePaddingBottomArea = m_indexOffset + numVisibleItems();
702     }
703 }
704 
705 void RenderListBox::scrollTo(int newOffset)
706 {
707     if (newOffset == m_indexOffset)
708         return;
709 
710     m_indexOffset = newOffset;
711 
712     computeFirstIndexesVisibleInPaddingTopBottomAreas();
713 
714     repaint();
715     document().addPendingScrollEventTarget(selectElement());
716 }
717 
718 LayoutUnit RenderListBox::itemHeight() const
719 {
720     return style().fontMetrics().height() + rowSpacing;
721 }
722 
723 int RenderListBox::verticalScrollbarWidth() const
724 {
725     return m_vBar ? m_vBar-&gt;occupiedWidth() : 0;
726 }
727 
728 // FIXME: We ignore padding in the vertical direction as far as these values are concerned, since that&#39;s
729 // how the control currently paints.
730 int RenderListBox::scrollWidth() const
731 {
732     // There is no horizontal scrolling allowed.
733     return roundToInt(clientWidth());
734 }
735 
736 int RenderListBox::scrollHeight() const
737 {
738     return roundToInt(std::max(clientHeight(), listHeight()));
739 }
740 
741 int RenderListBox::scrollLeft() const
742 {
743     return 0;
744 }
745 
746 void RenderListBox::setScrollLeft(int, ScrollType, ScrollClamping)
747 {
748 }
749 
750 int RenderListBox::scrollTop() const
751 {
752     return m_indexOffset * itemHeight();
753 }
754 
755 static void setupWheelEventTestMonitor(RenderListBox&amp; renderer)
756 {
757     if (!renderer.page().isMonitoringWheelEvents())
758         return;
759 
760     renderer.scrollAnimator().setWheelEventTestMonitor(renderer.page().wheelEventTestMonitor());
761 }
762 
763 void RenderListBox::setScrollTop(int newTop, ScrollType, ScrollClamping)
764 {
765     // Determine an index and scroll to it.
766     int index = newTop / itemHeight();
767     if (index &lt; 0 || index &gt;= numItems() || index == m_indexOffset)
768         return;
769 
770     setupWheelEventTestMonitor(*this);
771     scrollToOffsetWithoutAnimation(VerticalScrollbar, index);
772 }
773 
774 bool RenderListBox::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
775 {
776     if (!RenderBlockFlow::nodeAtPoint(request, result, locationInContainer, accumulatedOffset, hitTestAction))
777         return false;
778     const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement().listItems();
779     int size = numItems();
780     LayoutPoint adjustedLocation = accumulatedOffset + location();
781 
782     for (int i = 0; i &lt; size; ++i) {
783         if (!itemBoundingBoxRect(adjustedLocation, i).contains(locationInContainer.point()))
784             continue;
785         if (Element* node = listItems[i]) {
786             result.setInnerNode(node);
787             if (!result.innerNonSharedNode())
788                 result.setInnerNonSharedNode(node);
789             result.setLocalPoint(locationInContainer.point() - toLayoutSize(adjustedLocation));
790             break;
791         }
792     }
793 
794     return true;
795 }
796 
797 LayoutRect RenderListBox::controlClipRect(const LayoutPoint&amp; additionalOffset) const
798 {
799     // Clip against the padding box, to give &lt;option&gt;s and overlay scrollbar some extra space
800     // to get painted.
801     LayoutRect clipRect = paddingBoxRect();
802     clipRect.moveBy(additionalOffset);
803     return clipRect;
804 }
805 
806 bool RenderListBox::isActive() const
807 {
808     return page().focusController().isActive();
809 }
810 
811 void RenderListBox::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
812 {
813     IntRect scrollRect = rect;
814     scrollRect.move(shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - scrollbar.width(), borderTop());
815     repaintRectangle(scrollRect);
816 }
817 
818 IntRect RenderListBox::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntRect&amp; scrollbarRect) const
819 {
820     IntRect rect = scrollbarRect;
821     int scrollbarLeft = shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - scrollbar.width();
822     int scrollbarTop = borderTop();
823     rect.move(scrollbarLeft, scrollbarTop);
824     return view().frameView().convertFromRendererToContainingView(this, rect);
825 }
826 
827 IntRect RenderListBox::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntRect&amp; parentRect) const
828 {
829     IntRect rect = view().frameView().convertFromContainingViewToRenderer(this, parentRect);
830     int scrollbarLeft = shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - scrollbar.width();
831     int scrollbarTop = borderTop();
832     rect.move(-scrollbarLeft, -scrollbarTop);
833     return rect;
834 }
835 
836 IntPoint RenderListBox::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntPoint&amp; scrollbarPoint) const
837 {
838     IntPoint point = scrollbarPoint;
839     int scrollbarLeft = shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - scrollbar.width();
840     int scrollbarTop = borderTop();
841     point.move(scrollbarLeft, scrollbarTop);
842     return view().frameView().convertFromRendererToContainingView(this, point);
843 }
844 
845 IntPoint RenderListBox::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntPoint&amp; parentPoint) const
846 {
847     IntPoint point = view().frameView().convertFromContainingViewToRenderer(this, parentPoint);
848     int scrollbarLeft = shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - scrollbar.width();
849     int scrollbarTop = borderTop();
850     point.move(-scrollbarLeft, -scrollbarTop);
851     return point;
852 }
853 
854 IntSize RenderListBox::contentsSize() const
855 {
856     return IntSize(scrollWidth(), scrollHeight());
857 }
858 
859 IntPoint RenderListBox::lastKnownMousePosition() const
860 {
861     return view().frameView().lastKnownMousePosition();
862 }
863 
864 bool RenderListBox::isHandlingWheelEvent() const
865 {
866     return view().frameView().isHandlingWheelEvent();
867 }
868 
869 bool RenderListBox::shouldSuspendScrollAnimations() const
870 {
871     return view().frameView().shouldSuspendScrollAnimations();
872 }
873 
874 bool RenderListBox::forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const
875 {
876     return settings().forceUpdateScrollbarsOnMainThreadForPerformanceTesting();
877 }
878 
879 ScrollableArea* RenderListBox::enclosingScrollableArea() const
880 {
881     // FIXME: Return a RenderLayer that&#39;s scrollable.
882     return nullptr;
883 }
884 
885 bool RenderListBox::isScrollableOrRubberbandable()
886 {
887     return m_vBar;
888 }
889 
890 bool RenderListBox::hasScrollableOrRubberbandableAncestor()
891 {
892     return enclosingLayer() &amp;&amp; enclosingLayer()-&gt;hasScrollableOrRubberbandableAncestor();
893 }
894 
895 IntRect RenderListBox::scrollableAreaBoundingBox(bool*) const
896 {
897     return absoluteBoundingBoxRect();
898 }
899 
900 bool RenderListBox::usesMockScrollAnimator() const
901 {
902     return DeprecatedGlobalSettings::usesMockScrollAnimator();
903 }
904 
905 void RenderListBox::logMockScrollAnimatorMessage(const String&amp; message) const
906 {
907     document().addConsoleMessage(MessageSource::Other, MessageLevel::Debug, &quot;RenderListBox: &quot; + message);
908 }
909 
910 Ref&lt;Scrollbar&gt; RenderListBox::createScrollbar()
911 {
912     RefPtr&lt;Scrollbar&gt; widget;
913     bool hasCustomScrollbarStyle = style().hasPseudoStyle(PseudoId::Scrollbar);
914     if (hasCustomScrollbarStyle)
915         widget = RenderScrollbar::createCustomScrollbar(*this, VerticalScrollbar, &amp;selectElement());
916     else {
917         widget = Scrollbar::createNativeScrollbar(*this, VerticalScrollbar, theme().scrollbarControlSizeForPart(ListboxPart));
918         didAddScrollbar(widget.get(), VerticalScrollbar);
919         if (page().isMonitoringWheelEvents())
920             scrollAnimator().setWheelEventTestMonitor(page().wheelEventTestMonitor());
921     }
922     view().frameView().addChild(*widget);
923     return widget.releaseNonNull();
924 }
925 
926 void RenderListBox::destroyScrollbar()
927 {
928     if (!m_vBar)
929         return;
930 
931     if (!m_vBar-&gt;isCustomScrollbar())
932         ScrollableArea::willRemoveScrollbar(m_vBar.get(), VerticalScrollbar);
933     m_vBar-&gt;removeFromParent();
934     m_vBar = nullptr;
935 }
936 
937 void RenderListBox::setHasVerticalScrollbar(bool hasScrollbar)
938 {
939     if (hasScrollbar == (m_vBar != nullptr))
940         return;
941 
942     if (hasScrollbar)
943         m_vBar = createScrollbar();
944     else
945         destroyScrollbar();
946 
947     if (m_vBar)
948         m_vBar-&gt;styleChanged();
949 }
950 
951 bool RenderListBox::scrolledToTop() const
952 {
953     if (Scrollbar* vbar = verticalScrollbar())
954     return vbar-&gt;value() &lt;= 0;
955 
956     return true;
957 }
958 
959 bool RenderListBox::scrolledToBottom() const
960 {
961     Scrollbar* vbar = verticalScrollbar();
962     if (!vbar)
963         return true;
964 
965     return vbar-&gt;value() &gt;= vbar-&gt;maximum();
966 }
967 
968 bool RenderListBox::scrolledToLeft() const
969 {
970     // We do not scroll horizontally in a select element, so always report
971     // that we are at the full extent of the scroll.
972     return true;
973 }
974 
975 bool RenderListBox::scrolledToRight() const
976 {
977     // We do not scroll horizontally in a select element, so always report
978     // that we are at the full extent of the scroll.
979     return true;
980 }
981 
982 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/Scripts/wkbuiltins/builtins_model.py</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 #!/usr/bin/env python
  2 #
  3 # Copyright (c) 2015-2016 Apple Inc. All rights reserved.
  4 #
  5 # Redistribution and use in source and binary forms, with or without
  6 # modification, are permitted provided that the following conditions
  7 # are met:
  8 # 1. Redistributions of source code must retain the above copyright
  9 #    notice, this list of conditions and the following disclaimer.
 10 # 2. Redistributions in binary form must reproduce the above copyright
 11 #    notice, this list of conditions and the following disclaimer in the
 12 #    documentation and/or other materials provided with the distribution.
 13 #
 14 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 15 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 16 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 18 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 19 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 20 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 21 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 22 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 23 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 24 # THE POSSIBILITY OF SUCH DAMAGE.
 25 
 26 import logging
 27 import re
 28 import os
 29 
 30 from builtins_templates import BuiltinsGeneratorTemplates as Templates
 31 
 32 log = logging.getLogger(&#39;global&#39;)
 33 
 34 _FRAMEWORK_CONFIG_MAP = {
 35     &quot;JavaScriptCore&quot;: {
 36         &quot;macro_prefix&quot;: &quot;JSC&quot;,
 37         &quot;namespace&quot;: &quot;JSC&quot;,
 38     },
 39     &quot;WebCore&quot;: {
 40         &quot;macro_prefix&quot;: &quot;WEBCORE&quot;,
 41         &quot;namespace&quot;: &quot;WebCore&quot;,
 42     },
 43 }
 44 
 45 functionHeadRegExp = re.compile(r&quot;(?:@[\w|=\[\] \&quot;\.]+\s*\n)*(?:async\s+)?function\s+\w+\s*\(.*?\)&quot;, re.MULTILINE | re.DOTALL)
 46 functionGlobalPrivateRegExp = re.compile(r&quot;.*^@globalPrivate&quot;, re.MULTILINE | re.DOTALL)
<a name="1" id="anc1"></a><span class="line-added"> 47 functionNakedConstructorRegExp = re.compile(r&quot;.*^@nakedConstructor&quot;, re.MULTILINE | re.DOTALL)</span>
 48 functionIntrinsicRegExp = re.compile(r&quot;.*^@intrinsic=(\w+)&quot;, re.MULTILINE | re.DOTALL)
 49 functionIsConstructorRegExp = re.compile(r&quot;.*^@constructor&quot;, re.MULTILINE | re.DOTALL)
 50 functionIsGetterRegExp = re.compile(r&quot;.*^@getter&quot;, re.MULTILINE | re.DOTALL)
 51 functionIsAsyncRegExp = re.compile(r&quot;(async)?\s*function&quot;, re.MULTILINE | re.DOTALL)
 52 functionNameRegExp = re.compile(r&quot;function\s+(\w+)\s*\(&quot;, re.MULTILINE | re.DOTALL)
 53 functionOverriddenNameRegExp = re.compile(r&quot;.*^@overriddenName=(\&quot;.+\&quot;)$&quot;, re.MULTILINE | re.DOTALL)
 54 functionParameterFinder = re.compile(r&quot;^(?:async\s+)?function\s+(?:\w+)\s*\(((?:\s*\w+)?\s*(?:\s*,\s*\w+)*)?\s*\)&quot;, re.MULTILINE | re.DOTALL)
 55 
 56 multilineCommentRegExp = re.compile(r&quot;\/\*.*?\*\/&quot;, re.MULTILINE | re.DOTALL)
 57 singleLineCommentRegExp = re.compile(r&quot;\/\/.*?\n&quot;, re.MULTILINE | re.DOTALL)
 58 keyValueAnnotationCommentRegExp = re.compile(r&quot;^\/\/ @(\w+)=([^=]+?)\n&quot;, re.MULTILINE | re.DOTALL)
 59 flagAnnotationCommentRegExp = re.compile(r&quot;^\/\/ @(\w+)[^=]*?\n&quot;, re.MULTILINE | re.DOTALL)
 60 lineWithOnlySingleLineCommentRegExp = re.compile(r&quot;^\s*\/\/\n&quot;, re.MULTILINE | re.DOTALL)
 61 lineWithTrailingSingleLineCommentRegExp = re.compile(r&quot;\s*\/\/\n&quot;, re.MULTILINE | re.DOTALL)
 62 leadingWhitespaceRegExp = re.compile(r&quot;^ +&quot;, re.MULTILINE | re.DOTALL)
 63 multipleEmptyLinesRegExp = re.compile(r&quot;\n{2,}&quot;, re.MULTILINE | re.DOTALL)
 64 
 65 class ParseException(Exception):
 66     pass
 67 
 68 
 69 class Framework:
 70     def __init__(self, name):
 71         self._settings = _FRAMEWORK_CONFIG_MAP[name]
 72         self.name = name
 73 
 74     def setting(self, key, default=&#39;&#39;):
 75         return self._settings.get(key, default)
 76 
 77     @staticmethod
 78     def fromString(frameworkString):
 79         if frameworkString == &quot;JavaScriptCore&quot;:
 80             return Frameworks.JavaScriptCore
 81 
 82         if frameworkString == &quot;WebCore&quot;:
 83             return Frameworks.WebCore
 84 
 85         raise ParseException(&quot;Unknown framework: %s&quot; % frameworkString)
 86 
 87 
 88 class Frameworks:
 89     JavaScriptCore = Framework(&quot;JavaScriptCore&quot;)
 90     WebCore = Framework(&quot;WebCore&quot;)
 91 
 92 
 93 class BuiltinObject:
 94     def __init__(self, object_name, annotations, functions):
 95         self.object_name = object_name
 96         self.annotations = annotations
 97         self.functions = functions
 98         self.collection = None  # Set by the owning BuiltinsCollection
 99 
100         for function in self.functions:
101             function.object = self
102 
103 
104 class BuiltinFunction:
<a name="2" id="anc2"></a><span class="line-modified">105     def __init__(self, function_name, function_source, parameters, is_async, is_constructor, is_global_private, is_naked_constructor, intrinsic, overridden_name):</span>
106         self.function_name = function_name
107         self.function_source = function_source
108         self.parameters = parameters
109         self.is_async = is_async
110         self.is_constructor = is_constructor
<a name="3" id="anc3"></a><span class="line-added">111         self.is_naked_constructor = is_naked_constructor</span>
112         self.is_global_private = is_global_private
113         self.intrinsic = intrinsic
114         self.overridden_name = overridden_name
115         self.object = None  # Set by the owning BuiltinObject
116 
117     @staticmethod
118     def fromString(function_string):
119         function_source = multilineCommentRegExp.sub(&quot;&quot;, function_string)
120 
121         intrinsic = &quot;NoIntrinsic&quot;
122         intrinsicMatch = functionIntrinsicRegExp.search(function_source)
123         if intrinsicMatch:
124             intrinsic = intrinsicMatch.group(1)
125             function_source = functionIntrinsicRegExp.sub(&quot;&quot;, function_source)
126 
127         overridden_name = None
128         overriddenNameMatch = functionOverriddenNameRegExp.search(function_source)
129         if overriddenNameMatch:
130             overridden_name = overriddenNameMatch.group(1)
131             function_source = functionOverriddenNameRegExp.sub(&quot;&quot;, function_source)
132 
133         if not os.getenv(&quot;CONFIGURATION&quot;, &quot;Debug&quot;).startswith(&quot;Debug&quot;):
134             function_source = lineWithOnlySingleLineCommentRegExp.sub(&quot;&quot;, function_source)
135             function_source = lineWithTrailingSingleLineCommentRegExp.sub(&quot;\n&quot;, function_source)
136             function_source = leadingWhitespaceRegExp.sub(&quot;&quot;, function_source)
137             function_source = multipleEmptyLinesRegExp.sub(&quot;\n&quot;, function_source)
138 
139         function_name = functionNameRegExp.findall(function_source)[0]
140         async_match = functionIsAsyncRegExp.match(function_source)
141         is_async = async_match != None and async_match.group(1) == &quot;async&quot;
142         is_constructor = functionIsConstructorRegExp.match(function_source) != None
143         is_getter = functionIsGetterRegExp.match(function_source) != None
144         is_global_private = functionGlobalPrivateRegExp.match(function_source) != None
<a name="4" id="anc4"></a><span class="line-added">145         is_naked_constructor = functionNakedConstructorRegExp.match(function_source) != None</span>
<span class="line-added">146         if is_naked_constructor:</span>
<span class="line-added">147             is_constructor = True</span>
148         parameters = [s.strip() for s in functionParameterFinder.findall(function_source)[0].split(&#39;,&#39;)]
149         if len(parameters[0]) == 0:
150             parameters = []
151 
152         if is_getter and not overridden_name:
153             overridden_name = &quot;\&quot;get %s\&quot;&quot; % (function_name)
154 
155         if not overridden_name:
156             overridden_name = &quot;static_cast&lt;const char*&gt;(nullptr)&quot;
157 
<a name="5" id="anc5"></a><span class="line-modified">158         return BuiltinFunction(function_name, function_source, parameters, is_async, is_constructor, is_global_private, is_naked_constructor, intrinsic, overridden_name)</span>
159 
160     def __str__(self):
161         interface = &quot;%s(%s)&quot; % (self.function_name, &#39;, &#39;.join(self.parameters))
162         if self.is_constructor:
163             interface = interface + &quot; [Constructor]&quot;
164 
165         if self.is_async:
166             interface = &quot;async &quot; + interface
167 
168         return interface
169 
170     def __lt__(self, other):
171         return self.function_name &lt; other.function_name
172 
173 
174 class BuiltinsCollection:
175     def __init__(self, framework_name):
176         self._copyright_lines = set()
177         self.objects = []
178         self.framework = Framework.fromString(framework_name)
179         log.debug(&quot;Created new Builtins collection.&quot;)
180 
181     def parse_builtins_file(self, filename, text):
182         log.debug(&quot;Parsing builtins file: %s&quot; % filename)
183 
184         parsed_copyrights = set(self._parse_copyright_lines(text))
185         self._copyright_lines = self._copyright_lines.union(parsed_copyrights)
186 
187         log.debug(&quot;Found copyright lines:&quot;)
188         for line in self._copyright_lines:
189             log.debug(line)
190         log.debug(&quot;&quot;)
191 
192         object_annotations = self._parse_annotations(text)
193 
194         object_name, ext = os.path.splitext(os.path.basename(filename))
195         log.debug(&quot;Parsing object: %s&quot; % object_name)
196 
197         parsed_functions = self._parse_functions(text)
198         for function in parsed_functions:
199             function.object = object_name
200 
201         log.debug(&quot;Parsed functions:&quot;)
202         for func in parsed_functions:
203             log.debug(func)
204         log.debug(&quot;&quot;)
205 
206         new_object = BuiltinObject(object_name, object_annotations, parsed_functions)
207         new_object.collection = self
208         self.objects.append(new_object)
209 
210     def copyrights(self):
211         owner_to_years = dict()
212         copyrightYearRegExp = re.compile(r&quot;(\d{4})[, ]{0,2}&quot;)
213         ownerStartRegExp = re.compile(r&quot;[^\d, ]&quot;)
214 
215         # Returns deduplicated copyrights keyed on the owner.
216         for line in self._copyright_lines:
217             years = set(copyrightYearRegExp.findall(line))
218             ownerIndex = ownerStartRegExp.search(line).start()
219             owner = line[ownerIndex:]
220             log.debug(&quot;Found years: %s and owner: %s&quot; % (years, owner))
221             if owner not in owner_to_years:
222                 owner_to_years[owner] = set()
223 
224             owner_to_years[owner] = owner_to_years[owner].union(years)
225 
226         result = []
227 
228         for owner, years in list(owner_to_years.items()):
229             sorted_years = list(years)
230             sorted_years.sort()
231             result.append(&quot;%s %s&quot; % (&#39;, &#39;.join(sorted_years), owner))
232 
233         return result
234 
235     def all_functions(self):
236         result = []
237         for object in self.objects:
238             result.extend(object.functions)
239 
240         result.sort()
241         return result
242 
243     def all_internal_functions(self):
244         result = []
245         for object in [o for o in self.objects if &#39;internal&#39; in o.annotations]:
246             result.extend(object.functions)
247 
248         result.sort()
249         return result
250 
251     # Private methods.
252 
253     def _parse_copyright_lines(self, text):
254         licenseBlock = multilineCommentRegExp.findall(text)[0]
255         licenseBlock = licenseBlock[:licenseBlock.index(&quot;Redistribution&quot;)]
256 
257         copyrightLines = [Templates.DefaultCopyright]
258         for line in licenseBlock.split(&quot;\n&quot;):
259             line = line.replace(&quot;/*&quot;, &quot;&quot;)
260             line = line.replace(&quot;*/&quot;, &quot;&quot;)
261             line = line.replace(&quot;*&quot;, &quot;&quot;)
262             line = line.replace(&quot;Copyright&quot;, &quot;&quot;)
263             line = line.replace(&quot;copyright&quot;, &quot;&quot;)
264             line = line.replace(&quot;(C)&quot;, &quot;&quot;)
265             line = line.replace(&quot;(c)&quot;, &quot;&quot;)
266             line = line.strip()
267 
268             if len(line) == 0:
269                 continue
270 
271             copyrightLines.append(line)
272 
273         return copyrightLines
274 
275     def _parse_annotations(self, text):
276         annotations = {}
277 
278         for match in keyValueAnnotationCommentRegExp.finditer(text):
279             (key, value) = match.group(1, 2)
280             log.debug(&quot;Found annotation: &#39;%s&#39; =&gt; &#39;%s&#39;&quot; % (key, value))
281             if key in annotations:
282                 raise ParseException(&quot;Duplicate annotation found: %s&quot; % key)
283 
284             annotations[key] = value
285 
286         for match in flagAnnotationCommentRegExp.finditer(text):
287             key = match.group(1)
288             log.debug(&quot;Found annotation: &#39;%s&#39; =&gt; &#39;TRUE&#39;&quot; % key)
289             if key in annotations:
290                 raise ParseException(&quot;Duplicate annotation found: %s&quot; % key)
291 
292             annotations[key] = True
293 
294         return annotations
295 
296     def _parse_functions(self, text):
297         text = multilineCommentRegExp.sub(&quot;/**/&quot;, singleLineCommentRegExp.sub(&quot;//\n&quot;, text))
298 
299         matches = [func for func in functionHeadRegExp.finditer(text)]
300         functionBounds = []
301         start = 0
302         end = 0
303         for match in matches:
304             start = match.start()
305             if start &lt; end:
306                 continue
307             end = match.end()
308             while text[end] != &#39;{&#39;:
309                 end = end + 1
310             depth = 1
311             end = end + 1
312             while depth &gt; 0:
313                 if text[end] == &#39;{&#39;:
314                     depth = depth + 1
315                 elif text[end] == &#39;}&#39;:
316                     depth = depth - 1
317                 end = end + 1
318             functionBounds.append((start, end))
319 
320         functionStrings = [text[start:end].strip() for (start, end) in functionBounds]
321         return list(map(BuiltinFunction.fromString, functionStrings))
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
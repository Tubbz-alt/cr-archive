<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObjectInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSPromise.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObjectInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,9 ***</span>
  /*
   *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">!  *  Copyright (C) 2003-2017 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2007 Eric Seidel (eric@webkit.org)
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Library General Public
   *  License as published by the Free Software Foundation; either
<span class="line-new-header">--- 1,9 ---</span>
  /*
   *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">!  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2007 Eric Seidel (eric@webkit.org)
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Library General Public
   *  License as published by the Free Software Foundation; either
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,45 ***</span>
   */
  
  #pragma once
  
  #include &quot;AuxiliaryBarrierInlines.h&quot;
  #include &quot;Error.h&quot;
  #include &quot;JSObject.h&quot;
  #include &quot;JSTypedArrays.h&quot;
  #include &quot;Lookup.h&quot;
  #include &quot;StructureInlines.h&quot;
  #include &quot;TypedArrayType.h&quot;
  
  namespace JSC {
  
  // Section 7.3.17 of the spec.
  template &lt;typename AddFunction&gt; // Add function should have a type like: (JSValue, RuntimeType) -&gt; bool
<span class="line-modified">! void createListFromArrayLike(ExecState* exec, JSValue arrayLikeValue, RuntimeTypeMask legalTypesFilter, const String&amp; notAnObjectErroMessage, const String&amp; illegalTypeErrorMessage, AddFunction addFunction)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!arrayLikeValue.isObject()) {
<span class="line-modified">!         throwTypeError(exec, scope, notAnObjectErroMessage);</span>
          return;
      }
  
      Vector&lt;JSValue&gt; result;
<span class="line-modified">!     JSValue lengthProperty = arrayLikeValue.get(exec, vm.propertyNames-&gt;length);</span>
      RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!     double lengthAsDouble = lengthProperty.toLength(exec);</span>
      RETURN_IF_EXCEPTION(scope, void());
      RELEASE_ASSERT(lengthAsDouble &gt;= 0.0 &amp;&amp; lengthAsDouble == std::trunc(lengthAsDouble));
      uint64_t length = static_cast&lt;uint64_t&gt;(lengthAsDouble);
      for (uint64_t index = 0; index &lt; length; index++) {
<span class="line-modified">!         JSValue next = arrayLikeValue.get(exec, index);</span>
          RETURN_IF_EXCEPTION(scope, void());
  
          RuntimeType type = runtimeTypeForValue(vm, next);
          if (!(type &amp; legalTypesFilter)) {
<span class="line-modified">!             throwTypeError(exec, scope, illegalTypeErrorMessage);</span>
              return;
          }
  
          bool exitEarly = addFunction(next, type);
          if (exitEarly)
<span class="line-new-header">--- 22,54 ---</span>
   */
  
  #pragma once
  
  #include &quot;AuxiliaryBarrierInlines.h&quot;
<span class="line-added">+ #include &quot;ButterflyInlines.h&quot;</span>
  #include &quot;Error.h&quot;
<span class="line-added">+ #include &quot;JSFunction.h&quot;</span>
  #include &quot;JSObject.h&quot;
  #include &quot;JSTypedArrays.h&quot;
  #include &quot;Lookup.h&quot;
  #include &quot;StructureInlines.h&quot;
  #include &quot;TypedArrayType.h&quot;
  
  namespace JSC {
  
<span class="line-added">+ template&lt;typename CellType, SubspaceAccess&gt;</span>
<span class="line-added">+ CompleteSubspace* JSObject::subspaceFor(VM&amp; vm)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static_assert(!CellType::needsDestruction);</span>
<span class="line-added">+     return &amp;vm.cellSpace;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Section 7.3.17 of the spec.
  template &lt;typename AddFunction&gt; // Add function should have a type like: (JSValue, RuntimeType) -&gt; bool
<span class="line-modified">! void createListFromArrayLike(JSGlobalObject* globalObject, JSValue arrayLikeValue, RuntimeTypeMask legalTypesFilter, const String&amp; notAnObjectErroMessage, const String&amp; illegalTypeErrorMessage, AddFunction addFunction)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!arrayLikeValue.isObject()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, notAnObjectErroMessage);</span>
          return;
      }
  
      Vector&lt;JSValue&gt; result;
<span class="line-modified">!     JSValue lengthProperty = arrayLikeValue.get(globalObject, vm.propertyNames-&gt;length);</span>
      RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!     double lengthAsDouble = lengthProperty.toLength(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, void());
      RELEASE_ASSERT(lengthAsDouble &gt;= 0.0 &amp;&amp; lengthAsDouble == std::trunc(lengthAsDouble));
      uint64_t length = static_cast&lt;uint64_t&gt;(lengthAsDouble);
      for (uint64_t index = 0; index &lt; length; index++) {
<span class="line-modified">!         JSValue next = arrayLikeValue.get(globalObject, index);</span>
          RETURN_IF_EXCEPTION(scope, void());
  
          RuntimeType type = runtimeTypeForValue(vm, next);
          if (!(type &amp; legalTypesFilter)) {
<span class="line-modified">!             throwTypeError(globalObject, scope, illegalTypeErrorMessage);</span>
              return;
          }
  
          bool exitEarly = addFunction(next, type);
          if (exitEarly)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,92 ***</span>
          return false;
      return canPerformFastPutInlineExcludingProto(vm);
  }
  
  template&lt;typename CallbackWhenNoException&gt;
<span class="line-modified">! ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSObject::getPropertySlot(ExecState* exec, PropertyName propertyName, CallbackWhenNoException callback) const</span>
  {
      PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     return getPropertySlot(exec, propertyName, slot, callback);</span>
  }
  
  template&lt;typename CallbackWhenNoException&gt;
<span class="line-modified">! ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSObject::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot, CallbackWhenNoException callback) const</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     bool found = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);</span>
      RETURN_IF_EXCEPTION(scope, { });
      RELEASE_AND_RETURN(scope, callback(found, slot));
  }
  
<span class="line-modified">! ALWAYS_INLINE bool JSObject::getPropertySlot(ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      auto&amp; structureIDTable = vm.heap.structureIDTable();
      JSObject* object = this;
      MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
      while (true) {
          Structure* structure = structureIDTable.get(object-&gt;structureID());
<span class="line-modified">!         bool hasSlot = structure-&gt;classInfo()-&gt;methodTable.getOwnPropertySlotByIndex(object, exec, propertyName, slot);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (hasSlot)
              return true;
          JSValue prototype;
          if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype || slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry))
              prototype = object-&gt;getPrototypeDirect(vm);
          else {
<span class="line-modified">!             prototype = object-&gt;getPrototype(vm, exec);</span>
              RETURN_IF_EXCEPTION(scope, false);
          }
          if (!prototype.isObject())
              return false;
          object = asObject(prototype);
      }
  }
  
<span class="line-modified">! ALWAYS_INLINE bool JSObject::getNonIndexPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      // This method only supports non-index PropertyNames.
      ASSERT(!parseIndex(propertyName));
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      auto&amp; structureIDTable = vm.heap.structureIDTable();
      JSObject* object = this;
      MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
      while (true) {
          Structure* structure = structureIDTable.get(object-&gt;structureID());
          if (LIKELY(!TypeInfo::overridesGetOwnPropertySlot(object-&gt;inlineTypeFlags()))) {
              if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
                  return true;
          } else {
<span class="line-modified">!             bool hasSlot = structure-&gt;classInfo()-&gt;methodTable.getOwnPropertySlot(object, exec, propertyName, slot);</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (hasSlot)
                  return true;
          }
          JSValue prototype;
          if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype || slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry))
              prototype = object-&gt;getPrototypeDirect(vm);
          else {
<span class="line-modified">!             prototype = object-&gt;getPrototype(vm, exec);</span>
              RETURN_IF_EXCEPTION(scope, false);
          }
          if (!prototype.isObject())
              return false;
          object = asObject(prototype);
      }
  }
  
<span class="line-modified">! inline bool JSObject::getOwnPropertySlotInline(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      if (UNLIKELY(TypeInfo::overridesGetOwnPropertySlot(inlineTypeFlags())))
<span class="line-modified">!         return methodTable(vm)-&gt;getOwnPropertySlot(this, exec, propertyName, slot);</span>
<span class="line-modified">!     return JSObject::getOwnPropertySlot(this, exec, propertyName, slot);</span>
  }
  
  inline bool JSObject::mayInterceptIndexedAccesses(VM&amp; vm)
  {
      return structure(vm)-&gt;mayInterceptIndexedAccesses();
<span class="line-new-header">--- 103,96 ---</span>
          return false;
      return canPerformFastPutInlineExcludingProto(vm);
  }
  
  template&lt;typename CallbackWhenNoException&gt;
<span class="line-modified">! ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSObject::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, CallbackWhenNoException callback) const</span>
  {
      PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     return getPropertySlot(globalObject, propertyName, slot, callback);</span>
  }
  
  template&lt;typename CallbackWhenNoException&gt;
<span class="line-modified">! ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSObject::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot, CallbackWhenNoException callback) const</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     bool found = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
      RETURN_IF_EXCEPTION(scope, { });
      RELEASE_AND_RETURN(scope, callback(found, slot));
  }
  
<span class="line-modified">! ALWAYS_INLINE bool JSObject::getPropertySlot(JSGlobalObject* globalObject, unsigned propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      auto&amp; structureIDTable = vm.heap.structureIDTable();
      JSObject* object = this;
      MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
      while (true) {
          Structure* structure = structureIDTable.get(object-&gt;structureID());
<span class="line-modified">!         bool hasSlot = structure-&gt;classInfo()-&gt;methodTable.getOwnPropertySlotByIndex(object, globalObject, propertyName, slot);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (hasSlot)
              return true;
<span class="line-added">+         if (object-&gt;type() == ProxyObjectType &amp;&amp; slot.internalMethodType() == PropertySlot::InternalMethodType::HasProperty)</span>
<span class="line-added">+             return false;</span>
          JSValue prototype;
          if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype || slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry))
              prototype = object-&gt;getPrototypeDirect(vm);
          else {
<span class="line-modified">!             prototype = object-&gt;getPrototype(vm, globalObject);</span>
              RETURN_IF_EXCEPTION(scope, false);
          }
          if (!prototype.isObject())
              return false;
          object = asObject(prototype);
      }
  }
  
<span class="line-modified">! ALWAYS_INLINE bool JSObject::getNonIndexPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      // This method only supports non-index PropertyNames.
      ASSERT(!parseIndex(propertyName));
  
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      auto&amp; structureIDTable = vm.heap.structureIDTable();
      JSObject* object = this;
      MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
      while (true) {
          Structure* structure = structureIDTable.get(object-&gt;structureID());
          if (LIKELY(!TypeInfo::overridesGetOwnPropertySlot(object-&gt;inlineTypeFlags()))) {
              if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
                  return true;
          } else {
<span class="line-modified">!             bool hasSlot = structure-&gt;classInfo()-&gt;methodTable.getOwnPropertySlot(object, globalObject, propertyName, slot);</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (hasSlot)
                  return true;
<span class="line-added">+             if (object-&gt;type() == ProxyObjectType &amp;&amp; slot.internalMethodType() == PropertySlot::InternalMethodType::HasProperty)</span>
<span class="line-added">+                 return false;</span>
          }
          JSValue prototype;
          if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype || slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry))
              prototype = object-&gt;getPrototypeDirect(vm);
          else {
<span class="line-modified">!             prototype = object-&gt;getPrototype(vm, globalObject);</span>
              RETURN_IF_EXCEPTION(scope, false);
          }
          if (!prototype.isObject())
              return false;
          object = asObject(prototype);
      }
  }
  
<span class="line-modified">! inline bool JSObject::getOwnPropertySlotInline(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      if (UNLIKELY(TypeInfo::overridesGetOwnPropertySlot(inlineTypeFlags())))
<span class="line-modified">!         return methodTable(vm)-&gt;getOwnPropertySlot(this, globalObject, propertyName, slot);</span>
<span class="line-modified">!     return JSObject::getOwnPropertySlot(this, globalObject, propertyName, slot);</span>
  }
  
  inline bool JSObject::mayInterceptIndexedAccesses(VM&amp; vm)
  {
      return structure(vm)-&gt;mayInterceptIndexedAccesses();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 201,78 ***</span>
  {
      unsigned oldOutOfLineCapacity = structure-&gt;outOfLineCapacity();
      PropertyOffset result;
      structure-&gt;addPropertyWithoutTransition(
          vm, propertyName, attributes,
<span class="line-modified">!         [&amp;] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset offset, PropertyOffset newLastOffset) {</span>
<span class="line-modified">!             unsigned newOutOfLineCapacity = Structure::outOfLineCapacity(newLastOffset);</span>
              if (newOutOfLineCapacity != oldOutOfLineCapacity) {
                  Butterfly* butterfly = allocateMoreOutOfLineStorage(vm, oldOutOfLineCapacity, newOutOfLineCapacity);
                  nukeStructureAndSetButterfly(vm, structureID, butterfly);
<span class="line-modified">!                 structure-&gt;setLastOffset(newLastOffset);</span>
                  WTF::storeStoreFence();
                  setStructureIDDirectly(structureID);
              } else
<span class="line-modified">!                 structure-&gt;setLastOffset(newLastOffset);</span>
  
              // This assertion verifies that the concurrent GC won&#39;t read garbage if the concurrentGC
              // is running at the same time we put without transitioning.
              ASSERT(!getDirect(offset) || !JSValue::encode(getDirect(offset)));
              result = offset;
          });
      return result;
  }
  
  // ECMA 8.6.2.2
<span class="line-modified">! ALWAYS_INLINE bool JSObject::putInlineForJSObject(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
      ASSERT(value);
      ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(thisObject));
  
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
  
      // Try indexed put first. This is required for correctness, since loads on property names that appear like
      // valid indices will never look in the named property storage.
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, putByIndex(thisObject, exec, index.value(), value, slot.isStrictMode()));</span>
  
      if (thisObject-&gt;canPerformFastPutInline(vm, propertyName)) {
          ASSERT(!thisObject-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName));
          if (!thisObject-&gt;putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot))
<span class="line-modified">!             return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
          return true;
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, thisObject-&gt;putInlineSlow(exec, propertyName, value, slot));</span>
  }
  
  // HasOwnProperty(O, P) from section 7.3.11 in the spec.
  // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasownproperty
<span class="line-modified">! ALWAYS_INLINE bool JSObject::hasOwnProperty(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot) const</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      ASSERT(slot.internalMethodType() == PropertySlot::InternalMethodType::GetOwnProperty);
      if (LIKELY(const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(vm)-&gt;getOwnPropertySlot == JSObject::getOwnPropertySlot))
<span class="line-modified">!         return JSObject::getOwnPropertySlot(const_cast&lt;JSObject*&gt;(this), exec, propertyName, slot);</span>
<span class="line-modified">!     return const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(vm)-&gt;getOwnPropertySlot(const_cast&lt;JSObject*&gt;(this), exec, propertyName, slot);</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE bool JSObject::hasOwnProperty(ExecState* exec, PropertyName propertyName) const</span>
  {
      PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     return hasOwnProperty(exec, propertyName, slot);</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE bool JSObject::hasOwnProperty(ExecState* exec, unsigned propertyName) const</span>
  {
      PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     return const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(exec-&gt;vm())-&gt;getOwnPropertySlotByIndex(const_cast&lt;JSObject*&gt;(this), exec, propertyName, slot);</span>
  }
  
  template&lt;JSObject::PutMode mode&gt;
  ALWAYS_INLINE bool JSObject::putDirectInternal(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes, PutPropertySlot&amp; slot)
  {
<span class="line-new-header">--- 214,78 ---</span>
  {
      unsigned oldOutOfLineCapacity = structure-&gt;outOfLineCapacity();
      PropertyOffset result;
      structure-&gt;addPropertyWithoutTransition(
          vm, propertyName, attributes,
<span class="line-modified">!         [&amp;] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset offset, PropertyOffset newMaxOffset) {</span>
<span class="line-modified">!             unsigned newOutOfLineCapacity = Structure::outOfLineCapacity(newMaxOffset);</span>
              if (newOutOfLineCapacity != oldOutOfLineCapacity) {
                  Butterfly* butterfly = allocateMoreOutOfLineStorage(vm, oldOutOfLineCapacity, newOutOfLineCapacity);
                  nukeStructureAndSetButterfly(vm, structureID, butterfly);
<span class="line-modified">!                 structure-&gt;setMaxOffset(vm, newMaxOffset);</span>
                  WTF::storeStoreFence();
                  setStructureIDDirectly(structureID);
              } else
<span class="line-modified">!                 structure-&gt;setMaxOffset(vm, newMaxOffset);</span>
  
              // This assertion verifies that the concurrent GC won&#39;t read garbage if the concurrentGC
              // is running at the same time we put without transitioning.
              ASSERT(!getDirect(offset) || !JSValue::encode(getDirect(offset)));
              result = offset;
          });
      return result;
  }
  
  // ECMA 8.6.2.2
<span class="line-modified">! ALWAYS_INLINE bool JSObject::putInlineForJSObject(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
      ASSERT(value);
      ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(thisObject));
  
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
  
      // Try indexed put first. This is required for correctness, since loads on property names that appear like
      // valid indices will never look in the named property storage.
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, putByIndex(thisObject, globalObject, index.value(), value, slot.isStrictMode()));</span>
  
      if (thisObject-&gt;canPerformFastPutInline(vm, propertyName)) {
          ASSERT(!thisObject-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName));
          if (!thisObject-&gt;putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot))
<span class="line-modified">!             return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
          return true;
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, thisObject-&gt;putInlineSlow(globalObject, propertyName, value, slot));</span>
  }
  
  // HasOwnProperty(O, P) from section 7.3.11 in the spec.
  // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasownproperty
<span class="line-modified">! ALWAYS_INLINE bool JSObject::hasOwnProperty(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot) const</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      ASSERT(slot.internalMethodType() == PropertySlot::InternalMethodType::GetOwnProperty);
      if (LIKELY(const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(vm)-&gt;getOwnPropertySlot == JSObject::getOwnPropertySlot))
<span class="line-modified">!         return JSObject::getOwnPropertySlot(const_cast&lt;JSObject*&gt;(this), globalObject, propertyName, slot);</span>
<span class="line-modified">!     return const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(vm)-&gt;getOwnPropertySlot(const_cast&lt;JSObject*&gt;(this), globalObject, propertyName, slot);</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE bool JSObject::hasOwnProperty(JSGlobalObject* globalObject, PropertyName propertyName) const</span>
  {
      PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     return hasOwnProperty(globalObject, propertyName, slot);</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE bool JSObject::hasOwnProperty(JSGlobalObject* globalObject, unsigned propertyName) const</span>
  {
      PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     return const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(getVM(globalObject))-&gt;getOwnPropertySlotByIndex(const_cast&lt;JSObject*&gt;(this), globalObject, propertyName, slot);</span>
  }
  
  template&lt;JSObject::PutMode mode&gt;
  ALWAYS_INLINE bool JSObject::putDirectInternal(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes, PutPropertySlot&amp; slot)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 460,7 ***</span>
<span class="line-new-header">--- 473,66 ---</span>
          RELEASE_ASSERT_NOT_REACHED();
          return;
      }
  }
  
<span class="line-added">+ inline void JSObject::validatePutOwnDataProperty(VM&amp; vm, PropertyName propertyName, JSValue value)</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if ASSERT_ENABLED</span>
<span class="line-added">+     ASSERT(value);</span>
<span class="line-added">+     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));</span>
<span class="line-added">+     unsigned attributes;</span>
<span class="line-added">+     PropertyOffset offset = structure(vm)-&gt;get(vm, propertyName, attributes);</span>
<span class="line-added">+     if (isValidOffset(offset))</span>
<span class="line-added">+         ASSERT(!(attributes &amp; (PropertyAttribute::Accessor | PropertyAttribute::CustomAccessor | PropertyAttribute::ReadOnly)));</span>
<span class="line-added">+     else if (TypeInfo::hasStaticPropertyTable(inlineTypeFlags())) {</span>
<span class="line-added">+         if (auto entry = findPropertyHashEntry(vm, propertyName))</span>
<span class="line-added">+             ASSERT(!(entry-&gt;value-&gt;attributes() &amp; (PropertyAttribute::Accessor | PropertyAttribute::CustomAccessor | PropertyAttribute::ReadOnly)));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #else // not ASSERT_ENABLED</span>
<span class="line-added">+     UNUSED_PARAM(vm);</span>
<span class="line-added">+     UNUSED_PARAM(propertyName);</span>
<span class="line-added">+     UNUSED_PARAM(value);</span>
<span class="line-added">+ #endif // not ASSERT_ENABLED</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline bool JSObject::putOwnDataProperty(VM&amp; vm, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     validatePutOwnDataProperty(vm, propertyName, value);</span>
<span class="line-added">+     return putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline bool JSObject::putOwnDataPropertyMayBeIndex(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = getVM(globalObject);</span>
<span class="line-added">+     validatePutOwnDataProperty(vm, propertyName, value);</span>
<span class="line-added">+     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))</span>
<span class="line-added">+         return putDirectIndex(globalObject, index.value(), value, 0, PutDirectIndexLikePutDirect);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline CallType getCallData(VM&amp; vm, JSValue value, CallData&amp; callData)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!value.isCell())</span>
<span class="line-added">+         return CallType::None;</span>
<span class="line-added">+     JSCell* cell = value.asCell();</span>
<span class="line-added">+     if (cell-&gt;type() == JSFunctionType)</span>
<span class="line-added">+         return JSFunction::getCallData(cell, callData);</span>
<span class="line-added">+     CallType result = cell-&gt;methodTable(vm)-&gt;getCallData(cell, callData);</span>
<span class="line-added">+     ASSERT(result == CallType::None || value.isValidCallee());</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline ConstructType getConstructData(VM&amp; vm, JSValue value, ConstructData&amp; constructData)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!value.isCell())</span>
<span class="line-added">+         return ConstructType::None;</span>
<span class="line-added">+     JSCell* cell = value.asCell();</span>
<span class="line-added">+     if (cell-&gt;type() == JSFunctionType)</span>
<span class="line-added">+         return JSFunction::getConstructData(cell, constructData);</span>
<span class="line-added">+     ConstructType result = cell-&gt;methodTable(vm)-&gt;getConstructData(cell, constructData);</span>
<span class="line-added">+     ASSERT(result == ConstructType::None || value.isValidCallee());</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+ }</span>
  
  } // namespace JSC
</pre>
<center><a href="JSObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSPromise.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
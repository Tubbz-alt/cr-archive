<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/TransformationMatrix.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2005, 2006, 2013 Apple Inc.  All rights reserved.
   3  * Copyright (C) 2009 Torch Mobile, Inc.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;TransformationMatrix.h&quot;
  29 
  30 #include &quot;AffineTransform.h&quot;
  31 #include &quot;FloatQuad.h&quot;
  32 #include &quot;FloatRect.h&quot;
  33 #include &quot;IntRect.h&quot;
  34 #include &quot;LayoutRect.h&quot;
  35 #include &lt;cmath&gt;
  36 #include &lt;wtf/Assertions.h&gt;
  37 #include &lt;wtf/MathExtras.h&gt;
  38 #include &lt;wtf/Optional.h&gt;
  39 #include &lt;wtf/text/TextStream.h&gt;
  40 
<a name="1" id="anc1"></a><span class="line-added">  41 #if PLATFORM(JAVA)</span>
<span class="line-added">  42 #include &lt;wtf/java/JavaMath.h&gt;</span>
<span class="line-added">  43 #endif</span>
<span class="line-added">  44 </span>
  45 #if CPU(X86_64)
  46 #include &lt;emmintrin.h&gt;
  47 #endif
  48 
  49 namespace WebCore {
  50 
  51 //
  52 // Adapted from Matrix Inversion by Richard Carling, Graphics Gems &lt;http://tog.acm.org/GraphicsGems/index.html&gt;.
  53 
  54 // EULA: The Graphics Gems code is copyright-protected. In other words, you cannot claim the text of the code
  55 // as your own and resell it. Using the code is permitted in any program, product, or library, non-commercial
  56 // or commercial. Giving credit is not required, though is a nice gesture. The code comes as-is, and if there
  57 // are any flaws or problems with any Gems code, nobody involved with Gems - authors, editors, publishers, or
  58 // webmasters - are to be held responsible. Basically, don&#39;t be a jerk, and remember that anything free comes
  59 // with no guarantee.
  60 
  61 // A clarification about the storage of matrix elements
  62 //
  63 // This class uses a 2 dimensional array internally to store the elements of the matrix. The first index into
  64 // the array refers to the column that the element lies in; the second index refers to the row.
  65 //
  66 // In other words, this is the layout of the matrix:
  67 //
  68 // | m_matrix[0][0] m_matrix[1][0] m_matrix[2][0] m_matrix[3][0] |
  69 // | m_matrix[0][1] m_matrix[1][1] m_matrix[2][1] m_matrix[3][1] |
  70 // | m_matrix[0][2] m_matrix[1][2] m_matrix[2][2] m_matrix[3][2] |
  71 // | m_matrix[0][3] m_matrix[1][3] m_matrix[2][3] m_matrix[3][3] |
  72 
  73 typedef double Vector4[4];
  74 typedef double Vector3[3];
  75 
  76 const double SMALL_NUMBER = 1.e-8;
  77 
  78 const TransformationMatrix TransformationMatrix::identity { };
  79 
  80 // inverse(original_matrix, inverse_matrix)
  81 //
  82 // calculate the inverse of a 4x4 matrix
  83 //
  84 // -1
  85 // A  = ___1__ adjoint A
  86 //       det A
  87 
  88 //  double = determinant2x2(double a, double b, double c, double d)
  89 //
  90 //  calculate the determinant of a 2x2 matrix.
  91 
  92 static double determinant2x2(double a, double b, double c, double d)
  93 {
  94     return a * d - b * c;
  95 }
  96 
  97 //  double = determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3)
  98 //
  99 //  Calculate the determinant of a 3x3 matrix
 100 //  in the form
 101 //
 102 //      | a1,  b1,  c1 |
 103 //      | a2,  b2,  c2 |
 104 //      | a3,  b3,  c3 |
 105 
 106 static double determinant3x3(double a1, double a2, double a3, double b1, double b2, double b3, double c1, double c2, double c3)
 107 {
 108     return a1 * determinant2x2(b2, b3, c2, c3)
 109          - b1 * determinant2x2(a2, a3, c2, c3)
 110          + c1 * determinant2x2(a2, a3, b2, b3);
 111 }
 112 
 113 //  double = determinant4x4(matrix)
 114 //
 115 //  calculate the determinant of a 4x4 matrix.
 116 
 117 static double determinant4x4(const TransformationMatrix::Matrix4&amp; m)
 118 {
 119     // Assign to individual variable names to aid selecting
 120     // correct elements
 121 
 122     double a1 = m[0][0];
 123     double b1 = m[0][1];
 124     double c1 = m[0][2];
 125     double d1 = m[0][3];
 126 
 127     double a2 = m[1][0];
 128     double b2 = m[1][1];
 129     double c2 = m[1][2];
 130     double d2 = m[1][3];
 131 
 132     double a3 = m[2][0];
 133     double b3 = m[2][1];
 134     double c3 = m[2][2];
 135     double d3 = m[2][3];
 136 
 137     double a4 = m[3][0];
 138     double b4 = m[3][1];
 139     double c4 = m[3][2];
 140     double d4 = m[3][3];
 141 
 142     return a1 * determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4)
 143          - b1 * determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4)
 144          + c1 * determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4)
 145          - d1 * determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
 146 }
 147 
 148 // adjoint( original_matrix, inverse_matrix )
 149 //
 150 //   calculate the adjoint of a 4x4 matrix
 151 //
 152 //    Let  a   denote the minor determinant of matrix A obtained by
 153 //         ij
 154 //
 155 //    deleting the ith row and jth column from A.
 156 //
 157 //                  i+j
 158 //   Let  b   = (-1)    a
 159 //        ij            ji
 160 //
 161 //  The matrix B = (b  ) is the adjoint of A
 162 //                   ij
 163 
 164 static void adjoint(const TransformationMatrix::Matrix4&amp; matrix, TransformationMatrix::Matrix4&amp; result)
 165 {
 166     // Assign to individual variable names to aid
 167     // selecting correct values
 168     double a1 = matrix[0][0];
 169     double b1 = matrix[0][1];
 170     double c1 = matrix[0][2];
 171     double d1 = matrix[0][3];
 172 
 173     double a2 = matrix[1][0];
 174     double b2 = matrix[1][1];
 175     double c2 = matrix[1][2];
 176     double d2 = matrix[1][3];
 177 
 178     double a3 = matrix[2][0];
 179     double b3 = matrix[2][1];
 180     double c3 = matrix[2][2];
 181     double d3 = matrix[2][3];
 182 
 183     double a4 = matrix[3][0];
 184     double b4 = matrix[3][1];
 185     double c4 = matrix[3][2];
 186     double d4 = matrix[3][3];
 187 
 188     // Row column labeling reversed since we transpose rows &amp; columns
 189     result[0][0]  =   determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
 190     result[1][0]  = - determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
 191     result[2][0]  =   determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
 192     result[3][0]  = - determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
 193 
 194     result[0][1]  = - determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
 195     result[1][1]  =   determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
 196     result[2][1]  = - determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
 197     result[3][1]  =   determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);
 198 
 199     result[0][2]  =   determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
 200     result[1][2]  = - determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
 201     result[2][2]  =   determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
 202     result[3][2]  = - determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);
 203 
 204     result[0][3]  = - determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
 205     result[1][3]  =   determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
 206     result[2][3]  = - determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
 207     result[3][3]  =   determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
 208 }
 209 
 210 // Returns false if the matrix is not invertible
 211 static bool inverse(const TransformationMatrix::Matrix4&amp; matrix, TransformationMatrix::Matrix4&amp; result)
 212 {
 213     // Calculate the adjoint matrix
 214     adjoint(matrix, result);
 215 
 216     // Calculate the 4x4 determinant
 217     // If the determinant is zero,
 218     // then the inverse matrix is not unique.
 219     double det = determinant4x4(matrix);
 220 
 221     if (fabs(det) &lt; SMALL_NUMBER)
 222         return false;
 223 
 224     // Scale the adjoint matrix to get the inverse
 225 
 226     for (int i = 0; i &lt; 4; i++)
 227         for (int j = 0; j &lt; 4; j++)
 228             result[i][j] = result[i][j] / det;
 229 
 230     return true;
 231 }
 232 
 233 // End of code adapted from Matrix Inversion by Richard Carling
 234 
 235 // Perform a decomposition on the passed matrix, return false if unsuccessful
 236 // From Graphics Gems: unmatrix.c
 237 
 238 // Transpose rotation portion of matrix a, return b
 239 static void transposeMatrix4(const TransformationMatrix::Matrix4&amp; a, TransformationMatrix::Matrix4&amp; b)
 240 {
 241     for (int i = 0; i &lt; 4; i++)
 242         for (int j = 0; j &lt; 4; j++)
 243             b[i][j] = a[j][i];
 244 }
 245 
 246 // Multiply a homogeneous point by a matrix and return the transformed point
 247 static void v4MulPointByMatrix(const Vector4 p, const TransformationMatrix::Matrix4&amp; m, Vector4 result)
 248 {
 249     result[0] = (p[0] * m[0][0]) + (p[1] * m[1][0]) +
 250                 (p[2] * m[2][0]) + (p[3] * m[3][0]);
 251     result[1] = (p[0] * m[0][1]) + (p[1] * m[1][1]) +
 252                 (p[2] * m[2][1]) + (p[3] * m[3][1]);
 253     result[2] = (p[0] * m[0][2]) + (p[1] * m[1][2]) +
 254                 (p[2] * m[2][2]) + (p[3] * m[3][2]);
 255     result[3] = (p[0] * m[0][3]) + (p[1] * m[1][3]) +
 256                 (p[2] * m[2][3]) + (p[3] * m[3][3]);
 257 }
 258 
 259 static double v3Length(Vector3 a)
 260 {
<a name="2" id="anc2"></a><span class="line-modified"> 261 #if PLATFORM(JAVA)</span>
<span class="line-added"> 262     return javamath::hypot(a[0], a[1], a[2]);</span>
<span class="line-added"> 263 #else</span>
<span class="line-added"> 264     return std::hypot(a[0], a[1], a[2]);</span>
<span class="line-added"> 265 #endif</span>
 266 }
 267 
 268 static void v3Scale(Vector3 v, double desiredLength)
 269 {
 270     double len = v3Length(v);
 271     if (len != 0) {
 272         double l = desiredLength / len;
 273         v[0] *= l;
 274         v[1] *= l;
 275         v[2] *= l;
 276     }
 277 }
 278 
 279 static double v3Dot(const Vector3 a, const Vector3 b)
 280 {
 281     return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);
 282 }
 283 
 284 // Make a linear combination of two vectors and return the result.
 285 // result = (a * ascl) + (b * bscl)
 286 static void v3Combine(const Vector3 a, const Vector3 b, Vector3 result, double ascl, double bscl)
 287 {
 288     result[0] = (ascl * a[0]) + (bscl * b[0]);
 289     result[1] = (ascl * a[1]) + (bscl * b[1]);
 290     result[2] = (ascl * a[2]) + (bscl * b[2]);
 291 }
 292 
 293 // Return the cross product result = a cross b */
 294 static void v3Cross(const Vector3 a, const Vector3 b, Vector3 result)
 295 {
 296     result[0] = (a[1] * b[2]) - (a[2] * b[1]);
 297     result[1] = (a[2] * b[0]) - (a[0] * b[2]);
 298     result[2] = (a[0] * b[1]) - (a[1] * b[0]);
 299 }
 300 
 301 static bool decompose2(const TransformationMatrix::Matrix4&amp; matrix, TransformationMatrix::Decomposed2Type&amp; result)
 302 {
 303     double row0x = matrix[0][0];
 304     double row0y = matrix[0][1];
 305     double row1x = matrix[1][0];
 306     double row1y = matrix[1][1];
 307     result.translateX = matrix[3][0];
 308     result.translateY = matrix[3][1];
 309 
 310     // Compute scaling factors.
<a name="3" id="anc3"></a><span class="line-modified"> 311     result.scaleX = std::hypot(row0x, row0y);</span>
<span class="line-modified"> 312     result.scaleY = std::hypot(row1x, row1y);</span>
 313 
 314     // If determinant is negative, one axis was flipped.
 315     double determinant = row0x * row1y - row0y * row1x;
 316     if (determinant &lt; 0) {
 317         // Flip axis with minimum unit vector dot product.
 318         if (row0x &lt; row1y)
 319             result.scaleX = -result.scaleX;
 320         else
 321             result.scaleY = -result.scaleY;
 322     }
 323 
 324     // Renormalize matrix to remove scale.
 325     if (result.scaleX) {
 326         row0x *= 1 / result.scaleX;
 327         row0y *= 1 / result.scaleX;
 328     }
 329     if (result.scaleY) {
 330         row1x *= 1 / result.scaleY;
 331         row1y *= 1 / result.scaleY;
 332     }
 333 
 334     // Compute rotation and renormalize matrix.
 335     result.angle = atan2(row0y, row0x);
 336 
 337     if (result.angle) {
 338         // Rotate(-angle) = [cos(angle), sin(angle), -sin(angle), cos(angle)]
 339         //                = [row0x, -row0y, row0y, row0x]
 340         // Thanks to the normalization above.
 341         double sn = -row0y;
 342         double cs = row0x;
 343         double m11 = row0x, m12 = row0y;
 344         double m21 = row1x, m22 = row1y;
 345 
 346         row0x = cs * m11 + sn * m21;
 347         row0y = cs * m12 + sn * m22;
 348         row1x = -sn * m11 + cs * m21;
 349         row1y = -sn * m12 + cs * m22;
 350     }
 351 
 352     result.m11 = row0x;
 353     result.m12 = row0y;
 354     result.m21 = row1x;
 355     result.m22 = row1y;
 356 
 357     // Convert into degrees because our rotation functions expect it.
 358     result.angle = rad2deg(result.angle);
 359 
 360     return true;
 361 }
 362 
 363 static bool decompose4(const TransformationMatrix::Matrix4&amp; mat, TransformationMatrix::Decomposed4Type&amp; result)
 364 {
 365     TransformationMatrix::Matrix4 localMatrix;
 366     memcpy(localMatrix, mat, sizeof(TransformationMatrix::Matrix4));
 367 
 368     // Normalize the matrix.
 369     if (localMatrix[3][3] == 0)
 370         return false;
 371 
 372     int i, j;
 373     for (i = 0; i &lt; 4; i++)
 374         for (j = 0; j &lt; 4; j++)
 375             localMatrix[i][j] /= localMatrix[3][3];
 376 
 377     // perspectiveMatrix is used to solve for perspective, but it also provides
 378     // an easy way to test for singularity of the upper 3x3 component.
 379     TransformationMatrix::Matrix4 perspectiveMatrix;
 380     memcpy(perspectiveMatrix, localMatrix, sizeof(TransformationMatrix::Matrix4));
 381     for (i = 0; i &lt; 3; i++)
 382         perspectiveMatrix[i][3] = 0;
 383     perspectiveMatrix[3][3] = 1;
 384 
 385     if (determinant4x4(perspectiveMatrix) == 0)
 386         return false;
 387 
 388     // First, isolate perspective. This is the messiest.
 389     if (localMatrix[0][3] != 0 || localMatrix[1][3] != 0 || localMatrix[2][3] != 0) {
 390         // rightHandSide is the right hand side of the equation.
 391         Vector4 rightHandSide;
 392         rightHandSide[0] = localMatrix[0][3];
 393         rightHandSide[1] = localMatrix[1][3];
 394         rightHandSide[2] = localMatrix[2][3];
 395         rightHandSide[3] = localMatrix[3][3];
 396 
 397         // Solve the equation by inverting perspectiveMatrix and multiplying
 398         // rightHandSide by the inverse. (This is the easiest way, not
 399         // necessarily the best.)
 400         TransformationMatrix::Matrix4 inversePerspectiveMatrix, transposedInversePerspectiveMatrix;
 401         inverse(perspectiveMatrix, inversePerspectiveMatrix);
 402         transposeMatrix4(inversePerspectiveMatrix, transposedInversePerspectiveMatrix);
 403 
 404         Vector4 perspectivePoint;
 405         v4MulPointByMatrix(rightHandSide, transposedInversePerspectiveMatrix, perspectivePoint);
 406 
 407         result.perspectiveX = perspectivePoint[0];
 408         result.perspectiveY = perspectivePoint[1];
 409         result.perspectiveZ = perspectivePoint[2];
 410         result.perspectiveW = perspectivePoint[3];
 411 
 412         // Clear the perspective partition
 413         localMatrix[0][3] = localMatrix[1][3] = localMatrix[2][3] = 0;
 414         localMatrix[3][3] = 1;
 415     } else {
 416         // No perspective.
 417         result.perspectiveX = result.perspectiveY = result.perspectiveZ = 0;
 418         result.perspectiveW = 1;
 419     }
 420 
 421     // Next take care of translation (easy).
 422     result.translateX = localMatrix[3][0];
 423     localMatrix[3][0] = 0;
 424     result.translateY = localMatrix[3][1];
 425     localMatrix[3][1] = 0;
 426     result.translateZ = localMatrix[3][2];
 427     localMatrix[3][2] = 0;
 428 
 429     // Vector4 type and functions need to be added to the common set.
 430     Vector3 row[3], pdum3;
 431 
 432     // Now get scale and shear.
 433     for (i = 0; i &lt; 3; i++) {
 434         row[i][0] = localMatrix[i][0];
 435         row[i][1] = localMatrix[i][1];
 436         row[i][2] = localMatrix[i][2];
 437     }
 438 
 439     // Compute X scale factor and normalize first row.
 440     result.scaleX = v3Length(row[0]);
 441     v3Scale(row[0], 1.0);
 442 
 443     // Compute XY shear factor and make 2nd row orthogonal to 1st.
 444     result.skewXY = v3Dot(row[0], row[1]);
 445     v3Combine(row[1], row[0], row[1], 1.0, -result.skewXY);
 446 
 447     // Now, compute Y scale and normalize 2nd row.
 448     result.scaleY = v3Length(row[1]);
 449     v3Scale(row[1], 1.0);
 450     result.skewXY /= result.scaleY;
 451 
 452     // Compute XZ and YZ shears, orthogonalize 3rd row.
 453     result.skewXZ = v3Dot(row[0], row[2]);
 454     v3Combine(row[2], row[0], row[2], 1.0, -result.skewXZ);
 455     result.skewYZ = v3Dot(row[1], row[2]);
 456     v3Combine(row[2], row[1], row[2], 1.0, -result.skewYZ);
 457 
 458     // Next, get Z scale and normalize 3rd row.
 459     result.scaleZ = v3Length(row[2]);
 460     v3Scale(row[2], 1.0);
 461     result.skewXZ /= result.scaleZ;
 462     result.skewYZ /= result.scaleZ;
 463 
 464     // At this point, the matrix (in rows[]) is orthonormal.
 465     // Check for a coordinate system flip. If the determinant
 466     // is -1, then negate the matrix and the scaling factors.
 467     v3Cross(row[1], row[2], pdum3);
 468     if (v3Dot(row[0], pdum3) &lt; 0) {
 469 
 470         result.scaleX *= -1;
 471         result.scaleY *= -1;
 472         result.scaleZ *= -1;
 473 
 474         for (i = 0; i &lt; 3; i++) {
 475             row[i][0] *= -1;
 476             row[i][1] *= -1;
 477             row[i][2] *= -1;
 478         }
 479     }
 480 
 481     // Now, get the rotations out, as described in the gem.
 482 
 483     // FIXME - Add the ability to return either quaternions (which are
 484     // easier to recompose with) or Euler angles (rx, ry, rz), which
 485     // are easier for authors to deal with. The latter will only be useful
 486     // when we fix https://bugs.webkit.org/show_bug.cgi?id=23799, so I
 487     // will leave the Euler angle code here for now.
 488 
 489     // ret.rotateY = asin(-row[0][2]);
 490     // if (cos(ret.rotateY) != 0) {
 491     //     ret.rotateX = atan2(row[1][2], row[2][2]);
 492     //     ret.rotateZ = atan2(row[0][1], row[0][0]);
 493     // } else {
 494     //     ret.rotateX = atan2(-row[2][0], row[1][1]);
 495     //     ret.rotateZ = 0;
 496     // }
 497 
 498     double s, t, x, y, z, w;
 499 
 500     t = row[0][0] + row[1][1] + row[2][2] + 1.0;
 501 
 502     if (t &gt; 1e-4) {
 503         s = 0.5 / sqrt(t);
 504         w = 0.25 / s;
 505         x = (row[2][1] - row[1][2]) * s;
 506         y = (row[0][2] - row[2][0]) * s;
 507         z = (row[1][0] - row[0][1]) * s;
 508     } else if (row[0][0] &gt; row[1][1] &amp;&amp; row[0][0] &gt; row[2][2]) {
 509         s = sqrt(1.0 + row[0][0] - row[1][1] - row[2][2]) * 2.0; // S = 4 * qx.
 510         x = 0.25 * s;
 511         y = (row[0][1] + row[1][0]) / s;
 512         z = (row[0][2] + row[2][0]) / s;
 513         w = (row[2][1] - row[1][2]) / s;
 514     } else if (row[1][1] &gt; row[2][2]) {
 515         s = sqrt(1.0 + row[1][1] - row[0][0] - row[2][2]) * 2.0; // S = 4 * qy.
 516         x = (row[0][1] + row[1][0]) / s;
 517         y = 0.25 * s;
 518         z = (row[1][2] + row[2][1]) / s;
 519         w = (row[0][2] - row[2][0]) / s;
 520     } else {
 521         s = sqrt(1.0 + row[2][2] - row[0][0] - row[1][1]) * 2.0; // S = 4 * qz.
 522         x = (row[0][2] + row[2][0]) / s;
 523         y = (row[1][2] + row[2][1]) / s;
 524         z = 0.25 * s;
 525         w = (row[1][0] - row[0][1]) / s;
 526     }
 527 
 528     result.quaternionX = x;
 529     result.quaternionY = y;
 530     result.quaternionZ = z;
 531     result.quaternionW = w;
 532 
 533     return true;
 534 }
 535 
 536 // Perform a spherical linear interpolation between the two
 537 // passed quaternions with 0 &lt;= t &lt;= 1.
 538 static void slerp(double qa[4], const double qb[4], double t)
 539 {
 540     double ax, ay, az, aw;
 541     double bx, by, bz, bw;
 542     double cx, cy, cz, cw;
 543     double angle;
 544     double th, invth, scale, invscale;
 545 
 546     ax = qa[0]; ay = qa[1]; az = qa[2]; aw = qa[3];
 547     bx = qb[0]; by = qb[1]; bz = qb[2]; bw = qb[3];
 548 
 549     angle = ax * bx + ay * by + az * bz + aw * bw;
 550 
 551     if (angle &lt; 0.0) {
 552         ax = -ax; ay = -ay;
 553         az = -az; aw = -aw;
 554         angle = -angle;
 555     }
 556 
 557     if (angle + 1.0 &gt; .05) {
 558         if (1.0 - angle &gt;= .05) {
 559             th = acos (angle);
 560             invth = 1.0 / sin (th);
 561             scale = sin (th * (1.0 - t)) * invth;
 562             invscale = sin (th * t) * invth;
 563         } else {
 564             scale = 1.0 - t;
 565             invscale = t;
 566         }
 567     } else {
 568         bx = -ay;
 569         by = ax;
 570         bz = -aw;
 571         bw = az;
 572         scale = sin(piDouble * (.5 - t));
 573         invscale = sin (piDouble * t);
 574     }
 575 
 576     cx = ax * scale + bx * invscale;
 577     cy = ay * scale + by * invscale;
 578     cz = az * scale + bz * invscale;
 579     cw = aw * scale + bw * invscale;
 580 
 581     qa[0] = cx; qa[1] = cy; qa[2] = cz; qa[3] = cw;
 582 }
 583 
 584 // End of Supporting Math Functions
 585 
 586 TransformationMatrix::TransformationMatrix(const AffineTransform&amp; t)
 587 {
 588     setMatrix(t.a(), t.b(), t.c(), t.d(), t.e(), t.f());
 589 }
 590 
 591 TransformationMatrix&amp; TransformationMatrix::scale(double s)
 592 {
 593     return scaleNonUniform(s, s);
 594 }
 595 
 596 TransformationMatrix&amp; TransformationMatrix::rotateFromVector(double x, double y)
 597 {
 598     return rotate(rad2deg(atan2(y, x)));
 599 }
 600 
 601 TransformationMatrix&amp; TransformationMatrix::flipX()
 602 {
 603     return scaleNonUniform(-1.0, 1.0);
 604 }
 605 
 606 TransformationMatrix&amp; TransformationMatrix::flipY()
 607 {
 608     return scaleNonUniform(1.0, -1.0);
 609 }
 610 
 611 FloatPoint TransformationMatrix::projectPoint(const FloatPoint&amp; p, bool* clamped) const
 612 {
 613     // This is basically raytracing. We have a point in the destination
 614     // plane with z=0, and we cast a ray parallel to the z-axis from that
 615     // point to find the z-position at which it intersects the z=0 plane
 616     // with the transform applied. Once we have that point we apply the
 617     // inverse transform to find the corresponding point in the source
 618     // space.
 619     //
 620     // Given a plane with normal Pn, and a ray starting at point R0 and
 621     // with direction defined by the vector Rd, we can find the
 622     // intersection point as a distance d from R0 in units of Rd by:
 623     //
 624     // d = -dot (Pn&#39;, R0) / dot (Pn&#39;, Rd)
 625     if (clamped)
 626         *clamped = false;
 627 
 628     if (m33() == 0) {
 629         // In this case, the projection plane is parallel to the ray we are trying to
 630         // trace, and there is no well-defined value for the projection.
 631         return FloatPoint();
 632     }
 633 
 634     double x = p.x();
 635     double y = p.y();
 636     double z = -(m13() * x + m23() * y + m43()) / m33();
 637 
 638     // FIXME: use multVecMatrix()
 639     double outX = x * m11() + y * m21() + z * m31() + m41();
 640     double outY = x * m12() + y * m22() + z * m32() + m42();
 641 
 642     double w = x * m14() + y * m24() + z * m34() + m44();
 643     if (w &lt;= 0) {
 644         // Using int max causes overflow when other code uses the projected point. To
 645         // represent infinity yet reduce the risk of overflow, we use a large but
 646         // not-too-large number here when clamping.
 647         const int largeNumber = 100000000 / kFixedPointDenominator;
 648         outX = copysign(largeNumber, outX);
 649         outY = copysign(largeNumber, outY);
 650         if (clamped)
 651             *clamped = true;
 652     } else if (w != 1) {
 653         outX /= w;
 654         outY /= w;
 655     }
 656 
 657     return FloatPoint(static_cast&lt;float&gt;(outX), static_cast&lt;float&gt;(outY));
 658 }
 659 
 660 FloatQuad TransformationMatrix::projectQuad(const FloatQuad&amp; q, bool* clamped) const
 661 {
 662     FloatQuad projectedQuad;
 663 
 664     bool clamped1 = false;
 665     bool clamped2 = false;
 666     bool clamped3 = false;
 667     bool clamped4 = false;
 668 
 669     projectedQuad.setP1(projectPoint(q.p1(), &amp;clamped1));
 670     projectedQuad.setP2(projectPoint(q.p2(), &amp;clamped2));
 671     projectedQuad.setP3(projectPoint(q.p3(), &amp;clamped3));
 672     projectedQuad.setP4(projectPoint(q.p4(), &amp;clamped4));
 673 
 674     if (clamped)
 675         *clamped = clamped1 || clamped2 || clamped3 || clamped4;
 676 
 677     // If all points on the quad had w &lt; 0, then the entire quad would not be visible to the projected surface.
 678     bool everythingWasClipped = clamped1 &amp;&amp; clamped2 &amp;&amp; clamped3 &amp;&amp; clamped4;
 679     if (everythingWasClipped)
 680         return FloatQuad();
 681 
 682     return projectedQuad;
 683 }
 684 
 685 static float clampEdgeValue(float f)
 686 {
 687     ASSERT(!std::isnan(f));
 688     return std::min&lt;float&gt;(std::max&lt;float&gt;(f, -LayoutUnit::max() / 2), LayoutUnit::max() / 2);
 689 }
 690 
 691 LayoutRect TransformationMatrix::clampedBoundsOfProjectedQuad(const FloatQuad&amp; q) const
 692 {
 693     FloatRect mappedQuadBounds = projectQuad(q).boundingBox();
 694 
 695     float left = clampEdgeValue(floorf(mappedQuadBounds.x()));
 696     float top = clampEdgeValue(floorf(mappedQuadBounds.y()));
 697 
 698     float right;
 699     if (std::isinf(mappedQuadBounds.x()) &amp;&amp; std::isinf(mappedQuadBounds.width()))
 700         right = LayoutUnit::max() / 2;
 701     else
 702         right = clampEdgeValue(ceilf(mappedQuadBounds.maxX()));
 703 
 704     float bottom;
 705     if (std::isinf(mappedQuadBounds.y()) &amp;&amp; std::isinf(mappedQuadBounds.height()))
 706         bottom = LayoutUnit::max() / 2;
 707     else
 708         bottom = clampEdgeValue(ceilf(mappedQuadBounds.maxY()));
 709 
 710     return LayoutRect(LayoutUnit::clamp(left), LayoutUnit::clamp(top),  LayoutUnit::clamp(right - left), LayoutUnit::clamp(bottom - top));
 711 }
 712 
 713 void TransformationMatrix::map4ComponentPoint(double&amp; x, double&amp; y, double&amp; z, double&amp; w) const
 714 {
 715     if (isIdentityOrTranslation()) {
 716         x += m_matrix[3][0];
 717         y += m_matrix[3][1];
 718         z += m_matrix[3][2];
 719         return;
 720     }
 721 
 722     Vector4 input = { x, y, z, w };
 723     Vector4 result;
 724     v4MulPointByMatrix(input, m_matrix, result);
 725 
 726     x = result[0];
 727     y = result[1];
 728     z = result[2];
 729     w = result[3];
 730 }
 731 
 732 FloatPoint TransformationMatrix::mapPoint(const FloatPoint&amp; p) const
 733 {
 734     if (isIdentityOrTranslation())
 735         return FloatPoint(p.x() + static_cast&lt;float&gt;(m_matrix[3][0]), p.y() + static_cast&lt;float&gt;(m_matrix[3][1]));
 736 
 737     return internalMapPoint(p);
 738 }
 739 
 740 FloatPoint3D TransformationMatrix::mapPoint(const FloatPoint3D&amp; p) const
 741 {
 742     if (isIdentityOrTranslation())
 743         return FloatPoint3D(p.x() + static_cast&lt;float&gt;(m_matrix[3][0]),
 744                             p.y() + static_cast&lt;float&gt;(m_matrix[3][1]),
 745                             p.z() + static_cast&lt;float&gt;(m_matrix[3][2]));
 746 
 747     return internalMapPoint(p);
 748 }
 749 
 750 IntRect TransformationMatrix::mapRect(const IntRect &amp;rect) const
 751 {
 752     return enclosingIntRect(mapRect(FloatRect(rect)));
 753 }
 754 
 755 LayoutRect TransformationMatrix::mapRect(const LayoutRect&amp; r) const
 756 {
 757     return enclosingLayoutRect(mapRect(FloatRect(r)));
 758 }
 759 
 760 FloatRect TransformationMatrix::mapRect(const FloatRect&amp; r) const
 761 {
 762     if (isIdentityOrTranslation()) {
 763         FloatRect mappedRect(r);
 764         mappedRect.move(static_cast&lt;float&gt;(m_matrix[3][0]), static_cast&lt;float&gt;(m_matrix[3][1]));
 765         return mappedRect;
 766     }
 767 
 768     FloatQuad result;
 769 
 770     float maxX = r.maxX();
 771     float maxY = r.maxY();
 772     result.setP1(internalMapPoint(FloatPoint(r.x(), r.y())));
 773     result.setP2(internalMapPoint(FloatPoint(maxX, r.y())));
 774     result.setP3(internalMapPoint(FloatPoint(maxX, maxY)));
 775     result.setP4(internalMapPoint(FloatPoint(r.x(), maxY)));
 776 
 777     return result.boundingBox();
 778 }
 779 
 780 FloatQuad TransformationMatrix::mapQuad(const FloatQuad&amp; q) const
 781 {
 782     if (isIdentityOrTranslation()) {
 783         FloatQuad mappedQuad(q);
 784         mappedQuad.move(static_cast&lt;float&gt;(m_matrix[3][0]), static_cast&lt;float&gt;(m_matrix[3][1]));
 785         return mappedQuad;
 786     }
 787 
 788     FloatQuad result;
 789     result.setP1(internalMapPoint(q.p1()));
 790     result.setP2(internalMapPoint(q.p2()));
 791     result.setP3(internalMapPoint(q.p3()));
 792     result.setP4(internalMapPoint(q.p4()));
 793     return result;
 794 }
 795 
 796 TransformationMatrix&amp; TransformationMatrix::scaleNonUniform(double sx, double sy)
 797 {
 798     m_matrix[0][0] *= sx;
 799     m_matrix[0][1] *= sx;
 800     m_matrix[0][2] *= sx;
 801     m_matrix[0][3] *= sx;
 802 
 803     m_matrix[1][0] *= sy;
 804     m_matrix[1][1] *= sy;
 805     m_matrix[1][2] *= sy;
 806     m_matrix[1][3] *= sy;
 807     return *this;
 808 }
 809 
 810 TransformationMatrix&amp; TransformationMatrix::scale3d(double sx, double sy, double sz)
 811 {
 812     scaleNonUniform(sx, sy);
 813 
 814     m_matrix[2][0] *= sz;
 815     m_matrix[2][1] *= sz;
 816     m_matrix[2][2] *= sz;
 817     m_matrix[2][3] *= sz;
 818     return *this;
 819 }
 820 
 821 TransformationMatrix&amp; TransformationMatrix::rotate3d(double x, double y, double z, double angle)
 822 {
 823     // Normalize the axis of rotation
<a name="4" id="anc4"></a><span class="line-modified"> 824 #if PLATFORM(JAVA)</span>
<span class="line-added"> 825     double length = javamath::hypot(x, y, z);</span>
<span class="line-added"> 826 #else</span>
<span class="line-added"> 827     double length = std::hypot(x, y, z);</span>
<span class="line-added"> 828 #endif</span>
 829     if (length == 0) {
 830         // A direction vector that cannot be normalized, such as [0, 0, 0], will cause the rotation to not be applied.
 831         return *this;
 832     } else if (length != 1) {
 833         x /= length;
 834         y /= length;
 835         z /= length;
 836     }
 837 
 838     // Angles are in degrees. Switch to radians.
 839     angle = deg2rad(angle);
 840 
 841     double sinTheta = sin(angle);
 842     double cosTheta = cos(angle);
 843 
 844     TransformationMatrix mat;
 845 
 846     // Optimize cases where the axis is along a major axis
 847     if (x == 1.0 &amp;&amp; y == 0.0 &amp;&amp; z == 0.0) {
 848         mat.m_matrix[0][0] = 1.0;
 849         mat.m_matrix[0][1] = 0.0;
 850         mat.m_matrix[0][2] = 0.0;
 851         mat.m_matrix[1][0] = 0.0;
 852         mat.m_matrix[1][1] = cosTheta;
 853         mat.m_matrix[1][2] = sinTheta;
 854         mat.m_matrix[2][0] = 0.0;
 855         mat.m_matrix[2][1] = -sinTheta;
 856         mat.m_matrix[2][2] = cosTheta;
 857         mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 858         mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 859         mat.m_matrix[3][3] = 1.0;
 860     } else if (x == 0.0 &amp;&amp; y == 1.0 &amp;&amp; z == 0.0) {
 861         mat.m_matrix[0][0] = cosTheta;
 862         mat.m_matrix[0][1] = 0.0;
 863         mat.m_matrix[0][2] = -sinTheta;
 864         mat.m_matrix[1][0] = 0.0;
 865         mat.m_matrix[1][1] = 1.0;
 866         mat.m_matrix[1][2] = 0.0;
 867         mat.m_matrix[2][0] = sinTheta;
 868         mat.m_matrix[2][1] = 0.0;
 869         mat.m_matrix[2][2] = cosTheta;
 870         mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 871         mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 872         mat.m_matrix[3][3] = 1.0;
 873     } else if (x == 0.0 &amp;&amp; y == 0.0 &amp;&amp; z == 1.0) {
 874         mat.m_matrix[0][0] = cosTheta;
 875         mat.m_matrix[0][1] = sinTheta;
 876         mat.m_matrix[0][2] = 0.0;
 877         mat.m_matrix[1][0] = -sinTheta;
 878         mat.m_matrix[1][1] = cosTheta;
 879         mat.m_matrix[1][2] = 0.0;
 880         mat.m_matrix[2][0] = 0.0;
 881         mat.m_matrix[2][1] = 0.0;
 882         mat.m_matrix[2][2] = 1.0;
 883         mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 884         mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 885         mat.m_matrix[3][3] = 1.0;
 886     } else {
 887         // This case is the rotation about an arbitrary unit vector.
 888         //
 889         // Formula is adapted from Wikipedia article on Rotation matrix,
 890         // http://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle
 891         //
 892         // An alternate resource with the same matrix: http://www.fastgraph.com/makegames/3drotation/
 893         //
 894         double oneMinusCosTheta = 1 - cosTheta;
 895         mat.m_matrix[0][0] = cosTheta + x * x * oneMinusCosTheta;
 896         mat.m_matrix[0][1] = y * x * oneMinusCosTheta + z * sinTheta;
 897         mat.m_matrix[0][2] = z * x * oneMinusCosTheta - y * sinTheta;
 898         mat.m_matrix[1][0] = x * y * oneMinusCosTheta - z * sinTheta;
 899         mat.m_matrix[1][1] = cosTheta + y * y * oneMinusCosTheta;
 900         mat.m_matrix[1][2] = z * y * oneMinusCosTheta + x * sinTheta;
 901         mat.m_matrix[2][0] = x * z * oneMinusCosTheta + y * sinTheta;
 902         mat.m_matrix[2][1] = y * z * oneMinusCosTheta - x * sinTheta;
 903         mat.m_matrix[2][2] = cosTheta + z * z * oneMinusCosTheta;
 904         mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 905         mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 906         mat.m_matrix[3][3] = 1.0;
 907     }
 908     multiply(mat);
 909     return *this;
 910 }
 911 
 912 TransformationMatrix&amp; TransformationMatrix::rotate3d(double rx, double ry, double rz)
 913 {
 914     // Angles are in degrees. Switch to radians.
 915     rx = deg2rad(rx);
 916     ry = deg2rad(ry);
 917     rz = deg2rad(rz);
 918 
 919     TransformationMatrix mat;
 920 
 921     double sinTheta = sin(rz);
 922     double cosTheta = cos(rz);
 923 
 924     mat.m_matrix[0][0] = cosTheta;
 925     mat.m_matrix[0][1] = sinTheta;
 926     mat.m_matrix[0][2] = 0.0;
 927     mat.m_matrix[1][0] = -sinTheta;
 928     mat.m_matrix[1][1] = cosTheta;
 929     mat.m_matrix[1][2] = 0.0;
 930     mat.m_matrix[2][0] = 0.0;
 931     mat.m_matrix[2][1] = 0.0;
 932     mat.m_matrix[2][2] = 1.0;
 933     mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 934     mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 935     mat.m_matrix[3][3] = 1.0;
 936 
 937     TransformationMatrix rmat(mat);
 938 
 939     sinTheta = sin(ry);
 940     cosTheta = cos(ry);
 941 
 942     mat.m_matrix[0][0] = cosTheta;
 943     mat.m_matrix[0][1] = 0.0;
 944     mat.m_matrix[0][2] = -sinTheta;
 945     mat.m_matrix[1][0] = 0.0;
 946     mat.m_matrix[1][1] = 1.0;
 947     mat.m_matrix[1][2] = 0.0;
 948     mat.m_matrix[2][0] = sinTheta;
 949     mat.m_matrix[2][1] = 0.0;
 950     mat.m_matrix[2][2] = cosTheta;
 951     mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 952     mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 953     mat.m_matrix[3][3] = 1.0;
 954 
 955     rmat.multiply(mat);
 956 
 957     sinTheta = sin(rx);
 958     cosTheta = cos(rx);
 959 
 960     mat.m_matrix[0][0] = 1.0;
 961     mat.m_matrix[0][1] = 0.0;
 962     mat.m_matrix[0][2] = 0.0;
 963     mat.m_matrix[1][0] = 0.0;
 964     mat.m_matrix[1][1] = cosTheta;
 965     mat.m_matrix[1][2] = sinTheta;
 966     mat.m_matrix[2][0] = 0.0;
 967     mat.m_matrix[2][1] = -sinTheta;
 968     mat.m_matrix[2][2] = cosTheta;
 969     mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 970     mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 971     mat.m_matrix[3][3] = 1.0;
 972 
 973     rmat.multiply(mat);
 974 
 975     multiply(rmat);
 976     return *this;
 977 }
 978 
 979 TransformationMatrix&amp; TransformationMatrix::translate(double tx, double ty)
 980 {
 981     m_matrix[3][0] += tx * m_matrix[0][0] + ty * m_matrix[1][0];
 982     m_matrix[3][1] += tx * m_matrix[0][1] + ty * m_matrix[1][1];
 983     m_matrix[3][2] += tx * m_matrix[0][2] + ty * m_matrix[1][2];
 984     m_matrix[3][3] += tx * m_matrix[0][3] + ty * m_matrix[1][3];
 985     return *this;
 986 }
 987 
 988 TransformationMatrix&amp; TransformationMatrix::translate3d(double tx, double ty, double tz)
 989 {
 990     m_matrix[3][0] += tx * m_matrix[0][0] + ty * m_matrix[1][0] + tz * m_matrix[2][0];
 991     m_matrix[3][1] += tx * m_matrix[0][1] + ty * m_matrix[1][1] + tz * m_matrix[2][1];
 992     m_matrix[3][2] += tx * m_matrix[0][2] + ty * m_matrix[1][2] + tz * m_matrix[2][2];
 993     m_matrix[3][3] += tx * m_matrix[0][3] + ty * m_matrix[1][3] + tz * m_matrix[2][3];
 994     return *this;
 995 }
 996 
 997 TransformationMatrix&amp; TransformationMatrix::translateRight(double tx, double ty)
 998 {
 999     if (tx != 0) {
1000         m_matrix[0][0] +=  m_matrix[0][3] * tx;
1001         m_matrix[1][0] +=  m_matrix[1][3] * tx;
1002         m_matrix[2][0] +=  m_matrix[2][3] * tx;
1003         m_matrix[3][0] +=  m_matrix[3][3] * tx;
1004     }
1005 
1006     if (ty != 0) {
1007         m_matrix[0][1] +=  m_matrix[0][3] * ty;
1008         m_matrix[1][1] +=  m_matrix[1][3] * ty;
1009         m_matrix[2][1] +=  m_matrix[2][3] * ty;
1010         m_matrix[3][1] +=  m_matrix[3][3] * ty;
1011     }
1012 
1013     return *this;
1014 }
1015 
1016 TransformationMatrix&amp; TransformationMatrix::translateRight3d(double tx, double ty, double tz)
1017 {
1018     translateRight(tx, ty);
1019     if (tz != 0) {
1020         m_matrix[0][2] +=  m_matrix[0][3] * tz;
1021         m_matrix[1][2] +=  m_matrix[1][3] * tz;
1022         m_matrix[2][2] +=  m_matrix[2][3] * tz;
1023         m_matrix[3][2] +=  m_matrix[3][3] * tz;
1024     }
1025 
1026     return *this;
1027 }
1028 
1029 TransformationMatrix&amp; TransformationMatrix::skew(double sx, double sy)
1030 {
1031     // angles are in degrees. Switch to radians
1032     sx = deg2rad(sx);
1033     sy = deg2rad(sy);
1034 
1035     TransformationMatrix mat;
1036     mat.m_matrix[0][1] = tan(sy); // note that the y shear goes in the first row
1037     mat.m_matrix[1][0] = tan(sx); // and the x shear in the second row
1038 
1039     multiply(mat);
1040     return *this;
1041 }
1042 
1043 TransformationMatrix&amp; TransformationMatrix::applyPerspective(double p)
1044 {
1045     TransformationMatrix mat;
1046     if (p != 0)
1047         mat.m_matrix[2][3] = -1/p;
1048 
1049     multiply(mat);
1050     return *this;
1051 }
1052 
1053 TransformationMatrix TransformationMatrix::rectToRect(const FloatRect&amp; from, const FloatRect&amp; to)
1054 {
1055     ASSERT(!from.isEmpty());
1056     return TransformationMatrix(to.width() / from.width(),
1057                                 0, 0,
1058                                 to.height() / from.height(),
1059                                 to.x() - from.x(),
1060                                 to.y() - from.y());
1061 }
1062 
1063 // this = mat * this.
1064 TransformationMatrix&amp; TransformationMatrix::multiply(const TransformationMatrix&amp; mat)
1065 {
1066 #if CPU(ARM64) &amp;&amp; defined(_LP64)
1067     double* leftMatrix = &amp;(m_matrix[0][0]);
1068     const double* rightMatrix = &amp;(mat.m_matrix[0][0]);
1069     asm volatile (
1070         // First, load the leftMatrix completely in memory. The leftMatrix is in v16-v23.
1071         &quot;mov   x4, %[leftMatrix]\n\t&quot;
1072         &quot;ld1   {v16.2d, v17.2d, v18.2d, v19.2d}, [%[leftMatrix]], #64\n\t&quot;
1073         &quot;ld1   {v20.2d, v21.2d, v22.2d, v23.2d}, [%[leftMatrix]]\n\t&quot;
1074 
1075         // First row.
1076         &quot;ld4r  {v24.2d, v25.2d, v26.2d, v27.2d}, [%[rightMatrix]], #32\n\t&quot;
1077         &quot;fmul  v28.2d, v24.2d, v16.2d\n\t&quot;
1078         &quot;fmul  v29.2d, v24.2d, v17.2d\n\t&quot;
1079         &quot;fmla  v28.2d, v25.2d, v18.2d\n\t&quot;
1080         &quot;fmla  v29.2d, v25.2d, v19.2d\n\t&quot;
1081         &quot;fmla  v28.2d, v26.2d, v20.2d\n\t&quot;
1082         &quot;fmla  v29.2d, v26.2d, v21.2d\n\t&quot;
1083         &quot;fmla  v28.2d, v27.2d, v22.2d\n\t&quot;
1084         &quot;fmla  v29.2d, v27.2d, v23.2d\n\t&quot;
1085 
1086         &quot;ld4r  {v0.2d, v1.2d, v2.2d, v3.2d}, [%[rightMatrix]], #32\n\t&quot;
1087         &quot;st1  {v28.2d, v29.2d}, [x4], #32\n\t&quot;
1088 
1089         // Second row.
1090         &quot;fmul  v30.2d, v0.2d, v16.2d\n\t&quot;
1091         &quot;fmul  v31.2d, v0.2d, v17.2d\n\t&quot;
1092         &quot;fmla  v30.2d, v1.2d, v18.2d\n\t&quot;
1093         &quot;fmla  v31.2d, v1.2d, v19.2d\n\t&quot;
1094         &quot;fmla  v30.2d, v2.2d, v20.2d\n\t&quot;
1095         &quot;fmla  v31.2d, v2.2d, v21.2d\n\t&quot;
1096         &quot;fmla  v30.2d, v3.2d, v22.2d\n\t&quot;
1097         &quot;fmla  v31.2d, v3.2d, v23.2d\n\t&quot;
1098 
1099         &quot;ld4r  {v24.2d, v25.2d, v26.2d, v27.2d}, [%[rightMatrix]], #32\n\t&quot;
1100         &quot;st1   {v30.2d, v31.2d}, [x4], #32\n\t&quot;
1101 
1102         // Third row.
1103         &quot;fmul  v28.2d, v24.2d, v16.2d\n\t&quot;
1104         &quot;fmul  v29.2d, v24.2d, v17.2d\n\t&quot;
1105         &quot;fmla  v28.2d, v25.2d, v18.2d\n\t&quot;
1106         &quot;fmla  v29.2d, v25.2d, v19.2d\n\t&quot;
1107         &quot;fmla  v28.2d, v26.2d, v20.2d\n\t&quot;
1108         &quot;fmla  v29.2d, v26.2d, v21.2d\n\t&quot;
1109         &quot;fmla  v28.2d, v27.2d, v22.2d\n\t&quot;
1110         &quot;fmla  v29.2d, v27.2d, v23.2d\n\t&quot;
1111 
1112         &quot;ld4r  {v0.2d, v1.2d, v2.2d, v3.2d}, [%[rightMatrix]], #32\n\t&quot;
1113         &quot;st1   {v28.2d, v29.2d}, [x4], #32\n\t&quot;
1114 
1115         // Fourth row.
1116         &quot;fmul  v30.2d, v0.2d, v16.2d\n\t&quot;
1117         &quot;fmul  v31.2d, v0.2d, v17.2d\n\t&quot;
1118         &quot;fmla  v30.2d, v1.2d, v18.2d\n\t&quot;
1119         &quot;fmla  v31.2d, v1.2d, v19.2d\n\t&quot;
1120         &quot;fmla  v30.2d, v2.2d, v20.2d\n\t&quot;
1121         &quot;fmla  v31.2d, v2.2d, v21.2d\n\t&quot;
1122         &quot;fmla  v30.2d, v3.2d, v22.2d\n\t&quot;
1123         &quot;fmla  v31.2d, v3.2d, v23.2d\n\t&quot;
1124 
1125         &quot;st1  {v30.2d, v31.2d}, [x4]\n\t&quot;
1126 
1127         : [leftMatrix]&quot;+r&quot;(leftMatrix), [rightMatrix]&quot;+r&quot;(rightMatrix)
1128         :
1129         : &quot;memory&quot;, &quot;x4&quot;, &quot;v0&quot;, &quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot;, &quot;v16&quot;, &quot;v17&quot;, &quot;v18&quot;, &quot;v19&quot;, &quot;v20&quot;, &quot;v21&quot;, &quot;v22&quot;, &quot;v23&quot;, &quot;v24&quot;, &quot;v25&quot;, &quot;v26&quot;, &quot;v27&quot;, &quot;v28&quot;, &quot;v29&quot;, &quot;v30&quot;, &quot;v31&quot;);
1130 #elif CPU(APPLE_ARMV7S)
1131     double* leftMatrix = &amp;(m_matrix[0][0]);
1132     const double* rightMatrix = &amp;(mat.m_matrix[0][0]);
1133     asm volatile (// First row of leftMatrix.
1134         &quot;mov        r3, %[leftMatrix]\n\t&quot;
1135         &quot;vld1.64    { d16-d19 }, [%[leftMatrix], :128]!\n\t&quot;
1136         &quot;vld1.64    { d0-d3}, [%[rightMatrix], :128]!\n\t&quot;
1137         &quot;vmul.f64   d4, d0, d16\n\t&quot;
1138         &quot;vld1.64    { d20-d23 }, [%[leftMatrix], :128]!\n\t&quot;
1139         &quot;vmla.f64   d4, d1, d20\n\t&quot;
1140         &quot;vld1.64    { d24-d27 }, [%[leftMatrix], :128]!\n\t&quot;
1141         &quot;vmla.f64   d4, d2, d24\n\t&quot;
1142         &quot;vld1.64    { d28-d31 }, [%[leftMatrix], :128]!\n\t&quot;
1143         &quot;vmla.f64   d4, d3, d28\n\t&quot;
1144 
1145         &quot;vmul.f64   d5, d0, d17\n\t&quot;
1146         &quot;vmla.f64   d5, d1, d21\n\t&quot;
1147         &quot;vmla.f64   d5, d2, d25\n\t&quot;
1148         &quot;vmla.f64   d5, d3, d29\n\t&quot;
1149 
1150         &quot;vmul.f64   d6, d0, d18\n\t&quot;
1151         &quot;vmla.f64   d6, d1, d22\n\t&quot;
1152         &quot;vmla.f64   d6, d2, d26\n\t&quot;
1153         &quot;vmla.f64   d6, d3, d30\n\t&quot;
1154 
1155         &quot;vmul.f64   d7, d0, d19\n\t&quot;
1156         &quot;vmla.f64   d7, d1, d23\n\t&quot;
1157         &quot;vmla.f64   d7, d2, d27\n\t&quot;
1158         &quot;vmla.f64   d7, d3, d31\n\t&quot;
1159         &quot;vld1.64    { d0-d3}, [%[rightMatrix], :128]!\n\t&quot;
1160         &quot;vst1.64    { d4-d7 }, [r3, :128]!\n\t&quot;
1161 
1162         // Second row of leftMatrix.
1163         &quot;vmul.f64   d4, d0, d16\n\t&quot;
1164         &quot;vmla.f64   d4, d1, d20\n\t&quot;
1165         &quot;vmla.f64   d4, d2, d24\n\t&quot;
1166         &quot;vmla.f64   d4, d3, d28\n\t&quot;
1167 
1168         &quot;vmul.f64   d5, d0, d17\n\t&quot;
1169         &quot;vmla.f64   d5, d1, d21\n\t&quot;
1170         &quot;vmla.f64   d5, d2, d25\n\t&quot;
1171         &quot;vmla.f64   d5, d3, d29\n\t&quot;
1172 
1173         &quot;vmul.f64   d6, d0, d18\n\t&quot;
1174         &quot;vmla.f64   d6, d1, d22\n\t&quot;
1175         &quot;vmla.f64   d6, d2, d26\n\t&quot;
1176         &quot;vmla.f64   d6, d3, d30\n\t&quot;
1177 
1178         &quot;vmul.f64   d7, d0, d19\n\t&quot;
1179         &quot;vmla.f64   d7, d1, d23\n\t&quot;
1180         &quot;vmla.f64   d7, d2, d27\n\t&quot;
1181         &quot;vmla.f64   d7, d3, d31\n\t&quot;
1182         &quot;vld1.64    { d0-d3}, [%[rightMatrix], :128]!\n\t&quot;
1183         &quot;vst1.64    { d4-d7 }, [r3, :128]!\n\t&quot;
1184 
1185         // Third row of leftMatrix.
1186         &quot;vmul.f64   d4, d0, d16\n\t&quot;
1187         &quot;vmla.f64   d4, d1, d20\n\t&quot;
1188         &quot;vmla.f64   d4, d2, d24\n\t&quot;
1189         &quot;vmla.f64   d4, d3, d28\n\t&quot;
1190 
1191         &quot;vmul.f64   d5, d0, d17\n\t&quot;
1192         &quot;vmla.f64   d5, d1, d21\n\t&quot;
1193         &quot;vmla.f64   d5, d2, d25\n\t&quot;
1194         &quot;vmla.f64   d5, d3, d29\n\t&quot;
1195 
1196         &quot;vmul.f64   d6, d0, d18\n\t&quot;
1197         &quot;vmla.f64   d6, d1, d22\n\t&quot;
1198         &quot;vmla.f64   d6, d2, d26\n\t&quot;
1199         &quot;vmla.f64   d6, d3, d30\n\t&quot;
1200 
1201         &quot;vmul.f64   d7, d0, d19\n\t&quot;
1202         &quot;vmla.f64   d7, d1, d23\n\t&quot;
1203         &quot;vmla.f64   d7, d2, d27\n\t&quot;
1204         &quot;vmla.f64   d7, d3, d31\n\t&quot;
1205         &quot;vld1.64    { d0-d3}, [%[rightMatrix], :128]\n\t&quot;
1206         &quot;vst1.64    { d4-d7 }, [r3, :128]!\n\t&quot;
1207 
1208         // Fourth and last row of leftMatrix.
1209         &quot;vmul.f64   d4, d0, d16\n\t&quot;
1210         &quot;vmla.f64   d4, d1, d20\n\t&quot;
1211         &quot;vmla.f64   d4, d2, d24\n\t&quot;
1212         &quot;vmla.f64   d4, d3, d28\n\t&quot;
1213 
1214         &quot;vmul.f64   d5, d0, d17\n\t&quot;
1215         &quot;vmla.f64   d5, d1, d21\n\t&quot;
1216         &quot;vmla.f64   d5, d2, d25\n\t&quot;
1217         &quot;vmla.f64   d5, d3, d29\n\t&quot;
1218 
1219         &quot;vmul.f64   d6, d0, d18\n\t&quot;
1220         &quot;vmla.f64   d6, d1, d22\n\t&quot;
1221         &quot;vmla.f64   d6, d2, d26\n\t&quot;
1222         &quot;vmla.f64   d6, d3, d30\n\t&quot;
1223 
1224         &quot;vmul.f64   d7, d0, d19\n\t&quot;
1225         &quot;vmla.f64   d7, d1, d23\n\t&quot;
1226         &quot;vmla.f64   d7, d2, d27\n\t&quot;
1227         &quot;vmla.f64   d7, d3, d31\n\t&quot;
1228         &quot;vst1.64    { d4-d7 }, [r3, :128]\n\t&quot;
1229         : [leftMatrix]&quot;+r&quot;(leftMatrix), [rightMatrix]&quot;+r&quot;(rightMatrix)
1230         :
1231         : &quot;memory&quot;, &quot;r3&quot;, &quot;d0&quot;, &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot;, &quot;d5&quot;, &quot;d6&quot;, &quot;d7&quot;, &quot;d16&quot;, &quot;d17&quot;, &quot;d18&quot;, &quot;d19&quot;, &quot;d20&quot;, &quot;d21&quot;, &quot;d22&quot;, &quot;d23&quot;, &quot;d24&quot;, &quot;d25&quot;, &quot;d26&quot;, &quot;d27&quot;, &quot;d28&quot;, &quot;d29&quot;, &quot;d30&quot;, &quot;d31&quot;);
1232 #elif CPU(ARM_VFP) &amp;&amp; PLATFORM(IOS_FAMILY)
1233 
1234 #define MATRIX_MULTIPLY_ONE_LINE \
1235     &quot;vldmia.64  %[rightMatrix]!, { d0-d3}\n\t&quot; \
1236     &quot;vmul.f64   d4, d0, d16\n\t&quot; \
1237     &quot;vmla.f64   d4, d1, d20\n\t&quot; \
1238     &quot;vmla.f64   d4, d2, d24\n\t&quot; \
1239     &quot;vmla.f64   d4, d3, d28\n\t&quot; \
1240     \
1241     &quot;vmul.f64   d5, d0, d17\n\t&quot; \
1242     &quot;vmla.f64   d5, d1, d21\n\t&quot; \
1243     &quot;vmla.f64   d5, d2, d25\n\t&quot; \
1244     &quot;vmla.f64   d5, d3, d29\n\t&quot; \
1245     \
1246     &quot;vmul.f64   d6, d0, d18\n\t&quot; \
1247     &quot;vmla.f64   d6, d1, d22\n\t&quot; \
1248     &quot;vmla.f64   d6, d2, d26\n\t&quot; \
1249     &quot;vmla.f64   d6, d3, d30\n\t&quot; \
1250     \
1251     &quot;vmul.f64   d7, d0, d19\n\t&quot; \
1252     &quot;vmla.f64   d7, d1, d23\n\t&quot; \
1253     &quot;vmla.f64   d7, d2, d27\n\t&quot; \
1254     &quot;vmla.f64   d7, d3, d31\n\t&quot; \
1255     &quot;vstmia.64  %[leftMatrix]!, { d4-d7 }\n\t&quot;
1256 
1257     double* leftMatrix = &amp;(m_matrix[0][0]);
1258     const double* rightMatrix = &amp;(mat.m_matrix[0][0]);
1259     // We load the full m_matrix at once in d16-d31.
1260     asm volatile(&quot;vldmia.64  %[leftMatrix], { d16-d31 }\n\t&quot;
1261                  :
1262                  : [leftMatrix]&quot;r&quot;(leftMatrix)
1263                  : &quot;d16&quot;, &quot;d17&quot;, &quot;d18&quot;, &quot;d19&quot;, &quot;d20&quot;, &quot;d21&quot;, &quot;d22&quot;, &quot;d23&quot;, &quot;d24&quot;, &quot;d25&quot;, &quot;d26&quot;, &quot;d27&quot;, &quot;d28&quot;, &quot;d29&quot;, &quot;d30&quot;, &quot;d31&quot;);
1264     for (unsigned i = 0; i &lt; 4; ++i) {
1265         asm volatile(MATRIX_MULTIPLY_ONE_LINE
1266                      : [leftMatrix]&quot;+r&quot;(leftMatrix), [rightMatrix]&quot;+r&quot;(rightMatrix)
1267                      :
1268                      : &quot;memory&quot;, &quot;d0&quot;, &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot;, &quot;d5&quot;, &quot;d6&quot;, &quot;d7&quot;);
1269     }
1270 #undef MATRIX_MULTIPLY_ONE_LINE
1271 
1272 #elif defined(TRANSFORMATION_MATRIX_USE_X86_64_SSE2)
1273     // x86_64 has 16 XMM registers which is enough to do the multiplication fully in registers.
1274     __m128d matrixBlockA = _mm_load_pd(&amp;(m_matrix[0][0]));
1275     __m128d matrixBlockC = _mm_load_pd(&amp;(m_matrix[1][0]));
1276     __m128d matrixBlockE = _mm_load_pd(&amp;(m_matrix[2][0]));
1277     __m128d matrixBlockG = _mm_load_pd(&amp;(m_matrix[3][0]));
1278 
1279     // First row.
1280     __m128d otherMatrixFirstParam = _mm_set1_pd(mat.m_matrix[0][0]);
1281     __m128d otherMatrixSecondParam = _mm_set1_pd(mat.m_matrix[0][1]);
1282     __m128d otherMatrixThirdParam = _mm_set1_pd(mat.m_matrix[0][2]);
1283     __m128d otherMatrixFourthParam = _mm_set1_pd(mat.m_matrix[0][3]);
1284 
1285     // output00 and output01.
1286     __m128d accumulator = _mm_mul_pd(matrixBlockA, otherMatrixFirstParam);
1287     __m128d temp1 = _mm_mul_pd(matrixBlockC, otherMatrixSecondParam);
1288     __m128d temp2 = _mm_mul_pd(matrixBlockE, otherMatrixThirdParam);
1289     __m128d temp3 = _mm_mul_pd(matrixBlockG, otherMatrixFourthParam);
1290 
1291     __m128d matrixBlockB = _mm_load_pd(&amp;(m_matrix[0][2]));
1292     __m128d matrixBlockD = _mm_load_pd(&amp;(m_matrix[1][2]));
1293     __m128d matrixBlockF = _mm_load_pd(&amp;(m_matrix[2][2]));
1294     __m128d matrixBlockH = _mm_load_pd(&amp;(m_matrix[3][2]));
1295 
1296     accumulator = _mm_add_pd(accumulator, temp1);
1297     accumulator = _mm_add_pd(accumulator, temp2);
1298     accumulator = _mm_add_pd(accumulator, temp3);
1299     _mm_store_pd(&amp;m_matrix[0][0], accumulator);
1300 
1301     // output02 and output03.
1302     accumulator = _mm_mul_pd(matrixBlockB, otherMatrixFirstParam);
1303     temp1 = _mm_mul_pd(matrixBlockD, otherMatrixSecondParam);
1304     temp2 = _mm_mul_pd(matrixBlockF, otherMatrixThirdParam);
1305     temp3 = _mm_mul_pd(matrixBlockH, otherMatrixFourthParam);
1306 
1307     accumulator = _mm_add_pd(accumulator, temp1);
1308     accumulator = _mm_add_pd(accumulator, temp2);
1309     accumulator = _mm_add_pd(accumulator, temp3);
1310     _mm_store_pd(&amp;m_matrix[0][2], accumulator);
1311 
1312     // Second row.
1313     otherMatrixFirstParam = _mm_set1_pd(mat.m_matrix[1][0]);
1314     otherMatrixSecondParam = _mm_set1_pd(mat.m_matrix[1][1]);
1315     otherMatrixThirdParam = _mm_set1_pd(mat.m_matrix[1][2]);
1316     otherMatrixFourthParam = _mm_set1_pd(mat.m_matrix[1][3]);
1317 
1318     // output10 and output11.
1319     accumulator = _mm_mul_pd(matrixBlockA, otherMatrixFirstParam);
1320     temp1 = _mm_mul_pd(matrixBlockC, otherMatrixSecondParam);
1321     temp2 = _mm_mul_pd(matrixBlockE, otherMatrixThirdParam);
1322     temp3 = _mm_mul_pd(matrixBlockG, otherMatrixFourthParam);
1323 
1324     accumulator = _mm_add_pd(accumulator, temp1);
1325     accumulator = _mm_add_pd(accumulator, temp2);
1326     accumulator = _mm_add_pd(accumulator, temp3);
1327     _mm_store_pd(&amp;m_matrix[1][0], accumulator);
1328 
1329     // output12 and output13.
1330     accumulator = _mm_mul_pd(matrixBlockB, otherMatrixFirstParam);
1331     temp1 = _mm_mul_pd(matrixBlockD, otherMatrixSecondParam);
1332     temp2 = _mm_mul_pd(matrixBlockF, otherMatrixThirdParam);
1333     temp3 = _mm_mul_pd(matrixBlockH, otherMatrixFourthParam);
1334 
1335     accumulator = _mm_add_pd(accumulator, temp1);
1336     accumulator = _mm_add_pd(accumulator, temp2);
1337     accumulator = _mm_add_pd(accumulator, temp3);
1338     _mm_store_pd(&amp;m_matrix[1][2], accumulator);
1339 
1340     // Third row.
1341     otherMatrixFirstParam = _mm_set1_pd(mat.m_matrix[2][0]);
1342     otherMatrixSecondParam = _mm_set1_pd(mat.m_matrix[2][1]);
1343     otherMatrixThirdParam = _mm_set1_pd(mat.m_matrix[2][2]);
1344     otherMatrixFourthParam = _mm_set1_pd(mat.m_matrix[2][3]);
1345 
1346     // output20 and output21.
1347     accumulator = _mm_mul_pd(matrixBlockA, otherMatrixFirstParam);
1348     temp1 = _mm_mul_pd(matrixBlockC, otherMatrixSecondParam);
1349     temp2 = _mm_mul_pd(matrixBlockE, otherMatrixThirdParam);
1350     temp3 = _mm_mul_pd(matrixBlockG, otherMatrixFourthParam);
1351 
1352     accumulator = _mm_add_pd(accumulator, temp1);
1353     accumulator = _mm_add_pd(accumulator, temp2);
1354     accumulator = _mm_add_pd(accumulator, temp3);
1355     _mm_store_pd(&amp;m_matrix[2][0], accumulator);
1356 
1357     // output22 and output23.
1358     accumulator = _mm_mul_pd(matrixBlockB, otherMatrixFirstParam);
1359     temp1 = _mm_mul_pd(matrixBlockD, otherMatrixSecondParam);
1360     temp2 = _mm_mul_pd(matrixBlockF, otherMatrixThirdParam);
1361     temp3 = _mm_mul_pd(matrixBlockH, otherMatrixFourthParam);
1362 
1363     accumulator = _mm_add_pd(accumulator, temp1);
1364     accumulator = _mm_add_pd(accumulator, temp2);
1365     accumulator = _mm_add_pd(accumulator, temp3);
1366     _mm_store_pd(&amp;m_matrix[2][2], accumulator);
1367 
1368     // Fourth row.
1369     otherMatrixFirstParam = _mm_set1_pd(mat.m_matrix[3][0]);
1370     otherMatrixSecondParam = _mm_set1_pd(mat.m_matrix[3][1]);
1371     otherMatrixThirdParam = _mm_set1_pd(mat.m_matrix[3][2]);
1372     otherMatrixFourthParam = _mm_set1_pd(mat.m_matrix[3][3]);
1373 
1374     // output30 and output31.
1375     accumulator = _mm_mul_pd(matrixBlockA, otherMatrixFirstParam);
1376     temp1 = _mm_mul_pd(matrixBlockC, otherMatrixSecondParam);
1377     temp2 = _mm_mul_pd(matrixBlockE, otherMatrixThirdParam);
1378     temp3 = _mm_mul_pd(matrixBlockG, otherMatrixFourthParam);
1379 
1380     accumulator = _mm_add_pd(accumulator, temp1);
1381     accumulator = _mm_add_pd(accumulator, temp2);
1382     accumulator = _mm_add_pd(accumulator, temp3);
1383     _mm_store_pd(&amp;m_matrix[3][0], accumulator);
1384 
1385     // output32 and output33.
1386     accumulator = _mm_mul_pd(matrixBlockB, otherMatrixFirstParam);
1387     temp1 = _mm_mul_pd(matrixBlockD, otherMatrixSecondParam);
1388     temp2 = _mm_mul_pd(matrixBlockF, otherMatrixThirdParam);
1389     temp3 = _mm_mul_pd(matrixBlockH, otherMatrixFourthParam);
1390 
1391     accumulator = _mm_add_pd(accumulator, temp1);
1392     accumulator = _mm_add_pd(accumulator, temp2);
1393     accumulator = _mm_add_pd(accumulator, temp3);
1394     _mm_store_pd(&amp;m_matrix[3][2], accumulator);
1395 #else
1396     Matrix4 tmp;
1397 
1398     tmp[0][0] = (mat.m_matrix[0][0] * m_matrix[0][0] + mat.m_matrix[0][1] * m_matrix[1][0]
1399                + mat.m_matrix[0][2] * m_matrix[2][0] + mat.m_matrix[0][3] * m_matrix[3][0]);
1400     tmp[0][1] = (mat.m_matrix[0][0] * m_matrix[0][1] + mat.m_matrix[0][1] * m_matrix[1][1]
1401                + mat.m_matrix[0][2] * m_matrix[2][1] + mat.m_matrix[0][3] * m_matrix[3][1]);
1402     tmp[0][2] = (mat.m_matrix[0][0] * m_matrix[0][2] + mat.m_matrix[0][1] * m_matrix[1][2]
1403                + mat.m_matrix[0][2] * m_matrix[2][2] + mat.m_matrix[0][3] * m_matrix[3][2]);
1404     tmp[0][3] = (mat.m_matrix[0][0] * m_matrix[0][3] + mat.m_matrix[0][1] * m_matrix[1][3]
1405                + mat.m_matrix[0][2] * m_matrix[2][3] + mat.m_matrix[0][3] * m_matrix[3][3]);
1406 
1407     tmp[1][0] = (mat.m_matrix[1][0] * m_matrix[0][0] + mat.m_matrix[1][1] * m_matrix[1][0]
1408                + mat.m_matrix[1][2] * m_matrix[2][0] + mat.m_matrix[1][3] * m_matrix[3][0]);
1409     tmp[1][1] = (mat.m_matrix[1][0] * m_matrix[0][1] + mat.m_matrix[1][1] * m_matrix[1][1]
1410                + mat.m_matrix[1][2] * m_matrix[2][1] + mat.m_matrix[1][3] * m_matrix[3][1]);
1411     tmp[1][2] = (mat.m_matrix[1][0] * m_matrix[0][2] + mat.m_matrix[1][1] * m_matrix[1][2]
1412                + mat.m_matrix[1][2] * m_matrix[2][2] + mat.m_matrix[1][3] * m_matrix[3][2]);
1413     tmp[1][3] = (mat.m_matrix[1][0] * m_matrix[0][3] + mat.m_matrix[1][1] * m_matrix[1][3]
1414                + mat.m_matrix[1][2] * m_matrix[2][3] + mat.m_matrix[1][3] * m_matrix[3][3]);
1415 
1416     tmp[2][0] = (mat.m_matrix[2][0] * m_matrix[0][0] + mat.m_matrix[2][1] * m_matrix[1][0]
1417                + mat.m_matrix[2][2] * m_matrix[2][0] + mat.m_matrix[2][3] * m_matrix[3][0]);
1418     tmp[2][1] = (mat.m_matrix[2][0] * m_matrix[0][1] + mat.m_matrix[2][1] * m_matrix[1][1]
1419                + mat.m_matrix[2][2] * m_matrix[2][1] + mat.m_matrix[2][3] * m_matrix[3][1]);
1420     tmp[2][2] = (mat.m_matrix[2][0] * m_matrix[0][2] + mat.m_matrix[2][1] * m_matrix[1][2]
1421                + mat.m_matrix[2][2] * m_matrix[2][2] + mat.m_matrix[2][3] * m_matrix[3][2]);
1422     tmp[2][3] = (mat.m_matrix[2][0] * m_matrix[0][3] + mat.m_matrix[2][1] * m_matrix[1][3]
1423                + mat.m_matrix[2][2] * m_matrix[2][3] + mat.m_matrix[2][3] * m_matrix[3][3]);
1424 
1425     tmp[3][0] = (mat.m_matrix[3][0] * m_matrix[0][0] + mat.m_matrix[3][1] * m_matrix[1][0]
1426                + mat.m_matrix[3][2] * m_matrix[2][0] + mat.m_matrix[3][3] * m_matrix[3][0]);
1427     tmp[3][1] = (mat.m_matrix[3][0] * m_matrix[0][1] + mat.m_matrix[3][1] * m_matrix[1][1]
1428                + mat.m_matrix[3][2] * m_matrix[2][1] + mat.m_matrix[3][3] * m_matrix[3][1]);
1429     tmp[3][2] = (mat.m_matrix[3][0] * m_matrix[0][2] + mat.m_matrix[3][1] * m_matrix[1][2]
1430                + mat.m_matrix[3][2] * m_matrix[2][2] + mat.m_matrix[3][3] * m_matrix[3][2]);
1431     tmp[3][3] = (mat.m_matrix[3][0] * m_matrix[0][3] + mat.m_matrix[3][1] * m_matrix[1][3]
1432                + mat.m_matrix[3][2] * m_matrix[2][3] + mat.m_matrix[3][3] * m_matrix[3][3]);
1433 
1434     memcpy(&amp;m_matrix[0][0], &amp;tmp[0][0], sizeof(Matrix4));
1435 #endif
1436     return *this;
1437 }
1438 
1439 void TransformationMatrix::multVecMatrix(double x, double y, double&amp; resultX, double&amp; resultY) const
1440 {
1441     resultX = m_matrix[3][0] + x * m_matrix[0][0] + y * m_matrix[1][0];
1442     resultY = m_matrix[3][1] + x * m_matrix[0][1] + y * m_matrix[1][1];
1443     double w = m_matrix[3][3] + x * m_matrix[0][3] + y * m_matrix[1][3];
1444     if (w != 1 &amp;&amp; w != 0) {
1445         resultX /= w;
1446         resultY /= w;
1447     }
1448 }
1449 
1450 void TransformationMatrix::multVecMatrix(double x, double y, double z, double&amp; resultX, double&amp; resultY, double&amp; resultZ) const
1451 {
1452     resultX = m_matrix[3][0] + x * m_matrix[0][0] + y * m_matrix[1][0] + z * m_matrix[2][0];
1453     resultY = m_matrix[3][1] + x * m_matrix[0][1] + y * m_matrix[1][1] + z * m_matrix[2][1];
1454     resultZ = m_matrix[3][2] + x * m_matrix[0][2] + y * m_matrix[1][2] + z * m_matrix[2][2];
1455     double w = m_matrix[3][3] + x * m_matrix[0][3] + y * m_matrix[1][3] + z * m_matrix[2][3];
1456     if (w != 1 &amp;&amp; w != 0) {
1457         resultX /= w;
1458         resultY /= w;
1459         resultZ /= w;
1460     }
1461 }
1462 
1463 bool TransformationMatrix::isInvertible() const
1464 {
1465     if (isIdentityOrTranslation())
1466         return true;
1467 
1468     double det = WebCore::determinant4x4(m_matrix);
1469 
1470     if (fabs(det) &lt; SMALL_NUMBER)
1471         return false;
1472 
1473     return true;
1474 }
1475 
1476 Optional&lt;TransformationMatrix&gt; TransformationMatrix::inverse() const
1477 {
1478     if (isIdentityOrTranslation()) {
1479         // identity matrix
1480         if (m_matrix[3][0] == 0 &amp;&amp; m_matrix[3][1] == 0 &amp;&amp; m_matrix[3][2] == 0)
1481             return TransformationMatrix();
1482 
1483         // translation
1484         return TransformationMatrix(1, 0, 0, 0,
1485                                     0, 1, 0, 0,
1486                                     0, 0, 1, 0,
1487                                     -m_matrix[3][0], -m_matrix[3][1], -m_matrix[3][2], 1);
1488     }
1489 
1490     TransformationMatrix invMat;
1491     // FIXME: Use LU decomposition to apply the inverse instead of calculating the inverse explicitly.
1492     // Calculating the inverse of a 4x4 matrix using cofactors is numerically unstable and unnecessary to apply the inverse transformation to a point.
1493     if (!WebCore::inverse(m_matrix, invMat.m_matrix))
1494         return WTF::nullopt;
1495 
1496     return invMat;
1497 }
1498 
1499 void TransformationMatrix::makeAffine()
1500 {
1501     m_matrix[0][2] = 0;
1502     m_matrix[0][3] = 0;
1503 
1504     m_matrix[1][2] = 0;
1505     m_matrix[1][3] = 0;
1506 
1507     m_matrix[2][0] = 0;
1508     m_matrix[2][1] = 0;
1509     m_matrix[2][2] = 1;
1510     m_matrix[2][3] = 0;
1511 
1512     m_matrix[3][2] = 0;
1513     m_matrix[3][3] = 1;
1514 }
1515 
1516 AffineTransform TransformationMatrix::toAffineTransform() const
1517 {
1518     return AffineTransform(m_matrix[0][0], m_matrix[0][1], m_matrix[1][0],
1519                            m_matrix[1][1], m_matrix[3][0], m_matrix[3][1]);
1520 }
1521 
1522 static inline void blendFloat(double&amp; from, double to, double progress)
1523 {
1524     if (from != to)
1525         from = from + (to - from) * progress;
1526 }
1527 
1528 void TransformationMatrix::blend2(const TransformationMatrix&amp; from, double progress)
1529 {
1530     Decomposed2Type fromDecomp;
1531     Decomposed2Type toDecomp;
1532     if (!from.decompose2(fromDecomp) || !decompose2(toDecomp)) {
1533         if (progress &lt; 0.5)
1534             *this = from;
1535         return;
1536     }
1537 
1538     // If x-axis of one is flipped, and y-axis of the other, convert to an unflipped rotation.
1539     if ((fromDecomp.scaleX &lt; 0 &amp;&amp; toDecomp.scaleY &lt; 0) || (fromDecomp.scaleY &lt; 0 &amp;&amp; toDecomp.scaleX &lt; 0)) {
1540         fromDecomp.scaleX = -fromDecomp.scaleX;
1541         fromDecomp.scaleY = -fromDecomp.scaleY;
1542         fromDecomp.angle += fromDecomp.angle &lt; 0 ? 180 : -180;
1543     }
1544 
1545     // Don&#39;t rotate the long way around.
1546     if (!fromDecomp.angle)
1547         fromDecomp.angle = 360;
1548     if (!toDecomp.angle)
1549         toDecomp.angle = 360;
1550 
1551     if (fabs(fromDecomp.angle - toDecomp.angle) &gt; 180) {
1552         if (fromDecomp.angle &gt; toDecomp.angle)
1553             fromDecomp.angle -= 360;
1554         else
1555             toDecomp.angle -= 360;
1556     }
1557 
1558     blendFloat(fromDecomp.m11, toDecomp.m11, progress);
1559     blendFloat(fromDecomp.m12, toDecomp.m12, progress);
1560     blendFloat(fromDecomp.m21, toDecomp.m21, progress);
1561     blendFloat(fromDecomp.m22, toDecomp.m22, progress);
1562     blendFloat(fromDecomp.translateX, toDecomp.translateX, progress);
1563     blendFloat(fromDecomp.translateY, toDecomp.translateY, progress);
1564     blendFloat(fromDecomp.scaleX, toDecomp.scaleX, progress);
1565     blendFloat(fromDecomp.scaleY, toDecomp.scaleY, progress);
1566     blendFloat(fromDecomp.angle, toDecomp.angle, progress);
1567 
1568     recompose2(fromDecomp);
1569 }
1570 
1571 void TransformationMatrix::blend4(const TransformationMatrix&amp; from, double progress)
1572 {
1573     Decomposed4Type fromDecomp;
1574     Decomposed4Type toDecomp;
1575     if (!from.decompose4(fromDecomp) || !decompose4(toDecomp)) {
1576         if (progress &lt; 0.5)
1577             *this = from;
1578         return;
1579     }
1580 
1581     blendFloat(fromDecomp.scaleX, toDecomp.scaleX, progress);
1582     blendFloat(fromDecomp.scaleY, toDecomp.scaleY, progress);
1583     blendFloat(fromDecomp.scaleZ, toDecomp.scaleZ, progress);
1584     blendFloat(fromDecomp.skewXY, toDecomp.skewXY, progress);
1585     blendFloat(fromDecomp.skewXZ, toDecomp.skewXZ, progress);
1586     blendFloat(fromDecomp.skewYZ, toDecomp.skewYZ, progress);
1587     blendFloat(fromDecomp.translateX, toDecomp.translateX, progress);
1588     blendFloat(fromDecomp.translateY, toDecomp.translateY, progress);
1589     blendFloat(fromDecomp.translateZ, toDecomp.translateZ, progress);
1590     blendFloat(fromDecomp.perspectiveX, toDecomp.perspectiveX, progress);
1591     blendFloat(fromDecomp.perspectiveY, toDecomp.perspectiveY, progress);
1592     blendFloat(fromDecomp.perspectiveZ, toDecomp.perspectiveZ, progress);
1593     blendFloat(fromDecomp.perspectiveW, toDecomp.perspectiveW, progress);
1594 
1595     slerp(&amp;fromDecomp.quaternionX, &amp;toDecomp.quaternionX, progress);
1596 
1597     recompose4(fromDecomp);
1598 }
1599 
1600 void TransformationMatrix::blend(const TransformationMatrix&amp; from, double progress)
1601 {
1602     if (from.isIdentity() &amp;&amp; isIdentity())
1603         return;
1604 
1605     if (from.isAffine() &amp;&amp; isAffine())
1606         blend2(from, progress);
1607     else
1608         blend4(from, progress);
1609 }
1610 
1611 bool TransformationMatrix::decompose2(Decomposed2Type&amp; decomp) const
1612 {
1613     if (isIdentity()) {
1614         memset(&amp;decomp, 0, sizeof(decomp));
1615         decomp.scaleX = 1;
1616         decomp.scaleY = 1;
1617         decomp.m11 = 1;
1618         decomp.m22 = 1;
1619         return true;
1620     }
1621 
1622     return WebCore::decompose2(m_matrix, decomp);
1623 }
1624 
1625 bool TransformationMatrix::decompose4(Decomposed4Type&amp; decomp) const
1626 {
1627     if (isIdentity()) {
1628         memset(&amp;decomp, 0, sizeof(decomp));
1629         decomp.perspectiveW = 1;
1630         decomp.scaleX = 1;
1631         decomp.scaleY = 1;
1632         decomp.scaleZ = 1;
1633         return true;
1634     }
1635 
1636     return WebCore::decompose4(m_matrix, decomp);
1637 }
1638 
1639 void TransformationMatrix::recompose2(const Decomposed2Type&amp; decomp)
1640 {
1641     makeIdentity();
1642 
1643     m_matrix[0][0] = decomp.m11;
1644     m_matrix[0][1] = decomp.m12;
1645     m_matrix[1][0] = decomp.m21;
1646     m_matrix[1][1] = decomp.m22;
1647 
1648     translate3d(decomp.translateX, decomp.translateY, 0);
1649     rotate(decomp.angle);
1650     scale3d(decomp.scaleX, decomp.scaleY, 1);
1651 }
1652 
1653 void TransformationMatrix::recompose4(const Decomposed4Type&amp; decomp)
1654 {
1655     makeIdentity();
1656 
1657     // First apply perspective.
1658     m_matrix[0][3] = decomp.perspectiveX;
1659     m_matrix[1][3] = decomp.perspectiveY;
1660     m_matrix[2][3] = decomp.perspectiveZ;
1661     m_matrix[3][3] = decomp.perspectiveW;
1662 
1663     // Next, translate.
1664     translate3d(decomp.translateX, decomp.translateY, decomp.translateZ);
1665 
1666     // Apply rotation.
1667     double xx = decomp.quaternionX * decomp.quaternionX;
1668     double xy = decomp.quaternionX * decomp.quaternionY;
1669     double xz = decomp.quaternionX * decomp.quaternionZ;
1670     double xw = decomp.quaternionX * decomp.quaternionW;
1671     double yy = decomp.quaternionY * decomp.quaternionY;
1672     double yz = decomp.quaternionY * decomp.quaternionZ;
1673     double yw = decomp.quaternionY * decomp.quaternionW;
1674     double zz = decomp.quaternionZ * decomp.quaternionZ;
1675     double zw = decomp.quaternionZ * decomp.quaternionW;
1676 
1677     // Construct a composite rotation matrix from the quaternion values.
1678     TransformationMatrix rotationMatrix(1 - 2 * (yy + zz), 2 * (xy - zw), 2 * (xz + yw), 0,
1679                            2 * (xy + zw), 1 - 2 * (xx + zz), 2 * (yz - xw), 0,
1680                            2 * (xz - yw), 2 * (yz + xw), 1 - 2 * (xx + yy), 0,
1681                            0, 0, 0, 1);
1682 
1683     multiply(rotationMatrix);
1684 
1685     // Apply skew.
1686     if (decomp.skewYZ) {
1687         TransformationMatrix tmp;
1688         tmp.setM32(decomp.skewYZ);
1689         multiply(tmp);
1690     }
1691 
1692     if (decomp.skewXZ) {
1693         TransformationMatrix tmp;
1694         tmp.setM31(decomp.skewXZ);
1695         multiply(tmp);
1696     }
1697 
1698     if (decomp.skewXY) {
1699         TransformationMatrix tmp;
1700         tmp.setM21(decomp.skewXY);
1701         multiply(tmp);
1702     }
1703 
1704     // Finally, apply scale.
1705     scale3d(decomp.scaleX, decomp.scaleY, decomp.scaleZ);
1706 }
1707 
1708 bool TransformationMatrix::isIntegerTranslation() const
1709 {
1710     if (!isIdentityOrTranslation())
1711         return false;
1712 
1713     // Check for translate Z.
1714     if (m_matrix[3][2])
1715         return false;
1716 
1717     // Check for non-integer translate X/Y.
1718     if (static_cast&lt;int&gt;(m_matrix[3][0]) != m_matrix[3][0] || static_cast&lt;int&gt;(m_matrix[3][1]) != m_matrix[3][1])
1719         return false;
1720 
1721     return true;
1722 }
1723 
1724 bool TransformationMatrix::containsOnlyFiniteValues() const
1725 {
1726     return std::isfinite(m_matrix[0][0]) &amp;&amp; std::isfinite(m_matrix[0][1]) &amp;&amp; std::isfinite(m_matrix[0][2]) &amp;&amp; std::isfinite(m_matrix[0][3])
1727         &amp;&amp; std::isfinite(m_matrix[1][0]) &amp;&amp; std::isfinite(m_matrix[1][1]) &amp;&amp; std::isfinite(m_matrix[1][2]) &amp;&amp; std::isfinite(m_matrix[1][3])
1728         &amp;&amp; std::isfinite(m_matrix[2][0]) &amp;&amp; std::isfinite(m_matrix[2][1]) &amp;&amp; std::isfinite(m_matrix[2][2]) &amp;&amp; std::isfinite(m_matrix[2][3])
1729         &amp;&amp; std::isfinite(m_matrix[3][0]) &amp;&amp; std::isfinite(m_matrix[3][1]) &amp;&amp; std::isfinite(m_matrix[3][2]) &amp;&amp; std::isfinite(m_matrix[3][3]);
1730 }
1731 
1732 TransformationMatrix TransformationMatrix::to2dTransform() const
1733 {
1734     return TransformationMatrix(m_matrix[0][0], m_matrix[0][1], 0, m_matrix[0][3],
1735                                 m_matrix[1][0], m_matrix[1][1], 0, m_matrix[1][3],
1736                                 0, 0, 1, 0,
1737                                 m_matrix[3][0], m_matrix[3][1], 0, m_matrix[3][3]);
1738 }
1739 
1740 auto TransformationMatrix::toColumnMajorFloatArray() const -&gt; FloatMatrix4
1741 {
1742     return { {
1743         float(m11()), float(m12()), float(m13()), float(m14()),
1744         float(m21()), float(m22()), float(m23()), float(m24()),
1745         float(m31()), float(m32()), float(m33()), float(m34()),
1746         float(m41()), float(m42()), float(m43()), float(m44()) } };
1747 }
1748 
1749 bool TransformationMatrix::isBackFaceVisible() const
1750 {
1751     // Back-face visibility is determined by transforming the normal vector (0, 0, 1) and
1752     // checking the sign of the resulting z component. However, normals cannot be
1753     // transformed by the original matrix, they require being transformed by the
1754     // inverse-transpose.
1755     //
1756     // Since we know we will be using (0, 0, 1), and we only care about the z-component of
1757     // the transformed normal, then we only need the m33() element of the
1758     // inverse-transpose. Therefore we do not need the transpose.
1759     //
1760     // Additionally, if we only need the m33() element, we do not need to compute a full
1761     // inverse. Instead, knowing the inverse of a matrix is adjoint(matrix) / determinant,
1762     // we can simply compute the m33() of the adjoint (adjugate) matrix, without computing
1763     // the full adjoint.
1764 
1765     double determinant = WebCore::determinant4x4(m_matrix);
1766 
1767     // If the matrix is not invertible, then we assume its backface is not visible.
1768     if (fabs(determinant) &lt; SMALL_NUMBER)
1769         return false;
1770 
1771     double cofactor33 = determinant3x3(m11(), m12(), m14(), m21(), m22(), m24(), m41(), m42(), m44());
1772     double zComponentOfTransformedNormal = cofactor33 / determinant;
1773 
1774     return zComponentOfTransformedNormal &lt; 0;
1775 }
1776 
1777 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const TransformationMatrix&amp; transform)
1778 {
1779     TextStream::IndentScope indentScope(ts);
1780     ts &lt;&lt; &quot;\n&quot;;
1781     ts &lt;&lt; indent &lt;&lt; &quot;[&quot; &lt;&lt; transform.m11() &lt;&lt; &quot; &quot; &lt;&lt; transform.m12() &lt;&lt; &quot; &quot; &lt;&lt; transform.m13() &lt;&lt; &quot; &quot; &lt;&lt; transform.m14() &lt;&lt; &quot;]\n&quot;;
1782     ts &lt;&lt; indent &lt;&lt; &quot;[&quot; &lt;&lt; transform.m21() &lt;&lt; &quot; &quot; &lt;&lt; transform.m22() &lt;&lt; &quot; &quot; &lt;&lt; transform.m23() &lt;&lt; &quot; &quot; &lt;&lt; transform.m24() &lt;&lt; &quot;]\n&quot;;
1783     ts &lt;&lt; indent &lt;&lt; &quot;[&quot; &lt;&lt; transform.m31() &lt;&lt; &quot; &quot; &lt;&lt; transform.m32() &lt;&lt; &quot; &quot; &lt;&lt; transform.m33() &lt;&lt; &quot; &quot; &lt;&lt; transform.m34() &lt;&lt; &quot;]\n&quot;;
1784     ts &lt;&lt; indent &lt;&lt; &quot;[&quot; &lt;&lt; transform.m41() &lt;&lt; &quot; &quot; &lt;&lt; transform.m42() &lt;&lt; &quot; &quot; &lt;&lt; transform.m43() &lt;&lt; &quot; &quot; &lt;&lt; transform.m44() &lt;&lt; &quot;]&quot;;
1785     return ts;
1786 }
1787 
1788 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
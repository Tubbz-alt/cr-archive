<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationEffect.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AnimationEffect.h&quot;
 28 
 29 #include &quot;FillMode.h&quot;
 30 #include &quot;JSComputedEffectTiming.h&quot;
 31 #include &quot;WebAnimationUtilities.h&quot;
 32 
 33 namespace WebCore {
 34 
 35 AnimationEffect::AnimationEffect()
 36     : m_timingFunction(LinearTimingFunction::create())
 37 {
 38 }
 39 
 40 AnimationEffect::~AnimationEffect()
 41 {
 42 }
 43 
 44 EffectTiming AnimationEffect::getTiming() const
 45 {
 46     EffectTiming timing;
 47     timing.delay = secondsToWebAnimationsAPITime(m_delay);
 48     timing.endDelay = secondsToWebAnimationsAPITime(m_endDelay);
 49     timing.fill = m_fill;
 50     timing.iterationStart = m_iterationStart;
 51     timing.iterations = m_iterations;
 52     if (m_iterationDuration == 0_s)
 53         timing.duration = &quot;auto&quot;;
 54     else
 55         timing.duration = secondsToWebAnimationsAPITime(m_iterationDuration);
 56     timing.direction = m_direction;
 57     timing.easing = m_timingFunction-&gt;cssText();
 58     return timing;
 59 }
 60 
 61 BasicEffectTiming AnimationEffect::getBasicTiming() const
 62 {
 63     // The Web Animations spec introduces a number of animation effect time-related definitions that refer
 64     // to each other a fair bit, so rather than implementing them as individual methods, it&#39;s more efficient
 65     // to return them all as a single BasicEffectTiming.
 66 
<a name="1" id="anc1"></a>




















 67     auto localTime = [this]() -&gt; Optional&lt;Seconds&gt; {
 68         // 4.5.4. Local time
 69         // https://drafts.csswg.org/web-animations-1/#local-time-section
 70 
 71         // The local time of an animation effect at a given moment is based on the first matching condition from the following:
 72         // If the animation effect is associated with an animation, the local time is the current time of the animation.
 73         // Otherwise, the local time is unresolved.
 74         if (m_animation)
 75             return m_animation-&gt;currentTime();
 76         return WTF::nullopt;
 77     }();
 78 
<a name="2" id="anc2"></a><span class="line-modified"> 79     auto phase = [this, localTime]() -&gt; AnimationEffectPhase {</span>
 80         // 3.5.5. Animation effect phases and states
 81         // https://drafts.csswg.org/web-animations-1/#animation-effect-phases-and-states
 82 
 83         bool animationIsBackwards = m_animation &amp;&amp; m_animation-&gt;playbackRate() &lt; 0;
<a name="3" id="anc3"></a><span class="line-modified"> 84         auto beforeActiveBoundaryTime = std::max(std::min(m_delay, m_endTime), 0_s);</span>
<span class="line-modified"> 85         auto activeAfterBoundaryTime = std::max(std::min(m_delay + m_activeDuration, m_endTime), 0_s);</span>
 86 
 87         // (This should be the last statement, but it&#39;s more efficient to cache the local time and return right away if it&#39;s not resolved.)
 88         // Furthermore, it is often convenient to refer to the case when an animation effect is in none of the above phases
 89         // as being in the idle phase.
 90         if (!localTime)
 91             return AnimationEffectPhase::Idle;
 92 
 93         // An animation effect is in the before phase if the animation effect’s local time is not unresolved and
 94         // either of the following conditions are met:
 95         //     1. the local time is less than the before-active boundary time, or
 96         //     2. the animation direction is ‘backwards’ and the local time is equal to the before-active boundary time.
 97         if ((*localTime + timeEpsilon) &lt; beforeActiveBoundaryTime || (animationIsBackwards &amp;&amp; std::abs(localTime-&gt;microseconds() - beforeActiveBoundaryTime.microseconds()) &lt; timeEpsilon.microseconds()))
 98             return AnimationEffectPhase::Before;
 99 
100         // An animation effect is in the after phase if the animation effect’s local time is not unresolved and
101         // either of the following conditions are met:
102         //     1. the local time is greater than the active-after boundary time, or
103         //     2. the animation direction is ‘forwards’ and the local time is equal to the active-after boundary time.
104         if ((*localTime - timeEpsilon) &gt; activeAfterBoundaryTime || (!animationIsBackwards &amp;&amp; std::abs(localTime-&gt;microseconds() - activeAfterBoundaryTime.microseconds()) &lt; timeEpsilon.microseconds()))
105             return AnimationEffectPhase::After;
106 
107         // An animation effect is in the active phase if the animation effect’s local time is not unresolved and it is not
108         // in either the before phase nor the after phase.
109         // (No need to check, we&#39;ve already established that local time was resolved).
110         return AnimationEffectPhase::Active;
111     }();
112 
<a name="4" id="anc4"></a><span class="line-modified">113     auto activeTime = [this, localTime, phase]() -&gt; Optional&lt;Seconds&gt; {</span>
114         // 3.8.3.1. Calculating the active time
115         // https://drafts.csswg.org/web-animations-1/#calculating-the-active-time
116 
117         // The active time is based on the local time and start delay. However, it is only defined
118         // when the animation effect should produce an output and hence depends on its fill mode
119         // and phase as follows,
120 
121         // If the animation effect is in the before phase, the result depends on the first matching
122         // condition from the following,
123         if (phase == AnimationEffectPhase::Before) {
124             // If the fill mode is backwards or both, return the result of evaluating
125             // max(local time - start delay, 0).
126             if (m_fill == FillMode::Backwards || m_fill == FillMode::Both)
127                 return std::max(*localTime - m_delay, 0_s);
128             // Otherwise, return an unresolved time value.
129             return WTF::nullopt;
130         }
131 
132         // If the animation effect is in the active phase, return the result of evaluating local time - start delay.
133         if (phase == AnimationEffectPhase::Active)
134             return *localTime - m_delay;
135 
136         // If the animation effect is in the after phase, the result depends on the first matching
137         // condition from the following,
138         if (phase == AnimationEffectPhase::After) {
139             // If the fill mode is forwards or both, return the result of evaluating
140             // max(min(local time - start delay, active duration), 0).
141             if (m_fill == FillMode::Forwards || m_fill == FillMode::Both)
<a name="5" id="anc5"></a><span class="line-modified">142                 return std::max(std::min(*localTime - m_delay, m_activeDuration), 0_s);</span>
143             // Otherwise, return an unresolved time value.
144             return WTF::nullopt;
145         }
146 
147         // Otherwise (the local time is unresolved), return an unresolved time value.
148         return WTF::nullopt;
149     }();
150 
<a name="6" id="anc6"></a><span class="line-modified">151     return { localTime, activeTime, m_endTime, m_activeDuration, phase };</span>
152 }
153 
154 ComputedEffectTiming AnimationEffect::getComputedTiming() const
155 {
156     // The Web Animations spec introduces a number of animation effect time-related definitions that refer
157     // to each other a fair bit, so rather than implementing them as individual methods, it&#39;s more efficient
158     // to return them all as a single ComputedEffectTiming.
159 
160     auto basicEffectTiming = getBasicTiming();
161     auto activeTime = basicEffectTiming.activeTime;
<a name="7" id="anc7"></a>
162     auto phase = basicEffectTiming.phase;
163 
164     auto overallProgress = [this, phase, activeTime]() -&gt; Optional&lt;double&gt; {
165         // 3.8.3.2. Calculating the overall progress
166         // https://drafts.csswg.org/web-animations-1/#calculating-the-overall-progress
167 
168         // The overall progress describes the number of iterations that have completed (including partial iterations) and is defined as follows:
169 
170         // 1. If the active time is unresolved, return unresolved.
171         if (!activeTime)
172             return WTF::nullopt;
173 
174         // 2. Calculate an initial value for overall progress based on the first matching condition from below,
175         double overallProgress;
176 
177         if (!m_iterationDuration) {
178             // If the iteration duration is zero, if the animation effect is in the before phase, let overall progress be zero,
179             // otherwise, let it be equal to the iteration count.
180             overallProgress = phase == AnimationEffectPhase::Before ? 0 : m_iterations;
181         } else {
182             // Otherwise, let overall progress be the result of calculating active time / iteration duration.
183             overallProgress = secondsToWebAnimationsAPITime(*activeTime) / secondsToWebAnimationsAPITime(m_iterationDuration);
184         }
185 
186         // 3. Return the result of calculating overall progress + iteration start.
187         overallProgress += m_iterationStart;
188         return std::abs(overallProgress);
189     }();
190 
<a name="8" id="anc8"></a><span class="line-modified">191     auto simpleIterationProgress = [this, overallProgress, phase, activeTime]() -&gt; Optional&lt;double&gt; {</span>
192         // 3.8.3.3. Calculating the simple iteration progress
193         // https://drafts.csswg.org/web-animations-1/#calculating-the-simple-iteration-progress
194 
195         // The simple iteration progress is a fraction of the progress through the current iteration that
196         // ignores transformations to the time introduced by the playback direction or timing functions
197         // applied to the effect, and is calculated as follows:
198 
199         // 1. If the overall progress is unresolved, return unresolved.
200         if (!overallProgress)
201             return WTF::nullopt;
202 
203         // 2. If overall progress is infinity, let the simple iteration progress be iteration start % 1.0,
204         // otherwise, let the simple iteration progress be overall progress % 1.0.
205         double simpleIterationProgress = std::isinf(*overallProgress) ? fmod(m_iterationStart, 1) : fmod(*overallProgress, 1);
206 
207         // 3. If all of the following conditions are true,
208         //
209         // the simple iteration progress calculated above is zero, and
210         // the animation effect is in the active phase or the after phase, and
211         // the active time is equal to the active duration, and
212         // the iteration count is not equal to zero.
213         // let the simple iteration progress be 1.0.
<a name="9" id="anc9"></a><span class="line-modified">214         if (!simpleIterationProgress &amp;&amp; (phase == AnimationEffectPhase::Active || phase == AnimationEffectPhase::After) &amp;&amp; std::abs(activeTime-&gt;microseconds() - m_activeDuration.microseconds()) &lt; timeEpsilon.microseconds() &amp;&amp; m_iterations)</span>
215             return 1;
216 
217         return simpleIterationProgress;
218     }();
219 
220     auto currentIteration = [this, activeTime, phase, simpleIterationProgress, overallProgress]() -&gt; Optional&lt;double&gt; {
221         // 3.8.4. Calculating the current iteration
222         // https://drafts.csswg.org/web-animations-1/#calculating-the-current-iteration
223 
224         // The current iteration can be calculated using the following steps:
225 
226         // 1. If the active time is unresolved, return unresolved.
227         if (!activeTime)
228             return WTF::nullopt;
229 
230         // 2. If the animation effect is in the after phase and the iteration count is infinity, return infinity.
231         if (phase == AnimationEffectPhase::After &amp;&amp; std::isinf(m_iterations))
232             return std::numeric_limits&lt;double&gt;::infinity();
233 
234         // 3. If the simple iteration progress is 1.0, return floor(overall progress) - 1.
235         if (*simpleIterationProgress == 1)
236             return floor(*overallProgress) - 1;
237 
238         // 4. Otherwise, return floor(overall progress).
239         return floor(*overallProgress);
240     }();
241 
242     auto currentDirection = [this, currentIteration]() -&gt; AnimationEffect::ComputedDirection {
243         // 3.9.1. Calculating the directed progress
244         // https://drafts.csswg.org/web-animations-1/#calculating-the-directed-progress
245 
246         // If playback direction is normal, let the current direction be forwards.
247         if (m_direction == PlaybackDirection::Normal)
248             return AnimationEffect::ComputedDirection::Forwards;
249 
250         // If playback direction is reverse, let the current direction be reverse.
251         if (m_direction == PlaybackDirection::Reverse)
252             return AnimationEffect::ComputedDirection::Reverse;
253 
254         if (!currentIteration)
255             return AnimationEffect::ComputedDirection::Forwards;
256 
257         // Otherwise, let d be the current iteration.
258         auto d = *currentIteration;
259         // If playback direction is alternate-reverse increment d by 1.
260         if (m_direction == PlaybackDirection::AlternateReverse)
261             d++;
262         // If d % 2 == 0, let the current direction be forwards, otherwise let the current direction be reverse.
263         // If d is infinity, let the current direction be forwards.
264         if (std::isinf(d) || !fmod(d, 2))
265             return AnimationEffect::ComputedDirection::Forwards;
266         return AnimationEffect::ComputedDirection::Reverse;
267     }();
268 
269     auto directedProgress = [simpleIterationProgress, currentDirection]() -&gt; Optional&lt;double&gt; {
270         // 3.9.1. Calculating the directed progress
271         // https://drafts.csswg.org/web-animations-1/#calculating-the-directed-progress
272 
273         // The directed progress is calculated from the simple iteration progress using the following steps:
274 
275         // 1. If the simple iteration progress is unresolved, return unresolved.
276         if (!simpleIterationProgress)
277             return WTF::nullopt;
278 
279         // 2. Calculate the current direction (we implement this as a separate method).
280 
281         // 3. If the current direction is forwards then return the simple iteration progress.
282         if (currentDirection == AnimationEffect::ComputedDirection::Forwards)
283             return *simpleIterationProgress;
284 
285         // Otherwise, return 1.0 - simple iteration progress.
286         return 1 - *simpleIterationProgress;
287     }();
288 
289     auto transformedProgress = [this, directedProgress, currentDirection, phase]() -&gt; Optional&lt;double&gt; {
290         // 3.10.1. Calculating the transformed progress
291         // https://drafts.csswg.org/web-animations-1/#calculating-the-transformed-progress
292 
293         // The transformed progress is calculated from the directed progress using the following steps:
294         //
295         // 1. If the directed progress is unresolved, return unresolved.
296         if (!directedProgress)
297             return WTF::nullopt;
298 
299         if (auto iterationDuration = m_iterationDuration.seconds()) {
300             bool before = false;
301             // 2. Calculate the value of the before flag as follows:
302             if (is&lt;StepsTimingFunction&gt;(m_timingFunction)) {
303                 // 1. Determine the current direction using the procedure defined in §3.9.1 Calculating the directed progress.
304                 // 2. If the current direction is forwards, let going forwards be true, otherwise it is false.
305                 bool goingForwards = currentDirection == AnimationEffect::ComputedDirection::Forwards;
306                 // 3. The before flag is set if the animation effect is in the before phase and going forwards is true;
307                 //    or if the animation effect is in the after phase and going forwards is false.
308                 before = (phase == AnimationEffectPhase::Before &amp;&amp; goingForwards) || (phase == AnimationEffectPhase::After &amp;&amp; !goingForwards);
309             }
310 
311             // 3. Return the result of evaluating the animation effect’s timing function passing directed progress as the
312             //    input progress value and before flag as the before flag.
313             return m_timingFunction-&gt;transformTime(*directedProgress, iterationDuration, before);
314         }
315 
316         return *directedProgress;
317     }();
318 
319     ComputedEffectTiming computedTiming;
320     computedTiming.delay = secondsToWebAnimationsAPITime(m_delay);
321     computedTiming.endDelay = secondsToWebAnimationsAPITime(m_endDelay);
322     computedTiming.fill = m_fill == FillMode::Auto ? FillMode::None : m_fill;
323     computedTiming.iterationStart = m_iterationStart;
324     computedTiming.iterations = m_iterations;
325     computedTiming.duration = secondsToWebAnimationsAPITime(m_iterationDuration);
326     computedTiming.direction = m_direction;
327     computedTiming.easing = m_timingFunction-&gt;cssText();
<a name="10" id="anc10"></a><span class="line-modified">328     computedTiming.endTime = secondsToWebAnimationsAPITime(m_endTime);</span>
<span class="line-modified">329     computedTiming.activeDuration = secondsToWebAnimationsAPITime(m_activeDuration);</span>
330     if (basicEffectTiming.localTime)
331         computedTiming.localTime = secondsToWebAnimationsAPITime(*basicEffectTiming.localTime);
332     computedTiming.simpleIterationProgress = simpleIterationProgress;
333     computedTiming.progress = transformedProgress;
334     computedTiming.currentIteration = currentIteration;
335     computedTiming.phase = phase;
336     return computedTiming;
337 }
338 
339 ExceptionOr&lt;void&gt; AnimationEffect::updateTiming(Optional&lt;OptionalEffectTiming&gt; timing)
340 {
341     // 6.5.4. Updating the timing of an AnimationEffect
342     // https://drafts.csswg.org/web-animations/#updating-animationeffect-timing
343 
344     // To update the timing properties of an animation effect, effect, from an EffectTiming or OptionalEffectTiming object, input, perform the following steps:
345     if (!timing)
346         return { };
347 
<a name="11" id="anc11"></a><span class="line-added">348     Optional&lt;ComputedEffectTiming&gt; previousTiming;</span>
<span class="line-added">349     if (m_animation)</span>
<span class="line-added">350         previousTiming = getComputedTiming();</span>
<span class="line-added">351 </span>
352     // 1. If the iterationStart member of input is present and less than zero, throw a TypeError and abort this procedure.
353     if (timing-&gt;iterationStart) {
354         if (timing-&gt;iterationStart.value() &lt; 0)
355             return Exception { TypeError };
356     }
357 
358     // 2. If the iterations member of input is present, and less than zero or is the value NaN, throw a TypeError and abort this procedure.
359     if (timing-&gt;iterations) {
360         if (timing-&gt;iterations.value() &lt; 0 || std::isnan(timing-&gt;iterations.value()))
361             return Exception { TypeError };
362     }
363 
364     // 3. If the duration member of input is present, and less than zero or is the value NaN, throw a TypeError and abort this procedure.
365     // FIXME: should it not throw an exception on a string other than &quot;auto&quot;?
366     if (timing-&gt;duration) {
367         if (WTF::holds_alternative&lt;double&gt;(timing-&gt;duration.value())) {
368             auto durationAsDouble = WTF::get&lt;double&gt;(timing-&gt;duration.value());
369             if (durationAsDouble &lt; 0 || std::isnan(durationAsDouble))
370                 return Exception { TypeError };
371         } else {
372             if (WTF::get&lt;String&gt;(timing-&gt;duration.value()) != &quot;auto&quot;)
373                 return Exception { TypeError };
374         }
375     }
376 
377     // 4. If the easing member of input is present but cannot be parsed using the &lt;timing-function&gt; production [CSS-EASING-1], throw a TypeError and abort this procedure.
378     if (!timing-&gt;easing.isNull()) {
379         auto timingFunctionResult = TimingFunction::createFromCSSText(timing-&gt;easing);
380         if (timingFunctionResult.hasException())
381             return timingFunctionResult.releaseException();
382         m_timingFunction = timingFunctionResult.returnValue();
383     }
384 
385     // 5. Assign each member present in input to the corresponding timing property of effect as follows:
386     //
387     //    delay → start delay
388     //    endDelay → end delay
389     //    fill → fill mode
390     //    iterationStart → iteration start
391     //    iterations → iteration count
392     //    duration → iteration duration
393     //    direction → playback direction
394     //    easing → timing function
395 
396     if (timing-&gt;delay)
397         m_delay = Seconds::fromMilliseconds(timing-&gt;delay.value());
398 
399     if (timing-&gt;endDelay)
400         m_endDelay = Seconds::fromMilliseconds(timing-&gt;endDelay.value());
401 
402     if (timing-&gt;fill)
403         m_fill = timing-&gt;fill.value();
404 
405     if (timing-&gt;iterationStart)
406         m_iterationStart = timing-&gt;iterationStart.value();
407 
408     if (timing-&gt;iterations)
409         m_iterations = timing-&gt;iterations.value();
410 
411     if (timing-&gt;duration)
412         m_iterationDuration = WTF::holds_alternative&lt;double&gt;(timing-&gt;duration.value()) ? Seconds::fromMilliseconds(WTF::get&lt;double&gt;(timing-&gt;duration.value())) : 0_s;
413 
414     if (timing-&gt;direction)
415         m_direction = timing-&gt;direction.value();
416 
<a name="12" id="anc12"></a><span class="line-added">417     updateStaticTimingProperties();</span>
<span class="line-added">418 </span>
419     if (m_animation)
<a name="13" id="anc13"></a><span class="line-modified">420         m_animation-&gt;effectTimingDidChange(previousTiming);</span>
421 
422     return { };
423 }
424 
<a name="14" id="anc14"></a><span class="line-added">425 void AnimationEffect::updateStaticTimingProperties()</span>
<span class="line-added">426 {</span>
<span class="line-added">427     // 3.8.2. Calculating the active duration</span>
<span class="line-added">428     // https://drafts.csswg.org/web-animations-1/#calculating-the-active-duration</span>
<span class="line-added">429 </span>
<span class="line-added">430     // The active duration is calculated as follows:</span>
<span class="line-added">431     // active duration = iteration duration × iteration count</span>
<span class="line-added">432     // If either the iteration duration or iteration count are zero, the active duration is zero.</span>
<span class="line-added">433     if (!m_iterationDuration || !m_iterations)</span>
<span class="line-added">434         m_activeDuration = 0_s;</span>
<span class="line-added">435     else</span>
<span class="line-added">436         m_activeDuration = m_iterationDuration * m_iterations;</span>
<span class="line-added">437 </span>
<span class="line-added">438     // 3.5.3 The active interval</span>
<span class="line-added">439     // https://drafts.csswg.org/web-animations-1/#end-time</span>
<span class="line-added">440 </span>
<span class="line-added">441     // The end time of an animation effect is the result of evaluating max(start delay + active duration + end delay, 0).</span>
<span class="line-added">442     m_endTime = m_delay + m_activeDuration + m_endDelay;</span>
<span class="line-added">443     if (m_endTime &lt; 0_s)</span>
<span class="line-added">444         m_endTime = 0_s;</span>
<span class="line-added">445 }</span>
<span class="line-added">446 </span>
447 ExceptionOr&lt;void&gt; AnimationEffect::setIterationStart(double iterationStart)
448 {
449     // https://drafts.csswg.org/web-animations-1/#dom-animationeffecttiming-iterationstart
450     // If an attempt is made to set this attribute to a value less than zero, a TypeError must
451     // be thrown and the value of the iterationStart attribute left unchanged.
452     if (iterationStart &lt; 0)
453         return Exception { TypeError };
454 
455     if (m_iterationStart == iterationStart)
456         return { };
457 
458     m_iterationStart = iterationStart;
459 
460     return { };
461 }
462 
463 ExceptionOr&lt;void&gt; AnimationEffect::setIterations(double iterations)
464 {
465     // https://drafts.csswg.org/web-animations-1/#dom-animationeffecttiming-iterations
466     // If an attempt is made to set this attribute to a value less than zero or a NaN value, a
467     // TypeError must be thrown and the value of the iterations attribute left unchanged.
468     if (iterations &lt; 0 || std::isnan(iterations))
469         return Exception { TypeError };
470 
471     if (m_iterations == iterations)
472         return { };
473 
474     m_iterations = iterations;
475 
476     return { };
477 }
478 
479 void AnimationEffect::setDelay(const Seconds&amp; delay)
480 {
481     if (m_delay == delay)
482         return;
483 
484     m_delay = delay;
485 }
486 
487 void AnimationEffect::setEndDelay(const Seconds&amp; endDelay)
488 {
489     if (m_endDelay == endDelay)
490         return;
491 
492     m_endDelay = endDelay;
493 }
494 
495 void AnimationEffect::setFill(FillMode fill)
496 {
497     if (m_fill == fill)
498         return;
499 
500     m_fill = fill;
501 }
502 
503 void AnimationEffect::setIterationDuration(const Seconds&amp; duration)
504 {
505     if (m_iterationDuration == duration)
506         return;
507 
508     m_iterationDuration = duration;
509 }
510 
511 void AnimationEffect::setDirection(PlaybackDirection direction)
512 {
513     if (m_direction == direction)
514         return;
515 
516     m_direction = direction;
517 }
518 
519 void AnimationEffect::setTimingFunction(const RefPtr&lt;TimingFunction&gt;&amp; timingFunction)
520 {
521     m_timingFunction = timingFunction;
522 }
523 
524 } // namespace WebCore
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
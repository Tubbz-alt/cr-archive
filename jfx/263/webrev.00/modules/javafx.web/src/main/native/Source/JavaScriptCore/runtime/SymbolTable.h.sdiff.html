<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SymbolTable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SymbolTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TemplateObjectDescriptor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SymbolTable.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2007, 2008, 2012-2015 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
</pre>
<hr />
<pre>
 27  */
 28 
 29 #pragma once
 30 
 31 #include &quot;ConcurrentJSLock.h&quot;
 32 #include &quot;ConstantMode.h&quot;
 33 #include &quot;InferredValue.h&quot;
 34 #include &quot;JSObject.h&quot;
 35 #include &quot;ScopedArgumentsTable.h&quot;
 36 #include &quot;TypeLocation.h&quot;
 37 #include &quot;VarOffset.h&quot;
 38 #include &quot;Watchpoint.h&quot;
 39 #include &lt;memory&gt;
 40 #include &lt;wtf/HashTraits.h&gt;
 41 #include &lt;wtf/text/UniquedStringImpl.h&gt;
 42 
 43 namespace JSC {
 44 
 45 class SymbolTable;
 46 


 47 static ALWAYS_INLINE int missingSymbolMarker() { return std::numeric_limits&lt;int&gt;::max(); }
 48 
 49 // The bit twiddling in this class assumes that every register index is a
 50 // reasonably small positive or negative number, and therefore has its high
 51 // four bits all set or all unset.
 52 
 53 // In addition to implementing semantics-mandated variable attributes and
 54 // implementation-mandated variable indexing, this class also implements
 55 // watchpoints to be used for JIT optimizations. Because watchpoints are
 56 // meant to be relatively rare, this class optimizes heavily for the case
 57 // that they are not being used. To that end, this class uses the thin-fat
 58 // idiom: either it is thin, in which case it contains an in-place encoded
 59 // word that consists of attributes, the index, and a bit saying that it is
 60 // thin; or it is fat, in which case it contains a pointer to a malloc&#39;d
 61 // data structure and a bit saying that it is fat. The malloc&#39;d data
 62 // structure will be malloced a second time upon copy, to preserve the
 63 // property that in-place edits to SymbolTableEntry do not manifest in any
 64 // copies. However, the malloc&#39;d FatEntry data structure contains a ref-
 65 // counted pointer to a shared WatchpointSet. Thus, in-place edits of the
 66 // WatchpointSet will manifest in all copies. Here&#39;s a picture:
</pre>
<hr />
<pre>
315     WatchpointSet* watchpointSet()
316     {
317         if (!isFat())
318             return nullptr;
319         return fatEntry()-&gt;m_watchpoints.get();
320     }
321 
322 private:
323     static const intptr_t SlimFlag = 0x1;
324     static const intptr_t ReadOnlyFlag = 0x2;
325     static const intptr_t DontEnumFlag = 0x4;
326     static const intptr_t NotNullFlag = 0x8;
327     static const intptr_t KindBitsMask = 0x30;
328     static const intptr_t ScopeKindBits = 0x00;
329     static const intptr_t UnwatchableScopeKindBits = 0x10;
330     static const intptr_t StackKindBits = 0x20;
331     static const intptr_t DirectArgumentKindBits = 0x30;
332     static const intptr_t FlagBits = 6;
333 
334     class FatEntry {
<span class="line-modified">335         WTF_MAKE_FAST_ALLOCATED;</span>
336     public:
337         FatEntry(intptr_t bits)
338             : m_bits(bits &amp; ~SlimFlag)
339         {
340         }
341 
342         intptr_t m_bits; // always has FatFlag set and exactly matches what the bits would have been if this wasn&#39;t fat.
343 
344         RefPtr&lt;WatchpointSet&gt; m_watchpoints;
345     };
346 
347     SymbolTableEntry&amp; copySlow(const SymbolTableEntry&amp;);
348 
349     bool isFat() const
350     {
351         return !(m_bits &amp; SlimFlag);
352     }
353 
354     const FatEntry* fatEntry() const
355     {
</pre>
<hr />
<pre>
416             bitsRef |= StackKindBits;
417             break;
418         case VarKind::DirectArgument:
419             bitsRef |= DirectArgumentKindBits;
420             break;
421         default:
422             RELEASE_ASSERT_NOT_REACHED();
423             break;
424         }
425     }
426 
427     static bool isValidVarOffset(VarOffset offset)
428     {
429         return ((static_cast&lt;intptr_t&gt;(offset.rawOffset()) &lt;&lt; FlagBits) &gt;&gt; FlagBits) == static_cast&lt;intptr_t&gt;(offset.rawOffset());
430     }
431 
432     intptr_t m_bits;
433 };
434 
435 struct SymbolTableIndexHashTraits : HashTraits&lt;SymbolTableEntry&gt; {
<span class="line-modified">436     static const bool needsDestruction = true;</span>
437 };
438 
439 class SymbolTable final : public JSCell {
440     friend class CachedSymbolTable;
441 
442 public:
443     typedef JSCell Base;
<span class="line-modified">444     static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
445 
446     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, SymbolTableEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, SymbolTableIndexHashTraits&gt; Map;
447     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, GlobalVariableID, IdentifierRepHash&gt; UniqueIDMap;
448     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, RefPtr&lt;TypeSet&gt;, IdentifierRepHash&gt; UniqueTypeSetMap;
449     typedef HashMap&lt;VarOffset, RefPtr&lt;UniquedStringImpl&gt;&gt; OffsetToVariableMap;
450     typedef Vector&lt;SymbolTableEntry*&gt; LocalToEntryVec;
451 
452     template&lt;typename CellType, SubspaceAccess&gt;
453     static IsoSubspace* subspaceFor(VM&amp; vm)
454     {
455         return &amp;vm.symbolTableSpace;
456     }
457 
458     static SymbolTable* create(VM&amp; vm)
459     {
460         SymbolTable* symbolTable = new (NotNull, allocateCell&lt;SymbolTable&gt;(vm.heap)) SymbolTable(vm);
461         symbolTable-&gt;finishCreation(vm);
462         return symbolTable;
463     }
464 
<span class="line-modified">465     static const bool needsDestruction = true;</span>
466     static void destroy(JSCell*);
467 
468     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
469     {
470         return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
471     }
472 
473     // You must hold the lock until after you&#39;re done with the iterator.
474     Map::iterator find(const ConcurrentJSLocker&amp;, UniquedStringImpl* key)
475     {
476         return m_map.find(key);
477     }
478 
479     Map::iterator find(const GCSafeConcurrentJSLocker&amp;, UniquedStringImpl* key)
480     {
481         return m_map.find(key);
482     }
483 
484     SymbolTableEntry get(const ConcurrentJSLocker&amp;, UniquedStringImpl* key)
485     {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
</pre>
<hr />
<pre>
 27  */
 28 
 29 #pragma once
 30 
 31 #include &quot;ConcurrentJSLock.h&quot;
 32 #include &quot;ConstantMode.h&quot;
 33 #include &quot;InferredValue.h&quot;
 34 #include &quot;JSObject.h&quot;
 35 #include &quot;ScopedArgumentsTable.h&quot;
 36 #include &quot;TypeLocation.h&quot;
 37 #include &quot;VarOffset.h&quot;
 38 #include &quot;Watchpoint.h&quot;
 39 #include &lt;memory&gt;
 40 #include &lt;wtf/HashTraits.h&gt;
 41 #include &lt;wtf/text/UniquedStringImpl.h&gt;
 42 
 43 namespace JSC {
 44 
 45 class SymbolTable;
 46 
<span class="line-added"> 47 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SymbolTableEntryFatEntry);</span>
<span class="line-added"> 48 </span>
 49 static ALWAYS_INLINE int missingSymbolMarker() { return std::numeric_limits&lt;int&gt;::max(); }
 50 
 51 // The bit twiddling in this class assumes that every register index is a
 52 // reasonably small positive or negative number, and therefore has its high
 53 // four bits all set or all unset.
 54 
 55 // In addition to implementing semantics-mandated variable attributes and
 56 // implementation-mandated variable indexing, this class also implements
 57 // watchpoints to be used for JIT optimizations. Because watchpoints are
 58 // meant to be relatively rare, this class optimizes heavily for the case
 59 // that they are not being used. To that end, this class uses the thin-fat
 60 // idiom: either it is thin, in which case it contains an in-place encoded
 61 // word that consists of attributes, the index, and a bit saying that it is
 62 // thin; or it is fat, in which case it contains a pointer to a malloc&#39;d
 63 // data structure and a bit saying that it is fat. The malloc&#39;d data
 64 // structure will be malloced a second time upon copy, to preserve the
 65 // property that in-place edits to SymbolTableEntry do not manifest in any
 66 // copies. However, the malloc&#39;d FatEntry data structure contains a ref-
 67 // counted pointer to a shared WatchpointSet. Thus, in-place edits of the
 68 // WatchpointSet will manifest in all copies. Here&#39;s a picture:
</pre>
<hr />
<pre>
317     WatchpointSet* watchpointSet()
318     {
319         if (!isFat())
320             return nullptr;
321         return fatEntry()-&gt;m_watchpoints.get();
322     }
323 
324 private:
325     static const intptr_t SlimFlag = 0x1;
326     static const intptr_t ReadOnlyFlag = 0x2;
327     static const intptr_t DontEnumFlag = 0x4;
328     static const intptr_t NotNullFlag = 0x8;
329     static const intptr_t KindBitsMask = 0x30;
330     static const intptr_t ScopeKindBits = 0x00;
331     static const intptr_t UnwatchableScopeKindBits = 0x10;
332     static const intptr_t StackKindBits = 0x20;
333     static const intptr_t DirectArgumentKindBits = 0x30;
334     static const intptr_t FlagBits = 6;
335 
336     class FatEntry {
<span class="line-modified">337         WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(SymbolTableEntryFatEntry);</span>
338     public:
339         FatEntry(intptr_t bits)
340             : m_bits(bits &amp; ~SlimFlag)
341         {
342         }
343 
344         intptr_t m_bits; // always has FatFlag set and exactly matches what the bits would have been if this wasn&#39;t fat.
345 
346         RefPtr&lt;WatchpointSet&gt; m_watchpoints;
347     };
348 
349     SymbolTableEntry&amp; copySlow(const SymbolTableEntry&amp;);
350 
351     bool isFat() const
352     {
353         return !(m_bits &amp; SlimFlag);
354     }
355 
356     const FatEntry* fatEntry() const
357     {
</pre>
<hr />
<pre>
418             bitsRef |= StackKindBits;
419             break;
420         case VarKind::DirectArgument:
421             bitsRef |= DirectArgumentKindBits;
422             break;
423         default:
424             RELEASE_ASSERT_NOT_REACHED();
425             break;
426         }
427     }
428 
429     static bool isValidVarOffset(VarOffset offset)
430     {
431         return ((static_cast&lt;intptr_t&gt;(offset.rawOffset()) &lt;&lt; FlagBits) &gt;&gt; FlagBits) == static_cast&lt;intptr_t&gt;(offset.rawOffset());
432     }
433 
434     intptr_t m_bits;
435 };
436 
437 struct SymbolTableIndexHashTraits : HashTraits&lt;SymbolTableEntry&gt; {
<span class="line-modified">438     static constexpr bool needsDestruction = true;</span>
439 };
440 
441 class SymbolTable final : public JSCell {
442     friend class CachedSymbolTable;
443 
444 public:
445     typedef JSCell Base;
<span class="line-modified">446     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
447 
448     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, SymbolTableEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, SymbolTableIndexHashTraits&gt; Map;
449     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, GlobalVariableID, IdentifierRepHash&gt; UniqueIDMap;
450     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, RefPtr&lt;TypeSet&gt;, IdentifierRepHash&gt; UniqueTypeSetMap;
451     typedef HashMap&lt;VarOffset, RefPtr&lt;UniquedStringImpl&gt;&gt; OffsetToVariableMap;
452     typedef Vector&lt;SymbolTableEntry*&gt; LocalToEntryVec;
453 
454     template&lt;typename CellType, SubspaceAccess&gt;
455     static IsoSubspace* subspaceFor(VM&amp; vm)
456     {
457         return &amp;vm.symbolTableSpace;
458     }
459 
460     static SymbolTable* create(VM&amp; vm)
461     {
462         SymbolTable* symbolTable = new (NotNull, allocateCell&lt;SymbolTable&gt;(vm.heap)) SymbolTable(vm);
463         symbolTable-&gt;finishCreation(vm);
464         return symbolTable;
465     }
466 
<span class="line-modified">467     static constexpr bool needsDestruction = true;</span>
468     static void destroy(JSCell*);
469 
470     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
471     {
472         return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
473     }
474 
475     // You must hold the lock until after you&#39;re done with the iterator.
476     Map::iterator find(const ConcurrentJSLocker&amp;, UniquedStringImpl* key)
477     {
478         return m_map.find(key);
479     }
480 
481     Map::iterator find(const GCSafeConcurrentJSLocker&amp;, UniquedStringImpl* key)
482     {
483         return m_map.find(key);
484     }
485 
486     SymbolTableEntry get(const ConcurrentJSLocker&amp;, UniquedStringImpl* key)
487     {
</pre>
</td>
</tr>
</table>
<center><a href="SymbolTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TemplateObjectDescriptor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
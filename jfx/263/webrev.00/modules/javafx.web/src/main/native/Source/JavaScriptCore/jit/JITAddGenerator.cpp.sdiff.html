<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITAddGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JIT.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITAddGenerator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITAddGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JITAddGenerator.h&quot;
 28 
 29 #include &quot;ArithProfile.h&quot;
 30 #include &quot;JITMathIC.h&quot;
 31 #include &quot;LinkBuffer.h&quot;
 32 
 33 #if ENABLE(JIT)
 34 
 35 namespace JSC {
 36 
<span class="line-modified"> 37 JITMathICInlineResult JITAddGenerator::generateInline(CCallHelpers&amp; jit, MathICGenerationState&amp; state, const ArithProfile* arithProfile)</span>
 38 {
 39     // We default to speculating int32.
 40     ObservedType lhs = ObservedType().withInt32();
 41     ObservedType rhs = ObservedType().withInt32();
 42     if (arithProfile) {
 43         lhs = arithProfile-&gt;lhsObservedType();
 44         rhs = arithProfile-&gt;rhsObservedType();
 45     }
 46 
 47     if (lhs.isOnlyNonNumber() &amp;&amp; rhs.isOnlyNonNumber())
 48         return JITMathICInlineResult::DontGenerate;
 49 
 50     if ((lhs.isOnlyInt32() || m_leftOperand.isConstInt32()) &amp;&amp; (rhs.isOnlyInt32() || m_rightOperand.isConstInt32())) {
 51         ASSERT(!m_leftOperand.isConstInt32() || !m_rightOperand.isConstInt32());
 52         if (!m_leftOperand.isConstInt32())
 53             state.slowPathJumps.append(jit.branchIfNotInt32(m_left));
 54         if (!m_rightOperand.isConstInt32())
 55             state.slowPathJumps.append(jit.branchIfNotInt32(m_right));
 56 
 57         GPRReg scratch = m_scratchGPR;
 58         if (m_leftOperand.isConstInt32() || m_rightOperand.isConstInt32()) {
 59             JSValueRegs var = m_leftOperand.isConstInt32() ? m_right : m_left;
 60             int32_t constValue = m_leftOperand.isConstInt32() ? m_leftOperand.asConstInt32() : m_rightOperand.asConstInt32();
 61             if (var.payloadGPR() != m_result.payloadGPR())
 62                 scratch = m_result.payloadGPR();
 63             state.slowPathJumps.append(jit.branchAdd32(CCallHelpers::Overflow, var.payloadGPR(), CCallHelpers::Imm32(constValue), scratch));
 64         } else {
 65             if (m_left.payloadGPR() != m_result.payloadGPR() &amp;&amp; m_right.payloadGPR() != m_result.payloadGPR())
 66                 scratch = m_result.payloadGPR();
 67             state.slowPathJumps.append(jit.branchAdd32(CCallHelpers::Overflow, m_right.payloadGPR(), m_left.payloadGPR(), scratch));
 68         }
 69         jit.boxInt32(scratch, m_result);
 70         return JITMathICInlineResult::GeneratedFastPath;
 71     }
 72 
 73     return JITMathICInlineResult::GenerateFullSnippet;
 74 }
 75 
<span class="line-modified"> 76 bool JITAddGenerator::generateFastPath(CCallHelpers&amp; jit, CCallHelpers::JumpList&amp; endJumpList, CCallHelpers::JumpList&amp; slowPathJumpList, const ArithProfile* arithProfile, bool shouldEmitProfiling)</span>
 77 {
 78     ASSERT(m_scratchGPR != InvalidGPRReg);
 79     ASSERT(m_scratchGPR != m_left.payloadGPR());
 80     ASSERT(m_scratchGPR != m_right.payloadGPR());
 81 #if USE(JSVALUE32_64)
 82     ASSERT(m_scratchGPR != m_left.tagGPR());
 83     ASSERT(m_scratchGPR != m_right.tagGPR());
 84     ASSERT(m_scratchFPR != InvalidFPRReg);
 85 #endif
 86 
 87     ASSERT(!m_leftOperand.isConstInt32() || !m_rightOperand.isConstInt32());
 88 
 89     if (!m_leftOperand.mightBeNumber() || !m_rightOperand.mightBeNumber())
 90         return false;
 91 
 92     if (m_leftOperand.isConstInt32() || m_rightOperand.isConstInt32()) {
 93         JSValueRegs var = m_leftOperand.isConstInt32() ? m_right : m_left;
 94         SnippetOperand&amp; varOpr = m_leftOperand.isConstInt32() ? m_rightOperand : m_leftOperand;
 95         SnippetOperand&amp; constOpr = m_leftOperand.isConstInt32() ? m_leftOperand : m_rightOperand;
 96 
</pre>
</td>
<td>
<hr />
<pre>
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JITAddGenerator.h&quot;
 28 
 29 #include &quot;ArithProfile.h&quot;
 30 #include &quot;JITMathIC.h&quot;
 31 #include &quot;LinkBuffer.h&quot;
 32 
 33 #if ENABLE(JIT)
 34 
 35 namespace JSC {
 36 
<span class="line-modified"> 37 JITMathICInlineResult JITAddGenerator::generateInline(CCallHelpers&amp; jit, MathICGenerationState&amp; state, const BinaryArithProfile* arithProfile)</span>
 38 {
 39     // We default to speculating int32.
 40     ObservedType lhs = ObservedType().withInt32();
 41     ObservedType rhs = ObservedType().withInt32();
 42     if (arithProfile) {
 43         lhs = arithProfile-&gt;lhsObservedType();
 44         rhs = arithProfile-&gt;rhsObservedType();
 45     }
 46 
 47     if (lhs.isOnlyNonNumber() &amp;&amp; rhs.isOnlyNonNumber())
 48         return JITMathICInlineResult::DontGenerate;
 49 
 50     if ((lhs.isOnlyInt32() || m_leftOperand.isConstInt32()) &amp;&amp; (rhs.isOnlyInt32() || m_rightOperand.isConstInt32())) {
 51         ASSERT(!m_leftOperand.isConstInt32() || !m_rightOperand.isConstInt32());
 52         if (!m_leftOperand.isConstInt32())
 53             state.slowPathJumps.append(jit.branchIfNotInt32(m_left));
 54         if (!m_rightOperand.isConstInt32())
 55             state.slowPathJumps.append(jit.branchIfNotInt32(m_right));
 56 
 57         GPRReg scratch = m_scratchGPR;
 58         if (m_leftOperand.isConstInt32() || m_rightOperand.isConstInt32()) {
 59             JSValueRegs var = m_leftOperand.isConstInt32() ? m_right : m_left;
 60             int32_t constValue = m_leftOperand.isConstInt32() ? m_leftOperand.asConstInt32() : m_rightOperand.asConstInt32();
 61             if (var.payloadGPR() != m_result.payloadGPR())
 62                 scratch = m_result.payloadGPR();
 63             state.slowPathJumps.append(jit.branchAdd32(CCallHelpers::Overflow, var.payloadGPR(), CCallHelpers::Imm32(constValue), scratch));
 64         } else {
 65             if (m_left.payloadGPR() != m_result.payloadGPR() &amp;&amp; m_right.payloadGPR() != m_result.payloadGPR())
 66                 scratch = m_result.payloadGPR();
 67             state.slowPathJumps.append(jit.branchAdd32(CCallHelpers::Overflow, m_right.payloadGPR(), m_left.payloadGPR(), scratch));
 68         }
 69         jit.boxInt32(scratch, m_result);
 70         return JITMathICInlineResult::GeneratedFastPath;
 71     }
 72 
 73     return JITMathICInlineResult::GenerateFullSnippet;
 74 }
 75 
<span class="line-modified"> 76 bool JITAddGenerator::generateFastPath(CCallHelpers&amp; jit, CCallHelpers::JumpList&amp; endJumpList, CCallHelpers::JumpList&amp; slowPathJumpList, const BinaryArithProfile* arithProfile, bool shouldEmitProfiling)</span>
 77 {
 78     ASSERT(m_scratchGPR != InvalidGPRReg);
 79     ASSERT(m_scratchGPR != m_left.payloadGPR());
 80     ASSERT(m_scratchGPR != m_right.payloadGPR());
 81 #if USE(JSVALUE32_64)
 82     ASSERT(m_scratchGPR != m_left.tagGPR());
 83     ASSERT(m_scratchGPR != m_right.tagGPR());
 84     ASSERT(m_scratchFPR != InvalidFPRReg);
 85 #endif
 86 
 87     ASSERT(!m_leftOperand.isConstInt32() || !m_rightOperand.isConstInt32());
 88 
 89     if (!m_leftOperand.mightBeNumber() || !m_rightOperand.mightBeNumber())
 90         return false;
 91 
 92     if (m_leftOperand.isConstInt32() || m_rightOperand.isConstInt32()) {
 93         JSValueRegs var = m_leftOperand.isConstInt32() ? m_right : m_left;
 94         SnippetOperand&amp; varOpr = m_leftOperand.isConstInt32() ? m_rightOperand : m_leftOperand;
 95         SnippetOperand&amp; constOpr = m_leftOperand.isConstInt32() ? m_leftOperand : m_rightOperand;
 96 
</pre>
</td>
</tr>
</table>
<center><a href="JIT.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITAddGenerator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
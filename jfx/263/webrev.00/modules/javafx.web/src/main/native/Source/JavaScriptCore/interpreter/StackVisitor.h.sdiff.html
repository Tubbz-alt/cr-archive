<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/StackVisitor.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StackVisitor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMEntryRecord.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/StackVisitor.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 

 28 #include &quot;CalleeBits.h&quot;
 29 #include &quot;WasmIndexOrName.h&quot;
 30 #include &lt;wtf/Function.h&gt;
 31 #include &lt;wtf/Indenter.h&gt;
 32 #include &lt;wtf/text/WTFString.h&gt;
 33 
 34 namespace JSC {
 35 
 36 struct EntryFrame;
 37 struct InlineCallFrame;
 38 

 39 class CodeBlock;
 40 class CodeOrigin;
<span class="line-removed"> 41 class ExecState;</span>
 42 class JSCell;
 43 class JSFunction;
 44 class ClonedArguments;
 45 class Register;
 46 class RegisterAtOffsetList;
 47 
<span class="line-removed"> 48 typedef ExecState CallFrame;</span>
<span class="line-removed"> 49 </span>
 50 class StackVisitor {
 51 public:
 52     class Frame {
 53     public:
 54         enum CodeType {
 55             Global,
 56             Eval,
 57             Function,
 58             Module,
 59             Native,
 60             Wasm
 61         };
 62 
 63         size_t index() const { return m_index; }
 64         size_t argumentCountIncludingThis() const { return m_argumentCountIncludingThis; }
 65         bool callerIsEntryFrame() const { return m_callerIsEntryFrame; }
 66         CallFrame* callerFrame() const { return m_callerFrame; }
 67         CalleeBits callee() const { return m_callee; }
 68         CodeBlock* codeBlock() const { return m_codeBlock; }
<span class="line-modified"> 69         unsigned bytecodeOffset() const { return m_bytecodeOffset; }</span>
 70         InlineCallFrame* inlineCallFrame() const {
 71 #if ENABLE(DFG_JIT)
 72             return m_inlineCallFrame;
 73 #else
 74             return nullptr;
 75 #endif
 76         }
 77 
 78         bool isNativeFrame() const { return !codeBlock() &amp;&amp; !isWasmFrame(); }
 79         bool isInlinedFrame() const { return !!inlineCallFrame(); }
 80         bool isWasmFrame() const { return m_isWasmFrame; }
 81         Wasm::IndexOrName const wasmFunctionIndexOrName()
 82         {
 83             ASSERT(isWasmFrame());
 84             return m_wasmFunctionIndexOrName;
 85         }
 86 
 87         JS_EXPORT_PRIVATE String functionName() const;
 88         JS_EXPORT_PRIVATE String sourceURL() const;
 89         JS_EXPORT_PRIVATE String toString() const;
 90 
 91         JS_EXPORT_PRIVATE intptr_t sourceID();
 92 
 93         CodeType codeType() const;
 94         bool hasLineAndColumnInfo() const;
 95         JS_EXPORT_PRIVATE void computeLineAndColumn(unsigned&amp; line, unsigned&amp; column) const;
 96 
 97 #if ENABLE(ASSEMBLER)
 98         Optional&lt;RegisterAtOffsetList&gt; calleeSaveRegistersForUnwinding();
 99 #endif
100 
<span class="line-modified">101         ClonedArguments* createArguments();</span>
102         CallFrame* callFrame() const { return m_callFrame; }
103 
104         void dump(PrintStream&amp;, Indenter = Indenter()) const;
105         void dump(PrintStream&amp;, Indenter, WTF::Function&lt;void(PrintStream&amp;)&gt; prefix) const;
106 
107     private:
108         Frame() { }
109         ~Frame() { }
110 
111         void retrieveExpressionInfo(int&amp; divot, int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const;
112         void setToEnd();
113 
114 #if ENABLE(DFG_JIT)
115         InlineCallFrame* m_inlineCallFrame;
116 #endif
117         CallFrame* m_callFrame;
118         EntryFrame* m_entryFrame;
119         EntryFrame* m_callerEntryFrame;
120         CallFrame* m_callerFrame;
121         CalleeBits m_callee;
122         CodeBlock* m_codeBlock;
123         size_t m_index;
124         size_t m_argumentCountIncludingThis;
<span class="line-modified">125         unsigned m_bytecodeOffset;</span>
126         bool m_callerIsEntryFrame : 1;
127         bool m_isWasmFrame : 1;
128         Wasm::IndexOrName m_wasmFunctionIndexOrName;
129 
130         friend class StackVisitor;
131     };
132 
133     enum Status {
134         Continue = 0,
135         Done = 1
136     };
137 
138     // StackVisitor::visit() expects a Functor that implements the following method:
139     //     Status operator()(StackVisitor&amp;) const;
140 
141     enum EmptyEntryFrameAction {
142         ContinueIfTopEntryFrameIsEmpty,
143         TerminateIfTopEntryFrameIsEmpty,
144     };
145 
146     template &lt;EmptyEntryFrameAction action = ContinueIfTopEntryFrameIsEmpty, typename Functor&gt;
<span class="line-modified">147     static void visit(CallFrame* startFrame, VM* vm, const Functor&amp; functor)</span>
148     {
149         StackVisitor visitor(startFrame, vm);
150         if (action == TerminateIfTopEntryFrameIsEmpty &amp;&amp; visitor.topEntryFrameIsEmpty())
151             return;
152         while (visitor-&gt;callFrame()) {
153             Status status = functor(visitor);
154             if (status != Continue)
155                 break;
156             visitor.gotoNextFrame();
157         }
158     }
159 
160     Frame&amp; operator*() { return m_frame; }
161     ALWAYS_INLINE Frame* operator-&gt;() { return &amp;m_frame; }
162     void unwindToMachineCodeBlockFrame();
163 
164     bool topEntryFrameIsEmpty() const { return m_topEntryFrameIsEmpty; }
165 
166 private:
<span class="line-modified">167     JS_EXPORT_PRIVATE StackVisitor(CallFrame* startFrame, VM*);</span>
168 
169     JS_EXPORT_PRIVATE void gotoNextFrame();
170 
171     void readFrame(CallFrame*);
172     void readNonInlinedFrame(CallFrame*, CodeOrigin* = 0);
173 #if ENABLE(DFG_JIT)
174     void readInlinedFrame(CallFrame*, CodeOrigin*);
175 #endif
176 
177     Frame m_frame;
178     bool m_topEntryFrameIsEmpty { false };
179 };
180 
181 class CallerFunctor {
182 public:
183     CallerFunctor()
184         : m_hasSkippedFirstFrame(false)
185         , m_callerFrame(0)
186     {
187     }
</pre>
</td>
<td>
<hr />
<pre>
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
<span class="line-added"> 28 #include &quot;BytecodeIndex.h&quot;</span>
 29 #include &quot;CalleeBits.h&quot;
 30 #include &quot;WasmIndexOrName.h&quot;
 31 #include &lt;wtf/Function.h&gt;
 32 #include &lt;wtf/Indenter.h&gt;
 33 #include &lt;wtf/text/WTFString.h&gt;
 34 
 35 namespace JSC {
 36 
 37 struct EntryFrame;
 38 struct InlineCallFrame;
 39 
<span class="line-added"> 40 class CallFrame;</span>
 41 class CodeBlock;
 42 class CodeOrigin;

 43 class JSCell;
 44 class JSFunction;
 45 class ClonedArguments;
 46 class Register;
 47 class RegisterAtOffsetList;
 48 


 49 class StackVisitor {
 50 public:
 51     class Frame {
 52     public:
 53         enum CodeType {
 54             Global,
 55             Eval,
 56             Function,
 57             Module,
 58             Native,
 59             Wasm
 60         };
 61 
 62         size_t index() const { return m_index; }
 63         size_t argumentCountIncludingThis() const { return m_argumentCountIncludingThis; }
 64         bool callerIsEntryFrame() const { return m_callerIsEntryFrame; }
 65         CallFrame* callerFrame() const { return m_callerFrame; }
 66         CalleeBits callee() const { return m_callee; }
 67         CodeBlock* codeBlock() const { return m_codeBlock; }
<span class="line-modified"> 68         BytecodeIndex bytecodeIndex() const { return m_bytecodeIndex; }</span>
 69         InlineCallFrame* inlineCallFrame() const {
 70 #if ENABLE(DFG_JIT)
 71             return m_inlineCallFrame;
 72 #else
 73             return nullptr;
 74 #endif
 75         }
 76 
 77         bool isNativeFrame() const { return !codeBlock() &amp;&amp; !isWasmFrame(); }
 78         bool isInlinedFrame() const { return !!inlineCallFrame(); }
 79         bool isWasmFrame() const { return m_isWasmFrame; }
 80         Wasm::IndexOrName const wasmFunctionIndexOrName()
 81         {
 82             ASSERT(isWasmFrame());
 83             return m_wasmFunctionIndexOrName;
 84         }
 85 
 86         JS_EXPORT_PRIVATE String functionName() const;
 87         JS_EXPORT_PRIVATE String sourceURL() const;
 88         JS_EXPORT_PRIVATE String toString() const;
 89 
 90         JS_EXPORT_PRIVATE intptr_t sourceID();
 91 
 92         CodeType codeType() const;
 93         bool hasLineAndColumnInfo() const;
 94         JS_EXPORT_PRIVATE void computeLineAndColumn(unsigned&amp; line, unsigned&amp; column) const;
 95 
 96 #if ENABLE(ASSEMBLER)
 97         Optional&lt;RegisterAtOffsetList&gt; calleeSaveRegistersForUnwinding();
 98 #endif
 99 
<span class="line-modified">100         ClonedArguments* createArguments(VM&amp;);</span>
101         CallFrame* callFrame() const { return m_callFrame; }
102 
103         void dump(PrintStream&amp;, Indenter = Indenter()) const;
104         void dump(PrintStream&amp;, Indenter, WTF::Function&lt;void(PrintStream&amp;)&gt; prefix) const;
105 
106     private:
107         Frame() { }
108         ~Frame() { }
109 
110         void retrieveExpressionInfo(int&amp; divot, int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const;
111         void setToEnd();
112 
113 #if ENABLE(DFG_JIT)
114         InlineCallFrame* m_inlineCallFrame;
115 #endif
116         CallFrame* m_callFrame;
117         EntryFrame* m_entryFrame;
118         EntryFrame* m_callerEntryFrame;
119         CallFrame* m_callerFrame;
120         CalleeBits m_callee;
121         CodeBlock* m_codeBlock;
122         size_t m_index;
123         size_t m_argumentCountIncludingThis;
<span class="line-modified">124         BytecodeIndex m_bytecodeIndex;</span>
125         bool m_callerIsEntryFrame : 1;
126         bool m_isWasmFrame : 1;
127         Wasm::IndexOrName m_wasmFunctionIndexOrName;
128 
129         friend class StackVisitor;
130     };
131 
132     enum Status {
133         Continue = 0,
134         Done = 1
135     };
136 
137     // StackVisitor::visit() expects a Functor that implements the following method:
138     //     Status operator()(StackVisitor&amp;) const;
139 
140     enum EmptyEntryFrameAction {
141         ContinueIfTopEntryFrameIsEmpty,
142         TerminateIfTopEntryFrameIsEmpty,
143     };
144 
145     template &lt;EmptyEntryFrameAction action = ContinueIfTopEntryFrameIsEmpty, typename Functor&gt;
<span class="line-modified">146     static void visit(CallFrame* startFrame, VM&amp; vm, const Functor&amp; functor)</span>
147     {
148         StackVisitor visitor(startFrame, vm);
149         if (action == TerminateIfTopEntryFrameIsEmpty &amp;&amp; visitor.topEntryFrameIsEmpty())
150             return;
151         while (visitor-&gt;callFrame()) {
152             Status status = functor(visitor);
153             if (status != Continue)
154                 break;
155             visitor.gotoNextFrame();
156         }
157     }
158 
159     Frame&amp; operator*() { return m_frame; }
160     ALWAYS_INLINE Frame* operator-&gt;() { return &amp;m_frame; }
161     void unwindToMachineCodeBlockFrame();
162 
163     bool topEntryFrameIsEmpty() const { return m_topEntryFrameIsEmpty; }
164 
165 private:
<span class="line-modified">166     JS_EXPORT_PRIVATE StackVisitor(CallFrame* startFrame, VM&amp;);</span>
167 
168     JS_EXPORT_PRIVATE void gotoNextFrame();
169 
170     void readFrame(CallFrame*);
171     void readNonInlinedFrame(CallFrame*, CodeOrigin* = 0);
172 #if ENABLE(DFG_JIT)
173     void readInlinedFrame(CallFrame*, CodeOrigin*);
174 #endif
175 
176     Frame m_frame;
177     bool m_topEntryFrameIsEmpty { false };
178 };
179 
180 class CallerFunctor {
181 public:
182     CallerFunctor()
183         : m_hasSkippedFirstFrame(false)
184         , m_callerFrame(0)
185     {
186     }
</pre>
</td>
</tr>
</table>
<center><a href="StackVisitor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMEntryRecord.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
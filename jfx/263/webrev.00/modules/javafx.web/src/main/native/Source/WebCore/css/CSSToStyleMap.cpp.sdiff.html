<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSToStyleMap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSTimingFunctionValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSToStyleMap.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSToStyleMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 #include &quot;config.h&quot;
 29 #include &quot;CSSToStyleMap.h&quot;
 30 
 31 #include &quot;Animation.h&quot;
 32 #include &quot;CSSBorderImageSliceValue.h&quot;
 33 #include &quot;CSSImageGeneratorValue.h&quot;
 34 #include &quot;CSSImageSetValue.h&quot;
 35 #include &quot;CSSImageValue.h&quot;
 36 #include &quot;CSSPrimitiveValue.h&quot;
 37 #include &quot;CSSPrimitiveValueMappings.h&quot;
 38 #include &quot;CSSTimingFunctionValue.h&quot;
 39 #include &quot;CSSValueKeywords.h&quot;
 40 #include &quot;FillLayer.h&quot;
 41 #include &quot;Pair.h&quot;
 42 #include &quot;Rect.h&quot;
 43 #include &quot;StyleBuilderConverter.h&quot;
 44 #include &quot;StyleResolver.h&quot;
 45 
 46 namespace WebCore {
 47 
<span class="line-modified"> 48 CSSToStyleMap::CSSToStyleMap(StyleResolver* resolver)</span>
<span class="line-modified"> 49     : m_resolver(resolver)</span>
 50 {
 51 }
 52 
 53 RenderStyle* CSSToStyleMap::style() const
 54 {
<span class="line-modified"> 55     return m_resolver-&gt;style();</span>
<span class="line-removed"> 56 }</span>
<span class="line-removed"> 57 </span>
<span class="line-removed"> 58 const RenderStyle* CSSToStyleMap::rootElementStyle() const</span>
<span class="line-removed"> 59 {</span>
<span class="line-removed"> 60     return m_resolver-&gt;rootElementStyle();</span>
 61 }
 62 
 63 bool CSSToStyleMap::useSVGZoomRules() const
 64 {
<span class="line-modified"> 65     return m_resolver-&gt;useSVGZoomRules();</span>
 66 }
 67 
 68 RefPtr&lt;StyleImage&gt; CSSToStyleMap::styleImage(CSSValue&amp; value)
 69 {
<span class="line-modified"> 70     return m_resolver-&gt;styleImage(value);</span>
 71 }
 72 
 73 void CSSToStyleMap::mapFillAttachment(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
 74 {
 75     if (value.treatAsInitialValue(propertyID)) {
 76         layer.setAttachment(FillLayer::initialFillAttachment(layer.type()));
 77         return;
 78     }
 79 
 80     if (!is&lt;CSSPrimitiveValue&gt;(value))
 81         return;
 82 
 83     switch (downcast&lt;CSSPrimitiveValue&gt;(value).valueID()) {
 84     case CSSValueFixed:
 85         layer.setAttachment(FillAttachment::FixedBackground);
 86         break;
 87     case CSSValueScroll:
 88         layer.setAttachment(FillAttachment::ScrollBackground);
 89         break;
 90     case CSSValueLocal:
</pre>
<hr />
<pre>
197 {
198     if (value.treatAsInitialValue(propertyID)) {
199         layer.setSize(FillLayer::initialFillSize(layer.type()));
200         return;
201     }
202 
203     if (!is&lt;CSSPrimitiveValue&gt;(value))
204         return;
205 
206     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
207     FillSize fillSize;
208     switch (primitiveValue.valueID()) {
209     case CSSValueContain:
210         fillSize.type = FillSizeType::Contain;
211         break;
212     case CSSValueCover:
213         fillSize.type = FillSizeType::Cover;
214         break;
215     default:
216         ASSERT(fillSize.type == FillSizeType::Size);
<span class="line-modified">217         if (!convertToLengthSize(primitiveValue, m_resolver-&gt;state().cssToLengthConversionData(), fillSize.size))</span>
218             return;
219         break;
220     }
221     layer.setSize(fillSize);
222 }
223 
224 void CSSToStyleMap::mapFillXPosition(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
225 {
226     if (value.treatAsInitialValue(propertyID)) {
227         layer.setXPosition(FillLayer::initialFillXPosition(layer.type()));
228         return;
229     }
230 
231     if (!is&lt;CSSPrimitiveValue&gt;(value))
232         return;
233 
234     auto* primitiveValue = &amp;downcast&lt;CSSPrimitiveValue&gt;(value);
235     Pair* pair = primitiveValue-&gt;pairValue();
236     Length length;
237     if (pair) {
238         ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPositionX || propertyID == CSSPropertyWebkitMaskPositionX);
<span class="line-modified">239         length = StyleBuilderConverter::convertLength(*m_resolver, *pair-&gt;second());</span>
240     } else
<span class="line-modified">241         length = StyleBuilderConverter::convertPositionComponentX(*m_resolver, value);</span>
242 
243     layer.setXPosition(length);
244     if (pair)
245         layer.setBackgroundXOrigin(*pair-&gt;first());
246 }
247 
248 void CSSToStyleMap::mapFillYPosition(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
249 {
250     if (value.treatAsInitialValue(propertyID)) {
251         layer.setYPosition(FillLayer::initialFillYPosition(layer.type()));
252         return;
253     }
254 
255     if (!is&lt;CSSPrimitiveValue&gt;(value))
256         return;
257 
258     auto* primitiveValue = &amp;downcast&lt;CSSPrimitiveValue&gt;(value);
259     Pair* pair = primitiveValue-&gt;pairValue();
260     Length length;
261     if (pair) {
262         ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPositionY || propertyID == CSSPropertyWebkitMaskPositionY);
<span class="line-modified">263         length = StyleBuilderConverter::convertLength(*m_resolver, *pair-&gt;second());</span>
264     } else
<span class="line-modified">265         length = StyleBuilderConverter::convertPositionComponentY(*m_resolver, value);</span>
266 
267     layer.setYPosition(length);
268     if (pair)
269         layer.setBackgroundYOrigin(*pair-&gt;first());
270 }
271 
272 void CSSToStyleMap::mapFillMaskSourceType(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
273 {
274     MaskSourceType type = FillLayer::initialFillMaskSourceType(layer.type());
275     if (value.treatAsInitialValue(propertyID)) {
276         layer.setMaskSourceType(type);
277         return;
278     }
279 
280     if (!is&lt;CSSPrimitiveValue&gt;(value))
281         return;
282 
283     switch (downcast&lt;CSSPrimitiveValue&gt;(value).valueID()) {
284     case CSSValueAlpha:
285         type = MaskSourceType::Alpha;
</pre>
<hr />
<pre>
392     if (primitiveValue.valueID() == CSSValueInfinite)
393         animation.setIterationCount(Animation::IterationCountInfinite);
394     else
395         animation.setIterationCount(primitiveValue.floatValue());
396 }
397 
398 void CSSToStyleMap::mapAnimationName(Animation&amp; layer, const CSSValue&amp; value)
399 {
400     if (value.treatAsInitialValue(CSSPropertyAnimationName)) {
401         layer.setName(Animation::initialName());
402         return;
403     }
404 
405     if (!is&lt;CSSPrimitiveValue&gt;(value))
406         return;
407 
408     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
409     if (primitiveValue.valueID() == CSSValueNone)
410         layer.setIsNoneAnimation(true);
411     else
<span class="line-modified">412         layer.setName(primitiveValue.stringValue(), m_resolver-&gt;state().styleScopeOrdinal());</span>
413 }
414 
415 void CSSToStyleMap::mapAnimationPlayState(Animation&amp; layer, const CSSValue&amp; value)
416 {
417     if (value.treatAsInitialValue(CSSPropertyAnimationPlayState)) {
418         layer.setPlayState(Animation::initialPlayState());
419         return;
420     }
421 
422     if (!is&lt;CSSPrimitiveValue&gt;(value))
423         return;
424 
425     AnimationPlayState playState = (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValuePaused) ? AnimationPlayState::Paused : AnimationPlayState::Playing;
426     layer.setPlayState(playState);
427 }
428 
429 void CSSToStyleMap::mapAnimationProperty(Animation&amp; animation, const CSSValue&amp; value)
430 {
431     if (value.treatAsInitialValue(CSSPropertyAnimation)) {
432         animation.setAnimationMode(Animation::AnimateAll);
</pre>
<hr />
<pre>
551             style()-&gt;setBorderBottomWidth(image.borderSlices().bottom().value());
552         if (image.borderSlices().left().isFixed())
553             style()-&gt;setBorderLeftWidth(image.borderSlices().left().value());
554     }
555 }
556 
557 void CSSToStyleMap::mapNinePieceImageSlice(CSSValue&amp; value, NinePieceImage&amp; image)
558 {
559     if (!is&lt;CSSBorderImageSliceValue&gt;(value))
560         return;
561 
562     // Retrieve the border image value.
563     auto&amp; borderImageSlice = downcast&lt;CSSBorderImageSliceValue&gt;(value);
564 
565     // Set up a length box to represent our image slices.
566     LengthBox box;
567     Quad* slices = borderImageSlice.slices();
568     if (slices-&gt;top()-&gt;isPercentage())
569         box.top() = Length(slices-&gt;top()-&gt;doubleValue(), Percent);
570     else
<span class="line-modified">571         box.top() = Length(slices-&gt;top()-&gt;intValue(CSSPrimitiveValue::CSS_NUMBER), Fixed);</span>
572     if (slices-&gt;bottom()-&gt;isPercentage())
573         box.bottom() = Length(slices-&gt;bottom()-&gt;doubleValue(), Percent);
574     else
<span class="line-modified">575         box.bottom() = Length((int)slices-&gt;bottom()-&gt;floatValue(CSSPrimitiveValue::CSS_NUMBER), Fixed);</span>
576     if (slices-&gt;left()-&gt;isPercentage())
577         box.left() = Length(slices-&gt;left()-&gt;doubleValue(), Percent);
578     else
<span class="line-modified">579         box.left() = Length(slices-&gt;left()-&gt;intValue(CSSPrimitiveValue::CSS_NUMBER), Fixed);</span>
580     if (slices-&gt;right()-&gt;isPercentage())
581         box.right() = Length(slices-&gt;right()-&gt;doubleValue(), Percent);
582     else
<span class="line-modified">583         box.right() = Length(slices-&gt;right()-&gt;intValue(CSSPrimitiveValue::CSS_NUMBER), Fixed);</span>
584     image.setImageSlices(box);
585 
586     // Set our fill mode.
587     image.setFill(borderImageSlice.m_fill);
588 }
589 
590 LengthBox CSSToStyleMap::mapNinePieceImageQuad(CSSValue&amp; value)
591 {
592     if (!is&lt;CSSPrimitiveValue&gt;(value))
593         return LengthBox();
594 
595     // Get our zoom value.
<span class="line-modified">596     CSSToLengthConversionData conversionData = useSVGZoomRules() ? m_resolver-&gt;state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f) : m_resolver-&gt;state().cssToLengthConversionData();</span>
597 
598     // Retrieve the primitive value.
599     auto&amp; borderWidths = downcast&lt;CSSPrimitiveValue&gt;(value);
600 
601     // Set up a length box to represent our image slices.
602     LengthBox box; // Defaults to &#39;auto&#39; so we don&#39;t have to handle that explicitly below.
603     Quad* slices = borderWidths.quadValue();
604     if (slices-&gt;top()-&gt;isNumber())
605         box.top() = Length(slices-&gt;top()-&gt;intValue(), Relative);
606     else if (slices-&gt;top()-&gt;isPercentage())
<span class="line-modified">607         box.top() = Length(slices-&gt;top()-&gt;doubleValue(CSSPrimitiveValue::CSS_PERCENTAGE), Percent);</span>
608     else if (slices-&gt;top()-&gt;valueID() != CSSValueAuto)
609         box.top() = slices-&gt;top()-&gt;computeLength&lt;Length&gt;(conversionData);
610 
611     if (slices-&gt;right()-&gt;isNumber())
612         box.right() = Length(slices-&gt;right()-&gt;intValue(), Relative);
613     else if (slices-&gt;right()-&gt;isPercentage())
<span class="line-modified">614         box.right() = Length(slices-&gt;right()-&gt;doubleValue(CSSPrimitiveValue::CSS_PERCENTAGE), Percent);</span>
615     else if (slices-&gt;right()-&gt;valueID() != CSSValueAuto)
616         box.right() = slices-&gt;right()-&gt;computeLength&lt;Length&gt;(conversionData);
617 
618     if (slices-&gt;bottom()-&gt;isNumber())
619         box.bottom() = Length(slices-&gt;bottom()-&gt;intValue(), Relative);
620     else if (slices-&gt;bottom()-&gt;isPercentage())
<span class="line-modified">621         box.bottom() = Length(slices-&gt;bottom()-&gt;doubleValue(CSSPrimitiveValue::CSS_PERCENTAGE), Percent);</span>
622     else if (slices-&gt;bottom()-&gt;valueID() != CSSValueAuto)
623         box.bottom() = slices-&gt;bottom()-&gt;computeLength&lt;Length&gt;(conversionData);
624 
625     if (slices-&gt;left()-&gt;isNumber())
626         box.left() = Length(slices-&gt;left()-&gt;intValue(), Relative);
627     else if (slices-&gt;left()-&gt;isPercentage())
<span class="line-modified">628         box.left() = Length(slices-&gt;left()-&gt;doubleValue(CSSPrimitiveValue::CSS_PERCENTAGE), Percent);</span>
629     else if (slices-&gt;left()-&gt;valueID() != CSSValueAuto)
630         box.left() = slices-&gt;left()-&gt;computeLength&lt;Length&gt;(conversionData);
631 
632     return box;
633 }
634 
635 void CSSToStyleMap::mapNinePieceImageRepeat(CSSValue&amp; value, NinePieceImage&amp; image)
636 {
637     if (!is&lt;CSSPrimitiveValue&gt;(value))
638         return;
639 
640     CSSPrimitiveValue&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
641     Pair* pair = primitiveValue.pairValue();
642     if (!pair || !pair-&gt;first() || !pair-&gt;second())
643         return;
644 
645     CSSValueID firstIdentifier = pair-&gt;first()-&gt;valueID();
646     CSSValueID secondIdentifier = pair-&gt;second()-&gt;valueID();
647 
<span class="line-modified">648     ENinePieceImageRule horizontalRule;</span>
649     switch (firstIdentifier) {
650     case CSSValueStretch:
<span class="line-modified">651         horizontalRule = StretchImageRule;</span>
652         break;
653     case CSSValueRound:
<span class="line-modified">654         horizontalRule = RoundImageRule;</span>
655         break;
656     case CSSValueSpace:
<span class="line-modified">657         horizontalRule = SpaceImageRule;</span>
658         break;
659     default: // CSSValueRepeat
<span class="line-modified">660         horizontalRule = RepeatImageRule;</span>
661         break;
662     }
663     image.setHorizontalRule(horizontalRule);
664 
<span class="line-modified">665     ENinePieceImageRule verticalRule;</span>
666     switch (secondIdentifier) {
667     case CSSValueStretch:
<span class="line-modified">668         verticalRule = StretchImageRule;</span>
669         break;
670     case CSSValueRound:
<span class="line-modified">671         verticalRule = RoundImageRule;</span>
672         break;
673     case CSSValueSpace:
<span class="line-modified">674         verticalRule = SpaceImageRule;</span>
675         break;
676     default: // CSSValueRepeat
<span class="line-modified">677         verticalRule = RepeatImageRule;</span>
678         break;
679     }
680     image.setVerticalRule(verticalRule);
681 }
682 
683 };
</pre>
</td>
<td>
<hr />
<pre>
 28 #include &quot;config.h&quot;
 29 #include &quot;CSSToStyleMap.h&quot;
 30 
 31 #include &quot;Animation.h&quot;
 32 #include &quot;CSSBorderImageSliceValue.h&quot;
 33 #include &quot;CSSImageGeneratorValue.h&quot;
 34 #include &quot;CSSImageSetValue.h&quot;
 35 #include &quot;CSSImageValue.h&quot;
 36 #include &quot;CSSPrimitiveValue.h&quot;
 37 #include &quot;CSSPrimitiveValueMappings.h&quot;
 38 #include &quot;CSSTimingFunctionValue.h&quot;
 39 #include &quot;CSSValueKeywords.h&quot;
 40 #include &quot;FillLayer.h&quot;
 41 #include &quot;Pair.h&quot;
 42 #include &quot;Rect.h&quot;
 43 #include &quot;StyleBuilderConverter.h&quot;
 44 #include &quot;StyleResolver.h&quot;
 45 
 46 namespace WebCore {
 47 
<span class="line-modified"> 48 CSSToStyleMap::CSSToStyleMap(Style::BuilderState&amp; builderState)</span>
<span class="line-modified"> 49     : m_builderState(builderState)</span>
 50 {
 51 }
 52 
 53 RenderStyle* CSSToStyleMap::style() const
 54 {
<span class="line-modified"> 55     return &amp;m_builderState.style();</span>





 56 }
 57 
 58 bool CSSToStyleMap::useSVGZoomRules() const
 59 {
<span class="line-modified"> 60     return m_builderState.useSVGZoomRules();</span>
 61 }
 62 
 63 RefPtr&lt;StyleImage&gt; CSSToStyleMap::styleImage(CSSValue&amp; value)
 64 {
<span class="line-modified"> 65     return m_builderState.createStyleImage(value);</span>
 66 }
 67 
 68 void CSSToStyleMap::mapFillAttachment(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
 69 {
 70     if (value.treatAsInitialValue(propertyID)) {
 71         layer.setAttachment(FillLayer::initialFillAttachment(layer.type()));
 72         return;
 73     }
 74 
 75     if (!is&lt;CSSPrimitiveValue&gt;(value))
 76         return;
 77 
 78     switch (downcast&lt;CSSPrimitiveValue&gt;(value).valueID()) {
 79     case CSSValueFixed:
 80         layer.setAttachment(FillAttachment::FixedBackground);
 81         break;
 82     case CSSValueScroll:
 83         layer.setAttachment(FillAttachment::ScrollBackground);
 84         break;
 85     case CSSValueLocal:
</pre>
<hr />
<pre>
192 {
193     if (value.treatAsInitialValue(propertyID)) {
194         layer.setSize(FillLayer::initialFillSize(layer.type()));
195         return;
196     }
197 
198     if (!is&lt;CSSPrimitiveValue&gt;(value))
199         return;
200 
201     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
202     FillSize fillSize;
203     switch (primitiveValue.valueID()) {
204     case CSSValueContain:
205         fillSize.type = FillSizeType::Contain;
206         break;
207     case CSSValueCover:
208         fillSize.type = FillSizeType::Cover;
209         break;
210     default:
211         ASSERT(fillSize.type == FillSizeType::Size);
<span class="line-modified">212         if (!convertToLengthSize(primitiveValue, m_builderState.cssToLengthConversionData(), fillSize.size))</span>
213             return;
214         break;
215     }
216     layer.setSize(fillSize);
217 }
218 
219 void CSSToStyleMap::mapFillXPosition(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
220 {
221     if (value.treatAsInitialValue(propertyID)) {
222         layer.setXPosition(FillLayer::initialFillXPosition(layer.type()));
223         return;
224     }
225 
226     if (!is&lt;CSSPrimitiveValue&gt;(value))
227         return;
228 
229     auto* primitiveValue = &amp;downcast&lt;CSSPrimitiveValue&gt;(value);
230     Pair* pair = primitiveValue-&gt;pairValue();
231     Length length;
232     if (pair) {
233         ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPositionX || propertyID == CSSPropertyWebkitMaskPositionX);
<span class="line-modified">234         length = Style::BuilderConverter::convertLength(m_builderState, *pair-&gt;second());</span>
235     } else
<span class="line-modified">236         length = Style::BuilderConverter::convertPositionComponentX(m_builderState, value);</span>
237 
238     layer.setXPosition(length);
239     if (pair)
240         layer.setBackgroundXOrigin(*pair-&gt;first());
241 }
242 
243 void CSSToStyleMap::mapFillYPosition(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
244 {
245     if (value.treatAsInitialValue(propertyID)) {
246         layer.setYPosition(FillLayer::initialFillYPosition(layer.type()));
247         return;
248     }
249 
250     if (!is&lt;CSSPrimitiveValue&gt;(value))
251         return;
252 
253     auto* primitiveValue = &amp;downcast&lt;CSSPrimitiveValue&gt;(value);
254     Pair* pair = primitiveValue-&gt;pairValue();
255     Length length;
256     if (pair) {
257         ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPositionY || propertyID == CSSPropertyWebkitMaskPositionY);
<span class="line-modified">258         length = Style::BuilderConverter::convertLength(m_builderState, *pair-&gt;second());</span>
259     } else
<span class="line-modified">260         length = Style::BuilderConverter::convertPositionComponentY(m_builderState, value);</span>
261 
262     layer.setYPosition(length);
263     if (pair)
264         layer.setBackgroundYOrigin(*pair-&gt;first());
265 }
266 
267 void CSSToStyleMap::mapFillMaskSourceType(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
268 {
269     MaskSourceType type = FillLayer::initialFillMaskSourceType(layer.type());
270     if (value.treatAsInitialValue(propertyID)) {
271         layer.setMaskSourceType(type);
272         return;
273     }
274 
275     if (!is&lt;CSSPrimitiveValue&gt;(value))
276         return;
277 
278     switch (downcast&lt;CSSPrimitiveValue&gt;(value).valueID()) {
279     case CSSValueAlpha:
280         type = MaskSourceType::Alpha;
</pre>
<hr />
<pre>
387     if (primitiveValue.valueID() == CSSValueInfinite)
388         animation.setIterationCount(Animation::IterationCountInfinite);
389     else
390         animation.setIterationCount(primitiveValue.floatValue());
391 }
392 
393 void CSSToStyleMap::mapAnimationName(Animation&amp; layer, const CSSValue&amp; value)
394 {
395     if (value.treatAsInitialValue(CSSPropertyAnimationName)) {
396         layer.setName(Animation::initialName());
397         return;
398     }
399 
400     if (!is&lt;CSSPrimitiveValue&gt;(value))
401         return;
402 
403     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
404     if (primitiveValue.valueID() == CSSValueNone)
405         layer.setIsNoneAnimation(true);
406     else
<span class="line-modified">407         layer.setName(primitiveValue.stringValue(), m_builderState.styleScopeOrdinal());</span>
408 }
409 
410 void CSSToStyleMap::mapAnimationPlayState(Animation&amp; layer, const CSSValue&amp; value)
411 {
412     if (value.treatAsInitialValue(CSSPropertyAnimationPlayState)) {
413         layer.setPlayState(Animation::initialPlayState());
414         return;
415     }
416 
417     if (!is&lt;CSSPrimitiveValue&gt;(value))
418         return;
419 
420     AnimationPlayState playState = (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValuePaused) ? AnimationPlayState::Paused : AnimationPlayState::Playing;
421     layer.setPlayState(playState);
422 }
423 
424 void CSSToStyleMap::mapAnimationProperty(Animation&amp; animation, const CSSValue&amp; value)
425 {
426     if (value.treatAsInitialValue(CSSPropertyAnimation)) {
427         animation.setAnimationMode(Animation::AnimateAll);
</pre>
<hr />
<pre>
546             style()-&gt;setBorderBottomWidth(image.borderSlices().bottom().value());
547         if (image.borderSlices().left().isFixed())
548             style()-&gt;setBorderLeftWidth(image.borderSlices().left().value());
549     }
550 }
551 
552 void CSSToStyleMap::mapNinePieceImageSlice(CSSValue&amp; value, NinePieceImage&amp; image)
553 {
554     if (!is&lt;CSSBorderImageSliceValue&gt;(value))
555         return;
556 
557     // Retrieve the border image value.
558     auto&amp; borderImageSlice = downcast&lt;CSSBorderImageSliceValue&gt;(value);
559 
560     // Set up a length box to represent our image slices.
561     LengthBox box;
562     Quad* slices = borderImageSlice.slices();
563     if (slices-&gt;top()-&gt;isPercentage())
564         box.top() = Length(slices-&gt;top()-&gt;doubleValue(), Percent);
565     else
<span class="line-modified">566         box.top() = Length(slices-&gt;top()-&gt;intValue(CSSUnitType::CSS_NUMBER), Fixed);</span>
567     if (slices-&gt;bottom()-&gt;isPercentage())
568         box.bottom() = Length(slices-&gt;bottom()-&gt;doubleValue(), Percent);
569     else
<span class="line-modified">570         box.bottom() = Length((int)slices-&gt;bottom()-&gt;floatValue(CSSUnitType::CSS_NUMBER), Fixed);</span>
571     if (slices-&gt;left()-&gt;isPercentage())
572         box.left() = Length(slices-&gt;left()-&gt;doubleValue(), Percent);
573     else
<span class="line-modified">574         box.left() = Length(slices-&gt;left()-&gt;intValue(CSSUnitType::CSS_NUMBER), Fixed);</span>
575     if (slices-&gt;right()-&gt;isPercentage())
576         box.right() = Length(slices-&gt;right()-&gt;doubleValue(), Percent);
577     else
<span class="line-modified">578         box.right() = Length(slices-&gt;right()-&gt;intValue(CSSUnitType::CSS_NUMBER), Fixed);</span>
579     image.setImageSlices(box);
580 
581     // Set our fill mode.
582     image.setFill(borderImageSlice.m_fill);
583 }
584 
585 LengthBox CSSToStyleMap::mapNinePieceImageQuad(CSSValue&amp; value)
586 {
587     if (!is&lt;CSSPrimitiveValue&gt;(value))
588         return LengthBox();
589 
590     // Get our zoom value.
<span class="line-modified">591     CSSToLengthConversionData conversionData = useSVGZoomRules() ? m_builderState.cssToLengthConversionData().copyWithAdjustedZoom(1.0f) : m_builderState.cssToLengthConversionData();</span>
592 
593     // Retrieve the primitive value.
594     auto&amp; borderWidths = downcast&lt;CSSPrimitiveValue&gt;(value);
595 
596     // Set up a length box to represent our image slices.
597     LengthBox box; // Defaults to &#39;auto&#39; so we don&#39;t have to handle that explicitly below.
598     Quad* slices = borderWidths.quadValue();
599     if (slices-&gt;top()-&gt;isNumber())
600         box.top() = Length(slices-&gt;top()-&gt;intValue(), Relative);
601     else if (slices-&gt;top()-&gt;isPercentage())
<span class="line-modified">602         box.top() = Length(slices-&gt;top()-&gt;doubleValue(CSSUnitType::CSS_PERCENTAGE), Percent);</span>
603     else if (slices-&gt;top()-&gt;valueID() != CSSValueAuto)
604         box.top() = slices-&gt;top()-&gt;computeLength&lt;Length&gt;(conversionData);
605 
606     if (slices-&gt;right()-&gt;isNumber())
607         box.right() = Length(slices-&gt;right()-&gt;intValue(), Relative);
608     else if (slices-&gt;right()-&gt;isPercentage())
<span class="line-modified">609         box.right() = Length(slices-&gt;right()-&gt;doubleValue(CSSUnitType::CSS_PERCENTAGE), Percent);</span>
610     else if (slices-&gt;right()-&gt;valueID() != CSSValueAuto)
611         box.right() = slices-&gt;right()-&gt;computeLength&lt;Length&gt;(conversionData);
612 
613     if (slices-&gt;bottom()-&gt;isNumber())
614         box.bottom() = Length(slices-&gt;bottom()-&gt;intValue(), Relative);
615     else if (slices-&gt;bottom()-&gt;isPercentage())
<span class="line-modified">616         box.bottom() = Length(slices-&gt;bottom()-&gt;doubleValue(CSSUnitType::CSS_PERCENTAGE), Percent);</span>
617     else if (slices-&gt;bottom()-&gt;valueID() != CSSValueAuto)
618         box.bottom() = slices-&gt;bottom()-&gt;computeLength&lt;Length&gt;(conversionData);
619 
620     if (slices-&gt;left()-&gt;isNumber())
621         box.left() = Length(slices-&gt;left()-&gt;intValue(), Relative);
622     else if (slices-&gt;left()-&gt;isPercentage())
<span class="line-modified">623         box.left() = Length(slices-&gt;left()-&gt;doubleValue(CSSUnitType::CSS_PERCENTAGE), Percent);</span>
624     else if (slices-&gt;left()-&gt;valueID() != CSSValueAuto)
625         box.left() = slices-&gt;left()-&gt;computeLength&lt;Length&gt;(conversionData);
626 
627     return box;
628 }
629 
630 void CSSToStyleMap::mapNinePieceImageRepeat(CSSValue&amp; value, NinePieceImage&amp; image)
631 {
632     if (!is&lt;CSSPrimitiveValue&gt;(value))
633         return;
634 
635     CSSPrimitiveValue&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
636     Pair* pair = primitiveValue.pairValue();
637     if (!pair || !pair-&gt;first() || !pair-&gt;second())
638         return;
639 
640     CSSValueID firstIdentifier = pair-&gt;first()-&gt;valueID();
641     CSSValueID secondIdentifier = pair-&gt;second()-&gt;valueID();
642 
<span class="line-modified">643     NinePieceImageRule horizontalRule;</span>
644     switch (firstIdentifier) {
645     case CSSValueStretch:
<span class="line-modified">646         horizontalRule = NinePieceImageRule::Stretch;</span>
647         break;
648     case CSSValueRound:
<span class="line-modified">649         horizontalRule = NinePieceImageRule::Round;</span>
650         break;
651     case CSSValueSpace:
<span class="line-modified">652         horizontalRule = NinePieceImageRule::Space;</span>
653         break;
654     default: // CSSValueRepeat
<span class="line-modified">655         horizontalRule = NinePieceImageRule::Repeat;</span>
656         break;
657     }
658     image.setHorizontalRule(horizontalRule);
659 
<span class="line-modified">660     NinePieceImageRule verticalRule;</span>
661     switch (secondIdentifier) {
662     case CSSValueStretch:
<span class="line-modified">663         verticalRule = NinePieceImageRule::Stretch;</span>
664         break;
665     case CSSValueRound:
<span class="line-modified">666         verticalRule = NinePieceImageRule::Round;</span>
667         break;
668     case CSSValueSpace:
<span class="line-modified">669         verticalRule = NinePieceImageRule::Space;</span>
670         break;
671     default: // CSSValueRepeat
<span class="line-modified">672         verticalRule = NinePieceImageRule::Repeat;</span>
673         break;
674     }
675     image.setVerticalRule(verticalRule);
676 }
677 
678 };
</pre>
</td>
</tr>
</table>
<center><a href="CSSTimingFunctionValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSToStyleMap.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerParseData.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerParseData.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerParseData.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerParseData.cpp
@@ -31,47 +31,27 @@
 
 namespace JSC {
 
 Optional<JSTextPosition> DebuggerPausePositions::breakpointLocationForLineColumn(int line, int column)
 {
-    unsigned start = 0;
-    unsigned end = m_positions.size();
-    while (start != end) {
-        unsigned middle = start + ((end - start) / 2);
-        DebuggerPausePosition& pausePosition = m_positions[middle];
-        int pauseLine = pausePosition.position.line;
-        int pauseColumn = pausePosition.position.offset - pausePosition.position.lineStartOffset;
-
-        if (line < pauseLine) {
-            end = middle;
-            continue;
-        }
-        if (line > pauseLine) {
-            start = middle + 1;
-            continue;
-        }
-
-        if (column == pauseColumn) {
-            // Found an exact position match. Roll forward if this was a function Entry.
-            // We are guarenteed to have a Leave for an Entry so we don't need to bounds check.
-            while (true) {
-                if (pausePosition.type != DebuggerPausePositionType::Enter)
-                    return Optional<JSTextPosition>(pausePosition.position);
-                pausePosition = m_positions[middle++];
-            }
-        }
+    DebuggerPausePosition position = { DebuggerPausePositionType::Invalid, JSTextPosition(line, column, 0) };
+    auto it = std::lower_bound(m_positions.begin(), m_positions.end(), position, [] (const DebuggerPausePosition& a, const DebuggerPausePosition& b) {
+        if (a.position.line == b.position.line)
+            return a.position.column() < b.position.column();
+        return a.position.line < b.position.line;
+    });
+    if (it == m_positions.end())
+        return WTF::nullopt;
 
-        if (column < pauseColumn)
-            end = middle;
-        else
-            start = middle + 1;
+    if (line == it->position.line && column == it->position.column()) {
+        // Found an exact position match. Roll forward if this was a function Entry.
+        // We are guaranteed to have a Leave for an Entry so we don't need to bounds check.
+        while (it->type == DebuggerPausePositionType::Enter)
+            ++it;
+        return it->position;
     }
 
-    // Past the end, no possible pause locations.
-    if (start >= m_positions.size())
-        return WTF::nullopt;
-
     // If the next location is a function Entry we will need to decide if we should go into
     // the function or go past the function. We decide to go into the function if the
     // input is on the same line as the function entry. For example:
     //
     //     1. x;
@@ -84,20 +64,21 @@
     //
     // If the input was line 2, skip past functions to pause on line 7.
     // If the input was line 3, go into the function to pause on line 4.
 
     // Valid pause location. Use it.
-    DebuggerPausePosition& firstSlidePosition = m_positions[start];
+    auto& firstSlidePosition = *it;
     if (firstSlidePosition.type != DebuggerPausePositionType::Enter)
         return Optional<JSTextPosition>(firstSlidePosition.position);
 
     // Determine if we should enter this function or skip past it.
     // If entryStackSize is > 0 we are skipping functions.
     bool shouldEnterFunction = firstSlidePosition.position.line == line;
     int entryStackSize = shouldEnterFunction ? 0 : 1;
-    for (unsigned i = start + 1; i < m_positions.size(); ++i) {
-        DebuggerPausePosition& slidePosition = m_positions[i];
+    ++it;
+    for (; it != m_positions.end(); ++it) {
+        auto& slidePosition = *it;
         ASSERT(entryStackSize >= 0);
 
         // Already skipping functions.
         if (entryStackSize) {
             if (slidePosition.type == DebuggerPausePositionType::Enter)
@@ -122,29 +103,31 @@
 }
 
 void DebuggerPausePositions::sort()
 {
     std::sort(m_positions.begin(), m_positions.end(), [] (const DebuggerPausePosition& a, const DebuggerPausePosition& b) {
+        if (a.position.offset == b.position.offset)
+            return a.type < b.type;
         return a.position.offset < b.position.offset;
     });
 }
 
 typedef enum { Program, Module } DebuggerParseInfoTag;
 template <DebuggerParseInfoTag T> struct DebuggerParseInfo { };
 
 template <> struct DebuggerParseInfo<Program> {
     typedef JSC::ProgramNode RootNode;
-    static const SourceParseMode parseMode = SourceParseMode::ProgramMode;
-    static const JSParserStrictMode strictMode = JSParserStrictMode::NotStrict;
-    static const JSParserScriptMode scriptMode = JSParserScriptMode::Classic;
+    static constexpr SourceParseMode parseMode = SourceParseMode::ProgramMode;
+    static constexpr JSParserStrictMode strictMode = JSParserStrictMode::NotStrict;
+    static constexpr JSParserScriptMode scriptMode = JSParserScriptMode::Classic;
 };
 
 template <> struct DebuggerParseInfo<Module> {
     typedef JSC::ModuleProgramNode RootNode;
-    static const SourceParseMode parseMode = SourceParseMode::ModuleEvaluateMode;
-    static const JSParserStrictMode strictMode = JSParserStrictMode::Strict;
-    static const JSParserScriptMode scriptMode = JSParserScriptMode::Module;
+    static constexpr SourceParseMode parseMode = SourceParseMode::ModuleEvaluateMode;
+    static constexpr JSParserStrictMode strictMode = JSParserStrictMode::Strict;
+    static constexpr JSParserScriptMode scriptMode = JSParserScriptMode::Module;
 };
 
 template <DebuggerParseInfoTag T>
 bool gatherDebuggerParseData(VM& vm, const SourceCode& source, DebuggerParseData& debuggerParseData)
 {

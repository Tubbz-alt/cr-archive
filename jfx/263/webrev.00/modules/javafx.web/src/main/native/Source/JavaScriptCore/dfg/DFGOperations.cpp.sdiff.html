<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGOpInfo.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOperations.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGOperations.h&quot;
  28 
  29 #include &quot;ArrayConstructor.h&quot;
  30 #include &quot;ButterflyInlines.h&quot;
  31 #include &quot;ClonedArguments.h&quot;
  32 #include &quot;CodeBlock.h&quot;
  33 #include &quot;CommonSlowPaths.h&quot;
  34 #include &quot;DFGDriver.h&quot;
  35 #include &quot;DFGJITCode.h&quot;
  36 #include &quot;DFGOSRExit.h&quot;
  37 #include &quot;DFGThunks.h&quot;
  38 #include &quot;DFGToFTLDeferredCompilationCallback.h&quot;
  39 #include &quot;DFGToFTLForOSREntryDeferredCompilationCallback.h&quot;
  40 #include &quot;DFGWorklist.h&quot;

  41 #include &quot;DefinePropertyAttributes.h&quot;
  42 #include &quot;DirectArguments.h&quot;

  43 #include &quot;FTLForOSREntryJITCode.h&quot;
  44 #include &quot;FTLOSREntry.h&quot;
  45 #include &quot;FrameTracers.h&quot;
  46 #include &quot;HasOwnPropertyCache.h&quot;
  47 #include &quot;HostCallReturnValue.h&quot;
  48 #include &quot;Interpreter.h&quot;
  49 #include &quot;JIT.h&quot;
  50 #include &quot;JITExceptions.h&quot;
  51 #include &quot;JSArrayInlines.h&quot;


  52 #include &quot;JSBigInt.h&quot;
  53 #include &quot;JSCInlines.h&quot;
<span class="line-removed">  54 #include &quot;JSFixedArray.h&quot;</span>
  55 #include &quot;JSGenericTypedArrayViewConstructorInlines.h&quot;
  56 #include &quot;JSGlobalObjectFunctions.h&quot;
  57 #include &quot;JSImmutableButterfly.h&quot;


  58 #include &quot;JSLexicalEnvironment.h&quot;
  59 #include &quot;JSMap.h&quot;

  60 #include &quot;JSPropertyNameEnumerator.h&quot;
  61 #include &quot;JSSet.h&quot;
  62 #include &quot;JSWeakMap.h&quot;
  63 #include &quot;JSWeakSet.h&quot;

  64 #include &quot;NumberConstructor.h&quot;
  65 #include &quot;ObjectConstructor.h&quot;
  66 #include &quot;Operations.h&quot;
  67 #include &quot;ParseInt.h&quot;

  68 #include &quot;RegExpGlobalDataInlines.h&quot;
  69 #include &quot;RegExpMatchesArray.h&quot;
  70 #include &quot;RegExpObjectInlines.h&quot;
  71 #include &quot;Repatch.h&quot;
  72 #include &quot;ScopedArguments.h&quot;
  73 #include &quot;StringConstructor.h&quot;
  74 #include &quot;StringPrototypeInlines.h&quot;
  75 #include &quot;SuperSampler.h&quot;
  76 #include &quot;Symbol.h&quot;
  77 #include &quot;TypeProfilerLog.h&quot;
  78 #include &quot;TypedArrayInlines.h&quot;
  79 #include &quot;VMInlines.h&quot;
  80 #include &lt;wtf/InlineASM.h&gt;
  81 #include &lt;wtf/Variant.h&gt;
  82 
  83 #if ENABLE(JIT)
  84 #if ENABLE(DFG_JIT)
  85 


  86 namespace JSC { namespace DFG {
  87 
  88 template&lt;bool strict, bool direct&gt;
<span class="line-modified">  89 static inline void putByVal(ExecState* exec, VM&amp; vm, JSValue baseValue, uint32_t index, JSValue value)</span>
  90 {
  91     ASSERT(isIndex(index));
  92     if (direct) {
  93         RELEASE_ASSERT(baseValue.isObject());
<span class="line-modified">  94         asObject(baseValue)-&gt;putDirectIndex(exec, index, value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
  95         return;
  96     }
  97     if (baseValue.isObject()) {
  98         JSObject* object = asObject(baseValue);
  99         if (object-&gt;canSetIndexQuickly(index, value)) {
 100             object-&gt;setIndexQuickly(vm, index, value);
 101             return;
 102         }
 103 
<span class="line-modified"> 104         object-&gt;methodTable(vm)-&gt;putByIndex(object, exec, index, value, strict);</span>
 105         return;
 106     }
 107 
<span class="line-modified"> 108     baseValue.putByIndex(exec, index, value, strict);</span>
 109 }
 110 
 111 template&lt;bool strict, bool direct&gt;
<span class="line-modified"> 112 ALWAYS_INLINE static void putByValInternal(ExecState* exec, VM&amp; vm, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 113 {
 114     auto scope = DECLARE_THROW_SCOPE(vm);
 115 
 116     JSValue baseValue = JSValue::decode(encodedBase);
 117     JSValue property = JSValue::decode(encodedProperty);
 118     JSValue value = JSValue::decode(encodedValue);
 119 
 120     if (LIKELY(property.isUInt32())) {
 121         // Despite its name, JSValue::isUInt32 will return true only for positive boxed int32_t; all those values are valid array indices.
 122         ASSERT(isIndex(property.asUInt32()));
 123         scope.release();
<span class="line-modified"> 124         putByVal&lt;strict, direct&gt;(exec, vm, baseValue, property.asUInt32(), value);</span>
 125         return;
 126     }
 127 
 128     if (property.isDouble()) {
 129         double propertyAsDouble = property.asDouble();
 130         uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
 131         if (propertyAsDouble == propertyAsUInt32 &amp;&amp; isIndex(propertyAsUInt32)) {
 132             scope.release();
<span class="line-modified"> 133             putByVal&lt;strict, direct&gt;(exec, vm, baseValue, propertyAsUInt32, value);</span>
 134             return;
 135         }
 136     }
 137 
 138     // Don&#39;t put to an object if toString throws an exception.
<span class="line-modified"> 139     auto propertyName = property.toPropertyKey(exec);</span>
 140     RETURN_IF_EXCEPTION(scope, void());
 141 
 142     PutPropertySlot slot(baseValue, strict);
 143     if (direct) {
 144         RELEASE_ASSERT(baseValue.isObject());
 145         JSObject* baseObject = asObject(baseValue);
 146         if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
 147             scope.release();
<span class="line-modified"> 148             baseObject-&gt;putDirectIndex(exec, index.value(), value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
 149             return;
 150         }
 151         scope.release();
<span class="line-modified"> 152         CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, propertyName, value, slot);</span>
 153         return;
 154     }
 155     scope.release();
<span class="line-modified"> 156     baseValue.put(exec, propertyName, value, slot);</span>
 157 }
 158 
 159 template&lt;bool strict, bool direct&gt;
<span class="line-modified"> 160 ALWAYS_INLINE static void putByValCellInternal(ExecState* exec, VM&amp; vm, JSCell* base, PropertyName propertyName, JSValue value)</span>
 161 {
 162     PutPropertySlot slot(base, strict);
 163     if (direct) {
 164         RELEASE_ASSERT(base-&gt;isObject());
 165         JSObject* baseObject = asObject(base);
 166         if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
<span class="line-modified"> 167             baseObject-&gt;putDirectIndex(exec, index.value(), value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
 168             return;
 169         }
<span class="line-modified"> 170         CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, propertyName, value, slot);</span>
 171         return;
 172     }
<span class="line-modified"> 173     base-&gt;putInline(exec, propertyName, value, slot);</span>
 174 }
 175 
 176 template&lt;bool strict, bool direct&gt;
<span class="line-modified"> 177 ALWAYS_INLINE static void putByValCellStringInternal(ExecState* exec, VM&amp; vm, JSCell* base, JSString* property, JSValue value)</span>
 178 {
 179     auto scope = DECLARE_THROW_SCOPE(vm);
 180 
<span class="line-modified"> 181     auto propertyName = property-&gt;toIdentifier(exec);</span>
 182     RETURN_IF_EXCEPTION(scope, void());
 183 
 184     scope.release();
<span class="line-modified"> 185     putByValCellInternal&lt;strict, direct&gt;(exec, vm, base, propertyName, value);</span>
 186 }
 187 
 188 template&lt;typename ViewClass&gt;
<span class="line-modified"> 189 char* newTypedArrayWithSize(ExecState* exec, Structure* structure, int32_t size, char* vector)</span>
 190 {
<span class="line-removed"> 191     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed"> 192     NativeCallFrameTracer tracer(vm, exec);</span>
 193     auto scope = DECLARE_THROW_SCOPE(vm);
 194 
 195     if (size &lt; 0) {
<span class="line-modified"> 196         throwException(exec, scope, createRangeError(exec, &quot;Requested length is negative&quot;_s));</span>
 197         return 0;
 198     }
 199 
 200     if (vector)
<span class="line-modified"> 201         return bitwise_cast&lt;char*&gt;(ViewClass::createWithFastVector(exec, structure, size, untagArrayPtr(vector, size)));</span>
 202 
<span class="line-modified"> 203     RELEASE_AND_RETURN(scope, bitwise_cast&lt;char*&gt;(ViewClass::create(exec, structure, size)));</span>
 204 }
 205 
 206 template &lt;bool strict&gt;
<span class="line-modified"> 207 static ALWAYS_INLINE void putWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, const Identifier&amp; ident)</span>
 208 {
 209     JSValue baseValue = JSValue::decode(encodedBase);
 210     JSValue thisVal = JSValue::decode(encodedThis);
 211     JSValue putValue = JSValue::decode(encodedValue);
 212     PutPropertySlot slot(thisVal, strict);
<span class="line-modified"> 213     baseValue.putInline(exec, ident, putValue, slot);</span>
 214 }
 215 
 216 template&lt;typename BigIntOperation, typename NumberOperation&gt;
<span class="line-modified"> 217 static ALWAYS_INLINE EncodedJSValue binaryOp(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, NumberOperation&amp;&amp; numberOp, const char* errorMessage)</span>
 218 {
<span class="line-removed"> 219     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed"> 220     NativeCallFrameTracer tracer(vm, exec);</span>
 221     auto scope = DECLARE_THROW_SCOPE(vm);
 222 
 223     JSValue op1 = JSValue::decode(encodedOp1);
 224     JSValue op2 = JSValue::decode(encodedOp2);
 225 
<span class="line-modified"> 226     auto leftNumeric = op1.toNumeric(exec);</span>
 227     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified"> 228     auto rightNumeric = op2.toNumeric(exec);</span>
 229     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 230 
 231     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 232         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))
<span class="line-modified"> 233             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));</span>
 234 
<span class="line-modified"> 235         return throwVMTypeError(exec, scope, errorMessage);</span>
 236     }
 237 
 238     scope.release();
 239 
 240     return JSValue::encode(jsNumber(numberOp(WTF::get&lt;double&gt;(leftNumeric), WTF::get&lt;double&gt;(rightNumeric))));
 241 }
 242 
 243 template&lt;typename BigIntOperation, typename Int32Operation&gt;
<span class="line-modified"> 244 static ALWAYS_INLINE EncodedJSValue bitwiseBinaryOp(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, Int32Operation&amp;&amp; int32Op, const char* errorMessage)</span>
 245 {
<span class="line-removed"> 246     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed"> 247     NativeCallFrameTracer tracer(vm, exec);</span>
 248     auto scope = DECLARE_THROW_SCOPE(vm);
 249 
 250     JSValue op1 = JSValue::decode(encodedOp1);
 251     JSValue op2 = JSValue::decode(encodedOp2);
 252 
<span class="line-modified"> 253     auto leftNumeric = op1.toBigIntOrInt32(exec);</span>
 254     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified"> 255     auto rightNumeric = op2.toBigIntOrInt32(exec);</span>
 256     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 257 
 258     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 259         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))
<span class="line-modified"> 260             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));</span>
 261 
<span class="line-modified"> 262         return throwVMTypeError(exec, scope, errorMessage);</span>
 263     }
 264 
 265     scope.release();
 266 
 267     return JSValue::encode(jsNumber(int32Op(WTF::get&lt;int32_t&gt;(leftNumeric), WTF::get&lt;int32_t&gt;(rightNumeric))));
 268 }
 269 
 270 static ALWAYS_INLINE EncodedJSValue parseIntResult(double input)
 271 {
 272     int asInt = static_cast&lt;int&gt;(input);
 273     if (static_cast&lt;double&gt;(asInt) == input)
 274         return JSValue::encode(jsNumber(asInt));
 275     return JSValue::encode(jsNumber(input));
 276 }
 277 
<span class="line-modified"> 278 ALWAYS_INLINE static JSValue getByValObject(ExecState* exec, VM&amp; vm, JSObject* base, PropertyName propertyName)</span>
 279 {
 280     Structure&amp; structure = *base-&gt;structure(vm);
 281     if (JSCell::canUseFastGetOwnProperty(structure)) {
 282         if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, propertyName))
 283             return result;
 284     }
<span class="line-modified"> 285     return base-&gt;get(exec, propertyName);</span>
 286 }
 287 
 288 extern &quot;C&quot; {
 289 
<span class="line-modified"> 290 EncodedJSValue JIT_OPERATION operationToThis(ExecState* exec, EncodedJSValue encodedOp)</span>
 291 {
<span class="line-modified"> 292     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 293     NativeCallFrameTracer tracer(vm, exec);</span>

 294 
<span class="line-modified"> 295     return JSValue::encode(JSValue::decode(encodedOp).toThis(exec, NotStrictMode));</span>
 296 }
 297 
<span class="line-modified"> 298 EncodedJSValue JIT_OPERATION operationToThisStrict(ExecState* exec, EncodedJSValue encodedOp)</span>
 299 {
<span class="line-modified"> 300     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 301     NativeCallFrameTracer tracer(vm, exec);</span>

 302 
<span class="line-modified"> 303     return JSValue::encode(JSValue::decode(encodedOp).toThis(exec, StrictMode));</span>
 304 }
 305 
<span class="line-modified"> 306 JSArray* JIT_OPERATION operationObjectKeys(ExecState* exec, EncodedJSValue encodedObject)</span>
 307 {
<span class="line-modified"> 308     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 309     NativeCallFrameTracer tracer(vm, exec);</span>

 310     auto scope = DECLARE_THROW_SCOPE(vm);
 311 
<span class="line-modified"> 312     JSObject* object = JSValue::decode(encodedObject).toObject(exec);</span>
 313     RETURN_IF_EXCEPTION(scope, nullptr);
 314     scope.release();
<span class="line-modified"> 315     return ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);</span>
 316 }
 317 
<span class="line-modified"> 318 JSArray* JIT_OPERATION operationObjectKeysObject(ExecState* exec, JSObject* object)</span>
 319 {
<span class="line-modified"> 320     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 321     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified"> 322     return ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);</span>

 323 }
 324 
<span class="line-modified"> 325 JSCell* JIT_OPERATION operationObjectCreate(ExecState* exec, EncodedJSValue encodedPrototype)</span>
 326 {
<span class="line-modified"> 327     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 328     NativeCallFrameTracer tracer(vm, exec);</span>

 329     auto scope = DECLARE_THROW_SCOPE(vm);
 330 
 331     JSValue prototype = JSValue::decode(encodedPrototype);
 332 
 333     if (!prototype.isObject() &amp;&amp; !prototype.isNull()) {
<span class="line-modified"> 334         throwVMTypeError(exec, scope, &quot;Object prototype may only be an Object or null.&quot;_s);</span>
 335         return nullptr;
 336     }
 337 
 338     if (prototype.isObject())
<span class="line-modified"> 339         RELEASE_AND_RETURN(scope, constructEmptyObject(exec, asObject(prototype)));</span>
<span class="line-modified"> 340     RELEASE_AND_RETURN(scope, constructEmptyObject(exec, exec-&gt;lexicalGlobalObject()-&gt;nullPrototypeObjectStructure()));</span>
 341 }
 342 
<span class="line-modified"> 343 JSCell* JIT_OPERATION operationObjectCreateObject(ExecState* exec, JSObject* prototype)</span>
 344 {
<span class="line-modified"> 345     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 346     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified"> 347     return constructEmptyObject(exec, prototype);</span>

 348 }
 349 
<span class="line-modified"> 350 JSCell* JIT_OPERATION operationCreateThis(ExecState* exec, JSObject* constructor, uint32_t inlineCapacity)</span>
 351 {
<span class="line-modified"> 352     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 353     NativeCallFrameTracer tracer(vm, exec);</span>

 354     auto scope = DECLARE_THROW_SCOPE(vm);
 355     if (constructor-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructor)-&gt;canUseAllocationProfile()) {
<span class="line-modified"> 356         auto rareData = jsCast&lt;JSFunction*&gt;(constructor)-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity);</span>
 357         scope.releaseAssertNoException();
 358         ObjectAllocationProfileWithPrototype* allocationProfile = rareData-&gt;objectAllocationProfile();
 359         Structure* structure = allocationProfile-&gt;structure();
<span class="line-modified"> 360         JSObject* result = constructEmptyObject(exec, structure);</span>
 361         if (structure-&gt;hasPolyProto()) {
 362             JSObject* prototype = allocationProfile-&gt;prototype();
<span class="line-modified"> 363             ASSERT(prototype == jsCast&lt;JSFunction*&gt;(constructor)-&gt;prototypeForConstruction(vm, exec));</span>
 364             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 365             prototype-&gt;didBecomePrototype();
 366             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 367         }
 368         return result;
 369     }
 370 
<span class="line-modified"> 371     JSValue proto = constructor-&gt;get(exec, vm.propertyNames-&gt;prototype);</span>
 372     RETURN_IF_EXCEPTION(scope, nullptr);
 373     if (proto.isObject())
<span class="line-modified"> 374         return constructEmptyObject(exec, asObject(proto));</span>
<span class="line-modified"> 375     return constructEmptyObject(exec);</span>

































 376 }
 377 
<span class="line-modified"> 378 JSCell* JIT_OPERATION operationCallObjectConstructor(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedTarget)</span>
 379 {
<span class="line-modified"> 380     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 381     NativeCallFrameTracer tracer(vm, exec);</span>












 382 
 383     JSValue value = JSValue::decode(encodedTarget);
 384     ASSERT(!value.isObject());
 385 
 386     if (value.isUndefinedOrNull())
<span class="line-modified"> 387         return constructEmptyObject(exec, globalObject-&gt;objectPrototype());</span>
<span class="line-modified"> 388     return value.toObject(exec, globalObject);</span>
 389 }
 390 
<span class="line-modified"> 391 JSCell* JIT_OPERATION operationToObject(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedTarget, UniquedStringImpl* errorMessage)</span>
 392 {
<span class="line-modified"> 393     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 394     NativeCallFrameTracer tracer(vm, exec);</span>

 395     auto scope = DECLARE_THROW_SCOPE(vm);
 396 
 397     JSValue value = JSValue::decode(encodedTarget);
 398     ASSERT(!value.isObject());
 399 
 400     if (UNLIKELY(value.isUndefinedOrNull())) {
<span class="line-modified"> 401         if (errorMessage-&gt;length()) {</span>
<span class="line-modified"> 402             throwVMTypeError(exec, scope, errorMessage);</span>
 403             return nullptr;
 404         }
 405     }
 406 
<span class="line-modified"> 407     RELEASE_AND_RETURN(scope, value.toObject(exec, globalObject));</span>
 408 }
 409 
<span class="line-modified"> 410 EncodedJSValue JIT_OPERATION operationValueMod(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 411 {
<span class="line-modified"> 412     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 413         return JSBigInt::remainder(exec, left, right);</span>




 414     };
 415 
 416     auto numberOp = [] (double left, double right) -&gt; double {
 417         return jsMod(left, right);
 418     };
 419 
<span class="line-modified"> 420     return binaryOp(exec, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;);</span>






































 421 }
 422 
<span class="line-modified"> 423 EncodedJSValue JIT_OPERATION operationValueBitNot(ExecState* exec, EncodedJSValue encodedOp1)</span>
 424 {
<span class="line-modified"> 425     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 426     NativeCallFrameTracer tracer(vm, exec);</span>

 427     auto scope = DECLARE_THROW_SCOPE(vm);
 428 
 429     JSValue op1 = JSValue::decode(encodedOp1);
 430 
<span class="line-modified"> 431     auto operandNumeric = op1.toBigIntOrInt32(exec);</span>
 432     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 433 
 434     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))
<span class="line-modified"> 435         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::bitwiseNot(exec, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));</span>
 436 
 437     return JSValue::encode(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
 438 }
 439 
<span class="line-modified"> 440 EncodedJSValue JIT_OPERATION operationValueBitAnd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 441 {
<span class="line-modified"> 442     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 443         return JSBigInt::bitwiseAnd(exec, left, right);</span>




 444     };
 445 
 446     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 447         return left &amp; right;
 448     };
 449 
<span class="line-modified"> 450     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;_s);</span>
 451 }
 452 
<span class="line-modified"> 453 EncodedJSValue JIT_OPERATION operationValueBitOr(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 454 {
<span class="line-modified"> 455     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 456         return JSBigInt::bitwiseOr(exec, left, right);</span>




 457     };
 458 
 459     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 460         return left | right;
 461     };
 462 
<span class="line-modified"> 463     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;_s);</span>
 464 }
 465 
<span class="line-modified"> 466 EncodedJSValue JIT_OPERATION operationValueBitXor(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 467 {
<span class="line-modified"> 468     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 469         return JSBigInt::bitwiseXor(exec, left, right);</span>




 470     };
 471 
 472     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 473         return left ^ right;
 474     };
 475 
<span class="line-modified"> 476     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;_s);</span>
 477 }
 478 
<span class="line-modified"> 479 EncodedJSValue JIT_OPERATION operationValueBitLShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 480 {
<span class="line-modified"> 481     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 482         return JSBigInt::leftShift(exec, left, right);</span>




 483     };
 484 
 485     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 486         return left &lt;&lt; (right &amp; 0x1f);
 487     };
 488 
<span class="line-modified"> 489     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;_s);</span>
 490 }
 491 
<span class="line-modified"> 492 EncodedJSValue JIT_OPERATION operationValueBitRShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 493 {
<span class="line-modified"> 494     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 495     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified"> 496     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 497 
<span class="line-modified"> 498     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-modified"> 499     JSValue op2 = JSValue::decode(encodedOp2);</span>

 500 
<span class="line-modified"> 501     int32_t a = op1.toInt32(exec);</span>
<span class="line-modified"> 502     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-modified"> 503     scope.release();</span>
<span class="line-modified"> 504     uint32_t b = op2.toUInt32(exec);</span>
<span class="line-modified"> 505     return JSValue::encode(jsNumber(a &gt;&gt; (b &amp; 0x1f)));</span>
 506 }
 507 
<span class="line-modified"> 508 EncodedJSValue JIT_OPERATION operationValueBitURShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 509 {
<span class="line-modified"> 510     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 511     NativeCallFrameTracer tracer(vm, exec);</span>

 512     auto scope = DECLARE_THROW_SCOPE(vm);
 513 
 514     JSValue op1 = JSValue::decode(encodedOp1);
 515     JSValue op2 = JSValue::decode(encodedOp2);
 516 
<span class="line-modified"> 517     uint32_t a = op1.toUInt32(exec);</span>
 518     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 519     scope.release();
<span class="line-modified"> 520     uint32_t b = op2.toUInt32(exec);</span>
 521     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 0x1f))));
 522 }
 523 
<span class="line-modified"> 524 EncodedJSValue JIT_OPERATION operationValueAddNotNumber(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 525 {
<span class="line-modified"> 526     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 527     NativeCallFrameTracer tracer(vm, exec);</span>

 528 
 529     JSValue op1 = JSValue::decode(encodedOp1);
 530     JSValue op2 = JSValue::decode(encodedOp2);
 531 
<span class="line-modified"> 532     return JSValue::encode(jsAddNonNumber(exec, op1, op2));</span>
 533 }
 534 
<span class="line-modified"> 535 EncodedJSValue JIT_OPERATION operationValueDiv(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 536 {
<span class="line-modified"> 537     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 538         return JSBigInt::divide(exec, left, right);</span>




 539     };
 540 
 541     auto numberOp = [] (double left, double right) -&gt; double {
 542         return left / right;
 543     };
 544 
<span class="line-modified"> 545     return binaryOp(exec, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in division operation.&quot;);</span>
 546 }
 547 
<span class="line-modified"> 548 EncodedJSValue JIT_OPERATION operationValuePow(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 549 {
<span class="line-modified"> 550     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 551         return JSBigInt::exponentiate(exec, left, right);</span>




 552     };
 553 
 554     auto numberOp = [] (double left, double right) -&gt; double {
 555         return operationMathPow(left, right);
 556     };
 557 
<span class="line-modified"> 558     return binaryOp(exec, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;_s);</span>
 559 }
 560 
<span class="line-modified"> 561 double JIT_OPERATION operationArithAbs(ExecState* exec, EncodedJSValue encodedOp1)</span>
 562 {
<span class="line-modified"> 563     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 564     NativeCallFrameTracer tracer(vm, exec);</span>

 565     auto scope = DECLARE_THROW_SCOPE(vm);
 566 
 567     JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified"> 568     double a = op1.toNumber(exec);</span>
 569     RETURN_IF_EXCEPTION(scope, PNaN);
 570     return fabs(a);
 571 }
 572 
<span class="line-modified"> 573 uint32_t JIT_OPERATION operationArithClz32(ExecState* exec, EncodedJSValue encodedOp1)</span>
 574 {
<span class="line-modified"> 575     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 576     NativeCallFrameTracer tracer(vm, exec);</span>

 577     auto scope = DECLARE_THROW_SCOPE(vm);
 578 
 579     JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified"> 580     uint32_t value = op1.toUInt32(exec);</span>
 581     RETURN_IF_EXCEPTION(scope, 0);
 582     return clz(value);
 583 }
 584 
<span class="line-modified"> 585 double JIT_OPERATION operationArithFRound(ExecState* exec, EncodedJSValue encodedOp1)</span>
 586 {
<span class="line-modified"> 587     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 588     NativeCallFrameTracer tracer(vm, exec);</span>

 589     auto scope = DECLARE_THROW_SCOPE(vm);
 590 
 591     JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified"> 592     double a = op1.toNumber(exec);</span>
 593     RETURN_IF_EXCEPTION(scope, PNaN);
 594     return static_cast&lt;float&gt;(a);
 595 }
 596 
 597 #define DFG_ARITH_UNARY(capitalizedName, lowerName) \
<span class="line-modified"> 598 double JIT_OPERATION operationArith##capitalizedName(ExecState* exec, EncodedJSValue encodedOp1) \</span>
 599 { \
<span class="line-modified"> 600     VM&amp; vm = exec-&gt;vm(); \</span>
<span class="line-modified"> 601     NativeCallFrameTracer tracer(vm, exec); \</span>

 602     auto scope = DECLARE_THROW_SCOPE(vm); \
 603     JSValue op1 = JSValue::decode(encodedOp1); \
<span class="line-modified"> 604     double result = op1.toNumber(exec); \</span>
 605     RETURN_IF_EXCEPTION(scope, PNaN); \
 606     return JSC::Math::lowerName(result); \
 607 }
 608     FOR_EACH_DFG_ARITH_UNARY_OP(DFG_ARITH_UNARY)
 609 #undef DFG_ARITH_UNARY
 610 
<span class="line-modified"> 611 double JIT_OPERATION operationArithSqrt(ExecState* exec, EncodedJSValue encodedOp1)</span>
 612 {
<span class="line-modified"> 613     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 614     NativeCallFrameTracer tracer(vm, exec);</span>

 615     auto scope = DECLARE_THROW_SCOPE(vm);
 616 
 617     JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified"> 618     double a = op1.toNumber(exec);</span>
 619     RETURN_IF_EXCEPTION(scope, PNaN);
 620     return sqrt(a);
 621 }
 622 
<span class="line-modified"> 623 EncodedJSValue JIT_OPERATION operationArithRound(ExecState* exec, EncodedJSValue encodedArgument)</span>
 624 {
<span class="line-modified"> 625     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 626     NativeCallFrameTracer tracer(vm, exec);</span>

 627     auto scope = DECLARE_THROW_SCOPE(vm);
 628 
 629     JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified"> 630     double valueOfArgument = argument.toNumber(exec);</span>
 631     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 632     return JSValue::encode(jsNumber(jsRound(valueOfArgument)));
 633 }
 634 
<span class="line-modified"> 635 EncodedJSValue JIT_OPERATION operationArithFloor(ExecState* exec, EncodedJSValue encodedArgument)</span>
 636 {
<span class="line-modified"> 637     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 638     NativeCallFrameTracer tracer(vm, exec);</span>

 639     auto scope = DECLARE_THROW_SCOPE(vm);
 640 
 641     JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified"> 642     double valueOfArgument = argument.toNumber(exec);</span>
 643     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 644     return JSValue::encode(jsNumber(floor(valueOfArgument)));
 645 }
 646 
<span class="line-modified"> 647 EncodedJSValue JIT_OPERATION operationArithCeil(ExecState* exec, EncodedJSValue encodedArgument)</span>
 648 {
<span class="line-modified"> 649     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 650     NativeCallFrameTracer tracer(vm, exec);</span>

 651     auto scope = DECLARE_THROW_SCOPE(vm);
 652 
 653     JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified"> 654     double valueOfArgument = argument.toNumber(exec);</span>
 655     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 656     return JSValue::encode(jsNumber(ceil(valueOfArgument)));
 657 }
 658 
<span class="line-modified"> 659 EncodedJSValue JIT_OPERATION operationArithTrunc(ExecState* exec, EncodedJSValue encodedArgument)</span>
 660 {
<span class="line-modified"> 661     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 662     NativeCallFrameTracer tracer(vm, exec);</span>

 663     auto scope = DECLARE_THROW_SCOPE(vm);
 664 
 665     JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified"> 666     double truncatedValueOfArgument = argument.toIntegerPreserveNaN(exec);</span>
 667     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 668     return JSValue::encode(jsNumber(truncatedValueOfArgument));
 669 }
 670 
<span class="line-modified"> 671 static ALWAYS_INLINE EncodedJSValue getByVal(ExecState* exec, JSCell* base, uint32_t index)</span>
<span class="line-removed"> 672 {</span>
<span class="line-removed"> 673     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed"> 674     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed"> 675 </span>
<span class="line-removed"> 676     if (base-&gt;isObject()) {</span>
<span class="line-removed"> 677         JSObject* object = asObject(base);</span>
<span class="line-removed"> 678         if (object-&gt;canGetIndexQuickly(index))</span>
<span class="line-removed"> 679             return JSValue::encode(object-&gt;getIndexQuickly(index));</span>
<span class="line-removed"> 680     }</span>
<span class="line-removed"> 681 </span>
<span class="line-removed"> 682     if (isJSString(base) &amp;&amp; asString(base)-&gt;canGetIndex(index))</span>
<span class="line-removed"> 683         return JSValue::encode(asString(base)-&gt;getIndex(exec, index));</span>
<span class="line-removed"> 684 </span>
<span class="line-removed"> 685     return JSValue::encode(JSValue(base).get(exec, index));</span>
<span class="line-removed"> 686 }</span>
<span class="line-removed"> 687 </span>
<span class="line-removed"> 688 EncodedJSValue JIT_OPERATION operationGetByVal(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty)</span>
 689 {
<span class="line-modified"> 690     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 691     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified"> 692     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed"> 693 </span>
<span class="line-removed"> 694     JSValue baseValue = JSValue::decode(encodedBase);</span>
<span class="line-removed"> 695     JSValue property = JSValue::decode(encodedProperty);</span>
<span class="line-removed"> 696 </span>
<span class="line-removed"> 697     if (LIKELY(baseValue.isCell())) {</span>
<span class="line-removed"> 698         JSCell* base = baseValue.asCell();</span>
<span class="line-removed"> 699 </span>
<span class="line-removed"> 700         if (property.isUInt32())</span>
<span class="line-removed"> 701             RELEASE_AND_RETURN(scope, getByVal(exec, base, property.asUInt32()));</span>
<span class="line-removed"> 702 </span>
<span class="line-removed"> 703         if (property.isDouble()) {</span>
<span class="line-removed"> 704             double propertyAsDouble = property.asDouble();</span>
<span class="line-removed"> 705             uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);</span>
<span class="line-removed"> 706             if (propertyAsUInt32 == propertyAsDouble &amp;&amp; isIndex(propertyAsUInt32))</span>
<span class="line-removed"> 707                 RELEASE_AND_RETURN(scope, getByVal(exec, base, propertyAsUInt32));</span>
<span class="line-removed"> 708 </span>
<span class="line-removed"> 709         } else if (property.isString()) {</span>
<span class="line-removed"> 710             Structure&amp; structure = *base-&gt;structure(vm);</span>
<span class="line-removed"> 711             if (JSCell::canUseFastGetOwnProperty(structure)) {</span>
<span class="line-removed"> 712                 RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(property)-&gt;toExistingAtomString(exec);</span>
<span class="line-removed"> 713                 RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed"> 714                 if (existingAtomString) {</span>
<span class="line-removed"> 715                     if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))</span>
<span class="line-removed"> 716                         return JSValue::encode(result);</span>
<span class="line-removed"> 717                 }</span>
<span class="line-removed"> 718             }</span>
<span class="line-removed"> 719         }</span>
<span class="line-removed"> 720     }</span>
<span class="line-removed"> 721 </span>
<span class="line-removed"> 722     baseValue.requireObjectCoercible(exec);</span>
<span class="line-removed"> 723     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed"> 724     auto propertyName = property.toPropertyKey(exec);</span>
<span class="line-removed"> 725     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed"> 726     RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(exec, propertyName)));</span>
<span class="line-removed"> 727 }</span>
<span class="line-removed"> 728 </span>
<span class="line-removed"> 729 EncodedJSValue JIT_OPERATION operationGetByValCell(ExecState* exec, JSCell* base, EncodedJSValue encodedProperty)</span>
<span class="line-removed"> 730 {</span>
<span class="line-removed"> 731     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed"> 732     NativeCallFrameTracer tracer(vm, exec);</span>
 733     auto scope = DECLARE_THROW_SCOPE(vm);
 734 
 735     JSValue property = JSValue::decode(encodedProperty);
 736 
 737     if (property.isUInt32())
<span class="line-modified"> 738         RELEASE_AND_RETURN(scope, getByVal(exec, base, property.asUInt32()));</span>
 739 
 740     if (property.isDouble()) {
 741         double propertyAsDouble = property.asDouble();
 742         uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
 743         if (propertyAsUInt32 == propertyAsDouble)
<span class="line-modified"> 744             RELEASE_AND_RETURN(scope, getByVal(exec, base, propertyAsUInt32));</span>
 745 
 746     } else if (property.isString()) {
 747         Structure&amp; structure = *base-&gt;structure(vm);
 748         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified"> 749             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(property)-&gt;toExistingAtomString(exec);</span>
 750             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 751             if (existingAtomString) {
 752                 if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
 753                     return JSValue::encode(result);
 754             }
 755         }
 756     }
 757 
<span class="line-modified"> 758     auto propertyName = property.toPropertyKey(exec);</span>
 759     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified"> 760     RELEASE_AND_RETURN(scope, JSValue::encode(JSValue(base).get(exec, propertyName)));</span>
 761 }
 762 
<span class="line-modified"> 763 ALWAYS_INLINE EncodedJSValue getByValCellInt(ExecState* exec, JSCell* base, int32_t index)</span>
 764 {
<span class="line-removed"> 765     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed"> 766     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed"> 767 </span>
 768     if (index &lt; 0) {
 769         // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified"> 770         return JSValue::encode(JSValue(base).get(exec, Identifier::from(vm, index)));</span>
 771     }
 772 
 773     // Use this since we know that the value is out of bounds.
<span class="line-modified"> 774     return JSValue::encode(JSValue(base).get(exec, static_cast&lt;unsigned&gt;(index)));</span>
 775 }
 776 
<span class="line-modified"> 777 EncodedJSValue JIT_OPERATION operationGetByValObjectInt(ExecState* exec, JSObject* base, int32_t index)</span>
 778 {
<span class="line-modified"> 779     return getByValCellInt(exec, base, index);</span>




 780 }
 781 
<span class="line-modified"> 782 EncodedJSValue JIT_OPERATION operationGetByValStringInt(ExecState* exec, JSString* base, int32_t index)</span>
 783 {
<span class="line-modified"> 784     return getByValCellInt(exec, base, index);</span>




 785 }
 786 
<span class="line-modified"> 787 EncodedJSValue JIT_OPERATION operationGetByValObjectString(ExecState* exec, JSCell* base, JSCell* string)</span>
 788 {
<span class="line-modified"> 789     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 790     NativeCallFrameTracer tracer(vm, exec);</span>

 791 
 792     auto scope = DECLARE_THROW_SCOPE(vm);
 793 
<span class="line-modified"> 794     auto propertyName = asString(string)-&gt;toIdentifier(exec);</span>
 795     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 796 
<span class="line-modified"> 797     RELEASE_AND_RETURN(scope, JSValue::encode(getByValObject(exec, vm, asObject(base), propertyName)));</span>
 798 }
 799 
<span class="line-modified"> 800 EncodedJSValue JIT_OPERATION operationGetByValObjectSymbol(ExecState* exec, JSCell* base, JSCell* symbol)</span>
 801 {
<span class="line-modified"> 802     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 803     NativeCallFrameTracer tracer(vm, exec);</span>

 804 
 805     auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified"> 806     return JSValue::encode(getByValObject(exec, vm, asObject(base), propertyName));</span>
 807 }
 808 
<span class="line-modified"> 809 void JIT_OPERATION operationPutByValStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 810 {
<span class="line-modified"> 811     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 812     NativeCallFrameTracer tracer(vm, exec);</span>

 813 
<span class="line-modified"> 814     putByValInternal&lt;true, false&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);</span>
 815 }
 816 
<span class="line-modified"> 817 void JIT_OPERATION operationPutByValNonStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 818 {
<span class="line-modified"> 819     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 820     NativeCallFrameTracer tracer(vm, exec);</span>

 821 
<span class="line-modified"> 822     putByValInternal&lt;false, false&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);</span>
 823 }
 824 
<span class="line-modified"> 825 void JIT_OPERATION operationPutByValCellStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 826 {
<span class="line-modified"> 827     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 828     NativeCallFrameTracer tracer(vm, exec);</span>

 829 
<span class="line-modified"> 830     putByValInternal&lt;true, false&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
 831 }
 832 
<span class="line-modified"> 833 void JIT_OPERATION operationPutByValCellNonStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 834 {
<span class="line-modified"> 835     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 836     NativeCallFrameTracer tracer(vm, exec);</span>

 837 
<span class="line-modified"> 838     putByValInternal&lt;false, false&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
 839 }
 840 
<span class="line-modified"> 841 void JIT_OPERATION operationPutByValCellStringStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
 842 {
<span class="line-modified"> 843     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 844     NativeCallFrameTracer tracer(vm, exec);</span>

 845 
<span class="line-modified"> 846     putByValCellStringInternal&lt;true, false&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
 847 }
 848 
<span class="line-modified"> 849 void JIT_OPERATION operationPutByValCellStringNonStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
 850 {
<span class="line-modified"> 851     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 852     NativeCallFrameTracer tracer(vm, exec);</span>

 853 
<span class="line-modified"> 854     putByValCellStringInternal&lt;false, false&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
 855 }
 856 
<span class="line-modified"> 857 void JIT_OPERATION operationPutByValCellSymbolStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
 858 {
<span class="line-modified"> 859     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 860     NativeCallFrameTracer tracer(vm, exec);</span>

 861 
 862     auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified"> 863     putByValCellInternal&lt;true, false&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
 864 }
 865 
<span class="line-modified"> 866 void JIT_OPERATION operationPutByValCellSymbolNonStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
 867 {
<span class="line-modified"> 868     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 869     NativeCallFrameTracer tracer(vm, exec);</span>

 870 
 871     auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified"> 872     putByValCellInternal&lt;false, false&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
 873 }
 874 
<span class="line-modified"> 875 void JIT_OPERATION operationPutByValBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
 876 {
<span class="line-modified"> 877     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 878     NativeCallFrameTracer tracer(vm, exec);</span>

 879 
 880     if (index &gt;= 0) {
<span class="line-modified"> 881         object-&gt;putByIndexInline(exec, index, JSValue::decode(encodedValue), true);</span>
 882         return;
 883     }
 884 
 885     PutPropertySlot slot(object, true);
 886     object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified"> 887         object, exec, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
 888 }
 889 
<span class="line-modified"> 890 void JIT_OPERATION operationPutByValBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
 891 {
<span class="line-modified"> 892     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 893     NativeCallFrameTracer tracer(vm, exec);</span>

 894 
 895     if (index &gt;= 0) {
<span class="line-modified"> 896         object-&gt;putByIndexInline(exec, index, JSValue::decode(encodedValue), false);</span>
 897         return;
 898     }
 899 
 900     PutPropertySlot slot(object, false);
 901     object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified"> 902         object, exec, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
 903 }
 904 
<span class="line-modified"> 905 void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, double value)</span>
 906 {
<span class="line-modified"> 907     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 908     NativeCallFrameTracer tracer(vm, exec);</span>

 909 
 910     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
 911 
 912     if (index &gt;= 0) {
<span class="line-modified"> 913         object-&gt;putByIndexInline(exec, index, jsValue, true);</span>
 914         return;
 915     }
 916 
 917     PutPropertySlot slot(object, true);
 918     object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified"> 919         object, exec, Identifier::from(vm, index), jsValue, slot);</span>
 920 }
 921 
<span class="line-modified"> 922 void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, double value)</span>
 923 {
<span class="line-modified"> 924     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 925     NativeCallFrameTracer tracer(vm, exec);</span>

 926 
 927     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
 928 
 929     if (index &gt;= 0) {
<span class="line-modified"> 930         object-&gt;putByIndexInline(exec, index, jsValue, false);</span>
 931         return;
 932     }
 933 
 934     PutPropertySlot slot(object, false);
 935     object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified"> 936         object, exec, Identifier::from(vm, index), jsValue, slot);</span>
 937 }
 938 
<span class="line-modified"> 939 void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, double value)</span>
 940 {
<span class="line-modified"> 941     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 942     NativeCallFrameTracer tracer(vm, exec);</span>

 943 
 944     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
 945 
 946     if (index &gt;= 0) {
<span class="line-modified"> 947         object-&gt;putDirectIndex(exec, index, jsValue, 0, PutDirectIndexShouldThrow);</span>
 948         return;
 949     }
 950 
 951     PutPropertySlot slot(object, true);
<span class="line-modified"> 952     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), jsValue, slot);</span>
 953 }
 954 
<span class="line-modified"> 955 void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, double value)</span>
 956 {
<span class="line-modified"> 957     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 958     NativeCallFrameTracer tracer(vm, exec);</span>

 959 
 960     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
 961 
 962     if (index &gt;= 0) {
<span class="line-modified"> 963         object-&gt;putDirectIndex(exec, index, jsValue);</span>
 964         return;
 965     }
 966 
 967     PutPropertySlot slot(object, false);
<span class="line-modified"> 968     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), jsValue, slot);</span>
 969 }
 970 
<span class="line-modified"> 971 void JIT_OPERATION operationPutByValDirectStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 972 {
<span class="line-modified"> 973     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 974     NativeCallFrameTracer tracer(vm, exec);</span>

 975 
<span class="line-modified"> 976     putByValInternal&lt;true, true&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);</span>
 977 }
 978 
<span class="line-modified"> 979 void JIT_OPERATION operationPutByValDirectNonStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 980 {
<span class="line-modified"> 981     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 982     NativeCallFrameTracer tracer(vm, exec);</span>

 983 
<span class="line-modified"> 984     putByValInternal&lt;false, true&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);</span>
 985 }
 986 
<span class="line-modified"> 987 void JIT_OPERATION operationPutByValDirectCellStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 988 {
<span class="line-modified"> 989     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 990     NativeCallFrameTracer tracer(vm, exec);</span>

 991 
<span class="line-modified"> 992     putByValInternal&lt;true, true&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
 993 }
 994 
<span class="line-modified"> 995 void JIT_OPERATION operationPutByValDirectCellNonStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 996 {
<span class="line-modified"> 997     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 998     NativeCallFrameTracer tracer(vm, exec);</span>

 999 
<span class="line-modified">1000     putByValInternal&lt;false, true&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
1001 }
1002 
<span class="line-modified">1003 void JIT_OPERATION operationPutByValDirectCellStringStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
1004 {
<span class="line-modified">1005     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1006     NativeCallFrameTracer tracer(vm, exec);</span>

1007 
<span class="line-modified">1008     putByValCellStringInternal&lt;true, true&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
1009 }
1010 
<span class="line-modified">1011 void JIT_OPERATION operationPutByValDirectCellStringNonStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
1012 {
<span class="line-modified">1013     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1014     NativeCallFrameTracer tracer(vm, exec);</span>

1015 
<span class="line-modified">1016     putByValCellStringInternal&lt;false, true&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
1017 }
1018 
<span class="line-modified">1019 void JIT_OPERATION operationPutByValDirectCellSymbolStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
1020 {
<span class="line-modified">1021     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1022     NativeCallFrameTracer tracer(vm, exec);</span>

1023 
1024     auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">1025     putByValCellInternal&lt;true, true&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
1026 }
1027 
<span class="line-modified">1028 void JIT_OPERATION operationPutByValDirectCellSymbolNonStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
1029 {
<span class="line-modified">1030     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1031     NativeCallFrameTracer tracer(vm, exec);</span>

1032 
1033     auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">1034     putByValCellInternal&lt;false, true&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
1035 }
1036 
<span class="line-modified">1037 void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
1038 {
<span class="line-modified">1039     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1040     NativeCallFrameTracer tracer(vm, exec);</span>

1041     if (index &gt;= 0) {
<span class="line-modified">1042         object-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue), 0, PutDirectIndexShouldThrow);</span>
1043         return;
1044     }
1045 
1046     PutPropertySlot slot(object, true);
<span class="line-modified">1047     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
1048 }
1049 
<span class="line-modified">1050 void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
1051 {
<span class="line-modified">1052     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1053     NativeCallFrameTracer tracer(vm, exec);</span>

1054 
1055     if (index &gt;= 0) {
<span class="line-modified">1056         object-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue));</span>
1057         return;
1058     }
1059 
1060     PutPropertySlot slot(object, false);
<span class="line-modified">1061     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
1062 }
1063 
<span class="line-modified">1064 EncodedJSValue JIT_OPERATION operationArrayPush(ExecState* exec, EncodedJSValue encodedValue, JSArray* array)</span>
1065 {
<span class="line-modified">1066     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1067     NativeCallFrameTracer tracer(vm, exec);</span>

1068 
<span class="line-modified">1069     array-&gt;pushInline(exec, JSValue::decode(encodedValue));</span>
1070     return JSValue::encode(jsNumber(array-&gt;length()));
1071 }
1072 
<span class="line-modified">1073 EncodedJSValue JIT_OPERATION operationArrayPushDouble(ExecState* exec, double value, JSArray* array)</span>
1074 {
<span class="line-modified">1075     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1076     NativeCallFrameTracer tracer(vm, exec);</span>

1077 
<span class="line-modified">1078     array-&gt;pushInline(exec, JSValue(JSValue::EncodeAsDouble, value));</span>
1079     return JSValue::encode(jsNumber(array-&gt;length()));
1080 }
1081 
<span class="line-modified">1082 EncodedJSValue JIT_OPERATION operationArrayPushMultiple(ExecState* exec, JSArray* array, void* buffer, int32_t elementCount)</span>
1083 {
<span class="line-modified">1084     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1085     NativeCallFrameTracer tracer(vm, exec);</span>

1086     auto scope = DECLARE_THROW_SCOPE(vm);
1087 
1088     // We assume that multiple JSArray::push calls with ArrayWithInt32/ArrayWithContiguous do not cause JS traps.
1089     // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
1090     // content of ScratchBuffer. If the IndexingType is now ArrayWithInt32/ArrayWithContiguous, we can ensure
1091     // that there is no indexed accessors in this object and its prototype chain.
1092     //
1093     // ArrayWithArrayStorage is also OK. It can have indexed accessors. But if you define an indexed accessor, the array&#39;s length
1094     // becomes larger than that index. So Array#push never overlaps with this accessor. So accessors are never called unless
1095     // the IndexingType is ArrayWithSlowPutArrayStorage which could have an indexed accessor in a prototype chain.
1096     RELEASE_ASSERT(!shouldUseSlowPut(array-&gt;indexingType()));
1097 
1098     EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
1099     for (int32_t i = 0; i &lt; elementCount; ++i) {
<span class="line-modified">1100         array-&gt;pushInline(exec, JSValue::decode(values[i]));</span>
1101         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1102     }
1103     return JSValue::encode(jsNumber(array-&gt;length()));
1104 }
1105 
<span class="line-modified">1106 EncodedJSValue JIT_OPERATION operationArrayPushDoubleMultiple(ExecState* exec, JSArray* array, void* buffer, int32_t elementCount)</span>
1107 {
<span class="line-modified">1108     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1109     NativeCallFrameTracer tracer(vm, exec);</span>

1110     auto scope = DECLARE_THROW_SCOPE(vm);
1111 
1112     // We assume that multiple JSArray::push calls with ArrayWithDouble do not cause JS traps.
1113     // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
1114     // content of ScratchBuffer. If the IndexingType is now ArrayWithDouble, we can ensure
1115     // that there is no indexed accessors in this object and its prototype chain.
1116     ASSERT(array-&gt;indexingMode() == ArrayWithDouble);
1117 
1118     double* values = static_cast&lt;double*&gt;(buffer);
1119     for (int32_t i = 0; i &lt; elementCount; ++i) {
<span class="line-modified">1120         array-&gt;pushInline(exec, JSValue(JSValue::EncodeAsDouble, values[i]));</span>
1121         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1122     }
1123     return JSValue::encode(jsNumber(array-&gt;length()));
1124 }
1125 
<span class="line-modified">1126 EncodedJSValue JIT_OPERATION operationArrayPop(ExecState* exec, JSArray* array)</span>
1127 {
<span class="line-modified">1128     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1129     NativeCallFrameTracer tracer(vm, exec);</span>

1130 
<span class="line-modified">1131     return JSValue::encode(array-&gt;pop(exec));</span>
1132 }
1133 
<span class="line-modified">1134 EncodedJSValue JIT_OPERATION operationArrayPopAndRecoverLength(ExecState* exec, JSArray* array)</span>
1135 {
<span class="line-modified">1136     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1137     NativeCallFrameTracer tracer(vm, exec);</span>

1138 
1139     array-&gt;butterfly()-&gt;setPublicLength(array-&gt;butterfly()-&gt;publicLength() + 1);
1140 
<span class="line-modified">1141     return JSValue::encode(array-&gt;pop(exec));</span>
1142 }
1143 
<span class="line-modified">1144 EncodedJSValue JIT_OPERATION operationRegExpExecString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)</span>
1145 {
1146     SuperSamplerScope superSamplerScope(false);
1147 
1148     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1149     NativeCallFrameTracer tracer(vm, exec);</span>

1150 
<span class="line-modified">1151     return JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, argument));</span>
1152 }
1153 
<span class="line-modified">1154 EncodedJSValue JIT_OPERATION operationRegExpExec(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)</span>
1155 {
1156     SuperSamplerScope superSamplerScope(false);
1157 
1158     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1159     NativeCallFrameTracer tracer(vm, exec);</span>

1160     auto scope = DECLARE_THROW_SCOPE(vm);
1161 
1162     JSValue argument = JSValue::decode(encodedArgument);
1163 
<span class="line-modified">1164     JSString* input = argument.toStringOrNull(exec);</span>
1165     EXCEPTION_ASSERT(!!scope.exception() == !input);
1166     if (!input)
1167         return encodedJSValue();
<span class="line-modified">1168     RELEASE_AND_RETURN(scope, JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, input)));</span>
1169 }
1170 
<span class="line-modified">1171 EncodedJSValue JIT_OPERATION operationRegExpExecGeneric(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)</span>
1172 {
1173     SuperSamplerScope superSamplerScope(false);
1174 
1175     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1176     NativeCallFrameTracer tracer(vm, exec);</span>

1177     auto scope = DECLARE_THROW_SCOPE(vm);
1178 
1179     JSValue base = JSValue::decode(encodedBase);
1180     JSValue argument = JSValue::decode(encodedArgument);
1181 
1182     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
1183     if (UNLIKELY(!regexp))
<span class="line-modified">1184         return throwVMTypeError(exec, scope);</span>
1185 
<span class="line-modified">1186     JSString* input = argument.toStringOrNull(exec);</span>
1187     EXCEPTION_ASSERT(!!scope.exception() == !input);
1188     if (!input)
1189         return JSValue::encode(jsUndefined());
<span class="line-modified">1190     RELEASE_AND_RETURN(scope, JSValue::encode(regexp-&gt;exec(exec, globalObject, input)));</span>
1191 }
1192 
<span class="line-modified">1193 EncodedJSValue JIT_OPERATION operationRegExpExecNonGlobalOrSticky(ExecState* exec, JSGlobalObject* globalObject, RegExp* regExp, JSString* string)</span>
1194 {
1195     SuperSamplerScope superSamplerScope(false);
1196 
1197     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1198     NativeCallFrameTracer tracer(vm, exec);</span>

1199 
1200     auto scope = DECLARE_THROW_SCOPE(vm);
1201 
<span class="line-modified">1202     String input = string-&gt;value(exec);</span>
1203     RETURN_IF_EXCEPTION(scope, { });
1204 
1205     unsigned lastIndex = 0;
1206     MatchResult result;
1207     JSArray* array = createRegExpMatchesArray(vm, globalObject, string, input, regExp, lastIndex, result);
<span class="line-modified">1208     if (!array) {</span>
<span class="line-modified">1209         ASSERT(!scope.exception());</span>
1210         return JSValue::encode(jsNull());
<span class="line-removed">1211     }</span>
1212 
<span class="line-removed">1213     RETURN_IF_EXCEPTION(scope, { });</span>
1214     globalObject-&gt;regExpGlobalData().recordMatch(vm, globalObject, regExp, string, result);
1215     return JSValue::encode(array);
1216 }
1217 
<span class="line-modified">1218 EncodedJSValue JIT_OPERATION operationRegExpMatchFastString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)</span>
1219 {
1220     SuperSamplerScope superSamplerScope(false);
1221 
1222     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1223     NativeCallFrameTracer tracer(vm, exec);</span>

1224 
1225     if (!regExpObject-&gt;regExp()-&gt;global())
<span class="line-modified">1226         return JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, argument));</span>
<span class="line-modified">1227     return JSValue::encode(regExpObject-&gt;matchGlobal(exec, globalObject, argument));</span>
1228 }
1229 
<span class="line-modified">1230 EncodedJSValue JIT_OPERATION operationRegExpMatchFastGlobalString(ExecState* exec, JSGlobalObject* globalObject, RegExp* regExp, JSString* string)</span>
1231 {
1232     SuperSamplerScope superSamplerScope(false);
1233 
1234     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1235     NativeCallFrameTracer tracer(vm, exec);</span>

1236 
1237     auto scope = DECLARE_THROW_SCOPE(vm);
1238 
1239     ASSERT(regExp-&gt;global());
1240 
<span class="line-modified">1241     String s = string-&gt;value(exec);</span>
1242     RETURN_IF_EXCEPTION(scope, { });
1243 
1244     if (regExp-&gt;unicode()) {
1245         unsigned stringLength = s.length();
1246         RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
<span class="line-modified">1247             vm, exec, string, s, globalObject, regExp,</span>
1248             [&amp;] (size_t end) -&gt; size_t {
1249                 return advanceStringUnicode(s, stringLength, end);
1250             })));
1251     }
1252 
1253     RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
<span class="line-modified">1254         vm, exec, string, s, globalObject, regExp,</span>
1255         [&amp;] (size_t end) -&gt; size_t {
1256             return end + 1;
1257         })));
1258 }
1259 
<span class="line-modified">1260 EncodedJSValue JIT_OPERATION operationParseIntNoRadixGeneric(ExecState* exec, EncodedJSValue value)</span>
1261 {
<span class="line-modified">1262     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1263     NativeCallFrameTracer tracer(vm, exec);</span>

1264 
<span class="line-modified">1265     return toStringView(exec, JSValue::decode(value), [&amp;] (StringView view) {</span>
1266         // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
1267         return parseIntResult(parseInt(view, 0));
1268     });
1269 }
1270 
<span class="line-modified">1271 EncodedJSValue JIT_OPERATION operationParseIntStringNoRadix(ExecState* exec, JSString* string)</span>
1272 {
<span class="line-modified">1273     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1274     NativeCallFrameTracer tracer(vm, exec);</span>

1275     auto scope = DECLARE_THROW_SCOPE(vm);
1276 
<span class="line-modified">1277     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);</span>
1278     RETURN_IF_EXCEPTION(scope, { });
1279 
1280     // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
1281     return parseIntResult(parseInt(viewWithString.view, 0));
1282 }
1283 
<span class="line-modified">1284 EncodedJSValue JIT_OPERATION operationParseIntString(ExecState* exec, JSString* string, int32_t radix)</span>
1285 {
<span class="line-modified">1286     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1287     NativeCallFrameTracer tracer(vm, exec);</span>

1288     auto scope = DECLARE_THROW_SCOPE(vm);
1289 
<span class="line-modified">1290     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);</span>
1291     RETURN_IF_EXCEPTION(scope, { });
1292 
1293     return parseIntResult(parseInt(viewWithString.view, radix));
1294 }
1295 
<span class="line-modified">1296 EncodedJSValue JIT_OPERATION operationParseIntGeneric(ExecState* exec, EncodedJSValue value, int32_t radix)</span>
1297 {
<span class="line-modified">1298     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1299     NativeCallFrameTracer tracer(vm, exec);</span>

1300 
<span class="line-modified">1301     return toStringView(exec, JSValue::decode(value), [&amp;] (StringView view) {</span>
1302         return parseIntResult(parseInt(view, radix));
1303     });
1304 }
1305 
<span class="line-modified">1306 size_t JIT_OPERATION operationRegExpTestString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* input)</span>
1307 {
1308     SuperSamplerScope superSamplerScope(false);
1309 
1310     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1311     NativeCallFrameTracer tracer(vm, exec);</span>

1312 
<span class="line-modified">1313     return regExpObject-&gt;testInline(exec, globalObject, input);</span>
1314 }
1315 
<span class="line-modified">1316 size_t JIT_OPERATION operationRegExpTest(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)</span>
1317 {
1318     SuperSamplerScope superSamplerScope(false);
1319 
1320     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1321     NativeCallFrameTracer tracer(vm, exec);</span>

1322 
1323     JSValue argument = JSValue::decode(encodedArgument);
1324 
<span class="line-modified">1325     JSString* input = argument.toStringOrNull(exec);</span>
1326     if (!input)
1327         return false;
<span class="line-modified">1328     return regExpObject-&gt;testInline(exec, globalObject, input);</span>
1329 }
1330 
<span class="line-modified">1331 size_t JIT_OPERATION operationRegExpTestGeneric(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)</span>
1332 {
1333     SuperSamplerScope superSamplerScope(false);
1334 
1335     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1336     NativeCallFrameTracer tracer(vm, exec);</span>

1337     auto scope = DECLARE_THROW_SCOPE(vm);
1338 
1339     JSValue base = JSValue::decode(encodedBase);
1340     JSValue argument = JSValue::decode(encodedArgument);
1341 
1342     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
1343     if (UNLIKELY(!regexp)) {
<span class="line-modified">1344         throwTypeError(exec, scope);</span>
1345         return false;
1346     }
1347 
<span class="line-modified">1348     JSString* input = argument.toStringOrNull(exec);</span>
1349     EXCEPTION_ASSERT(!!scope.exception() == !input);
1350     if (!input)
1351         return false;
<span class="line-modified">1352     RELEASE_AND_RETURN(scope, regexp-&gt;test(exec, globalObject, input));</span>
1353 }
1354 
<span class="line-modified">1355 JSCell* JIT_OPERATION operationSubBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
1356 {
<span class="line-modified">1357     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1358     NativeCallFrameTracer tracer(vm, exec);</span>

1359 
1360     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1361     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1362 
<span class="line-modified">1363     return JSBigInt::sub(exec, leftOperand, rightOperand);</span>
1364 }
1365 
<span class="line-modified">1366 JSCell* JIT_OPERATION operationBitNotBigInt(ExecState* exec, JSCell* op1)</span>
1367 {
<span class="line-modified">1368     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1369     NativeCallFrameTracer tracer(vm, exec);</span>

1370 
1371     JSBigInt* operand = jsCast&lt;JSBigInt*&gt;(op1);
1372 
<span class="line-modified">1373     return JSBigInt::bitwiseNot(exec, operand);</span>
1374 }
1375 
<span class="line-modified">1376 JSCell* JIT_OPERATION operationMulBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
1377 {
<span class="line-modified">1378     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1379     NativeCallFrameTracer tracer(vm, exec);</span>

1380 
1381     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1382     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1383 
<span class="line-modified">1384     return JSBigInt::multiply(exec, leftOperand, rightOperand);</span>
1385 }
1386 
<span class="line-modified">1387 JSCell* JIT_OPERATION operationModBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
1388 {
<span class="line-modified">1389     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1390     NativeCallFrameTracer tracer(vm, exec);</span>

1391 
1392     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1393     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1394 
<span class="line-modified">1395     return JSBigInt::remainder(exec, leftOperand, rightOperand);</span>
1396 }
1397 
<span class="line-modified">1398 JSCell* JIT_OPERATION operationDivBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
1399 {
<span class="line-modified">1400     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1401     NativeCallFrameTracer tracer(vm, exec);</span>

1402 
1403     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1404     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1405 
<span class="line-modified">1406     return JSBigInt::divide(exec, leftOperand, rightOperand);</span>
1407 }
1408 
<span class="line-modified">1409 JSCell* JIT_OPERATION operationPowBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
1410 {
<span class="line-modified">1411     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1412     NativeCallFrameTracer tracer(vm, exec);</span>

1413 
1414     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1415     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1416 
<span class="line-modified">1417     return JSBigInt::exponentiate(exec, leftOperand, rightOperand);</span>
1418 }
1419 
<span class="line-modified">1420 JSCell* JIT_OPERATION operationBitAndBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
1421 {
<span class="line-modified">1422     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1423     NativeCallFrameTracer tracer(vm, exec);</span>

1424 
1425     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1426     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1427 
<span class="line-modified">1428     return JSBigInt::bitwiseAnd(exec, leftOperand, rightOperand);</span>
1429 }
1430 
<span class="line-modified">1431 JSCell* JIT_OPERATION operationBitLShiftBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
1432 {
<span class="line-modified">1433     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1434     NativeCallFrameTracer tracer(vm, exec);</span>

1435 
1436     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1437     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1438 
<span class="line-modified">1439     return JSBigInt::leftShift(exec, leftOperand, rightOperand);</span>
1440 }
1441 
<span class="line-modified">1442 JSCell* JIT_OPERATION operationAddBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
1443 {
<span class="line-modified">1444     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1445     NativeCallFrameTracer tracer(vm, exec);</span>

1446 
1447     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1448     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1449 
<span class="line-modified">1450     return JSBigInt::add(exec, leftOperand, rightOperand);</span>
1451 }
1452 
<span class="line-modified">1453 JSCell* JIT_OPERATION operationBitOrBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
1454 {
<span class="line-modified">1455     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1456     NativeCallFrameTracer tracer(vm, exec);</span>

1457 
1458     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1459     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1460 
<span class="line-modified">1461     return JSBigInt::bitwiseOr(exec, leftOperand, rightOperand);</span>
1462 }
1463 
<span class="line-modified">1464 JSCell* JIT_OPERATION operationBitXorBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
1465 {
<span class="line-modified">1466     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1467     NativeCallFrameTracer tracer(vm, exec);</span>

1468 
1469     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1470     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1471 
<span class="line-modified">1472     return JSBigInt::bitwiseXor(exec, leftOperand, rightOperand);</span>
1473 }
1474 
<span class="line-modified">1475 size_t JIT_OPERATION operationCompareStrictEqCell(ExecState* exec, JSCell* op1, JSCell* op2)</span>
1476 {
<span class="line-modified">1477     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1478     NativeCallFrameTracer tracer(vm, exec);</span>




1479 
<span class="line-modified">1480     return JSValue::strictEqualSlowCaseInline(exec, op1, op2);</span>
1481 }
1482 
<span class="line-modified">1483 size_t JIT_OPERATION operationSameValue(ExecState* exec, EncodedJSValue arg1, EncodedJSValue arg2)</span>
1484 {
<span class="line-modified">1485     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1486     NativeCallFrameTracer tracer(vm, exec);</span>




























1487 
<span class="line-modified">1488     return sameValue(exec, JSValue::decode(arg1), JSValue::decode(arg2));</span>
1489 }
1490 
<span class="line-modified">1491 EncodedJSValue JIT_OPERATION operationToPrimitive(ExecState* exec, EncodedJSValue value)</span>
1492 {
<span class="line-modified">1493     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1494     NativeCallFrameTracer tracer(vm, exec);</span>

1495 
<span class="line-modified">1496     return JSValue::encode(JSValue::decode(value).toPrimitive(exec));</span>
1497 }
1498 
<span class="line-modified">1499 EncodedJSValue JIT_OPERATION operationToNumber(ExecState* exec, EncodedJSValue value)</span>
1500 {
<span class="line-modified">1501     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1502     NativeCallFrameTracer tracer(vm, exec);</span>

1503 
<span class="line-modified">1504     return JSValue::encode(jsNumber(JSValue::decode(value).toNumber(exec)));</span>



1505 }
1506 
<span class="line-modified">1507 EncodedJSValue JIT_OPERATION operationGetByValWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript)</span>
1508 {
<span class="line-modified">1509     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1510     NativeCallFrameTracer tracer(vm, exec);</span>

1511     auto scope = DECLARE_THROW_SCOPE(vm);
1512 
1513     JSValue baseValue = JSValue::decode(encodedBase);
1514     JSValue thisVal = JSValue::decode(encodedThis);
1515     JSValue subscript = JSValue::decode(encodedSubscript);
1516 
1517     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1518         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1519         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">1520             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
1521             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1522             if (existingAtomString) {
1523                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
1524                     return JSValue::encode(result);
1525             }
1526         }
1527     }
1528 
1529     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
1530     if (subscript.isUInt32()) {
1531         uint32_t i = subscript.asUInt32();
1532         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
<span class="line-modified">1533             return JSValue::encode(asString(baseValue)-&gt;getIndex(exec, i));</span>
1534 
<span class="line-modified">1535         RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(exec, i, slot)));</span>
1536     }
1537 
<span class="line-modified">1538     baseValue.requireObjectCoercible(exec);</span>
1539     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1540 
<span class="line-modified">1541     auto property = subscript.toPropertyKey(exec);</span>
1542     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1543     RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(exec, property, slot)));</span>
1544 }
1545 
<span class="line-modified">1546 void JIT_OPERATION operationPutByIdWithThisStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)</span>
1547 {
<span class="line-modified">1548     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1549     NativeCallFrameTracer tracer(vm, exec);</span>

1550 
<span class="line-modified">1551     putWithThis&lt;true&gt;(exec, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));</span>
1552 }
1553 
<span class="line-modified">1554 void JIT_OPERATION operationPutByIdWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)</span>
1555 {
<span class="line-modified">1556     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1557     NativeCallFrameTracer tracer(vm, exec);</span>

1558 
<span class="line-modified">1559     putWithThis&lt;false&gt;(exec, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));</span>
1560 }
1561 
<span class="line-modified">1562 void JIT_OPERATION operationPutByValWithThisStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)</span>
1563 {
<span class="line-modified">1564     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1565     NativeCallFrameTracer tracer(vm, exec);</span>

1566     auto scope = DECLARE_THROW_SCOPE(vm);
1567 
<span class="line-modified">1568     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(exec);</span>
1569     RETURN_IF_EXCEPTION(scope, void());
1570     scope.release();
<span class="line-modified">1571     putWithThis&lt;true&gt;(exec, encodedBase, encodedThis, encodedValue, property);</span>
1572 }
1573 
<span class="line-modified">1574 void JIT_OPERATION operationPutByValWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)</span>
1575 {
<span class="line-modified">1576     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1577     NativeCallFrameTracer tracer(vm, exec);</span>

1578     auto scope = DECLARE_THROW_SCOPE(vm);
1579 
<span class="line-modified">1580     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(exec);</span>
1581     RETURN_IF_EXCEPTION(scope, void());
1582     scope.release();
<span class="line-modified">1583     putWithThis&lt;false&gt;(exec, encodedBase, encodedThis, encodedValue, property);</span>
1584 }
1585 
<span class="line-modified">1586 ALWAYS_INLINE static void defineDataProperty(ExecState* exec, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSValue value, int32_t attributes)</span>
1587 {
1588     PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes));
1589     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1590     if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
<span class="line-modified">1591         JSObject::defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
1592     else
<span class="line-modified">1593         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
1594 }
1595 
<span class="line-modified">1596 void JIT_OPERATION operationDefineDataProperty(ExecState* exec, JSObject* base, EncodedJSValue encodedProperty, EncodedJSValue encodedValue, int32_t attributes)</span>
1597 {
<span class="line-modified">1598     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1599     NativeCallFrameTracer tracer(vm, exec);</span>

1600     auto scope = DECLARE_THROW_SCOPE(vm);
1601 
<span class="line-modified">1602     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(exec);</span>
1603     RETURN_IF_EXCEPTION(scope, void());
1604     scope.release();
<span class="line-modified">1605     defineDataProperty(exec, vm, base, propertyName, JSValue::decode(encodedValue), attributes);</span>
1606 }
1607 
<span class="line-modified">1608 void JIT_OPERATION operationDefineDataPropertyString(ExecState* exec, JSObject* base, JSString* property, EncodedJSValue encodedValue, int32_t attributes)</span>
1609 {
<span class="line-modified">1610     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1611     NativeCallFrameTracer tracer(vm, exec);</span>

1612     auto scope = DECLARE_THROW_SCOPE(vm);
1613 
<span class="line-modified">1614     Identifier propertyName = property-&gt;toIdentifier(exec);</span>
1615     RETURN_IF_EXCEPTION(scope, void());
1616     scope.release();
<span class="line-modified">1617     defineDataProperty(exec, vm, base, propertyName, JSValue::decode(encodedValue), attributes);</span>
1618 }
1619 
<span class="line-modified">1620 void JIT_OPERATION operationDefineDataPropertyStringIdent(ExecState* exec, JSObject* base, UniquedStringImpl* property, EncodedJSValue encodedValue, int32_t attributes)</span>
1621 {
<span class="line-modified">1622     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1623     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1624     defineDataProperty(exec, vm, base, Identifier::fromUid(vm, property), JSValue::decode(encodedValue), attributes);</span>

1625 }
1626 
<span class="line-modified">1627 void JIT_OPERATION operationDefineDataPropertySymbol(ExecState* exec, JSObject* base, Symbol* property, EncodedJSValue encodedValue, int32_t attributes)</span>
1628 {
<span class="line-modified">1629     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1630     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1631     defineDataProperty(exec, vm, base, Identifier::fromUid(property-&gt;privateName()), JSValue::decode(encodedValue), attributes);</span>

1632 }
1633 
<span class="line-modified">1634 ALWAYS_INLINE static void defineAccessorProperty(ExecState* exec, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSObject* getter, JSObject* setter, int32_t attributes)</span>
1635 {
1636     PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes));
1637     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1638     if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
<span class="line-modified">1639         JSObject::defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
1640     else
<span class="line-modified">1641         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
1642 }
1643 
<span class="line-modified">1644 void JIT_OPERATION operationDefineAccessorProperty(ExecState* exec, JSObject* base, EncodedJSValue encodedProperty, JSObject* getter, JSObject* setter, int32_t attributes)</span>
1645 {
<span class="line-modified">1646     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1647     NativeCallFrameTracer tracer(vm, exec);</span>

1648     auto scope = DECLARE_THROW_SCOPE(vm);
1649 
<span class="line-modified">1650     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(exec);</span>
1651     RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">1652     defineAccessorProperty(exec, vm, base, propertyName, getter, setter, attributes);</span>
1653 }
1654 
<span class="line-modified">1655 void JIT_OPERATION operationDefineAccessorPropertyString(ExecState* exec, JSObject* base, JSString* property, JSObject* getter, JSObject* setter, int32_t attributes)</span>
1656 {
<span class="line-modified">1657     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1658     NativeCallFrameTracer tracer(vm, exec);</span>

1659     auto scope = DECLARE_THROW_SCOPE(vm);
1660 
<span class="line-modified">1661     Identifier propertyName = property-&gt;toIdentifier(exec);</span>
1662     RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">1663     defineAccessorProperty(exec, vm, base, propertyName, getter, setter, attributes);</span>
1664 }
1665 
<span class="line-modified">1666 void JIT_OPERATION operationDefineAccessorPropertyStringIdent(ExecState* exec, JSObject* base, UniquedStringImpl* property, JSObject* getter, JSObject* setter, int32_t attributes)</span>
1667 {
<span class="line-modified">1668     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1669     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1670     defineAccessorProperty(exec, vm, base, Identifier::fromUid(vm, property), getter, setter, attributes);</span>

1671 }
1672 
<span class="line-modified">1673 void JIT_OPERATION operationDefineAccessorPropertySymbol(ExecState* exec, JSObject* base, Symbol* property, JSObject* getter, JSObject* setter, int32_t attributes)</span>
1674 {
<span class="line-modified">1675     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1676     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1677     defineAccessorProperty(exec, vm, base, Identifier::fromUid(property-&gt;privateName()), getter, setter, attributes);</span>

1678 }
1679 
<span class="line-modified">1680 char* JIT_OPERATION operationNewArray(ExecState* exec, Structure* arrayStructure, void* buffer, size_t size)</span>
1681 {
<span class="line-modified">1682     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1683     NativeCallFrameTracer tracer(vm, exec);</span>

1684 
<span class="line-modified">1685     return bitwise_cast&lt;char*&gt;(constructArray(exec, arrayStructure, static_cast&lt;JSValue*&gt;(buffer), size));</span>
1686 }
1687 
<span class="line-modified">1688 char* JIT_OPERATION operationNewEmptyArray(ExecState* exec, Structure* arrayStructure)</span>
1689 {
<span class="line-modified">1690     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1691     NativeCallFrameTracer tracer(vm, exec);</span>

1692 
1693     return bitwise_cast&lt;char*&gt;(JSArray::create(vm, arrayStructure));
1694 }
1695 
<span class="line-modified">1696 char* JIT_OPERATION operationNewArrayWithSize(ExecState* exec, Structure* arrayStructure, int32_t size, Butterfly* butterfly)</span>
1697 {
<span class="line-modified">1698     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1699     NativeCallFrameTracer tracer(vm, exec);</span>

1700     auto scope = DECLARE_THROW_SCOPE(vm);
1701 
1702     if (UNLIKELY(size &lt; 0))
<span class="line-modified">1703         return bitwise_cast&lt;char*&gt;(throwException(exec, scope, createRangeError(exec, &quot;Array size is not a small enough positive integer.&quot;_s)));</span>
1704 
1705     JSArray* result;
1706     if (butterfly)
1707         result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
1708     else
1709         result = JSArray::create(vm, arrayStructure, size);
1710     return bitwise_cast&lt;char*&gt;(result);
1711 }
1712 
<span class="line-modified">1713 char* JIT_OPERATION operationNewArrayWithSizeAndHint(ExecState* exec, Structure* arrayStructure, int32_t size, int32_t vectorLengthHint, Butterfly* butterfly)</span>
1714 {
<span class="line-modified">1715     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1716     NativeCallFrameTracer tracer(vm, exec);</span>

1717     auto scope = DECLARE_THROW_SCOPE(vm);
1718 
1719     if (UNLIKELY(size &lt; 0))
<span class="line-modified">1720         return bitwise_cast&lt;char*&gt;(throwException(exec, scope, createRangeError(exec, &quot;Array size is not a small enough positive integer.&quot;_s)));</span>
1721 
1722     JSArray* result;
1723     if (butterfly)
1724         result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
1725     else {
1726         result = JSArray::tryCreate(vm, arrayStructure, size, vectorLengthHint);
1727         RELEASE_ASSERT(result);
1728     }
1729     return bitwise_cast&lt;char*&gt;(result);
1730 }
1731 
<span class="line-modified">1732 JSCell* JIT_OPERATION operationNewArrayBuffer(ExecState* exec, Structure* arrayStructure, JSCell* immutableButterflyCell)</span>
1733 {
<span class="line-modified">1734     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1735     NativeCallFrameTracer tracer(vm, exec);</span>

1736     ASSERT(!arrayStructure-&gt;outOfLineCapacity());
1737     auto* immutableButterfly = jsCast&lt;JSImmutableButterfly*&gt;(immutableButterflyCell);
1738     ASSERT(arrayStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode() || hasAnyArrayStorage(arrayStructure-&gt;indexingMode()));
1739     auto* result = CommonSlowPaths::allocateNewArrayBuffer(vm, arrayStructure, immutableButterfly);
1740     ASSERT(result-&gt;indexingMode() == result-&gt;structure(vm)-&gt;indexingMode());
1741     ASSERT(result-&gt;structure(vm) == arrayStructure);
1742     return result;
1743 }
1744 
1745 char* JIT_OPERATION operationNewInt8ArrayWithSize(
<span class="line-modified">1746     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
1747 {
<span class="line-modified">1748     return newTypedArrayWithSize&lt;JSInt8Array&gt;(exec, structure, length, vector);</span>



1749 }
1750 
1751 char* JIT_OPERATION operationNewInt8ArrayWithOneArgument(
<span class="line-modified">1752     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
1753 {
<span class="line-modified">1754     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1755     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1756     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt8Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>

1757 }
1758 
1759 char* JIT_OPERATION operationNewInt16ArrayWithSize(
<span class="line-modified">1760     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
1761 {
<span class="line-modified">1762     return newTypedArrayWithSize&lt;JSInt16Array&gt;(exec, structure, length, vector);</span>



1763 }
1764 
1765 char* JIT_OPERATION operationNewInt16ArrayWithOneArgument(
<span class="line-modified">1766     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
1767 {
<span class="line-modified">1768     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1769     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1770     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt16Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>

1771 }
1772 
1773 char* JIT_OPERATION operationNewInt32ArrayWithSize(
<span class="line-modified">1774     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
1775 {
<span class="line-modified">1776     return newTypedArrayWithSize&lt;JSInt32Array&gt;(exec, structure, length, vector);</span>



1777 }
1778 
1779 char* JIT_OPERATION operationNewInt32ArrayWithOneArgument(
<span class="line-modified">1780     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
1781 {
<span class="line-modified">1782     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1783     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1784     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>

1785 }
1786 
1787 char* JIT_OPERATION operationNewUint8ArrayWithSize(
<span class="line-modified">1788     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
1789 {
<span class="line-modified">1790     return newTypedArrayWithSize&lt;JSUint8Array&gt;(exec, structure, length, vector);</span>



1791 }
1792 
1793 char* JIT_OPERATION operationNewUint8ArrayWithOneArgument(
<span class="line-modified">1794     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
1795 {
<span class="line-modified">1796     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1797     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1798     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>

1799 }
1800 
1801 char* JIT_OPERATION operationNewUint8ClampedArrayWithSize(
<span class="line-modified">1802     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
1803 {
<span class="line-modified">1804     return newTypedArrayWithSize&lt;JSUint8ClampedArray&gt;(exec, structure, length, vector);</span>



1805 }
1806 
1807 char* JIT_OPERATION operationNewUint8ClampedArrayWithOneArgument(
<span class="line-modified">1808     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
1809 {
<span class="line-modified">1810     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1811     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1812     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8ClampedArray&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>

1813 }
1814 
1815 char* JIT_OPERATION operationNewUint16ArrayWithSize(
<span class="line-modified">1816     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
1817 {
<span class="line-modified">1818     return newTypedArrayWithSize&lt;JSUint16Array&gt;(exec, structure, length, vector);</span>



1819 }
1820 
1821 char* JIT_OPERATION operationNewUint16ArrayWithOneArgument(
<span class="line-modified">1822     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
1823 {
<span class="line-modified">1824     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1825     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1826     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint16Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>

1827 }
1828 
1829 char* JIT_OPERATION operationNewUint32ArrayWithSize(
<span class="line-modified">1830     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
1831 {
<span class="line-modified">1832     return newTypedArrayWithSize&lt;JSUint32Array&gt;(exec, structure, length, vector);</span>



1833 }
1834 
1835 char* JIT_OPERATION operationNewUint32ArrayWithOneArgument(
<span class="line-modified">1836     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
1837 {
<span class="line-modified">1838     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1839     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1840     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>

1841 }
1842 
1843 char* JIT_OPERATION operationNewFloat32ArrayWithSize(
<span class="line-modified">1844     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
1845 {
<span class="line-modified">1846     return newTypedArrayWithSize&lt;JSFloat32Array&gt;(exec, structure, length, vector);</span>



1847 }
1848 
1849 char* JIT_OPERATION operationNewFloat32ArrayWithOneArgument(
<span class="line-modified">1850     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
1851 {
<span class="line-modified">1852     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1853     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1854     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>

1855 }
1856 
1857 char* JIT_OPERATION operationNewFloat64ArrayWithSize(
<span class="line-modified">1858     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
1859 {
<span class="line-modified">1860     return newTypedArrayWithSize&lt;JSFloat64Array&gt;(exec, structure, length, vector);</span>



1861 }
1862 
1863 char* JIT_OPERATION operationNewFloat64ArrayWithOneArgument(
<span class="line-modified">1864     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
1865 {
<span class="line-modified">1866     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1867     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1868     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat64Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>










1869 }
1870 
<span class="line-modified">1871 JSCell* JIT_OPERATION operationCreateActivationDirect(ExecState* exec, Structure* structure, JSScope* scope, SymbolTable* table, EncodedJSValue initialValueEncoded)</span>
1872 {
<span class="line-modified">1873     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1874     NativeCallFrameTracer tracer(vm, exec);</span>

1875     JSValue initialValue = JSValue::decode(initialValueEncoded);
1876     ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
1877     return JSLexicalEnvironment::create(vm, structure, scope, table, initialValue);
1878 }
1879 
<span class="line-modified">1880 JSCell* JIT_OPERATION operationCreateDirectArguments(ExecState* exec, Structure* structure, uint32_t length, uint32_t minCapacity)</span>
1881 {
<span class="line-modified">1882     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1883     NativeCallFrameTracer tracer(vm, exec);</span>

1884     DirectArguments* result = DirectArguments::create(
1885         vm, structure, length, std::max(length, minCapacity));
1886     // The caller will store to this object without barriers. Most likely, at this point, this is
1887     // still a young object and so no barriers are needed. But it&#39;s good to be careful anyway,
1888     // since the GC should be allowed to do crazy (like pretenuring, for example).
1889     vm.heap.writeBarrier(result);
1890     return result;
1891 }
1892 
<span class="line-modified">1893 JSCell* JIT_OPERATION operationCreateScopedArguments(ExecState* exec, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee, JSLexicalEnvironment* scope)</span>
1894 {
<span class="line-modified">1895     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1896     NativeCallFrameTracer tracer(vm, exec);</span>

1897 
1898     // We could pass the ScopedArgumentsTable* as an argument. We currently don&#39;t because I
1899     // didn&#39;t feel like changing the max number of arguments for a slow path call from 6 to 7.
1900     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
1901 
1902     return ScopedArguments::createByCopyingFrom(
1903         vm, structure, argumentStart, length, callee, table, scope);
1904 }
1905 
<span class="line-modified">1906 JSCell* JIT_OPERATION operationCreateClonedArguments(ExecState* exec, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee)</span>
1907 {
<span class="line-modified">1908     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1909     NativeCallFrameTracer tracer(vm, exec);</span>

1910     return ClonedArguments::createByCopyingFrom(
<span class="line-modified">1911         exec, structure, argumentStart, length, callee);</span>
1912 }
1913 
<span class="line-modified">1914 JSCell* JIT_OPERATION operationCreateDirectArgumentsDuringExit(ExecState* exec, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)</span>
1915 {
<span class="line-modified">1916     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1917     NativeCallFrameTracer tracer(vm, exec);</span>


















1918 
1919     DeferGCForAWhile deferGC(vm.heap);
1920 
1921     CodeBlock* codeBlock;
1922     if (inlineCallFrame)
1923         codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
1924     else
<span class="line-modified">1925         codeBlock = exec-&gt;codeBlock();</span>
1926 
1927     unsigned length = argumentCount - 1;
1928     unsigned capacity = std::max(length, static_cast&lt;unsigned&gt;(codeBlock-&gt;numParameters() - 1));
1929     DirectArguments* result = DirectArguments::create(
1930         vm, codeBlock-&gt;globalObject()-&gt;directArgumentsStructure(), length, capacity);
1931 
1932     result-&gt;setCallee(vm, callee);
1933 
1934     Register* arguments =
<span class="line-modified">1935         exec-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +</span>
1936         CallFrame::argumentOffset(0);
1937     for (unsigned i = length; i--;)
1938         result-&gt;setIndexQuickly(vm, i, arguments[i].jsValue());
1939 
1940     return result;
1941 }
1942 
<span class="line-modified">1943 JSCell* JIT_OPERATION operationCreateClonedArgumentsDuringExit(ExecState* exec, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)</span>
1944 {
<span class="line-modified">1945     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1946     NativeCallFrameTracer tracer(vm, exec);</span>

1947 
1948     DeferGCForAWhile deferGC(vm.heap);
1949 
1950     CodeBlock* codeBlock;
1951     if (inlineCallFrame)
1952         codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
1953     else
<span class="line-modified">1954         codeBlock = exec-&gt;codeBlock();</span>
1955 
1956     unsigned length = argumentCount - 1;

1957     ClonedArguments* result = ClonedArguments::createEmpty(
<span class="line-modified">1958         vm, codeBlock-&gt;globalObject()-&gt;clonedArgumentsStructure(), callee, length);</span>
1959 
1960     Register* arguments =
<span class="line-modified">1961         exec-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +</span>
1962         CallFrame::argumentOffset(0);
1963     for (unsigned i = length; i--;)
<span class="line-modified">1964         result-&gt;putDirectIndex(exec, i, arguments[i].jsValue());</span>
1965 
1966 
1967     return result;
1968 }
1969 
<span class="line-modified">1970 JSCell* JIT_OPERATION operationCreateRest(ExecState* exec, Register* argumentStart, unsigned numberOfParamsToSkip, unsigned arraySize)</span>
1971 {
<span class="line-modified">1972     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1973     NativeCallFrameTracer tracer(vm, exec);</span>

1974 
<span class="line-removed">1975     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
1976     Structure* structure = globalObject-&gt;restParameterStructure();
1977     static_assert(sizeof(Register) == sizeof(JSValue), &quot;This is a strong assumption here.&quot;);
1978     JSValue* argumentsToCopyRegion = bitwise_cast&lt;JSValue*&gt;(argumentStart) + numberOfParamsToSkip;
<span class="line-modified">1979     return constructArray(exec, structure, argumentsToCopyRegion, arraySize);</span>
1980 }
1981 
<span class="line-modified">1982 size_t JIT_OPERATION operationObjectIsObject(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)</span>
1983 {
<span class="line-modified">1984     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1985     NativeCallFrameTracer tracer(vm, exec);</span>

1986 
1987     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
1988 
1989     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
1990         return false;
1991     if (object-&gt;isFunction(vm))
1992         return false;
1993     return true;
1994 }
1995 
<span class="line-modified">1996 size_t JIT_OPERATION operationObjectIsFunction(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)</span>
1997 {
<span class="line-modified">1998     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1999     NativeCallFrameTracer tracer(vm, exec);</span>

2000 
2001     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2002 
2003     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2004         return false;
2005     if (object-&gt;isFunction(vm))
2006         return true;
2007     return false;
2008 }
2009 
<span class="line-modified">2010 JSCell* JIT_OPERATION operationTypeOfObject(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)</span>
2011 {
<span class="line-modified">2012     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2013     NativeCallFrameTracer tracer(vm, exec);</span>

2014 
2015     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2016 
2017     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2018         return vm.smallStrings.undefinedString();
2019     if (object-&gt;isFunction(vm))
2020         return vm.smallStrings.functionString();
2021     return vm.smallStrings.objectString();
2022 }
2023 
<span class="line-modified">2024 int32_t JIT_OPERATION operationTypeOfObjectAsTypeofType(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)</span>
2025 {
<span class="line-modified">2026     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2027     NativeCallFrameTracer tracer(vm, exec);</span>

2028 
2029     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2030 
2031     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2032         return static_cast&lt;int32_t&gt;(TypeofType::Undefined);
2033     if (object-&gt;isFunction(vm))
2034         return static_cast&lt;int32_t&gt;(TypeofType::Function);
2035     return static_cast&lt;int32_t&gt;(TypeofType::Object);
2036 }
2037 
<span class="line-modified">2038 char* JIT_OPERATION operationAllocateSimplePropertyStorageWithInitialCapacity(ExecState* exec)</span>
2039 {
<span class="line-modified">2040     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2041     NativeCallFrameTracer tracer(vm, exec);</span>

2042 
2043     return reinterpret_cast&lt;char*&gt;(
2044         Butterfly::createUninitialized(vm, 0, 0, initialOutOfLineCapacity, false, 0));
2045 }
2046 
<span class="line-modified">2047 char* JIT_OPERATION operationAllocateSimplePropertyStorage(ExecState* exec, size_t newSize)</span>
2048 {
<span class="line-modified">2049     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2050     NativeCallFrameTracer tracer(vm, exec);</span>

2051 
2052     return reinterpret_cast&lt;char*&gt;(
2053         Butterfly::createUninitialized(vm, 0, 0, newSize, false, 0));
2054 }
2055 
<span class="line-modified">2056 char* JIT_OPERATION operationAllocateComplexPropertyStorageWithInitialCapacity(ExecState* exec, JSObject* object)</span>
2057 {
<span class="line-modified">2058     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2059     NativeCallFrameTracer tracer(vm, exec);</span>

2060 
2061     ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
2062     return reinterpret_cast&lt;char*&gt;(
2063         object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity));
2064 }
2065 
<span class="line-modified">2066 char* JIT_OPERATION operationAllocateComplexPropertyStorage(ExecState* exec, JSObject* object, size_t newSize)</span>
2067 {
<span class="line-modified">2068     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2069     NativeCallFrameTracer tracer(vm, exec);</span>

2070 
2071     return reinterpret_cast&lt;char*&gt;(
2072         object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize));
2073 }
2074 
<span class="line-modified">2075 char* JIT_OPERATION operationEnsureInt32(ExecState* exec, JSCell* cell)</span>
2076 {
<span class="line-modified">2077     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2078     NativeCallFrameTracer tracer(vm, exec);</span>

2079 
2080     if (!cell-&gt;isObject())
2081         return 0;
2082 
2083     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableInt32(vm).data());
2084     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasInt32(cell-&gt;indexingMode())) || !result);
2085     return result;
2086 }
2087 
<span class="line-modified">2088 char* JIT_OPERATION operationEnsureDouble(ExecState* exec, JSCell* cell)</span>
2089 {
<span class="line-modified">2090     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2091     NativeCallFrameTracer tracer(vm, exec);</span>

2092 
2093     if (!cell-&gt;isObject())
2094         return 0;
2095 
2096     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableDouble(vm).data());
2097     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasDouble(cell-&gt;indexingMode())) || !result);
2098     return result;
2099 }
2100 
<span class="line-modified">2101 char* JIT_OPERATION operationEnsureContiguous(ExecState* exec, JSCell* cell)</span>
2102 {
<span class="line-modified">2103     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2104     NativeCallFrameTracer tracer(vm, exec);</span>

2105 
2106     if (!cell-&gt;isObject())
2107         return 0;
2108 
2109     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableContiguous(vm).data());
2110     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasContiguous(cell-&gt;indexingMode())) || !result);
2111     return result;
2112 }
2113 
<span class="line-modified">2114 char* JIT_OPERATION operationEnsureArrayStorage(ExecState* exec, JSCell* cell)</span>
2115 {
<span class="line-modified">2116     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2117     NativeCallFrameTracer tracer(vm, exec);</span>

2118 
2119     if (!cell-&gt;isObject())
2120         return 0;
2121 
2122     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;ensureArrayStorage(vm));
2123     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasAnyArrayStorage(cell-&gt;indexingMode())) || !result);
2124     return result;
2125 }
2126 
<span class="line-modified">2127 EncodedJSValue JIT_OPERATION operationHasGenericProperty(ExecState* exec, EncodedJSValue encodedBaseValue, JSCell* property)</span>
2128 {
<span class="line-modified">2129     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2130     NativeCallFrameTracer tracer(vm, exec);</span>

2131     auto scope = DECLARE_THROW_SCOPE(vm);
2132 
2133     JSValue baseValue = JSValue::decode(encodedBaseValue);
2134     if (baseValue.isUndefinedOrNull())
2135         return JSValue::encode(jsBoolean(false));
2136 
<span class="line-modified">2137     JSObject* base = baseValue.toObject(exec);</span>
<span class="line-modified">2138     ASSERT(!scope.exception() || !base);</span>
2139     if (!base)
2140         return JSValue::encode(JSValue());
<span class="line-modified">2141     auto propertyName = asString(property)-&gt;toIdentifier(exec);</span>
2142     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">2143     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty))));</span>
2144 }
2145 
<span class="line-modified">2146 size_t JIT_OPERATION operationHasIndexedPropertyByInt(ExecState* exec, JSCell* baseCell, int32_t subscript, int32_t internalMethodType)</span>
2147 {
<span class="line-modified">2148     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2149     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">2150     JSObject* object = baseCell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());</span>

2151     if (UNLIKELY(subscript &lt; 0)) {
2152         // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified">2153         return object-&gt;hasPropertyGeneric(exec, Identifier::from(vm, subscript), static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));</span>
2154     }
<span class="line-modified">2155     return object-&gt;hasPropertyGeneric(exec, subscript, static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));</span>
2156 }
2157 
<span class="line-modified">2158 JSCell* JIT_OPERATION operationGetPropertyEnumerator(ExecState* exec, EncodedJSValue encodedBase)</span>
2159 {
<span class="line-modified">2160     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2161     NativeCallFrameTracer tracer(vm, exec);</span>

2162     auto scope = DECLARE_THROW_SCOPE(vm);
2163 
2164     JSValue base = JSValue::decode(encodedBase);
2165     if (base.isUndefinedOrNull())
2166         return vm.emptyPropertyNameEnumerator();
2167 
<span class="line-modified">2168     JSObject* baseObject = base.toObject(exec);</span>
2169     RETURN_IF_EXCEPTION(scope, { });
2170 
<span class="line-modified">2171     RELEASE_AND_RETURN(scope, propertyNameEnumerator(exec, baseObject));</span>
2172 }
2173 
<span class="line-modified">2174 JSCell* JIT_OPERATION operationGetPropertyEnumeratorCell(ExecState* exec, JSCell* cell)</span>
2175 {
<span class="line-modified">2176     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2177     NativeCallFrameTracer tracer(vm, exec);</span>

2178     auto scope = DECLARE_THROW_SCOPE(vm);
2179 
<span class="line-modified">2180     JSObject* base = cell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());</span>
2181     RETURN_IF_EXCEPTION(scope, { });
2182 
<span class="line-modified">2183     RELEASE_AND_RETURN(scope, propertyNameEnumerator(exec, base));</span>
2184 }
2185 
<span class="line-modified">2186 JSCell* JIT_OPERATION operationToIndexString(ExecState* exec, int32_t index)</span>
2187 {
<span class="line-modified">2188     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2189     NativeCallFrameTracer tracer(vm, exec);</span>

2190     return jsString(vm, Identifier::from(vm, index).string());
2191 }
2192 
<span class="line-modified">2193 JSCell* JIT_OPERATION operationNewRegexpWithLastIndex(ExecState* exec, JSCell* regexpPtr, EncodedJSValue encodedLastIndex)</span>
2194 {
<span class="line-modified">2195     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2196     NativeCallFrameTracer tracer(vm, exec);</span>

2197 
2198     RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
2199     ASSERT(regexp-&gt;isValid());
<span class="line-modified">2200     return RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regexp, JSValue::decode(encodedLastIndex));</span>
2201 }
2202 
<span class="line-modified">2203 StringImpl* JIT_OPERATION operationResolveRope(ExecState* exec, JSString* string)</span>
2204 {
<span class="line-modified">2205     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2206     NativeCallFrameTracer tracer(vm, exec);</span>

2207 
<span class="line-modified">2208     return string-&gt;value(exec).impl();</span>
2209 }
2210 
<span class="line-modified">2211 JSString* JIT_OPERATION operationStringValueOf(ExecState* exec, EncodedJSValue encodedArgument)</span>
2212 {
<span class="line-modified">2213     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2214     NativeCallFrameTracer tracer(vm, exec);</span>

2215     auto scope = DECLARE_THROW_SCOPE(vm);
2216 
2217     JSValue argument = JSValue::decode(encodedArgument);
2218 
2219     if (argument.isString())
2220         return asString(argument);
2221 
2222     if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, argument))
2223         return stringObject-&gt;internalValue();
2224 
<span class="line-modified">2225     throwVMTypeError(exec, scope);</span>
2226     return nullptr;
2227 }
2228 
<span class="line-modified">2229 JSCell* JIT_OPERATION operationStringSubstr(ExecState* exec, JSCell* cell, int32_t from, int32_t span)</span>
2230 {
<span class="line-modified">2231     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2232     NativeCallFrameTracer tracer(vm, exec);</span>

2233 
<span class="line-modified">2234     return jsSubstring(vm, exec, jsCast&lt;JSString*&gt;(cell), from, span);</span>
2235 }
2236 
<span class="line-modified">2237 JSCell* JIT_OPERATION operationStringSlice(ExecState* exec, JSCell* cell, int32_t start, int32_t end)</span>
2238 {
<span class="line-modified">2239     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2240     NativeCallFrameTracer tracer(vm, exec);</span>

2241 
2242     JSString* string = asString(cell);
2243     static_assert(static_cast&lt;uint64_t&gt;(JSString::MaxLength) &lt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()), &quot;&quot;);
<span class="line-modified">2244     return stringSlice(exec, vm, string, string-&gt;length(), start, end);</span>
2245 }
2246 
<span class="line-modified">2247 JSString* JIT_OPERATION operationToLowerCase(ExecState* exec, JSString* string, uint32_t failingIndex)</span>
2248 {
<span class="line-modified">2249     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2250     NativeCallFrameTracer tracer(vm, exec);</span>

2251 
2252     auto scope = DECLARE_THROW_SCOPE(vm);
2253 
<span class="line-modified">2254     const String&amp; inputString = string-&gt;value(exec);</span>
2255     RETURN_IF_EXCEPTION(scope, nullptr);
2256     if (!inputString.length())
2257         return vm.smallStrings.emptyString();
2258 
2259     String lowercasedString = inputString.is8Bit() ? inputString.convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(failingIndex) : inputString.convertToLowercaseWithoutLocale();
2260     if (lowercasedString.impl() == inputString.impl())
2261         return string;
2262     RELEASE_AND_RETURN(scope, jsString(vm, lowercasedString));
2263 }
2264 
<span class="line-modified">2265 char* JIT_OPERATION operationInt32ToString(ExecState* exec, int32_t value, int32_t radix)</span>
2266 {
<span class="line-modified">2267     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2268     NativeCallFrameTracer tracer(vm, exec);</span>

2269 
2270     auto scope = DECLARE_THROW_SCOPE(vm);
2271 
2272     if (radix &lt; 2 || radix &gt; 36) {
<span class="line-modified">2273         throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));</span>
2274         return nullptr;
2275     }
2276 
2277     return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
2278 }
2279 
<span class="line-modified">2280 char* JIT_OPERATION operationInt52ToString(ExecState* exec, int64_t value, int32_t radix)</span>
2281 {
<span class="line-modified">2282     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2283     NativeCallFrameTracer tracer(vm, exec);</span>

2284 
2285     auto scope = DECLARE_THROW_SCOPE(vm);
2286 
2287     if (radix &lt; 2 || radix &gt; 36) {
<span class="line-modified">2288         throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));</span>
2289         return nullptr;
2290     }
2291 
2292     return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
2293 }
2294 
<span class="line-modified">2295 char* JIT_OPERATION operationDoubleToString(ExecState* exec, double value, int32_t radix)</span>
2296 {
<span class="line-modified">2297     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2298     NativeCallFrameTracer tracer(vm, exec);</span>

2299 
2300     auto scope = DECLARE_THROW_SCOPE(vm);
2301 
2302     if (radix &lt; 2 || radix &gt; 36) {
<span class="line-modified">2303         throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));</span>
2304         return nullptr;
2305     }
2306 
2307     return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
2308 }
2309 
<span class="line-modified">2310 char* JIT_OPERATION operationInt32ToStringWithValidRadix(ExecState* exec, int32_t value, int32_t radix)</span>
2311 {
<span class="line-modified">2312     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2313     NativeCallFrameTracer tracer(vm, exec);</span>

2314 
2315     return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
2316 }
2317 
<span class="line-modified">2318 char* JIT_OPERATION operationInt52ToStringWithValidRadix(ExecState* exec, int64_t value, int32_t radix)</span>
2319 {
<span class="line-modified">2320     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2321     NativeCallFrameTracer tracer(vm, exec);</span>

2322 
2323     return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
2324 }
2325 
<span class="line-modified">2326 char* JIT_OPERATION operationDoubleToStringWithValidRadix(ExecState* exec, double value, int32_t radix)</span>
2327 {
<span class="line-modified">2328     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2329     NativeCallFrameTracer tracer(vm, exec);</span>

2330 
2331     return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
2332 }
2333 
<span class="line-modified">2334 JSString* JIT_OPERATION operationSingleCharacterString(ExecState* exec, int32_t character)</span>
2335 {
<span class="line-modified">2336     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2337     NativeCallFrameTracer tracer(vm, exec);</span>

2338 
2339     return jsSingleCharacterString(vm, static_cast&lt;UChar&gt;(character));
2340 }
2341 
<span class="line-modified">2342 Symbol* JIT_OPERATION operationNewSymbol(ExecState* exec)</span>
2343 {
<span class="line-modified">2344     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2345     NativeCallFrameTracer tracer(vm, exec);</span>

2346 
2347     return Symbol::create(vm);
2348 }
2349 
<span class="line-modified">2350 Symbol* JIT_OPERATION operationNewSymbolWithDescription(ExecState* exec, JSString* description)</span>
2351 {
<span class="line-modified">2352     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2353     NativeCallFrameTracer tracer(vm, exec);</span>

2354     auto scope = DECLARE_THROW_SCOPE(vm);
2355 
<span class="line-modified">2356     String string = description-&gt;value(exec);</span>
2357     RETURN_IF_EXCEPTION(scope, nullptr);
2358 
2359     return Symbol::createWithDescription(vm, string);
2360 }
2361 
<span class="line-modified">2362 JSCell* JIT_OPERATION operationNewStringObject(ExecState* exec, JSString* string, Structure* structure)</span>
2363 {
<span class="line-modified">2364     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2365     NativeCallFrameTracer tracer(vm, exec);</span>

2366 
2367     return StringObject::create(vm, structure, string);
2368 }
2369 
<span class="line-modified">2370 JSString* JIT_OPERATION operationToStringOnCell(ExecState* exec, JSCell* cell)</span>
2371 {
<span class="line-modified">2372     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2373     NativeCallFrameTracer tracer(vm, exec);</span>

2374 
<span class="line-modified">2375     return JSValue(cell).toString(exec);</span>
2376 }
2377 
<span class="line-modified">2378 JSString* JIT_OPERATION operationToString(ExecState* exec, EncodedJSValue value)</span>
2379 {
<span class="line-modified">2380     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2381     NativeCallFrameTracer tracer(vm, exec);</span>

2382 
<span class="line-modified">2383     return JSValue::decode(value).toString(exec);</span>
2384 }
2385 
<span class="line-modified">2386 JSString* JIT_OPERATION operationCallStringConstructorOnCell(ExecState* exec, JSCell* cell)</span>
2387 {
<span class="line-modified">2388     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2389     NativeCallFrameTracer tracer(vm, exec);</span>

2390 
<span class="line-modified">2391     return stringConstructor(exec, cell);</span>
2392 }
2393 
<span class="line-modified">2394 JSString* JIT_OPERATION operationCallStringConstructor(ExecState* exec, EncodedJSValue value)</span>
2395 {
<span class="line-modified">2396     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2397     NativeCallFrameTracer tracer(vm, exec);</span>

2398 
<span class="line-modified">2399     return stringConstructor(exec, JSValue::decode(value));</span>
2400 }
2401 
<span class="line-modified">2402 JSString* JIT_OPERATION operationMakeRope2(ExecState* exec, JSString* left, JSString* right)</span>
2403 {
<span class="line-modified">2404     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2405     NativeCallFrameTracer tracer(vm, exec);</span>

2406 
<span class="line-modified">2407     return jsString(exec, left, right);</span>
2408 }
2409 
<span class="line-modified">2410 JSString* JIT_OPERATION operationMakeRope3(ExecState* exec, JSString* a, JSString* b, JSString* c)</span>
2411 {
<span class="line-modified">2412     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2413     NativeCallFrameTracer tracer(vm, exec);</span>

2414 
<span class="line-modified">2415     return jsString(exec, a, b, c);</span>
2416 }
2417 
<span class="line-modified">2418 JSString* JIT_OPERATION operationStrCat2(ExecState* exec, EncodedJSValue a, EncodedJSValue b)</span>
2419 {
<span class="line-modified">2420     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2421     NativeCallFrameTracer tracer(vm, exec);</span>

2422     auto scope = DECLARE_THROW_SCOPE(vm);
2423 
2424     ASSERT(!JSValue::decode(a).isSymbol());
2425     ASSERT(!JSValue::decode(b).isSymbol());
<span class="line-modified">2426     JSString* str1 = JSValue::decode(a).toString(exec);</span>
2427     scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
<span class="line-modified">2428     JSString* str2 = JSValue::decode(b).toString(exec);</span>
2429     scope.assertNoException();
2430 
<span class="line-modified">2431     RELEASE_AND_RETURN(scope, jsString(exec, str1, str2));</span>
2432 }
2433 
<span class="line-modified">2434 JSString* JIT_OPERATION operationStrCat3(ExecState* exec, EncodedJSValue a, EncodedJSValue b, EncodedJSValue c)</span>
2435 {
<span class="line-modified">2436     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2437     NativeCallFrameTracer tracer(vm, exec);</span>

2438     auto scope = DECLARE_THROW_SCOPE(vm);
2439 
2440     ASSERT(!JSValue::decode(a).isSymbol());
2441     ASSERT(!JSValue::decode(b).isSymbol());
2442     ASSERT(!JSValue::decode(c).isSymbol());
<span class="line-modified">2443     JSString* str1 = JSValue::decode(a).toString(exec);</span>
2444     scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
<span class="line-modified">2445     JSString* str2 = JSValue::decode(b).toString(exec);</span>
2446     scope.assertNoException();
<span class="line-modified">2447     JSString* str3 = JSValue::decode(c).toString(exec);</span>
2448     scope.assertNoException();
2449 
<span class="line-modified">2450     RELEASE_AND_RETURN(scope, jsString(exec, str1, str2, str3));</span>
2451 }
2452 
<span class="line-modified">2453 char* JIT_OPERATION operationFindSwitchImmTargetForDouble(</span>
<span class="line-removed">2454     ExecState* exec, EncodedJSValue encodedValue, size_t tableIndex)</span>
2455 {
<span class="line-modified">2456     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2457     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">2458     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>

2459     SimpleJumpTable&amp; table = codeBlock-&gt;switchJumpTable(tableIndex);
2460     JSValue value = JSValue::decode(encodedValue);
2461     ASSERT(value.isDouble());
2462     double asDouble = value.asDouble();
2463     int32_t asInt32 = static_cast&lt;int32_t&gt;(asDouble);
2464     if (asDouble == asInt32)
2465         return table.ctiForValue(asInt32).executableAddress&lt;char*&gt;();
2466     return table.ctiDefault.executableAddress&lt;char*&gt;();
2467 }
2468 
<span class="line-modified">2469 char* JIT_OPERATION operationSwitchString(ExecState* exec, size_t tableIndex, JSString* string)</span>
2470 {
<span class="line-modified">2471     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2472     NativeCallFrameTracer tracer(vm, exec);</span>

2473     auto throwScope = DECLARE_THROW_SCOPE(vm);
2474 
<span class="line-modified">2475     StringImpl* strImpl = string-&gt;value(exec).impl();</span>
2476 
2477     RETURN_IF_EXCEPTION(throwScope, nullptr);
2478 
<span class="line-modified">2479     return exec-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).ctiForValue(strImpl).executableAddress&lt;char*&gt;();</span>
2480 }
2481 
<span class="line-modified">2482 int32_t JIT_OPERATION operationSwitchStringAndGetBranchOffset(ExecState* exec, size_t tableIndex, JSString* string)</span>
2483 {
<span class="line-modified">2484     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2485     NativeCallFrameTracer tracer(vm, exec);</span>

2486     auto throwScope = DECLARE_THROW_SCOPE(vm);
2487 
<span class="line-modified">2488     StringImpl* strImpl = string-&gt;value(exec).impl();</span>
2489 
2490     RETURN_IF_EXCEPTION(throwScope, 0);
2491 
<span class="line-modified">2492     return exec-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).offsetForValue(strImpl, std::numeric_limits&lt;int32_t&gt;::min());</span>
2493 }
2494 
2495 uintptr_t JIT_OPERATION operationCompareStringImplLess(StringImpl* a, StringImpl* b)
2496 {
2497     return codePointCompare(a, b) &lt; 0;
2498 }
2499 
2500 uintptr_t JIT_OPERATION operationCompareStringImplLessEq(StringImpl* a, StringImpl* b)
2501 {
2502     return codePointCompare(a, b) &lt;= 0;
2503 }
2504 
2505 uintptr_t JIT_OPERATION operationCompareStringImplGreater(StringImpl* a, StringImpl* b)
2506 {
2507     return codePointCompare(a, b) &gt; 0;
2508 }
2509 
2510 uintptr_t JIT_OPERATION operationCompareStringImplGreaterEq(StringImpl* a, StringImpl* b)
2511 {
2512     return codePointCompare(a, b) &gt;= 0;
2513 }
2514 
<span class="line-modified">2515 uintptr_t JIT_OPERATION operationCompareStringLess(ExecState* exec, JSString* a, JSString* b)</span>
2516 {
<span class="line-modified">2517     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2518     NativeCallFrameTracer tracer(vm, exec);</span>

2519 
<span class="line-modified">2520     return codePointCompareLessThan(asString(a)-&gt;value(exec), asString(b)-&gt;value(exec));</span>
2521 }
2522 
<span class="line-modified">2523 uintptr_t JIT_OPERATION operationCompareStringLessEq(ExecState* exec, JSString* a, JSString* b)</span>
2524 {
<span class="line-modified">2525     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2526     NativeCallFrameTracer tracer(vm, exec);</span>

2527 
<span class="line-modified">2528     return !codePointCompareLessThan(asString(b)-&gt;value(exec), asString(a)-&gt;value(exec));</span>
2529 }
2530 
<span class="line-modified">2531 uintptr_t JIT_OPERATION operationCompareStringGreater(ExecState* exec, JSString* a, JSString* b)</span>
2532 {
<span class="line-modified">2533     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2534     NativeCallFrameTracer tracer(vm, exec);</span>

2535 
<span class="line-modified">2536     return codePointCompareLessThan(asString(b)-&gt;value(exec), asString(a)-&gt;value(exec));</span>
2537 }
2538 
<span class="line-modified">2539 uintptr_t JIT_OPERATION operationCompareStringGreaterEq(ExecState* exec, JSString* a, JSString* b)</span>
2540 {
<span class="line-modified">2541     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2542     NativeCallFrameTracer tracer(vm, exec);</span>

2543 
<span class="line-modified">2544     return !codePointCompareLessThan(asString(a)-&gt;value(exec), asString(b)-&gt;value(exec));</span>
2545 }
2546 
<span class="line-modified">2547 void JIT_OPERATION operationNotifyWrite(ExecState* exec, WatchpointSet* set)</span>
2548 {
<span class="line-modified">2549     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2550     NativeCallFrameTracer tracer(vm, exec);</span>

2551 
2552     set-&gt;touch(vm, &quot;Executed NotifyWrite&quot;);
2553 }
2554 
<span class="line-modified">2555 void JIT_OPERATION operationThrowStackOverflowForVarargs(ExecState* exec)</span>
2556 {
<span class="line-modified">2557     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2558     NativeCallFrameTracer tracer(vm, exec);</span>

2559     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2560     throwStackOverflowError(exec, scope);</span>
2561 }
2562 
<span class="line-modified">2563 int32_t JIT_OPERATION operationSizeOfVarargs(ExecState* exec, EncodedJSValue encodedArguments, uint32_t firstVarArgOffset)</span>
2564 {
<span class="line-modified">2565     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2566     NativeCallFrameTracer tracer(vm, exec);</span>

2567     JSValue arguments = JSValue::decode(encodedArguments);
2568 
<span class="line-modified">2569     return sizeOfVarargs(exec, arguments, firstVarArgOffset);</span>
2570 }
2571 
<span class="line-modified">2572 int32_t JIT_OPERATION operationHasOwnProperty(ExecState* exec, JSObject* thisObject, EncodedJSValue encodedKey)</span>
2573 {
<span class="line-modified">2574     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2575     NativeCallFrameTracer tracer(vm, exec);</span>

2576     auto scope = DECLARE_THROW_SCOPE(vm);
2577 
2578     JSValue key = JSValue::decode(encodedKey);
<span class="line-modified">2579     Identifier propertyName = key.toPropertyKey(exec);</span>
2580     RETURN_IF_EXCEPTION(scope, false);
2581 
2582     PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">2583     bool result = thisObject-&gt;hasOwnProperty(exec, propertyName.impl(), slot);</span>
2584     RETURN_IF_EXCEPTION(scope, false);
2585 
2586     HasOwnPropertyCache* hasOwnPropertyCache = vm.hasOwnPropertyCache();
2587     ASSERT(hasOwnPropertyCache);
2588     hasOwnPropertyCache-&gt;tryAdd(vm, slot, thisObject, propertyName.impl(), result);
2589     return result;
2590 }
2591 
<span class="line-modified">2592 int32_t JIT_OPERATION operationNumberIsInteger(ExecState* exec, EncodedJSValue value)</span>
2593 {
<span class="line-modified">2594     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2595     NativeCallFrameTracer tracer(vm, exec);</span>

2596     return NumberConstructor::isIntegerImpl(JSValue::decode(value));
2597 }
2598 
<span class="line-modified">2599 int32_t JIT_OPERATION operationArrayIndexOfString(ExecState* exec, Butterfly* butterfly, JSString* searchElement, int32_t index)</span>
2600 {
<span class="line-modified">2601     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2602     NativeCallFrameTracer tracer(vm, exec);</span>

2603     auto scope = DECLARE_THROW_SCOPE(vm);
2604 
2605     int32_t length = butterfly-&gt;publicLength();
2606     auto data = butterfly-&gt;contiguous().data();
2607     for (; index &lt; length; ++index) {
2608         JSValue value = data[index].get();
2609         if (!value || !value.isString())
2610             continue;
2611         auto* string = asString(value);
2612         if (string == searchElement)
2613             return index;
<span class="line-modified">2614         if (string-&gt;equal(exec, searchElement)) {</span>
2615             scope.assertNoException();
2616             return index;
2617         }
2618         RETURN_IF_EXCEPTION(scope, { });
2619     }
2620     return -1;
2621 }
2622 
<span class="line-modified">2623 int32_t JIT_OPERATION operationArrayIndexOfValueInt32OrContiguous(ExecState* exec, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)</span>
2624 {
<span class="line-modified">2625     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2626     NativeCallFrameTracer tracer(vm, exec);</span>

2627     auto scope = DECLARE_THROW_SCOPE(vm);
2628 
2629     JSValue searchElement = JSValue::decode(encodedValue);
2630 
2631     int32_t length = butterfly-&gt;publicLength();
2632     auto data = butterfly-&gt;contiguous().data();
2633     for (; index &lt; length; ++index) {
2634         JSValue value = data[index].get();
2635         if (!value)
2636             continue;
<span class="line-modified">2637         bool isEqual = JSValue::strictEqual(exec, searchElement, value);</span>
2638         RETURN_IF_EXCEPTION(scope, { });
2639         if (isEqual)
2640             return index;
2641     }
2642     return -1;
2643 }
2644 
<span class="line-modified">2645 int32_t JIT_OPERATION operationArrayIndexOfValueDouble(ExecState* exec, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)</span>
2646 {
<span class="line-modified">2647     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2648     NativeCallFrameTracer tracer(vm, exec);</span>

2649 
2650     JSValue searchElement = JSValue::decode(encodedValue);
2651 
2652     if (!searchElement.isNumber())
2653         return -1;
2654     double number = searchElement.asNumber();
2655 
2656     int32_t length = butterfly-&gt;publicLength();
2657     const double* data = butterfly-&gt;contiguousDouble().data();
2658     for (; index &lt; length; ++index) {
2659         // This comparison ignores NaN.
2660         if (data[index] == number)
2661             return index;
2662     }
2663     return -1;
2664 }
2665 
<span class="line-modified">2666 void JIT_OPERATION operationLoadVarargs(ExecState* exec, int32_t firstElementDest, EncodedJSValue encodedArguments, uint32_t offset, uint32_t length, uint32_t mandatoryMinimum)</span>
2667 {
<span class="line-modified">2668     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2669     NativeCallFrameTracer tracer(vm, exec);</span>


2670     JSValue arguments = JSValue::decode(encodedArguments);
2671 
<span class="line-modified">2672     loadVarargs(exec, VirtualRegister(firstElementDest), arguments, offset, length);</span>
2673 
<span class="line-modified">2674     for (uint32_t i = length; i &lt; mandatoryMinimum; ++i)</span>
<span class="line-modified">2675         exec-&gt;r(firstElementDest + i) = jsUndefined();</span>
2676 }
2677 
2678 double JIT_OPERATION operationFModOnInts(int32_t a, int32_t b)
2679 {
2680     return fmod(a, b);
2681 }
2682 
2683 #if USE(JSVALUE32_64)
2684 double JIT_OPERATION operationRandom(JSGlobalObject* globalObject)
2685 {
2686     return globalObject-&gt;weakRandomNumber();
2687 }
2688 #endif
2689 
<span class="line-modified">2690 JSCell* JIT_OPERATION operationStringFromCharCode(ExecState* exec, int32_t op1)</span>
2691 {
<span class="line-modified">2692     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2693     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">2694     return JSC::stringFromCharCode(exec, op1);</span>

2695 }
2696 
<span class="line-modified">2697 EncodedJSValue JIT_OPERATION operationStringFromCharCodeUntyped(ExecState* exec, EncodedJSValue encodedValue)</span>
2698 {
<span class="line-modified">2699     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2700     NativeCallFrameTracer tracer(vm, exec);</span>

2701     JSValue charValue = JSValue::decode(encodedValue);
<span class="line-modified">2702     int32_t chInt = charValue.toUInt32(exec);</span>
<span class="line-modified">2703     return JSValue::encode(JSC::stringFromCharCode(exec, chInt));</span>
2704 }
2705 
2706 int64_t JIT_OPERATION operationConvertBoxedDoubleToInt52(EncodedJSValue encodedValue)
2707 {
2708     JSValue value = JSValue::decode(encodedValue);
2709     if (!value.isDouble())
2710         return JSValue::notInt52;
2711     return tryConvertToInt52(value.asDouble());
2712 }
2713 
2714 int64_t JIT_OPERATION operationConvertDoubleToInt52(double value)
2715 {
2716     return tryConvertToInt52(value);
2717 }
2718 
<span class="line-modified">2719 char* JIT_OPERATION operationNewRawObject(ExecState* exec, Structure* structure, int32_t length, Butterfly* butterfly)</span>
2720 {
<span class="line-modified">2721     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2722     NativeCallFrameTracer tracer(vm, exec);</span>

2723 
2724     if (!butterfly
2725         &amp;&amp; (structure-&gt;outOfLineCapacity() || hasIndexedProperties(structure-&gt;indexingType()))) {
2726         IndexingHeader header;
2727         header.setVectorLength(length);
2728         header.setPublicLength(0);
2729 
2730         butterfly = Butterfly::create(
2731             vm, nullptr, 0, structure-&gt;outOfLineCapacity(),
2732             hasIndexedProperties(structure-&gt;indexingType()), header,
2733             length * sizeof(EncodedJSValue));
2734     }
2735 
<span class="line-modified">2736     JSObject* result = JSObject::createRawObject(exec, structure, butterfly);</span>
<span class="line-removed">2737     result-&gt;butterfly(); // Ensure that the butterfly is in to-space.</span>
2738     return bitwise_cast&lt;char*&gt;(result);
2739 }
2740 
<span class="line-modified">2741 JSCell* JIT_OPERATION operationNewObjectWithButterfly(ExecState* exec, Structure* structure, Butterfly* butterfly)</span>
2742 {
<span class="line-modified">2743     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2744     NativeCallFrameTracer tracer(vm, exec);</span>

2745 
2746     if (!butterfly) {
2747         butterfly = Butterfly::create(
2748             vm, nullptr, 0, structure-&gt;outOfLineCapacity(), false, IndexingHeader(), 0);
2749     }
2750 
<span class="line-modified">2751     JSObject* result = JSObject::createRawObject(exec, structure, butterfly);</span>
<span class="line-removed">2752     result-&gt;butterfly(); // Ensure that the butterfly is in to-space.</span>
2753     return result;
2754 }
2755 
<span class="line-modified">2756 JSCell* JIT_OPERATION operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength(ExecState* exec, Structure* structure, unsigned length, Butterfly* butterfly)</span>
2757 {
<span class="line-modified">2758     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2759     NativeCallFrameTracer tracer(vm, exec);</span>

2760 
2761     IndexingHeader header;
2762     header.setVectorLength(length);
2763     header.setPublicLength(0);
2764     if (butterfly)
2765         *butterfly-&gt;indexingHeader() = header;
2766     else {
2767         butterfly = Butterfly::create(
2768             vm, nullptr, 0, structure-&gt;outOfLineCapacity(), true, header,
2769             sizeof(EncodedJSValue) * length);
2770     }
2771 
2772     // Paradoxically this may allocate a JSArray. That&#39;s totally cool.
<span class="line-modified">2773     JSObject* result = JSObject::createRawObject(exec, structure, butterfly);</span>
<span class="line-removed">2774     result-&gt;butterfly(); // Ensure that the butterfly is in to-space.</span>
2775     return result;
2776 }
2777 
<span class="line-modified">2778 JSCell* JIT_OPERATION operationNewArrayWithSpreadSlow(ExecState* exec, void* buffer, uint32_t numItems)</span>
2779 {
<span class="line-modified">2780     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2781     NativeCallFrameTracer tracer(vm, exec);</span>

2782     auto scope = DECLARE_THROW_SCOPE(vm);
2783 
2784     EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
2785     Checked&lt;unsigned, RecordOverflow&gt; checkedLength = 0;
2786     for (unsigned i = 0; i &lt; numItems; i++) {
2787         JSValue value = JSValue::decode(values[i]);
<span class="line-modified">2788         if (JSFixedArray* array = jsDynamicCast&lt;JSFixedArray*&gt;(vm, value))</span>
<span class="line-modified">2789             checkedLength += array-&gt;size();</span>
2790         else
2791             ++checkedLength;
2792     }
2793 
2794     if (UNLIKELY(checkedLength.hasOverflowed())) {
<span class="line-modified">2795         throwOutOfMemoryError(exec, scope);</span>
2796         return nullptr;
2797     }
2798 
2799     unsigned length = checkedLength.unsafeGet();
2800     if (UNLIKELY(length &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)) {
<span class="line-modified">2801         throwOutOfMemoryError(exec, scope);</span>
2802         return nullptr;
2803     }
2804 
<span class="line-removed">2805     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
2806     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
2807 
2808     JSArray* result = JSArray::tryCreate(vm, structure, length);
2809     if (UNLIKELY(!result)) {
<span class="line-modified">2810         throwOutOfMemoryError(exec, scope);</span>
2811         return nullptr;
2812     }
2813     RETURN_IF_EXCEPTION(scope, nullptr);
2814 
2815     unsigned index = 0;
2816     for (unsigned i = 0; i &lt; numItems; i++) {
2817         JSValue value = JSValue::decode(values[i]);
<span class="line-modified">2818         if (JSFixedArray* array = jsDynamicCast&lt;JSFixedArray*&gt;(vm, value)) {</span>
2819             // We are spreading.
<span class="line-modified">2820             for (unsigned i = 0; i &lt; array-&gt;size(); i++) {</span>
<span class="line-modified">2821                 result-&gt;putDirectIndex(exec, index, array-&gt;get(i));</span>
2822                 RETURN_IF_EXCEPTION(scope, nullptr);
2823                 ++index;
2824             }
2825         } else {
2826             // We are not spreading.
<span class="line-modified">2827             result-&gt;putDirectIndex(exec, index, value);</span>
2828             RETURN_IF_EXCEPTION(scope, nullptr);
2829             ++index;
2830         }
2831     }
2832 
2833     return result;
2834 }
2835 
<span class="line-modified">2836 JSCell* operationCreateFixedArray(ExecState* exec, unsigned length)</span>
2837 {
<span class="line-modified">2838     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2839     NativeCallFrameTracer tracer(vm, exec);</span>

2840     auto scope = DECLARE_THROW_SCOPE(vm);
2841 
<span class="line-modified">2842     if (JSFixedArray* result = JSFixedArray::tryCreate(vm, vm.fixedArrayStructure.get(), length))</span>
2843         return result;
2844 
<span class="line-modified">2845     throwOutOfMemoryError(exec, scope);</span>
2846     return nullptr;
2847 }
2848 
<span class="line-modified">2849 JSCell* JIT_OPERATION operationSpreadGeneric(ExecState* exec, JSCell* iterable)</span>
2850 {
<span class="line-modified">2851     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2852     NativeCallFrameTracer tracer(vm, exec);</span>

2853 
2854     auto throwScope = DECLARE_THROW_SCOPE(vm);
2855 
2856     if (isJSArray(iterable)) {
2857         JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
2858         if (array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">2859             RELEASE_AND_RETURN(throwScope, JSFixedArray::createFromArray(exec, vm, array));</span>
2860     }
2861 
2862     // FIXME: we can probably make this path faster by having our caller JS code call directly into
2863     // the iteration protocol builtin: https://bugs.webkit.org/show_bug.cgi?id=164520
2864 
<span class="line-removed">2865     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
2866     JSArray* array;
2867     {
2868         JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
2869         CallData callData;
2870         CallType callType = JSC::getCallData(vm, iterationFunction, callData);
2871         ASSERT(callType != CallType::None);
2872 
2873         MarkedArgumentBuffer arguments;
2874         arguments.append(iterable);
2875         ASSERT(!arguments.hasOverflowed());
<span class="line-modified">2876         JSValue arrayResult = call(exec, iterationFunction, callType, callData, jsNull(), arguments);</span>
2877         RETURN_IF_EXCEPTION(throwScope, nullptr);
2878         array = jsCast&lt;JSArray*&gt;(arrayResult);
2879     }
2880 
<span class="line-modified">2881     RELEASE_AND_RETURN(throwScope, JSFixedArray::createFromArray(exec, vm, array));</span>
2882 }
2883 
<span class="line-modified">2884 JSCell* JIT_OPERATION operationSpreadFastArray(ExecState* exec, JSCell* cell)</span>
2885 {
<span class="line-modified">2886     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2887     NativeCallFrameTracer tracer(vm, exec);</span>

2888 
2889     ASSERT(isJSArray(cell));
2890     JSArray* array = jsCast&lt;JSArray*&gt;(cell);
2891     ASSERT(array-&gt;isIteratorProtocolFastAndNonObservable());
2892 
<span class="line-modified">2893     return JSFixedArray::createFromArray(exec, vm, array);</span>
2894 }
2895 
<span class="line-modified">2896 void JIT_OPERATION operationProcessTypeProfilerLogDFG(ExecState* exec)</span>
2897 {
<span class="line-modified">2898     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2899     NativeCallFrameTracer tracer(vm, exec);</span>

2900 
2901     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside DFG.&quot;_s);
2902 }
2903 
<span class="line-modified">2904 EncodedJSValue JIT_OPERATION operationResolveScopeForHoistingFuncDeclInEval(ExecState* exec, JSScope* scope, UniquedStringImpl* impl)</span>
2905 {
<span class="line-modified">2906     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2907     NativeCallFrameTracer tracer(vm, exec);</span>

2908 
<span class="line-modified">2909     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, Identifier::fromUid(vm, impl));</span>
2910     return JSValue::encode(resolvedScope);
2911 }
2912 
<span class="line-modified">2913 JSCell* JIT_OPERATION operationResolveScope(ExecState* exec, JSScope* scope, UniquedStringImpl* impl)</span>
2914 {
<span class="line-modified">2915     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2916     NativeCallFrameTracer tracer(vm, exec);</span>

2917 
<span class="line-modified">2918     JSObject* resolvedScope = JSScope::resolve(exec, scope, Identifier::fromUid(vm, impl));</span>
2919     return resolvedScope;
2920 }
2921 
<span class="line-modified">2922 EncodedJSValue JIT_OPERATION operationGetDynamicVar(ExecState* exec, JSObject* scope, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
2923 {
<span class="line-modified">2924     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2925     NativeCallFrameTracer tracer(vm, exec);</span>

2926     auto throwScope = DECLARE_THROW_SCOPE(vm);
2927 
2928     Identifier ident = Identifier::fromUid(vm, impl);
<span class="line-modified">2929     RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
2930         if (!found) {
2931             GetPutInfo getPutInfo(getPutInfoBits);
2932             if (getPutInfo.resolveMode() == ThrowIfNotFound)
<span class="line-modified">2933                 throwException(exec, throwScope, createUndefinedVariableError(exec, ident));</span>
2934             return jsUndefined();
2935         }
2936 
2937         if (scope-&gt;isGlobalLexicalEnvironment()) {
2938             // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
<span class="line-modified">2939             JSValue result = slot.getValue(exec, ident);</span>
2940             if (result == jsTDZValue()) {
<span class="line-modified">2941                 throwException(exec, throwScope, createTDZError(exec));</span>
2942                 return jsUndefined();
2943             }
2944             return result;
2945         }
2946 
<span class="line-modified">2947         return slot.getValue(exec, ident);</span>
2948     })));
2949 }
2950 
<span class="line-modified">2951 ALWAYS_INLINE static void putDynamicVar(ExecState* exec, VM&amp; vm, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits, bool isStrictMode)</span>
2952 {
2953     auto throwScope = DECLARE_THROW_SCOPE(vm);
2954 
2955     const Identifier&amp; ident = Identifier::fromUid(vm, impl);
2956     GetPutInfo getPutInfo(getPutInfoBits);
<span class="line-modified">2957     bool hasProperty = scope-&gt;hasProperty(exec, ident);</span>
2958     RETURN_IF_EXCEPTION(throwScope, void());
2959     if (hasProperty
2960         &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
2961         &amp;&amp; !isInitialization(getPutInfo.initializationMode())) {
2962         // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
2963         PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified">2964         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, exec, ident, slot);</span>
<span class="line-modified">2965         if (slot.getValue(exec, ident) == jsTDZValue()) {</span>
<span class="line-modified">2966             throwException(exec, throwScope, createTDZError(exec));</span>
2967             return;
2968         }
2969     }
2970 
2971     if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
<span class="line-modified">2972         throwException(exec, throwScope, createUndefinedVariableError(exec, ident));</span>
2973         return;
2974     }
2975 
2976     PutPropertySlot slot(scope, isStrictMode, PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));
2977     throwScope.release();
<span class="line-modified">2978     scope-&gt;methodTable(vm)-&gt;put(scope, exec, ident, JSValue::decode(value), slot);</span>
2979 }
2980 
<span class="line-modified">2981 void JIT_OPERATION operationPutDynamicVarStrict(ExecState* exec, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
2982 {
<span class="line-modified">2983     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2984     NativeCallFrameTracer tracer(vm, exec);</span>

2985     constexpr bool isStrictMode = true;
<span class="line-modified">2986     return putDynamicVar(exec, vm, scope, value, impl, getPutInfoBits, isStrictMode);</span>
2987 }
2988 
<span class="line-modified">2989 void JIT_OPERATION operationPutDynamicVarNonStrict(ExecState* exec, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
2990 {
<span class="line-modified">2991     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2992     NativeCallFrameTracer tracer(vm, exec);</span>

2993     constexpr bool isStrictMode = false;
<span class="line-modified">2994     return putDynamicVar(exec, vm, scope, value, impl, getPutInfoBits, isStrictMode);</span>
2995 }
2996 
<span class="line-modified">2997 int32_t JIT_OPERATION operationMapHash(ExecState* exec, EncodedJSValue input)</span>
2998 {
<span class="line-modified">2999     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3000     NativeCallFrameTracer tracer(vm, exec);</span>

3001 
<span class="line-modified">3002     return jsMapHash(exec, vm, JSValue::decode(input));</span>
3003 }
3004 
<span class="line-modified">3005 JSCell* JIT_OPERATION operationJSMapFindBucket(ExecState* exec, JSCell* map, EncodedJSValue key, int32_t hash)</span>
3006 {
<span class="line-modified">3007     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3008     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">3009     JSMap::BucketType** bucket = jsCast&lt;JSMap*&gt;(map)-&gt;findBucket(exec, JSValue::decode(key), hash);</span>

3010     if (!bucket)
3011         return vm.sentinelMapBucket();
3012     return *bucket;
3013 }
3014 
<span class="line-modified">3015 JSCell* JIT_OPERATION operationJSSetFindBucket(ExecState* exec, JSCell* map, EncodedJSValue key, int32_t hash)</span>
3016 {
<span class="line-modified">3017     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3018     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">3019     JSSet::BucketType** bucket = jsCast&lt;JSSet*&gt;(map)-&gt;findBucket(exec, JSValue::decode(key), hash);</span>

3020     if (!bucket)
3021         return vm.sentinelSetBucket();
3022     return *bucket;
3023 }
3024 
<span class="line-modified">3025 JSCell* JIT_OPERATION operationSetAdd(ExecState* exec, JSCell* set, EncodedJSValue key, int32_t hash)</span>
3026 {
<span class="line-modified">3027     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3028     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">3029     auto* bucket = jsCast&lt;JSSet*&gt;(set)-&gt;addNormalized(exec, JSValue::decode(key), JSValue(), hash);</span>

3030     if (!bucket)
3031         return vm.sentinelSetBucket();
3032     return bucket;
3033 }
3034 
<span class="line-modified">3035 JSCell* JIT_OPERATION operationMapSet(ExecState* exec, JSCell* map, EncodedJSValue key, EncodedJSValue value, int32_t hash)</span>
3036 {
<span class="line-modified">3037     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3038     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">3039     auto* bucket = jsCast&lt;JSMap*&gt;(map)-&gt;addNormalized(exec, JSValue::decode(key), JSValue::decode(value), hash);</span>

3040     if (!bucket)
3041         return vm.sentinelMapBucket();
3042     return bucket;
3043 }
3044 
<span class="line-modified">3045 void JIT_OPERATION operationWeakSetAdd(ExecState* exec, JSCell* set, JSCell* key, int32_t hash)</span>
3046 {
<span class="line-modified">3047     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3048     NativeCallFrameTracer tracer(vm, exec);</span>

3049     jsCast&lt;JSWeakSet*&gt;(set)-&gt;add(vm, asObject(key), JSValue(), hash);
3050 }
3051 
<span class="line-modified">3052 void JIT_OPERATION operationWeakMapSet(ExecState* exec, JSCell* map, JSCell* key, EncodedJSValue value, int32_t hash)</span>
3053 {
<span class="line-modified">3054     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3055     NativeCallFrameTracer tracer(vm, exec);</span>

3056     jsCast&lt;JSWeakMap*&gt;(map)-&gt;add(vm, asObject(key), JSValue::decode(value), hash);
3057 }
3058 
<span class="line-modified">3059 EncodedJSValue JIT_OPERATION operationGetPrototypeOfObject(ExecState* exec, JSObject* thisObject)</span>
3060 {
<span class="line-modified">3061     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3062     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">3063     return JSValue::encode(thisObject-&gt;getPrototype(vm, exec));</span>

3064 }
3065 
<span class="line-modified">3066 EncodedJSValue JIT_OPERATION operationGetPrototypeOf(ExecState* exec, EncodedJSValue encodedValue)</span>
3067 {
<span class="line-modified">3068     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3069     NativeCallFrameTracer tracer(vm, exec);</span>

3070     auto scope = DECLARE_THROW_SCOPE(vm);
3071 
<span class="line-modified">3072     JSValue thisValue = JSValue::decode(encodedValue).toThis(exec, StrictMode);</span>
3073     if (thisValue.isUndefinedOrNull())
<span class="line-modified">3074         return throwVMError(exec, scope, createNotAnObjectError(exec, thisValue));</span>
3075 
3076     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
3077     if (!thisObject) {
<span class="line-modified">3078         JSObject* prototype = thisValue.synthesizePrototype(exec);</span>
3079         EXCEPTION_ASSERT(!!scope.exception() == !prototype);
3080         if (UNLIKELY(!prototype))
3081             return JSValue::encode(JSValue());
3082         return JSValue::encode(prototype);
3083     }
3084 
<span class="line-modified">3085     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, exec)));</span>




































































































































3086 }
3087 
<span class="line-modified">3088 void JIT_OPERATION operationThrowDFG(ExecState* exec, EncodedJSValue valueToThrow)</span>
3089 {
<span class="line-modified">3090     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3091     NativeCallFrameTracer tracer(vm, exec);</span>





























































3092     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">3093     scope.throwException(exec, JSValue::decode(valueToThrow));</span>
3094 }
3095 
<span class="line-modified">3096 void JIT_OPERATION operationThrowStaticError(ExecState* exec, JSString* message, uint32_t errorType)</span>
3097 {
<span class="line-modified">3098     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3099     NativeCallFrameTracer tracer(vm, exec);</span>

3100     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">3101     String errorMessage = message-&gt;value(exec);</span>
<span class="line-modified">3102     scope.throwException(exec, createError(exec, static_cast&lt;ErrorType&gt;(errorType), errorMessage));</span>
3103 }
3104 
<span class="line-modified">3105 extern &quot;C&quot; void JIT_OPERATION triggerReoptimizationNow(CodeBlock* codeBlock, CodeBlock* optimizedCodeBlock, OSRExitBase* exit)</span>




















































3106 {
3107     // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t
3108     // really be profitable.
3109     DeferGCForAWhile deferGC(codeBlock-&gt;vm().heap);
3110 
3111     sanitizeStackForVM(codeBlock-&gt;vm());
3112 
<span class="line-modified">3113     if (Options::verboseOSR())</span>
<span class="line-removed">3114         dataLog(*codeBlock, &quot;: Entered reoptimize\n&quot;);</span>
3115     // We must be called with the baseline code block.
3116     ASSERT(JITCode::isBaselineCode(codeBlock-&gt;jitType()));
3117 
3118     // If I am my own replacement, then reoptimization has already been triggered.
3119     // This can happen in recursive functions.
3120     //
3121     // Note that even if optimizedCodeBlock is an FTLForOSREntry style CodeBlock, this condition is a
3122     // sure bet that we don&#39;t have anything else left to do.
3123     CodeBlock* replacement = codeBlock-&gt;replacement();
3124     if (!replacement || replacement == codeBlock) {
<span class="line-modified">3125         if (Options::verboseOSR())</span>
<span class="line-removed">3126             dataLog(*codeBlock, &quot;: Not reoptimizing because we&#39;ve already been jettisoned.\n&quot;);</span>
3127         return;
3128     }
3129 
3130     // Otherwise, the replacement must be optimized code. Use this as an opportunity
3131     // to check our logic.
3132     ASSERT(codeBlock-&gt;hasOptimizedReplacement());
3133     ASSERT(JITCode::isOptimizingJIT(optimizedCodeBlock-&gt;jitType()));
3134 
3135     bool didTryToEnterIntoInlinedLoops = false;
3136     for (InlineCallFrame* inlineCallFrame = exit-&gt;m_codeOrigin.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame()) {
3137         if (inlineCallFrame-&gt;baselineCodeBlock-&gt;ownerExecutable()-&gt;didTryToEnterInLoop()) {
3138             didTryToEnterIntoInlinedLoops = true;
3139             break;
3140         }
3141     }
3142 
3143     // In order to trigger reoptimization, one of two things must have happened:
3144     // 1) We exited more than some number of times.
3145     // 2) We exited and got stuck in a loop, and now we&#39;re exiting again.
3146     bool didExitABunch = optimizedCodeBlock-&gt;shouldReoptimizeNow();
3147     bool didGetStuckInLoop =
3148         (codeBlock-&gt;checkIfOptimizationThresholdReached() || didTryToEnterIntoInlinedLoops)
3149         &amp;&amp; optimizedCodeBlock-&gt;shouldReoptimizeFromLoopNow();
3150 
3151     if (!didExitABunch &amp;&amp; !didGetStuckInLoop) {
<span class="line-modified">3152         if (Options::verboseOSR())</span>
<span class="line-removed">3153             dataLog(*codeBlock, &quot;: Not reoptimizing &quot;, *optimizedCodeBlock, &quot; because it either didn&#39;t exit enough or didn&#39;t loop enough after exit.\n&quot;);</span>
3154         codeBlock-&gt;optimizeAfterLongWarmUp();
3155         return;
3156     }
3157 
3158     optimizedCodeBlock-&gt;jettison(Profiler::JettisonDueToOSRExit, CountReoptimization);
3159 }
3160 





3161 #if ENABLE(FTL_JIT)
3162 static bool shouldTriggerFTLCompile(CodeBlock* codeBlock, JITCode* jitCode)
3163 {
3164     if (codeBlock-&gt;baselineVersion()-&gt;m_didFailFTLCompilation) {
3165         CODEBLOCK_LOG_EVENT(codeBlock, &quot;abortFTLCompile&quot;, ());
<span class="line-modified">3166         if (Options::verboseOSR())</span>
<span class="line-removed">3167             dataLog(&quot;Deferring FTL-optimization of &quot;, *codeBlock, &quot; indefinitely because there was an FTL failure.\n&quot;);</span>
3168         jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3169         return false;
3170     }
3171 
3172     if (!codeBlock-&gt;hasOptimizedReplacement()
3173         &amp;&amp; !jitCode-&gt;checkIfOptimizationThresholdReached(codeBlock)) {
3174         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;counter = &quot;, jitCode-&gt;tierUpCounter));
<span class="line-modified">3175         if (Options::verboseOSR())</span>
<span class="line-removed">3176             dataLog(&quot;Choosing not to FTL-optimize &quot;, *codeBlock, &quot; yet.\n&quot;);</span>
3177         return false;
3178     }
3179     return true;
3180 }
3181 
3182 static void triggerFTLReplacementCompile(VM&amp; vm, CodeBlock* codeBlock, JITCode* jitCode)
3183 {
3184     if (codeBlock-&gt;codeType() == GlobalCode) {
3185         // Global code runs once, so we don&#39;t want to do anything. We don&#39;t want to defer indefinitely,
3186         // since this may have been spuriously called from tier-up initiated in a loop, and that loop may
3187         // later want to run faster code. Deferring for warm-up seems safest.
3188         jitCode-&gt;optimizeAfterWarmUp(codeBlock);
3189         return;
3190     }
3191 
3192     Worklist::State worklistState;
3193     if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
3194         worklistState = worklist-&gt;completeAllReadyPlansForVM(
3195             vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLMode));
3196     } else
</pre>
<hr />
<pre>
3198 
3199     if (worklistState == Worklist::Compiling) {
3200         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;still compiling&quot;));
3201         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3202             codeBlock, CompilationDeferred);
3203         return;
3204     }
3205 
3206     if (codeBlock-&gt;hasOptimizedReplacement()) {
3207         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;has replacement&quot;));
3208         // That&#39;s great, we&#39;ve compiled the code - next time we call this function,
3209         // we&#39;ll enter that replacement.
3210         jitCode-&gt;optimizeSoon(codeBlock);
3211         return;
3212     }
3213 
3214     if (worklistState == Worklist::Compiled) {
3215         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;compiled and failed&quot;));
3216         // This means that we finished compiling, but failed somehow; in that case the
3217         // thresholds will be set appropriately.
<span class="line-modified">3218         if (Options::verboseOSR())</span>
<span class="line-removed">3219             dataLog(&quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.\n&quot;);</span>
3220         return;
3221     }
3222 
3223     CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLReplacement&quot;, ());
3224     // We need to compile the code.
3225     compile(
<span class="line-modified">3226         vm, codeBlock-&gt;newReplacement(), codeBlock, FTLMode, UINT_MAX,</span>
3227         Operands&lt;Optional&lt;JSValue&gt;&gt;(), ToFTLDeferredCompilationCallback::create());
3228 
3229     // If we reached here, the counter has not be reset. Do that now.
3230     jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3231         codeBlock, CompilationDeferred);
3232 }
3233 
<span class="line-modified">3234 void JIT_OPERATION triggerTierUpNow(ExecState* exec)</span>
3235 {
<span class="line-modified">3236     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3237     NativeCallFrameTracer tracer(vm, exec);</span>

3238     DeferGCForAWhile deferGC(vm.heap);
<span class="line-modified">3239     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
3240 
3241     sanitizeStackForVM(vm);
3242 
3243     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
3244         dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
3245         RELEASE_ASSERT_NOT_REACHED();
3246     }
3247 
3248     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3249 
<span class="line-modified">3250     if (Options::verboseOSR()) {</span>
<span class="line-modified">3251         dataLog(</span>
<span class="line-removed">3252             *codeBlock, &quot;: Entered triggerTierUpNow with executeCounter = &quot;,</span>
<span class="line-removed">3253             jitCode-&gt;tierUpCounter, &quot;\n&quot;);</span>
<span class="line-removed">3254     }</span>
3255 
3256     if (shouldTriggerFTLCompile(codeBlock, jitCode))
3257         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3258 
3259     if (codeBlock-&gt;hasOptimizedReplacement()) {
3260         if (jitCode-&gt;tierUpEntryTriggers.isEmpty()) {
3261             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;replacement in place, delaying indefinitely&quot;));
3262             // There is nothing more we can do, the only way this will be entered
3263             // is through the function entry point.
3264             jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3265             return;
3266         }
3267         if (jitCode-&gt;osrEntryBlock() &amp;&amp; jitCode-&gt;tierUpEntryTriggers.size() == 1) {
3268             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;trigger in place, delaying indefinitely&quot;));
3269             // There is only one outer loop and its trigger must have been set
3270             // when the plan completed.
3271             // Exiting the inner loop is useless, we can ignore the counter and leave
3272             // the trigger do its job.
3273             jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3274             return;
3275         }
3276     }
3277 }
3278 
<span class="line-modified">3279 static char* tierUpCommon(ExecState* exec, unsigned originBytecodeIndex, bool canOSREnterHere)</span>
3280 {
<span class="line-modified">3281     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">3282     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
3283 
3284     // Resolve any pending plan for OSR Enter on this function.
3285     Worklist::State worklistState;
3286     if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
3287         worklistState = worklist-&gt;completeAllReadyPlansForVM(
3288             vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLForOSREntryMode));
3289     } else
3290         worklistState = Worklist::NotKnown;
3291 
3292     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3293 
3294     bool triggeredSlowPathToStartCompilation = false;
3295     auto tierUpEntryTriggers = jitCode-&gt;tierUpEntryTriggers.find(originBytecodeIndex);
3296     if (tierUpEntryTriggers != jitCode-&gt;tierUpEntryTriggers.end()) {
3297         switch (tierUpEntryTriggers-&gt;value) {
3298         case JITCode::TriggerReason::DontTrigger:
3299             // The trigger isn&#39;t set, we entered because the counter reached its
3300             // threshold.
3301             break;
3302 
</pre>
<hr />
<pre>
3310             // entry for the current bytecode location. Unset this trigger so we
3311             // don&#39;t continually enter.
3312             tierUpEntryTriggers-&gt;value = JITCode::TriggerReason::DontTrigger;
3313             triggeredSlowPathToStartCompilation = true;
3314             break;
3315         }
3316     }
3317 
3318     if (worklistState == Worklist::Compiling) {
3319         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;still compiling&quot;));
3320         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
3321         return nullptr;
3322     }
3323 
3324     // If we can OSR Enter, do it right away.
3325     if (canOSREnterHere) {
3326         auto iter = jitCode-&gt;bytecodeIndexToStreamIndex.find(originBytecodeIndex);
3327         if (iter != jitCode-&gt;bytecodeIndexToStreamIndex.end()) {
3328             unsigned streamIndex = iter-&gt;value;
3329             if (CodeBlock* entryBlock = jitCode-&gt;osrEntryBlock()) {
<span class="line-modified">3330                 if (Options::verboseOSR())</span>
<span class="line-modified">3331                     dataLog(&quot;OSR entry: From &quot;, RawPointer(jitCode), &quot; got entry block &quot;, RawPointer(entryBlock), &quot;\n&quot;);</span>
<span class="line-modified">3332                 if (void* address = FTL::prepareOSREntry(exec, codeBlock, entryBlock, originBytecodeIndex, streamIndex)) {</span>
<span class="line-modified">3333                     CODEBLOCK_LOG_EVENT(entryBlock, &quot;osrEntry&quot;, (&quot;at bc#&quot;, originBytecodeIndex));</span>
<span class="line-removed">3334                     return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(exec));</span>
3335                 }
3336             }
3337         }
3338     }
3339 
3340     if (worklistState == Worklist::Compiled) {
3341         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;compiled and failed&quot;));
3342         // This means that compilation failed and we already set the thresholds.
<span class="line-modified">3343         if (Options::verboseOSR())</span>
<span class="line-removed">3344             dataLog(&quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.\n&quot;);</span>
3345         return nullptr;
3346     }
3347 
3348     // - If we don&#39;t have an FTL code block, then try to compile one.
3349     // - If we do have an FTL code block, then try to enter for a while.
3350     // - If we couldn&#39;t enter for a while, then trigger OSR entry.
3351 
3352     if (!shouldTriggerFTLCompile(codeBlock, jitCode) &amp;&amp; !triggeredSlowPathToStartCompilation)
3353         return nullptr;
3354 
3355     if (!jitCode-&gt;neverExecutedEntry &amp;&amp; !triggeredSlowPathToStartCompilation) {
3356         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3357 
3358         if (!codeBlock-&gt;hasOptimizedReplacement())
3359             return nullptr;
3360 
3361         if (jitCode-&gt;osrEntryRetry &lt; Options::ftlOSREntryRetryThreshold()) {
3362             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;avoiding OSR entry compile&quot;));
3363             jitCode-&gt;osrEntryRetry++;
3364             return nullptr;
</pre>
<hr />
<pre>
3398 
3399         // An inner loop didn&#39;t specifically ask for us to kick off a compilation. This means the counter
3400         // crossed its threshold. We either fall through and kick off a compile for originBytecodeIndex,
3401         // or we flag an outer loop to immediately try to compile itself. If there are outer loops,
3402         // we first try to make them compile themselves. But we will eventually fall back to compiling
3403         // a progressively inner loop if it takes too long for control to reach an outer loop.
3404 
3405         auto tryTriggerOuterLoopToCompile = [&amp;] {
3406             auto tierUpHierarchyEntry = jitCode-&gt;tierUpInLoopHierarchy.find(originBytecodeIndex);
3407             if (tierUpHierarchyEntry == jitCode-&gt;tierUpInLoopHierarchy.end())
3408                 return false;
3409 
3410             // This vector is ordered from innermost to outermost loop. Every bytecode entry in this vector is
3411             // allowed to do OSR entry. We start with the outermost loop and make our way inwards (hence why we
3412             // iterate the vector in reverse). Our policy is that we will trigger an outer loop to compile
3413             // immediately when program control reaches it. If program control is taking too long to reach that
3414             // outer loop, we progressively move inwards, meaning, we&#39;ll eventually trigger some loop that is
3415             // executing to compile. We start with trying to compile outer loops since we believe outer loop
3416             // compilations reveal the best opportunities for optimizing code.
3417             for (auto iter = tierUpHierarchyEntry-&gt;value.rbegin(), end = tierUpHierarchyEntry-&gt;value.rend(); iter != end; ++iter) {
<span class="line-modified">3418                 unsigned osrEntryCandidate = *iter;</span>
3419 
3420                 if (jitCode-&gt;tierUpEntryTriggers.get(osrEntryCandidate) == JITCode::TriggerReason::StartCompilation) {
3421                     // This means that we already asked this loop to compile. If we&#39;ve reached here, it
3422                     // means program control has not yet reached that loop. So it&#39;s taking too long to compile.
3423                     // So we move on to asking the inner loop of this loop to compile itself.
3424                     continue;
3425                 }
3426 
3427                 // This is where we ask the outer to loop to immediately compile itself if program
3428                 // control reaches it.
<span class="line-modified">3429                 if (Options::verboseOSR())</span>
<span class="line-removed">3430                     dataLog(&quot;Inner-loop bc#&quot;, originBytecodeIndex, &quot; in &quot;, *codeBlock, &quot; setting parent loop bc#&quot;, osrEntryCandidate, &quot;&#39;s trigger and backing off.\n&quot;);</span>
3431                 jitCode-&gt;tierUpEntryTriggers.set(osrEntryCandidate, JITCode::TriggerReason::StartCompilation);
3432                 return true;
3433             }
3434 
3435             return false;
3436         };
3437 
3438         if (tryTriggerOuterLoopToCompile()) {
3439             jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
3440             return nullptr;
3441         }
3442     }
3443 
3444     if (!canOSREnterHere) {
3445         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
3446         return nullptr;
3447     }
3448 
3449     // We aren&#39;t compiling and haven&#39;t compiled anything for OSR entry. So, try to compile
3450     // something.
3451 
3452     auto triggerIterator = jitCode-&gt;tierUpEntryTriggers.find(originBytecodeIndex);
3453     if (triggerIterator == jitCode-&gt;tierUpEntryTriggers.end()) {
3454         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
3455         return nullptr;
3456     }
3457 
3458     JITCode::TriggerReason* triggerAddress = &amp;(triggerIterator-&gt;value);
3459 
3460     Operands&lt;Optional&lt;JSValue&gt;&gt; mustHandleValues;
3461     unsigned streamIndex = jitCode-&gt;bytecodeIndexToStreamIndex.get(originBytecodeIndex);
<span class="line-modified">3462     jitCode-&gt;reconstruct(</span>
<span class="line-removed">3463         exec, codeBlock, CodeOrigin(originBytecodeIndex), streamIndex, mustHandleValues);</span>
3464     CodeBlock* replacementCodeBlock = codeBlock-&gt;newReplacement();
3465 
3466     CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLOSR&quot;, ());
3467     CompilationResult forEntryResult = compile(
3468         vm, replacementCodeBlock, codeBlock, FTLForOSREntryMode, originBytecodeIndex,
3469         mustHandleValues, ToFTLForOSREntryDeferredCompilationCallback::create(triggerAddress));
3470 
3471     if (jitCode-&gt;neverExecutedEntry)
3472         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3473 
3474     if (forEntryResult != CompilationSuccessful) {
3475         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR ecompilation not successful&quot;));
3476         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3477             codeBlock, CompilationDeferred);
3478         return nullptr;
3479     }
3480 
<span class="line-modified">3481     CODEBLOCK_LOG_EVENT(jitCode-&gt;osrEntryBlock(), &quot;osrEntry&quot;, (&quot;at bc#&quot;, originBytecodeIndex));</span>
3482     // It&#39;s possible that the for-entry compile already succeeded. In that case OSR
3483     // entry will succeed unless we ran out of stack. It&#39;s not clear what we should do.
3484     // We signal to try again after a while if that happens.
<span class="line-modified">3485     if (Options::verboseOSR())</span>
<span class="line-removed">3486         dataLog(&quot;Immediate OSR entry: From &quot;, RawPointer(jitCode), &quot; got entry block &quot;, RawPointer(jitCode-&gt;osrEntryBlock()), &quot;\n&quot;);</span>
3487 
<span class="line-modified">3488     void* address = FTL::prepareOSREntry(</span>
<span class="line-removed">3489         exec, codeBlock, jitCode-&gt;osrEntryBlock(), originBytecodeIndex, streamIndex);</span>
3490     if (!address)
3491         return nullptr;
<span class="line-modified">3492     return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(exec));</span>
3493 }
3494 
<span class="line-modified">3495 void JIT_OPERATION triggerTierUpNowInLoop(ExecState* exec, unsigned bytecodeIndex)</span>
3496 {
<span class="line-modified">3497     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3498     NativeCallFrameTracer tracer(vm, exec);</span>

3499     DeferGCForAWhile deferGC(vm.heap);
<span class="line-modified">3500     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>

3501 
3502     sanitizeStackForVM(vm);
3503 
3504     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
<span class="line-modified">3505         dataLog(&quot;Unexpected code block in DFG-&gt;FTL trigger tier up now in loop: &quot;, *codeBlock, &quot;\n&quot;);</span>
3506         RELEASE_ASSERT_NOT_REACHED();
3507     }
3508 
3509     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3510 
<span class="line-modified">3511     if (Options::verboseOSR()) {</span>
<span class="line-removed">3512         dataLog(</span>
<span class="line-removed">3513             *codeBlock, &quot;: Entered triggerTierUpNowInLoop with executeCounter = &quot;,</span>
<span class="line-removed">3514             jitCode-&gt;tierUpCounter, &quot;\n&quot;);</span>
<span class="line-removed">3515     }</span>
3516 
3517     if (jitCode-&gt;tierUpInLoopHierarchy.contains(bytecodeIndex))
<span class="line-modified">3518         tierUpCommon(exec, bytecodeIndex, false);</span>
3519     else if (shouldTriggerFTLCompile(codeBlock, jitCode))
3520         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3521 
3522     // Since we cannot OSR Enter here, the default &quot;optimizeSoon()&quot; is not useful.
3523     if (codeBlock-&gt;hasOptimizedReplacement()) {
3524         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR in loop failed, deferring&quot;));
3525         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
3526     }
3527 }
3528 
<span class="line-modified">3529 char* JIT_OPERATION triggerOSREntryNow(ExecState* exec, unsigned bytecodeIndex)</span>
3530 {
<span class="line-modified">3531     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">3532     NativeCallFrameTracer tracer(vm, exec);</span>

3533     DeferGCForAWhile deferGC(vm.heap);
<span class="line-modified">3534     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>

3535 
3536     sanitizeStackForVM(vm);
3537 
3538     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
3539         dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
3540         RELEASE_ASSERT_NOT_REACHED();
3541     }
3542 
3543     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3544 
<span class="line-modified">3545     if (Options::verboseOSR()) {</span>
<span class="line-removed">3546         dataLog(</span>
<span class="line-removed">3547             *codeBlock, &quot;: Entered triggerOSREntryNow with executeCounter = &quot;,</span>
<span class="line-removed">3548             jitCode-&gt;tierUpCounter, &quot;\n&quot;);</span>
<span class="line-removed">3549     }</span>
3550 
<span class="line-modified">3551     return tierUpCommon(exec, bytecodeIndex, true);</span>
3552 }
3553 
3554 #endif // ENABLE(FTL_JIT)
3555 
3556 } // extern &quot;C&quot;
3557 } } // namespace JSC::DFG
3558 


3559 #endif // ENABLE(DFG_JIT)
3560 
3561 #endif // ENABLE(JIT)
</pre>
</td>
<td>
<hr />
<pre>
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGOperations.h&quot;
  28 
  29 #include &quot;ArrayConstructor.h&quot;
  30 #include &quot;ButterflyInlines.h&quot;
  31 #include &quot;ClonedArguments.h&quot;
  32 #include &quot;CodeBlock.h&quot;
  33 #include &quot;CommonSlowPaths.h&quot;
  34 #include &quot;DFGDriver.h&quot;
  35 #include &quot;DFGJITCode.h&quot;
  36 #include &quot;DFGOSRExit.h&quot;
  37 #include &quot;DFGThunks.h&quot;
  38 #include &quot;DFGToFTLDeferredCompilationCallback.h&quot;
  39 #include &quot;DFGToFTLForOSREntryDeferredCompilationCallback.h&quot;
  40 #include &quot;DFGWorklist.h&quot;
<span class="line-added">  41 #include &quot;DateInstance.h&quot;</span>
  42 #include &quot;DefinePropertyAttributes.h&quot;
  43 #include &quot;DirectArguments.h&quot;
<span class="line-added">  44 #include &quot;EvalCodeBlock.h&quot;</span>
  45 #include &quot;FTLForOSREntryJITCode.h&quot;
  46 #include &quot;FTLOSREntry.h&quot;
  47 #include &quot;FrameTracers.h&quot;
  48 #include &quot;HasOwnPropertyCache.h&quot;
  49 #include &quot;HostCallReturnValue.h&quot;
  50 #include &quot;Interpreter.h&quot;
  51 #include &quot;JIT.h&quot;
  52 #include &quot;JITExceptions.h&quot;
  53 #include &quot;JSArrayInlines.h&quot;
<span class="line-added">  54 #include &quot;JSArrayIterator.h&quot;</span>
<span class="line-added">  55 #include &quot;JSAsyncGenerator.h&quot;</span>
  56 #include &quot;JSBigInt.h&quot;
  57 #include &quot;JSCInlines.h&quot;

  58 #include &quot;JSGenericTypedArrayViewConstructorInlines.h&quot;
  59 #include &quot;JSGlobalObjectFunctions.h&quot;
  60 #include &quot;JSImmutableButterfly.h&quot;
<span class="line-added">  61 #include &quot;JSInternalPromise.h&quot;</span>
<span class="line-added">  62 #include &quot;JSInternalPromiseConstructor.h&quot;</span>
  63 #include &quot;JSLexicalEnvironment.h&quot;
  64 #include &quot;JSMap.h&quot;
<span class="line-added">  65 #include &quot;JSPromiseConstructor.h&quot;</span>
  66 #include &quot;JSPropertyNameEnumerator.h&quot;
  67 #include &quot;JSSet.h&quot;
  68 #include &quot;JSWeakMap.h&quot;
  69 #include &quot;JSWeakSet.h&quot;
<span class="line-added">  70 #include &quot;ModuleProgramCodeBlock.h&quot;</span>
  71 #include &quot;NumberConstructor.h&quot;
  72 #include &quot;ObjectConstructor.h&quot;
  73 #include &quot;Operations.h&quot;
  74 #include &quot;ParseInt.h&quot;
<span class="line-added">  75 #include &quot;ProgramCodeBlock.h&quot;</span>
  76 #include &quot;RegExpGlobalDataInlines.h&quot;
  77 #include &quot;RegExpMatchesArray.h&quot;
  78 #include &quot;RegExpObjectInlines.h&quot;
  79 #include &quot;Repatch.h&quot;
  80 #include &quot;ScopedArguments.h&quot;
  81 #include &quot;StringConstructor.h&quot;
  82 #include &quot;StringPrototypeInlines.h&quot;
  83 #include &quot;SuperSampler.h&quot;
  84 #include &quot;Symbol.h&quot;
  85 #include &quot;TypeProfilerLog.h&quot;
  86 #include &quot;TypedArrayInlines.h&quot;
  87 #include &quot;VMInlines.h&quot;
  88 #include &lt;wtf/InlineASM.h&gt;
  89 #include &lt;wtf/Variant.h&gt;
  90 
  91 #if ENABLE(JIT)
  92 #if ENABLE(DFG_JIT)
  93 
<span class="line-added">  94 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added">  95 </span>
  96 namespace JSC { namespace DFG {
  97 
  98 template&lt;bool strict, bool direct&gt;
<span class="line-modified">  99 static inline void putByVal(JSGlobalObject* globalObject, VM&amp; vm, JSValue baseValue, uint32_t index, JSValue value)</span>
 100 {
 101     ASSERT(isIndex(index));
 102     if (direct) {
 103         RELEASE_ASSERT(baseValue.isObject());
<span class="line-modified"> 104         asObject(baseValue)-&gt;putDirectIndex(globalObject, index, value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
 105         return;
 106     }
 107     if (baseValue.isObject()) {
 108         JSObject* object = asObject(baseValue);
 109         if (object-&gt;canSetIndexQuickly(index, value)) {
 110             object-&gt;setIndexQuickly(vm, index, value);
 111             return;
 112         }
 113 
<span class="line-modified"> 114         object-&gt;methodTable(vm)-&gt;putByIndex(object, globalObject, index, value, strict);</span>
 115         return;
 116     }
 117 
<span class="line-modified"> 118     baseValue.putByIndex(globalObject, index, value, strict);</span>
 119 }
 120 
 121 template&lt;bool strict, bool direct&gt;
<span class="line-modified"> 122 ALWAYS_INLINE static void putByValInternal(JSGlobalObject* globalObject, VM&amp; vm, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 123 {
 124     auto scope = DECLARE_THROW_SCOPE(vm);
 125 
 126     JSValue baseValue = JSValue::decode(encodedBase);
 127     JSValue property = JSValue::decode(encodedProperty);
 128     JSValue value = JSValue::decode(encodedValue);
 129 
 130     if (LIKELY(property.isUInt32())) {
 131         // Despite its name, JSValue::isUInt32 will return true only for positive boxed int32_t; all those values are valid array indices.
 132         ASSERT(isIndex(property.asUInt32()));
 133         scope.release();
<span class="line-modified"> 134         putByVal&lt;strict, direct&gt;(globalObject, vm, baseValue, property.asUInt32(), value);</span>
 135         return;
 136     }
 137 
 138     if (property.isDouble()) {
 139         double propertyAsDouble = property.asDouble();
 140         uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
 141         if (propertyAsDouble == propertyAsUInt32 &amp;&amp; isIndex(propertyAsUInt32)) {
 142             scope.release();
<span class="line-modified"> 143             putByVal&lt;strict, direct&gt;(globalObject, vm, baseValue, propertyAsUInt32, value);</span>
 144             return;
 145         }
 146     }
 147 
 148     // Don&#39;t put to an object if toString throws an exception.
<span class="line-modified"> 149     auto propertyName = property.toPropertyKey(globalObject);</span>
 150     RETURN_IF_EXCEPTION(scope, void());
 151 
 152     PutPropertySlot slot(baseValue, strict);
 153     if (direct) {
 154         RELEASE_ASSERT(baseValue.isObject());
 155         JSObject* baseObject = asObject(baseValue);
 156         if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
 157             scope.release();
<span class="line-modified"> 158             baseObject-&gt;putDirectIndex(globalObject, index.value(), value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
 159             return;
 160         }
 161         scope.release();
<span class="line-modified"> 162         CommonSlowPaths::putDirectWithReify(vm, globalObject, baseObject, propertyName, value, slot);</span>
 163         return;
 164     }
 165     scope.release();
<span class="line-modified"> 166     baseValue.put(globalObject, propertyName, value, slot);</span>
 167 }
 168 
 169 template&lt;bool strict, bool direct&gt;
<span class="line-modified"> 170 ALWAYS_INLINE static void putByValCellInternal(JSGlobalObject* globalObject, VM&amp; vm, JSCell* base, PropertyName propertyName, JSValue value)</span>
 171 {
 172     PutPropertySlot slot(base, strict);
 173     if (direct) {
 174         RELEASE_ASSERT(base-&gt;isObject());
 175         JSObject* baseObject = asObject(base);
 176         if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
<span class="line-modified"> 177             baseObject-&gt;putDirectIndex(globalObject, index.value(), value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
 178             return;
 179         }
<span class="line-modified"> 180         CommonSlowPaths::putDirectWithReify(vm, globalObject, baseObject, propertyName, value, slot);</span>
 181         return;
 182     }
<span class="line-modified"> 183     base-&gt;putInline(globalObject, propertyName, value, slot);</span>
 184 }
 185 
 186 template&lt;bool strict, bool direct&gt;
<span class="line-modified"> 187 ALWAYS_INLINE static void putByValCellStringInternal(JSGlobalObject* globalObject, VM&amp; vm, JSCell* base, JSString* property, JSValue value)</span>
 188 {
 189     auto scope = DECLARE_THROW_SCOPE(vm);
 190 
<span class="line-modified"> 191     auto propertyName = property-&gt;toIdentifier(globalObject);</span>
 192     RETURN_IF_EXCEPTION(scope, void());
 193 
 194     scope.release();
<span class="line-modified"> 195     putByValCellInternal&lt;strict, direct&gt;(globalObject, vm, base, propertyName, value);</span>
 196 }
 197 
 198 template&lt;typename ViewClass&gt;
<span class="line-modified"> 199 char* newTypedArrayWithSize(JSGlobalObject* globalObject, VM&amp; vm, Structure* structure, int32_t size, char* vector)</span>
 200 {


 201     auto scope = DECLARE_THROW_SCOPE(vm);
 202 
 203     if (size &lt; 0) {
<span class="line-modified"> 204         throwException(globalObject, scope, createRangeError(globalObject, &quot;Requested length is negative&quot;_s));</span>
 205         return 0;
 206     }
 207 
 208     if (vector)
<span class="line-modified"> 209         return bitwise_cast&lt;char*&gt;(ViewClass::createWithFastVector(globalObject, structure, size, untagArrayPtr(vector, size)));</span>
 210 
<span class="line-modified"> 211     RELEASE_AND_RETURN(scope, bitwise_cast&lt;char*&gt;(ViewClass::create(globalObject, structure, size)));</span>
 212 }
 213 
 214 template &lt;bool strict&gt;
<span class="line-modified"> 215 static ALWAYS_INLINE void putWithThis(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, const Identifier&amp; ident)</span>
 216 {
 217     JSValue baseValue = JSValue::decode(encodedBase);
 218     JSValue thisVal = JSValue::decode(encodedThis);
 219     JSValue putValue = JSValue::decode(encodedValue);
 220     PutPropertySlot slot(thisVal, strict);
<span class="line-modified"> 221     baseValue.putInline(globalObject, ident, putValue, slot);</span>
 222 }
 223 
 224 template&lt;typename BigIntOperation, typename NumberOperation&gt;
<span class="line-modified"> 225 static ALWAYS_INLINE EncodedJSValue binaryOp(JSGlobalObject* globalObject, VM&amp; vm, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, NumberOperation&amp;&amp; numberOp, const char* errorMessage)</span>
 226 {


 227     auto scope = DECLARE_THROW_SCOPE(vm);
 228 
 229     JSValue op1 = JSValue::decode(encodedOp1);
 230     JSValue op2 = JSValue::decode(encodedOp2);
 231 
<span class="line-modified"> 232     auto leftNumeric = op1.toNumeric(globalObject);</span>
 233     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified"> 234     auto rightNumeric = op2.toNumeric(globalObject);</span>
 235     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 236 
 237     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 238         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))
<span class="line-modified"> 239             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));</span>
 240 
<span class="line-modified"> 241         return throwVMTypeError(globalObject, scope, errorMessage);</span>
 242     }
 243 
 244     scope.release();
 245 
 246     return JSValue::encode(jsNumber(numberOp(WTF::get&lt;double&gt;(leftNumeric), WTF::get&lt;double&gt;(rightNumeric))));
 247 }
 248 
 249 template&lt;typename BigIntOperation, typename Int32Operation&gt;
<span class="line-modified"> 250 static ALWAYS_INLINE EncodedJSValue bitwiseBinaryOp(JSGlobalObject* globalObject, VM&amp; vm, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, Int32Operation&amp;&amp; int32Op, const char* errorMessage)</span>
 251 {


 252     auto scope = DECLARE_THROW_SCOPE(vm);
 253 
 254     JSValue op1 = JSValue::decode(encodedOp1);
 255     JSValue op2 = JSValue::decode(encodedOp2);
 256 
<span class="line-modified"> 257     auto leftNumeric = op1.toBigIntOrInt32(globalObject);</span>
 258     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified"> 259     auto rightNumeric = op2.toBigIntOrInt32(globalObject);</span>
 260     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 261 
 262     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 263         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))
<span class="line-modified"> 264             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));</span>
 265 
<span class="line-modified"> 266         return throwVMTypeError(globalObject, scope, errorMessage);</span>
 267     }
 268 
 269     scope.release();
 270 
 271     return JSValue::encode(jsNumber(int32Op(WTF::get&lt;int32_t&gt;(leftNumeric), WTF::get&lt;int32_t&gt;(rightNumeric))));
 272 }
 273 
 274 static ALWAYS_INLINE EncodedJSValue parseIntResult(double input)
 275 {
 276     int asInt = static_cast&lt;int&gt;(input);
 277     if (static_cast&lt;double&gt;(asInt) == input)
 278         return JSValue::encode(jsNumber(asInt));
 279     return JSValue::encode(jsNumber(input));
 280 }
 281 
<span class="line-modified"> 282 ALWAYS_INLINE static JSValue getByValObject(JSGlobalObject* globalObject, VM&amp; vm, JSObject* base, PropertyName propertyName)</span>
 283 {
 284     Structure&amp; structure = *base-&gt;structure(vm);
 285     if (JSCell::canUseFastGetOwnProperty(structure)) {
 286         if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, propertyName))
 287             return result;
 288     }
<span class="line-modified"> 289     return base-&gt;get(globalObject, propertyName);</span>
 290 }
 291 
 292 extern &quot;C&quot; {
 293 
<span class="line-modified"> 294 EncodedJSValue JIT_OPERATION operationToThis(JSGlobalObject* globalObject, EncodedJSValue encodedOp)</span>
 295 {
<span class="line-modified"> 296     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 297     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 298     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 299 
<span class="line-modified"> 300     return JSValue::encode(JSValue::decode(encodedOp).toThis(globalObject, NotStrictMode));</span>
 301 }
 302 
<span class="line-modified"> 303 EncodedJSValue JIT_OPERATION operationToThisStrict(JSGlobalObject* globalObject, EncodedJSValue encodedOp)</span>
 304 {
<span class="line-modified"> 305     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 306     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 307     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 308 
<span class="line-modified"> 309     return JSValue::encode(JSValue::decode(encodedOp).toThis(globalObject, StrictMode));</span>
 310 }
 311 
<span class="line-modified"> 312 JSArray* JIT_OPERATION operationObjectKeys(JSGlobalObject* globalObject, EncodedJSValue encodedObject)</span>
 313 {
<span class="line-modified"> 314     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 315     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 316     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 317     auto scope = DECLARE_THROW_SCOPE(vm);
 318 
<span class="line-modified"> 319     JSObject* object = JSValue::decode(encodedObject).toObject(globalObject);</span>
 320     RETURN_IF_EXCEPTION(scope, nullptr);
 321     scope.release();
<span class="line-modified"> 322     return ownPropertyKeys(globalObject, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);</span>
 323 }
 324 
<span class="line-modified"> 325 JSArray* JIT_OPERATION operationObjectKeysObject(JSGlobalObject* globalObject, JSObject* object)</span>
 326 {
<span class="line-modified"> 327     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 328     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified"> 329     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 330     return ownPropertyKeys(globalObject, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);</span>
 331 }
 332 
<span class="line-modified"> 333 JSCell* JIT_OPERATION operationObjectCreate(JSGlobalObject* globalObject, EncodedJSValue encodedPrototype)</span>
 334 {
<span class="line-modified"> 335     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 336     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 337     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 338     auto scope = DECLARE_THROW_SCOPE(vm);
 339 
 340     JSValue prototype = JSValue::decode(encodedPrototype);
 341 
 342     if (!prototype.isObject() &amp;&amp; !prototype.isNull()) {
<span class="line-modified"> 343         throwVMTypeError(globalObject, scope, &quot;Object prototype may only be an Object or null.&quot;_s);</span>
 344         return nullptr;
 345     }
 346 
 347     if (prototype.isObject())
<span class="line-modified"> 348         RELEASE_AND_RETURN(scope, constructEmptyObject(globalObject, asObject(prototype)));</span>
<span class="line-modified"> 349     RELEASE_AND_RETURN(scope, constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure()));</span>
 350 }
 351 
<span class="line-modified"> 352 JSCell* JIT_OPERATION operationObjectCreateObject(JSGlobalObject* globalObject, JSObject* prototype)</span>
 353 {
<span class="line-modified"> 354     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 355     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified"> 356     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 357     return constructEmptyObject(globalObject, prototype);</span>
 358 }
 359 
<span class="line-modified"> 360 JSCell* JIT_OPERATION operationCreateThis(JSGlobalObject* globalObject, JSObject* constructor, uint32_t inlineCapacity)</span>
 361 {
<span class="line-modified"> 362     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 363     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 364     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 365     auto scope = DECLARE_THROW_SCOPE(vm);
 366     if (constructor-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructor)-&gt;canUseAllocationProfile()) {
<span class="line-modified"> 367         auto rareData = jsCast&lt;JSFunction*&gt;(constructor)-&gt;ensureRareDataAndAllocationProfile(globalObject, inlineCapacity);</span>
 368         scope.releaseAssertNoException();
 369         ObjectAllocationProfileWithPrototype* allocationProfile = rareData-&gt;objectAllocationProfile();
 370         Structure* structure = allocationProfile-&gt;structure();
<span class="line-modified"> 371         JSObject* result = constructEmptyObject(vm, structure);</span>
 372         if (structure-&gt;hasPolyProto()) {
 373             JSObject* prototype = allocationProfile-&gt;prototype();
<span class="line-modified"> 374             ASSERT(prototype == jsCast&lt;JSFunction*&gt;(constructor)-&gt;prototypeForConstruction(vm, globalObject));</span>
 375             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 376             prototype-&gt;didBecomePrototype();
 377             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 378         }
 379         return result;
 380     }
 381 
<span class="line-modified"> 382     JSValue proto = constructor-&gt;get(globalObject, vm.propertyNames-&gt;prototype);</span>
 383     RETURN_IF_EXCEPTION(scope, nullptr);
 384     if (proto.isObject())
<span class="line-modified"> 385         return constructEmptyObject(globalObject, asObject(proto));</span>
<span class="line-modified"> 386     return constructEmptyObject(globalObject);</span>
<span class="line-added"> 387 }</span>
<span class="line-added"> 388 </span>
<span class="line-added"> 389 JSCell* JIT_OPERATION operationCreatePromise(JSGlobalObject* globalObject, JSObject* constructor)</span>
<span class="line-added"> 390 {</span>
<span class="line-added"> 391     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 392     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 393     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 394     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 395     Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;promiseConstructor(), constructor, globalObject-&gt;promiseStructure());</span>
<span class="line-added"> 396     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 397     RELEASE_AND_RETURN(scope, JSPromise::create(vm, structure));</span>
<span class="line-added"> 398 }</span>
<span class="line-added"> 399 </span>
<span class="line-added"> 400 JSCell* JIT_OPERATION operationCreateInternalPromise(JSGlobalObject* globalObject, JSObject* constructor)</span>
<span class="line-added"> 401 {</span>
<span class="line-added"> 402     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 403     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 404     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 405     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 406     Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;internalPromiseConstructor(), constructor, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-added"> 407     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 408     RELEASE_AND_RETURN(scope, JSInternalPromise::create(vm, structure));</span>
<span class="line-added"> 409 }</span>
<span class="line-added"> 410 </span>
<span class="line-added"> 411 JSCell* JIT_OPERATION operationCreateGenerator(JSGlobalObject* globalObject, JSObject* constructor)</span>
<span class="line-added"> 412 {</span>
<span class="line-added"> 413     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 414     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 415     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 416     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 417     Structure* structure = InternalFunction::createSubclassStructure(globalObject, nullptr, constructor, globalObject-&gt;generatorStructure());</span>
<span class="line-added"> 418     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 419     RELEASE_AND_RETURN(scope, JSGenerator::create(vm, structure));</span>
 420 }
 421 
<span class="line-modified"> 422 JSCell* JIT_OPERATION operationCreateAsyncGenerator(JSGlobalObject* globalObject, JSObject* constructor)</span>
 423 {
<span class="line-modified"> 424     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 425     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 426     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 427     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 428     Structure* structure = InternalFunction::createSubclassStructure(globalObject, nullptr, constructor, globalObject-&gt;asyncGeneratorStructure());</span>
<span class="line-added"> 429     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 430     RELEASE_AND_RETURN(scope, JSAsyncGenerator::create(vm, structure));</span>
<span class="line-added"> 431 }</span>
<span class="line-added"> 432 </span>
<span class="line-added"> 433 JSCell* JIT_OPERATION operationCallObjectConstructor(JSGlobalObject* globalObject, EncodedJSValue encodedTarget)</span>
<span class="line-added"> 434 {</span>
<span class="line-added"> 435     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 436     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 437     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 438 
 439     JSValue value = JSValue::decode(encodedTarget);
 440     ASSERT(!value.isObject());
 441 
 442     if (value.isUndefinedOrNull())
<span class="line-modified"> 443         return constructEmptyObject(globalObject, globalObject-&gt;objectPrototype());</span>
<span class="line-modified"> 444     return value.toObject(globalObject);</span>
 445 }
 446 
<span class="line-modified"> 447 JSCell* JIT_OPERATION operationToObject(JSGlobalObject* globalObject, EncodedJSValue encodedTarget, UniquedStringImpl* errorMessage)</span>
 448 {
<span class="line-modified"> 449     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 450     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 451     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 452     auto scope = DECLARE_THROW_SCOPE(vm);
 453 
 454     JSValue value = JSValue::decode(encodedTarget);
 455     ASSERT(!value.isObject());
 456 
 457     if (UNLIKELY(value.isUndefinedOrNull())) {
<span class="line-modified"> 458         if (errorMessage &amp;&amp; errorMessage-&gt;length()) {</span>
<span class="line-modified"> 459             throwVMTypeError(globalObject, scope, errorMessage);</span>
 460             return nullptr;
 461         }
 462     }
 463 
<span class="line-modified"> 464     RELEASE_AND_RETURN(scope, value.toObject(globalObject));</span>
 465 }
 466 
<span class="line-modified"> 467 EncodedJSValue JIT_OPERATION operationValueMod(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 468 {
<span class="line-modified"> 469     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 470     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 471     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 472 </span>
<span class="line-added"> 473     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added"> 474         return JSBigInt::remainder(globalObject, left, right);</span>
 475     };
 476 
 477     auto numberOp = [] (double left, double right) -&gt; double {
 478         return jsMod(left, right);
 479     };
 480 
<span class="line-modified"> 481     return binaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;);</span>
<span class="line-added"> 482 }</span>
<span class="line-added"> 483 </span>
<span class="line-added"> 484 EncodedJSValue JIT_OPERATION operationInc(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
<span class="line-added"> 485 {</span>
<span class="line-added"> 486     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 487     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 488     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 489     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-added"> 492 </span>
<span class="line-added"> 493     auto operandNumeric = op1.toNumeric(globalObject);</span>
<span class="line-added"> 494     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added"> 495 </span>
<span class="line-added"> 496     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))</span>
<span class="line-added"> 497         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::inc(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));</span>
<span class="line-added"> 498 </span>
<span class="line-added"> 499     double value = WTF::get&lt;double&gt;(operandNumeric);</span>
<span class="line-added"> 500     return JSValue::encode(jsNumber(value + 1));</span>
<span class="line-added"> 501 }</span>
<span class="line-added"> 502 </span>
<span class="line-added"> 503 EncodedJSValue JIT_OPERATION operationDec(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
<span class="line-added"> 504 {</span>
<span class="line-added"> 505     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 506     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 507     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 508     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 509 </span>
<span class="line-added"> 510     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-added"> 511 </span>
<span class="line-added"> 512     auto operandNumeric = op1.toNumeric(globalObject);</span>
<span class="line-added"> 513     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added"> 514 </span>
<span class="line-added"> 515     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))</span>
<span class="line-added"> 516         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::dec(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));</span>
<span class="line-added"> 517 </span>
<span class="line-added"> 518     double value = WTF::get&lt;double&gt;(operandNumeric);</span>
<span class="line-added"> 519     return JSValue::encode(jsNumber(value - 1));</span>
 520 }
 521 
<span class="line-modified"> 522 EncodedJSValue JIT_OPERATION operationValueBitNot(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
 523 {
<span class="line-modified"> 524     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 525     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 526     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 527     auto scope = DECLARE_THROW_SCOPE(vm);
 528 
 529     JSValue op1 = JSValue::decode(encodedOp1);
 530 
<span class="line-modified"> 531     auto operandNumeric = op1.toBigIntOrInt32(globalObject);</span>
 532     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 533 
 534     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))
<span class="line-modified"> 535         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::bitwiseNot(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));</span>
 536 
 537     return JSValue::encode(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
 538 }
 539 
<span class="line-modified"> 540 EncodedJSValue JIT_OPERATION operationValueBitAnd(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 541 {
<span class="line-modified"> 542     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 543     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 544     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 545 </span>
<span class="line-added"> 546     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added"> 547         return JSBigInt::bitwiseAnd(globalObject, left, right);</span>
 548     };
 549 
 550     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 551         return left &amp; right;
 552     };
 553 
<span class="line-modified"> 554     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;_s);</span>
 555 }
 556 
<span class="line-modified"> 557 EncodedJSValue JIT_OPERATION operationValueBitOr(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 558 {
<span class="line-modified"> 559     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 560     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 561     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 562 </span>
<span class="line-added"> 563     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added"> 564         return JSBigInt::bitwiseOr(globalObject, left, right);</span>
 565     };
 566 
 567     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 568         return left | right;
 569     };
 570 
<span class="line-modified"> 571     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;_s);</span>
 572 }
 573 
<span class="line-modified"> 574 EncodedJSValue JIT_OPERATION operationValueBitXor(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 575 {
<span class="line-modified"> 576     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 577     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 578     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 579 </span>
<span class="line-added"> 580     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added"> 581         return JSBigInt::bitwiseXor(globalObject, left, right);</span>
 582     };
 583 
 584     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 585         return left ^ right;
 586     };
 587 
<span class="line-modified"> 588     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;_s);</span>
 589 }
 590 
<span class="line-modified"> 591 EncodedJSValue JIT_OPERATION operationValueBitLShift(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 592 {
<span class="line-modified"> 593     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 594     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 595     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 596 </span>
<span class="line-added"> 597     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added"> 598         return JSBigInt::leftShift(globalObject, left, right);</span>
 599     };
 600 
 601     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
 602         return left &lt;&lt; (right &amp; 0x1f);
 603     };
 604 
<span class="line-modified"> 605     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;_s);</span>
 606 }
 607 
<span class="line-modified"> 608 EncodedJSValue JIT_OPERATION operationValueBitRShift(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 609 {
<span class="line-modified"> 610     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 611     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified"> 612     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 613 
<span class="line-modified"> 614     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified"> 615         return JSBigInt::signedRightShift(globalObject, left, right);</span>
<span class="line-added"> 616     };</span>
 617 
<span class="line-modified"> 618     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {</span>
<span class="line-modified"> 619         return left &gt;&gt; (right &amp; 0x1f);</span>
<span class="line-modified"> 620     };</span>
<span class="line-modified"> 621 </span>
<span class="line-modified"> 622     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in signed right shift operation.&quot;_s);</span>
 623 }
 624 
<span class="line-modified"> 625 EncodedJSValue JIT_OPERATION operationValueBitURShift(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 626 {
<span class="line-modified"> 627     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 628     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 629     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 630     auto scope = DECLARE_THROW_SCOPE(vm);
 631 
 632     JSValue op1 = JSValue::decode(encodedOp1);
 633     JSValue op2 = JSValue::decode(encodedOp2);
 634 
<span class="line-modified"> 635     uint32_t a = op1.toUInt32(globalObject);</span>
 636     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 637     scope.release();
<span class="line-modified"> 638     uint32_t b = op2.toUInt32(globalObject);</span>
 639     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 0x1f))));
 640 }
 641 
<span class="line-modified"> 642 EncodedJSValue JIT_OPERATION operationValueAddNotNumber(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 643 {
<span class="line-modified"> 644     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 645     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 646     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 647 
 648     JSValue op1 = JSValue::decode(encodedOp1);
 649     JSValue op2 = JSValue::decode(encodedOp2);
 650 
<span class="line-modified"> 651     return JSValue::encode(jsAddNonNumber(globalObject, op1, op2));</span>
 652 }
 653 
<span class="line-modified"> 654 EncodedJSValue JIT_OPERATION operationValueDiv(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 655 {
<span class="line-modified"> 656     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 657     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 658     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 659 </span>
<span class="line-added"> 660     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added"> 661         return JSBigInt::divide(globalObject, left, right);</span>
 662     };
 663 
 664     auto numberOp = [] (double left, double right) -&gt; double {
 665         return left / right;
 666     };
 667 
<span class="line-modified"> 668     return binaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in division operation.&quot;);</span>
 669 }
 670 
<span class="line-modified"> 671 EncodedJSValue JIT_OPERATION operationValuePow(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
 672 {
<span class="line-modified"> 673     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 674     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 675     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 676 </span>
<span class="line-added"> 677     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added"> 678         return JSBigInt::exponentiate(globalObject, left, right);</span>
 679     };
 680 
 681     auto numberOp = [] (double left, double right) -&gt; double {
 682         return operationMathPow(left, right);
 683     };
 684 
<span class="line-modified"> 685     return binaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;_s);</span>
 686 }
 687 
<span class="line-modified"> 688 double JIT_OPERATION operationArithAbs(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
 689 {
<span class="line-modified"> 690     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 691     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 692     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 693     auto scope = DECLARE_THROW_SCOPE(vm);
 694 
 695     JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified"> 696     double a = op1.toNumber(globalObject);</span>
 697     RETURN_IF_EXCEPTION(scope, PNaN);
 698     return fabs(a);
 699 }
 700 
<span class="line-modified"> 701 uint32_t JIT_OPERATION operationArithClz32(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
 702 {
<span class="line-modified"> 703     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 704     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 705     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 706     auto scope = DECLARE_THROW_SCOPE(vm);
 707 
 708     JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified"> 709     uint32_t value = op1.toUInt32(globalObject);</span>
 710     RETURN_IF_EXCEPTION(scope, 0);
 711     return clz(value);
 712 }
 713 
<span class="line-modified"> 714 double JIT_OPERATION operationArithFRound(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
 715 {
<span class="line-modified"> 716     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 717     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 718     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 719     auto scope = DECLARE_THROW_SCOPE(vm);
 720 
 721     JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified"> 722     double a = op1.toNumber(globalObject);</span>
 723     RETURN_IF_EXCEPTION(scope, PNaN);
 724     return static_cast&lt;float&gt;(a);
 725 }
 726 
 727 #define DFG_ARITH_UNARY(capitalizedName, lowerName) \
<span class="line-modified"> 728 double JIT_OPERATION operationArith##capitalizedName(JSGlobalObject* globalObject, EncodedJSValue encodedOp1) \</span>
 729 { \
<span class="line-modified"> 730     VM&amp; vm = globalObject-&gt;vm(); \</span>
<span class="line-modified"> 731     CallFrame* callFrame = DECLARE_CALL_FRAME(vm); \</span>
<span class="line-added"> 732     JITOperationPrologueCallFrameTracer tracer(vm, callFrame); \</span>
 733     auto scope = DECLARE_THROW_SCOPE(vm); \
 734     JSValue op1 = JSValue::decode(encodedOp1); \
<span class="line-modified"> 735     double result = op1.toNumber(globalObject); \</span>
 736     RETURN_IF_EXCEPTION(scope, PNaN); \
 737     return JSC::Math::lowerName(result); \
 738 }
 739     FOR_EACH_DFG_ARITH_UNARY_OP(DFG_ARITH_UNARY)
 740 #undef DFG_ARITH_UNARY
 741 
<span class="line-modified"> 742 double JIT_OPERATION operationArithSqrt(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
 743 {
<span class="line-modified"> 744     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 745     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 746     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 747     auto scope = DECLARE_THROW_SCOPE(vm);
 748 
 749     JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified"> 750     double a = op1.toNumber(globalObject);</span>
 751     RETURN_IF_EXCEPTION(scope, PNaN);
 752     return sqrt(a);
 753 }
 754 
<span class="line-modified"> 755 EncodedJSValue JIT_OPERATION operationArithRound(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)</span>
 756 {
<span class="line-modified"> 757     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 758     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 759     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 760     auto scope = DECLARE_THROW_SCOPE(vm);
 761 
 762     JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified"> 763     double valueOfArgument = argument.toNumber(globalObject);</span>
 764     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 765     return JSValue::encode(jsNumber(jsRound(valueOfArgument)));
 766 }
 767 
<span class="line-modified"> 768 EncodedJSValue JIT_OPERATION operationArithFloor(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)</span>
 769 {
<span class="line-modified"> 770     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 771     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 772     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 773     auto scope = DECLARE_THROW_SCOPE(vm);
 774 
 775     JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified"> 776     double valueOfArgument = argument.toNumber(globalObject);</span>
 777     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 778     return JSValue::encode(jsNumber(floor(valueOfArgument)));
 779 }
 780 
<span class="line-modified"> 781 EncodedJSValue JIT_OPERATION operationArithCeil(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)</span>
 782 {
<span class="line-modified"> 783     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 784     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 785     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 786     auto scope = DECLARE_THROW_SCOPE(vm);
 787 
 788     JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified"> 789     double valueOfArgument = argument.toNumber(globalObject);</span>
 790     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 791     return JSValue::encode(jsNumber(ceil(valueOfArgument)));
 792 }
 793 
<span class="line-modified"> 794 EncodedJSValue JIT_OPERATION operationArithTrunc(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)</span>
 795 {
<span class="line-modified"> 796     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 797     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 798     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 799     auto scope = DECLARE_THROW_SCOPE(vm);
 800 
 801     JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified"> 802     double truncatedValueOfArgument = argument.toIntegerPreserveNaN(globalObject);</span>
 803     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 804     return JSValue::encode(jsNumber(truncatedValueOfArgument));
 805 }
 806 
<span class="line-modified"> 807 EncodedJSValue JIT_OPERATION operationGetByValCell(JSGlobalObject* globalObject, JSCell* base, EncodedJSValue encodedProperty)</span>

















 808 {
<span class="line-modified"> 809     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 810     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified"> 811     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>








































 812     auto scope = DECLARE_THROW_SCOPE(vm);
 813 
 814     JSValue property = JSValue::decode(encodedProperty);
 815 
 816     if (property.isUInt32())
<span class="line-modified"> 817         RELEASE_AND_RETURN(scope, getByValWithIndex(globalObject, base, property.asUInt32()));</span>
 818 
 819     if (property.isDouble()) {
 820         double propertyAsDouble = property.asDouble();
 821         uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
 822         if (propertyAsUInt32 == propertyAsDouble)
<span class="line-modified"> 823             RELEASE_AND_RETURN(scope, getByValWithIndex(globalObject, base, propertyAsUInt32));</span>
 824 
 825     } else if (property.isString()) {
 826         Structure&amp; structure = *base-&gt;structure(vm);
 827         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified"> 828             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(property)-&gt;toExistingAtomString(globalObject);</span>
 829             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 830             if (existingAtomString) {
 831                 if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
 832                     return JSValue::encode(result);
 833             }
 834         }
 835     }
 836 
<span class="line-modified"> 837     auto propertyName = property.toPropertyKey(globalObject);</span>
 838     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified"> 839     RELEASE_AND_RETURN(scope, JSValue::encode(JSValue(base).get(globalObject, propertyName)));</span>
 840 }
 841 
<span class="line-modified"> 842 ALWAYS_INLINE EncodedJSValue getByValCellInt(JSGlobalObject* globalObject, VM&amp; vm, JSCell* base, int32_t index)</span>
 843 {



 844     if (index &lt; 0) {
 845         // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified"> 846         return JSValue::encode(JSValue(base).get(globalObject, Identifier::from(vm, index)));</span>
 847     }
 848 
 849     // Use this since we know that the value is out of bounds.
<span class="line-modified"> 850     return JSValue::encode(JSValue(base).get(globalObject, static_cast&lt;unsigned&gt;(index)));</span>
 851 }
 852 
<span class="line-modified"> 853 EncodedJSValue JIT_OPERATION operationGetByValObjectInt(JSGlobalObject* globalObject, JSObject* base, int32_t index)</span>
 854 {
<span class="line-modified"> 855     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 856     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 857     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 858 </span>
<span class="line-added"> 859     return getByValCellInt(globalObject, vm, base, index);</span>
 860 }
 861 
<span class="line-modified"> 862 EncodedJSValue JIT_OPERATION operationGetByValStringInt(JSGlobalObject* globalObject, JSString* base, int32_t index)</span>
 863 {
<span class="line-modified"> 864     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 865     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 866     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 867 </span>
<span class="line-added"> 868     return getByValCellInt(globalObject, vm, base, index);</span>
 869 }
 870 
<span class="line-modified"> 871 EncodedJSValue JIT_OPERATION operationGetByValObjectString(JSGlobalObject* globalObject, JSCell* base, JSCell* string)</span>
 872 {
<span class="line-modified"> 873     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 874     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 875     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 876 
 877     auto scope = DECLARE_THROW_SCOPE(vm);
 878 
<span class="line-modified"> 879     auto propertyName = asString(string)-&gt;toIdentifier(globalObject);</span>
 880     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 881 
<span class="line-modified"> 882     RELEASE_AND_RETURN(scope, JSValue::encode(getByValObject(globalObject, vm, asObject(base), propertyName)));</span>
 883 }
 884 
<span class="line-modified"> 885 EncodedJSValue JIT_OPERATION operationGetByValObjectSymbol(JSGlobalObject* globalObject, JSCell* base, JSCell* symbol)</span>
 886 {
<span class="line-modified"> 887     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 888     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 889     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 890 
 891     auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified"> 892     return JSValue::encode(getByValObject(globalObject, vm, asObject(base), propertyName));</span>
 893 }
 894 
<span class="line-modified"> 895 void JIT_OPERATION operationPutByValStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 896 {
<span class="line-modified"> 897     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 898     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 899     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 900 
<span class="line-modified"> 901     putByValInternal&lt;true, false&gt;(globalObject, vm, encodedBase, encodedProperty, encodedValue);</span>
 902 }
 903 
<span class="line-modified"> 904 void JIT_OPERATION operationPutByValNonStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 905 {
<span class="line-modified"> 906     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 907     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 908     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 909 
<span class="line-modified"> 910     putByValInternal&lt;false, false&gt;(globalObject, vm, encodedBase, encodedProperty, encodedValue);</span>
 911 }
 912 
<span class="line-modified"> 913 void JIT_OPERATION operationPutByValCellStrict(JSGlobalObject* globalObject, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 914 {
<span class="line-modified"> 915     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 916     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 917     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 918 
<span class="line-modified"> 919     putByValInternal&lt;true, false&gt;(globalObject, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
 920 }
 921 
<span class="line-modified"> 922 void JIT_OPERATION operationPutByValCellNonStrict(JSGlobalObject* globalObject, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
 923 {
<span class="line-modified"> 924     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 925     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 926     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 927 
<span class="line-modified"> 928     putByValInternal&lt;false, false&gt;(globalObject, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
 929 }
 930 
<span class="line-modified"> 931 void JIT_OPERATION operationPutByValCellStringStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
 932 {
<span class="line-modified"> 933     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 934     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 935     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 936 
<span class="line-modified"> 937     putByValCellStringInternal&lt;true, false&gt;(globalObject, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
 938 }
 939 
<span class="line-modified"> 940 void JIT_OPERATION operationPutByValCellStringNonStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
 941 {
<span class="line-modified"> 942     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 943     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 944     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 945 
<span class="line-modified"> 946     putByValCellStringInternal&lt;false, false&gt;(globalObject, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
 947 }
 948 
<span class="line-modified"> 949 void JIT_OPERATION operationPutByValCellSymbolStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
 950 {
<span class="line-modified"> 951     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 952     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 953     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 954 
 955     auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified"> 956     putByValCellInternal&lt;true, false&gt;(globalObject, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
 957 }
 958 
<span class="line-modified"> 959 void JIT_OPERATION operationPutByValCellSymbolNonStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
 960 {
<span class="line-modified"> 961     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 962     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 963     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 964 
 965     auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified"> 966     putByValCellInternal&lt;false, false&gt;(globalObject, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
 967 }
 968 
<span class="line-modified"> 969 void JIT_OPERATION operationPutByValBeyondArrayBoundsStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
 970 {
<span class="line-modified"> 971     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 972     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 973     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 974 
 975     if (index &gt;= 0) {
<span class="line-modified"> 976         object-&gt;putByIndexInline(globalObject, index, JSValue::decode(encodedValue), true);</span>
 977         return;
 978     }
 979 
 980     PutPropertySlot slot(object, true);
 981     object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified"> 982         object, globalObject, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
 983 }
 984 
<span class="line-modified"> 985 void JIT_OPERATION operationPutByValBeyondArrayBoundsNonStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
 986 {
<span class="line-modified"> 987     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 988     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 989     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 990 
 991     if (index &gt;= 0) {
<span class="line-modified"> 992         object-&gt;putByIndexInline(globalObject, index, JSValue::decode(encodedValue), false);</span>
 993         return;
 994     }
 995 
 996     PutPropertySlot slot(object, false);
 997     object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified"> 998         object, globalObject, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
 999 }
1000 
<span class="line-modified">1001 void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, double value)</span>
1002 {
<span class="line-modified">1003     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1004     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1005     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1006 
1007     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
1008 
1009     if (index &gt;= 0) {
<span class="line-modified">1010         object-&gt;putByIndexInline(globalObject, index, jsValue, true);</span>
1011         return;
1012     }
1013 
1014     PutPropertySlot slot(object, true);
1015     object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified">1016         object, globalObject, Identifier::from(vm, index), jsValue, slot);</span>
1017 }
1018 
<span class="line-modified">1019 void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsNonStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, double value)</span>
1020 {
<span class="line-modified">1021     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1022     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1023     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1024 
1025     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
1026 
1027     if (index &gt;= 0) {
<span class="line-modified">1028         object-&gt;putByIndexInline(globalObject, index, jsValue, false);</span>
1029         return;
1030     }
1031 
1032     PutPropertySlot slot(object, false);
1033     object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified">1034         object, globalObject, Identifier::from(vm, index), jsValue, slot);</span>
1035 }
1036 
<span class="line-modified">1037 void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, double value)</span>
1038 {
<span class="line-modified">1039     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1040     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1041     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1042 
1043     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
1044 
1045     if (index &gt;= 0) {
<span class="line-modified">1046         object-&gt;putDirectIndex(globalObject, index, jsValue, 0, PutDirectIndexShouldThrow);</span>
1047         return;
1048     }
1049 
1050     PutPropertySlot slot(object, true);
<span class="line-modified">1051     CommonSlowPaths::putDirectWithReify(vm, globalObject, object, Identifier::from(vm, index), jsValue, slot);</span>
1052 }
1053 
<span class="line-modified">1054 void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsNonStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, double value)</span>
1055 {
<span class="line-modified">1056     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1057     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1058     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1059 
1060     JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
1061 
1062     if (index &gt;= 0) {
<span class="line-modified">1063         object-&gt;putDirectIndex(globalObject, index, jsValue);</span>
1064         return;
1065     }
1066 
1067     PutPropertySlot slot(object, false);
<span class="line-modified">1068     CommonSlowPaths::putDirectWithReify(vm, globalObject, object, Identifier::from(vm, index), jsValue, slot);</span>
1069 }
1070 
<span class="line-modified">1071 void JIT_OPERATION operationPutByValDirectStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
1072 {
<span class="line-modified">1073     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1074     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1075     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1076 
<span class="line-modified">1077     putByValInternal&lt;true, true&gt;(globalObject, vm, encodedBase, encodedProperty, encodedValue);</span>
1078 }
1079 
<span class="line-modified">1080 void JIT_OPERATION operationPutByValDirectNonStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
1081 {
<span class="line-modified">1082     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1083     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1084     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1085 
<span class="line-modified">1086     putByValInternal&lt;false, true&gt;(globalObject, vm, encodedBase, encodedProperty, encodedValue);</span>
1087 }
1088 
<span class="line-modified">1089 void JIT_OPERATION operationPutByValDirectCellStrict(JSGlobalObject* globalObject, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
1090 {
<span class="line-modified">1091     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1092     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1093     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1094 
<span class="line-modified">1095     putByValInternal&lt;true, true&gt;(globalObject, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
1096 }
1097 
<span class="line-modified">1098 void JIT_OPERATION operationPutByValDirectCellNonStrict(JSGlobalObject* globalObject, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
1099 {
<span class="line-modified">1100     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1101     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1102     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1103 
<span class="line-modified">1104     putByValInternal&lt;false, true&gt;(globalObject, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
1105 }
1106 
<span class="line-modified">1107 void JIT_OPERATION operationPutByValDirectCellStringStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
1108 {
<span class="line-modified">1109     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1110     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1111     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1112 
<span class="line-modified">1113     putByValCellStringInternal&lt;true, true&gt;(globalObject, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
1114 }
1115 
<span class="line-modified">1116 void JIT_OPERATION operationPutByValDirectCellStringNonStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
1117 {
<span class="line-modified">1118     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1119     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1120     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1121 
<span class="line-modified">1122     putByValCellStringInternal&lt;false, true&gt;(globalObject, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
1123 }
1124 
<span class="line-modified">1125 void JIT_OPERATION operationPutByValDirectCellSymbolStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
1126 {
<span class="line-modified">1127     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1128     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1129     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1130 
1131     auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">1132     putByValCellInternal&lt;true, true&gt;(globalObject, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
1133 }
1134 
<span class="line-modified">1135 void JIT_OPERATION operationPutByValDirectCellSymbolNonStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
1136 {
<span class="line-modified">1137     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1138     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1139     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1140 
1141     auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">1142     putByValCellInternal&lt;false, true&gt;(globalObject, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
1143 }
1144 
<span class="line-modified">1145 void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
1146 {
<span class="line-modified">1147     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1148     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1149     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1150     if (index &gt;= 0) {
<span class="line-modified">1151         object-&gt;putDirectIndex(globalObject, index, JSValue::decode(encodedValue), 0, PutDirectIndexShouldThrow);</span>
1152         return;
1153     }
1154 
1155     PutPropertySlot slot(object, true);
<span class="line-modified">1156     CommonSlowPaths::putDirectWithReify(vm, globalObject, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
1157 }
1158 
<span class="line-modified">1159 void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsNonStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
1160 {
<span class="line-modified">1161     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1162     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1163     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1164 
1165     if (index &gt;= 0) {
<span class="line-modified">1166         object-&gt;putDirectIndex(globalObject, index, JSValue::decode(encodedValue));</span>
1167         return;
1168     }
1169 
1170     PutPropertySlot slot(object, false);
<span class="line-modified">1171     CommonSlowPaths::putDirectWithReify(vm, globalObject, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
1172 }
1173 
<span class="line-modified">1174 EncodedJSValue JIT_OPERATION operationArrayPush(JSGlobalObject* globalObject, EncodedJSValue encodedValue, JSArray* array)</span>
1175 {
<span class="line-modified">1176     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1177     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1178     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1179 
<span class="line-modified">1180     array-&gt;pushInline(globalObject, JSValue::decode(encodedValue));</span>
1181     return JSValue::encode(jsNumber(array-&gt;length()));
1182 }
1183 
<span class="line-modified">1184 EncodedJSValue JIT_OPERATION operationArrayPushDouble(JSGlobalObject* globalObject, double value, JSArray* array)</span>
1185 {
<span class="line-modified">1186     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1187     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1188     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1189 
<span class="line-modified">1190     array-&gt;pushInline(globalObject, JSValue(JSValue::EncodeAsDouble, value));</span>
1191     return JSValue::encode(jsNumber(array-&gt;length()));
1192 }
1193 
<span class="line-modified">1194 EncodedJSValue JIT_OPERATION operationArrayPushMultiple(JSGlobalObject* globalObject, JSArray* array, void* buffer, int32_t elementCount)</span>
1195 {
<span class="line-modified">1196     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1197     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1198     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1199     auto scope = DECLARE_THROW_SCOPE(vm);
1200 
1201     // We assume that multiple JSArray::push calls with ArrayWithInt32/ArrayWithContiguous do not cause JS traps.
1202     // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
1203     // content of ScratchBuffer. If the IndexingType is now ArrayWithInt32/ArrayWithContiguous, we can ensure
1204     // that there is no indexed accessors in this object and its prototype chain.
1205     //
1206     // ArrayWithArrayStorage is also OK. It can have indexed accessors. But if you define an indexed accessor, the array&#39;s length
1207     // becomes larger than that index. So Array#push never overlaps with this accessor. So accessors are never called unless
1208     // the IndexingType is ArrayWithSlowPutArrayStorage which could have an indexed accessor in a prototype chain.
1209     RELEASE_ASSERT(!shouldUseSlowPut(array-&gt;indexingType()));
1210 
1211     EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
1212     for (int32_t i = 0; i &lt; elementCount; ++i) {
<span class="line-modified">1213         array-&gt;pushInline(globalObject, JSValue::decode(values[i]));</span>
1214         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1215     }
1216     return JSValue::encode(jsNumber(array-&gt;length()));
1217 }
1218 
<span class="line-modified">1219 EncodedJSValue JIT_OPERATION operationArrayPushDoubleMultiple(JSGlobalObject* globalObject, JSArray* array, void* buffer, int32_t elementCount)</span>
1220 {
<span class="line-modified">1221     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1222     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1223     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1224     auto scope = DECLARE_THROW_SCOPE(vm);
1225 
1226     // We assume that multiple JSArray::push calls with ArrayWithDouble do not cause JS traps.
1227     // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
1228     // content of ScratchBuffer. If the IndexingType is now ArrayWithDouble, we can ensure
1229     // that there is no indexed accessors in this object and its prototype chain.
1230     ASSERT(array-&gt;indexingMode() == ArrayWithDouble);
1231 
1232     double* values = static_cast&lt;double*&gt;(buffer);
1233     for (int32_t i = 0; i &lt; elementCount; ++i) {
<span class="line-modified">1234         array-&gt;pushInline(globalObject, JSValue(JSValue::EncodeAsDouble, values[i]));</span>
1235         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1236     }
1237     return JSValue::encode(jsNumber(array-&gt;length()));
1238 }
1239 
<span class="line-modified">1240 EncodedJSValue JIT_OPERATION operationArrayPop(JSGlobalObject* globalObject, JSArray* array)</span>
1241 {
<span class="line-modified">1242     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1243     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1244     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1245 
<span class="line-modified">1246     return JSValue::encode(array-&gt;pop(globalObject));</span>
1247 }
1248 
<span class="line-modified">1249 EncodedJSValue JIT_OPERATION operationArrayPopAndRecoverLength(JSGlobalObject* globalObject, JSArray* array)</span>
1250 {
<span class="line-modified">1251     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1252     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1253     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1254 
1255     array-&gt;butterfly()-&gt;setPublicLength(array-&gt;butterfly()-&gt;publicLength() + 1);
1256 
<span class="line-modified">1257     return JSValue::encode(array-&gt;pop(globalObject));</span>
1258 }
1259 
<span class="line-modified">1260 EncodedJSValue JIT_OPERATION operationRegExpExecString(JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)</span>
1261 {
1262     SuperSamplerScope superSamplerScope(false);
1263 
1264     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1265     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1266     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1267 
<span class="line-modified">1268     return JSValue::encode(regExpObject-&gt;execInline(globalObject, argument));</span>
1269 }
1270 
<span class="line-modified">1271 EncodedJSValue JIT_OPERATION operationRegExpExec(JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)</span>
1272 {
1273     SuperSamplerScope superSamplerScope(false);
1274 
1275     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1276     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1277     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1278     auto scope = DECLARE_THROW_SCOPE(vm);
1279 
1280     JSValue argument = JSValue::decode(encodedArgument);
1281 
<span class="line-modified">1282     JSString* input = argument.toStringOrNull(globalObject);</span>
1283     EXCEPTION_ASSERT(!!scope.exception() == !input);
1284     if (!input)
1285         return encodedJSValue();
<span class="line-modified">1286     RELEASE_AND_RETURN(scope, JSValue::encode(regExpObject-&gt;execInline(globalObject, input)));</span>
1287 }
1288 
<span class="line-modified">1289 EncodedJSValue JIT_OPERATION operationRegExpExecGeneric(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)</span>
1290 {
1291     SuperSamplerScope superSamplerScope(false);
1292 
1293     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1294     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1295     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1296     auto scope = DECLARE_THROW_SCOPE(vm);
1297 
1298     JSValue base = JSValue::decode(encodedBase);
1299     JSValue argument = JSValue::decode(encodedArgument);
1300 
1301     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
1302     if (UNLIKELY(!regexp))
<span class="line-modified">1303         return throwVMTypeError(globalObject, scope);</span>
1304 
<span class="line-modified">1305     JSString* input = argument.toStringOrNull(globalObject);</span>
1306     EXCEPTION_ASSERT(!!scope.exception() == !input);
1307     if (!input)
1308         return JSValue::encode(jsUndefined());
<span class="line-modified">1309     RELEASE_AND_RETURN(scope, JSValue::encode(regexp-&gt;exec(globalObject, input)));</span>
1310 }
1311 
<span class="line-modified">1312 EncodedJSValue JIT_OPERATION operationRegExpExecNonGlobalOrSticky(JSGlobalObject* globalObject, RegExp* regExp, JSString* string)</span>
1313 {
1314     SuperSamplerScope superSamplerScope(false);
1315 
1316     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1317     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1318     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1319 
1320     auto scope = DECLARE_THROW_SCOPE(vm);
1321 
<span class="line-modified">1322     String input = string-&gt;value(globalObject);</span>
1323     RETURN_IF_EXCEPTION(scope, { });
1324 
1325     unsigned lastIndex = 0;
1326     MatchResult result;
1327     JSArray* array = createRegExpMatchesArray(vm, globalObject, string, input, regExp, lastIndex, result);
<span class="line-modified">1328     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-modified">1329     if (!array)</span>
1330         return JSValue::encode(jsNull());

1331 

1332     globalObject-&gt;regExpGlobalData().recordMatch(vm, globalObject, regExp, string, result);
1333     return JSValue::encode(array);
1334 }
1335 
<span class="line-modified">1336 EncodedJSValue JIT_OPERATION operationRegExpMatchFastString(JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)</span>
1337 {
1338     SuperSamplerScope superSamplerScope(false);
1339 
1340     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1341     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1342     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1343 
1344     if (!regExpObject-&gt;regExp()-&gt;global())
<span class="line-modified">1345         return JSValue::encode(regExpObject-&gt;execInline(globalObject, argument));</span>
<span class="line-modified">1346     return JSValue::encode(regExpObject-&gt;matchGlobal(globalObject, argument));</span>
1347 }
1348 
<span class="line-modified">1349 EncodedJSValue JIT_OPERATION operationRegExpMatchFastGlobalString(JSGlobalObject* globalObject, RegExp* regExp, JSString* string)</span>
1350 {
1351     SuperSamplerScope superSamplerScope(false);
1352 
1353     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1354     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1355     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1356 
1357     auto scope = DECLARE_THROW_SCOPE(vm);
1358 
1359     ASSERT(regExp-&gt;global());
1360 
<span class="line-modified">1361     String s = string-&gt;value(globalObject);</span>
1362     RETURN_IF_EXCEPTION(scope, { });
1363 
1364     if (regExp-&gt;unicode()) {
1365         unsigned stringLength = s.length();
1366         RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
<span class="line-modified">1367             vm, globalObject, string, s, regExp,</span>
1368             [&amp;] (size_t end) -&gt; size_t {
1369                 return advanceStringUnicode(s, stringLength, end);
1370             })));
1371     }
1372 
1373     RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
<span class="line-modified">1374         vm, globalObject, string, s, regExp,</span>
1375         [&amp;] (size_t end) -&gt; size_t {
1376             return end + 1;
1377         })));
1378 }
1379 
<span class="line-modified">1380 EncodedJSValue JIT_OPERATION operationParseIntNoRadixGeneric(JSGlobalObject* globalObject, EncodedJSValue value)</span>
1381 {
<span class="line-modified">1382     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1383     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1384     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1385 
<span class="line-modified">1386     return toStringView(globalObject, JSValue::decode(value), [&amp;] (StringView view) {</span>
1387         // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
1388         return parseIntResult(parseInt(view, 0));
1389     });
1390 }
1391 
<span class="line-modified">1392 EncodedJSValue JIT_OPERATION operationParseIntStringNoRadix(JSGlobalObject* globalObject, JSString* string)</span>
1393 {
<span class="line-modified">1394     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1395     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1396     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1397     auto scope = DECLARE_THROW_SCOPE(vm);
1398 
<span class="line-modified">1399     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);</span>
1400     RETURN_IF_EXCEPTION(scope, { });
1401 
1402     // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
1403     return parseIntResult(parseInt(viewWithString.view, 0));
1404 }
1405 
<span class="line-modified">1406 EncodedJSValue JIT_OPERATION operationParseIntString(JSGlobalObject* globalObject, JSString* string, int32_t radix)</span>
1407 {
<span class="line-modified">1408     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1409     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1410     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1411     auto scope = DECLARE_THROW_SCOPE(vm);
1412 
<span class="line-modified">1413     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);</span>
1414     RETURN_IF_EXCEPTION(scope, { });
1415 
1416     return parseIntResult(parseInt(viewWithString.view, radix));
1417 }
1418 
<span class="line-modified">1419 EncodedJSValue JIT_OPERATION operationParseIntGeneric(JSGlobalObject* globalObject, EncodedJSValue value, int32_t radix)</span>
1420 {
<span class="line-modified">1421     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1422     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1423     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1424 
<span class="line-modified">1425     return toStringView(globalObject, JSValue::decode(value), [&amp;] (StringView view) {</span>
1426         return parseIntResult(parseInt(view, radix));
1427     });
1428 }
1429 
<span class="line-modified">1430 size_t JIT_OPERATION operationRegExpTestString(JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* input)</span>
1431 {
1432     SuperSamplerScope superSamplerScope(false);
1433 
1434     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1435     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1436     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1437 
<span class="line-modified">1438     return regExpObject-&gt;testInline(globalObject, input);</span>
1439 }
1440 
<span class="line-modified">1441 size_t JIT_OPERATION operationRegExpTest(JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)</span>
1442 {
1443     SuperSamplerScope superSamplerScope(false);
1444 
1445     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1446     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1447     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1448 
1449     JSValue argument = JSValue::decode(encodedArgument);
1450 
<span class="line-modified">1451     JSString* input = argument.toStringOrNull(globalObject);</span>
1452     if (!input)
1453         return false;
<span class="line-modified">1454     return regExpObject-&gt;testInline(globalObject, input);</span>
1455 }
1456 
<span class="line-modified">1457 size_t JIT_OPERATION operationRegExpTestGeneric(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)</span>
1458 {
1459     SuperSamplerScope superSamplerScope(false);
1460 
1461     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1462     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1463     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1464     auto scope = DECLARE_THROW_SCOPE(vm);
1465 
1466     JSValue base = JSValue::decode(encodedBase);
1467     JSValue argument = JSValue::decode(encodedArgument);
1468 
1469     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
1470     if (UNLIKELY(!regexp)) {
<span class="line-modified">1471         throwTypeError(globalObject, scope);</span>
1472         return false;
1473     }
1474 
<span class="line-modified">1475     JSString* input = argument.toStringOrNull(globalObject);</span>
1476     EXCEPTION_ASSERT(!!scope.exception() == !input);
1477     if (!input)
1478         return false;
<span class="line-modified">1479     RELEASE_AND_RETURN(scope, regexp-&gt;test(globalObject, input));</span>
1480 }
1481 
<span class="line-modified">1482 JSCell* JIT_OPERATION operationSubBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
1483 {
<span class="line-modified">1484     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1485     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1486     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1487 
1488     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1489     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1490 
<span class="line-modified">1491     return JSBigInt::sub(globalObject, leftOperand, rightOperand);</span>
1492 }
1493 
<span class="line-modified">1494 JSCell* JIT_OPERATION operationBitNotBigInt(JSGlobalObject* globalObject, JSCell* op1)</span>
1495 {
<span class="line-modified">1496     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1497     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1498     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1499 
1500     JSBigInt* operand = jsCast&lt;JSBigInt*&gt;(op1);
1501 
<span class="line-modified">1502     return JSBigInt::bitwiseNot(globalObject, operand);</span>
1503 }
1504 
<span class="line-modified">1505 JSCell* JIT_OPERATION operationMulBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
1506 {
<span class="line-modified">1507     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1508     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1509     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1510 
1511     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1512     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1513 
<span class="line-modified">1514     return JSBigInt::multiply(globalObject, leftOperand, rightOperand);</span>
1515 }
1516 
<span class="line-modified">1517 JSCell* JIT_OPERATION operationModBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
1518 {
<span class="line-modified">1519     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1520     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1521     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1522 
1523     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1524     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1525 
<span class="line-modified">1526     return JSBigInt::remainder(globalObject, leftOperand, rightOperand);</span>
1527 }
1528 
<span class="line-modified">1529 JSCell* JIT_OPERATION operationDivBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
1530 {
<span class="line-modified">1531     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1532     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1533     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1534 
1535     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1536     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1537 
<span class="line-modified">1538     return JSBigInt::divide(globalObject, leftOperand, rightOperand);</span>
1539 }
1540 
<span class="line-modified">1541 JSCell* JIT_OPERATION operationPowBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
1542 {
<span class="line-modified">1543     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1544     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1545     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1546 
1547     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1548     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1549 
<span class="line-modified">1550     return JSBigInt::exponentiate(globalObject, leftOperand, rightOperand);</span>
1551 }
1552 
<span class="line-modified">1553 JSCell* JIT_OPERATION operationBitAndBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
1554 {
<span class="line-modified">1555     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1556     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1557     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1558 
1559     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1560     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1561 
<span class="line-modified">1562     return JSBigInt::bitwiseAnd(globalObject, leftOperand, rightOperand);</span>
1563 }
1564 
<span class="line-modified">1565 JSCell* JIT_OPERATION operationBitLShiftBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
1566 {
<span class="line-modified">1567     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1568     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1569     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1570 
1571     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1572     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1573 
<span class="line-modified">1574     return JSBigInt::leftShift(globalObject, leftOperand, rightOperand);</span>
1575 }
1576 
<span class="line-modified">1577 JSCell* JIT_OPERATION operationAddBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
1578 {
<span class="line-modified">1579     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1580     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1581     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1582 
1583     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1584     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1585 
<span class="line-modified">1586     return JSBigInt::add(globalObject, leftOperand, rightOperand);</span>
1587 }
1588 
<span class="line-modified">1589 JSCell* JIT_OPERATION operationBitRShiftBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
1590 {
<span class="line-modified">1591     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1592     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1593     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1594 
1595     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1596     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1597 
<span class="line-modified">1598     return JSBigInt::signedRightShift(globalObject, leftOperand, rightOperand);</span>
1599 }
1600 
<span class="line-modified">1601 JSCell* JIT_OPERATION operationBitOrBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
1602 {
<span class="line-modified">1603     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1604     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1605     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1606 
1607     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
1608     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
1609 
<span class="line-modified">1610     return JSBigInt::bitwiseOr(globalObject, leftOperand, rightOperand);</span>
1611 }
1612 
<span class="line-modified">1613 JSCell* JIT_OPERATION operationBitXorBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
1614 {
<span class="line-modified">1615     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1616     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1617     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1618 </span>
<span class="line-added">1619     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);</span>
<span class="line-added">1620     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);</span>
1621 
<span class="line-modified">1622     return JSBigInt::bitwiseXor(globalObject, leftOperand, rightOperand);</span>
1623 }
1624 
<span class="line-modified">1625 size_t JIT_OPERATION operationCompareStrictEqCell(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
1626 {
<span class="line-modified">1627     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1628     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1629     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1630 </span>
<span class="line-added">1631     return JSValue::strictEqualSlowCaseInline(globalObject, op1, op2);</span>
<span class="line-added">1632 }</span>
<span class="line-added">1633 </span>
<span class="line-added">1634 size_t JIT_OPERATION operationSameValue(JSGlobalObject* globalObject, EncodedJSValue arg1, EncodedJSValue arg2)</span>
<span class="line-added">1635 {</span>
<span class="line-added">1636     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1637     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1638     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1639 </span>
<span class="line-added">1640     return sameValue(globalObject, JSValue::decode(arg1), JSValue::decode(arg2));</span>
<span class="line-added">1641 }</span>
<span class="line-added">1642 </span>
<span class="line-added">1643 EncodedJSValue JIT_OPERATION operationToPrimitive(JSGlobalObject* globalObject, EncodedJSValue value)</span>
<span class="line-added">1644 {</span>
<span class="line-added">1645     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1646     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1647     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1648 </span>
<span class="line-added">1649     return JSValue::encode(JSValue::decode(value).toPrimitive(globalObject));</span>
<span class="line-added">1650 }</span>
<span class="line-added">1651 </span>
<span class="line-added">1652 EncodedJSValue JIT_OPERATION operationToPropertyKey(JSGlobalObject* globalObject, EncodedJSValue value)</span>
<span class="line-added">1653 {</span>
<span class="line-added">1654     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1655     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1656     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1657 
<span class="line-modified">1658     return JSValue::encode(JSValue::decode(value).toPropertyKeyValue(globalObject));</span>
1659 }
1660 
<span class="line-modified">1661 EncodedJSValue JIT_OPERATION operationToNumber(JSGlobalObject* globalObject, EncodedJSValue value)</span>
1662 {
<span class="line-modified">1663     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1664     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1665     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1666 
<span class="line-modified">1667     return JSValue::encode(jsNumber(JSValue::decode(value).toNumber(globalObject)));</span>
1668 }
1669 
<span class="line-modified">1670 EncodedJSValue JIT_OPERATION operationToNumeric(JSGlobalObject* globalObject, EncodedJSValue value)</span>
1671 {
<span class="line-modified">1672     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1673     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1674     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1675 
<span class="line-modified">1676     auto variant = JSValue::decode(value).toNumeric(globalObject);</span>
<span class="line-added">1677     if (WTF::holds_alternative&lt;JSBigInt*&gt;(variant))</span>
<span class="line-added">1678         return JSValue::encode(WTF::get&lt;JSBigInt*&gt;(variant));</span>
<span class="line-added">1679     return JSValue::encode(jsNumber(WTF::get&lt;double&gt;(variant)));</span>
1680 }
1681 
<span class="line-modified">1682 EncodedJSValue JIT_OPERATION operationGetByValWithThis(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript)</span>
1683 {
<span class="line-modified">1684     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1685     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1686     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1687     auto scope = DECLARE_THROW_SCOPE(vm);
1688 
1689     JSValue baseValue = JSValue::decode(encodedBase);
1690     JSValue thisVal = JSValue::decode(encodedThis);
1691     JSValue subscript = JSValue::decode(encodedSubscript);
1692 
1693     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1694         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1695         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">1696             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(globalObject);</span>
1697             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1698             if (existingAtomString) {
1699                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
1700                     return JSValue::encode(result);
1701             }
1702         }
1703     }
1704 
1705     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
1706     if (subscript.isUInt32()) {
1707         uint32_t i = subscript.asUInt32();
1708         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
<span class="line-modified">1709             return JSValue::encode(asString(baseValue)-&gt;getIndex(globalObject, i));</span>
1710 
<span class="line-modified">1711         RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(globalObject, i, slot)));</span>
1712     }
1713 
<span class="line-modified">1714     baseValue.requireObjectCoercible(globalObject);</span>
1715     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1716 
<span class="line-modified">1717     auto property = subscript.toPropertyKey(globalObject);</span>
1718     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1719     RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(globalObject, property, slot)));</span>
1720 }
1721 
<span class="line-modified">1722 void JIT_OPERATION operationPutByIdWithThisStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)</span>
1723 {
<span class="line-modified">1724     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1725     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1726     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1727 
<span class="line-modified">1728     putWithThis&lt;true&gt;(globalObject, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));</span>
1729 }
1730 
<span class="line-modified">1731 void JIT_OPERATION operationPutByIdWithThis(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)</span>
1732 {
<span class="line-modified">1733     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1734     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1735     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1736 
<span class="line-modified">1737     putWithThis&lt;false&gt;(globalObject, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));</span>
1738 }
1739 
<span class="line-modified">1740 void JIT_OPERATION operationPutByValWithThisStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)</span>
1741 {
<span class="line-modified">1742     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1743     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1744     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1745     auto scope = DECLARE_THROW_SCOPE(vm);
1746 
<span class="line-modified">1747     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(globalObject);</span>
1748     RETURN_IF_EXCEPTION(scope, void());
1749     scope.release();
<span class="line-modified">1750     putWithThis&lt;true&gt;(globalObject, encodedBase, encodedThis, encodedValue, property);</span>
1751 }
1752 
<span class="line-modified">1753 void JIT_OPERATION operationPutByValWithThis(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)</span>
1754 {
<span class="line-modified">1755     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1756     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1757     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1758     auto scope = DECLARE_THROW_SCOPE(vm);
1759 
<span class="line-modified">1760     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(globalObject);</span>
1761     RETURN_IF_EXCEPTION(scope, void());
1762     scope.release();
<span class="line-modified">1763     putWithThis&lt;false&gt;(globalObject, encodedBase, encodedThis, encodedValue, property);</span>
1764 }
1765 
<span class="line-modified">1766 ALWAYS_INLINE static void defineDataProperty(JSGlobalObject* globalObject, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSValue value, int32_t attributes)</span>
1767 {
1768     PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes));
1769     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1770     if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
<span class="line-modified">1771         JSObject::defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
1772     else
<span class="line-modified">1773         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
1774 }
1775 
<span class="line-modified">1776 void JIT_OPERATION operationDefineDataProperty(JSGlobalObject* globalObject, JSObject* base, EncodedJSValue encodedProperty, EncodedJSValue encodedValue, int32_t attributes)</span>
1777 {
<span class="line-modified">1778     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1779     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1780     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1781     auto scope = DECLARE_THROW_SCOPE(vm);
1782 
<span class="line-modified">1783     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(globalObject);</span>
1784     RETURN_IF_EXCEPTION(scope, void());
1785     scope.release();
<span class="line-modified">1786     defineDataProperty(globalObject, vm, base, propertyName, JSValue::decode(encodedValue), attributes);</span>
1787 }
1788 
<span class="line-modified">1789 void JIT_OPERATION operationDefineDataPropertyString(JSGlobalObject* globalObject, JSObject* base, JSString* property, EncodedJSValue encodedValue, int32_t attributes)</span>
1790 {
<span class="line-modified">1791     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1792     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1793     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1794     auto scope = DECLARE_THROW_SCOPE(vm);
1795 
<span class="line-modified">1796     Identifier propertyName = property-&gt;toIdentifier(globalObject);</span>
1797     RETURN_IF_EXCEPTION(scope, void());
1798     scope.release();
<span class="line-modified">1799     defineDataProperty(globalObject, vm, base, propertyName, JSValue::decode(encodedValue), attributes);</span>
1800 }
1801 
<span class="line-modified">1802 void JIT_OPERATION operationDefineDataPropertyStringIdent(JSGlobalObject* globalObject, JSObject* base, UniquedStringImpl* property, EncodedJSValue encodedValue, int32_t attributes)</span>
1803 {
<span class="line-modified">1804     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1805     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">1806     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1807     defineDataProperty(globalObject, vm, base, Identifier::fromUid(vm, property), JSValue::decode(encodedValue), attributes);</span>
1808 }
1809 
<span class="line-modified">1810 void JIT_OPERATION operationDefineDataPropertySymbol(JSGlobalObject* globalObject, JSObject* base, Symbol* property, EncodedJSValue encodedValue, int32_t attributes)</span>
1811 {
<span class="line-modified">1812     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1813     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">1814     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1815     defineDataProperty(globalObject, vm, base, Identifier::fromUid(property-&gt;privateName()), JSValue::decode(encodedValue), attributes);</span>
1816 }
1817 
<span class="line-modified">1818 ALWAYS_INLINE static void defineAccessorProperty(JSGlobalObject* globalObject, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSObject* getter, JSObject* setter, int32_t attributes)</span>
1819 {
1820     PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes));
1821     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1822     if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
<span class="line-modified">1823         JSObject::defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
1824     else
<span class="line-modified">1825         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
1826 }
1827 
<span class="line-modified">1828 void JIT_OPERATION operationDefineAccessorProperty(JSGlobalObject* globalObject, JSObject* base, EncodedJSValue encodedProperty, JSObject* getter, JSObject* setter, int32_t attributes)</span>
1829 {
<span class="line-modified">1830     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1831     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1832     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1833     auto scope = DECLARE_THROW_SCOPE(vm);
1834 
<span class="line-modified">1835     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(globalObject);</span>
1836     RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">1837     defineAccessorProperty(globalObject, vm, base, propertyName, getter, setter, attributes);</span>
1838 }
1839 
<span class="line-modified">1840 void JIT_OPERATION operationDefineAccessorPropertyString(JSGlobalObject* globalObject, JSObject* base, JSString* property, JSObject* getter, JSObject* setter, int32_t attributes)</span>
1841 {
<span class="line-modified">1842     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1843     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1844     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1845     auto scope = DECLARE_THROW_SCOPE(vm);
1846 
<span class="line-modified">1847     Identifier propertyName = property-&gt;toIdentifier(globalObject);</span>
1848     RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">1849     defineAccessorProperty(globalObject, vm, base, propertyName, getter, setter, attributes);</span>
1850 }
1851 
<span class="line-modified">1852 void JIT_OPERATION operationDefineAccessorPropertyStringIdent(JSGlobalObject* globalObject, JSObject* base, UniquedStringImpl* property, JSObject* getter, JSObject* setter, int32_t attributes)</span>
1853 {
<span class="line-modified">1854     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1855     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">1856     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1857     defineAccessorProperty(globalObject, vm, base, Identifier::fromUid(vm, property), getter, setter, attributes);</span>
1858 }
1859 
<span class="line-modified">1860 void JIT_OPERATION operationDefineAccessorPropertySymbol(JSGlobalObject* globalObject, JSObject* base, Symbol* property, JSObject* getter, JSObject* setter, int32_t attributes)</span>
1861 {
<span class="line-modified">1862     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1863     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">1864     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1865     defineAccessorProperty(globalObject, vm, base, Identifier::fromUid(property-&gt;privateName()), getter, setter, attributes);</span>
1866 }
1867 
<span class="line-modified">1868 char* JIT_OPERATION operationNewArray(JSGlobalObject* globalObject, Structure* arrayStructure, void* buffer, size_t size)</span>
1869 {
<span class="line-modified">1870     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1871     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1872     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1873 
<span class="line-modified">1874     return bitwise_cast&lt;char*&gt;(constructArray(globalObject, arrayStructure, static_cast&lt;JSValue*&gt;(buffer), size));</span>
1875 }
1876 
<span class="line-modified">1877 char* JIT_OPERATION operationNewEmptyArray(VM* vmPointer, Structure* arrayStructure)</span>
1878 {
<span class="line-modified">1879     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">1880     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1881     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1882 
1883     return bitwise_cast&lt;char*&gt;(JSArray::create(vm, arrayStructure));
1884 }
1885 
<span class="line-modified">1886 char* JIT_OPERATION operationNewArrayWithSize(JSGlobalObject* globalObject, Structure* arrayStructure, int32_t size, Butterfly* butterfly)</span>
1887 {
<span class="line-modified">1888     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1889     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1890     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1891     auto scope = DECLARE_THROW_SCOPE(vm);
1892 
1893     if (UNLIKELY(size &lt; 0))
<span class="line-modified">1894         return bitwise_cast&lt;char*&gt;(throwException(globalObject, scope, createRangeError(globalObject, &quot;Array size is not a small enough positive integer.&quot;_s)));</span>
1895 
1896     JSArray* result;
1897     if (butterfly)
1898         result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
1899     else
1900         result = JSArray::create(vm, arrayStructure, size);
1901     return bitwise_cast&lt;char*&gt;(result);
1902 }
1903 
<span class="line-modified">1904 char* JIT_OPERATION operationNewArrayWithSizeAndHint(JSGlobalObject* globalObject, Structure* arrayStructure, int32_t size, int32_t vectorLengthHint, Butterfly* butterfly)</span>
1905 {
<span class="line-modified">1906     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1907     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1908     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1909     auto scope = DECLARE_THROW_SCOPE(vm);
1910 
1911     if (UNLIKELY(size &lt; 0))
<span class="line-modified">1912         return bitwise_cast&lt;char*&gt;(throwException(globalObject, scope, createRangeError(globalObject, &quot;Array size is not a small enough positive integer.&quot;_s)));</span>
1913 
1914     JSArray* result;
1915     if (butterfly)
1916         result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
1917     else {
1918         result = JSArray::tryCreate(vm, arrayStructure, size, vectorLengthHint);
1919         RELEASE_ASSERT(result);
1920     }
1921     return bitwise_cast&lt;char*&gt;(result);
1922 }
1923 
<span class="line-modified">1924 JSCell* JIT_OPERATION operationNewArrayBuffer(VM* vmPointer, Structure* arrayStructure, JSCell* immutableButterflyCell)</span>
1925 {
<span class="line-modified">1926     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">1927     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1928     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1929     ASSERT(!arrayStructure-&gt;outOfLineCapacity());
1930     auto* immutableButterfly = jsCast&lt;JSImmutableButterfly*&gt;(immutableButterflyCell);
1931     ASSERT(arrayStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode() || hasAnyArrayStorage(arrayStructure-&gt;indexingMode()));
1932     auto* result = CommonSlowPaths::allocateNewArrayBuffer(vm, arrayStructure, immutableButterfly);
1933     ASSERT(result-&gt;indexingMode() == result-&gt;structure(vm)-&gt;indexingMode());
1934     ASSERT(result-&gt;structure(vm) == arrayStructure);
1935     return result;
1936 }
1937 
1938 char* JIT_OPERATION operationNewInt8ArrayWithSize(
<span class="line-modified">1939     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
1940 {
<span class="line-modified">1941     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1942     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1943     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1944     return newTypedArrayWithSize&lt;JSInt8Array&gt;(globalObject, vm, structure, length, vector);</span>
1945 }
1946 
1947 char* JIT_OPERATION operationNewInt8ArrayWithOneArgument(
<span class="line-modified">1948     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
1949 {
<span class="line-modified">1950     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1951     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">1952     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1953     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt8Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
1954 }
1955 
1956 char* JIT_OPERATION operationNewInt16ArrayWithSize(
<span class="line-modified">1957     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
1958 {
<span class="line-modified">1959     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1960     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1961     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1962     return newTypedArrayWithSize&lt;JSInt16Array&gt;(globalObject, vm, structure, length, vector);</span>
1963 }
1964 
1965 char* JIT_OPERATION operationNewInt16ArrayWithOneArgument(
<span class="line-modified">1966     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
1967 {
<span class="line-modified">1968     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1969     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">1970     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1971     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt16Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
1972 }
1973 
1974 char* JIT_OPERATION operationNewInt32ArrayWithSize(
<span class="line-modified">1975     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
1976 {
<span class="line-modified">1977     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1978     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1979     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1980     return newTypedArrayWithSize&lt;JSInt32Array&gt;(globalObject, vm, structure, length, vector);</span>
1981 }
1982 
1983 char* JIT_OPERATION operationNewInt32ArrayWithOneArgument(
<span class="line-modified">1984     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
1985 {
<span class="line-modified">1986     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1987     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">1988     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1989     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt32Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
1990 }
1991 
1992 char* JIT_OPERATION operationNewUint8ArrayWithSize(
<span class="line-modified">1993     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
1994 {
<span class="line-modified">1995     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1996     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1997     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1998     return newTypedArrayWithSize&lt;JSUint8Array&gt;(globalObject, vm, structure, length, vector);</span>
1999 }
2000 
2001 char* JIT_OPERATION operationNewUint8ArrayWithOneArgument(
<span class="line-modified">2002     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
2003 {
<span class="line-modified">2004     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2005     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2006     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2007     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
2008 }
2009 
2010 char* JIT_OPERATION operationNewUint8ClampedArrayWithSize(
<span class="line-modified">2011     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
2012 {
<span class="line-modified">2013     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2014     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2015     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2016     return newTypedArrayWithSize&lt;JSUint8ClampedArray&gt;(globalObject, vm, structure, length, vector);</span>
2017 }
2018 
2019 char* JIT_OPERATION operationNewUint8ClampedArrayWithOneArgument(
<span class="line-modified">2020     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
2021 {
<span class="line-modified">2022     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2023     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2024     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2025     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8ClampedArray&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
2026 }
2027 
2028 char* JIT_OPERATION operationNewUint16ArrayWithSize(
<span class="line-modified">2029     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
2030 {
<span class="line-modified">2031     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2032     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2033     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2034     return newTypedArrayWithSize&lt;JSUint16Array&gt;(globalObject, vm, structure, length, vector);</span>
2035 }
2036 
2037 char* JIT_OPERATION operationNewUint16ArrayWithOneArgument(
<span class="line-modified">2038     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
2039 {
<span class="line-modified">2040     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2041     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2042     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2043     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint16Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
2044 }
2045 
2046 char* JIT_OPERATION operationNewUint32ArrayWithSize(
<span class="line-modified">2047     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
2048 {
<span class="line-modified">2049     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2050     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2051     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2052     return newTypedArrayWithSize&lt;JSUint32Array&gt;(globalObject, vm, structure, length, vector);</span>
2053 }
2054 
2055 char* JIT_OPERATION operationNewUint32ArrayWithOneArgument(
<span class="line-modified">2056     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
2057 {
<span class="line-modified">2058     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2059     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2060     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2061     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint32Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
2062 }
2063 
2064 char* JIT_OPERATION operationNewFloat32ArrayWithSize(
<span class="line-modified">2065     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
2066 {
<span class="line-modified">2067     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2068     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2069     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2070     return newTypedArrayWithSize&lt;JSFloat32Array&gt;(globalObject, vm, structure, length, vector);</span>
2071 }
2072 
2073 char* JIT_OPERATION operationNewFloat32ArrayWithOneArgument(
<span class="line-modified">2074     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
2075 {
<span class="line-modified">2076     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2077     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2078     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2079     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat32Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
2080 }
2081 
2082 char* JIT_OPERATION operationNewFloat64ArrayWithSize(
<span class="line-modified">2083     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
2084 {
<span class="line-modified">2085     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2086     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2087     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2088     return newTypedArrayWithSize&lt;JSFloat64Array&gt;(globalObject, vm, structure, length, vector);</span>
2089 }
2090 
2091 char* JIT_OPERATION operationNewFloat64ArrayWithOneArgument(
<span class="line-modified">2092     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
2093 {
<span class="line-modified">2094     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2095     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2096     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2097     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat64Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
<span class="line-added">2098 }</span>
<span class="line-added">2099 </span>
<span class="line-added">2100 JSCell* JIT_OPERATION operationNewArrayIterator(VM* vmPointer, Structure* structure)</span>
<span class="line-added">2101 {</span>
<span class="line-added">2102     VM&amp; vm = *vmPointer;</span>
<span class="line-added">2103     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2104     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2105 </span>
<span class="line-added">2106     return JSArrayIterator::createWithInitialValues(vm, structure);</span>
2107 }
2108 
<span class="line-modified">2109 JSCell* JIT_OPERATION operationCreateActivationDirect(VM* vmPointer, Structure* structure, JSScope* scope, SymbolTable* table, EncodedJSValue initialValueEncoded)</span>
2110 {
<span class="line-modified">2111     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2112     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2113     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2114     JSValue initialValue = JSValue::decode(initialValueEncoded);
2115     ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
2116     return JSLexicalEnvironment::create(vm, structure, scope, table, initialValue);
2117 }
2118 
<span class="line-modified">2119 JSCell* JIT_OPERATION operationCreateDirectArguments(VM* vmPointer, Structure* structure, uint32_t length, uint32_t minCapacity)</span>
2120 {
<span class="line-modified">2121     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2122     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2123     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2124     DirectArguments* result = DirectArguments::create(
2125         vm, structure, length, std::max(length, minCapacity));
2126     // The caller will store to this object without barriers. Most likely, at this point, this is
2127     // still a young object and so no barriers are needed. But it&#39;s good to be careful anyway,
2128     // since the GC should be allowed to do crazy (like pretenuring, for example).
2129     vm.heap.writeBarrier(result);
2130     return result;
2131 }
2132 
<span class="line-modified">2133 JSCell* JIT_OPERATION operationCreateScopedArguments(JSGlobalObject* globalObject, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee, JSLexicalEnvironment* scope)</span>
2134 {
<span class="line-modified">2135     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2136     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2137     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2138 
2139     // We could pass the ScopedArgumentsTable* as an argument. We currently don&#39;t because I
2140     // didn&#39;t feel like changing the max number of arguments for a slow path call from 6 to 7.
2141     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
2142 
2143     return ScopedArguments::createByCopyingFrom(
2144         vm, structure, argumentStart, length, callee, table, scope);
2145 }
2146 
<span class="line-modified">2147 JSCell* JIT_OPERATION operationCreateClonedArguments(JSGlobalObject* globalObject, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee)</span>
2148 {
<span class="line-modified">2149     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2150     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2151     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2152     return ClonedArguments::createByCopyingFrom(
<span class="line-modified">2153         globalObject, structure, argumentStart, length, callee);</span>
2154 }
2155 
<span class="line-modified">2156 JSCell* JIT_OPERATION operationCreateArgumentsButterfly(JSGlobalObject* globalObject, Register* argumentStart, uint32_t argumentCount)</span>
2157 {
<span class="line-modified">2158     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2159     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2160     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2161     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2162 </span>
<span class="line-added">2163     JSImmutableButterfly* butterfly = JSImmutableButterfly::tryCreate(vm, vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), argumentCount);</span>
<span class="line-added">2164     if (!butterfly) {</span>
<span class="line-added">2165         throwOutOfMemoryError(globalObject, scope);</span>
<span class="line-added">2166         return nullptr;</span>
<span class="line-added">2167     }</span>
<span class="line-added">2168     for (unsigned index = 0; index &lt; argumentCount; ++index)</span>
<span class="line-added">2169         butterfly-&gt;setIndex(vm, index, argumentStart[index].jsValue());</span>
<span class="line-added">2170     return butterfly;</span>
<span class="line-added">2171 }</span>
<span class="line-added">2172 </span>
<span class="line-added">2173 JSCell* JIT_OPERATION operationCreateDirectArgumentsDuringExit(VM* vmPointer, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)</span>
<span class="line-added">2174 {</span>
<span class="line-added">2175     VM&amp; vm = *vmPointer;</span>
<span class="line-added">2176     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2177     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2178 
2179     DeferGCForAWhile deferGC(vm.heap);
2180 
2181     CodeBlock* codeBlock;
2182     if (inlineCallFrame)
2183         codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
2184     else
<span class="line-modified">2185         codeBlock = callFrame-&gt;codeBlock();</span>
2186 
2187     unsigned length = argumentCount - 1;
2188     unsigned capacity = std::max(length, static_cast&lt;unsigned&gt;(codeBlock-&gt;numParameters() - 1));
2189     DirectArguments* result = DirectArguments::create(
2190         vm, codeBlock-&gt;globalObject()-&gt;directArgumentsStructure(), length, capacity);
2191 
2192     result-&gt;setCallee(vm, callee);
2193 
2194     Register* arguments =
<span class="line-modified">2195         callFrame-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +</span>
2196         CallFrame::argumentOffset(0);
2197     for (unsigned i = length; i--;)
2198         result-&gt;setIndexQuickly(vm, i, arguments[i].jsValue());
2199 
2200     return result;
2201 }
2202 
<span class="line-modified">2203 JSCell* JIT_OPERATION operationCreateClonedArgumentsDuringExit(VM* vmPointer, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)</span>
2204 {
<span class="line-modified">2205     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2206     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2207     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2208 
2209     DeferGCForAWhile deferGC(vm.heap);
2210 
2211     CodeBlock* codeBlock;
2212     if (inlineCallFrame)
2213         codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
2214     else
<span class="line-modified">2215         codeBlock = callFrame-&gt;codeBlock();</span>
2216 
2217     unsigned length = argumentCount - 1;
<span class="line-added">2218     JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
2219     ClonedArguments* result = ClonedArguments::createEmpty(
<span class="line-modified">2220         vm, globalObject-&gt;clonedArgumentsStructure(), callee, length);</span>
2221 
2222     Register* arguments =
<span class="line-modified">2223         callFrame-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +</span>
2224         CallFrame::argumentOffset(0);
2225     for (unsigned i = length; i--;)
<span class="line-modified">2226         result-&gt;putDirectIndex(globalObject, i, arguments[i].jsValue());</span>
2227 
2228 
2229     return result;
2230 }
2231 
<span class="line-modified">2232 JSCell* JIT_OPERATION operationCreateRest(JSGlobalObject* globalObject, Register* argumentStart, unsigned numberOfParamsToSkip, unsigned arraySize)</span>
2233 {
<span class="line-modified">2234     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2235     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2236     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2237 

2238     Structure* structure = globalObject-&gt;restParameterStructure();
2239     static_assert(sizeof(Register) == sizeof(JSValue), &quot;This is a strong assumption here.&quot;);
2240     JSValue* argumentsToCopyRegion = bitwise_cast&lt;JSValue*&gt;(argumentStart) + numberOfParamsToSkip;
<span class="line-modified">2241     return constructArray(globalObject, structure, argumentsToCopyRegion, arraySize);</span>
2242 }
2243 
<span class="line-modified">2244 size_t JIT_OPERATION operationObjectIsObject(JSGlobalObject* globalObject, JSCell* object)</span>
2245 {
<span class="line-modified">2246     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2247     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2248     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2249 
2250     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2251 
2252     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2253         return false;
2254     if (object-&gt;isFunction(vm))
2255         return false;
2256     return true;
2257 }
2258 
<span class="line-modified">2259 size_t JIT_OPERATION operationObjectIsFunction(JSGlobalObject* globalObject, JSCell* object)</span>
2260 {
<span class="line-modified">2261     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2262     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2263     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2264 
2265     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2266 
2267     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2268         return false;
2269     if (object-&gt;isFunction(vm))
2270         return true;
2271     return false;
2272 }
2273 
<span class="line-modified">2274 JSCell* JIT_OPERATION operationTypeOfObject(JSGlobalObject* globalObject, JSCell* object)</span>
2275 {
<span class="line-modified">2276     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2277     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2278     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2279 
2280     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2281 
2282     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2283         return vm.smallStrings.undefinedString();
2284     if (object-&gt;isFunction(vm))
2285         return vm.smallStrings.functionString();
2286     return vm.smallStrings.objectString();
2287 }
2288 
<span class="line-modified">2289 int32_t JIT_OPERATION operationTypeOfObjectAsTypeofType(JSGlobalObject* globalObject, JSCell* object)</span>
2290 {
<span class="line-modified">2291     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2292     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2293     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2294 
2295     ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
2296 
2297     if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
2298         return static_cast&lt;int32_t&gt;(TypeofType::Undefined);
2299     if (object-&gt;isFunction(vm))
2300         return static_cast&lt;int32_t&gt;(TypeofType::Function);
2301     return static_cast&lt;int32_t&gt;(TypeofType::Object);
2302 }
2303 
<span class="line-modified">2304 char* JIT_OPERATION operationAllocateSimplePropertyStorageWithInitialCapacity(VM* vmPointer)</span>
2305 {
<span class="line-modified">2306     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2307     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2308     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2309 
2310     return reinterpret_cast&lt;char*&gt;(
2311         Butterfly::createUninitialized(vm, 0, 0, initialOutOfLineCapacity, false, 0));
2312 }
2313 
<span class="line-modified">2314 char* JIT_OPERATION operationAllocateSimplePropertyStorage(VM* vmPointer, size_t newSize)</span>
2315 {
<span class="line-modified">2316     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2317     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2318     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2319 
2320     return reinterpret_cast&lt;char*&gt;(
2321         Butterfly::createUninitialized(vm, 0, 0, newSize, false, 0));
2322 }
2323 
<span class="line-modified">2324 char* JIT_OPERATION operationAllocateComplexPropertyStorageWithInitialCapacity(VM* vmPointer, JSObject* object)</span>
2325 {
<span class="line-modified">2326     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2327     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2328     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2329 
2330     ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
2331     return reinterpret_cast&lt;char*&gt;(
2332         object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity));
2333 }
2334 
<span class="line-modified">2335 char* JIT_OPERATION operationAllocateComplexPropertyStorage(VM* vmPointer, JSObject* object, size_t newSize)</span>
2336 {
<span class="line-modified">2337     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2338     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2339     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2340 
2341     return reinterpret_cast&lt;char*&gt;(
2342         object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize));
2343 }
2344 
<span class="line-modified">2345 char* JIT_OPERATION operationEnsureInt32(VM* vmPointer, JSCell* cell)</span>
2346 {
<span class="line-modified">2347     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2348     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2349     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2350 
2351     if (!cell-&gt;isObject())
2352         return 0;
2353 
2354     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableInt32(vm).data());
2355     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasInt32(cell-&gt;indexingMode())) || !result);
2356     return result;
2357 }
2358 
<span class="line-modified">2359 char* JIT_OPERATION operationEnsureDouble(VM* vmPointer, JSCell* cell)</span>
2360 {
<span class="line-modified">2361     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2362     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2363     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2364 
2365     if (!cell-&gt;isObject())
2366         return 0;
2367 
2368     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableDouble(vm).data());
2369     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasDouble(cell-&gt;indexingMode())) || !result);
2370     return result;
2371 }
2372 
<span class="line-modified">2373 char* JIT_OPERATION operationEnsureContiguous(VM* vmPointer, JSCell* cell)</span>
2374 {
<span class="line-modified">2375     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2376     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2377     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2378 
2379     if (!cell-&gt;isObject())
2380         return 0;
2381 
2382     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableContiguous(vm).data());
2383     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasContiguous(cell-&gt;indexingMode())) || !result);
2384     return result;
2385 }
2386 
<span class="line-modified">2387 char* JIT_OPERATION operationEnsureArrayStorage(VM* vmPointer, JSCell* cell)</span>
2388 {
<span class="line-modified">2389     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2390     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2391     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2392 
2393     if (!cell-&gt;isObject())
2394         return 0;
2395 
2396     auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;ensureArrayStorage(vm));
2397     ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasAnyArrayStorage(cell-&gt;indexingMode())) || !result);
2398     return result;
2399 }
2400 
<span class="line-modified">2401 EncodedJSValue JIT_OPERATION operationHasGenericProperty(JSGlobalObject* globalObject, EncodedJSValue encodedBaseValue, JSCell* property)</span>
2402 {
<span class="line-modified">2403     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2404     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2405     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2406     auto scope = DECLARE_THROW_SCOPE(vm);
2407 
2408     JSValue baseValue = JSValue::decode(encodedBaseValue);
2409     if (baseValue.isUndefinedOrNull())
2410         return JSValue::encode(jsBoolean(false));
2411 
<span class="line-modified">2412     JSObject* base = baseValue.toObject(globalObject);</span>
<span class="line-modified">2413     EXCEPTION_ASSERT(!scope.exception() || !base);</span>
2414     if (!base)
2415         return JSValue::encode(JSValue());
<span class="line-modified">2416     auto propertyName = asString(property)-&gt;toIdentifier(globalObject);</span>
2417     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">2418     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::GetOwnProperty))));</span>
2419 }
2420 
<span class="line-modified">2421 size_t JIT_OPERATION operationHasIndexedPropertyByInt(JSGlobalObject* globalObject, JSCell* baseCell, int32_t subscript, int32_t internalMethodType)</span>
2422 {
<span class="line-modified">2423     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2424     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2425     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2426     JSObject* object = baseCell-&gt;toObject(globalObject);</span>
2427     if (UNLIKELY(subscript &lt; 0)) {
2428         // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified">2429         return object-&gt;hasPropertyGeneric(globalObject, Identifier::from(vm, subscript), static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));</span>
2430     }
<span class="line-modified">2431     return object-&gt;hasPropertyGeneric(globalObject, subscript, static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));</span>
2432 }
2433 
<span class="line-modified">2434 JSCell* JIT_OPERATION operationGetPropertyEnumerator(JSGlobalObject* globalObject, EncodedJSValue encodedBase)</span>
2435 {
<span class="line-modified">2436     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2437     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2438     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2439     auto scope = DECLARE_THROW_SCOPE(vm);
2440 
2441     JSValue base = JSValue::decode(encodedBase);
2442     if (base.isUndefinedOrNull())
2443         return vm.emptyPropertyNameEnumerator();
2444 
<span class="line-modified">2445     JSObject* baseObject = base.toObject(globalObject);</span>
2446     RETURN_IF_EXCEPTION(scope, { });
2447 
<span class="line-modified">2448     RELEASE_AND_RETURN(scope, propertyNameEnumerator(globalObject, baseObject));</span>
2449 }
2450 
<span class="line-modified">2451 JSCell* JIT_OPERATION operationGetPropertyEnumeratorCell(JSGlobalObject* globalObject, JSCell* cell)</span>
2452 {
<span class="line-modified">2453     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2454     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2455     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2456     auto scope = DECLARE_THROW_SCOPE(vm);
2457 
<span class="line-modified">2458     JSObject* base = cell-&gt;toObject(globalObject);</span>
2459     RETURN_IF_EXCEPTION(scope, { });
2460 
<span class="line-modified">2461     RELEASE_AND_RETURN(scope, propertyNameEnumerator(globalObject, base));</span>
2462 }
2463 
<span class="line-modified">2464 JSCell* JIT_OPERATION operationToIndexString(JSGlobalObject* globalObject, int32_t index)</span>
2465 {
<span class="line-modified">2466     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2467     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2468     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2469     return jsString(vm, Identifier::from(vm, index).string());
2470 }
2471 
<span class="line-modified">2472 JSCell* JIT_OPERATION operationNewRegexpWithLastIndex(JSGlobalObject* globalObject, JSCell* regexpPtr, EncodedJSValue encodedLastIndex)</span>
2473 {
<span class="line-modified">2474     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2475     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2476     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2477 
2478     RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
2479     ASSERT(regexp-&gt;isValid());
<span class="line-modified">2480     return RegExpObject::create(vm, globalObject-&gt;regExpStructure(), regexp, JSValue::decode(encodedLastIndex));</span>
2481 }
2482 
<span class="line-modified">2483 StringImpl* JIT_OPERATION operationResolveRope(JSGlobalObject* globalObject, JSString* string)</span>
2484 {
<span class="line-modified">2485     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2486     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2487     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2488 
<span class="line-modified">2489     return string-&gt;value(globalObject).impl();</span>
2490 }
2491 
<span class="line-modified">2492 JSString* JIT_OPERATION operationStringValueOf(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)</span>
2493 {
<span class="line-modified">2494     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2495     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2496     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2497     auto scope = DECLARE_THROW_SCOPE(vm);
2498 
2499     JSValue argument = JSValue::decode(encodedArgument);
2500 
2501     if (argument.isString())
2502         return asString(argument);
2503 
2504     if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, argument))
2505         return stringObject-&gt;internalValue();
2506 
<span class="line-modified">2507     throwVMTypeError(globalObject, scope);</span>
2508     return nullptr;
2509 }
2510 
<span class="line-modified">2511 JSCell* JIT_OPERATION operationStringSubstr(JSGlobalObject* globalObject, JSCell* cell, int32_t from, int32_t span)</span>
2512 {
<span class="line-modified">2513     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2514     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2515     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2516 
<span class="line-modified">2517     return jsSubstring(vm, globalObject, jsCast&lt;JSString*&gt;(cell), from, span);</span>
2518 }
2519 
<span class="line-modified">2520 JSCell* JIT_OPERATION operationStringSlice(JSGlobalObject* globalObject, JSCell* cell, int32_t start, int32_t end)</span>
2521 {
<span class="line-modified">2522     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2523     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2524     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2525 
2526     JSString* string = asString(cell);
2527     static_assert(static_cast&lt;uint64_t&gt;(JSString::MaxLength) &lt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()), &quot;&quot;);
<span class="line-modified">2528     return stringSlice(globalObject, vm, string, string-&gt;length(), start, end);</span>
2529 }
2530 
<span class="line-modified">2531 JSString* JIT_OPERATION operationToLowerCase(JSGlobalObject* globalObject, JSString* string, uint32_t failingIndex)</span>
2532 {
<span class="line-modified">2533     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2534     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2535     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2536 
2537     auto scope = DECLARE_THROW_SCOPE(vm);
2538 
<span class="line-modified">2539     String inputString = string-&gt;value(globalObject);</span>
2540     RETURN_IF_EXCEPTION(scope, nullptr);
2541     if (!inputString.length())
2542         return vm.smallStrings.emptyString();
2543 
2544     String lowercasedString = inputString.is8Bit() ? inputString.convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(failingIndex) : inputString.convertToLowercaseWithoutLocale();
2545     if (lowercasedString.impl() == inputString.impl())
2546         return string;
2547     RELEASE_AND_RETURN(scope, jsString(vm, lowercasedString));
2548 }
2549 
<span class="line-modified">2550 char* JIT_OPERATION operationInt32ToString(JSGlobalObject* globalObject, int32_t value, int32_t radix)</span>
2551 {
<span class="line-modified">2552     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2553     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2554     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2555 
2556     auto scope = DECLARE_THROW_SCOPE(vm);
2557 
2558     if (radix &lt; 2 || radix &gt; 36) {
<span class="line-modified">2559         throwVMError(globalObject, scope, createRangeError(globalObject, &quot;toString() radix argument must be between 2 and 36&quot;_s));</span>
2560         return nullptr;
2561     }
2562 
2563     return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
2564 }
2565 
<span class="line-modified">2566 char* JIT_OPERATION operationInt52ToString(JSGlobalObject* globalObject, int64_t value, int32_t radix)</span>
2567 {
<span class="line-modified">2568     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2569     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2570     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2571 
2572     auto scope = DECLARE_THROW_SCOPE(vm);
2573 
2574     if (radix &lt; 2 || radix &gt; 36) {
<span class="line-modified">2575         throwVMError(globalObject, scope, createRangeError(globalObject, &quot;toString() radix argument must be between 2 and 36&quot;_s));</span>
2576         return nullptr;
2577     }
2578 
2579     return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
2580 }
2581 
<span class="line-modified">2582 char* JIT_OPERATION operationDoubleToString(JSGlobalObject* globalObject, double value, int32_t radix)</span>
2583 {
<span class="line-modified">2584     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2585     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2586     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2587 
2588     auto scope = DECLARE_THROW_SCOPE(vm);
2589 
2590     if (radix &lt; 2 || radix &gt; 36) {
<span class="line-modified">2591         throwVMError(globalObject, scope, createRangeError(globalObject, &quot;toString() radix argument must be between 2 and 36&quot;_s));</span>
2592         return nullptr;
2593     }
2594 
2595     return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
2596 }
2597 
<span class="line-modified">2598 char* JIT_OPERATION operationInt32ToStringWithValidRadix(JSGlobalObject* globalObject, int32_t value, int32_t radix)</span>
2599 {
<span class="line-modified">2600     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2601     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2602     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2603 
2604     return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
2605 }
2606 
<span class="line-modified">2607 char* JIT_OPERATION operationInt52ToStringWithValidRadix(JSGlobalObject* globalObject, int64_t value, int32_t radix)</span>
2608 {
<span class="line-modified">2609     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2610     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2611     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2612 
2613     return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
2614 }
2615 
<span class="line-modified">2616 char* JIT_OPERATION operationDoubleToStringWithValidRadix(JSGlobalObject* globalObject, double value, int32_t radix)</span>
2617 {
<span class="line-modified">2618     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2619     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2620     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2621 
2622     return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
2623 }
2624 
<span class="line-modified">2625 JSString* JIT_OPERATION operationSingleCharacterString(VM* vmPointer, int32_t character)</span>
2626 {
<span class="line-modified">2627     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2628     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2629     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2630 
2631     return jsSingleCharacterString(vm, static_cast&lt;UChar&gt;(character));
2632 }
2633 
<span class="line-modified">2634 Symbol* JIT_OPERATION operationNewSymbol(VM* vmPointer)</span>
2635 {
<span class="line-modified">2636     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2637     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2638     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2639 
2640     return Symbol::create(vm);
2641 }
2642 
<span class="line-modified">2643 Symbol* JIT_OPERATION operationNewSymbolWithDescription(JSGlobalObject* globalObject, JSString* description)</span>
2644 {
<span class="line-modified">2645     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2646     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2647     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2648     auto scope = DECLARE_THROW_SCOPE(vm);
2649 
<span class="line-modified">2650     String string = description-&gt;value(globalObject);</span>
2651     RETURN_IF_EXCEPTION(scope, nullptr);
2652 
2653     return Symbol::createWithDescription(vm, string);
2654 }
2655 
<span class="line-modified">2656 JSCell* JIT_OPERATION operationNewStringObject(VM* vmPointer, JSString* string, Structure* structure)</span>
2657 {
<span class="line-modified">2658     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2659     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2660     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2661 
2662     return StringObject::create(vm, structure, string);
2663 }
2664 
<span class="line-modified">2665 JSString* JIT_OPERATION operationToStringOnCell(JSGlobalObject* globalObject, JSCell* cell)</span>
2666 {
<span class="line-modified">2667     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2668     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2669     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2670 
<span class="line-modified">2671     return JSValue(cell).toString(globalObject);</span>
2672 }
2673 
<span class="line-modified">2674 JSString* JIT_OPERATION operationToString(JSGlobalObject* globalObject, EncodedJSValue value)</span>
2675 {
<span class="line-modified">2676     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2677     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2678     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2679 
<span class="line-modified">2680     return JSValue::decode(value).toString(globalObject);</span>
2681 }
2682 
<span class="line-modified">2683 JSString* JIT_OPERATION operationCallStringConstructorOnCell(JSGlobalObject* globalObject, JSCell* cell)</span>
2684 {
<span class="line-modified">2685     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2686     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2687     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2688 
<span class="line-modified">2689     return stringConstructor(globalObject, cell);</span>
2690 }
2691 
<span class="line-modified">2692 JSString* JIT_OPERATION operationCallStringConstructor(JSGlobalObject* globalObject, EncodedJSValue value)</span>
2693 {
<span class="line-modified">2694     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2695     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2696     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2697 
<span class="line-modified">2698     return stringConstructor(globalObject, JSValue::decode(value));</span>
2699 }
2700 
<span class="line-modified">2701 JSString* JIT_OPERATION operationMakeRope2(JSGlobalObject* globalObject, JSString* left, JSString* right)</span>
2702 {
<span class="line-modified">2703     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2704     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2705     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2706 
<span class="line-modified">2707     return jsString(globalObject, left, right);</span>
2708 }
2709 
<span class="line-modified">2710 JSString* JIT_OPERATION operationMakeRope3(JSGlobalObject* globalObject, JSString* a, JSString* b, JSString* c)</span>
2711 {
<span class="line-modified">2712     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2713     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2714     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2715 
<span class="line-modified">2716     return jsString(globalObject, a, b, c);</span>
2717 }
2718 
<span class="line-modified">2719 JSString* JIT_OPERATION operationStrCat2(JSGlobalObject* globalObject, EncodedJSValue a, EncodedJSValue b)</span>
2720 {
<span class="line-modified">2721     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2722     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2723     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2724     auto scope = DECLARE_THROW_SCOPE(vm);
2725 
2726     ASSERT(!JSValue::decode(a).isSymbol());
2727     ASSERT(!JSValue::decode(b).isSymbol());
<span class="line-modified">2728     JSString* str1 = JSValue::decode(a).toString(globalObject);</span>
2729     scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
<span class="line-modified">2730     JSString* str2 = JSValue::decode(b).toString(globalObject);</span>
2731     scope.assertNoException();
2732 
<span class="line-modified">2733     RELEASE_AND_RETURN(scope, jsString(globalObject, str1, str2));</span>
2734 }
2735 
<span class="line-modified">2736 JSString* JIT_OPERATION operationStrCat3(JSGlobalObject* globalObject, EncodedJSValue a, EncodedJSValue b, EncodedJSValue c)</span>
2737 {
<span class="line-modified">2738     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2739     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2740     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2741     auto scope = DECLARE_THROW_SCOPE(vm);
2742 
2743     ASSERT(!JSValue::decode(a).isSymbol());
2744     ASSERT(!JSValue::decode(b).isSymbol());
2745     ASSERT(!JSValue::decode(c).isSymbol());
<span class="line-modified">2746     JSString* str1 = JSValue::decode(a).toString(globalObject);</span>
2747     scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
<span class="line-modified">2748     JSString* str2 = JSValue::decode(b).toString(globalObject);</span>
2749     scope.assertNoException();
<span class="line-modified">2750     JSString* str3 = JSValue::decode(c).toString(globalObject);</span>
2751     scope.assertNoException();
2752 
<span class="line-modified">2753     RELEASE_AND_RETURN(scope, jsString(globalObject, str1, str2, str3));</span>
2754 }
2755 
<span class="line-modified">2756 char* JIT_OPERATION operationFindSwitchImmTargetForDouble(VM* vmPointer, EncodedJSValue encodedValue, size_t tableIndex)</span>

2757 {
<span class="line-modified">2758     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2759     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2760     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2761     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
2762     SimpleJumpTable&amp; table = codeBlock-&gt;switchJumpTable(tableIndex);
2763     JSValue value = JSValue::decode(encodedValue);
2764     ASSERT(value.isDouble());
2765     double asDouble = value.asDouble();
2766     int32_t asInt32 = static_cast&lt;int32_t&gt;(asDouble);
2767     if (asDouble == asInt32)
2768         return table.ctiForValue(asInt32).executableAddress&lt;char*&gt;();
2769     return table.ctiDefault.executableAddress&lt;char*&gt;();
2770 }
2771 
<span class="line-modified">2772 char* JIT_OPERATION operationSwitchString(JSGlobalObject* globalObject, size_t tableIndex, JSString* string)</span>
2773 {
<span class="line-modified">2774     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2775     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2776     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2777     auto throwScope = DECLARE_THROW_SCOPE(vm);
2778 
<span class="line-modified">2779     StringImpl* strImpl = string-&gt;value(globalObject).impl();</span>
2780 
2781     RETURN_IF_EXCEPTION(throwScope, nullptr);
2782 
<span class="line-modified">2783     return callFrame-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).ctiForValue(strImpl).executableAddress&lt;char*&gt;();</span>
2784 }
2785 
<span class="line-modified">2786 int32_t JIT_OPERATION operationSwitchStringAndGetBranchOffset(JSGlobalObject* globalObject, size_t tableIndex, JSString* string)</span>
2787 {
<span class="line-modified">2788     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2789     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2790     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2791     auto throwScope = DECLARE_THROW_SCOPE(vm);
2792 
<span class="line-modified">2793     StringImpl* strImpl = string-&gt;value(globalObject).impl();</span>
2794 
2795     RETURN_IF_EXCEPTION(throwScope, 0);
2796 
<span class="line-modified">2797     return callFrame-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).offsetForValue(strImpl, std::numeric_limits&lt;int32_t&gt;::min());</span>
2798 }
2799 
2800 uintptr_t JIT_OPERATION operationCompareStringImplLess(StringImpl* a, StringImpl* b)
2801 {
2802     return codePointCompare(a, b) &lt; 0;
2803 }
2804 
2805 uintptr_t JIT_OPERATION operationCompareStringImplLessEq(StringImpl* a, StringImpl* b)
2806 {
2807     return codePointCompare(a, b) &lt;= 0;
2808 }
2809 
2810 uintptr_t JIT_OPERATION operationCompareStringImplGreater(StringImpl* a, StringImpl* b)
2811 {
2812     return codePointCompare(a, b) &gt; 0;
2813 }
2814 
2815 uintptr_t JIT_OPERATION operationCompareStringImplGreaterEq(StringImpl* a, StringImpl* b)
2816 {
2817     return codePointCompare(a, b) &gt;= 0;
2818 }
2819 
<span class="line-modified">2820 uintptr_t JIT_OPERATION operationCompareStringLess(JSGlobalObject* globalObject, JSString* a, JSString* b)</span>
2821 {
<span class="line-modified">2822     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2823     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2824     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2825 
<span class="line-modified">2826     return codePointCompareLessThan(asString(a)-&gt;value(globalObject), asString(b)-&gt;value(globalObject));</span>
2827 }
2828 
<span class="line-modified">2829 uintptr_t JIT_OPERATION operationCompareStringLessEq(JSGlobalObject* globalObject, JSString* a, JSString* b)</span>
2830 {
<span class="line-modified">2831     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2832     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2833     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2834 
<span class="line-modified">2835     return !codePointCompareLessThan(asString(b)-&gt;value(globalObject), asString(a)-&gt;value(globalObject));</span>
2836 }
2837 
<span class="line-modified">2838 uintptr_t JIT_OPERATION operationCompareStringGreater(JSGlobalObject* globalObject, JSString* a, JSString* b)</span>
2839 {
<span class="line-modified">2840     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2841     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2842     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2843 
<span class="line-modified">2844     return codePointCompareLessThan(asString(b)-&gt;value(globalObject), asString(a)-&gt;value(globalObject));</span>
2845 }
2846 
<span class="line-modified">2847 uintptr_t JIT_OPERATION operationCompareStringGreaterEq(JSGlobalObject* globalObject, JSString* a, JSString* b)</span>
2848 {
<span class="line-modified">2849     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2850     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2851     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2852 
<span class="line-modified">2853     return !codePointCompareLessThan(asString(a)-&gt;value(globalObject), asString(b)-&gt;value(globalObject));</span>
2854 }
2855 
<span class="line-modified">2856 void JIT_OPERATION operationNotifyWrite(VM* vmPointer, WatchpointSet* set)</span>
2857 {
<span class="line-modified">2858     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2859     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2860     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2861 
2862     set-&gt;touch(vm, &quot;Executed NotifyWrite&quot;);
2863 }
2864 
<span class="line-modified">2865 void JIT_OPERATION operationThrowStackOverflowForVarargs(JSGlobalObject* globalObject)</span>
2866 {
<span class="line-modified">2867     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2868     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2869     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2870     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2871     throwStackOverflowError(globalObject, scope);</span>
2872 }
2873 
<span class="line-modified">2874 int32_t JIT_OPERATION operationSizeOfVarargs(JSGlobalObject* globalObject, EncodedJSValue encodedArguments, uint32_t firstVarArgOffset)</span>
2875 {
<span class="line-modified">2876     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2877     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2878     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2879     JSValue arguments = JSValue::decode(encodedArguments);
2880 
<span class="line-modified">2881     return sizeOfVarargs(globalObject, arguments, firstVarArgOffset);</span>
2882 }
2883 
<span class="line-modified">2884 int32_t JIT_OPERATION operationHasOwnProperty(JSGlobalObject* globalObject, JSObject* thisObject, EncodedJSValue encodedKey)</span>
2885 {
<span class="line-modified">2886     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2887     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2888     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2889     auto scope = DECLARE_THROW_SCOPE(vm);
2890 
2891     JSValue key = JSValue::decode(encodedKey);
<span class="line-modified">2892     Identifier propertyName = key.toPropertyKey(globalObject);</span>
2893     RETURN_IF_EXCEPTION(scope, false);
2894 
2895     PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">2896     bool result = thisObject-&gt;hasOwnProperty(globalObject, propertyName.impl(), slot);</span>
2897     RETURN_IF_EXCEPTION(scope, false);
2898 
2899     HasOwnPropertyCache* hasOwnPropertyCache = vm.hasOwnPropertyCache();
2900     ASSERT(hasOwnPropertyCache);
2901     hasOwnPropertyCache-&gt;tryAdd(vm, slot, thisObject, propertyName.impl(), result);
2902     return result;
2903 }
2904 
<span class="line-modified">2905 int32_t JIT_OPERATION operationNumberIsInteger(JSGlobalObject* globalObject, EncodedJSValue value)</span>
2906 {
<span class="line-modified">2907     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2908     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2909     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2910     return NumberConstructor::isIntegerImpl(JSValue::decode(value));
2911 }
2912 
<span class="line-modified">2913 int32_t JIT_OPERATION operationArrayIndexOfString(JSGlobalObject* globalObject, Butterfly* butterfly, JSString* searchElement, int32_t index)</span>
2914 {
<span class="line-modified">2915     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2916     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2917     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2918     auto scope = DECLARE_THROW_SCOPE(vm);
2919 
2920     int32_t length = butterfly-&gt;publicLength();
2921     auto data = butterfly-&gt;contiguous().data();
2922     for (; index &lt; length; ++index) {
2923         JSValue value = data[index].get();
2924         if (!value || !value.isString())
2925             continue;
2926         auto* string = asString(value);
2927         if (string == searchElement)
2928             return index;
<span class="line-modified">2929         if (string-&gt;equal(globalObject, searchElement)) {</span>
2930             scope.assertNoException();
2931             return index;
2932         }
2933         RETURN_IF_EXCEPTION(scope, { });
2934     }
2935     return -1;
2936 }
2937 
<span class="line-modified">2938 int32_t JIT_OPERATION operationArrayIndexOfValueInt32OrContiguous(JSGlobalObject* globalObject, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)</span>
2939 {
<span class="line-modified">2940     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2941     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2942     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2943     auto scope = DECLARE_THROW_SCOPE(vm);
2944 
2945     JSValue searchElement = JSValue::decode(encodedValue);
2946 
2947     int32_t length = butterfly-&gt;publicLength();
2948     auto data = butterfly-&gt;contiguous().data();
2949     for (; index &lt; length; ++index) {
2950         JSValue value = data[index].get();
2951         if (!value)
2952             continue;
<span class="line-modified">2953         bool isEqual = JSValue::strictEqual(globalObject, searchElement, value);</span>
2954         RETURN_IF_EXCEPTION(scope, { });
2955         if (isEqual)
2956             return index;
2957     }
2958     return -1;
2959 }
2960 
<span class="line-modified">2961 int32_t JIT_OPERATION operationArrayIndexOfValueDouble(JSGlobalObject* globalObject, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)</span>
2962 {
<span class="line-modified">2963     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2964     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2965     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2966 
2967     JSValue searchElement = JSValue::decode(encodedValue);
2968 
2969     if (!searchElement.isNumber())
2970         return -1;
2971     double number = searchElement.asNumber();
2972 
2973     int32_t length = butterfly-&gt;publicLength();
2974     const double* data = butterfly-&gt;contiguousDouble().data();
2975     for (; index &lt; length; ++index) {
2976         // This comparison ignores NaN.
2977         if (data[index] == number)
2978             return index;
2979     }
2980     return -1;
2981 }
2982 
<span class="line-modified">2983 void JIT_OPERATION operationLoadVarargs(JSGlobalObject* globalObject, int32_t firstElementDest, EncodedJSValue encodedArguments, uint32_t offset, uint32_t lengthIncludingThis, uint32_t mandatoryMinimum)</span>
2984 {
<span class="line-modified">2985     VirtualRegister firstElement { firstElementDest };</span>
<span class="line-modified">2986     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2987     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2988     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2989     JSValue arguments = JSValue::decode(encodedArguments);
2990 
<span class="line-modified">2991     loadVarargs(globalObject, bitwise_cast&lt;JSValue*&gt;(&amp;callFrame-&gt;r(firstElement)), arguments, offset, lengthIncludingThis - 1);</span>
2992 
<span class="line-modified">2993     for (uint32_t i = lengthIncludingThis - 1; i &lt; mandatoryMinimum; ++i)</span>
<span class="line-modified">2994         callFrame-&gt;r(firstElement + i) = jsUndefined();</span>
2995 }
2996 
2997 double JIT_OPERATION operationFModOnInts(int32_t a, int32_t b)
2998 {
2999     return fmod(a, b);
3000 }
3001 
3002 #if USE(JSVALUE32_64)
3003 double JIT_OPERATION operationRandom(JSGlobalObject* globalObject)
3004 {
3005     return globalObject-&gt;weakRandomNumber();
3006 }
3007 #endif
3008 
<span class="line-modified">3009 JSCell* JIT_OPERATION operationStringFromCharCode(JSGlobalObject* globalObject, int32_t op1)</span>
3010 {
<span class="line-modified">3011     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3012     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">3013     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3014     return JSC::stringFromCharCode(globalObject, op1);</span>
3015 }
3016 
<span class="line-modified">3017 EncodedJSValue JIT_OPERATION operationStringFromCharCodeUntyped(JSGlobalObject* globalObject, EncodedJSValue encodedValue)</span>
3018 {
<span class="line-modified">3019     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3020     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3021     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3022     JSValue charValue = JSValue::decode(encodedValue);
<span class="line-modified">3023     int32_t chInt = charValue.toUInt32(globalObject);</span>
<span class="line-modified">3024     return JSValue::encode(JSC::stringFromCharCode(globalObject, chInt));</span>
3025 }
3026 
3027 int64_t JIT_OPERATION operationConvertBoxedDoubleToInt52(EncodedJSValue encodedValue)
3028 {
3029     JSValue value = JSValue::decode(encodedValue);
3030     if (!value.isDouble())
3031         return JSValue::notInt52;
3032     return tryConvertToInt52(value.asDouble());
3033 }
3034 
3035 int64_t JIT_OPERATION operationConvertDoubleToInt52(double value)
3036 {
3037     return tryConvertToInt52(value);
3038 }
3039 
<span class="line-modified">3040 char* JIT_OPERATION operationNewRawObject(VM* vmPointer, Structure* structure, int32_t length, Butterfly* butterfly)</span>
3041 {
<span class="line-modified">3042     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">3043     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3044     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3045 
3046     if (!butterfly
3047         &amp;&amp; (structure-&gt;outOfLineCapacity() || hasIndexedProperties(structure-&gt;indexingType()))) {
3048         IndexingHeader header;
3049         header.setVectorLength(length);
3050         header.setPublicLength(0);
3051 
3052         butterfly = Butterfly::create(
3053             vm, nullptr, 0, structure-&gt;outOfLineCapacity(),
3054             hasIndexedProperties(structure-&gt;indexingType()), header,
3055             length * sizeof(EncodedJSValue));
3056     }
3057 
<span class="line-modified">3058     JSObject* result = JSObject::createRawObject(vm, structure, butterfly);</span>

3059     return bitwise_cast&lt;char*&gt;(result);
3060 }
3061 
<span class="line-modified">3062 JSCell* JIT_OPERATION operationNewObjectWithButterfly(VM* vmPointer, Structure* structure, Butterfly* butterfly)</span>
3063 {
<span class="line-modified">3064     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">3065     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3066     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3067 
3068     if (!butterfly) {
3069         butterfly = Butterfly::create(
3070             vm, nullptr, 0, structure-&gt;outOfLineCapacity(), false, IndexingHeader(), 0);
3071     }
3072 
<span class="line-modified">3073     JSObject* result = JSObject::createRawObject(vm, structure, butterfly);</span>

3074     return result;
3075 }
3076 
<span class="line-modified">3077 JSCell* JIT_OPERATION operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength(VM* vmPointer, Structure* structure, unsigned length, Butterfly* butterfly)</span>
3078 {
<span class="line-modified">3079     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">3080     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3081     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3082 
3083     IndexingHeader header;
3084     header.setVectorLength(length);
3085     header.setPublicLength(0);
3086     if (butterfly)
3087         *butterfly-&gt;indexingHeader() = header;
3088     else {
3089         butterfly = Butterfly::create(
3090             vm, nullptr, 0, structure-&gt;outOfLineCapacity(), true, header,
3091             sizeof(EncodedJSValue) * length);
3092     }
3093 
3094     // Paradoxically this may allocate a JSArray. That&#39;s totally cool.
<span class="line-modified">3095     JSObject* result = JSObject::createRawObject(vm, structure, butterfly);</span>

3096     return result;
3097 }
3098 
<span class="line-modified">3099 JSCell* JIT_OPERATION operationNewArrayWithSpreadSlow(JSGlobalObject* globalObject, void* buffer, uint32_t numItems)</span>
3100 {
<span class="line-modified">3101     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3102     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3103     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3104     auto scope = DECLARE_THROW_SCOPE(vm);
3105 
3106     EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
3107     Checked&lt;unsigned, RecordOverflow&gt; checkedLength = 0;
3108     for (unsigned i = 0; i &lt; numItems; i++) {
3109         JSValue value = JSValue::decode(values[i]);
<span class="line-modified">3110         if (JSImmutableButterfly* array = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, value))</span>
<span class="line-modified">3111             checkedLength += array-&gt;publicLength();</span>
3112         else
3113             ++checkedLength;
3114     }
3115 
3116     if (UNLIKELY(checkedLength.hasOverflowed())) {
<span class="line-modified">3117         throwOutOfMemoryError(globalObject, scope);</span>
3118         return nullptr;
3119     }
3120 
3121     unsigned length = checkedLength.unsafeGet();
3122     if (UNLIKELY(length &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)) {
<span class="line-modified">3123         throwOutOfMemoryError(globalObject, scope);</span>
3124         return nullptr;
3125     }
3126 

3127     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
3128 
3129     JSArray* result = JSArray::tryCreate(vm, structure, length);
3130     if (UNLIKELY(!result)) {
<span class="line-modified">3131         throwOutOfMemoryError(globalObject, scope);</span>
3132         return nullptr;
3133     }
3134     RETURN_IF_EXCEPTION(scope, nullptr);
3135 
3136     unsigned index = 0;
3137     for (unsigned i = 0; i &lt; numItems; i++) {
3138         JSValue value = JSValue::decode(values[i]);
<span class="line-modified">3139         if (JSImmutableButterfly* array = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, value)) {</span>
3140             // We are spreading.
<span class="line-modified">3141             for (unsigned i = 0; i &lt; array-&gt;publicLength(); i++) {</span>
<span class="line-modified">3142                 result-&gt;putDirectIndex(globalObject, index, array-&gt;get(i));</span>
3143                 RETURN_IF_EXCEPTION(scope, nullptr);
3144                 ++index;
3145             }
3146         } else {
3147             // We are not spreading.
<span class="line-modified">3148             result-&gt;putDirectIndex(globalObject, index, value);</span>
3149             RETURN_IF_EXCEPTION(scope, nullptr);
3150             ++index;
3151         }
3152     }
3153 
3154     return result;
3155 }
3156 
<span class="line-modified">3157 JSCell* operationCreateImmutableButterfly(JSGlobalObject* globalObject, unsigned length)</span>
3158 {
<span class="line-modified">3159     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3160     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3161     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3162     auto scope = DECLARE_THROW_SCOPE(vm);
3163 
<span class="line-modified">3164     if (JSImmutableButterfly* result = JSImmutableButterfly::tryCreate(vm, vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), length))</span>
3165         return result;
3166 
<span class="line-modified">3167     throwOutOfMemoryError(globalObject, scope);</span>
3168     return nullptr;
3169 }
3170 
<span class="line-modified">3171 JSCell* JIT_OPERATION operationSpreadGeneric(JSGlobalObject* globalObject, JSCell* iterable)</span>
3172 {
<span class="line-modified">3173     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3174     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3175     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3176 
3177     auto throwScope = DECLARE_THROW_SCOPE(vm);
3178 
3179     if (isJSArray(iterable)) {
3180         JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
3181         if (array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">3182             RELEASE_AND_RETURN(throwScope, JSImmutableButterfly::createFromArray(globalObject, vm, array));</span>
3183     }
3184 
3185     // FIXME: we can probably make this path faster by having our caller JS code call directly into
3186     // the iteration protocol builtin: https://bugs.webkit.org/show_bug.cgi?id=164520
3187 

3188     JSArray* array;
3189     {
3190         JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
3191         CallData callData;
3192         CallType callType = JSC::getCallData(vm, iterationFunction, callData);
3193         ASSERT(callType != CallType::None);
3194 
3195         MarkedArgumentBuffer arguments;
3196         arguments.append(iterable);
3197         ASSERT(!arguments.hasOverflowed());
<span class="line-modified">3198         JSValue arrayResult = call(globalObject, iterationFunction, callType, callData, jsNull(), arguments);</span>
3199         RETURN_IF_EXCEPTION(throwScope, nullptr);
3200         array = jsCast&lt;JSArray*&gt;(arrayResult);
3201     }
3202 
<span class="line-modified">3203     RELEASE_AND_RETURN(throwScope, JSImmutableButterfly::createFromArray(globalObject, vm, array));</span>
3204 }
3205 
<span class="line-modified">3206 JSCell* JIT_OPERATION operationSpreadFastArray(JSGlobalObject* globalObject, JSCell* cell)</span>
3207 {
<span class="line-modified">3208     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3209     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3210     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3211 
3212     ASSERT(isJSArray(cell));
3213     JSArray* array = jsCast&lt;JSArray*&gt;(cell);
3214     ASSERT(array-&gt;isIteratorProtocolFastAndNonObservable());
3215 
<span class="line-modified">3216     return JSImmutableButterfly::createFromArray(globalObject, vm, array);</span>
3217 }
3218 
<span class="line-modified">3219 void JIT_OPERATION operationProcessTypeProfilerLogDFG(VM* vmPointer)</span>
3220 {
<span class="line-modified">3221     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">3222     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3223     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3224 
3225     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside DFG.&quot;_s);
3226 }
3227 
<span class="line-modified">3228 EncodedJSValue JIT_OPERATION operationResolveScopeForHoistingFuncDeclInEval(JSGlobalObject* globalObject, JSScope* scope, UniquedStringImpl* impl)</span>
3229 {
<span class="line-modified">3230     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3231     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3232     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3233 
<span class="line-modified">3234     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, Identifier::fromUid(vm, impl));</span>
3235     return JSValue::encode(resolvedScope);
3236 }
3237 
<span class="line-modified">3238 JSCell* JIT_OPERATION operationResolveScope(JSGlobalObject* globalObject, JSScope* scope, UniquedStringImpl* impl)</span>
3239 {
<span class="line-modified">3240     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3241     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3242     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3243 
<span class="line-modified">3244     JSObject* resolvedScope = JSScope::resolve(globalObject, scope, Identifier::fromUid(vm, impl));</span>
3245     return resolvedScope;
3246 }
3247 
<span class="line-modified">3248 EncodedJSValue JIT_OPERATION operationGetDynamicVar(JSGlobalObject* globalObject, JSObject* scope, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
3249 {
<span class="line-modified">3250     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3251     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3252     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3253     auto throwScope = DECLARE_THROW_SCOPE(vm);
3254 
3255     Identifier ident = Identifier::fromUid(vm, impl);
<span class="line-modified">3256     RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(globalObject, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
3257         if (!found) {
3258             GetPutInfo getPutInfo(getPutInfoBits);
3259             if (getPutInfo.resolveMode() == ThrowIfNotFound)
<span class="line-modified">3260                 throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, ident));</span>
3261             return jsUndefined();
3262         }
3263 
3264         if (scope-&gt;isGlobalLexicalEnvironment()) {
3265             // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
<span class="line-modified">3266             JSValue result = slot.getValue(globalObject, ident);</span>
3267             if (result == jsTDZValue()) {
<span class="line-modified">3268                 throwException(globalObject, throwScope, createTDZError(globalObject));</span>
3269                 return jsUndefined();
3270             }
3271             return result;
3272         }
3273 
<span class="line-modified">3274         return slot.getValue(globalObject, ident);</span>
3275     })));
3276 }
3277 
<span class="line-modified">3278 ALWAYS_INLINE static void putDynamicVar(JSGlobalObject* globalObject, VM&amp; vm, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits, bool isStrictMode)</span>
3279 {
3280     auto throwScope = DECLARE_THROW_SCOPE(vm);
3281 
3282     const Identifier&amp; ident = Identifier::fromUid(vm, impl);
3283     GetPutInfo getPutInfo(getPutInfoBits);
<span class="line-modified">3284     bool hasProperty = scope-&gt;hasProperty(globalObject, ident);</span>
3285     RETURN_IF_EXCEPTION(throwScope, void());
3286     if (hasProperty
3287         &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
3288         &amp;&amp; !isInitialization(getPutInfo.initializationMode())) {
3289         // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
3290         PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified">3291         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, globalObject, ident, slot);</span>
<span class="line-modified">3292         if (slot.getValue(globalObject, ident) == jsTDZValue()) {</span>
<span class="line-modified">3293             throwException(globalObject, throwScope, createTDZError(globalObject));</span>
3294             return;
3295         }
3296     }
3297 
3298     if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
<span class="line-modified">3299         throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, ident));</span>
3300         return;
3301     }
3302 
3303     PutPropertySlot slot(scope, isStrictMode, PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));
3304     throwScope.release();
<span class="line-modified">3305     scope-&gt;methodTable(vm)-&gt;put(scope, globalObject, ident, JSValue::decode(value), slot);</span>
3306 }
3307 
<span class="line-modified">3308 void JIT_OPERATION operationPutDynamicVarStrict(JSGlobalObject* globalObject, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
3309 {
<span class="line-modified">3310     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3311     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3312     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3313     constexpr bool isStrictMode = true;
<span class="line-modified">3314     return putDynamicVar(globalObject, vm, scope, value, impl, getPutInfoBits, isStrictMode);</span>
3315 }
3316 
<span class="line-modified">3317 void JIT_OPERATION operationPutDynamicVarNonStrict(JSGlobalObject* globalObject, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
3318 {
<span class="line-modified">3319     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3320     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3321     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3322     constexpr bool isStrictMode = false;
<span class="line-modified">3323     return putDynamicVar(globalObject, vm, scope, value, impl, getPutInfoBits, isStrictMode);</span>
3324 }
3325 
<span class="line-modified">3326 int32_t JIT_OPERATION operationMapHash(JSGlobalObject* globalObject, EncodedJSValue input)</span>
3327 {
<span class="line-modified">3328     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3329     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3330     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3331 
<span class="line-modified">3332     return jsMapHash(globalObject, vm, JSValue::decode(input));</span>
3333 }
3334 
<span class="line-modified">3335 JSCell* JIT_OPERATION operationJSMapFindBucket(JSGlobalObject* globalObject, JSCell* map, EncodedJSValue key, int32_t hash)</span>
3336 {
<span class="line-modified">3337     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3338     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">3339     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3340     JSMap::BucketType** bucket = jsCast&lt;JSMap*&gt;(map)-&gt;findBucket(globalObject, JSValue::decode(key), hash);</span>
3341     if (!bucket)
3342         return vm.sentinelMapBucket();
3343     return *bucket;
3344 }
3345 
<span class="line-modified">3346 JSCell* JIT_OPERATION operationJSSetFindBucket(JSGlobalObject* globalObject, JSCell* map, EncodedJSValue key, int32_t hash)</span>
3347 {
<span class="line-modified">3348     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3349     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">3350     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3351     JSSet::BucketType** bucket = jsCast&lt;JSSet*&gt;(map)-&gt;findBucket(globalObject, JSValue::decode(key), hash);</span>
3352     if (!bucket)
3353         return vm.sentinelSetBucket();
3354     return *bucket;
3355 }
3356 
<span class="line-modified">3357 JSCell* JIT_OPERATION operationSetAdd(JSGlobalObject* globalObject, JSCell* set, EncodedJSValue key, int32_t hash)</span>
3358 {
<span class="line-modified">3359     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3360     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">3361     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3362     auto* bucket = jsCast&lt;JSSet*&gt;(set)-&gt;addNormalized(globalObject, JSValue::decode(key), JSValue(), hash);</span>
3363     if (!bucket)
3364         return vm.sentinelSetBucket();
3365     return bucket;
3366 }
3367 
<span class="line-modified">3368 JSCell* JIT_OPERATION operationMapSet(JSGlobalObject* globalObject, JSCell* map, EncodedJSValue key, EncodedJSValue value, int32_t hash)</span>
3369 {
<span class="line-modified">3370     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3371     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">3372     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3373     auto* bucket = jsCast&lt;JSMap*&gt;(map)-&gt;addNormalized(globalObject, JSValue::decode(key), JSValue::decode(value), hash);</span>
3374     if (!bucket)
3375         return vm.sentinelMapBucket();
3376     return bucket;
3377 }
3378 
<span class="line-modified">3379 void JIT_OPERATION operationWeakSetAdd(VM* vmPointer, JSCell* set, JSCell* key, int32_t hash)</span>
3380 {
<span class="line-modified">3381     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">3382     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3383     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3384     jsCast&lt;JSWeakSet*&gt;(set)-&gt;add(vm, asObject(key), JSValue(), hash);
3385 }
3386 
<span class="line-modified">3387 void JIT_OPERATION operationWeakMapSet(VM* vmPointer, JSCell* map, JSCell* key, EncodedJSValue value, int32_t hash)</span>
3388 {
<span class="line-modified">3389     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">3390     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3391     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3392     jsCast&lt;JSWeakMap*&gt;(map)-&gt;add(vm, asObject(key), JSValue::decode(value), hash);
3393 }
3394 
<span class="line-modified">3395 EncodedJSValue JIT_OPERATION operationGetPrototypeOfObject(JSGlobalObject* globalObject, JSObject* thisObject)</span>
3396 {
<span class="line-modified">3397     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3398     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">3399     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3400     return JSValue::encode(thisObject-&gt;getPrototype(vm, globalObject));</span>
3401 }
3402 
<span class="line-modified">3403 EncodedJSValue JIT_OPERATION operationGetPrototypeOf(JSGlobalObject* globalObject, EncodedJSValue encodedValue)</span>
3404 {
<span class="line-modified">3405     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3406     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3407     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3408     auto scope = DECLARE_THROW_SCOPE(vm);
3409 
<span class="line-modified">3410     JSValue thisValue = JSValue::decode(encodedValue).toThis(globalObject, StrictMode);</span>
3411     if (thisValue.isUndefinedOrNull())
<span class="line-modified">3412         return throwVMError(globalObject, scope, createNotAnObjectError(globalObject, thisValue));</span>
3413 
3414     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
3415     if (!thisObject) {
<span class="line-modified">3416         JSObject* prototype = thisValue.synthesizePrototype(globalObject);</span>
3417         EXCEPTION_ASSERT(!!scope.exception() == !prototype);
3418         if (UNLIKELY(!prototype))
3419             return JSValue::encode(JSValue());
3420         return JSValue::encode(prototype);
3421     }
3422 
<span class="line-modified">3423     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, globalObject)));</span>
<span class="line-added">3424 }</span>
<span class="line-added">3425 </span>
<span class="line-added">3426 EncodedJSValue JIT_OPERATION operationDateGetFullYear(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3427 {</span>
<span class="line-added">3428     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3429     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3430     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3431 </span>
<span class="line-added">3432     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">3433     if (!gregorianDateTime)</span>
<span class="line-added">3434         return JSValue::encode(jsNaN());</span>
<span class="line-added">3435     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));</span>
<span class="line-added">3436 }</span>
<span class="line-added">3437 </span>
<span class="line-added">3438 EncodedJSValue JIT_OPERATION operationDateGetUTCFullYear(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3439 {</span>
<span class="line-added">3440     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3441     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3442     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3443 </span>
<span class="line-added">3444     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">3445     if (!gregorianDateTime)</span>
<span class="line-added">3446         return JSValue::encode(jsNaN());</span>
<span class="line-added">3447     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));</span>
<span class="line-added">3448 }</span>
<span class="line-added">3449 </span>
<span class="line-added">3450 EncodedJSValue JIT_OPERATION operationDateGetMonth(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3451 {</span>
<span class="line-added">3452     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3453     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3454     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3455 </span>
<span class="line-added">3456     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">3457     if (!gregorianDateTime)</span>
<span class="line-added">3458         return JSValue::encode(jsNaN());</span>
<span class="line-added">3459     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));</span>
<span class="line-added">3460 }</span>
<span class="line-added">3461 </span>
<span class="line-added">3462 EncodedJSValue JIT_OPERATION operationDateGetUTCMonth(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3463 {</span>
<span class="line-added">3464     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3465     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3466     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3467 </span>
<span class="line-added">3468     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">3469     if (!gregorianDateTime)</span>
<span class="line-added">3470         return JSValue::encode(jsNaN());</span>
<span class="line-added">3471     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));</span>
<span class="line-added">3472 }</span>
<span class="line-added">3473 </span>
<span class="line-added">3474 EncodedJSValue JIT_OPERATION operationDateGetDate(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3475 {</span>
<span class="line-added">3476     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3477     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3478     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3479 </span>
<span class="line-added">3480     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">3481     if (!gregorianDateTime)</span>
<span class="line-added">3482         return JSValue::encode(jsNaN());</span>
<span class="line-added">3483     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));</span>
<span class="line-added">3484 }</span>
<span class="line-added">3485 </span>
<span class="line-added">3486 EncodedJSValue JIT_OPERATION operationDateGetUTCDate(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3487 {</span>
<span class="line-added">3488     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3489     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3490     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3491 </span>
<span class="line-added">3492     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">3493     if (!gregorianDateTime)</span>
<span class="line-added">3494         return JSValue::encode(jsNaN());</span>
<span class="line-added">3495     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));</span>
<span class="line-added">3496 }</span>
<span class="line-added">3497 </span>
<span class="line-added">3498 EncodedJSValue JIT_OPERATION operationDateGetDay(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3499 {</span>
<span class="line-added">3500     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3501     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3502     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3503 </span>
<span class="line-added">3504     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">3505     if (!gregorianDateTime)</span>
<span class="line-added">3506         return JSValue::encode(jsNaN());</span>
<span class="line-added">3507     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));</span>
<span class="line-added">3508 }</span>
<span class="line-added">3509 </span>
<span class="line-added">3510 EncodedJSValue JIT_OPERATION operationDateGetUTCDay(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3511 {</span>
<span class="line-added">3512     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3513     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3514     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3515 </span>
<span class="line-added">3516     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">3517     if (!gregorianDateTime)</span>
<span class="line-added">3518         return JSValue::encode(jsNaN());</span>
<span class="line-added">3519     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));</span>
<span class="line-added">3520 }</span>
<span class="line-added">3521 </span>
<span class="line-added">3522 EncodedJSValue JIT_OPERATION operationDateGetHours(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3523 {</span>
<span class="line-added">3524     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3525     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3526     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3527 </span>
<span class="line-added">3528     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">3529     if (!gregorianDateTime)</span>
<span class="line-added">3530         return JSValue::encode(jsNaN());</span>
<span class="line-added">3531     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));</span>
<span class="line-added">3532 }</span>
<span class="line-added">3533 </span>
<span class="line-added">3534 EncodedJSValue JIT_OPERATION operationDateGetUTCHours(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3535 {</span>
<span class="line-added">3536     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3537     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3538     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3539 </span>
<span class="line-added">3540     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">3541     if (!gregorianDateTime)</span>
<span class="line-added">3542         return JSValue::encode(jsNaN());</span>
<span class="line-added">3543     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));</span>
<span class="line-added">3544 }</span>
<span class="line-added">3545 </span>
<span class="line-added">3546 EncodedJSValue JIT_OPERATION operationDateGetMinutes(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3547 {</span>
<span class="line-added">3548     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3549     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3550     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3551 </span>
<span class="line-added">3552     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">3553     if (!gregorianDateTime)</span>
<span class="line-added">3554         return JSValue::encode(jsNaN());</span>
<span class="line-added">3555     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));</span>
3556 }
3557 
<span class="line-modified">3558 EncodedJSValue JIT_OPERATION operationDateGetUTCMinutes(VM* vmPointer, DateInstance* date)</span>
3559 {
<span class="line-modified">3560     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">3561     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3562     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3563 </span>
<span class="line-added">3564     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">3565     if (!gregorianDateTime)</span>
<span class="line-added">3566         return JSValue::encode(jsNaN());</span>
<span class="line-added">3567     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));</span>
<span class="line-added">3568 }</span>
<span class="line-added">3569 </span>
<span class="line-added">3570 EncodedJSValue JIT_OPERATION operationDateGetSeconds(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3571 {</span>
<span class="line-added">3572     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3573     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3574     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3575 </span>
<span class="line-added">3576     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">3577     if (!gregorianDateTime)</span>
<span class="line-added">3578         return JSValue::encode(jsNaN());</span>
<span class="line-added">3579     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));</span>
<span class="line-added">3580 }</span>
<span class="line-added">3581 </span>
<span class="line-added">3582 EncodedJSValue JIT_OPERATION operationDateGetUTCSeconds(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3583 {</span>
<span class="line-added">3584     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3585     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3586     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3587 </span>
<span class="line-added">3588     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">3589     if (!gregorianDateTime)</span>
<span class="line-added">3590         return JSValue::encode(jsNaN());</span>
<span class="line-added">3591     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));</span>
<span class="line-added">3592 }</span>
<span class="line-added">3593 </span>
<span class="line-added">3594 EncodedJSValue JIT_OPERATION operationDateGetTimezoneOffset(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3595 {</span>
<span class="line-added">3596     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3597     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3598     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3599 </span>
<span class="line-added">3600     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">3601     if (!gregorianDateTime)</span>
<span class="line-added">3602         return JSValue::encode(jsNaN());</span>
<span class="line-added">3603     return JSValue::encode(jsNumber(-gregorianDateTime-&gt;utcOffsetInMinute()));</span>
<span class="line-added">3604 }</span>
<span class="line-added">3605 </span>
<span class="line-added">3606 EncodedJSValue JIT_OPERATION operationDateGetYear(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">3607 {</span>
<span class="line-added">3608     VM&amp; vm = *vmPointer;</span>
<span class="line-added">3609     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3610     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3611 </span>
<span class="line-added">3612     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">3613     if (!gregorianDateTime)</span>
<span class="line-added">3614         return JSValue::encode(jsNaN());</span>
<span class="line-added">3615     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year() - 1900));</span>
<span class="line-added">3616 }</span>
<span class="line-added">3617 </span>
<span class="line-added">3618 void JIT_OPERATION operationThrowDFG(JSGlobalObject* globalObject, EncodedJSValue valueToThrow)</span>
<span class="line-added">3619 {</span>
<span class="line-added">3620     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">3621     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3622     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3623     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">3624     scope.throwException(globalObject, JSValue::decode(valueToThrow));</span>
3625 }
3626 
<span class="line-modified">3627 void JIT_OPERATION operationThrowStaticError(JSGlobalObject* globalObject, JSString* message, uint32_t errorType)</span>
3628 {
<span class="line-modified">3629     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">3630     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3631     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3632     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">3633     String errorMessage = message-&gt;value(globalObject);</span>
<span class="line-modified">3634     scope.throwException(globalObject, createError(globalObject, static_cast&lt;ErrorType&gt;(errorType), errorMessage));</span>
3635 }
3636 
<span class="line-modified">3637 void JIT_OPERATION operationLinkDirectCall(CallLinkInfo* callLinkInfo, JSFunction* callee)</span>
<span class="line-added">3638 {</span>
<span class="line-added">3639     JSGlobalObject* globalObject = callee-&gt;globalObject();</span>
<span class="line-added">3640     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">3641     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3642     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">3643     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">3644 </span>
<span class="line-added">3645     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();</span>
<span class="line-added">3646 </span>
<span class="line-added">3647     RELEASE_ASSERT(callLinkInfo-&gt;isDirect());</span>
<span class="line-added">3648 </span>
<span class="line-added">3649     // This would happen if the executable died during GC but the CodeBlock did not die. That should</span>
<span class="line-added">3650     // not happen because the CodeBlock should have a weak reference to any executable it uses for</span>
<span class="line-added">3651     // this purpose.</span>
<span class="line-added">3652     RELEASE_ASSERT(callLinkInfo-&gt;executable());</span>
<span class="line-added">3653 </span>
<span class="line-added">3654     // Having a CodeBlock indicates that this is linked. We shouldn&#39;t be taking this path if it&#39;s</span>
<span class="line-added">3655     // linked.</span>
<span class="line-added">3656     RELEASE_ASSERT(!callLinkInfo-&gt;codeBlock());</span>
<span class="line-added">3657 </span>
<span class="line-added">3658     // We just don&#39;t support this yet.</span>
<span class="line-added">3659     RELEASE_ASSERT(!callLinkInfo-&gt;isVarargs());</span>
<span class="line-added">3660 </span>
<span class="line-added">3661     ExecutableBase* executable = callLinkInfo-&gt;executable();</span>
<span class="line-added">3662     RELEASE_ASSERT(callee-&gt;executable() == callLinkInfo-&gt;executable());</span>
<span class="line-added">3663 </span>
<span class="line-added">3664     JSScope* scope = callee-&gt;scopeUnchecked();</span>
<span class="line-added">3665 </span>
<span class="line-added">3666     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;</span>
<span class="line-added">3667     CodeBlock* codeBlock = nullptr;</span>
<span class="line-added">3668     if (executable-&gt;isHostFunction())</span>
<span class="line-added">3669         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);</span>
<span class="line-added">3670     else {</span>
<span class="line-added">3671         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);</span>
<span class="line-added">3672 </span>
<span class="line-added">3673         RELEASE_ASSERT(isCall(kind) || functionExecutable-&gt;constructAbility() != ConstructAbility::CannotConstruct);</span>
<span class="line-added">3674 </span>
<span class="line-added">3675         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, codeBlock);</span>
<span class="line-added">3676         EXCEPTION_ASSERT_UNUSED(throwScope, throwScope.exception() == error);</span>
<span class="line-added">3677         if (UNLIKELY(error))</span>
<span class="line-added">3678             return;</span>
<span class="line-added">3679         unsigned argumentStackSlots = callLinkInfo-&gt;maxArgumentCountIncludingThis();</span>
<span class="line-added">3680         if (argumentStackSlots &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))</span>
<span class="line-added">3681             codePtr = functionExecutable-&gt;entrypointFor(kind, MustCheckArity);</span>
<span class="line-added">3682         else</span>
<span class="line-added">3683             codePtr = functionExecutable-&gt;entrypointFor(kind, ArityCheckNotRequired);</span>
<span class="line-added">3684     }</span>
<span class="line-added">3685 </span>
<span class="line-added">3686     linkDirectFor(callFrame, *callLinkInfo, codeBlock, codePtr);</span>
<span class="line-added">3687 }</span>
<span class="line-added">3688 </span>
<span class="line-added">3689 void triggerReoptimizationNow(CodeBlock* codeBlock, CodeBlock* optimizedCodeBlock, OSRExitBase* exit)</span>
3690 {
3691     // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t
3692     // really be profitable.
3693     DeferGCForAWhile deferGC(codeBlock-&gt;vm().heap);
3694 
3695     sanitizeStackForVM(codeBlock-&gt;vm());
3696 
<span class="line-modified">3697     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Entered reoptimize&quot;);</span>

3698     // We must be called with the baseline code block.
3699     ASSERT(JITCode::isBaselineCode(codeBlock-&gt;jitType()));
3700 
3701     // If I am my own replacement, then reoptimization has already been triggered.
3702     // This can happen in recursive functions.
3703     //
3704     // Note that even if optimizedCodeBlock is an FTLForOSREntry style CodeBlock, this condition is a
3705     // sure bet that we don&#39;t have anything else left to do.
3706     CodeBlock* replacement = codeBlock-&gt;replacement();
3707     if (!replacement || replacement == codeBlock) {
<span class="line-modified">3708         dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Not reoptimizing because we&#39;ve already been jettisoned.&quot;);</span>

3709         return;
3710     }
3711 
3712     // Otherwise, the replacement must be optimized code. Use this as an opportunity
3713     // to check our logic.
3714     ASSERT(codeBlock-&gt;hasOptimizedReplacement());
3715     ASSERT(JITCode::isOptimizingJIT(optimizedCodeBlock-&gt;jitType()));
3716 
3717     bool didTryToEnterIntoInlinedLoops = false;
3718     for (InlineCallFrame* inlineCallFrame = exit-&gt;m_codeOrigin.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame()) {
3719         if (inlineCallFrame-&gt;baselineCodeBlock-&gt;ownerExecutable()-&gt;didTryToEnterInLoop()) {
3720             didTryToEnterIntoInlinedLoops = true;
3721             break;
3722         }
3723     }
3724 
3725     // In order to trigger reoptimization, one of two things must have happened:
3726     // 1) We exited more than some number of times.
3727     // 2) We exited and got stuck in a loop, and now we&#39;re exiting again.
3728     bool didExitABunch = optimizedCodeBlock-&gt;shouldReoptimizeNow();
3729     bool didGetStuckInLoop =
3730         (codeBlock-&gt;checkIfOptimizationThresholdReached() || didTryToEnterIntoInlinedLoops)
3731         &amp;&amp; optimizedCodeBlock-&gt;shouldReoptimizeFromLoopNow();
3732 
3733     if (!didExitABunch &amp;&amp; !didGetStuckInLoop) {
<span class="line-modified">3734         dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Not reoptimizing &quot;, *optimizedCodeBlock, &quot; because it either didn&#39;t exit enough or didn&#39;t loop enough after exit.&quot;);</span>

3735         codeBlock-&gt;optimizeAfterLongWarmUp();
3736         return;
3737     }
3738 
3739     optimizedCodeBlock-&gt;jettison(Profiler::JettisonDueToOSRExit, CountReoptimization);
3740 }
3741 
<span class="line-added">3742 void JIT_OPERATION operationTriggerReoptimizationNow(CodeBlock* codeBlock, CodeBlock* optimizedCodeBlock, OSRExitBase* exit)</span>
<span class="line-added">3743 {</span>
<span class="line-added">3744     triggerReoptimizationNow(codeBlock, optimizedCodeBlock, exit);</span>
<span class="line-added">3745 }</span>
<span class="line-added">3746 </span>
3747 #if ENABLE(FTL_JIT)
3748 static bool shouldTriggerFTLCompile(CodeBlock* codeBlock, JITCode* jitCode)
3749 {
3750     if (codeBlock-&gt;baselineVersion()-&gt;m_didFailFTLCompilation) {
3751         CODEBLOCK_LOG_EVENT(codeBlock, &quot;abortFTLCompile&quot;, ());
<span class="line-modified">3752         dataLogLnIf(Options::verboseOSR(), &quot;Deferring FTL-optimization of &quot;, *codeBlock, &quot; indefinitely because there was an FTL failure.&quot;);</span>

3753         jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3754         return false;
3755     }
3756 
3757     if (!codeBlock-&gt;hasOptimizedReplacement()
3758         &amp;&amp; !jitCode-&gt;checkIfOptimizationThresholdReached(codeBlock)) {
3759         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;counter = &quot;, jitCode-&gt;tierUpCounter));
<span class="line-modified">3760         dataLogLnIf(Options::verboseOSR(), &quot;Choosing not to FTL-optimize &quot;, *codeBlock, &quot; yet.&quot;);</span>

3761         return false;
3762     }
3763     return true;
3764 }
3765 
3766 static void triggerFTLReplacementCompile(VM&amp; vm, CodeBlock* codeBlock, JITCode* jitCode)
3767 {
3768     if (codeBlock-&gt;codeType() == GlobalCode) {
3769         // Global code runs once, so we don&#39;t want to do anything. We don&#39;t want to defer indefinitely,
3770         // since this may have been spuriously called from tier-up initiated in a loop, and that loop may
3771         // later want to run faster code. Deferring for warm-up seems safest.
3772         jitCode-&gt;optimizeAfterWarmUp(codeBlock);
3773         return;
3774     }
3775 
3776     Worklist::State worklistState;
3777     if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
3778         worklistState = worklist-&gt;completeAllReadyPlansForVM(
3779             vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLMode));
3780     } else
</pre>
<hr />
<pre>
3782 
3783     if (worklistState == Worklist::Compiling) {
3784         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;still compiling&quot;));
3785         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3786             codeBlock, CompilationDeferred);
3787         return;
3788     }
3789 
3790     if (codeBlock-&gt;hasOptimizedReplacement()) {
3791         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;has replacement&quot;));
3792         // That&#39;s great, we&#39;ve compiled the code - next time we call this function,
3793         // we&#39;ll enter that replacement.
3794         jitCode-&gt;optimizeSoon(codeBlock);
3795         return;
3796     }
3797 
3798     if (worklistState == Worklist::Compiled) {
3799         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;compiled and failed&quot;));
3800         // This means that we finished compiling, but failed somehow; in that case the
3801         // thresholds will be set appropriately.
<span class="line-modified">3802         dataLogLnIf(Options::verboseOSR(), &quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.&quot;);</span>

3803         return;
3804     }
3805 
3806     CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLReplacement&quot;, ());
3807     // We need to compile the code.
3808     compile(
<span class="line-modified">3809         vm, codeBlock-&gt;newReplacement(), codeBlock, FTLMode, BytecodeIndex(),</span>
3810         Operands&lt;Optional&lt;JSValue&gt;&gt;(), ToFTLDeferredCompilationCallback::create());
3811 
3812     // If we reached here, the counter has not be reset. Do that now.
3813     jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
3814         codeBlock, CompilationDeferred);
3815 }
3816 
<span class="line-modified">3817 void JIT_OPERATION operationTriggerTierUpNow(VM* vmPointer)</span>
3818 {
<span class="line-modified">3819     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">3820     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3821     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3822     DeferGCForAWhile deferGC(vm.heap);
<span class="line-modified">3823     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
3824 
3825     sanitizeStackForVM(vm);
3826 
3827     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
3828         dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
3829         RELEASE_ASSERT_NOT_REACHED();
3830     }
3831 
3832     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3833 
<span class="line-modified">3834     dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">3835         *codeBlock, &quot;: Entered triggerTierUpNow with executeCounter = &quot;, jitCode-&gt;tierUpCounter);</span>



3836 
3837     if (shouldTriggerFTLCompile(codeBlock, jitCode))
3838         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3839 
3840     if (codeBlock-&gt;hasOptimizedReplacement()) {
3841         if (jitCode-&gt;tierUpEntryTriggers.isEmpty()) {
3842             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;replacement in place, delaying indefinitely&quot;));
3843             // There is nothing more we can do, the only way this will be entered
3844             // is through the function entry point.
3845             jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3846             return;
3847         }
3848         if (jitCode-&gt;osrEntryBlock() &amp;&amp; jitCode-&gt;tierUpEntryTriggers.size() == 1) {
3849             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;trigger in place, delaying indefinitely&quot;));
3850             // There is only one outer loop and its trigger must have been set
3851             // when the plan completed.
3852             // Exiting the inner loop is useless, we can ignore the counter and leave
3853             // the trigger do its job.
3854             jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
3855             return;
3856         }
3857     }
3858 }
3859 
<span class="line-modified">3860 static char* tierUpCommon(VM&amp; vm, CallFrame* callFrame, BytecodeIndex originBytecodeIndex, bool canOSREnterHere)</span>
3861 {
<span class="line-modified">3862     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>

3863 
3864     // Resolve any pending plan for OSR Enter on this function.
3865     Worklist::State worklistState;
3866     if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
3867         worklistState = worklist-&gt;completeAllReadyPlansForVM(
3868             vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLForOSREntryMode));
3869     } else
3870         worklistState = Worklist::NotKnown;
3871 
3872     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
3873 
3874     bool triggeredSlowPathToStartCompilation = false;
3875     auto tierUpEntryTriggers = jitCode-&gt;tierUpEntryTriggers.find(originBytecodeIndex);
3876     if (tierUpEntryTriggers != jitCode-&gt;tierUpEntryTriggers.end()) {
3877         switch (tierUpEntryTriggers-&gt;value) {
3878         case JITCode::TriggerReason::DontTrigger:
3879             // The trigger isn&#39;t set, we entered because the counter reached its
3880             // threshold.
3881             break;
3882 
</pre>
<hr />
<pre>
3890             // entry for the current bytecode location. Unset this trigger so we
3891             // don&#39;t continually enter.
3892             tierUpEntryTriggers-&gt;value = JITCode::TriggerReason::DontTrigger;
3893             triggeredSlowPathToStartCompilation = true;
3894             break;
3895         }
3896     }
3897 
3898     if (worklistState == Worklist::Compiling) {
3899         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;still compiling&quot;));
3900         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
3901         return nullptr;
3902     }
3903 
3904     // If we can OSR Enter, do it right away.
3905     if (canOSREnterHere) {
3906         auto iter = jitCode-&gt;bytecodeIndexToStreamIndex.find(originBytecodeIndex);
3907         if (iter != jitCode-&gt;bytecodeIndexToStreamIndex.end()) {
3908             unsigned streamIndex = iter-&gt;value;
3909             if (CodeBlock* entryBlock = jitCode-&gt;osrEntryBlock()) {
<span class="line-modified">3910                 dataLogLnIf(Options::verboseOSR(), &quot;OSR entry: From &quot;, RawPointer(jitCode), &quot; got entry block &quot;, RawPointer(entryBlock));</span>
<span class="line-modified">3911                 if (void* address = FTL::prepareOSREntry(vm, callFrame, codeBlock, entryBlock, originBytecodeIndex, streamIndex)) {</span>
<span class="line-modified">3912                     CODEBLOCK_LOG_EVENT(entryBlock, &quot;osrEntry&quot;, (&quot;at &quot;, originBytecodeIndex));</span>
<span class="line-modified">3913                     return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(callFrame));</span>

3914                 }
3915             }
3916         }
3917     }
3918 
3919     if (worklistState == Worklist::Compiled) {
3920         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;compiled and failed&quot;));
3921         // This means that compilation failed and we already set the thresholds.
<span class="line-modified">3922         dataLogLnIf(Options::verboseOSR(), &quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.&quot;);</span>

3923         return nullptr;
3924     }
3925 
3926     // - If we don&#39;t have an FTL code block, then try to compile one.
3927     // - If we do have an FTL code block, then try to enter for a while.
3928     // - If we couldn&#39;t enter for a while, then trigger OSR entry.
3929 
3930     if (!shouldTriggerFTLCompile(codeBlock, jitCode) &amp;&amp; !triggeredSlowPathToStartCompilation)
3931         return nullptr;
3932 
3933     if (!jitCode-&gt;neverExecutedEntry &amp;&amp; !triggeredSlowPathToStartCompilation) {
3934         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
3935 
3936         if (!codeBlock-&gt;hasOptimizedReplacement())
3937             return nullptr;
3938 
3939         if (jitCode-&gt;osrEntryRetry &lt; Options::ftlOSREntryRetryThreshold()) {
3940             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;avoiding OSR entry compile&quot;));
3941             jitCode-&gt;osrEntryRetry++;
3942             return nullptr;
</pre>
<hr />
<pre>
3976 
3977         // An inner loop didn&#39;t specifically ask for us to kick off a compilation. This means the counter
3978         // crossed its threshold. We either fall through and kick off a compile for originBytecodeIndex,
3979         // or we flag an outer loop to immediately try to compile itself. If there are outer loops,
3980         // we first try to make them compile themselves. But we will eventually fall back to compiling
3981         // a progressively inner loop if it takes too long for control to reach an outer loop.
3982 
3983         auto tryTriggerOuterLoopToCompile = [&amp;] {
3984             auto tierUpHierarchyEntry = jitCode-&gt;tierUpInLoopHierarchy.find(originBytecodeIndex);
3985             if (tierUpHierarchyEntry == jitCode-&gt;tierUpInLoopHierarchy.end())
3986                 return false;
3987 
3988             // This vector is ordered from innermost to outermost loop. Every bytecode entry in this vector is
3989             // allowed to do OSR entry. We start with the outermost loop and make our way inwards (hence why we
3990             // iterate the vector in reverse). Our policy is that we will trigger an outer loop to compile
3991             // immediately when program control reaches it. If program control is taking too long to reach that
3992             // outer loop, we progressively move inwards, meaning, we&#39;ll eventually trigger some loop that is
3993             // executing to compile. We start with trying to compile outer loops since we believe outer loop
3994             // compilations reveal the best opportunities for optimizing code.
3995             for (auto iter = tierUpHierarchyEntry-&gt;value.rbegin(), end = tierUpHierarchyEntry-&gt;value.rend(); iter != end; ++iter) {
<span class="line-modified">3996                 BytecodeIndex osrEntryCandidate = *iter;</span>
3997 
3998                 if (jitCode-&gt;tierUpEntryTriggers.get(osrEntryCandidate) == JITCode::TriggerReason::StartCompilation) {
3999                     // This means that we already asked this loop to compile. If we&#39;ve reached here, it
4000                     // means program control has not yet reached that loop. So it&#39;s taking too long to compile.
4001                     // So we move on to asking the inner loop of this loop to compile itself.
4002                     continue;
4003                 }
4004 
4005                 // This is where we ask the outer to loop to immediately compile itself if program
4006                 // control reaches it.
<span class="line-modified">4007                 dataLogLnIf(Options::verboseOSR(), &quot;Inner-loop &quot;, originBytecodeIndex, &quot; in &quot;, *codeBlock, &quot; setting parent loop &quot;, osrEntryCandidate, &quot;&#39;s trigger and backing off.&quot;);</span>

4008                 jitCode-&gt;tierUpEntryTriggers.set(osrEntryCandidate, JITCode::TriggerReason::StartCompilation);
4009                 return true;
4010             }
4011 
4012             return false;
4013         };
4014 
4015         if (tryTriggerOuterLoopToCompile()) {
4016             jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
4017             return nullptr;
4018         }
4019     }
4020 
4021     if (!canOSREnterHere) {
4022         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
4023         return nullptr;
4024     }
4025 
4026     // We aren&#39;t compiling and haven&#39;t compiled anything for OSR entry. So, try to compile
4027     // something.
4028 
4029     auto triggerIterator = jitCode-&gt;tierUpEntryTriggers.find(originBytecodeIndex);
4030     if (triggerIterator == jitCode-&gt;tierUpEntryTriggers.end()) {
4031         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
4032         return nullptr;
4033     }
4034 
4035     JITCode::TriggerReason* triggerAddress = &amp;(triggerIterator-&gt;value);
4036 
4037     Operands&lt;Optional&lt;JSValue&gt;&gt; mustHandleValues;
4038     unsigned streamIndex = jitCode-&gt;bytecodeIndexToStreamIndex.get(originBytecodeIndex);
<span class="line-modified">4039     jitCode-&gt;reconstruct(callFrame, codeBlock, CodeOrigin(originBytecodeIndex), streamIndex, mustHandleValues);</span>

4040     CodeBlock* replacementCodeBlock = codeBlock-&gt;newReplacement();
4041 
4042     CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLOSR&quot;, ());
4043     CompilationResult forEntryResult = compile(
4044         vm, replacementCodeBlock, codeBlock, FTLForOSREntryMode, originBytecodeIndex,
4045         mustHandleValues, ToFTLForOSREntryDeferredCompilationCallback::create(triggerAddress));
4046 
4047     if (jitCode-&gt;neverExecutedEntry)
4048         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
4049 
4050     if (forEntryResult != CompilationSuccessful) {
4051         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR ecompilation not successful&quot;));
4052         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
4053             codeBlock, CompilationDeferred);
4054         return nullptr;
4055     }
4056 
<span class="line-modified">4057     CODEBLOCK_LOG_EVENT(jitCode-&gt;osrEntryBlock(), &quot;osrEntry&quot;, (&quot;at &quot;, originBytecodeIndex));</span>
4058     // It&#39;s possible that the for-entry compile already succeeded. In that case OSR
4059     // entry will succeed unless we ran out of stack. It&#39;s not clear what we should do.
4060     // We signal to try again after a while if that happens.
<span class="line-modified">4061     dataLogLnIf(Options::verboseOSR(), &quot;Immediate OSR entry: From &quot;, RawPointer(jitCode), &quot; got entry block &quot;, RawPointer(jitCode-&gt;osrEntryBlock()));</span>

4062 
<span class="line-modified">4063     void* address = FTL::prepareOSREntry(vm, callFrame, codeBlock, jitCode-&gt;osrEntryBlock(), originBytecodeIndex, streamIndex);</span>

4064     if (!address)
4065         return nullptr;
<span class="line-modified">4066     return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(callFrame));</span>
4067 }
4068 
<span class="line-modified">4069 void JIT_OPERATION operationTriggerTierUpNowInLoop(VM* vmPointer, unsigned bytecodeIndexBits)</span>
4070 {
<span class="line-modified">4071     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">4072     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">4073     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
4074     DeferGCForAWhile deferGC(vm.heap);
<span class="line-modified">4075     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">4076     BytecodeIndex bytecodeIndex = BytecodeIndex::fromBits(bytecodeIndexBits);</span>
4077 
4078     sanitizeStackForVM(vm);
4079 
4080     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
<span class="line-modified">4081         dataLogLn(&quot;Unexpected code block in DFG-&gt;FTL trigger tier up now in loop: &quot;, *codeBlock);</span>
4082         RELEASE_ASSERT_NOT_REACHED();
4083     }
4084 
4085     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
4086 
<span class="line-modified">4087     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Entered triggerTierUpNowInLoop with executeCounter = &quot;, jitCode-&gt;tierUpCounter);</span>




4088 
4089     if (jitCode-&gt;tierUpInLoopHierarchy.contains(bytecodeIndex))
<span class="line-modified">4090         tierUpCommon(vm, callFrame, bytecodeIndex, false);</span>
4091     else if (shouldTriggerFTLCompile(codeBlock, jitCode))
4092         triggerFTLReplacementCompile(vm, codeBlock, jitCode);
4093 
4094     // Since we cannot OSR Enter here, the default &quot;optimizeSoon()&quot; is not useful.
4095     if (codeBlock-&gt;hasOptimizedReplacement()) {
4096         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR in loop failed, deferring&quot;));
4097         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
4098     }
4099 }
4100 
<span class="line-modified">4101 char* JIT_OPERATION operationTriggerOSREntryNow(VM* vmPointer, unsigned bytecodeIndexBits)</span>
4102 {
<span class="line-modified">4103     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">4104     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">4105     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
4106     DeferGCForAWhile deferGC(vm.heap);
<span class="line-modified">4107     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">4108     BytecodeIndex bytecodeIndex = BytecodeIndex::fromBits(bytecodeIndexBits);</span>
4109 
4110     sanitizeStackForVM(vm);
4111 
4112     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
4113         dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
4114         RELEASE_ASSERT_NOT_REACHED();
4115     }
4116 
4117     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
4118 
<span class="line-modified">4119     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Entered triggerOSREntryNow with executeCounter = &quot;, jitCode-&gt;tierUpCounter);</span>




4120 
<span class="line-modified">4121     return tierUpCommon(vm, callFrame, bytecodeIndex, true);</span>
4122 }
4123 
4124 #endif // ENABLE(FTL_JIT)
4125 
4126 } // extern &quot;C&quot;
4127 } } // namespace JSC::DFG
4128 
<span class="line-added">4129 IGNORE_WARNINGS_END</span>
<span class="line-added">4130 </span>
4131 #endif // ENABLE(DFG_JIT)
4132 
4133 #endif // ENABLE(JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGOpInfo.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOperations.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGPathData.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGMarkerData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGRenderSupport.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGPathData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 #include &quot;SVGPolygonElement.h&quot;
 36 #include &quot;SVGPolylineElement.h&quot;
 37 #include &quot;SVGRectElement.h&quot;
 38 #include &lt;wtf/HashMap.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 static Path pathFromCircleElement(const SVGElement&amp; element)
 43 {
 44     ASSERT(is&lt;SVGCircleElement&gt;(element));
 45 
 46     RenderElement* renderer = element.renderer();
 47     if (!renderer)
 48         return { };
 49 
 50     Path path;
 51     auto&amp; style = renderer-&gt;style();
 52     SVGLengthContext lengthContext(&amp;element);
 53     float r = lengthContext.valueForLength(style.svgStyle().r());
 54     if (r &gt; 0) {
<span class="line-modified"> 55         float cx = lengthContext.valueForLength(style.svgStyle().cx(), LengthModeWidth);</span>
<span class="line-modified"> 56         float cy = lengthContext.valueForLength(style.svgStyle().cy(), LengthModeHeight);</span>
 57         path.addEllipse(FloatRect(cx - r, cy - r, r * 2, r * 2));
 58     }
 59     return path;
 60 }
 61 
 62 static Path pathFromEllipseElement(const SVGElement&amp; element)
 63 {
 64     RenderElement* renderer = element.renderer();
 65     if (!renderer)
 66         return { };
 67 
 68     auto&amp; style = renderer-&gt;style();
 69     SVGLengthContext lengthContext(&amp;element);
<span class="line-modified"> 70     float rx = lengthContext.valueForLength(style.svgStyle().rx(), LengthModeWidth);</span>
 71     if (rx &lt;= 0)
 72         return { };
 73 
<span class="line-modified"> 74     float ry = lengthContext.valueForLength(style.svgStyle().ry(), LengthModeHeight);</span>
 75     if (ry &lt;= 0)
 76         return { };
 77 
 78     Path path;
<span class="line-modified"> 79     float cx = lengthContext.valueForLength(style.svgStyle().cx(), LengthModeWidth);</span>
<span class="line-modified"> 80     float cy = lengthContext.valueForLength(style.svgStyle().cy(), LengthModeHeight);</span>
 81     path.addEllipse(FloatRect(cx - rx, cy - ry, rx * 2, ry * 2));
 82     return path;
 83 }
 84 
 85 static Path pathFromLineElement(const SVGElement&amp; element)
 86 {
 87     Path path;
 88     const auto&amp; line = downcast&lt;SVGLineElement&gt;(element);
 89 
 90     SVGLengthContext lengthContext(&amp;element);
 91     path.moveTo(FloatPoint(line.x1().value(lengthContext), line.y1().value(lengthContext)));
 92     path.addLineTo(FloatPoint(line.x2().value(lengthContext), line.y2().value(lengthContext)));
 93     return path;
 94 }
 95 
 96 static Path pathFromPathElement(const SVGElement&amp; element)
 97 {
 98     return downcast&lt;SVGPathElement&gt;(element).path();
 99 }
100 
</pre>
<hr />
<pre>
121     if (points.isEmpty())
122         return { };
123 
124     Path path;
125     path.moveTo(points.first()-&gt;value());
126 
127     unsigned size = points.size();
128     for (unsigned i = 1; i &lt; size; ++i)
129         path.addLineTo(points.at(i)-&gt;value());
130     return path;
131 }
132 
133 static Path pathFromRectElement(const SVGElement&amp; element)
134 {
135     RenderElement* renderer = element.renderer();
136     if (!renderer)
137         return { };
138 
139     auto&amp; style = renderer-&gt;style();
140     SVGLengthContext lengthContext(&amp;element);
<span class="line-modified">141     float width = lengthContext.valueForLength(style.width(), LengthModeWidth);</span>
142     if (width &lt;= 0)
143         return { };
144 
<span class="line-modified">145     float height = lengthContext.valueForLength(style.height(), LengthModeHeight);</span>
146     if (height &lt;= 0)
147         return { };
148 
149     Path path;
<span class="line-modified">150     float x = lengthContext.valueForLength(style.svgStyle().x(), LengthModeWidth);</span>
<span class="line-modified">151     float y = lengthContext.valueForLength(style.svgStyle().y(), LengthModeHeight);</span>
<span class="line-modified">152     float rx = lengthContext.valueForLength(style.svgStyle().rx(), LengthModeWidth);</span>
<span class="line-modified">153     float ry = lengthContext.valueForLength(style.svgStyle().ry(), LengthModeHeight);</span>
154     bool hasRx = rx &gt; 0;
155     bool hasRy = ry &gt; 0;
156     if (hasRx || hasRy) {
157         if (!hasRx)
158             rx = ry;
159         else if (!hasRy)
160             ry = rx;
161         // FIXME: We currently enforce using beziers here, as at least on CoreGraphics/Lion, as
162         // the native method uses a different line dash origin, causing svg/custom/dashOrigin.svg to fail.
163         // See bug https://bugs.webkit.org/show_bug.cgi?id=79932 which tracks this issue.
<span class="line-modified">164         path.addRoundedRect(FloatRect(x, y, width, height), FloatSize(rx, ry), Path::PreferBezierRoundedRect);</span>
165         return path;
166     }
167 
168     path.addRect(FloatRect(x, y, width, height));
169     return path;
170 }
171 
172 Path pathFromGraphicsElement(const SVGElement* element)
173 {
174     ASSERT(element);
175 
176     typedef Path (*PathFromFunction)(const SVGElement&amp;);
177     static HashMap&lt;AtomStringImpl*, PathFromFunction&gt;* map = 0;
178     if (!map) {
179         map = new HashMap&lt;AtomStringImpl*, PathFromFunction&gt;;
180         map-&gt;set(SVGNames::circleTag-&gt;localName().impl(), pathFromCircleElement);
181         map-&gt;set(SVGNames::ellipseTag-&gt;localName().impl(), pathFromEllipseElement);
182         map-&gt;set(SVGNames::lineTag-&gt;localName().impl(), pathFromLineElement);
183         map-&gt;set(SVGNames::pathTag-&gt;localName().impl(), pathFromPathElement);
184         map-&gt;set(SVGNames::polygonTag-&gt;localName().impl(), pathFromPolygonElement);
</pre>
</td>
<td>
<hr />
<pre>
 35 #include &quot;SVGPolygonElement.h&quot;
 36 #include &quot;SVGPolylineElement.h&quot;
 37 #include &quot;SVGRectElement.h&quot;
 38 #include &lt;wtf/HashMap.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 static Path pathFromCircleElement(const SVGElement&amp; element)
 43 {
 44     ASSERT(is&lt;SVGCircleElement&gt;(element));
 45 
 46     RenderElement* renderer = element.renderer();
 47     if (!renderer)
 48         return { };
 49 
 50     Path path;
 51     auto&amp; style = renderer-&gt;style();
 52     SVGLengthContext lengthContext(&amp;element);
 53     float r = lengthContext.valueForLength(style.svgStyle().r());
 54     if (r &gt; 0) {
<span class="line-modified"> 55         float cx = lengthContext.valueForLength(style.svgStyle().cx(), SVGLengthMode::Width);</span>
<span class="line-modified"> 56         float cy = lengthContext.valueForLength(style.svgStyle().cy(), SVGLengthMode::Height);</span>
 57         path.addEllipse(FloatRect(cx - r, cy - r, r * 2, r * 2));
 58     }
 59     return path;
 60 }
 61 
 62 static Path pathFromEllipseElement(const SVGElement&amp; element)
 63 {
 64     RenderElement* renderer = element.renderer();
 65     if (!renderer)
 66         return { };
 67 
 68     auto&amp; style = renderer-&gt;style();
 69     SVGLengthContext lengthContext(&amp;element);
<span class="line-modified"> 70     float rx = lengthContext.valueForLength(style.svgStyle().rx(), SVGLengthMode::Width);</span>
 71     if (rx &lt;= 0)
 72         return { };
 73 
<span class="line-modified"> 74     float ry = lengthContext.valueForLength(style.svgStyle().ry(), SVGLengthMode::Height);</span>
 75     if (ry &lt;= 0)
 76         return { };
 77 
 78     Path path;
<span class="line-modified"> 79     float cx = lengthContext.valueForLength(style.svgStyle().cx(), SVGLengthMode::Width);</span>
<span class="line-modified"> 80     float cy = lengthContext.valueForLength(style.svgStyle().cy(), SVGLengthMode::Height);</span>
 81     path.addEllipse(FloatRect(cx - rx, cy - ry, rx * 2, ry * 2));
 82     return path;
 83 }
 84 
 85 static Path pathFromLineElement(const SVGElement&amp; element)
 86 {
 87     Path path;
 88     const auto&amp; line = downcast&lt;SVGLineElement&gt;(element);
 89 
 90     SVGLengthContext lengthContext(&amp;element);
 91     path.moveTo(FloatPoint(line.x1().value(lengthContext), line.y1().value(lengthContext)));
 92     path.addLineTo(FloatPoint(line.x2().value(lengthContext), line.y2().value(lengthContext)));
 93     return path;
 94 }
 95 
 96 static Path pathFromPathElement(const SVGElement&amp; element)
 97 {
 98     return downcast&lt;SVGPathElement&gt;(element).path();
 99 }
100 
</pre>
<hr />
<pre>
121     if (points.isEmpty())
122         return { };
123 
124     Path path;
125     path.moveTo(points.first()-&gt;value());
126 
127     unsigned size = points.size();
128     for (unsigned i = 1; i &lt; size; ++i)
129         path.addLineTo(points.at(i)-&gt;value());
130     return path;
131 }
132 
133 static Path pathFromRectElement(const SVGElement&amp; element)
134 {
135     RenderElement* renderer = element.renderer();
136     if (!renderer)
137         return { };
138 
139     auto&amp; style = renderer-&gt;style();
140     SVGLengthContext lengthContext(&amp;element);
<span class="line-modified">141     float width = lengthContext.valueForLength(style.width(), SVGLengthMode::Width);</span>
142     if (width &lt;= 0)
143         return { };
144 
<span class="line-modified">145     float height = lengthContext.valueForLength(style.height(), SVGLengthMode::Height);</span>
146     if (height &lt;= 0)
147         return { };
148 
149     Path path;
<span class="line-modified">150     float x = lengthContext.valueForLength(style.svgStyle().x(), SVGLengthMode::Width);</span>
<span class="line-modified">151     float y = lengthContext.valueForLength(style.svgStyle().y(), SVGLengthMode::Height);</span>
<span class="line-modified">152     float rx = lengthContext.valueForLength(style.svgStyle().rx(), SVGLengthMode::Width);</span>
<span class="line-modified">153     float ry = lengthContext.valueForLength(style.svgStyle().ry(), SVGLengthMode::Height);</span>
154     bool hasRx = rx &gt; 0;
155     bool hasRy = ry &gt; 0;
156     if (hasRx || hasRy) {
157         if (!hasRx)
158             rx = ry;
159         else if (!hasRy)
160             ry = rx;
161         // FIXME: We currently enforce using beziers here, as at least on CoreGraphics/Lion, as
162         // the native method uses a different line dash origin, causing svg/custom/dashOrigin.svg to fail.
163         // See bug https://bugs.webkit.org/show_bug.cgi?id=79932 which tracks this issue.
<span class="line-modified">164         path.addRoundedRect(FloatRect(x, y, width, height), FloatSize(rx, ry), Path::RoundedRectStrategy::PreferBezier);</span>
165         return path;
166     }
167 
168     path.addRect(FloatRect(x, y, width, height));
169     return path;
170 }
171 
172 Path pathFromGraphicsElement(const SVGElement* element)
173 {
174     ASSERT(element);
175 
176     typedef Path (*PathFromFunction)(const SVGElement&amp;);
177     static HashMap&lt;AtomStringImpl*, PathFromFunction&gt;* map = 0;
178     if (!map) {
179         map = new HashMap&lt;AtomStringImpl*, PathFromFunction&gt;;
180         map-&gt;set(SVGNames::circleTag-&gt;localName().impl(), pathFromCircleElement);
181         map-&gt;set(SVGNames::ellipseTag-&gt;localName().impl(), pathFromEllipseElement);
182         map-&gt;set(SVGNames::lineTag-&gt;localName().impl(), pathFromLineElement);
183         map-&gt;set(SVGNames::pathTag-&gt;localName().impl(), pathFromPathElement);
184         map-&gt;set(SVGNames::polygonTag-&gt;localName().impl(), pathFromPolygonElement);
</pre>
</td>
</tr>
</table>
<center><a href="SVGMarkerData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGRenderSupport.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
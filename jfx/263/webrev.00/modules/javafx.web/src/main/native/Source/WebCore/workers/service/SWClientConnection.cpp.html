<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/workers/service/SWClientConnection.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWClientConnection.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;Document.h&quot;
 32 #include &quot;ExceptionData.h&quot;
 33 #include &quot;MessageEvent.h&quot;
 34 #include &quot;SWContextManager.h&quot;
 35 #include &quot;ServiceWorkerContainer.h&quot;
 36 #include &quot;ServiceWorkerFetchResult.h&quot;
 37 #include &quot;ServiceWorkerGlobalScope.h&quot;
 38 #include &quot;ServiceWorkerJobData.h&quot;
 39 #include &quot;ServiceWorkerRegistration.h&quot;
 40 #include &lt;wtf/CrossThreadCopier.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 static bool dispatchToContextThreadIfNecessary(const DocumentOrWorkerIdentifier&amp; contextIdentifier, WTF::Function&lt;void(ScriptExecutionContext&amp;)&gt;&amp;&amp; task)
 45 {
 46     RELEASE_ASSERT(isMainThread());
 47     bool wasPosted = false;
 48     switchOn(contextIdentifier, [&amp;] (DocumentIdentifier identifier) {
 49         auto* document = Document::allDocumentsMap().get(identifier);
 50         if (!document)
 51             return;
 52         task(*document);
 53         wasPosted = true;
 54     }, [&amp;](ServiceWorkerIdentifier identifier) {
 55         wasPosted = SWContextManager::singleton().postTaskToServiceWorker(identifier, [task = WTFMove(task)](auto&amp; scope) mutable {
 56             task(scope);
 57         });
 58     });
 59     return wasPosted;
 60 }
 61 
 62 SWClientConnection::SWClientConnection() = default;
 63 
 64 SWClientConnection::~SWClientConnection() = default;
 65 
 66 void SWClientConnection::scheduleJob(DocumentOrWorkerIdentifier contextIdentifier, const ServiceWorkerJobData&amp; jobData)
 67 {
 68     auto addResult = m_scheduledJobSources.add(jobData.identifier().jobIdentifier, contextIdentifier);
 69     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 70 
 71     scheduleJobInServer(jobData);
 72 }
 73 
 74 bool SWClientConnection::postTaskForJob(ServiceWorkerJobIdentifier jobIdentifier, IsJobComplete isJobComplete, Function&lt;void(ServiceWorkerJob&amp;)&gt;&amp;&amp; task)
 75 {
 76     ASSERT(isMainThread());
 77 
 78     auto iterator = m_scheduledJobSources.find(jobIdentifier);
 79     if (iterator == m_scheduledJobSources.end()) {
 80         LOG_ERROR(&quot;Job %s was not found&quot;, jobIdentifier.loggingString().utf8().data());
 81         return false;
 82     }
 83     auto isPosted = dispatchToContextThreadIfNecessary(iterator-&gt;value, [jobIdentifier, task = WTFMove(task)] (ScriptExecutionContext&amp; context) mutable {
 84         if (auto* container = context.serviceWorkerContainer()) {
 85             if (auto* job = container-&gt;job(jobIdentifier))
 86                 task(*job);
 87         }
 88     });
 89     if (isJobComplete == IsJobComplete::Yes)
 90         m_scheduledJobSources.remove(iterator);
 91     return isPosted;
 92 }
 93 
 94 void SWClientConnection::jobRejectedInServer(ServiceWorkerJobIdentifier jobIdentifier, const ExceptionData&amp; exceptionData)
 95 {
 96     postTaskForJob(jobIdentifier, IsJobComplete::Yes, [exceptionData = exceptionData.isolatedCopy()] (auto&amp; job) {
 97         job.failedWithException(exceptionData.toException());
 98     });
 99 }
100 
101 void SWClientConnection::registrationJobResolvedInServer(ServiceWorkerJobIdentifier jobIdentifier, ServiceWorkerRegistrationData&amp;&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
102 {
103     bool isPosted = postTaskForJob(jobIdentifier, IsJobComplete::Yes, [registrationData = registrationData.isolatedCopy(), shouldNotifyWhenResolved] (auto&amp; job) mutable {
104         job.resolvedWithRegistration(WTFMove(registrationData), shouldNotifyWhenResolved);
105     });
106 
107     if (!isPosted &amp;&amp; shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)
108         didResolveRegistrationPromise(registrationData.key);
109 }
110 
111 void SWClientConnection::unregistrationJobResolvedInServer(ServiceWorkerJobIdentifier jobIdentifier, bool unregistrationResult)
112 {
113     postTaskForJob(jobIdentifier, IsJobComplete::Yes, [unregistrationResult] (auto&amp; job) {
114         job.resolvedWithUnregistrationResult(unregistrationResult);
115     });
116 }
117 
118 void SWClientConnection::startScriptFetchForServer(ServiceWorkerJobIdentifier jobIdentifier, const ServiceWorkerRegistrationKey&amp; registrationKey, FetchOptions::Cache cachePolicy)
119 {
120     bool isPosted = postTaskForJob(jobIdentifier, IsJobComplete::No, [cachePolicy] (auto&amp; job) {
121         job.startScriptFetch(cachePolicy);
122     });
123     if (!isPosted)
124         finishFetchingScriptInServer(serviceWorkerFetchError({ serverConnectionIdentifier(), jobIdentifier }, ServiceWorkerRegistrationKey { registrationKey}, ResourceError { errorDomainWebKitInternal, 0, { }, makeString(&quot;Failed to fetch script for service worker with scope &quot;, registrationKey.scope().string()) }));
125 }
126 
127 
128 void SWClientConnection::postMessageToServiceWorkerClient(DocumentIdentifier destinationContextIdentifier, MessageWithMessagePorts&amp;&amp; message, ServiceWorkerData&amp;&amp; sourceData, String&amp;&amp; sourceOrigin)
129 {
130     ASSERT(isMainThread());
131 
132     // FIXME: destinationContextIdentifier can only identify a Document at the moment.
133     auto* destinationDocument = Document::allDocumentsMap().get(destinationContextIdentifier);
134     if (!destinationDocument)
135         return;
136 
137     if (auto* container = destinationDocument-&gt;ensureServiceWorkerContainer())
138         container-&gt;postMessage(WTFMove(message), WTFMove(sourceData), WTFMove(sourceOrigin));
139 }
140 
141 void SWClientConnection::updateRegistrationState(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerRegistrationState state, const Optional&lt;ServiceWorkerData&gt;&amp; serviceWorkerData)
142 {
143     ASSERT(isMainThread());
144 
145     SWContextManager::singleton().forEachServiceWorkerThread([identifier, state, &amp;serviceWorkerData] (auto&amp; workerThread) {
146         workerThread.thread().runLoop().postTask([identifier, state, serviceWorkerData = crossThreadCopy(serviceWorkerData)](ScriptExecutionContext&amp; context) mutable {
147             if (auto* container = context.serviceWorkerContainer())
148                 container-&gt;updateRegistrationState(identifier, state, WTFMove(serviceWorkerData));
149         });
150     });
151 
152     for (auto* document : Document::allDocuments()) {
153         if (auto* container = document-&gt;serviceWorkerContainer())
154             container-&gt;updateRegistrationState(identifier, state, serviceWorkerData);
155     }
156 }
157 
158 void SWClientConnection::updateWorkerState(ServiceWorkerIdentifier identifier, ServiceWorkerState state)
159 {
160     ASSERT(isMainThread());
161 
162     SWContextManager::singleton().forEachServiceWorkerThread([identifier, state] (auto&amp; workerThread) {
163         workerThread.thread().runLoop().postTask([identifier, state](ScriptExecutionContext&amp; context) {
164             if (auto* container = context.serviceWorkerContainer())
165                 container-&gt;updateWorkerState(identifier, state);
166         });
167     });
168 
169     for (auto* document : Document::allDocuments()) {
170         if (auto* container = document-&gt;serviceWorkerContainer())
171             container-&gt;updateWorkerState(identifier, state);
172     }
173 }
174 
175 void SWClientConnection::fireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier identifier)
176 {
177     ASSERT(isMainThread());
178 
179     SWContextManager::singleton().forEachServiceWorkerThread([identifier] (auto&amp; workerThread) {
180         workerThread.thread().runLoop().postTask([identifier](ScriptExecutionContext&amp; context) {
181             if (auto* container = context.serviceWorkerContainer())
182                 container-&gt;queueTaskToFireUpdateFoundEvent(identifier);
183         });
184     });
185 
186     for (auto* document : Document::allDocuments()) {
187         if (auto* container = document-&gt;serviceWorkerContainer())
188             container-&gt;queueTaskToFireUpdateFoundEvent(identifier);
189     }
190 }
191 
192 void SWClientConnection::setRegistrationLastUpdateTime(ServiceWorkerRegistrationIdentifier identifier, WallTime lastUpdateTime)
193 {
194     ASSERT(isMainThread());
195 
196     SWContextManager::singleton().forEachServiceWorkerThread([identifier, lastUpdateTime] (auto&amp; workerThread) {
197         workerThread.thread().runLoop().postTask([identifier, lastUpdateTime](ScriptExecutionContext&amp; context) {
198             if (auto* container = context.serviceWorkerContainer()) {
199                 if (auto* registration = container-&gt;registration(identifier))
200                     registration-&gt;setLastUpdateTime(lastUpdateTime);
201             }
202         });
203     });
204 
205     for (auto* document : Document::allDocuments()) {
206         if (auto* container = document-&gt;serviceWorkerContainer()) {
207             if (auto* registration = container-&gt;registration(identifier))
208                 registration-&gt;setLastUpdateTime(lastUpdateTime);
209         }
210     }
211 }
212 
213 void SWClientConnection::setRegistrationUpdateViaCache(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerUpdateViaCache updateViaCache)
214 {
215     ASSERT(isMainThread());
216 
217     SWContextManager::singleton().forEachServiceWorkerThread([identifier, updateViaCache] (auto&amp; workerThread) {
218         workerThread.thread().runLoop().postTask([identifier, updateViaCache](ScriptExecutionContext&amp; context) {
219             if (auto* container = context.serviceWorkerContainer()) {
220                 if (auto* registration = container-&gt;registration(identifier))
221                     registration-&gt;setUpdateViaCache(updateViaCache);
222             }
223         });
224     });
225 
226     for (auto* document : Document::allDocuments()) {
227         if (auto* container = document-&gt;serviceWorkerContainer()) {
228             if (auto* registration = container-&gt;registration(identifier))
229                 registration-&gt;setUpdateViaCache(updateViaCache);
230         }
231     }
232 }
233 
234 void SWClientConnection::notifyClientsOfControllerChange(const HashSet&lt;DocumentIdentifier&gt;&amp; contextIdentifiers, ServiceWorkerData&amp;&amp; newController)
235 {
236     ASSERT(isMainThread());
237     ASSERT(!contextIdentifiers.isEmpty());
238 
239     for (auto&amp; clientIdentifier : contextIdentifiers) {
240         // FIXME: Support worker contexts.
241         auto* client = Document::allDocumentsMap().get(clientIdentifier);
242         if (!client)
243             continue;
244 
245         client-&gt;setActiveServiceWorker(ServiceWorker::getOrCreate(*client, WTFMove(newController)));
246         if (auto* container = client-&gt;serviceWorkerContainer())
247             container-&gt;queueTaskToDispatchControllerChangeEvent();
248     }
249 }
250 
251 void SWClientConnection::clearPendingJobs()
252 {
253     ASSERT(isMainThread());
254 
255     auto jobSources = WTFMove(m_scheduledJobSources);
256     for (auto&amp; keyValue : jobSources) {
257         dispatchToContextThreadIfNecessary(keyValue.value, [identifier = keyValue.key] (auto&amp; context) {
258             if (auto* container = context.serviceWorkerContainer()) {
259                 if (auto* job = container-&gt;job(identifier))
260                     job-&gt;failedWithException(Exception { TypeError, &quot;Internal error&quot;_s });
261             }
262         });
263     }
264 }
265 
266 void SWClientConnection::registerServiceWorkerClients()
267 {
268     for (auto* document : Document::allDocuments()) {
269         auto controllingServiceWorkerRegistrationIdentifier = document-&gt;activeServiceWorker() ? makeOptional&lt;ServiceWorkerRegistrationIdentifier&gt;(document-&gt;activeServiceWorker()-&gt;registrationIdentifier()) : WTF::nullopt;
270         registerServiceWorkerClient(document-&gt;topOrigin(), ServiceWorkerClientData::from(*document, *this), controllingServiceWorkerRegistrationIdentifier, document-&gt;userAgent(document-&gt;url()));
271     }
272 }
273 
274 } // namespace WebCore
275 
276 #endif // ENABLE(SERVICE_WORKER)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGAvailabilityMap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGBasicBlock.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
111         }
112 
113         case ValueBitAnd:
114         case ArithBitAnd: {
115             if (power &gt; 31)
116                 return true;
117 
118             return isWithinPowerOfTwoNonRecursive&lt;power&gt;(node-&gt;child1().node())
119                 || isWithinPowerOfTwoNonRecursive&lt;power&gt;(node-&gt;child2().node());
120         }
121 
122         case ArithBitOr:
123         case ArithBitXor:
124         case ValueBitOr:
125         case ValueBitXor:
126         case ValueBitLShift:
127         case ArithBitLShift: {
128             return power &gt; 31;
129         }
130 
<span class="line-modified">131         case BitRShift:</span>

132         case BitURShift: {
133             if (power &gt; 31)
134                 return true;
135 
136             Node* shiftAmount = node-&gt;child2().node();
137             if (!node-&gt;isNumberConstant())
138                 return false;
139             JSValue immediateValue = shiftAmount-&gt;asJSValue();
140             if (!immediateValue.isInt32())
141                 return false;
142             return immediateValue.asInt32() &gt; 32 - power;
143         }
144 
145         default:
146             return false;
147         }
148     }
149 
150     template&lt;int power&gt;
151     bool isWithinPowerOfTwo(Edge edge)
</pre>
<hr />
<pre>
209         case MovHint:
210         case Check:
211         case CheckVarargs:
212             break;
213 
214         case ValueBitNot:
215         case ArithBitNot: {
216             flags |= NodeBytecodeUsesAsInt;
217             flags &amp;= ~(NodeBytecodeUsesAsNumber | NodeBytecodeNeedsNegZero | NodeBytecodeUsesAsOther);
218             flags &amp;= ~NodeBytecodeUsesAsArrayIndex;
219             node-&gt;child1()-&gt;mergeFlags(flags);
220             break;
221         }
222 
223         case ArithBitAnd:
224         case ArithBitOr:
225         case ArithBitXor:
226         case ValueBitAnd:
227         case ValueBitOr:
228         case ValueBitXor:
<span class="line-removed">229         case BitRShift:</span>
230         case ValueBitLShift:
231         case ArithBitLShift:


232         case BitURShift:
233         case ArithIMul: {
234             flags |= NodeBytecodeUsesAsInt;
235             flags &amp;= ~(NodeBytecodeUsesAsNumber | NodeBytecodeNeedsNegZero | NodeBytecodeUsesAsOther);
236             flags &amp;= ~NodeBytecodeUsesAsArrayIndex;
237             node-&gt;child1()-&gt;mergeFlags(flags);
238             node-&gt;child2()-&gt;mergeFlags(flags);
239             break;
240         }
241 
<span class="line-modified">242         case StringCharCodeAt: {</span>


243             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsValue);
244             node-&gt;child2()-&gt;mergeFlags(NodeBytecodeUsesAsValue | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
245             break;
246         }
247 
248         case StringSlice: {
249             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsValue);
250             node-&gt;child2()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
251             if (node-&gt;child3())
252                 node-&gt;child3()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
253             break;
254         }
255 
256         case ArraySlice: {
257             m_graph.varArgChild(node, 0)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
258 
259             if (node-&gt;numChildren() == 2)
260                 m_graph.varArgChild(node, 1)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
261             else if (node-&gt;numChildren() == 3) {
262                 m_graph.varArgChild(node, 1)-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
</pre>
<hr />
<pre>
315             flags &amp;= ~NodeBytecodeUsesAsOther;
316             if (isNotNegZero(node-&gt;child1().node()) || isNotPosZero(node-&gt;child2().node()))
317                 flags &amp;= ~NodeBytecodeNeedsNegZero;
318             if (!isWithinPowerOfTwo&lt;32&gt;(node-&gt;child1()) &amp;&amp; !isWithinPowerOfTwo&lt;32&gt;(node-&gt;child2()))
319                 flags |= NodeBytecodeUsesAsNumber;
320             if (!m_allowNestedOverflowingAdditions)
321                 flags |= NodeBytecodeUsesAsNumber;
322 
323             node-&gt;child1()-&gt;mergeFlags(flags);
324             node-&gt;child2()-&gt;mergeFlags(flags);
325             break;
326         }
327 
328         case ArithNegate: {
329             flags &amp;= ~NodeBytecodeUsesAsOther;
330 
331             node-&gt;child1()-&gt;mergeFlags(flags);
332             break;
333         }
334 













335         case ValueMul:
336         case ArithMul: {
337             // As soon as a multiply happens, we can easily end up in the part
338             // of the double domain where the point at which you do truncation
339             // can change the outcome. So, ArithMul always forces its inputs to
340             // check for overflow. Additionally, it will have to check for overflow
341             // itself unless we can prove that there is no way for the values
342             // produced to cause double rounding.
343 
344             if (!isWithinPowerOfTwo&lt;22&gt;(node-&gt;child1().node())
345                 &amp;&amp; !isWithinPowerOfTwo&lt;22&gt;(node-&gt;child2().node()))
346                 flags |= NodeBytecodeUsesAsNumber;
347 
348             node-&gt;mergeFlags(flags);
349 
350             flags |= NodeBytecodeUsesAsNumber | NodeBytecodeNeedsNegZero;
351             flags &amp;= ~NodeBytecodeUsesAsOther;
352 
353             node-&gt;child1()-&gt;mergeFlags(flags);
354             node-&gt;child2()-&gt;mergeFlags(flags);
</pre>
<hr />
<pre>
373             node-&gt;child1()-&gt;mergeFlags(flags);
374             node-&gt;child2()-&gt;mergeFlags(flags &amp; ~NodeBytecodeNeedsNegZero);
375             break;
376         }
377 
378         case GetByVal: {
379             m_graph.varArgChild(node, 0)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
380             m_graph.varArgChild(node, 1)-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
381             break;
382         }
383 
384         case NewTypedArray:
385         case NewArrayWithSize: {
386             // Negative zero is not observable. NaN versus undefined are only observable
387             // in that you would get a different exception message. So, like, whatever: we
388             // claim here that NaN v. undefined is observable.
389             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsInt | NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsArrayIndex);
390             break;
391         }
392 
<span class="line-removed">393         case StringCharAt: {</span>
<span class="line-removed">394             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsValue);</span>
<span class="line-removed">395             node-&gt;child2()-&gt;mergeFlags(NodeBytecodeUsesAsValue | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);</span>
<span class="line-removed">396             break;</span>
<span class="line-removed">397         }</span>
<span class="line-removed">398 </span>
399         case ToString:
400         case CallStringConstructor: {
401             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther);
402             break;
403         }
404 
405         case ToPrimitive:
<span class="line-modified">406         case ToNumber: {</span>

407             node-&gt;child1()-&gt;mergeFlags(flags);
408             break;
409         }
410 
411         case CompareLess:
412         case CompareLessEq:
413         case CompareGreater:
414         case CompareGreaterEq:
415         case CompareBelow:
416         case CompareBelowEq:
417         case CompareEq:
418         case CompareStrictEq: {
419             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther);
420             node-&gt;child2()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther);
421             break;
422         }
423 
424         case PutByValDirect:
425         case PutByVal: {
426             m_graph.varArgChild(node, 0)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
</pre>
</td>
<td>
<hr />
<pre>
111         }
112 
113         case ValueBitAnd:
114         case ArithBitAnd: {
115             if (power &gt; 31)
116                 return true;
117 
118             return isWithinPowerOfTwoNonRecursive&lt;power&gt;(node-&gt;child1().node())
119                 || isWithinPowerOfTwoNonRecursive&lt;power&gt;(node-&gt;child2().node());
120         }
121 
122         case ArithBitOr:
123         case ArithBitXor:
124         case ValueBitOr:
125         case ValueBitXor:
126         case ValueBitLShift:
127         case ArithBitLShift: {
128             return power &gt; 31;
129         }
130 
<span class="line-modified">131         case ArithBitRShift:</span>
<span class="line-added">132         case ValueBitRShift:</span>
133         case BitURShift: {
134             if (power &gt; 31)
135                 return true;
136 
137             Node* shiftAmount = node-&gt;child2().node();
138             if (!node-&gt;isNumberConstant())
139                 return false;
140             JSValue immediateValue = shiftAmount-&gt;asJSValue();
141             if (!immediateValue.isInt32())
142                 return false;
143             return immediateValue.asInt32() &gt; 32 - power;
144         }
145 
146         default:
147             return false;
148         }
149     }
150 
151     template&lt;int power&gt;
152     bool isWithinPowerOfTwo(Edge edge)
</pre>
<hr />
<pre>
210         case MovHint:
211         case Check:
212         case CheckVarargs:
213             break;
214 
215         case ValueBitNot:
216         case ArithBitNot: {
217             flags |= NodeBytecodeUsesAsInt;
218             flags &amp;= ~(NodeBytecodeUsesAsNumber | NodeBytecodeNeedsNegZero | NodeBytecodeUsesAsOther);
219             flags &amp;= ~NodeBytecodeUsesAsArrayIndex;
220             node-&gt;child1()-&gt;mergeFlags(flags);
221             break;
222         }
223 
224         case ArithBitAnd:
225         case ArithBitOr:
226         case ArithBitXor:
227         case ValueBitAnd:
228         case ValueBitOr:
229         case ValueBitXor:

230         case ValueBitLShift:
231         case ArithBitLShift:
<span class="line-added">232         case ArithBitRShift:</span>
<span class="line-added">233         case ValueBitRShift:</span>
234         case BitURShift:
235         case ArithIMul: {
236             flags |= NodeBytecodeUsesAsInt;
237             flags &amp;= ~(NodeBytecodeUsesAsNumber | NodeBytecodeNeedsNegZero | NodeBytecodeUsesAsOther);
238             flags &amp;= ~NodeBytecodeUsesAsArrayIndex;
239             node-&gt;child1()-&gt;mergeFlags(flags);
240             node-&gt;child2()-&gt;mergeFlags(flags);
241             break;
242         }
243 
<span class="line-modified">244         case StringCharAt:</span>
<span class="line-added">245         case StringCharCodeAt:</span>
<span class="line-added">246         case StringCodePointAt: {</span>
247             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsValue);
248             node-&gt;child2()-&gt;mergeFlags(NodeBytecodeUsesAsValue | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
249             break;
250         }
251 
252         case StringSlice: {
253             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsValue);
254             node-&gt;child2()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
255             if (node-&gt;child3())
256                 node-&gt;child3()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
257             break;
258         }
259 
260         case ArraySlice: {
261             m_graph.varArgChild(node, 0)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
262 
263             if (node-&gt;numChildren() == 2)
264                 m_graph.varArgChild(node, 1)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
265             else if (node-&gt;numChildren() == 3) {
266                 m_graph.varArgChild(node, 1)-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
</pre>
<hr />
<pre>
319             flags &amp;= ~NodeBytecodeUsesAsOther;
320             if (isNotNegZero(node-&gt;child1().node()) || isNotPosZero(node-&gt;child2().node()))
321                 flags &amp;= ~NodeBytecodeNeedsNegZero;
322             if (!isWithinPowerOfTwo&lt;32&gt;(node-&gt;child1()) &amp;&amp; !isWithinPowerOfTwo&lt;32&gt;(node-&gt;child2()))
323                 flags |= NodeBytecodeUsesAsNumber;
324             if (!m_allowNestedOverflowingAdditions)
325                 flags |= NodeBytecodeUsesAsNumber;
326 
327             node-&gt;child1()-&gt;mergeFlags(flags);
328             node-&gt;child2()-&gt;mergeFlags(flags);
329             break;
330         }
331 
332         case ArithNegate: {
333             flags &amp;= ~NodeBytecodeUsesAsOther;
334 
335             node-&gt;child1()-&gt;mergeFlags(flags);
336             break;
337         }
338 
<span class="line-added">339         case Inc:</span>
<span class="line-added">340         case Dec: {</span>
<span class="line-added">341             flags &amp;= ~NodeBytecodeNeedsNegZero;</span>
<span class="line-added">342             flags &amp;= ~NodeBytecodeUsesAsOther;</span>
<span class="line-added">343             if (!isWithinPowerOfTwo&lt;32&gt;(node-&gt;child1()))</span>
<span class="line-added">344                 flags |= NodeBytecodeUsesAsNumber;</span>
<span class="line-added">345             if (!m_allowNestedOverflowingAdditions)</span>
<span class="line-added">346                 flags |= NodeBytecodeUsesAsNumber;</span>
<span class="line-added">347 </span>
<span class="line-added">348             node-&gt;child1()-&gt;mergeFlags(flags);</span>
<span class="line-added">349             break;</span>
<span class="line-added">350         }</span>
<span class="line-added">351 </span>
352         case ValueMul:
353         case ArithMul: {
354             // As soon as a multiply happens, we can easily end up in the part
355             // of the double domain where the point at which you do truncation
356             // can change the outcome. So, ArithMul always forces its inputs to
357             // check for overflow. Additionally, it will have to check for overflow
358             // itself unless we can prove that there is no way for the values
359             // produced to cause double rounding.
360 
361             if (!isWithinPowerOfTwo&lt;22&gt;(node-&gt;child1().node())
362                 &amp;&amp; !isWithinPowerOfTwo&lt;22&gt;(node-&gt;child2().node()))
363                 flags |= NodeBytecodeUsesAsNumber;
364 
365             node-&gt;mergeFlags(flags);
366 
367             flags |= NodeBytecodeUsesAsNumber | NodeBytecodeNeedsNegZero;
368             flags &amp;= ~NodeBytecodeUsesAsOther;
369 
370             node-&gt;child1()-&gt;mergeFlags(flags);
371             node-&gt;child2()-&gt;mergeFlags(flags);
</pre>
<hr />
<pre>
390             node-&gt;child1()-&gt;mergeFlags(flags);
391             node-&gt;child2()-&gt;mergeFlags(flags &amp; ~NodeBytecodeNeedsNegZero);
392             break;
393         }
394 
395         case GetByVal: {
396             m_graph.varArgChild(node, 0)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
397             m_graph.varArgChild(node, 1)-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
398             break;
399         }
400 
401         case NewTypedArray:
402         case NewArrayWithSize: {
403             // Negative zero is not observable. NaN versus undefined are only observable
404             // in that you would get a different exception message. So, like, whatever: we
405             // claim here that NaN v. undefined is observable.
406             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsInt | NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsArrayIndex);
407             break;
408         }
409 






410         case ToString:
411         case CallStringConstructor: {
412             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther);
413             break;
414         }
415 
416         case ToPrimitive:
<span class="line-modified">417         case ToNumber:</span>
<span class="line-added">418         case ToNumeric: {</span>
419             node-&gt;child1()-&gt;mergeFlags(flags);
420             break;
421         }
422 
423         case CompareLess:
424         case CompareLessEq:
425         case CompareGreater:
426         case CompareGreaterEq:
427         case CompareBelow:
428         case CompareBelowEq:
429         case CompareEq:
430         case CompareStrictEq: {
431             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther);
432             node-&gt;child2()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther);
433             break;
434         }
435 
436         case PutByValDirect:
437         case PutByVal: {
438             m_graph.varArgChild(node, 0)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
</pre>
</td>
</tr>
</table>
<center><a href="DFGAvailabilityMap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGBasicBlock.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StringPrototype.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,10 ***</span>
<span class="line-new-header">--- 37,11 ---</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSFunction.h&quot;
  #include &quot;JSGlobalObjectFunctions.h&quot;
  #include &quot;JSStringIterator.h&quot;
  #include &quot;Lookup.h&quot;
<span class="line-added">+ #include &quot;ObjectConstructor.h&quot;</span>
  #include &quot;ObjectPrototype.h&quot;
  #include &quot;ParseInt.h&quot;
  #include &quot;PropertyNameArray.h&quot;
  #include &quot;RegExpCache.h&quot;
  #include &quot;RegExpConstructor.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,34 ***</span>
  
  namespace JSC {
  
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(StringPrototype);
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(ExecState*);</span>
  
  }
  
  #include &quot;StringPrototype.lut.h&quot;
  
<span class="line-new-header">--- 60,35 ---</span>
  
  namespace JSC {
  
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(StringPrototype);
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceAllUsingStringSearch(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(JSGlobalObject*, CallFrame*);</span>
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(JSGlobalObject*, CallFrame*);</span>
  
  }
  
  #include &quot;StringPrototype.lut.h&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,32 ***</span>
  
  const ClassInfo StringPrototype::s_info = { &quot;String&quot;, &amp;StringObject::s_info, &amp;stringPrototypeTable, nullptr, CREATE_METHOD_TABLE(StringPrototype) };
  
  /* Source for StringConstructor.lut.h
  @begin stringPrototypeTable
<span class="line-modified">!     concat    JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     match     JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     matchAll  JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     padStart  JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     padEnd    JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     repeat    JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     replace   JSBuiltin    DontEnum|Function 2</span>
<span class="line-modified">!     search    JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     split     JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     anchor    JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     big       JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     bold      JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     blink     JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     fixed     JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     fontcolor JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     fontsize  JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     italics   JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     link      JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     small     JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     strike    JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     sub       JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     sup       JSBuiltin    DontEnum|Function 0</span>
  @end
  */
  
  // ECMA 15.5.4
  StringPrototype::StringPrototype(VM&amp; vm, Structure* structure)
<span class="line-new-header">--- 96,33 ---</span>
  
  const ClassInfo StringPrototype::s_info = { &quot;String&quot;, &amp;StringObject::s_info, &amp;stringPrototypeTable, nullptr, CREATE_METHOD_TABLE(StringPrototype) };
  
  /* Source for StringConstructor.lut.h
  @begin stringPrototypeTable
<span class="line-modified">!     concat        JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     match         JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     matchAll      JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     padStart      JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     padEnd        JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     repeat        JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     replace       JSBuiltin    DontEnum|Function 2</span>
<span class="line-modified">!     replaceAll    JSBuiltin    DontEnum|Function 2</span>
<span class="line-modified">!     search        JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     split         JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     anchor        JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     big           JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     bold          JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     blink         JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     fixed         JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     fontcolor     JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     fontsize      JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     italics       JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     link          JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified">!     small         JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     strike        JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified">!     sub           JSBuiltin    DontEnum|Function 0</span>
<span class="line-added">+     sup           JSBuiltin    DontEnum|Function 0</span>
  @end
  */
  
  // ECMA 15.5.4
  StringPrototype::StringPrototype(VM&amp; vm, Structure* structure)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,15 ***</span>
  
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toString, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;valueOf, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charAt&quot;, stringProtoFuncCharAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharAtIntrinsic);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charCodeAt&quot;, stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
<span class="line-modified">!     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;codePointAt&quot;, stringProtoFuncCodePointAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);</span>
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, stringProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, stringProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingRegExpPrivateName(), stringProtoFuncReplaceUsingRegExp, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeReplaceRegExpIntrinsic);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingStringSearchPrivateName(), stringProtoFuncReplaceUsingStringSearch, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;slice&quot;, stringProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeSliceIntrinsic);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substr&quot;, stringProtoFuncSubstr, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substring&quot;, stringProtoFuncSubstring, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;toLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeToLowerCaseIntrinsic);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
<span class="line-new-header">--- 137,16 ---</span>
  
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toString, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;valueOf, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charAt&quot;, stringProtoFuncCharAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharAtIntrinsic);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charCodeAt&quot;, stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
<span class="line-modified">!     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;codePointAt&quot;, stringProtoFuncCodePointAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, StringPrototypeCodePointAtIntrinsic);</span>
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, stringProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, stringProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingRegExpPrivateName(), stringProtoFuncReplaceUsingRegExp, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeReplaceRegExpIntrinsic);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingStringSearchPrivateName(), stringProtoFuncReplaceUsingStringSearch, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
<span class="line-added">+     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceAllUsingStringSearchPrivateName(), stringProtoFuncReplaceAllUsingStringSearch, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);</span>
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;slice&quot;, stringProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeSliceIntrinsic);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substr&quot;, stringProtoFuncSubstr, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substring&quot;, stringProtoFuncSubstring, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;toLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeToLowerCaseIntrinsic);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,35 ***</span>
          } else if (ref == &#39;\&#39;&#39;) {
              backrefStart = ovector[1];
              backrefLength = source.length() - backrefStart;
          } else if (reg &amp;&amp; ref == &#39;&lt;&#39;) {
              // Named back reference
<span class="line-modified">!             if (!hasNamedCaptures) {</span>
<span class="line-removed">-                 result.append(replacement.substring(i, 2));</span>
<span class="line-removed">-                 offset = i + 2;</span>
<span class="line-removed">-                 advance = 1;</span>
                  continue;
<span class="line-removed">-             }</span>
  
              size_t closingBracket = replacement.find(&#39;&gt;&#39;, i + 2);
<span class="line-modified">!             if (closingBracket == WTF::notFound) {</span>
<span class="line-removed">-                 // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176434</span>
<span class="line-removed">-                 // Current proposed spec change throws a syntax error in this case.</span>
<span class="line-removed">-                 // We have made the case that it makes more sense to treat this a literal</span>
<span class="line-removed">-                 // If throwSyntaxError(exec, scope, &quot;Missing closing &#39;&gt;&#39; in replacement text&quot;);</span>
                  continue;
<span class="line-removed">-             }</span>
  
              unsigned nameLength = closingBracket - i - 2;
              unsigned backrefIndex = reg-&gt;subpatternForName(replacement.substring(i + 2, nameLength).toString());
  
              if (!backrefIndex || backrefIndex &gt; reg-&gt;numSubpatterns()) {
<span class="line-removed">-                 // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176434</span>
<span class="line-removed">-                 // Proposed spec change throws a throw syntax error in this case.</span>
<span class="line-removed">-                 // We have made the case that a non-existent back reference should be replaced with</span>
<span class="line-removed">-                 // and empty string.</span>
<span class="line-removed">-                 // throwSyntaxError(exec, scope, makeString(&quot;Replacement text references non-existent backreference \&quot;&quot; + replacement.substring(i + 2, nameLength).toString()));</span>
                  backrefStart = 0;
                  backrefLength = 0;
              } else {
                  backrefStart = ovector[2 * backrefIndex];
                  backrefLength = ovector[2 * backrefIndex + 1] - backrefStart;
<span class="line-new-header">--- 218,21 ---</span>
          } else if (ref == &#39;\&#39;&#39;) {
              backrefStart = ovector[1];
              backrefLength = source.length() - backrefStart;
          } else if (reg &amp;&amp; ref == &#39;&lt;&#39;) {
              // Named back reference
<span class="line-modified">!             if (!hasNamedCaptures)</span>
                  continue;
  
              size_t closingBracket = replacement.find(&#39;&gt;&#39;, i + 2);
<span class="line-modified">!             if (closingBracket == WTF::notFound)</span>
                  continue;
  
              unsigned nameLength = closingBracket - i - 2;
              unsigned backrefIndex = reg-&gt;subpatternForName(replacement.substring(i + 2, nameLength).toString());
  
              if (!backrefIndex || backrefIndex &gt; reg-&gt;numSubpatterns()) {
                  backrefStart = 0;
                  backrefLength = 0;
              } else {
                  backrefStart = ovector[2 * backrefIndex];
                  backrefLength = ovector[2 * backrefIndex + 1] - backrefStart;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 309,13 ***</span>
  
      int position;
      int length;
  };
  
<span class="line-modified">! static ALWAYS_INLINE JSString* jsSpliceSubstrings(ExecState* exec, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (rangeCount == 1) {
          int sourceSize = source.length();
          int position = substringRanges[0].position;
<span class="line-new-header">--- 299,13 ---</span>
  
      int position;
      int length;
  };
  
<span class="line-modified">! static ALWAYS_INLINE JSString* jsSpliceSubstrings(JSGlobalObject* globalObject, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (rangeCount == 1) {
          int sourceSize = source.length();
          int position = substringRanges[0].position;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,11 ***</span>
      if (source.is8Bit()) {
          LChar* buffer;
          const LChar* sourceData = source.characters8();
          auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
          if (!impl) {
<span class="line-modified">!             throwOutOfMemoryError(exec, scope);</span>
              return nullptr;
          }
  
          Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
          for (int i = 0; i &lt; rangeCount; i++) {
<span class="line-new-header">--- 331,11 ---</span>
      if (source.is8Bit()) {
          LChar* buffer;
          const LChar* sourceData = source.characters8();
          auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
          if (!impl) {
<span class="line-modified">!             throwOutOfMemoryError(globalObject, scope);</span>
              return nullptr;
          }
  
          Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
          for (int i = 0; i &lt; rangeCount; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,11 ***</span>
      UChar* buffer;
      const UChar* sourceData = source.characters16();
  
      auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
      if (!impl) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
  
      Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
      for (int i = 0; i &lt; rangeCount; i++) {
<span class="line-new-header">--- 351,11 ---</span>
      UChar* buffer;
      const UChar* sourceData = source.characters16();
  
      auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
      if (!impl) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
      for (int i = 0; i &lt; rangeCount; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 376,13 ***</span>
      }
  
      RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
  }
  
<span class="line-modified">! static ALWAYS_INLINE JSString* jsSpliceSubstringsWithSeparators(ExecState* exec, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount, const String* separators, int separatorCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (rangeCount == 1 &amp;&amp; separatorCount == 0) {
          int sourceSize = source.length();
          int position = substringRanges[0].position;
<span class="line-new-header">--- 366,13 ---</span>
      }
  
      RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
  }
  
<span class="line-modified">! static ALWAYS_INLINE JSString* jsSpliceSubstringsWithSeparators(JSGlobalObject* globalObject, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount, const String* separators, int separatorCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (rangeCount == 1 &amp;&amp; separatorCount == 0) {
          int sourceSize = source.length();
          int position = substringRanges[0].position;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 391,21 ***</span>
              return sourceVal;
          // We could call String::substringSharingImpl(), but this would result in redundant checks.
          RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
      }
  
      Checked&lt;int, RecordOverflow&gt; totalLength = 0;
      bool allSeparators8Bit = true;
      for (int i = 0; i &lt; rangeCount; i++)
          totalLength += substringRanges[i].length;
      for (int i = 0; i &lt; separatorCount; i++) {
          totalLength += separators[i].length();
          if (separators[i].length() &amp;&amp; !separators[i].is8Bit())
              allSeparators8Bit = false;
      }
      if (totalLength.hasOverflowed()) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
  
      if (!totalLength)
          return jsEmptyString(vm);
<span class="line-new-header">--- 381,27 ---</span>
              return sourceVal;
          // We could call String::substringSharingImpl(), but this would result in redundant checks.
          RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
      }
  
<span class="line-added">+     if (rangeCount == 2 &amp;&amp; separatorCount == 1) {</span>
<span class="line-added">+         String leftPart(StringImpl::createSubstringSharingImpl(*source.impl(), substringRanges[0].position, substringRanges[0].length));</span>
<span class="line-added">+         String rightPart(StringImpl::createSubstringSharingImpl(*source.impl(), substringRanges[1].position, substringRanges[1].length));</span>
<span class="line-added">+         RELEASE_AND_RETURN(scope, jsString(globalObject, leftPart, separators[0], rightPart));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      Checked&lt;int, RecordOverflow&gt; totalLength = 0;
      bool allSeparators8Bit = true;
      for (int i = 0; i &lt; rangeCount; i++)
          totalLength += substringRanges[i].length;
      for (int i = 0; i &lt; separatorCount; i++) {
          totalLength += separators[i].length();
          if (separators[i].length() &amp;&amp; !separators[i].is8Bit())
              allSeparators8Bit = false;
      }
      if (totalLength.hasOverflowed()) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      if (!totalLength)
          return jsEmptyString(vm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 414,11 ***</span>
          LChar* buffer;
          const LChar* sourceData = source.characters8();
  
          auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
          if (!impl) {
<span class="line-modified">!             throwOutOfMemoryError(exec, scope);</span>
              return nullptr;
          }
  
          int maxCount = std::max(rangeCount, separatorCount);
          Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
<span class="line-new-header">--- 410,11 ---</span>
          LChar* buffer;
          const LChar* sourceData = source.characters8();
  
          auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
          if (!impl) {
<span class="line-modified">!             throwOutOfMemoryError(globalObject, scope);</span>
              return nullptr;
          }
  
          int maxCount = std::max(rangeCount, separatorCount);
          Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 441,11 ***</span>
      }
  
      UChar* buffer;
      auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
      if (!impl) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
  
      int maxCount = std::max(rangeCount, separatorCount);
      Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
<span class="line-new-header">--- 437,11 ---</span>
      }
  
      UChar* buffer;
      auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
      if (!impl) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      int maxCount = std::max(rangeCount, separatorCount);
      Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 477,31 ***</span>
      do { \
          throwOutOfMemoryError(exec__, scope__); \
          return nullptr; \
      } while (false)
  
<span class="line-modified">! static ALWAYS_INLINE JSString* removeUsingRegExpSearch(VM&amp; vm, ExecState* exec, JSString* string, const String&amp; source, RegExp* regExp)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      SuperSamplerScope superSamplerScope(false);
  
      size_t lastIndex = 0;
      unsigned startPosition = 0;
  
      Vector&lt;StringRange, 16&gt; sourceRanges;
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      unsigned sourceLen = source.length();
  
      while (true) {
          MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition);
          RETURN_IF_EXCEPTION(scope, nullptr);
          if (!result)
              break;
  
          if (lastIndex &lt; result.start) {
              if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified">!                 OUT_OF_MEMORY(exec, scope);</span>
          }
          lastIndex = result.end;
          startPosition = lastIndex;
  
          // special case of empty match
<span class="line-new-header">--- 473,30 ---</span>
      do { \
          throwOutOfMemoryError(exec__, scope__); \
          return nullptr; \
      } while (false)
  
<span class="line-modified">! static ALWAYS_INLINE JSString* removeUsingRegExpSearch(VM&amp; vm, JSGlobalObject* globalObject, JSString* string, const String&amp; source, RegExp* regExp)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      SuperSamplerScope superSamplerScope(false);
  
      size_t lastIndex = 0;
      unsigned startPosition = 0;
  
      Vector&lt;StringRange, 16&gt; sourceRanges;
      unsigned sourceLen = source.length();
  
      while (true) {
          MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition);
          RETURN_IF_EXCEPTION(scope, nullptr);
          if (!result)
              break;
  
          if (lastIndex &lt; result.start) {
              if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified">!                 OUT_OF_MEMORY(globalObject, scope);</span>
          }
          lastIndex = result.end;
          startPosition = lastIndex;
  
          // special case of empty match
</pre>
<hr />
<pre>
<span class="line-old-header">*** 515,43 ***</span>
      if (!lastIndex)
          return string;
  
      if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
          if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
<span class="line-modified">!             OUT_OF_MEMORY(exec, scope);</span>
      }
<span class="line-modified">!     RELEASE_AND_RETURN(scope, jsSpliceSubstrings(exec, string, source, sourceRanges.data(), sourceRanges.size()));</span>
  }
  
  static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(
<span class="line-modified">!     VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, CallData&amp; callData,</span>
      CallType callType, String&amp; replacementString, JSValue replaceValue)
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String source = string-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      unsigned sourceLen = source.length();
      RETURN_IF_EXCEPTION(scope, nullptr);
      RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(searchValue);
      RegExp* regExp = regExpObject-&gt;regExp();
      bool global = regExp-&gt;global();
      bool hasNamedCaptures = regExp-&gt;hasNamedCaptures();
  
      if (global) {
          // ES5.1 15.5.4.10 step 8.a.
<span class="line-modified">!         regExpObject-&gt;setLastIndex(exec, 0);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
  
          if (callType == CallType::None &amp;&amp; !replacementString.length())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, string, source, regExp));</span>
      }
  
<span class="line-removed">-     // FIXME: This is wrong because we may be called directly from the FTL.</span>
<span class="line-removed">-     // https://bugs.webkit.org/show_bug.cgi?id=154874</span>
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">- </span>
      size_t lastIndex = 0;
      unsigned startPosition = 0;
  
      Vector&lt;StringRange, 16&gt; sourceRanges;
      Vector&lt;String, 16&gt; replacements;
<span class="line-new-header">--- 510,39 ---</span>
      if (!lastIndex)
          return string;
  
      if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
          if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
<span class="line-modified">!             OUT_OF_MEMORY(globalObject, scope);</span>
      }
<span class="line-modified">!     RELEASE_AND_RETURN(scope, jsSpliceSubstrings(globalObject, string, source, sourceRanges.data(), sourceRanges.size()));</span>
  }
  
  static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(
<span class="line-modified">!     VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* string, JSValue searchValue, CallData&amp; callData,</span>
      CallType callType, String&amp; replacementString, JSValue replaceValue)
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String source = string-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      unsigned sourceLen = source.length();
      RETURN_IF_EXCEPTION(scope, nullptr);
      RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(searchValue);
      RegExp* regExp = regExpObject-&gt;regExp();
      bool global = regExp-&gt;global();
      bool hasNamedCaptures = regExp-&gt;hasNamedCaptures();
  
      if (global) {
          // ES5.1 15.5.4.10 step 8.a.
<span class="line-modified">!         regExpObject-&gt;setLastIndex(globalObject, 0);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
  
          if (callType == CallType::None &amp;&amp; !replacementString.length())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, globalObject, string, source, regExp));</span>
      }
  
      size_t lastIndex = 0;
      unsigned startPosition = 0;
  
      Vector&lt;StringRange, 16&gt; sourceRanges;
      Vector&lt;String, 16&gt; replacements;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 561,30 ***</span>
          // regExp-&gt;numSubpatterns() + 1 for pattern args, + 2 for match start and string
          int argCount = regExp-&gt;numSubpatterns() + 1 + 2;
          if (hasNamedCaptures)
              ++argCount;
          JSFunction* func = jsCast&lt;JSFunction*&gt;(replaceValue);
<span class="line-modified">!         CachedCall cachedCall(exec, func, argCount);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
          while (true) {
              int* ovector;
              MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &amp;ovector);
              RETURN_IF_EXCEPTION(scope, nullptr);
              if (!result)
                  break;
  
              if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified">!                 OUT_OF_MEMORY(exec, scope);</span>
  
              cachedCall.clearArguments();
<span class="line-modified">! </span>
<span class="line-removed">-             JSObject* groups = nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (hasNamedCaptures) {</span>
<span class="line-removed">-                 JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">-                 groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject-&gt;objectPrototype(), 0));</span>
<span class="line-removed">-             }</span>
  
              for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
                  int matchStart = ovector[i * 2];
                  int matchLen = ovector[i * 2 + 1] - matchStart;
  
<span class="line-new-header">--- 552,24 ---</span>
          // regExp-&gt;numSubpatterns() + 1 for pattern args, + 2 for match start and string
          int argCount = regExp-&gt;numSubpatterns() + 1 + 2;
          if (hasNamedCaptures)
              ++argCount;
          JSFunction* func = jsCast&lt;JSFunction*&gt;(replaceValue);
<span class="line-modified">!         CachedCall cachedCall(globalObject, callFrame, func, argCount);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
          while (true) {
              int* ovector;
              MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &amp;ovector);
              RETURN_IF_EXCEPTION(scope, nullptr);
              if (!result)
                  break;
  
              if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified">!                 OUT_OF_MEMORY(globalObject, scope);</span>
  
              cachedCall.clearArguments();
<span class="line-modified">!             JSObject* groups = hasNamedCaptures ? constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure()) : nullptr;</span>
  
              for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
                  int matchStart = ovector[i * 2];
                  int matchLen = ovector[i * 2 + 1] - matchStart;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 609,17 ***</span>
              if (hasNamedCaptures)
                  cachedCall.appendArgument(groups);
  
              cachedCall.setThis(jsUndefined());
              if (UNLIKELY(cachedCall.hasOverflowedArguments())) {
<span class="line-modified">!                 throwOutOfMemoryError(exec, scope);</span>
                  return nullptr;
              }
  
              JSValue jsResult = cachedCall.call();
              RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!             replacements.append(jsResult.toWTFString(exec));</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
  
              lastIndex = result.end;
              startPosition = lastIndex;
  
<span class="line-new-header">--- 594,17 ---</span>
              if (hasNamedCaptures)
                  cachedCall.appendArgument(groups);
  
              cachedCall.setThis(jsUndefined());
              if (UNLIKELY(cachedCall.hasOverflowedArguments())) {
<span class="line-modified">!                 throwOutOfMemoryError(globalObject, scope);</span>
                  return nullptr;
              }
  
              JSValue jsResult = cachedCall.call();
              RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!             replacements.append(jsResult.toWTFString(globalObject));</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
  
              lastIndex = result.end;
              startPosition = lastIndex;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 638,19 ***</span>
              if (!result)
                  break;
  
              if (callType != CallType::None) {
                  if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified">!                     OUT_OF_MEMORY(exec, scope);</span>
  
                  MarkedArgumentBuffer args;
<span class="line-modified">!                 JSObject* groups = nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 if (hasNamedCaptures) {</span>
<span class="line-removed">-                     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">-                     groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject-&gt;objectPrototype(), 0));</span>
<span class="line-removed">-                 }</span>
  
                  for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
                      int matchStart = ovector[i * 2];
                      int matchLen = ovector[i * 2 + 1] - matchStart;
  
<span class="line-new-header">--- 623,14 ---</span>
              if (!result)
                  break;
  
              if (callType != CallType::None) {
                  if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified">!                     OUT_OF_MEMORY(globalObject, scope);</span>
  
                  MarkedArgumentBuffer args;
<span class="line-modified">!                 JSObject* groups = hasNamedCaptures ? constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure()) : nullptr;</span>
  
                  for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
                      int matchStart = ovector[i * 2];
                      int matchLen = ovector[i * 2 + 1] - matchStart;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 668,39 ***</span>
                      if (i &amp;&amp; hasNamedCaptures) {
                          String groupName = regExp-&gt;getCaptureGroupName(i);
                          if (!groupName.isEmpty())
                              groups-&gt;putDirect(vm, Identifier::fromString(vm, groupName), patternValue);
                      }
<span class="line-removed">- </span>
                  }
  
                  args.append(jsNumber(result.start));
                  args.append(string);
                  if (hasNamedCaptures)
                      args.append(groups);
                  if (UNLIKELY(args.hasOverflowed())) {
<span class="line-modified">!                     throwOutOfMemoryError(exec, scope);</span>
                      return nullptr;
                  }
  
<span class="line-modified">!                 JSValue replacement = call(exec, replaceValue, callType, callData, jsUndefined(), args);</span>
                  RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!                 String replacementString = replacement.toWTFString(exec);</span>
                  RETURN_IF_EXCEPTION(scope, nullptr);
                  replacements.append(replacementString);
                  RETURN_IF_EXCEPTION(scope, nullptr);
              } else {
                  int replLen = replacementString.length();
                  if (lastIndex &lt; result.start || replLen) {
                      if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified">!                         OUT_OF_MEMORY(exec, scope);</span>
  
                      if (replLen) {
                          StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
                          substituteBackreferences(replacement, replacementString, source, ovector, regExp);
                          if (UNLIKELY(replacement.hasOverflowed()))
<span class="line-modified">!                             OUT_OF_MEMORY(exec, scope);</span>
                          replacements.append(replacement.toString());
                      } else
                          replacements.append(String());
                  }
              }
<span class="line-new-header">--- 648,38 ---</span>
                      if (i &amp;&amp; hasNamedCaptures) {
                          String groupName = regExp-&gt;getCaptureGroupName(i);
                          if (!groupName.isEmpty())
                              groups-&gt;putDirect(vm, Identifier::fromString(vm, groupName), patternValue);
                      }
                  }
  
                  args.append(jsNumber(result.start));
                  args.append(string);
                  if (hasNamedCaptures)
                      args.append(groups);
                  if (UNLIKELY(args.hasOverflowed())) {
<span class="line-modified">!                     throwOutOfMemoryError(globalObject, scope);</span>
                      return nullptr;
                  }
  
<span class="line-modified">!                 JSValue replacement = call(globalObject, replaceValue, callType, callData, jsUndefined(), args);</span>
                  RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!                 String replacementString = replacement.toWTFString(globalObject);</span>
                  RETURN_IF_EXCEPTION(scope, nullptr);
                  replacements.append(replacementString);
                  RETURN_IF_EXCEPTION(scope, nullptr);
              } else {
                  int replLen = replacementString.length();
                  if (lastIndex &lt; result.start || replLen) {
                      if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified">!                         OUT_OF_MEMORY(globalObject, scope);</span>
  
                      if (replLen) {
                          StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
                          substituteBackreferences(replacement, replacementString, source, ovector, regExp);
                          if (UNLIKELY(replacement.hasOverflowed()))
<span class="line-modified">!                             OUT_OF_MEMORY(globalObject, scope);</span>
                          replacements.append(replacement.toString());
                      } else
                          replacements.append(String());
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 720,118 ***</span>
      if (!lastIndex &amp;&amp; replacements.isEmpty())
          return string;
  
      if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
          if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
<span class="line-modified">!             OUT_OF_MEMORY(exec, scope);</span>
      }
<span class="line-modified">!     RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(exec, string, source, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpEmptyStr(</span>
<span class="line-modified">!     ExecState* exec, JSString* thisValue, RegExpObject* searchValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      RegExp* regExp = searchValue-&gt;regExp();
      if (regExp-&gt;global()) {
          // ES5.1 15.5.4.10 step 8.a.
<span class="line-modified">!         searchValue-&gt;setLastIndex(exec, 0);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         String source = thisValue-&gt;value(exec);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, thisValue, source, regExp));</span>
      }
  
      CallData callData;
      String replacementString = emptyString();
      RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
<span class="line-modified">!         vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, JSValue()));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpString(</span>
<span class="line-removed">-     ExecState* exec, JSString* thisValue, RegExpObject* searchValue, JSString* replaceString)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      CallData callData;
<span class="line-modified">!     String replacementString = replaceString-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
<span class="line-modified">!         vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, replaceString));</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      String replacementString;
      CallData callData;
      CallType callType = getCallData(vm, replaceValue, callData);
      if (callType == CallType::None) {
<span class="line-modified">!         replacementString = replaceValue.toWTFString(exec);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
      }
  
      RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
<span class="line-modified">!         vm, exec, string, searchValue, callData, callType, replacementString, replaceValue));</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE JSString* replaceUsingStringSearch(VM&amp; vm, ExecState* exec, JSString* jsString, JSValue searchValue, JSValue replaceValue)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String string = jsString-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     String searchString = searchValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
<span class="line-removed">-     size_t matchStart = string.find(searchString);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (matchStart == notFound)</span>
<span class="line-removed">-         return jsString;</span>
<span class="line-removed">- </span>
      CallData callData;
      CallType callType = getCallData(vm, replaceValue, callData);
<span class="line-modified">!     if (callType != CallType::None) {</span>
<span class="line-modified">!         MarkedArgumentBuffer args;</span>
<span class="line-modified">!         auto* substring = jsSubstring(vm, string, matchStart, searchString.impl()-&gt;length());</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         args.append(substring);</span>
<span class="line-modified">!         args.append(jsNumber(matchStart));</span>
<span class="line-removed">-         args.append(jsString);</span>
<span class="line-removed">-         ASSERT(!args.hasOverflowed());</span>
<span class="line-removed">-         replaceValue = call(exec, replaceValue, callType, callData, jsUndefined(), args);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
      }
  
<span class="line-modified">!     String replaceString = replaceValue.toWTFString(exec);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, nullptr);</span>
  
<span class="line-modified">!     StringImpl* stringImpl = string.impl();</span>
<span class="line-modified">!     String leftPart(StringImpl::createSubstringSharingImpl(*stringImpl, 0, matchStart));</span>
  
<span class="line-modified">!     size_t matchEnd = matchStart + searchString.impl()-&gt;length();</span>
<span class="line-modified">!     int ovector[2] = { static_cast&lt;int&gt;(matchStart),  static_cast&lt;int&gt;(matchEnd)};</span>
<span class="line-removed">-     String middlePart;</span>
<span class="line-removed">-     if (callType != CallType::None)</span>
<span class="line-removed">-         middlePart = replaceString;</span>
<span class="line-removed">-     else {</span>
<span class="line-removed">-         StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);</span>
<span class="line-removed">-         substituteBackreferences(replacement, replaceString, string, ovector, 0);</span>
<span class="line-removed">-         if (UNLIKELY(replacement.hasOverflowed()))</span>
<span class="line-removed">-             OUT_OF_MEMORY(exec, scope);</span>
<span class="line-removed">-         middlePart = replacement.toString();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     size_t leftLength = stringImpl-&gt;length() - matchEnd;</span>
<span class="line-modified">!     String rightPart(StringImpl::createSubstringSharingImpl(*stringImpl, matchEnd, leftLength));</span>
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSC::jsString(exec, leftPart, middlePart, rightPart));</span>
  }
  
  static inline bool checkObjectCoercible(JSValue thisValue)
  {
      if (thisValue.isString())
<span class="line-new-header">--- 699,153 ---</span>
      if (!lastIndex &amp;&amp; replacements.isEmpty())
          return string;
  
      if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
          if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
<span class="line-modified">!             OUT_OF_MEMORY(globalObject, scope);</span>
      }
<span class="line-modified">!     RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(globalObject, string, source, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));</span>
  }
  
<span class="line-modified">! IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-modified">! </span>
<span class="line-added">+ JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpEmptyStr(JSGlobalObject* globalObject, JSString* thisValue, RegExpObject* searchValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      RegExp* regExp = searchValue-&gt;regExp();
      if (regExp-&gt;global()) {
          // ES5.1 15.5.4.10 step 8.a.
<span class="line-modified">!         searchValue-&gt;setLastIndex(globalObject, 0);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         String source = thisValue-&gt;value(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, globalObject, thisValue, source, regExp));</span>
      }
  
      CallData callData;
      String replacementString = emptyString();
      RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
<span class="line-modified">!         vm, globalObject, callFrame, thisValue, searchValue, callData, CallType::None, replacementString, JSValue()));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpString(JSGlobalObject* globalObject, JSString* thisValue, RegExpObject* searchValue, JSString* replaceString)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      CallData callData;
<span class="line-modified">!     String replacementString = replaceString-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
<span class="line-modified">!         vm, globalObject, callFrame, thisValue, searchValue, callData, CallType::None, replacementString, replaceString));</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* string, JSValue searchValue, JSValue replaceValue)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      String replacementString;
      CallData callData;
      CallType callType = getCallData(vm, replaceValue, callData);
      if (callType == CallType::None) {
<span class="line-modified">!         replacementString = replaceValue.toWTFString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
      }
  
      RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
<span class="line-modified">!         vm, globalObject, callFrame, string, searchValue, callData, callType, replacementString, replaceValue));</span>
  }
  
<span class="line-modified">! enum class ReplaceMode : bool { Single, Global };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static ALWAYS_INLINE JSString* replaceUsingStringSearch(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* jsString, JSValue searchValue, JSValue replaceValue, ReplaceMode mode)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String string = jsString-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     String searchString = searchValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      CallData callData;
      CallType callType = getCallData(vm, replaceValue, callData);
<span class="line-modified">!     Optional&lt;CachedCall&gt; cachedCall;</span>
<span class="line-modified">!     String replaceString;</span>
<span class="line-modified">!     if (callType == CallType::None) {</span>
<span class="line-added">+         replaceString = replaceValue.toWTFString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     } else if (callType == CallType::JS) {</span>
<span class="line-modified">!         cachedCall.emplace(globalObject, callFrame, jsCast&lt;JSFunction*&gt;(replaceValue), 3);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-added">+         cachedCall-&gt;setThis(jsUndefined());</span>
      }
  
<span class="line-modified">!     size_t matchStart = string.find(searchString);</span>
<span class="line-modified">!     if (matchStart == notFound)</span>
<span class="line-added">+         return jsString;</span>
  
<span class="line-modified">!     size_t endOfLastMatch = 0;</span>
<span class="line-modified">!     size_t searchStringLength = searchString.length();</span>
<span class="line-added">+     Vector&lt;StringRange, 16&gt; sourceRanges;</span>
<span class="line-added">+     Vector&lt;String, 16&gt; replacements;</span>
<span class="line-added">+     do {</span>
<span class="line-added">+         if (callType != CallType::None) {</span>
<span class="line-added">+             JSValue replacement;</span>
<span class="line-added">+             if (cachedCall) {</span>
<span class="line-added">+                 auto* substring = jsSubstring(vm, string, matchStart, searchStringLength);</span>
<span class="line-added">+                 RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added">+                 cachedCall-&gt;clearArguments();</span>
<span class="line-added">+                 cachedCall-&gt;appendArgument(substring);</span>
<span class="line-added">+                 cachedCall-&gt;appendArgument(jsNumber(matchStart));</span>
<span class="line-added">+                 cachedCall-&gt;appendArgument(jsString);</span>
<span class="line-added">+                 ASSERT(!cachedCall-&gt;hasOverflowedArguments());</span>
<span class="line-added">+                 replacement = cachedCall-&gt;call();</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 MarkedArgumentBuffer args;</span>
<span class="line-added">+                 auto* substring = jsSubstring(vm, string, matchStart, searchString.impl()-&gt;length());</span>
<span class="line-added">+                 RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added">+                 args.append(substring);</span>
<span class="line-added">+                 args.append(jsNumber(matchStart));</span>
<span class="line-added">+                 args.append(jsString);</span>
<span class="line-added">+                 ASSERT(!args.hasOverflowed());</span>
<span class="line-added">+                 replacement = call(globalObject, replaceValue, callType, callData, jsUndefined(), args);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added">+             replaceString = replacement.toWTFString(globalObject);</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(endOfLastMatch, matchStart - endOfLastMatch)))</span>
<span class="line-modified">!             OUT_OF_MEMORY(globalObject, scope);</span>
  
<span class="line-modified">!         size_t matchEnd = matchStart + searchStringLength;</span>
<span class="line-modified">!         if (callType != CallType::None)</span>
<span class="line-modified">!             replacements.append(replaceString);</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);</span>
<span class="line-added">+             int ovector[2] = { static_cast&lt;int&gt;(matchStart),  static_cast&lt;int&gt;(matchEnd) };</span>
<span class="line-added">+             substituteBackreferences(replacement, replaceString, string, ovector, nullptr);</span>
<span class="line-added">+             if (UNLIKELY(replacement.hasOverflowed()))</span>
<span class="line-added">+                 OUT_OF_MEMORY(globalObject, scope);</span>
<span class="line-added">+             replacements.append(replacement.toString());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         endOfLastMatch = matchEnd;</span>
<span class="line-added">+         if (mode == ReplaceMode::Single)</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         matchStart = string.find(searchString, !searchStringLength ? endOfLastMatch + 1 : endOfLastMatch);</span>
<span class="line-added">+     } while (matchStart != notFound);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (UNLIKELY(!sourceRanges.tryConstructAndAppend(endOfLastMatch, string.length() - endOfLastMatch)))</span>
<span class="line-added">+         OUT_OF_MEMORY(globalObject, scope);</span>
<span class="line-added">+     RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(globalObject, jsString, string, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));</span>
  }
  
  static inline bool checkObjectCoercible(JSValue thisValue)
  {
      if (thisValue.isString())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 844,167 ***</span>
          return false;
  
      return true;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncRepeatCharacter(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // For a string which length is single, instead of creating ropes,
      // allocating a sequential buffer and fill with the repeated string for efficiency.
<span class="line-modified">!     ASSERT(exec-&gt;argumentCount() == 2);</span>
  
<span class="line-modified">!     ASSERT(exec-&gt;uncheckedArgument(0).isString());</span>
<span class="line-modified">!     JSString* string = asString(exec-&gt;uncheckedArgument(0));</span>
      ASSERT(string-&gt;length() == 1);
  
<span class="line-modified">!     JSValue repeatCountValue = exec-&gt;uncheckedArgument(1);</span>
      RELEASE_ASSERT(repeatCountValue.isNumber());
      int32_t repeatCount;
      double value = repeatCountValue.asNumber();
      if (value &gt; JSString::MaxLength)
<span class="line-modified">!         return JSValue::encode(throwOutOfMemoryError(exec, scope));</span>
      repeatCount = static_cast&lt;int32_t&gt;(value);
      ASSERT(repeatCount &gt;= 0);
      ASSERT(!repeatCountValue.isDouble() || repeatCountValue.asDouble() == repeatCount);
  
<span class="line-modified">!     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);</span>
      StringView view = viewWithString.view;
      ASSERT(view.length() == 1);
      scope.assertNoException();
      UChar character = view[0];
      scope.release();
      if (isLatin1(character))
<span class="line-modified">!         return JSValue::encode(repeatCharacter(*exec, static_cast&lt;LChar&gt;(character), repeatCount));</span>
<span class="line-modified">!     return JSValue::encode(repeatCharacter(*exec, character, repeatCount));</span>
  }
  
  ALWAYS_INLINE JSString* replace(
<span class="line-modified">!     VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)</span>
  {
      if (searchValue.inherits&lt;RegExpObject&gt;(vm))
<span class="line-modified">!         return replaceUsingRegExpSearch(vm, exec, string, searchValue, replaceValue);</span>
<span class="line-modified">!     return replaceUsingStringSearch(vm, exec, string, searchValue, replaceValue);</span>
  }
  
  ALWAYS_INLINE JSString* replace(
<span class="line-modified">!     VM&amp; vm, ExecState* exec, JSValue thisValue, JSValue searchValue, JSValue replaceValue)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!checkObjectCoercible(thisValue)) {
<span class="line-modified">!         throwVMTypeError(exec, scope);</span>
          return nullptr;
      }
<span class="line-modified">!     JSString* string = thisValue.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, replace(vm, exec, string, searchValue, replaceValue));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSString* string = exec-&gt;thisValue().toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue searchValue = exec-&gt;argument(0);</span>
      if (!searchValue.inherits&lt;RegExpObject&gt;(vm))
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingRegExpSearch(vm, exec, string, searchValue, exec-&gt;argument(1))));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSString* string = exec-&gt;thisValue().toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, exec, string, exec-&gt;argument(0), exec-&gt;argument(1))));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationStringProtoFuncReplaceGeneric(</span>
<span class="line-removed">-     ExecState* exec, EncodedJSValue thisValue, EncodedJSValue searchValue,</span>
<span class="line-removed">-     EncodedJSValue replaceValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return replace(
<span class="line-modified">!         vm, exec, JSValue::decode(thisValue), JSValue::decode(searchValue),</span>
          JSValue::decode(replaceValue));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      // Also used for valueOf.
  
      if (thisValue.isString())
          return JSValue::encode(thisValue);
  
      auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, thisValue);
      if (stringObject)
          return JSValue::encode(stringObject-&gt;internalValue());
  
<span class="line-modified">!     return throwVMTypeError(exec, scope);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">!     auto viewWithString = thisValue.toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      StringView view = viewWithString.view;
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     JSValue a0 = exec-&gt;argument(0);</span>
      if (a0.isUInt32()) {
          uint32_t i = a0.asUInt32();
          if (i &lt; view.length())
              return JSValue::encode(jsSingleCharacterString(vm, view[i]));
          return JSValue::encode(jsEmptyString(vm));
      }
<span class="line-modified">!     double dpos = a0.toInteger(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
          return JSValue::encode(jsSingleCharacterString(vm, view[static_cast&lt;unsigned&gt;(dpos)]));
      return JSValue::encode(jsEmptyString(vm));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">!     auto viewWithString = thisValue.toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      StringView view = viewWithString.view;
<span class="line-modified">!     JSValue a0 = exec-&gt;argument(0);</span>
      if (a0.isUInt32()) {
          uint32_t i = a0.asUInt32();
          if (i &lt; view.length())
              return JSValue::encode(jsNumber(view[i]));
          return JSValue::encode(jsNaN());
      }
<span class="line-modified">!     double dpos = a0.toInteger(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
          return JSValue::encode(jsNumber(view[static_cast&lt;int&gt;(dpos)]));
      return JSValue::encode(jsNaN());
  }
<span class="line-new-header">--- 858,179 ---</span>
          return false;
  
      return true;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncRepeatCharacter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // For a string which length is single, instead of creating ropes,
      // allocating a sequential buffer and fill with the repeated string for efficiency.
<span class="line-modified">!     ASSERT(callFrame-&gt;argumentCount() == 2);</span>
  
<span class="line-modified">!     ASSERT(callFrame-&gt;uncheckedArgument(0).isString());</span>
<span class="line-modified">!     JSString* string = asString(callFrame-&gt;uncheckedArgument(0));</span>
      ASSERT(string-&gt;length() == 1);
  
<span class="line-modified">!     JSValue repeatCountValue = callFrame-&gt;uncheckedArgument(1);</span>
      RELEASE_ASSERT(repeatCountValue.isNumber());
      int32_t repeatCount;
      double value = repeatCountValue.asNumber();
      if (value &gt; JSString::MaxLength)
<span class="line-modified">!         return JSValue::encode(throwOutOfMemoryError(globalObject, scope));</span>
      repeatCount = static_cast&lt;int32_t&gt;(value);
      ASSERT(repeatCount &gt;= 0);
      ASSERT(!repeatCountValue.isDouble() || repeatCountValue.asDouble() == repeatCount);
  
<span class="line-modified">!     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);</span>
      StringView view = viewWithString.view;
      ASSERT(view.length() == 1);
      scope.assertNoException();
      UChar character = view[0];
      scope.release();
      if (isLatin1(character))
<span class="line-modified">!         return JSValue::encode(repeatCharacter(globalObject, static_cast&lt;LChar&gt;(character), repeatCount));</span>
<span class="line-modified">!     return JSValue::encode(repeatCharacter(globalObject, character, repeatCount));</span>
  }
  
  ALWAYS_INLINE JSString* replace(
<span class="line-modified">!     VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* string, JSValue searchValue, JSValue replaceValue)</span>
  {
      if (searchValue.inherits&lt;RegExpObject&gt;(vm))
<span class="line-modified">!         return replaceUsingRegExpSearch(vm, globalObject, callFrame, string, searchValue, replaceValue);</span>
<span class="line-modified">!     return replaceUsingStringSearch(vm, globalObject, callFrame, string, searchValue, replaceValue, ReplaceMode::Single);</span>
  }
  
  ALWAYS_INLINE JSString* replace(
<span class="line-modified">!     VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSValue thisValue, JSValue searchValue, JSValue replaceValue)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!checkObjectCoercible(thisValue)) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope);</span>
          return nullptr;
      }
<span class="line-modified">!     JSString* string = thisValue.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, replace(vm, globalObject, callFrame, string, searchValue, replaceValue));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSString* string = callFrame-&gt;thisValue().toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue searchValue = callFrame-&gt;argument(0);</span>
      if (!searchValue.inherits&lt;RegExpObject&gt;(vm))
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingRegExpSearch(vm, globalObject, callFrame, string, searchValue, callFrame-&gt;argument(1))));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSString* string = callFrame-&gt;thisValue().toString(globalObject);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">+ </span>
<span class="line-added">+     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, globalObject, callFrame, string, callFrame-&gt;argument(0), callFrame-&gt;argument(1), ReplaceMode::Single)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceAllUsingStringSearch(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSString* string = callFrame-&gt;thisValue().toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, globalObject, callFrame, string, callFrame-&gt;argument(0), callFrame-&gt;argument(1), ReplaceMode::Global)));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationStringProtoFuncReplaceGeneric(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue searchValue, EncodedJSValue replaceValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      return replace(
<span class="line-modified">!         vm, globalObject, callFrame, JSValue::decode(thisValue), JSValue::decode(searchValue),</span>
          JSValue::decode(replaceValue));
  }
  
<span class="line-modified">! IGNORE_WARNINGS_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      // Also used for valueOf.
  
      if (thisValue.isString())
          return JSValue::encode(thisValue);
  
      auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, thisValue);
      if (stringObject)
          return JSValue::encode(stringObject-&gt;internalValue());
  
<span class="line-modified">!     return throwVMTypeError(globalObject, scope);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">!     auto viewWithString = thisValue.toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      StringView view = viewWithString.view;
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     JSValue a0 = callFrame-&gt;argument(0);</span>
      if (a0.isUInt32()) {
          uint32_t i = a0.asUInt32();
          if (i &lt; view.length())
              return JSValue::encode(jsSingleCharacterString(vm, view[i]));
          return JSValue::encode(jsEmptyString(vm));
      }
<span class="line-modified">!     double dpos = a0.toInteger(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
          return JSValue::encode(jsSingleCharacterString(vm, view[static_cast&lt;unsigned&gt;(dpos)]));
      return JSValue::encode(jsEmptyString(vm));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">!     auto viewWithString = thisValue.toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      StringView view = viewWithString.view;
<span class="line-modified">!     JSValue a0 = callFrame-&gt;argument(0);</span>
      if (a0.isUInt32()) {
          uint32_t i = a0.asUInt32();
          if (i &lt; view.length())
              return JSValue::encode(jsNumber(view[i]));
          return JSValue::encode(jsNaN());
      }
<span class="line-modified">!     double dpos = a0.toInteger(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
          return JSValue::encode(jsNumber(view[static_cast&lt;int&gt;(dpos)]));
      return JSValue::encode(jsNaN());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1017,65 ***</span>
      UChar32 character;
      U16_NEXT(string.characters16(), position, length, character);
      return character;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
  
<span class="line-modified">!     String string = thisValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      unsigned length = string.length();
  
<span class="line-modified">!     JSValue argument0 = exec-&gt;argument(0);</span>
      if (argument0.isUInt32()) {
          unsigned position = argument0.asUInt32();
          if (position &lt; length)
              return JSValue::encode(jsNumber(codePointAt(string, position, length)));
          return JSValue::encode(jsUndefined());
      }
  
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     double doublePosition = argument0.toInteger(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (doublePosition &gt;= 0 &amp;&amp; doublePosition &lt; length)
          return JSValue::encode(jsNumber(codePointAt(string, static_cast&lt;unsigned&gt;(doublePosition), length)));
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
  
<span class="line-modified">!     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">!     JSValue a1 = exec-&gt;argument(1);</span>
  
<span class="line-modified">!     JSString* thisJSString = thisValue.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     JSString* otherJSString = a0.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      unsigned pos = 0;
      if (!a1.isUndefined()) {
          int len = thisJSString-&gt;length();
          RELEASE_ASSERT(len &gt;= 0);
          if (a1.isUInt32())
              pos = std::min&lt;uint32_t&gt;(a1.asUInt32(), len);
          else {
<span class="line-modified">!             double dpos = a1.toInteger(exec);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              if (dpos &lt; 0)
                  dpos = 0;
              else if (dpos &gt; len)
                  dpos = len;
<span class="line-new-header">--- 1043,65 ---</span>
      UChar32 character;
      U16_NEXT(string.characters16(), position, length, character);
      return character;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
<span class="line-modified">!     String string = thisValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      unsigned length = string.length();
  
<span class="line-modified">!     JSValue argument0 = callFrame-&gt;argument(0);</span>
      if (argument0.isUInt32()) {
          unsigned position = argument0.asUInt32();
          if (position &lt; length)
              return JSValue::encode(jsNumber(codePointAt(string, position, length)));
          return JSValue::encode(jsUndefined());
      }
  
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     double doublePosition = argument0.toInteger(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (doublePosition &gt;= 0 &amp;&amp; doublePosition &lt; length)
          return JSValue::encode(jsNumber(codePointAt(string, static_cast&lt;unsigned&gt;(doublePosition), length)));
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
<span class="line-modified">!     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     JSValue a1 = callFrame-&gt;argument(1);</span>
  
<span class="line-modified">!     JSString* thisJSString = thisValue.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     JSString* otherJSString = a0.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      unsigned pos = 0;
      if (!a1.isUndefined()) {
          int len = thisJSString-&gt;length();
          RELEASE_ASSERT(len &gt;= 0);
          if (a1.isUInt32())
              pos = std::min&lt;uint32_t&gt;(a1.asUInt32(), len);
          else {
<span class="line-modified">!             double dpos = a1.toInteger(globalObject);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              if (dpos &lt; 0)
                  dpos = 0;
              else if (dpos &gt; len)
                  dpos = len;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1084,39 ***</span>
      }
  
      if (thisJSString-&gt;length() &lt; otherJSString-&gt;length() + pos)
          return JSValue::encode(jsNumber(-1));
  
<span class="line-modified">!     auto thisViewWithString = thisJSString-&gt;viewWithUnderlyingString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     auto otherViewWithString = otherJSString-&gt;viewWithUnderlyingString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      size_t result = thisViewWithString.view.find(otherViewWithString.view, pos);
      if (result == notFound)
          return JSValue::encode(jsNumber(-1));
      return JSValue::encode(jsNumber(result));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
  
<span class="line-modified">!     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">!     JSValue a1 = exec-&gt;argument(1);</span>
  
<span class="line-modified">!     JSString* thisJSString = thisValue.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      unsigned len = thisJSString-&gt;length();
<span class="line-modified">!     JSString* otherJSString = a0.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     double dpos = a1.toIntegerPreserveNaN(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      unsigned startPosition;
      if (dpos &lt; 0)
          startPosition = 0;
      else if (!(dpos &lt;= len)) // true for NaN
<span class="line-new-header">--- 1110,39 ---</span>
      }
  
      if (thisJSString-&gt;length() &lt; otherJSString-&gt;length() + pos)
          return JSValue::encode(jsNumber(-1));
  
<span class="line-modified">!     auto thisViewWithString = thisJSString-&gt;viewWithUnderlyingString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     auto otherViewWithString = otherJSString-&gt;viewWithUnderlyingString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      size_t result = thisViewWithString.view.find(otherViewWithString.view, pos);
      if (result == notFound)
          return JSValue::encode(jsNumber(-1));
      return JSValue::encode(jsNumber(result));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
<span class="line-modified">!     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     JSValue a1 = callFrame-&gt;argument(1);</span>
  
<span class="line-modified">!     JSString* thisJSString = thisValue.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      unsigned len = thisJSString-&gt;length();
<span class="line-modified">!     JSString* otherJSString = a0.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     double dpos = a1.toIntegerPreserveNaN(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      unsigned startPosition;
      if (dpos &lt; 0)
          startPosition = 0;
      else if (!(dpos &lt;= len)) // true for NaN
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1125,13 ***</span>
          startPosition = static_cast&lt;unsigned&gt;(dpos);
  
      if (len &lt; otherJSString-&gt;length())
          return JSValue::encode(jsNumber(-1));
  
<span class="line-modified">!     String thisString = thisJSString-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     String otherString = otherJSString-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      size_t result;
      if (!startPosition)
          result = thisString.startsWith(otherString) ? 0 : notFound;
      else
<span class="line-new-header">--- 1151,13 ---</span>
          startPosition = static_cast&lt;unsigned&gt;(dpos);
  
      if (len &lt; otherJSString-&gt;length())
          return JSValue::encode(jsNumber(-1));
  
<span class="line-modified">!     String thisString = thisJSString-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     String otherString = otherJSString-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      size_t result;
      if (!startPosition)
          result = thisString.startsWith(otherString) ? 0 : notFound;
      else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1139,40 ***</span>
      if (result == notFound)
          return JSValue::encode(jsNumber(-1));
      return JSValue::encode(jsNumber(result));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">!     JSString* string = thisValue.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">!     JSValue a1 = exec-&gt;argument(1);</span>
  
      int length = string-&gt;length();
      RELEASE_ASSERT(length &gt;= 0);
  
      // The arg processing is very much like ArrayProtoFunc::Slice
<span class="line-modified">!     double start = a0.toInteger(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     double end = a1.isUndefined() ? length : a1.toInteger(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(stringSlice(exec, vm, string, length, start, end)));</span>
  }
  
  // Return true in case of early return (resultLength got to limitLength).
  template&lt;typename CharacterType&gt;
<span class="line-modified">! static ALWAYS_INLINE bool splitStringByOneCharacterImpl(ExecState* exec, JSArray* result, JSValue originalValue, const String&amp; input, StringImpl* string, UChar separatorCharacter, size_t&amp; position, unsigned&amp; resultLength, unsigned limitLength)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 12. Let q = p.
      size_t matchPosition;
      const CharacterType* characters = string-&gt;characters&lt;CharacterType&gt;();
<span class="line-new-header">--- 1165,40 ---</span>
      if (result == notFound)
          return JSValue::encode(jsNumber(-1));
      return JSValue::encode(jsNumber(result));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">!     JSString* string = thisValue.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     JSValue a1 = callFrame-&gt;argument(1);</span>
  
      int length = string-&gt;length();
      RELEASE_ASSERT(length &gt;= 0);
  
      // The arg processing is very much like ArrayProtoFunc::Slice
<span class="line-modified">!     double start = a0.toInteger(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     double end = a1.isUndefined() ? length : a1.toInteger(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(stringSlice(globalObject, vm, string, length, start, end)));</span>
  }
  
  // Return true in case of early return (resultLength got to limitLength).
  template&lt;typename CharacterType&gt;
<span class="line-modified">! static ALWAYS_INLINE bool splitStringByOneCharacterImpl(JSGlobalObject* globalObject, JSArray* result, JSValue originalValue, const String&amp; input, StringImpl* string, UChar separatorCharacter, size_t&amp; position, unsigned&amp; resultLength, unsigned limitLength)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 12. Let q = p.
      size_t matchPosition;
      const CharacterType* characters = string-&gt;characters&lt;CharacterType&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1183,13 ***</span>
      while ((matchPosition = WTF::find(characters, string-&gt;length(), separatorCharacter, position)) != notFound) {
          // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
          //    through q (exclusive).
          // 2. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA),
          //    Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
<span class="line-modified">!         auto* substring = jsSubstring(exec, originalValue, input, position, matchPosition - position);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         result-&gt;putDirectIndex(exec, resultLength, substring);</span>
          RETURN_IF_EXCEPTION(scope, false);
          // 3. Increment lengthA by 1.
          // 4. If lengthA == lim, return A.
          if (++resultLength == limitLength)
              return true;
<span class="line-new-header">--- 1209,13 ---</span>
      while ((matchPosition = WTF::find(characters, string-&gt;length(), separatorCharacter, position)) != notFound) {
          // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
          //    through q (exclusive).
          // 2. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA),
          //    Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
<span class="line-modified">!         auto* substring = jsSubstring(globalObject, originalValue, input, position, matchPosition - position);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         result-&gt;putDirectIndex(globalObject, resultLength, substring);</span>
          RETURN_IF_EXCEPTION(scope, false);
          // 3. Increment lengthA by 1.
          // 4. If lengthA == lim, return A.
          if (++resultLength == limitLength)
              return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1200,54 ***</span>
      }
      return false;
  }
  
  // ES 21.1.3.17 String.prototype.split(separator, limit)
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSplitFast(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      ASSERT(checkObjectCoercible(thisValue));
  
      // 3. Let S be the result of calling ToString, giving it the this value as its argument.
      // 7. Let s be the number of characters in S.
<span class="line-modified">!     String input = thisValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      ASSERT(!input.isNull());
  
      // 4. Let A be a new array created as if by the expression new Array()
      //    where Array is the standard built-in constructor with that name.
<span class="line-modified">!     JSArray* result = constructEmptyArray(exec, 0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 5. Let lengthA be 0.
      unsigned resultLength = 0;
  
      // 6. If limit is undefined, let lim = 2^32-1; else let lim = ToUint32(limit).
<span class="line-modified">!     JSValue limitValue = exec-&gt;uncheckedArgument(1);</span>
<span class="line-modified">!     unsigned limit = limitValue.isUndefined() ? 0xFFFFFFFFu : limitValue.toUInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 8. Let p = 0.
      size_t position = 0;
  
      // 9. If separator is a RegExp object (its [[Class]] is &quot;RegExp&quot;), let R = separator;
      //    otherwise let R = ToString(separator).
<span class="line-modified">!     JSValue separatorValue = exec-&gt;uncheckedArgument(0);</span>
<span class="line-modified">!     String separator = separatorValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 10. If lim == 0, return A.
      if (!limit)
          return JSValue::encode(result);
  
      // 11. If separator is undefined, then
      if (separatorValue.isUndefined()) {
          // a. Call the [[DefineOwnProperty]] internal method of A with arguments &quot;0&quot;,
          scope.release();
<span class="line-modified">!         result-&gt;putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));</span>
          // b. Return A.
          return JSValue::encode(result);
      }
  
      // 12. If s == 0, then
<span class="line-new-header">--- 1226,54 ---</span>
      }
      return false;
  }
  
  // ES 21.1.3.17 String.prototype.split(separator, limit)
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSplitFast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      ASSERT(checkObjectCoercible(thisValue));
  
      // 3. Let S be the result of calling ToString, giving it the this value as its argument.
      // 7. Let s be the number of characters in S.
<span class="line-modified">!     String input = thisValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      ASSERT(!input.isNull());
  
      // 4. Let A be a new array created as if by the expression new Array()
      //    where Array is the standard built-in constructor with that name.
<span class="line-modified">!     JSArray* result = constructEmptyArray(globalObject, 0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 5. Let lengthA be 0.
      unsigned resultLength = 0;
  
      // 6. If limit is undefined, let lim = 2^32-1; else let lim = ToUint32(limit).
<span class="line-modified">!     JSValue limitValue = callFrame-&gt;uncheckedArgument(1);</span>
<span class="line-modified">!     unsigned limit = limitValue.isUndefined() ? 0xFFFFFFFFu : limitValue.toUInt32(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 8. Let p = 0.
      size_t position = 0;
  
      // 9. If separator is a RegExp object (its [[Class]] is &quot;RegExp&quot;), let R = separator;
      //    otherwise let R = ToString(separator).
<span class="line-modified">!     JSValue separatorValue = callFrame-&gt;uncheckedArgument(0);</span>
<span class="line-modified">!     String separator = separatorValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 10. If lim == 0, return A.
      if (!limit)
          return JSValue::encode(result);
  
      // 11. If separator is undefined, then
      if (separatorValue.isUndefined()) {
          // a. Call the [[DefineOwnProperty]] internal method of A with arguments &quot;0&quot;,
          scope.release();
<span class="line-modified">!         result-&gt;putDirectIndex(globalObject, 0, jsStringWithReuse(globalObject, thisValue, input));</span>
          // b. Return A.
          return JSValue::encode(result);
      }
  
      // 12. If s == 0, then
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1256,11 ***</span>
          // b. If z is not false, return A.
          // c. Call CreateDataProperty(A, &quot;0&quot;, S).
          // d. Return A.
          if (!separator.isEmpty()) {
              scope.release();
<span class="line-modified">!             result-&gt;putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));</span>
          }
          return JSValue::encode(result);
      }
  
      // Optimized case for splitting on the empty string.
<span class="line-new-header">--- 1282,11 ---</span>
          // b. If z is not false, return A.
          // c. Call CreateDataProperty(A, &quot;0&quot;, S).
          // d. Return A.
          if (!separator.isEmpty()) {
              scope.release();
<span class="line-modified">!             result-&gt;putDirectIndex(globalObject, 0, jsStringWithReuse(globalObject, thisValue, input));</span>
          }
          return JSValue::encode(result);
      }
  
      // Optimized case for splitting on the empty string.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1268,11 ***</span>
          limit = std::min(limit, input.length());
          // Zero limt/input length handled in steps 9/11 respectively, above.
          ASSERT(limit);
  
          do {
<span class="line-modified">!             result-&gt;putDirectIndex(exec, position, jsSingleCharacterString(vm, input[position]));</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          } while (++position &lt; limit);
  
          return JSValue::encode(result);
      }
<span class="line-new-header">--- 1294,11 ---</span>
          limit = std::min(limit, input.length());
          // Zero limt/input length handled in steps 9/11 respectively, above.
          ASSERT(limit);
  
          do {
<span class="line-modified">!             result-&gt;putDirectIndex(globalObject, position, jsSingleCharacterString(vm, input[position]));</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          } while (++position &lt; limit);
  
          return JSValue::encode(result);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1291,14 ***</span>
              separatorCharacter = separatorImpl-&gt;characters8()[0];
          else
              separatorCharacter = separatorImpl-&gt;characters16()[0];
  
          if (stringImpl-&gt;is8Bit()) {
<span class="line-modified">!             if (splitStringByOneCharacterImpl&lt;LChar&gt;(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))</span>
                  RELEASE_AND_RETURN(scope, JSValue::encode(result));
          } else {
<span class="line-modified">!             if (splitStringByOneCharacterImpl&lt;UChar&gt;(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))</span>
                  RELEASE_AND_RETURN(scope, JSValue::encode(result));
          }
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      } else {
          // 13. Let q = p.
<span class="line-new-header">--- 1317,14 ---</span>
              separatorCharacter = separatorImpl-&gt;characters8()[0];
          else
              separatorCharacter = separatorImpl-&gt;characters16()[0];
  
          if (stringImpl-&gt;is8Bit()) {
<span class="line-modified">!             if (splitStringByOneCharacterImpl&lt;LChar&gt;(globalObject, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))</span>
                  RELEASE_AND_RETURN(scope, JSValue::encode(result));
          } else {
<span class="line-modified">!             if (splitStringByOneCharacterImpl&lt;UChar&gt;(globalObject, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))</span>
                  RELEASE_AND_RETURN(scope, JSValue::encode(result));
          }
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      } else {
          // 13. Let q = p.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1309,13 ***</span>
          //   c. Else, e is an integer index &lt;= s.
          while ((matchPosition = stringImpl-&gt;find(separatorImpl, position)) != notFound) {
              // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
              //    through q (exclusive).
              // 2. Call CreateDataProperty(A, ToString(lengthA), T).
<span class="line-modified">!             auto* substring = jsSubstring(exec, thisValue, input, position, matchPosition - position);</span>
              RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!             result-&gt;putDirectIndex(exec, resultLength, substring);</span>
              RETURN_IF_EXCEPTION(scope, { });
              // 3. Increment lengthA by 1.
              // 4. If lengthA == lim, return A.
              if (++resultLength == limit)
                  return JSValue::encode(result);
<span class="line-new-header">--- 1335,13 ---</span>
          //   c. Else, e is an integer index &lt;= s.
          while ((matchPosition = stringImpl-&gt;find(separatorImpl, position)) != notFound) {
              // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
              //    through q (exclusive).
              // 2. Call CreateDataProperty(A, ToString(lengthA), T).
<span class="line-modified">!             auto* substring = jsSubstring(globalObject, thisValue, input, position, matchPosition - position);</span>
              RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!             result-&gt;putDirectIndex(globalObject, resultLength, substring);</span>
              RETURN_IF_EXCEPTION(scope, { });
              // 3. Increment lengthA by 1.
              // 4. If lengthA == lim, return A.
              if (++resultLength == limit)
                  return JSValue::encode(result);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1327,45 ***</span>
      }
  
      // 15. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
      //     through s (exclusive).
      // 16. Call CreateDataProperty(A, ToString(lengthA), T).
<span class="line-modified">!     auto* substring = jsSubstring(exec, thisValue, input, position, input.length() - position);</span>
      RETURN_IF_EXCEPTION(scope, { });
      scope.release();
<span class="line-modified">!     result-&gt;putDirectIndex(exec, resultLength++, substring);</span>
  
      // 17. Return A.
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
      unsigned len;
      JSString* jsString = 0;
      String uString;
      if (thisValue.isString()) {
          jsString = asString(thisValue);
          len = jsString-&gt;length();
      } else {
<span class="line-modified">!         uString = thisValue.toWTFString(exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          len = uString.length();
      }
  
<span class="line-modified">!     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">!     JSValue a1 = exec-&gt;argument(1);</span>
  
<span class="line-modified">!     double start = a0.toInteger(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     double length = a1.isUndefined() ? len : a1.toInteger(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (start &gt;= len || length &lt;= 0)
          return JSValue::encode(jsEmptyString(vm));
      if (start &lt; 0) {
          start += len;
<span class="line-new-header">--- 1353,45 ---</span>
      }
  
      // 15. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
      //     through s (exclusive).
      // 16. Call CreateDataProperty(A, ToString(lengthA), T).
<span class="line-modified">!     auto* substring = jsSubstring(globalObject, thisValue, input, position, input.length() - position);</span>
      RETURN_IF_EXCEPTION(scope, { });
      scope.release();
<span class="line-modified">!     result-&gt;putDirectIndex(globalObject, resultLength++, substring);</span>
  
      // 17. Return A.
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue stringProtoFuncSubstrImpl(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
      unsigned len;
      JSString* jsString = 0;
      String uString;
      if (thisValue.isString()) {
          jsString = asString(thisValue);
          len = jsString-&gt;length();
      } else {
<span class="line-modified">!         uString = thisValue.toWTFString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          len = uString.length();
      }
  
<span class="line-modified">!     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     JSValue a1 = callFrame-&gt;argument(1);</span>
  
<span class="line-modified">!     double start = a0.toInteger(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     double length = a1.isUndefined() ? len : a1.toInteger(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (start &gt;= len || length &lt;= 0)
          return JSValue::encode(jsEmptyString(vm));
      if (start &lt; 0) {
          start += len;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1376,56 ***</span>
          length = len - start;
      unsigned substringStart = static_cast&lt;unsigned&gt;(start);
      unsigned substringLength = static_cast&lt;unsigned&gt;(length);
      scope.release();
      if (jsString)
<span class="line-modified">!         return JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength));</span>
      return JSValue::encode(jsSubstring(vm, uString, substringStart, substringLength));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL builtinStringSubstrInternal(ExecState* exec)</span>
  {
      // @substrInternal should not have any observable side effects (e.g. it should not call
      // GetMethod(..., @@toPrimitive) on the thisValue).
  
      // It is ok to use the default stringProtoFuncSubstr as the implementation of
      // @substrInternal because @substrInternal will only be called by builtins, which will
      // guarantee that we only pass it a string thisValue. As a result, stringProtoFuncSubstr
      // will not need to call toString() on the thisValue, and there will be no observable
      // side-effects.
<span class="line-modified">!     ASSERT(exec-&gt;thisValue().isString());</span>
<span class="line-modified">!     return stringProtoFuncSubstr(exec);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
  
<span class="line-modified">!     JSString* jsString = thisValue.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">!     JSValue a1 = exec-&gt;argument(1);</span>
      int len = jsString-&gt;length();
      RELEASE_ASSERT(len &gt;= 0);
  
<span class="line-modified">!     double start = a0.toNumber(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      double end;
      if (!(start &gt;= 0)) // check for negative values or NaN
          start = 0;
      else if (start &gt; len)
          start = len;
      if (a1.isUndefined())
          end = len;
      else {
<span class="line-modified">!         end = a1.toNumber(exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (!(end &gt;= 0)) // check for negative values or NaN
              end = 0;
          else if (end &gt; len)
              end = len;
<span class="line-new-header">--- 1402,61 ---</span>
          length = len - start;
      unsigned substringStart = static_cast&lt;unsigned&gt;(start);
      unsigned substringLength = static_cast&lt;unsigned&gt;(length);
      scope.release();
      if (jsString)
<span class="line-modified">!         return JSValue::encode(jsSubstring(globalObject, jsString, substringStart, substringLength));</span>
      return JSValue::encode(jsSubstring(vm, uString, substringStart, substringLength));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return stringProtoFuncSubstrImpl(globalObject, callFrame);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL builtinStringSubstrInternal(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      // @substrInternal should not have any observable side effects (e.g. it should not call
      // GetMethod(..., @@toPrimitive) on the thisValue).
  
      // It is ok to use the default stringProtoFuncSubstr as the implementation of
      // @substrInternal because @substrInternal will only be called by builtins, which will
      // guarantee that we only pass it a string thisValue. As a result, stringProtoFuncSubstr
      // will not need to call toString() on the thisValue, and there will be no observable
      // side-effects.
<span class="line-modified">!     ASSERT(callFrame-&gt;thisValue().isString());</span>
<span class="line-modified">!     return stringProtoFuncSubstrImpl(globalObject, callFrame);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
<span class="line-modified">!     JSString* jsString = thisValue.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     JSValue a1 = callFrame-&gt;argument(1);</span>
      int len = jsString-&gt;length();
      RELEASE_ASSERT(len &gt;= 0);
  
<span class="line-modified">!     double start = a0.toNumber(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      double end;
      if (!(start &gt;= 0)) // check for negative values or NaN
          start = 0;
      else if (start &gt; len)
          start = len;
      if (a1.isUndefined())
          end = len;
      else {
<span class="line-modified">!         end = a1.toNumber(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (!(end &gt;= 0)) // check for negative values or NaN
              end = 0;
          else if (end &gt; len)
              end = len;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1435,117 ***</span>
          end = start;
          start = temp;
      }
      unsigned substringStart = static_cast&lt;unsigned&gt;(start);
      unsigned substringLength = static_cast&lt;unsigned&gt;(end) - substringStart;
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">!     JSString* sVal = thisValue.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     String s = sVal-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      String lowercasedString = s.convertToLowercaseWithoutLocale();
      if (lowercasedString.impl() == s.impl())
          return JSValue::encode(sVal);
      RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lowercasedString)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">!     JSString* sVal = thisValue.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     String s = sVal-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      String uppercasedString = s.convertToUppercaseWithoutLocale();
      if (uppercasedString.impl() == s.impl())
          return JSValue::encode(sVal);
      RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, uppercasedString)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(ExecState* exec)</span>
  {
      // 13.1.1 String.prototype.localeCompare (that [, locales [, options ]]) (ECMA-402 2.0)
      // http://ecma-international.org/publications/standards/Ecma-402.htm
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. Let O be RequireObjectCoercible(this value).
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;String.prototype.localeCompare requires that |this| not be null or undefined&quot;_s);</span>
  
      // 2. Let S be ToString(O).
      // 3. ReturnIfAbrupt(S).
<span class="line-modified">!     String string = thisValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 4. Let That be ToString(that).
      // 5. ReturnIfAbrupt(That).
<span class="line-modified">!     JSValue thatValue = exec-&gt;argument(0);</span>
<span class="line-modified">!     String that = thatValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
  #if ENABLE(INTL)
<span class="line-modified">!     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-modified">!     JSValue locales = exec-&gt;argument(1);</span>
<span class="line-removed">-     JSValue options = exec-&gt;argument(2);</span>
      IntlCollator* collator = nullptr;
<span class="line-modified">!     if (locales.isUndefined() &amp;&amp; options.isUndefined()) {</span>
<span class="line-modified">!         collator = globalObject-&gt;defaultCollator(exec);</span>
<span class="line-modified">!         RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">-     } else {</span>
          collator = IntlCollator::create(vm, globalObject-&gt;collatorStructure());
<span class="line-modified">!         collator-&gt;initializeCollator(*exec, locales, options);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(collator-&gt;compareStrings(*exec, string, that)));</span>
  #else
      return JSValue::encode(jsNumber(Collator().collate(string, that)));
  #endif
  }
  
  #if ENABLE(INTL)
<span class="line-modified">! static EncodedJSValue toLocaleCase(ExecState* state, int32_t (*convertCase)(UChar*, int32_t, const UChar*, int32_t, const char*, UErrorCode*))</span>
  {
<span class="line-modified">!     VM&amp; vm = state-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. Let O be RequireObjectCoercible(this value).
<span class="line-modified">!     JSValue thisValue = state-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(state, scope);</span>
  
      // 2. Let S be ToString(O).
<span class="line-modified">!     JSString* sVal = thisValue.toString(state);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     const String&amp; s = sVal-&gt;value(state);</span>
  
      // 3. ReturnIfAbrupt(S).
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // Optimization for empty strings.
      if (s.isEmpty())
          return JSValue::encode(sVal);
  
      // 4. Let requestedLocales be CanonicalizeLocaleList(locales).
<span class="line-modified">!     Vector&lt;String&gt; requestedLocales = canonicalizeLocaleList(*state, state-&gt;argument(0));</span>
  
      // 5. ReturnIfAbrupt(requestedLocales).
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 6. Let len be the number of elements in requestedLocales.
<span class="line-new-header">--- 1466,126 ---</span>
          end = start;
          start = temp;
      }
      unsigned substringStart = static_cast&lt;unsigned&gt;(start);
      unsigned substringLength = static_cast&lt;unsigned&gt;(end) - substringStart;
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(jsSubstring(globalObject, jsString, substringStart, substringLength)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">!     JSString* sVal = thisValue.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     String s = sVal-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      String lowercasedString = s.convertToLowercaseWithoutLocale();
      if (lowercasedString.impl() == s.impl())
          return JSValue::encode(sVal);
      RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lowercasedString)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">!     JSString* sVal = thisValue.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     String s = sVal-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      String uppercasedString = s.convertToUppercaseWithoutLocale();
      if (uppercasedString.impl() == s.impl())
          return JSValue::encode(sVal);
      RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, uppercasedString)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      // 13.1.1 String.prototype.localeCompare (that [, locales [, options ]]) (ECMA-402 2.0)
      // http://ecma-international.org/publications/standards/Ecma-402.htm
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. Let O be RequireObjectCoercible(this value).
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;String.prototype.localeCompare requires that |this| not be null or undefined&quot;_s);</span>
  
      // 2. Let S be ToString(O).
      // 3. ReturnIfAbrupt(S).
<span class="line-modified">!     String string = thisValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 4. Let That be ToString(that).
      // 5. ReturnIfAbrupt(That).
<span class="line-modified">!     JSValue thatValue = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     String that = thatValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
  #if ENABLE(INTL)
<span class="line-modified">!     JSValue locales = callFrame-&gt;argument(1);</span>
<span class="line-modified">!     JSValue options = callFrame-&gt;argument(2);</span>
      IntlCollator* collator = nullptr;
<span class="line-modified">!     if (locales.isUndefined() &amp;&amp; options.isUndefined())</span>
<span class="line-modified">!         collator = globalObject-&gt;defaultCollator();</span>
<span class="line-modified">!     else {</span>
          collator = IntlCollator::create(vm, globalObject-&gt;collatorStructure());
<span class="line-modified">!         collator-&gt;initializeCollator(globalObject, locales, options);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(collator-&gt;compareStrings(globalObject, string, that)));</span>
  #else
      return JSValue::encode(jsNumber(Collator().collate(string, that)));
  #endif
  }
  
  #if ENABLE(INTL)
<span class="line-modified">! enum class CaseConversionMode {</span>
<span class="line-added">+     Upper,</span>
<span class="line-added">+     Lower,</span>
<span class="line-added">+ };</span>
<span class="line-added">+ template&lt;CaseConversionMode mode&gt;</span>
<span class="line-added">+ static EncodedJSValue toLocaleCase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-added">+     auto convertCase = [&amp;] (auto&amp;&amp;... args) {</span>
<span class="line-added">+         if (mode == CaseConversionMode::Lower)</span>
<span class="line-added">+             return u_strToLower(std::forward&lt;decltype(args)&gt;(args)...);</span>
<span class="line-added">+         return u_strToUpper(std::forward&lt;decltype(args)&gt;(args)...);</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
      // 1. Let O be RequireObjectCoercible(this value).
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
      // 2. Let S be ToString(O).
<span class="line-modified">!     JSString* sVal = thisValue.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     String s = sVal-&gt;value(globalObject);</span>
  
      // 3. ReturnIfAbrupt(S).
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // Optimization for empty strings.
      if (s.isEmpty())
          return JSValue::encode(sVal);
  
      // 4. Let requestedLocales be CanonicalizeLocaleList(locales).
<span class="line-modified">!     Vector&lt;String&gt; requestedLocales = canonicalizeLocaleList(globalObject, callFrame-&gt;argument(0));</span>
  
      // 5. ReturnIfAbrupt(requestedLocales).
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 6. Let len be the number of elements in requestedLocales.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1553,11 ***</span>
  
      // 7. If len &gt; 0, then
      // a. Let requestedLocale be the first element of requestedLocales.
      // 8. Else
      // a. Let requestedLocale be DefaultLocale().
<span class="line-modified">!     String requestedLocale = len &gt; 0 ? requestedLocales.first() : defaultLocale(*state);</span>
  
      // 9. Let noExtensionsLocale be the String value that is requestedLocale with all Unicode locale extension sequences (6.2.1) removed.
      String noExtensionsLocale = removeUnicodeLocaleExtension(requestedLocale);
  
      // 10. Let availableLocales be a List with the language tags of the languages for which the Unicode character database contains language sensitive case mappings.
<span class="line-new-header">--- 1593,11 ---</span>
  
      // 7. If len &gt; 0, then
      // a. Let requestedLocale be the first element of requestedLocales.
      // 8. Else
      // a. Let requestedLocale be DefaultLocale().
<span class="line-modified">!     String requestedLocale = len &gt; 0 ? requestedLocales.first() : defaultLocale(globalObject);</span>
  
      // 9. Let noExtensionsLocale be the String value that is requestedLocale with all Unicode locale extension sequences (6.2.1) removed.
      String noExtensionsLocale = removeUnicodeLocaleExtension(requestedLocale);
  
      // 10. Let availableLocales be a List with the language tags of the languages for which the Unicode character database contains language sensitive case mappings.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1593,48 ***</span>
          // Converted case needs more space than original. Try again.
          UErrorCode error(U_ZERO_ERROR);
          Vector&lt;UChar&gt; buffer(resultLength);
          convertCase(buffer.data(), resultLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
          if (U_FAILURE(error))
<span class="line-modified">!             return throwVMTypeError(state, scope, u_errorName(error));</span>
          lower = String(buffer.data(), resultLength);
      } else
<span class="line-modified">!         return throwVMTypeError(state, scope, u_errorName(error));</span>
  
      // 18. Return L.
      RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lower)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(ExecState* state)</span>
  {
      // 13.1.2 String.prototype.toLocaleLowerCase ([locales])
      // http://ecma-international.org/publications/standards/Ecma-402.htm
<span class="line-modified">!     return toLocaleCase(state, u_strToLower);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(ExecState* state)</span>
  {
      // 13.1.3 String.prototype.toLocaleUpperCase ([locales])
      // http://ecma-international.org/publications/standards/Ecma-402.htm
      // This function interprets a string value as a sequence of code points, as described in ES2015, 6.1.4. This function behaves in exactly the same way as String.prototype.toLocaleLowerCase, except that characters are mapped to their uppercase equivalents as specified in the Unicode character database.
<span class="line-modified">!     return toLocaleCase(state, u_strToUpper);</span>
  }
  #endif // ENABLE(INTL)
  
  enum {
      TrimStart = 1,
      TrimEnd = 2
  };
  
<span class="line-modified">! static inline JSValue trimString(ExecState* exec, JSValue thisValue, int trimKind)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwTypeError(exec, scope);</span>
<span class="line-modified">!     String str = thisValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      unsigned left = 0;
      if (trimKind &amp; TrimStart) {
          while (left &lt; str.length() &amp;&amp; isStrWhiteSpace(str[left]))
<span class="line-new-header">--- 1633,48 ---</span>
          // Converted case needs more space than original. Try again.
          UErrorCode error(U_ZERO_ERROR);
          Vector&lt;UChar&gt; buffer(resultLength);
          convertCase(buffer.data(), resultLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
          if (U_FAILURE(error))
<span class="line-modified">!             return throwVMTypeError(globalObject, scope, u_errorName(error));</span>
          lower = String(buffer.data(), resultLength);
      } else
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, u_errorName(error));</span>
  
      // 18. Return L.
      RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lower)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      // 13.1.2 String.prototype.toLocaleLowerCase ([locales])
      // http://ecma-international.org/publications/standards/Ecma-402.htm
<span class="line-modified">!     return toLocaleCase&lt;CaseConversionMode::Lower&gt;(globalObject, callFrame);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      // 13.1.3 String.prototype.toLocaleUpperCase ([locales])
      // http://ecma-international.org/publications/standards/Ecma-402.htm
      // This function interprets a string value as a sequence of code points, as described in ES2015, 6.1.4. This function behaves in exactly the same way as String.prototype.toLocaleLowerCase, except that characters are mapped to their uppercase equivalents as specified in the Unicode character database.
<span class="line-modified">!     return toLocaleCase&lt;CaseConversionMode::Upper&gt;(globalObject,callFrame);</span>
  }
  #endif // ENABLE(INTL)
  
  enum {
      TrimStart = 1,
      TrimEnd = 2
  };
  
<span class="line-modified">! static inline JSValue trimString(JSGlobalObject* globalObject, JSValue thisValue, int trimKind)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwTypeError(globalObject, scope);</span>
<span class="line-modified">!     String str = thisValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      unsigned left = 0;
      if (trimKind &amp; TrimStart) {
          while (left &lt; str.length() &amp;&amp; isStrWhiteSpace(str[left]))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1651,26 ***</span>
          return thisValue;
  
      RELEASE_AND_RETURN(scope, jsString(vm, str.substringSharingImpl(left, right - left)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState* exec)</span>
  {
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
<span class="line-modified">!     return JSValue::encode(trimString(exec, thisValue, TrimStart | TrimEnd));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState* exec)</span>
  {
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
<span class="line-modified">!     return JSValue::encode(trimString(exec, thisValue, TrimStart));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState* exec)</span>
  {
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
<span class="line-modified">!     return JSValue::encode(trimString(exec, thisValue, TrimEnd));</span>
  }
  
  static inline unsigned clampAndTruncateToUnsigned(double value, unsigned min, unsigned max)
  {
      if (value &lt; min)
<span class="line-new-header">--- 1691,26 ---</span>
          return thisValue;
  
      RELEASE_AND_RETURN(scope, jsString(vm, str.substringSharingImpl(left, right - left)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
<span class="line-modified">!     return JSValue::encode(trimString(globalObject, thisValue, TrimStart | TrimEnd));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
<span class="line-modified">!     return JSValue::encode(trimString(globalObject, thisValue, TrimStart));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
<span class="line-modified">!     return JSValue::encode(trimString(globalObject, thisValue, TrimEnd));</span>
  }
  
  static inline unsigned clampAndTruncateToUnsigned(double value, unsigned min, unsigned max)
  {
      if (value &lt; min)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1678,151 ***</span>
      if (value &gt; max)
          return max;
      return static_cast&lt;unsigned&gt;(value);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
  
<span class="line-modified">!     String stringToSearchIn = thisValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">!     bool isRegularExpression = isRegExp(vm, exec, a0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (isRegularExpression)
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Argument to String.prototype.startsWith cannot be a RegExp&quot;);</span>
  
<span class="line-modified">!     String searchString = a0.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue positionArg = exec-&gt;argument(1);</span>
      unsigned start = 0;
      if (positionArg.isInt32())
          start = std::max(0, positionArg.asInt32());
      else {
          unsigned length = stringToSearchIn.length();
<span class="line-modified">!         start = clampAndTruncateToUnsigned(positionArg.toInteger(exec), 0, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
      return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixStartingAt(searchString, start)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
  
<span class="line-modified">!     String stringToSearchIn = thisValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">!     bool isRegularExpression = isRegExp(vm, exec, a0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (isRegularExpression)
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Argument to String.prototype.endsWith cannot be a RegExp&quot;);</span>
  
<span class="line-modified">!     String searchString = a0.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      unsigned length = stringToSearchIn.length();
  
<span class="line-modified">!     JSValue endPositionArg = exec-&gt;argument(1);</span>
      unsigned end = length;
      if (endPositionArg.isInt32())
          end = std::max(0, endPositionArg.asInt32());
      else if (!endPositionArg.isUndefined()) {
<span class="line-modified">!         end = clampAndTruncateToUnsigned(endPositionArg.toInteger(exec), 0, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
      return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixEndingAt(searchString, std::min(end, length))));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL stringIncludesImpl(VM&amp; vm, ExecState* exec, String stringToSearchIn, String searchString, JSValue positionArg)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      unsigned start = 0;
      if (positionArg.isInt32())
          start = std::max(0, positionArg.asInt32());
      else {
          unsigned length = stringToSearchIn.length();
<span class="line-modified">!         start = clampAndTruncateToUnsigned(positionArg.toInteger(exec), 0, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
      return JSValue::encode(jsBoolean(stringToSearchIn.find(searchString, start) != notFound));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
  
<span class="line-modified">!     String stringToSearchIn = thisValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">!     bool isRegularExpression = isRegExp(vm, exec, a0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (isRegularExpression)
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Argument to String.prototype.includes cannot be a RegExp&quot;);</span>
  
<span class="line-modified">!     String searchString = a0.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue positionArg = exec-&gt;argument(1);</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, stringIncludesImpl(vm, exec, stringToSearchIn, searchString, positionArg));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL builtinStringIncludesInternal(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      ASSERT(checkObjectCoercible(thisValue));
  
<span class="line-modified">!     String stringToSearchIn = thisValue.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue a0 = exec-&gt;uncheckedArgument(0);</span>
<span class="line-modified">!     String searchString = a0.toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue positionArg = exec-&gt;argument(1);</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, stringIncludesImpl(vm, exec, stringToSearchIn, searchString, positionArg));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">!     JSString* string = thisValue.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     return JSValue::encode(JSStringIterator::create(exec, exec-&gt;jsCallee()-&gt;globalObject(vm)-&gt;stringIteratorStructure(), string));</span>
  }
  
  enum class NormalizationForm { NFC, NFD, NFKC, NFKD };
  
  static constexpr bool normalizationAffects8Bit(NormalizationForm form)
<span class="line-new-header">--- 1718,151 ---</span>
      if (value &gt; max)
          return max;
      return static_cast&lt;unsigned&gt;(value);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
<span class="line-modified">!     String stringToSearchIn = thisValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     bool isRegularExpression = isRegExp(vm, globalObject, a0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (isRegularExpression)
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Argument to String.prototype.startsWith cannot be a RegExp&quot;);</span>
  
<span class="line-modified">!     String searchString = a0.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue positionArg = callFrame-&gt;argument(1);</span>
      unsigned start = 0;
      if (positionArg.isInt32())
          start = std::max(0, positionArg.asInt32());
      else {
          unsigned length = stringToSearchIn.length();
<span class="line-modified">!         start = clampAndTruncateToUnsigned(positionArg.toInteger(globalObject), 0, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
      return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixStartingAt(searchString, start)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
<span class="line-modified">!     String stringToSearchIn = thisValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     bool isRegularExpression = isRegExp(vm, globalObject, a0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (isRegularExpression)
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Argument to String.prototype.endsWith cannot be a RegExp&quot;);</span>
  
<span class="line-modified">!     String searchString = a0.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      unsigned length = stringToSearchIn.length();
  
<span class="line-modified">!     JSValue endPositionArg = callFrame-&gt;argument(1);</span>
      unsigned end = length;
      if (endPositionArg.isInt32())
          end = std::max(0, endPositionArg.asInt32());
      else if (!endPositionArg.isUndefined()) {
<span class="line-modified">!         end = clampAndTruncateToUnsigned(endPositionArg.toInteger(globalObject), 0, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
      return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixEndingAt(searchString, std::min(end, length))));
  }
  
<span class="line-modified">! static EncodedJSValue stringIncludesImpl(JSGlobalObject* globalObject, VM&amp; vm, String stringToSearchIn, String searchString, JSValue positionArg)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      unsigned start = 0;
      if (positionArg.isInt32())
          start = std::max(0, positionArg.asInt32());
      else {
          unsigned length = stringToSearchIn.length();
<span class="line-modified">!         start = clampAndTruncateToUnsigned(positionArg.toInteger(globalObject), 0, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
      return JSValue::encode(jsBoolean(stringToSearchIn.find(searchString, start) != notFound));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
<span class="line-modified">!     String stringToSearchIn = thisValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     bool isRegularExpression = isRegExp(vm, globalObject, a0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (isRegularExpression)
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Argument to String.prototype.includes cannot be a RegExp&quot;);</span>
  
<span class="line-modified">!     String searchString = a0.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue positionArg = callFrame-&gt;argument(1);</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, stringIncludesImpl(globalObject, vm, stringToSearchIn, searchString, positionArg));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL builtinStringIncludesInternal(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      ASSERT(checkObjectCoercible(thisValue));
  
<span class="line-modified">!     String stringToSearchIn = thisValue.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue a0 = callFrame-&gt;uncheckedArgument(0);</span>
<span class="line-modified">!     String searchString = a0.toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue positionArg = callFrame-&gt;argument(1);</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, stringIncludesImpl(globalObject, vm, stringToSearchIn, searchString, positionArg));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">!     JSString* string = thisValue.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     return JSValue::encode(JSStringIterator::create(vm, globalObject-&gt;stringIteratorStructure(), string));</span>
  }
  
  enum class NormalizationForm { NFC, NFD, NFKC, NFKD };
  
  static constexpr bool normalizationAffects8Bit(NormalizationForm form)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1863,16 ***</span>
      ASSERT(normalizer);
      ASSERT(U_SUCCESS(status));
      return normalizer;
  }
  
<span class="line-modified">! static JSValue normalize(ExecState* exec, JSString* string, NormalizationForm form)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      StringView view = viewWithString.view;
      if (view.is8Bit() &amp;&amp; (!normalizationAffects8Bit(form) || charactersAreAllASCII(view.characters8(), view.length())))
          RELEASE_AND_RETURN(scope, string);
<span class="line-new-header">--- 1903,16 ---</span>
      ASSERT(normalizer);
      ASSERT(U_SUCCESS(status));
      return normalizer;
  }
  
<span class="line-modified">! static JSValue normalize(JSGlobalObject* globalObject, JSString* string, NormalizationForm form)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      StringView view = viewWithString.view;
      if (view.is8Bit() &amp;&amp; (!normalizationAffects8Bit(form) || charactersAreAllASCII(view.characters8(), view.length())))
          RELEASE_AND_RETURN(scope, string);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1893,34 ***</span>
      ASSERT(status == U_BUFFER_OVERFLOW_ERROR);
  
      UChar* buffer;
      auto result = StringImpl::tryCreateUninitialized(normalizedStringLength, buffer);
      if (!result)
<span class="line-modified">!         return throwOutOfMemoryError(exec, scope);</span>
  
      status = U_ZERO_ERROR;
      unorm2_normalize(normalizer, characters, view.length(), buffer, normalizedStringLength, &amp;status);
      ASSERT(U_SUCCESS(status));
  
      RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(result)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">!     JSString* string = thisValue.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      auto form = NormalizationForm::NFC;
<span class="line-modified">!     JSValue formValue = exec-&gt;argument(0);</span>
      if (!formValue.isUndefined()) {
<span class="line-modified">!         String formString = formValue.toWTFString(exec);</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          if (formString == &quot;NFC&quot;)
              form = NormalizationForm::NFC;
          else if (formString == &quot;NFD&quot;)
<span class="line-new-header">--- 1933,34 ---</span>
      ASSERT(status == U_BUFFER_OVERFLOW_ERROR);
  
      UChar* buffer;
      auto result = StringImpl::tryCreateUninitialized(normalizedStringLength, buffer);
      if (!result)
<span class="line-modified">!         return throwOutOfMemoryError(globalObject, scope);</span>
  
      status = U_ZERO_ERROR;
      unorm2_normalize(normalizer, characters, view.length(), buffer, normalizedStringLength, &amp;status);
      ASSERT(U_SUCCESS(status));
  
      RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(result)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
      if (!checkObjectCoercible(thisValue))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">!     JSString* string = thisValue.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      auto form = NormalizationForm::NFC;
<span class="line-modified">!     JSValue formValue = callFrame-&gt;argument(0);</span>
      if (!formValue.isUndefined()) {
<span class="line-modified">!         String formString = formValue.toWTFString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          if (formString == &quot;NFC&quot;)
              form = NormalizationForm::NFC;
          else if (formString == &quot;NFD&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1928,12 ***</span>
          else if (formString == &quot;NFKC&quot;)
              form = NormalizationForm::NFKC;
          else if (formString == &quot;NFKD&quot;)
              form = NormalizationForm::NFKD;
          else
<span class="line-modified">!             return throwVMRangeError(exec, scope, &quot;argument does not match any normalization form&quot;_s);</span>
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(normalize(exec, string, form)));</span>
  }
  
  } // namespace JSC
<span class="line-new-header">--- 1968,12 ---</span>
          else if (formString == &quot;NFKC&quot;)
              form = NormalizationForm::NFKC;
          else if (formString == &quot;NFKD&quot;)
              form = NormalizationForm::NFKD;
          else
<span class="line-modified">!             return throwVMRangeError(globalObject, scope, &quot;argument does not match any normalization form&quot;_s);</span>
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(normalize(globalObject, string, form)));</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="StringObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StringPrototype.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>